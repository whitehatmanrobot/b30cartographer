_LOCATION IrpSp
                   )
/*++

Routine Description:

    Converts a TDI SetEventHandler IRP into a call to TdiSetEventHandler.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successful.

Notes:

    This routine does not pend.

--*/

{
    NTSTATUS status;
    PTDI_REQUEST_KERNEL_SET_EVENT event;
    PTCP_CONTEXT tcpContext;

    PAGED_CODE();

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("+TCPSetEventHandler \n")));

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    event = (PTDI_REQUEST_KERNEL_SET_EVENT) & (IrpSp->Parameters);

    IF_TCPDBG(TCP_DEBUG_EVENT_HANDLER) {
        TCPTRACE((
                  "TCPSetEventHandler: irp %lx event %lx handler %lx context %lx\n",
                  Irp,
                  event->EventType,
                  event->EventHandler,
                  event->EventContext
                 ));
    }

    status = TdiSetEvent(
                         tcpContext->Handle.AddressHandle,
                         event->EventType,
                         event->EventHandler,
                         event->EventContext
                         );

    ASSERT(status != TDI_PENDING);

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("-TCPSetEventHandler \n")));

    return (status);

}                                // TCPSetEventHandler


NTSTATUS
TCPQueryInformation(
                    IN PIRP Irp,
                    IN PIO_STACK_LOCATION IrpSp
                    )
/*++

Routine Description:

    Converts a TDI QueryInformation IRP into a call to TdiQueryInformation.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successful.

Notes:

--*/

{
    TDI_REQUEST request;
    TDI_STATUS status = STATUS_SUCCESS;
    PTCP_CONTEXT tcpContext;
    PTDI_REQUEST_KERNEL_QUERY_INFORMATION queryInformation;
    uint isConn = FALSE;
    uint dataSize = 0;

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("+TCPQueryInformation \n")));

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    queryInformation = (PTDI_REQUEST_KERNEL_QUERY_INFORMATION)
        & (IrpSp->Parameters);

    request.RequestNotifyObject = TCPDataRequestComplete;
    request.RequestContext = Irp;

    switch (queryInformation->QueryType) {

    case TDI_QUERY_BROADCAST_ADDRESS:
        ASSERT(PtrToUlong(IrpSp->FileObject->FsContext2) ==
                  TDI_CONTROL_CHANNEL_FILE
                  );
        request.Handle.ControlChannel = tcpContext->Handle.ControlChannel;
        break;

    case TDI_QUERY_PROVIDER_INFO:
//
        // NetBT does this. Reinstate the ASSERT when it is fixed.
        //
        //              ASSERT( ((int) IrpSp->FileObject->FsContext2) ==
        //                      TDI_CONTROL_CHANNEL_FILE
        //                    );
        request.Handle.ControlChannel = tcpContext->Handle.ControlChannel;
        break;

    case TDI_QUERY_ADDRESS_INFO:
        if (PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE) {
            //
            // This is a TCP connection object.
            //
            isConn = TRUE;
            request.Handle.ConnectionContext =
                tcpContext->Handle.ConnectionContext;
        } else {
            //
            // This is an address object
            //
            request.Handle.AddressHandle = tcpContext->Handle.AddressHandle;
        }
        break;

    case TDI_QUERY_CONNECTION_INFO:

        if (PtrToUlong(IrpSp->FileObject->FsContext2) != TDI_CONNECTION_FILE){

            status = STATUS_INVALID_PARAMETER;

        } else {

            isConn = TRUE;
            request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
        }
        break;


    case TDI_QUERY_PROVIDER_STATISTICS:

        request.Handle.ControlChannel = tcpContext->Handle.ControlChannel;
        break;

    case TDI_QUERY_ROUTING_INFO:
        if (PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE) {
            request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
            isConn = TRUE;
        } else if (PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE) {
            request.Handle.AddressHandle = tcpContext->Handle.AddressHandle;
        } else {
            status = STATUS_INVALID_PARAMETER;
        }
        break;

    default:
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    if (NT_SUCCESS(status)) {

        PNDIS_BUFFER pNdisBuffer;

        //
        // This request isn't cancellable, but we put it through
        // the cancel path because it handles some checks for us
        // and tracks the irp.
        //
        status = TCPPrepareIrpForCancel(tcpContext, Irp, NULL);

        if (NT_SUCCESS(status)) {

            dataSize = TCPGetMdlChainByteCount(Irp->MdlAddress);
            status = ConvertMdlToNdisBuffer(Irp, Irp->MdlAddress, &pNdisBuffer);

            if (status == TDI_SUCCESS) {
                status = TdiQueryInformation(
                                             &request,
                                             queryInformation,
                                             pNdisBuffer,
                                             &dataSize,
                                             isConn
                                             );
            }

            if (status != TDI_PENDING) {
                IrpSp->Control &= ~SL_PENDING_RETURNED;
                status = TCPDataRequestComplete(Irp, status, dataSize);
                return (status);
            }

            return (STATUS_PENDING);
        }
        return (status);
    }
    Irp->IoStatus.Status = (NTSTATUS) status;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("-TCPQueryInformation \n")));
    return (status);

}                                // TCPQueryInformation

NTSTATUS
TCPQueryInformationExComplete(
                              void *Context,
                              NTSTATUS Status,
                              unsigned int ByteCount
                              )
/*++

Routine Description:

    Completes a TdiQueryInformationEx request.

Arguments:

    Context   - A pointer to the IRP for this request.
    Status    - The final TDI status of the request.
    ByteCount - Bytes returned in output buffer.

Return Value:

    None.

Notes:

--*/
{
    PTCP_QUERY_CONTEXT queryContext = (PTCP_QUERY_CONTEXT) Context;
    ULONG bytesCopied;

    DEBUGMSG(DBG_TRACE && DBG_TDI,
        (DTEXT("+TCPQueryInformationExComplete(%x, %x, %d)\n"),
        Context, Status, ByteCount));

    if (NT_SUCCESS(Status)) {
        //
        // Copy the returned context to the input buffer.
        //
#if defined(_WIN64)
        if (IoIs32bitProcess(queryContext->Irp)) {
            TdiCopyBufferToMdl(
                &queryContext->QueryInformation.Context,
                0,
                CONTEXT_SIZE,
                queryContext->InputMdl,
                FIELD_OFFSET(TCP_REQUEST_QUERY_INFORMATION_EX32, Context),
                &bytesCopied
                );
        } else {
#endif // _WIN64
        TdiCopyBufferToMdl(
            &(queryContext->QueryInformation.Context),
            0,
            CONTEXT_SIZE,
            queryContext->InputMdl,
            FIELD_OFFSET(TCP_REQUEST_QUERY_INFORMATION_EX, Context),
            &bytesCopied
            );
#if defined(_WIN64)
        }
#endif // _WIN64

        if (bytesCopied != CONTEXT_SIZE) {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            ByteCount = 0;
        }
    }
    //
    // Unlock the user's buffers and free the MDLs describing them.
    //
    MmUnlockPages(queryContext->InputMdl);
    IoFreeMdl(queryContext->InputMdl);
    MmUnlockPages(queryContext->OutputMdl);
    IoFreeMdl(queryContext->OutputMdl);

    //
    // Complete the request
    //
    Status = TCPDataRequestComplete(queryContext->Irp, Status, ByteCount);

    CTEFreeMem(queryContext);

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("-TCPQueryInformationExComplete \n")));
    return Status;
}

NTSTATUS
TCPQueryInformationEx(
                      IN PIRP Irp,
                      IN PIO_STACK_LOCATION IrpSp
                      )
/*++

Routine Description:

    Converts a TDI QueryInformationEx IRP into a call to TdiQueryInformationEx.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successful.

Notes:

--*/

{
    TDI_REQUEST request;
    TDI_STATUS status = STATUS_SUCCESS;
    PTCP_CONTEXT tcpContext;
    uint size;
    PTCP_REQUEST_QUERY_INFORMATION_EX InputBuffer;
    PVOID OutputBuffer;
    PMDL inputMdl = NULL;
    PMDL outputMdl = NULL;
    ULONG InputBufferLength, OutputBufferLength;
    PTCP_QUERY_CONTEXT queryContext;
    BOOLEAN inputLocked = FALSE;
    BOOLEAN outputLocked = FALSE;
#if defined(_WIN64)
    BOOLEAN is32bitProcess = FALSE;
#endif // _WIN64
    BOOLEAN inputBufferValid = FALSE;
    ULONG AllocSize = 0;


    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("+TCPQueryInformationEx \n")));

    IF_TCPDBG(TCP_DEBUG_INFO) {
        TCPTRACE((
                  "QueryInformationEx starting - irp %lx fileobj %lx\n",
                  Irp,
                  IrpSp->FileObject
                 ));
    }

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;

    switch (PtrToUlong(IrpSp->FileObject->FsContext2)) {

    case TDI_TRANSPORT_ADDRESS_FILE:
        request.Handle.AddressHandle = tcpContext->Handle.AddressHandle;
        break;

    case TDI_CONNECTION_FILE:
        request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
        break;

    case TDI_CONTROL_CHANNEL_FILE:
        request.Handle.ControlChannel = tcpContext->Handle.ControlChannel;
        break;

    default:
        ASSERT(0);

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        return (STATUS_INVALID_PARAMETER);
    }

    InputBufferLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
    OutputBufferLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    //
    // Validate the input parameters
    //
#if defined(_WIN64)
    if ((is32bitProcess = IoIs32bitProcess(Irp)) != 0) {
        if (InputBufferLength >= sizeof(TCP_REQUEST_QUERY_INFORMATION_EX32) &&
            InputBufferLength < MAXLONG) {
            inputBufferValid = TRUE;
            AllocSize =
                FIELD_OFFSET(TCP_QUERY_CONTEXT, QueryInformation.Context) +
                InputBufferLength -
                FIELD_OFFSET(TCP_REQUEST_QUERY_INFORMATION_EX32, Context);
        } else {
            inputBufferValid = FALSE;
        }
    } else {
#endif // _WIN64
    if (InputBufferLength >= sizeof(TCP_REQUEST_QUERY_INFORMATION_EX) &&
        InputBufferLength < MAXLONG) {
        inputBufferValid = TRUE;
        AllocSize =
            FIELD_OFFSET(TCP_QUERY_CONTEXT, QueryInformation) +
            InputBufferLength;
    } else {
        inputBufferValid = FALSE;
    }
#if defined(_WIN64)
    }
#endif // _WIN64
    if (inputBufferValid && OutputBufferLength != 0) {

        OutputBuffer = Irp->UserBuffer;
        InputBuffer =
            (PTCP_REQUEST_QUERY_INFORMATION_EX)
                IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

        queryContext = CTEAllocMem(AllocSize);

        if (queryContext != NULL) {
            status = TCPPrepareIrpForCancel(tcpContext, Irp, NULL);

            if (!NT_SUCCESS(status)) {
                CTEFreeMem(queryContext);
                return (status);
            }
            //
            // Allocate Mdls to describe the input and output buffers.
            // Probe and lock the buffers.
            //
            try {
                inputMdl = IoAllocateMdl(
                                         InputBuffer,
                                         InputBufferLength,
                                         FALSE,
                                         TRUE,
                                         NULL
                                         );

                outputMdl = IoAllocateMdl(
                                          OutputBuffer,
                                          OutputBufferLength,
                                          FALSE,
                                          TRUE,
                                          NULL
                                          );

                if ((inputMdl != NULL) && (outputMdl != NULL)) {

                    MmProbeAndLockPages(
                                        inputMdl,
                                        Irp->RequestorMode,
                                        IoModifyAccess
                                        );

                    inputLocked = TRUE;

                    MmProbeAndLockPages(
                                        outputMdl,
                                        Irp->RequestorMode,
                                        IoWriteAccess
                                        );

                    outputLocked = TRUE;

                    //
                    // Copy the input parameter to our pool block so
                    // TdiQueryInformationEx can manipulate it directly.
                    //
#if defined(_WIN64)
                    if (is32bitProcess) {
                        RtlCopyMemory(
                            &queryContext->QueryInformation,
                            InputBuffer,
                            FIELD_OFFSET(TCP_REQUEST_QUERY_INFORMATION_EX32, Context)
                            );
                        RtlCopyMemory(
                            &queryContext->QueryInformation.Context,
                            (PUCHAR)InputBuffer +
                            FIELD_OFFSET(TCP_REQUEST_QUERY_INFORMATION_EX32, Context),
                            InputBufferLength -
                            FIELD_OFFSET(TCP_REQUEST_QUERY_INFORMATION_EX32, Context)
                            );
                    } else {
#endif // _WIN64
                    RtlCopyMemory(
                        &queryContext->QueryInformation,
                        InputBuffer,
                        InputBufferLength
                        );
#if defined(_WIN64)
                    }
#endif // _WIN64
                } else {

                    IF_TCPDBG(TCP_DEBUG_INFO) {
                        TCPTRACE(("QueryInfoEx: Couldn't allocate MDL\n"));
                    }

                    IrpSp->Control &= ~SL_PENDING_RETURNED;

                    status = STATUS_INSUFFICIENT_RESOURCES;
                }

            } except(EXCEPTION_EXECUTE_HANDLER) {

                IF_TCPDBG(TCP_DEBUG_INFO) {
                    TCPTRACE((
                              "QueryInfoEx: exception copying input params %lx\n",
                              GetExceptionCode()
                             ));
                }

                status = GetExceptionCode();
            }

            if (NT_SUCCESS(status)) {

                PNDIS_BUFFER OutputNdisBuf;

                //
                // It's finally time to do this thing.
                //
                size = TCPGetMdlChainByteCount(outputMdl);

                queryContext->Irp = Irp;
                queryContext->InputMdl = inputMdl;
                queryContext->OutputMdl = outputMdl;

                request.RequestNotifyObject = TCPQueryInformationExComplete;
                request.RequestContext = queryContext;

                status = ConvertMdlToNdisBuffer(Irp, outputMdl, &OutputNdisBuf);

                if (status == TDI_SUCCESS) {
                    status = TdiQueryInformationEx(
                                                   &request,
                                                   &(queryContext->QueryInformation.ID),
                                                   OutputNdisBuf,
                                                   &size,
                                                   &(queryContext->QueryInformation.Context)
                                                   );
                }

                if (status != TDI_PENDING) {

                    // Since status is not pending, clear the
                    // control flag to keep IO verifier happy.

                    IrpSp->Control &= ~SL_PENDING_RETURNED;

                    status = TCPQueryInformationExComplete(
                                                  queryContext,
                                                  status,
                                                  size
                                                  );
                    return (status);
                }
                IF_TCPDBG(TCP_DEBUG_INFO) {
                    TCPTRACE((
                              "QueryInformationEx - pending irp %lx fileobj %lx\n",
                              Irp,
                              IrpSp->FileObject
                             ));
                }

                return (STATUS_PENDING);
            }
            //
            // If we get here, something failed. Clean up.
            //
            if (inputMdl != NULL) {
                if (inputLocked) {
                    MmUnlockPages(inputMdl);
                }
                IoFreeMdl(inputMdl);
            }
            if (outputMdl != NULL) {
                if (outputLocked) {
                    MmUnlockPages(outputMdl);
                }
                IoFreeMdl(outputMdl);
            }
            CTEFreeMem(queryContext);

            // Since status is not pending, clear the
            // control flag to keep IO verifier happy.

            IrpSp->Control &= ~SL_PENDING_RETURNED;

            // This Irp may be in the process of cancellation
            // get the real status used in irp completion

            status = TCPDataRequestComplete(Irp, status, 0);

            return (status);

        } else {
            IrpSp->Control &= ~SL_PENDING_RETURNED;
            status = STATUS_INSUFFICIENT_RESOURCES;

            IF_TCPDBG(TCP_DEBUG_INFO) {
                TCPTRACE(("QueryInfoEx: Unable to allocate query context\n"));
            }
        }
    } else {
        status = STATUS_INVALID_PARAMETER;

        IF_TCPDBG(TCP_DEBUG_INFO) {
            TCPTRACE((
                      "QueryInfoEx: Bad buffer len, OBufLen %d, InBufLen %d\n",
                      OutputBufferLength, InputBufferLength
                     ));
        }
    }

    IF_TCPDBG(TCP_DEBUG_INFO) {
        TCPTRACE((
                  "QueryInformationEx complete - irp %lx, status %lx\n",
                  Irp,
                  status
                 ));
    }

    Irp->IoStatus.Status = (NTSTATUS) status;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("-TCPQueryInformationEx \n")));

    return (status);
}

NTSTATUS
TCPSetInformationEx(
                    IN PIRP Irp,
                    IN PIO_STACK_LOCATION IrpSp
                    )
/*++

Routine Description:

    Converts a TDI SetInformationEx IRP into a call to TdiSetInformationEx.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successful.

Notes:

    This routine does not pend.

--*/

{
    TDI_REQUEST request;
    TDI_STATUS status;
    PTCP_CONTEXT tcpContext;
    PTCP_REQUEST_SET_INFORMATION_EX setInformation;

    PAGED_CODE();

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("+TCPSetInformationEx \n")));

    IF_TCPDBG(TCP_DEBUG_INFO) {
        TCPTRACE((
                  "SetInformationEx - irp %lx fileobj %lx\n",
                  Irp,
                  IrpSp->FileObject
                 ));
    }

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;
    setInformation = (PTCP_REQUEST_SET_INFORMATION_EX)
        Irp->AssociatedIrp.SystemBuffer;

    if (IrpSp->Parameters.DeviceIoControl.InputBufferLength <
        FIELD_OFFSET(TCP_REQUEST_SET_INFORMATION_EX, Buffer) ||
        IrpSp->Parameters.DeviceIoControl.InputBufferLength -
        FIELD_OFFSET(TCP_REQUEST_SET_INFORMATION_EX, Buffer) < setInformation->BufferSize) {

        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        return (STATUS_INVALID_PARAMETER);
    }
    switch (PtrToUlong(IrpSp->FileObject->FsContext2)) {

    case TDI_TRANSPORT_ADDRESS_FILE:
        request.Handle.AddressHandle = tcpContext->Handle.AddressHandle;
        break;

    case TDI_CONNECTION_FILE:
        request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
        break;

    case TDI_CONTROL_CHANNEL_FILE:
        request.Handle.ControlChannel = tcpContext->Handle.ControlChannel;
        break;

    default:
        ASSERT(0);
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        return (STATUS_INVALID_PARAMETER);
    }

    if (IrpSp->Parameters.DeviceIoControl.IoControlCode  ==
                          IOCTL_TCP_WSH_SET_INFORMATION_EX) {
        uint Entity;

        Entity = setInformation->ID.toi_entity.tei_entity;

        if ((Entity != CO_TL_ENTITY) && (Entity != CL_TL_ENTITY) ) {
            Irp->IoStatus.Status = STATUS_ACCESS_DENIED;
            Irp->IoStatus.Information = 0;
            IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
            return (STATUS_ACCESS_DENIED);
        }

    }

    status = TCPPrepareIrpForCancel(tcpContext, Irp, NULL);

    if (NT_SUCCESS(status)) {
        request.RequestNotifyObject = TCPDataRequestComplete;
        request.RequestContext = Irp;

        status = TdiSetInformationEx(
                                     &request,
                                     &(setInformation->ID),
                                     &(setInformation->Buffer[0]),
                                     setInformation->BufferSize
                                     );

        if (status != TDI_PENDING) {

            DEBUGMSG(status != TDI_SUCCESS && DBG_ERROR && DBG_SETINFO,
                (DTEXT("TCPSetInformationEx: TdiSetInformationEx failure %x\n"),
                status));

            IrpSp->Control &= ~SL_PENDING_RETURNED;

            status = TCPDataRequestComplete(
                                   Irp,
                                   status,
                                   0
                                   );

            return (status);
        }
        IF_TCPDBG(TCP_DEBUG_INFO) {
            TCPTRACE((
                      "SetInformationEx - pending irp %lx fileobj %lx\n",
                      Irp,
                      IrpSp->FileObject
                     ));
        }

        return (STATUS_PENDING);
    }
    IF_TCPDBG(TCP_DEBUG_INFO) {
        TCPTRACE((
                  "SetInformationEx complete - irp %lx\n",
                  Irp
                 ));
    }

    //
    // The irp has already been completed.
    //
    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("-TCPSetInformationEx \n")));

    return (status);
}


NTSTATUS
TCPControlSecurityFilter(
                         IN PIRP Irp,
                         IN PIO_STACK_LOCATION IrpSp
                         )
/*++

Routine Description:

    Processes a request to query or set the status of security filtering.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successful.

Notes:

    This routine does not pend.

--*/

{

    PTCP_SECURITY_FILTER_STATUS request;
    ULONG requestLength;
    ULONG requestCode;
    TDI_STATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

    request = (PTCP_SECURITY_FILTER_STATUS) Irp->AssociatedIrp.SystemBuffer;
    requestCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

    if (requestCode == IOCTL_TCP_QUERY_SECURITY_FILTER_STATUS) {
        requestLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

        if (requestLength < sizeof(TCP_SECURITY_FILTER_STATUS)) {
            status = STATUS_INVALID_PARAMETER;
        } else {
            request->FilteringEnabled = IsSecurityFilteringEnabled();
            Irp->IoStatus.Information = sizeof(TCP_SECURITY_FILTER_STATUS);
        }
    } else {
        ASSERT(requestCode == IOCTL_TCP_SET_SECURITY_FILTER_STATUS);

        requestLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

        if (requestLength < sizeof(TCP_SECURITY_FILTER_STATUS)) {
            status = STATUS_INVALID_PARAMETER;
        } else {
            ControlSecurityFiltering(request->FilteringEnabled);
        }
    }

    Irp->IoStatus.Status = status;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return (status);
}

NTSTATUS
TCPProcessSecurityFilterRequest(
                                IN PIRP Irp,
                                IN PIO_STACK_LOCATION IrpSp
                                )
/*++

Routine Description:

    Processes a request to add or delete a transport security filter.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successful.

Notes:

    This routine does not pend.

--*/

{
    TCPSecurityFilterEntry *request;
    ULONG requestLength;
    ULONG requestCode;
    NTSTATUS status = STATUS_SUCCESS;

    PAGED_CODE();

    Irp->IoStatus.Information = 0;

    request = (TCPSecurityFilterEntry *) Irp->AssociatedIrp.SystemBuffer;
    requestLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
    requestCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;

    if (requestLength < sizeof(TCPSecurityFilterEntry)) {
        status = STATUS_INVALID_PARAMETER;
    } else {
        if (requestCode == IOCTL_TCP_ADD_SECURITY_FILTER) {
            status = AddValueSecurityFilter(
                                            net_long(request->tsf_address),
                                            request->tsf_protocol,
                                            request->tsf_value
                                            );
        } else {
            ASSERT(requestCode == IOCTL_TCP_DELETE_SECURITY_FILTER);
            status = DeleteValueSecurityFilter(
                                               net_long(request->tsf_address),
                                               request->tsf_protocol,
                                               request->tsf_value
                                               );
        }
    }

    Irp->IoStatus.Status = status;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return (status);
}

NTSTATUS
TCPEnumerateSecurityFilter(
                           IN PIRP Irp,
                           IN PIO_STACK_LOCATION IrpSp
                           )
/*++

Routine Description:

    Processes a request to enumerate a transport security filter list.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successful.

Notes:

    This routine does not pend.

--*/

{

    TCPSecurityFilterEntry *request;
    TCPSecurityFilterEnum *response;
    ULONG requestLength, responseLength;
    NTSTATUS status;

    PAGED_CODE();

    request = (TCPSecurityFilterEntry *) Irp->AssociatedIrp.SystemBuffer;
    response = (TCPSecurityFilterEnum *) request;
    requestLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
    responseLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if (requestLength < sizeof(TCPSecurityFilterEntry)) {
        status = STATUS_INVALID_PARAMETER;
        Irp->IoStatus.Information = 0;
    } else if (responseLength < sizeof(TCPSecurityFilterEnum)) {
        status = STATUS_BUFFER_TOO_SMALL;
        Irp->IoStatus.Information = 0;
    } else {
        EnumerateSecurityFilters(
                                 net_long(request->tsf_address),
                                 request->tsf_protocol,
                                 request->tsf_value,
                                 (uchar *) (response + 1),
                                 responseLength - sizeof(TCPSecurityFilterEnum),
                                 &(response->tfe_entries_returned),
                                 &(response->tfe_entries_available)
                                 );

        status = TDI_SUCCESS;
        Irp->IoStatus.Information =
            sizeof(TCPSecurityFilterEnum) +
            (response->tfe_entries_returned * sizeof(TCPSecurityFilterEntry));

    }

    Irp->IoStatus.Status = status;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return (status);
}


NTSTATUS
TCPReservePorts(
                IN PIRP Irp,
                IN PIO_STACK_LOCATION IrpSp
                )
{
    ULONG requestLength;
    ULONG requestCode;
    TDI_STATUS status = STATUS_SUCCESS;
    PTCP_RESERVE_PORT_RANGE request;
    CTELockHandle Handle;

    //PAGED_CODE();

    Irp->IoStatus.Information = 0;

    request = (PTCP_RESERVE_PORT_RANGE) Irp->AssociatedIrp.SystemBuffer;
    requestCode = IrpSp->Parameters.DeviceIoControl.IoControlCode;
    requestLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;

    if (requestLength < sizeof(TCP_RESERVE_PORT_RANGE)) {
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
        return (STATUS_INVALID_PARAMETER);

    }
    if ((request->UpperRange >= request->LowerRange) &&
        (request->LowerRange >= MIN_USER_PORT) &&
        (request->UpperRange <= MaxUserPort)) {

        if (IrpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_TCP_RESERVE_PORT_RANGE) {
            ReservedPortListEntry *ListEntry;

            ListEntry = CTEAllocMem(sizeof(ReservedPortListEntry));

            if (ListEntry) {

                ListEntry->UpperRange = request->UpperRange;
                ListEntry->LowerRange = request->LowerRange;

                CTEGetLock(&AddrObjTableLock.Lock, &Handle);
                ListEntry->next = PortRangeList;
                PortRangeList = ListEntry;
                CTEFreeLock(&AddrObjTableLock.Lock, Handle);
            } else
                status = STATUS_INSUFFICIENT_RESOURCES;

        } else if (PortRangeList) {
            //UNRESERVE


            ReservedPortListEntry *ListEntry, *PrevEntry;

            CTEGetLock(&AddrObjTableLock.Lock, &Handle);

            ListEntry = PortRangeList;
            PrevEntry = ListEntry;


            status = STATUS_INVALID_PARAMETER;
            while (ListEntry) {

                if ((request->LowerRange <= ListEntry->LowerRange) &&
                    (request->UpperRange >= ListEntry->UpperRange)) {
                    //This list should be deleted.

                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Deleting port range %d to %d\n", request->LowerRange, request->UpperRange));

                    if (PrevEntry == PortRangeList) {
                        PortRangeList = ListEntry->next;
                        CTEFreeMem(ListEntry);
                        ListEntry = PortRangeList;
                    } else {
                        PrevEntry->next = ListEntry->next;
                        CTEFreeMem(ListEntry);
                        ListEntry = PrevEntry->next;
                    }
                    status = STATUS_SUCCESS;
                    break;
                } else {
                    PrevEntry = ListEntry;
                    ListEntry = ListEntry->next;
                }

            }
            CTEFreeLock(&AddrObjTableLock.Lock, Handle);

        }
    } else
        status = STATUS_INVALID_PARAMETER;

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    return (status);

}

NTSTATUS
BlockTCPPorts(
              IN PIRP Irp,
              IN PIO_STACK_LOCATION IrpSp
              )
{
    TDI_STATUS status = STATUS_SUCCESS;
    BOOLEAN ReservePorts;
    CTELockHandle Handle;
    ULONG requestLength, responseLength;
    PTCP_BLOCKPORTS_REQUEST request;
    PULONG response;

    Irp->IoStatus.Information = 0;

    request = (PTCP_BLOCKPORTS_REQUEST) Irp->AssociatedIrp.SystemBuffer;
    response = (PULONG) Irp->AssociatedIrp.SystemBuffer;

    requestLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
    responseLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if (requestLength < sizeof(TCP_BLOCKPORTS_REQUEST)) {
        Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
        return (STATUS_INVALID_PARAMETER);
    }
    ReservePorts = (uchar) request->ReservePorts;

    if (ReservePorts) {

        ushort LowerRange = MaxUserPort + 1;
        ushort UpperRange = 65534;
        uint NumberofPorts = request->NumberofPorts;
        ReservedPortListEntry *tmpEntry, *ListEntry, *prevEntry = NULL;
        AddrObj *ExistingAO;
        uint PortsRemaining;
        ushort Start;
        ushort netStart;
        ushort LeftEdge;

        if (responseLength < sizeof(ULONG)) {
            Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
            return (STATUS_INVALID_PARAMETER);
        }
        if ((UpperRange - LowerRange + 1) < (ushort) NumberofPorts) {
            Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
            return (STATUS_INVALID_PARAMETER);
        }
        if (!NumberofPorts) {
            Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
            IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
            return (STATUS_INVALID_PARAMETER);
        }
        CTEGetLock(&AddrObjTableLock.Lock, &Handle);

        // its assumed that BlockedPortList is sorted in the order of port number range

        tmpEntry = BlockedPortList;
        Start = LowerRange;
        PortsRemaining = NumberofPorts;
        LeftEdge = Start;

        while (Start < UpperRange) {
            // check whether the current port lies in the reserved range

            if ((tmpEntry) && ((Start >= tmpEntry->LowerRange) && (Start <= tmpEntry->UpperRange))) {
                Start = tmpEntry->UpperRange + 1;
                PortsRemaining = NumberofPorts;
                LeftEdge = Start;
                prevEntry = tmpEntry;
                tmpEntry = tmpEntry->next;
            } else {

                // Start port doesn't lie in the current blocked range
                // check whether somebody has done a bind to it

                netStart = net_short(Start);
                ExistingAO = FindAddrObjWithPort(netStart);

                if (ExistingAO) {
                    Start++;
                    PortsRemaining = NumberofPorts;
                    LeftEdge = Start;
                } else {
                    PortsRemaining--;
                    Start++;
                    if (!PortsRemaining) {
                        break;
                    }
                }
            }
        }

        // we have either found the range
        // or we couldn't find a contiguous range

        if (!PortsRemaining) {
            // we found the range
            // return the range
            // LeftEdge <-> LeftEdge + NumberofPorts - 1
            ListEntry = CTEAllocMem(sizeof(ReservedPortListEntry));

            if (ListEntry) {
                ListEntry->LowerRange = LeftEdge;
                ListEntry->UpperRange = LeftEdge + NumberofPorts - 1;

                // BlockedPortList is a sorted list

                if (prevEntry) {
                    // insert it after prevEntry
                    ListEntry->next = prevEntry->next;
                    prevEntry->next = ListEntry;
                } else {
                    // this has to be the first element in the list
                    ListEntry->next = BlockedPortList;
                    BlockedPortList = ListEntry;
                }
                Irp->IoStatus.Information = sizeof(ULONG);
                *response = LeftEdge;
                status = STATUS_SUCCESS;
            } else {
                // no resources
                status = STATUS_INSUFFICIENT_RESOURCES;
            }

        } else {
            // couldn't find the range
            status = STATUS_INVALID_PARAMETER;
        }

    } else {
        // unreserve the ports;
        ReservedPortListEntry *CurrEntry = BlockedPortList;
        ReservedPortListEntry *PrevEntry = NULL;
        ULONG StartHandle;

        StartHandle = request->StartHandle;

        CTEGetLock(&AddrObjTableLock.Lock, &Handle);

        status = STATUS_INVALID_PARAMETER;
        while (CurrEntry) {
            if (CurrEntry->LowerRange == StartHandle) {
                // delete the entry
                if (PrevEntry == NULL) {
                    // this is the first entry
                    BlockedPortList = CurrEntry->next;
                } else {
                    // this is intermediate entry
                    PrevEntry->next = CurrEntry->next;
                }
                // free the current entry
                CTEFreeMem(CurrEntry);
                status = STATUS_SUCCESS;
                break;
            } else if (StartHandle > CurrEntry->UpperRange) {
                PrevEntry = CurrEntry;
                CurrEntry = CurrEntry->next;
            } else {
                // the list is sorted can't find the handle
                break;
            }
        }
    }

    CTEFreeLock(&AddrObjTableLock.Lock, Handle);
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    return (status);
}

NTSTATUS
TCPEnumerateConnectionList(
                           IN PIRP Irp,
                           IN PIO_STACK_LOCATION IrpSp
                           )
/*++

Routine Description:

    Processes a request to enumerate the workstation connection list.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successful.

Notes:

    This routine does not pend.

--*/

{

    TCPConnectionListEntry *request;
    TCPConnectionListEnum *response;
    ULONG requestLength, responseLength;
    NTSTATUS status;

    PAGED_CODE();

    request = (TCPConnectionListEntry *) Irp->AssociatedIrp.SystemBuffer;
    response = (TCPConnectionListEnum *) request;
    requestLength = IrpSp->Parameters.DeviceIoControl.InputBufferLength;
    responseLength = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;

    if (responseLength < sizeof(TCPConnectionListEnum)) {
        status = STATUS_BUFFER_TOO_SMALL;
        Irp->IoStatus.Information = 0;
    } else {
        EnumerateConnectionList(
                                (uchar *) (response + 1),
                                responseLength - sizeof(TCPConnectionListEnum),
                                &(response->tce_entries_returned),
                                &(response->tce_entries_available)
                                );

        status = TDI_SUCCESS;
        Irp->IoStatus.Information =
            sizeof(TCPConnectionListEnum) +
            (response->tce_entries_returned * sizeof(TCPConnectionListEntry));

    }

    Irp->IoStatus.Status = status;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    return (status);
}

NTSTATUS
TCPCreate(
          IN PDEVICE_OBJECT DeviceObject,
          IN PIRP Irp,
          IN PIO_STACK_LOCATION IrpSp
          )
/*++

Routine Description:

Arguments:

    DeviceObject - Pointer to the device object for this request.
    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    TDI_REQUEST Request;
    NTSTATUS status;
    FILE_FULL_EA_INFORMATION *ea;
    FILE_FULL_EA_INFORMATION UNALIGNED *targetEA;
    PTCP_CONTEXT tcpContext;
    uint protocol;
    BOOLEAN IsRawOpen = FALSE;

    PAGED_CODE();

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("+TCPCreate \n")));

    RtlZeroMemory(&Request, sizeof(TDI_REQUEST));
    tcpContext = ExAllocatePoolWithTag(NonPagedPool, sizeof(TCP_CONTEXT), 'cPCT');

    if (tcpContext == NULL) {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }
#if DBG
    InitializeListHead(&(tcpContext->PendingIrpList));
    InitializeListHead(&(tcpContext->CancelledIrpList));
#endif

    tcpContext->ReferenceCount = 1;        // put initial reference on open object

    tcpContext->CancelIrps = FALSE;
    KeInitializeEvent(&(tcpContext->CleanupEvent), SynchronizationEvent, FALSE);
    CTEInitLock(&(tcpContext->EndpointLock));

    tcpContext->Cleanup = FALSE;

    ea = (PFILE_FULL_EA_INFORMATION) Irp->AssociatedIrp.SystemBuffer;

    //
    // See if this is a Control Channel open.
    //
    if (!ea) {
        IF_TCPDBG(TCP_DEBUG_OPEN) {
            TCPTRACE((
                      "TCPCreate: Opening control channel for file object %lx\n",
                      IrpSp->FileObject
                     ));
        }

        tcpContext->Handle.ControlChannel = NULL;
        IrpSp->FileObject->FsContext = tcpContext;
        IrpSp->FileObject->FsContext2 = (PVOID) TDI_CONTROL_CHANNEL_FILE;

        return (STATUS_SUCCESS);
    }
    //
    // See if this is an Address Object open.
    //
    targetEA = FindEA(
                      ea,
                      TdiTransportAddress,
                      TDI_TRANSPORT_ADDRESS_LENGTH
                      );

    if (targetEA != NULL) {
        UCHAR optionsBuffer[3];
        PUCHAR optionsPointer = optionsBuffer;
        PSECURITY_DESCRIPTOR addrSD = NULL;

        //Sanity check the address list. Should be bound by EaValueLength
        {
            TA_ADDRESS *tmpTA;
            TRANSPORT_ADDRESS UNALIGNED *tmpTAList;
            LONG Count = 1;
            UINT tmpLen = 0;
            UINT sizeof_TransportAddress = FIELD_OFFSET(TRANSPORT_ADDRESS, Address);
            UINT sizeof_TAAddress = FIELD_OFFSET(TA_ADDRESS, Address);

            if (ea->EaValueLength >= sizeof_TransportAddress + sizeof_TAAddress) {

                tmpTAList = (TRANSPORT_ADDRESS UNALIGNED *)
                    & (targetEA->EaName[targetEA->EaNameLength + 1]);

                Count = tmpTAList->TAAddressCount;
                tmpLen = sizeof_TransportAddress;
                tmpTA = (PTA_ADDRESS) tmpTAList->Address;

                while (Count && ((tmpLen += sizeof_TAAddress) <= ea->EaValueLength)) {

                    tmpLen += tmpTA->AddressLength;
                    tmpTA = (PTA_ADDRESS) (tmpTA->Address + tmpTA->AddressLength);
                    Count--;
                }

                if (tmpLen > ea->EaValueLength) {
                    Count = 1;
                }
            }
            if (Count) {
                //Does not match what is stated in EA. Bail out

                TCPTRACE(("TCPCreate: ea count and Ea Val length does not match for transport address's\n"));
                status = STATUS_INVALID_EA_NAME;
                ExFreePool(tcpContext);
                ASSERT(status != TDI_PENDING);

                return (status);

            }
        }

        if (DeviceObject == TCPDeviceObject) {
            protocol = PROTOCOL_TCP;
        } else if (DeviceObject == UDPDeviceObject) {
            protocol = PROTOCOL_UDP;

            ASSERT(optionsPointer - optionsBuffer <= 3);

            if (IsDHCPZeroAddress(
                                  (TRANSPORT_ADDRESS UNALIGNED *)
                                  & (targetEA->EaName[targetEA->EaNameLength + 1])
                )) {
#if ACC
                if (!IsAdminIoRequest(Irp, IrpSp)) {
                    ExFreePool(tcpContext);
                    return (STATUS_ACCESS_DENIED);
                }
#endif
                *optionsPointer = TDI_ADDRESS_OPTION_DHCP;
                optionsPointer++;
            }
            ASSERT(optionsPointer - optionsBuffer <= 3);
        } else {
            //
            // This is a raw ip open
            //
#if ACC
            //
            // Only administrators can create raw addresses
            // unless this is allowed through registry
            //
            if (!AllowUserRawAccess && !IsAdminIoRequest(Irp, IrpSp)) {
                ExFreePool(tcpContext);
                return (STATUS_ACCESS_DENIED);
            }
#endif // ACC

            protocol = RawExtractProtocolNumber(
                                                &(IrpSp->FileObject->FileName)
                                                );

            if ((protocol == 0xFFFFFFFF) || (protocol == PROTOCOL_TCP)) {
                ExFreePool(tcpContext);
                return (STATUS_INVALID_PARAMETER);
            }
            IsRawOpen = TRUE;
        }

        if ((IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_READ) ||
            (IrpSp->Parameters.Create.ShareAccess & FILE_SHARE_WRITE)
            ) {
            *optionsPointer = TDI_ADDRESS_OPTION_REUSE;
            optionsPointer++;
        }
        *optionsPointer = TDI_OPTION_EOL;

        IF_TCPDBG(TCP_DEBUG_OPEN) {
            TCPTRACE((
                      "TCPCreate: Opening address for file object %lx\n",
                      IrpSp->FileObject
                     ));
        }

#if ACC
        Request.RequestContext = Irp;
#endif
        if (protocol == PROTOCOL_TCP || protocol == PROTOCOL_UDP) {
            status = CaptureCreatorSD(Irp, IrpSp, &addrSD);
        } else {
            status = STATUS_SUCCESS;
        }

        if (NT_SUCCESS(status)) {
            status = TdiOpenAddress(
                                    &Request,
                                    (TRANSPORT_ADDRESS UNALIGNED *)
                                    & (targetEA->EaName[targetEA->EaNameLength + 1]),
                                    protocol,
                                    optionsBuffer,
                                    addrSD,
                                    IsRawOpen
                                    );
        }

        if (NT_SUCCESS(status)) {
            //
            // Save off the handle to the AO passed back.
            //
            tcpContext->Handle.AddressHandle = Request.Handle.AddressHandle;
            IrpSp->FileObject->FsContext = tcpContext;
            IrpSp->FileObject->FsContext2 =
                (PVOID) TDI_TRANSPORT_ADDRESS_FILE;
        } else {
            if (addrSD != NULL) {
                ObDereferenceSecurityDescriptor(addrSD, 1);
            }
            ExFreePool(tcpContext);
            //TCPTRACE(("TdiOpenAddress failed, status %lx\n", status));
            if (status == STATUS_ADDRESS_ALREADY_EXISTS) {
                status = STATUS_SHARING_VIOLATION;
            }
        }

        ASSERT(status != TDI_PENDING);

        return (status);
    }
    //
    // See if this is a Connection Object open.
    //
    targetEA = FindEA(
                      ea,
                      TdiConnectionContext,
                      TDI_CONNECTION_CONTEXT_LENGTH
                      );

    if (targetEA != NULL) {
        //
        // This is an open of a Connection Object.
        //

        if (DeviceObject == TCPDeviceObject) {

            IF_TCPDBG(TCP_DEBUG_OPEN) {
                TCPTRACE((
                          "TCPCreate: Opening connection for file object %lx\n",
                          IrpSp->FileObject
                         ));
            }

            if (targetEA->EaValueLength < sizeof(CONNECTION_CONTEXT)) {
                status = STATUS_EA_LIST_INCONSISTENT;
            } else {
                status = TdiOpenConnection(
                                           &Request,
                                           *((CONNECTION_CONTEXT UNALIGNED *)
                                             & (targetEA->EaName[targetEA->EaNameLength + 1]))
                                           );
            }

            if (NT_SUCCESS(status)) {
                //
                // Save off the Connection Context passed back.
                //
                tcpContext->Handle.ConnectionContext =
                    Request.Handle.ConnectionContext;
                IrpSp->FileObject->FsContext = tcpContext;
                IrpSp->FileObject->FsContext2 =
                    (PVOID) TDI_CONNECTION_FILE;

                tcpContext->Conn = (UINT_PTR) Request.RequestContext;
            } else {
                ExFreePool(tcpContext);
                TCPTRACE((
                          "TdiOpenConnection failed, status %lx\n",
                          status
                         ));
            }
        } else {
            TCPTRACE((
                      "TCP: TdiOpenConnection issued on UDP device!\n"
                     ));
            status = STATUS_INVALID_DEVICE_REQUEST;
            ExFreePool(tcpContext);
        }

        ASSERT(status != TDI_PENDING);

        return (status);
    }
    TCPTRACE(("TCPCreate: didn't find any useful ea's\n"));
    status = STATUS_INVALID_EA_NAME;
    ExFreePool(tcpContext);

    ASSERT(status != TDI_PENDING);

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("-TCPCreate \n")));

    return (status);

}                                // TCPCreate

#if ACC

BOOLEAN
IsAdminIoRequest(
                 PIRP Irp,
                 PIO_STACK_LOCATION IrpSp
                 )
/*++

Routine Description:

    (Lifted from AFD - AfdPerformSecurityCheck)
    Compares security context of the endpoint creator to that
    of the administrator and local system.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

Return Value:

    TRUE    - the socket creator has admin or local system privilige
    FALSE    - the socket creator is just a plain user

--*/

{
    BOOLEAN accessGranted;
    PACCESS_STATE accessState;
    PIO_SECURITY_CONTEXT securityContext;
    PPRIVILEGE_SET privileges = NULL;
    ACCESS_MASK grantedAccess;
    PGENERIC_MAPPING GenericMapping;
    ACCESS_MASK AccessMask = GENERIC_ALL;
    NTSTATUS Status;

    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask(&AccessMask, GenericMapping);

    securityContext = IrpSp->Parameters.Create.SecurityContext;
    accessState = securityContext->AccessState;

    SeLockSubjectContext(&accessState->SubjectSecurityContext);

    accessGranted = SeAccessCheck(
                                  TcpAdminSecurityDescriptor,
                                  &accessState->SubjectSecurityContext,
                                  TRUE,
                                  AccessMask,
                                  0,
                                  &privileges,
                                  IoGetFileObjectGenericMapping(),
                                  (KPROCESSOR_MODE) ((IrpSp->Flags & SL_FORCE_ACCESS_CHECK)
                                                     ? UserMode
                                                     : Irp->RequestorMode),
                                  &grantedAccess,
                                  &Status
                                  );

    if (privileges) {
        (VOID) SeAppendPrivileges(
                                  accessState,
                                  privileges
                                  );
        SeFreePrivileges(privileges);
    }
    if (accessGranted) {
        accessState->PreviouslyGrantedAccess |= grantedAccess;
        accessState->RemainingDesiredAccess &= ~(grantedAccess | MAXIMUM_ALLOWED);
        ASSERT(NT_SUCCESS(Status));
    } else {
        ASSERT(!NT_SUCCESS(Status));
    }
    SeUnlockSubjectContext(&accessState->SubjectSecurityContext);

    return accessGranted;
}

#endif

void
TCPCloseObjectComplete(
                       void *Context,
                       unsigned int Status,
                       unsigned int UnUsed
                       )
/*++

Routine Description:

    Completes a TdiCloseConnectoin or TdiCloseAddress request.

Arguments:

    Context    - A pointer to the IRP for this request.
    Status     - The final status of the operation.
    UnUsed     - An unused parameter

Return Value:

    None.

Notes:

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PTCP_CONTEXT tcpContext;
    CTELockHandle CancelHandle;

    UNREFERENCED_PARAMETER(UnUsed);

    irp = (PIRP) Context;
    irpSp = IoGetCurrentIrpStackLocation(irp);
    tcpContext = (PTCP_CONTEXT) irpSp->FileObject->FsContext;
    irp->IoStatus.Status = Status;

    IF_TCPDBG(TCP_DEBUG_CLEANUP) {
        TCPTRACE((
                  "TCPCloseObjectComplete on file object %lx\n",
                  irpSp->FileObject
                 ));
    }
    CTEGetLock(&tcpContext->EndpointLock, &CancelHandle);

    ASSERT(tcpContext->ReferenceCount > 0);
    ASSERT(tcpContext->CancelIrps);

    //
    // Remove the initial reference that was put on by TCPCreate.
    //
    ASSERT(tcpContext->ReferenceCount > 0);

    IF_TCPDBG(TCP_DEBUG_IRP) {
        TCPTRACE((
                  "TCPCloseObjectComplete: irp %lx fileobj %lx refcnt dec to %u\n",
                  irp,
                  irpSp,
                  tcpContext->ReferenceCount - 1
                 ));
    }


    if (--(tcpContext->ReferenceCount) == 0) {

        IF_TCPDBG(TCP_DEBUG_CANCEL) {
            ASSERT(IsListEmpty(&(tcpContext->CancelledIrpList)));
            ASSERT(IsListEmpty(&(tcpContext->PendingIrpList)));
        }

        //
        // Free the EndpointLock before setting CleanupEvent,
        // as tcpContext can go away as soon as the event is signalled.
        //

        CTEFreeLock(&tcpContext->EndpointLock, CancelHandle);
        KeSetEvent(&(tcpContext->CleanupEvent), 0, FALSE);
        return;
    }

    CTEFreeLock(&tcpContext->EndpointLock, CancelHandle);

    return;

}                                // TCPCleanupComplete

NTSTATUS
TCPCleanup(
           IN PDEVICE_OBJECT DeviceObject,
           IN PIRP Irp,
           IN PIO_STACK_LOCATION IrpSp
           )
/*++

Routine Description:

    Cancels all outstanding Irps on a TDI object by calling the close
        routine for the object. It then waits for them to be completed
        before returning.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

Notes:

    This routine blocks, but does not pend.

--*/

{
    PTCP_CONTEXT tcpContext;
    NTSTATUS status;
    TDI_REQUEST request;
    CTELockHandle CancelHandle;
    CTEBlockTracker Tracker;

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("+TCPCleanup \n")));

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;

    CTEGetLock(&tcpContext->EndpointLock, &CancelHandle);

    tcpContext->CancelIrps = TRUE;
    KeResetEvent(&(tcpContext->CleanupEvent));


    ASSERT(!tcpContext->Cleanup);
    tcpContext->Cleanup = TRUE;
    tcpContext->Irp = Irp;


    CTEFreeLock(&tcpContext->EndpointLock, CancelHandle);

    //
    // Now call the TDI close routine for this object to force all of its Irps
    // to complete.
    //
    request.RequestNotifyObject = TCPCloseObjectComplete;
    request.RequestContext = Irp;

    switch (PtrToUlong(IrpSp->FileObject->FsContext2)) {

    case TDI_TRANSPORT_ADDRESS_FILE:
        IF_TCPDBG(TCP_DEBUG_CLOSE) {
            TCPTRACE((
                      "TCPCleanup: Closing address object on file object %lx\n",
                      IrpSp->FileObject
                     ));
        }
        request.Handle.AddressHandle = tcpContext->Handle.AddressHandle;
        status = TdiCloseAddress(&request);
        break;

    case TDI_CONNECTION_FILE:
        IF_TCPDBG(TCP_DEBUG_CLOSE) {
            TCPTRACE((
                      "TCPCleanup: Closing Connection object on file object %lx\n",
                      IrpSp->FileObject
                     ));
        }
        request.Handle.ConnectionContext = tcpContext->Handle.ConnectionContext;
        status = TdiCloseConnection(&request);
        break;

    case TDI_CONTROL_CHANNEL_FILE:
        IF_TCPDBG(TCP_DEBUG_CLOSE) {
            TCPTRACE((
                      "TCPCleanup: Closing Control Channel object on file object %lx\n",
                      IrpSp->FileObject
                     ));
        }
        status = STATUS_SUCCESS;
        break;

    default:
        //
        // This should never happen.
        //
        ASSERT(FALSE);

        CTEGetLock(&tcpContext->EndpointLock, &CancelHandle);

        tcpContext->CancelIrps = FALSE;

        CTEFreeLock(&tcpContext->EndpointLock, CancelHandle);

        return (STATUS_INVALID_PARAMETER);
    }

    if (status != TDI_PENDING) {
        TCPCloseObjectComplete(Irp, status, 0);
    }
    IF_TCPDBG(TCP_DEBUG_CLEANUP) {
        TCPTRACE((
                  "TCPCleanup: waiting for completion of Irps on file object %lx\n",
                  IrpSp->FileObject
                 ));
    }

    CTEInsertBlockTracker(&Tracker, IrpSp->FileObject);
    status = KeWaitForSingleObject(
                                   &(tcpContext->CleanupEvent),
                                   UserRequest,
                                   KernelMode,
                                   FALSE,
                                   NULL
                                   );
    CTERemoveBlockTracker(&Tracker);

    ASSERT(NT_SUCCESS(status));

    IF_TCPDBG(TCP_DEBUG_CLEANUP) {
        TCPTRACE((
                  "TCPCleanup: Wait on file object %lx finished\n",
                  IrpSp->FileObject
                 ));
    }

    //
    // The cleanup Irp will be completed by the dispatch routine.
    //

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("-TCPCleanup \n")));

    return (Irp->IoStatus.Status);

}                                // TCPCleanup

NTSTATUS
TCPClose(
         IN PIRP Irp,
         IN PIO_STACK_LOCATION IrpSp
         )
/*++

Routine Description:

    Dispatch routine for MJ_CLOSE IRPs. Performs final cleanup of the
        open endpoint.

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

Notes:

    This request does not pend.

--*/

{
    PTCP_CONTEXT tcpContext;

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("+TCPClose \n")));

    tcpContext = (PTCP_CONTEXT) IrpSp->FileObject->FsContext;

#if DBG

    IF_TCPDBG(TCP_DEBUG_CANCEL) {

        KIRQL oldIrql;

        IoAcquireCancelSpinLock(&oldIrql);

        ASSERT(tcpContext->ReferenceCount == 0);
        ASSERT(IsListEmpty(&(tcpContext->PendingIrpList)));
        ASSERT(IsListEmpty(&(tcpContext->CancelledIrpList)));

        IoReleaseCancelSpinLock(oldIrql);
    }
#endif // DBG

    IF_TCPDBG(TCP_DEBUG_CLOSE) {
        TCPTRACE(("TCPClose on file object %lx\n", IrpSp->FileObject));
    }

    ExFreePool(tcpContext);

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("-TCPClose \n")));

    return (STATUS_SUCCESS);

}                                // TCPClose

NTSTATUS
TCPDispatchDeviceControl(
                         IN PIRP Irp,
                         IN PIO_STACK_LOCATION IrpSp
                         )
/*++

Routine Description:

Arguments:

    Irp          - Pointer to I/O request packet
    IrpSp        - Pointer to the current stack location in the Irp.

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    NTSTATUS status;


    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("+TCPDispatchDeviceControl \n")));

    //
    // Set this in advance. Any IOCTL dispatch routine that cares about it
    // will modify it itself.
    //
    Irp->IoStatus.Information = 0;

    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode) {

    case IOCTL_TCP_FINDTCB:
        {
            IPAddr Src;
            IPAddr Dest;
            ushort DestPort;
            ushort SrcPort;
            PTCP_FINDTCB_REQUEST request;
            PTCP_FINDTCB_RESPONSE TCBInfo;
            ULONG InfoBufferLen;

            if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength <
                 sizeof(TCP_FINDTCB_REQUEST)
                )
                ||
                (IrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                 sizeof(TCP_FINDTCB_RESPONSE))
                ) {
                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;
                IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
                return STATUS_INVALID_PARAMETER;
            }
            request = Irp->AssociatedIrp.SystemBuffer;

            Src = request->Src;
            Dest = request->Dest;
            DestPort = request->DestPort;
            SrcPort = request->SrcPort;

            InfoBufferLen = IrpSp->Parameters.DeviceIoControl.OutputBufferLength;
            TCBInfo = Irp->AssociatedIrp.SystemBuffer;
            NdisZeroMemory(TCBInfo, sizeof(TCP_FINDTCB_RESPONSE));

            status = GetTCBInfo(TCBInfo, Dest, Src, DestPort, SrcPort);
            if (status == STATUS_SUCCESS) {
                Irp->IoStatus.Information = sizeof(TCP_FINDTCB_RESPONSE);
            } else {
                Irp->IoStatus.Information = 0;
            }

            Irp->IoStatus.Status = status;
            IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
            return status;
            break;
        }

    case IOCTL_TCP_QUERY_INFORMATION_EX:
        return (TCPQueryInformationEx(Irp, IrpSp));
        break;

    case IOCTL_TCP_WSH_SET_INFORMATION_EX:
    case IOCTL_TCP_SET_INFORMATION_EX:
        return (TCPSetInformationEx(Irp, IrpSp));
        break;

    case IOCTL_TCP_QUERY_SECURITY_FILTER_STATUS:
    case IOCTL_TCP_SET_SECURITY_FILTER_STATUS:
        return (TCPControlSecurityFilter(Irp, IrpSp));
        break;

    case IOCTL_TCP_ADD_SECURITY_FILTER:
    case IOCTL_TCP_DELETE_SECURITY_FILTER:
        return (TCPProcessSecurityFilterRequest(Irp, IrpSp));
        break;

    case IOCTL_TCP_ENUMERATE_SECURITY_FILTER:
        return (TCPEnumerateSecurityFilter(Irp, IrpSp));
        break;


    case IOCTL_TCP_RESERVE_PORT_RANGE:
    case IOCTL_TCP_UNRESERVE_PORT_RANGE:
        return (TCPReservePorts(Irp, IrpSp));
        break;

    case IOCTL_TCP_BLOCK_PORTS:
        return (BlockTCPPorts(Irp, IrpSp));
        break;

    default:
        status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    Irp->IoStatus.Status = status;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("-TCPDispatchDeviceControl \n")));

    return status;

}                                // TCPDispatchDeviceControl

#if TRACE_EVENT
NTSTATUS
TCPEventTraceControl(
                     IN PDEVICE_OBJECT DeviceObject,
                     IN PIRP Irp
                     )
/*++

Routine Description:

    This routine handles any WMI requests for enabling/disabling Event
    tracing.

Arguments:

    DeviceObject - Context for the activity.
    Irp          - The device control argument block.

Return Value:

    Status is returned.

--*/
{
    NTSTATUS status;
    ULONG retSize;

    if (DeviceObject != IPDeviceObject) {

        PIO_STACK_LOCATION irpSp;
        ULONG bufferSize;
        PVOID buffer;

        irpSp = IoGetCurrentIrpStackLocation(Irp);
        bufferSize = irpSp->Parameters.WMI.BufferSize;
        buffer = irpSp->Parameters.WMI.Buffer;

        switch (irpSp->MinorFunction) {
#pragma warning(push)
#pragma warning(disable:4055) // cast from a data pointer to a function pointer
        case IRP_MN_SET_TRACE_NOTIFY:
            if (bufferSize < sizeof(PTDI_DATA_REQUEST_NOTIFY_ROUTINE)) {
                status = STATUS_BUFFER_TOO_SMALL;
            } else {
                TCPCPHandlerRoutine = (PTDI_DATA_REQUEST_NOTIFY_ROUTINE)
                    * ((PVOID *) buffer);
                status = STATUS_SUCCESS;
            }
            retSize = 0;
            break;
#pragma warning(pop)
        case IRP_MN_REGINFO:
            {
                //
                // Stub for now. TCP can register its Guids with WMI here
                //
                PWMIREGINFOW WmiRegInfo;
                ULONG WmiRegInfoSize = sizeof(WMIREGINFOW);

                status = STATUS_SUCCESS;
                if (bufferSize >= WmiRegInfoSize) {
                    WmiRegInfo = (PWMIREGINFOW) buffer;
                    RtlZeroMemory(WmiRegInfo, WmiRegInfoSize);
                    WmiRegInfo->BufferSize = WmiRegInfoSize;

                    retSize = WmiRegInfoSize;
                } else {
                    *(ULONG *) buffer = WmiRegInfoSize;
                    retSize = sizeof(ULONG);
                }
                break;
            }

        default:
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                      "TCPDispatch: Irp %lx unsupported minor function 0x%lx\n",
                      irpSp,
                      irpSp->MinorFunction
                     ));
            retSize = 0;
            status = STATUS_INVALID_DEVICE_REQUEST;
        }

    } else {
        status = STATUS_INVALID_DEVICE_REQUEST;
        retSize = 0;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = retSize;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    return status;
}
#endif

NTSTATUS
TCPDispatchInternalDeviceControl(
                                 IN PDEVICE_OBJECT DeviceObject,
                                 IN PIRP Irp
                                 )
/*++

Routine Description:

    This is the dispatch routine for Internal Device Control IRPs.
    This is the hot path for kernel-mode clients.

Arguments:

    DeviceObject - Pointer to device object for target device
    Irp          - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    DEBUGMSG(DBG_TRACE && DBG_TDI && DBG_VERBOSE,
        (DTEXT("+TCPDispatchInternalDeviceControl \n")));

#if IPMCAST

    if (DeviceObject == IpMcastDeviceObject) {
        return IpMcastDispatch(DeviceObject,
                               Irp);
    }
#endif

    if (DeviceObject != IPDeviceObject) {

        irpSp = IoGetCurrentIrpStackLocation(Irp);

        if (PtrToUlong(irpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE) {
            //
            // Send and receive are the performance path, so check for them
            // right away.
            //
            if (irpSp->MinorFunction == TDI_SEND) {
                return (TCPSendData(Irp, irpSp));
            }
            if (irpSp->MinorFunction == TDI_RECEIVE) {
                return (TCPReceiveData(Irp, irpSp));
            }
            switch (irpSp->MinorFunction) {

            case TDI_ASSOCIATE_ADDRESS:
                status = TCPAssociateAddress(Irp, irpSp);
                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

                return (status);

            case TDI_DISASSOCIATE_ADDRESS:
                return (TCPDisassociateAddress(Irp, irpSp));

            case TDI_CONNECT:
                return (TCPConnect(Irp, irpSp));

            case TDI_DISCONNECT:
                return (TCPDisconnect(Irp, irpSp));

            case TDI_LISTEN:
                return (TCPListen(Irp, irpSp));

            case TDI_ACCEPT:
                return (TCPAccept(Irp, irpSp));

            default:
                break;
            }

            //
            // Fall through.
            //
        } else if (PtrToUlong(irpSp->FileObject->FsContext2) ==
                   TDI_TRANSPORT_ADDRESS_FILE
                   ) {

            if (irpSp->MinorFunction == TDI_SEND) {
                return (UDPSendData(Irp, irpSp));
            }
            if (irpSp->MinorFunction == TDI_SEND_DATAGRAM) {
                return (UDPSendDatagram(Irp, irpSp));
            }
            if (irpSp->MinorFunction == TDI_RECEIVE_DATAGRAM) {
                return (UDPReceiveDatagram(Irp, irpSp));
            }
            if (irpSp->MinorFunction == TDI_SET_EVENT_HANDLER) {
                status = TCPSetEventHandler(Irp, irpSp);

                Irp->IoStatus.Status = status;
                Irp->IoStatus.Information = 0;
                IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

                return (status);
            }
            if (irpSp->MinorFunction == TDI_CONNECT) {

                return (TCPConnect(Irp, irpSp));
            }
            if (irpSp->MinorFunction == TDI_DISCONNECT) {

                return (TCPDisconnect(Irp, irpSp));
            }
            //
            // Fall through.
            //
        }
        ASSERT(
                  (PtrToUlong(irpSp->FileObject->FsContext2) == TDI_TRANSPORT_ADDRESS_FILE)
                  ||
                  (PtrToUlong(irpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE)
                  ||
                  (PtrToUlong(irpSp->FileObject->FsContext2) == TDI_CONTROL_CHANNEL_FILE)
                  );

        //
        // These functions are common to all endpoint types.
        //
        switch (irpSp->MinorFunction) {

        case TDI_QUERY_INFORMATION:
            return (TCPQueryInformation(Irp, irpSp));

        case TDI_SET_INFORMATION:
        case TDI_ACTION:
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                      "TCP: Call to unimplemented TDI function 0x%x\n",
                      irpSp->MinorFunction
                     ));
            status = STATUS_NOT_IMPLEMENTED;
            break;
        default:
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                      "TCP: call to invalid TDI function 0x%x\n",
                      irpSp->MinorFunction
                     ));
            status = STATUS_INVALID_DEVICE_REQUEST;
        }

        ASSERT(status != TDI_PENDING);

        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = 0;

        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        return status;
    }

    DEBUGMSG(DBG_TRACE && DBG_TDI && DBG_VERBOSE, (DTEXT("-TCPDispatchInternalDeviceControl \n")));

    return (IPDispatch(DeviceObject, Irp));
}

NTSTATUS
TCPDispatch(
            IN PDEVICE_OBJECT DeviceObject,
            IN PIRP Irp
            )
/*++

Routine Description:

    This is the generic dispatch routine for TCP/UDP/RawIP.

Arguments:

    DeviceObject - Pointer to device object for target device
    Irp          - Pointer to I/O request packet

Return Value:

    NTSTATUS -- Indicates whether the request was successfully queued.

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS status;

    DEBUGMSG(DBG_TRACE && DBG_TDI && DBG_VERBOSE, (DTEXT("+TCPDispatch(%x, %x) \n"), DeviceObject, Irp));

#if IPMCAST

    if (DeviceObject == IpMcastDeviceObject) {
        return IpMcastDispatch(DeviceObject,
                               Irp);
    }
#endif

    if (DeviceObject != IPDeviceObject) {

#if MILLEN
        // Ensure that the driver context is zero'd for our use.
        Irp->Tail.Overlay.DriverContext[0] = NULL;
#endif // MILLEN

        Irp->IoStatus.Information = 0;

        irpSp = IoGetCurrentIrpStackLocation(Irp);

        ASSERT(irpSp->MajorFunction != IRP_MJ_INTERNAL_DEVICE_CONTROL);

        switch (irpSp->MajorFunction) {

        case IRP_MJ_CREATE:
            status = TCPCreate(DeviceObject, Irp, irpSp);
            break;

        case IRP_MJ_CLEANUP:
            status = TCPCleanup(DeviceObject, Irp, irpSp);
            break;

        case IRP_MJ_CLOSE:
            status = TCPClose(Irp, irpSp);
            break;

        case IRP_MJ_DEVICE_CONTROL:
            status = TdiMapUserRequest(DeviceObject, Irp, irpSp);

            if (status == STATUS_SUCCESS) {
                return (TCPDispatchInternalDeviceControl(DeviceObject, Irp));
            }
            if (irpSp->Parameters.DeviceIoControl.IoControlCode == IOCTL_TDI_QUERY_DIRECT_SEND_HANDLER) {

                PULONG_PTR EntryPoint;

                EntryPoint = irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                try {

                    // Type3InputBuffer must be writeable by the caller.

                    if (Irp->RequestorMode != KernelMode) {
                        ProbeForWrite(EntryPoint,
                                      sizeof(ULONG_PTR),
                                      PROBE_ALIGNMENT(ULONG_PTR));
                    }
                    *EntryPoint = (ULONG_PTR) TCPSendData;

                    status = STATUS_SUCCESS;
                }
                except(EXCEPTION_EXECUTE_HANDLER) {
                    status = STATUS_INVALID_PARAMETER;
                }

                break;
            }
            return (TCPDispatchDeviceControl(
                                             Irp,
                                             IoGetCurrentIrpStackLocation(Irp)
                    ));
            break;

        case IRP_MJ_QUERY_SECURITY:
            //
            // This is generated on Raw endpoints. We don't do anything
            // for it.
            //
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;

        case IRP_MJ_PNP:
            status = TCPDispatchPnPPower(Irp, irpSp);
            break;


#if TRACE_EVENT
        case IRP_MJ_SYSTEM_CONTROL:
            return TCPEventTraceControl(DeviceObject, Irp);
#endif

        case IRP_MJ_WRITE:
        case IRP_MJ_READ:

        default:
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                      "TCPDispatch: Irp %lx unsupported major function 0x%lx\n",
                      irpSp,
                      irpSp->MajorFunction
                     ));
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        ASSERT(status != TDI_PENDING);

        Irp->IoStatus.Status = status;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

        return status;

    }

    return (IPDispatch(DeviceObject, Irp));
}                                // TCPDispatch

//
// Private utility functions
//
FILE_FULL_EA_INFORMATION UNALIGNED *
FindEA(
       PFILE_FULL_EA_INFORMATION StartEA,
       CHAR * TargetName,
       USHORT TargetNameLength
       )
/*++

Routine Description:

    Parses and extended attribute list for a given target attribute.

Arguments:

    StartEA           - the first extended attribute in the list.
        TargetName        - the name of the target attribute.
        TargetNameLength  - the length of the name of the target attribute.

Return Value:

    A pointer to the requested attribute or NULL if the target wasn't found.

--*/

{
    USHORT i;
    BOOLEAN found;
    FILE_FULL_EA_INFORMATION UNALIGNED *CurrentEA;

    PAGED_CODE();

    do {
        found = TRUE;

        CurrentEA = StartEA;

        StartEA = (FILE_FULL_EA_INFORMATION *) ((PUCHAR) StartEA + CurrentEA->NextEntryOffset);

        if (CurrentEA->EaNameLength != TargetNameLength) {
            continue;
        }
        for (i = 0; i < CurrentEA->EaNameLength; i++) {
            if (CurrentEA->EaName[i] == TargetName[i]) {
                continue;
            }
            found = FALSE;
            break;
        }

        if (found) {
            return (CurrentEA);
        }
    } while (CurrentEA->NextEntryOffset != 0);

    return (NULL);
}

BOOLEAN
IsDHCPZeroAddress(
                  TRANSPORT_ADDRESS UNALIGNED * AddrList
                  )
/*++

Routine Description:

    Checks a TDI IP address list for an address from DHCP binding
    to the IP address zero. Normally, binding to zero means wildcard.
    For DHCP, it really means bind to an interface with an address of
    zero. This semantic is flagged by a special value in an unused
    portion of the address structure (ie. this is a kludge).

Arguments:

    AddrList   - The TDI transport address list passed in the create IRP.

Return Value:

    TRUE if the first IP address found had the flag set. FALSE otherwise.

--*/

{
    int i;                        // Index variable.
    TA_ADDRESS *CurrentAddr;    // Address we're examining and may use.

    // First, verify that someplace in Address is an address we can use.
    CurrentAddr = (PTA_ADDRESS) AddrList->Address;

    for (i = 0; i < AddrList->TAAddressCount; i++) {
        if (CurrentAddr->AddressType == TDI_ADDRESS_TYPE_IP) {
            if (CurrentAddr->AddressLength == TDI_ADDRESS_LENGTH_IP) {
                TDI_ADDRESS_IP UNALIGNED *ValidAddr;

                ValidAddr = (TDI_ADDRESS_IP UNALIGNED *) CurrentAddr->Address;

                if (*((ULONG UNALIGNED *) ValidAddr->sin_zero) == 0x12345678) {

                    return TRUE;
                }
            } else {
                return FALSE;    // Wrong length for address.

            }
        } else {
            CurrentAddr = (PTA_ADDRESS)
                (CurrentAddr->Address + CurrentAddr->AddressLength);
        }
    }

    return FALSE;                // Didn't find a match.

}

ULONG
TCPGetMdlChainByteCount(
                        PMDL Mdl
                        )
/*++

Routine Description:

    Sums the byte counts of each MDL in a chain.

Arguments:

    Mdl  - Pointer to the MDL chain to sum.

Return Value:

    The byte count of the MDL chain.

--*/

{
    ULONG count = 0;

    while (Mdl != NULL) {
        count += MmGetMdlByteCount(Mdl);
        Mdl = Mdl->Next;
    }

    return (count);
}

ULONG
TCPGetNdisBufferChainByteCount(
    PNDIS_BUFFER pBuffer
    )
{
    ULONG cb = 0;

    while (pBuffer != NULL) {
        cb += NdisBufferLength(pBuffer);
        pBuffer = NDIS_BUFFER_LINKAGE(pBuffer);
    }

    return cb;
}

ULONG
RawExtractProtocolNumber(
                         IN PUNICODE_STRING FileName
                         )
/*++

Routine Description:

    Extracts the protocol number from the file object name.

Arguments:

    FileName  -  The unicode file name.

Return Value:

    The protocol number or 0xFFFFFFFF on error.

--*/

{
    PWSTR name;
    UNICODE_STRING unicodeString;
    ULONG protocol;
    NTSTATUS status;

    PAGED_CODE();

    name = FileName->Buffer;

    if (FileName->Length <
        (sizeof(OBJ_NAME_PATH_SEPARATOR) + sizeof(WCHAR))
        ) {
        return (0xFFFFFFFF);
    }
    //
    // Step over separator
    //
    if (*name++ != OBJ_NAME_PATH_SEPARATOR) {
        return (0xFFFFFFFF);
    }
    if (*name == UNICODE_NULL) {
        return (0xFFFFFFFF);
    }
    //
    // Convert the remaining name into a number.
    //
    RtlInitUnicodeString(&unicodeString, name);

    status = RtlUnicodeStringToInteger(
                                       &unicodeString,
                                       10,
                                       &protocol
                                       );

    if (!NT_SUCCESS(status)) {
        return (0xFFFFFFFF);
    }
    if (protocol > 255) {
        return (0xFFFFFFFF);
    }
    return (protocol);

}

NTSTATUS
CaptureCreatorSD(
    PIRP Irp,
    PIO_STACK_LOCATION IrpSp,
    OUT PSECURITY_DESCRIPTOR* CreatorSD
    )

/*++

Routine Description:

    Captures the security-descriptor associated with an IRP_MJ_CREATE request.

Arguments:

    Irp - supplies the I/O request packet.

    IrpSp - specifies the I/O stack location containing the IRP_MJ_CREATE.

    CreatorSD - on success, receives the captured security descriptor.

Return Value:

    NTSTATUS - indicates success/failure.

--*/

{
    NTSTATUS status;
    PSECURITY_DESCRIPTOR mergedSD;
    PACCESS_STATE accessState =
        IrpSp->Parameters.Create.SecurityContext->AccessState;

    PAGED_CODE();

    if (Irp->RequestorMode == KernelMode &&
        IrpSp->Parameters.Create.ShareAccess == 0 &&
        accessState->SecurityDescriptor == NULL) {
        *CreatorSD = NULL;
        status = STATUS_SUCCESS;
    } else {
        // Take a read-lock on the subject security context for the request,
        // and merge the request's SD into a new SD.

        SeLockSubjectContext(&accessState->SubjectSecurityContext);
        status = SeAssignSecurity(NULL, accessState->SecurityDescriptor,
                                  &mergedSD, FALSE,
                                  &accessState->SubjectSecurityContext,
                                  IoGetFileObjectGenericMapping(), PagedPool);
        SeUnlockSubjectContext(&accessState->SubjectSecurityContext);
        if (NT_SUCCESS(status)) {
            // Request a tracked and referenced copy of the merged SD.

            status = ObLogSecurityDescriptor(mergedSD, CreatorSD, 1);
            ExFreePool(mergedSD);
        }
    }
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\raw.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** RAW.C - Raw IP interface code.
//
//  This file contains the code for the Raw IP interface functions,
//  principally send and receive datagram.
//

#include "precomp.h"
#include "addr.h"
#include "raw.h"
#include "tlcommon.h"
#include "info.h"
#include "tcpcfg.h"
#include "secfltr.h"
#include "udp.h"

#define NO_TCP_DEFS 1
#include "tcpdeb.h"

#define PROT_IGMP   2
#define PROT_RSVP  46            // Protocol number for RSVP

#ifdef POOL_TAGGING

#ifdef ExAllocatePool
#undef ExAllocatePool
#endif

#define ExAllocatePool(type, size) ExAllocatePoolWithTag(type, size, 'rPCT')

#ifndef CTEAllocMem
#error "CTEAllocMem is not already defined - will override tagging"
#else
#undef CTEAllocMem
#endif

#define CTEAllocMem(size) ExAllocatePoolWithTag(NonPagedPool, size, 'rPCT')

#endif // POOL_TAGGING

void *RawProtInfo = NULL;

extern IPInfo LocalNetInfo;


//** RawSend - Send a datagram.
//
//  The real send datagram routine. We assume that the busy bit is
//  set on the input AddrObj, and that the address of the SendReq
//  has been verified.
//
//  We start by sending the input datagram, and we loop until there's
//  nothing left on the send q.
//
//  Input:  SrcAO       - Pointer to AddrObj doing the send.
//          SendReq     - Pointer to sendreq describing send.
//
//  Returns: Nothing
//
void
RawSend(AddrObj * SrcAO, DGSendReq * SendReq)
{
    PNDIS_BUFFER RawBuffer;
    UDPHeader *UH;
    CTELockHandle AOHandle;
    RouteCacheEntry *RCE;        // RCE used for each send.
    IPAddr SrcAddr;                // Source address IP thinks we should
    // use.
    uchar DestType = 0;                // Type of destination address.
    IP_STATUS SendStatus;        // Status of send attempt.
    ushort MSS;
    uint AddrValid;
    IPOptInfo OptInfo;
    IPAddr BoundAddr;
    uchar protocol;

    CTEStructAssert(SrcAO, ao);
    ASSERT(SrcAO->ao_usecnt != 0);

    protocol = SrcAO->ao_prot;

    IF_TCPDBG(TCP_DEBUG_RAW) {
        TCPTRACE((
                  "RawSend called, prot %u\n", protocol
                 ));
    }

    //* Loop while we have something to send, and can get
    //  resources to send.
    for (;;) {

        CTEStructAssert(SendReq, dsr);

        // Make sure we have a Raw header buffer for this send. If we
        // don't, try to get one.
        if ((RawBuffer = SendReq->dsr_header) == NULL) {
            // Don't have one, so try to get one.
            RawBuffer = GetDGHeader(&UH);
            if (RawBuffer != NULL)
                SendReq->dsr_header = RawBuffer;
            else {
                // Couldn't get a header buffer. Push the send request
                // back on the queue, and queue the addr object for when
                // we get resources.
                CTEGetLock(&SrcAO->ao_lock, &AOHandle);
                PUSHQ(&SrcAO->ao_sendq, &SendReq->dsr_q);
                PutPendingQ(SrcAO);
                CTEFreeLock(&SrcAO->ao_lock, AOHandle);
                return;
            }
        }
        // At this point, we have the buffer we need. Call IP to get an
        // RCE (along with the source address if we need it), then
        // send the data.
        ASSERT(RawBuffer != NULL);

        BoundAddr = SrcAO->ao_addr;

        if (!CLASSD_ADDR(SendReq->dsr_addr)) {
            // This isn't a multicast send, so we'll use the ordinary
            // information.
            OptInfo = SrcAO->ao_opt;
        } else {
            OptInfo = SrcAO->ao_mcastopt;

            if (SrcAO->ao_opt.ioi_options &&
                (*SrcAO->ao_opt.ioi_options == IP_OPT_ROUTER_ALERT)) {
                //Temporarily point to ao_opt options to satisfy
                //RFC 2113 (router alerts goes onmcast address too)
                OptInfo.ioi_options = SrcAO->ao_opt.ioi_options;
                OptInfo.ioi_optlength = SrcAO->ao_opt.ioi_optlength;
            }
        }

        ASSERT(!(SrcAO->ao_flags & AO_DHCP_FLAG));


        if ((OptInfo.ioi_mcastif) && CLASSD_ADDR(SendReq->dsr_addr)) {
            uint BoundIf;

            // mcast_if is set and this is a mcast send
            BoundIf = (*LocalNetInfo.ipi_getifindexfromaddr)(BoundAddr,IF_CHECK_NONE);

            // Use the bound IP address only if the 'interfaces match' and the
            // 'bound address is not NULL'
            if ((BoundIf == OptInfo.ioi_mcastif) &&
                (!IP_ADDR_EQUAL(BoundAddr, NULL_IP_ADDR))) {
                SrcAddr = BoundAddr;
            } else {

                SrcAddr = (*LocalNetInfo.ipi_isvalidindex)(OptInfo.ioi_mcastif);
            }

            // go thru slow path
            RCE = NULL;

        } else if (SrcAO->ao_opt.ioi_ucastif) {
            // srcaddr = address the socket is bound to
            SrcAddr = SrcAO->ao_addr;
            // go thru slow path
            RCE = NULL;
        } else {
            SrcAddr = (*LocalNetInfo.ipi_openrce) (SendReq->dsr_addr,
                                                   BoundAddr, &RCE, &DestType, &MSS, &OptInfo);
        }

        AddrValid = !IP_ADDR_EQUAL(SrcAddr, NULL_IP_ADDR);

        if (AddrValid) {

            // The OpenRCE worked. Send it.

            if (!CLASSD_ADDR(SendReq->dsr_addr) &&
                !IP_ADDR_EQUAL(BoundAddr, NULL_IP_ADDR)) {
                //
                // Unless we're doing a multicast lookup (which must be strong
                // host), use the bound address as the source.
                //
                SrcAddr = BoundAddr;
            }

            NdisAdjustBufferLength(RawBuffer, 0);
            NDIS_BUFFER_LINKAGE(RawBuffer) = SendReq->dsr_buffer;

            // Now send the packet.
            IF_TCPDBG(TCP_DEBUG_RAW) {
                TCPTRACE(("RawSend transmitting\n"));
            }

            UStats.us_outdatagrams++;
            SendStatus = (*LocalNetInfo.ipi_xmit) (RawProtInfo, SendReq,
                                                   RawBuffer, (uint) SendReq->dsr_size, SendReq->dsr_addr, SrcAddr,
                                                   &OptInfo, RCE, protocol, SendReq->dsr_context);

            // closerce will just return if RCE is NULL
            (*LocalNetInfo.ipi_closerce) (RCE);

            // If it completed immediately, give it back to the user.
            // Otherwise we'll complete it when the SendComplete happens.
            // Currently, we don't map the error code from this call - we
            // might need to in the future.
            if (SendStatus != IP_PENDING)
                DGSendComplete(SendReq, RawBuffer, SendStatus);

        } else {
            TDI_STATUS Status;

            if (DestType == DEST_INVALID)
                Status = TDI_BAD_ADDR;
            else
                Status = TDI_DEST_UNREACHABLE;

            // Complete the request with an error.
            (*SendReq->dsr_rtn) (SendReq->dsr_context, Status, 0);
            // Now free the request.
            SendReq->dsr_rtn = NULL;
            DGSendComplete(SendReq, RawBuffer, IP_SUCCESS);
        }

        CTEGetLock(&SrcAO->ao_lock, &AOHandle);

        if (!EMPTYQ(&SrcAO->ao_sendq)) {
            DEQUEUE(&SrcAO->ao_sendq, SendReq, DGSendReq, dsr_q);
            CTEFreeLock(&SrcAO->ao_lock, AOHandle);
        } else {
            CLEAR_AO_REQUEST(SrcAO, AO_SEND);
            CTEFreeLock(&SrcAO->ao_lock, AOHandle);
            return;
        }

    }
}

//* RawDeliver - Deliver a datagram to a user.
//
//  This routine delivers a datagram to a Raw user. We're called with
//  the AddrObj to deliver on, and with the AddrObjTable lock held.
//  We try to find a receive on the specified AddrObj, and if we do
//  we remove it and copy the data into the buffer. Otherwise we'll
//  call the receive datagram event handler, if there is one. If that
//  fails we'll discard the datagram.
//
//  Input:  RcvAO       - AO to receive the datagram.
//          SrcIP       - Source IP address of datagram.
//          IPH         - IP Header
//          IPHLength   - Bytes in IPH.
//          RcvBuf      - The IPReceive buffer containing the data.
//          RcvSize     - Size received, including the Raw header.
//          TableHandle - Lock handle for AddrObj table.
//
//  Returns: Nothing.
//
void
RawDeliver(AddrObj * RcvAO, IPAddr SrcIP, IPHeader UNALIGNED * IPH,
           uint IPHLength, IPRcvBuf * RcvBuf, uint RcvSize, IPOptInfo * OptInfo,
           CTELockHandle TableHandle, DGDeliverInfo *DeliverInfo)
{
    Queue *CurrentQ;
    CTELockHandle AOHandle;
    DGRcvReq *RcvReq;
    uint BytesTaken = 0;
    uchar AddressBuffer[TCP_TA_SIZE];
    uint RcvdSize;
    EventRcvBuffer *ERB = NULL;
    int BufferSize = 0;
    PVOID BufferToSend = NULL;

    CTEStructAssert(RcvAO, ao);

    CTEGetLock(&RcvAO->ao_lock, &AOHandle);
    CTEFreeLock(&AddrObjTableLock.Lock, AOHandle);

    if (AO_VALID(RcvAO)) {

        if ((DeliverInfo->Flags & IS_BCAST) && (DeliverInfo->Flags & SRC_LOCAL)
                && (RcvAO->ao_mcast_loop == 0)) {
            goto loop_exit;
        }

        IF_TCPDBG(TCP_DEBUG_RAW) {
            TCPTRACE((
                      "Raw delivering %u byte header + %u data bytes to AO %lx\n",
                      IPHLength, RcvSize, RcvAO
                     ));
        }

        CurrentQ = QHEAD(&RcvAO->ao_rcvq);

        // Walk the list, looking for a receive buffer that matches.
        while (CurrentQ != QEND(&RcvAO->ao_rcvq)) {
            RcvReq = QSTRUCT(DGRcvReq, CurrentQ, drr_q);

            CTEStructAssert(RcvReq, drr);

            // If this request is a wildcard request, or matches the source IP
            // address, deliver it.

            if (IP_ADDR_EQUAL(RcvReq->drr_addr, NULL_IP_ADDR) ||
                IP_ADDR_EQUAL(RcvReq->drr_addr, SrcIP)) {

                TDI_STATUS Status;
                PNDIS_BUFFER DestBuf = RcvReq->drr_buffer;
                uint DestOffset = 0;

                // Remove this from the queue.
                REMOVEQ(&RcvReq->drr_q);

                // We're done. We can free the AddrObj lock now.
                CTEFreeLock(&RcvAO->ao_lock, TableHandle);

                IF_TCPDBG(TCP_DEBUG_RAW) {
                    TCPTRACE(("Copying to posted receive\n"));
                }

                // Copy the header
                DestBuf = CopyFlatToNdis(DestBuf, (uchar *) IPH, IPHLength,
                                         &DestOffset, &RcvdSize);

                // Copy the data and then complete the request.
                RcvdSize += CopyRcvToNdis(RcvBuf, DestBuf,
                                          RcvSize, 0, DestOffset);

                ASSERT(RcvdSize <= RcvReq->drr_size);

                IF_TCPDBG(TCP_DEBUG_RAW) {
                    TCPTRACE(("Copied %u bytes\n", RcvdSize));
                }

                Status = UpdateConnInfo(RcvReq->drr_conninfo, OptInfo,
                                        SrcIP, 0);

                UStats.us_indatagrams++;

                (*RcvReq->drr_rtn) (RcvReq->drr_context, Status, RcvdSize);

                FreeDGRcvReq(RcvReq);

                return;

            }
            // Either the IP address or the port didn't match. Get the next
            // one.
            CurrentQ = QNEXT(CurrentQ);
        }

        // We've walked the list, and not found a buffer. Call the recv.
        // handler now.

        if (RcvAO->ao_rcvdg != NULL) {
            PRcvDGEvent RcvEvent = RcvAO->ao_rcvdg;
            PVOID RcvContext = RcvAO->ao_rcvdgcontext;
            TDI_STATUS RcvStatus;
            uint IndicateSize;
            uint DestOffset;
            PNDIS_BUFFER DestBuf;
            ULONG Flags = TDI_RECEIVE_COPY_LOOKAHEAD;

            uchar *TempBuf = NULL;
            ulong TempBufLen = 0;

            REF_AO(RcvAO);
            CTEFreeLock(&RcvAO->ao_lock, TableHandle);

            BuildTDIAddress(AddressBuffer, SrcIP, 0);

            IndicateSize = IPHLength;

            if (((uchar *) IPH + IPHLength) == RcvBuf->ipr_buffer) {
                //
                // The header is contiguous with the data
                //
                IndicateSize += RcvBuf->ipr_size;

                IF_TCPDBG(TCP_DEBUG_RAW) {
                    TCPTRACE(("RawRcv: header & data are contiguous\n"));
                }
            } else {

                //if totallength  is less than 128,
                //put it on a staging buffer

                TempBufLen = 128;
                if ((IPHLength + RcvSize) < 128) {
                    TempBufLen = IPHLength + RcvSize;
                }
                TempBuf = CTEAllocMem(TempBufLen);
                if (TempBuf) {
                    RtlCopyMemory(TempBuf, (uchar *) IPH, IPHLength);

                    RtlCopyMemory((TempBuf + IPHLength), RcvBuf->ipr_buffer, (TempBufLen - IPHLength));

                }
            }

            IF_TCPDBG(TCP_DEBUG_RAW) {
                TCPTRACE(("Indicating %u bytes\n", IndicateSize));
            }

            UStats.us_indatagrams++;
            if (DeliverInfo->Flags & IS_BCAST) {
                // This flag is true if this is a multicast, subnet broadcast,
                // or broadcast.  We need to differentiate to set the right
                // receive flags.
                //

                if (!CLASSD_ADDR(DeliverInfo->DestAddr)) {
                    Flags |= TDI_RECEIVE_BROADCAST;
                } else  {
                    Flags |= TDI_RECEIVE_MULTICAST;
                }
            }

            // If the IP_PKTINFO option was set, then create the control
            // information to be passed to the handler.  Currently only one
            // such option exists, so only one ancillary data object is
            // created.  We should be able to support an array of them as
            // more options are added.
            //
            if (AO_PKTINFO(RcvAO)) {
                BufferToSend = DGFillIpPktInfo(DeliverInfo->DestAddr,
                                               DeliverInfo->LocalAddr,
                                               &BufferSize);
                if (BufferToSend) {
                    // Set the receive flag so the receive handler knows
                    // we are passing up control info.
                    //
                    Flags |= TDI_RECEIVE_CONTROL_INFO;
                }
            }

            if (TempBuf) {

                RcvStatus = (*RcvEvent) (RcvContext, TCP_TA_SIZE,
                                         (PTRANSPORT_ADDRESS) AddressBuffer,
                                         BufferSize,
                                         BufferToSend, Flags,
                                         TempBufLen,
                                         IPHLength + RcvSize, (PULONG)&BytesTaken,
                                         (uchar *) TempBuf, &ERB);

                CTEFreeMem(TempBuf);

            } else {

                RcvStatus = (*RcvEvent) (RcvContext, TCP_TA_SIZE,
                                         (PTRANSPORT_ADDRESS) AddressBuffer,
                                         BufferSize, BufferToSend, Flags,
                                         IndicateSize,
                                         IPHLength + RcvSize, (PULONG)&BytesTaken,
                                         (uchar *) IPH, &ERB);
            }

            if (BufferToSend) {
                ExFreePool(BufferToSend);
            }

            if (RcvStatus == TDI_MORE_PROCESSING) {

                ASSERT(ERB != NULL);

                // We were passed back a receive buffer. Copy the data in now.

                // He can't have taken more than was in the indicated
                // buffer, but in debug builds we'll check to make sure.

                ASSERT(BytesTaken <= RcvBuf->ipr_size);

                IF_TCPDBG(TCP_DEBUG_RAW) {
                    TCPTRACE(("ind took %u bytes\n", BytesTaken));
                }

                {
#if !MILLEN
                    PIO_STACK_LOCATION IrpSp;
                    PTDI_REQUEST_KERNEL_RECEIVEDG DatagramInformation;

                    IrpSp = IoGetCurrentIrpStackLocation(ERB);
                    DatagramInformation = (PTDI_REQUEST_KERNEL_RECEIVEDG)
                        & (IrpSp->Parameters);

                    DestBuf = ERB->MdlAddress;
#else // !MILLEN
                    DestBuf = ERB->erb_buffer;
#endif // MILLEN
                    DestOffset = 0;

                    if (BytesTaken < IPHLength) {

                        // Copy the rest of the IP header
                        DestBuf = CopyFlatToNdis(
                                                 DestBuf,
                                                 (uchar *) IPH + BytesTaken,
                                                 IPHLength - BytesTaken,
                                                 &DestOffset,
                                                 &RcvdSize
                                                 );

                        BytesTaken = 0;
                    } else {
                        BytesTaken -= IPHLength;
                        RcvdSize = 0;
                    }

                    // Copy the data
                    RcvdSize += CopyRcvToNdis(
                                              RcvBuf,
                                              DestBuf,
                                              RcvSize - BytesTaken,
                                              BytesTaken,
                                              DestOffset
                                              );

                    IF_TCPDBG(TCP_DEBUG_RAW) {
                        TCPTRACE(("Copied %u bytes\n", RcvdSize));
                    }

#if !MILLEN
                    //
                    // Update the return address info
                    //
                    RcvStatus = UpdateConnInfo(
                                               DatagramInformation->ReturnDatagramInformation,
                                               OptInfo, SrcIP, 0);

                    //
                    // Complete the IRP.
                    //
                    ERB->IoStatus.Information = RcvdSize;
                    ERB->IoStatus.Status = RcvStatus;
                    IoCompleteRequest(ERB, 2);
#else // !MILLEN
                    //
                    // Call the completion routine.
                    //
                    (*ERB->erb_rtn) (ERB->erb_context, TDI_SUCCESS, RcvdSize);
#endif // MILLEN
                }

            } else {
                ASSERT(
                          (RcvStatus == TDI_SUCCESS) ||
                          (RcvStatus == TDI_NOT_ACCEPTED)
                          );

                IF_TCPDBG(TCP_DEBUG_RAW) {
                    TCPTRACE((
                              "Data %s taken\n",
                              (RcvStatus == TDI_SUCCESS) ? "all" : "not"
                             ));
                }

                ASSERT(ERB == NULL);
            }

            DELAY_DEREF_AO(RcvAO);

            return;

        } else
            UStats.us_inerrors++;

        // When we get here, we didn't have a buffer to put this data into.
        // Fall through to the return case.
    } else
        UStats.us_inerrors++;

  loop_exit:

    CTEFreeLock(&RcvAO->ao_lock, TableHandle);

}

//* RawRcv - Receive a Raw datagram.
//
//  The routine called by IP when a Raw datagram arrived. We
//  look up the port/local address pair in our address table,
//  and deliver the data to a user if we find one. For broadcast
//  frames we may deliver it to multiple users.
//
//  Entry:  IPContext   - IPContext identifying physical i/f that
//                          received the data.
//          Dest        - IPAddr of destionation.
//          Src         - IPAddr of source.
//          LocalAddr   - Local address of network which caused this to be
//                          received.
//          SrcAddr     - Address of local interface which received the packet
//          IPH         - IP Header.
//          IPHLength   - Bytes in IPH.
//          RcvBuf      - Pointer to receive buffer chain containing data.
//          Size        - Size in bytes of data received.
//          IsBCast     - Boolean indicator of whether or not this came in as
//                          a bcast.
//          Protocol    - Protocol this came in on - should be Raw.
//          OptInfo     - Pointer to info structure for received options.
//
//  Returns: Status of reception. Anything other than IP_SUCCESS will cause
//          IP to send a 'port unreachable' message.
//
IP_STATUS
RawRcv(void *IPContext, IPAddr Dest, IPAddr Src, IPAddr LocalAddr,
       IPAddr SrcAddr, IPHeader UNALIGNED * IPH, uint IPHLength, IPRcvBuf * RcvBuf,
       uint Size, uchar IsBCast, uchar Protocol, IPOptInfo * OptInfo)
{
    CTELockHandle AOTableHandle;
    AddrObj *ReceiveingAO;
    uchar SrcType, DestType;
    AOSearchContextEx Search;
    IP_STATUS Status = IP_DEST_PROT_UNREACHABLE;
    uint IfIndex;
    uint Deliver;
    DGDeliverInfo DeliverInfo = {0};

    IF_TCPDBG(TCP_DEBUG_RAW) {
        TCPTRACE(("RawRcv prot %u size %u\n", IPH->iph_protocol, Size));
    }

    SrcType = (*LocalNetInfo.ipi_getaddrtype) (Src);
    DestType = (*LocalNetInfo.ipi_getaddrtype) (Dest);

    if (SrcType == DEST_LOCAL) {
        DeliverInfo.Flags |= SRC_LOCAL;
    }
    IfIndex = (*LocalNetInfo.ipi_getifindexfromnte) (IPContext, IF_CHECK_NONE);

    // The following code relies on DEST_INVALID being a broadcast dest type.
    // If this is changed the code here needs to change also.
    if (IS_BCAST_DEST(SrcType)) {
        if (!IP_ADDR_EQUAL(Src, NULL_IP_ADDR) || !IsBCast) {
            UStats.us_inerrors++;
            return IP_SUCCESS;    // Bad src address.

        }
    }

    // Set the rest of our DeliverInfo for RawDeliver to consume.
    //
    DeliverInfo.Flags |= IsBCast ? IS_BCAST : 0;
    DeliverInfo.LocalAddr = LocalAddr;
    DeliverInfo.DestAddr = Dest;

    // Get the AddrObjTable lock, and then try to find some AddrObj(s) to give
    // this to. We deliver to all addr objs registered for the protocol and
    // address.
    CTEGetLock(&AddrObjTableLock.Lock, &AOTableHandle);


    if (!SecurityFilteringEnabled ||
        IsPermittedSecurityFilter(SrcAddr, IPContext, PROTOCOL_RAW, Protocol)
        || (RcvBuf->ipr_flags & IPR_FLAG_PROMISCUOUS)) {

        ReceiveingAO = GetFirstAddrObjEx(
                                         LocalAddr,
                                         0,        // port is zero
                                          Protocol,
                                         IfIndex,
                                         &Search
                                         );

        if (ReceiveingAO != NULL) {
            do {
                // Default behavior is not to deliver unless requested
                Deliver = FALSE;

                // Deliver if socket is bound/joined appropriately
                // Case 1: bound to destination IP address
                // Case 2: bound to INADDR_ANY (but not ifindex)
                // Case 3: bound to ifindex
                if ((IP_ADDR_EQUAL(ReceiveingAO->ao_addr, LocalAddr) ||
                     ((ReceiveingAO->ao_bindindex == 0) &&
                      (IP_ADDR_EQUAL(ReceiveingAO->ao_addr, NULL_IP_ADDR))) ||
                     (ReceiveingAO->ao_bindindex == IfIndex)) &&
                    ((ReceiveingAO->ao_prot == IPH->iph_protocol) ||
                     (ReceiveingAO->ao_prot == Protocol) ||
                     (ReceiveingAO->ao_prot == 0))) {
                    switch(DestType) {
                    case DEST_LOCAL:
                        Deliver = TRUE;
                        break;
                    case DEST_MCAST:
                        Deliver = MCastAddrOnAO(ReceiveingAO, Dest, Src, IfIndex, LocalAddr);
                        break;
                    }
                }

                // Otherwise, see whether AO is promiscuous
                if (!Deliver &&
                    (IfIndex == ReceiveingAO->ao_promis_ifindex)) {
                    if (ReceiveingAO->ao_rcvall &&
                        ((ReceiveingAO->ao_prot == IPH->iph_protocol) ||
                         (ReceiveingAO->ao_prot == Protocol) ||
                         (ReceiveingAO->ao_prot == 0))) {
                        Deliver = TRUE;
                    } else if ((ReceiveingAO->ao_rcvall_mcast) &&
                        CLASSD_ADDR(Dest) &&
                        ((ReceiveingAO->ao_prot == IPH->iph_protocol) ||
                         (ReceiveingAO->ao_prot == Protocol) ||
                         (ReceiveingAO->ao_prot == 0))) {
                        Deliver = TRUE;
                    } else if ((ReceiveingAO->ao_absorb_rtralert) &&
                        ((*LocalNetInfo.ipi_isrtralertpacket) (IPH))) {
                        Deliver = TRUE;
                    }
                }

                if (Deliver) {
                    RawDeliver(
                               ReceiveingAO, Src, IPH, IPHLength, RcvBuf, Size,
                               OptInfo, AOTableHandle, &DeliverInfo
                               );

                    // RawDeliver frees the lock so we have to get it back
                    CTEGetLock(&AddrObjTableLock.Lock, &AOTableHandle);
                }
                ReceiveingAO = GetNextAddrObjEx(&Search);
            } while (ReceiveingAO != NULL);
            Status = IP_SUCCESS;
        } else {
            UStats.us_noports++;
        }


    }

    CTEFreeLock(&AddrObjTableLock.Lock, AOTableHandle);

    return Status;
}

//* RawStatus - Handle a status indication.
//
//  This is the Raw status handler, called by IP when a status event
//  occurs. For most of these we do nothing. For certain severe status
//  events we will mark the local address as invalid.
//
//  Entry:  StatusType      - Type of status (NET or HW). NET status
//                              is usually caused by a received ICMP
//                              message. HW status indicate a HW
//                              problem.
//          StatusCode      - Code identifying IP_STATUS.
//          OrigDest        - If this is NET status, the original dest. of
//                              DG that triggered it.
//          OrigSrc         - "   "    "  "    "   , the original src.
//          Src             - IP address of status originator (could be local
//                              or remote).
//          Param           - Additional information for status - i.e. the
//                              param field of an ICMP message.
//          Data            - Data pertaining to status - for NET status, this
//                              is the first 8 bytes of the original DG.
//
//  Returns: Nothing
//
void
RawStatus(uchar StatusType, IP_STATUS StatusCode, IPAddr OrigDest,
          IPAddr OrigSrc, IPAddr Src, ulong Param, void *Data)
{

    IF_TCPDBG(TCP_DEBUG_RAW) {
        TCPTRACE(("RawStatus called\n"));
    }

    // If this is a HW status, it could be because we've had an address go
    // away.
    if (StatusType == IP_HW_STATUS) {

        if (StatusCode == IP_ADDR_DELETED) {

            // An address has gone away. OrigDest identifies the address.

            //
            // Delete any security filters associated with this address
            //
            DeleteProtocolSecurityFilter(OrigDest, PROTOCOL_RAW);


            return;
        }
        if (StatusCode == IP_ADDR_ADDED) {

            //
            // An address has materialized. OrigDest identifies the address.
            // Data is a handle to the IP configuration information for the
            // interface on which the address is instantiated.
            //
            AddProtocolSecurityFilter(OrigDest, PROTOCOL_RAW,
                                      (NDIS_HANDLE) Data);

            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\ntautodl.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    ntautodl.c

Abstract:

    NT specific routines for interfacing with the
    RAS AutoDial driver (acd.sys).

Author:

    Anthony Discolo (adiscolo)     Aug 30, 1995

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    adiscolo    08-30-95    created

Notes:

--*/

#include "precomp.h"
#include <acd.h>
#include <acdapi.h>
#include "addr.h"
#include "tcp.h"
#include "tcb.h"
#include "tcpconn.h"
#include "udp.h"
#include "tlcommon.h"

//
// Macro for calculating
// an IP address component.
//


#define UC(pIpAddr, i)   ((ULONG)(((PCHAR)(pIpAddr))[i]) & 0xff)


VOID
TCPAcdBind();

#pragma alloc_text(INIT, TCPAcdBind)

//
// Global variables
//
BOOLEAN fAcdLoadedG;
ACD_DRIVER AcdDriverG;
ULONG ulDriverIdG = 'Tcp ';

VOID
TCPNoteNewConnection(
                     IN TCB * pTCB,
                     IN CTELockHandle Handle
                     )
{
    ACD_ADDR addr;
    ACD_ADAPTER adapter;

    //
    // If there is a NULL source
    // or destination IP address, then return.
    //
    if (!pTCB->tcb_saddr || !pTCB->tcb_daddr) {
        CTEFreeLock(&pTCB->tcb_lock, Handle);
        return;
    }
    //
    // We also know we aren't interested in
    // any connections on the 127 network.
    //
    if (UC(&pTCB->tcb_daddr, 0) == 127) {
        CTEFreeLock(&pTCB->tcb_lock, Handle);
        return;
    }
    //
    // Get the address of the connection.
    //
    addr.fType = ACD_ADDR_IP;
    addr.ulIpaddr = pTCB->tcb_daddr;
    adapter.fType = ACD_ADAPTER_IP;
    adapter.ulIpaddr = pTCB->tcb_saddr;
    //
    // Release the TCB lock handle before
    // calling out of this driver.
    //
    CTEFreeLock(&pTCB->tcb_lock, Handle);
    //
    // Inform the automatic connection driver
    // of the new connection.
    //
    (*AcdDriverG.lpfnNewConnection) (&addr, &adapter);
}                                // TCPNoteNewConnection

VOID
TCPAcdBind()
{
    NTSTATUS status;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    PIRP pIrp;
    PFILE_OBJECT pAcdFileObject;
    PDEVICE_OBJECT pAcdDeviceObject;
    PACD_DRIVER pDriver = &AcdDriverG;

    //
    // Initialize the name of the automatic
    // connection device.
    //
    RtlInitUnicodeString(&nameString, ACD_DEVICE_NAME);
    //
    // Get the file and device objects for the
    // device.
    //
    status = IoGetDeviceObjectPointer(
                                      &nameString,
                                      SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                                      &pAcdFileObject,
                                      &pAcdDeviceObject);
    if (status != STATUS_SUCCESS)
        return;
    //
    // Reference the device object.
    //
    ObReferenceObject(pAcdDeviceObject);
    //
    // Remove the reference IoGetDeviceObjectPointer()
    // put on the file object.
    //
    ObDereferenceObject(pAcdFileObject);
    //
    // Initialize our part of the ACD_DRIVER
    // structure.
    //
    KeInitializeSpinLock(&AcdDriverG.SpinLock);
    AcdDriverG.ulDriverId = ulDriverIdG;
    AcdDriverG.fEnabled = FALSE;
    //
    // Build a request to get the automatic
    // connection driver entry points.
    //
    pIrp = IoBuildDeviceIoControlRequest(
                                         IOCTL_INTERNAL_ACD_BIND,
                                         pAcdDeviceObject,
                                         (PVOID) & pDriver,
                                         sizeof(pDriver),
                                         NULL,
                                         0,
                                         TRUE,
                                         NULL,
                                         &ioStatusBlock);
    if (pIrp == NULL) {
        ObDereferenceObject(pAcdDeviceObject);
        return;
    }
    //
    // Submit the request to the
    // automatic connection driver.
    //
    status = IoCallDriver(pAcdDeviceObject, pIrp);
    fAcdLoadedG = (status == STATUS_SUCCESS)? TRUE:FALSE;
    //
    // Close the device.
    //
    ObDereferenceObject(pAcdDeviceObject);
}                                // TCPAcdBind

VOID
TCPAcdUnbind()
{
    NTSTATUS status;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    PIRP pIrp;
    PFILE_OBJECT pAcdFileObject;
    PDEVICE_OBJECT pAcdDeviceObject;
    PACD_DRIVER pDriver = &AcdDriverG;

    //
    // Don't bother to unbind if we
    // didn't successfully bind in the
    // first place.
    //
    if (!fAcdLoadedG)
        return;
    //
    // Initialize the name of the automatic
    // connection device.
    //
    RtlInitUnicodeString(&nameString, ACD_DEVICE_NAME);
    //
    // Get the file and device objects for the
    // device.
    //
    status = IoGetDeviceObjectPointer(
                                      &nameString,
                                      SYNCHRONIZE | GENERIC_READ | GENERIC_WRITE,
                                      &pAcdFileObject,
                                      &pAcdDeviceObject);
    if (status != STATUS_SUCCESS)
        return;
    //
    // Reference the device object.
    //
    ObReferenceObject(pAcdDeviceObject);
    //
    // Remove the reference IoGetDeviceObjectPointer()
    // put on the file object.
    //
    ObDereferenceObject(pAcdFileObject);
    //
    // Build a request to unbind from
    // the automatic connection driver.
    //
    pIrp = IoBuildDeviceIoControlRequest(
                                         IOCTL_INTERNAL_ACD_UNBIND,
                                         pAcdDeviceObject,
                                         (PVOID) & pDriver,
                                         sizeof(pDriver),
                                         NULL,
                                         0,
                                         TRUE,
                                         NULL,
                                         &ioStatusBlock);
    if (pIrp == NULL) {
        ObDereferenceObject(pAcdDeviceObject);
        return;
    }
    //
    // Submit the request to the
    // automatic connection driver.
    //
    status = IoCallDriver(pAcdDeviceObject, pIrp);
    //
    // Close the device.
    //
    ObDereferenceObject(pAcdDeviceObject);
}                                // TCPAcdUnbind
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\raw.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** RAW.H - Raw IP interface definitions.
//
//	This file contains definitions for the Raw IP interface functions.
//

#include "dgram.h"


//
// This value is used to identify the RAW transport for security filtering.
// It is out of the range of valid IP protocols.
//
#define PROTOCOL_RAW  255


//* External definitions.
extern	IP_STATUS	RawRcv(void *IPContext, IPAddr Dest, IPAddr Src,
                        IPAddr LocalAddr, IPAddr SrcAddr,
                        IPHeader UNALIGNED *IPH, uint IPHLength,
                        IPRcvBuf *RcvBuf,  uint Size, uchar IsBCast,
                        uchar Protocol, IPOptInfo *OptInfo);

extern	void		RawStatus(uchar StatusType, IP_STATUS StatusCode, IPAddr OrigDest,
						IPAddr OrigSrc, IPAddr Src, ulong Param, void *Data);

extern	void		RawSend(AddrObj *SrcAO, DGSendReq *SendReq);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\ntinit.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    ntinit.c

Abstract:

    NT specific routines for loading and configuring the TCP/UDP driver.

Author:

    Mike Massa (mikemas)           Aug 13, 1993

Revision History:

    Who         When        What
    --------    --------    ----------------------------------------------
    mikemas     08-13-93    created

Notes:

--*/

#include "precomp.h"

#if !MILLEN
#include <ipfilter.h>
#include <ipsec.h>
#endif // !MILLEN

#include "tdint.h"
#include "addr.h"
#include "tcp.h"
#include "tcb.h"
#include "udp.h"
#include "raw.h"
#include "tcpconn.h"
#include "mdlpool.h"
#include "pplasl.h"
#include "tcprcv.h"
#include "tcpsend.h"
#include "tlcommon.h"
#include "tcpcfg.h"
#include "secfltr.h"
#include "info.h"

#if GPC
#include <qos.h>
#include <traffic.h>
#include "gpcifc.h"
#include "ntddtc.h"

GPC_HANDLE hGpcClient[GPC_CF_MAX] = {0};
ulong GpcCfCounts[GPC_CF_MAX] = {0};
GPC_EXPORTED_CALLS GpcEntries;
GPC_CLIENT_FUNC_LIST GpcHandlers;

ulong GPCcfInfo = 0;


GPC_STATUS GPCcfInfoAddNotifyIpsec(GPC_CLIENT_HANDLE ClCtxt,
                                   GPC_HANDLE GpcHandle,
                                   PTC_INTERFACE_ID InterfaceInfo,
                                   ULONG CfInfoSize,
                                   PVOID CfInfo,
                                   PGPC_CLIENT_HANDLE pClInfoCxt);

GPC_STATUS GPCcfInfoRemoveNotifyIpsec(GPC_CLIENT_HANDLE ClCtxt,
                                      GPC_CLIENT_HANDLE ClInfoCxt);

GPC_STATUS GPCcfInfoAddNotifyQoS(GPC_CLIENT_HANDLE ClCtxt,
                                 GPC_HANDLE GpcHandle,
                                 PTC_INTERFACE_ID InterfaceInfo,
                                 ULONG CfInfoSize,
                                 PVOID CfInfo,
                                 PGPC_CLIENT_HANDLE pClInfoCxt);

GPC_STATUS GPCcfInfoRemoveNotifyQoS(GPC_CLIENT_HANDLE ClCtxt,
                                    GPC_CLIENT_HANDLE ClInfoCxt);

#endif

ReservedPortListEntry *PortRangeList = NULL;

VOID
GetReservedPortList(
                    NDIS_HANDLE ConfigHandle
                    );

//
// Global variables.
//
PDRIVER_OBJECT TCPDriverObject = NULL;
PDEVICE_OBJECT TCPDeviceObject = NULL;
PDEVICE_OBJECT UDPDeviceObject = NULL;
PDEVICE_OBJECT RawIPDeviceObject = NULL;

extern PDEVICE_OBJECT IPDeviceObject;

TCPXSUM_ROUTINE tcpxsum_routine = tcpxsum;

#if ACC
PSECURITY_DESCRIPTOR TcpAdminSecurityDescriptor;
extern uint AllowUserRawAccess;

typedef ULONG SECURITY_INFORMATION;

BOOLEAN
IsRunningOnPersonal (
    VOID
    );

#endif

extern uint DisableLargeSendOffload;

//
//Place holder for Maximum duplicate acks we would like
//to see before we do fast retransmit
//
extern uint MaxDupAcks;

MM_SYSTEMSIZE systemSize;

extern uint MaxHashTableSize;
extern uint NumTcbTablePartitions;
extern uint PerPartitionSize;
extern uint LogPerPartitionSize;
#define CACHE_LINE_SIZE 64
#define CACHE_ALIGN_MASK (~(CACHE_LINE_SIZE-1))

CTELock *pTWTCBTableLock;
CTELock *pTCBTableLock;

CTELock *pSynTCBTableLock;

extern Queue *TWQueue;

extern Queue *TWTCBTable;
extern TCB **TCBTable;
extern Queue *SYNTCBTable;

extern PTIMER_WHEEL TimerWheel;
PTIMER_WHEEL OrgTimerWheel;

extern TCPConn **ConnTable;
extern uint MaxConnBlocks;
extern uint ConnPerBlock;

extern uint GlobalMaxRcvWin;

extern uint TcpHostOpts;
extern uint TcpHostSendOpts;

HANDLE TCPRegistrationHandle;
HANDLE UDPRegistrationHandle;
HANDLE IPRegistrationHandle;


//SynAttackProtect=0 no syn flood attack protection
//SynAttackProtect !0  syn flood attack protection
//SynAttackProtect !0 syn flood attack protection+forced(non-dynamic)

//                   delayed connect acceptance

uint SynAttackProtect;        // SYN-attack protection checks are made

uint TCPMaxHalfOpen;            //Max # of half-open connections allowed
                                    //  before we dec. the syn-ack retries
uint TCPMaxHalfOpenRetried;        //Max # of half-open conn. that have
                                    //  been retried at least 1 time
uint TCPMaxHalfOpenRetriedLW;    //Low-watermark of the above. When
                                    //  go down to it, we revert to normal
                                    //  # of retries for syn-acks
uint TCPHalfOpen;                //# of half-open connections
uint TCPHalfOpenRetried;        //# of half-open conn. that have been
                                    //retried at least once

PDEVICE_OBJECT  IPSECDeviceObject;
PFILE_OBJECT    IPSECFileObject;

extern uint Time_Proc;

extern HANDLE TcbPool;
extern HANDLE TimewaitTcbPool;
extern HANDLE SynTcbPool;

extern void ArpUnload(PDRIVER_OBJECT);
extern CTETimer TCBTimer[];
extern BOOLEAN fTCBTimerStopping;
extern CTEBlockStruc TcpipUnloadBlock;
HANDLE AddressChangeHandle;

extern ulong DefaultTOSValue;
extern ulong DisableUserTOSSetting;
extern uint MaxSendSegments;

//
// External function prototypes
//

int
tlinit(
       void
       );

NTSTATUS
TCPDispatch(
            IN PDEVICE_OBJECT DeviceObject,
            IN PIRP Irp
            );

NTSTATUS
TCPDispatchInternalDeviceControl(
                                 IN PDEVICE_OBJECT DeviceObject,
                                 IN PIRP Irp
                                 );

NTSTATUS
IPDispatch(
           IN PDEVICE_OBJECT DeviceObject,
           IN PIRP Irp
           );

NTSTATUS
IPDriverEntry(
              IN PDRIVER_OBJECT DriverObject,
              IN PUNICODE_STRING RegistryPath
              );

NTSTATUS
IPPostDriverEntry(
                  IN PDRIVER_OBJECT DriverObject,
                  IN PUNICODE_STRING RegistryPath
                  );

NTSTATUS
GetRegMultiSZValue(
                   HANDLE KeyHandle,
                   PWCHAR ValueName,
                   PUNICODE_STRING ValueData
                   );

PWCHAR
EnumRegMultiSz(
               IN PWCHAR MszString,
               IN ULONG MszStringLength,
               IN ULONG StringIndex
               );


uint InitIsnGenerator();
#if !MILLEN
extern ulong g_cRandIsnStore;
#endif // !MILLEN


#if MILLEN
extern VOID InitializeWDebDebug();
#endif // MILLEN

        //
// Local funcion prototypes
//
NTSTATUS
DriverEntry(
            IN PDRIVER_OBJECT DriverObject,
            IN PUNICODE_STRING RegistryPath
            );

void *
TLRegisterProtocol(
                    uchar Protocol,
                    void *RcvHandler,
                    void *XmitHandler,
                    void *StatusHandler,
                    void *RcvCmpltHandler,
                    void *PnPHandler,
                    void *ElistHandler
                    );

IP_STATUS
TLGetIPInfo(
            IPInfo * Buffer,
            int Size
            );

uchar
TCPGetConfigInfo(
                 void
                 );

NTSTATUS
TCPInitializeParameter(
                       HANDLE KeyHandle,
                       PWCHAR ValueName,
                       PULONG Value
                       );

#if !MILLEN
NTSTATUS
IpsecInitialize(
          void
          );

NTSTATUS
IpsecDeinitialize(
            void
            );
#endif

#if !MILLEN
#ifdef i386
NTSTATUS
TCPSetChecksumRoutine(
                      VOID
                      );
#endif
#endif // !MILLEN

uint
EnumSecurityFilterValue(
                        PNDIS_STRING FilterList,
                        ulong Index,
                        ulong * FilterValue
                        );


VOID
TCPAcdBind();

#ifdef ACC

typedef ULONG SECURITY_INFORMATION;

NTSTATUS
TcpBuildDeviceAcl(
                  OUT PACL * DeviceAcl
                  );

NTSTATUS
TcpCreateAdminSecurityDescriptor(
                                 VOID
                                 );

NTSTATUS
AddNetConfigOpsAce(IN PACL Dacl,
                  OUT PACL * DeviceAcl
                  );
NTSTATUS
CreateDeviceDriverSecurityDescriptor(PVOID DeviceOrDriverObject
                                     );

#endif // ACC


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, TLRegisterProtocol)
#pragma alloc_text(INIT, TLGetIPInfo)
#pragma alloc_text(INIT, TCPGetConfigInfo)
#pragma alloc_text(INIT, TCPInitializeParameter)

#if !MILLEN
#pragma alloc_text(INIT, IpsecInitialize)
#endif

#if !MILLEN
#ifdef i386
#pragma alloc_text(INIT, TCPSetChecksumRoutine)
#endif
#endif // !MILLEN

#pragma alloc_text(PAGE, EnumSecurityFilterValue)

#pragma alloc_text(INIT, TCPAcdBind)

#ifdef ACC
#pragma alloc_text(INIT, TcpBuildDeviceAcl)
#pragma alloc_text(INIT, TcpCreateAdminSecurityDescriptor)
#pragma alloc_text(INIT, AddNetConfigOpsAce)
#pragma alloc_text(INIT, CreateDeviceDriverSecurityDescriptor)
#endif // ACC

#endif


//
// Function definitions
//
NTSTATUS
DriverEntry(
            IN PDRIVER_OBJECT DriverObject,
            IN PUNICODE_STRING RegistryPath
            )
/*++

Routine Description:

    Initialization routine for the TCP/UDP driver.

Arguments:

    DriverObject      - Pointer to the TCP driver object created by the system.
    DeviceDescription - The name of TCP's node in the registry.

Return Value:

    The final status from the initialization operation.

--*/

{
    NTSTATUS status;
    UNICODE_STRING deviceName;
    UNICODE_STRING SymbolicDeviceName;
    USHORT i;
    int initStatus;

    DEBUGMSGINIT();

    DEBUGMSG(DBG_TRACE && DBG_INIT,
        (DTEXT("+DriverEntry(%x, %x)\n"), DriverObject, RegistryPath));

    TdiInitialize();

    //
    // IP calls the security filter code, so initialize it first.
    //
    InitializeSecurityFilters();


    //
    // Initialize IP
    //
    status = IPDriverEntry(DriverObject, RegistryPath);

    if (!NT_SUCCESS(status)) {
        DEBUGMSG(DBG_ERROR && DBG_INIT,
            (DTEXT("TCPIP: IP Initialization failure %x\n"), status));
        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-DriverEntry [%x]\n"), status));
        return (status);
    }

#if !MILLEN
    //
    // Initialize IPSEC
    //
    status = IpsecInitialize();

    if (!NT_SUCCESS(status)) {
        DEBUGMSG(DBG_ERROR && DBG_INIT,
            (DTEXT("TCPIP: IPSEC Initialization failure %x\n"), status));
        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-DriverEntry [%x]\n"), status));

        goto init_failed;
    }
#endif

    //
    // Initialize TCP, UDP, and RawIP
    //
    TCPDriverObject = DriverObject;

    //
    // Create the device objects. IoCreateDevice zeroes the memory
    // occupied by the object.
    //

    RtlInitUnicodeString(&deviceName, DD_TCP_DEVICE_NAME);
    RtlInitUnicodeString(&SymbolicDeviceName, DD_TCP_SYMBOLIC_DEVICE_NAME);

    status = IoCreateDevice(
                            DriverObject,
                            0,
                            &deviceName,
                            FILE_DEVICE_NETWORK,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &TCPDeviceObject
                            );

    if (!NT_SUCCESS(status)) {
        CTELogEvent(
                    DriverObject,
                    EVENT_TCPIP_CREATE_DEVICE_FAILED,
                    1,
                    1,
                    &deviceName.Buffer,
                    0,
                    NULL
                    );

        DEBUGMSG(DBG_ERROR && DBG_INIT,
            (DTEXT("DriverEntry: failure %x to create TCP device object %ws\n"),
            status, DD_TCP_DEVICE_NAME));

        goto init_failed;
    }

    status = IoCreateSymbolicLink(&SymbolicDeviceName, &deviceName);

    if (!NT_SUCCESS(status)) {
        CTELogEvent(
                    DriverObject,
                    EVENT_TCPIP_CREATE_DEVICE_FAILED,
                    1,
                    1,
                    &deviceName.Buffer,
                    0,
                    NULL
                    );

        DEBUGMSG(DBG_ERROR && DBG_INIT,
            (DTEXT("DriverEntry: failure %x to create TCP symbolic device link %ws\n"),
            status, DD_TCP_SYMBOLIC_DEVICE_NAME));

        goto init_failed;
    }

    RtlInitUnicodeString(&deviceName, DD_UDP_DEVICE_NAME);

    status = IoCreateDevice(
                            DriverObject,
                            0,
                            &deviceName,
                            FILE_DEVICE_NETWORK,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &UDPDeviceObject
                            );

    if (!NT_SUCCESS(status)) {
        CTELogEvent(
                    DriverObject,
                    EVENT_TCPIP_CREATE_DEVICE_FAILED,
                    1,
                    1,
                    &deviceName.Buffer,
                    0,
                    NULL
                    );

        TCPTRACE((
                  "TCP: Failed to create UDP device object, status %lx\n",
                  status
                 ));
        goto init_failed;
    }
    RtlInitUnicodeString(&deviceName, DD_RAW_IP_DEVICE_NAME);

    status = IoCreateDevice(
                            DriverObject,
                            0,
                            &deviceName,
                            FILE_DEVICE_NETWORK,
                            FILE_DEVICE_SECURE_OPEN,
                            FALSE,
                            &RawIPDeviceObject
                            );

    if (!NT_SUCCESS(status)) {
        CTELogEvent(
                    DriverObject,
                    EVENT_TCPIP_CREATE_DEVICE_FAILED,
                    1,
                    1,
                    &deviceName.Buffer,
                    0,
                    NULL
                    );

        TCPTRACE((
                  "TCP: Failed to create Raw IP device object, status %lx\n",
                  status
                 ));
        goto init_failed;
    }
    //
    // Initialize the driver object
    //
    DriverObject->DriverUnload = ArpUnload;

    DriverObject->FastIoDispatch = NULL;
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = TCPDispatch;
    }

    //
    // We special case Internal Device Controls because they are the
    // hot path for kernel-mode clients.
    //
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
        TCPDispatchInternalDeviceControl;

    //
    // Intialize the device objects.
    //
    TCPDeviceObject->Flags |= DO_DIRECT_IO;
    UDPDeviceObject->Flags |= DO_DIRECT_IO;
    RawIPDeviceObject->Flags |= DO_DIRECT_IO;

#ifdef ACC

    // Change the different devices and Objects to allow access to Network Configuration Operators

    if (!IsRunningOnPersonal()) {

        status = CreateDeviceDriverSecurityDescriptor(IPDeviceObject);
        if (!NT_SUCCESS(status)) {
            goto init_failed;
        }

        status = CreateDeviceDriverSecurityDescriptor(TCPDeviceObject);
        if (!NT_SUCCESS(status)) {
            goto init_failed;
        }

        status = CreateDeviceDriverSecurityDescriptor(IPSECDeviceObject);
        if (!NT_SUCCESS(status)) {
            goto init_failed;
        }
    }

    //
    // Create the security descriptor used for raw socket access checks.
    //
    status = TcpCreateAdminSecurityDescriptor();

    if (!NT_SUCCESS(status)) {
        goto init_failed;
    }
#endif // ACC

#if !MILLEN
#ifdef i386
    //
    // Set the checksum routine pointer according to the processor available
    //
    TCPSetChecksumRoutine();
#endif
#endif // !MILLEN

    //
    // Finally, initialize the stack.
    //
    initStatus = tlinit();

    if (initStatus == TRUE) {
        //
        // Get the automatic connection driver
        // entry points.
        //
        TCPAcdBind();

        RtlInitUnicodeString(&deviceName, DD_TCP_DEVICE_NAME);
        (void)TdiRegisterDeviceObject(&deviceName, &TCPRegistrationHandle);

        RtlInitUnicodeString(&deviceName, DD_UDP_DEVICE_NAME);
        (void)TdiRegisterDeviceObject(&deviceName, &UDPRegistrationHandle);

        RtlInitUnicodeString(&deviceName, DD_RAW_IP_DEVICE_NAME);
        (void)TdiRegisterDeviceObject(&deviceName, &IPRegistrationHandle);

#if GPC
        status = GpcInitialize(&GpcEntries);

        if (!NT_SUCCESS(status)) {

            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"GpcInitialize Failed! Status: 0x%x\n", status));

            //return status;
        } else {
            //
            // Need to register as GPC client. Try it now.
            // we register clients for QOS and IPSEC
            //

            memset(&GpcHandlers, 0, sizeof(GPC_CLIENT_FUNC_LIST));

            GpcHandlers.ClAddCfInfoNotifyHandler = GPCcfInfoAddNotifyQoS;
            GpcHandlers.ClRemoveCfInfoNotifyHandler = GPCcfInfoRemoveNotifyQoS;

            status = GpcEntries.GpcRegisterClientHandler(
                                                         GPC_CF_QOS,    // classification family
                                                          0,    // flags
                                                          1,    // default max priority
                                                          &GpcHandlers,        // client notification vector - no notifications to TCPIP required
                                                          0,    // client context, not needed
                                                          &hGpcClient[GPC_CF_QOS]);

            if (!NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"GPC registerclient QOS status %x hGpcClient %p\n",
                         status, hGpcClient[GPC_CF_QOS]));
                hGpcClient[GPC_CF_QOS] = NULL;
            }
            GpcHandlers.ClAddCfInfoNotifyHandler = GPCcfInfoAddNotifyIpsec;
            GpcHandlers.ClRemoveCfInfoNotifyHandler = GPCcfInfoRemoveNotifyIpsec;

            status = GpcEntries.GpcRegisterClientHandler(
                                                         GPC_CF_IPSEC,    // classification family
                                                          0,    // flags
                                                          GPC_PRIORITY_IPSEC,    // default max priority
                                                          &GpcHandlers,        // client notification vector - no notifications to TCPIP required
                                                          0,    // client context, not needed
                                                          &hGpcClient[GPC_CF_IPSEC]);

            if (!NT_SUCCESS(status)) {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"GPC registerclient IPSEC status %x hGpcClient %p\n",
                         status, hGpcClient[GPC_CF_IPSEC]));
                hGpcClient[GPC_CF_IPSEC] = NULL;
            }
        }
#endif

        if (InitIsnGenerator() == FALSE) {
            DEBUGMSG(DBG_ERROR && DBG_INIT,
                (DTEXT("InitIsnGenerator failure. TCP/IP failing to start.\n")));
            DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-DriverEntry [%x]\n"), status));
            return (STATUS_UNSUCCESSFUL);
        }

        // do the ndis register protocol now after all the intialization
        // is complete, o/w we get bindadapter even before we r fully
        // initialized.
        status = IPPostDriverEntry(DriverObject, RegistryPath);
        if (!NT_SUCCESS(status)) {

            DEBUGMSG(DBG_ERROR && DBG_INIT,
                (DTEXT("TCPIP: IP post-init failure %x\n"), status));
            DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-DriverEntry [%x]\n"), status));
            return (status);
        }

// Millennium TCPIP has debugger extensions built in!
#if MILLEN
        InitializeWDebDebug();
#endif // MILLEN

#if TRACE_EVENT
        //
        // Register with WMI for Enable/Disable Notification
        // of Trace Logging
        //
        TCPCPHandlerRoutine = NULL;

        IoWMIRegistrationControl(
                                 TCPDeviceObject,
                                 WMIREG_ACTION_REGISTER |
                                 WMIREG_FLAG_TRACE_PROVIDER |
                                 WMIREG_NOTIFY_TDI_IO
                                 );
#endif

        //
        // Initialize the connection callback object. We do not treat its
        // failure as fatal, and continue to function even in case of failure.
        // We may log it in the future.
        //
        TcpInitCcb();


        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-DriverEntry [SUCCESS]\n")));
        return (STATUS_SUCCESS);
    }

    DEBUGMSG(DBG_ERROR && DBG_INIT,
        (DTEXT("TCPIP: TCP initialization failed, IP still available.\n")));

    CTELogEvent(
                DriverObject,
                EVENT_TCPIP_TCP_INIT_FAILED,
                1,
                0,
                NULL,
                0,
                NULL
                );
    status = STATUS_UNSUCCESSFUL;

  init_failed:

    DEBUGMSG(DBG_ERROR && DBG_INIT,
        (DTEXT("TCPIP DriverEntry initialization failure!\n")));
    //
    // IP has successfully started, but TCP & UDP failed. Set the
    // Dispatch routine to point to IP only, since the TCP and UDP
    // devices don't exist.
    //

    if (TCPDeviceObject != NULL) {
        IoDeleteDevice(TCPDeviceObject);
    }
    if (UDPDeviceObject != NULL) {
        IoDeleteDevice(UDPDeviceObject);
    }
    if (RawIPDeviceObject != NULL) {
        IoDeleteDevice(RawIPDeviceObject);
    }
    for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++) {
        DriverObject->MajorFunction[i] = IPDispatch;
    }

#if !MILLEN
    if (IPSECFileObject) {
        IpsecDeinitialize();
    }
#endif

    return (status);
}

#if !MILLEN
#ifdef i386

NTSTATUS
TCPSetChecksumRoutine(
                      VOID
                      )
/*++

Routine Description:

    This routine sets the checksum routine function pointer to the
    appropriate routine based on the processor features available

Arguments:

    None

Return Value:

    STATUS_SUCCESS - if successful

--*/

{

    NTSTATUS Status = STATUS_INSUFFICIENT_RESOURCES;

    if (ExIsProcessorFeaturePresent(PF_XMMI_INSTRUCTIONS_AVAILABLE)) {
        tcpxsum_routine = tcpxsum_xmmi;
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"tcpip: Loading XMMI Prefetch Checksum\n"));
        Status = STATUS_SUCCESS;
    }
    return Status;

}

#endif
#endif // !MILLEN

IP_STATUS
TLGetIPInfo(
            IPInfo * Buffer,
            int Size
            )
/*++

Routine Description:

    Returns information necessary for TCP to call into IP.

Arguments:

    Buffer  - A pointer to the IP information structure.

    Size    - The size of Buffer.

Return Value:

    The IP status of the operation.

--*/

{
    return (IPGetInfo(Buffer, Size));
}

void *
TLRegisterProtocol(
                   uchar Protocol,
                   void *RcvHandler,
                   void *XmitHandler,
                   void *StatusHandler,
                   void *RcvCmpltHandler,
                   void *PnPHandler,
                   void *ElistHandler
                   )
/*++

Routine Description:

    Calls the IP driver's protocol registration function.

Arguments:

    Protocol        -  The protocol number to register.

    RcvHandler      -  Transport's packet receive handler.

    XmitHandler     -  Transport's packet transmit complete handler.

    StatusHandler   -  Transport's status update handler.

    RcvCmpltHandler -  Transport's receive complete handler

Return Value:

    A context value for the protocol to pass to IP when transmitting.

--*/

{
    return (IPRegisterProtocol(
                               Protocol,
                               RcvHandler,
                               XmitHandler,
                               StatusHandler,
                               RcvCmpltHandler,
                               PnPHandler,
                               ElistHandler));
}

//
// Interval in milliseconds between keepalive transmissions until a
// response is received.
//
#define DEFAULT_KEEPALIVE_INTERVAL  1000


//
// time to first keepalive transmission. 2 hours == 7,200,000 milliseconds
//
#define DEFAULT_KEEPALIVE_TIME      7200000


#define MIN_THRESHOLD_MAX_HO          1
#define MIN_THRESHOLD_MAX_HO_RETRIED  80

uchar
TCPGetConfigInfo(
                 void
                 )
/*++

Routine Description:

    Initializes TCP global configuration parameters.

Arguments:

    None.

Return Value:

    Zero on failure, nonzero on success.

--*/

{
    HANDLE keyHandle;
    NTSTATUS status;
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING UKeyName;
    ULONG maxConnectRexmits = 0;
    ULONG maxConnectResponseRexmits = 0;
    ULONG maxDataRexmits = 0;
    ULONG pptpmaxDataRexmits = 0;
    ULONG useRFC1122UrgentPointer = 0;
    ULONG tcp1323opts = 3;        //turning off 1323 options by default
    ULONG SackOpts;
    ULONG i, j;

    DEBUGMSG(DBG_TRACE && DBG_INIT,
        (DTEXT("+TCPGetConfigInfo()\n")));

    //
    // Initialize to the defaults in case an error occurs somewhere.
    //
    KAInterval = DEFAULT_KEEPALIVE_INTERVAL;
    KeepAliveTime = DEFAULT_KEEPALIVE_TIME;
    PMTUDiscovery = TRUE;
    PMTUBHDetect = FALSE;
    DeadGWDetect = TRUE;
    DefaultRcvWin = 0;            // Automagically pick a reasonable one.

    MaxConnections = DEFAULT_MAX_CONNECTIONS;
    maxConnectRexmits = MAX_CONNECT_REXMIT_CNT;
    maxConnectResponseRexmits = MAX_CONNECT_RESPONSE_REXMIT_CNT;
    pptpmaxDataRexmits = maxDataRexmits = MAX_REXMIT_CNT;
    BSDUrgent = TRUE;
    FinWait2TO = FIN_WAIT2_TO;
    NTWMaxConnectCount = NTW_MAX_CONNECT_COUNT;
    NTWMaxConnectTime = NTW_MAX_CONNECT_TIME;
    MaxUserPort = DEFAULT_MAX_USER_PORT;

//  Default number of duplicate acks
    MaxDupAcks = 2;

    SynAttackProtect = 0;    //by default it is always off

#if MILLEN
    TCPMaxHalfOpen = 100;
    TCPMaxHalfOpenRetried = 80;
#else // MILLEN
    if (!MmIsThisAnNtAsSystem()) {
        TCPMaxHalfOpen = 100;
        TCPMaxHalfOpenRetried = 80;
    } else {
        TCPMaxHalfOpen = 500;
        TCPMaxHalfOpenRetried = 400;
    }
#endif // !MILLEN

    SecurityFilteringEnabled = FALSE;

#ifdef ACC
    AllowUserRawAccess = FALSE;
#endif

    //
    // Read the TCP optional (hidden) registry parameters.
    //
#if !MILLEN
    RtlInitUnicodeString(
                         &UKeyName,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\Tcpip\\Parameters"
                         );
#else // !MILLEN
    RtlInitUnicodeString(
                         &UKeyName,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\VxD\\MSTCP"
                         );
#endif // MILLEN

    DEBUGMSG(DBG_INFO && DBG_INIT,
        (DTEXT("TCPGetConfigInfo: Opening key %ws\n"), UKeyName.Buffer));

    memset(&objectAttributes, 0, sizeof(OBJECT_ATTRIBUTES));

    InitializeObjectAttributes(
                               &objectAttributes,
                               &UKeyName,
                               OBJ_CASE_INSENSITIVE | OBJ_KERNEL_HANDLE,
                               NULL,
                               NULL
                               );

    status = ZwOpenKey(
                       &keyHandle,
                       KEY_READ,
                       &objectAttributes
                       );

    DEBUGMSG(!NT_SUCCESS(status) && DBG_ERROR,
        (DTEXT("TCPGetConfigInfo: failed to open TCP registry configuration: %ws\n"),
         UKeyName.Buffer));

    if (NT_SUCCESS(status)) {

        DEBUGMSG(DBG_INFO && DBG_INIT,
            (DTEXT("TCPGetConfigInfo: successfully opened registry to read.\n")));
#if !MILLEN
        TCPInitializeParameter(
                               keyHandle,
                               L"IsnStoreSize",
                               &g_cRandIsnStore
                               );
#endif // !MILLEN

        TCPInitializeParameter(
                               keyHandle,
                               L"KeepAliveInterval",
                               (PULONG)&KAInterval
                               );

        TCPInitializeParameter(
                               keyHandle,
                               L"KeepAliveTime",
                               (PULONG)&KeepAliveTime
                               );

        status = TCPInitializeParameter(
                               keyHandle,
                               L"EnablePMTUBHDetect",
                               (PULONG)&PMTUBHDetect
                               );

#if MILLEN
        //
        // Backwards compatibility. If 'EnablePMTUBHDetect' value does not exist,
        // then attempt to read legacy 'PMTUBlackHoleDetect'.
        //
        if (!NT_SUCCESS(status)) {
            TCPInitializeParameter(
                                   keyHandle,
                                   L"PMTUBlackHoleDetect",
                                   &PMTUBHDetect
                                   );
        }
#endif // MILLEN

        status = TCPInitializeParameter(
                                        keyHandle,
                                        L"TcpWindowSize",
                                        (PULONG)&DefaultRcvWin
                                        );

#if MILLEN
        //
        // Backwards compatibility. If 'TcpWindowSize' value does not exist,
        // then attempt to read legacy 'DefaultRcvWindow'.
        //
        if (!NT_SUCCESS(status)) {
            TCPInitializeParameter(
                                   keyHandle,
                                   L"DefaultRcvWindow",
                                   &DefaultRcvWin
                                   );
        }
#endif // MILLEN

        // We can not have negative size windows
        if ( (LONG) DefaultRcvWin < 0 ) {
            DefaultRcvWin = TCP_MAX_SCALED_WIN;
        }

        status = TCPInitializeParameter(
                                        keyHandle,
                                        L"TcpNumConnections",
                                        (PULONG)&MaxConnections
                                        );

#if MILLEN

        //
        // Backwards compatibility. If 'TcpNumConnections' value does not exist,
        // then attempt to read legacy 'MaxConnections'.
        //
        if (!NT_SUCCESS(status)) {
            TCPInitializeParameter(
                                   keyHandle,
                                   L"MaxConnections",
                                   &MaxConnections
                                   );
        }
#endif // MILLEN

        status = TCPInitializeParameter(
                                        keyHandle,
                                        L"TcpMaxConnectRetransmissions",
                                        &maxConnectRexmits
                                        );

#if MILLEN
        //
        // Backwards compatibility. If 'TcpMaxConnectRetransmissions' value does not exist,
        // then attempt to read legacty 'MaxConnectRetries'.
        //
        if (!NT_SUCCESS(status)) {
            TCPInitializeParameter(
                                   keyHandle,
                                   L"MaxConnectRetries",
                                   &maxConnectRexmits
                                   );
        }
#endif // MILLEN

        if (maxConnectRexmits > 255) {
            maxConnectRexmits = 255;
        }
        TCPInitializeParameter(
                               keyHandle,
                               L"TcpMaxConnectResponseRetransmissions",
                               &maxConnectResponseRexmits
                               );

        if (maxConnectResponseRexmits > 255) {
            maxConnectResponseRexmits = 255;
        }

        status = TCPInitializeParameter(
                                        keyHandle,
                                        L"TcpMaxDataRetransmissions",
                                        &maxDataRexmits
                                        );

#if MILLEN
        //
        // Backwards compatibility. If 'TcpMaxDataRetransmissions' value does not exist,
        // then attempt to read legacy 'MaxDataRetries'.
        //
        if (!NT_SUCCESS(status)) {
            TCPInitializeParameter(
                                   keyHandle,
                                   L"MaxDataRetries",
                                   &maxDataRexmits
                                   );
        }
#endif // MILLEN

        if (maxDataRexmits > 255) {
            maxDataRexmits = 255;
        }
        // Limit the MaxDupAcks to 3

        status = TCPInitializeParameter(
                                        keyHandle,
                                        L"TcpMaxDupAcks",
                                        (PULONG)&MaxDupAcks
                                        );

#if MILLEN
        //
        // Backwards compatibility. If 'TcpMaxDupAcks' value does not exist,
        // then attempt to read legacy 'MaxDupAcks'.
        //
        if (!NT_SUCCESS(status)) {
            TCPInitializeParameter(
                                   keyHandle,
                                   L"MaxDupAcks",
                                   &MaxDupAcks
                                   );
        }
#endif // MILLEN

        if (MaxDupAcks > 3) {
            MaxDupAcks = 3;
        }
        if (MaxDupAcks == 0) {
            MaxDupAcks = 1;
        }

#if MILLEN
        MaxConnBlocks = 16;
#else // MILLEN

        systemSize = MmQuerySystemSize();

        if (MmIsThisAnNtAsSystem()) {

            if (systemSize == MmSmallSystem) {
                MaxConnBlocks = 128;
            } else if (systemSize == MmMediumSystem) {
                MaxConnBlocks = 256;
            } else {
#if defined(_WIN64)
                MaxConnBlocks = 4096;
#else
                MaxConnBlocks = 1024;
#endif
            }
        } else {
            //for workstation, small system limit default number of connections to 4K.
            // medium system 8k
            // Large system 32k connections

            if (systemSize == MmSmallSystem) {
                MaxConnBlocks = 16;
            } else if (systemSize == MmMediumSystem) {
                MaxConnBlocks = 32;
            } else {
                MaxConnBlocks = 128;
            }
        }
#endif // !MILLEN


#if MILLEN
        NumTcbTablePartitions = 1;
#else
        NumTcbTablePartitions = (KeNumberProcessors * KeNumberProcessors);
#endif

        TCPInitializeParameter(
                               keyHandle,
                               L"NumTcbTablePartitions",
                               (PULONG)&NumTcbTablePartitions
                               );
        if (NumTcbTablePartitions > (MAXIMUM_PROCESSORS * MAXIMUM_PROCESSORS)) {
            NumTcbTablePartitions = (MAXIMUM_PROCESSORS * MAXIMUM_PROCESSORS);
        }
        NumTcbTablePartitions = ComputeLargerOrEqualPowerOfTwo(NumTcbTablePartitions);


        // Default to 128 buckets per partition
        MaxHashTableSize = 128 * NumTcbTablePartitions;

        TCPInitializeParameter(
                               keyHandle,
                               L"MaxHashTableSize",
                               (PULONG)&MaxHashTableSize
                               );

        if (MaxHashTableSize < 64) {
            MaxHashTableSize = 64;
        } else if (MaxHashTableSize > 0xffff) {
            MaxHashTableSize = 0x10000;
        }
        MaxHashTableSize = ComputeLargerOrEqualPowerOfTwo(MaxHashTableSize);
        if (MaxHashTableSize < NumTcbTablePartitions) {
            MaxHashTableSize = 128 * NumTcbTablePartitions;
        }
        ASSERT(IsPowerOfTwo(MaxHashTableSize));

        //since hash table size is power of 2 and cache line size
        //is power of 2 and number of partion is even,
        //entries per partions will be power of 2 and multiple of
        //cache line size.

        PerPartitionSize = MaxHashTableSize / NumTcbTablePartitions;
        ASSERT(IsPowerOfTwo(PerPartitionSize));
        LogPerPartitionSize =
            ComputeShiftForLargerOrEqualPowerOfTwo(PerPartitionSize);

        status = TCPInitializeParameter(
                                        keyHandle,
                                        L"Tcp1323Opts",
                                        &tcp1323opts
                                        );

        if (status == STATUS_SUCCESS) {

            // Check if TS  and/or WS options
            // are enabled.

            TcpHostOpts = TCP_FLAG_WS | TCP_FLAG_TS;

            if (!(tcp1323opts & TCP_FLAG_TS)) {
                TcpHostOpts &= ~TCP_FLAG_TS;
            }
            if (!(tcp1323opts & TCP_FLAG_WS)) {
                TcpHostOpts &= ~TCP_FLAG_WS;

            }

            TcpHostSendOpts = TcpHostOpts;

        } else {
            TcpHostSendOpts = 0;
        }

        TcpHostOpts  |= TCP_FLAG_SACK;

        status = TCPInitializeParameter(
                                        keyHandle,
                                        L"SackOpts",
                                        &SackOpts
                                        );

        if (status == STATUS_SUCCESS) {
            //Check if Sack option is enabled
            //If so, set it in  global options variable

            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Sackopts %x\n", SackOpts));

            if (!SackOpts) {
                TcpHostOpts &= ~TCP_FLAG_SACK;
            }
        }

        TCPInitializeParameter(
                               keyHandle,
                               L"GlobalMaxTcpWindowSize",
                               (PULONG)&GlobalMaxRcvWin
                               );


        TCPInitializeParameter(
                               keyHandle,
                               L"SynAttackProtect",
                               (unsigned long *)&SynAttackProtect
                               );

        if (SynAttackProtect) {

            TCPInitializeParameter(
                                   keyHandle,
                                   L"TCPMaxHalfOpen",
                                   (PULONG)&TCPMaxHalfOpen
                                   );

            if (TCPMaxHalfOpen < MIN_THRESHOLD_MAX_HO) {
                TCPMaxHalfOpen = MIN_THRESHOLD_MAX_HO;
            }
            TCPInitializeParameter(
                                   keyHandle,
                                   L"TCPMaxHalfOpenRetried",
                                   (PULONG)&TCPMaxHalfOpenRetried
                                   );

            if ((TCPMaxHalfOpenRetried > TCPMaxHalfOpen) ||
                (TCPMaxHalfOpenRetried < MIN_THRESHOLD_MAX_HO_RETRIED)) {
                TCPMaxHalfOpenRetried = MIN_THRESHOLD_MAX_HO_RETRIED;
            }
            TCPMaxHalfOpenRetriedLW = (TCPMaxHalfOpenRetried >> 1) +
                (TCPMaxHalfOpenRetried >> 2);
        }
        //
        // If we fail, then set to same value as maxDataRexmit so that the
        // max(pptpmaxDataRexmit,maxDataRexmit) is a decent value
        // Need this since TCPInitializeParameter no longer "initializes"
        // to a default value
        //

        if (TCPInitializeParameter(keyHandle,
                                   L"PPTPTcpMaxDataRetransmissions",
                                   &pptpmaxDataRexmits) != STATUS_SUCCESS) {
            pptpmaxDataRexmits = maxDataRexmits;
        }
        if (pptpmaxDataRexmits > 255) {
            pptpmaxDataRexmits = 255;
        }

        status = TCPInitializeParameter(
                               keyHandle,
                               L"TcpUseRFC1122UrgentPointer",
                               &useRFC1122UrgentPointer
                               );

#if MILLEN
        //
        // Backwards compatibility. If TcpUseRFC1122UrgentPointer does not exist,
        // then check for BSDUrgent. These values are logical opposites.
        //
        if (!NT_SUCCESS(status)) {
            ULONG tmpBsdUrgent = TRUE;

            status = TCPInitializeParameter(
                keyHandle,
                L"BSDUrgent",
                &tmpBsdUrgent);

            if (NT_SUCCESS(status)) {
                useRFC1122UrgentPointer = !tmpBsdUrgent;
            }
        }
#endif

        if (useRFC1122UrgentPointer) {
            BSDUrgent = FALSE;
        }
        TCPInitializeParameter(
                               keyHandle,
                               L"TcpTimedWaitDelay",
                               (PULONG)&FinWait2TO
                               );

        if (FinWait2TO > 300) {
            FinWait2TO = 300;
        }
        FinWait2TO = MS_TO_TICKS(FinWait2TO * 1000);

        NTWMaxConnectTime = MS_TO_TICKS(NTWMaxConnectTime * 1000);

        TCPInitializeParameter(
                               keyHandle,
                               L"MaxUserPort",
                               (PULONG)&MaxUserPort
                               );

        if (MaxUserPort < 5000) {
            MaxUserPort = 5000;
        }
        if (MaxUserPort > 65534) {
            MaxUserPort = 65534;
        }
        GetReservedPortList(keyHandle);

        //Reserve ports if

        //
        // Read a few IP optional (hidden) registry parameters that TCP
        // cares about.
        //
        status = TCPInitializeParameter(
                               keyHandle,
                               L"EnablePMTUDiscovery",
                               (PULONG)&PMTUDiscovery
                               );

#if MILLEN
        //
        // Backwards compatibility. If 'EnablePMTUDiscovery' value does not exist,
        // then attempt to read legacy 'PMTUDiscovery'.
        //
        if (!NT_SUCCESS(status)) {
            TCPInitializeParameter(
                                   keyHandle,
                                   L"PMTUDiscovery",
                                   &PMTUDiscovery
                                   );
        }
#endif // MILLEN

        TCPInitializeParameter(
                               keyHandle,
                               L"EnableDeadGWDetect",
                               (PULONG)&DeadGWDetect
                               );

        TCPInitializeParameter(
                               keyHandle,
                               L"EnableSecurityFilters",
                               (PULONG)&SecurityFilteringEnabled
                               );

#ifdef ACC
        TCPInitializeParameter(
                               keyHandle,
                               L"AllowUserRawAccess",
                               (PULONG)&AllowUserRawAccess
                               );
#endif // ACC

        status = TCPInitializeParameter(
                                        keyHandle,
                                        L"DefaultTOSValue",
                                        &DefaultTOSValue
                                        );

#if MILLEN
        //
        // Backwards compatibility. Read 'DefaultTOS' if 'DefaultTOSValue' is
        // not present.
        //
        if (!NT_SUCCESS(status)) {
            TCPInitializeParameter(
                                   keyHandle,
                                   L"DefaultTOS",
                                   &DefaultTOSValue
                                   );
        }
#endif // MILLEN

        TCPInitializeParameter(
                               keyHandle,
                               L"DisableUserTOSSetting",
                               &DisableUserTOSSetting
                               );

        TCPInitializeParameter(
                               keyHandle,
                               L"MaxSendSegments",
                               (PULONG)&MaxSendSegments
                               );

        TCPInitializeParameter(
                               keyHandle,
                               L"DisableLargeSendOffload",
                               (PULONG)&DisableLargeSendOffload
                               );



        ZwClose(keyHandle);
    }
    MaxConnectRexmitCount = maxConnectRexmits;
    MaxConnectResponseRexmitCount = maxConnectResponseRexmits;
    MaxConnectResponseRexmitCountTmp = MaxConnectResponseRexmitCount;

    //
    // Use the greater of the two, hence both values should be valid
    //

    MaxDataRexmitCount = (maxDataRexmits > pptpmaxDataRexmits ? maxDataRexmits : pptpmaxDataRexmits);

    TWTCBTable = CTEAllocMemBoot(MaxHashTableSize * sizeof(*TWTCBTable));
    if (TWTCBTable == NULL) {
        ZwClose(keyHandle);
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Could  not allocate tw tcb table of size %x\n", MaxHashTableSize));
        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-TCPGetConfigInfo [failure]\n")));
        return (0);
    }
    for (i = 0; i < MaxHashTableSize; i++)
    {
        INITQ(&TWTCBTable[i]);
    }

    TCBTable = CTEAllocMemBoot(MaxHashTableSize * sizeof(*TCBTable));
    if (TCBTable == NULL) {
        ExFreePool(TWTCBTable);
        ZwClose(keyHandle);
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Could  not allocate tcb table of size %x\n", MaxHashTableSize));
        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-TCPGetConfigInfo [failure]\n")));
        return (0);
    }

    NdisZeroMemory(TCBTable, MaxHashTableSize * sizeof(*TCBTable));

    SYNTCBTable = CTEAllocMemBoot(MaxHashTableSize * sizeof(*SYNTCBTable));
    if (SYNTCBTable == NULL) {
        ExFreePool(TWTCBTable);
        ExFreePool(TCBTable);
        ZwClose(keyHandle);
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Could  not allocate syn tcb table of size %x\n", MaxHashTableSize));
        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-TCPGetConfigInfo [failure]\n")));
        return (0);
    }

    for (i = 0; i < MaxHashTableSize; i++)
    {
        INITQ(&SYNTCBTable[i]);
    }

    pSynTCBTableLock = CTEAllocMemBoot(NumTcbTablePartitions * sizeof(CTELock));
    if (pSynTCBTableLock == NULL) {
        ExFreePool(TCBTable);
        ExFreePool(TWTCBTable);
        ExFreePool(SYNTCBTable);
        ZwClose(keyHandle);
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Could  not allocate twtcb lock table \n"));
        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-TCPGetConfigInfo [failure]\n")));
        return (0);
    }

    pTWTCBTableLock = CTEAllocMemBoot(NumTcbTablePartitions * sizeof(CTELock));
    if (pTWTCBTableLock == NULL) {
        ExFreePool(TCBTable);
        ExFreePool(TWTCBTable);
        ExFreePool(SYNTCBTable);
        ExFreePool(pSynTCBTableLock);
        ZwClose(keyHandle);
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Could  not allocate twtcb lock table \n"));
        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-TCPGetConfigInfo [failure]\n")));
        return (0);
    }

    pTCBTableLock = CTEAllocMemBoot(NumTcbTablePartitions * sizeof(CTELock));
    if (pTCBTableLock == NULL) {
        ExFreePool(TCBTable);
        ExFreePool(TWTCBTable);
        ExFreePool(pTWTCBTableLock);
        ExFreePool(SYNTCBTable);
        ExFreePool(pSynTCBTableLock);
        ZwClose(keyHandle);
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Could  not allocate tcb lock table \n"));
        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-TCPGetConfigInfo [failure]\n")));
        return (0);
    }

    TWQueue = CTEAllocMemBoot(NumTcbTablePartitions * sizeof(Queue));
    if (TWQueue == NULL) {
        ExFreePool(TCBTable);
        ExFreePool(TWTCBTable);
        ExFreePool(pTWTCBTableLock);
        ExFreePool(SYNTCBTable);
        ExFreePool(pSynTCBTableLock);
        ExFreePool(pTCBTableLock);
        ZwClose(keyHandle);
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Could  not allocate Twqueue \n"));
        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-TCPGetConfigInfo [failure]\n")));
        return (0);

    }

    TimerWheel = CTEAllocMemBoot(NumTcbTablePartitions * sizeof(TIMER_WHEEL) + CACHE_LINE_SIZE);
    if (TimerWheel == NULL) {
        ExFreePool(TCBTable);
        ExFreePool(TWTCBTable);
        ExFreePool(pTWTCBTableLock);
        ExFreePool(SYNTCBTable);
        ExFreePool(pSynTCBTableLock);
        ExFreePool(pTCBTableLock);
        ExFreePool(TWQueue);
        ZwClose(keyHandle);
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Could  not allocate Twqueue \n"));
        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-TCPGetConfigInfo [failure]\n")));
        return (0);
    }
    OrgTimerWheel = TimerWheel;
    TimerWheel = (PTIMER_WHEEL)(((ULONG_PTR) TimerWheel + CACHE_LINE_SIZE) & CACHE_ALIGN_MASK);


    for (i = 0; i < NumTcbTablePartitions; i++) {
        CTEInitLock(&pTCBTableLock[i]);
        CTEInitLock(&pTWTCBTableLock[i]);
        CTEInitLock(&pSynTCBTableLock[i]);
        INITQ(&TWQueue[i])

        // Init the timer wheel
        CTEInitLock(&TimerWheel[i].tw_lock);

#ifdef  TIMER_TEST
    TimerWheel[i].tw_starttick = 0xfffff000;
#else
        TimerWheel[i].tw_starttick = 0;
#endif

        for(j = 0; j < TIMER_WHEEL_SIZE; j++) {
            INITQ(&TimerWheel[i].tw_timerslot[j])
        }
    }

    if (MaxConnections != DEFAULT_MAX_CONNECTIONS) {
        //make it even
        MaxConnBlocks = ((MaxConnections >> 1) << 1);

        //allow minimum of 1k level 1 conn blocks.
        //this gives minimum of 256K connections capability
        if (MaxConnBlocks < 1024) {
            MaxConnBlocks = 1024;
        }
    }

    ConnTable = CTEAllocMemBoot(MaxConnBlocks * sizeof(TCPConnBlock *));
    if (ConnTable == NULL) {
        ExFreePool(OrgTimerWheel);
        ExFreePool(TWQueue);
        ExFreePool(TCBTable);
        ExFreePool(TWTCBTable);
        ExFreePool(pTWTCBTableLock);
        ExFreePool(pTCBTableLock);
        ExFreePool(SYNTCBTable);
        ExFreePool(pSynTCBTableLock);
        ZwClose(keyHandle);
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Could  not allocate ConnTable \n"));
        DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-TCPGetConfigInfo [failure]\n")));
        return (0);
    }

    DEBUGMSG(DBG_TRACE && DBG_INIT, (DTEXT("-TCPGetConfigInfo [SUCCESS]\n")));
    return (1);
}

#define WORK_BUFFER_SIZE 256

extern NTSTATUS
GetRegDWORDValue(
                 HANDLE KeyHandle,
                 PWCHAR ValueName,
                 PULONG ValueData
                 );

NTSTATUS
TCPInitializeParameter(
                       HANDLE KeyHandle,
                       PWCHAR ValueName,
                       PULONG Value
                       )
/*++

Routine Description:

    Initializes a ULONG parameter from the registry or to a default
    parameter if accessing the registry value fails.

Arguments:

    KeyHandle    - An open handle to the registry key for the parameter.
    ValueName    - The UNICODE name of the registry value to read.
    Value        - The ULONG into which to put the data.
    DefaultValue - The default to assign if reading the registry fails.

Return Value:

    None.

--*/

{
    return (GetRegDWORDValue(KeyHandle, ValueName, Value));
}

VOID
GetReservedPortList(
                    NDIS_HANDLE ConfigHandle
                    )
{
    UNICODE_STRING PortList;
    PWCHAR nextRange;

    TDI_STATUS status;

    PortList.Buffer = CTEAllocMemBoot(WORK_BUFFER_SIZE * sizeof(WCHAR));

    if (!PortList.Buffer) {
        return;
    }
    PortList.Buffer[0] = UNICODE_NULL;
    PortList.Length = 0;
    PortList.MaximumLength = WORK_BUFFER_SIZE * sizeof(WCHAR);

    PortRangeList = NULL;

    if (PortList.Buffer) {

        NdisZeroMemory(PortList.Buffer, WORK_BUFFER_SIZE * sizeof(WCHAR));

        status = GetRegMultiSZValue(
                                    ConfigHandle,
                                    L"ReservedPorts",
                                    &PortList
                                    );

        if (NT_SUCCESS(status)) {

            for (nextRange = PortList.Buffer;
                 *nextRange != L'\0';
                 nextRange += wcslen(nextRange) + 1) {

                PWCHAR tmps = nextRange;
                USHORT upval = 0, loval = 0, tmpval = 0;
                BOOLEAN error = FALSE;
                ReservedPortListEntry *ListEntry;

                while (*tmps != L'\0') {
                    if (*tmps == L'-') {
                        tmps++;
                        loval = tmpval;
                        tmpval = 0;
                    }
                    if (*tmps >= L'0' && *tmps <= L'9') {
                        tmpval = tmpval * 10 + (*tmps - L'0');
                    } else {
                        error = TRUE;
                        break;
                    }
                    tmps++;
                }
                upval = tmpval;
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"loval %d upval %d\n", loval, upval));
                if (!error && (loval > 0) && (upval > 0) && (loval <= upval) &&
                    (upval <= MaxUserPort) && (loval <= MaxUserPort)) {

                    ListEntry = CTEAllocMemBoot(sizeof(ReservedPortListEntry));

                    if (ListEntry) {

                        //Insert this range.
                        //No need to take locks
                        //since we are at initialization.

                        ListEntry->UpperRange = upval;
                        ListEntry->LowerRange = loval;

                        ListEntry->next = PortRangeList;
                        PortRangeList = ListEntry;

                    }
                }
            }
        }
        CTEFreeMem(PortList.Buffer);

    }
}


TDI_STATUS
GetSecurityFilterList(
                      NDIS_HANDLE ConfigHandle,
                      ulong Protocol,
                      PNDIS_STRING FilterList
                      )
{
    PWCHAR parameterName;
    TDI_STATUS status;

    if (Protocol == PROTOCOL_TCP) {
        parameterName = L"TcpAllowedPorts";
    } else if (Protocol == PROTOCOL_UDP) {
        parameterName = L"UdpAllowedPorts";
    } else {
        parameterName = L"RawIpAllowedProtocols";
    }

    status = GetRegMultiSZValue(
                                ConfigHandle,
                                parameterName,
                                FilterList
                                );

    if (!NT_SUCCESS(status)) {
        FilterList->Length = 0;
    }
    return (status);
}

uint
EnumSecurityFilterValue(
                        PNDIS_STRING FilterList,
                        ulong Index,
                        ulong * FilterValue
                        )
{
    PWCHAR valueString;
    UNICODE_STRING unicodeString;
    NTSTATUS status;

    PAGED_CODE();

    valueString = EnumRegMultiSz(
                                 FilterList->Buffer,
                                 FilterList->Length,
                                 Index
                                 );

    if ((valueString == NULL) || (valueString[0] == UNICODE_NULL)) {
        return (FALSE);
    }
    RtlInitUnicodeString(&unicodeString, valueString);

    status = RtlUnicodeStringToInteger(&unicodeString, 0, FilterValue);

    if (!(NT_SUCCESS(status))) {
        TCPTRACE(("TCP: Invalid filter value %ws\n", valueString));
        return (FALSE);
    }
    return (TRUE);
}


VOID
TCPFreeupMemory()
/*++

Routine Description:

    This routine frees up the memory at the TCP layer

Arguments:

    NULL

Return Value:

    None.

--*/
{

    //
    // Walk various lists and free assoc blocks
    //

    // DG header list
    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Freeing DG headers....\n"));

    MdpDestroyPool(DgHeaderPool);

    if (AddrObjTable) {
        CTEFreeMem(AddrObjTable);
    }

    PplDestroyPool(TcbPool);
    PplDestroyPool(SynTcbPool);

#ifdef ACC
    if (TcpAdminSecurityDescriptor) {
        ExFreePool(TcpAdminSecurityDescriptor);
    }
#endif

}

VOID
TCPUnload(
          IN PDRIVER_OBJECT DriverObject
          )
/*++

Routine Description:

    This routine cleans up the TCP layer.

Arguments:

    DriverObject - Pointer to driver object created by the system.

Return Value:

    None. When the function returns, the driver is unloaded.

--*/
{
    NTSTATUS status;
    uint i;

    TcpUnInitCcb();

#if !MILLEN
    //
    // Deinitialize IPSEC first
    //
    status = IpsecDeinitialize();
#endif

    //
    // Shut down all timers/events
    //
    CTEInitBlockStrucEx(&TcpipUnloadBlock);
    fTCBTimerStopping = TRUE;

    for (i = 0; i < Time_Proc; i++) {
        if (!CTEStopTimer(&TCBTimer[i])) {
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Could not stop TCB timer - waiting on unload event\n"));

    #if !MILLEN
            if (KeReadStateEvent(&(TcpipUnloadBlock.cbs_event))) {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Event is signaled...\n"));
            }
    #endif // !MILLEN

            (VOID) CTEBlock(&TcpipUnloadBlock);
            KeClearEvent(&TcpipUnloadBlock.cbs_event);
        }
    }
#if GPC
    //
    if (hGpcClient[GPC_CF_QOS]) {

        status = GpcEntries.GpcDeregisterClientHandler(hGpcClient[GPC_CF_QOS]);
        hGpcClient[GPC_CF_QOS] = NULL;

    }
    if (hGpcClient[GPC_CF_IPSEC]) {

        status = GpcEntries.GpcDeregisterClientHandler(hGpcClient[GPC_CF_IPSEC]);
        hGpcClient[GPC_CF_IPSEC] = NULL;

    }
    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Deregistering GPC\n"));

    status = GpcDeinitialize(&GpcEntries);

#endif
    //
    // Clean up all residual memory
    //
    TCPFreeupMemory();

    //
    // Deregister address notifn handler with TDI
    //
    (void)TdiDeregisterPnPHandlers(AddressChangeHandle);

    //
    // Deregister our devices with TDI
    //
    (void)TdiDeregisterDeviceObject(TCPRegistrationHandle);

    (void)TdiDeregisterDeviceObject(UDPRegistrationHandle);

    (void)TdiDeregisterDeviceObject(IPRegistrationHandle);


#if TRACE_EVENT
    //
    // Deregister with WMI
    //

    IoWMIRegistrationControl(TCPDeviceObject, WMIREG_ACTION_DEREGISTER);
#endif

    //
    // Delete devices
    //
    IoDeleteDevice(TCPDeviceObject);
    IoDeleteDevice(UDPDeviceObject);
    IoDeleteDevice(RawIPDeviceObject);
}

#if GPC

GPC_STATUS
GPCcfInfoAddNotifyIpsec(GPC_CLIENT_HANDLE ClCtxt,
                        GPC_HANDLE GpcHandle,
                        PTC_INTERFACE_ID InterfaceInfo,
                        ULONG CfInfoSize,
                        PVOID CfInfo,
                        PGPC_CLIENT_HANDLE pClInfoCxt)
{
    InterlockedIncrement((PLONG)&GPCcfInfo);

    IF_TCPDBG(TCP_DEBUG_GPC)
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"tcpip - Cfinfo Add notification %x\n", GPCcfInfo));

    InterlockedIncrement((PLONG)&GpcCfCounts[GPC_CF_IPSEC]);

    IF_TCPDBG(TCP_DEBUG_GPC)
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"tcpip - Cfinfo Add notification IPSEC:%x\n", GpcCfCounts[GPC_CF_IPSEC]));

    return (STATUS_SUCCESS);
}

GPC_STATUS
GPCcfInfoRemoveNotifyIpsec(GPC_CLIENT_HANDLE ClCtxt,
                           GPC_CLIENT_HANDLE ClInfoCxt)
{
    InterlockedDecrement((PLONG)&GPCcfInfo);

    IF_TCPDBG(TCP_DEBUG_GPC)
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"tcpip - Cfinfo remove notification %x\n", GPCcfInfo));

    InterlockedDecrement((PLONG)&GpcCfCounts[GPC_CF_IPSEC]);

    IF_TCPDBG(TCP_DEBUG_GPC)
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"tcpip - Cfinfo Add notification IPSEC: %x\n", GpcCfCounts[GPC_CF_IPSEC]));

    return (STATUS_SUCCESS);
}

GPC_STATUS
GPCcfInfoAddNotifyQoS(GPC_CLIENT_HANDLE ClCtxt,
                      GPC_HANDLE GpcHandle,
                      PTC_INTERFACE_ID InterfaceInfo,
                      ULONG CfInfoSize,
                      PVOID CfInfo,
                      PGPC_CLIENT_HANDLE pClInfoCxt)
{
    InterlockedIncrement((PLONG)&GPCcfInfo);

    IF_TCPDBG(TCP_DEBUG_GPC)
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"tcpip - Cfinfo Add notification %x\n", GPCcfInfo));

    InterlockedIncrement((PLONG)&GpcCfCounts[GPC_CF_QOS]);

    IF_TCPDBG(TCP_DEBUG_GPC)
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"tcpip - Cfinfo Add notification QOS: %x\n", GpcCfCounts[GPC_CF_QOS]));

    return (STATUS_SUCCESS);
}

GPC_STATUS
GPCcfInfoRemoveNotifyQoS(GPC_CLIENT_HANDLE ClCtxt,
                         GPC_CLIENT_HANDLE ClInfoCxt)
{
    InterlockedDecrement((PLONG)&GPCcfInfo);

    IF_TCPDBG(TCP_DEBUG_GPC)
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"tcpip - Cfinfo remove notification %x\n", GPCcfInfo));

    InterlockedDecrement((PLONG)&GpcCfCounts[GPC_CF_QOS]);

    IF_TCPDBG(TCP_DEBUG_GPC)
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"tcpip - Cfinfo Add notification %x\n", GpcCfCounts[GPC_CF_QOS]));

    return (STATUS_SUCCESS);
}
#endif

#if ACC

NTSTATUS
TcpBuildDeviceAcl(
                  OUT PACL * DeviceAcl
                  )
/*++

Routine Description:

    (Lifted from AFD - AfdBuildDeviceAcl)
    This routine builds an ACL which gives Administrators and LocalSystem
    principals full access. All other principals have no access.

Arguments:

    DeviceAcl - Output pointer to the new ACL.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PGENERIC_MAPPING GenericMapping;
    PSID AdminsSid;
    PSID SystemSid;
    PSID NetworkSid;
    ULONG AclLength;
    NTSTATUS Status;
    ACCESS_MASK AccessMask = GENERIC_ALL;
    PACL NewAcl;

    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask(&AccessMask, GenericMapping);

    AdminsSid = SeExports->SeAliasAdminsSid;
    SystemSid = SeExports->SeLocalSystemSid;
    NetworkSid = SeExports->SeNetworkServiceSid;

    AclLength = sizeof(ACL) +
        3 * FIELD_OFFSET(ACCESS_ALLOWED_ACE,SidStart) +
        RtlLengthSid(AdminsSid) +
        RtlLengthSid(SystemSid) +
        RtlLengthSid(NetworkSid);

    NewAcl = CTEAllocMemBoot(AclLength);

    if (NewAcl == NULL) {
        return (STATUS_INSUFFICIENT_RESOURCES);
    }

    Status = RtlCreateAcl(NewAcl, AclLength, ACL_REVISION);
    if (!NT_SUCCESS(Status)) {
        CTEFreeMem(NewAcl);
        return (Status);
    }

    Status = RtlAddAccessAllowedAce(
                                    NewAcl,
                                    ACL_REVISION,
                                    AccessMask,
                                    AdminsSid
                                    );

    ASSERT(NT_SUCCESS(Status));

    Status = RtlAddAccessAllowedAce(
                                    NewAcl,
                                    ACL_REVISION,
                                    AccessMask,
                                    SystemSid
                                    );

    ASSERT(NT_SUCCESS(Status));


    // Add acl for NetworkSid!

    Status = RtlAddAccessAllowedAce(
                                    NewAcl,
                                    ACL_REVISION,
                                    AccessMask,
                                    NetworkSid
                                    );

    ASSERT(NT_SUCCESS(Status));

    *DeviceAcl = NewAcl;

    return (STATUS_SUCCESS);

}                                // TcpBuildDeviceAcl

NTSTATUS
TcpCreateAdminSecurityDescriptor(
                                 VOID
                                 )
/*++

Routine Description:

    (Lifted from AFD - AfdCreateAdminSecurityDescriptor)
    This routine creates a security descriptor which gives access
    only to Administrtors and LocalSystem. This descriptor is used
    to access check raw endpoint opens and exclisive access to transport
    addresses.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PACL rawAcl = NULL;
    NTSTATUS status;
    BOOLEAN memoryAllocated = FALSE;
    PSECURITY_DESCRIPTOR tcpSecurityDescriptor;
    ULONG tcpSecurityDescriptorLength;
    CHAR buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR localSecurityDescriptor =
    (PSECURITY_DESCRIPTOR) & buffer;
    PSECURITY_DESCRIPTOR localTcpAdminSecurityDescriptor;
    SECURITY_INFORMATION securityInformation = DACL_SECURITY_INFORMATION;

    //
    // Get a pointer to the security descriptor from the TCP device object.
    //
    status = ObGetObjectSecurity(
                                 TCPDeviceObject,
                                 &tcpSecurityDescriptor,
                                 &memoryAllocated
                                 );

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                 "TCP: Unable to get security descriptor, error: %x\n",
                 status
                ));
        ASSERT(memoryAllocated == FALSE);
        return (status);
    }
    //
    // Build a local security descriptor with an ACL giving only
    // administrators and system access.
    //
    status = TcpBuildDeviceAcl(&rawAcl);

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"TCP: Unable to create Raw ACL, error: %x\n", status));
        goto error_exit;
    }
    (VOID) RtlCreateSecurityDescriptor(
                                       localSecurityDescriptor,
                                       SECURITY_DESCRIPTOR_REVISION
                                       );

    (VOID) RtlSetDaclSecurityDescriptor(
                                        localSecurityDescriptor,
                                        TRUE,
                                        rawAcl,
                                        FALSE
                                        );

    //
    // Make a copy of the TCP descriptor. This copy will be the raw descriptor.
    //
    tcpSecurityDescriptorLength = RtlLengthSecurityDescriptor(
                                                              tcpSecurityDescriptor
                                                              );

    localTcpAdminSecurityDescriptor = ExAllocatePool(
                                                     PagedPool,
                                                     tcpSecurityDescriptorLength
                                                     );

    if (localTcpAdminSecurityDescriptor == NULL) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"TCP: couldn't allocate security descriptor\n"));
        goto error_exit;
    }
    RtlMoveMemory(
                  localTcpAdminSecurityDescriptor,
                  tcpSecurityDescriptor,
                  tcpSecurityDescriptorLength
                  );

    TcpAdminSecurityDescriptor = localTcpAdminSecurityDescriptor;

    //
    // Now apply the local descriptor to the raw descriptor.
    //
    status = SeSetSecurityDescriptorInfo(
                                         NULL,
                                         &securityInformation,
                                         localSecurityDescriptor,
                                         &TcpAdminSecurityDescriptor,
                                         PagedPool,
                                         IoGetFileObjectGenericMapping()
                                         );

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"TCP: SeSetSecurity failed, %lx\n", status));
        ASSERT(TcpAdminSecurityDescriptor == localTcpAdminSecurityDescriptor);
        ExFreePool(TcpAdminSecurityDescriptor);
        TcpAdminSecurityDescriptor = NULL;
        goto error_exit;
    }
    if (TcpAdminSecurityDescriptor != localTcpAdminSecurityDescriptor) {
        ExFreePool(localTcpAdminSecurityDescriptor);
    }
    status = STATUS_SUCCESS;

  error_exit:

    ObReleaseObjectSecurity(
                            tcpSecurityDescriptor,
                            memoryAllocated
                            );

    if (rawAcl != NULL) {
        CTEFreeMem(rawAcl);
    }
    return (status);
}

#endif // ACC

#if !MILLEN
NTSTATUS
IpsecInitialize(
          void
          )
/*++

Routine Description:

    Initialize IPSEC.SYS.

Arguments:

    None.

Return Value:

    None.

--*/

{
    UNICODE_STRING          IPSECDeviceName;
    IPSEC_SET_TCPIP_STATUS  SetTcpipStatus;
    PIRP                    Irp;
    IO_STATUS_BLOCK         StatusBlock;
    KEVENT                  Event;
    NTSTATUS                status;

    IPSECDeviceObject = NULL;
    IPSECFileObject = NULL;

    RtlInitUnicodeString(&IPSECDeviceName, DD_IPSEC_DEVICE_NAME);

    //
    // Keep a reference to the IPSec driver so it won't unload before us.
    //
    status = IoGetDeviceObjectPointer(  &IPSECDeviceName,
                                        FILE_ALL_ACCESS,
                                        &IPSECFileObject,
                                        &IPSECDeviceObject);

    if (!NT_SUCCESS(status)) {
        IPSECFileObject = NULL;

        return (status);
    }

    SetTcpipStatus.TcpipStatus = TRUE;

    SetTcpipStatus.TcpipFreeBuff = FreeIprBuff;
    SetTcpipStatus.TcpipAllocBuff = IPAllocBuff;
    SetTcpipStatus.TcpipGetInfo = IPGetInfo;
    SetTcpipStatus.TcpipNdisRequest = IPProxyNdisRequest;
    SetTcpipStatus.TcpipSetIPSecStatus = IPSetIPSecStatus;
    SetTcpipStatus.TcpipSetIPSecPtr = SetIPSecPtr;
    SetTcpipStatus.TcpipUnSetIPSecPtr = UnSetIPSecPtr;
    SetTcpipStatus.TcpipUnSetIPSecSendPtr = UnSetIPSecSendPtr;
    SetTcpipStatus.TcpipTCPXsum = tcpxsum;
    SetTcpipStatus.TcpipSendICMPErr = SendICMPErr;

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    Irp = IoBuildDeviceIoControlRequest(    IOCTL_IPSEC_SET_TCPIP_STATUS,
                                            IPSECDeviceObject,
                                            &SetTcpipStatus,
                                            sizeof(IPSEC_SET_TCPIP_STATUS),
                                            NULL,
                                            0,
                                            FALSE,
                                            &Event,
                                            &StatusBlock);

    if (Irp) {
        status = IoCallDriver(IPSECDeviceObject, Irp);

        if (status == STATUS_PENDING) {
            KeWaitForSingleObject( &Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL);
            status = StatusBlock.Status;
        }
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    return (status);
}

NTSTATUS
IpsecDeinitialize(
            void
            )
/*++

Routine Description:

    Deinitialize IPSEC.SYS.

Arguments:

    None.

Return Value:

    None.

--*/

{
    IPSEC_SET_TCPIP_STATUS  SetTcpipStatus;
    PIRP                    Irp;
    IO_STATUS_BLOCK         StatusBlock;
    KEVENT                  Event;
    NTSTATUS                status;

    if (!IPSECFileObject) {
        return (STATUS_SUCCESS);
    }

    RtlZeroMemory(&SetTcpipStatus, sizeof(IPSEC_SET_TCPIP_STATUS));

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);

    Irp = IoBuildDeviceIoControlRequest(    IOCTL_IPSEC_SET_TCPIP_STATUS,
                                            IPSECDeviceObject,
                                            &SetTcpipStatus,
                                            sizeof(IPSEC_SET_TCPIP_STATUS),
                                            NULL,
                                            0,
                                            FALSE,
                                            &Event,
                                            &StatusBlock);

    if (Irp) {
        status = IoCallDriver(IPSECDeviceObject, Irp);

        if (status == STATUS_PENDING) {
            KeWaitForSingleObject( &Event,
                                   Executive,
                                   KernelMode,
                                   FALSE,
                                   NULL);
            status = StatusBlock.Status;
        }
    } else {
        status = STATUS_INSUFFICIENT_RESOURCES;
    }

    ObDereferenceObject(IPSECFileObject);
    IPSECFileObject = NULL;

    return (status);
}


NTSTATUS
AddNetConfigOpsAce(IN PACL Dacl,
                  OUT PACL * DeviceAcl
                  )
/*++

Routine Description:

    This routine builds an ACL which gives adds the Network Configuration Operators group
    to the principals allowed to control the driver.

Arguments:

    Dacl - Existing DACL.
    DeviceAcl - Output pointer to the new ACL.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PGENERIC_MAPPING GenericMapping;
    PSID NetworkSid = NULL;
    PSID NetConfigOpsSid = NULL;
    ULONG AclLength;
    NTSTATUS Status;
    ACCESS_MASK AccessMask = GENERIC_ALL;
    PACL NewAcl = NULL;
    ULONG SidSize;
    SID_IDENTIFIER_AUTHORITY sidAuth = SECURITY_NT_AUTHORITY;
    PACE_HEADER AceTemp;
    int i;
    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask(&AccessMask, GenericMapping);

    NetworkSid = SeExports->SeNetworkServiceSid;
    SidSize = RtlLengthRequiredSid(3);
    NetConfigOpsSid = (PSID)(CTEAllocMemBoot(SidSize));

    if (NULL == NetConfigOpsSid) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = RtlInitializeSid(NetConfigOpsSid, &sidAuth, 2);
    if (Status != STATUS_SUCCESS) {
        goto clean_up;
    }

    *RtlSubAuthoritySid(NetConfigOpsSid, 0) =
        SECURITY_BUILTIN_DOMAIN_RID;
    *RtlSubAuthoritySid(NetConfigOpsSid, 1) =
        DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS;

    AclLength = Dacl->AclSize;

    AclLength = Dacl->AclSize +
                2*FIELD_OFFSET(ACCESS_ALLOWED_ACE, SidStart) +
                RtlLengthSid(NetConfigOpsSid) +
                RtlLengthSid(NetworkSid);

    NewAcl = CTEAllocMemBoot(AclLength);

    if (NewAcl == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto clean_up;
    }

    Status = RtlCreateAcl(NewAcl, AclLength, ACL_REVISION);

    if (!NT_SUCCESS(Status)) {
        goto clean_up;
    }

    for (i = 0; i < Dacl->AceCount; i++) {
        Status = RtlGetAce(Dacl, i, &AceTemp);

        if (NT_SUCCESS(Status)) {
            Status = RtlAddAce(NewAcl, ACL_REVISION, MAXULONG, AceTemp,
                               AceTemp->AceSize);
        }

        if (!NT_SUCCESS(Status)) {
            goto clean_up;
        }
    }

    // Add Net Config Operators Ace
    Status = RtlAddAccessAllowedAce(NewAcl,
                                    ACL_REVISION,
                                    AccessMask,
                                    NetConfigOpsSid);

    if (!NT_SUCCESS(Status)) {
        goto clean_up;
    }


    // Add Network Services Ace
    Status = RtlAddAccessAllowedAce(NewAcl,
                                    ACL_REVISION,
                                    AccessMask,
                                    NetworkSid);

    if (!NT_SUCCESS(Status)) {
        goto clean_up;
    }

    *DeviceAcl = NewAcl;

clean_up:
    if (NetConfigOpsSid) {
        CTEFreeMem(NetConfigOpsSid);
    }
    if (!NT_SUCCESS(Status) && NewAcl) {
        CTEFreeMem(NewAcl);
    }

    return (Status);
}


NTSTATUS
CreateDeviceDriverSecurityDescriptor(PVOID DeviceOrDriverObject)

/*++

Routine Description:

    Creates the SD responsible for giving access to different users.

Arguments:

    DeviceOrDriverObject - Object to which to assign the Access Rights.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    NTSTATUS status;
    BOOLEAN memoryAllocated = FALSE;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    PACL Dacl = NULL;
    BOOLEAN HasDacl = FALSE;
    BOOLEAN DaclDefaulted = FALSE;
    PACL NewAcl = NULL;

    //
    // Get a pointer to the security descriptor from the driver/device object.
    //

    status = ObGetObjectSecurity(
                                 DeviceOrDriverObject,
                                 &SecurityDescriptor,
                                 &memoryAllocated
                                 );

    if (!NT_SUCCESS(status)) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                 "TCP: Unable to get security descriptor, error: %x\n",
                 status
                ));
        ASSERT(memoryAllocated == FALSE);
        return (status);
    }

    status = RtlGetDaclSecurityDescriptor(SecurityDescriptor, &HasDacl, &Dacl, &DaclDefaulted);

    if (NT_SUCCESS(status) && HasDacl && Dacl != NULL)
    {
        status = AddNetConfigOpsAce(Dacl, &NewAcl);

        if (NT_SUCCESS(status)) {

            PSECURITY_DESCRIPTOR SecDesc = NULL;
            ULONG SecDescSize = 0;
            PACL AbsDacl = NULL;
            ULONG DaclSize = 0;
            PACL AbsSacl = NULL;
            ULONG ulSacl = 0;
            PSID Owner = NULL;
            ULONG OwnerSize = 0;
            PSID PrimaryGroup = NULL;
            ULONG PrimaryGroupSize = 0;
            BOOLEAN OwnerDefault = FALSE;
            BOOLEAN GroupDefault = FALSE;
            BOOLEAN HasSacl = FALSE;
            BOOLEAN SaclDefaulted = FALSE;

            SECURITY_INFORMATION secInfo = OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;

            SecDescSize = sizeof(SecDesc) + NewAcl->AclSize;
            SecDesc = CTEAllocMemBoot(SecDescSize);

            if (SecDesc) {
                DaclSize = NewAcl->AclSize;
                AbsDacl = CTEAllocMemBoot(DaclSize);

                if (AbsDacl) {
                    status = RtlGetOwnerSecurityDescriptor(SecurityDescriptor, &Owner, &OwnerDefault);

                    if (NT_SUCCESS(status)) {
                        OwnerSize = RtlLengthSid(Owner);

                        status = RtlGetGroupSecurityDescriptor(SecurityDescriptor, &PrimaryGroup, &GroupDefault);

                        if (NT_SUCCESS(status)) {
                            PrimaryGroupSize = RtlLengthSid(PrimaryGroup);

                            status = RtlGetSaclSecurityDescriptor(SecurityDescriptor, &HasSacl, &AbsSacl, &SaclDefaulted);

                            if (NT_SUCCESS(status)) {

                                if (HasSacl) {
                                    ulSacl = AbsSacl->AclSize;
                                    secInfo |= SACL_SECURITY_INFORMATION;
                                }

                                status = RtlSelfRelativeToAbsoluteSD(SecurityDescriptor, SecDesc, &SecDescSize, AbsDacl,
                                                            &DaclSize, AbsSacl, &ulSacl, Owner, &OwnerSize, PrimaryGroup, &PrimaryGroupSize);

                                if (NT_SUCCESS(status)) {
                                    status = RtlSetDaclSecurityDescriptor(SecDesc, TRUE, NewAcl, FALSE);

                                    if (NT_SUCCESS(status)) {
                                        status = ObSetSecurityObjectByPointer(DeviceOrDriverObject, secInfo, SecDesc);
                                    }
                                }
                            }
                        }

                    } else {
                        status = STATUS_INSUFFICIENT_RESOURCES;
                    }
                } else {
                    status = STATUS_INSUFFICIENT_RESOURCES;
                }

                if (SecDesc) {
                    // Since this is a Self-Relative security descriptor, freeing it also frees
                    // Owner and PrimaryGroup.
                    CTEFreeMem(SecDesc);
                }

                if (AbsDacl) {
                    CTEFreeMem(AbsDacl);
                }
            }

            if (NewAcl) {
                CTEFreeMem(NewAcl);
            }

        }
    } else {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"TCP: No Dacl: %x\n", status));
    }

    ObReleaseObjectSecurity(
                            SecurityDescriptor,
                            memoryAllocated
                            );
    return (status);
}


//
// Function:    IsRunningOnPersonal
//
// Purpose:     Determines whether running on Whistler Personal
//
// Returns:     Returns true if running on Personal - FALSE otherwise
BOOLEAN
IsRunningOnPersonal(
    VOID
    )
{
    OSVERSIONINFOEXW OsVer = {0};
    ULONGLONG ConditionMask = 0;
    BOOLEAN IsPersonal = TRUE;

    OsVer.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    OsVer.wSuiteMask = VER_SUITE_PERSONAL;
    OsVer.wProductType = VER_NT_WORKSTATION;

    VER_SET_CONDITION(ConditionMask, VER_PRODUCT_TYPE, VER_EQUAL);
    VER_SET_CONDITION(ConditionMask, VER_SUITENAME, VER_AND);

    if (RtlVerifyVersionInfo(&OsVer, VER_PRODUCT_TYPE | VER_SUITENAME,
        ConditionMask) == STATUS_REVISION_MISMATCH) {
        IsPersonal = FALSE;
    }

    return IsPersonal;
}


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\tcb.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TCB.C - TCP TCB management code.
//
//  This file contains the code for managing TCBs.
//

#include "precomp.h"
#include "addr.h"
#include "tcp.h"
#include "tcb.h"
#include "tlcommon.h"
#include "tcpconn.h"
#include "tcpsend.h"
#include "tcprcv.h"
#include "info.h"
#include "tcpcfg.h"
#include "pplasl.h"
#include "tcpdeliv.h"

#include <acd.h>
#include <acdapi.h>

HANDLE TcbPool;
HANDLE SynTcbPool;
HANDLE IprBufPool = NULL;
extern HANDLE TcpRequestPool;

//Special spinlock and table for TIMED_WAIT states.

extern CTELock *pTWTCBTableLock;
extern CTELock *pSynTCBTableLock;

Queue *TWTCBTable;
PTIMER_WHEEL TimerWheel;

// This queue is used for faster scavenging
Queue *TWQueue;

ulong numtwqueue = 0;
ulong numtwtimedout = 0;

extern
void
ClassifyPacket(TCB *SendTCB);

void
TCBTimeoutdpc(
#if !MILLEN
              PKDPC Dpc,
#else // !MILLEN
              PVOID arg0,
#endif // MILLEN
              PVOID DeferredContext,
              PVOID arg1,
              PVOID arg2
              );

extern CTELock *pTCBTableLock;

#if MILLEN
#define MAX_TIMER_PROCS 1
#else // MILLEN
#define MAX_TIMER_PROCS MAXIMUM_PROCESSORS
#endif // !MILLEN


uint TCPTime;
uint CPUTCPTime[MAX_TIMER_PROCS];
uint TCBWalkCount;
uint PerTimerSize = 0;
uint Time_Proc = 0;

TCB **TCBTable;

TCB *PendingFreeList=NULL;
SYNTCB *PendingSynFreeList=NULL;

Queue *SYNTCBTable;

CACHE_LINE_KSPIN_LOCK PendingFreeLock;

#define NUM_DEADMAN_TICKS   MS_TO_TICKS(1000)
#define NUM_DEADMAN_TIME    1000

#define DQ_PARTITION_TIME   8
uint LastDelayQPartitionTime = 0;

uint MaxHashTableSize = 512;
uint DeadmanTicks;

//choose reasonable defaults

uint NumTcbTablePartitions = 4;
uint PerPartitionSize = 128;
uint LogPerPartitionSize = 7;

CTETimer TCBTimer[MAX_TIMER_PROCS];

ULONGLONG LastTimeoutTime;
ULONG CumulativeCarryOver=0;

extern IPInfo LocalNetInfo;

extern SeqNum g_CurISN;
extern int g_Credits;
extern int g_LastIsnUpdateTime;
extern int g_MaxCredits;

//
// All of the init code can be discarded.
//

int InitTCB(void);
void UnInitTCB(void);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, InitTCB)
#pragma alloc_text(INIT, UnInitTCB)
#endif


extern CTEBlockStruc TcpipUnloadBlock;
BOOLEAN fTCBTimerStopping = FALSE;

extern ACD_DRIVER AcdDriverG;

VOID
TCPNoteNewConnection(
                     IN TCB * pTCB,
                     IN CTELockHandle Handle
                     );

NTSTATUS
GetTCBInfo(PTCP_FINDTCB_RESPONSE TCBInfo,
           IPAddr Dest,
           IPAddr Src,
           ushort DestPort,
           ushort SrcPort
           );

void
TCBTimeoutdpc(
#if !MILLEN
              PKDPC Dpc,
#else // !MILLEN
              PVOID arg0,
#endif // MILLEN
              PVOID DeferredContext,
              PVOID arg1,
              PVOID arg2
              )
/*++

Routine Description:

    System timer dpc wrapper routine for TCBTimeout().

Arguments:


Return Value:

    None.

--*/

{
   CTETimer *Timer;
   Timer = (CTETimer *) DeferredContext;

#if MILLEN
    // Set the timer again to make it periodic.
    NdisSetTimer(&Timer->t_timer, MS_PER_TICK);
#endif // MILLEN

    (*Timer->t_handler)((CTEEvent *)Timer, Timer->t_arg);
}

void
CTEInitTimerEx(
    CTETimer    *Timer
    )
/*++

Routine Description:

    Initializes a CTE Timer variable for periodic timer.

Arguments:

    Timer   - Timer variable to initialize.

Return Value:

    None.

--*/

{
    Timer->t_handler = NULL;
    Timer->t_arg = NULL;
#if !MILLEN
    KeInitializeDpc(&(Timer->t_dpc), TCBTimeoutdpc, Timer);
    KeInitializeTimerEx(&(Timer->t_timer),NotificationTimer);
#else !MILLEN
    NdisInitializeTimer(&Timer->t_timer, TCBTimeoutdpc, Timer);
#endif // MILLEN
}

void *
CTEStartTimerEx(
    CTETimer      *Timer,
    unsigned long  DueTime,
    CTEEventRtn    Handler,
    void          *Context
    )

/*++

Routine Description:

    Sets a CTE Timer for expiration for periodic timer.

Arguments:

    Timer    - Pointer to a CTE Timer variable.
    DueTime  - Time in milliseconds after which the timer should expire.
    Handler  - Timer expiration handler routine.
    Context  - Argument to pass to the handler.

Return Value:

    0 if the timer could not be set. Nonzero otherwise.

--*/

{
#if !MILLEN
    LARGE_INTEGER  LargeDueTime;

    ASSERT(Handler != NULL);

    //
    // Convert milliseconds to hundreds of nanoseconds and negate to make
    // an NT relative timeout.
    //
    LargeDueTime.HighPart = 0;
    LargeDueTime.LowPart = DueTime;
    LargeDueTime = RtlExtendedIntegerMultiply(LargeDueTime, 10000);
    LargeDueTime.QuadPart = -LargeDueTime.QuadPart;

    Timer->t_handler = Handler;
    Timer->t_arg = Context;

    KeSetTimerEx(
        &(Timer->t_timer),
        LargeDueTime,
        MS_PER_TICK,
        &(Timer->t_dpc)
        );
#else // !MILLEN
    ASSERT(Handler != NULL);

    Timer->t_handler = Handler;
    Timer->t_arg = Context;

    NdisSetTimer(&Timer->t_timer, DueTime);
#endif // MILLEN

    return((void *) 1);
}

//* ReadNextTCB - Read the next TCB in the table.
//
//  Called to read the next TCB in the table. The needed information
//  is derived from the incoming context, which is assumed to be valid.
//  We'll copy the information, and then update the context value with
//  the next TCB to be read.
//  The table lock for the given index is assumed to be held when this
//  function is called.
//
//  Input:  Context     - Poiner to a TCPConnContext.
//          Buffer      - Pointer to a TCPConnTableEntry structure.
//
//  Returns: TRUE if more data is available to be read, FALSE is not.
//
uint
ReadNextTCB(void *Context, void *Buffer)
{
    TCPConnContext *TCContext = (TCPConnContext *) Context;
    TCPConnTableEntry *TCEntry = (TCPConnTableEntry *) Buffer;
    CTELockHandle Handle;
    TCB *CurrentTCB;
    TWTCB *CurrentTWTCB;
    Queue *Scan;
    uint i;

    if (TCContext->tcc_index >= TCB_TABLE_SIZE) {

        CurrentTWTCB = (TWTCB *) TCContext->tcc_tcb;
        CTEStructAssert(CurrentTWTCB, twtcb);

        TCEntry->tct_state = TCB_TIME_WAIT + TCB_STATE_DELTA;

        TCEntry->tct_localaddr = CurrentTWTCB->twtcb_saddr;
        TCEntry->tct_localport = CurrentTWTCB->twtcb_sport;
        TCEntry->tct_remoteaddr = CurrentTWTCB->twtcb_daddr;
        TCEntry->tct_remoteport = CurrentTWTCB->twtcb_dport;

        if (TCContext->tcc_infosize > sizeof(TCPConnTableEntry)) {
            ((TCPConnTableEntryEx*)TCEntry)->tcte_owningpid = 0;
        }

        i = TCContext->tcc_index - TCB_TABLE_SIZE;

        Scan = QNEXT(&CurrentTWTCB->twtcb_link);

        if (Scan != QEND(&TWTCBTable[i])) {
            TCContext->tcc_tcb = (TCB *) QSTRUCT(TWTCB, Scan, twtcb_link);
            return TRUE;
        }
    } else {

        CurrentTCB = TCContext->tcc_tcb;
        CTEStructAssert(CurrentTCB, tcb);

        CTEGetLock(&CurrentTCB->tcb_lock, &Handle);
        if (CLOSING(CurrentTCB))
            TCEntry->tct_state = TCP_CONN_CLOSED;
        else
            TCEntry->tct_state = (uint) CurrentTCB->tcb_state + TCB_STATE_DELTA;
        TCEntry->tct_localaddr = CurrentTCB->tcb_saddr;
        TCEntry->tct_localport = CurrentTCB->tcb_sport;
        TCEntry->tct_remoteaddr = CurrentTCB->tcb_daddr;
        TCEntry->tct_remoteport = CurrentTCB->tcb_dport;

        if (TCContext->tcc_infosize > sizeof(TCPConnTableEntry)) {
            ((TCPConnTableEntryEx*)TCEntry)->tcte_owningpid =
                (CurrentTCB->tcb_conn) ? CurrentTCB->tcb_conn->tc_owningpid
                                       : 0;
        }

        CTEFreeLock(&CurrentTCB->tcb_lock, Handle);

        if (CurrentTCB->tcb_next != NULL) {
            TCContext->tcc_tcb = CurrentTCB->tcb_next;
            return TRUE;
        }
    }

    // NextTCB is NULL. Loop through the TCBTable looking for a new
    // one.
    i = TCContext->tcc_index + 1;



    if (i >= TCB_TABLE_SIZE) {

        // If the index is greater than the TCB_TABLE_SIZE,
        // Then it must be referring to the TIM_WAIT table.
        // Get the correct hash index and search in TW table.

        i = i - TCB_TABLE_SIZE;

        while (i < TCB_TABLE_SIZE) {
            if (!EMPTYQ(&TWTCBTable[i])) {
                TCContext->tcc_tcb = (TCB *)
                    QSTRUCT(TWTCB, QHEAD(&TWTCBTable[i]), twtcb_link);
                TCContext->tcc_index = i + TCB_TABLE_SIZE;
                return TRUE;
                break;
            } else
                i++;
        }

    } else {

        //Normal table scan

        while (i < TCB_TABLE_SIZE) {
            if (TCBTable[i] != NULL) {
                TCContext->tcc_tcb = TCBTable[i];
                TCContext->tcc_index = i;
                return TRUE;
                break;
            } else
                i++;
        }

        // We exhausted normal table move on to TIM_WAIT table

        i = i - TCB_TABLE_SIZE;

        while (i < TCB_TABLE_SIZE) {
            if (!EMPTYQ(&TWTCBTable[i])) {
                TCContext->tcc_tcb = (TCB *)
                    QSTRUCT(TWTCB, QHEAD(&TWTCBTable[i]), twtcb_link);
                TCContext->tcc_index = i + TCB_TABLE_SIZE;
                return TRUE;
                break;
            } else
                i++;
        }

    }

    TCContext->tcc_index = 0;
    TCContext->tcc_tcb = NULL;
    return FALSE;

}

//* ValidateTCBContext - Validate the context for reading a TCB table.
//
//  Called to start reading the TCB table sequentially. We take in
//  a context, and if the values are 0 we return information about the
//  first TCB in the table. Otherwise we make sure that the context value
//  is valid, and if it is we return TRUE.
//  We assume the caller holds the TCB table lock.
//
//  Input:  Context     - Pointer to a TCPConnContext.
//          Valid       - Where to return information about context being
//                          valid.
//
//  Returns: TRUE if data in table, FALSE if not. *Valid set to true if the
//      context is valid.
//
uint
ValidateTCBContext(void *Context, uint * Valid)
{
    TCPConnContext *TCContext = (TCPConnContext *) Context;
    uint i;
    TCB *TargetTCB;
    TCB *CurrentTCB;
    TWTCB *CurrentTWTCB;
    Queue *Scan;

    i = TCContext->tcc_index;

    TargetTCB = TCContext->tcc_tcb;

    // If the context values are 0 and NULL, we're starting from the beginning.
    if (i == 0 && TargetTCB == NULL) {
        *Valid = TRUE;
        do {
            if ((CurrentTCB = TCBTable[i]) != NULL) {
                CTEStructAssert(CurrentTCB, tcb);
                TCContext->tcc_index = i;
                TCContext->tcc_tcb = CurrentTCB;

                return TRUE;
            }
            i++;
        } while (i < TCB_TABLE_SIZE);

        // We have TCBs in time wait table also...
        i = 0;
        do {
            if (!EMPTYQ(&TWTCBTable[i])) {

                CurrentTWTCB =
                    QSTRUCT(TWTCB, QHEAD(&TWTCBTable[i]), twtcb_link);
                CTEStructAssert(CurrentTWTCB, twtcb);
                TCContext->tcc_index = i + TCB_TABLE_SIZE;
                TCContext->tcc_tcb = (TCB *) CurrentTWTCB;

                return TRUE;
            }
            i++;
        } while (i < TCB_TABLE_SIZE);

        return FALSE;
    } else {

        // We've been given a context. We just need to make sure that it's
        // valid.

        if (i >= TCB_TABLE_SIZE) {

            // If the index is greater than the TCB_TABLE_SIZE,
            // Then it must be referring to the TIM_WAIT table.
            // Get the correct hash index and search in TW table.

            i = i - TCB_TABLE_SIZE;
            if (i < TCB_TABLE_SIZE) {
                Scan = QHEAD(&TWTCBTable[i]);
                while (Scan != QEND(&TWTCBTable[i])) {
                    CurrentTWTCB = QSTRUCT(TWTCB, Scan, twtcb_link);
                    if (CurrentTWTCB == (TWTCB *) TargetTCB) {
                        *Valid = TRUE;

                        return TRUE;
                        break;
                    } else {
                        Scan = QNEXT(Scan);
                    }
                }
            }
        } else {

            //Normal table

            if (i < TCB_TABLE_SIZE) {
                CurrentTCB = TCBTable[i];
                while (CurrentTCB != NULL) {
                    if (CurrentTCB == TargetTCB) {
                        *Valid = TRUE;
                        return TRUE;
                        break;
                    } else {
                        CurrentTCB = CurrentTCB->tcb_next;
                    }
                }

            }
        }

        // If we get here, we didn't find the matching TCB.
        *Valid = FALSE;
        return FALSE;

    }

}

//* FindNextTCB - Find the next TCB in a particular chain.
//
//  This routine is used to find the 'next' TCB in a chain. Since we keep
//  the chain in ascending order, we look for a TCB which is greater than
//  the input TCB. When we find one, we return it.
//
//  This routine is mostly used when someone is walking the table and needs
//  to free the various locks to perform some action.
//
//  Input:  Index       - Index into TCBTable
//          Current     - Current TCB - we find the one after this one.
//
//  Returns: Pointer to the next TCB, or NULL.
//
TCB *
FindNextTCB(uint Index, TCB * Current)
{
    TCB *Next;

    ASSERT(Index < TCB_TABLE_SIZE);

    Next = TCBTable[Index];

    while (Next != NULL && (Next <= Current))
        Next = Next->tcb_next;

    return Next;
}

//* ResetSendNext - Set the sendnext value of a TCB.
//
//  Called to set the send next value of a TCB. We do that, and adjust all
//  pointers to the appropriate places. We assume the caller holds the lock
//  on the TCB.
//
//  Input:  SeqTCB - Pointer to TCB to be updated.
//          NewSeq - Sequence number to set.
//
//  Returns: Nothing.
//
void
ResetSendNext(TCB *SeqTCB, SeqNum NewSeq)
{
    TCPSendReq *SendReq;
    uint AmtForward;
    Queue *CurQ;
    PNDIS_BUFFER Buffer;
    uint Offset;

    CTEStructAssert(SeqTCB, tcb);
    ASSERT(SEQ_GTE(NewSeq, SeqTCB->tcb_senduna));

    // The new seq must be less than send max, or NewSeq, senduna, sendnext,
    // and sendmax must all be equal. (The latter case happens when we're
    // called exiting TIME_WAIT, or possibly when we're retransmitting
    // during a flow controlled situation).
    ASSERT(SEQ_LT(NewSeq, SeqTCB->tcb_sendmax) ||
              (SEQ_EQ(SeqTCB->tcb_senduna, SeqTCB->tcb_sendnext) &&
               SEQ_EQ(SeqTCB->tcb_senduna, SeqTCB->tcb_sendmax) &&
               SEQ_EQ(SeqTCB->tcb_senduna, NewSeq)));

    AmtForward = NewSeq - SeqTCB->tcb_senduna;


    if ((AmtForward == 1) && (SeqTCB->tcb_flags & FIN_SENT) &&
        !((SeqTCB->tcb_sendnext-SeqTCB->tcb_senduna) > 1) &&
        (SEQ_EQ(SeqTCB->tcb_sendnext, SeqTCB->tcb_sendmax))) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                   "tcpip: trying to set sendnext for FIN_SENT\n"));
        //CheckTCBSends(SeqTCB);
        //allow retransmits of this FIN
        SeqTCB->tcb_sendnext = NewSeq;
        SeqTCB->tcb_flags &= ~FIN_OUTSTANDING;
        return;
    }
    if ((SeqTCB->tcb_flags & FIN_SENT) &&
        (SEQ_EQ(SeqTCB->tcb_sendnext, SeqTCB->tcb_sendmax)) &&
        ((SeqTCB->tcb_sendnext - NewSeq) == 1)) {

        //There is only FIN that is left beyond sendnext.
        //allow retransmits of this FIN
        SeqTCB->tcb_sendnext = NewSeq;
        SeqTCB->tcb_flags &= ~FIN_OUTSTANDING;
        return;
    }

    SeqTCB->tcb_sendnext = NewSeq;

    // If we're backing off send next, turn off the FIN_OUTSTANDING flag to
    // maintain a consistent state.
    if (!SEQ_EQ(NewSeq, SeqTCB->tcb_sendmax))
        SeqTCB->tcb_flags &= ~FIN_OUTSTANDING;

    if (SYNC_STATE(SeqTCB->tcb_state) && SeqTCB->tcb_state != TCB_TIME_WAIT) {
        // In these states we need to update the send queue.

        if (!EMPTYQ(&SeqTCB->tcb_sendq)) {
            CurQ = QHEAD(&SeqTCB->tcb_sendq);

            SendReq = (TCPSendReq *) STRUCT_OF(TCPReq, CurQ, tr_q);

            // SendReq points to the first send request on the send queue.
            // Move forward AmtForward bytes on the send queue, and set the
            // TCB pointers to the resultant SendReq, buffer, offset, size.
            while (AmtForward) {

                CTEStructAssert(SendReq, tsr);

                if (AmtForward >= SendReq->tsr_unasize) {
                    // We're going to move completely past this one. Subtract
                    // his size from AmtForward and get the next one.

                    AmtForward -= SendReq->tsr_unasize;
                    CurQ = QNEXT(CurQ);
                    ASSERT(CurQ != QEND(&SeqTCB->tcb_sendq));
                    SendReq = (TCPSendReq *) STRUCT_OF(TCPReq, CurQ, tr_q);
                } else {
                    // We're pointing at the proper send req now. Break out
                    // of this loop and save the information. Further down
                    // we'll need to walk down the buffer chain to find
                    // the proper buffer and offset.
                    break;
                }
            }

            // We're pointing at the proper send req now. We need to go down
            // the buffer chain here to find the proper buffer and offset.
            SeqTCB->tcb_cursend = SendReq;
            SeqTCB->tcb_sendsize = SendReq->tsr_unasize - AmtForward;
            Buffer = SendReq->tsr_buffer;
            Offset = SendReq->tsr_offset;

            while (AmtForward) {
                // Walk the buffer chain.
                uint Length;

                // We'll need the length of this buffer. Use the portable
                // macro to get it. We have to adjust the length by the offset
                // into it, also.
                ASSERT((Offset < NdisBufferLength(Buffer)) ||
                          ((Offset == 0) && (NdisBufferLength(Buffer) == 0)));

                Length = NdisBufferLength(Buffer) - Offset;

                if (AmtForward >= Length) {
                    // We're moving past this one. Skip over him, and 0 the
                    // Offset we're keeping.

                    AmtForward -= Length;
                    Offset = 0;
                    Buffer = NDIS_BUFFER_LINKAGE(Buffer);
                    ASSERT(Buffer != NULL);
                } else
                    break;
            }

            // Save the buffer we found, and the offset into that buffer.
            SeqTCB->tcb_sendbuf = Buffer;
            SeqTCB->tcb_sendofs = Offset + AmtForward;

        } else {
            ASSERT(SeqTCB->tcb_cursend == NULL);
            ASSERT(AmtForward == 0);
        }
    }

    CheckTCBSends(SeqTCB);
}


//* TCPAbortAndIndicateDisconnect
//
//  Abortively closes a TCB and issues a disconnect indication up the the
//  transport user. This function is used to support cancellation of
//  TDI send and receive requests.
//
//  Input:   ConnectionContext    - The connection ID to find a TCB for.
//
//  Returns: Nothing.
//
BOOLEAN
TCPAbortAndIndicateDisconnect(
                              uint ConnectionContext,
                              PVOID Irp,
                              uint Rcv,
                              CTELockHandle inHandle
                              )
{
    TCB *AbortTCB;
    CTELockHandle ConnTableHandle;
    TCPConn *Conn;
    VOID *CancelContext, *CancelID;
    PTCP_CONTEXT tcpContext;
    PIO_STACK_LOCATION irpSp;

    irpSp = IoGetCurrentIrpStackLocation((PIRP)Irp);
    tcpContext = (PTCP_CONTEXT) irpSp->FileObject->FsContext;

    Conn = GetConnFromConnID(ConnectionContext, &ConnTableHandle);

    if (Conn != NULL) {
        CTEStructAssert(Conn, tc);

        AbortTCB = Conn->tc_tcb;

        if (AbortTCB != NULL) {

            // If it's CLOSING or CLOSED, skip it.
            if ((AbortTCB->tcb_state != TCB_CLOSED) && !CLOSING(AbortTCB)) {
                CTEStructAssert(AbortTCB, tcb);
                CTEGetLockAtDPC(&AbortTCB->tcb_lock);
                CTEFreeLockFromDPC(&(Conn->tc_ConnBlock->cb_lock));

                if (AbortTCB->tcb_state == TCB_CLOSED || CLOSING(AbortTCB)) {
                    CTEFreeLockFromDPC(&AbortTCB->tcb_lock);
                    CTEFreeLock(&tcpContext->EndpointLock, inHandle);

                    return FALSE;
                }

                if (Rcv && AbortTCB->tcb_rcvhndlr == BufferData) {

                    // First, search for the IRP in the normal-receive queue.
                    if (AbortTCB->tcb_rcvhead) {
                        TCPRcvReq *RcvReq = AbortTCB->tcb_rcvhead;

                        while (RcvReq) {
                            CTEStructAssert(RcvReq, trr);
                            if (RcvReq->trr_context == Irp) {
                                break;
                            }
                            RcvReq = RcvReq->trr_next;
                        }

                        // If the IRP was found, push it and all of its
                        // predecessors, then let CompleteRcvs complete them.

                        if (RcvReq) {
                            TCPRcvReq* TmpReq = AbortTCB->tcb_rcvhead;
                            while (TmpReq != RcvReq) {
                                TmpReq->trr_flags |= TRR_PUSHED;
                                TmpReq = TmpReq->trr_next;
                            }
                            RcvReq->trr_flags |= TRR_PUSHED;
                            RcvReq->trr_status = TDI_CANCELLED;

                            REFERENCE_TCB(AbortTCB);
                            CTEFreeLockFromDPC(&AbortTCB->tcb_lock);
                            CTEFreeLock(&tcpContext->EndpointLock, inHandle);

                            CompleteRcvs(AbortTCB);

                            CTEGetLock(&AbortTCB->tcb_lock, &inHandle);
                            DerefTCB(AbortTCB, inHandle);
                            return FALSE;
                        }
                    }

                    // Next, search for the IRP in the expedited-receive queue.
                    if (AbortTCB->tcb_exprcv) {
                        TCPRcvReq *RcvReq, *PrevReq;
                        PrevReq = STRUCT_OF(TCPRcvReq, &AbortTCB->tcb_exprcv,
                                            trr_next);
                        RcvReq = PrevReq->trr_next;

                        while (RcvReq) {
                            CTEStructAssert(RcvReq, trr);

                            if (RcvReq->trr_context == Irp) {
                                PrevReq->trr_next = RcvReq->trr_next;
                                FreeRcvReq(RcvReq);
                                CTEFreeLockFromDPC(&AbortTCB->tcb_lock);

                                //
                                // Account for reference count
                                // on endoint, as we are not calling
                                // TCPDataRequestComplete() for this
                                // request.
                                //

                                tcpContext->ReferenceCount--;

                                CTEFreeLock(&tcpContext->EndpointLock,
                                            inHandle);
                                return TRUE;
                            }
                            PrevReq = RcvReq;
                            RcvReq = RcvReq->trr_next;
                        }
                    }
                }

                CancelContext = ((PIRP)Irp)->Tail.Overlay.DriverContext[0];
                CancelID = ((PIRP)Irp)->Tail.Overlay.DriverContext[1];
                CTEFreeLockFromDPC(&tcpContext->EndpointLock);

                REFERENCE_TCB(AbortTCB);

                if (!Rcv) {

                    CTEFreeLockFromDPC(&AbortTCB->tcb_lock);

                    // Call ndis cancel packets routine to free up
                    // queued send packets

                    (*LocalNetInfo.ipi_cancelpackets) (CancelContext, CancelID);
                    CTEGetLockAtDPC(&AbortTCB->tcb_lock);
                }

                AbortTCB->tcb_flags |= NEED_RST; // send a reset if connected
                TryToCloseTCB(AbortTCB, TCB_CLOSE_ABORTED, DISPATCH_LEVEL);
                RemoveTCBFromConn(AbortTCB);

                IF_TCPDBG(TCP_DEBUG_IRP) {
                    TCPTRACE((
                              "TCPAbortAndIndicateDisconnect, indicating discon\n"
                             ));
                }

                NotifyOfDisc(AbortTCB, NULL, TDI_CONNECTION_ABORTED, NULL);
                CTEGetLockAtDPC(&AbortTCB->tcb_lock);
                DerefTCB(AbortTCB, inHandle);
                return FALSE;

            } else
                CTEFreeLockFromDPC(&(Conn->tc_ConnBlock->cb_lock));
        } else
            CTEFreeLockFromDPC(&(Conn->tc_ConnBlock->cb_lock));
    }
    CTEFreeLock(&tcpContext->EndpointLock, inHandle);

    return FALSE;
}

//* AddHalfOpenTCB
//
//  Called to update the count of half-open connections and, if necessary,
//  adjust retransmission thresholds.
//
//  Input:  None.
//
//  Returns: Nothing.
//
void
AddHalfOpenTCB(void)
{
    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
    CTEGetLockAtDPC(&SynAttLock.Lock);
    if (++TCPHalfOpen >= TCPMaxHalfOpen &&
        TCPHalfOpenRetried >= TCPMaxHalfOpenRetried &&
        MaxConnectResponseRexmitCountTmp == MAX_CONNECT_RESPONSE_REXMIT_CNT) {
        MaxConnectResponseRexmitCountTmp =
            ADAPTED_MAX_CONNECT_RESPONSE_REXMIT_CNT;
    }
    CTEFreeLockFromDPC(&SynAttLock.Lock);
}

//* AddHalfOpenRetry
//
//  Called to update the count of half-open connections which have reached our
//  threshold for the number of SYN-ACK retransmissions. If necessary,
//  the routine adjusts overall retransmission thresholds.
//
//  Input:  RexmitCnt   - number of rexmits on the TCB for whom we're called.
//
//  Returns: Nothing.
//
void
AddHalfOpenRetry(uint RexmitCnt)
{
    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
    if (RexmitCnt == ADAPTED_MAX_CONNECT_RESPONSE_REXMIT_CNT) {
        CTEGetLockAtDPC(&SynAttLock.Lock);
        if (++TCPHalfOpenRetried >= TCPMaxHalfOpenRetried &&
            TCPHalfOpen >= TCPMaxHalfOpen &&
            MaxConnectResponseRexmitCountTmp ==
                MAX_CONNECT_RESPONSE_REXMIT_CNT) {
            MaxConnectResponseRexmitCountTmp =
                ADAPTED_MAX_CONNECT_RESPONSE_REXMIT_CNT;
        }
        CTEFreeLockFromDPC(&SynAttLock.Lock);
    }
}

//* DropHalfOpenTCB
//
//  Called to update the count of half-open connections and, if necessary,
//  adjust retransmission thresholds.
//
//  Input:  RexmitCnt   - number of rexmits on the TCB for whom we're called.
//
//  Returns: Nothing.
//
void
DropHalfOpenTCB(uint RexmitCnt)
{
    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    CTEGetLockAtDPC(&SynAttLock.Lock);

    // Drop the count of half-open connections. If this one's retransmissions
    // reached the adaptation threshold, drop the count of retries too.

    --TCPHalfOpen;
    if (RexmitCnt >= ADAPTED_MAX_CONNECT_RESPONSE_REXMIT_CNT) {
        --TCPHalfOpenRetried;
    }

    if ((TCPHalfOpen < TCPMaxHalfOpen ||
         TCPHalfOpenRetried < TCPMaxHalfOpenRetriedLW) &&
        MaxConnectResponseRexmitCountTmp ==
            ADAPTED_MAX_CONNECT_RESPONSE_REXMIT_CNT) {
        MaxConnectResponseRexmitCountTmp = MAX_CONNECT_RESPONSE_REXMIT_CNT;
    }
    CTEFreeLockFromDPC(&SynAttLock.Lock);
}


//* ProcessSynTcbs
//
//  Called from timeout routine to handle syntcbs in syntcb table
//  Retransmits SYN if rexmitcnt has not expired. Else removes the
//  syntcb from the table and frees it.
//
//  Input:  Processor number that is used to select the syntcb space
//          to handle.
//
//  Returns: Nothing.
//
void
ProcessSynTcbs(uint Processor)
{
    Queue *Scan;
    SYNTCB *SynTCB;
    uint i, maxRexmitCnt, StartIndex = 0;
    StartIndex = Processor * PerTimerSize;
    for (i = StartIndex; i < MIN(TCB_TABLE_SIZE, StartIndex+PerTimerSize); i++) {

        Scan  = QHEAD(&SYNTCBTable[i]);

        while (Scan != QEND(&SYNTCBTable[i])) {

            SynTCB = QSTRUCT(SYNTCB, Scan, syntcb_link);
            CTEStructAssert(SynTCB, syntcb);

            CTEGetLockAtDPC(&SynTCB->syntcb_lock);

            Scan = QNEXT(Scan);

            // This TCB needs to be processed further only if it is in the
            // table, which means it is active still.
            // (N.B. This is a more restrictive check than ref-count != 0).

            if ((SynTCB->syntcb_flags & IN_SYNTCB_TABLE) &&
                (TCB_TIMER_RUNNING(SynTCB->syntcb_rexmittimer))) {
                // The timer is running.
                if (--(SynTCB->syntcb_rexmittimer) == 0) {

                    maxRexmitCnt = MIN(MaxConnectResponseRexmitCountTmp,
                                       MaxConnectResponseRexmitCount);

                    // Need a (greater or equal) here, because, we want to stop
                    // when the count reaches the max.
                    if (SynTCB->syntcb_rexmitcnt++ >= maxRexmitCnt) {
                        uint RexmitCnt = SynTCB->syntcb_rexmitcnt;

                        AddHalfOpenRetry(RexmitCnt);

                        SynTCB->syntcb_refcnt++;
                        CTEFreeLockFromDPC(&SynTCB->syntcb_lock);
                        CTEGetLockAtDPC(&pSynTCBTableLock[SynTCB->syntcb_partition]);
                        CTEGetLockAtDPC(&SynTCB->syntcb_lock);

                        if (SynTCB->syntcb_flags & IN_SYNTCB_TABLE) {
                            REMOVEQ(&SynTCB->syntcb_link);
                            SynTCB->syntcb_flags &= ~IN_SYNTCB_TABLE;

                            // We indeed removed the Syn TCB; so, notify.
                            TcpInvokeCcb(TCP_CONN_SYN_RCVD, TCP_CONN_CLOSED,
                                         &SynTCB->syntcb_addrbytes, 0);
                            DropHalfOpenTCB(RexmitCnt);
                            SynTCB->syntcb_refcnt--;
                        }
                        CTEFreeLockFromDPC(
                            &pSynTCBTableLock[SynTCB->syntcb_partition]);

                        DerefSynTCB(SynTCB, DISPATCH_LEVEL);

                    } else {
                        AddHalfOpenRetry(SynTCB->syntcb_rexmitcnt);

                        --SynTCB->syntcb_sendnext;
                        SendSYNOnSynTCB(SynTCB, DISPATCH_LEVEL);
                    }
                } else {
                     CTEFreeLockFromDPC(&SynTCB->syntcb_lock);
                }
            } else {
                CTEFreeLockFromDPC(&SynTCB->syntcb_lock);
            }
        }
    }
}

__inline void
InsertIntoTimerWheel(TCB *InsertTCB, ushort Slot)
{
    PTIMER_WHEEL WheelPtr;
    Queue* TimerSlotPtr;

    WheelPtr = &TimerWheel[InsertTCB->tcb_partition];
    TimerSlotPtr = &WheelPtr->tw_timerslot[Slot];

    ASSERT(InsertTCB->tcb_timerslot == DUMMY_SLOT);

    CTEGetLockAtDPC(&(WheelPtr->tw_lock));

    InsertTCB->tcb_timerslot    = Slot;
    PUSHQ(TimerSlotPtr, &InsertTCB->tcb_timerwheelq);

    CTEFreeLockFromDPC(&(WheelPtr->tw_lock));
}

__inline void
RemoveFromTimerWheel(TCB *RemoveTCB)
{
    PTIMER_WHEEL WheelPtr;

    WheelPtr = &TimerWheel[RemoveTCB->tcb_partition];
    ASSERT(RemoveTCB->tcb_timerslot < TIMER_WHEEL_SIZE);

    CTEGetLockAtDPC(&(WheelPtr->tw_lock));

    RemoveTCB->tcb_timerslot    = DUMMY_SLOT;
    RemoveTCB->tcb_timertime    = 0;

    REMOVEQ(&RemoveTCB->tcb_timerwheelq);

    CTEFreeLockFromDPC(&(WheelPtr->tw_lock));

}

__inline void
RemoveAndInsertIntoTimerWheel(TCB *RemInsTCB, ushort InsertSlot)
{
    PTIMER_WHEEL WheelPtr;
    Queue* InsertSlotPtr;

    ASSERT(RemInsTCB->tcb_timerslot < TIMER_WHEEL_SIZE);

    WheelPtr = &TimerWheel[RemInsTCB->tcb_partition];
    InsertSlotPtr = &WheelPtr->tw_timerslot[InsertSlot];

    CTEGetLockAtDPC(&WheelPtr->tw_lock);

    REMOVEQ(&RemInsTCB->tcb_timerwheelq);
    RemInsTCB->tcb_timerslot   = InsertSlot;
    PUSHQ(InsertSlotPtr, &RemInsTCB->tcb_timerwheelq);

    CTEFreeLockFromDPC(&WheelPtr->tw_lock);
}

__inline void
RecomputeTimerState(TCB *TimerTCB)
{
    TCP_TIMER_TYPE i;

    TimerTCB->tcb_timertype = NO_TIMER;
    TimerTCB->tcb_timertime = 0;

    for(i = 0; i < NUM_TIMERS; i++) {

        if ((TimerTCB->tcb_timer[i] != 0) &&
        ((TimerTCB->tcb_timertime == 0) ||
            (TCPTIME_LTE(TimerTCB->tcb_timer[i], TimerTCB->tcb_timertime)))) {
            TimerTCB->tcb_timertime = TimerTCB->tcb_timer[i];
            TimerTCB->tcb_timertype = i;
        }
    }
}

// StartTCBTimerR
// Arguments: A TCB, timer type, and the interval in ticks after which the
//            timer is supposed to fire.
// Description:
// Sets the array element in tcb_timer for that particular timer to the
// appropriate value, and recomputes the tcb_timertime and tcb_timertype
// values ONLY if we need to. All shortcuts and optimizations are done to
// avoid recomputing the tcb_timertime and tcb_timertype by going through
// the whole array.

// return value: TRUE if minimum got changed; FALSE if not.

BOOLEAN
StartTCBTimerR(TCB *StartTCB, TCP_TIMER_TYPE TimerType, uint DeltaTime)
{
    ASSERT(TimerType < NUM_TIMERS);

    StartTCB->tcb_timer[TimerType] = TCPTime + DeltaTime;

    // Make a check for the case where TCPTime + DeltaTime is 0
    // because of wraparound
    if (StartTCB->tcb_timer[TimerType] == 0)  {
        StartTCB->tcb_timer[TimerType] = 1;
    }

    // This is really simple logic. Find out if the setting of
    // this timer changes the minimum. Don't care whether it was
    // already running, or whether it already the minimum...


    if ((StartTCB->tcb_timertime == 0 ) ||
    (TCPTIME_LT(StartTCB->tcb_timer[TimerType], StartTCB->tcb_timertime))
    )
    {
        // Yup it changed the minimum...
        StartTCB->tcb_timertime = StartTCB->tcb_timer[TimerType];
        StartTCB->tcb_timertype = TimerType;
        return TRUE;
    }

    // No it did not change the minimum.
    // You only have to recompute if it was already the minimum
    if (StartTCB->tcb_timertype == TimerType)  {
        RecomputeTimerState(StartTCB);
    }

    return FALSE;
}



// StopTCBTimerR
// Arguments: A TCB, and a timer type
// Description:
// Sets the array element for that timer to 0, and recomputes
// tcb_timertime and tcb_timertype. It automatically handles
// the case where the function is called for a timer which has
// already stopped.

void
StopTCBTimerR(TCB *StopTCB, TCP_TIMER_TYPE TimerType)
{
    ASSERT(TimerType < NUM_TIMERS);
    StopTCB->tcb_timer[TimerType] = 0;

    // Is this the lowest timer value we are running?
    if (StopTCB->tcb_timertype == TimerType)
    {
        // Stopping a timer can only push back the firing
        // time, so we will never remove a TCB from a slot.
        RecomputeTimerState(StopTCB);
    }

    return;
}




// START_TCB_TIMER_R modifies the timer state and only modifies
// wheel state if the timer that was started was earlier than all the
// other timers on that TCB. This is in accordance with the lazy evaluation
// strategy.

__inline void
START_TCB_TIMER_R(TCB *StartTCB, TCP_TIMER_TYPE Type, uint Value)
{
    ushort Slot;

    // The value of the delta ticks has to be atleast 2.
    if (Value < 2) {
        Value = 2;
    }

    if( StartTCB->tcb_timerslot == DUMMY_SLOT ) {

    StartTCBTimerR(StartTCB, Type, Value);
    Slot = COMPUTE_SLOT(StartTCB->tcb_timertime);
    InsertIntoTimerWheel(StartTCB, Slot);

    } else if ( StartTCBTimerR(StartTCB, Type, Value)) {

    Slot = COMPUTE_SLOT(StartTCB->tcb_timertime);
    RemoveAndInsertIntoTimerWheel(StartTCB, Slot);
    }
}




__inline void
STOP_TCB_TIMER_R(TCB *StopTCB, TCP_TIMER_TYPE Type)
{
    StopTCBTimerR(StopTCB, Type);
    return;
}



void
MakeTimerStateConsistent(TCB *TimerTCB, uint CurrentTime)
{
    uint    i;
    BOOLEAN     TimesChanged = FALSE;

    for(i = 0; i < NUM_TIMERS; i++) {
        if (TimerTCB->tcb_timer[i] != 0) {
            if (TCPTIME_LTE(TimerTCB->tcb_timer[i], CurrentTime)) {

        //  This should not happen. If it does, we either have a bug in the current code
        //  or in the TimerWheel code.

        //  This assert was modified because it was found that, at some point of time
        //  ACD_CON_NOTIF was ON but not looked at after processing CONN_TIMER. So, it
        //  alright to advance timers by 1 tick if they were supposed to go off on the
        //  'current' tick. Otherwise, assert.

        if( TCPTIME_LT(TimerTCB->tcb_timer[i], CurrentTime )) {
            ASSERT(0);
        }

        TimesChanged = TRUE;
                TimerTCB->tcb_timer[i] = CurrentTime + 1;
                // Code to handle wraparound.
                if (TimerTCB->tcb_timer[i] == 0) {
                    TimerTCB->tcb_timer[i] = 1;
                }
            }
        }
    }

    return;
}


//* TCBTimeout - Do timeout events on TCBs.
//
//  Called every MS_PER_TICKS milliseconds to do timeout processing on TCBs.
//  We run throught the TCB table, decrementing timers. If one goes to zero
//  we look at it's state to decide what to do.
//
//  Input:  Timer           - Event structure for timer that fired.
//          Context         - Context for timer (NULL in this case.
//
//  Returns: Nothing.
//
void
TCBTimeout(CTEEvent * Timer, void *Context)
{
    CTELockHandle TCBHandle;
    uint i, j;
    TCB *CurrentTCB;
    uint Delayed = FALSE;
    uint ProcessDelayQ = FALSE;
    ULONGLONG CurrentTime;
    ULONG TimeDiff;
    uint Processor, StartIndex, EndIndex;
#if TRACE_EVENT
    PTDI_DATA_REQUEST_NOTIFY_ROUTINE CPCallBack;
    WMIData WMIInfo;
#endif
    // LocalTime must remain a uint. A loop below uses the
    // termination condition j != (LocalTime + 1) and that
    // works only if LocalTime is a uint so that wraparound
    // can be handled correctly.
    uint LocalTime = 0;
    uint PerProcPartitions, ExtraPartitions;


    Processor = KeGetCurrentProcessorNumber();

    // Update our free running counter.

    if (Processor == 0) {
        int Delta;
        ULONG CarryOver;
        int ElapsedTicks, ExtraTicks;

        CurrentTime = KeQueryInterruptTime();

        // This is time between when we processed the timer last and now.
        TimeDiff = (ULONG)(CurrentTime - LastTimeoutTime);
        LastTimeoutTime = CurrentTime;
        
        // This is the extra time we have to carry forward.
        ElapsedTicks = TimeDiff / 1000000;
        CarryOver = TimeDiff % 1000000;

        // This is the total extra time we have seen so far:
        CumulativeCarryOver = CumulativeCarryOver + CarryOver;

        // If that exceeds 1 tick, we remember that.
        if(CumulativeCarryOver > 1000000) {
            ExtraTicks = CumulativeCarryOver / 1000000;
            CumulativeCarryOver = CumulativeCarryOver % 1000000;
        } else {
            ExtraTicks = 0;
        }

        // Preserved for historic reasons. I can't think of a case where
        // this is required!
        CPUTCPTime[0] += MIN(200, ElapsedTicks);
        
        LocalTime = TCPTime = CPUTCPTime[0];

        if (ExtraTicks) {
            // This makes the timer process 1 (or more) extra tick(s) when the
            // timer fires next time. However, this will not make us process
            // 2 ticks immediately after TCPTime is incremented by 2 ticks,
            // which is going to take care of delayed-ack timers.
            CPUTCPTime[0] += ExtraTicks;
            TCPTime = CPUTCPTime[0];
        }

        // Set credits so that some more connections can increment the 
        // Initial Sequence Number, during the next 100 ms.
        InterlockedExchange((PLONG)&g_Credits, g_MaxCredits);

        Delta = GetDeltaTime();

        // The increment made is (256)*(Time in milliseconds). This is really 
        // close to 25000 increment made originally every 100 ms.
        if(Delta > 0) {
            Delta *= 0x100;
            InterlockedExchangeAdd((PLONG)&g_CurISN, Delta);
        }
    } else {
        // This is the tick upto which we are going to process this time.
        LocalTime = TCPTime;
    }

    CTEInterlockedAddUlong((PULONG)&TCBWalkCount, 1, &PendingFreeLock.Lock);
    TCBHandle = DISPATCH_LEVEL;

    // First compute the indexes of the timer wheels that we need to
    // visit on this processor.
    PerProcPartitions = NumTcbTablePartitions / KeNumberProcessors;
    ExtraPartitions   = NumTcbTablePartitions % KeNumberProcessors;
    StartIndex = Processor * PerProcPartitions;
    StartIndex += MIN(Processor, ExtraPartitions);
    EndIndex   = MIN(NumTcbTablePartitions, StartIndex + PerProcPartitions);
    if (Processor < ExtraPartitions) {
        EndIndex++;
    }

    // Now loop through the timer wheels.
    for (i = StartIndex; i < EndIndex; i++) {


    // For each timer wheel, tw_starttick stores the first time tick which
    // needs to be checked. We loop from tw_starttick to the current time,
    // and each time we figure out the slot corresponding to that tick,
    // and visit all the TCBs on that slot's queue.
    //
    ushort CurrentSlot = COMPUTE_SLOT(TimerWheel[i].tw_starttick);

    // In this for-loop, the termination condition is not j <= LocalTime,
    // but j != LocalTime + 1. This is because TCPTime can wraparound, and
    // tw_starttick may actually be higher that LocalTime.
    // It is important to make sure that j is a uint, otherwise this logic
    // does not hold.
    for (j = TimerWheel[i].tw_starttick;
         j != (LocalTime + 1);
         j++, CurrentSlot = (CurrentSlot == (TIMER_WHEEL_SIZE - 1)) ? 0 : CurrentSlot + 1) {
        Queue MarkerElement;
        uint maxRexmitCnt;
        ushort Slot;

        // Our basic loop is going to be:
        // Pull out a TCB from the timer slot queue. Process it. Put it
        // back into the timer wheel if we need to, depending on if other
        // timers need to be fired. The problem with this is if the TCB
        // ends up falling in the same slot, we get into this loop where
        // we pull the TCB out, process it, put it back into the current
        // slot, pull it out again, process it, ad infinitum.
        //
        // So we introduce a dummy element called MarkerElement. We begin
        // our processing by inserting this element into the head of the
        // queue. Now we always pull out a TCB which the MarkerElement points
        // to, process it, and then push it to the head of the timer slot
        // queue. Since no TCBs are ever added to the timer slot queue after
        // the MarkerElement (elements are always added to the head of the
        // queue), MarkerElement will eventually point to the head of the
        // timer slot queue, at which point we know that we are done.

        CTEGetLockAtDPC(&TimerWheel[i].tw_lock);
        PUSHQ(&TimerWheel[i].tw_timerslot[CurrentSlot], &MarkerElement);
        CTEFreeLockFromDPC(&TimerWheel[i].tw_lock);

        for (; ;) {
            // First remove the tcb at the head of the list
            CTEGetLockAtDPC(&TimerWheel[i].tw_lock);

            // The list is empty if the marker points to timer slot
            if (QNEXT(&MarkerElement) == &TimerWheel[i].tw_timerslot[CurrentSlot]) {
                REMOVEQ(&MarkerElement);
                CTEFreeLockFromDPC(&TimerWheel[i].tw_lock);
                break;
            }

            CurrentTCB = STRUCT_OF(TCB, QNEXT(&MarkerElement), tcb_timerwheelq);

            CTEFreeLockFromDPC(&TimerWheel[i].tw_lock);

            CTEStructAssert(CurrentTCB, tcb);
            CTEGetLockAtDPC(&CurrentTCB->tcb_lock);

            // Someone may have removed this TCB before we reacquired the tcb
            // lock.  Check if it is still in the list and still in the same slot.
            if  (CurrentTCB->tcb_timerslot != CurrentSlot) {
                CTEFreeLockFromDPC(&CurrentTCB->tcb_lock);
                continue;
            }

            // This TCB may not be in the TCB table anymore.
            // In that case, it should not be processed.
            if (!(CurrentTCB->tcb_flags & IN_TCB_TABLE)) {
                RemoveFromTimerWheel(CurrentTCB);
                CTEFreeLockFromDPC(&CurrentTCB->tcb_lock);
                continue;
            }

            // Check if this is firing at the current time. In case of keepalive
            // timers (which fire after hours), sometimes TCBs may queue to the
            // current slot but their firing time is not the current time.
            // This if statement also does the lazy evaluation -- if all timers
            // have been stopped on this TCB just remove the TCB out.
            // Callers of STOP_TCB_TIMER_R never end up removing the TCB. That
            // job is left to this routine.

            if (CurrentTCB->tcb_timertime != j) {

                MakeTimerStateConsistent(CurrentTCB, j);
                ASSERT(CurrentTCB->tcb_timerslot < TIMER_WHEEL_SIZE);

                RecomputeTimerState(CurrentTCB);

                if (CurrentTCB->tcb_timertype == NO_TIMER) {
                    RemoveFromTimerWheel(CurrentTCB);
                } else {
                    Slot = COMPUTE_SLOT(CurrentTCB->tcb_timertime);
                    RemoveAndInsertIntoTimerWheel(CurrentTCB, Slot);
                }

                CTEFreeLockFromDPC(&CurrentTCB->tcb_lock);
                continue;
            }

            // If it's CLOSING or CLOSED, skip it.
            if (CurrentTCB->tcb_state == TCB_CLOSED || CLOSING(CurrentTCB)) {

                // CloseTCB will handle all outstanding requests.
                // So, it is safe to remove the TCB from timer wheel.

                RemoveFromTimerWheel(CurrentTCB);
                CTEFreeLockFromDPC(&CurrentTCB->tcb_lock);
                continue;
            }

            CheckTCBSends(CurrentTCB);
            CheckTCBRcv(CurrentTCB);

            // First check the rexmit timer.
            if (TCB_TIMER_FIRED_R(CurrentTCB, RXMIT_TIMER, j)) {
                StopTCBTimerR(CurrentTCB, RXMIT_TIMER);

                // And it's fired. Figure out what to do now.

                // Remove all SACK rcvd entries (per RFC 2018)

                if ((CurrentTCB->tcb_tcpopts & TCP_FLAG_SACK) &&
                    CurrentTCB->tcb_SackRcvd) {
                    SackListEntry *Prev, *Current;
                    Prev = STRUCT_OF(SackListEntry, &CurrentTCB->tcb_SackRcvd, next);
                    Current = CurrentTCB->tcb_SackRcvd;
                    while (Current) {
                        Prev->next = Current->next;
                        CTEFreeMem(Current);
                        Current = Prev->next;

                    }
                }

                // If we've had too many retransits, abort now.
                CurrentTCB->tcb_rexmitcnt++;

                if (CurrentTCB->tcb_state == TCB_SYN_SENT) {
                    maxRexmitCnt = MaxConnectRexmitCount;
                } else if (CurrentTCB->tcb_state == TCB_SYN_RCVD) {

                    // Save on locking. Though MaxConnectRexmitCountTmp may
                    // be changing, we are assured that we will not use
                    // more than the MaxConnectRexmitCount.

                    maxRexmitCnt = MIN(MaxConnectResponseRexmitCountTmp,
                                       MaxConnectResponseRexmitCount);
                    if (SynAttackProtect) {
                        AddHalfOpenRetry(CurrentTCB->tcb_rexmitcnt);
                    }
                } else {
                    maxRexmitCnt = MaxDataRexmitCount;
                }

                // If we've run out of retransmits or we're in FIN_WAIT2,
                // time out.
                if (CurrentTCB->tcb_rexmitcnt > maxRexmitCnt) {

                    ASSERT(CurrentTCB->tcb_state > TCB_LISTEN);

                    // This connection has timed out. Abort it. First
                    // reference him, then mark as closed, notify the
                    // user, and finally dereference and close him.

TimeoutTCB:
                    // This call may not be needed, but I've just added it
                    // for safety.
                    MakeTimerStateConsistent(CurrentTCB, j);
                    RecomputeTimerState(CurrentTCB);

                    ASSERT(CurrentTCB->tcb_timerslot < TIMER_WHEEL_SIZE);
                    if (CurrentTCB->tcb_timertype == NO_TIMER) {
                        RemoveFromTimerWheel(CurrentTCB);
                    } else {
                        Slot = COMPUTE_SLOT(CurrentTCB->tcb_timertime);
                        RemoveAndInsertIntoTimerWheel(CurrentTCB, Slot);
                    }
                    REFERENCE_TCB(CurrentTCB);
                    TryToCloseTCB(CurrentTCB, TCB_CLOSE_TIMEOUT, TCBHandle);

                    RemoveTCBFromConn(CurrentTCB);
                    NotifyOfDisc(CurrentTCB, NULL, TDI_TIMED_OUT, NULL);

                    CTEGetLockAtDPC(&CurrentTCB->tcb_lock);
                    DerefTCB(CurrentTCB, TCBHandle);
                    continue;
                }
#if TRACE_EVENT
                if ((CurrentTCB->tcb_state == TCB_SYN_SENT) ||
                    (CurrentTCB->tcb_state == TCB_ESTAB)) {

                    CPCallBack = TCPCPHandlerRoutine;
                    if (CPCallBack != NULL) {
                        ulong GroupType;

                        WMIInfo.wmi_destaddr = CurrentTCB->tcb_daddr;
                        WMIInfo.wmi_destport = CurrentTCB->tcb_dport;
                        WMIInfo.wmi_srcaddr  = CurrentTCB->tcb_saddr;
                        WMIInfo.wmi_srcport  = CurrentTCB->tcb_sport;
                        WMIInfo.wmi_size     = 0;
                        WMIInfo.wmi_context  = CurrentTCB->tcb_cpcontext;
                        if (CurrentTCB->tcb_state == TCB_ESTAB) {
                            GroupType = EVENT_TRACE_GROUP_TCPIP + EVENT_TRACE_TYPE_RETRANSMIT;
                        } else {
                            GroupType = EVENT_TRACE_GROUP_TCPIP + EVENT_TRACE_TYPE_RECONNECT;
                        }

                        (*CPCallBack) (GroupType, (PVOID)&WMIInfo, sizeof(WMIInfo), NULL);
                    }
                }
#endif
                CurrentTCB->tcb_rtt = 0;    // Stop round trip time
                                            // measurement.

                // Figure out what our new retransmit timeout should be. We
                // double it each time we get a retransmit, and reset it
                // back when we get an ack for new data.
                CurrentTCB->tcb_rexmit = MIN(CurrentTCB->tcb_rexmit << 1,
                                             MAX_REXMIT_TO);

                // Reset the sequence number, and reset the congestion
                // window.
                ResetSendNext(CurrentTCB, CurrentTCB->tcb_senduna);

                if (!(CurrentTCB->tcb_flags & FLOW_CNTLD)) {
                    // Don't let the slow start threshold go below 2
                    // segments
                    CurrentTCB->tcb_ssthresh =
                        MAX(
                            MIN(
                                CurrentTCB->tcb_cwin,
                                CurrentTCB->tcb_sendwin
                            ) / 2,
                            (uint) CurrentTCB->tcb_mss * 2
                            );
                    CurrentTCB->tcb_cwin = CurrentTCB->tcb_mss;
                } else {
                    // We're probing, and the probe timer has fired. We
                    // need to set the FORCE_OUTPUT bit here.
                    CurrentTCB->tcb_flags |= FORCE_OUTPUT;
                }

                // See if we need to probe for a PMTU black hole.
                if (PMTUBHDetect &&
                    CurrentTCB->tcb_rexmitcnt == ((maxRexmitCnt + 1) / 2)) {
                    // We may need to probe for a black hole. If we're
                    // doing MTU discovery on this connection and we
                    // are retransmitting more than a minimum segment
                    // size, or we are probing for a PMTU BH already, turn
                    // off the DF flag and bump the probe count. If the
                    // probe count gets too big we'll assume it's not
                    // a PMTU black hole, and we'll try to switch the
                    // router.
                    if ((CurrentTCB->tcb_flags & PMTU_BH_PROBE) ||
                        ((CurrentTCB->tcb_opt.ioi_flags & IP_FLAG_DF) &&
                         (CurrentTCB->tcb_sendmax - CurrentTCB->tcb_senduna)
                         > 8)) {
                        // May need to probe. If we haven't exceeded our
                        // probe count, do so, otherwise restore those
                        // values.
                        if (CurrentTCB->tcb_bhprobecnt++ < 2) {

                            // We're going to probe. Turn on the flag,
                            // drop the MSS, and turn off the don't
                            // fragment bit.
                            if (!(CurrentTCB->tcb_flags & PMTU_BH_PROBE)) {
                                CurrentTCB->tcb_flags |= PMTU_BH_PROBE;
                                CurrentTCB->tcb_slowcount++;
                                CurrentTCB->tcb_fastchk |= TCP_FLAG_SLOW;

                                // Drop the MSS to the minimum. Save the old
                                // one in case we need it later.
                                CurrentTCB->tcb_mss = MIN(MAX_REMOTE_MSS -
                                                          CurrentTCB->tcb_opt.ioi_optlength,
                                                          CurrentTCB->tcb_remmss);

                                ASSERT(CurrentTCB->tcb_mss > 0);

                                CurrentTCB->tcb_cwin = CurrentTCB->tcb_mss;
                                CurrentTCB->tcb_opt.ioi_flags &= ~IP_FLAG_DF;
                            }
                            // Drop the rexmit count so we come here again,
                            // and don't retrigger DeadGWDetect.

                            CurrentTCB->tcb_rexmitcnt--;
                        } else {
                            // Too many probes. Stop probing, and allow fallover
                            // to the next gateway.
                            //
                            // Currently this code won't do BH probing on the 2nd
                            // gateway. The MSS will stay at the minimum size. This
                            // might be a little suboptimal, but it's
                            // easy to implement for the Sept. 95 service pack
                            // and will  keep connections alive if possible.
                            //
                            // In the future we should investigate doing
                            // dead g/w detect on a per-connection basis, and then
                            // doing PMTU probing for each connection.

                            if (CurrentTCB->tcb_flags & PMTU_BH_PROBE) {
                                CurrentTCB->tcb_flags &= ~PMTU_BH_PROBE;
                                if (--(CurrentTCB->tcb_slowcount) == 0)
                                    CurrentTCB->tcb_fastchk &=
                                        ~TCP_FLAG_SLOW;

                            }
                            CurrentTCB->tcb_bhprobecnt = 0;
                        }
                    }

                }
                // Check to see if we're doing dead gateway detect. If we
                // are, see if it's time to ask IP.
                if (DeadGWDetect &&
                   (SYNC_STATE(CurrentTCB->tcb_state) ||
                   !(CurrentTCB->tcb_fastchk & TCP_FLAG_RST_WHILE_SYN)) &&
                    (CurrentTCB->tcb_rexmitcnt == ((maxRexmitCnt + 1) / 2)) &&
                    (CurrentTCB->tcb_rce != NULL)) {
                    uint CheckRouteFlag;
                    if (SYNC_STATE(CurrentTCB->tcb_state)) {
                        CheckRouteFlag = 0;
                    } else {
                        CheckRouteFlag = CHECK_RCE_ONLY;
                    }

                    (*LocalNetInfo.ipi_checkroute) (CurrentTCB->tcb_daddr,
                                                    CurrentTCB->tcb_saddr,
                                                    CurrentTCB->tcb_rce,
                                                    &CurrentTCB->tcb_opt,
                                                    CheckRouteFlag);

                }
                if (CurrentTCB->tcb_fastchk & TCP_FLAG_RST_WHILE_SYN) {
                    CurrentTCB->tcb_fastchk &= ~TCP_FLAG_RST_WHILE_SYN;

                    if (--(CurrentTCB->tcb_slowcount) == 0) {
                        CurrentTCB->tcb_fastchk &= ~TCP_FLAG_SLOW;
                    }
                }

                // Now handle the various cases.
                switch (CurrentTCB->tcb_state) {

                    // In SYN-SENT or SYN-RCVD we'll need to retransmit
                    // the SYN.
                case TCB_SYN_SENT:
                case TCB_SYN_RCVD:
                    MakeTimerStateConsistent(CurrentTCB, j);
                    RecomputeTimerState( CurrentTCB );

                    if (CurrentTCB->tcb_timertype == NO_TIMER) {
                        RemoveFromTimerWheel(CurrentTCB);
                    } else {
                        Slot = COMPUTE_SLOT(CurrentTCB->tcb_timertime);
                        RemoveAndInsertIntoTimerWheel(CurrentTCB, Slot);
                    }

                    SendSYN(CurrentTCB, TCBHandle);
                    continue;

                case TCB_FIN_WAIT1:
                case TCB_CLOSING:
                case TCB_LAST_ACK:
                    // The call to ResetSendNext (above) will have
                    // turned off the FIN_OUTSTANDING flag.
                    CurrentTCB->tcb_flags |= FIN_NEEDED;
                case TCB_CLOSE_WAIT:
                case TCB_ESTAB:
                    // In this state we have data to retransmit, unless
                    // the window is zero (in which case we need to
                    // probe), or we're just sending a FIN.

                    CheckTCBSends(CurrentTCB);

                    Delayed = TRUE;
                    DelayAction(CurrentTCB, NEED_OUTPUT);
                    break;

                    // If it's fired in TIME-WAIT, we're all done and
                    // can clean up. We'll call TryToCloseTCB even
                    // though he's already sort of closed. TryToCloseTCB
                    // will figure this out and do the right thing.
                case TCB_TIME_WAIT:
                    MakeTimerStateConsistent(CurrentTCB, j);
                    RecomputeTimerState(CurrentTCB);

                    if (CurrentTCB->tcb_timertype == NO_TIMER) {
                        RemoveFromTimerWheel(CurrentTCB);
                    } else {
                        Slot = COMPUTE_SLOT(CurrentTCB->tcb_timertime);
                        RemoveAndInsertIntoTimerWheel(CurrentTCB, Slot);
                    }

                    TryToCloseTCB(CurrentTCB, TCB_CLOSE_SUCCESS,
                                  TCBHandle);
                    continue;
                default:
                    break;
                }
            }
            // Now check the SWS deadlock timer..
            if (TCB_TIMER_FIRED_R(CurrentTCB, SWS_TIMER, j)) {
                StopTCBTimerR(CurrentTCB, SWS_TIMER);
                // And it's fired. Force output now.

                CurrentTCB->tcb_flags |= FORCE_OUTPUT;
                Delayed = TRUE;
                DelayAction(CurrentTCB, NEED_OUTPUT);
            }
            // Check the push data timer.
            if (TCB_TIMER_FIRED_R(CurrentTCB, PUSH_TIMER, j)) {
                StopTCBTimerR(CurrentTCB, PUSH_TIMER);
                // It's fired.
                PushData(CurrentTCB, FALSE);
                Delayed = TRUE;
            }
            // Check the delayed ack timer.
            if (TCB_TIMER_FIRED_R(CurrentTCB, DELACK_TIMER, j)) {
                StopTCBTimerR(CurrentTCB, DELACK_TIMER);
                // And it's fired. Set up to send an ACK.

                Delayed = TRUE;
                DelayAction(CurrentTCB, NEED_ACK);
            }

            if (TCB_TIMER_FIRED_R(CurrentTCB, KA_TIMER, j)) {
                StopTCBTimerR(CurrentTCB, KA_TIMER);

                // Finally check the keepalive timer.
                if (SYNC_STATE(CurrentTCB->tcb_state) &&
                    (CurrentTCB->tcb_flags & KEEPALIVE) &&
                    CurrentTCB->tcb_conn != NULL) {
                    if (CurrentTCB->tcb_kacount < MaxDataRexmitCount) {

                        MakeTimerStateConsistent(CurrentTCB, j);
                        RecomputeTimerState( CurrentTCB );

                        START_TCB_TIMER_R(CurrentTCB, KA_TIMER,
                                          CurrentTCB->tcb_conn->tc_tcbkainterval);

                        ASSERT(CurrentTCB->tcb_timertype != NO_TIMER);
                        ASSERT(CurrentTCB->tcb_timerslot < TIMER_WHEEL_SIZE);

                        SendKA(CurrentTCB, TCBHandle);
                        continue;
                    } else {
                        goto TimeoutTCB;
                    }
                }
            }

            if (TCB_TIMER_FIRED_R(CurrentTCB, CONN_TIMER, j)) {
                StopTCBTimerR(CurrentTCB, CONN_TIMER);

                // If this is an active open connection in SYN-SENT or SYN-RCVD,
                // or we have a FIN pending, check the connect timer.
                if (CurrentTCB->tcb_flags & (ACTIVE_OPEN | FIN_NEEDED | FIN_SENT)) {
                    if (CurrentTCB->tcb_connreq) {
                        // The connection timer has timed out.

                        CurrentTCB->tcb_flags |= NEED_RST;

                        MakeTimerStateConsistent(CurrentTCB, j);
                        RecomputeTimerState( CurrentTCB );

                        START_TCB_TIMER_R(CurrentTCB, RXMIT_TIMER,
                                          CurrentTCB->tcb_rexmit);

                        ASSERT(CurrentTCB->tcb_timertype != NO_TIMER);
                        ASSERT(CurrentTCB->tcb_timerslot < TIMER_WHEEL_SIZE);

                        TryToCloseTCB(CurrentTCB, TCB_CLOSE_TIMEOUT,
                                      TCBHandle);
                        continue;
                    }
                }
            }
            //
            // Check to see if we have to notify the
            // automatic connection driver about this
            // connection.
            //
            if (TCB_TIMER_FIRED_R(CurrentTCB, ACD_TIMER, j)) {
                BOOLEAN fEnabled;

                StopTCBTimerR(CurrentTCB, ACD_TIMER);
                MakeTimerStateConsistent(CurrentTCB, j);

                RecomputeTimerState(CurrentTCB);

                ASSERT(CurrentTCB->tcb_timerslot < TIMER_WHEEL_SIZE);
                if (CurrentTCB->tcb_timertype == NO_TIMER) {
                    RemoveFromTimerWheel(CurrentTCB);
                } else {
                    Slot = COMPUTE_SLOT(CurrentTCB->tcb_timertime);
                    RemoveAndInsertIntoTimerWheel(CurrentTCB, Slot);
                }

                //
                // Determine if we need to notify
                // the automatic connection driver.
                //
                CTEGetLockAtDPC(&AcdDriverG.SpinLock);
                fEnabled = AcdDriverG.fEnabled;
                CTEFreeLockFromDPC(&AcdDriverG.SpinLock);
                if (fEnabled)
                    TCPNoteNewConnection(CurrentTCB, TCBHandle);
                else
                    CTEFreeLockFromDPC(&CurrentTCB->tcb_lock);


                continue;
            }

            // Timer isn't running, or didn't fire.
            MakeTimerStateConsistent(CurrentTCB, j);
            ASSERT(CurrentTCB->tcb_timerslot < TIMER_WHEEL_SIZE);

            RecomputeTimerState( CurrentTCB );

            if (CurrentTCB->tcb_timertype == NO_TIMER) {
                RemoveFromTimerWheel(CurrentTCB);
            } else {
                Slot = COMPUTE_SLOT(CurrentTCB->tcb_timertime);
                RemoveAndInsertIntoTimerWheel(CurrentTCB, Slot);
            }

            CTEFreeLockFromDPC(&CurrentTCB->tcb_lock);
        }
    }
    TimerWheel[i].tw_starttick = LocalTime + 1;
    }

    if (SynAttackProtect) {
        ProcessSynTcbs(Processor);
    }

    // Check if it is about time to remove TCBs off TWQueue
    if (Processor == 0) {
        for (i = 0; i < NumTcbTablePartitions; i++) {

            BOOLEAN Done = FALSE, firstime = TRUE;
            TWTCB *CurrentTCB = NULL;
            Queue *tmp;

            CTEGetLockAtDPC(&pTWTCBTableLock[i]);

            while (!Done) {

                if (!EMPTYQ(&TWQueue[i])) {

                    PEEKQ(&TWQueue[i], CurrentTCB, TWTCB, twtcb_TWQueue);

                    CTEStructAssert(CurrentTCB, twtcb);
                    ASSERT(CurrentTCB->twtcb_flags & IN_TWQUEUE);

                    //Decrement its life time and the last TCB in the queue
                    //because this is a timer delta queue!

                    if (firstime) {
                        TWTCB *PrvTCB;

                        if (CurrentTCB->twtcb_rexmittimer > 0)
                            CurrentTCB->twtcb_rexmittimer--;
                        tmp = TWQueue[i].q_prev;
                        PrvTCB = STRUCT_OF(TWTCB, tmp, twtcb_TWQueue);
                        PrvTCB->twtcb_delta--;
                        firstime = FALSE;
                    }

                } else {
                    Done = TRUE;
                    CurrentTCB = NULL;
                }

                if (CurrentTCB) {
                    // Check the rexmit timer.

                    if ((CurrentTCB->twtcb_rexmittimer <= 0)) {

                        // Timer fired close and remove this tcb

                        RemoveTWTCB(CurrentTCB, i);

                        numtwtimedout++;
                        FreeTWTCB(CurrentTCB);

                    } else {
                        Done = TRUE;
                    }
                } else
                    break;
            } //while

            CTEFreeLockFromDPC(&pTWTCBTableLock[i]);

        } //for
    } //proc == 0

    // See if we need to process the delay queues as part of deadman 
    // processing. We do this now because we want to restart the timer before 
    // processing the delay queues, in case that takes a while. If we make 
    // this check while the timer is running we'd have to lock, so we'll check
    // and save the result now before we start the timer.
    if (Processor == 0) {
        if (DeadmanTicks <= LocalTime) {
            ProcessDelayQ = TRUE;
            DeadmanTicks = NUM_DEADMAN_TIME+LocalTime;
        }
    }

    // Now check the pending free list. If it's not null, walk down the
    // list and decrement the walk count. If the count goes below 2, pull it
    // from the list. If the count goes to 0, free the TCB. If the count is
    // at 1 it'll be freed by whoever called RemoveTCB.

    if (Processor == 0) {
        CTEGetLockAtDPC(&PendingFreeLock.Lock);

        if (PendingFreeList != NULL) {
            TCB *PrevTCB;

            PrevTCB = STRUCT_OF(TCB, &PendingFreeList, tcb_delayq.q_next);

            do {
                CurrentTCB = (TCB *) PrevTCB->tcb_delayq.q_next;

                CTEStructAssert(CurrentTCB, tcb);

                CurrentTCB->tcb_walkcount--;
                if (CurrentTCB->tcb_walkcount <= 0) {
                    *(TCB **) & PrevTCB->tcb_delayq.q_next =
                        (TCB *) CurrentTCB->tcb_delayq.q_next;
                    FreeTCB(CurrentTCB);
                } else {
                    PrevTCB = CurrentTCB;
                }
            } while (PrevTCB->tcb_delayq.q_next != NULL);
        }

        if (PendingSynFreeList != NULL) {

            SYNTCB *PrevTCB,*CurrentTCB;

            //we use q_prev in link q so that QNEXT will still walk to the
            //next syntcb in processsyntcb, while this tcb is on SynFreeLis.t

            PrevTCB = STRUCT_OF(SYNTCB, &PendingSynFreeList, syntcb_link.q_prev);

            do {
                CurrentTCB = (SYNTCB *) PrevTCB->syntcb_link.q_prev;

                CTEStructAssert(CurrentTCB, syntcb);

                CurrentTCB->syntcb_walkcount--;
                if (CurrentTCB->syntcb_walkcount <= 0) {
                    *(SYNTCB **) & PrevTCB->syntcb_link.q_prev =
                        (SYNTCB *) CurrentTCB->syntcb_link.q_prev;
                    FreeSynTCB(CurrentTCB);
                } else {
                    PrevTCB = CurrentTCB;
                }
            } while (PrevTCB->syntcb_link.q_prev != NULL);

        }

        CTEFreeLockFromDPC(&PendingFreeLock.Lock);

        // Do AddrCheckTable cleanup

        if (AddrCheckTable) {

            TCPAddrCheckElement *Temp;

            CTEGetLockAtDPC(&AddrObjTableLock.Lock);

            for (Temp = AddrCheckTable; Temp < AddrCheckTable + NTWMaxConnectCount; Temp++) {
                if (Temp->TickCount > 0) {
                    if ((--(Temp->TickCount)) == 0) {
                        Temp->SourceAddress = 0;
                    }
                }
            }

            CTEFreeLockFromDPC(&AddrObjTableLock.Lock);
        }
    }

    CTEInterlockedAddUlong((PULONG)&TCBWalkCount, (ULONG)-1, &PendingFreeLock.Lock);

    if ((Processor == 0) && 
        TCPTIME_LTE((LastDelayQPartitionTime + DQ_PARTITION_TIME), TCPTime)) {
        LastDelayQPartitionTime = TCPTime;
        PartitionDelayQProcessing(TRUE);
        ProcessDelayQ = TRUE;
    }

    if (ProcessDelayQ) {
        ProcessTCBDelayQ(DISPATCH_LEVEL, TRUE);
    } else if (Delayed) {
        ProcessPerCpuTCBDelayQ(Processor, DISPATCH_LEVEL, NULL, NULL);
    }
}

//* SetTCBMTU - Set TCB MTU values.
//
//  A function called by TCBWalk to set the MTU values of all TCBs using
//  a particular path.
//
//  Input:  CheckTCB        - TCB to be checked.
//          DestPtr         - Ptr to destination address.
//          SrcPtr          - Ptr to source address.
//          MTUPtr          - Ptr to new MTU.
//
//  Returns: TRUE.
//
uint
SetTCBMTU(TCB * CheckTCB, void *DestPtr, void *SrcPtr, void *MTUPtr)
{
    IPAddr DestAddr = *(IPAddr *) DestPtr;
    IPAddr SrcAddr = *(IPAddr *) SrcPtr;
    CTELockHandle TCBHandle;

    CTEStructAssert(CheckTCB, tcb);

    CTEGetLock(&CheckTCB->tcb_lock, &TCBHandle);

    if (IP_ADDR_EQUAL(CheckTCB->tcb_daddr, DestAddr) &&
        IP_ADDR_EQUAL(CheckTCB->tcb_saddr, SrcAddr) &&
        (CheckTCB->tcb_opt.ioi_flags & IP_FLAG_DF)) {
        uint MTU = *(uint *)MTUPtr - CheckTCB->tcb_opt.ioi_optlength;

        CheckTCB->tcb_mss = (ushort) MIN(MTU, (uint) CheckTCB->tcb_remmss);

        ASSERT(CheckTCB->tcb_mss > 0);
        ValidateMSS(CheckTCB);

        //
        // Reset the Congestion Window if necessary
        //
        if (CheckTCB->tcb_cwin < CheckTCB->tcb_mss) {
            CheckTCB->tcb_cwin = CheckTCB->tcb_mss;

            //
            // Make sure the slow start threshold is at least
            // 2 segments
            //
            if (CheckTCB->tcb_ssthresh < ((uint) CheckTCB->tcb_mss * 2)) {
                CheckTCB->tcb_ssthresh = CheckTCB->tcb_mss * 2;
            }
        }
    }
    CTEFreeLock(&CheckTCB->tcb_lock, TCBHandle);

    return TRUE;
}

//* DeleteTCBWithSrc - Delete tcbs with a particular src address.
//
//  A function called by TCBWalk to delete all TCBs with a particular source
//  address.
//
//  Input:  CheckTCB        - TCB to be checked.
//          AddrPtr         - Ptr to address.
//
//  Returns: FALSE if CheckTCB is to be deleted, TRUE otherwise.
//
uint
DeleteTCBWithSrc(TCB * CheckTCB, void *AddrPtr, void *Unused1, void *Unused3)
{
    IPAddr Addr = *(IPAddr *) AddrPtr;

    CTEStructAssert(CheckTCB, tcb);

    if (IP_ADDR_EQUAL(CheckTCB->tcb_saddr, Addr))
        return FALSE;
    else
        return TRUE;
}

//* TCBWalk - Walk the TCBs in the table, and call a function for each of them.
//
//  Called when we need to repetively do something to each TCB in the table.
//  We call the specified function with a pointer to the TCB and the input
//  context for each TCB in the table. If the function returns FALSE, we
//  delete the TCB.
//
//  Input:  CallRtn             - Routine to be called.
//          Context1            - Context to pass to CallRtn.
//          Context2            - Second context to pass to call routine.
//          Context3            - Third context to pass to call routine.
//
//  Returns: Nothing.
//
void
TCBWalk(uint(*CallRtn) (struct TCB *, void *, void *, void *), void *Context1,
        void *Context2, void *Context3)
{
    uint i, j;
    TCB *CurTCB;
    CTELockHandle Handle, TCBHandle;

    // Loop through each bucket in the table, going down the chain of
    // TCBs on the bucket. For each one call CallRtn.

    for (j = 0; j < NumTcbTablePartitions; j++) {

        CTEGetLock(&pTCBTableLock[j], &Handle);

        for (i = j * PerPartitionSize; i < (j + 1) * PerPartitionSize; i++) {

            CurTCB = TCBTable[i];

            // Walk down the chain on this bucket.
            while (CurTCB != NULL) {
                if (!(*CallRtn) (CurTCB, Context1, Context2, Context3)) {
                    // He failed the call. Notify the client and close the
                    // TCB.
                    CTEGetLock(&CurTCB->tcb_lock, &TCBHandle);

                    ASSERT(CurTCB->tcb_partition == j);

                    if (!CLOSING(CurTCB)) {
                        REFERENCE_TCB(CurTCB);
                        CTEFreeLock(&pTCBTableLock[j], TCBHandle);
                        TryToCloseTCB(CurTCB, TCB_CLOSE_ABORTED, Handle);

                        RemoveTCBFromConn(CurTCB);
                        if (CurTCB->tcb_state != TCB_TIME_WAIT)
                            NotifyOfDisc(CurTCB, NULL, TDI_CONNECTION_ABORTED,
                                         NULL);

                        CTEGetLock(&CurTCB->tcb_lock, &TCBHandle);
                        DerefTCB(CurTCB, TCBHandle);
                        CTEGetLock(&pTCBTableLock[j], &Handle);
                    } else
                        CTEFreeLock(&CurTCB->tcb_lock, TCBHandle);

                    CurTCB = FindNextTCB(i, CurTCB);
                } else {
                    CurTCB = CurTCB->tcb_next;
                }
            }
        }

        CTEFreeLock(&pTCBTableLock[j], Handle);
    }
}

void
DerefSynTCB(SYNTCB * SynTCB, CTELockHandle TCBHandle)
{
    ASSERT(SynTCB->syntcb_refcnt != 0);

    if (--SynTCB->syntcb_refcnt == 0) {

        CTEGetLockAtDPC(&PendingFreeLock.Lock);
        if (TCBWalkCount) {

            ASSERT(!(SynTCB->syntcb_flags & IN_SYNTCB_TABLE));
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                       "Freeing to synpendinglist %x\n",SynTCB));

            //we use q_prev in link q so that QNEXT will still walk to the
            //next syntcb in processsyntcb, while this tcb is on SynFreeLis.t

            SynTCB->syntcb_walkcount = TCBWalkCount + 1;
            *(SYNTCB **) &SynTCB->syntcb_link.q_prev = PendingSynFreeList;
            PendingSynFreeList = SynTCB;
            CTEFreeLockFromDPC(&PendingFreeLock.Lock);
            CTEFreeLock(&SynTCB->syntcb_lock, TCBHandle);

        } else {

            CTEFreeLockFromDPC(&PendingFreeLock.Lock);
            CTEFreeLock(&SynTCB->syntcb_lock, TCBHandle);
            FreeSynTCB(SynTCB);

            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"syntcb freed %x\n",SynTCB));
        }
    } else {
        CTEFreeLock(&SynTCB->syntcb_lock, TCBHandle);
    }
}

TCB *
RemoveAndInsertSynTCB(SYNTCB *SynTCB, CTELockHandle TCBHandle)
{
    TCB *NewTCB;
    LOGICAL Inserted;

    NewTCB = AllocTCB();

    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"reminsertsyn: %x %x\n",SynTCB,NewTCB));

    if (NewTCB) {
        // Initialize the full TCB to replace this SYN TCB.

        NewTCB->tcb_dport = SynTCB->syntcb_dport;
        NewTCB->tcb_sport = SynTCB->syntcb_sport;
        NewTCB->tcb_daddr = SynTCB->syntcb_daddr;
        NewTCB->tcb_saddr = SynTCB->syntcb_saddr;
        NewTCB->tcb_rcvnext = SynTCB->syntcb_rcvnext;
        NewTCB->tcb_senduna = SynTCB->syntcb_sendnext - 1;
        NewTCB->tcb_sendmax = SynTCB->syntcb_sendnext;
        NewTCB->tcb_sendnext = SynTCB->syntcb_sendnext;
        NewTCB->tcb_sendwin = SynTCB->syntcb_sendwin;
        NewTCB->tcb_defaultwin = SynTCB->syntcb_defaultwin;
        NewTCB->tcb_phxsum = PHXSUM(SynTCB->syntcb_saddr, SynTCB->syntcb_daddr,
                                PROTOCOL_TCP, 0);

        NewTCB->tcb_rtt = 0;
        NewTCB->tcb_smrtt = 0;
        NewTCB->tcb_delta = MS_TO_TICKS(6000);
        NewTCB->tcb_rexmit = MS_TO_TICKS(3000);

        NewTCB->tcb_mss = SynTCB->syntcb_mss;
        NewTCB->tcb_remmss = SynTCB->syntcb_remmss;
        NewTCB->tcb_rcvwin = SynTCB->syntcb_defaultwin;
        NewTCB->tcb_rcvwinscale = SynTCB->syntcb_rcvwinscale;
        NewTCB->tcb_sndwinscale = SynTCB->syntcb_sndwinscale;
        NewTCB->tcb_tcpopts = SynTCB->syntcb_tcpopts;

        NewTCB->tcb_state = TCB_SYN_RCVD;
        NewTCB->tcb_connreq = NULL;
        NewTCB->tcb_refcnt = 0;
        REFERENCE_TCB(NewTCB);
        NewTCB->tcb_fastchk |= TCP_FLAG_ACCEPT_PENDING;
        NewTCB->tcb_flags |= (SynTCB->syntcb_flags & SYNTCB_SHARED_FLAGS);
        NewTCB->tcb_tsrecent = SynTCB->syntcb_tsrecent;
        NewTCB->tcb_tsupdatetime = SynTCB->syntcb_tsupdatetime;
        NewTCB->tcb_rexmitcnt = 0;

        ClassifyPacket(NewTCB);
 
        (*LocalNetInfo.ipi_initopts) (&NewTCB->tcb_opt);
        NewTCB->tcb_opt.ioi_ttl = SynTCB->syntcb_ttl;
        CTEFreeLockFromDPC(&SynTCB->syntcb_lock);

        Inserted = InsertTCB(NewTCB, FALSE);

        CTEGetLockAtDPC(&NewTCB->tcb_lock);

        if (!Inserted || CLOSING(NewTCB)) {
            if (!CLOSING(NewTCB)) {
                TryToCloseTCB(NewTCB, TCB_CLOSE_ABORTED, DISPATCH_LEVEL);
                CTEGetLockAtDPC(&NewTCB->tcb_lock);
            }
            DerefTCB(NewTCB, DISPATCH_LEVEL);
            NewTCB = NULL;
            CTEGetLockAtDPC(&SynTCB->syntcb_lock);
        } else {
            // No deletion is pending on the TCB, so just drop its refcnt
            // and return with its lock held.
            DEREFERENCE_TCB(NewTCB);

            // Start the timer on the TCB that just got created.
            // The only timer that needs to be transfered across is the
            // retransmit timer. The number of ticks remaining till the
            // next retransmission of SYN+ACK on the SYN TCB is used
            // to start the TCB timer. 
            CTEGetLockAtDPC(&SynTCB->syntcb_lock);
            START_TCB_TIMER_R(NewTCB, RXMIT_TIMER,
                              (SynTCB->syntcb_rexmittimer < 2)
                                    ? 2 : SynTCB->syntcb_rexmittimer);
        }
    } else {
        // Could not convert it to a regular TCB, hence notify.
        TcpInvokeCcb(TCP_CONN_SYN_RCVD, TCP_CONN_CLOSED, 
                     &SynTCB->syntcb_addrbytes, 0);
        DropHalfOpenTCB(SynTCB->syntcb_rexmitcnt);
    }

    // Drop the initial reference to the SYN TCB.

    DerefSynTCB(SynTCB, TCBHandle);
    return NewTCB;
}


//* FindSynTCB - Find a SynTCB in the syntcb table. Convert to
// full TCB if necessary and indicates what actions should
// be taken with the returned TCB
//
//  Called when we need to find a SynTCB in the synTCB table.
//  Note : No locks are held on entry. On exit tcb lock will be held
//
//  Input:  Src         - Source IP address of TCB to be found.
//          Dest        - Dest.  "" ""      ""  "" "" ""   "".
//          DestPort    - Destination port of TCB to be found.
//          SrcPort     - Source port of TCB to be found.
//          RcvInfo     - Received segment information.
//          Size        - Size of payload in TCP segment.
//          index       - The index for the SynTCBTable.
//  Output: Action      - Action upon return of this function that
//                        should be performed. Flags are
//                        SYN_PKT_SEND_RST
//                        SYN_PKT_RST_RCVD
//                        SYN_PKT_DROP
//                        Flags are defined in tcb.h
//
//  Returns: Pointer to synTCB found, or NULL if none.
//
TCB *
FindSynTCB(IPAddr Src, IPAddr Dest,
           ushort DestPort, ushort SrcPort,
           TCPRcvInfo RcvInfo, uint Size,
           uint index,
           PUCHAR Action)
{
    ulong Partition;
    SYNTCB *SynTCB;
    Queue *Scan;
    TCB * RcvTCB;
    uchar rexmitCnt;
    
    Partition = GET_PARTITION(index);

    *Action = 0;
    
    CTEGetLockAtDPC(&pSynTCBTableLock[Partition]);

    for (Scan  = QHEAD(&SYNTCBTable[index]);
         Scan != QEND(&SYNTCBTable[index]);
         Scan  = QNEXT(Scan)) {

        SynTCB = QSTRUCT(SYNTCB, Scan, syntcb_link);
        CTEStructAssert(SynTCB, syntcb);

        if (IP_ADDR_EQUAL(SynTCB->syntcb_daddr, Dest) &&
            SynTCB->syntcb_dport == DestPort &&
            IP_ADDR_EQUAL(SynTCB->syntcb_saddr, Src) &&
            SynTCB->syntcb_sport == SrcPort) {
            
            SeqNum SendUna = SynTCB->syntcb_sendnext - 1;
            SeqNum SendMax = SynTCB->syntcb_sendnext;

            CTEGetLockAtDPC(&SynTCB->syntcb_lock);

            rexmitCnt = SynTCB->syntcb_rexmitcnt;
            
            // 1st, we need to verify the sequence number.
            // RcvWindow should be 0 here.
            if (!SEQ_EQ(RcvInfo.tri_seq, SynTCB->syntcb_rcvnext)) {
                CTEFreeLockFromDPC(&SynTCB->syntcb_lock);
                CTEFreeLockFromDPC(&pSynTCBTableLock[Partition]);

                // Normally, we should send an ACK back but we
                // will wait for the retransmit timer to expire.
                *Action = SYN_PKT_DROP;
                return NULL;
            }
            
            // 2nd, we check for RST, if set, we terminate connection.     
            if (RcvInfo.tri_flags & TCP_FLAG_RST) {
                
                *Action = SYN_PKT_RST_RCVD;

            // 3rd, security and precedence check, does not apply
            // 4th, check for SYN    
            } else if (RcvInfo.tri_flags & TCP_FLAG_SYN) {
    
                *Action = SYN_PKT_SEND_RST;
                
            // 5th, check for ACK
            } else if (!(RcvInfo.tri_flags & TCP_FLAG_ACK)) {  

                // We return right here because in this case we
                // actually do not want to change the SynTCB
                CTEFreeLockFromDPC(&SynTCB->syntcb_lock);
                CTEFreeLockFromDPC(&pSynTCBTableLock[Partition]);

                *Action = SYN_PKT_DROP;
                return NULL;

            // 5th, continue to check for validity of ACK
            } else if (SEQ_GTE(SendUna, RcvInfo.tri_ack) ||
                       SEQ_GT(RcvInfo.tri_ack, SendMax)) {

                *Action = SYN_PKT_SEND_RST;
            }

            // At this point, if some action needs to be taken
            // the SynTCB needs to be killed
            if (*Action) {
                SynTCB->syntcb_flags &= ~IN_SYNTCB_TABLE;
                REMOVEQ(&SynTCB->syntcb_link);
                CTEFreeLockFromDPC(&pSynTCBTableLock[Partition]);

                TcpInvokeCcb(TCP_CONN_SYN_RCVD, TCP_CONN_CLOSED, 
                             &SynTCB->syntcb_addrbytes, 0);
                DropHalfOpenTCB(SynTCB->syntcb_rexmitcnt);

                DerefSynTCB(SynTCB, DISPATCH_LEVEL);
                return NULL;
            }

            // If we got here we know we have to convert the SynTCB to
            // a full TCB
            SynTCB->syntcb_flags &= ~IN_SYNTCB_TABLE;
            REMOVEQ(&SynTCB->syntcb_link);
            CTEFreeLockFromDPC(&pSynTCBTableLock[Partition]);

            RcvTCB = RemoveAndInsertSynTCB(SynTCB, DISPATCH_LEVEL);
            if (RcvTCB == NULL) {
                // Could not allocate a TCB.
                *Action = SYN_PKT_SEND_RST;
                return NULL;
            }
            
            return RcvTCB;
        } // end of if we found a matching SynTCB
    } // end of for loop scanning for SynTCBs

    CTEFreeLockFromDPC(&pSynTCBTableLock[Partition]);
    // no matching TCB

    return NULL;
}

//* FindTCB - Find a TCB in the tcb table.
//
//  Called when we need to find a TCB in the TCB table. We take a quick
//  look at the last TCB we found, and if it matches we return it, lock held. Otherwise
//  we hash into the TCB table and look for it.
//  Note : No locks are held on entry. On exit tcb lock will be held
//
//  Input:  Src         - Source IP address of TCB to be found.
//          Dest        - Dest.  "" ""      ""  "" "" ""   ""
//          DestPort    - Destination port of TCB to be found.
//          SrcPort     - Source port of TCB to be found.
//
//  Returns: Pointer to TCB found, or NULL if none.
//
TCB *
FindTCB(IPAddr Src, IPAddr Dest, ushort DestPort, ushort SrcPort,
    CTELockHandle * Handle, BOOLEAN AtDispatch, uint * hash)
{
    TCB *FoundTCB;
    ulong index, Partition;

    *hash = index = TCB_HASH(Dest, Src, DestPort, SrcPort);

    Partition = GET_PARTITION(index);

    if (AtDispatch) {
        CTEGetLockAtDPC(&pTCBTableLock[Partition]);
    } else {
        CTEGetLock(&pTCBTableLock[Partition], Handle);
    }

    // Didn't find it in our 1 element cache.
    FoundTCB = TCBTable[index];
    while (FoundTCB != NULL) {
        CTEStructAssert(FoundTCB, tcb);
        if (IP_ADDR_EQUAL(FoundTCB->tcb_daddr, Dest) &&
            FoundTCB->tcb_dport == DestPort &&
            IP_ADDR_EQUAL(FoundTCB->tcb_saddr, Src) &&
            FoundTCB->tcb_sport == SrcPort) {

            // Found it. Update the cache for next time, and return.
            //LastTCB = FoundTCB;

            CTEGetLockAtDPC(&FoundTCB->tcb_lock);
            CTEFreeLockFromDPC(&pTCBTableLock[Partition]);

            return FoundTCB;

        } else
            FoundTCB = FoundTCB->tcb_next;
    }

    if (AtDispatch) {
        CTEFreeLockFromDPC(&pTCBTableLock[Partition]);
    } else {
        CTEFreeLock(&pTCBTableLock[Partition], *Handle);
    }
    // no matching TCB

    return NULL;

}


//* FindTCBTW - Find a TCB in the time wait tcb table.
//
//  Called when we need to find a TCB in the TCB table. We take a quick
//  look at the last TCB we found, and if it matches we return it. Otherwise
//  we hash into the TCB table and look for it. We assume the TCB table lock
//  is held when we are called.
//
//  Input:  Src         - Source IP address of TCB to be found.
//          Dest        - Dest.  "" ""      ""  "" "" ""   ""
//          DestPort    - Destination port of TCB to be found.
//          SrcPort     - Source port of TCB to be found.
//
//  Returns: Pointer to TCB found, or NULL if none.
//
TWTCB *
FindTCBTW(IPAddr Src, IPAddr Dest, ushort DestPort, ushort SrcPort, uint index)
{
    TWTCB *FoundTCB;
    Queue *Scan;

    for (Scan  = QHEAD(&TWTCBTable[index]);
         Scan != QEND(&TWTCBTable[index]);
         Scan  = QNEXT(Scan)) {

        FoundTCB = QSTRUCT(TWTCB, Scan, twtcb_link);
        CTEStructAssert(FoundTCB, twtcb);

        if (IP_ADDR_EQUAL(FoundTCB->twtcb_daddr, Dest) &&
            FoundTCB->twtcb_dport == DestPort &&
            IP_ADDR_EQUAL(FoundTCB->twtcb_saddr, Src) &&
            FoundTCB->twtcb_sport == SrcPort) {

            return FoundTCB;
        }
    }

    // no matching TCB

    return NULL;
}

void
InsertInTimewaitQueue(TWTCB *Twtcb, uint Partition)
{
    Queue *PrevLink;
    TWTCB *Prev;

    CTEStructAssert(Twtcb, twtcb);
    ASSERT(!(Twtcb->twtcb_flags & IN_TWQUEUE));

    ENQUEUE(&TWQueue[Partition], &Twtcb->twtcb_TWQueue);

    PrevLink = QPREV(&Twtcb->twtcb_TWQueue);
    if (PrevLink != &TWQueue[Partition]) {

        Prev = STRUCT_OF(TWTCB, PrevLink, twtcb_TWQueue);

        // Compute this TCB's delta value from the using previous TCB's delta
        // Note that prev tcb delta is decremented by timeout routine
        // every tick

        Twtcb->twtcb_rexmittimer = MAX_REXMIT_TO - Prev->twtcb_delta;

    } else {

        Twtcb->twtcb_rexmittimer = MAX_REXMIT_TO;
    }

    Twtcb->twtcb_delta = MAX_REXMIT_TO;

#if DBG
    Twtcb->twtcb_flags |= IN_TWQUEUE;
#endif

}

void
RemoveFromTimewaitQueue(TWTCB *Twtcb, uint Partition)
{
    Queue *NextLink, *PrevLink;
    TWTCB *AdjacentTwTcb;

    CTEStructAssert(Twtcb, twtcb);
    ASSERT(Twtcb->twtcb_flags & IN_TWQUEUE);

    // Update the delta queue elements. If this element is not the last one, 
    // update the retransmit ticks of the next element. Otherwise, if this is 
    // not the only element, update the delta ticks of the previous element.

    NextLink = QNEXT(&Twtcb->twtcb_TWQueue);
    PrevLink = QPREV(&Twtcb->twtcb_TWQueue);

    if (NextLink != QEND(&TWQueue[Partition])) {

        AdjacentTwTcb = STRUCT_OF(TWTCB, NextLink, twtcb_TWQueue);
        AdjacentTwTcb->twtcb_rexmittimer += Twtcb->twtcb_rexmittimer;
    } else if (PrevLink !=  &TWQueue[Partition]) {

        AdjacentTwTcb = STRUCT_OF(TWTCB, PrevLink, twtcb_TWQueue);
        AdjacentTwTcb->twtcb_delta = AdjacentTwTcb->twtcb_delta - 
                                     (MAX_REXMIT_TO - Twtcb->twtcb_delta);
    }

    REMOVEQ(&Twtcb->twtcb_TWQueue);

#if DBG
    Twtcb->twtcb_flags &= ~IN_TWQUEUE;
#endif

}

//* RemoveAndInsert();
//  This routine is called by graceful close routine when the TCB
//  needs to be placed in TIM_WAIT state.
//  The routine removes the TCB from normal table and inserts a small
//  version of it
//  in TW table at the same hash index as the previous one.
//  Also, it queues the TWTCB in timer delta queue for time out
//  processing
//
uint
RemoveAndInsert(TCB * TimWaitTCB)
{
    uint TCBIndex;
    CTELockHandle TableHandle;
    TCB *PrevTCB;
    TWTCB *TWTcb;
    uint Partition = TimWaitTCB->tcb_partition;
    Queue* Scan;

#if DBG
    uint Found = FALSE;
#endif

    CTEStructAssert(TimWaitTCB, tcb);

    if (!(TimWaitTCB->tcb_flags & IN_TCB_TABLE)) {
        CTELockHandle TcbHandle;
        CTEGetLock(&TimWaitTCB->tcb_lock, &TcbHandle);
        TryToCloseTCB(TimWaitTCB, TCB_CLOSE_ABORTED, TcbHandle);
        CTEGetLock(&TimWaitTCB->tcb_lock, &TcbHandle);
        DerefTCB(TimWaitTCB, TcbHandle);
        return FALSE;
    }

    CTEGetLock(&pTCBTableLock[Partition], &TableHandle);

    CTEGetLockAtDPC(&TimWaitTCB->tcb_lock);

    TCBIndex = TCB_HASH(TimWaitTCB->tcb_daddr, TimWaitTCB->tcb_saddr,
                        TimWaitTCB->tcb_dport, TimWaitTCB->tcb_sport);

    PrevTCB = STRUCT_OF(TCB, &TCBTable[TCBIndex], tcb_next);

    do {
        if (PrevTCB->tcb_next == TimWaitTCB) {
            // Found him.
            PrevTCB->tcb_next = TimWaitTCB->tcb_next;
#if DBG
            Found = TRUE;
#endif
            break;
        }
        PrevTCB = PrevTCB->tcb_next;
#if DBG
        CTEStructAssert(PrevTCB, tcb);
#endif
    } while (PrevTCB != NULL);

    ASSERT(Found);

    TimWaitTCB->tcb_flags &= ~IN_TCB_TABLE;
    TimWaitTCB->tcb_pending |= FREE_PENDING;
    //rce and opts are freed in dereftcb.

    //at this point tcb is out of this tcbtable
    //nobody should be holding on to this.
    //we are free to close this tcb and
    //move the state to a smaller twtcb after acquiring
    //twtcbtable lock

    //get a free twtcb
    if ((TWTcb = AllocTWTCB(Partition)) == NULL) {

        // Could not allocate Time-wait TCB; so, notify.
        TcpInvokeCcb(TCP_CONN_TIME_WAIT, TCP_CONN_CLOSED, 
                     &TimWaitTCB->tcb_addrbytes, 0);
        DerefTCB(TimWaitTCB, DISPATCH_LEVEL);
        CTEFreeLock(&pTCBTableLock[Partition], TableHandle);
        return TRUE;
        //possibaly we should queue this tcb on wait queue
        //and service it when we get free twtcb
    }

    // Initialize twtcb
    //
    TWTcb->twtcb_daddr   = TimWaitTCB->tcb_daddr;
    TWTcb->twtcb_saddr   = TimWaitTCB->tcb_saddr;
    TWTcb->twtcb_dport   = TimWaitTCB->tcb_dport;
    TWTcb->twtcb_sport   = TimWaitTCB->tcb_sport;
    TWTcb->twtcb_rcvnext = TimWaitTCB->tcb_rcvnext;
    TWTcb->twtcb_sendnext = TimWaitTCB->tcb_sendnext;

    ASSERT(TimWaitTCB->tcb_sendnext == TimWaitTCB->tcb_senduna);   
    
#if DBG
    TWTcb->twtcb_flags   = 0;
#endif

    CTEGetLockAtDPC(&pTWTCBTableLock[Partition]);

    // Free the parent tcb for this connection

    DerefTCB(TimWaitTCB, DISPATCH_LEVEL);

    // now insert this in to time wait table after locking

    if (EMPTYQ(&TWTCBTable[TCBIndex])) {
        //
        // First item in this bucket.
        //
        PUSHQ(&TWTCBTable[TCBIndex], &TWTcb->twtcb_link);

    } else {
        //
        // Insert the item in sorted order.  The order is based
        // on the address of the TWTCB.  (In this case, comparison
        // is made against the address of the twtcb_link member, but
        // the same result is achieved.)
        //
        for (Scan  = QHEAD(&TWTCBTable[TCBIndex]);
             Scan != QEND(&TWTCBTable[TCBIndex]);
             Scan  = QNEXT(Scan)) {

            if (Scan > &TWTcb->twtcb_link) {
                TWTcb->twtcb_link.q_next = Scan;
                TWTcb->twtcb_link.q_prev = Scan->q_prev;
                Scan->q_prev->q_next = &TWTcb->twtcb_link;
                Scan->q_prev = &TWTcb->twtcb_link;

                break;
            }
        }
        //
        // If we made it to the end without inserting, insert it
        // at the end.
        //
        if (Scan == QEND(&TWTCBTable[TCBIndex])) {
            ENQUEUE(&TWTCBTable[TCBIndex], &TWTcb->twtcb_link);
        }
    }

    //no need to hold on to tcbtablelock beyond this point
#if DBG
    TWTcb->twtcb_flags |= IN_TWTCB_TABLE;
#endif
    CTEFreeLockFromDPC(&pTCBTableLock[Partition]);

    InsertInTimewaitQueue(TWTcb, Partition);

    CTEFreeLock(&pTWTCBTableLock[Partition], TableHandle);

    InterlockedIncrement((PLONG)&numtwqueue);            //debug purpose

    return TRUE;
}

//* RemoveTWTCB - Remove a TWTCB from the TWTCB table.
//
//  Called when we need to remove a TCB in time-wait from the time wait TCB
//  table. We assume the TWTCB table lock is held when we are called.
//
//  Input:  RemovedTCB          - TWTCB to be removed.
//
void
RemoveTWTCB(TWTCB *RemovedTCB, uint Partition)
{
    CTEStructAssert(RemovedTCB, twtcb);
    ASSERT(RemovedTCB->twtcb_flags & IN_TWTCB_TABLE);
    ASSERT(RemovedTCB->twtcb_flags & IN_TWQUEUE);

    // The time-wait expired and we have to notify.
    TcpInvokeCcb(TCP_CONN_TIME_WAIT, TCP_CONN_CLOSED, 
                 &RemovedTCB->twtcb_addrbytes, 0);

    REMOVEQ(&RemovedTCB->twtcb_link);
    InterlockedDecrement((PLONG)&TStats.ts_numconns);

    RemoveFromTimewaitQueue(RemovedTCB, Partition);
    InterlockedDecrement((PLONG)&numtwqueue);

#if DBG
    RemovedTCB->twtcb_flags &= ~IN_TWTCB_TABLE;
#endif
}

void
ReInsert2MSL(TWTCB *RemovedTCB)
{
    uint Index, Partition;

    CTEStructAssert(RemovedTCB, twtcb);
    ASSERT(RemovedTCB->twtcb_flags & IN_TWQUEUE);

    Index = TCB_HASH(RemovedTCB->twtcb_daddr, RemovedTCB->twtcb_saddr,
                     RemovedTCB->twtcb_dport, RemovedTCB->twtcb_sport);
    Partition = GET_PARTITION(Index);

    RemoveFromTimewaitQueue(RemovedTCB, Partition);
    InsertInTimewaitQueue(RemovedTCB, Partition);
}

//* AssassinateTWTCB - Assassinate the time wait TCB, if possible.
//
//  A TCB in time wait can be assasinated if (a) the new TCB being created is
//  because of passive open and (b) the incoming sequence number on the SYN is
//  greater or equal to the next expected sequence number on the connection.
//  The sequence number to be used to send the outgoing SYN is derived from the
//  next expected send sequence number. If these conditions are satisfied, the 
//  Time-wait TCB is removed and freed.
//
//
//  Input:  TwTcb           - Time wait TCB to be replaced.
//          RecvNext        - Next Sequence number after the SYN's sequence.
//          SendNext        - [OUT] ISN to be used on the new connection.
//          Partition       - Partition to which the TCB belongs to.
//
//  Returns: TRUE if the assassination was possible, FALSE otherwise.
//
__inline
BOOLEAN
AssassinateTWTCB(TWTCB *TwTcb, SeqNum RecvNext, SeqNum *SendNext, 
                 uint Partition)
{
    if (SEQ_GT(RecvNext, TwTcb->twtcb_rcvnext)) {
        *SendNext= TwTcb->twtcb_sendnext + 128000;
        RemoveTWTCB(TwTcb, Partition);
        FreeTWTCB(TwTcb);
        return TRUE;
    }
    return FALSE;
}

//* InsertSynTCB - Insert a SYNTCB in the tcb table.
//
//  This routine inserts a SYNTCB in the SYNTCB table. No locks need to be held
//  when this routine is called. We insert TCBs in ascending address order.
//  Before inserting we make sure that the SYNTCB isn't already in the table.
//
//  Input:  NewTCB      - SYNTCB to be inserted.
//
//  Returns: TRUE if we inserted, false if we didn't.
//
uint
InsertSynTCB(SYNTCB * NewTCB, CTELockHandle *TableHandle)
{
    uint TCBIndex;
    TCB *CurrentTCB;
    uint Partition;
    Queue *Scan, *WhereToInsert;

    ASSERT(NewTCB != NULL);
    CTEStructAssert(NewTCB, syntcb);
    TCBIndex = TCB_HASH(NewTCB->syntcb_daddr, NewTCB->syntcb_saddr,
                        NewTCB->syntcb_dport, NewTCB->syntcb_sport);

    Partition = GET_PARTITION(TCBIndex);

    CTEGetLock(&pTCBTableLock[Partition], TableHandle);
    NewTCB->syntcb_partition = Partition;

    // Begin by looking for duplicates of the new SYNTCB in the TCB table.
    // If we find one, bail out.

    CurrentTCB = TCBTable[TCBIndex];

    while (CurrentTCB != NULL) {
        if (IP_ADDR_EQUAL(CurrentTCB->tcb_daddr, NewTCB->syntcb_daddr) &&
            IP_ADDR_EQUAL(CurrentTCB->tcb_saddr, NewTCB->syntcb_saddr) &&
            (CurrentTCB->tcb_sport == NewTCB->syntcb_sport) &&
            (CurrentTCB->tcb_dport == NewTCB->syntcb_dport)) {

            CTEFreeLock(&pTCBTableLock[Partition], *TableHandle);
            return FALSE;

        } else {
            CurrentTCB = CurrentTCB->tcb_next;
        }
    }

    // Retain our lock on the TCB table, and look next for a duplicate
    // in the TWTCB table.

    CTEGetLockAtDPC(&pTWTCBTableLock[Partition]);
    for (Scan = QHEAD(&TWTCBTable[TCBIndex]);
         Scan != QEND(&TWTCBTable[TCBIndex]); Scan = QNEXT(Scan)) {
        TWTCB* CurrentTWTCB = STRUCT_OF(TWTCB, Scan, twtcb_link);

        if (IP_ADDR_EQUAL(CurrentTWTCB->twtcb_daddr, NewTCB->syntcb_daddr) &&
            (CurrentTWTCB->twtcb_dport == NewTCB->syntcb_dport) &&
            IP_ADDR_EQUAL(CurrentTWTCB->twtcb_saddr, NewTCB->syntcb_saddr) &&
            (CurrentTWTCB->twtcb_sport == NewTCB->syntcb_sport)) {

            if (AssassinateTWTCB(CurrentTWTCB, NewTCB->syntcb_rcvnext,
                                &NewTCB->syntcb_sendnext, Partition)) {
                break;
            } else {
                CTEFreeLockFromDPC(&pTWTCBTableLock[Partition]);
                CTEFreeLock(&pTCBTableLock[Partition], *TableHandle);
                return FALSE;
            }
        }
    }
    CTEFreeLockFromDPC(&pTWTCBTableLock[Partition]);

    // Finally, check for duplicates in the SYNTCB table, and at the same time
    // find the insertion point for the new entry.

    CTEGetLockAtDPC(&pSynTCBTableLock[Partition]);
    CTEGetLockAtDPC(&NewTCB->syntcb_lock);

    WhereToInsert = NULL;
    for (Scan = QHEAD(&SYNTCBTable[TCBIndex]);
         Scan != QEND(&SYNTCBTable[TCBIndex]); Scan  = QNEXT(Scan)) {

        SYNTCB *CurrentSynTCB = STRUCT_OF(SYNTCB, Scan, syntcb_link);

        if (IP_ADDR_EQUAL(CurrentSynTCB->syntcb_daddr, NewTCB->syntcb_daddr) &&
            (CurrentSynTCB->syntcb_dport == NewTCB->syntcb_dport) &&
            IP_ADDR_EQUAL(CurrentSynTCB->syntcb_saddr, NewTCB->syntcb_saddr) &&
            (CurrentSynTCB->syntcb_sport == NewTCB->syntcb_sport)) {

            CTEFreeLockFromDPC(&NewTCB->syntcb_lock);
            CTEFreeLockFromDPC(&pSynTCBTableLock[Partition]);
            CTEFreeLock(&pTCBTableLock[Partition], *TableHandle);
            return FALSE;
        }

        if (WhereToInsert == NULL && Scan > &NewTCB->syntcb_link) {
            WhereToInsert = Scan;
        }
    }

    if (WhereToInsert == NULL) {
        WhereToInsert = Scan;
    }

    ENQUEUE(WhereToInsert, &NewTCB->syntcb_link);

    NewTCB->syntcb_flags |= IN_SYNTCB_TABLE;

    CTEFreeLockFromDPC(&pSynTCBTableLock[Partition]);
    CTEFreeLockFromDPC(&pTCBTableLock[Partition]);

    return TRUE;
}


//* InsertTCB - Insert a TCB in the tcb table.
//
//  This routine inserts a TCB in the TCB table. No locks need to be held
//  when this routine is called. We insert TCBs in ascending address order.
//  Before inserting we make sure that the TCB isn't already in the table.
//
//  Input:  NewTCB      - TCB to be inserted.
//          ForceInsert - If there is a time wait TCB, it can be replaced.
//
//  Returns: TRUE if we inserted, false if we didn't.
//
uint
InsertTCB(TCB * NewTCB, BOOLEAN ForceInsert)
{
    uint TCBIndex;
    CTELockHandle TableHandle;
    TCB *PrevTCB, *CurrentTCB;
    TCB *WhereToInsert;
    uint Partition;
    Queue *Scan;
    uint EarlyInsertTime;

    ASSERT(NewTCB != NULL);
    CTEStructAssert(NewTCB, tcb);

    TCBIndex = TCB_HASH(NewTCB->tcb_daddr, NewTCB->tcb_saddr,
                        NewTCB->tcb_dport, NewTCB->tcb_sport);
    Partition = GET_PARTITION(TCBIndex);

    CTEGetLock(&pTCBTableLock[Partition], &TableHandle);
    CTEGetLockAtDPC(&NewTCB->tcb_lock);
    NewTCB->tcb_partition = Partition;

    // Look first for a duplicate in the SYNTCB table.

    if (SynAttackProtect) {
        CTEGetLockAtDPC(&pSynTCBTableLock[Partition]);
    
        for (Scan = QHEAD(&SYNTCBTable[TCBIndex]);
             Scan != QEND(&SYNTCBTable[TCBIndex]); Scan = QNEXT(Scan)) {
    
            SYNTCB *CurrentSynTCB = STRUCT_OF(SYNTCB, Scan, syntcb_link);
    
            if (IP_ADDR_EQUAL(CurrentSynTCB->syntcb_daddr, NewTCB->tcb_daddr) &&
                (CurrentSynTCB->syntcb_dport == NewTCB->tcb_dport) &&
                IP_ADDR_EQUAL(CurrentSynTCB->syntcb_saddr, NewTCB->tcb_saddr) &&
                (CurrentSynTCB->syntcb_sport == NewTCB->tcb_sport)) {
    
                CTEFreeLockFromDPC(&pSynTCBTableLock[Partition]);
                CTEFreeLockFromDPC(&NewTCB->tcb_lock);
                CTEFreeLock(&pTCBTableLock[Partition], TableHandle);
                return FALSE;
            }
        }
    
        CTEFreeLockFromDPC(&pSynTCBTableLock[Partition]);
    }

    // Next, look for a duplicate in the TWTCB table.

    CTEGetLockAtDPC(&pTWTCBTableLock[Partition]);

    for (Scan  = QHEAD(&TWTCBTable[TCBIndex]);
         Scan != QEND(&TWTCBTable[TCBIndex]); Scan  = QNEXT(Scan)) {

        TWTCB *CurrentTWTCB = STRUCT_OF(TWTCB, Scan, twtcb_link);
        CTEStructAssert(CurrentTWTCB, twtcb);

        if (IP_ADDR_EQUAL(CurrentTWTCB->twtcb_daddr, NewTCB->tcb_daddr) &&
            (CurrentTWTCB->twtcb_dport == NewTCB->tcb_dport) &&
            IP_ADDR_EQUAL(CurrentTWTCB->twtcb_saddr, NewTCB->tcb_saddr) &&
            (CurrentTWTCB->twtcb_sport == NewTCB->tcb_sport)) {

            if (ForceInsert && 
                AssassinateTWTCB(CurrentTWTCB, NewTCB->tcb_rcvnext,
                                 &NewTCB->tcb_sendnext, Partition)) {
                break;
            } else {
                CTEFreeLockFromDPC(&pTWTCBTableLock[Partition]);
                CTEFreeLockFromDPC(&NewTCB->tcb_lock);
                CTEFreeLock(&pTCBTableLock[Partition], TableHandle);
                return FALSE;
            }
        }
    }

    CTEFreeLockFromDPC(&pTWTCBTableLock[Partition]);

    // Find the proper place in the table to insert him. While
    // we're walking we'll check to see if a dupe already exists.
    // When we find the right place to insert, we'll remember it, and
    // keep walking looking for a duplicate.

    PrevTCB = STRUCT_OF(TCB, &TCBTable[TCBIndex], tcb_next);
    WhereToInsert = NULL;

    while (PrevTCB->tcb_next != NULL) {
        CurrentTCB = PrevTCB->tcb_next;

        if (IP_ADDR_EQUAL(CurrentTCB->tcb_daddr, NewTCB->tcb_daddr) &&
            IP_ADDR_EQUAL(CurrentTCB->tcb_saddr, NewTCB->tcb_saddr) &&
            (CurrentTCB->tcb_sport == NewTCB->tcb_sport) &&
            (CurrentTCB->tcb_dport == NewTCB->tcb_dport)) {

            CTEFreeLockFromDPC(&NewTCB->tcb_lock);
            CTEFreeLock(&pTCBTableLock[Partition], TableHandle);
            return FALSE;

        } else {

            if (WhereToInsert == NULL && CurrentTCB > NewTCB) {
                WhereToInsert = PrevTCB;
            }
            CTEStructAssert(PrevTCB->tcb_next, tcb);
            PrevTCB = PrevTCB->tcb_next;
        }
    }

    // there can be timed_wait tcb in the tw tcb table.
    // look if there is a tcb with the same address.
    // Get lock on TW table too.


    if (WhereToInsert == NULL) {
        WhereToInsert = PrevTCB;
    }
    NewTCB->tcb_next = WhereToInsert->tcb_next;
    WhereToInsert->tcb_next = NewTCB;
    NewTCB->tcb_flags |= IN_TCB_TABLE;

    // Perform early insertion of the new TCB, since it's likely to have
    // a timer scheduled right away in any case.

    EarlyInsertTime = TCPTime + 2;
    if (EarlyInsertTime == 0) {
        EarlyInsertTime = 1;
    }

    if (NewTCB->tcb_timerslot == DUMMY_SLOT) {
        NewTCB->tcb_timertime = EarlyInsertTime;
        InsertIntoTimerWheel(NewTCB, COMPUTE_SLOT(EarlyInsertTime));
    } else if ((TCPTIME_LT(EarlyInsertTime, NewTCB->tcb_timertime)) ||
               (NewTCB->tcb_timertime == 0)) {
        NewTCB->tcb_timertime = EarlyInsertTime;
        RemoveAndInsertIntoTimerWheel(NewTCB, COMPUTE_SLOT(EarlyInsertTime));
    }

    CTEFreeLockFromDPC(&NewTCB->tcb_lock);
    CTEFreeLock(&pTCBTableLock[Partition], TableHandle);

    InterlockedIncrement((PLONG)&TStats.ts_numconns);

    return TRUE;
}

//* RemoveTCB - Remove a TCB from the tcb table.
//
//  Called when we need to remove a TCB from the TCB table. We assume the
//  TCB table lock and the TCB lock are held when we are called. If the
//  TCB isn't in the table we won't try to remove him.
//
//  Input:  RemovedTCB          - TCB to be removed.
//          PreviousState       - Previous state of the TCB.
//
//  Returns: TRUE if it's OK to free it, FALSE otherwise.
//
uint
RemoveTCB(TCB * RemovedTCB, uint PreviousState)
{
    uint TCBIndex;
    TCB *PrevTCB;
#if DBG
    uint Found = FALSE;
#endif

    CTEStructAssert(RemovedTCB, tcb);

    if (RemovedTCB->tcb_timerslot != DUMMY_SLOT) {
        ASSERT(RemovedTCB->tcb_timerslot < TIMER_WHEEL_SIZE);
        RemoveFromTimerWheel(RemovedTCB);
    }

    if (RemovedTCB->tcb_flags & IN_TCB_TABLE) {

        TcpInvokeCcb(CONN_STATE(PreviousState), TCP_CONN_CLOSED, 
                     &RemovedTCB->tcb_addrbytes, 0);
        
        TCBIndex = TCB_HASH(RemovedTCB->tcb_daddr, RemovedTCB->tcb_saddr,
                            RemovedTCB->tcb_dport, RemovedTCB->tcb_sport);

        PrevTCB = STRUCT_OF(TCB, &TCBTable[TCBIndex], tcb_next);

        do {
            if (PrevTCB->tcb_next == RemovedTCB) {
                // Found him.
                PrevTCB->tcb_next = RemovedTCB->tcb_next;
                RemovedTCB->tcb_flags &= ~IN_TCB_TABLE;
                InterlockedDecrement((PLONG)&TStats.ts_numconns);
#if DBG
                Found = TRUE;
#endif
                break;
            }
            PrevTCB = PrevTCB->tcb_next;
#if DBG
            if (PrevTCB != NULL)
                CTEStructAssert(PrevTCB, tcb);
#endif
        } while (PrevTCB != NULL);

        ASSERT(Found);

    }
    CTEGetLockAtDPC(&PendingFreeLock.Lock);
    if (TCBWalkCount != 0) {

#ifdef  PENDING_FREE_DBG
    if( RemovedTCB->tcb_flags & IN_TCB_TABLE )
       DbgBreakPoint();
#endif

        RemovedTCB->tcb_walkcount = TCBWalkCount + 1;
        *(TCB **) & RemovedTCB->tcb_delayq.q_next = PendingFreeList;
        PendingFreeList = RemovedTCB;
        CTEFreeLockFromDPC(&PendingFreeLock.Lock);
        return FALSE;

    } else {

        CTEFreeLockFromDPC(&PendingFreeLock.Lock);
        return TRUE;
    }

}

//* AllocTWTCB - Allocate a TCB.
//
//  Called whenever we need to allocate a TWTCB. We try to pull one off the
//  free list, or allocate one if we need one. We then initialize it, etc.
//
//  Input:  Nothing.
//
//  Returns: Pointer to the new TCB, or NULL if we couldn't get one.
//
TWTCB *
AllocTWTCB(uint index)
{
    TWTCB *NewTWTCB;
    LOGICAL FromList;

    // We use the reqeust pool, because its buffers are in the same size
    // range as TWTCB.  Further, it is a very active and efficient look
    // aside list whereas when TWTCBs are on their own look aside list it
    // is usually at a very small depth because TWTCBs are not allocated
    // very frequently w.r.t. to the update period of the look aside list.
    //
    NewTWTCB = PplAllocate(TcpRequestPool, &FromList);
    if (NewTWTCB) {
        NdisZeroMemory(NewTWTCB, sizeof(TWTCB));

#if DBG
        NewTWTCB->twtcb_sig = twtcb_signature;
#endif
    }

    return NewTWTCB;
}

//* AllocTCB - Allocate a TCB.
//
//  Called whenever we need to allocate a TCB. We try to pull one off the
//  free list, or allocate one if we need one. We then initialize it, etc.
//
//  Input:  Nothing.
//
//  Returns: Pointer to the new TCB, or NULL if we couldn't get one.
//
TCB *
AllocTCB(VOID)
{
    TCB *NewTCB;
    LOGICAL FromList;

    NewTCB = PplAllocate(TcbPool, &FromList);
    if (NewTCB) {
        NdisZeroMemory(NewTCB, sizeof(TCB));

#if DBG
        NewTCB->tcb_sig = tcb_signature;
#endif
        INITQ(&NewTCB->tcb_sendq);
        // Initially we're not on the fast path because we're not established. Set
        // the slowcount to one and set up the fastchk fields so we don't take the
        // fast path. We start with the assumption that all types of offloads
        // are permitted.
        NewTCB->tcb_slowcount = 1;
        NewTCB->tcb_fastchk = TCP_FLAG_ACK | TCP_FLAG_SLOW;
        NewTCB->tcb_delackticks = DEL_ACK_TICKS;
        NewTCB->tcb_allowedoffloads = TCP_IP_OFFLOAD_TYPES;
        NewTCB->tcb_partition = 0;

        CTEInitLock(&NewTCB->tcb_lock);

        INITQ(&NewTCB->tcb_timerwheelq);
        NewTCB->tcb_timerslot = DUMMY_SLOT;
        NewTCB->tcb_timertime = 0;
        NewTCB->tcb_timertype = NO_TIMER;
    }


    return NewTCB;
}


//* AllocSynTCB - Allocate a SYNTCB.
//
//  Called whenever we need to allocate a synTCB. We try to pull one off the
//  free list, or allocate one if we need one. We then initialize it, etc.
//
//  Input:  Nothing.
//
//  Returns: Pointer to the new SYNTCB, or NULL if we couldn't get one.
//
SYNTCB *
AllocSynTCB(VOID)
{
    SYNTCB *SynTCB;
    LOGICAL FromList;

    SynTCB = PplAllocate(SynTcbPool, &FromList);
    if (SynTCB) {
        NdisZeroMemory(SynTCB, sizeof(SYNTCB));

#if DBG
        SynTCB->syntcb_sig = syntcb_signature;
#endif

        CTEInitLock(&SynTCB->syntcb_lock);
    }
    return SynTCB;
}


//* FreeTCB - Free a TCB.
//
//  Called whenever we need to free a TCB.
//
//  Note: This routine may be called with the TCBTableLock held.
//
//  Input:  FreedTCB    - TCB to be freed.
//
//  Returns: Nothing.
//
VOID
FreeTCB(TCB * FreedTCB)
{
    CTELockHandle Handle;
    CTEStructAssert(FreedTCB, tcb);

    if (FreedTCB->tcb_timerslot !=  DUMMY_SLOT) {
        CTEGetLock(&FreedTCB->tcb_lock, &Handle);
    
        // This TCB should not be touched in this stage at all..
        ASSERT(FreedTCB->tcb_timerslot != DUMMY_SLOT);
    
        // Even if it does, it has to be handled properly..
        if (FreedTCB->tcb_timerslot != DUMMY_SLOT) {
            ASSERT(FreedTCB->tcb_timerslot < TIMER_WHEEL_SIZE);
            RemoveFromTimerWheel(FreedTCB);
        }
    
        CTEFreeLock(&FreedTCB->tcb_lock, Handle);
    }


    if (FreedTCB->tcb_SackBlock)
        CTEFreeMem(FreedTCB->tcb_SackBlock);

    if (FreedTCB->tcb_SackRcvd) {
        SackListEntry *tmp, *next;
        tmp = FreedTCB->tcb_SackRcvd;
        while (tmp) {
            next = tmp->next;
            CTEFreeMem(tmp);
            tmp = next;
        }
    }

    PplFree(TcbPool, FreedTCB);
}



//* FreeSynTCB - Free a TCB.
//
//  Called whenever we need to free a SynTCB.
//
//  Note: This routine may be called with the SYNTCBTableLock held.
//
//  Input:  SynTCB    - SynTCB to be freed.
//
//  Returns: Nothing.
//
VOID
FreeSynTCB(SYNTCB * SynTCB)
{
    CTEStructAssert(SynTCB, syntcb);

    PplFree(SynTcbPool, SynTCB);
}


//* FreeTWTCB - Free a TWTCB.
//
//  Called whenever we need to free a TWTCB.
//
//  Note: This routine may be called with the TWTCBTableLock held.
//
//  Input:  FreedTCB    - TCB to be freed.
//
//  Returns: Nothing.
//
__inline
void
FreeTWTCB(TWTCB * FreedTWTCB)
{
    PplFree(TcpRequestPool, FreedTWTCB);
}

NTSTATUS
GetTCBInfo(PTCP_FINDTCB_RESPONSE TCBInfo, IPAddr Dest, IPAddr Src,
           ushort DestPort, ushort SrcPort)
{
    TCB *FoundTCB;
    CTELockHandle Handle, TwHandle;
    BOOLEAN timedwait = FALSE;
    uint Index, Partition;

    FoundTCB = FindTCB(Src, Dest, DestPort, SrcPort, &Handle, FALSE, &Index);
    Partition = GET_PARTITION(Index);

    if (FoundTCB == NULL) {

        CTEGetLock(&pTWTCBTableLock[Partition], &TwHandle);
        FoundTCB = (TCB*)FindTCBTW(Src, Dest, DestPort, SrcPort, Index);
        if (!FoundTCB) {
            CTEFreeLock(&pTWTCBTableLock[Partition], TwHandle);
            return STATUS_NOT_FOUND;
        } else {
            timedwait = TRUE;
        }
    } else {
        TwHandle = Handle;
    }
    // okay we now have tcb locked.
    // copy the fileds

    TCBInfo->tcb_addr = (ULONG_PTR) FoundTCB;

    if (!timedwait) {
        TCBInfo->tcb_senduna = FoundTCB->tcb_senduna;
        TCBInfo->tcb_sendnext = FoundTCB->tcb_sendnext;
        TCBInfo->tcb_sendmax = FoundTCB->tcb_sendmax;
        TCBInfo->tcb_sendwin = FoundTCB->tcb_sendwin;
        TCBInfo->tcb_unacked = FoundTCB->tcb_unacked;
        TCBInfo->tcb_maxwin = FoundTCB->tcb_maxwin;
        TCBInfo->tcb_cwin = FoundTCB->tcb_cwin;
        TCBInfo->tcb_mss = FoundTCB->tcb_mss;
        TCBInfo->tcb_rtt = FoundTCB->tcb_rtt;
        TCBInfo->tcb_smrtt = FoundTCB->tcb_smrtt;
        TCBInfo->tcb_rexmitcnt = FoundTCB->tcb_rexmitcnt;
        TCBInfo->tcb_rexmittimer = 0; // FoundTCB->tcb_rexmittimer;
        TCBInfo->tcb_rexmit = FoundTCB->tcb_rexmit;
        TCBInfo->tcb_retrans = TStats.ts_retranssegs;
        TCBInfo->tcb_state = FoundTCB->tcb_state;

        CTEFreeLock(&FoundTCB->tcb_lock, Handle);
    } else {
        //TCBInfo->tcb_state = ((TWTCB *)FoundTCB)->twtcb_state;
        TCBInfo->tcb_state = TCB_TIME_WAIT;
        CTEFreeLock(&pTWTCBTableLock[Partition], TwHandle);
    }

    return STATUS_SUCCESS;

}

#if REFERENCE_DEBUG

uint
TcpReferenceTCB(
                IN TCB *RefTCB,
                IN uchar *File,
                IN uint Line
                )
/*++

Routine Description:

    Increases the reference count of a TCB and records a history of who
    made the call to reference.

Arguments:

    RefTCB     - The TCB to reference.
    File       - The filename containing the calling fcn (output of the __FILE__ macro).
    Line       - The line number of the call to this fcn. (output of the __LINE__ macro).

Return Value:

    The new reference count.

--*/
{
    void *CallersCaller;
    TCP_REFERENCE_HISTORY *RefHistory;

    RefHistory = &RefTCB->tcb_refhistory[RefTCB->tcb_refhistory_index];
    RefHistory->File = File;
    RefHistory->Line = Line;
    RtlGetCallersAddress(&RefHistory->Caller, &CallersCaller);
    RefHistory->Count = ++RefTCB->tcb_refcnt;
    RefTCB->tcb_refhistory_index = ++RefTCB->tcb_refhistory_index % MAX_REFERENCE_HISTORY;

    return RefTCB->tcb_refcnt;
}

uint
TcpDereferenceTCB(
                  IN TCB *DerefTCB,
                  IN uchar *File,
                  IN uint Line
                  )
/*++

Routine Description:

    Decreases the reference count of a TCB and records a history of who
    made the call to dereference.

Arguments:

    DerefTCB   - The TCB to dereference.
    File       - The filename containing the calling fcn (output of the __FILE__ macro).
    Line       - The line number of the call to this fcn. (output of the __LINE__ macro).

Return Value:

    The new reference count.

--*/
{
    void *Caller;
    TCP_REFERENCE_HISTORY *RefHistory;

    RefHistory = &DerefTCB->tcb_refhistory[DerefTCB->tcb_refhistory_index];
    RefHistory->File = File;
    RefHistory->Line = Line;

    // Because Dereference is usually called from DerefTCB, we are more
    // interested in who called DerefTCB.  So for dereference, we
    // store the caller's caller in our history. We still retain a history
    // of the actually call to this fcn via the file and line fields, so
    // we are covered if the call did not come from DerefTCB.
    //
    RtlGetCallersAddress(&Caller, &RefHistory->Caller);

    RefHistory->Count = --DerefTCB->tcb_refcnt;
    DerefTCB->tcb_refhistory_index = ++DerefTCB->tcb_refhistory_index % MAX_REFERENCE_HISTORY;

    return DerefTCB->tcb_refcnt;
}

#endif // REFERENCE_DEBUG

#pragma BEGIN_INIT

//* InitTCB - Initialize our TCB code.
//
//  Called during init time to initialize our TCB code. We initialize
//  the TCB table, etc, then return.
//
//  Input: Nothing.
//
//  Returns: TRUE if we did initialize, false if we didn't.
//
int
InitTCB(void)
{
    uint i;

    for (i = 0; i < TCB_TABLE_SIZE; i++)
        TCBTable[i] = NULL;

    CTEInitLock(&PendingFreeLock.Lock);

    LastTimeoutTime = KeQueryInterruptTime();


#ifdef  TIMER_TEST
    TCPTime = 0xfffff000;
#else
    TCPTime = 0;
#endif


    TCBWalkCount = 0;

    DeadmanTicks = NUM_DEADMAN_TIME;

#if MILLEN
    Time_Proc = 1;
    PerTimerSize = TCB_TABLE_SIZE;
#else // MILLEN
    Time_Proc = KeNumberProcessors;
    PerTimerSize = (TCB_TABLE_SIZE + Time_Proc) / Time_Proc;
#endif // !MILLEN

    for (i = 0; i < Time_Proc; i++) {
        CTEInitTimerEx(&TCBTimer[i]);
#if !MILLEN
        KeSetTargetProcessorDpc(&(TCBTimer[i].t_dpc), (CCHAR) i);
#endif // !MILLEN

       CTEStartTimerEx(&TCBTimer[i], MS_PER_TICK , TCBTimeout, NULL);
    }

    TcbPool = PplCreatePool(NULL, NULL, 0, sizeof(TCB), 'TPCT', 0);
    if (!TcbPool)
    {
        return FALSE;
    }

    SynTcbPool = PplCreatePool(NULL, NULL, 0, sizeof(SYNTCB), 'YPCT', 0);
    if (!SynTcbPool)
    {
        PplDestroyPool(TcbPool);
        return FALSE;
    }


    return TRUE;
}

//* UnInitTCB - UnInitialize our TCB code.
//
//  Called during init time if we're going to fail the init. We don't actually
//  do anything here.
//
//  Input: Nothing.
//
//  Returns: Nothing.
//
void
UnInitTCB(void)
{
    uint i;

    for (i = 0; i < Time_Proc; i++) {
        CTEStopTimer(&TCBTimer[i]);
    }
}

#pragma END_INIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\tcb.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TCB.H - TCB management definitions.
//
// This file contains the definitons needed for TCB management.
//


extern uint MaxHashTableSize;
#define TCB_TABLE_SIZE         MaxHashTableSize

extern uint LogPerPartitionSize;

#define GET_PARTITION(i) (i >> (ulong) LogPerPartitionSize)

#define MAX_REXMIT_CNT           5
#define MAX_CONNECT_REXMIT_CNT   2        //dropped from 3 to 2
#define MAX_CONNECT_RESPONSE_REXMIT_CNT  2
#define ADAPTED_MAX_CONNECT_RESPONSE_REXMIT_CNT  1

extern  uint        TCPTime;


#define ROR8(x) (ushort)( ( (ushort)(x) >> 1) | (ushort) ( ( (ushort)(x) & 1) << 15) )


#define TCB_HASH(DA,SA,DP,SP) (uint)(  ((uint)(ROR8( ROR8 (ROR8( *(ushort*)&(DP)+ \
*(ushort *)&(SP) ) + *(ushort *)&(DA)  )+ \
*((ushort *)&(DA)+1) ) ) ) & (TCB_TABLE_SIZE-1))

// These values indicate what action should be taken upon return
// of FindSynTCB - sending a reset, restting out own connection or
// just dropping the packet that was received.
#define SYN_PKT_SEND_RST        0x01
#define SYN_PKT_RST_RCVD        0x02
#define SYN_PKT_DROP            0x03

// Maximum Increment of 32K per connection.
#define MAX_ISN_INCREMENT_PER_CONNECTION 0x7FFF

// Number of connections that can increment the ISN per 100ms without
// the problem of old duplicates being a threat. Note that, this still does
// not guarantee that "wrap-around of sequence number space does not
// happen within 2MSL", which could lead to failures in reuse of Time-wait
// TCBs etc.
#define MAX_ISN_INCREMENTABLE_CONNECTIONS_PER_100MS ((0xFFFFFFFF) / \
            (MAX_REXMIT_TO * MAX_ISN_INCREMENT_PER_CONNECTION ))

// Converts a quantity represented in 100 ns units to ms.
#define X100NSTOMS(x) ((x)/10000)

extern ULONG GetDeltaTime();


extern  struct TCB  *FindTCB(IPAddr Src, IPAddr Dest, ushort DestPort,
                        ushort SrcPort,CTELockHandle *Handle, BOOLEAN Dpc,uint *index);

extern struct TCB * FindSynTCB(IPAddr Src, IPAddr Dest,
                               ushort DestPort, ushort SrcPort,
                               TCPRcvInfo RcvInfo, uint Size,
                               uint index,
                               PUCHAR Action);

extern  uint        InsertTCB(struct TCB *NewTCB, BOOLEAN ForceInsert);
extern  struct TCB  *AllocTCB(void);
extern  struct SYNTCB  *AllocSynTCB(void);

extern  struct TWTCB    *AllocTWTCB(uint index);
extern  void        FreeTCB(struct TCB *FreedTCB);
extern  void        FreeSynTCB(struct SYNTCB *FreedTCB);
extern  void        FreeTWTCB(struct TWTCB *FreedTCB);


extern  uint        RemoveTCB(struct TCB *RemovedTCB, uint PreviousState);

extern  void        RemoveTWTCB(struct TWTCB *RemovedTCB, uint Partition);

extern  struct TWTCB    *FindTCBTW(IPAddr Src, IPAddr Dest, ushort DestPort,
                        ushort SrcPort,uint index);

extern  uint        RemoveAndInsert(struct TCB *RemovedTCB);

extern  uint        ValidateTCBContext(void *Context, uint *Valid);
extern  uint        ReadNextTCB(void *Context, void *OutBuf);

extern  int         InitTCB(void);
extern  void        UnInitTCB(void);
extern  void        TCBWalk(uint (*CallRtn)(struct TCB *, void *, void *,
                        void *), void *Context1, void *Context2,
                        void *Context3);
extern  uint        DeleteTCBWithSrc(struct TCB *CheckTCB, void *AddrPtr,
                        void *Unused1, void *Unused2);
extern  uint        SetTCBMTU(struct TCB *CheckTCB, void *DestPtr,
                        void *SrcPtr, void *MTUPtr);
extern  void        ReetSendNext(struct TCB *SeqTCB, SeqNum DropSeq);
extern  uint        InsertSynTCB(SYNTCB * NewTCB,CTELockHandle *Handle);
extern  ushort      FindMSSAndOptions(TCPHeader UNALIGNED * TCPH,
                        TCB * SynTCB, BOOLEAN syntcb);
extern  void        SendSYNOnSynTCB(SYNTCB * SYNTcb,CTELockHandle TCBHandle);
extern  void        AddHalfOpenTCB(void);
extern  void        AddHalfOpenRetry(uint RexmitCnt);
extern  void        DropHalfOpenTCB(uint RexmitCnt);

extern  uint        TCBWalkCount;
extern  uint        NumTcbTablePartions;
extern  uint        PerPartionSize;
extern  uint        LogPerPartion;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\sources.inc ===
TARGETNAME=tcp
TARGETPATH=obj
TARGETTYPE=DRIVER_LIBRARY

C_DEFINES=$(C_DEFINES) -DNT -D_NTDRIVER_ -DDROP_PKT=0 -DDBG_VALIDITY_CHECK=1
NT_UP=0
PRECOMPILED_INCLUDE=..\precomp.h
MSC_WARNING_LEVEL= /W4 /WX

INCLUDES=..\;..\..\inc;$(BASE_INC_PATH);$(DS_INC_PATH)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\tcpconn.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//** TCPCONN.H - TCP connection related definitions.
//
// This file contains the definitions for connection related structures,
// such as the TCPConnReq structure.
//

#define INVALID_CONN_INDEX  0xffffff

//* Structure used for tracking Connect/Listen/Accept/Disconnect requests.

#define tcr_signature   0x20524354      // 'TCR '

typedef struct TCPConnReq {
    struct TCPReq   tcr_req;            // General request structure.
#if DBG
    ulong           tcr_sig;
#endif
    struct _TDI_CONNECTION_INFORMATION  *tcr_conninfo;    // Where to return info.
    struct _TDI_CONNECTION_INFORMATION  *tcr_addrinfo;
    ushort          tcr_flags;          // Flags for this request.
    ushort          tcr_timeout;        // Timeout value for this request.
} TCPConnReq;


#define TCR_FLAG_QUERY_ACCEPT       0x0001  // Consult client before accepting
                                            // connections.

//* Structure used for tracking abortive-disconnect requests.

typedef struct TCPAbortReq {
    CTEReqCmpltRtn  tar_rtn;            // Completion routine.
    PVOID           tar_context;        // User context.
} TCPAbortReq;


#define MAX_CONN_PER_BLOCK 256

//* Structure of a ConnTable.

typedef struct TCPConnBlock {
    DEFINE_LOCK_STRUCTURE(cb_lock)
#if DBG
    uchar   *module;
    uint    line;
#endif
    uint    cb_freecons;
    uint    cb_nextfree;
    uint    cb_blockid;
    uint    cb_conninst;
    void    *cb_conn[MAX_CONN_PER_BLOCK];
} TCPConnBlock;


//* Structure of a TCB Connection. A TCP Connection points to a TCP and an
//  address object.

typedef void (*ConnDoneRtn)(struct TCPConn *, CTELockHandle);

#define tc_signature    0x20204354      // 'TC '

typedef struct TCPConn {
#if DBG
    ulong           tc_sig;
#endif
    Queue           tc_q;               // Linkage on AO.
    struct TCB      *tc_tcb;            // Pointer to TCB for connection.
    struct AddrObj  *tc_ao;             // Back pointer to AddrObj.
    uchar           tc_inst;            // Instance number.
    uchar           tc_flags;           // Flags for connection.
    ushort          tc_refcnt;          // Count of TCBs which reference this connection.
    void            *tc_context;        // User's context.
    CTEReqCmpltRtn  tc_rtn;             // Completion routine.
    void            *tc_rtncontext;     // User context for completion routine.
    ConnDoneRtn     tc_donertn;         // Routine to call when refcnt goes to 0.
    uint            tc_tcbflags;        // Flags for TCB when it comes in.
    ulong           tc_owningpid;       // Owning process id
    uint            tc_tcbkatime;       // Initial keep alive time value for this conn.
    uint            tc_tcbkainterval;   // Keep alive interval for this conn.
    uint            tc_window;          // Default window for TCB.
    struct TCB      *tc_LastTCB;
    TCPConnBlock    *tc_ConnBlock;      //Back pointer to the conn block
    uint            tc_connid;
} TCPConn;

#define CONN_CLOSING    1               // Connection is closing.
#define CONN_DISACC     2               // Conn. is disassociating.
#define CONN_WINSET     4               // Window explictly set.
#define CONN_WINCFG     8               // Window read from configuration.
#define CONN_INVALID    (CONN_CLOSING | CONN_DISACC)


#define CONN_INDEX(c)       ((c) & 0xff)
#define CONN_BLOCKID(c)     (((c) & 0xffff00) >> 8 )
#define CONN_INST(c)        ((uchar)((c) >> 24))
#define MAKE_CONN_ID(index,block,instance)  ((((uint)(instance)) << 24) | (((uint)(block)) << 8) | ((uint)(index)))
#define INVALID_CONN_ID     0xffffffff

#define DEFAULT_CONN_BLOCKS 2;

typedef struct TCPAddrCheck {
    IPAddr  SourceAddress;
    uint    TickCount;
} TCPAddrCheckElement;

extern TCPAddrCheckElement *AddrCheckTable;

//* External definitions for TDI entry points.
extern TDI_STATUS TdiOpenConnection(PTDI_REQUEST Request, PVOID Context);
extern TDI_STATUS TdiCloseConnection(PTDI_REQUEST Request);
extern TDI_STATUS TdiAssociateAddress(PTDI_REQUEST Request, HANDLE AddrHandle);
extern TDI_STATUS TdiDisAssociateAddress(PTDI_REQUEST Request);
extern TDI_STATUS TdiConnect(PTDI_REQUEST Request, void *Timeout,
                             PTDI_CONNECTION_INFORMATION RequestAddr,
                             PTDI_CONNECTION_INFORMATION ReturnAddr);
extern TDI_STATUS TdiListen(PTDI_REQUEST Request, ushort Flags,
                            PTDI_CONNECTION_INFORMATION AcceptableAddr,
                            PTDI_CONNECTION_INFORMATION ConnectedAddr);
extern TDI_STATUS TdiAccept(PTDI_REQUEST Request,
                            PTDI_CONNECTION_INFORMATION AcceptInfo,
                            PTDI_CONNECTION_INFORMATION ConnectedInfo);
extern TDI_STATUS TdiDisconnect(PTDI_REQUEST Request, void *TO, ushort Flags,
                                PTDI_CONNECTION_INFORMATION DiscConnInfo,
                                PTDI_CONNECTION_INFORMATION ReturnInfo,
                                TCPAbortReq *AbortReq);
extern TDI_STATUS UDPConnect(PTDI_REQUEST Request, void *Timeout,
                             PTDI_CONNECTION_INFORMATION RequestAddr,
                             PTDI_CONNECTION_INFORMATION ReturnAddr);
extern TDI_STATUS UDPDisconnect(PTDI_REQUEST Request, void *TO,
                                PTDI_CONNECTION_INFORMATION DiscConnInfo,
                                PTDI_CONNECTION_INFORMATION ReturnInfo);

extern void FreeConn(TCPConn *Conn);
extern TCPConn *GetConn(void);
extern struct TCPConnReq *GetConnReq(void);
extern void FreeConnReq(struct TCPConnReq *FreedReq);
extern void DerefTCB(struct TCB *DoneTCB, CTELockHandle Handle);
extern void DerefSynTCB(struct SYNTCB *DoneTCB, CTELockHandle Handle);
extern void InitRCE(struct TCB *NewTCB);
extern void AcceptConn(struct TCB *AcceptTCB, BOOLEAN SYNSent,
                       CTELockHandle Handle);
extern void FreeConnID(TCPConn *Conn);
extern void NotifyOfDisc(struct TCB *DiscTCB, struct IPOptInfo *DiscInfo,
                         TDI_STATUS Status, CTELockHandle* Handle);
extern TCPConn *GetConnFromConnID(uint ConnID, CTELockHandle *Handle);

extern void TryToCloseTCB(struct TCB *ClosedTCB, uchar Reason,
                          CTELockHandle Handle);
extern TDI_STATUS InitTCBFromConn(struct TCPConn *Conn, struct TCB *NewTCB,
                                  PTDI_CONNECTION_INFORMATION Addr, uint AOLocked);

extern void PushData(struct TCB *PushTCB, BOOLEAN PushAll);
extern TDI_STATUS MapIPError(IP_STATUS IPError, TDI_STATUS Default);
extern void GracefulClose(struct TCB *CloseTCB, uint ToTimeWait, uint Notify,
                          CTELockHandle Handle);
extern void RemoveTCBFromConn(struct TCB *RemovedTCB);
extern void InitAddrChecks();
extern int  ConnCheckPassed(IPAddr Src, ulong Prt);
extern void EnumerateConnectionList(uchar *Buffer, ulong BufferSize,
                                    ulong *EntriesReturned, ulong *EntriesAvailable);
extern void ValidateMSS(TCB* MssTCB);
extern void AdjustTCBFromRCE(TCB* RceTCB);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\secfltr.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

#ifndef _SECFLTR_INCLUDED
#define _SECFLTR_INCLUDED 1


//** SECFLTR.H - Security filtering support
//
//  This file contains definitions related to security filtering.
//

//
// Functions
//
extern void
InitializeSecurityFilters(void);

extern void
CleanupSecurityFilters(void);

extern uint
IsSecurityFilteringEnabled(void);

extern void
ControlSecurityFiltering(uint IsEnabled);

extern void
AddProtocolSecurityFilter(IPAddr InterfaceAddress, ulong Protocol,
                             NDIS_HANDLE  ConfigHandle);

extern void
DeleteProtocolSecurityFilter(IPAddr InterfaceAddress, ulong Protocol);

extern TDI_STATUS
AddValueSecurityFilter(IPAddr InterfaceAddress, ulong Protocol,
                       ulong FilterValue);

extern TDI_STATUS
DeleteValueSecurityFilter(IPAddr InterfaceAddress, ulong Protocol,
                          ulong FilterValue);

extern void
EnumerateSecurityFilters(IPAddr InterfaceAddress, ulong Protocol,
                         ulong Value, uchar *Buffer, ulong BufferSize,
                         ulong *EntriesReturned, ulong *EntriesAvailable);

extern BOOLEAN
IsPermittedSecurityFilter(IPAddr InterfaceAddress, void *IPContext,
                          ulong Protocol, ulong FilterValue);



#endif  // _SECFLTR_INCLUDED


=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\tcpconn.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//** TCPCONN.C - TCP connection mgmt code.
//
//  This file contains the code handling TCP connection related requests,
//  such as connecting and disconnecting.
//

#include "precomp.h"
#include "md5.h"
#include "addr.h"
#include "tcp.h"
#include "tcb.h"
#include "tcpconn.h"
#include "tcpsend.h"
#include "tcprcv.h"
#include "pplasl.h"
#include "tcpdeliv.h"
#include "tlcommon.h"
#include "info.h"
#include "tcpcfg.h"

#if !MILLEN
#include "crypto\rc4.h"
#include "ntddksec.h"
#endif // !MILLEN


uint MaxConnBlocks = DEFAULT_CONN_BLOCKS;
uint ConnPerBlock = MAX_CONN_PER_BLOCK;

uint NextConnBlock = 0;
uint MaxAllocatedConnBlocks = 0;

TCPConnBlock **ConnTable = NULL;
HANDLE TcpConnPool;
extern HANDLE TcpRequestPool;

extern uint GlobalMaxRcvWin;

extern uint TCBWalkCount;
extern TCB *PendingFreeList;
extern CACHE_LINE_KSPIN_LOCK PendingFreeLock;

extern AORequest *GetAORequest(uint Type);

//
// ISN globals.
//

#if !MILLEN
#define ISN_KEY_SIZE 256        // 2048 bits.
#define ISN_DEF_RAND_STORE_SIZE 256
#define ISN_MIN_RAND_STORE_SIZE 1
#define ISN_MAX_RAND_STORE_SIZE 16384

RC4_KEYSTRUCT g_rc4keyIsn;

typedef struct _ISN_RAND_STORE {
    MD5_CONTEXT Md5Context;
    ulong   iBuf;
    ushort* pBuf;
} ISN_RAND_STORE, *PISN_RAND_STORE;

PISN_RAND_STORE g_pRandIsnStore;

ulong g_cRandIsnStore = ISN_DEF_RAND_STORE_SIZE;
ulong g_maskRandIsnStore;
#else // !MILLEN
ulong g_dwRandom;
#endif // MILLEN

SeqNum g_CurISN = 0;
int g_Credits;
int g_LastIsnUpdateTime;
int g_MaxCredits;


uint
InitIsnGenerator()
/*++

Routine Description:

    Initializes the ISN generator. In this case, calls in to get 2048 bits
    random and creates an RC4 key.

Arguments:

    None.

Return Value:

    TRUE  - success.
    FALSE - failure.

Called at PASSIVE level.

--*/

{
#if MILLEN
    g_CurISN = CTESystemUpTime();
    g_dwRandom = g_CurISN;
    return TRUE;
#else // MILLEN
    UNICODE_STRING DeviceName;
    NTSTATUS NtStatus;
    PFILE_OBJECT pFileObject;
    PDEVICE_OBJECT pDeviceObject;
    unsigned char pBuf[ISN_KEY_SIZE];
    PIRP pIrp;
    IO_STATUS_BLOCK ioStatusBlock;
    KEVENT kEvent;
    ULONG cBits = 0;
    ULONG i;
    ULONG MD5Key[MD5_DATA_LENGTH];
    ULONG cProcs = KeNumberProcessors;

    // Start with the credits that would last for 1 tick.
    g_MaxCredits = g_Credits = MAX_ISN_INCREMENTABLE_CONNECTIONS_PER_100MS;
    g_LastIsnUpdateTime = (int)X100NSTOMS(KeQueryInterruptTime());


    // Request a block of random bits from the KSecDD driver.
    // To do so, retrieve its device object pointer, build an I/O control
    // request to be submitted to the driver, and submit the request.
    // If any failure occurs, we fall back on the somewhat less-random
    // approach of requesting the bits from the randlibk library.

    for (; ;) {

        RtlInitUnicodeString(
                             &DeviceName,
                             DD_KSEC_DEVICE_NAME_U);

        KeInitializeEvent(&kEvent, SynchronizationEvent, FALSE);

        // Get the file and device objects for KDSECDD,
        // acquire a reference to the device-object,
        // release the unneeded reference to the file-object,
        // and build the I/O control request to issued to KSecDD.

        NtStatus = IoGetDeviceObjectPointer(
                                            &DeviceName,
                                            FILE_ALL_ACCESS,
                                            &pFileObject,
                                            &pDeviceObject);

        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Tcpip: IoGetDeviceObjectPointer(KSecDD)=%08x\n",
                     NtStatus));
            break;
        }
        ObReferenceObject(pDeviceObject);
        ObDereferenceObject(pFileObject);

        pIrp = IoBuildDeviceIoControlRequest(
                                             IOCTL_KSEC_RNG,
                                             pDeviceObject,
                                             NULL,    // No input buffer.
                                             0,
                                             pBuf,    // Output buffer stores rng.
                                             ISN_KEY_SIZE,
                                             FALSE,
                                             &kEvent,
                                             &ioStatusBlock);

        if (pIrp == NULL) {
            ObDereferenceObject(pDeviceObject);
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }
        // Issue the I/O control request, wait for it to complete
        // if necessary, and release the reference to KSecDD's device-object.

        NtStatus = IoCallDriver(pDeviceObject, pIrp);

        if (NtStatus == STATUS_PENDING) {
            KeWaitForSingleObject(
                                  &kEvent,
                                  Executive,
                                  KernelMode,
                                  FALSE,    // Not alertable.
                                  NULL);    // No timeout.

            NtStatus = ioStatusBlock.Status;
        }
        ObDereferenceObject(pDeviceObject);

        if (!NT_SUCCESS(NtStatus)) {
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                     "Tcpip: IoCallDriver IOCTL_KSEC_RNG failed %#x\n", NtStatus));
            break;
        }
        break;
    }

    if (!NT_SUCCESS(NtStatus)) {
        return FALSE;
    }

    // Generate the key control structure.
    rc4_key(&g_rc4keyIsn, ISN_KEY_SIZE, pBuf);

    // Initalialize the current sequence number to a random value.
    rc4(&g_rc4keyIsn, sizeof(SeqNum), (uchar*)&g_CurISN);

    // Generate a random Key value for using along with the MD5 hash
    rc4(&g_rc4keyIsn, sizeof(ULONG) * MD5_DATA_LENGTH, (uchar*)&MD5Key);

    //
    // Round down the store size to power of 2. Verify in range.
    //

    while ((g_cRandIsnStore = g_cRandIsnStore >> 1) != 0) {
        cBits++;
    }

    g_cRandIsnStore = 1 << cBits;

    if (g_cRandIsnStore < ISN_MIN_RAND_STORE_SIZE ||
        g_cRandIsnStore > ISN_MAX_RAND_STORE_SIZE) {
        g_cRandIsnStore = ISN_DEF_RAND_STORE_SIZE;
    }
    // The mask is store size - 1.
    g_maskRandIsnStore = g_cRandIsnStore - 1;

    //
    // Initialize the random ISN store. One array/index per processor.
    //

    g_pRandIsnStore = CTEAllocMemBoot(cProcs * sizeof(ISN_RAND_STORE));

    if (g_pRandIsnStore == NULL) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Tcpip: failed to allocate ISN rand store\n"));
        return (FALSE);
    }
    memset(g_pRandIsnStore, 0, sizeof(ISN_RAND_STORE) * cProcs);

    for (i = 0; i < cProcs; i++) {
        g_pRandIsnStore[i].pBuf = CTEAllocMemBoot(sizeof(ushort) * g_cRandIsnStore);

        if (g_pRandIsnStore[i].pBuf == NULL) {
            goto error1;
        }
        rc4(
            &g_rc4keyIsn,
            sizeof(ushort) * g_cRandIsnStore,
            (uchar*)g_pRandIsnStore[i].pBuf);

        // Initialize the MD5 parameters.
        MD5Init(&g_pRandIsnStore[i].Md5Context, MD5Key);
    }

    return (TRUE);

  error1:

    for (i = 0; i < cProcs; i++) {
        if (g_pRandIsnStore[i].pBuf != NULL) {
            CTEFreeMem(g_pRandIsnStore[i].pBuf);
        }
    }
    CTEFreeMem(g_pRandIsnStore);

    return (FALSE);
#endif // !MILLEN
}


int
GetRandBits()
/*++

 Routine Description:

    Returns 16 random bits from the random number array generated using RC4.
    When the store is exhausted, it will be replenished.

 Arguments:

    None.

 Return Value:

    16 bits of random data.

--*/
{
    ulong iStore;
    int randbits;
    ulong iProc = KeGetCurrentProcessorNumber();

    // Get index into the random store. Mask performs mod operation.
    iStore = ++g_pRandIsnStore[iProc].iBuf
                        & g_maskRandIsnStore;

    ASSERT(iStore < g_cRandIsnStore);

    randbits = g_pRandIsnStore[iProc].pBuf[iStore];

    if (iStore == 0) {
        rc4( &g_rc4keyIsn, sizeof(ushort) * g_cRandIsnStore,
                (uchar*) g_pRandIsnStore[iProc].pBuf);
    }

    return randbits;
}


ULONG
GetDeltaTime()
/*++

 Routine Description:

    Tracks the time-based updates of ISN. It will return the time elapsed since
    the last time this function was called. This would be used by the caller to
    increment the ISN by an appropriate amount. Note that the maximum value
    this function returns is 200 MS.

 Arguments:

    None.

 Return Value:

    Delta time in milli-seconds.

--*/
{
    // If the time has changed since the ISN was updated last time, it
    // can be incremented now.
    int PreviousUpdateTime, Delta;
    int CurrentUpdateTime = (int)X100NSTOMS(KeQueryInterruptTime());

    PreviousUpdateTime = InterlockedExchange(
                (PLONG)&g_LastIsnUpdateTime, CurrentUpdateTime);

    Delta = CurrentUpdateTime - PreviousUpdateTime;

    if (Delta > 0) {
        return MIN(Delta,200);
    } else {
        return 0;
    }
}



VOID
GetRandomISN(
    PULONG SeqNum,
    TCPAddrInfo *TcpAddr
    )
/*++

 Routine Description:

    Called when an Initial Sequence Number (ISN) is needed. Calls crypto
    functions for random number generation.

 Arguments:

    SeqNum - This will be updated with the value of the ISN generated.

    TcpAddr - This points to the address information of a TCP connection:
        [Destination Address, Source Address, Destination Port, Source Port]. 
        They should be always in the same order, otherwise the sequence numbers
        would not be monotonically increasing.

 Return Value:

    None.

--*/
{
#if MILLEN
    ulong randbits;

    // Pseudo random bits based on time.
    randbits = CTESystemUpTime() + *SeqNum;

    g_dwRandom = ROTATE_LEFT(randbits^g_dwRandom, 15);

    // We want to add between 32K and 64K of random, so adjust. There are 16
    // bits of randomness, just ensure that the high order bit is set and we
    // have >= 32K and <= (64K-1)::15bits of randomness.
    randbits = (g_dwRandom & 0xffff) | 0x8000;

    // Update global CurISN. InterlockedExchangeAdd returns initial value
    // (not the added value).
    *SeqNum = InterlockedExchangeAdd(&g_CurISN, randbits);

    // We don't need to add randbits here. We have randomized the global
    // counter which is good enough for next time we choose ISN.
    /* pTcb->tcb_sendnext += randbits; */

    return;
#else // MILLEN
    ULONG randbits;
    ulong iProc;

    //
    // Raise IRQL to DISPATCH so that we don't get swapped out while accessing
    // the processor specific array. Check to see if already at DISPATCH
    // before doing the work.
    //

    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);

    // Make sure the caller is not passing in un-initialized values for the
    // address variables.
    ASSERT((TcpAddr->tai_daddr != 0) && (TcpAddr->tai_saddr != 0) && 
           ((TcpAddr->tai_sport != 0) || (TcpAddr->tai_dport != 0)));

    iProc = KeGetCurrentProcessorNumber();

    // Add the random number only if the number of connections that can
    // increment the sequence number within this time period is non zero.
    // [Note: This could make the g_Credits less than 0, but it is not a
    // problem].
    if((g_Credits > 0) && (InterlockedDecrement((PLONG)&g_Credits) > 0)) {
        randbits = GetRandBits();

        // We want to add between 16K and 32K of random, so adjust. There are
        // 15 bits of randomness, just ensure that the high order bit is set
        // and we have >= 16K and <= (32K-1)::14bits of randomness.
        randbits &= 0x7FFF;
        randbits |= 0x4000;

    } else {
        int Delta = GetDeltaTime();

        if(Delta > 0) {
            randbits = GetRandBits();

            // We can add anywhere from 256 to 512 per ms.
            randbits &= 0x1FF;
            randbits |= 0x100;

            randbits *= Delta;
        } else {
            randbits = 0;
        }
    }

    // Update global CurISN. InterlockedExchangeAdd returns initial value
    // (not the added value).
    *SeqNum = InterlockedExchangeAdd((PLONG)&g_CurISN, randbits);

    // Move 3 words from the connection.
    RtlCopyMemory(&g_pRandIsnStore[iProc].Md5Context.Data, TcpAddr,
                  sizeof(TCPAddrInfo));

    // Add the Invariant hash to the sequence number.
    *SeqNum += ComputeMd5Transform(&(g_pRandIsnStore[iProc].Md5Context));

    return;
#endif // !MILLEN
}


extern PDRIVER_OBJECT TCPDriverObject;

DEFINE_LOCK_STRUCTURE(ConnTableLock)
extern CTELock *pTCBTableLock;
extern CTELock *pTWTCBTableLock;

TCPAddrCheckElement *AddrCheckTable = NULL;        // The current check table

extern IPInfo LocalNetInfo;
extern void RemoveConnFromAO(AddrObj * AO, TCPConn * Conn);

//
// All of the init code can be discarded.
//

int InitTCPConn(void);
void UnInitTCPConn(void);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, InitTCPConn)
#pragma alloc_text(INIT, UnInitTCPConn)
#endif


void CompleteConnReq(TCB * CmpltTCB, IPOptInfo * OptInfo, TDI_STATUS Status);

//** Routines for handling conn refcount going to 0.

//* DummyDone - Called when nothing to do.
//
//  Input:  Conn    - Conn goint to 0.
//          Handle  - Lock handle for conn table lock.
//
//  Returns: Nothing.
//
void
DummyDone(TCPConn * Conn, CTELockHandle Handle)
{
    CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), Handle);
}

//* DummyCmplt - Dummy close completion routine.
void
DummyCmplt(PVOID Dummy1, uint Dummy2, uint Dummy3)
{
}

//* CloseDone - Called when we need to complete a close.
//
//  Input:  Conn    - Conn going to 0.
//          Handle  - Lock handle for conn table lock.
//
//  Returns: Nothing.
//
void
CloseDone(TCPConn * Conn, CTELockHandle Handle)
{
    CTEReqCmpltRtn Rtn;            // Completion routine.
    PVOID Context;                // User context for completion routine.
    CTELockHandle AOTableHandle;
    AddrObj *AO;

    ASSERT(Conn->tc_flags & CONN_CLOSING);

    Rtn = Conn->tc_rtn;
    Context = Conn->tc_rtncontext;
    CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), Handle);

    CTEGetLock(&AddrObjTableLock.Lock, &AOTableHandle);
    CTEGetLockAtDPC(&(Conn->tc_ConnBlock->cb_lock));
#if DBG
    Conn->tc_ConnBlock->line = (uint) __LINE__;
    Conn->tc_ConnBlock->module = (uchar *) __FILE__;
#endif

    if ((AO = Conn->tc_ao) != NULL) {

        CTEStructAssert(AO, ao);

        // It's associated.
        CTEGetLockAtDPC(&AO->ao_lock);
        RemoveConnFromAO(AO, Conn);
        // We've pulled him from the AO, we can free the lock now.
        CTEFreeLockFromDPC(&AO->ao_lock);
    }
    CTEFreeLockFromDPC(&(Conn->tc_ConnBlock->cb_lock));
    CTEFreeLock(&AddrObjTableLock.Lock, AOTableHandle);

    FreeConn(Conn);

    (*Rtn) (Context, TDI_SUCCESS, 0);

}

//* DisassocDone - Called when we need to complete a disassociate.
//
//  Input:  Conn    - Conn going to 0.
//          Handle  - Lock handle for conn table lock.
//
//  Returns: Nothing.
//
void
DisassocDone(TCPConn * Conn, CTELockHandle Handle)
{
    CTEReqCmpltRtn Rtn;            // Completion routine.
    PVOID Context;                // User context for completion routine.
    AddrObj *AO;
    CTELockHandle AOTableHandle, ConnTableHandle, AOHandle;
    uint NeedClose = FALSE;

    ASSERT(Conn->tc_flags & CONN_DISACC);
    ASSERT(!(Conn->tc_flags & CONN_CLOSING));
    ASSERT(Conn->tc_refcnt == 0);

    Rtn = Conn->tc_rtn;
    Context = Conn->tc_rtncontext;
    Conn->tc_refcnt = 1;
    CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), Handle);

    CTEGetLock(&AddrObjTableLock.Lock, &AOTableHandle);
    CTEGetLock(&(Conn->tc_ConnBlock->cb_lock), &ConnTableHandle);
#if DBG
    Conn->tc_ConnBlock->line = (uint) __LINE__;
    Conn->tc_ConnBlock->module = (uchar *) __FILE__;
#endif
    if (!(Conn->tc_flags & CONN_CLOSING)) {

        AO = Conn->tc_ao;
        if (AO != NULL) {
            CTEGetLock(&AO->ao_lock, &AOHandle);
            RemoveConnFromAO(AO, Conn);
            CTEFreeLock(&AO->ao_lock, AOHandle);
        }
        ASSERT(Conn->tc_refcnt == 1);
        Conn->tc_flags &= ~CONN_DISACC;
    } else
        NeedClose = TRUE;

    Conn->tc_refcnt = 0;
    CTEFreeLock(&AddrObjTableLock.Lock, ConnTableHandle);

    if (NeedClose) {
        CloseDone(Conn, AOTableHandle);
    } else {
        CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), AOTableHandle);
        (*Rtn) (Context, TDI_SUCCESS, 0);
    }

}

PVOID
NTAPI
TcpConnAllocate (
    IN POOL_TYPE PoolType,
    IN SIZE_T NumberOfBytes,
    IN ULONG Tag
    )
{
    TCPConn *Conn;

    Conn = ExAllocatePoolWithTag(PoolType, NumberOfBytes, Tag);

    if (Conn) {
        NdisZeroMemory(Conn, sizeof(TCPConn));

        Conn->tc_connid = INVALID_CONN_ID;
    }
    return Conn;
}


VOID
NTAPI
TcpConnFree (
    IN PVOID Buffer
    )
{
    ExFreePool(Buffer);
}


__inline
VOID
FreeConn(TCPConn *Conn)
{
    PplFree(TcpConnPool, Conn);
}

TCPConn *
GetConn()
{
    TCPConn *Conn;
    uint id;
    TCPConnBlock *ConnBlock;
    LOGICAL FromList;

    Conn = PplAllocate(TcpConnPool, &FromList);
    if (Conn) {

        // If the allocation was satisifed from the lookaside list,
        // we need to reinitialize the connection structure.
        //
        if (FromList)
        {
            // Save these to avoid an expensive lookup later.
            //
            id = Conn->tc_connid;
            ConnBlock = Conn->tc_ConnBlock;

            NdisZeroMemory(Conn, sizeof(TCPConn));

            Conn->tc_connid = id;
            Conn->tc_ConnBlock = ConnBlock;
        }
    }
    return Conn;
}

//* FreeConnReq - Free a connection request structure.
//
//  Called to free a connection request structure.
//
//  Input:  FreedReq    - Connection request structure to be freed.
//
//  Returns: Nothing.
//
__inline
VOID
FreeConnReq(TCPConnReq *Request)
{
    PplFree(TcpRequestPool, Request);
}

//* GetConnReq - Get a connection request structure.
//
//  Called to get a connection request structure.
//
//  Input:  Nothing.
//
//  Returns: Pointer to ConnReq structure, or NULL if none.
//
__inline
TCPConnReq *
GetConnReq(VOID)
{
    TCPConnReq *Request;
    LOGICAL FromList;

    Request = PplAllocate(TcpRequestPool, &FromList);
    if (Request) {
#if DBG
        Request->tcr_req.tr_sig = tr_signature;
        Request->tcr_sig = tcr_signature;
#endif
    }

    return Request;
}

//* GetConnFromConnID - Get a Connection from a connection ID.
//
//  Called to obtain a Connection pointer from a ConnID. We don't actually
//  check the connection pointer here, but we do bounds check the input ConnID
//  and make sure the instance fields match.
//
//  Input:  ConnID      - Connection ID to find a pointer for.

//
//  Returns: Pointer to the TCPConn, or NULL.
//           Also, returns with conn block lock held.
//
TCPConn *
GetConnFromConnID(uint ConnID, CTELockHandle * Handle)
{
    uint ConnIndex = CONN_INDEX(ConnID);
    uint ConnBlockId = CONN_BLOCKID(ConnID);
    uchar inst = CONN_INST(ConnID);
    TCPConn *MatchingConn = NULL;
    TCPConnBlock *ConnBlock;

    if ((ConnIndex < MAX_CONN_PER_BLOCK) &&
        (ConnBlockId < MaxAllocatedConnBlocks)) {

        // Peek at the ConnTable slot and, if it looks occupied,
        // take the lock to reconfirm its occupancy.

        ConnBlock = (ConnTable)[ConnBlockId];
        if (ConnBlock && ConnBlock->cb_conn[ConnIndex]) {
            CTEGetLock(&(ConnBlock->cb_lock), Handle);
            MatchingConn = ConnBlock->cb_conn[ConnIndex];
            if (MatchingConn) {
#if DBG
                ConnBlock->line = (uint) __LINE__;
                ConnBlock->module = (uchar *) __FILE__;
#endif
                CTEStructAssert(MatchingConn, tc);

                if (inst != MatchingConn->tc_inst) {
                    MatchingConn = NULL;
                    CTEFreeLock(&(ConnBlock->cb_lock), *Handle);
                }
            } else {
                CTEFreeLock(&(ConnBlock->cb_lock), *Handle);
            }
        }
    } else {
        MatchingConn = NULL;
    }

    return MatchingConn;
}

//* GetConnID - Get a ConnTable slot.
//
//  Called during OpenConnection to find a free slot in the ConnTable and
//  set it up with a connection. We assume the caller holds the lock on the
//  TCB ConnTable when we are called.
//
//  Input: NewConn      - Connection to enter into slot..
//
//  Returns: A ConnId to use.
//
uint
GetConnID(TCPConn * NewConn, CTELockHandle * Handle)
{
    uint CurrConnID = NewConn->tc_connid;
    uint i, j, block, k;        // Index variable.
    CTELockHandle TableHandle;
    uchar inst;

    //see if newconn has a valid conn id and if the slot is still free
    //assuming that this came from freelist

    if (CurrConnID != INVALID_CONN_ID) {

        //just peek first.
        //Assuming Connblock as still valid!!

        if (!(NewConn->tc_ConnBlock->cb_conn)[CONN_INDEX(CurrConnID)]) {
            CTEGetLock(&(NewConn->tc_ConnBlock->cb_lock), Handle);
#if DBG
            NewConn->tc_ConnBlock->line = (uint) __LINE__;
            NewConn->tc_ConnBlock->module = (uchar *) __FILE__;
#endif

            //make sure that this slot is still empty

            if (!(NewConn->tc_ConnBlock->cb_conn)[CONN_INDEX(CurrConnID)]) {
                (NewConn->tc_ConnBlock->cb_conn)[CONN_INDEX(CurrConnID)] = NewConn;

                NewConn->tc_ConnBlock->cb_freecons--;

                NewConn->tc_inst = NewConn->tc_ConnBlock->cb_conninst++;

                NewConn->tc_connid = MAKE_CONN_ID(CONN_INDEX(CurrConnID), NewConn->tc_ConnBlock->cb_blockid, NewConn->tc_inst);
                //return with this block_lock held.

                return NewConn->tc_connid;
            }
            CTEFreeLock(&(NewConn->tc_ConnBlock->cb_lock), *Handle);

        }
    }
    //Nope. try searching for a free slot from the last block that
    //we have seen

    if (MaxAllocatedConnBlocks) {

        uint TempMaxConnBlocks = MaxAllocatedConnBlocks;
        uint TempNextConnBlock = NextConnBlock;

        for (k = 0; k < TempMaxConnBlocks; k++) {

            if (TempNextConnBlock >= TempMaxConnBlocks) {
                //wrap around the allocated blocks

                TempNextConnBlock = 0;
            }
            i = TempNextConnBlock;

            //Since this is part of allocated, it can not be null

            ASSERT(ConnTable[TempNextConnBlock] != NULL);

            //Peek if this block  has free slots

            if ((ConnTable[i])->cb_freecons) {

                CTEGetLock(&(ConnTable[i])->cb_lock, Handle);
#if DBG
                ConnTable[i]->line = (uint) __LINE__;
                ConnTable[i]->module = (uchar *) __FILE__;
#endif

                if ((ConnTable[i])->cb_freecons) {
                    //it still has free slots if nextfree is valid
                    // no need to loop around

                    uint index = (ConnTable[i])->cb_nextfree;

                    for (j = 0; j < MAX_CONN_PER_BLOCK; j++) {

                        if (index >= MAX_CONN_PER_BLOCK) {
                            index = 0;
                        }
                        if (!((ConnTable[i])->cb_conn)[index]) {

                            ((ConnTable[i])->cb_conn)[index] = NewConn;
                            (ConnTable[i])->cb_freecons--;

                            inst = NewConn->tc_inst = (ConnTable[i])->cb_conninst++;
                            block = (ConnTable[i])->cb_blockid;
                            NewConn->tc_ConnBlock = ConnTable[i];
                            NewConn->tc_connid = MAKE_CONN_ID(index, block, inst);

                            (ConnTable[i])->cb_nextfree = index++;

                            NextConnBlock = TempNextConnBlock++;

                            if (NextConnBlock > MaxAllocatedConnBlocks) {
                                NextConnBlock = 0;
                            }
                            return NewConn->tc_connid;
                        }
                        index++;

                    }
#if DBG
                    // we should have got a slot if freecons is correct
                    KdPrint(("Connid: Inconsistent freecon %x\n", ConnTable[i]));
                    DbgBreakPoint();
#endif
                }
                CTEFreeLock(&(ConnTable[i])->cb_lock, *Handle);
            }
            //no more freeslots. try next allocated block
            TempNextConnBlock++;
        }
    } //if MaxAllocatedConnBlocks

    //Need to create a conn block at next index.
    //we need a lock for mp safe

    CTEGetLock(&ConnTableLock, Handle);

    if (MaxAllocatedConnBlocks < MaxConnBlocks) {
        uint cbindex = MaxAllocatedConnBlocks;
        TCPConnBlock *ConnBlock;

        ConnBlock = CTEAllocMemN(sizeof(TCPConnBlock), 'CPCT');
        if (ConnBlock) {

            NdisZeroMemory(ConnBlock, sizeof(TCPConnBlock));
            CTEInitLock(&(ConnBlock->cb_lock));
            ConnBlock->cb_blockid = cbindex;

            //hang on to this lock while inserting

            CTEGetLock(&(ConnBlock->cb_lock), &TableHandle);
#if DBG
            ConnBlock->line = (uint) __LINE__;
            ConnBlock->module = (uchar *) __FILE__;
#endif

            //get the first slot for ourselves

            ConnBlock->cb_freecons = MAX_CONN_PER_BLOCK - 1;

            ConnBlock->cb_nextfree = 1;

            inst = ConnBlock->cb_conninst = 1;
            NewConn->tc_ConnBlock = ConnBlock;
            (ConnBlock->cb_conn)[0] = NewConn;

            NewConn->tc_connid = MAKE_CONN_ID(0, cbindex, inst);
            NewConn->tc_inst = inst;
            ConnBlock->cb_conninst++;

            //assignment is atomic!!
            ConnTable[cbindex] = ConnBlock;

            MaxAllocatedConnBlocks++;

            CTEFreeLock(&ConnTableLock, TableHandle);

            return NewConn->tc_connid;
        }
    }
    CTEFreeLock(&ConnTableLock, *Handle);
    return INVALID_CONN_ID;

}

//* FreeConnID - Free a ConnTable slot.
//
//  Called when we're done with a ConnID. We assume the caller holds the lock
//  on the TCB ConnTable when we are called.
//
//  Input: ConnID       - Connection ID to be freed.
//
//  Returns: Nothing.
//
void
FreeConnID(TCPConn * Conn)
{
    uint Index = CONN_INDEX(Conn->tc_connid);    // Index into conn table.
    uint cbIndex;
    TCPConnBlock *ConnBlock = Conn->tc_ConnBlock;

    cbIndex = CONN_BLOCKID(Conn->tc_connid);
    ASSERT(Index < MAX_CONN_PER_BLOCK);
    ASSERT(cbIndex < MaxAllocatedConnBlocks);
    ASSERT((ConnBlock->cb_conn)[Index] != NULL);

    if ((ConnBlock->cb_conn)[Index]) {
        (ConnBlock->cb_conn)[Index] = NULL;
        ConnBlock->cb_freecons++;
        ConnBlock->cb_nextfree = Index;
        ASSERT(ConnBlock->cb_freecons <= MAX_CONN_PER_BLOCK);
    } else {
        ASSERT(0);
    }
}

//* MapIPError - Map an IP error to a TDI error.
//
//  Called to map an input IP error code to a TDI error code. If we can't,
//  we return the provided default.
//
//  Input:  IPError     - Error code to be mapped.
//          Default     - Default error code to return.
//
//  Returns: Mapped TDI error.
//
TDI_STATUS
MapIPError(IP_STATUS IPError, TDI_STATUS Default)
{
    switch (IPError) {

    case IP_DEST_NET_UNREACHABLE:
        return TDI_DEST_NET_UNREACH;
    case IP_DEST_HOST_UNREACHABLE:
    case IP_NEGOTIATING_IPSEC:
        return TDI_DEST_HOST_UNREACH;
    case IP_DEST_PROT_UNREACHABLE:
        return TDI_DEST_PROT_UNREACH;
    case IP_DEST_PORT_UNREACHABLE:
        return TDI_DEST_PORT_UNREACH;
    default:
        return Default;
    }
}

//* FinishRemoveTCBFromConn - Finish removing a TCB from a conn structure.
//
//  Called when we have the locks we need and we just want to pull the
//  TCB off the connection. The caller must hold the ConnTableLock before
//      calling this.
//
//  Input:  RemovedTCB      - TCB to be removed.
//
//  Returns: Nothing.
//
void
FinishRemoveTCBFromConn(TCB * RemovedTCB)
{
    TCPConn *Conn;
    CTELockHandle ConnHandle;
    AddrObj *AO;
    TCPConnBlock *ConnBlock = NULL;


    if (((Conn = RemovedTCB->tcb_conn) != NULL) &&
        (Conn->tc_tcb == RemovedTCB)) {

        CTEStructAssert(Conn, tc);
        ConnBlock = Conn->tc_ConnBlock;

        CTEGetLock(&(ConnBlock->cb_lock), &ConnHandle);
#if DBG
        ConnBlock->line = (uint) __LINE__;
        ConnBlock->module = (uchar *) __FILE__;
#endif

        AO = Conn->tc_ao;

        if (AO != NULL) {
            CTEGetLockAtDPC(&AO->ao_lock);

            if (AO_VALID(AO)) {

                CTEGetLockAtDPC(&RemovedTCB->tcb_lock);

                // Need to double check this is still correct.
                if (Conn == RemovedTCB->tcb_conn) {
                    // Everything still looks good.
                    REMOVEQ(&Conn->tc_q);
                    //ENQUEUE(&AO->ao_idleq, &Conn->tc_q);
                    PUSHQ(&AO->ao_idleq, &Conn->tc_q);
                } else
                    Conn = RemovedTCB->tcb_conn;
            } else {
                CTEGetLockAtDPC(&RemovedTCB->tcb_lock);
                Conn = RemovedTCB->tcb_conn;
            }

            CTEFreeLockFromDPC(&AO->ao_lock);
        } else {
            CTEGetLockAtDPC(&RemovedTCB->tcb_lock);
            Conn = RemovedTCB->tcb_conn;
        }

        if (Conn != NULL) {
            if (Conn->tc_tcb == RemovedTCB) {
#if TRACE_EVENT
                PTDI_DATA_REQUEST_NOTIFY_ROUTINE CPCallBack;
                WMIData WMIInfo;

                CPCallBack = TCPCPHandlerRoutine;
                if (CPCallBack != NULL) {
                    ulong GroupType;
                    WMIInfo.wmi_srcaddr     = RemovedTCB->tcb_saddr;
                    WMIInfo.wmi_srcport     = RemovedTCB->tcb_sport;
                    WMIInfo.wmi_destaddr    = RemovedTCB->tcb_daddr;
                    WMIInfo.wmi_destport    = RemovedTCB->tcb_dport;
                    WMIInfo.wmi_context     = RemovedTCB->tcb_cpcontext;
                    WMIInfo.wmi_size        = 0;
                    GroupType = EVENT_TRACE_GROUP_TCPIP + EVENT_TRACE_TYPE_DISCONNECT;
                    (*CPCallBack) (GroupType, (PVOID) &WMIInfo, sizeof(WMIInfo), NULL);
                }
#endif

                Conn->tc_tcb = NULL;
                //RemovedTCB->tc_connid=0;
                Conn->tc_LastTCB = RemovedTCB;
            } else {

                ASSERT(Conn->tc_tcb == NULL);
            }
        }
        CTEFreeLockFromDPC(&RemovedTCB->tcb_lock);

        ASSERT(ConnBlock != NULL);

        CTEFreeLock(&(ConnBlock->cb_lock), ConnHandle);
    }
}

//* RemoveTCBFromConn - Remove a TCB from a Conn structure.
//
//  Called when we need to disassociate a TCB from a connection structure.
//  All we do is get the appropriate locks and call FinishRemoveTCBFromConn.
//
//  Input:  RemovedTCB      - TCB to be removed.
//
//  Returns: Nothing.
//
void
RemoveTCBFromConn(TCB * RemovedTCB)
{

    CTEStructAssert(RemovedTCB, tcb);

    FinishRemoveTCBFromConn(RemovedTCB);
}

//* RemoveConnFromTCB - Remove a conn from a TCB.
//
//  Called when we want to break the final association between a connection
//  and a TCB.
//
//  Input:  RemoveTCB   - TCB to be removed.
//
//  Returns: Nothing.
//
void
RemoveConnFromTCB(TCB * RemoveTCB)
{
    ConnDoneRtn DoneRtn = NULL;
    CTELockHandle ConnHandle;
    TCPConn *Conn;


    ConnHandle = 0;
    if ((Conn = RemoveTCB->tcb_conn) != NULL) {

        CTEGetLock(&(Conn->tc_ConnBlock->cb_lock), &ConnHandle);
#if DBG
        Conn->tc_ConnBlock->line = (uint) __LINE__;
        Conn->tc_ConnBlock->module = (uchar *) __FILE__;
#endif
        CTEGetLockAtDPC(&RemoveTCB->tcb_lock);

        CTEStructAssert(Conn, tc);

        if (--(Conn->tc_refcnt) == 0)
            DoneRtn = Conn->tc_donertn;

        RemoveTCB->tcb_conn = NULL;

        CTEFreeLockFromDPC(&RemoveTCB->tcb_lock);
    }
    if (DoneRtn != NULL) {

        (*DoneRtn) (Conn, ConnHandle);

    } else {
        if (Conn) {
            CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), ConnHandle);
        }
        //CTEFreeLock(&ConnTableLock, ConnHandle);
    }
}

//* CloseTCB - Close a TCB.
//
//  Called when we are done with a TCB, and want to free it. We'll remove
//  him from any tables that he's in, and destroy any outstanding requests.
//
//  Input:  ClosedTCB       - TCB to be closed.
//          Handle          - Lock handle for TCB.
//
//  Returns: Nothing.
//
void
CloseTCB(TCB * ClosedTCB, CTELockHandle Handle)
{
    CTELockHandle TCBTableHandle;
    uchar OrigState = ClosedTCB->tcb_state;
    TDI_STATUS Status;
    uint OKToFree;
    uint Partition = ClosedTCB->tcb_partition;
    RouteCacheEntry* RCE = ClosedTCB->tcb_rce;
    CTEStructAssert(ClosedTCB, tcb);
    ASSERT(ClosedTCB->tcb_refcnt == 0);
    ASSERT(ClosedTCB->tcb_state != TCB_CLOSED);
    ASSERT(ClosedTCB->tcb_pending & DEL_PENDING);

    // We'll check to make sure that our state isn't CLOSED. This should never
    // happen, since nobody should call TryToCloseTCB when the state is
    // closed, or take the reference count if we're closing. Nevertheless,
    // we'll double check as a safety measure.

    if (ClosedTCB->tcb_state == TCB_CLOSED) {
        CTEFreeLock(&ClosedTCB->tcb_lock, Handle);
        return;
    }

    // Update SNMP counters. If we're in SYN-SENT or SYN-RCVD, this is a failed
    // connection attempt. If we're in ESTABLISED or CLOSE-WAIT, treat this
    // as an 'Established Reset' event.
    if (ClosedTCB->tcb_state == TCB_SYN_SENT ||
        ClosedTCB->tcb_state == TCB_SYN_RCVD)
        TStats.ts_attemptfails++;
    else if (ClosedTCB->tcb_state == TCB_ESTAB ||
             ClosedTCB->tcb_state == TCB_CLOSE_WAIT) {
        TStats.ts_estabresets++;
        InterlockedDecrement((PLONG)&TStats.ts_currestab);
    }

    if (SynAttackProtect && ClosedTCB->tcb_state == TCB_SYN_RCVD) {
        DropHalfOpenTCB(ClosedTCB->tcb_rexmitcnt);
    }

    ClosedTCB->tcb_state = TCB_CLOSED;
    ClosedTCB->tcb_rce = NULL;
    CTEFreeLock(&ClosedTCB->tcb_lock, Handle);

    // Remove the TCB from it's associated TCPConn structure, if it has one.

    //this takes the appropriate conntable lock.
    FinishRemoveTCBFromConn(ClosedTCB);


    if (SYNC_RCVD_STATE(OrigState) && !GRACEFUL_CLOSED_STATE(OrigState)) {
        if (ClosedTCB->tcb_flags & NEED_RST)
            SendRSTFromTCB(ClosedTCB, RCE);
    }
    (*LocalNetInfo.ipi_freeopts) (&ClosedTCB->tcb_opt);

    if (RCE) {
        (*LocalNetInfo.ipi_closerce)(RCE);
    }

    CTEGetLock(&ClosedTCB->tcb_lock, &Handle);

    if (ClosedTCB->tcb_closereason & TCB_CLOSE_RST)
        Status = TDI_CONNECTION_RESET;
    else if (ClosedTCB->tcb_closereason & TCB_CLOSE_ABORTED)
        Status = TDI_CONNECTION_ABORTED;
    else if (ClosedTCB->tcb_closereason & TCB_CLOSE_TIMEOUT)
        Status = MapIPError(ClosedTCB->tcb_error, TDI_TIMED_OUT);
    else if (ClosedTCB->tcb_closereason & TCB_CLOSE_REFUSED)
        Status = TDI_CONN_REFUSED;
    else if (ClosedTCB->tcb_closereason & TCB_CLOSE_UNREACH)
        Status = MapIPError(ClosedTCB->tcb_error, TDI_DEST_UNREACHABLE);
    else
        Status = TDI_SUCCESS;

    // Ref this TCB so that it will not go away until
    // we cleanup pending requests.
    REFERENCE_TCB(ClosedTCB);

    // Now complete any outstanding requests on the TCB.
    if (ClosedTCB->tcb_abortreq != NULL) {
        TCPAbortReq* AbortReq = ClosedTCB->tcb_abortreq;

        CTEFreeLock(&ClosedTCB->tcb_lock, Handle);
        (*AbortReq->tar_rtn)(AbortReq->tar_context, TDI_SUCCESS, 0);
        CTEGetLock(&ClosedTCB->tcb_lock, &Handle);
    }
    if (ClosedTCB->tcb_connreq != NULL) {
        TCPConnReq *ConnReq = ClosedTCB->tcb_connreq;
        CTEStructAssert(ConnReq, tcr);

        CTEFreeLock(&ClosedTCB->tcb_lock, Handle);
        (*ConnReq->tcr_req.tr_rtn) (ConnReq->tcr_req.tr_context, Status, 0);
        FreeConnReq(ConnReq);
        CTEGetLock(&ClosedTCB->tcb_lock, &Handle);
    }
    if (ClosedTCB->tcb_discwait != NULL) {
        TCPConnReq *ConnReq = ClosedTCB->tcb_discwait;
        CTEStructAssert(ConnReq, tcr);

        CTEFreeLock(&ClosedTCB->tcb_lock, Handle);
        (*ConnReq->tcr_req.tr_rtn) (ConnReq->tcr_req.tr_context, Status, 0);
        FreeConnReq(ConnReq);
        CTEGetLock(&ClosedTCB->tcb_lock, &Handle);
    }
    while (!EMPTYQ(&ClosedTCB->tcb_sendq)) {
        TCPReq *Req;
        TCPSendReq *SendReq;
        long Result;
        uint SendReqFlags;

        DEQUEUE(&ClosedTCB->tcb_sendq, Req, TCPReq, tr_q);

        CTEStructAssert(Req, tr);
        SendReq = (TCPSendReq *) Req;
        CTEStructAssert(SendReq, tsr);

        // Decrement the initial reference put on the buffer when it was
        // allocated. This reference would have been decremented if the
        // send had been acknowledged, but then the send would not still
        // be on the tcb_sendq.

        SendReqFlags = SendReq->tsr_flags;

        if (SendReqFlags & TSR_FLAG_SEND_AND_DISC) {

            BOOLEAN BytesSentOkay=FALSE;
            ASSERT(ClosedTCB->tcb_fastchk & TCP_FLAG_SEND_AND_DISC);

            if ((ClosedTCB->tcb_unacked == 0) &&
                    (ClosedTCB->tcb_sendnext == ClosedTCB->tcb_sendmax) &&
                    (ClosedTCB->tcb_sendnext == (ClosedTCB->tcb_senduna + 1) ||
                    (ClosedTCB->tcb_sendnext == ClosedTCB->tcb_senduna)) ) {
                BytesSentOkay=TRUE;
            }

            if (BytesSentOkay &&
                !((ClosedTCB->tcb_closereason == TCB_CLOSE_TIMEOUT) ||
                (ClosedTCB->tcb_closereason == TCB_CLOSE_RST) ||
                (ClosedTCB->tcb_closereason == TCB_CLOSE_ABORTED))) {

                Req->tr_status = TDI_SUCCESS;

            } else {
                Req->tr_status = Status;
            }
        } else {
            Req->tr_status = Status;
        }

        Result = CTEInterlockedDecrementLong(&SendReq->tsr_refcnt);

        ASSERT(Result >= 0);

        if (Result <= 0) {
            // If we've sent directly from this send, NULL out the next
            // pointer for the last buffer in the chain.
            if (SendReq->tsr_lastbuf != NULL) {
                NDIS_BUFFER_LINKAGE(SendReq->tsr_lastbuf) = NULL;
                SendReq->tsr_lastbuf = NULL;
            }
            CTEFreeLock(&ClosedTCB->tcb_lock, Handle);
            (*Req->tr_rtn) (Req->tr_context, Req->tr_status, Req->tr_status == TDI_SUCCESS ? SendReq->tsr_size : 0);
            CTEGetLock(&ClosedTCB->tcb_lock, &Handle);
            FreeSendReq(SendReq);

        } else {
            // The send request will be freed when all outstanding references
            // to it have completed.
            if ((SendReqFlags & TSR_FLAG_SEND_AND_DISC) && (Result <= 1)) {

                // If we've sent directly from this send, NULL out the next
                // pointer for the last buffer in the chain.
                if (SendReq->tsr_lastbuf != NULL) {
                    NDIS_BUFFER_LINKAGE(SendReq->tsr_lastbuf) = NULL;
                    SendReq->tsr_lastbuf = NULL;
                }
                CTEFreeLock(&ClosedTCB->tcb_lock, Handle);
                (*Req->tr_rtn) (Req->tr_context, Req->tr_status, Req->tr_status == TDI_SUCCESS ? SendReq->tsr_size : 0);
                CTEGetLock(&ClosedTCB->tcb_lock, &Handle);
                FreeSendReq(SendReq);

            }
        }
    }

    while (ClosedTCB->tcb_rcvhead != NULL) {
        TCPRcvReq *RcvReq;

        RcvReq = ClosedTCB->tcb_rcvhead;
        CTEStructAssert(RcvReq, trr);
        ClosedTCB->tcb_rcvhead = RcvReq->trr_next;
        CTEFreeLock(&ClosedTCB->tcb_lock, Handle);
        (*RcvReq->trr_rtn) (RcvReq->trr_context, Status, 0);
        CTEGetLock(&ClosedTCB->tcb_lock, &Handle);
        FreeRcvReq(RcvReq);
    }

    while (ClosedTCB->tcb_exprcv != NULL) {
        TCPRcvReq *RcvReq;

        RcvReq = ClosedTCB->tcb_exprcv;
        CTEStructAssert(RcvReq, trr);
        ClosedTCB->tcb_exprcv = RcvReq->trr_next;

        CTEFreeLock(&ClosedTCB->tcb_lock, Handle);
        (*RcvReq->trr_rtn) (RcvReq->trr_context, Status, 0);
        CTEGetLock(&ClosedTCB->tcb_lock, &Handle);
        FreeRcvReq(RcvReq);
    }

    if (ClosedTCB->tcb_pendhead != NULL)
        FreeRBChain(ClosedTCB->tcb_pendhead);

    if (ClosedTCB->tcb_urgpending != NULL)
        FreeRBChain(ClosedTCB->tcb_urgpending);

    while (ClosedTCB->tcb_raq != NULL) {
        TCPRAHdr *Hdr;

        Hdr = ClosedTCB->tcb_raq;
        CTEStructAssert(Hdr, trh);
        ClosedTCB->tcb_raq = Hdr->trh_next;
        if (Hdr->trh_buffer != NULL)
            FreeRBChain(Hdr->trh_buffer);

        CTEFreeMem(Hdr);
    }

    CTEFreeLock(&ClosedTCB->tcb_lock, Handle);

    RemoveConnFromTCB(ClosedTCB);

    CTEGetLock(&pTCBTableLock[Partition], &TCBTableHandle);

    CTEGetLockAtDPC(&ClosedTCB->tcb_lock);

    ClosedTCB->tcb_refcnt--;

    OKToFree = RemoveTCB(ClosedTCB, OrigState);

    // He's been pulled from the appropriate places so nobody can find him.
    // Free the locks, and proceed to destroy any requests, etc.

    CTEFreeLockFromDPC(&ClosedTCB->tcb_lock);

    CTEFreeLock(&pTCBTableLock[Partition], TCBTableHandle);

    if (OKToFree) {
        FreeTCB(ClosedTCB);
    }
}

//* TryToCloseTCB - Try to close a TCB.
//
//  Called when we need to close a TCB, but don't know if we can. If
//  the reference count is 0, we'll call CloseTCB to deal with it.
//  Otherwise we'll set the DELETE_PENDING bit and deal with it when
//  the ref. count goes to 0. We assume the TCB is locked when we are called.
//
//  Input:  ClosedTCB       - TCB to be closed.
//          Reason          - Reason we're closing.
//          Handle          - Lock handle for TCB.
//
//  Returns: Nothing.
//
void
TryToCloseTCB(TCB * ClosedTCB, uchar Reason, CTELockHandle Handle)
{
    CTEStructAssert(ClosedTCB, tcb);
    ASSERT(ClosedTCB->tcb_state != TCB_CLOSED);

    ClosedTCB->tcb_closereason |= Reason;

    if (ClosedTCB->tcb_pending & DEL_PENDING) {
        CTEFreeLock(&ClosedTCB->tcb_lock, Handle);
        return;
    }
    ClosedTCB->tcb_pending |= DEL_PENDING;
    ClosedTCB->tcb_slowcount++;
    ClosedTCB->tcb_fastchk |= TCP_FLAG_SLOW;

    if (ClosedTCB->tcb_refcnt == 0)
        CloseTCB(ClosedTCB, Handle);
    else {
        CTEFreeLock(&ClosedTCB->tcb_lock, Handle);
    }
}

//* DerefTCB - Dereference a TCB.
//
//  Called when we're done with a TCB, and want to let exclusive user
//  have a shot. We dec. the refcount, and if it goes to zero and there
//  are pending actions, we'll perform one of the pending actions.
//
//  Input:  DoneTCB         - TCB to be dereffed.
//          Handle          - Lock handle to be used when freeing TCB lock.
//
//  Returns: Nothing.
//
void
DerefTCB(TCB * DoneTCB, CTELockHandle Handle)
{
    ASSERT(DoneTCB->tcb_refcnt != 0);
    if (DEREFERENCE_TCB(DoneTCB) == 0) {
        if (DoneTCB->tcb_pending == 0) {
            CTEFreeLock(&DoneTCB->tcb_lock, Handle);
            return;
        } else {
            if (DoneTCB->tcb_pending & RST_PENDING) {
                REFERENCE_TCB(DoneTCB);
                NotifyOfDisc(DoneTCB, NULL, TDI_CONNECTION_RESET, &Handle);
                CTEGetLock(&DoneTCB->tcb_lock, &Handle);
                DerefTCB(DoneTCB, Handle);
                return;
            }
            if (DoneTCB->tcb_pending & DEL_PENDING)
                CloseTCB(DoneTCB, Handle);
            else if (DoneTCB->tcb_pending & FREE_PENDING) {

                RouteCacheEntry* RCE = DoneTCB->tcb_rce;
                DoneTCB->tcb_rce = NULL;
                (*LocalNetInfo.ipi_freeopts) (&DoneTCB->tcb_opt);

                // Need to take this TCB out of the timerwheel if it is in there.
                if( DoneTCB->tcb_timerslot != DUMMY_SLOT) {
                  ASSERT( DoneTCB->tcb_timerslot < TIMER_WHEEL_SIZE );
                  RemoveFromTimerWheel( DoneTCB );
                }

                CTEFreeLock(&DoneTCB->tcb_lock, Handle);

                // Close the RCE on this guy.
                if (RCE) {
                    (*LocalNetInfo.ipi_closerce) (RCE);
                }

                CTEGetLock(&PendingFreeLock.Lock, &Handle);
                if (TCBWalkCount != 0) {

#ifdef  PENDING_FREE_DBG
                    if( DoneTCB->tcb_flags & IN_TCB_TABLE)
                        DbgBreakPoint();
#endif

                    //tcbtimeout is walking the table
                    //Let it free this tcb too.
                    DoneTCB->tcb_walkcount = TCBWalkCount + 1;
                    *(TCB **) & DoneTCB->tcb_delayq.q_next = PendingFreeList;
                    PendingFreeList = DoneTCB;
                    CTEFreeLock(&PendingFreeLock.Lock, Handle);
                    return;

                } else {

                    CTEFreeLock(&PendingFreeLock.Lock, Handle);
                }
                //it is okay to free this.

                FreeTCB(DoneTCB);
            } else
                ASSERT(0);

            return;
        }
    }
    CTEFreeLock(&DoneTCB->tcb_lock, Handle);
}

//** TdiOpenConnection - Open a connection.
//
//  This is the TDI Open Connection entry point. We open a connection,
//  and save the caller's connection context. A TCPConn structure is allocated
//  here, but a TCB isn't allocated until the Connect or Listen is done.
//
//  Input:  Request         - Pointed to a TDI request structure.
//          Context         - Connection context to be saved for connection.
//
//  Returns: Status of attempt to open the connection.
//
TDI_STATUS
TdiOpenConnection(PTDI_REQUEST Request, PVOID Context)
{
    TCPConn *NewConn;            // The newly opened connection.
    CTELockHandle Handle;        // Lock handle for TCPConnTable.
    uint ConnID;                // New ConnID.
    TDI_STATUS Status;            // Status of this request.

    NewConn = GetConn();

    if (NewConn != NULL) {        // We allocated a connection.

#if DBG
        NewConn->tc_sig = tc_signature;
#endif
        NewConn->tc_tcb = NULL;
        NewConn->tc_ao = NULL;
        NewConn->tc_context = Context;

        ConnID = GetConnID(NewConn, &Handle);
        if (ConnID != INVALID_CONN_ID) {
            // We successfully got a ConnID.
            Request->Handle.ConnectionContext = UintToPtr(ConnID);
            NewConn->tc_refcnt = 0;
            NewConn->tc_flags = 0;
            NewConn->tc_tcbflags = NAGLING | (BSDUrgent ? BSD_URGENT : 0);
            if (DefaultRcvWin != 0) {
                NewConn->tc_window = DefaultRcvWin;
                NewConn->tc_flags |= CONN_WINCFG;
            } else {

                NewConn->tc_window = DEFAULT_RCV_WIN;
            }

            NewConn->tc_donertn = DummyDone;
#if !MILLEN
            NewConn->tc_owningpid = HandleToUlong(PsGetCurrentProcessId());
#endif

            Request->RequestContext = NewConn;
            Status = TDI_SUCCESS;

            CTEFreeLock(&(NewConn->tc_ConnBlock->cb_lock), Handle);
        } else {
            FreeConn(NewConn);

            Status = TDI_NO_RESOURCES;
        }

        return Status;
    }
    // Couldn't get a connection.
    return TDI_NO_RESOURCES;

}

//* RemoveConnFromAO - Remove a connection from an AddrObj.
//
//  A little utility routine to remove a connection from an AddrObj.
//  We run down the connections on the AO, and when we find him we splice
//  him out. We assume the caller holds the locks on the AddrObj and the
//  TCPConnTable lock.
//
//  Input:  AO          - AddrObj to remove from.
//          Conn        - Conn to remove.
//
//  Returns: Nothing.
//
void
RemoveConnFromAO(AddrObj * AO, TCPConn * Conn)
{

    CTEStructAssert(AO, ao);
    CTEStructAssert(Conn, tc);

    REMOVEQ(&Conn->tc_q);
    Conn->tc_ao = NULL;

}

//* TdiCloseConnection - Close a connection.
//
//  Called when the user is done with a connection, and wants to close it.
//  We look the connection up in our table, and if we find it we'll remove
//  the connection from the AddrObj it's associate with (if any). If there's
//  a TCB associated with the connection we'll close it also.
//
//  There are some interesting wrinkles related to closing while a TCB
//  is still referencing the connection (i.e. tc_refcnt != 0) or while a
//  disassociate address is in progress. See below for more details.
//
//  Input:  Request         - Request identifying connection to be closed.
//
//  Returns: Status of attempt to close.
//
TDI_STATUS
TdiCloseConnection(PTDI_REQUEST Request)
{
    uint ConnID = PtrToUlong(Request->Handle.ConnectionContext);
    CTELockHandle TableHandle;
    TCPConn *Conn;
    TDI_STATUS Status;

    //CTEGetLock(&ConnTableLock, &TableHandle);

    // We have the locks we need. Try to find a connection.
    Conn = GetConnFromConnID(ConnID, &TableHandle);

    if (Conn != NULL) {
        CTELockHandle TCBHandle;
        TCB *ConnTCB;

        // We found the connection. Free the ConnID and mark the connection
        // as closing.

        CTEStructAssert(Conn, tc);

        FreeConnID(Conn);

        Conn->tc_flags |= CONN_CLOSING;

        // See if there's a TCB referencing this connection.
        // If there is, we'll need to wait until he's done before closing him.
        // We'll hurry the process along if we still have a pointer to him.

        if (Conn->tc_refcnt != 0) {
            CTEReqCmpltRtn Rtn;
            PVOID Context;

            // A connection still references him. Save the current rtn stuff
            // in case we are in the middle of disassociating him from an
            // address, and store the caller's callback routine and our done
            // routine.
            Rtn = Conn->tc_rtn;
            Context = Conn->tc_rtncontext;

            Conn->tc_rtn = Request->RequestNotifyObject;
            Conn->tc_rtncontext = Request->RequestContext;
            Conn->tc_donertn = CloseDone;

            // See if we're in the middle of disassociating him
            if (Conn->tc_flags & CONN_DISACC) {

                // We are disassociating him. We'll free the conn table lock
                // now and fail the disassociate request. Note that when
                // we free the lock the refcount could go to zero. This is
                // OK, because we've already stored the neccessary info. in
                // the connection so the caller will get called back if it
                // does. From this point out we return PENDING, so a callback
                // is OK. We've marked him as closing, so the disassoc done
                // routine will bail out if we've interrupted him. If the ref.
                // count does go to zero, Conn->tc_tcb would have to be NULL,
                // so in that case we'll just fall out of this routine.

                CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), TableHandle);
                (*Rtn) (Context, (uint) TDI_REQ_ABORTED, 0);
                CTEGetLock(&(Conn->tc_ConnBlock->cb_lock), &TableHandle);
#if DBG
                Conn->tc_ConnBlock->line = (uint) __LINE__;
                Conn->tc_ConnBlock->module = (uchar *) __FILE__;
#endif
            }
            ConnTCB = Conn->tc_tcb;
            if (ConnTCB != NULL) {

                CTEStructAssert(ConnTCB, tcb);
                // We have a TCB. Take the lock on him and get ready to
                // close him.
                CTEGetLock(&ConnTCB->tcb_lock, &TCBHandle);
                if (ConnTCB->tcb_state != TCB_CLOSED) {
                    ConnTCB->tcb_flags |= NEED_RST;

                    CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), TCBHandle);
                    //CTEFreeLock(&ConnTableLock, TCBHandle);
                    if (!CLOSING(ConnTCB))
                        TryToCloseTCB(ConnTCB, TCB_CLOSE_ABORTED, TableHandle);
                    else
                        CTEFreeLock(&ConnTCB->tcb_lock, TableHandle);
                    return TDI_PENDING;
                } else {
                    // He's already closing. This should be harmless, but check
                    // this case.
                    CTEFreeLock(&ConnTCB->tcb_lock, TCBHandle);
                }
            }
            Status = TDI_PENDING;

        } else {
            // We have a connection that we can close. Finish the close.
            Conn->tc_rtn = DummyCmplt;
            CloseDone(Conn, TableHandle);
            return TDI_SUCCESS;
        }

        CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), TableHandle);

    } else
        Status = TDI_INVALID_CONNECTION;

    // We're done with the connection. Go ahead and free him.
    //

    return Status;

}

//* TdiAssociateAddress - Associate an address with a connection.
//
//  Called to associate an address with a connection. We do a minimal
//  amount of sanity checking, and then put the connection on the AddrObj's
//  list.
//
//  Input:  Request         - Pointer to request structure for this request.
//          AddrHandle      - Address handle to associate connection with.
//
//  Returns: Status of attempt to associate.
//
TDI_STATUS
TdiAssociateAddress(PTDI_REQUEST Request, HANDLE AddrHandle)
{
    CTELockHandle TableHandle;
    AddrObj *AO;
    uint ConnID = PtrToUlong(Request->Handle.ConnectionContext);
    TCPConn *Conn;
    TDI_STATUS Status;

    DEBUGMSG(DBG_TRACE && DBG_TDI,
             (DTEXT("+TdiAssociateAddress(%x, %x) Conn %x\n"),
             Request, AddrHandle, Request->Handle.ConnectionContext));

    Conn = GetConnFromConnID(ConnID, &TableHandle);

    if (!Conn) {
        DEBUGMSG(DBG_ERROR && DBG_TDI,
            (DTEXT("TdiAssociateAddress: Invalid ConnID %x\n"), ConnID));
        return TDI_INVALID_CONNECTION;
    }
    CTEStructAssert(Conn, tc);

    AO = (AddrObj *) AddrHandle;
    CTEGetLockAtDPC(&AO->ao_lock);
    CTEStructAssert(AO, ao);

    if (!AO_VALID(AO)) {
        DEBUGMSG(DBG_ERROR && DBG_TDI,
                 (DTEXT("TdiAssociateAddress: Invalid AO %x\n"), AO));
        Status = TDI_INVALID_PARAMETER;
    } else if (Conn->tc_ao != NULL) {
        // It's already associated. Error out.
        ASSERT(0);
        DEBUGMSG(DBG_ERROR && DBG_TDI,
            (DTEXT("TdiAssociateAddress: Already assoc Addr %x conn %x\n"),
             AO, Conn));
        Status = TDI_ALREADY_ASSOCIATED;
    } else {
        Conn->tc_ao = AO;
        ASSERT(Conn->tc_tcb == NULL);
        PUSHQ(&AO->ao_idleq, &Conn->tc_q);
        Status = TDI_SUCCESS;
    }

    CTEFreeLockFromDPC(&AO->ao_lock);
    CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), TableHandle);
    return Status;
}

//* TdiDisAssociateAddress - Disassociate a connection from an address.
//
//  The TDI entry point to disassociate a connection from an address. The
//  connection must actually be associated  and not connected to anything.
//
//  Input:  Request         - Pointer to the request structure for this
//                              command.
//
//  Returns: Status of request.
//
TDI_STATUS
TdiDisAssociateAddress(PTDI_REQUEST Request)
{
    uint ConnID = PtrToUlong(Request->Handle.ConnectionContext);
    CTELockHandle AOTableHandle, ConnTableHandle;
    TCPConn *Conn;
    AddrObj *AO;
    TDI_STATUS Status;

    CTEGetLock(&AddrObjTableLock.Lock, &AOTableHandle);

    Conn = GetConnFromConnID(ConnID, &ConnTableHandle);

    if (Conn != NULL) {
        // The connection actually exists!

        CTEStructAssert(Conn, tc);
        AO = Conn->tc_ao;
        if (AO != NULL) {
            CTEStructAssert(AO, ao);
            // And it's associated.
            CTEGetLockAtDPC(&AO->ao_lock);
            // If there's no connection currently active, go ahead and remove
            // him from the AddrObj. If a connection is active error the
            // request out.
            if (Conn->tc_tcb == NULL) {
                if (Conn->tc_refcnt == 0) {
                    RemoveConnFromAO(AO, Conn);
                    Status = TDI_SUCCESS;
                } else {
                    // He shouldn't be closing, or we couldn't have found him.
                    ASSERT(!(Conn->tc_flags & CONN_CLOSING));

                    Conn->tc_rtn = Request->RequestNotifyObject;
                    Conn->tc_rtncontext = Request->RequestContext;
                    Conn->tc_donertn = DisassocDone;
                    Conn->tc_flags |= CONN_DISACC;
                    Status = TDI_PENDING;
                }

            } else
                Status = TDI_CONNECTION_ACTIVE;
            CTEFreeLockFromDPC(&AO->ao_lock);
        } else
            Status = TDI_NOT_ASSOCIATED;

        CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), ConnTableHandle);
    } else
        Status = TDI_INVALID_CONNECTION;

    CTEFreeLock(&AddrObjTableLock.Lock, AOTableHandle);

    return Status;

}

//* ProcessUserOptions - Process options from the user.
//
//  A utility routine to process options from the user. We fill in the
//  optinfo structure, and if we have options we call ip to check on them.
//
//  Input:  Info            - Info structure containing options to be processed.
//          OptInfo         - Info structure to be filled in.
//
//  Returns: TDI_STATUS of attempt.
//
TDI_STATUS
ProcessUserOptions(PTDI_CONNECTION_INFORMATION Info, IPOptInfo * OptInfo)
{
    TDI_STATUS Status;

    (*LocalNetInfo.ipi_initopts) (OptInfo);

    if (Info != NULL && Info->Options != NULL) {
        IP_STATUS OptStatus;

        OptStatus = (*LocalNetInfo.ipi_copyopts) (Info->Options,
                                                  Info->OptionsLength, OptInfo);
        if (OptStatus != IP_SUCCESS) {
            if (OptStatus == IP_NO_RESOURCES)
                Status = TDI_NO_RESOURCES;
            else
                Status = TDI_BAD_OPTION;
        } else
            Status = TDI_SUCCESS;
    } else {
        Status = TDI_SUCCESS;
    }

    return Status;

}

//* InitTCBFromConn - Initialize a TCB from information in a Connection.
//
//  Called from Connect and Listen processing to initialize a new TCB from
//  information in the connection. We assume the AddrObjTableLock and
//  ConnTableLocks are held when we are called, or that the caller has some
//  other way of making sure that the referenced AO doesn't go away in the middle
//      of operation.
//
//  Input:  Conn            - Connection to initialize from.
//          NewTCB          - TCB to be initialized.
//          Addr            - Remote addressing and option info for NewTCB.
//                      AOLocked                - True if the called has the address object locked.
//
//  Returns: TDI_STATUS of init attempt.
//
TDI_STATUS
InitTCBFromConn(TCPConn * Conn, TCB * NewTCB,
                PTDI_CONNECTION_INFORMATION Addr, uint AOLocked)
{
    CTELockHandle AOHandle;
    TDI_STATUS Status;
    int tos = 0;
    uint UnicastIf;
    uchar ttl;

    CTEStructAssert(Conn, tc);

    // We have a connection. Make sure it's associated with an address and
    // doesn't already have a TCB attached.

    if (Conn->tc_flags & CONN_INVALID)
        return TDI_INVALID_CONNECTION;

    if (Conn->tc_tcb == NULL) {
        AddrObj *ConnAO;

        ConnAO = Conn->tc_ao;
        if (ConnAO != NULL) {
            CTEStructAssert(ConnAO, ao);

            if (!AOLocked) {
                CTEGetLock(&ConnAO->ao_lock, &AOHandle);
            } else {
                AOHandle = DISPATCH_LEVEL;
            }
            if (!(NewTCB->tcb_fastchk & TCP_FLAG_ACCEPT_PENDING)) {
                uint Window;

                // Choose a window for the TCB based on the Conn or AO.
                // See AdjustTCBFromRCE for the remaining window-selection
                // logic, which applies if neither the Conn nor the AO
                // have a specified window. The precedence for window-selection
                // is as follows:
                //
                //  (1) TCP_SOCKET_WINDOW
                //      controlled by CONN_WINSET in TCPConn.tc_flags
                //      read from Conn->tc_window
                //      results in WINDOW_SET in TCB.tcb_flags
                //  (2) AO_TCP_WINDOW
                //      controlled by AO_FLAG_WINSET in AddrObj.ao_flags
                //      read from AO->ao_window
                //      results in WINDOW_SET in TCB.tcb_flags
                //  (3) "TcpWindowSize" (per-interface)
                //      read from RCE->rce_TcpWindowSize
                //  (4) "TcpWindowSize" (global)
                //      controlled by CONN_WINCFG in TCPConn.tc_flags
                //      read from DefaultRcvWin
                //  (5) Auto-selection based on media-speed
                //      based on RCE->rce_mediaspeed
                //      computed in AdjustTCBFromRCE.
                //
                // Cases (1), (2), and (4) are handled below. Cases (3) and (5)
                // are handled in AdjustTCBFromRCE.

                NewTCB->tcb_saddr = ConnAO->ao_addr;
                if (Conn->tc_flags & CONN_WINSET) {
                    Window = Conn->tc_window;
                } else if (AO_WINSET(ConnAO)) {
                    Window = ConnAO->ao_window;
                } else {
                    Window = Conn->tc_window;
                }
                NewTCB->tcb_defaultwin = Window;
                NewTCB->tcb_rcvwin = Window;

                // Compute rcv window scale  based on the rcvwin
                // From RFC 1323 - TCP_MAX_WINSHIFT is set to 14
                NewTCB->tcb_rcvwinscale = 0;
                while ((NewTCB->tcb_rcvwinscale < TCP_MAX_WINSHIFT) &&
                       ((TCP_MAXWIN << NewTCB->tcb_rcvwinscale) <
                        (int)Window)) {
                    NewTCB->tcb_rcvwinscale++;
                }
            }

            NewTCB->tcb_sport = ConnAO->ao_port;
            NewTCB->tcb_rcvind = ConnAO->ao_rcv;
            NewTCB->tcb_chainedrcvind = ConnAO->ao_chainedrcv;
            NewTCB->tcb_chainedrcvcontext = ConnAO->ao_chainedrcvcontext;
            NewTCB->tcb_ricontext = ConnAO->ao_rcvcontext;
            if (NewTCB->tcb_rcvind == NULL)
                NewTCB->tcb_rcvhndlr = PendData;
            else
                NewTCB->tcb_rcvhndlr = IndicateData;

            NewTCB->tcb_conncontext = Conn->tc_context;
            NewTCB->tcb_flags |= Conn->tc_tcbflags;
#if TRACE_EVENT
            NewTCB->tcb_cpcontext = Conn->tc_owningpid;
#endif

            if ((Conn->tc_flags & CONN_WINSET) || AO_WINSET(ConnAO)) {
                NewTCB->tcb_flags |= WINDOW_SET;
            }

            if (AO_SCALE_CWIN(ConnAO)) {
                NewTCB->tcb_flags |= SCALE_CWIN;
            }

            IF_TCPDBG(TCP_DEBUG_OPTIONS) {
                TCPTRACE((
                          "setting TOS to %d on AO %lx in TCB %lx\n", ConnAO->ao_opt.ioi_tos, ConnAO, NewTCB
                         ));
            }

            if (ConnAO->ao_opt.ioi_tos) {
                tos = ConnAO->ao_opt.ioi_tos;
            }
            //
            // copy the ttl of ConnAO over
            //
            ttl = ConnAO->ao_opt.ioi_ttl;
            UnicastIf = ConnAO->ao_opt.ioi_ucastif;

            if (!AOLocked) {
                CTEFreeLock(&ConnAO->ao_lock, AOHandle);
            }
            // If we've been given options, we need to process them now.
            if (Addr != NULL && Addr->Options != NULL)
                NewTCB->tcb_flags |= CLIENT_OPTIONS;
            Status = ProcessUserOptions(Addr, &NewTCB->tcb_opt);

            if (tos) {
                NewTCB->tcb_opt.ioi_tos = (uchar) tos;
            }
            NewTCB->tcb_opt.ioi_ttl = ttl;
            NewTCB->tcb_opt.ioi_ucastif = UnicastIf;

            return Status;
        } else
            return TDI_NOT_ASSOCIATED;
    } else
        return TDI_CONNECTION_ACTIVE;

}

//*ScheduleConnDisRequest  - ScheduleDelayed Connect/Disconnect Request
//
//  Queues Connect or disconnect request for execution by ProcessAORequest
//  when ao_usecnt falls to zero.
//
//  Input:  AO             - Address Object, ao_lock is held.
//          Request        - Original Connect/Disconnect Request.
//          Type           - Connect or Disconnect Type.
//
//  Returns: Status pending/failure
//
//
NTSTATUS
ScheduleConnDisRequest(AddrObj *AO, PTDI_REQUEST Request, uint Type,
                       CTELockHandle Handle)
{
    AORequest *NewRequest, *OldRequest;
    //
    // Allocate an AO request.
    //

    NewRequest = GetAORequest(Type);

    if (NewRequest != NULL) {    // Got a request.

        //
        // Initialize and Queue NewRequest.
        //

        NewRequest->aor_rtn = Request->RequestNotifyObject;
        NewRequest->aor_context = Request->RequestContext;
        NewRequest->aor_next = NULL;

        OldRequest = STRUCT_OF(AORequest, &AO->ao_request, aor_next);

        while (OldRequest->aor_next != NULL)
            OldRequest = OldRequest->aor_next;

        OldRequest->aor_next = NewRequest;

        //
        // Let ProcessAORequest know what to do.
        //

        if (Type == AOR_TYPE_DISCONNECT) {
            SET_AO_REQUEST(AO, AO_DISCONNECT);
        } else {
            SET_AO_REQUEST(AO, AO_CONNECT);
        }

        CTEFreeLock(&AO->ao_lock, Handle);
        return TDI_PENDING;

    } else {

        CTEFreeLock(&AO->ao_lock, Handle);
        return TDI_NO_RESOURCES;

    }

}

//* UdpConnect - Establish a pseudo udp connection
//
//  The TDI connection establishment routine. Called when the client wants to
//  establish a udp connection,  we validate his incoming parameters
//  initialize AO to point to a udp conection information block
//
//
//  Input:  Request             - The request structure for this command.
//          Timeout             - How long to wait for the request. The format
//                                  of this time is system specific - we use
//                                 a macro to convert to ticks.
//          RequestAddr         - Pointer to a TDI_CONNECTION_INFORMATION
//                                  structure describing the destination.
//          ReturnAddr          - Pointer to where to return information.
//
//  Returns: Status of attempt to connect.
//
TDI_STATUS
UDPConnect(PTDI_REQUEST Request, void *TO,
           PTDI_CONNECTION_INFORMATION RequestAddr,
           PTDI_CONNECTION_INFORMATION ReturnAddr)
{

    AddrObj *AO;
    CTELockHandle AOHandle;
    IPAddr DestAddr;
    ushort DestPort;
    uchar AddrType;
    IPAddr SrcAddr;
    ushort MSS;
    IPOptInfo *OptInfo;
    IPAddr OrigSrc;

    // First, get and validate the remote address.
    if (RequestAddr == NULL || RequestAddr->RemoteAddress == NULL ||
        !GetAddress((PTRANSPORT_ADDRESS) RequestAddr->RemoteAddress, &DestAddr,
                    &DestPort))
        return TDI_BAD_ADDR;

    AddrType = (*LocalNetInfo.ipi_getaddrtype) (DestAddr);

    if (AddrType == DEST_INVALID)
        return TDI_BAD_ADDR;

    AO = (AddrObj *) Request->Handle.AddressHandle;

    //Save the connection information for the later use.

    if ((AO != NULL) && AO_VALID(AO)) {
        CTEGetLock(&AO->ao_lock, &AOHandle);
        CTEStructAssert(AO, ao);
        if (AO->ao_usecnt) {

            //
            // There is send in progress on  AddrObj. Defer this request.
            //
            return ScheduleConnDisRequest(AO, Request, AOR_TYPE_CONNECT, AOHandle);
        }

        RtlCopyMemory(&AO->ao_udpconn, RequestAddr, sizeof(TDI_CONNECTION_INFORMATION));

        if (AO->ao_RemoteAddress) {
            CTEFreeMem(AO->ao_RemoteAddress);
        }
        if (AO->ao_Options) {
            CTEFreeMem(AO->ao_Options);
        }
        if (AO->ao_udpconn.RemoteAddressLength) {

            IF_TCPDBG(TCP_DEBUG_CONUDP)
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Allocating remote address %d\n", AO->ao_udpconn.RemoteAddressLength));

            AO->ao_RemoteAddress = CTEAllocMemN(AO->ao_udpconn.RemoteAddressLength, 'aPCT');
            if (!AO->ao_RemoteAddress) {
                IF_TCPDBG(TCP_DEBUG_CONUDP)
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"UDPConnect: remote address alloc failed\n"));
                CTEFreeLock(&AO->ao_lock, AOHandle);
                return TDI_NO_RESOURCES;

            }
            RtlCopyMemory(AO->ao_RemoteAddress, RequestAddr->RemoteAddress, RequestAddr->RemoteAddressLength);
        }
        if (AO->ao_udpconn.OptionsLength) {

            IF_TCPDBG(TCP_DEBUG_CONUDP)
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Allocating options %d\n", AO->ao_udpconn.OptionsLength));
            AO->ao_Options = CTEAllocMemN(AO->ao_udpconn.OptionsLength, 'aPCT');
            if (!AO->ao_Options) {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"UDPConnect: options alloc failed\n"));
                CTEFreeLock(&AO->ao_lock, AOHandle);
                return TDI_NO_RESOURCES;

            }
            RtlCopyMemory(AO->ao_Options, RequestAddr->Options, AO->ao_udpconn.OptionsLength);
        } else {

            AO->ao_Options = 0;
        }

        AO->ao_udpconn.RemoteAddress = AO->ao_RemoteAddress;
        AO->ao_udpconn.Options = AO->ao_Options;

        OrigSrc = AO->ao_addr;

        if (!CLASSD_ADDR(DestAddr)) {
            OptInfo = &AO->ao_opt;
        } else {
            OptInfo = &AO->ao_mcastopt;
        }

        SrcAddr = (*LocalNetInfo.ipi_openrce) (DestAddr,
                                               OrigSrc, &AO->ao_rce, &AddrType, &MSS,
                                               OptInfo);

        if (IP_ADDR_EQUAL(SrcAddr, NULL_IP_ADDR)) {
            // The request failed. We know the destination is good
            // (we verified it above), so it must be unreachable.
            IF_TCPDBG(TCP_DEBUG_CONUDP)
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"UDPConnect: OpenRCE Failed\n"));
            CTEFreeLock(&AO->ao_lock, AOHandle);
            return TDI_DEST_UNREACHABLE;
        }
        IF_TCPDBG(TCP_DEBUG_CONUDP)
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"UDPConnect---AO %x OpenRCE %x\n", AO, AO->ao_rce));

        AO->ao_rcesrc = SrcAddr;

        //indicate that connection structure for udp is setup

        SET_AO_CONNUDP(AO);

        CTEFreeLock(&AO->ao_lock, AOHandle);

        return TDI_SUCCESS;

    }
    return TDI_ADDR_INVALID;

}

//* UdpDisconnect - remve the "connection" info from AO
//
//  Called when the client wants to
//  break a udp connection,  we validate his incoming parameters
//  initialize AO to point to a udp conection information block
//
//
//  Input:  Request             - The request structure for this command.
//          Timeout             - How long to wait for the request. The format
//                                  of this time is system specific - we use
//                                 a macro to convert to ticks.
//          RequestAddr         - Pointer to a TDI_CONNECTION_INFORMATION
//                                  structure describing the destination.
//          ReturnAddr          - Pointer to where to return information.
//
//  Returns: Status of attempt to connect.
//
TDI_STATUS
UDPDisconnect(PTDI_REQUEST Request, void *TO,
              PTDI_CONNECTION_INFORMATION RequestAddr,
              PTDI_CONNECTION_INFORMATION ReturnAddr)
{

    AddrObj *AO;
    CTELockHandle AOHandle;

    AO = (AddrObj *) Request->Handle.AddressHandle;

    //Save the connection information for the later use.

    if ((AO != NULL) && AO_VALID(AO)) {
        CTEGetLock(&AO->ao_lock, &AOHandle);
        CTEStructAssert(AO, ao);

        if (AO->ao_usecnt) {
            //
            // There is send in progress on  AddrObj. Defer this request.
            //
            return ScheduleConnDisRequest(AO, Request, AOR_TYPE_DISCONNECT, AOHandle);

        }


        IF_TCPDBG(TCP_DEBUG_CONUDP)
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"UDPDisconnect: Closerce %x \n", AO->ao_rce));
        if (AO->ao_rce)
            (*LocalNetInfo.ipi_closerce) (AO->ao_rce);
        AO->ao_rce = NULL;

        if (AO->ao_RemoteAddress) {
            IF_TCPDBG(TCP_DEBUG_CONUDP)
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"udpdisc: deleting remoteaddress %x %x\n", AO, AO->ao_RemoteAddress));
            CTEFreeMem(AO->ao_RemoteAddress);

            AO->ao_RemoteAddress = NULL;

        }
        if (AO->ao_Options) {
            IF_TCPDBG(TCP_DEBUG_CONUDP)
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"udpdisc: deleting remoteaddress %x %x\n", AO, AO->ao_Options));
            CTEFreeMem(AO->ao_Options);

            AO->ao_Options = NULL;
        }
        CLEAR_AO_CONNUDP(AO);
        CTEFreeLock(&AO->ao_lock, AOHandle);

        return TDI_SUCCESS;

    }
    return TDI_ADDR_INVALID;

}


//* TdiConnect - Establish a connection.
//
//  The TDI connection establishment routine. Called when the client wants to
//  establish a connection, we validate his incoming parameters and kick
//  things off by sending a SYN.
//
//  Input:  Request             - The request structure for this command.
//          Timeout             - How long to wait for the request. The format
//                                  of this time is system specific - we use
//                                  a macro to convert to ticks.
//          RequestAddr         - Pointer to a TDI_CONNECTION_INFORMATION
//                                  structure describing the destination.
//          ReturnAddr          - Pointer to where to return information.
//
//  Returns: Status of attempt to connect.
//
TDI_STATUS
TdiConnect(PTDI_REQUEST Request, void *TO,
           PTDI_CONNECTION_INFORMATION RequestAddr,
           PTDI_CONNECTION_INFORMATION ReturnAddr)
{
    TCPConnReq *ConnReq;        // Connection request to use.
    IPAddr DestAddr;
    ushort DestPort;
    uchar AddrType;
    TCPConn *Conn;
    TCB *NewTCB;
    uint ConnID = PtrToUlong(Request->Handle.ConnectionContext);
    CTELockHandle AOTableHandle, ConnTableHandle, AOHandle;
    AddrObj *AO;
    TDI_STATUS Status;
    CTELockHandle TCBHandle;
    IPAddr SrcAddr;
    ushort MSS;
    TCP_TIME *Timeout;

    // First, get and validate the remote address.
    if (RequestAddr == NULL || RequestAddr->RemoteAddress == NULL ||
        !GetAddress((PTRANSPORT_ADDRESS) RequestAddr->RemoteAddress, &DestAddr,
                    &DestPort))
        return TDI_BAD_ADDR;

    AddrType = (*LocalNetInfo.ipi_getaddrtype) (DestAddr);

    if (AddrType == DEST_INVALID || IS_BCAST_DEST(AddrType) || DestPort == 0)
        return TDI_BAD_ADDR;

    // Now get a connection request. If we can't, bail out now.
    ConnReq = GetConnReq();
    if (ConnReq == NULL)
        return TDI_NO_RESOURCES;

    // Get a TCB, assuming we'll need one.
    NewTCB = AllocTCB();
    if (NewTCB == NULL) {
        // Couldn't get a TCB.
        FreeConnReq(ConnReq);
        return TDI_NO_RESOURCES;
    }
    Timeout = (TCP_TIME *) TO;

    if (Timeout != NULL && !INFINITE_CONN_TO(*Timeout)) {
        ulong Ticks = TCP_TIME_TO_TICKS(*Timeout);
        if (Ticks > MAX_CONN_TO_TICKS)
            Ticks = MAX_CONN_TO_TICKS;
        else
            Ticks++;
        ConnReq->tcr_timeout = (ushort) Ticks;
    } else
        ConnReq->tcr_timeout = 0;

    ConnReq->tcr_conninfo = ReturnAddr;
    ConnReq->tcr_addrinfo = NULL;
    ConnReq->tcr_req.tr_rtn = Request->RequestNotifyObject;
    ConnReq->tcr_req.tr_context = Request->RequestContext;
    NewTCB->tcb_daddr = DestAddr;
    NewTCB->tcb_dport = DestPort;

    // Now find the real connection. If we find it, we'll make sure it's
    // associated.
    CTEGetLock(&AddrObjTableLock.Lock, &AOTableHandle);
    Conn = GetConnFromConnID(ConnID, &ConnTableHandle);
    if (Conn != NULL) {
        uint Inserted;

        CTEStructAssert(Conn, tc);

        AO = Conn->tc_ao;

        if (AO != NULL) {
            CTEGetLock(&AO->ao_lock, &AOHandle);

            CTEStructAssert(AO, ao);
            Status = InitTCBFromConn(Conn, NewTCB, RequestAddr, TRUE);

            NewTCB->tcb_numdelacks = 1;
            NewTCB->tcb_rcvdsegs = 0;

            if (Status == TDI_SUCCESS) {

                // We've processed the options, and we know the destination
                // address is good, and we have all the resources we need,
                // so we can go ahead and open an RCE. If this works we'll
                // put the TCB into the Connection and send a SYN.

                // We're done with the AddrObjTable now, so we can free it's
                // lock.
                NewTCB->tcb_flags |= ACTIVE_OPEN;

                CTEFreeLock(&AddrObjTableLock.Lock, AOHandle);

                SrcAddr = (*LocalNetInfo.ipi_openrce)(DestAddr,
                                                      NewTCB->tcb_saddr,
                                                      &NewTCB->tcb_rce,
                                                      &AddrType, &MSS,
                                                      &NewTCB->tcb_opt);

                if (IP_ADDR_EQUAL(SrcAddr, NULL_IP_ADDR)) {
                    // The request failed. We know the destination is good
                    // (we verified it above), so it must be unreachable.
                    CTEFreeLock(&AO->ao_lock, ConnTableHandle);
                    CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), AOTableHandle);
                    Status = TDI_DEST_UNREACHABLE;
                    goto error;
                }



                if (AddrType == DEST_LOCAL) {
                    NewTCB->tcb_flags &= ~NAGLING;
                    // Ack every segment for loopback
                    NewTCB->tcb_numdelacks = 0;
                }

                // OK, the RCE open worked. Enter the TCB into the connection.
                CTEGetLock(&NewTCB->tcb_lock, &TCBHandle);
                Conn->tc_tcb = NewTCB;

                NewTCB->tcb_connid = Conn->tc_connid;
                Conn->tc_refcnt++;
                NewTCB->tcb_conn = Conn;
                REMOVEQ(&Conn->tc_q);

                ENQUEUE(&AO->ao_activeq, &Conn->tc_q);

                // This is outgoing connect request
                // ISN will not be grabbed twice

#if MILLEN
                //just use tcb_sendnext to hold hash value
                //for randisn
                NewTCB->tcb_sendnext =
                    TCB_HASH(NewTCB->tcb_daddr, NewTCB->tcb_dport,
                             NewTCB->tcb_saddr, NewTCB->tcb_sport);
#endif

                CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), TCBHandle);
                CTEFreeLock(&AO->ao_lock, ConnTableHandle);

                // If the caller didn't specify a local address, use what
                // IP provided.
                if (IP_ADDR_EQUAL(NewTCB->tcb_saddr, NULL_IP_ADDR))
                    NewTCB->tcb_saddr = SrcAddr;

                // ISN has to be generated only after all the invariants on the
                // TCB have been initialized.
                GetRandomISN((PULONG)&NewTCB->tcb_sendnext,
                             &NewTCB->tcb_addrbytes);

                // Until we have MTU discovery in place, hold the MSS down
                // to 536 if we're going off net.
                MSS -= sizeof(TCPHeader);

                if (!PMTUDiscovery && IS_OFFNET_DEST(AddrType)) {
                    NewTCB->tcb_mss = MIN(MSS, MAX_REMOTE_MSS) -
                        NewTCB->tcb_opt.ioi_optlength;

                    ASSERT(NewTCB->tcb_mss > 0);
                } else {
                    if (PMTUDiscovery)
                        NewTCB->tcb_opt.ioi_flags = IP_FLAG_DF;
                    NewTCB->tcb_mss = MSS - NewTCB->tcb_opt.ioi_optlength;

                    ASSERT(NewTCB->tcb_mss > 0);
                }

                ValidateMSS(NewTCB);

                //
                // Initialize the remote mss in case we receive an MTU change
                // from IP before the remote SYN arrives. The remmms will
                // be replaced when the remote SYN is processed.
                //
                NewTCB->tcb_remmss = NewTCB->tcb_mss;

                // Now initialize our send state.
                InitSendState(NewTCB);
                NewTCB->tcb_refcnt = 0;
                REFERENCE_TCB(NewTCB);
                NewTCB->tcb_state = TCB_SYN_SENT;
                TStats.ts_activeopens++;

#if TRACE_EVENT
                NewTCB->tcb_cpcontext = HandleToUlong(PsGetCurrentProcessId());
#endif

                // Need to put the ConnReq on the TCB now,
                // in case the timer fires after we've inserted.

                NewTCB->tcb_connreq = ConnReq;
                CTEFreeLock(&NewTCB->tcb_lock, AOTableHandle);

                //
                // Make sure that we have proper window size
                // selection.
                //

                AdjustTCBFromRCE(NewTCB);

                Inserted = InsertTCB(NewTCB, FALSE);
                CTEGetLock(&NewTCB->tcb_lock, &TCBHandle);

                if (!Inserted) {
                    // Insert failed. We must already have a connection. Pull
                    // the connreq from the TCB first, so we can return the
                    // correct error code for it.
                    NewTCB->tcb_connreq = NULL;
                    TryToCloseTCB(NewTCB, TCB_CLOSE_ABORTED, TCBHandle);
                    CTEGetLock(&NewTCB->tcb_lock, &TCBHandle);
                    DerefTCB(NewTCB, TCBHandle);
                    FreeConnReq(ConnReq);
                    return TDI_ADDR_IN_USE;
                }
                // If it's closing somehow, stop now. It can't have gone to
                // closed, as we hold a reference on it. It could have gone
                // to some other state (for example SYN-RCVD) so we need to
                // check that now too.
                if (!CLOSING(NewTCB) && NewTCB->tcb_state == TCB_SYN_SENT) {
                    if (ConnReq->tcr_timeout > 0) {
                        START_TCB_TIMER_R(NewTCB, CONN_TIMER, ConnReq->tcr_timeout);
                    }

                    TcpInvokeCcb(TCP_CONN_CLOSED, TCP_CONN_SYN_SENT, 
                                 &NewTCB->tcb_addrbytes, 0);
                    SendSYN(NewTCB, TCBHandle);
                    CTEGetLock(&NewTCB->tcb_lock, &TCBHandle);
                }
                DerefTCB(NewTCB, TCBHandle);

                return TDI_PENDING;
            } else
                CTEFreeLock(&AO->ao_lock, AOHandle);

        } else
            Status = TDI_NOT_ASSOCIATED;

        CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), ConnTableHandle);
    } else
        Status = TDI_INVALID_CONNECTION;

    CTEFreeLock(&AddrObjTableLock.Lock, AOTableHandle);
  error:
    //CTEFreeLock(&ConnTableLock, AOTableHandle);
    FreeConnReq(ConnReq);
    FreeTCB(NewTCB);
    return Status;

}

//* TdiListen - Listen for a connection.
//
//  The TDI listen handling routine. Called when the client wants to
//  post a listen, we validate his incoming parameters, allocate a TCB
//  and return.
//
//  Input:  Request             - The request structure for this command.
//          Flags               - Listen flags for the listen.
//          AcceptableAddr      - Pointer to a TDI_CONNECTION_INFORMATION
//                                  structure describing acceptable remote
//                                  addresses.
//          ConnectedAddr       - Pointer to where to return information
//                                  about the address we connected to.
//
//  Returns: Status of attempt to connect.
//
TDI_STATUS
TdiListen(PTDI_REQUEST Request, ushort Flags,
          PTDI_CONNECTION_INFORMATION AcceptableAddr,
          PTDI_CONNECTION_INFORMATION ConnectedAddr)
{
    TCPConnReq *ConnReq;        // Connection request to use.
    IPAddr RemoteAddr;            // Remote address to take conn. from.
    ushort RemotePort;            // Acceptable remote port.
    uchar AddrType;                // Type of remote address.
    TCPConn *Conn;                // Pointer to the Connection being
    // listened upon.
    TCB *NewTCB;                // Pointer to the new TCB we'll use.
    uint ConnID = PtrToUlong(Request->Handle.ConnectionContext);
    CTELockHandle ConnTableHandle;
    TDI_STATUS Status;

    // If we've been given remote addressing criteria, check it out.
    if (AcceptableAddr != NULL && AcceptableAddr->RemoteAddress != NULL) {
        if (!GetAddress((PTRANSPORT_ADDRESS) AcceptableAddr->RemoteAddress,
                        &RemoteAddr, &RemotePort))
            return TDI_BAD_ADDR;

        if (!IP_ADDR_EQUAL(RemoteAddr, NULL_IP_ADDR)) {
            AddrType = (*LocalNetInfo.ipi_getaddrtype) (RemoteAddr);

            if (AddrType == DEST_INVALID || IS_BCAST_DEST(AddrType))
                return TDI_BAD_ADDR;
        }
    } else {
        RemoteAddr = NULL_IP_ADDR;
        RemotePort = 0;
    }

    // The remote address is valid. Get a ConnReq, and maybe a TCB.
    ConnReq = GetConnReq();
    if (ConnReq == NULL)
        return TDI_NO_RESOURCES;    // Couldn't get one.

    // Now try to get a TCB.
    NewTCB = AllocTCB();
    if (NewTCB == NULL) {
        // Couldn't get a TCB. Return an error.
        FreeConnReq(ConnReq);
        return TDI_NO_RESOURCES;
    }
    // We have the resources we need. Initialize them, and then check the
    // state of the connection.
    ConnReq->tcr_flags =
        (Flags & TDI_QUERY_ACCEPT) ? TCR_FLAG_QUERY_ACCEPT : 0;
    ConnReq->tcr_conninfo = ConnectedAddr;
    ConnReq->tcr_addrinfo = NULL;
    ConnReq->tcr_req.tr_rtn = Request->RequestNotifyObject;
    ConnReq->tcr_req.tr_context = Request->RequestContext;
    NewTCB->tcb_connreq = ConnReq;
    NewTCB->tcb_daddr = RemoteAddr;
    NewTCB->tcb_dport = RemotePort;
    NewTCB->tcb_state = TCB_LISTEN;

    // Now find the real connection. If we find it, we'll make sure it's
    // associated.
    //CTEGetLock(&ConnTableLock, &ConnTableHandle);
    Conn = GetConnFromConnID(ConnID, &ConnTableHandle);
    if (Conn != NULL) {
        AddrObj *ConnAO;

        CTEStructAssert(Conn, tc);
        // We have a connection. Make sure it's associated with an address and
        // doesn't already have a TCB attached.
        ConnAO = Conn->tc_ao;

        if (ConnAO != NULL) {
            CTEStructAssert(ConnAO, ao);
            CTEGetLockAtDPC(&ConnAO->ao_lock);

            if (AO_VALID(ConnAO)) {
                Status = InitTCBFromConn(Conn, NewTCB, AcceptableAddr, TRUE);
            } else {
                Status = TDI_ADDR_INVALID;
            }

            if (Status == TDI_SUCCESS) {

                // The initialization worked. Assign the new TCB to the connection,
                // and return.

                REMOVEQ(&Conn->tc_q);
                //ENQUEUE(&ConnAO->ao_listenq, &Conn->tc_q);
                PUSHQ(&ConnAO->ao_listenq, &Conn->tc_q);

                Conn->tc_tcb = NewTCB;
                NewTCB->tcb_conn = Conn;
                NewTCB->tcb_connid = Conn->tc_connid;
                Conn->tc_refcnt++;

                ConnAO->ao_listencnt++;
                CTEFreeLockFromDPC(&ConnAO->ao_lock);

                Status = TDI_PENDING;
            } else {
                FreeTCB(NewTCB);
                CTEFreeLockFromDPC(&ConnAO->ao_lock);
            }
        } else {
            FreeTCB(NewTCB);
            Status = TDI_NOT_ASSOCIATED;
        }

        CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), ConnTableHandle);
    } else {
        FreeTCB(NewTCB);
        Status = TDI_INVALID_CONNECTION;
    }

    // We're all done. Free the locks and get out.
    //CTEFreeLock(&ConnTableLock, ConnTableHandle);
    if (Status != TDI_PENDING) {
        FreeConnReq(ConnReq);
    }
    return Status;

}

//* InitRCE - Initialize an RCE.
//
//  A utility routine to open and RCE and determine the maximum segment size
//  for a connections. This function is called with the TCB lock held
//  when transitioning out of the SYN_SENT or LISTEN states.
//
//  Input:  NewTCB          - TCB for which an RCE is to be opened.
//
//  Returns: Nothing.
//
void
InitRCE(TCB * NewTCB)
{
    uchar DType;
    ushort MSS;

    // Open an RCE for this connection.
    // postpone getting an RCE for this until gotpoestab,
    // if in synattackprotect mode.

    if (SynAttackProtect && NewTCB->tcb_state == TCB_SYN_RCVD &&
        TCPHalfOpen > TCPMaxHalfOpen) {

        (*LocalNetInfo.ipi_openrce)(NewTCB->tcb_daddr, NewTCB->tcb_saddr,
                                    NULL, &DType, &MSS, &NewTCB->tcb_opt);
    } else {

        (*LocalNetInfo.ipi_openrce)(NewTCB->tcb_daddr, NewTCB->tcb_saddr,
                                    &NewTCB->tcb_rce, &DType, &MSS,
                                    &NewTCB->tcb_opt);
    }

    NewTCB->tcb_numdelacks = 1;
    NewTCB->tcb_rcvdsegs = 0;

    AdjustTCBFromRCE(NewTCB);

    if (DType == DEST_LOCAL) {
        // Ack every segment for loopback
        NewTCB->tcb_numdelacks = 0;
        NewTCB->tcb_flags &= ~NAGLING;
    }
    // Until we have Dynamic MTU discovery in place, force MTU down.
    MSS -= sizeof(TCPHeader);
    if (!PMTUDiscovery && (DType & DEST_OFFNET_BIT)) {
        NewTCB->tcb_mss = MIN(NewTCB->tcb_remmss, MIN(MSS, MAX_REMOTE_MSS)
                              - NewTCB->tcb_opt.ioi_optlength);

        ASSERT(NewTCB->tcb_mss > 0);
    } else {
        if (PMTUDiscovery)
            NewTCB->tcb_opt.ioi_flags = IP_FLAG_DF;
        MSS -= NewTCB->tcb_opt.ioi_optlength;
        NewTCB->tcb_mss = MIN(NewTCB->tcb_remmss, MSS);

        ASSERT(NewTCB->tcb_mss > 0);

    }

    ValidateMSS(NewTCB);
}

//* AdjustTCBFromRCE - customize a TCB based on its outgoing RCE.
//
//  Called to choose various TCB parameters based on the information
//  in the TCB's RCE. Assumes the caller holds the TCB's lock.
//
//  Input:  RceTCB          - TCB to be updated.
//
//  Returns: Nothing.
//
void
AdjustTCBFromRCE(TCB* RceTCB)
{
    RouteCacheEntry* RCE;
    RCE = RceTCB->tcb_rce;
    if (RCE) {

        // Pick a different receive-window, if possible.
        // See InitTCBFromConn for the precedence rules.
        // For both of the two cases handled here, WINDOW_SET must be clear
        // (otherwise a Conn or AO window was set, and takes precedence).
        // For the auto-selection case, CONN_WINCFG must be clear
        // (otherwise a global "TcpWindowSize" was set, and takes precedence).

        if (!(RceTCB->tcb_flags & WINDOW_SET)) {
            TCPConn*    Conn = RceTCB->tcb_conn;
            uint        Window = 0;

             if (RCE->rce_TcpWindowSize) {
                if (RCE->rce_TcpWindowSize <= GlobalMaxRcvWin) {
                    Window = RCE->rce_TcpWindowSize;
                } else if (RceTCB->tcb_defaultwin > GlobalMaxRcvWin) {
                    Window = GlobalMaxRcvWin;
                }
            } else if (Conn == NULL || !(Conn->tc_flags & CONN_WINCFG)) {

                // Auto-select the window based on media-speed.
                // The choice made here is adjusted to multiple of MSS
                // later on in AdjustRcvWin.

                if (RCE->rce_mediaspeed < 100000) {
                    Window = DEFAULT_RCV_WIN / 2;
                } else if (RCE->rce_mediaspeed < 1000000000) {
                    Window = DEFAULT_RCV_WIN;
                } else if (RCE->rce_mediaspeed >= 1000000000) {
                    Window = TCP_MAXWIN;
                }

            }

            if (Window) {
                RceTCB->tcb_defaultwin = Window;
                RceTCB->tcb_rcvwin = Window;

                // (Re)compute the window scale-factor.

                RceTCB->tcb_rcvwinscale = 0;
                while ((RceTCB->tcb_rcvwinscale < TCP_MAX_WINSHIFT) &&
                       ((TCP_MAXWIN << RceTCB->tcb_rcvwinscale) <
                            (int)RceTCB->tcb_defaultwin)) {
                    RceTCB->tcb_rcvwinscale++;
                }
            }
        }

        RceTCB->tcb_delackticks = MAX(RCE->rce_TcpDelAckTicks, DEL_ACK_TICKS);

        if (RCE->rce_TcpAckFrequency) {
            RceTCB->tcb_numdelacks = RCE->rce_TcpAckFrequency - 1;
        }

        if (RCE->rce_TcpInitialRTT > MIN_INITIAL_RTT) {
            RceTCB->tcb_delta = MS_TO_TICKS(RCE->rce_TcpInitialRTT * 2);
            RceTCB->tcb_rexmit = MS_TO_TICKS(RCE->rce_TcpInitialRTT);
        }
    }
}


//* ValidateMSS - Enforce restrictions on the MSS selected for a TCB.
//
//  Called to enforce the minimum acceptable value of the MSS for a TCB.
//  In the case where an MSS has been selected which drops below the minimum,
//  the minimum is chosen and the dont-fragment flag is cleared to allow
//  fragmentation. Assumes the TCB is locked by the caller.
//
//  Input:  MssTCB          - TCB to be validated.
//
//  Returns: Nothing.
//
void
ValidateMSS(TCB* MssTCB)
{
    if ((MssTCB->tcb_mss + MssTCB->tcb_opt.ioi_optlength) < MIN_LOCAL_MSS) {
        MssTCB->tcb_mss = MIN_LOCAL_MSS - MssTCB->tcb_opt.ioi_optlength;
        MssTCB->tcb_opt.ioi_flags &= ~IP_FLAG_DF;
    }
}

//* AcceptConn - Accept a connection on a TCB.
//
//  Called to accept a connection on a TCB, either from an incoming
//  receive segment or via a user's accept. We initialize the RCE
//  and the send state, and send out a SYN if one hasn't yet been sent.
//  We assume the TCB is locked and referenced when we get it.
//
//  Input:  AcceptTCB       - TCB to accept on.
//          SYNSent         - If TRUE, the SYN-ACK has already been sent.
//          Handle          - Lock handle for TCB.
//
//  Returns: Nothing.
//
void
AcceptConn(TCB * AcceptTCB, BOOLEAN SYNSent, CTELockHandle Handle)
{
    CTEStructAssert(AcceptTCB, tcb);
    ASSERT(AcceptTCB->tcb_refcnt != 0);

    InitRCE(AcceptTCB);
    AdjustRcvWin(AcceptTCB);

    if (!SYNSent) {
        InitSendState(AcceptTCB);
        SendSYN(AcceptTCB, Handle);
        CTEGetLock(&AcceptTCB->tcb_lock, &Handle);
        DerefTCB(AcceptTCB, Handle);
    }
}

//* TdiAccept - Accept a connection.
//
//  The TDI accept routine. Called when the client wants to
//  accept a connection for which a listen had previously completed. We
//  examine the state of the connection - it has to be in SYN-RCVD, with
//  a TCB, with no pending connreq, etc.
//
//  Input:  Request             - The request structure for this command.
//          AcceptInfo          - Pointer to a TDI_CONNECTION_INFORMATION
//                                  structure describing option information
//                                  for this accept.
//          ConnectedIndo       - Pointer to where to return information
//                                  about the address we connected to.
//
//  Returns: Status of attempt to connect.
//
TDI_STATUS
TdiAccept(PTDI_REQUEST Request, PTDI_CONNECTION_INFORMATION AcceptInfo,
          PTDI_CONNECTION_INFORMATION ConnectedInfo)
{
    TCPConnReq          *ConnReq;       // ConnReq for this connection.
    uint                ConnID = PtrToUlong(Request->Handle.ConnectionContext);
    TCPConn             *Conn;          // Connection being accepted upon.
    TCB                 *AcceptTCB;     // TCB for Conn.
    CTELockHandle       ConnTableHandle;// Lock handle for connection table.
    CTELockHandle       TCBHandle;      // Lock handle for TCB.
    TDI_STATUS          Status;

    // First, get the ConnReq we'll need.
    ConnReq = GetConnReq();
    if (ConnReq == NULL)
        return TDI_NO_RESOURCES;

    ConnReq->tcr_conninfo = ConnectedInfo;
    ConnReq->tcr_addrinfo = NULL;
    ConnReq->tcr_req.tr_rtn = Request->RequestNotifyObject;
    ConnReq->tcr_req.tr_context = Request->RequestContext;
    ConnReq->tcr_flags = 0;

    // Now look up the connection.
    //CTEGetLock(&ConnTableLock, &ConnTableHandle);
    Conn = GetConnFromConnID(ConnID, &ConnTableHandle);
    if (Conn != NULL) {
        CTEStructAssert(Conn, tc);

        // We have the connection. Make sure is has a TCB, and that the
        // TCB is in the SYN-RCVD state, etc.
        AcceptTCB = Conn->tc_tcb;

        if (AcceptTCB != NULL) {
            CTEStructAssert(AcceptTCB, tcb);

            // Grab random ISN
            // Note that if CONN was pre accepted we would'nt be here
            // So, we are not getting ISN twice.
#if MILLEN
            //just use tcb_sendnext to hold hash value
            //for randisn
            AcceptTCB->tcb_sendnext = TCB_HASH(AcceptTCB->tcb_daddr, AcceptTCB->tcb_dport, AcceptTCB->tcb_saddr, AcceptTCB->tcb_sport);

#endif

            GetRandomISN((PULONG)&AcceptTCB->tcb_sendnext,
                         &AcceptTCB->tcb_addrbytes);

            CTEGetLock(&AcceptTCB->tcb_lock, &TCBHandle);
            CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), TCBHandle);

            if (!CLOSING(AcceptTCB) && AcceptTCB->tcb_state == TCB_SYN_RCVD) {
                // State is valid. Make sure this TCB had a delayed accept on
                // it, and that there is currently no connect request pending.
                if (!(AcceptTCB->tcb_flags & CONN_ACCEPTED) &&
                    AcceptTCB->tcb_connreq == NULL) {

                    // If the caller gave us options, they'll override any
                    // that are already present, if they're valid.
                    if (AcceptInfo != NULL) {
                        if (AcceptInfo->Options != NULL) {
                            IPOptInfo TempOptInfo;

                            // We have options. Copy them to make sure they're
                            // valid.
                            Status = ProcessUserOptions(AcceptInfo,
                                                        &TempOptInfo);
                            if (Status == TDI_SUCCESS) {
                                (*LocalNetInfo.ipi_freeopts) (&AcceptTCB->tcb_opt);
                                AcceptTCB->tcb_opt = TempOptInfo;
                                AcceptTCB->tcb_flags |= CLIENT_OPTIONS;
                            } else
                                goto connerror;
                        }
                        if (AcceptInfo->RemoteAddress) {
                            ConnReq->tcr_addrinfo = AcceptInfo;
                        }
                    }
                    AcceptTCB->tcb_connreq = ConnReq;
                    AcceptTCB->tcb_flags |= CONN_ACCEPTED;
                    REFERENCE_TCB(AcceptTCB);

                    // Everything's set. Accept the connection now.
                    AcceptConn(AcceptTCB, FALSE, ConnTableHandle);

#if TRACE_EVENT
                    AcceptTCB->tcb_cpcontext = HandleToUlong(PsGetCurrentProcessId());
#endif
                    return TDI_PENDING;
                }
            }
          connerror:
            CTEFreeLock(&AcceptTCB->tcb_lock, ConnTableHandle);
            Status = TDI_INVALID_CONNECTION;
            goto error;
        }
        CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), ConnTableHandle);
    }
    Status = TDI_INVALID_CONNECTION;
    //CTEFreeLock(&ConnTableLock, ConnTableHandle);

  error:
    FreeConnReq(ConnReq);
    return Status;

}

//* TdiDisConnect - Disconnect a connection.
//
//  The TDI disconnection routine. Called when the client wants to disconnect
//  a connection. There are two types of disconnection we support, graceful
//  and abortive. A graceful close will cause us to send a FIN and not complete
//  the request until we get the ACK back. An abortive close causes us to send
//  a RST. In that case we'll just get things going and return immediately.
//
//  Input:  Request             - The request structure for this command.
//          Timeout             - How long to wait for the request. The format
//                                  of this time is system specific - we use
//                                  a macro to convert to ticks.
//          Flags               - Flags indicating type of disconnect.
//          DiscConnInfo        - Pointer to a TDI_CONNECTION_INFORMATION
//                                  structure giving disconnection info. Ignored
//                                  for this request.
//          ReturnInfo          - Pointer to where to return information.
//                                  Ignored for this request.
//
//  Returns: Status of attempt to disconnect.
//
TDI_STATUS
TdiDisconnect(PTDI_REQUEST Request, void *TO, ushort Flags,
              PTDI_CONNECTION_INFORMATION DiscConnInfo,
              PTDI_CONNECTION_INFORMATION ReturnInfo,
              TCPAbortReq *AbortReq)
{
    TCPConnReq *ConnReq;        // Connection request to use.
    TCPConn *Conn;
    TCB *DiscTCB;
    CTELockHandle ConnTableHandle;
    TDI_STATUS Status;
    TCP_TIME *Timeout;

    //CTEGetLock(&ConnTableLock, &ConnTableHandle);

    Conn = GetConnFromConnID(PtrToUlong(Request->Handle.ConnectionContext), &ConnTableHandle);

    if (Conn != NULL) {
        CTEStructAssert(Conn, tc);

        DiscTCB = Conn->tc_tcb;

        if (DiscTCB != NULL) {

            CTEStructAssert(DiscTCB, tcb);
            CTEGetLockAtDPC(&DiscTCB->tcb_lock);

            // We have the TCB. See what kind of disconnect this is.
            if (Flags & TDI_DISCONNECT_ABORT) {
                // This is an abortive disconnect. If we're not already
                // closed or closing, blow the connection away.
                if (DiscTCB->tcb_state != TCB_CLOSED) {
                    CTEFreeLockFromDPC(&(Conn->tc_ConnBlock->cb_lock));

                    if (AbortReq != NULL) {
                        if (DiscTCB->tcb_abortreq == NULL) {
                            AbortReq->tar_rtn = Request->RequestNotifyObject;
                            AbortReq->tar_context = Request->RequestContext;
                            DiscTCB->tcb_abortreq = AbortReq;
                            Status = TDI_PENDING;
                        } else {
                            Status = TDI_SUCCESS;
                        }
                    } else {
                        Status = TDI_SUCCESS;
                    }

                    if (!CLOSING(DiscTCB)) {
                        DiscTCB->tcb_flags |= NEED_RST;
                        TryToCloseTCB(DiscTCB, TCB_CLOSE_ABORTED,
                                      ConnTableHandle);
                    } else
                        CTEFreeLock(&DiscTCB->tcb_lock, ConnTableHandle);

                    return Status;

                } else {
                    // The TCB isn't connected.
                    CTEFreeLockFromDPC(&(Conn->tc_ConnBlock->cb_lock));

                    CTEFreeLock(&DiscTCB->tcb_lock, ConnTableHandle);
                    return TDI_INVALID_STATE;
                }
            } else {
                // This is not an abortive close. For graceful close we'll need
                // a ConnReq.
                CTEFreeLockFromDPC(&(Conn->tc_ConnBlock->cb_lock));

                // Make sure we aren't in the middle of an abortive close.
                if (CLOSING(DiscTCB)) {
                    CTEFreeLock(&DiscTCB->tcb_lock, ConnTableHandle);
                    return TDI_INVALID_CONNECTION;
                }
                ConnReq = GetConnReq();
                if (ConnReq != NULL) {
                    // Got the ConnReq. See if this is a DISCONNECT_WAIT
                    // primitive or not.

                    ConnReq->tcr_flags = 0;
                    ConnReq->tcr_conninfo = NULL;
                    ConnReq->tcr_addrinfo = NULL;
                    ConnReq->tcr_req.tr_rtn = Request->RequestNotifyObject;
                    ConnReq->tcr_req.tr_context = Request->RequestContext;

                    if (!(Flags & TDI_DISCONNECT_WAIT)) {
                        Timeout = (TCP_TIME *) TO;

                        if (Timeout != NULL && !INFINITE_CONN_TO(*Timeout)) {
                            ulong Ticks = TCP_TIME_TO_TICKS(*Timeout);
                            if (Ticks > MAX_CONN_TO_TICKS)
                                Ticks = MAX_CONN_TO_TICKS;
                            else
                                Ticks++;
                            ConnReq->tcr_timeout = (ushort) Ticks;
                        } else
                            ConnReq->tcr_timeout = 0;

                        // OK, we're just about set. We need to update the TCB
                        // state, and send the FIN.
                        if (DiscTCB->tcb_state == TCB_ESTAB) {
                            DiscTCB->tcb_state = TCB_FIN_WAIT1;

                            // Since we left established, we're off the fast
                            // receive path.
                            DiscTCB->tcb_slowcount++;
                            DiscTCB->tcb_fastchk |= TCP_FLAG_SLOW;
                        } else if (DiscTCB->tcb_state == TCB_CLOSE_WAIT)
                            DiscTCB->tcb_state = TCB_LAST_ACK;
                        else {
                            CTEFreeLock(&DiscTCB->tcb_lock, ConnTableHandle);
                            FreeConnReq(ConnReq);
                            return TDI_INVALID_STATE;
                        }

                        // Update SNMP info.
                        InterlockedDecrement((PLONG)&TStats.ts_currestab); 

                        ASSERT(DiscTCB->tcb_connreq == NULL);
                        DiscTCB->tcb_connreq = ConnReq;
                        if (ConnReq->tcr_timeout > 0) {
                            START_TCB_TIMER_R(DiscTCB, CONN_TIMER, ConnReq->tcr_timeout);
                        }
                        DiscTCB->tcb_flags |= FIN_NEEDED;
                        REFERENCE_TCB(DiscTCB);
                        TCPSend(DiscTCB, ConnTableHandle);
                        return TDI_PENDING;
                    } else {
                        // This is a DISC_WAIT request.
                        ConnReq->tcr_timeout = 0;
                        if (DiscTCB->tcb_discwait == NULL) {
                            DiscTCB->tcb_discwait = ConnReq;
                            Status = TDI_PENDING;
                        } else {
                            FreeConnReq(ConnReq);
                            Status = TDI_INVALID_STATE;
                        }

                        CTEFreeLock(&DiscTCB->tcb_lock, ConnTableHandle);
                        return Status;
                    }
                } else {
                    // Couldn't get a ConnReq.
                    CTEFreeLock(&DiscTCB->tcb_lock, ConnTableHandle);
                    return TDI_NO_RESOURCES;
                }
            }
        } else
            CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), ConnTableHandle);
    }
    // No Conn, or no TCB on conn. Return an error.
    //CTEFreeLock(&ConnTableLock, ConnTableHandle);
    return TDI_INVALID_CONNECTION;
}

//* OKToNotify - See if it's OK to notify about a DISC.
//
//  A little utility function, called to see it it's OK to notify the client
//  of an incoming FIN.
//
//  Input: NotifyTCB    - TCB to check.
//
//  Returns: TRUE if it's OK, False otherwise.
//
uint
OKToNotify(TCB * NotifyTCB)
{
    CTEStructAssert(NotifyTCB, tcb);
    if (NotifyTCB->tcb_pendingcnt == 0 && NotifyTCB->tcb_urgcnt == 0 &&
        NotifyTCB->tcb_rcvhead == NULL && NotifyTCB->tcb_exprcv == NULL)
        return TRUE;
    else
        return FALSE;
}

//* NotifyOfDisc - Notify a client that a TCB is being disconnected.
//
//  Called when we're disconnecting a TCB because we've received a FIN or
//  RST from the remote peer, or because we're aborting for some reason.
//  We'll complete a DISCONNECT_WAIT request if we have one, or try and
//  issue an indication otherwise. This is only done if we're in a synchronized
//  state and not in TIMED-WAIT.
//
//  Input:  DiscTCB         - Pointer to TCB we're notifying.
//          Status          - Status code for notification.
//
//  Returns: Nothing.
//
void
NotifyOfDisc(TCB * DiscTCB, IPOptInfo * DiscInfo, TDI_STATUS Status,
             CTELockHandle* TCBHandlePtr)
{
    CTELockHandle TCBHandle, AOTHandle, ConnTHandle;
    TCPConnReq *DiscReq;
    TCPConn *Conn;
    AddrObj *DiscAO;
    PVOID ConnContext;

    CTEStructAssert(DiscTCB, tcb);
    ASSERT(DiscTCB->tcb_refcnt != 0);

    if (TCBHandlePtr) {
        TCBHandle = *TCBHandlePtr;
    } else {
        CTEGetLock(&DiscTCB->tcb_lock, &TCBHandle);
    }
    if (SYNC_STATE(DiscTCB->tcb_state) &&
        !(DiscTCB->tcb_flags & DISC_NOTIFIED)) {

        // We can't notify him if there's still data to be taken.
        if (Status == TDI_GRACEFUL_DISC) {
            if (!OKToNotify(DiscTCB)) {
                DiscTCB->tcb_flags |= DISC_PENDING;
                CTEFreeLock(&DiscTCB->tcb_lock, TCBHandle);
                return;
            }
            if (DiscTCB->tcb_pending & RST_PENDING) {
                CTEFreeLock(&DiscTCB->tcb_lock, TCBHandle);
                return;
            }
        } else {
            if (DiscTCB->tcb_flags & (IN_RCV_IND | IN_DELIV_URG)) {
                DiscTCB->tcb_pending |= RST_PENDING;
                CTEFreeLock(&DiscTCB->tcb_lock, TCBHandle);
                return;
            }
            DiscTCB->tcb_pending &= ~RST_PENDING;
        }

        DiscTCB->tcb_flags |= DISC_NOTIFIED;
        DiscTCB->tcb_flags &= ~DISC_PENDING;

        // We're in a state where a disconnect is meaningful, and we haven't
        // already notified the client.

        // See if we have a DISC-WAIT request pending.
        if ((DiscReq = DiscTCB->tcb_discwait) != NULL) {
            // We have a disconnect wait request. Complete it and we're done.
            DiscTCB->tcb_discwait = NULL;
            CTEFreeLock(&DiscTCB->tcb_lock, TCBHandle);
            (*DiscReq->tcr_req.tr_rtn) (DiscReq->tcr_req.tr_context, Status, 0);
            FreeConnReq(DiscReq);
            return;

        }
        // No DISC-WAIT. Find the AddrObj for the connection, and see if there
        // is a disconnect handler registered.

        ConnContext = DiscTCB->tcb_conncontext;
        CTEFreeLock(&DiscTCB->tcb_lock, TCBHandle);

        CTEGetLock(&AddrObjTableLock.Lock, &AOTHandle);
        //CTEGetLock(&ConnTableLock, &ConnTHandle);
        if ((Conn = DiscTCB->tcb_conn) != NULL) {

            CTEGetLock(&(Conn->tc_ConnBlock->cb_lock), &ConnTHandle);
#if DBG
            Conn->tc_ConnBlock->line = (uint) __LINE__;
            Conn->tc_ConnBlock->module = (uchar *) __FILE__;
#endif
            CTEStructAssert(Conn, tc);

            DiscAO = Conn->tc_ao;
            if (DiscAO != NULL) {
                CTELockHandle AOHandle;
                PDisconnectEvent DiscEvent;
                PVOID DiscContext;

                CTEStructAssert(DiscAO, ao);
                CTEGetLock(&DiscAO->ao_lock, &AOHandle);
                CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), AOHandle);
                CTEFreeLock(&AddrObjTableLock.Lock, ConnTHandle);

                DiscEvent = DiscAO->ao_disconnect;
                DiscContext = DiscAO->ao_disconncontext;

                if (DiscEvent != NULL) {
                    uint InfoLength;
                    PVOID Info;

                    REF_AO(DiscAO);
                    CTEFreeLock(&DiscAO->ao_lock, AOTHandle);

                    if (DiscInfo != NULL) {
                        InfoLength = (uint) DiscInfo->ioi_optlength;
                        Info = DiscInfo->ioi_options;
                    } else {
                        InfoLength = 0;
                        Info = NULL;
                    }

                    IF_TCPDBG(TCP_DEBUG_CLOSE) {
                        TCPTRACE(("TCP: indicating %s disconnect\n",
                                  (Status == TDI_GRACEFUL_DISC) ? "graceful" :
                                  "abortive"
                                 ));
                    }

                    (*DiscEvent) (DiscContext,
                                  ConnContext, 0,
                                  NULL, InfoLength, Info, (Status == TDI_GRACEFUL_DISC) ?
                                  TDI_DISCONNECT_RELEASE : TDI_DISCONNECT_ABORT);

                    DELAY_DEREF_AO(DiscAO);
                    return;
                } else {
                    CTEFreeLock(&DiscAO->ao_lock, AOTHandle);
                    return;
                }
            }
            CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), ConnTHandle);
        }
        CTEFreeLock(&AddrObjTableLock.Lock, AOTHandle);
        return;

    }
    CTEFreeLock(&DiscTCB->tcb_lock, TCBHandle);

}

//* GracefulClose - Complete the transition to a gracefully closed state.
//
//  Called when we need to complete the transition to a gracefully closed
//  state, either TIME_WAIT or CLOSED. This completion involves removing
//  the TCB from it's associated connection (if it has one), notifying the
//  upper layer client either via completing a request or calling a disc.
//  notification handler, and actually doing the transition.
//
//  The tricky part here is if we need to notify him (instead of completing
//  a graceful disconnect request). We can't notify him if there is pending
//  data on the connection, so in that case we have to pend the disconnect
//  notification until we deliver the data.
//
//  Input:  CloseTCB        - TCB to transition.
//          ToTimeWait      - True if we're going to TIME_WAIT, False if
//                              we're going to close the TCB.
//          Notify          - True if we're going to transition via notification,
//                              False if we're going to transition by completing
//                              a disconnect request.
//          Handle          - Lock handle for TCB.
//
//  Returns: Nothing.
//
void
GracefulClose(TCB * CloseTCB, uint ToTimeWait, uint Notify, CTELockHandle Handle)
{
    CTEStructAssert(CloseTCB, tcb);
    ASSERT(CloseTCB->tcb_refcnt != 0);

#if DBG
    if (Notify && (CloseTCB->tcb_fastchk & TCP_FLAG_SEND_AND_DISC)) {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Notifying on S&D %x\n", CloseTCB));
        DbgBreakPoint();
    }
#endif


    if ((CloseTCB->tcb_fastchk & TCP_FLAG_SEND_AND_DISC) &&
        (!OKToNotify(CloseTCB))) {
        // Can't notify him now. Set the appropriate flags, and return.
        CloseTCB->tcb_flags |= (GC_PENDING | (ToTimeWait ? TW_PENDING : 0));
        DerefTCB(CloseTCB, Handle);
        return;
    }

    // First, see if we need to notify the client of a FIN.
    if (Notify) {
        // We do need to notify him. See if it's OK to do so.
        if (OKToNotify(CloseTCB)) {
            // We can notify him. Change his state, pull him from the conn.,
            // and notify him.
            if (ToTimeWait) {
                // Save the time we went into time wait, in case we need to
                // scavenge.
                //CloseTCB->tcb_alive = CTESystemUpTime();
                CloseTCB->tcb_state = TCB_TIME_WAIT;
                //take care rcvind if this is on delay q.
                CloseTCB->tcb_rcvind = NULL;

                CTEFreeLock(&CloseTCB->tcb_lock, Handle);

            } else {
                // He's going to close. Mark him as closing with TryToCloseTCB
                // (he won't actually close since we have a ref. on him). We
                // do this so that anyone touching him after we free the
                // lock will fail.
                TryToCloseTCB(CloseTCB, TDI_SUCCESS, Handle);
            }

            RemoveTCBFromConn(CloseTCB);
            NotifyOfDisc(CloseTCB, NULL, TDI_GRACEFUL_DISC, NULL);

        } else {
            // Can't notify him now. Set the appropriate flags, and return.
            CloseTCB->tcb_flags |= (GC_PENDING | (ToTimeWait ? TW_PENDING : 0));
            DerefTCB(CloseTCB, Handle);
            return;
        }
    } else {
        // We're not notifying this guy, we just need to complete a conn. req.
        // We need to check and see if he's been notified, and if not
        // we'll complete the request and notify him later.
        if ((CloseTCB->tcb_flags & DISC_NOTIFIED)
            || (CloseTCB->tcb_fastchk & TCP_FLAG_SEND_AND_DISC)) {
            // He's been notified.
            if (ToTimeWait) {
                // Save the time we went into time wait, in case we need to
                // scavenge.
                //CloseTCB->tcb_alive = CTESystemUpTime();
                CloseTCB->tcb_state = TCB_TIME_WAIT;
                CloseTCB->tcb_rcvind = NULL;

                CTEFreeLock(&CloseTCB->tcb_lock, Handle);

            } else {
                // Mark him as closed. See comments above.
                TryToCloseTCB(CloseTCB, TDI_SUCCESS, Handle);
            }

            RemoveTCBFromConn(CloseTCB);

            CTEGetLock(&CloseTCB->tcb_lock, &Handle);

            if (CloseTCB->tcb_fastchk & TCP_FLAG_SEND_AND_DISC) {

                if (!EMPTYQ(&CloseTCB->tcb_sendq)) {

                    TCPReq *Req;
                    TCPSendReq *SendReq;
                    uint Result;

                    DEQUEUE(&CloseTCB->tcb_sendq, Req, TCPReq, tr_q);

                    CTEStructAssert(Req, tr);
                    SendReq = (TCPSendReq *) Req;
                    CTEStructAssert(SendReq, tsr);

                    ASSERT(SendReq->tsr_flags & TSR_FLAG_SEND_AND_DISC);

                    // Decrement the initial reference put on the buffer when it was
                    // allocated. This reference would have been decremented if the
                    // send had been acknowledged, but then the send would not still
                    // be on the tcb_sendq.

                    SendReq->tsr_req.tr_status = TDI_SUCCESS;

                    Result = CTEInterlockedDecrementLong(&(SendReq->tsr_refcnt));

                    if (Result <= 1) {
                        // If we've sent directly from this send, NULL out the next
                        // pointer for the last buffer in the chain.
                        CloseTCB->tcb_flags |= DISC_NOTIFIED;
                        CTEFreeLock(&CloseTCB->tcb_lock, Handle);

                        if (SendReq->tsr_lastbuf != NULL) {
                            NDIS_BUFFER_LINKAGE(SendReq->tsr_lastbuf) = NULL;
                            SendReq->tsr_lastbuf = NULL;
                        }
                        //KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"GC: Completing %x %x %x\n",
                        //         SendReq, Req->tr_context, CloseTCB));
                        (*Req->tr_rtn) (Req->tr_context, TDI_SUCCESS, SendReq->tsr_size);
                        FreeSendReq(SendReq);
                    } else {
                        CTEFreeLock(&CloseTCB->tcb_lock, Handle);
                    }
                } else {
                    CTEFreeLock(&CloseTCB->tcb_lock, Handle);
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"S&D empty sendq %x\n", CloseTCB));
                    ASSERT(FALSE);
                }

            } else {

                CompleteConnReq(CloseTCB, NULL, TDI_SUCCESS);
                CTEFreeLock(&CloseTCB->tcb_lock, Handle);
            }

        } else {
            // He hasn't been notified. He should be pending already.
            ASSERT(CloseTCB->tcb_flags & DISC_PENDING);
            CloseTCB->tcb_flags |= (GC_PENDING | (ToTimeWait ? TW_PENDING : 0));

            CompleteConnReq(CloseTCB, NULL, TDI_SUCCESS);

            DerefTCB(CloseTCB, Handle);
            return;
        }
    }

    // If we're going to TIME_WAIT, start the TIME_WAIT timer now.
    // Otherwise close the TCB.
    CTEGetLock(&CloseTCB->tcb_lock, &Handle);
    if (!CLOSING(CloseTCB) && ToTimeWait) {
        CTEFreeLock(&CloseTCB->tcb_lock, Handle);
        RemoveConnFromTCB(CloseTCB);

        //at this point ref_cnt should be 1
        //tcb_pending should be 0

        if (!RemoveAndInsert(CloseTCB)) {
            ASSERT(0);
        }

        return;
    }
    DerefTCB(CloseTCB, Handle);

}

//* ConnCheckPassed - Check to see if we have exceeded the connect limit
//
//  Called when a SYN is received to determine whether we will accept
//  the incoming connection. If the is an empty slot or if the IPAddr
//  is already in the table, we accept it.
//
//  Input: Source Address of incoming connection
//         Destination port of incoming connection
//
//  Returns: TRUE is connect is to be accepted
//           FALSE if connection is rejected
//
int
ConnCheckPassed(IPAddr Src, ulong Prt)
{
    UNREFERENCED_PARAMETER(Src);
    UNREFERENCED_PARAMETER(Prt);

    return TRUE;
}

void
InitAddrChecks()
{
    return;
}

//* EnumerateConnectionList - Enumerate Connection List database.
//
//  This routine enumerates the contents of the connection limit database
//
//  Input:
//
//          Buffer            - A pointer to a buffer into which to put
//                              the returned connection list entries.
//
//          BufferSize        - On input, the size in bytes of Buffer.
//                              On output, the number of bytes written.
//
//          EntriesAvailable  - On output, the total number of connection entries
//                              available in the database.
//
//  Returns: A TDI status code:
//
//           TDI_SUCCESS otherwise.
//
//  NOTES:
//
//      This routine acquires AddrObjTableLock.
//
//      Entries written to output buffer are in host byte order.
//
void
EnumerateConnectionList(uchar * Buffer, ulong BufferSize,
                        ulong * EntriesReturned, ulong * EntriesAvailable)
{

    UNREFERENCED_PARAMETER(Buffer);
    UNREFERENCED_PARAMETER(BufferSize);

    *EntriesAvailable = 0;
    *EntriesReturned = 0;

    return;
}

#pragma BEGIN_INIT

//* InitTCPConn - Initialize TCP connection management code.
//
//  Called during init time to initialize our TCP connection mgmt..
//
//  Input: Nothing.
//
//  Returns: TRUE.
//
int
InitTCPConn(void)
{
    TcpConnPool = PplCreatePool(
                    TcpConnAllocate,
                    TcpConnFree,
                    0,
                    sizeof(TCPConn),
                    'CPCT',
                    0);

    if (!TcpConnPool) {
        return FALSE;
    }

    CTEInitLock(&ConnTableLock);
    return TRUE;
}

//* UnInitTCPConn - Uninitialize our connection management code.
//
//  Called if initialization fails to uninitialize our conn mgmet.
//
//
//  Input:  Nothing.
//
//  Returns: Nothing.
//
void
UnInitTCPConn(void)
{
    PplDestroyPool(TcpConnPool);
}

#pragma END_INIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\secfltr.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** SECFLTR.C - Security Filter Support
//
//
// Security filters provide a mechanism by which the transport protocol
// traffic accepted on IP interfaces may be controlled. Security filtering
// is globally enabled or disabled for all IP interfaces and transports.
// If filtering is enabled, incoming traffic is filtered based on registered
// {interface, protocol, transport value} tuples. The tuples specify
// permissible traffic. All other values will be rejected. For UDP datagrams
// and TCP connections, the transport value is the port number. For RawIP
// datagrams, the transport value is the IP protocol number. An entry exists
// in the filter database for all active interfaces and protocols in the
// system.
//
// The initial status of security filtering - enabled or disabled, is
// controlled by the registry parameter
//
//         Services\Tcpip\Parameters\EnableSecurityFilters
//
// If the parameter is not found, filtering is disabled.
//
// The list of permissible values for each protocol is stored in the registry
// under the <Adaptername>\Parameters\Tcpip key in MULTI_SZ parameters.
// The parameter names are TCPAllowedPorts, UDPAllowedPorts and
// RawIPAllowedProtocols. If no parameter is found for a particular protocol,
// all values are permissible. If a parameter is found, the string identifies
// the permissible values. If the string is empty, no values are permissible.
//
// Filter Operation (Filtering Enabled):
//
//     IF ( Match(interface, protocol) AND ( AllValuesPermitted(Protocol) OR
//                                       Match(Value) ))
//     THEN operation permitted.
//     ELSE operation rejected.
//
// Database Implementation:
//
// The filter database is implemented as a three-level structure. The top
// level is a list of interface entries. Each interface entry points to
// a list of protocol entries. Each protocol entry contains a bucket hash
// table used to store transport value entries.
//

// The following calls may be used to access the security filter database:
//
//     InitializeSecurityFilters
//     CleanupSecurityFilters
//     IsSecurityFilteringEnabled
//     ControlSecurityFiltering
//     AddProtocolSecurityFilter
//     DeleteProtocolSecurityFilter
//     AddValueSecurityFilter
//     DeleteValueSecurityFilter
//     EnumerateSecurityFilters
//     IsPermittedSecurityFilter
//

#include "precomp.h"

#include "addr.h"
#include "tlcommon.h"
#include "udp.h"
#include "tcp.h"
#include "raw.h"
#include "tcpcfg.h"
#include "tcpinfo.h"
#include "secfltr.h"

//
// All of the init code can be discarded.
//

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, InitializeSecurityFilters)
#endif

//
// The following routines must be supplied by each platform which implements
// security filters.
//
extern TDI_STATUS
 GetSecurityFilterList(
                       IN NDIS_HANDLE ConfigHandle,
                       IN ulong Protocol,
                       IN OUT PNDIS_STRING FilterList
                       );

extern uint
 EnumSecurityFilterValue(
                         IN PNDIS_STRING FilterList,
                         IN ulong Index,
                         OUT ulong * FilterValue
                         );

//
// Constants
//

#define DHCP_CLIENT_PORT 68

//
// Modification Opcodes
//
#define ADD_VALUE_SECURITY_FILTER     0
#define DELETE_VALUE_SECURITY_FILTER  1

//
// Types
//

//
// Structure for a transport value entry.
//
struct value_entry {
    struct Queue ve_link;
    ulong ve_value;
};

typedef struct value_entry VALUE_ENTRY, *PVALUE_ENTRY;

#define VALUE_ENTRY_HASH_SIZE  16
#define VALUE_ENTRY_HASH(value)   (value % VALUE_ENTRY_HASH_SIZE)

//
// Structure for a protocol entry.
//
struct protocol_entry {
    struct Queue pe_link;
    ulong pe_protocol;
    ULONG pe_accept_all;        // TRUE if all values are accepted.

    struct Queue pe_entries[VALUE_ENTRY_HASH_SIZE];
};

typedef struct protocol_entry PROTOCOL_ENTRY, *PPROTOCOL_ENTRY;

//
// Structure for an interface entry.
//
struct interface_entry {
    struct Queue ie_link;
    IPAddr ie_address;
    struct Queue ie_protocol_list;    // list of protocols to filter

};

typedef struct interface_entry INTERFACE_ENTRY, *PINTERFACE_ENTRY;

//
// Global Data
//

//
// This list of interface entries is the root of the filter database.
//
struct Queue InterfaceEntryList;

//
// The filter operations are synchronized using the AddrObjTableLock.
//
extern IPInfo LocalNetInfo;

//
// Filter Database Helper Functions
//

//* FindInterfaceEntry - Search for an interface entry.
//
//  This utility routine searches the security filter database
//  for the specified interface entry.
//
//
//  Input:  InterfaceAddress  - The address of the interface to search for.
//
//
//  Returns: A pointer to the database entry for the Interface,
//               or NULL if no match was found.
//
//
PINTERFACE_ENTRY
FindInterfaceEntry(ULONG InterfaceAddress)
{
    PINTERFACE_ENTRY ientry;
    struct Queue *qentry;

    for (qentry = InterfaceEntryList.q_next;
         qentry != &InterfaceEntryList;
         qentry = qentry->q_next
         ) {
        ientry = STRUCT_OF(INTERFACE_ENTRY, qentry, ie_link);

        if (ientry->ie_address == InterfaceAddress) {
            return (ientry);
        }
    }

    return (NULL);
}

//* FindProtocolEntry - Search for a protocol associated with an interface.
//
//  This utility routine searches the security filter database
//  for the specified protocol registered under the specified interface.
//
//
//  Input:  InterfaceEntry    - A pointer to an interface entry to search under.
//          Protocol          - The protocol value to search for.
//
//
//  Returns: A pointer to the database entry for the <Address, Protocol>,
//               or NULL if no match was found.
//
//
PPROTOCOL_ENTRY
FindProtocolEntry(PINTERFACE_ENTRY InterfaceEntry, ULONG Protocol)
{
    PPROTOCOL_ENTRY pentry;
    struct Queue *qentry;

    for (qentry = InterfaceEntry->ie_protocol_list.q_next;
         qentry != &(InterfaceEntry->ie_protocol_list);
         qentry = qentry->q_next
         ) {
        pentry = STRUCT_OF(PROTOCOL_ENTRY, qentry, pe_link);

        if (pentry->pe_protocol == Protocol) {
            return (pentry);
        }
    }

    return (NULL);
}

//* FindValueEntry - Search for a value on a particular protocol.
//
//  This utility routine searches the security filter database
//  for the specified value registered under the specified protocol.
//
//
//  Input:  ProtocolEntry   - A pointer to the database structure for the
//                                Protocol to search.
//          FilterValue     - The value to search for.
//
//
//  Returns: A pointer to the database entry for the <Protocol, Value>,
//               or NULL if no match was found.
//
//
PVALUE_ENTRY
FindValueEntry(PPROTOCOL_ENTRY ProtocolEntry, ULONG FilterValue)
{
    PVALUE_ENTRY ventry;
    ulong hash_value = VALUE_ENTRY_HASH(FilterValue);
    struct Queue *qentry;

    for (qentry = ProtocolEntry->pe_entries[hash_value].q_next;
         qentry != &(ProtocolEntry->pe_entries[hash_value]);
         qentry = qentry->q_next
         ) {
        ventry = STRUCT_OF(VALUE_ENTRY, qentry, ve_link);

        if (ventry->ve_value == FilterValue) {
            return (ventry);
        }
    }

    return (NULL);
}

//* DeleteProtocolValueEntries
//
//  This utility routine deletes all the value entries associated with
//  a protocol filter entry.
//
//
//  Input:  ProtocolEntry - The protocol filter entry for which to
//                          delete the value entries.
//
//
//  Returns: Nothing
//
void
DeleteProtocolValueEntries(PPROTOCOL_ENTRY ProtocolEntry)
{
    ulong i;
    PVALUE_ENTRY entry;

    for (i = 0; i < VALUE_ENTRY_HASH_SIZE; i++) {
        while (!EMPTYQ(&(ProtocolEntry->pe_entries[i]))) {

            DEQUEUE(&(ProtocolEntry->pe_entries[i]), entry, VALUE_ENTRY, ve_link);
            CTEFreeMem(entry);
        }
    }

    return;
}

//* ModifyProtocolEntry
//
//  This utility routine modifies one or more filter values associated
//  with a protocol.
//
//
//  Input:  Operation     - The operation to perform (add or delete)
//
//          ProtocolEntry - A pointer to the protocol entry structure on
//                              which to operate.
//
//          FilterValue   - The value to add or delete.
//
//
//  Returns: TDI_STATUS code
//
TDI_STATUS
ModifyProtocolEntry(ulong Operation, PPROTOCOL_ENTRY ProtocolEntry,
                    ulong FilterValue)
{
    TDI_STATUS status = TDI_SUCCESS;

    if (FilterValue == 0) {
        if (Operation == ADD_VALUE_SECURITY_FILTER) {
            //
            // Accept all values for the protocol
            //
            ProtocolEntry->pe_accept_all = TRUE;
        } else {
            //
            // Reject all values for the protocol
            //
            ProtocolEntry->pe_accept_all = FALSE;
        }

        DeleteProtocolValueEntries(ProtocolEntry);
    } else {
        PVALUE_ENTRY ventry;
        ulong hash_value;

        //
        // This request modifies an individual entry.
        //
        ventry = FindValueEntry(ProtocolEntry, FilterValue);

        if (Operation == ADD_VALUE_SECURITY_FILTER) {

            if (ventry == NULL) {

                ventry = CTEAllocMem(sizeof(VALUE_ENTRY));

                if (ventry != NULL) {
                    ventry->ve_value = FilterValue;
                    hash_value = VALUE_ENTRY_HASH(FilterValue);

                    ENQUEUE(&(ProtocolEntry->pe_entries[hash_value]),
                            &(ventry->ve_link));

                    ProtocolEntry->pe_accept_all = FALSE;
                } else {
                    status = TDI_NO_RESOURCES;
                }
            }
        } else {
            if (ventry != NULL) {
                REMOVEQ(&(ventry->ve_link));
                CTEFreeMem(ventry);
            }
        }
    }

    return (status);
}

//* ModifyInterfaceEntry
//
//  This utility routine modifies the value entries of one or more protocol
//  entries associated with an interface.
//
//
//  Input:  Operation     - The operation to perform (add or delete)
//
//          ProtocolEntry - A pointer to the interface entry structure on
//                              which to operate.
//
//          Protocol      - The protocol on which to operate.
//
//          FilterValue   - The value to add or delete.
//
//
//  Returns: TDI_STATUS code
//
TDI_STATUS
ModifyInterfaceEntry(ulong Operation, PINTERFACE_ENTRY InterfaceEntry,
                     ulong Protocol, ulong FilterValue)
{
    PPROTOCOL_ENTRY pentry;
    TDI_STATUS status;
    TDI_STATUS returnStatus = TDI_SUCCESS;

    if (Protocol == 0) {
        struct Queue *qentry;

        //
        // Modify all protocols on the interface
        //
        for (qentry = InterfaceEntry->ie_protocol_list.q_next;
             qentry != &(InterfaceEntry->ie_protocol_list);
             qentry = qentry->q_next
             ) {
            pentry = STRUCT_OF(PROTOCOL_ENTRY, qentry, pe_link);
            status = ModifyProtocolEntry(Operation, pentry, FilterValue);

            if (status != TDI_SUCCESS) {
                returnStatus = status;
            }
        }
    } else {
        //
        // Modify a specific protocol on the interface
        //
        pentry = FindProtocolEntry(InterfaceEntry, Protocol);

        if (pentry != NULL) {
            returnStatus = ModifyProtocolEntry(Operation, pentry, FilterValue);
        } else {
            returnStatus = TDI_INVALID_PARAMETER;
        }
    }

    return (returnStatus);
}

//* ModifySecurityFilter - Add or delete an entry.
//
//  This routine adds or deletes an entry to/from the security filter database.
//
//
//  Input:  Operation         - The operation to perform (Add or Delete)
//          InterfaceAddress  - The interface address to modify.
//          Protocol          - The protocol to modify.
//          FilterValue       - The transport value to add/delete.
//
//  Returns: A TDI status code:
//               TDI_INVALID_PARAMETER if the protocol is not in the database.
//               TDI_ADDR_INVALID if the interface is not in the database.
//               TDI_NO_RESOURCES if memory could not be allocated.
//               TDI_SUCCESS otherwise
//
//  NOTES:
//
TDI_STATUS
ModifySecurityFilter(ulong Operation, IPAddr InterfaceAddress, ulong Protocol,
                     ulong FilterValue)
{
    PINTERFACE_ENTRY ientry;
    TDI_STATUS status;
    TDI_STATUS returnStatus = TDI_SUCCESS;

    if (InterfaceAddress == 0) {
        struct Queue *qentry;

        //
        // Modify on all interfaces
        //
        for (qentry = InterfaceEntryList.q_next;
             qentry != &InterfaceEntryList;
             qentry = qentry->q_next
             ) {
            ientry = STRUCT_OF(INTERFACE_ENTRY, qentry, ie_link);
            status = ModifyInterfaceEntry(Operation, ientry, Protocol,
                                          FilterValue);

            if (status != TDI_SUCCESS) {
                returnStatus = status;
            }
        }
    } else {
        ientry = FindInterfaceEntry(InterfaceAddress);

        if (ientry != NULL) {
            returnStatus = ModifyInterfaceEntry(Operation, ientry, Protocol,
                                                FilterValue);
        } else {
            returnStatus = TDI_ADDR_INVALID;
        }
    }

    return (returnStatus);
}

//* FillInEnumerationEntry
//
//  This utility routine fills in an enumeration entry for a particular
//  filter value entry.
//
//
//  Input:  InterfaceAddress  - The address of the associated interface.
//
//          Protocol          - The associated protocol number.
//
//          Value             - The enumerated value.
//
//          Buffer            - Pointer to the user's enumeration buffer.
//
//          BufferSize        - Pointer to the size of the enumeration buffer.
//
//          EntriesReturned   - Pointer to a running count of enumerated
//                              entries stored in Buffer.
//
//          EntriesAvailable  - Pointer to a running count of entries available
//                              for enumeration.
//
//  Returns: Nothing.
//
//  Note: Values written to enumeration entry are in host byte order.
//
void
FillInEnumerationEntry(IPAddr InterfaceAddress, ulong Protocol, ulong Value,
                       uchar ** Buffer, ulong * BufferSize,
                       ulong * EntriesReturned, ulong * EntriesAvailable)
{
    TCPSecurityFilterEntry *entry = (TCPSecurityFilterEntry *) * Buffer;

    if (*BufferSize >= sizeof(TCPSecurityFilterEntry)) {
        entry->tsf_address = net_long(InterfaceAddress);
        entry->tsf_protocol = Protocol;
        entry->tsf_value = Value;

        *Buffer += sizeof(TCPSecurityFilterEntry);
        *BufferSize -= sizeof(TCPSecurityFilterEntry);
        (*EntriesReturned)++;
    }
    (*EntriesAvailable)++;

    return;
}

//* EnumerateProtocolValues
//
//  This utility routine enumerates values associated with a
//  protocol on an interface.
//
//
//  Input:  InterfaceEntry    - Pointer to the associated interface entry.
//
//          ProtocolEntry     - Pointer to the protocol being enumerated.
//
//          Value             - The value to enumerate.
//
//          Buffer            - Pointer to the user's enumeration buffer.
//
//          BufferSize        - Pointer to the size of the enumeration buffer.
//
//          EntriesReturned   - Pointer to a running count of enumerated
//                              entries stored in Buffer.
//
//          EntriesAvailable  - Pointer to a running count of entries available
//                              for enumeration.
//
//  Returns: Nothing.
//
void
EnumerateProtocolValues(PINTERFACE_ENTRY InterfaceEntry,
                        PPROTOCOL_ENTRY ProtocolEntry, ulong Value,
                        uchar ** Buffer, ulong * BufferSize,
                        ulong * EntriesReturned, ulong * EntriesAvailable)
{
    struct Queue *qentry;
    PVALUE_ENTRY ventry;
    ulong i;

    if (Value == 0) {
        //
        // Enumerate all values
        //
        if (ProtocolEntry->pe_accept_all == TRUE) {
            //
            // All values permitted.
            //
            FillInEnumerationEntry(
                                   InterfaceEntry->ie_address,
                                   ProtocolEntry->pe_protocol,
                                   0,
                                   Buffer,
                                   BufferSize,
                                   EntriesReturned,
                                   EntriesAvailable
                                   );
        } else {
            for (i = 0; i < VALUE_ENTRY_HASH_SIZE; i++) {
                for (qentry = ProtocolEntry->pe_entries[i].q_next;
                     qentry != &(ProtocolEntry->pe_entries[i]);
                     qentry = qentry->q_next
                     ) {
                    ventry = STRUCT_OF(VALUE_ENTRY, qentry, ve_link);

                    FillInEnumerationEntry(
                                           InterfaceEntry->ie_address,
                                           ProtocolEntry->pe_protocol,
                                           ventry->ve_value,
                                           Buffer,
                                           BufferSize,
                                           EntriesReturned,
                                           EntriesAvailable
                                           );
                }
            }
        }
    } else {
        //
        // Enumerate a specific value, if it is registered.
        //
        ventry = FindValueEntry(ProtocolEntry, Value);

        if (ventry != NULL) {
            FillInEnumerationEntry(
                                   InterfaceEntry->ie_address,
                                   ProtocolEntry->pe_protocol,
                                   ventry->ve_value,
                                   Buffer,
                                   BufferSize,
                                   EntriesReturned,
                                   EntriesAvailable
                                   );
        }
    }

    return;
}

//* EnumerateInterfaceProtocols
//
//  This utility routine enumerates protocols associated with
//  an interface.
//
//
//  Input:  InterfaceEntry    - Pointer to the associated interface entry.
//
//          Protocol          - Protocol number to enumerate.
//
//          Value             - The filter value to enumerate.
//
//          Buffer            - Pointer to the user's enumeration buffer.
//
//          BufferSize        - Pointer to the size of the enumeration buffer.
//
//          EntriesReturned   - Pointer to a running count of enumerated
//                              entries stored in Buffer.
//
//          EntriesAvailable  - Pointer to a running count of entries available
//                              for enumeration.
//
//  Returns: Nothing.
//
void
EnumerateInterfaceProtocols(PINTERFACE_ENTRY InterfaceEntry, ulong Protocol,
                            ulong Value, uchar ** Buffer, ulong * BufferSize,
                            ulong * EntriesReturned, ulong * EntriesAvailable)
{
    PPROTOCOL_ENTRY pentry;

    if (Protocol == 0) {
        struct Queue *qentry;

        //
        // Enumerate all protocols.
        //
        for (qentry = InterfaceEntry->ie_protocol_list.q_next;
             qentry != &(InterfaceEntry->ie_protocol_list);
             qentry = qentry->q_next
             ) {
            pentry = STRUCT_OF(PROTOCOL_ENTRY, qentry, pe_link);

            EnumerateProtocolValues(
                                    InterfaceEntry,
                                    pentry,
                                    Value,
                                    Buffer,
                                    BufferSize,
                                    EntriesReturned,
                                    EntriesAvailable
                                    );
        }
    } else {
        //
        // Enumerate a specific protocol
        //

        pentry = FindProtocolEntry(InterfaceEntry, Protocol);

        if (pentry != NULL) {
            EnumerateProtocolValues(
                                    InterfaceEntry,
                                    pentry,
                                    Value,
                                    Buffer,
                                    BufferSize,
                                    EntriesReturned,
                                    EntriesAvailable
                                    );
        }
    }

    return;
}

//
// Filter Database Public API.
//

//* InitializeSecurityFilters - Initializes the security filter database.
//
//  The routine performs the initialization necessary to enable the
//  security filter database for operation.
//
//  Input:  None.
//
//  Returns: Nothing.
//
//
void
InitializeSecurityFilters(void)
{
    INITQ(&InterfaceEntryList);

    return;
}

//* CleanupSecurityFilters - Deletes the entire security filter database.
//
//  This routine deletes all entries from the security filter database.
//
//
//  Input:  None.
//
//  Returns: Nothing.
//
//  NOTE: This routine acquires the AddrObjTableLock.
//
//
void
CleanupSecurityFilters(void)
{
    PPROTOCOL_ENTRY pentry;
    PINTERFACE_ENTRY ientry;
    CTELockHandle handle;

    CTEGetLock(&AddrObjTableLock.Lock, &handle);

    while (!EMPTYQ(&InterfaceEntryList)) {
        DEQUEUE(&InterfaceEntryList, ientry, INTERFACE_ENTRY, ie_link);

        while (!EMPTYQ(&(ientry->ie_protocol_list))) {
            DEQUEUE(&(ientry->ie_protocol_list), pentry, PROTOCOL_ENTRY,
                    pe_link);

            DeleteProtocolValueEntries(pentry);

            CTEFreeMem(pentry);
        }

        CTEFreeMem(ientry);
    }

    SecurityFilteringEnabled = FALSE;

    CTEFreeLock(&AddrObjTableLock.Lock, handle);

    return;
}

//* IsSecurityFilteringEnabled
//
//  This routine returns the current global status of security filtering.
//
//  Entry:  Nothing
//
//  Returns: 0 if filtering is disabled, !0 if filtering is enabled.
//
extern uint
IsSecurityFilteringEnabled(void)
{
    uint enabled;
    CTELockHandle handle;

    CTEGetLock(&AddrObjTableLock.Lock, &handle);

    enabled = SecurityFilteringEnabled;

    CTEFreeLock(&AddrObjTableLock.Lock, handle);

    return (enabled);
}

//* ControlSecurityFiltering
//
//  This routine globally enables/disables security filtering.
//
//  Entry:  IsEnabled  - 0 disabled filtering, !0 enables filtering.
//
//  Returns: Nothing
//
extern void
ControlSecurityFiltering(uint IsEnabled)
{
    CTELockHandle handle;

    CTEGetLock(&AddrObjTableLock.Lock, &handle);

    if (IsEnabled) {
        SecurityFilteringEnabled = TRUE;
    } else {
        SecurityFilteringEnabled = FALSE;
    }

    CTEFreeLock(&AddrObjTableLock.Lock, handle);

    return;
}

//* AddProtocolSecurityFilter
//
//  This routine enables security filtering for a specified protocol
//  on a specified IP interface.
//
//  Entry:  InterfaceAddress - The interface on which to enable the protocol.
//                                 (in network byte order)
//          Protocol         - The protocol to enable.
//          ConfigName       - The configuration key from which to read
//                                 the filter value information.
//
//  Returns: Nothing
//
void
AddProtocolSecurityFilter(IPAddr InterfaceAddress, ulong Protocol,
                          NDIS_HANDLE ConfigHandle)
{
    NDIS_STRING filterList;
    ulong filterValue;
    ulong i;
    PINTERFACE_ENTRY ientry;
    PPROTOCOL_ENTRY pentry;
    PVOID temp;
    CTELockHandle handle;
    TDI_STATUS status = 0;

    if (IP_ADDR_EQUAL(InterfaceAddress, NULL_IP_ADDR) ||
        IP_LOOPBACK_ADDR(InterfaceAddress)
        ) {
        return;
    }
    ASSERT((Protocol != 0) && (Protocol <= 0xFF));

    //
    // Read the protocol-specific filter value list from the registry.
    //
    filterList.MaximumLength = filterList.Length = 0;
    filterList.Buffer = NULL;

    if (ConfigHandle != NULL) {
        status = GetSecurityFilterList(ConfigHandle, Protocol, &filterList);
    }
    //
    // Preallocate interface & protocol structures. We abort on failure.
    // The interface & protocol will be protected by default.
    //
    ientry = CTEAllocMem(sizeof(INTERFACE_ENTRY));

    if (ientry == NULL) {
        goto cleanup;
    }
    ientry->ie_address = InterfaceAddress;
    INITQ(&(ientry->ie_protocol_list));

    pentry = CTEAllocMem(sizeof(PROTOCOL_ENTRY));

    if (pentry == NULL) {
        CTEFreeMem(ientry);
        goto cleanup;
    }
    pentry->pe_protocol = Protocol;
    pentry->pe_accept_all = FALSE;

    for (i = 0; i < VALUE_ENTRY_HASH_SIZE; i++) {
        INITQ(&(pentry->pe_entries[i]));
    }

    //
    // Now go set everything up. First create the interface and protocol
    // structures.
    //
    CTEGetLock(&AddrObjTableLock.Lock, &handle);

    temp = FindInterfaceEntry(InterfaceAddress);

    if (temp == NULL) {
        //
        // New interface & protocol.
        //
        ENQUEUE(&InterfaceEntryList, &(ientry->ie_link));
        ENQUEUE(&(ientry->ie_protocol_list), &(pentry->pe_link));
    } else {
        //
        // Existing interface
        //
        CTEFreeMem(ientry);
        ientry = temp;

        temp = FindProtocolEntry(ientry, Protocol);

        if (temp == NULL) {
            //
            // New protocol
            //
            ENQUEUE(&(ientry->ie_protocol_list), &(pentry->pe_link));
        } else {
            //
            // Existing protocol
            //
            CTEFreeMem(pentry);
        }
    }

    CTEFreeLock(&AddrObjTableLock.Lock, handle);

    //
    // At this point, the protocol entry is installed, but no values
    // are permitted. This is the safest default.
    //

    if (ConfigHandle != NULL) {
        //
        // Process the filter value list.
        //
        if (status == TDI_SUCCESS) {
            for (i = 0;
                 EnumSecurityFilterValue(&filterList, i, &filterValue);
                 i++
                 ) {
                AddValueSecurityFilter(InterfaceAddress, Protocol,
                                       filterValue);
            }
        } else if (status == TDI_ITEM_NOT_FOUND) {
            //
            // No filter registered, permit everything.
            //
            AddValueSecurityFilter(InterfaceAddress, Protocol, 0);
        }
    }
cleanup:
    if (filterList.Buffer != NULL) {
        CTEFreeMem(filterList.Buffer);
    }
    return;
}

//* DeleteProtocolSecurityFilter
//
//  This routine disables security filtering for a specified protocol
//  on a specified IP interface.
//
//  Entry:  InterfaceAddress - The interface on which to disable the protocol.
//                                 (in network byte order)
//          Protocol         - The protocol to disable.
//
//  Returns: Nothing
//
void
DeleteProtocolSecurityFilter(IPAddr InterfaceAddress, ulong Protocol)
{
    PINTERFACE_ENTRY ientry;
    PPROTOCOL_ENTRY pentry;
    CTELockHandle handle;
    BOOLEAN deleteInterface = FALSE;

    CTEGetLock(&AddrObjTableLock.Lock, &handle);

    ientry = FindInterfaceEntry(InterfaceAddress);

    if (ientry != NULL) {

        ASSERT(!EMPTYQ(&(ientry->ie_protocol_list)));

        pentry = FindProtocolEntry(ientry, Protocol);

        if (pentry != NULL) {
            REMOVEQ(&(pentry->pe_link));
        }
        if (EMPTYQ(&(ientry->ie_protocol_list))) {
            //
            // Last protocol, delete interface as well.
            //
            REMOVEQ(&(ientry->ie_link));
            deleteInterface = TRUE;
        }
        CTEFreeLock(&AddrObjTableLock.Lock, handle);

        if (pentry != NULL) {
            DeleteProtocolValueEntries(pentry);
            CTEFreeMem(pentry);
        }
        if (deleteInterface) {
            ASSERT(EMPTYQ(&(ientry->ie_protocol_list)));
            CTEFreeMem(ientry);
        }
    } else {
        CTEFreeLock(&AddrObjTableLock.Lock, handle);
    }

    return;
}

//* AddValueSecurityFilter - Add an entry.
//
//  This routine adds a value entry for a specified protocol on a specified
//  interface in the security filter database.
//
//
//  Input:  InterfaceAddress  - The interface address to which to add.
//                                  (in network byte order)
//          Protocol          - The protocol to which to add.
//          FilterValue       - The transport value to add.
//                                  (in host byte order)
//
//  Returns: A TDI status code:
//               TDI_INVALID_PARAMETER if the protocol is not in the database.
//               TDI_ADDR_INVALID if the interface is not in the database.
//               TDI_NO_RESOURCES if memory could not be allocated.
//               TDI_SUCCESS otherwise
//
//  NOTES:
//
//      This routine acquires AddrObjTableLock.
//
//      Zero is a wildcard value. Supplying a zero value for the
//      InterfaceAddress and/or Protocol causes the operation to be applied
//      to all interfaces and/or protocols, as appropriate. Supplying a
//      non-zero value causes the operation to be applied to only the
//      specified interface and/or protocol. Supplying a FilterValue parameter
//      of zero causes all values to be acceptable. Any previously
//      registered values are deleted from the database.
//
TDI_STATUS
AddValueSecurityFilter(IPAddr InterfaceAddress, ulong Protocol, ulong FilterValue)
{
    CTELockHandle handle;
    TDI_STATUS status;

    CTEGetLock(&AddrObjTableLock.Lock, &handle);

    status = ModifySecurityFilter(ADD_VALUE_SECURITY_FILTER, InterfaceAddress,
                                  Protocol, FilterValue);

    CTEFreeLock(&AddrObjTableLock.Lock, handle);

    return (status);
}

//* DeleteValueSecurityFilter - Delete an entry.
//
//  This routine deletes a value entry for a specified protocol on a specified
//  interface in the security filter database.
//
//
//  Input:  InterfaceAddress  - The interface address from which to delete.
//                                  (in network byte order)
//          Protocol          - The protocol from which to delete.
//          FilterValue       - The transport value to delete.
//                                  (in host byte order)
//
//  Returns: A TDI status code:
//               TDI_INVALID_PARAMETER if the protocol is not in the database.
//               TDI_ADDR_INVALID if the interface is not in the database.
//               TDI_NO_RESOURCES if memory could not be allocated.
//               TDI_SUCCESS otherwise
//
//  NOTES:
//
//      This routine acquires AddrObjTableLock.
//
//      Zero is a wildcard value. Supplying a zero value for the
//      InterfaceAddress and/or Protocol causes the operation to be applied
//      to all interfaces and/or protocols, as appropriate. Supplying a
//      non-zero value causes the operation to be applied to only the
//      specified interface and/or protocol. Supplying a FilterValue parameter
//      of zero causes all values to be rejected. Any previously
//      registered values are deleted from the database.
//
TDI_STATUS
DeleteValueSecurityFilter(IPAddr InterfaceAddress, ulong Protocol,
                          ulong FilterValue)
{
    CTELockHandle handle;
    TDI_STATUS status;

    CTEGetLock(&AddrObjTableLock.Lock, &handle);

    status = ModifySecurityFilter(DELETE_VALUE_SECURITY_FILTER,
                                  InterfaceAddress, Protocol, FilterValue);

    CTEFreeLock(&AddrObjTableLock.Lock, handle);

    return (status);
}

//* EnumerateSecurityFilters - Enumerate security filter database.
//
//  This routine enumerates the contents of the security filter database
//  for the specified protocol and IP interface.
//
//  Input:  InterfaceAddress  - The interface address to enumerate. A value
//                              of zero means enumerate all interfaces.
//                                  (in network byte order)
//
//          Protocol          - The protocol to enumerate. A value of zero
//                              means enumerate all protocols.
//
//          Value             - The Protocol value to enumerate. A value of
//                              zero means enumerate all protocol values.
//                                  (in host byte order)
//
//          Buffer            - A pointer to a buffer into which to put
//                              the returned filter entries.
//
//          BufferSize        - On input, the size in bytes of Buffer.
//                              On output, the number of bytes written.
//
//          EntriesAvailable  - On output, the total number of filter entries
//                              available in the database.
//
//  Returns: A TDI status code:
//
//           TDI_ADDR_INVALID if the address is not a valid IP interface.
//           TDI_SUCCESS otherwise.
//
//  NOTES:
//
//      This routine acquires AddrObjTableLock.
//
//      Entries written to output buffer are in host byte order.
//
void
EnumerateSecurityFilters(IPAddr InterfaceAddress, ulong Protocol,
                         ulong Value, uchar * Buffer, ulong BufferSize,
                         ulong * EntriesReturned, ulong * EntriesAvailable)
{
    PINTERFACE_ENTRY ientry;
    CTELockHandle handle;

    *EntriesAvailable = *EntriesReturned = 0;

    CTEGetLock(&AddrObjTableLock.Lock, &handle);

    if (InterfaceAddress == 0) {
        struct Queue *qentry;

        //
        // Enumerate all interfaces.
        //
        for (qentry = InterfaceEntryList.q_next;
             qentry != &InterfaceEntryList;
             qentry = qentry->q_next
             ) {
            ientry = STRUCT_OF(INTERFACE_ENTRY, qentry, ie_link);

            EnumerateInterfaceProtocols(
                                        ientry,
                                        Protocol,
                                        Value,
                                        &Buffer,
                                        &BufferSize,
                                        EntriesReturned,
                                        EntriesAvailable
                                        );
        }
    } else {
        //
        // Enumerate a specific interface.
        //

        ientry = FindInterfaceEntry(InterfaceAddress);

        if (ientry != NULL) {
            EnumerateInterfaceProtocols(
                                        ientry,
                                        Protocol,
                                        Value,
                                        &Buffer,
                                        &BufferSize,
                                        EntriesReturned,
                                        EntriesAvailable
                                        );
        }
    }

    CTEFreeLock(&AddrObjTableLock.Lock, handle);

    return;
}

//* IsPermittedSecurityFilter
//
//  This routine determines if communications addressed to
//  {Protocol, InterfaceAddress, Value} are permitted by the security filters.
//  It looks up the tuple in the security filter database.
//
//  Input:  InterfaceAddress  - The IP interface address to check
//                                  (in network byte order)
//          IPContext         - The IPContext value passed to the transport
//          Protocol          - The protocol to check
//          Value             - The value to check (in host byte order)
//
//  Returns: A boolean indicating whether or not the communication is permitted.
//
//  NOTES:
//
//      This routine must be called with AddrObjTableLock held.
//
//
BOOLEAN
IsPermittedSecurityFilter(IPAddr InterfaceAddress, void *IPContext,
                          ulong Protocol, ulong FilterValue)
{
    PINTERFACE_ENTRY ientry;
    PPROTOCOL_ENTRY pentry;
    PVALUE_ENTRY ventry;
    ulong hash_value;
    struct Queue *qentry;

    ASSERT(Protocol <= 0xFF);

    for (qentry = InterfaceEntryList.q_next;
         qentry != &InterfaceEntryList;
         qentry = qentry->q_next
         ) {
        ientry = STRUCT_OF(INTERFACE_ENTRY, qentry, ie_link);

        if (ientry->ie_address == InterfaceAddress) {

            for (qentry = ientry->ie_protocol_list.q_next;
                 qentry != &(ientry->ie_protocol_list);
                 qentry = qentry->q_next
                 ) {
                pentry = STRUCT_OF(PROTOCOL_ENTRY, qentry, pe_link);

                if (pentry->pe_protocol == Protocol) {

                    if (pentry->pe_accept_all == TRUE) {
                        //
                        // All values accepted. Permit operation.
                        //
                        return (TRUE);
                    }
                    hash_value = VALUE_ENTRY_HASH(FilterValue);

                    for (qentry = pentry->pe_entries[hash_value].q_next;
                         qentry != &(pentry->pe_entries[hash_value]);
                         qentry = qentry->q_next
                         ) {
                        ventry = STRUCT_OF(VALUE_ENTRY, qentry, ve_link);

                        if (ventry->ve_value == FilterValue) {
                            //
                            // Found it. Operation is permitted.
                            //
                            return (TRUE);
                        }
                    }

                    //
                    // {Interface, Protocol} protected, but no value found.
                    // Reject operation.
                    //
                    return (FALSE);
                }
            }

            //
            // Protocol not registered. Reject operation
            //
            return (FALSE);
        }
    }

    //
    // If this packet is on the loopback interface, let it through.
    //
    if (IP_LOOPBACK_ADDR(InterfaceAddress)) {
        return (TRUE);
    }
    //
    // Special check to allow the DHCP client to receive its packets.
    // It is safe to make this check all the time because IP will
    // not permit a packet to get through on an NTE with a zero address
    // unless DHCP is in the process of configuring that NTE.
    //
    if ((Protocol == PROTOCOL_UDP) &&
        (FilterValue == DHCP_CLIENT_PORT) &&
        (*LocalNetInfo.ipi_isdhcpinterface) (IPContext)
        ) {
        return (TRUE);
    }
    //
    // Interface not registered. Deny operation.
    //
    return (FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\tcpcfg.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//*	TCPCFG.H - Definitions of configuration information for TCP.
//

/*NOINC*/
extern uint DeadGWDetect;
extern uint PMTUDiscovery;
extern uint PMTUBHDetect;
extern uint KeepAliveTime;
extern uint KAInterval;
extern uint DefaultRcvWin;
extern uint MaxConnections;
extern uint MaxConnectRexmitCount;
extern uint MaxConnectResponseRexmitCount;
extern uint MaxDataRexmitCount;

extern uint SynAttackProtect;
extern uint TCPHalfOpen;
extern uint TCPHalfOpenRetried;
extern uint TCPMaxHalfOpen;
extern uint TCPMaxHalfOpenRetried;
extern uint TCPMaxHalfOpenRetriedLW;
extern uint MaxConnectResponseRexmitCountTmp;
extern CACHE_LINE_KSPIN_LOCK SynAttLock;

extern uint	BSDUrgent;
extern uint	PreloadCount;
extern uint FinWait2TO;
extern uint NTWMaxConnectCount;
extern uint NTWMaxConnectTime;
extern uint MaxUserPort;

extern uint SecurityFilteringEnabled;
/*INC*/

#define	DEFAULT_DEAD_GW_DETECT		TRUE
#define	DEFAULT_PMTU_DISCOVERY		TRUE
#define	DEFAULT_PMTU_BHDETECT		FALSE
#define	DEFAULT_KA_TIME				7200000
#define	DEFAULT_KA_INTERVAL			1000
#define DEFAULT_RCV_WIN				8192*2
#define DEFAULT_PRELOAD_COUNT		0
#define MAX_PRELOAD_COUNT			32
#define PRELOAD_BLOCK_SIZE			16384
#define DEFAULT_MAX_USER_PORT       5000    // Maximum value for a user port.
#define	FIN_WAIT2_TO	            120

/*NOINC*/
#ifndef	VXD
#define DEFAULT_MAX_CONNECTIONS		(INVALID_CONN_INDEX - 1)
#define NTW_MAX_CONNECT_TIME        600
#define NTW_MAX_CONNECT_COUNT       15
#else

/*INC*/
#define	DEFAULT_MAX_CONNECTIONS		100

/*NOINC*/
#endif
/*INC*/

#define	DEFAULT_CONNECT_REXMIT_CNT	3
#define	DEFAULT_DATA_REXMIT_CNT		5
#define	DEFAULT_BSD_URGENT			TRUE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\tcpdeb.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TCPDEB.C - TCP debug code.
//
//  This file contains the code for various TCP specific debug routines.
//

#include "precomp.h"
#include "tcp.h"
#include "tcpsend.h"
#include "tlcommon.h"

#if DBG


ULONG TCPDebug = TCP_DEBUG_CANCEL;


//* CheckRBList - Check a list of RBs for the correct size.
//
//  A routine to walk a list of RBs, making sure the size is what we think
//  it it.
//
//  Input:  RBList      - List of RBs to check.
//          Size        - Size RBs should be.
//
//  Returns: Nothing.
//
void
CheckRBList(IPRcvBuf * RBList, uint Size)
{
    uint SoFar = 0;
    IPRcvBuf *List = RBList;

    while (List != NULL) {
        SoFar += List->ipr_size;
        List = List->ipr_next;
    }

    ASSERT(Size == SoFar);

}

//* CheckTCBRcv - Check receives on a TCB.
//
//  Check the receive state of a TCB.
//
//  Input:  CheckTCB    - TCB to check.
//
//  Returns: Nothing.
//
void
CheckTCBRcv(TCB * CheckTCB)
{
    CTEStructAssert(CheckTCB, tcb);

    ASSERT(!(CheckTCB->tcb_flags & FLOW_CNTLD) ||
              (CheckTCB->tcb_sendwin == 0));

    if ((CheckTCB->tcb_fastchk & ~TCP_FLAG_IN_RCV) == TCP_FLAG_ACK) {
        ASSERT(CheckTCB->tcb_slowcount == 0);
        ASSERT(CheckTCB->tcb_state == TCB_ESTAB);
        ASSERT(CheckTCB->tcb_raq == NULL);
        //ASSERT(!(CheckTCB->tcb_flags & TCP_SLOW_FLAGS));
        ASSERT(!CLOSING(CheckTCB));
    } else {
        ASSERT(CheckTCB->tcb_slowcount != 0);
        ASSERT((CheckTCB->tcb_state != TCB_ESTAB) ||
               (CheckTCB->tcb_raq != NULL) ||
               (CheckTCB->tcb_flags & TCP_SLOW_FLAGS) ||
               (CheckTCB->tcb_fastchk & TCP_FLAG_RST_WHILE_SYN) ||
               CLOSING(CheckTCB));
    }

}

//* CheckTCBSends - Check the send status of a TCB.
//
//  A routine to check the send status of a TCB. We make sure that all
//  of the SendReqs make sense, as well as making sure that the send seq.
//  variables in the TCB are consistent.
//
//  Input:  CheckTCB    - TCB to check.
//
//  Returns: Nothing.
//
void
CheckTCBSends(TCB *CheckTCB)
{
    Queue *End, *Current;           // End and current elements.
    TCPSendReq *CurrentTSR;         // Current send req we're examining.
    uint Unacked;                   // Number of unacked bytes.
    PNDIS_BUFFER CurrentBuffer;
    uint FoundSendReq;

    CTEStructAssert(CheckTCB, tcb);

    // Don't check on unsynchronized TCBs.
    if (!SYNC_STATE(CheckTCB->tcb_state)) {
        return;
    }

    ASSERT(SEQ_LTE(CheckTCB->tcb_senduna, CheckTCB->tcb_sendnext));
    ASSERT(SEQ_LTE(CheckTCB->tcb_sendnext, CheckTCB->tcb_sendmax));
    ASSERT(!(CheckTCB->tcb_flags & FIN_OUTSTANDING) ||
              (CheckTCB->tcb_sendnext == CheckTCB->tcb_sendmax));

    if ((CheckTCB->tcb_fastchk & TCP_FLAG_REQUEUE_FROM_SEND_AND_DISC)) {
         ASSERT(CheckTCB->tcb_unacked == 0);
         return;
    }

    if (CheckTCB->tcb_unacked == 0){
        ASSERT(CheckTCB->tcb_cursend == NULL);
        ASSERT(CheckTCB->tcb_sendsize == 0);
    }

    if (CheckTCB->tcb_sendbuf != NULL) {
        ASSERT(CheckTCB->tcb_sendofs < NdisBufferLength(CheckTCB->tcb_sendbuf));
    }

    FoundSendReq = (CheckTCB->tcb_cursend == NULL) ? TRUE : FALSE;

    End = QEND(&CheckTCB->tcb_sendq);
    Current = QHEAD(&CheckTCB->tcb_sendq);

    Unacked = 0;
    while (Current != End) {
        CurrentTSR = STRUCT_OF(TCPSendReq, QSTRUCT(TCPReq, Current, tr_q), tsr_req);
        CTEStructAssert(CurrentTSR, tsr);

        if (CurrentTSR == CheckTCB->tcb_cursend)
            FoundSendReq = TRUE;

        ASSERT(CurrentTSR->tsr_unasize <= CurrentTSR->tsr_size);

        CurrentBuffer = CurrentTSR->tsr_buffer;
        ASSERT(CurrentBuffer != NULL);

        ASSERT(CurrentTSR->tsr_offset < NdisBufferLength(CurrentBuffer));

        // All send requests after the current should have zero offsets.
        //
        if (CheckTCB->tcb_cursend &&
            FoundSendReq && (CurrentTSR != CheckTCB->tcb_cursend)) {
            ASSERT(0 == CurrentTSR->tsr_offset);
        }

        Unacked += CurrentTSR->tsr_unasize;
        Current = QNEXT(Current);
    }

    ASSERT(FoundSendReq);

    if (!CheckTCB->tcb_unacked &&
        ((CheckTCB->tcb_senduna == CheckTCB->tcb_sendmax) ||
         (CheckTCB->tcb_senduna == CheckTCB->tcb_sendmax - 1)) &&
        ((CheckTCB->tcb_sendnext == CheckTCB->tcb_sendmax) ||
         (CheckTCB->tcb_sendnext == CheckTCB->tcb_sendmax - 1)) &&
        (CheckTCB->tcb_fastchk & TCP_FLAG_SEND_AND_DISC)) {

        if (!EMPTYQ(&CheckTCB->tcb_sendq)) {
            Current = QHEAD(&CheckTCB->tcb_sendq);
            CurrentTSR = STRUCT_OF(TCPSendReq, QSTRUCT(TCPReq, Current, tr_q),
                                   tsr_req);
            ASSERT(CurrentTSR->tsr_flags & TSR_FLAG_SEND_AND_DISC);
        }
    }

    if (!(CheckTCB->tcb_flags & FIN_SENT) &&
        !(CheckTCB->tcb_state == TCB_FIN_WAIT2) &&
        !(CheckTCB->tcb_fastchk & TCP_FLAG_REQUEUE_FROM_SEND_AND_DISC)) {
        ASSERT(Unacked == CheckTCB->tcb_unacked);
        ASSERT((CheckTCB->tcb_sendmax - CheckTCB->tcb_senduna) <= (int)Unacked);
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\tcpdeliv.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TCPDELIV.H - TCP data delivery definitions.
//
// This file contains the definitions for structures used by the data
//  delivery code.
//

extern  void    FreeRcvReq(struct TCPRcvReq *FreedReq);

extern uint IndicateData(struct TCB *RcvTCB, uint RcvFlags, IPRcvBuf *InBuffer,
    uint Size);
extern uint BufferData(struct TCB *RcvTCB, uint RcvFlags, IPRcvBuf *InBuffer,
    uint Size);
extern uint PendData(struct TCB *RcvTCB, uint RcvFlags, IPRcvBuf *InBuffer,
    uint Size);


extern void IndicatePendingData(struct TCB *RcvTCB, struct TCPRcvReq *RcvReq,
	CTELockHandle TCBHandle);

extern  void HandleUrgent(struct TCB *RcvTCB, struct TCPRcvInfo *RcvInfo,
    IPRcvBuf *RcvBuf, uint *Size);

extern  TDI_STATUS TdiReceive(PTDI_REQUEST Request, ushort *Flags,
    uint *RcvLength, PNDIS_BUFFER Buffer);
extern  IPRcvBuf *FreePartialRB(IPRcvBuf *RB, uint Size);
extern  void FreeRBChain(IPRcvBuf * RBChain);
extern  void    PushData(struct TCB *PushTCB, BOOLEAN PushAll);

extern HANDLE TcprBufferPool;

#if !MILLEN
#define TCP_FIXED_SIZE_IPR_SIZE       1460
#define TCP_UNUSED_PEND_BUF_LIMIT     2920
extern HANDLE TcprBufferPool;
#ifdef DBG
extern ULONG SlistAllocates, NPPAllocates;
#endif

// This data structure embeds the generic IPRcvBuf structure as well as holds
// a pointer to the TCB for which this buffer has been allocated for.
//
typedef struct _TCPRcvBuf{
    IPRcvBuf tcpr_ipr;
    PVOID tcpr_tcb;
} TCPRcvBuf, *PTCPRcvBuf;

// This macro calculates the unused bytes in a TcpRcvBuf structure.
//
#define IPR_BUF_UNUSED_BYTES(_Tcpr) \
     (TCP_FIXED_SIZE_IPR_SIZE - (_Tcpr)->tcpr_ipr.ipr_size - \
        ((PCHAR)((_Tcpr)->tcpr_ipr.ipr_buffer) - (PCHAR)(_Tcpr) - sizeof(TCPRcvBuf)))



//* InitTcpIpr - Initializes the IPRcvBuffer.
//
//  Input:  Tcpr - Pointer to the TCPRcvBuf.
//            BufferSize - Number of bytes that are used.
//            PendTCB - Pointer to the TCB for which this allocation is being made.
//
//  Returns: None.
//
__inline void
InitTcpIpr(TCPRcvBuf *Tcpr, ULONG BufferSize, TCB* PendTCB)
{
    Tcpr->tcpr_ipr.ipr_owner  = IPR_OWNER_TCP;
    Tcpr->tcpr_ipr.ipr_next   = NULL;
    Tcpr->tcpr_ipr.ipr_buffer = (PUCHAR) Tcpr + sizeof(TCPRcvBuf);
    Tcpr->tcpr_ipr.ipr_size   = BufferSize;
    Tcpr->tcpr_tcb = PendTCB;
}


//* AllocTcpIpr - Allocates the IPRcvBuffer from NPP.
//
//  A utility routine to allocate a TCP owned IPRcvBuffer. This routine
//  allocates the IPR from NPP and initializes appropriate fields.
//
//  Input:  BufferSize - Size of data to buffer.
//            Tag - Tag to be used if allocation is done from NPP.
//
//  Returns: Pointer to allocated IPR.
//
__inline IPRcvBuf *
AllocTcpIpr(ULONG BufferSize, ULONG Tag)
{
    TCPRcvBuf *Tcpr;
    ULONG AllocateSize;

    // Real size that we need.
    AllocateSize = BufferSize + sizeof(TCPRcvBuf);

    Tcpr = CTEAllocMemLow(AllocateSize, Tag);

    if (Tcpr != NULL) {
#ifdef DBG        
        InterlockedIncrement((PLONG)&NPPAllocates);
#endif
        InitTcpIpr(Tcpr, BufferSize, NULL);
    }

    return &Tcpr->tcpr_ipr;
}


//* AllocTcpIprFromSlist - Allocates the IPRcvBuffer from NPP.
//
//  A utility routine to allocate a TCP owned IPRcvBuffer. This routine
//  allocates the IPR from an SLIST and initializes appropriate fields.
//
//  Input:  Tcb - Pointer to the TCB for which this allocation is being made.
//             BufferSize - Size of data buffer required.
//            Tag - Tag to be used if allocation is done from NPP.
//
//  Returns: Pointer to allocated IPR.
//
__inline IPRcvBuf *
AllocTcpIprFromSlist(TCB* PendTCB, ULONG BufferSize, ULONG Tag)
{
    TCPRcvBuf* Tcpr;
    LOGICAL FromList;

    if ((BufferSize <= TCP_FIXED_SIZE_IPR_SIZE) &&
        (PendTCB->tcb_unusedpendbuf + TCP_FIXED_SIZE_IPR_SIZE 
            - BufferSize <= TCP_UNUSED_PEND_BUF_LIMIT)) {

        Tcpr = PplAllocate(TcprBufferPool, &FromList);

        if (NULL != Tcpr) {
#ifdef DBG            
            InterlockedIncrement((PLONG)&SlistAllocates);

#endif
            // Set up IPR fields appropriately.
            InitTcpIpr(Tcpr, BufferSize, PendTCB);

            ASSERT(PendTCB->tcb_unusedpendbuf >= 0);
            PendTCB->tcb_unusedpendbuf += (short)IPR_BUF_UNUSED_BYTES(Tcpr);
            ASSERT(PendTCB->tcb_unusedpendbuf <= TCP_UNUSED_PEND_BUF_LIMIT);

            return &Tcpr->tcpr_ipr;
        }
    }

    return AllocTcpIpr(BufferSize, Tag);

}


//* FreeTcpIpr - Frees the IPRcvBuffer..
//
//  A utility routine to free a TCP owned IPRcvBuffer.
//
//  Input:  Ipr - Pointer the IPR.
//
//  Returns: None.
//
__inline VOID
FreeTcpIpr(IPRcvBuf *Ipr)
{
    TCB *PendTCB;
    PTCPRcvBuf Tcpr = (PTCPRcvBuf)Ipr;

    if (Tcpr->tcpr_tcb) {
        PendTCB = (TCB*)(Tcpr->tcpr_tcb);

        ASSERT(PendTCB->tcb_unusedpendbuf <= TCP_UNUSED_PEND_BUF_LIMIT); 
        PendTCB->tcb_unusedpendbuf -= (short)IPR_BUF_UNUSED_BYTES(Tcpr);
        ASSERT(PendTCB->tcb_unusedpendbuf >= 0);

        PplFree(TcprBufferPool, Tcpr);
#ifdef DBG
        InterlockedDecrement((PLONG)&SlistAllocates);
#endif
    } else {
        CTEFreeMem(Tcpr);
#ifdef DBG
        InterlockedDecrement((PLONG)&NPPAllocates);
#endif
    }
}
#else // MILLEN
IPRcvBuf *AllocTcpIpr(ULONG BufferSize, ULONG Tag);
VOID FreeTcpIpr(IPRcvBuf *Ipr);
#endif // MILLEN
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\tcprcv.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//** TCPRCV.H - TCP receive protocol definitions.
//
// This file contains the definitions for structures used by the receive code.
//
#pragma once

#define CONN_REQUEST_COMPLETE   0x01
#define SEND_REQUEST_COMPLETE   0x02

#define IN_RCV_COMPLETE         0x10
#define ANY_REQUEST_COMPLETE    (CONN_REQUEST_COMPLETE | SEND_REQUEST_COMPLETE)

#define trh_signature   0x20485254      // 'TRH '

typedef struct TCPRAHdr {
#if DBG
    ulong               trh_sig;        // Signature.
#endif
    struct  TCPRAHdr    *trh_next;      // Next pointer.
    SeqNum              trh_start;      // First sequence number.
    uint                trh_size;       // Size in bytes of data in this TRH.
    uint                trh_flags;      // Flags for this segment.
    uint                trh_urg;        // Urgent pointer from this seg.
    IPRcvBuf            *trh_buffer;    // Head of buffer list for this TRH.
    IPRcvBuf            *trh_end;       // End of buffer list for this TRH.

} TCPRAHdr;

//* Structure of a TCP receive request.

#define trr_signature   0x20525254      // 'TRR '

typedef struct TCPRcvReq {
#if DBG
    ulong               trr_sig;        // Signature.
#endif
    struct TCPRcvReq    *trr_next;      // Next in chain.
    CTEReqCmpltRtn      trr_rtn;        // Completion routine.
    PVOID               trr_context;    // User context.
    uint                trr_amt;        // Number of bytes currently in buffer.
    uint                trr_offset;     // Offset into first buffer on chain
                                        // at which to start copying.
    uint                trr_flags;      // Flags for this recv.
    uint                trr_size;       // Total size of buffer chain.
    ushort              *trr_uflags;    // Pointer to user specifed flags.
    PNDIS_BUFFER        trr_buffer;     // Pointer to useable NDIS buffer chain.
    int                 trr_status;     // Final completion status.
} TCPRcvReq;

#define TRR_PUSHED      0x80000000      // This buffer has been pushed.

extern void FreeRBChain(IPRcvBuf *RBChain);
extern void AdjustRcvWin(struct TCB *WinTCB);

//* Delay Queue and related receive handling definitions and functions.

extern BOOLEAN PartitionedDelayQ;

extern void TCPRcvComplete(void);
extern void DelayAction(struct TCB *DelayTCB, uint Action);
extern void ProcessTCBDelayQ(KIRQL OrigIrql, BOOLEAN ProcessAllQueues);
extern LOGICAL ProcessPerCpuTCBDelayQ(int Proc, KIRQL OrigIrql,
                                      const LARGE_INTEGER* StopTicks,
                                      ulong *ItemsProcessed);
extern void CompleteRcvs(struct TCB *CmpltTCB);


__inline void PartitionDelayQProcessing(BOOLEAN NewState) {
    if (NewState != PartitionedDelayQ) {
        InterlockedExchange(((PLONG)&(PartitionedDelayQ)), NewState);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\tcpsend.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//** TCPSEND.C - TCP send protocol code.
//
//  This file contains the code for sending Data and Control segments.
//

#include "precomp.h"
#include "addr.h"
#include "tcp.h"
#include "tcb.h"
#include "tcpconn.h"
#include "tcpsend.h"
#include "tcprcv.h"
#include "tlcommon.h"
#include "info.h"
#include "tcpcfg.h"
#include "secfltr.h"
#include "tcpipbuf.h"
#include "mdlpool.h"
#include "pplasl.h"

#if GPC
#include "qos.h"
#include "traffic.h"
#include "gpcifc.h"
#include "ntddtc.h"
extern GPC_HANDLE hGpcClient[GPC_CF_MAX];
extern ULONG GpcCfCounts[GPC_CF_MAX];
extern GPC_EXPORTED_CALLS GpcEntries;
extern ULONG GPCcfInfo;
#endif

NTSTATUS
GetIFAndLink(void *Rce, ULONG * IFIndex, IPAddr * NextHop);

extern ulong DisableUserTOSSetting;

uint MaxSendSegments = 64;
#if MILLEN
uint DisableLargeSendOffload = 1;
#else // MILLEN
uint DisableLargeSendOffload = 0;
#endif // !MILLEN

#if DBG
ulong DbgDcProb = 0;
ulong DbgTcpSendHwChksumCount = 0;
#endif

extern HANDLE TcpRequestPool;
extern CTELock *pTWTCBTableLock;
extern CACHE_LINE_KSPIN_LOCK RequestCompleteListLock;
extern uint TcpHostOpts;
extern uint TcpHostSendOpts;
#define ALIGNED_SACK_OPT_SIZE 4+8*4        //Maximum 4 sack blocks of 2longword each+sack opt itself


void
ClassifyPacket(TCB *SendTCB);

void
 TCPFastSend(TCB * SendTCB,
             PNDIS_BUFFER in_SendBuf,
             uint in_SendOfs,
             TCPSendReq * in_SendReq,
             uint in_SendSize,
             SeqNum NextSeq,
             int in_ToBeSent);



void *TCPProtInfo;                // TCP protocol info for IP.


NDIS_HANDLE TCPSendBufferPool;

USHORT TcpHeaderBufferSize;
HANDLE TcpHeaderPool;

extern IPInfo LocalNetInfo;


//
// All of the init code can be discarded.
//

int InitTCPSend(void);



void UnInitTCPSend(void);


#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, InitTCPSend)
#pragma alloc_text(INIT, UnInitTCPSend)
#endif

extern void ResetSendNext(TCB * SeqTCB, SeqNum NewSeq);

extern NTSTATUS
TCPPnPPowerRequest(void *ipContext, IPAddr ipAddr, NDIS_HANDLE handle,
                   PNET_PNP_EVENT netPnPEvent);
extern void TCPElistChangeHandler(void);

//* GetTCPHeader - Get a TCP header buffer.
//
//  Called when we need to get a TCP header buffer. This routine is
//  specific to the particular environment (VxD or NT). All we
//  need to do is pop the buffer from the free list.
//
//  Input:  Nothing.
//
//  Returns: Pointer to an NDIS buffer, or NULL is none.
//
PNDIS_BUFFER
GetTCPHeaderAtDpcLevel(TCPHeader **Header)
{
    PNDIS_BUFFER Buffer;

#if DBG
    *Header = NULL;
#endif

    Buffer = MdpAllocateAtDpcLevel(TcpHeaderPool, Header);

    if (Buffer) {

        ASSERT(*Header);

        NdisAdjustBufferLength(Buffer, sizeof(TCPHeader));

#if BACK_FILL
        ASSERT(Buffer->ByteOffset >= 40);

        *Header = (TCPHeader*)((ULONG_PTR)(*Header) + MAX_BACKFILL_HDR_SIZE);
        Buffer->MappedSystemVa = (PVOID)((ULONG_PTR)Buffer->MappedSystemVa
                                         + MAX_BACKFILL_HDR_SIZE);
        Buffer->ByteOffset += MAX_BACKFILL_HDR_SIZE;

        Buffer->MdlFlags |= MDL_NETWORK_HEADER;
#endif
    }
    return Buffer;
}

#if MILLEN
#define GetTCPHeader GetTCPHeaderAtDpcLevel
#else
__inline
PNDIS_BUFFER
GetTCPHeader(TCPHeader **Header)
{
    KIRQL OldIrql;
    PNDIS_BUFFER Buffer;

    OldIrql = KeRaiseIrqlToDpcLevel();

    Buffer = GetTCPHeaderAtDpcLevel(Header);

    KeLowerIrql(OldIrql);

    return Buffer;
}
#endif

//* FreeTCPHeader - Free a TCP header buffer.
//
//  Called to free a TCP header buffer.
//
//  Input: Buffer to be freed.
//
//  Returns: Nothing.
//
__inline
VOID
FreeTCPHeader(PNDIS_BUFFER Buffer)
{
    NdisAdjustBufferLength(Buffer, TcpHeaderBufferSize);
#if BACK_FILL
    Buffer->MappedSystemVa = (PVOID)((ULONG_PTR)Buffer->MappedSystemVa
                                     - MAX_BACKFILL_HDR_SIZE);
    Buffer->ByteOffset -= MAX_BACKFILL_HDR_SIZE;
#endif
    MdpFree(Buffer);
}

//* FreeSendReq - Free a send request structure.
//
//  Called to free a send request structure.
//
//  Input:  FreedReq    - Connection request structure to be freed.
//
//  Returns: Nothing.
//
__inline
void
FreeSendReq(TCPSendReq *Request)
{
    PplFree(TcpRequestPool, Request);
}

//* GetSendReq - Get a send request structure.
//
//  Called to get a send request structure.
//
//  Input:  Nothing.
//
//  Returns: Pointer to SendReq structure, or NULL if none.
//
__inline
TCPSendReq *
GetSendReq(VOID)
{
    TCPSendReq *Request;
    LOGICAL FromList;

    Request = PplAllocate(TcpRequestPool, &FromList);
    if (Request) {
#if DBG
        Request->tsr_req.tr_sig = tr_signature;
        Request->tsr_sig = tsr_signature;
#endif
    }

    return Request;
}

//* TCPSendComplete - Complete a TCP send.
//
//  Called by IP when a send we've made is complete. We free the buffer,
//  and possibly complete some sends. Each send queued on a TCB has a ref.
//  count with it, which is the number of times a pointer to a buffer
//  associated with the send has been passed to the underlying IP layer. We
//  can't complete a send until that count it 0. If this send was actually
//  from a send of data, we'll go down the chain of send and decrement the
//  refcount on each one. If we have one going to 0 and the send has already
//  been acked we'll complete the send. If it hasn't been acked we'll leave
//  it until the ack comes in.
//
//  NOTE: We aren't protecting any of this with locks. When we port this to
//  NT we'll need to fix this, probably with a global lock. See the comments
//  in ACKSend() in TCPRCV.C for more details.
//
//  Input:  Context     - Context we gave to IP.
//          BufferChain - BufferChain for send.
//
//  Returns: Nothing.
//
void
TCPSendComplete(void *Context, PNDIS_BUFFER BufferChain, IP_STATUS SendStatus)
{
    BOOLEAN DoRcvComplete = FALSE;
    PNDIS_BUFFER CurrentBuffer;

    if (Context != NULL) {
        SendCmpltContext *SCContext = (SendCmpltContext *) Context;
        TCPSendReq *CurrentSend;
        uint i;

        CTEStructAssert(SCContext, scc);
        if (SCContext->scc_LargeSend) {
            TCB *LargeSendTCB = SCContext->scc_LargeSend;
            CTELockHandle TCBHandle;
            CTEGetLock(&LargeSendTCB->tcb_lock, &TCBHandle);

            IF_TCPDBG(TCP_DEBUG_OFFLOAD) {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"TCPSendComplete: tcb %x sent %d of %d una %u "
                         "next %u unacked %u\n", LargeSendTCB,
                         SCContext->scc_ByteSent, SCContext->scc_SendSize,
                         LargeSendTCB->tcb_senduna, LargeSendTCB->tcb_sendnext,
                         LargeSendTCB->tcb_unacked));
            }

            if (SCContext->scc_ByteSent < SCContext->scc_SendSize) {
                uint BytesNotSent = SCContext->scc_SendSize -
                                    SCContext->scc_ByteSent;
                SeqNum Next = LargeSendTCB->tcb_sendnext;

                IF_TCPDBG(TCP_DEBUG_OFFLOAD) {
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"TCPSendComplete: unsent %d\n",
                             SCContext->scc_SendSize-SCContext->scc_ByteSent));
                }

                if (SEQ_GTE((Next - BytesNotSent), LargeSendTCB->tcb_senduna) &&
                    SEQ_LT((Next - BytesNotSent), LargeSendTCB->tcb_sendnext)) {
                    ResetSendNext(LargeSendTCB, (Next - BytesNotSent));
                }
            }
#if DBG
            LargeSendTCB->tcb_LargeSend--;
#endif

            if (LargeSendTCB->tcb_unacked)
                DelayAction(LargeSendTCB, NEED_OUTPUT);

            DerefTCB(LargeSendTCB, TCBHandle);
        }
        // First, loop through and free any NDIS buffers here that need to be.
        // freed. We'll skip any 'user' buffers, and then free our buffers. We
        // need to do this before decrementing the reference count to avoid
        // destroying the buffer chain if we have to zap tsr_lastbuf->Next to
        // NULL.

        CurrentBuffer = NDIS_BUFFER_LINKAGE(BufferChain);
        for (i = 0; i < (uint) SCContext->scc_ubufcount; i++) {
            ASSERT(CurrentBuffer != NULL);
            CurrentBuffer = NDIS_BUFFER_LINKAGE(CurrentBuffer);
        }

        for (i = 0; i < (uint) SCContext->scc_tbufcount; i++) {
            PNDIS_BUFFER TempBuffer;

            ASSERT(CurrentBuffer != NULL);

            TempBuffer = CurrentBuffer;
            CurrentBuffer = NDIS_BUFFER_LINKAGE(CurrentBuffer);
            NdisFreeBuffer(TempBuffer);
        }

        CurrentSend = SCContext->scc_firstsend;

        i = 0;
        while (i < SCContext->scc_count) {
            Queue   *TempQ;
            long    Result;
            uint    SendReqFlags;

            TempQ = QNEXT(&CurrentSend->tsr_req.tr_q);
            SendReqFlags = CurrentSend->tsr_flags;

            CTEStructAssert(CurrentSend, tsr);

            Result = CTEInterlockedDecrementLong(&(CurrentSend->tsr_refcnt));

            ASSERT(Result >= 0);

            if ((Result <= 0) ||
                ((SendReqFlags & TSR_FLAG_SEND_AND_DISC) && (Result == 1))) {
                TCPReq  *Req;

                // Reference count has gone to 0 which means the send has
                // been ACK'd or cancelled. Complete it now.

                // If we've sent directly from this send, NULL out the next
                // pointer for the last buffer in the chain.
                if (CurrentSend->tsr_lastbuf != NULL) {
                    NDIS_BUFFER_LINKAGE(CurrentSend->tsr_lastbuf) = NULL;
                    CurrentSend->tsr_lastbuf = NULL;
                }

                Req = &CurrentSend->tsr_req;
                (*Req->tr_rtn)(Req->tr_context, Req->tr_status,
                               Req->tr_status == TDI_SUCCESS
                                    ? CurrentSend->tsr_size : 0);
                FreeSendReq(CurrentSend);

                DoRcvComplete = TRUE;
            }
            CurrentSend = STRUCT_OF(TCPSendReq, QSTRUCT(TCPReq, TempQ, tr_q),
                                    tsr_req);

            i++;
        }

    }
    FreeTCPHeader(BufferChain);

    if (DoRcvComplete && !PartitionedDelayQ) {
        KIRQL Irql = KeRaiseIrqlToDpcLevel();
        TCPRcvComplete();
        KeLowerIrql(Irql);
    }
}

//* RcvWin - Figure out the receive window to offer in an ack.
//
//  A routine to figure out what window to offer on a connection. We
//  take into account SWS avoidance, what the default connection window is,
//  and what the last window we offered is.
//
//  Input:  WinTCB          - TCB on which to perform calculations.
//
//  Returns: Window to be offered.
//
uint
RcvWin(TCB * WinTCB)
{
    int CouldOffer;                // The window size we could offer.

    CTEStructAssert(WinTCB, tcb);

    CheckRBList(WinTCB->tcb_pendhead, WinTCB->tcb_pendingcnt);

    ASSERT(WinTCB->tcb_rcvwin >= 0);

    CouldOffer = WinTCB->tcb_defaultwin - WinTCB->tcb_pendingcnt;

    ASSERT(CouldOffer >= 0);
    ASSERT(CouldOffer >= WinTCB->tcb_rcvwin);

    if ((CouldOffer - WinTCB->tcb_rcvwin) >=
        (int)MIN(WinTCB->tcb_defaultwin / 2, WinTCB->tcb_mss))
        WinTCB->tcb_rcvwin = CouldOffer;

    return WinTCB->tcb_rcvwin;
}



//* SendSYNOnSynTCB - Send a SYN segment for syntcb
//
//  This is called during connection establishment time to send a SYN
//  segment to the peer. We get a buffer if we can, and then fill
//  it in. There's a tricky part here where we have to build the MSS
//  option in the header - we find the MSS by finding the MSS offered
//  by the net for the local address. After that, we send it.
//
//  Input:  SYNTcb          - TCB from which SYN is to be sent.
//
//  Returns: Nothing.
//
void
SendSYNOnSynTCB(SYNTCB * SYNTcb, CTELockHandle TCBHandle)
{
    PNDIS_BUFFER HeaderBuffer;
    TCPHeader *SYNHeader;
    uchar *OptPtr;
    IP_STATUS SendStatus;
    ushort OptSize = 0, HdrSize = 0;
    BOOLEAN SackOpt = FALSE;
    IPOptInfo OptInfo;

    CTEStructAssert(SYNTcb, syntcb);

    HeaderBuffer = GetTCPHeaderAtDpcLevel(&SYNHeader);

    // Go ahead and set the retransmission timer now, in case we didn't get a
    // buffer. In the future we might want to queue the connection for
    // when we free a buffer.

    START_TCB_TIMER(SYNTcb->syntcb_rexmittimer, SYNTcb->syntcb_rexmit);

    // The Rexmit interval has to be doubled here
    
    SYNTcb->syntcb_rexmit = MIN(SYNTcb->syntcb_rexmit << 1, MAX_REXMIT_TO);

    if (HeaderBuffer != NULL) {
        ushort TempWin;
        ushort MSS;
        uchar FoundMSS;

        SYNHeader = (TCPHeader *) ((PUCHAR)SYNHeader + LocalNetInfo.ipi_hsize);

        NDIS_BUFFER_LINKAGE(HeaderBuffer) = NULL;

        if (SYNTcb->syntcb_tcpopts & TCP_FLAG_WS) {
            OptSize += WS_OPT_SIZE + 1;        // 1 NOP for alignment

        }
        if (SYNTcb->syntcb_tcpopts & TCP_FLAG_TS) {
            OptSize += TS_OPT_SIZE + 2;        // 2 NOPs for alignment
        }
        if (SYNTcb->syntcb_tcpopts & TCP_FLAG_SACK){
            SackOpt = TRUE;
            OptSize += 4;        // 2 NOPS, SACK kind and length field
        }
        NdisAdjustBufferLength(HeaderBuffer,
                               sizeof(TCPHeader) + MSS_OPT_SIZE + OptSize);

        SYNHeader->tcp_src = SYNTcb->syntcb_sport;
        SYNHeader->tcp_dest = SYNTcb->syntcb_dport;
        SYNHeader->tcp_seq = net_long(SYNTcb->syntcb_sendnext);
        SYNTcb->syntcb_sendnext++;

        if (SYNTcb->syntcb_rexmitcnt == 0) {
            TCPSIncrementOutSegCount();
        } else
            TStats.ts_retranssegs++;

        SYNHeader->tcp_ack = net_long(SYNTcb->syntcb_rcvnext);

        // Reuse OPt size for header size determination
        // default is MSS amd tcp header size

        HdrSize = 6;

        // set size field to reflect TS and WND scale option
        // tcp header + windowscale + Timestamp + pad

        if (SYNTcb->syntcb_tcpopts & TCP_FLAG_WS) {
            // WS: Add one more long word
            HdrSize += 1;
        }
        if (SYNTcb->syntcb_tcpopts & TCP_FLAG_TS) {
            // TS: Add 3 more long words
            HdrSize += 3;
        }
        if (SackOpt) {
            // SACK: Add 1 more long word
            HdrSize += 1;
        }

        SYNHeader->tcp_flags =
                MAKE_TCP_FLAGS(HdrSize, TCP_FLAG_SYN | TCP_FLAG_ACK);

        if (SYNTcb->syntcb_defaultwin <= TCP_MAXWIN) {
            TempWin = (ushort)SYNTcb->syntcb_defaultwin;
        } else {
            // Don't apply the scale-factor in a SYN segment.
            // Instead, advertise the largest window possible.
            TempWin = TCP_MAXWIN;
        }

        SYNHeader->tcp_window = net_short(TempWin);
        SYNHeader->tcp_urgent = 0;
        SYNHeader->tcp_xsum = 0;
        OptPtr = (uchar *) (SYNHeader + 1);

        FoundMSS = (*LocalNetInfo.ipi_getlocalmtu) (SYNTcb->syntcb_saddr, &MSS);

        if (!FoundMSS) {
            CTEFreeLock(&SYNTcb->syntcb_lock, TCBHandle);
            FreeTCPHeader(HeaderBuffer);
            return;
        }
        MSS -= sizeof(TCPHeader);

        SYNTcb->syntcb_mss = MSS;

        *OptPtr++ = TCP_OPT_MSS;
        *OptPtr++ = MSS_OPT_SIZE;
        **(ushort **) & OptPtr = net_short(MSS);

        OptPtr++;
        OptPtr++;

        if (SYNTcb->syntcb_tcpopts & TCP_FLAG_WS) {

            // Fill in the WS option headers and value

            *OptPtr++ = TCP_OPT_NOP;
            *OptPtr++ = TCP_OPT_WS;
            *OptPtr++ = WS_OPT_SIZE;

            //Initial window scale factor
            *OptPtr++ = (uchar) SYNTcb->syntcb_rcvwinscale;
        }
        if (SYNTcb->syntcb_tcpopts & TCP_FLAG_TS) {

            //Start loading time stamp option header and value

            *OptPtr++ = TCP_OPT_NOP;
            *OptPtr++ = TCP_OPT_NOP;
            *OptPtr++ = TCP_OPT_TS;
            *OptPtr++ = TS_OPT_SIZE;

            // Initialize TS value TSval

            *(long *)OptPtr = 0;
            OptPtr += 4;

            //Initialize TS Echo Reply TSecr

            *(long *)OptPtr = 0;
            OptPtr += 4;
        }
        if (SackOpt) {

            // Initialize with SACK_PERMITTED option

            *(long *)OptPtr = net_long(0x01010402);

            IF_TCPDBG(TCP_DEBUG_SACK) {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Sending SACK_OPT %x\n", SYNTcb));
            }

        }

        SYNTcb->syntcb_refcnt++;

        // Account for Options.
        (*LocalNetInfo.ipi_initopts) (&OptInfo);
        OptInfo.ioi_ttl = SYNTcb->syntcb_ttl;

        SYNHeader->tcp_xsum =
            ~XsumSendChain(PHXSUM(SYNTcb->syntcb_saddr, SYNTcb->syntcb_daddr,
                                  PROTOCOL_TCP, 0) +
                           (uint)net_short(sizeof(TCPHeader) + MSS_OPT_SIZE +
                                           OptSize), HeaderBuffer);

        CTEFreeLock(&SYNTcb->syntcb_lock, TCBHandle);

        SendStatus =
            (*LocalNetInfo.ipi_xmit)(TCPProtInfo, NULL, HeaderBuffer,
                                     sizeof(TCPHeader) + MSS_OPT_SIZE + OptSize,
                                     SYNTcb->syntcb_daddr, SYNTcb->syntcb_saddr,
                                     &OptInfo, NULL, PROTOCOL_TCP, NULL);

        if (SendStatus != IP_PENDING) {
            FreeTCPHeader(HeaderBuffer);
        }
        CTEGetLock(&SYNTcb->syntcb_lock, &TCBHandle);
        DerefSynTCB(SYNTcb, TCBHandle);

    } else {
        SYNTcb->syntcb_sendnext++;
        CTEFreeLock(&SYNTcb->syntcb_lock, TCBHandle);
        return;
    }

}



//* SendSYN - Send a SYN segment.
//
//  This is called during connection establishment time to send a SYN
//  segment to the peer. We get a buffer if we can, and then fill
//  it in. There's a tricky part here where we have to build the MSS
//  option in the header - we find the MSS by finding the MSS offered
//  by the net for the local address. After that, we send it.
//
//  Input:  SYNTcb          - TCB from which SYN is to be sent.
//          TCBHandle       - Handle for lock on TCB.
//
//  Returns: Nothing.
//
void
SendSYN(TCB * SYNTcb, CTELockHandle TCBHandle)
{
    PNDIS_BUFFER HeaderBuffer;
    TCPHeader *SYNHeader;
    uchar *OptPtr;
    IP_STATUS SendStatus;
    ushort OptSize = 0, HdrSize = 0, rfc1323opts = 0;
    BOOLEAN SackOpt = FALSE;

    CTEStructAssert(SYNTcb, tcb);

    HeaderBuffer = GetTCPHeaderAtDpcLevel(&SYNHeader);

    // Go ahead and set the retransmission timer now, in case we didn't get a
    // buffer. In the future we might want to queue the connection for
    // when we free a buffer.

    START_TCB_TIMER_R(SYNTcb, RXMIT_TIMER, SYNTcb->tcb_rexmit);

    if (HeaderBuffer != NULL) {
        ushort TempWin;
        ushort MSS;
        uchar FoundMSS;

        SYNHeader = (TCPHeader *) ((PUCHAR)SYNHeader + LocalNetInfo.ipi_hsize);

        NDIS_BUFFER_LINKAGE(HeaderBuffer) = NULL;


        // If we are doing active open, check if we are configured to do
        // window scaling and time stamp options

        if ((((TcpHostSendOpts & TCP_FLAG_WS) || SYNTcb->tcb_rcvwinscale) &&
             SYNTcb->tcb_state == TCB_SYN_SENT) ||
            (SYNTcb->tcb_tcpopts & TCP_FLAG_WS)) {

            rfc1323opts |= TCP_FLAG_WS;

            IF_TCPDBG(TCP_DEBUG_1323) {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Selected WS option TCB %x\n", SYNTcb));
            }
        }
        if (((TcpHostSendOpts & TCP_FLAG_TS) &&
             (SYNTcb->tcb_state == TCB_SYN_SENT)) ||
            (SYNTcb->tcb_tcpopts & TCP_FLAG_TS)) {

            IF_TCPDBG(TCP_DEBUG_1323) {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Selected TS option TCB %x\n", SYNTcb));
            }
            rfc1323opts |= TCP_FLAG_TS;
        }

        if (rfc1323opts & TCP_FLAG_WS) {
            OptSize += WS_OPT_SIZE + 1;        // 1 NOP for alignment
        }
        if (rfc1323opts & TCP_FLAG_TS) {
            OptSize += TS_OPT_SIZE + 2;        // 2 NOPs for alignment
        }
        if ((SYNTcb->tcb_tcpopts & TCP_FLAG_SACK) ||
            ((SYNTcb->tcb_state == TCB_SYN_SENT) &&
            (TcpHostOpts & TCP_FLAG_SACK))) {
            SackOpt = TRUE;

            OptSize += 4;        // 2 NOPS, SACK kind and length field
        }
        NdisAdjustBufferLength(HeaderBuffer,
                               sizeof(TCPHeader) + MSS_OPT_SIZE + OptSize);

        SYNHeader->tcp_src = SYNTcb->tcb_sport;
        SYNHeader->tcp_dest = SYNTcb->tcb_dport;
        SYNHeader->tcp_seq = net_long(SYNTcb->tcb_sendnext);
        SYNTcb->tcb_sendnext++;

        if (SEQ_GT(SYNTcb->tcb_sendnext, SYNTcb->tcb_sendmax)) {
            TCPSIncrementOutSegCount();
            SYNTcb->tcb_sendmax = SYNTcb->tcb_sendnext;
        } else
            TStats.ts_retranssegs++;

        SYNHeader->tcp_ack = net_long(SYNTcb->tcb_rcvnext);

        // Reuse OPt size for header size determination
        // default is MSS amd tcp header size

        HdrSize = 6;

        // set size field to reflect TS and WND scale option
        // tcp header + windowscale + Timestamp + pad

        if (rfc1323opts & TCP_FLAG_WS) {

            // WS: Add one more long word
            HdrSize += 1;

        }
        if (rfc1323opts & TCP_FLAG_TS) {

            // TS: Add 3 more long words
            HdrSize += 3;
        }
        if (SackOpt) {
            // SACK: Add 1 more long word
            HdrSize += 1;

        }
        if (SYNTcb->tcb_state == TCB_SYN_RCVD) {
            SYNHeader->tcp_flags =
                MAKE_TCP_FLAGS(HdrSize, TCP_FLAG_SYN | TCP_FLAG_ACK);
        } else {
            SYNHeader->tcp_flags = MAKE_TCP_FLAGS(HdrSize, TCP_FLAG_SYN);
        }

        SYNTcb->tcb_lastack = SYNTcb->tcb_rcvnext;

        if (SYNTcb->tcb_rcvwin <= TCP_MAXWIN) {
            TempWin = (ushort)SYNTcb->tcb_rcvwin;
        } else {
            // Don't apply the scale-factor in a SYN segment.
            // Instead, advertise the largest window possible.
            TempWin = TCP_MAXWIN;
        }

        SYNHeader->tcp_window = net_short(TempWin);
        SYNHeader->tcp_urgent = 0;
        SYNHeader->tcp_xsum = 0;
        OptPtr = (uchar *) (SYNHeader + 1);

        FoundMSS = (*LocalNetInfo.ipi_getlocalmtu) (SYNTcb->tcb_saddr, &MSS);

        if (!FoundMSS) {
            CTEFreeLock(&SYNTcb->tcb_lock, TCBHandle);
            FreeTCPHeader(HeaderBuffer);
            return;
        }

        MSS -= sizeof(TCPHeader);

        *OptPtr++ = TCP_OPT_MSS;
        *OptPtr++ = MSS_OPT_SIZE;
        **(ushort **) & OptPtr = net_short(MSS);

        OptPtr++;
        OptPtr++;

        if (rfc1323opts & TCP_FLAG_WS) {

            // Fill in the WS option headers and value

            *OptPtr++ = TCP_OPT_NOP;
            *OptPtr++ = TCP_OPT_WS;
            *OptPtr++ = WS_OPT_SIZE;

            // Initial window scale factor
            *OptPtr++ = (uchar) SYNTcb->tcb_rcvwinscale;
        }
        if (rfc1323opts & TCP_FLAG_TS) {

            // Start loading time stamp option header and value

            *OptPtr++ = TCP_OPT_NOP;
            *OptPtr++ = TCP_OPT_NOP;
            *OptPtr++ = TCP_OPT_TS;
            *OptPtr++ = TS_OPT_SIZE;

            // Initialize TS value TSval

            *(long *)OptPtr = 0;
            OptPtr += 4;

            // Initialize TS Echo Reply TSecr

            *(long *)OptPtr = 0;
            OptPtr += 4;
        }
        if (SackOpt) {

            // Initialize with SACK_PERMITTED option

            *(long *)OptPtr = net_long(0x01010402);

            IF_TCPDBG(TCP_DEBUG_SACK) {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Sending SACK_OPT %x\n", SYNTcb));
            }

        }

        REFERENCE_TCB(SYNTcb);

        // Account for Options.

        SYNTcb->tcb_opt.ioi_TcpChksum = 0;

        SYNHeader->tcp_xsum =
            ~XsumSendChain(SYNTcb->tcb_phxsum +
                (uint)net_short(sizeof(TCPHeader) + MSS_OPT_SIZE + OptSize),
                HeaderBuffer);


        ClassifyPacket(SYNTcb);

        CTEFreeLock(&SYNTcb->tcb_lock, TCBHandle);

        SendStatus =
            (*LocalNetInfo.ipi_xmit)(TCPProtInfo, NULL, HeaderBuffer,
                                     sizeof(TCPHeader) + MSS_OPT_SIZE + OptSize,
                                     SYNTcb->tcb_daddr, SYNTcb->tcb_saddr,
                                     &SYNTcb->tcb_opt, SYNTcb->tcb_rce,
                                     PROTOCOL_TCP, NULL);

        SYNTcb->tcb_error = SendStatus;
        if (SendStatus != IP_PENDING) {
            FreeTCPHeader(HeaderBuffer);
        }
        CTEGetLock(&SYNTcb->tcb_lock, &TCBHandle);
        DerefTCB(SYNTcb, TCBHandle);

    } else {
        SYNTcb->tcb_sendnext++;
        if (SEQ_GT(SYNTcb->tcb_sendnext, SYNTcb->tcb_sendmax))
            SYNTcb->tcb_sendmax = SYNTcb->tcb_sendnext;
        CTEFreeLock(&SYNTcb->tcb_lock, TCBHandle);
        return;
    }

}

//* SendKA - Send a keep alive segment.
//
//  This is called when we want to send a keep alive.
//
//  Input:  KATcb   - TCB from which keep alive is to be sent.
//          Handle  - Handle for lock on TCB.
//
//  Returns: Nothing.
//
void
SendKA(TCB * KATcb, CTELockHandle Handle)
{
    PNDIS_BUFFER HeaderBuffer;
    TCPHeader *Header;
    IP_STATUS SendStatus;

    CTEStructAssert(KATcb, tcb);

    HeaderBuffer = GetTCPHeaderAtDpcLevel(&Header);

    if (HeaderBuffer != NULL) {
        ushort TempWin;
        SeqNum TempSeq;

        Header = (TCPHeader *) ((PUCHAR) Header + LocalNetInfo.ipi_hsize);

        NDIS_BUFFER_LINKAGE(HeaderBuffer) = NULL;
        NdisAdjustBufferLength(HeaderBuffer, sizeof(TCPHeader) + 1);
        Header->tcp_src = KATcb->tcb_sport;
        Header->tcp_dest = KATcb->tcb_dport;
        TempSeq = KATcb->tcb_senduna - 1;
        Header->tcp_seq = net_long(TempSeq);

        TStats.ts_retranssegs++;

        Header->tcp_ack = net_long(KATcb->tcb_rcvnext);
        Header->tcp_flags = MAKE_TCP_FLAGS(5, TCP_FLAG_ACK);

        // Initialize the single byte that we're sending.
        *(uchar*)(Header + 1) = 0;

        // We need to scale  the rcv window
        // Use temprary variable to workaround truncation
        // caused by net_short

        TempWin = (ushort) (RcvWin(KATcb) >> KATcb->tcb_rcvwinscale);
        Header->tcp_window = net_short(TempWin);
        Header->tcp_urgent = 0;

        KATcb->tcb_lastack = KATcb->tcb_rcvnext;

        Header->tcp_xsum = 0;

        KATcb->tcb_opt.ioi_TcpChksum = 0;
        Header->tcp_xsum =
            ~XsumSendChain(KATcb->tcb_phxsum +
                           (uint)net_short(sizeof(TCPHeader) + 1),
                           HeaderBuffer);

        KATcb->tcb_kacount++;
        ClassifyPacket(KATcb);
        REFERENCE_TCB(KATcb);
        CTEFreeLock(&KATcb->tcb_lock, Handle);

        SendStatus = (*LocalNetInfo.ipi_xmit)(TCPProtInfo,
                                              NULL,
                                              HeaderBuffer,
                                              sizeof(TCPHeader) + 1,
                                              KATcb->tcb_daddr,
                                              KATcb->tcb_saddr,
                                              &KATcb->tcb_opt,
                                              KATcb->tcb_rce,
                                              PROTOCOL_TCP,
                                              NULL);

        if (SendStatus != IP_PENDING) {
            FreeTCPHeader(HeaderBuffer);
        }

        CTEGetLock(&KATcb->tcb_lock, &Handle);
        DerefTCB(KATcb, Handle);
    } else {
        CTEFreeLock(&KATcb->tcb_lock, Handle);
    }

}

//* SendACK - Send an ACK segment.
//
//  This is called whenever we need to send an ACK for some reason. Nothing
//  fancy, we just do it.
//
//  Input:  ACKTcb          - TCB from which ACK is to be sent.
//
//  Returns: Nothing.
//
void
SendACK(TCB * ACKTcb)
{
    PNDIS_BUFFER HeaderBuffer;
    TCPHeader *ACKHeader;
    IP_STATUS SendStatus;
    CTELockHandle TCBHandle;
    SeqNum SendNext;
    ushort SackLength = 0, i, hdrlen = 5;
    ulong *ts_opt;
    BOOLEAN HWChksum = FALSE;

    CTEStructAssert(ACKTcb, tcb);

    HeaderBuffer = GetTCPHeader(&ACKHeader);

    if (HeaderBuffer != NULL) {
        ushort TempWin;
        ushort Size;

        ACKHeader = (TCPHeader *) ((PUCHAR) ACKHeader + LocalNetInfo.ipi_hsize);

        CTEGetLock(&ACKTcb->tcb_lock, &TCBHandle);


        // Allow room for filling time stamp option.
        // Note that it is 12 bytes and will never ever change

        if (ACKTcb->tcb_tcpopts & TCP_FLAG_TS) {
            NdisAdjustBufferLength(HeaderBuffer,
                                   sizeof(TCPHeader) + ALIGNED_TS_OPT_SIZE);

            // Header length is multiple of 32bits

            hdrlen = 5 + 3; // standard header size +
                            // header size requirement for TS option

            ACKTcb->tcb_lastack = ACKTcb->tcb_rcvnext;

        }
        if ((ACKTcb->tcb_tcpopts & TCP_FLAG_SACK) &&
            ACKTcb->tcb_SackBlock &&
            (ACKTcb->tcb_SackBlock->Mask[0] == 1)) {

            SackLength++;
            for (i = 1; i < 3; i++) {
                if (ACKTcb->tcb_SackBlock->Mask[i] == 1)
                    SackLength++;
            }

            IF_TCPDBG(TCP_DEBUG_SACK) {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"Sending SACKs!! %x %x\n", ACKTcb, SackLength));
            }

            NdisAdjustBufferLength(HeaderBuffer,
                                   NdisBufferLength(HeaderBuffer) + SackLength * 8 + 4);

            // Sack block is of 2 long words (8 bytes) and 4 bytes
            // is for Sack option header.

            hdrlen += ((SackLength * 8 + 4) >> 2);
        }

        NDIS_BUFFER_LINKAGE(HeaderBuffer) = NULL;

        ACKHeader->tcp_src = ACKTcb->tcb_sport;
        ACKHeader->tcp_dest = ACKTcb->tcb_dport;
        ACKHeader->tcp_ack = net_long(ACKTcb->tcb_rcvnext);

        // If the remote peer is advertising a window of zero, we need to
        // send this ack with a seq. number of his rcv_next (which in that case
        // should be our senduna). We have code here ifdef'd out that makes
        // sure that we don't send outside the RWE, but this doesn't work. We
        // need to be able to send a pure ACK exactly at the RWE.

        if (ACKTcb->tcb_sendwin != 0) {

            SendNext = ACKTcb->tcb_sendnext;
        } else
            SendNext = ACKTcb->tcb_senduna;

        if ((ACKTcb->tcb_flags & FIN_SENT) &&
            SEQ_EQ(SendNext, ACKTcb->tcb_sendmax - 1)) {
            ACKHeader->tcp_flags = MAKE_TCP_FLAGS(hdrlen,
                                                  TCP_FLAG_FIN | TCP_FLAG_ACK);
        } else
            ACKHeader->tcp_flags = MAKE_TCP_FLAGS(hdrlen, TCP_FLAG_ACK);

        ACKHeader->tcp_seq = net_long(SendNext);

        TempWin = (ushort) (RcvWin(ACKTcb) >> ACKTcb->tcb_rcvwinscale);
        ACKHeader->tcp_window = net_short(TempWin);
        ACKHeader->tcp_urgent = 0;
        ACKHeader->tcp_xsum = 0;

        Size = sizeof(TCPHeader);

        // Point to a place beyond tcp header

        ts_opt = (ulong *)((uchar *) ACKHeader + 20);

        if (ACKTcb->tcb_tcpopts & TCP_FLAG_TS) {

            // Form time stamp header with 2 NOPs for alignment
            *ts_opt++ = net_long(0x0101080A);
            *ts_opt++ = net_long(TCPTime);
            *ts_opt++ = net_long(ACKTcb->tcb_tsrecent);

            // Add 12 more bytes to the size to account for TS

            Size += ALIGNED_TS_OPT_SIZE;

        }
        if ((ACKTcb->tcb_tcpopts & TCP_FLAG_SACK) &&
            ACKTcb->tcb_SackBlock &&
            (ACKTcb->tcb_SackBlock->Mask[0] == 1)) {

            ushort* UshortPtr;
            uchar* UcharPtr;
            UshortPtr = (ushort *)ts_opt;
            *UshortPtr = 0x0101;
            ts_opt = (ulong *)((uchar *)ts_opt + 2);
            UcharPtr = (uchar *)ts_opt;
            *UcharPtr = (uchar)0x05;
            ts_opt = (ulong *)((uchar *)ts_opt + 1);
            UcharPtr = (uchar *)ts_opt;
            *UcharPtr = (uchar) SackLength * 8 + 2;
            ts_opt = (ulong *)((uchar *)ts_opt + 1);

            // Sack option header + the block times times sack length!
            Size += 4 + SackLength * 8;

            for (i = 0; i < 3; i++) {
                if (ACKTcb->tcb_SackBlock->Mask[i] != 0) {
                    *ts_opt++ =
                        net_long(ACKTcb->tcb_SackBlock->Block[i].begin);
                    *ts_opt++ =
                        net_long(ACKTcb->tcb_SackBlock->Block[i].end);
                }
            }
        }

        if (ACKTcb->tcb_rce &&
            (ACKTcb->tcb_rce->rce_OffloadFlags &
             TCP_XMT_CHECKSUM_OFFLOAD)) {
            HWChksum = TRUE;

            if ((Size > sizeof(TCPHeader)) &&
                !(ACKTcb->tcb_rce->rce_OffloadFlags &
                  TCP_CHECKSUM_OPT_OFFLOAD)) {
                HWChksum = FALSE;
            }
        }

        if (HWChksum) {
            uint PHXsum = ACKTcb->tcb_phxsum + (uint) net_short(Size);

            PHXsum = (((PHXsum << 16) | (PHXsum >> 16)) + PHXsum) >> 16;
            ACKHeader->tcp_xsum = (ushort) PHXsum;
            ACKTcb->tcb_opt.ioi_TcpChksum = 1;
#if DBG
            DbgTcpSendHwChksumCount++;
#endif
        } else {

            ACKHeader->tcp_xsum =
                ~XsumSendChain(ACKTcb->tcb_phxsum +
                               (uint)net_short(Size), HeaderBuffer);
            ACKTcb->tcb_opt.ioi_TcpChksum = 0;
        }

        STOP_TCB_TIMER_R(ACKTcb, DELACK_TIMER);
        ACKTcb->tcb_rcvdsegs = 0;
        ACKTcb->tcb_flags &= ~(NEED_ACK | ACK_DELAYED);

        ClassifyPacket(ACKTcb);

        CTEFreeLock(&ACKTcb->tcb_lock, TCBHandle);

        TCPSIncrementOutSegCount();

        if (ACKTcb->tcb_tcpopts) {
            SendStatus = (*LocalNetInfo.ipi_xmit)(TCPProtInfo,
                                                  NULL,
                                                  HeaderBuffer,
                                                  Size,
                                                  ACKTcb->tcb_daddr,
                                                  ACKTcb->tcb_saddr,
                                                  &ACKTcb->tcb_opt,
                                                  ACKTcb->tcb_rce,
                                                  PROTOCOL_TCP,
                                                  NULL);
        } else {
            SendStatus = (*LocalNetInfo.ipi_xmit)(TCPProtInfo,
                                                  NULL,
                                                  HeaderBuffer,
                                                  sizeof(TCPHeader),
                                                  ACKTcb->tcb_daddr,
                                                  ACKTcb->tcb_saddr,
                                                  &ACKTcb->tcb_opt,
                                                  ACKTcb->tcb_rce,
                                                  PROTOCOL_TCP,
                                                  NULL);

        }

        ACKTcb->tcb_error = SendStatus;
        if (SendStatus != IP_PENDING)
            FreeTCPHeader(HeaderBuffer);
    }
    return;

}

//* SendTWtcbACK- Send an ACK segment for a twtcb
//
//
//  Input:  ACKTcb          - TCB from which ACK is to be sent.
//
//  Returns: Nothing.
//
void
SendTWtcbACK(TWTCB *ACKTcb, uint Partition, CTELockHandle TCBHandle)
{
    PNDIS_BUFFER HeaderBuffer;
    TCPHeader *ACKHeader;
    IP_STATUS SendStatus;
    SeqNum SendNext;
    ushort hdrlen = 5;
    uint phxsum;

    CTEStructAssert(ACKTcb, twtcb);

    HeaderBuffer = GetTCPHeaderAtDpcLevel(&ACKHeader);

    if (HeaderBuffer != NULL) {
        ushort Size;
        IPOptInfo NewInfo;

        ACKHeader = (TCPHeader *)((PUCHAR)ACKHeader + LocalNetInfo.ipi_hsize);

        NDIS_BUFFER_LINKAGE(HeaderBuffer) = NULL;

        ACKHeader->tcp_src = ACKTcb->twtcb_sport;
        ACKHeader->tcp_dest = ACKTcb->twtcb_dport;
        ACKHeader->tcp_ack = net_long(ACKTcb->twtcb_rcvnext);

        SendNext = ACKTcb->twtcb_sendnext;

        ACKHeader->tcp_flags = MAKE_TCP_FLAGS(hdrlen, TCP_FLAG_ACK);

        ACKHeader->tcp_seq = net_long(SendNext);

        // Window needs to be zero since we can not rcv anyway.
        ACKHeader->tcp_window = 0;
        ACKHeader->tcp_urgent = 0;

        Size = sizeof(TCPHeader);

        phxsum = PHXSUM(ACKTcb->twtcb_saddr, ACKTcb->twtcb_daddr,
                                PROTOCOL_TCP, 0);

        ACKHeader->tcp_xsum = 0;
        ACKHeader->tcp_xsum =
            ~XsumSendChain(phxsum +
                           (uint)net_short(Size), HeaderBuffer);
        //ACKTcb->tcb_opt.ioi_TcpChksum=0;

        CTEFreeLockFromDPC(&pTWTCBTableLock[Partition]);

        TCPSIncrementOutSegCount();

        (*LocalNetInfo.ipi_initopts) (&NewInfo);

        SendStatus =
            (*LocalNetInfo.ipi_xmit)(TCPProtInfo,
                                     NULL,
                                     HeaderBuffer,
                                     sizeof(TCPHeader),
                                     ACKTcb->twtcb_daddr,
                                     ACKTcb->twtcb_saddr,
                                     &NewInfo,
                                     NULL,
                                     PROTOCOL_TCP,
                                     NULL);

        if (SendStatus != IP_PENDING)
            FreeTCPHeader(HeaderBuffer);

        (*LocalNetInfo.ipi_freeopts) (&NewInfo);

    } else {
        CTEFreeLockFromDPC(&pTWTCBTableLock[Partition]);
    }
}

//* SendRSTFromTCB - Send a RST from a TCB.
//
//  This is called during close when we need to send a RST.
//
//  Input:  RSTTcb          - TCB from which RST is to be sent.
//          RCE             - Optional RCE to be used in sending.
//
//  Returns: Nothing.
//
void
SendRSTFromTCB(TCB * RSTTcb, RouteCacheEntry* RCE)
{
    PNDIS_BUFFER HeaderBuffer;
    TCPHeader *RSTHeader;
    IP_STATUS SendStatus;

    CTEStructAssert(RSTTcb, tcb);
    ASSERT(RSTTcb->tcb_state == TCB_CLOSED);

    HeaderBuffer = GetTCPHeader(&RSTHeader);

    if (HeaderBuffer != NULL) {
        SeqNum RSTSeq;

        RSTHeader = (TCPHeader *) ((PUCHAR)RSTHeader + LocalNetInfo.ipi_hsize);

        NDIS_BUFFER_LINKAGE(HeaderBuffer) = NULL;

        RSTHeader->tcp_src = RSTTcb->tcb_sport;
        RSTHeader->tcp_dest = RSTTcb->tcb_dport;

        // If the remote peer has a window of 0, send with a seq. # equal
        // to senduna so he'll accept it. Otherwise send with send max.
        if (RSTTcb->tcb_sendwin != 0)
            RSTSeq = RSTTcb->tcb_sendmax;
        else
            RSTSeq = RSTTcb->tcb_senduna;

        RSTHeader->tcp_seq = net_long(RSTSeq);
        RSTHeader->tcp_ack = net_long(RSTTcb->tcb_rcvnext);
        RSTHeader->tcp_flags = MAKE_TCP_FLAGS(sizeof(TCPHeader) / sizeof(ulong),
                                              TCP_FLAG_RST | TCP_FLAG_ACK);

        RSTHeader->tcp_window = 0;
        RSTHeader->tcp_urgent = 0;
        RSTHeader->tcp_xsum = 0;

        // Recompute pseudo checksum as this will
        // not be valid when connection is disconnected
        // in pre-accept case.

        RSTHeader->tcp_xsum =
            ~XsumSendChain(PHXSUM(RSTTcb->tcb_saddr,
                                  RSTTcb->tcb_daddr,
                                  PROTOCOL_TCP,
                                  sizeof(TCPHeader)),
                           HeaderBuffer);


        RSTTcb->tcb_opt.ioi_TcpChksum = 0;

        TCPSIncrementOutSegCount();
        TStats.ts_outrsts++;
        SendStatus = (*LocalNetInfo.ipi_xmit)(TCPProtInfo,
                                              NULL,
                                              HeaderBuffer,
                                              sizeof(TCPHeader),
                                              RSTTcb->tcb_daddr,
                                              RSTTcb->tcb_saddr,
                                              &RSTTcb->tcb_opt,
                                              RCE,
                                              PROTOCOL_TCP,
                                              NULL);

        if (SendStatus != IP_PENDING)
            FreeTCPHeader(HeaderBuffer);
    }
    return;

}
//* SendRSTFromHeader - Send a RST back, based on a header.
//
//  Called when we need to send a RST, but don't necessarily have a TCB.
//
//  Input:  TCPH            - TCP header to be RST.
//          Length          - Length of the incoming segment.
//          Dest            - Destination IP address for RST.
//          Src             - Source IP address for RST.
//          OptInfo         - IP Options to use on RST.
//
//  Returns: Nothing.
//
void
SendRSTFromHeader(TCPHeader UNALIGNED * TCPH, uint Length, IPAddr Dest,
                  IPAddr Src, IPOptInfo * OptInfo)
{
    PNDIS_BUFFER Buffer;
    TCPHeader *RSTHdr;
    IPOptInfo NewInfo;
    IP_STATUS SendStatus;

    if (TCPH->tcp_flags & TCP_FLAG_RST)
        return;

    Buffer = GetTCPHeader(&RSTHdr);

    if (Buffer != NULL) {
        // Got a buffer. Fill in the header so as to make it believable to
        // the remote guy, and send it.

        RSTHdr = (TCPHeader *) ((PUCHAR)RSTHdr + LocalNetInfo.ipi_hsize);

        NDIS_BUFFER_LINKAGE(Buffer) = NULL;

        if (TCPH->tcp_flags & TCP_FLAG_SYN)
            Length++;

        if (TCPH->tcp_flags & TCP_FLAG_FIN)
            Length++;

        if (TCPH->tcp_flags & TCP_FLAG_ACK) {
            RSTHdr->tcp_seq = TCPH->tcp_ack;
            RSTHdr->tcp_ack = TCPH->tcp_ack;
            RSTHdr->tcp_flags =
                MAKE_TCP_FLAGS(sizeof(TCPHeader) / sizeof(ulong), TCP_FLAG_RST);
        } else {
            SeqNum TempSeq;

            RSTHdr->tcp_seq = 0;
            TempSeq = net_long(TCPH->tcp_seq);
            TempSeq += Length;
            RSTHdr->tcp_ack = net_long(TempSeq);
            RSTHdr->tcp_flags =
                MAKE_TCP_FLAGS(sizeof(TCPHeader) / sizeof(ulong),
                               TCP_FLAG_RST | TCP_FLAG_ACK);
        }

        RSTHdr->tcp_window = 0;
        RSTHdr->tcp_urgent = 0;
        RSTHdr->tcp_dest = TCPH->tcp_src;
        RSTHdr->tcp_src = TCPH->tcp_dest;
        RSTHdr->tcp_xsum = 0;

        RSTHdr->tcp_xsum =
            ~XsumSendChain(PHXSUM(Src, Dest, PROTOCOL_TCP, sizeof(TCPHeader)),
                           Buffer);

        (*LocalNetInfo.ipi_initopts) (&NewInfo);

        if (OptInfo->ioi_options != NULL)
            (*LocalNetInfo.ipi_updateopts)(OptInfo, &NewInfo, Dest,
                                           NULL_IP_ADDR);

        TCPSIncrementOutSegCount();
        TStats.ts_outrsts++;
        SendStatus = (*LocalNetInfo.ipi_xmit)(TCPProtInfo,
                                              NULL,
                                              Buffer,
                                              sizeof(TCPHeader),
                                              Dest,
                                              Src,
                                              &NewInfo,
                                              NULL,
                                              PROTOCOL_TCP,
                                              NULL);

        if (SendStatus != IP_PENDING)
            FreeTCPHeader(Buffer);

        (*LocalNetInfo.ipi_freeopts) (&NewInfo);
    }
}

//* GoToEstab - Transition to the established state.
//
//  Called when we are going to the established state and need to finish up
//  initializing things that couldn't be done until now. We assume the TCB
//  lock is held by the caller on the TCB we're called with.
//
//  Input:  EstabTCB    - TCB to transition.
//
//  Returns: Nothing.
//
void
GoToEstab(TCB * EstabTCB)
{
    uchar DType;
    ushort MSS;

    // Initialize our slow start and congestion control variables.
    EstabTCB->tcb_cwin = 2 * EstabTCB->tcb_mss;
    EstabTCB->tcb_ssthresh = 0xffffffff;

    EstabTCB->tcb_state = TCB_ESTAB;

    if (SynAttackProtect && EstabTCB->tcb_rce == NULL) {
        (*LocalNetInfo.ipi_openrce)(EstabTCB->tcb_daddr, EstabTCB->tcb_saddr,
                                    &EstabTCB->tcb_rce, &DType, &MSS,
                                    &EstabTCB->tcb_opt);
    }


    // We're in established. We'll subtract one from slow count for this fact,
    // and if the slowcount goes to 0 we'll move onto the fast path.

    if (--(EstabTCB->tcb_slowcount) == 0)
        EstabTCB->tcb_fastchk &= ~TCP_FLAG_SLOW;

    InterlockedIncrement((PLONG)&TStats.ts_currestab);

    EstabTCB->tcb_flags &= ~ACTIVE_OPEN;    // Turn off the active opening flag.

    // Start the Keep-Alive timer if necessary.
    if ((EstabTCB->tcb_flags & KEEPALIVE) && EstabTCB->tcb_conn) {
        START_TCB_TIMER_R(EstabTCB, KA_TIMER, 
                          EstabTCB->tcb_conn->tc_tcbkatime);
        EstabTCB->tcb_kacount = 0;
    }
}

//* InitSendState - Initialize the send state of a connection.
//
//  Called during connection establishment to initialize our send state.
//  (In this case, this refers to all information we'll put on the wire as
//  well as pure send state). We pick an ISS, set up a rexmit timer value,
//  etc. We assume the tcb_lock is held on the TCB when we are called.
//
//  Input:  NewTCB      - TCB to be set up.
//
//  Returns: Nothing.
void
InitSendState(TCB * NewTCB)
{
    CTEStructAssert(NewTCB, tcb);

    NewTCB->tcb_senduna = NewTCB->tcb_sendnext;
    NewTCB->tcb_sendmax = NewTCB->tcb_sendnext;
    NewTCB->tcb_error = IP_SUCCESS;

    // Initialize pseudo-header xsum.
    NewTCB->tcb_phxsum = PHXSUM(NewTCB->tcb_saddr, NewTCB->tcb_daddr,
                                PROTOCOL_TCP, 0);

    // Initialize retransmit and delayed ack stuff.
    NewTCB->tcb_rexmitcnt = 0;
    NewTCB->tcb_rtt = 0;
    NewTCB->tcb_smrtt = 0;


    NewTCB->tcb_delta = MS_TO_TICKS(6000);
    NewTCB->tcb_rexmit = MS_TO_TICKS(3000);

    if (NewTCB->tcb_rce) {

        //
        // InitialRtt can be as low as 300msec to enable
        // certain scenarios to work correctly.
        //
        if (NewTCB->tcb_rce->rce_TcpInitialRTT &&
            NewTCB->tcb_rce->rce_TcpInitialRTT > 3) {

            NewTCB->tcb_delta =
                MS_TO_TICKS(NewTCB->tcb_rce->rce_TcpInitialRTT * 2);
            NewTCB->tcb_rexmit =
                MS_TO_TICKS(NewTCB->tcb_rce->rce_TcpInitialRTT);
        }
    }

    STOP_TCB_TIMER_R(NewTCB, RXMIT_TIMER);
    STOP_TCB_TIMER_R(NewTCB, DELACK_TIMER);


}

//* TCPStatus - Handle a status indication.
//
//  This is the TCP status handler, called by IP when a status event
//  occurs. For most of these we do nothing. For certain severe status
//  events we will mark the local address as invalid.
//
//  Entry:  StatusType      - Type of status (NET or HW). NET status
//                              is usually caused by a received ICMP
//                              message. HW status indicate a HW
//                              problem.
//          StatusCode      - Code identifying IP_STATUS.
//          OrigDest        - If this is NET status, the original dest. of
//                              DG that triggered it.
//          OrigSrc         - "   "    "  "    "   , the original src.
//          Src             - IP address of status originator (could be local
//                              or remote).
//          Param           - Additional information for status - i.e. the
//                              param field of an ICMP message.
//          Data            - Data pertaining to status - for NET status, this
//                              is the first 8 bytes of the original DG.
//
//  Returns: Nothing
//
void
TCPStatus(uchar StatusType, IP_STATUS StatusCode, IPAddr OrigDest,
          IPAddr OrigSrc, IPAddr Src, ulong Param, void *Data)
{
    CTELockHandle TCBHandle;
    TCB *StatusTCB;
    TCPHeader UNALIGNED *Header = (TCPHeader UNALIGNED *) Data;
    SeqNum DropSeq;
    uint index;

    // Handle NET status codes differently from HW status codes.
    if (StatusType == IP_NET_STATUS) {
        // It's a NET code. Find a matching TCB.
        StatusTCB = FindTCB(OrigSrc, OrigDest, Header->tcp_dest,
                            Header->tcp_src, &TCBHandle, FALSE, &index);
        if (StatusTCB != NULL) {
            // Found one. Get the lock on it, and continue.
            CTEStructAssert(StatusTCB, tcb);
            // Make sure the TCB is in a state that is interesting.
            if (StatusTCB->tcb_state == TCB_CLOSED ||
                StatusTCB->tcb_state == TCB_TIME_WAIT ||
                CLOSING(StatusTCB)) {
                CTEFreeLock(&StatusTCB->tcb_lock, TCBHandle);
                return;
            }
            switch (StatusCode) {
                // Hard errors - Destination protocol unreachable. We treat
                // these as fatal errors. Close the connection now.
            case IP_DEST_PROT_UNREACHABLE:
                StatusTCB->tcb_error = StatusCode;
                REFERENCE_TCB(StatusTCB);
                TryToCloseTCB(StatusTCB, TCB_CLOSE_UNREACH, TCBHandle);

                RemoveTCBFromConn(StatusTCB);
                NotifyOfDisc(StatusTCB, NULL,
                             MapIPError(StatusCode, TDI_DEST_UNREACHABLE),
                             NULL);
                CTEGetLock(&StatusTCB->tcb_lock, &TCBHandle);
                DerefTCB(StatusTCB, TCBHandle);
                return;
                break;

                // Soft errors. Save the error in case it time out.
            case IP_DEST_NET_UNREACHABLE:
            case IP_DEST_HOST_UNREACHABLE:
            case IP_DEST_PORT_UNREACHABLE:

            case IP_BAD_ROUTE:
            case IP_TTL_EXPIRED_TRANSIT:
            case IP_TTL_EXPIRED_REASSEM:
            case IP_PARAM_PROBLEM:
                StatusTCB->tcb_error = StatusCode;
                break;

            case IP_PACKET_TOO_BIG:

                // icmp new MTU is in ich_param=1
                Param = net_short(Param >> 16);
                StatusTCB->tcb_error = StatusCode;
                // Fall through mtu change code


            case IP_SPEC_MTU_CHANGE:
                // A TCP datagram has triggered an MTU change. Figure out
                // which connection it is, and update him to retransmit the
                // segment. The Param value is the new MTU. We'll need to
                // retransmit if the new MTU is less than our existing MTU
                // and the sequence of the dropped packet is less than our
                // current send next.


                Param = Param - (sizeof(TCPHeader) +
                    StatusTCB->tcb_opt.ioi_optlength + sizeof(IPHeader));

                DropSeq = net_long(Header->tcp_seq);

                if (*(ushort *) & Param <= StatusTCB->tcb_mss &&
                    (SEQ_GTE(DropSeq, StatusTCB->tcb_senduna) &&
                     SEQ_LT(DropSeq, StatusTCB->tcb_sendnext))) {

                    // Need to initiate a retranmsit.
                    ResetSendNext(StatusTCB, DropSeq);
                    // Set the congestion window to allow only one packet.
                    // This may prevent us from sending anything if we
                    // didn't just set sendnext to senduna. This is OK,
                    // we'll retransmit later, or send when we get an ack.
                    StatusTCB->tcb_cwin = Param;
                    DelayAction(StatusTCB, NEED_OUTPUT);
                    PartitionDelayQProcessing(FALSE);
                }
                StatusTCB->tcb_mss =
                    (ushort) MIN(Param, (ulong) StatusTCB->tcb_remmss);


                ASSERT(StatusTCB->tcb_mss > 0);
                ValidateMSS(StatusTCB);

                //
                // Reset the Congestion Window if necessary
                //
                if (StatusTCB->tcb_cwin < StatusTCB->tcb_mss) {
                    StatusTCB->tcb_cwin = StatusTCB->tcb_mss;

                    //
                    // Make sure the slow start threshold is at least
                    // 2 segments
                    //
                    if (StatusTCB->tcb_ssthresh <
                        ((uint) StatusTCB->tcb_mss * 2)
                        ) {
                        StatusTCB->tcb_ssthresh = StatusTCB->tcb_mss * 2;
                    }
                }
                break;

                // Source quench. This will cause us to reinitiate our
                // slow start by resetting our congestion window and
                // adjusting our slow start threshold.
            case IP_SOURCE_QUENCH:

                //
                // Code is removed, since source quench messages can be
                // misused to cause DoS attack.
                //
                break;

            default:
                ASSERT(0);
                break;
            }

            CTEFreeLock(&StatusTCB->tcb_lock, TCBHandle);

        } else {
            // Couldn't find a matching TCB. Just free the lock and return.
        }

    } else if (StatusType == IP_RECONFIG_STATUS) {

        if (StatusCode == IP_RECONFIG_SECFLTR) {
            ControlSecurityFiltering(Param);
        }
    } else {
        uint NewMTU;

        // 'Hardware' or 'global' status. Figure out what to do.
        switch (StatusCode) {
        case IP_ADDR_DELETED:
            // Local address has gone away. OrigDest is the IPAddr which is
            // gone.

            //
            // Delete any security filters associated with this address
            //
            DeleteProtocolSecurityFilter(OrigDest, PROTOCOL_TCP);

            break;

        case IP_ADDR_ADDED:

            //
            // An address has materialized. OrigDest identifies the address.
            // Data is a handle to the IP configuration information for the
            // interface on which the address is instantiated.
            //
            AddProtocolSecurityFilter(OrigDest, PROTOCOL_TCP,
                                      (NDIS_HANDLE) Data);

            break;

        case IP_MTU_CHANGE:
            NewMTU = Param - sizeof(TCPHeader);
            TCBWalk(SetTCBMTU, &OrigDest, &OrigSrc, &NewMTU);
            break;
        default:
            ASSERT(0);
            break;
        }

    }
}

//* FillTCPHeader - Fill the TCP header in.
//
//  A utility routine to fill in the TCP header.
//
//  Input:  SendTCB         - TCB to fill from.
//          Header          - Header to fill into.
//
//  Returns: Nothing.
//
void
FillTCPHeader(TCB * SendTCB, TCPHeader * Header)
{
    ushort S;
    ulong L;

    Header->tcp_src = SendTCB->tcb_sport;
    Header->tcp_dest = SendTCB->tcb_dport;
    L = SendTCB->tcb_sendnext;
    Header->tcp_seq = net_long(L);
    L = SendTCB->tcb_rcvnext;
    Header->tcp_ack = net_long(L);
    Header->tcp_flags = 0x1050;
    Header->tcp_xsum = 0;
    Header->tcp_urgent = 0;

    if (SendTCB->tcb_tcpopts & TCP_FLAG_TS) {

        ulong *ts_opt;

        ts_opt = (ulong *)((uchar *) Header + 20);
        //ts_opt = ts_opt + sizeof(TCPHeader);

        *ts_opt++ = net_long(0x0101080A);
        *ts_opt++ = net_long(TCPTime);
        *ts_opt = net_long(SendTCB->tcb_tsrecent);

        // Now the header is 32 bytes!!
        Header->tcp_flags = 0x1080;

    }
    S = (ushort) (RcvWin(SendTCB) >> SendTCB->tcb_rcvwinscale);
    Header->tcp_window = net_short(S);

}

//* ClassifyPacket - Classifies packets for GPC flow.
//
//
//  Input:  SendTCB - TCB of data/control packet to classify.
//
//  Returns: Nothing.
//
void
ClassifyPacket(
    TCB *SendTCB
    )
{
#if GPC

    //
    // clear the precedence bits and get ready to be set
    // according to the service type
    //

    if (DisableUserTOSSetting)
        SendTCB->tcb_opt.ioi_tos &= TOS_MASK;

    if (SendTCB->tcb_rce && GPCcfInfo) {

        struct QosCfTransportInfo TransportInfo = {0, 0};
        GPC_STATUS status = STATUS_SUCCESS;
        GPC_IP_PATTERN Pattern;

        IF_TCPDBG(TCP_DEBUG_GPC)
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"TCPSend: Classifying packet TCP %x\n", SendTCB));

        Pattern.SrcAddr = SendTCB->tcb_saddr;
        Pattern.DstAddr = SendTCB->tcb_daddr;
        Pattern.ProtocolId = PROTOCOL_TCP;
        Pattern.gpcSrcPort = SendTCB->tcb_sport;
        Pattern.gpcDstPort = SendTCB->tcb_dport;
        if (SendTCB->tcb_GPCCachedRTE != (void *)SendTCB->tcb_rce->rce_rte) {

            //
            // first time we use this RTE, or it has been changed
            // since the last send
            //

            if (GetIFAndLink(SendTCB->tcb_rce, &SendTCB->tcb_GPCCachedIF,
                             (IPAddr *) & SendTCB->tcb_GPCCachedLink) ==
                             STATUS_SUCCESS) {

                SendTCB->tcb_GPCCachedRTE = (void *)SendTCB->tcb_rce->rce_rte;
            }
            //
            // invaludate the classification handle
            //

            SendTCB->tcb_opt.ioi_GPCHandle = 0;
        }
        Pattern.InterfaceId.InterfaceId = SendTCB->tcb_GPCCachedIF;
        Pattern.InterfaceId.LinkId = SendTCB->tcb_GPCCachedLink;

        IF_TCPDBG(TCP_DEBUG_GPC)
            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"TCPSend: IF=%x Link=%x\n",
                     Pattern.InterfaceId.InterfaceId,
                     Pattern.InterfaceId.LinkId));

        if (!SendTCB->tcb_opt.ioi_GPCHandle) {

            IF_TCPDBG(TCP_DEBUG_GPC)
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"TCPsend: Classification Handle is NULL, getting one now.\n"));

            status =
                GpcEntries.GpcClassifyPatternHandler(
                    (GPC_HANDLE)hGpcClient[GPC_CF_QOS],
                    GPC_PROTOCOL_TEMPLATE_IP,
                    &Pattern,
                    NULL,        // context
                    (PCLASSIFICATION_HANDLE)&SendTCB->tcb_opt.ioi_GPCHandle,
                    0,
                    NULL,
                    FALSE);

        }

        // Only if QOS patterns exist, we get the TOS bits out.
        if (NT_SUCCESS(status) && GpcCfCounts[GPC_CF_QOS]) {

            status =
                GpcEntries.GpcGetUlongFromCfInfoHandler(
                   (GPC_HANDLE) hGpcClient[GPC_CF_QOS],
                   SendTCB->tcb_opt.ioi_GPCHandle,
                   FIELD_OFFSET(CF_INFO_QOS, TransportInformation),
                   (PULONG)&TransportInfo);

            // It is likely that the pattern has gone by now
            // and the handle that we are caching is INVALID.
            // We need to pull up a new handle and get the
            // TOS bit again.
            if (STATUS_INVALID_HANDLE == status) {

                IF_TCPDBG(TCP_DEBUG_GPC)
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"TCPsend: Classification Handle is NULL, "
                             "getting one now.\n"));

                SendTCB->tcb_opt.ioi_GPCHandle = 0;

                status =
                    GpcEntries.GpcClassifyPatternHandler(
                        (GPC_HANDLE) hGpcClient[GPC_CF_QOS],
                        GPC_PROTOCOL_TEMPLATE_IP,
                        &Pattern,
                        NULL,        // context
                        (PCLASSIFICATION_HANDLE)&SendTCB->tcb_opt.ioi_GPCHandle,
                        0,
                        NULL,
                        FALSE);

                //
                // Only if QOS patterns exist, we get the TOS bits out.
                //
                if (NT_SUCCESS(status)) {

                    status =
                        GpcEntries.GpcGetUlongFromCfInfoHandler(
                           (GPC_HANDLE) hGpcClient[GPC_CF_QOS],
                           SendTCB->tcb_opt.ioi_GPCHandle,
                           FIELD_OFFSET(CF_INFO_QOS, TransportInformation),
                           (PULONG)&TransportInfo);
                }
            }

            //
            // Perhaps something needs to be done if GPC_CF_IPSEC has non-zero patterns.
            //

            //
            // Set the TOS bit now.
            //
            IF_TCPDBG(TCP_DEBUG_GPC)
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"TCPsend: ServiceType(%d)=%d\n", 
                          FIELD_OFFSET(CF_INFO_QOS, TransportInformation)));

            if (status == STATUS_SUCCESS) {

                //
                // Get the TOS value and the types of allowed offloads.
                //
                SendTCB->tcb_opt.ioi_tos |= TransportInfo.ToSValue;
                SendTCB->tcb_allowedoffloads = (USHORT)TransportInfo.AllowedOffloads;

                //
                // We are guaranteed for now that the other kind of offloads are 
                // never disabled, and hence, we won't check them on a per 
                // connection basis.
                //
                ASSERT((TransportInfo.AllowedOffloads | TCP_LARGE_SEND_OFFLOAD |
                       TCP_LARGE_SEND_TCPOPT_OFFLOAD | 
                       TCP_LARGE_SEND_IPOPT_OFFLOAD) == TCP_IP_OFFLOAD_TYPES);
            }

            IF_TCPDBG(TCP_DEBUG_GPC)
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"TCPsend: TOS set to 0x%x\n", 
                          SendTCB->tcb_opt.ioi_tos));
        }

    }
#endif

}

BOOLEAN
ProcessSend(TCB *SendTCB, SendCmpltContext *SCC, uint *pSendLength, uint AmtUnsent,
            TCPHeader *Header, int SendWin, PNDIS_BUFFER CurrentBuffer)
{
    TCPSendReq *CurSend = SCC->scc_firstsend;
    long Result;
    uint AmountLeft = *pSendLength;
    ulong PrevFlags;
    Queue *Next;
    SeqNum OldSeq;

    if (*pSendLength != 0) {

        do {

            BOOLEAN DirectSend = FALSE;
            ASSERT(CurSend->tsr_refcnt > 0);

            Result = CTEInterlockedIncrementLong(&(CurSend->tsr_refcnt));

            ASSERT(Result > 0);
            SCC->scc_count++;

            if (SendTCB->tcb_sendofs == 0 &&
                (SendTCB->tcb_sendsize <= AmountLeft) &&
                (SCC->scc_tbufcount == 0) &&
                (CurSend->tsr_lastbuf == NULL)) {

                ulong length = 0;
                PNDIS_BUFFER tmp = SendTCB->tcb_sendbuf;

                while (tmp) {
                    length += NdisBufferLength(tmp);
                    tmp = NDIS_BUFFER_LINKAGE(tmp);
                }

                // If the requested length is
                // more than in this mdl chain
                // we can use fast path

                if (AmountLeft >= length) {
                    DirectSend = TRUE;
                }
            }

            if (DirectSend) {

                NDIS_BUFFER_LINKAGE(CurrentBuffer) = SendTCB->tcb_sendbuf;

                do {
                    SCC->scc_ubufcount++;
                    CurrentBuffer =
                        NDIS_BUFFER_LINKAGE(CurrentBuffer);
                } while (NDIS_BUFFER_LINKAGE(CurrentBuffer) != NULL);


                CurSend->tsr_lastbuf = CurrentBuffer;
                AmountLeft -= SendTCB->tcb_sendsize;
                SendTCB->tcb_sendsize = 0;
            } else {

                uint AmountToDup;
                PNDIS_BUFFER NewBuf, Buf;
                uint Offset;
                NDIS_STATUS NStatus;
                uint Length;

                // Either the current send has more data than
                // or the offset is not zero.
                // In either case we'll need to loop
                // through the current send, allocating buffers.

                Buf = SendTCB->tcb_sendbuf;
                Offset = SendTCB->tcb_sendofs;

                do {
                    ASSERT(Buf != NULL);

                    Length = NdisBufferLength(Buf);

                    ASSERT((Offset < Length) ||
                             (Offset == 0 && Length == 0));

                    // Adjust the length for the offset into
                    // this buffer.

                    Length -= Offset;

                    AmountToDup = MIN(AmountLeft, Length);

                    NdisCopyBuffer(&NStatus, &NewBuf, TCPSendBufferPool, Buf,
                                   Offset, AmountToDup);

                    if (NStatus == NDIS_STATUS_SUCCESS) {

                        SCC->scc_tbufcount++;

                        NDIS_BUFFER_LINKAGE(CurrentBuffer) = NewBuf;

                        CurrentBuffer = NewBuf;

                        if (AmountToDup >= Length) {
                            // Exhausted this buffer.
                            Buf = NDIS_BUFFER_LINKAGE(Buf);
                            Offset = 0;
                        } else {
                            Offset += AmountToDup;
                            ASSERT(Offset < NdisBufferLength(Buf));

                        }

                        SendTCB->tcb_sendsize -= AmountToDup;
                        AmountLeft -= AmountToDup;
                    } else {
                        // Couldn't allocate a buffer. If
                        // the packet is already partly built,
                        // send what we've got, otherwise
                        // bail out.
                        if (SCC->scc_tbufcount == 0 &&
                            SCC->scc_ubufcount == 0) {
                            return FALSE;
                        }
                        *pSendLength -= AmountLeft;
                        AmountLeft = 0;
                    }

               } while (AmountLeft && SendTCB->tcb_sendsize);

               SendTCB->tcb_sendbuf = Buf;
               SendTCB->tcb_sendofs = Offset;
           }

           if (CurSend->tsr_flags & TSR_FLAG_URG) {
               ushort UP;
               // This send is urgent data. We need to figure
               // out what the urgent data pointer should be.
               // We know sendnext is the starting sequence
               // number of the frame, and that at the top of
               // this do loop sendnext identified a byte in
               // the CurSend at that time. We advanced CurSend
               // at the same rate we've decremented
               // AmountLeft (AmountToSend - AmountLeft ==
               // AmountBuilt), so sendnext +
               // (AmountToSend - AmountLeft) identifies a byte
               // in the current value of CurSend, and that
               // quantity plus tcb_sendsize is the sequence
               // number one beyond the current send.
               UP =
                    (ushort) (*pSendLength - AmountLeft) +
                    (ushort) SendTCB->tcb_sendsize -
                    ((SendTCB->tcb_flags & BSD_URGENT) ? 0 : 1);
               Header->tcp_urgent = net_short(UP);
               Header->tcp_flags |= TCP_FLAG_URG;
           }

           if (SendTCB->tcb_sendsize == 0) {

               // We've exhausted this send. Set the PUSH bit.

               Header->tcp_flags |= TCP_FLAG_PUSH;
               PrevFlags = CurSend->tsr_flags;
               Next = QNEXT(&CurSend->tsr_req.tr_q);
               if (Next != QEND(&SendTCB->tcb_sendq)) {
                   CurSend = STRUCT_OF(TCPSendReq,
                                       QSTRUCT(TCPReq, Next,
                                               tr_q), tsr_req);
                   CTEStructAssert(CurSend, tsr);
                   SendTCB->tcb_sendsize =
                       CurSend->tsr_unasize;
                   SendTCB->tcb_sendofs = CurSend->tsr_offset;
                   SendTCB->tcb_sendbuf = CurSend->tsr_buffer;
                   SendTCB->tcb_cursend = CurSend;

                   // Check the urgent flags. We can't combine
                   // new urgent data on to the end of old
                   // non-urgent data.
                   if ((PrevFlags & TSR_FLAG_URG) && !
                       (CurSend->tsr_flags & TSR_FLAG_URG))
                       break;
               } else {
                   ASSERT(AmountLeft == 0);
                   SendTCB->tcb_cursend = NULL;
                   SendTCB->tcb_sendbuf = NULL;
               }

           }
        } while (AmountLeft != 0);

    }


    // Update the sequence numbers, and start a RTT
    // measurement if needed.

    // Adjust for what we're really going to send.
    *pSendLength -= AmountLeft;

    OldSeq = SendTCB->tcb_sendnext;
    SendTCB->tcb_sendnext += *pSendLength;

    if (SEQ_EQ(OldSeq, SendTCB->tcb_sendmax)) {

        // We're sending entirely new data.
        // We can't advance sendmax once FIN_SENT is set.

        ASSERT(!(SendTCB->tcb_flags & FIN_SENT));

        SendTCB->tcb_sendmax = SendTCB->tcb_sendnext;

        // We've advanced sendmax, so we must be sending
        // some new data, so bump the outsegs counter.

        TCPSIncrementOutSegCount();

        if (SendTCB->tcb_rtt == 0) {
           // No RTT running, so start one.
            SendTCB->tcb_rtt = TCPTime;
            SendTCB->tcb_rttseq = OldSeq;
        }
    } else {

        // We have at least some retransmission.

        if ((SendTCB->tcb_sendmax - OldSeq) > 1) {
            TStats.ts_retranssegs++;
        }
        if (SEQ_GT(SendTCB->tcb_sendnext,
                   SendTCB->tcb_sendmax)) {
            // But we also have some new data, so check the rtt stuff.
            TCPSIncrementOutSegCount();
            ASSERT(!(SendTCB->tcb_flags & FIN_SENT));
            SendTCB->tcb_sendmax = SendTCB->tcb_sendnext;

            if (SendTCB->tcb_rtt == 0) {
                // No RTT running, so start one.
                SendTCB->tcb_rtt = TCPTime;
                SendTCB->tcb_rttseq = OldSeq;
            }
        }
    }

    // We've built the frame entirely. If we've send
    // everything we have and there is a FIN pending,
    // OR it in.

    if (AmtUnsent == *pSendLength) {
        if (SendTCB->tcb_flags & FIN_NEEDED) {
            ASSERT(!(SendTCB->tcb_flags & FIN_SENT) ||
                      (SendTCB->tcb_sendnext ==
                        (SendTCB->tcb_sendmax - 1)));
            // See if we still have room in the window for a FIN.
            if (SendWin > (int)*pSendLength) {
                Header->tcp_flags |= TCP_FLAG_FIN;
                SendTCB->tcb_sendnext++;
                SendTCB->tcb_sendmax =
                    SendTCB->tcb_sendnext;
                SendTCB->tcb_flags |=
                    (FIN_SENT | FIN_OUTSTANDING);
                SendTCB->tcb_flags &= ~FIN_NEEDED;
            }
        }
    }

    return TRUE;

}

//* TCPSend - Send data from a TCP connection.
//
//  This is the main 'send data' routine. We go into a loop, trying
//  to send data until we can't for some reason. First we compute
//  the useable window, use it to figure the amount we could send. If
//  the amount we could send meets certain criteria we'll build a frame
//  and send it, after setting any appropriate control bits. We assume
//  the caller has put a reference on the TCB.
//
//  Input:  SendTCB     - TCB to be sent from.
//          TCBHandle   - Lock handle for TCB.
//
//  Returns: Nothing.
//
void
TCPSend(TCB * SendTCB, CTELockHandle TCBHandle)
{
    int SendWin;                // Useable send window.
    uint AmountToSend;            // Amount to send this time.
    uint AmountLeft;
    TCPHeader *Header;            // TCP header for a send.
    PNDIS_BUFFER FirstBuffer, CurrentBuffer;
    TCPSendReq *CurSend;
    SendCmpltContext *SCC;
    SeqNum OldSeq;
    IP_STATUS SendStatus;
    uint AmtOutstanding, AmtUnsent;
    int ForceWin;                // Window we're force to use.
    BOOLEAN FullSegment;
    BOOLEAN MoreToSend = FALSE;
    uint SegmentsSent = 0;
    BOOLEAN LargeSendOffload = FALSE;
    BOOLEAN LargeSendFailed = FALSE;
    uint MSS;

    uint LargeSend, SentBytes;
    void *Irp;


    CTEStructAssert(SendTCB, tcb);
    ASSERT(SendTCB->tcb_refcnt != 0);

    ASSERT(*(int *)&SendTCB->tcb_sendwin >= 0);
    ASSERT(*(int *)&SendTCB->tcb_cwin >= SendTCB->tcb_mss);

    ASSERT(!(SendTCB->tcb_flags & FIN_OUTSTANDING) ||
              (SendTCB->tcb_sendnext == SendTCB->tcb_sendmax));

    if (!(SendTCB->tcb_flags & IN_TCP_SEND) &&
        !(SendTCB->tcb_fastchk & TCP_FLAG_IN_RCV)) {
        SendTCB->tcb_flags |= IN_TCP_SEND;

        // We'll continue this loop until we send a FIN, or we break out
        // internally for some other reason.

        while (!(SendTCB->tcb_flags & FIN_OUTSTANDING)) {

            CheckTCBSends(SendTCB);
            SegmentsSent++;

            if (SegmentsSent > MaxSendSegments) {

                // We are throttled by max segments that can be sent in
                // this loop. Comeback later

                MoreToSend = TRUE;
                break;
            }
            AmtOutstanding = (uint) (SendTCB->tcb_sendnext -
                                     SendTCB->tcb_senduna);
            AmtUnsent = SendTCB->tcb_unacked - AmtOutstanding;

            ASSERT(*(int *)&AmtUnsent >= 0);

            SendWin = (int)(MIN(SendTCB->tcb_sendwin, SendTCB->tcb_cwin) -
                            AmtOutstanding);

            // if this send is after the fast recovery
            // and sendwin is zero because of amt outstanding
            // then, at least force 1 segment to prevent delayed
            // ack timeouts from the remote

            if (SendTCB->tcb_force) {
                SendTCB->tcb_force = 0;
                if (SendWin < SendTCB->tcb_mss) {

                    SendWin = SendTCB->tcb_mss;
                }
            }
            // Since the window could have shrank, need to get it to zero at
            // least.
            ForceWin = (int)((SendTCB->tcb_flags & FORCE_OUTPUT) >>
                             FORCE_OUT_SHIFT);
            SendWin = MAX(SendWin, ForceWin);

            LargeSend = MIN((uint) SendWin, AmtUnsent);
            LargeSend = MIN(LargeSend, SendTCB->tcb_mss * MaxSendSegments);

            AmountToSend =
                MIN(MIN((uint) SendWin, AmtUnsent), SendTCB->tcb_mss);

            ASSERT(SendTCB->tcb_mss > 0);

            // Time stamp option addition might force us to cut the data
            // to be sent by 12 bytes.

            FullSegment = FALSE;

            if ((SendTCB->tcb_tcpopts & TCP_FLAG_TS) &&
                (AmountToSend + ALIGNED_TS_OPT_SIZE >= SendTCB->tcb_mss)) {
                AmountToSend = SendTCB->tcb_mss - ALIGNED_TS_OPT_SIZE;
                FullSegment = TRUE;
            } else {

                if (AmountToSend == SendTCB->tcb_mss)
                    FullSegment = TRUE;
            }


            // We will send a segment if
            //
            // 1. The segment size == mss
            // 2. This is the only segment to be sent
            // 3. FIN is set and this is the last segment
            // 4. FORCE_OUTPUT is set
            // 5. Amount to be sent is >= MSS/2

            if (FullSegment ||


                (AmountToSend != 0 && AmountToSend == AmtUnsent) ||
                (SendWin != 0 &&
                 (((SendTCB->tcb_flags & FIN_NEEDED) &&
                  (AmtUnsent <= SendTCB->tcb_mss)) ||
                  (SendTCB->tcb_flags & FORCE_OUTPUT) ||
                  AmountToSend >= (SendTCB->tcb_maxwin / 2)))) {

                  //
                  // Set MSS first.
                  //

                 if (SendTCB->tcb_tcpopts & TCP_FLAG_TS) {
                     MSS = SendTCB->tcb_mss - ALIGNED_TS_OPT_SIZE;
                 } else {
                     MSS = SendTCB->tcb_mss;
                 }
                // It's OK to send something. Try to get a header buffer now.
                FirstBuffer = GetTCPHeaderAtDpcLevel(&Header);
                if (FirstBuffer != NULL) {

                    // Got a header buffer. Loop through the sends on the TCB,
                    // building a frame.
                    CurrentBuffer = FirstBuffer;
                    CurSend = SendTCB->tcb_cursend;

                    Header =
                        (TCPHeader *)((PUCHAR)Header + LocalNetInfo.ipi_hsize);


                    // allow room for filling time stamp options (12 bytes)

                    if (SendTCB->tcb_tcpopts & TCP_FLAG_TS) {

                        NdisAdjustBufferLength(FirstBuffer,
                                               sizeof(TCPHeader) + ALIGNED_TS_OPT_SIZE);

                        SCC = (SendCmpltContext *) (Header + 1);
                        SCC = (SendCmpltContext *) ((uchar *) SCC + ALIGNED_TS_OPT_SIZE);

                    } else {

                        SCC = (SendCmpltContext *) (Header + 1);
                    }

                    SCC =  ALIGN_UP_POINTER(SCC, PVOID);
#if DBG
                    SCC->scc_sig = scc_signature;
#endif

                    FillTCPHeader(SendTCB, Header);

                    SCC->scc_ubufcount = 0;
                    SCC->scc_tbufcount = 0;
                    SCC->scc_count = 0;

                    SCC->scc_LargeSend = 0;

                    // Check if RCE has large send capability and, if so,
                    // attempt to offload segmentation to the hardware.
                    // * only offload if there is more than 1 segment's worth
                    //   of data.
                    // * only offload if the number of segments is greater than
                    //   the minimum number of segments the adapter is willing
                    //   to offload.
                    // * only offload if it is allowed by all the entities of
                    //   known classification families. 
                    // * ( i.e. if TCP or IP options need to be 
                    //   offloaded, we only offload if the adapter supports it)
                    //

                    if (!DisableLargeSendOffload &&
                        SendTCB->tcb_rce &&
                        (SendTCB->tcb_rce->rce_OffloadFlags &
                            TCP_LARGE_SEND_OFFLOAD) &&
                        (SendTCB->tcb_allowedoffloads & 
                            TCP_LARGE_SEND_OFFLOAD) &&
                        (!(SendTCB->tcb_tcpopts & TCP_FLAG_TS) ||
                         (SendTCB->tcb_rce->rce_OffloadFlags &
                             TCP_LARGE_SEND_TCPOPT_OFFLOAD)) &&
                        (!SendTCB->tcb_opt.ioi_options ||
                         (SendTCB->tcb_rce->rce_OffloadFlags &
                             TCP_LARGE_SEND_IPOPT_OFFLOAD)) &&
                        !LargeSendFailed &&
                        (MSS < LargeSend) &&
                        (CurSend && (CurSend->tsr_lastbuf == NULL)) && !(CurSend->tsr_flags & TSR_FLAG_URG)) {

                        uint PartialSegment; 
                        LargeSendOffload = TRUE;
                        LargeSend =
                            MIN(SendTCB->tcb_rce->rce_TcpLargeSend.MaxOffLoadSize,
                                LargeSend);
                        //
                        // Adjust LargeSend to make LSO path
                        // conform sender side silly window avoidance:
                        // 1) it is multiple of MSS
                        // 2) We are sending out everything we have
                        // 3) FORCE_OUTPUT is set
                        // 4) Amount to be sent is >= maximum window size /2
                        //

                        PartialSegment = LargeSend % MSS;
                        if ((PartialSegment != 0) &&
                            (LargeSend != AmtUnsent) &&
                            (!(SendTCB->tcb_flags & FORCE_OUTPUT)) &&
                            (PartialSegment < (SendTCB->tcb_maxwin / 2))) {
                            LargeSend -= PartialSegment;
                        }
                        
                        //
                        // Offload only if the segments we have is greater than 
                        // the minimum segment requirement of the NIC.
                        //

                        if (SendTCB->tcb_rce->rce_TcpLargeSend.MinSegmentCount >
                            (LargeSend + MSS - 1) / MSS ) {
                            LargeSendOffload = FALSE;
                        }
                       
                        //
                        // LargeSend can not be zero.
                        //

                        if (LargeSend == 0) {
                            LargeSendOffload = FALSE;
                        }
                    } else {
                        LargeSendOffload = FALSE;
                    }

                    if (LargeSendOffload) {

                        IF_TCPDBG(TCP_DEBUG_OFFLOAD) {
                            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"TCPSend: tcb %x offload %d bytes at "
                                     "seq %u ack %u win %u\n",
                                     SendTCB, LargeSend, SendTCB->tcb_sendnext,
                                     SendTCB->tcb_rcvnext, SendWin));
                        }


                        OldSeq = SendTCB->tcb_sendnext;

                        CTEStructAssert(CurSend, tsr);
                        SCC->scc_firstsend = CurSend;

                        if (!ProcessSend(SendTCB, SCC, &LargeSend, AmtUnsent, Header,
                                         SendWin, CurrentBuffer)) {
                           goto error_oor1;
                        }

                        {
                            uint PHXsum = SendTCB->tcb_phxsum;
                            PHXsum = (((PHXsum << 16) | (PHXsum >> 16)) +
                                PHXsum) >> 16;
                            Header->tcp_xsum = (ushort) PHXsum;
                        }


                        SCC->scc_SendSize = LargeSend;
                        SCC->scc_ByteSent = 0;
                        SCC->scc_LargeSend = SendTCB;
                        REFERENCE_TCB(SendTCB);
#if DBG
                        SendTCB->tcb_LargeSend++;
#endif
                        SendTCB->tcb_rcvdsegs = 0;

                        if (SendTCB->tcb_tcpopts & TCP_FLAG_TS) {
                            LargeSend +=
                                sizeof(TCPHeader) + ALIGNED_TS_OPT_SIZE;
                        } else {
                            LargeSend += sizeof(TCPHeader);
                        }

                        IF_TCPDBG(TCP_DEBUG_OFFLOAD) {
                            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"TCPSend: tcb %x large-send %d seq %u\n",
                                     SendTCB, LargeSend, OldSeq));
                        }

                        ClassifyPacket(SendTCB);

                        CTEFreeLock(&SendTCB->tcb_lock, TCBHandle);

                        SendStatus =
                            (*LocalNetInfo.ipi_largexmit)(TCPProtInfo, SCC,
                                                          FirstBuffer,
                                                          LargeSend,
                                                          SendTCB->tcb_daddr,
                                                          SendTCB->tcb_saddr,
                                                          &SendTCB->tcb_opt,
                                                          SendTCB->tcb_rce,
                                                          PROTOCOL_TCP,
                                                          &SentBytes,
                                                          MSS);

                        SendTCB->tcb_error = SendStatus;

                        if (SendStatus != IP_PENDING) {

                            // Let TCPSendComplete hanlde partial sends

                            SCC->scc_ByteSent = SentBytes;
                            TCPSendComplete(SCC, FirstBuffer, IP_SUCCESS);

                        }

                        CTEGetLock(&SendTCB->tcb_lock, &TCBHandle);

                        if (SendStatus == IP_GENERAL_FAILURE) {

                            if (SEQ_GTE(OldSeq, SendTCB->tcb_senduna) &&
                                SEQ_LT(OldSeq, SendTCB->tcb_sendnext)) {

                                ResetSendNext(SendTCB, OldSeq);
                            }
                            LargeSendFailed = TRUE;
                            continue;
                        }

                        if (SendStatus == IP_PACKET_TOO_BIG) {
                            SeqNum NewSeq = OldSeq + SentBytes;
                            //Not everything got sent.
                            //Adjust for what is sent
                            if (SEQ_GTE(NewSeq, SendTCB->tcb_senduna) &&
                                SEQ_LT(NewSeq, SendTCB->tcb_sendnext)) {
                                ResetSendNext(SendTCB, NewSeq);

                            }
                        }
                        if (!TCB_TIMER_RUNNING_R(SendTCB, RXMIT_TIMER)) {

                            START_TCB_TIMER_R(SendTCB, RXMIT_TIMER, SendTCB->tcb_rexmit);
                        }
                        SendTCB->tcb_flags &= ~(IN_TCP_SEND | NEED_OUTPUT |
                                                FORCE_OUTPUT | SEND_AFTER_RCV);

                        DerefTCB(SendTCB, TCBHandle);
                        return;

                    }

                    // Normal path

                    AmountLeft = AmountToSend;

                    if (AmountToSend != 0) {
                        CTEStructAssert(CurSend, tsr);
                        SCC->scc_firstsend = CurSend;
                    } else {

                        // We're in the loop, but AmountToSend is 0. This
                        // should happen only when we're sending a FIN. Check
                        // this, and return if it's not true.
                        ASSERT(AmtUnsent == 0);
                        if (!(SendTCB->tcb_flags & FIN_NEEDED)) {
                            FreeTCPHeader(FirstBuffer);
                            break;
                        }
                        SCC->scc_firstsend = NULL;
                        NDIS_BUFFER_LINKAGE(FirstBuffer) = NULL;
                    }

                    OldSeq = SendTCB->tcb_sendnext;

                    if (!ProcessSend(SendTCB, SCC, &AmountToSend, AmtUnsent, Header,
                                     SendWin, CurrentBuffer)) {
                        goto error_oor1;
                    }

                    AmountToSend += sizeof(TCPHeader);


                    SendTCB->tcb_flags &= ~(NEED_ACK | ACK_DELAYED |
                                            FORCE_OUTPUT);
                    STOP_TCB_TIMER_R(SendTCB, DELACK_TIMER);
                    STOP_TCB_TIMER_R(SendTCB, SWS_TIMER);
                    SendTCB->tcb_rcvdsegs = 0;

                    if ( (SendTCB->tcb_flags & KEEPALIVE) && ( SendTCB->tcb_conn != NULL) )
                        START_TCB_TIMER_R(SendTCB, KA_TIMER, SendTCB->tcb_conn->tc_tcbkatime);
                    SendTCB->tcb_kacount = 0;

                    // We're all set. Xsum it and send it.
                    ClassifyPacket(SendTCB);

                    // Account for time stamp options
                    if (SendTCB->tcb_tcpopts & TCP_FLAG_TS) {

                        if (SendTCB->tcb_rce &&
                            (SendTCB->tcb_rce->rce_OffloadFlags &
                                TCP_XMT_CHECKSUM_OFFLOAD) &&
                            (SendTCB->tcb_rce->rce_OffloadFlags &
                                TCP_CHECKSUM_OPT_OFFLOAD)) {
                            uint PHXsum =
                                SendTCB->tcb_phxsum +
                                (uint)net_short(AmountToSend + ALIGNED_TS_OPT_SIZE);

                            PHXsum = (((PHXsum << 16) | (PHXsum >> 16)) +
                                      PHXsum) >> 16;
                            Header->tcp_xsum = (ushort) PHXsum;
                            SendTCB->tcb_opt.ioi_TcpChksum = 1;
#if DBG
                            DbgTcpSendHwChksumCount++;
#endif
                        } else {

                            Header->tcp_xsum =
                                ~XsumSendChain(
                                    SendTCB->tcb_phxsum +
                                    (uint)net_short(AmountToSend + ALIGNED_TS_OPT_SIZE),
                                    FirstBuffer);

                            SendTCB->tcb_opt.ioi_TcpChksum = 0;
                        }



                        CTEFreeLock(&SendTCB->tcb_lock, TCBHandle);

                        Irp = NULL;
                        if (SCC->scc_firstsend) {
                            Irp = SCC->scc_firstsend->tsr_req.tr_context;
                        }

                        SendStatus =
                            (*LocalNetInfo.ipi_xmit)(TCPProtInfo, SCC,
                                                     FirstBuffer,
                                                     AmountToSend +
                                                     ALIGNED_TS_OPT_SIZE,
                                                     SendTCB->tcb_daddr,
                                                     SendTCB->tcb_saddr,
                                                     &SendTCB->tcb_opt,
                                                     SendTCB->tcb_rce,
                                                     PROTOCOL_TCP,
                                                     Irp );

                    } else {

                        if (SendTCB->tcb_rce &&
                            (SendTCB->tcb_rce->rce_OffloadFlags &
                                TCP_XMT_CHECKSUM_OFFLOAD)) {
                            uint PHXsum = SendTCB->tcb_phxsum +
                                          (uint)net_short(AmountToSend);

                            PHXsum = (((PHXsum << 16) | (PHXsum >> 16)) +
                                      PHXsum) >> 16;

                            Header->tcp_xsum = (ushort) PHXsum;
                            SendTCB->tcb_opt.ioi_TcpChksum = 1;
#if DBG
                            DbgTcpSendHwChksumCount++;
#endif
                        } else {
                            Header->tcp_xsum =
                                ~XsumSendChain(SendTCB->tcb_phxsum +
                                               (uint)net_short(AmountToSend),
                                               FirstBuffer);
                            SendTCB->tcb_opt.ioi_TcpChksum = 0;
                        }

                        CTEFreeLock(&SendTCB->tcb_lock, TCBHandle);

                        Irp = NULL;
                        if(SCC->scc_firstsend) {
                           Irp = SCC->scc_firstsend->tsr_req.tr_context;
                        }

                        SendStatus =
                            (*LocalNetInfo.ipi_xmit)(TCPProtInfo,
                                                     SCC,
                                                     FirstBuffer,
                                                     AmountToSend,
                                                     SendTCB->tcb_daddr,
                                                     SendTCB->tcb_saddr,
                                                     &SendTCB->tcb_opt,
                                                     SendTCB->tcb_rce,
                                                     PROTOCOL_TCP,
                                                     Irp );

                    }

                    SendTCB->tcb_error = SendStatus;

                    if (SendStatus != IP_PENDING) {

                        TCPSendComplete(SCC, FirstBuffer, IP_SUCCESS);
                        if (SendStatus != IP_SUCCESS) {
                            CTEGetLock(&SendTCB->tcb_lock, &TCBHandle);
                            // This packet didn't get sent. If nothing's
                            // changed in the TCB, put sendnext back to
                            // what we just tried to send. Depending on
                            // the error, we may try again.
                            if (SEQ_GTE(OldSeq, SendTCB->tcb_senduna) &&
                                SEQ_LT(OldSeq, SendTCB->tcb_sendnext))
                                ResetSendNext(SendTCB, OldSeq);

                            // We know this packet didn't get sent. Start
                            // the retransmit timer now, if it's not already
                            // runnimg, in case someone came in while we
                            // were in IP and stopped it.
                            if (!TCB_TIMER_RUNNING_R(SendTCB, RXMIT_TIMER)) {
                                START_TCB_TIMER_R(SendTCB, RXMIT_TIMER, SendTCB->tcb_rexmit);
                            }
                            // If it failed because of an MTU problem, get
                            // the new MTU and try again.
                            if (SendStatus == IP_PACKET_TOO_BIG) {
                                uint NewMTU;

                                // The MTU has changed. Update it, and try
                                // again.
                                // if ipsec is adjusting the mtu, rce_newmtu
                                // will contain the newmtu.
                                if (SendTCB->tcb_rce) {

                                    if (!SendTCB->tcb_rce->rce_newmtu) {

                                        SendStatus =
                                            (*LocalNetInfo.ipi_getpinfo)(
                                                SendTCB->tcb_daddr,
                                                SendTCB->tcb_saddr,
                                                &NewMTU,
                                                NULL,
                                                SendTCB->tcb_rce);
                                    } else {
                                        NewMTU = SendTCB->tcb_rce->rce_newmtu;
                                        SendStatus = IP_SUCCESS;
                                    }

                                } else {
                                    SendStatus =
                                        (*LocalNetInfo.ipi_getpinfo)(
                                            SendTCB->tcb_daddr,
                                            SendTCB->tcb_saddr,
                                            &NewMTU,
                                            NULL,
                                            SendTCB->tcb_rce);

                                }

                                if (SendStatus != IP_SUCCESS)
                                    break;

                                // We have a new MTU. Make sure it's big enough
                                // to use. If not, correct this and turn off
                                // MTU discovery on this TCB. Otherwise use the
                                // new MTU.
                                if (NewMTU <=
                                    (sizeof(TCPHeader) +
                                     SendTCB->tcb_opt.ioi_optlength)) {

                                    // The new MTU is too small to use. Turn off
                                    // PMTU discovery on this TCB, and drop to
                                    // our off net MTU size.
                                    SendTCB->tcb_opt.ioi_flags &= ~IP_FLAG_DF;
                                    SendTCB->tcb_mss =
                                        MIN((ushort)MAX_REMOTE_MSS,
                                            SendTCB->tcb_remmss);
                                } else {

                                    // The new MTU is adequate. Adjust it for
                                    // the header size and options length, and
                                    // use it.
                                    NewMTU -= sizeof(TCPHeader) -
                                        SendTCB->tcb_opt.ioi_optlength;
                                    SendTCB->tcb_mss =
                                        MIN((ushort) NewMTU,
                                            SendTCB->tcb_remmss);
                                }

                                ASSERT(SendTCB->tcb_mss > 0);
                                ValidateMSS(SendTCB);

                                continue;
                            }
                            break;
                        }
                    }
                    //Start it now, since we know that mac driver accepted it.

                    CTEGetLock(&SendTCB->tcb_lock, &TCBHandle);
                    if (!TCB_TIMER_RUNNING_R(SendTCB, RXMIT_TIMER)) {

                        START_TCB_TIMER_R(SendTCB, RXMIT_TIMER, SendTCB->tcb_rexmit);
                    }
                    continue;
                } else            // FirstBuffer != NULL.

                    goto error_oor;
            } else {
                // We've decided we can't send anything now. Figure out why, and
                // see if we need to set a timer.
                if (SendTCB->tcb_sendwin == 0) {
                    if (!(SendTCB->tcb_flags & FLOW_CNTLD)) {
                        ushort tmp;

                        SendTCB->tcb_flags |= FLOW_CNTLD;

                        SendTCB->tcb_rexmitcnt = 0;

                        tmp = MIN(MAX(REXMIT_TO(SendTCB),
                                      MIN_RETRAN_TICKS), MAX_REXMIT_TO);

                        START_TCB_TIMER_R(SendTCB, RXMIT_TIMER, tmp);
                        SendTCB->tcb_slowcount++;
                        SendTCB->tcb_fastchk |= TCP_FLAG_SLOW;
                    } else if (!TCB_TIMER_RUNNING_R(SendTCB, RXMIT_TIMER))
                        START_TCB_TIMER_R(SendTCB, RXMIT_TIMER, SendTCB->tcb_rexmit);
                } else if (AmountToSend != 0)
                    // We have something to send, but we're not sending
                    // it, presumably due to SWS avoidance.
                    if (!TCB_TIMER_RUNNING_R(SendTCB, SWS_TIMER))
                        START_TCB_TIMER_R(SendTCB, SWS_TIMER, SWS_TO);

                break;
            }

        }                        // while (!FIN_OUTSTANDING)

        // We're done sending, so we don't need the output flags set.

        SendTCB->tcb_flags &= ~(IN_TCP_SEND | NEED_OUTPUT | FORCE_OUTPUT |
                                SEND_AFTER_RCV);

        if (MoreToSend) {
            //just indicate that we need to send more
            DelayAction(SendTCB, NEED_OUTPUT);
            PartitionDelayQProcessing(FALSE);
        }
        // This is for TS algo
        SendTCB->tcb_lastack = SendTCB->tcb_rcvnext;

    } else
        SendTCB->tcb_flags |= SEND_AFTER_RCV;

    DerefTCB(SendTCB, TCBHandle);
    return;

    // Common case error handling code for out of resource conditions. Start the
    // retransmit timer if it's not already running (so that we try this again
    // later), clean up and return.
  error_oor:
    if (!TCB_TIMER_RUNNING_R(SendTCB, RXMIT_TIMER)) {
        ushort tmp;

        tmp = MIN(MAX(REXMIT_TO(SendTCB),
                      MIN_RETRAN_TICKS), MAX_REXMIT_TO);

        START_TCB_TIMER_R(SendTCB, RXMIT_TIMER, tmp);
    }
    // We had an out of resource problem, so clear the OUTPUT flags.
    SendTCB->tcb_flags &= ~(IN_TCP_SEND | NEED_OUTPUT | FORCE_OUTPUT);
    DerefTCB(SendTCB, TCBHandle);
    return;

  error_oor1:
    if (!TCB_TIMER_RUNNING_R(SendTCB, RXMIT_TIMER)) {
        ushort tmp;

        tmp = MIN(MAX(REXMIT_TO(SendTCB),
                      MIN_RETRAN_TICKS), MAX_REXMIT_TO);

        START_TCB_TIMER_R(SendTCB, RXMIT_TIMER, tmp);
    }
    // We had an out of resource problem, so clear the OUTPUT flags.
    SendTCB->tcb_flags &= ~(IN_TCP_SEND | NEED_OUTPUT | FORCE_OUTPUT);
    DerefTCB(SendTCB, TCBHandle);
    TCPSendComplete(SCC, FirstBuffer, IP_SUCCESS);

    return;

}

//* ResetSendNextAndFastSend - Set the sendnext value of a TCB.
//
//  Called to handle fast retransmit of the segment which the reveiver
//  is asking for.
//  We assume the caller has put a reference on the TCB, and the TCB is locked
//  on entry. The reference is dropped and the lock released before returning.
//
//  Input:  SeqTCB                  - Pointer to TCB to be updated.
//          NewSeq                  - Sequence number to set.
//          NewCWin                 - new value for congestion window.
//
//  Returns: Nothing.
//
void
ResetAndFastSend(TCB * SeqTCB, SeqNum NewSeq, uint NewCWin)
{
    TCPSendReq      *SendReq;
    uint            AmtForward;
    Queue           *CurQ;
    PNDIS_BUFFER    Buffer;
    uint            Offset;
    uint            SendSize;
    CTELockHandle   TCBHandle;
    int             ToBeSent;

    CTEStructAssert(SeqTCB, tcb);
    ASSERT(SEQ_GTE(NewSeq, SeqTCB->tcb_senduna));

    // The new seq must be less than send max, or NewSeq, senduna, sendnext,
    // and sendmax must all be equal. (The latter case happens when we're
    // called exiting TIME_WAIT, or possibly when we're retransmitting
    // during a flow controlled situation).

    ASSERT(SEQ_LT(NewSeq, SeqTCB->tcb_sendmax) ||
           (SEQ_EQ(SeqTCB->tcb_senduna, SeqTCB->tcb_sendnext) &&
            SEQ_EQ(SeqTCB->tcb_senduna, SeqTCB->tcb_sendmax) &&
            SEQ_EQ(SeqTCB->tcb_senduna, NewSeq)));

    if (SYNC_STATE(SeqTCB->tcb_state) && SeqTCB->tcb_state != TCB_TIME_WAIT) {
        // In these states we need to update the send queue.

        if (!EMPTYQ(&SeqTCB->tcb_sendq)) {

            // Stop the retransmit timer only if we are sure there are going
            // to be retransmissions.
            STOP_TCB_TIMER_R(SeqTCB, RXMIT_TIMER);
            SeqTCB->tcb_rtt = 0;

            CurQ = QHEAD(&SeqTCB->tcb_sendq);

            SendReq = (TCPSendReq *) STRUCT_OF(TCPReq, CurQ, tr_q);

            // SendReq points to the first send request on the send queue.
            // We're pointing at the proper send req now. We need to go down

            // SendReq points to the cursend
            // SendSize point to sendsize in the cursend

            SendSize = SendReq->tsr_unasize;

            Buffer = SendReq->tsr_buffer;
            Offset = SendReq->tsr_offset;

            // Call the fast retransmit send now

            if ((SeqTCB->tcb_tcpopts & TCP_FLAG_SACK)) {
                SackListEntry   *Prev, *Current;
                SeqNum          CurBegin = 0, CurEnd;
                BOOLEAN         UseSackList = TRUE;

                Prev = STRUCT_OF(SackListEntry, &SeqTCB->tcb_SackRcvd, next);
                Current = Prev->next;

                // There is a hole from Newseq to Currentbeg
                // try to retransmit whole hole size!!

                if (Current && SEQ_LT(NewSeq, Current->begin)) {
                    ToBeSent = Current->begin - NewSeq;
                    CurBegin = Current->begin;
                    CurEnd = Current->end;
                } else {
                    UseSackList = FALSE;
                    ToBeSent = SeqTCB->tcb_mss;
                }

                IF_TCPDBG(TCP_DEBUG_SACK) {
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                               "In Sack Reset and send rexmiting %d %d\n",
                               NewSeq, SendSize));
                }

                TCPFastSend(SeqTCB, Buffer, Offset, SendReq, SendSize, NewSeq,
                            ToBeSent);

                // If we have not been already acked for the missing segments
                // and if we know where to start retransmitting do so now.
                // Also, re-validate SackListentry

                Prev = STRUCT_OF(SackListEntry, &SeqTCB->tcb_SackRcvd, next);
                Current = Prev->next;

                if (!UseSackList || (Current && Current->begin != CurBegin)) {
                    // The SACK list changed while we were in a transmission.
                    // Just bail out, and wait for the next ACK to continue
                    // if necessary.
                    Current = NULL;
                }

                while (Current && Current->next &&
                       (SEQ_GTE(NewSeq, SeqTCB->tcb_senduna)) &&
                       (SEQ_LT(SeqTCB->tcb_senduna, Current->next->end))) {

                    SeqNum NextSeq;

                    ASSERT(SEQ_LTE(Current->begin, Current->end));

                    // There can be multiple dropped packets till
                    // Current->begin.

                    IF_TCPDBG(TCP_DEBUG_SACK) {
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                                   "Scanning after Current %d %d\n",
                                   Current->begin, Current->end));
                    }

                    NextSeq = Current->end;
                    CurBegin = Current->begin;

                    ASSERT(SEQ_LT(NextSeq, SeqTCB->tcb_sendmax));

                    // If we have not yet sent the segment keep quiet now.

                    if (SEQ_GTE(NextSeq, SeqTCB->tcb_sendnext) ||
                        (SEQ_LTE(NextSeq, SeqTCB->tcb_senduna))) {

                        break;
                    }

                    // Position cursend by following number of bytes

                    AmtForward = NextSeq - NewSeq;

                    if (!EMPTYQ(&SeqTCB->tcb_sendq)) {
                        CurQ = QHEAD(&SeqTCB->tcb_sendq);
                        SendReq = (TCPSendReq *) STRUCT_OF(TCPReq, CurQ, tr_q);
                        while (AmtForward) {
                            if (AmtForward >= SendReq->tsr_unasize) {
                                AmtForward -= SendReq->tsr_unasize;
                                CurQ = QNEXT(CurQ);
                                SendReq =
                                    (TCPSendReq *)STRUCT_OF(TCPReq, CurQ, tr_q);
                                ASSERT(CurQ != QEND(&SeqTCB->tcb_sendq));
                            } else {
                                break;
                            }
                        }

                        SendSize = SendReq->tsr_unasize - AmtForward;
                        Buffer = SendReq->tsr_buffer;
                        Offset = SendReq->tsr_offset;
                        while (AmtForward) {
                            uint Length;
                            ASSERT((Offset < NdisBufferLength(Buffer)) ||
                                   ((Offset == 0) &&
                                   (NdisBufferLength(Buffer) == 0)));

                            Length = NdisBufferLength(Buffer) - Offset;
                            if (AmtForward >= Length) {
                                // We're moving past this one. Skip over him,
                                // and 0 the Offset we're keeping.

                                AmtForward -= Length;
                                Offset = 0;
                                Buffer = NDIS_BUFFER_LINKAGE(Buffer);
                                ASSERT(Buffer != NULL);
                            } else {
                                break;
                            }

                        }

                        Offset = Offset + AmtForward;

                        // Okay. Now retransmit this seq too.

                        if (Current->next) {
                            ToBeSent = Current->next->begin - Current->end;

                        } else {
                            ToBeSent = SeqTCB->tcb_mss;
                        }

                        IF_TCPDBG(TCP_DEBUG_SACK) {
                            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                                       "SACK inner loop rexmiting %d %d %d\n",
                                       Current->end, SendSize, ToBeSent));
                        }

                        TCPFastSend(SeqTCB, Buffer, Offset, SendReq, SendSize,
                                    NextSeq, ToBeSent);
                    } else {
                        break;
                    }


                    // Also, re-validate Current Sack list in SackListentry

                    Prev =
                        STRUCT_OF(SackListEntry, &SeqTCB->tcb_SackRcvd, next);
                    Current = Prev->next;

                    while (Current && Current->begin != CurBegin) {
                        // The SACK list changed while in TCPFastSend.
                        // Just bail out.
                        Current = Current->next;
                    }

                    if (Current) {
                        Current = Current->next;
                    } else {
                        break;
                    }
                }
            } else {
                ToBeSent = SeqTCB->tcb_mss;

                TCPFastSend(SeqTCB, Buffer, Offset, SendReq, SendSize, NewSeq,
                            ToBeSent);
            }
        } else {
            ASSERT(SeqTCB->tcb_cursend == NULL);
        }
    }
    SeqTCB->tcb_cwin = NewCWin;

    // Make sure there is nothing outstanding or the retransmit timer is
    // running or we are in the process of sending a segment (and yet to
    // start the timer).
    ASSERT((SeqTCB->tcb_sendnext == SeqTCB->tcb_senduna) ||
           TCB_TIMER_RUNNING_R(SeqTCB, RXMIT_TIMER) ||
           (SeqTCB->tcb_flags & IN_TCP_SEND));

    TCBHandle = DISPATCH_LEVEL;
    DerefTCB(SeqTCB, TCBHandle);
    return;
}

//* TCPFastSend - To send a segment without changing TCB state
//
//  Called to handle fast retransmit of the segment
//  tcb_lock will be held while entering (called by TCPRcv)
//
//  Input:  SendTCB        - Pointer to TCB
//          in_sendBuf     - Pointer to ndis_buffer
//          in_sendofs     - Send Offset
//          in_sendreq     - current send request
//          in_sendsize    - size of this send
//
//  Returns: Nothing.
//

void
TCPFastSend(TCB * SendTCB, PNDIS_BUFFER in_SendBuf, uint in_SendOfs,
            TCPSendReq * in_SendReq, uint in_SendSize, SeqNum NextSeq,
            int in_ToBeSent)
{
    uint AmountToSend;            // Amount to send this time.
    uint AmountLeft;
    TCPHeader *Header;            // TCP header for a send.
    PNDIS_BUFFER FirstBuffer, CurrentBuffer;
    TCPSendReq *CurSend;
    SendCmpltContext *SCC;
    SeqNum OldSeq;
    SeqNum SendNext;
    IP_STATUS SendStatus;
    uint AmtOutstanding, AmtUnsent;
    CTELockHandle TCBHandle;
    void *Irp;
    uint TSLen=0;

    uint SendOfs = in_SendOfs;
    uint SendSize = in_SendSize;

    PNDIS_BUFFER SendBuf = in_SendBuf;

    SendNext = NextSeq;
    CurSend = in_SendReq;

    TCBHandle = DISPATCH_LEVEL;

    CTEStructAssert(SendTCB, tcb);
    ASSERT(SendTCB->tcb_refcnt != 0);

    ASSERT(*(int *)&SendTCB->tcb_sendwin >= 0);
    ASSERT(*(int *)&SendTCB->tcb_cwin >= SendTCB->tcb_mss);

    ASSERT(!(SendTCB->tcb_flags & FIN_OUTSTANDING) ||
              (SendTCB->tcb_sendnext == SendTCB->tcb_sendmax));

    AmtOutstanding = (uint) (SendTCB->tcb_sendnext -
                             SendTCB->tcb_senduna);


    AmtUnsent = MIN(MIN(in_ToBeSent, (int)SendSize), (int)SendTCB->tcb_sendwin);

    while (AmtUnsent > 0) {

        if (SEQ_GT(SendTCB->tcb_senduna, SendNext)) {

            // Since tcb_lock is releasd in this loop
            // it is possible that delayed ack acked
            // what we are trying to retransmit.

            goto error_oor;
        }
        //This was minimum of sendwin and amtunsent

        AmountToSend = MIN(AmtUnsent, SendTCB->tcb_mss);

        // Time stamp option addition might force us to cut the data
        // to be sent by 12 bytes.

        if ((SendTCB->tcb_tcpopts & TCP_FLAG_TS) &&
            (AmountToSend + ALIGNED_TS_OPT_SIZE >= SendTCB->tcb_mss)) {
            AmountToSend -= ALIGNED_TS_OPT_SIZE;
        }

        // See if we have enough to send. We'll send if we have at least a
        // segment, or if we really have some data to send and we can send
        // all that we have, or the send window is > 0 and we need to force
        // output or send a FIN (note that if we need to force output
        // SendWin will be at least 1 from the check above), or if we can
        // send an amount == to at least half the maximum send window
        // we've seen.

        ASSERT((int)AmtUnsent >= 0);

        // It's OK to send something. Try to get a header buffer now.
        // Mark the TCB for debugging.
        // This should be removed for shipping version.

        FirstBuffer = GetTCPHeaderAtDpcLevel(&Header);

        if (FirstBuffer != NULL) {

            // Got a header buffer. Loop through the sends on the TCB,
            // building a frame.

            CurrentBuffer = FirstBuffer;

            Header = (TCPHeader *) ((PUCHAR)Header + LocalNetInfo.ipi_hsize);

            // allow room for filling time stamp options.

            if (SendTCB->tcb_tcpopts & TCP_FLAG_TS) {

                // Account for time stamp options

                TSLen = ALIGNED_TS_OPT_SIZE;

                NdisAdjustBufferLength(FirstBuffer,
                                       sizeof(TCPHeader) + ALIGNED_TS_OPT_SIZE);

                SCC = ALIGN_UP_POINTER((SendCmpltContext *) (Header + 1),PVOID);
                SCC = (SendCmpltContext *)((uchar *) SCC + ALIGNED_TS_OPT_SIZE);

            } else {

                SCC = (SendCmpltContext *) (Header + 1);

            }

            SCC =  ALIGN_UP_POINTER(SCC, PVOID);
#if DBG
            SCC->scc_sig = scc_signature;
#endif

            FillTCPHeader(SendTCB, Header);
            {
                ulong L = SendNext;
                Header->tcp_seq = net_long(L);

            }

            SCC->scc_ubufcount = 0;
            SCC->scc_tbufcount = 0;
            SCC->scc_count = 0;
            SCC->scc_LargeSend = 0;

            AmountLeft = AmountToSend;

            if (AmountToSend != 0) {

                long Result;

                CTEStructAssert(CurSend, tsr);
                SCC->scc_firstsend = CurSend;

                do {

                    BOOLEAN DirectSend = FALSE;

                    ASSERT(CurSend->tsr_refcnt > 0);

                    Result = CTEInterlockedIncrementLong(&(CurSend->tsr_refcnt));

                    ASSERT(Result > 0);

                    SCC->scc_count++;

                    // If the current send offset is 0 and the current
                    // send is less than or equal to what we have left
                    // to send, we haven't already put a transport
                    // buffer on this send, and nobody else is using
                    // the buffer chain directly, just use the input
                    // buffers. We check for other people using them
                    // by looking at tsr_lastbuf. If it's NULL,
                    // nobody else is using the buffers. If it's not
                    // NULL, somebody is.

                    if (SendOfs == 0 &&
                        (SendSize <= AmountLeft) &&
                        (SCC->scc_tbufcount == 0) &&
                        CurSend->tsr_lastbuf == NULL) {

                        ulong length = 0;
                        PNDIS_BUFFER tmp = SendBuf;

                        while (tmp) {
                            length += NdisBufferLength(tmp);
                            tmp = NDIS_BUFFER_LINKAGE(tmp);
                        }

                        // If sum of mdl lengths is > request length
                        // use slow path.

                        if (AmountLeft >= length) {
                            DirectSend = TRUE;
                        }
                    }

                    if (DirectSend) {

                        NDIS_BUFFER_LINKAGE(CurrentBuffer) = SendBuf;

                        do {
                            SCC->scc_ubufcount++;
                            CurrentBuffer = NDIS_BUFFER_LINKAGE(CurrentBuffer);
                        } while (NDIS_BUFFER_LINKAGE(CurrentBuffer) != NULL);

                        CurSend->tsr_lastbuf = CurrentBuffer;
                        AmountLeft -= SendSize;
                        SendSize = 0;
                    } else {
                        uint AmountToDup;
                        PNDIS_BUFFER NewBuf, Buf;
                        uint Offset;
                        NDIS_STATUS NStatus;
                        uchar *VirtualAddress;
                        uint Length;

                        // Either the current send has more data than
                        // we want to send, or the starting offset is
                        // not 0. In either case we'll need to loop
                        // through the current send, allocating buffers.

                        Buf = SendBuf;

                        Offset = SendOfs;

                        do {
                            ASSERT(Buf != NULL);

                            TcpipQueryBuffer(Buf, &VirtualAddress, &Length,
                                             NormalPagePriority);

                            if (VirtualAddress == NULL) {

                                if (SCC->scc_tbufcount == 0 &&
                                    SCC->scc_ubufcount == 0) {
                                    //TCPSendComplete(SCC, FirstBuffer,IP_SUCCESS);
                                    goto error_oor1;

                                }
                                AmountToSend -= AmountLeft;
                                AmountLeft = 0;
                                break;

                            }
                            ASSERT((Offset < Length) ||
                                      (Offset == 0 && Length == 0));

                            // Adjust the length for the offset into
                            // this buffer.

                            Length -= Offset;

                            AmountToDup = MIN(AmountLeft, Length);

                            NdisAllocateBuffer(&NStatus, &NewBuf,
                                               TCPSendBufferPool,
                                               VirtualAddress + Offset,
                                               AmountToDup);

                            if (NStatus == NDIS_STATUS_SUCCESS) {

                                SCC->scc_tbufcount++;

                                NDIS_BUFFER_LINKAGE(CurrentBuffer) = NewBuf;

                                CurrentBuffer = NewBuf;

                                if (AmountToDup >= Length) {

                                    // Exhausted this buffer.

                                    Buf = NDIS_BUFFER_LINKAGE(Buf);
                                    Offset = 0;

                                } else {

                                    Offset += AmountToDup;
                                    ASSERT(Offset < NdisBufferLength(Buf));
                                }

                                SendSize -= AmountToDup;
                                AmountLeft -= AmountToDup;

                            } else {

                                // Couldn't allocate a buffer. If
                                // the packet is already partly built,
                                // send what we've got, otherwise
                                // bail out.

                                if (SCC->scc_tbufcount == 0 &&
                                    SCC->scc_ubufcount == 0) {
                                    goto error_oor1;
                                }
                                AmountToSend -= AmountLeft;
                                AmountLeft = 0;

                            }
                        } while (AmountLeft && SendSize);

                        SendBuf = Buf;
                        SendOfs = Offset;
                    }

                    if (CurSend->tsr_flags & TSR_FLAG_URG) {
                        ushort UP;

                        // This send is urgent data. We need to figure
                        // out what the urgent data pointer should be.
                        // We know sendnext is the starting sequence
                        // number of the frame, and that at the top of
                        // this do loop sendnext identified a byte in
                        // the CurSend at that time. We advanced CurSend
                        // at the same rate we've decremented
                        // AmountLeft (AmountToSend - AmountLeft ==
                        // AmountBuilt), so sendnext +
                        // (AmountToSend - AmountLeft) identifies a byte
                        // in the current value of CurSend, and that
                        // quantity plus tcb_sendsize is the sequence
                        // number one beyond the current send.

                        UP =
                            (ushort) (AmountToSend - AmountLeft) +
                            (ushort)SendSize -
                            ((SendTCB->tcb_flags & BSD_URGENT) ? 0 : 1);

                        Header->tcp_urgent = net_short(UP);

                        Header->tcp_flags |= TCP_FLAG_URG;
                    }
                    // See if we've exhausted this send. If we have,
                    // set the PUSH bit in this frame and move on to
                    // the next send. We also need to check the
                    // urgent data bit.

                    if (SendSize == 0) {
                        Queue *Next;
                        ulong PrevFlags;

                        // We've exhausted this send. Set the PUSH bit.
                        Header->tcp_flags |= TCP_FLAG_PUSH;
                        PrevFlags = CurSend->tsr_flags;
                        Next = QNEXT(&CurSend->tsr_req.tr_q);
                        if (Next != QEND(&SendTCB->tcb_sendq)) {
                            CurSend = STRUCT_OF(TCPSendReq,
                                                QSTRUCT(TCPReq, Next, tr_q),
                                                tsr_req);
                            CTEStructAssert(CurSend, tsr);
                            SendSize = CurSend->tsr_unasize;
                            SendOfs = CurSend->tsr_offset;
                            SendBuf = CurSend->tsr_buffer;

                            // Check the urgent flags. We can't combine
                            // new urgent data on to the end of old
                            // non-urgent data.
                            if ((PrevFlags & TSR_FLAG_URG) && !
                                (CurSend->tsr_flags & TSR_FLAG_URG))
                                break;
                        } else {
                            ASSERT(AmountLeft == 0);
                            CurSend = NULL;
                            SendBuf = NULL;
                        }
                    }
                } while (AmountLeft != 0);

            } else {

                // Amt to send is 0.
                // Just bail out and strat timer.

                if (!TCB_TIMER_RUNNING_R(SendTCB, RXMIT_TIMER)) {

                    START_TCB_TIMER_R(SendTCB, RXMIT_TIMER, SendTCB->tcb_rexmit);
                }
                FreeTCPHeader(FirstBuffer);
                return;

            }

            // Adjust for what we're really going to send.

            AmountToSend -= AmountLeft;

            OldSeq = SendNext;
            SendNext += AmountToSend;
            AmtUnsent -= AmountToSend;

            TStats.ts_retranssegs++;

            // We've built the frame entirely. If we've send everything
            // we have and their's a FIN pending, OR it in.

            AmountToSend += sizeof(TCPHeader);

            SendTCB->tcb_flags &= ~(NEED_ACK | ACK_DELAYED |
                                    FORCE_OUTPUT);

            STOP_TCB_TIMER_R(SendTCB, DELACK_TIMER);
            STOP_TCB_TIMER_R(SendTCB, SWS_TIMER);
            SendTCB->tcb_rcvdsegs = 0;

            if ( (SendTCB->tcb_flags & KEEPALIVE) && (SendTCB->tcb_conn != NULL) )
                START_TCB_TIMER_R(SendTCB, KA_TIMER, SendTCB->tcb_conn->tc_tcbkatime);
            SendTCB->tcb_kacount = 0;

            CTEFreeLock(&SendTCB->tcb_lock, TCBHandle);

            Irp = NULL;

            if (SCC->scc_firstsend) {
                Irp = SCC->scc_firstsend->tsr_req.tr_context;
            }

            // We're all set. Xsum it and send it.


            if (SendTCB->tcb_rce &&
                (SendTCB->tcb_rce->rce_OffloadFlags &
                TCP_XMT_CHECKSUM_OFFLOAD) &&
                (SendTCB->tcb_rce->rce_OffloadFlags &
                TCP_CHECKSUM_OPT_OFFLOAD) ){

                uint PHXsum =
                    SendTCB->tcb_phxsum +
                    (uint)net_short(AmountToSend + TSLen);

                    PHXsum = (((PHXsum << 16) | (PHXsum >> 16)) + PHXsum) >> 16;
                    Header->tcp_xsum = (ushort) PHXsum;
                    SendTCB->tcb_opt.ioi_TcpChksum = 1;

            } else {

                Header->tcp_xsum =
                    ~XsumSendChain(
                                   SendTCB->tcb_phxsum +
                                   (uint)net_short(AmountToSend + TSLen),
                                   FirstBuffer);
                SendTCB->tcb_opt.ioi_TcpChksum = 0;
            }

            SendStatus =
                (*LocalNetInfo.ipi_xmit)(TCPProtInfo,
                                         SCC,
                                         FirstBuffer,
                                         AmountToSend + TSLen,
                                         SendTCB->tcb_daddr,
                                         SendTCB->tcb_saddr,
                                         &SendTCB->tcb_opt,
                                         SendTCB->tcb_rce,
                                         PROTOCOL_TCP,
                                         Irp);


            //Reacquire Lock to keep DerefTCB happy
            //Bug #63904

            if (SendStatus != IP_PENDING) {
                TCPSendComplete(SCC, FirstBuffer, IP_SUCCESS);
            }
            CTEGetLock(&SendTCB->tcb_lock, &TCBHandle);

            SendTCB->tcb_error = SendStatus;
            if (!TCB_TIMER_RUNNING_R(SendTCB, RXMIT_TIMER)) {

                START_TCB_TIMER_R(SendTCB, RXMIT_TIMER, SendTCB->tcb_rexmit);
            }
        } else {                // FirstBuffer != NULL.

            goto error_oor;
        }
    }                            //while AmtUnsent > 0

    return;

    // Common case error handling code for out of resource conditions. Start the
    // retransmit timer if it's not already running (so that we try this again
    // later), clean up and return.

  error_oor:
    if (!TCB_TIMER_RUNNING_R(SendTCB, RXMIT_TIMER)) {
        ushort tmp;

        tmp = MIN(MAX(REXMIT_TO(SendTCB),
                      MIN_RETRAN_TICKS), MAX_REXMIT_TO);

        START_TCB_TIMER_R(SendTCB, RXMIT_TIMER, tmp);
    }

    return;

  error_oor1:
    if (!TCB_TIMER_RUNNING_R(SendTCB, RXMIT_TIMER)) {
        ushort tmp;

        tmp = MIN(MAX(REXMIT_TO(SendTCB),
                      MIN_RETRAN_TICKS), MAX_REXMIT_TO);

        START_TCB_TIMER_R(SendTCB, RXMIT_TIMER, tmp);
    }

    TCPSendComplete(SCC, FirstBuffer, IP_SUCCESS);

    return;

}


//* TDISend - Send data on a connection.
//
//  The main TDI send entry point. We take the input parameters, validate them,
//  allocate a send request, etc. We then put the send request on the queue.
//  If we have no other sends on the queue or Nagling is disabled we'll
//  call TCPSend to send the data.
//
//  Input:  Request             - The TDI request for the call.
//          Flags               - Flags for this send.
//          SendLength          - Length in bytes of send.
//          SendBuffer          - Pointer to buffer chain to be sent.
//
//  Returns: Status of attempt to send.
//
TDI_STATUS
TdiSend(PTDI_REQUEST Request, ushort Flags, uint SendLength,
        PNDIS_BUFFER SendBuffer)
{
    TCPConn *Conn;
    TCB *SendTCB;
    TCPSendReq *SendReq;
    CTELockHandle ConnTableHandle;
    TDI_STATUS Error;
    uint EmptyQ;

#if DBG_VALIDITY_CHECK

    // Check for Mdl sanity in send requests
    // Should be removed for RTM

    uint RealSendSize;
    PNDIS_BUFFER Temp;

    // Loop through the buffer chain, and make sure that the length matches
    // up with SendLength.

    Temp = SendBuffer;
    RealSendSize = 0;
    if (Temp != NULL) {

        do {
            RealSendSize += NdisBufferLength(Temp);
            Temp = NDIS_BUFFER_LINKAGE(Temp);
        } while (Temp != NULL);

        if (RealSendSize < SendLength) {
            PIRP Irp = (PIRP)Request->RequestContext;
            PIO_STACK_LOCATION IrpSp = IoGetCurrentIrpStackLocation(Irp);
            DbgPrint("Invalid TDI_SEND request issued to \\\\Device\\\\Tcp.\n");
            DbgPrint("Irp: %p Mdl: %p CompletionRoutine: %p\n",
                     Irp, Irp->MdlAddress, IrpSp->CompletionRoutine);
            DbgPrint("This is not a bug in tcpip.sys.\n");
            DbgPrint("Please notify the originator of this IRP.\n");
            DbgBreakPoint();
        }
    }

#endif

    //CTEGetLock(&ConnTableLock, &ConnTableHandle);

    Conn = GetConnFromConnID(PtrToUlong(Request->Handle.ConnectionContext), &ConnTableHandle);

    if (Conn != NULL) {
        CTEStructAssert(Conn, tc);

        SendTCB = Conn->tc_tcb;
        if (SendTCB != NULL) {
            CTEStructAssert(SendTCB, tcb);
            CTEGetLockAtDPC(&SendTCB->tcb_lock);
            CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), DISPATCH_LEVEL);
            if (DATA_SEND_STATE(SendTCB->tcb_state) && !CLOSING(SendTCB)) {
                // We have a TCB, and it's valid. Get a send request now.

                CheckTCBSends(SendTCB);

                if (SendLength == 0) {
                    Error = TDI_SUCCESS;
                } else if (((ULONG64)SendTCB->tcb_unacked + SendLength)
                                >= MAXULONG) {
                    Error = TDI_INVALID_PARAMETER;
                } else {

                    SendReq = GetSendReq();
                    if (SendReq != NULL) {
                        SendReq->tsr_req.tr_rtn = Request->RequestNotifyObject;
                        SendReq->tsr_req.tr_context = Request->RequestContext;
                        SendReq->tsr_buffer = SendBuffer;
                        SendReq->tsr_size = SendLength;
                        SendReq->tsr_unasize = SendLength;
                        SendReq->tsr_refcnt = 1;    // ACK will decrement this ref

                        SendReq->tsr_offset = 0;
                        SendReq->tsr_lastbuf = NULL;
                        SendReq->tsr_time = TCPTime;
                        SendReq->tsr_flags = (Flags & TDI_SEND_EXPEDITED) ?
                            TSR_FLAG_URG : 0;
                        SendTCB->tcb_unacked += SendLength;

                        if (Flags & TDI_SEND_AND_DISCONNECT) {

                            //move the state to fin_wait and
                            //mark the tcb for send and disconnect

                            if (SendTCB->tcb_state == TCB_ESTAB) {
                                SendTCB->tcb_state = TCB_FIN_WAIT1;
                            } else {
                                ASSERT(SendTCB->tcb_state == TCB_CLOSE_WAIT);
                                SendTCB->tcb_state = TCB_LAST_ACK;
                            }
                            SendTCB->tcb_slowcount++;
                            SendTCB->tcb_fastchk |= TCP_FLAG_SLOW;
                            SendTCB->tcb_fastchk |= TCP_FLAG_SEND_AND_DISC;
                            SendTCB->tcb_flags |= FIN_NEEDED;
                            SendReq->tsr_flags |= TSR_FLAG_SEND_AND_DISC;

                            //extrac reference to make sure that
                            //this request will not be completed until the
                            //connection is closed

                            SendReq->tsr_refcnt++;
                            InterlockedDecrement((PLONG)&TStats.ts_currestab);

                        }
                        EmptyQ = EMPTYQ(&SendTCB->tcb_sendq);
                        ENQUEUE(&SendTCB->tcb_sendq, &SendReq->tsr_req.tr_q);
                        if (SendTCB->tcb_cursend == NULL) {
                            SendTCB->tcb_cursend = SendReq;
                            SendTCB->tcb_sendbuf = SendBuffer;
                            SendTCB->tcb_sendofs = 0;
                            SendTCB->tcb_sendsize = SendLength;
                        }
                        if (EmptyQ) {
                            REFERENCE_TCB(SendTCB);
                            TCPSend(SendTCB, ConnTableHandle);
                        } else if (!(SendTCB->tcb_flags & NAGLING) ||
                                   (SendTCB->tcb_unacked -
                                    (SendTCB->tcb_sendmax -
                                     SendTCB->tcb_senduna)) >=
                                    SendTCB->tcb_mss) {
                            REFERENCE_TCB(SendTCB);
                            TCPSend(SendTCB, ConnTableHandle);
                        } else
                            CTEFreeLock(&SendTCB->tcb_lock,
                                        ConnTableHandle);

                        return TDI_PENDING;
                    } else
                        Error = TDI_NO_RESOURCES;
                }
            } else
                Error = TDI_INVALID_STATE;

            CTEFreeLock(&SendTCB->tcb_lock, ConnTableHandle);
            return Error;
        } else {
            CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), ConnTableHandle);
            Error = TDI_INVALID_STATE;
        }
    } else
        Error = TDI_INVALID_CONNECTION;

    //CTEFreeLock(&ConnTableLock, ConnTableHandle);
    return Error;

}

#pragma BEGIN_INIT

extern void *TLRegisterProtocol(uchar Protocol, void *RcvHandler,
                                void *XmitHandler, void *StatusHandler,
                                void *RcvCmpltHandler, void *PnPHandler,
                                void *ElistHandler);

extern IP_STATUS TCPRcv(void *IPContext, IPAddr Dest, IPAddr Src,
                        IPAddr LocalAddr, IPAddr SrcAddr,
                        IPHeader UNALIGNED * IPH, uint IPHLength,
                        IPRcvBuf * RcvBuf, uint Size, uchar IsBCast,
                        uchar Protocol, IPOptInfo * OptInfo);
extern void TCPRcvComplete(void);

uchar SendInited = FALSE;

//* InitTCPSend - Initialize our send side.
//
//  Called during init time to initialize our TCP send state.
//
//  Input: Nothing.
//
//  Returns: TRUE if we inited, false if we didn't.
//
int
InitTCPSend(void)
{
    NDIS_STATUS Status;


    TcpHeaderBufferSize =
        (USHORT)(ALIGN_UP(LocalNetInfo.ipi_hsize,PVOID) +
        ALIGN_UP((sizeof(TCPHeader) + ALIGNED_TS_OPT_SIZE + ALIGNED_SACK_OPT_SIZE),PVOID) +
        ALIGN_UP(MAX(MSS_OPT_SIZE, sizeof(SendCmpltContext)),PVOID));

#if BACK_FILL
    TcpHeaderBufferSize += MAX_BACKFILL_HDR_SIZE;
#endif

    TcpHeaderPool = MdpCreatePool (TcpHeaderBufferSize, 'thCT');
    if (!TcpHeaderPool)
    {
        return FALSE;
    }

    NdisAllocateBufferPool(&Status, &TCPSendBufferPool, NUM_TCP_BUFFERS);
    if (Status != NDIS_STATUS_SUCCESS) {
        MdpDestroyPool(TcpHeaderPool);
        return FALSE;
    }
    TCPProtInfo = TLRegisterProtocol(PROTOCOL_TCP, TCPRcv, TCPSendComplete,
                                     TCPStatus, TCPRcvComplete,
                                     TCPPnPPowerRequest, TCPElistChangeHandler);
    if (TCPProtInfo == NULL) {
        MdpDestroyPool(TcpHeaderPool);
        NdisFreeBufferPool(TCPSendBufferPool);
        return FALSE;
    }
    SendInited = TRUE;
    return TRUE;
}

//* UnInitTCPSend - UnInitialize our send side.
//
//  Called during init time if we're going to fail to initialize.
//
//  Input: Nothing.
//
//  Returns: TRUE if we inited, false if we didn't.
//
void
UnInitTCPSend(void)
{
    if (!SendInited)
        return;

    TLRegisterProtocol(PROTOCOL_TCP, NULL, NULL, NULL, NULL, NULL, NULL);

    MdpDestroyPool(TcpHeaderPool);
    NdisFreeBufferPool(TCPSendBufferPool);
}
#pragma END_INIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\tcprcv.c ===
/*++

Copyright (c) 1990-2000  Microsoft Corporation

Module Name:

       TCPRCV.C - TCP receive protocol code.

Abstract:

  This file contains the code for handling incoming TCP packets.

Author:


[Environment:]

    kernel mode only

[Notes:]

    optional-notes

Revision History:


--*/

#include "precomp.h"
#include "addr.h"
#include "tcp.h"
#include "tcb.h"
#include "tcpconn.h"
#include "tcpsend.h"
#include "tcprcv.h"
#include "pplasl.h"
#include "tcpdeliv.h"
#include "tlcommon.h"
#include "info.h"
#include "tcpcfg.h"
#include "secfltr.h"
CACHE_LINE_KSPIN_LOCK SynAttLock;
CACHE_LINE_ULONG TCBDelayRtnLimit;

typedef struct CACHE_ALIGN CPUDelayQ {
    DEFINE_LOCK_STRUCTURE(TCBDelayLock)
    ulong TCBDelayRtnCount;
    Queue TCBDelayQ;
} CPUDelayQ;
C_ASSERT(sizeof(CPUDelayQ) % MAX_CACHE_LINE_SIZE == 0);
C_ASSERT(__alignof(CPUDelayQ) == MAX_CACHE_LINE_SIZE);

CPUDelayQ *PerCPUDelayQ;
BOOLEAN PartitionedDelayQ = TRUE;

uint MaxDupAcks;
#define TCB_DELAY_RTN_LIMIT 4

#if DBG
ulong DbgTcpHwChkSumOk = 0;
ulong DbgTcpHwChkSumErr = 0;
ulong DbgDnsProb = 0;
#endif

extern uint Time_Proc;
extern CTELock *pTWTCBTableLock;
extern CTELock *pTCBTableLock;

#if IRPFIX
extern PDEVICE_OBJECT TCPDeviceObject;
#endif

extern Queue TWQueue;
extern ulong CurrentTCBs;
extern ulong MaxFreeTcbs;
extern IPInfo LocalNetInfo;

#define PERSIST_TIMEOUT MS_TO_TICKS(500)

typedef enum {
    TwaDoneProcessing,
    TwaSendReset,
    TwaAcceptConnection,
    TwaMaxActions
} TimeWaitAction;

TimeWaitAction
HandleTWTCB(TWTCB * RcvTCB, uint flags, SeqNum seq, uint Partition);

void
SendTWtcbACK(TWTCB *ACKTcb, uint Partition, CTELockHandle TCBHandle);

void
ReInsert2MSL(TWTCB *RemovedTCB);

void ResetSendNext(TCB *SeqTCB, SeqNum NewSeq);

void ResetAndFastSend(TCB *SeqTCB, SeqNum NewSeq, uint NewCWin);

void GetRandomISN(PULONG SeqNum, TCPAddrInfo *TcpAddr);

extern uint TcpHostOpts;
extern BOOLEAN fAcdLoadedG;


extern NTSTATUS TCPPrepareIrpForCancel(PTCP_CONTEXT TcpContext, PIRP Irp,
                                       PDRIVER_CANCEL CancelRoutine);

extern void TCPRequestComplete(void *Context, uint Status,
                               uint UnUsed);

void TCPCancelRequest(PDEVICE_OBJECT Device, PIRP Irp);

#ifdef DBG
extern ULONG SListCredits;
#endif


//
// All of the init code can be discarded.
//

int InitTCPRcv(void);
void UnInitTCPRcv(void);

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, InitTCPRcv)
#pragma alloc_text(INIT, UnInitTCPRcv)
#endif


//* AdjustRcvWin - Adjust the receive window on a TCB.
//
//  A utility routine that adjusts the receive window to an even multiple of
//  the local segment size. We round it up to the next closest multiple, or
//  leave it alone if it's already an event multiple. We assume we have
//  exclusive access to the input TCB.
//
//  Input:  WinTCB  - TCB to be adjusted.
//
//  Returns: Nothing.
//
void
AdjustRcvWin(TCB *WinTCB)
{
    ushort  LocalMSS;
    uchar   FoundMSS;
    ulong   SegmentsInWindow;
    uint    ScaledMaxRcvWin;

    ASSERT(WinTCB->tcb_defaultwin != 0);
    ASSERT(WinTCB->tcb_rcvwin != 0);
    ASSERT(WinTCB->tcb_remmss != 0);

    if (WinTCB->tcb_flags & WINDOW_SET)
        return;

    // First, get the local MSS by calling IP.

    FoundMSS = (*LocalNetInfo.ipi_getlocalmtu)(WinTCB->tcb_saddr, &LocalMSS);

    // If we didn't find it, error out.
    if (!FoundMSS) {
        //ASSERT(FALSE);
        return;
    }
    LocalMSS -= sizeof(TCPHeader);
    LocalMSS = MIN(LocalMSS, WinTCB->tcb_remmss);

    // Compute the actual maximum receive window, accounting for the presence
    // of window scaling on this particular connection. This value is used
    // in the computations below, rather than the cross-connection maximum.

    ScaledMaxRcvWin = TCP_MAXWIN << WinTCB->tcb_rcvwinscale;

    // Make sure we have at least 4 segments in window, if that wouldn't make
    // the window too big.

    SegmentsInWindow = WinTCB->tcb_defaultwin / (ulong)LocalMSS;

    if (SegmentsInWindow < 4) {

        // We have fewer than four segments in the window. Round up to 4
        // if we can do so without exceeding the maximum window size; otherwise
        // use the maximum multiple that we can fit in 64K. The exception is if
        // we can only fit one integral multiple in the window - in that case
        // we'll use a window equal to the scaled maximum.

        if (LocalMSS <= (ScaledMaxRcvWin / 4)) {
            WinTCB->tcb_defaultwin = (uint)(4 * LocalMSS);
        } else {
            ulong SegmentsInMaxWindow;

            // Figure out the maximum number of segments we could possibly
            // fit in a window. If this is > 1, use that as the basis for
            // our window size. Otherwise use a maximum size window.

            SegmentsInMaxWindow = ScaledMaxRcvWin / (ulong)LocalMSS;
            if (SegmentsInMaxWindow != 1)
                WinTCB->tcb_defaultwin = SegmentsInMaxWindow * (ulong)LocalMSS;
            else
                WinTCB->tcb_defaultwin = ScaledMaxRcvWin;
        }

        WinTCB->tcb_rcvwin = WinTCB->tcb_defaultwin;

    } else {
        // If it's not already an even multiple, bump the default and current
        // windows to the nearest multiple.

        if ((SegmentsInWindow * (ulong)LocalMSS) != WinTCB->tcb_defaultwin) {
            ulong NewWindow;

            NewWindow = (SegmentsInWindow + 1) * (ulong)LocalMSS;

            // Don't let the new window be > 64K
            // or what ever is set (if window scaling is enabled)

            if (NewWindow <= ScaledMaxRcvWin) {
                WinTCB->tcb_defaultwin = (uint)NewWindow;
                WinTCB->tcb_rcvwin = (uint)NewWindow;
            }
        }
    }
}

//* CompleteRcvs - Complete rcvs on a TCB.
//
//  Called when we need to complete rcvs on a TCB. We'll pull things from
//  the TCB's rcv queue, as long as there are rcvs that have the PUSH bit
//  set.
//
//  Input:  CmpltTCB        - TCB to complete on.
//
//  Returns: Nothing.
//
void
CompleteRcvs(TCB * CmpltTCB)
{
    CTELockHandle TCBHandle;
    TCPRcvReq *CurrReq, *NextReq, *IndReq;
#if TRACE_EVENT
    PTDI_DATA_REQUEST_NOTIFY_ROUTINE CPCallBack;
    WMIData WMIInfo;
#endif

    CTEStructAssert(CmpltTCB, tcb);
    ASSERT(CmpltTCB->tcb_refcnt != 0);

    CTEGetLock(&CmpltTCB->tcb_lock, &TCBHandle);

    if (!CLOSING(CmpltTCB) && !(CmpltTCB->tcb_flags & RCV_CMPLTING)
        && (CmpltTCB->tcb_rcvhead != NULL)) {

        CmpltTCB->tcb_flags |= RCV_CMPLTING;

        for (;;) {

            CurrReq = CmpltTCB->tcb_rcvhead;
            IndReq = NULL;
            do {
                CTEStructAssert(CurrReq, trr);

                if (CurrReq->trr_flags & TRR_PUSHED) {
                    // Need to complete this one. If this is the current rcv
                    // advance the current rcv to the next one in the list.
                    // Then set the list head to the next one in the list.

                    NextReq = CurrReq->trr_next;
                    if (CmpltTCB->tcb_currcv == CurrReq)
                        CmpltTCB->tcb_currcv = NextReq;

                    CmpltTCB->tcb_rcvhead = NextReq;

                    if (NextReq == NULL) {

                        // We've just removed the last buffer. Set the
                        // rcvhandler to PendData, in case something
                        // comes in during the callback.
                        ASSERT(CmpltTCB->tcb_rcvhndlr != IndicateData);
                        CmpltTCB->tcb_rcvhndlr = PendData;
                    }
                    CTEFreeLock(&CmpltTCB->tcb_lock, TCBHandle);
                    if (CurrReq->trr_uflags != NULL)
                        *(CurrReq->trr_uflags) =
                            TDI_RECEIVE_NORMAL | TDI_RECEIVE_ENTIRE_MESSAGE;
#if TRACE_EVENT
                    CPCallBack = TCPCPHandlerRoutine;
                    if (CPCallBack != NULL) {
                        ulong GroupType;

                        WMIInfo.wmi_destaddr = CmpltTCB->tcb_daddr;
                        WMIInfo.wmi_destport = CmpltTCB->tcb_dport;
                        WMIInfo.wmi_srcaddr  = CmpltTCB->tcb_saddr;
                        WMIInfo.wmi_srcport  = CmpltTCB->tcb_sport;
                        WMIInfo.wmi_size     = CurrReq->trr_amt;
                        WMIInfo.wmi_context  = CmpltTCB->tcb_cpcontext;

                        GroupType = EVENT_TRACE_GROUP_TCPIP + EVENT_TRACE_TYPE_RECEIVE;
                        (*CPCallBack) (GroupType, (PVOID) &WMIInfo, sizeof(WMIInfo), NULL);
                    }
#endif

                    (*CurrReq->trr_rtn) (CurrReq->trr_context,
                                         CurrReq->trr_status, CurrReq->trr_amt);
                    if (IndReq != NULL)
                        FreeRcvReq(CurrReq);
                    else {
                        IndReq = CurrReq;
                        IndReq->trr_status = TDI_SUCCESS;
                    }
                    CTEGetLock(&CmpltTCB->tcb_lock, &TCBHandle);
                    CurrReq = CmpltTCB->tcb_rcvhead;

                } else
                    // This one isn't to be completed, so bail out.
                    break;
            } while (CurrReq != NULL);

            // Now see if we've completed all of the requests. If we have, we
            // may need to deal with pending data and/or reset the rcv. handler.
            if (CurrReq == NULL) {
                // We've completed everything that can be, so stop the push
                // timer. We don't stop it if CurrReq isn't NULL because we
                // want to make sure later data is eventually pushed.
                STOP_TCB_TIMER_R(CmpltTCB, PUSH_TIMER);

                ASSERT(IndReq != NULL);
                // No more recv. requests.
                if (CmpltTCB->tcb_pendhead == NULL) {

                    FreeRcvReq(IndReq);
                    // No pending data. Set the rcv. handler to either PendData
                    // or IndicateData.
                    if (!(CmpltTCB->tcb_flags & (DISC_PENDING | GC_PENDING))) {
                        if (CmpltTCB->tcb_rcvind != NULL &&
                            CmpltTCB->tcb_indicated == 0)
                            CmpltTCB->tcb_rcvhndlr = IndicateData;
                        else
                            CmpltTCB->tcb_rcvhndlr = PendData;
                    } else {
                        goto Complete_Notify;
                    }

                } else {
                    // We have pending data to deal with.
                    if (CmpltTCB->tcb_rcvind != NULL &&
                        ((CmpltTCB->tcb_indicated == 0) || (CmpltTCB->tcb_moreflag == 4))) {

                        // There's a rcv. indicate handler on this TCB. Call
                        // the indicate handler with the pending data.

                        IndicatePendingData(CmpltTCB, IndReq, TCBHandle);
                        SendACK(CmpltTCB);
                        CTEGetLock(&CmpltTCB->tcb_lock, &TCBHandle);
                        // See if a buffer has been posted. If so, we'll need
                        // to check and see if it needs to be completed.
                        if (CmpltTCB->tcb_rcvhead != NULL)
                            continue;
                        else {
                            // If the pending head is now NULL, we've used up
                            // all the data.
                            if (CmpltTCB->tcb_pendhead == NULL &&
                                (CmpltTCB->tcb_flags &
                                 (DISC_PENDING | GC_PENDING)))
                                goto Complete_Notify;
                        }

                    } else {
                        // No indicate handler, so nothing to do. The rcv.
                        // handler should already be set to PendData.

                        FreeRcvReq(IndReq);
                        ASSERT(CmpltTCB->tcb_rcvhndlr == PendData);
                    }
                }
            } else {
                if (IndReq != NULL)
                    FreeRcvReq(IndReq);
            }

            break;
        }
        CmpltTCB->tcb_flags &= ~RCV_CMPLTING;
    }
    CTEFreeLock(&CmpltTCB->tcb_lock, TCBHandle);
    return;

  Complete_Notify:
    // Something is pending. Figure out what it is, and do
    // it.
    if (CmpltTCB->tcb_flags & GC_PENDING) {
        CmpltTCB->tcb_flags &= ~RCV_CMPLTING;
        // Bump the refcnt, because GracefulClose will
        // deref the TCB and we're not really done with
        // it yet.
        REFERENCE_TCB(CmpltTCB);

        //it is okay to ignore the tw state since we are returning frome here
        //anyway, without touching the tcb.

        GracefulClose(CmpltTCB, CmpltTCB->tcb_flags & TW_PENDING,
                      (CmpltTCB->tcb_fastchk & TCP_FLAG_SEND_AND_DISC) ? 
                      FALSE : TRUE, TCBHandle);

    } else if (CmpltTCB->tcb_flags & DISC_PENDING) {
        NotifyOfDisc(CmpltTCB, NULL, TDI_GRACEFUL_DISC, &TCBHandle);

        CTEGetLock(&CmpltTCB->tcb_lock, &TCBHandle);
        CmpltTCB->tcb_flags &= ~RCV_CMPLTING;
        CTEFreeLock(&CmpltTCB->tcb_lock, TCBHandle);
    } else {
        ASSERT(FALSE);
        CTEFreeLock(&CmpltTCB->tcb_lock, TCBHandle);
    }

    return;

}

//* CompleteSends - Complete TCP send requests.
//
//  Called when we need to complete a chain of send-requests pulled off a TCB
//  during our ACK processing. If the SendQ is non-empty, requests are dequeued
//  and completed.
//
//  Input:  SendQ       - A chain of TCPSendReq structures.
//
//  Returns: nothing.
//
void
CompleteSends(Queue* SendQ)
{
    Queue* CurrentQ = QHEAD(SendQ);
    TCPReq* Req;
    if (EMPTYQ(SendQ)) {
        return;
    }
    do {
        Req = QSTRUCT(TCPReq, CurrentQ, tr_q);
        CurrentQ = QNEXT(CurrentQ);
        CTEStructAssert(Req, tr);
        (*Req->tr_rtn)(Req->tr_context, Req->tr_status,
                       Req->tr_status == TDI_SUCCESS
                        ? ((TCPSendReq*)Req)->tsr_size : 0);
        FreeSendReq((TCPSendReq*)Req);
    } while (CurrentQ != QEND(SendQ));
}

//* ProcessPerCpuTCBDelayQ - Process TCBs on the delayed Q on this cpu.
//
//  Called at various times to process TCBs on the delayed Q.
//
//  Input: Proc           - Index into the per-processor delay queues.
//         OrigIrql       - The callers IRQL.
//         StopTicks      - Optional pointer to KeQueryTickCount value after
//                          which processing should stop.  This is used to
//                          limit the time spent at DISPATCH_LEVEL.
//         ItemsProcessed - Optional output pointer where the number of items
//                          processed is stored.  (Caller takes responsibility
//                          for initializing this counter if used.)
//
//  Returns: TRUE if processing was stopped due to time constraint.  FALSE
//           otherwise, or if no time constraint was given.
//
LOGICAL
ProcessPerCpuTCBDelayQ(int Proc, KIRQL OrigIrql,
                       const LARGE_INTEGER* StopTicks, ulong *ItemsProcessed)
{
    CPUDelayQ* CpuQ;
    Queue* Item;
    TCB *DelayTCB;
    CTELockHandle TCBHandle;
    LARGE_INTEGER Ticks;
    LOGICAL TimeConstrained = FALSE;

    CpuQ = &PerCPUDelayQ[Proc];

    while ((Item = InterlockedDequeueIfNotEmptyAtIrql(&CpuQ->TCBDelayQ,
                                                      &CpuQ->TCBDelayLock,
                                                      OrigIrql)) != NULL) {
        DelayTCB = STRUCT_OF(TCB, Item, tcb_delayq);
        CTEStructAssert(DelayTCB, tcb);

        CTEGetLockAtIrql(&DelayTCB->tcb_lock, OrigIrql, &TCBHandle);

        ASSERT(DelayTCB->tcb_refcnt != 0);
        ASSERT(DelayTCB->tcb_flags & IN_DELAY_Q);

        while (!CLOSING(DelayTCB) && (DelayTCB->tcb_flags & DELAYED_FLAGS)) {

            if (DelayTCB->tcb_flags & NEED_RCV_CMPLT) {
                DelayTCB->tcb_flags &= ~NEED_RCV_CMPLT;
                CTEFreeLockAtIrql(&DelayTCB->tcb_lock, OrigIrql, TCBHandle);
                CompleteRcvs(DelayTCB);
                CTEGetLockAtIrql(&DelayTCB->tcb_lock, OrigIrql, &TCBHandle);
            }
            if (DelayTCB->tcb_flags & NEED_OUTPUT) {
                DelayTCB->tcb_flags &= ~NEED_OUTPUT;
                REFERENCE_TCB(DelayTCB);
                TCPSend(DelayTCB, TCBHandle);
                CTEGetLockAtIrql(&DelayTCB->tcb_lock, OrigIrql, &TCBHandle);
            }
            if (DelayTCB->tcb_flags & NEED_ACK) {
                DelayTCB->tcb_flags &= ~NEED_ACK;
                CTEFreeLockAtIrql(&DelayTCB->tcb_lock, OrigIrql, TCBHandle);
                SendACK(DelayTCB);
                CTEGetLockAtIrql(&DelayTCB->tcb_lock, OrigIrql, &TCBHandle);
            }
        }

        if (CLOSING(DelayTCB) &&
            (DelayTCB->tcb_flags & NEED_OUTPUT) &&
            DATA_RCV_STATE(DelayTCB->tcb_state) && (DelayTCB->tcb_closereason & TCB_CLOSE_RST)) {
#if DBG
            DbgDnsProb++;
#endif
            DelayTCB->tcb_flags &= ~NEED_OUTPUT;
            REFERENCE_TCB(DelayTCB);

            TCPSend(DelayTCB, TCBHandle);
            CTEGetLockAtIrql(&DelayTCB->tcb_lock, OrigIrql, &TCBHandle);
        }

        DelayTCB->tcb_flags &= ~IN_DELAY_Q;
        DerefTCB(DelayTCB, TCBHandle);

        if (ItemsProcessed) {
            (*ItemsProcessed)++;
        }

        // If a time constraint was given, bail out if we've past it.
        //
        if (StopTicks) {
            KeQueryTickCount(&Ticks);
            if (Ticks.QuadPart > StopTicks->QuadPart) {
                TimeConstrained = TRUE;
                break;
            }
        }
     }

     return TimeConstrained;
}

//* ProcessTCBDelayQ - Process TCBs on the delayed Q.
//
//  Called at various times to process TCBs on the delayed Q.
//
//  Input: OrigIrql         - Current IRQL.
//         ProcessAllQueues - Process all queues if TRUE; otherwise, current 
//                            processor queue only.
//
//  Returns: Nothing.
//
void
ProcessTCBDelayQ(KIRQL OrigIrql, BOOLEAN ProcessAllQueues)
{
    uint i;
    uint Index;
    LOGICAL TimeConstrained;
    ulong ItemsProcessed;
    LARGE_INTEGER TicksDelta;
    LARGE_INTEGER StopTicks;
    ulong DelayRtnCount;
    ulong Proc;


    //
    // Get the current processor#
    //

    Proc = KeGetCurrentProcessorNumber();

    // Check for recursion. We do not stop recursion completely, only
    // limit it. This is done to allow multiple threads to process the
    // TCBDelayQ simultaneously.

    DelayRtnCount = CTEInterlockedIncrementLong((PLONG)&(PerCPUDelayQ[Proc].TCBDelayRtnCount));

    if (DelayRtnCount > TCBDelayRtnLimit.Value) {
        CTEInterlockedDecrementLong((PLONG)&(PerCPUDelayQ[Proc].TCBDelayRtnCount));
        return;
    }

    //
    // Constrain ProcessPerCpuTCBDelayQ to run only for 100 ms maximum.
    //

    ItemsProcessed = 0;
    TicksDelta.HighPart = 0;
    TicksDelta.LowPart = (100 * 10 * 1000) / KeQueryTimeIncrement();
    KeQueryTickCount(&StopTicks);
    StopTicks.QuadPart = StopTicks.QuadPart + TicksDelta.QuadPart;

    for (i = 0; i < Time_Proc; i++) {

        //
        // Delayed items on the current processor is processed first.
        // This improves the chances of L1 cache hit for the TCBs.
        //

        Index = (i + Proc) % Time_Proc;

        // We are just peeking at the queue to prevent taking it's
        // lock uneccessarily.
        //
        if (!EMPTYQ(&PerCPUDelayQ[Index].TCBDelayQ)) {

            TimeConstrained = ProcessPerCpuTCBDelayQ(Index,
                                                     OrigIrql,
                                                     &StopTicks,
                                                     &ItemsProcessed);

            if (TimeConstrained) {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                          "ProcessTCBDelayQ: Processed %u TCBs before "
                          "time expired.\n",
                          ItemsProcessed));
                break;
            }
        }

        //
        // If there is no need to process all the delay quues, break out after
        // processing the current one.
        //
        
        if (!ProcessAllQueues) {
            break;
        }
    }

    CTEInterlockedDecrementLong((PLONG)&(PerCPUDelayQ[Proc].TCBDelayRtnCount));
}

//* DelayAction - Put a TCB on the queue for a delayed action.
//
//  Called when we want to put a TCB on the DelayQ for a delayed action at
//  rcv. complete or some other time. The lock on the TCB must be held when
//      this is called.
//
//  Input:  DelayTCB            - TCB which we're going to sched.
//          Action              - Action we're scheduling.
//
//  Returns: Nothing.
//
void
DelayAction(TCB * DelayTCB, uint Action)
{
    // Schedule the completion.
    //
    DelayTCB->tcb_flags |= Action;
    if (!(DelayTCB->tcb_flags & IN_DELAY_Q)) {
        uint Proc;
#if MILLEN
        Proc = 0;
#else // MILLEN
        Proc = KeGetCurrentProcessorNumber();
#endif // !MILLEN

        DelayTCB->tcb_flags |= IN_DELAY_Q;
        REFERENCE_TCB(DelayTCB);    // Reference this for later.

        //We may not be running timer dpcs on all the processors
        if (!(Proc < Time_Proc)) {
           Proc = 0;
        }

        InterlockedEnqueueAtDpcLevel(&PerCPUDelayQ[Proc].TCBDelayQ,
                                     &DelayTCB->tcb_delayq,
                                     &PerCPUDelayQ[Proc].TCBDelayLock);
    }
}


//* HandleTWTCB - Process a segment matching a time wait TCB.
//  
//  This function operates on a TCB in time wait state. The action taken is
//  based on RFC 793 with modifications done to handle all the actions on a 
//  time wait TCB upfront and moving a time-wait TCB to SYN-RCVD state (the
//  conditions have been rearranged as well).
//
//  Input:    RcvTCB      - TCB which matching the segment.
//            flags       - Flags on the segment.
//            seq         - Sequence number of the segment.
//            Partition   - Partition to which the TCB belongs.
//
//  Returns:  The action to be taken by the caller.
//
TimeWaitAction
HandleTWTCB(TWTCB * RcvTCB, uint flags, SeqNum seq, uint Partition)
{
    if (flags & TCP_FLAG_RST) {
        if (SEQ_EQ(seq, RcvTCB->twtcb_rcvnext)) {
            RemoveTWTCB(RcvTCB, Partition);
            FreeTWTCB(RcvTCB);
        }
        CTEFreeLockFromDPC(&pTWTCBTableLock[Partition]);
        return TwaDoneProcessing;
    } else if (flags & TCP_FLAG_ACK) {
        if (SEQ_EQ(seq, RcvTCB->twtcb_rcvnext) && (flags & TCP_FLAG_SYN)) {
            CTEFreeLockFromDPC(&pTWTCBTableLock[Partition]);
            return TwaSendReset;
        } else if (SEQ_EQ(seq, RcvTCB->twtcb_rcvnext - 1) && 
                   ((flags & (TCP_FLAG_FIN | TCP_FLAG_SYN)) == TCP_FLAG_FIN)) {
            ReInsert2MSL(RcvTCB);
        } else if (SEQ_EQ(seq, RcvTCB->twtcb_rcvnext)) {
            CTEFreeLockFromDPC(&pTWTCBTableLock[Partition]);
            return TwaDoneProcessing;
        }

        SendTWtcbACK(RcvTCB, Partition, DISPATCH_LEVEL);
        return TwaDoneProcessing;
    } else if (SEQ_GTE(seq, RcvTCB->twtcb_rcvnext) && 
               ((flags & TCP_FLAGS_ALL) == TCP_FLAG_SYN)) {
        CTEFreeLockFromDPC(&pTWTCBTableLock[Partition]);
        return TwaAcceptConnection;
    } else {
        CTEFreeLockFromDPC(&pTWTCBTableLock[Partition]);
        return TwaDoneProcessing;
    }
}

//* TCPRcvComplete - Handle a receive complete.
//
//  Called by the lower layers when we're done receiving. If we have any work
//  to do, we use this time to do it.
//
//  Input: Nothing.
//
//  Returns: Nothing.
//
void
TCPRcvComplete(void)
{
    ProcessTCBDelayQ(DISPATCH_LEVEL, !PartitionedDelayQ);
}

//* CompleteConnReq - Complete a connection request on a TCB.
//
//  A utility function to complete a connection request on a TCB. We remove
//  the connreq, and put it on the ConnReqCmpltQ where it will be picked
//  off later during RcvCmplt processing. We assume the TCB lock is held when
//  we're called.
//
//  Input:  CmpltTCB    - TCB from which to complete.
//          OptInfo     - IP OptInfo for completeion.
//          Status      - Status to complete with.
//
//  Returns: Nothing.
//
void
CompleteConnReq(TCB * CmpltTCB, IPOptInfo * OptInfo, TDI_STATUS Status)
{
    TCPConnReq *ConnReq;

    CTEStructAssert(CmpltTCB, tcb);

    ConnReq = CmpltTCB->tcb_connreq;
    if (ConnReq != NULL) {

        uint FastChk;

        // There's a connreq on this TCB. Fill in the connection information
        // before returning it.
        if (TCB_TIMER_RUNNING_R(CmpltTCB, CONN_TIMER))
            STOP_TCB_TIMER_R(CmpltTCB, CONN_TIMER);

        CmpltTCB->tcb_connreq = NULL;
        UpdateConnInfo(ConnReq->tcr_conninfo, OptInfo, CmpltTCB->tcb_daddr,
                       CmpltTCB->tcb_dport);
        if (ConnReq->tcr_addrinfo) {
            UpdateConnInfo(ConnReq->tcr_addrinfo, OptInfo, CmpltTCB->tcb_saddr,
                           CmpltTCB->tcb_sport);
        }

        ConnReq->tcr_req.tr_status = Status;

        // In order to complete this request directly, we must block further
        // receive-processing until this connect-indication is complete.
        // We require that any caller of this routine must already hold
        // a reference to the TCB so that the dereference below does not drop
        // the reference-count to zero.

        FastChk = (CmpltTCB->tcb_fastchk & TCP_FLAG_IN_RCV) ^ TCP_FLAG_IN_RCV;
        CmpltTCB->tcb_fastchk |= FastChk;
        CTEFreeLockFromDPC(&CmpltTCB->tcb_lock);
        (ConnReq->tcr_req.tr_rtn)(ConnReq->tcr_req.tr_context,
                                  ConnReq->tcr_req.tr_status, 0);
        FreeConnReq(ConnReq);
        CTEGetLockAtDPC(&CmpltTCB->tcb_lock);
        CmpltTCB->tcb_fastchk &= ~FastChk;
        if (CmpltTCB->tcb_flags & SEND_AFTER_RCV) {
            CmpltTCB->tcb_flags &= ~SEND_AFTER_RCV;
            DelayAction(CmpltTCB, NEED_OUTPUT);
        }
    }
#if DBG
    else {
        ASSERT((CmpltTCB->tcb_state == TCB_SYN_RCVD) &&
               (CmpltTCB->tcb_fastchk & TCP_FLAG_ACCEPT_PENDING));
    }
#endif
}

BOOLEAN
DelayedAcceptConn(AddrObj *ListenAO, IPAddr Src, ushort SrcPort,
                  IPOptInfo *OptInfo, TCB *AcceptTCB)
{
    TCPConn *CurrentConn = NULL;
    CTELockHandle ConnHandle;
    Queue *Temp;
    TCPConnReq *ConnReq = NULL;
    BOOLEAN FoundConn = FALSE;
    uchar TAddress[TCP_TA_SIZE];
    PVOID ConnContext;
    PConnectEvent Event;
    PVOID EventContext;
    TDI_STATUS Status;
    PTCP_CONTEXT TcpContext = NULL;
    ConnectEventInfo *EventInfo;

    CTEStructAssert(ListenAO, ao);
    CTEGetLockAtDPC(&ListenAO->ao_lock);
    CTEFreeLockFromDPC(&AddrObjTableLock.Lock);

    if (!AO_VALID(ListenAO) || ListenAO->ao_connect == NULL) {
        CTEFreeLockFromDPC(&ListenAO->ao_lock);
        return FALSE;
    }

    // He has a connect handler. Put the transport address together,
    // and call him. We also need to get the necessary resources
    // first.

    Event = ListenAO->ao_connect;
    EventContext = ListenAO->ao_conncontext;
    REF_AO(ListenAO);
    CTEFreeLockFromDPC(&ListenAO->ao_lock);

    ConnReq = GetConnReq();

    if (ConnReq == NULL) {
        DELAY_DEREF_AO(ListenAO);
        return FALSE;
    }

    BuildTDIAddress(TAddress, Src, SrcPort);

    IF_TCPDBG(TCP_DEBUG_CONNECT) {
        TCPTRACE(("indicating connect request\n"));
    }

    Status = (*Event) (EventContext, TCP_TA_SIZE,
                       (PTRANSPORT_ADDRESS) TAddress, 0, NULL,
                       OptInfo->ioi_optlength, OptInfo->ioi_options,
                       &ConnContext, &EventInfo);

    if (Status == TDI_MORE_PROCESSING) {
#if !MILLEN
        PIO_STACK_LOCATION IrpSp;
        PTDI_REQUEST_KERNEL_ACCEPT AcceptRequest;

        IrpSp = IoGetCurrentIrpStackLocation(EventInfo);

        Status = TCPPrepareIrpForCancel(
                                        (PTCP_CONTEXT) IrpSp->FileObject->FsContext,
                                        EventInfo,
                                        TCPCancelRequest
                                        );

        if (!NT_SUCCESS(Status)) {
            Status = TDI_NOT_ACCEPTED;
            EventInfo = NULL;
            goto AcceptIrpCancelled;
        }

        // He accepted it. Find the connection on the AddrObj.

        IF_TCPDBG(TCP_DEBUG_CONNECT) {
            TCPTRACE((
                      "connect indication accepted, queueing request\n"
                     ));
        }

        AcceptRequest = (PTDI_REQUEST_KERNEL_ACCEPT)
                & (IrpSp->Parameters);
        ConnReq->tcr_conninfo =
        AcceptRequest->ReturnConnectionInformation;
        if (AcceptRequest->RequestConnectionInformation &&
            AcceptRequest->RequestConnectionInformation->RemoteAddress) {
            ConnReq->tcr_addrinfo =
                AcceptRequest->RequestConnectionInformation;
        } else {
            ConnReq->tcr_addrinfo = NULL;
        }
        ConnReq->tcr_req.tr_rtn = TCPRequestComplete;
        ConnReq->tcr_req.tr_context = EventInfo;

#else // !MILLEN
        ConnReq->tcr_req.tr_rtn = EventInfo.cei_rtn;
        ConnReq->tcr_req.tr_context = EventInfo.cei_context;
        ConnReq->tcr_conninfo = EventInfo.cei_conninfo;
        ConnReq->tcr_addrinfo = NULL;
#endif // MILLEN

        CurrentConn = NULL;

#if !MILLEN
        if ((IrpSp->FileObject->DeviceObject == TCPDeviceObject) &&
            (PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE) &&
            ((TcpContext = IrpSp->FileObject->FsContext) != NULL) &&
            ((CurrentConn = GetConnFromConnID(
                                              PtrToUlong(TcpContext->Handle.ConnectionContext), &ConnHandle)) != NULL) &&
            (CurrentConn->tc_context == ConnContext) &&
            !(CurrentConn->tc_flags & CONN_INVALID)) {

            // Found the Conn structure!!
            // Don't have to loop below.
            CTEStructAssert(CurrentConn, tc);

            CTEGetLockAtDPC(&ListenAO->ao_lock);
            CTEGetLockAtDPC(&AcceptTCB->tcb_lock);

            if (AcceptTCB->tcb_fastchk & TCP_FLAG_ACCEPT_PENDING) {
                Status = InitTCBFromConn(CurrentConn, AcceptTCB,
                                         AcceptRequest->RequestConnectionInformation,
                                         TRUE);
            } else {
                Status = TDI_INVALID_STATE;
            }

            if (Status == TDI_SUCCESS) {
                FoundConn = TRUE;

                ASSERT(AcceptTCB->tcb_state == TCB_SYN_RCVD);

                AcceptTCB->tcb_fastchk &= ~TCP_FLAG_ACCEPT_PENDING;
                AcceptTCB->tcb_connreq = ConnReq;
                AcceptTCB->tcb_conn = CurrentConn;
                AcceptTCB->tcb_connid = CurrentConn->tc_connid;
                CurrentConn->tc_tcb = AcceptTCB;
                CurrentConn->tc_refcnt++;

                // Move him from the idle q to the active
                // queue.

                REMOVEQ(&CurrentConn->tc_q);
                PUSHQ(&ListenAO->ao_activeq, &CurrentConn->tc_q);
            } else {
                CTEFreeLockFromDPC(&AcceptTCB->tcb_lock);
                CTEFreeLockFromDPC(&CurrentConn->tc_ConnBlock->cb_lock);
            }

        } else {
#endif // !MILLEN
            if (CurrentConn) {
                CTEFreeLockFromDPC(&CurrentConn->tc_ConnBlock->cb_lock);
            }

SearchAO:
            CTEGetLockAtDPC(&ListenAO->ao_lock);

            Temp = QHEAD(&ListenAO->ao_idleq);;

            Status = TDI_INVALID_CONNECTION;

            while (Temp != QEND(&ListenAO->ao_idleq)) {

                CurrentConn = QSTRUCT(TCPConn, Temp, tc_q);


                CTEStructAssert(CurrentConn, tc);

                if ((CurrentConn->tc_context == ConnContext) &&
                    !(CurrentConn->tc_flags & CONN_INVALID)) {

                    //
                    // We need to lock its TCPConnBlock, with care.
                    // We'll ref the TCPConn so it can't go away,
                    // then unlock the AO (which is already ref'd),
                    // then relock. Note that tc_refcnt is updated
                    // under ao_lock for any associated TCPConn.
                    // If things have changed, go back and try again.
                    //
                    ++CurrentConn->tc_refcnt;
                    CTEFreeLockFromDPC(&ListenAO->ao_lock);
                    CTEGetLockAtDPC(&CurrentConn->tc_ConnBlock->cb_lock);

                    if (--CurrentConn->tc_refcnt == 0 &&
                        ((CurrentConn->tc_flags & CONN_INVALID) ||
                         (CurrentConn->tc_tcb != NULL))) {
                        ConnDoneRtn DoneRtn = CurrentConn->tc_donertn;
                        DoneRtn(CurrentConn, DISPATCH_LEVEL);
                        goto SearchAO;
                    }

                    CTEGetLockAtDPC(&ListenAO->ao_lock);
                    CTEGetLockAtDPC(&AcceptTCB->tcb_lock);

                    // We think we have a match. The connection
                    // shouldn't have a TCB associated with it. If it
                    // does, it's an error. InitTCBFromConn will
                    // handle all this, but first confirm that
                    // TCP_FLAG_ACCEPT_PENDING is still set. If not,
                    // someone took this before we did.

                    if (AcceptTCB->tcb_fastchk &
                            TCP_FLAG_ACCEPT_PENDING) {
                        Status =
                            InitTCBFromConn(CurrentConn, AcceptTCB,
#if !MILLEN
                                            AcceptRequest->RequestConnectionInformation,
#else // !MILLEN
                                            EventInfo.cei_acceptinfo,
#endif // MILLEN
                                            TRUE);
                    } else {
                        Status = TDI_INVALID_STATE;
                    }

                    if (Status == TDI_SUCCESS) {

                        FoundConn = TRUE;
                        AcceptTCB->tcb_fastchk &=
                            ~TCP_FLAG_ACCEPT_PENDING;
                        AcceptTCB->tcb_connreq = ConnReq;
                        AcceptTCB->tcb_conn = CurrentConn;
                        AcceptTCB->tcb_connid = CurrentConn->tc_connid;
                        CurrentConn->tc_tcb = AcceptTCB;
                        CurrentConn->tc_refcnt++;

                        // Move him from the idle q to the active
                        // queue.
                        REMOVEQ(&CurrentConn->tc_q);
                        ENQUEUE(&ListenAO->ao_activeq, &CurrentConn->tc_q);
                    } else {
                        CTEFreeLockFromDPC(&AcceptTCB->tcb_lock);
                        CTEFreeLockFromDPC(&CurrentConn->tc_ConnBlock->cb_lock);
                    }

                    // In any case, we're done now.
                    break;
                }

                Temp = QNEXT(Temp);
            }
#if !MILLEN
        }
#endif // !MILLEN
        LOCKED_DELAY_DEREF_AO(ListenAO);
        CTEFreeLockFromDPC(&ListenAO->ao_lock);
        if (FoundConn) {
            CTEFreeLockFromDPC(&(CurrentConn->tc_ConnBlock->cb_lock));
        } else {
            // Either we couldn't find a TCPConn for this TCB,
            // or someone accepted it before us. We just complete
            // the unnecessary ConnReq, then we're done.

            UpdateConnInfo(ConnReq->tcr_conninfo, OptInfo,
                           AcceptTCB->tcb_daddr, AcceptTCB->tcb_dport);
            if (ConnReq->tcr_addrinfo) {
                UpdateConnInfo(ConnReq->tcr_addrinfo, OptInfo,
                               AcceptTCB->tcb_saddr,
                               AcceptTCB->tcb_sport);
            }

            ConnReq->tcr_req.tr_status = Status;
            (ConnReq->tcr_req.tr_rtn)(ConnReq->tcr_req.tr_context,
                                      ConnReq->tcr_req.tr_status, 0);
            FreeConnReq(ConnReq);
        }

        return FoundConn;
    }

    // The event handler didn't take it. Dereference it, free
    // the resources, and return NULL.
#if !MILLEN
AcceptIrpCancelled:
#endif // !MILLEN

    FreeConnReq(ConnReq);
    DELAY_DEREF_AO(ListenAO);

    return FALSE;
}

BOOLEAN
InitSynTCB(SYNTCB *SynTcb, AddrObj* AO, IPAddr Src, IPAddr Dest,
           TCPHeader UNALIGNED *TCPH, TCPRcvInfo *RcvInfo, uint IFIndex)
{
    CTELockHandle Handle;

    SynTcb->syntcb_state = TCB_SYN_RCVD;
    SynTcb->syntcb_flags |= CONN_ACCEPTED;

    SynTcb->syntcb_refcnt = 1;

    SynTcb->syntcb_rcvnext = ++(RcvInfo->tri_seq);
    SynTcb->syntcb_sendwin = RcvInfo->tri_window;

    SynTcb->syntcb_ttl = AO->ao_opt.ioi_ttl;
    if (AO_WINSET(AO)) {
        SynTcb->syntcb_defaultwin = AO->ao_window;
        SynTcb->syntcb_flags |= WINDOW_SET;
    } else if (DefaultRcvWin) {
        SynTcb->syntcb_defaultwin = DefaultRcvWin;
    } else {
        SynTcb->syntcb_defaultwin = DEFAULT_RCV_WIN;
    }

    CTEFreeLockFromDPC(&AO->ao_lock);

    SynTcb->syntcb_rcvwinscale = 0;
    while ((SynTcb->syntcb_rcvwinscale < TCP_MAX_WINSHIFT) &&
           ((TCP_MAXWIN << SynTcb->syntcb_rcvwinscale) <
                (int)SynTcb->syntcb_defaultwin)) {
        SynTcb->syntcb_rcvwinscale++;
    }

    // Find Remote MSS and also if WS, TS or
    // sack options are negotiated.

    SynTcb->syntcb_sndwinscale = 0;
    SynTcb->syntcb_remmss = FindMSSAndOptions(TCPH, (TCB *)SynTcb, TRUE);

    if (SynTcb->syntcb_remmss <= ALIGNED_TS_OPT_SIZE) {

        // turn off TS if mss is not sufficient to
        // hold TS fields.

        SynTcb->syntcb_tcpopts &= ~TCP_FLAG_TS;
    }

    if (!InsertSynTCB(SynTcb, &Handle)){
        FreeSynTCB(SynTcb);
        return FALSE;
    }

    TcpInvokeCcb(TCP_CONN_CLOSED, TCP_CONN_SYN_RCVD, &SynTcb->syntcb_addrbytes,
                 IFIndex);
    AddHalfOpenTCB();

    SynTcb->syntcb_rexmitcnt = 0;
    SynTcb->syntcb_rexmit = MS_TO_TICKS(3000);

    SendSYNOnSynTCB(SynTcb, Handle);

    TStats.ts_passiveopens++;
    return TRUE;
}


//* FindListenConn - Find (or fabricate) a listening connection.
//
//  Called by our Receive handler to decide what to do about an incoming
//  SYN. We walk down the list of connections associated with the destination
//  address, and if we find any in the listening state that can be used for
//  the incoming request we'll take them, possibly returning a listen in the
//  process. If we don't find any appropriate listening connections, we'll
//  call the Connect Event handler if one is registerd. If all else fails,
//  we'll return NULL and the SYN will be RST.
//
//      The caller must hold the AddrObjTableLock before calling this routine,
//      and that lock must have been taken at DPC level. This routine will free
//      that lock back to DPC level.
//
//  Input:  ListenAO            - Pointer to AddrObj for local address.
//          Src                 - Source IP address of SYN.
//          Dest                - Destination IP address of SYN.
//          SrcPort             - Source port of SYN.
//          OptInfo             - IP options info from SYN.
//          TCPH                - TCP Header of SYN.
//          RcvInfo             - Information about the SYN segment
//          IFIndex             - Interface index on which the SYN came in.
//          syn                 - [OUT] will be set if a SYN TCB was created.
//
//  Returns: Pointer to found TCB, or NULL if we can't find one.
//
TCB *
FindListenConn(AddrObj *ListenAO, IPAddr Src, IPAddr Dest, ushort SrcPort,
               IPOptInfo *OptInfo, TCPHeader UNALIGNED *TCPH,
               TCPRcvInfo *RcvInfo, ULONG IFIndex, BOOLEAN *syn)
{
    TCB *CurrentTCB = NULL;
    TCPConn *CurrentConn = NULL;
    TCPConnReq *ConnReq = NULL;
    CTELockHandle ConnHandle;
    Queue *CurrentQ, *MarkerQ, Marker;
    uint FoundConn = FALSE;
    
    BOOLEAN SecondTry = FALSE;

  funcstart:
    
    CTEStructAssert(ListenAO, ao);
    CTEGetLockAtDPC(&ListenAO->ao_lock);

    // We have the lock on the AddrObj. Walk down it's list, looking
    // for connections in the listening state.

    if (!AO_VALID(ListenAO)) {
        AddrObj * NextAddrObj;
        
        if (SecondTry) {
            CTEFreeLockFromDPC(&ListenAO->ao_lock);
            CTEFreeLockFromDPC(&AddrObjTableLock.Lock);
            return NULL;
        }

        // We will find the next best AO for another try
        CTEFreeLockFromDPC(&ListenAO->ao_lock);
        NextAddrObj = GetNextBestAddrObj(Dest, TCPH->tcp_dest, PROTOCOL_TCP,
                                         ListenAO, GAO_FLAG_CHECK_IF_LIST);
        
        if (NextAddrObj == NULL) {
            CTEFreeLockFromDPC(&AddrObjTableLock.Lock);
            return NULL;
        }
        
        ListenAO = NextAddrObj;
        SecondTry = TRUE;
        goto funcstart;
    }
    
    if (ListenAO->ao_listencnt != 0) {

        REF_AO(ListenAO);
        MarkerQ = &Marker;
        CurrentQ = QHEAD(&ListenAO->ao_listenq);

        while (CurrentQ != QEND(&ListenAO->ao_listenq)) {

            CurrentConn = QSTRUCT(TCPConn, CurrentQ, tc_q);

            INITQ(MarkerQ);
            PUSHQ(CurrentQ, MarkerQ);
            CTEFreeLockFromDPC(&ListenAO->ao_lock);

            CTEGetLockAtDPC(&(CurrentConn->tc_ConnBlock->cb_lock));
#if DBG
            CurrentConn->tc_ConnBlock->line = (uint) __LINE__;
            CurrentConn->tc_ConnBlock->module = (uchar *) __FILE__;
#endif
            CTEStructAssert(CurrentConn, tc);

            CTEGetLockAtDPC(&ListenAO->ao_lock);

            // If this TCB is in the listening state, with no delete
            // pending, it's a candidate. Look at the pending listen
            // info. to see if we should take it. Also ensure that
            // the Conn we found has not been removed from the listen queue.

            if (QPREV(MarkerQ) == CurrentQ &&
                (CurrentConn->tc_flags & CONN_INVALID) == 0 &&
                (CurrentTCB = CurrentConn->tc_tcb) != NULL &&
                CurrentTCB->tcb_state == TCB_LISTEN) {

                CTEStructAssert(CurrentTCB, tcb);
                ASSERT(CurrentTCB->tcb_state == TCB_LISTEN);

                CTEGetLockAtDPC(&CurrentTCB->tcb_lock);

                if (CurrentTCB->tcb_state == TCB_LISTEN &&
                    !PENDING_ACTION(CurrentTCB)) {

                    // Need to see if we can take it.
                    // See if the addresses specifed in the ConnReq
                    // match.
                    if ((IP_ADDR_EQUAL(CurrentTCB->tcb_daddr,
                                       NULL_IP_ADDR) ||
                         IP_ADDR_EQUAL(CurrentTCB->tcb_daddr,
                                       Src)) &&
                        (CurrentTCB->tcb_dport == 0 ||
                         CurrentTCB->tcb_dport == SrcPort)) {
                        FoundConn = TRUE;
                        REMOVEQ(MarkerQ);
                        break;
                    }
                    // Otherwise, this didn't match, so we'll check the
                    // next one.
                }
                CTEFreeLockFromDPC(&CurrentTCB->tcb_lock);
            }
            CTEFreeLockFromDPC(&CurrentConn->tc_ConnBlock->cb_lock);
            CurrentQ = QNEXT(MarkerQ);
            REMOVEQ(MarkerQ);
        }

        CTEFreeLockFromDPC(&AddrObjTableLock.Lock);
        LOCKED_DELAY_DEREF_AO(ListenAO);

        // See why we've exited the loop.
        if (FoundConn) {
            CTEStructAssert(CurrentTCB, tcb);

            // We exited because we found a TCB. If it's pre-accepted,
            // we're done.
            REFERENCE_TCB(CurrentTCB);

            ASSERT(CurrentTCB->tcb_connreq != NULL);

            ConnReq = CurrentTCB->tcb_connreq;

            CurrentTCB->tcb_daddr = Src;
            CurrentTCB->tcb_saddr = Dest;
            CurrentTCB->tcb_dport = TCPH->tcp_src;
            CurrentTCB->tcb_sport = TCPH->tcp_dest;

            // If QUERY_ACCEPT isn't set, turn on the CONN_ACCEPTED bit.
            if (!(ConnReq->tcr_flags & TCR_FLAG_QUERY_ACCEPT)) {

                CurrentTCB->tcb_flags |= CONN_ACCEPTED;
#if MILLEN
                //just use tcb_sendnext to hold hash value
                //for randisn
                CurrentTCB->tcb_sendnext = TCB_HASH(CurrentTCB->tcb_daddr, 
                                                    CurrentTCB->tcb_dport,
                                                    CurrentTCB->tcb_saddr, 
                                                    CurrentTCB->tcb_sport);

#endif

                // If CONN_ACCEPTED, TdiAccept is not called
                // again. So, get ISN when we are with in conn table lock
                GetRandomISN((PULONG)&CurrentTCB->tcb_sendnext,
                             &CurrentTCB->tcb_addrbytes);
            }
            CurrentTCB->tcb_state = TCB_SYN_RCVD;

            ListenAO->ao_listencnt--;

            // Since he's no longer listening, remove him from the listen
            // queue and put him on the active queue.
            REMOVEQ(&CurrentConn->tc_q);
            ENQUEUE(&ListenAO->ao_activeq, &CurrentConn->tc_q);

            CTEFreeLockFromDPC(&CurrentTCB->tcb_lock);
            CTEFreeLockFromDPC(&ListenAO->ao_lock);
            CTEFreeLockFromDPC(&(CurrentConn->tc_ConnBlock->cb_lock));
            return CurrentTCB;
        } else {
            // Since we have a listening count, this should never happen
            // if that count was non-zero initially.

            // We currently don't keep a good count on ao_listencnt when
            // the IRPs are cancelled.
            // ASSERT(FALSE);
        }
    } else {
        CTEFreeLockFromDPC(&AddrObjTableLock.Lock);
    }

    // We didn't find a matching TCB. If there is no connect indicate handler, 
    // we should not be creating any state.
    if (ListenAO->ao_connect == NULL) {
        AddrObj * NextAddrObj;
        
        // Try with the next AO if we can
        if (SecondTry) {
            CTEFreeLockFromDPC(&ListenAO->ao_lock);
            return NULL;
        }

        REF_AO(ListenAO);
        CTEFreeLockFromDPC(&ListenAO->ao_lock);
        CTEGetLockAtDPC(&AddrObjTableLock.Lock);
        
        NextAddrObj = GetNextBestAddrObj(Dest, TCPH->tcp_dest, PROTOCOL_TCP,
                                         ListenAO, GAO_FLAG_CHECK_IF_LIST);

        DELAY_DEREF_AO(ListenAO);
        
        if (NextAddrObj == NULL) {
            CTEFreeLockFromDPC(&AddrObjTableLock.Lock);
            return NULL;
        }

        ListenAO = NextAddrObj;
        SecondTry = TRUE;
        goto funcstart;
    }

    ASSERT(FoundConn == FALSE);

    if (SynAttackProtect){

        SYNTCB *AcceptTCB;

        AcceptTCB = AllocSynTCB();

        if (AcceptTCB) {
            AcceptTCB->syntcb_daddr = Src;
            AcceptTCB->syntcb_saddr= Dest;
            AcceptTCB->syntcb_dport= TCPH->tcp_src;
            AcceptTCB->syntcb_sport= TCPH->tcp_dest;

            GetRandomISN((PULONG)&AcceptTCB->syntcb_sendnext,
                         &AcceptTCB->syntcb_addrbytes);
            if (InitSynTCB(AcceptTCB, ListenAO, Src, Dest, TCPH, RcvInfo,
                           IFIndex)) {
                *syn = TRUE;
            }
            // Fall through. (ListenAO->ao_lock was freed by InitSynTCB.)
        } else {
            CTEFreeLockFromDPC(&ListenAO->ao_lock);
        }
    } else {
        uchar TAddress[TCP_TA_SIZE];
        PVOID ConnContext;
        PConnectEvent Event;
        PVOID EventContext;
        TDI_STATUS Status;
        TCB *AcceptTCB;
        TCPConnReq *ConnReq;
        PTCP_CONTEXT TcpContext = NULL;
#if !MILLEN
        ConnectEventInfo *EventInfo;
#else // !MILLEN
        ConnectEventInfo EventInfo;
#endif // MILLEN

        // He has a connect handler. Put the transport address together,
        // and call him. We also need to get the necessary resources
        // first.

        Event = ListenAO->ao_connect;
        EventContext = ListenAO->ao_conncontext;
        REF_AO(ListenAO);
        CTEFreeLockFromDPC(&ListenAO->ao_lock);

        AcceptTCB = AllocTCB();
        ConnReq = GetConnReq();

        if (AcceptTCB != NULL && ConnReq != NULL) {
            BuildTDIAddress(TAddress, Src, SrcPort);

            AcceptTCB->tcb_state = TCB_LISTEN;
            AcceptTCB->tcb_connreq = ConnReq;
            AcceptTCB->tcb_flags |= CONN_ACCEPTED;

            IF_TCPDBG(TCP_DEBUG_CONNECT) {
                TCPTRACE(("indicating connect request\n"));
            }

            Status = (*Event) (EventContext, TCP_TA_SIZE,
                               (PTRANSPORT_ADDRESS) TAddress, 0, NULL,
                               OptInfo->ioi_optlength, OptInfo->ioi_options,
                               &ConnContext, &EventInfo);
            
            if (Status == TDI_MORE_PROCESSING) {
#if !MILLEN
                PIO_STACK_LOCATION IrpSp;
                PTDI_REQUEST_KERNEL_ACCEPT AcceptRequest;

                IrpSp = IoGetCurrentIrpStackLocation(EventInfo);

                Status = TCPPrepareIrpForCancel(
                                                (PTCP_CONTEXT) IrpSp->FileObject->FsContext,
                                                EventInfo,
                                                TCPCancelRequest
                                                );

                if (!NT_SUCCESS(Status)) {
                     Status = TDI_NOT_ACCEPTED;
                     EventInfo = NULL;
                    goto AcceptIrpCancelled;
                }

                // He accepted it. Find the connection on the AddrObj.
                {

                    IF_TCPDBG(TCP_DEBUG_CONNECT) {
                        TCPTRACE((
                                  "connect indication accepted, queueing request\n"
                                 ));
                    }

                    AcceptRequest = (PTDI_REQUEST_KERNEL_ACCEPT)
                        & (IrpSp->Parameters);
                    ConnReq->tcr_conninfo =
                        AcceptRequest->ReturnConnectionInformation;
                    if (AcceptRequest->RequestConnectionInformation &&
                        AcceptRequest->RequestConnectionInformation->RemoteAddress) {
                        ConnReq->tcr_addrinfo =
                            AcceptRequest->RequestConnectionInformation;
                    } else {
                        ConnReq->tcr_addrinfo = NULL;
                    }
                    ConnReq->tcr_req.tr_rtn = TCPRequestComplete;
                    ConnReq->tcr_req.tr_context = EventInfo;
                    ConnReq->tcr_flags = 0;
                }

#else // !MILLEN
                ConnReq->tcr_req.tr_rtn = EventInfo.cei_rtn;
                ConnReq->tcr_req.tr_context = EventInfo.cei_context;
                ConnReq->tcr_conninfo = EventInfo.cei_conninfo;
                ConnReq->tcr_addrinfo = NULL;
#endif // MILLEN

                CurrentConn = NULL;

#if !MILLEN

                if ((IrpSp->FileObject->DeviceObject == TCPDeviceObject) &&
                    (PtrToUlong(IrpSp->FileObject->FsContext2) == TDI_CONNECTION_FILE) &&
                    ((TcpContext = IrpSp->FileObject->FsContext) != NULL) &&
                    ((CurrentConn =
                        GetConnFromConnID(
                            PtrToUlong(TcpContext->Handle.ConnectionContext),
                            &ConnHandle)) != NULL) &&
                    (CurrentConn->tc_context == ConnContext) &&
                    !(CurrentConn->tc_flags & CONN_INVALID)) {

                    CTEGetLockAtDPC(&ListenAO->ao_lock);

                    // Found the Conn structure!!
                    // Don't have to loop below.
                    CTEStructAssert(CurrentConn, tc);

                    AcceptTCB->tcb_refcnt = 0;
                    REFERENCE_TCB(AcceptTCB);
                    Status = InitTCBFromConn(CurrentConn, AcceptTCB,
                                             AcceptRequest->RequestConnectionInformation,
                                             TRUE);

                    // Let's store the connection invariants upfront. 
                    AcceptTCB->tcb_daddr = Src;
                    AcceptTCB->tcb_saddr= Dest;
                    AcceptTCB->tcb_dport= TCPH->tcp_src;
                    AcceptTCB->tcb_sport= TCPH->tcp_dest;

                    if (Status == TDI_SUCCESS) {
                        FoundConn = TRUE;
                        AcceptTCB->tcb_state = TCB_SYN_RCVD;
                        AcceptTCB->tcb_conn = CurrentConn;
                        AcceptTCB->tcb_connid = CurrentConn->tc_connid;
                        CurrentConn->tc_tcb = AcceptTCB;
                        CurrentConn->tc_refcnt++;

                        GetRandomISN((PULONG)&AcceptTCB->tcb_sendnext, 
                                     &AcceptTCB->tcb_addrbytes);
                        
                        // Move him from the idle q to the active
                        // queue.
                        REMOVEQ(&CurrentConn->tc_q);
                        PUSHQ(&ListenAO->ao_activeq, &CurrentConn->tc_q);
                    } else {
                        CTEFreeLockFromDPC(&ListenAO->ao_lock);
                        CTEFreeLockFromDPC(&CurrentConn->tc_ConnBlock->cb_lock);
                    }

                } else {

#endif // !MILLEN

                    if (CurrentConn) {
                        CTEFreeLockFromDPC(&CurrentConn->tc_ConnBlock->cb_lock);
                    }

                    CTEGetLockAtDPC(&AddrObjTableLock.Lock);
                    CTEGetLockAtDPC(&ListenAO->ao_lock);

                    MarkerQ = &Marker;
                    CurrentQ = QHEAD(&ListenAO->ao_idleq);;

                    CurrentTCB = NULL;
                    Status = TDI_INVALID_CONNECTION;

                    while (CurrentQ != QEND(&ListenAO->ao_idleq)) {
                        CurrentConn = QSTRUCT(TCPConn, CurrentQ, tc_q);

                        INITQ(MarkerQ);
                        PUSHQ(CurrentQ, MarkerQ);

                        CTEFreeLockFromDPC(&ListenAO->ao_lock);
                        CTEGetLockAtDPC(&CurrentConn->tc_ConnBlock->cb_lock);
#if DBG
                        CurrentConn->tc_ConnBlock->line = (uint) __LINE__;
                        CurrentConn->tc_ConnBlock->module = (uchar *) __FILE__;
#endif
                        CTEGetLockAtDPC(&ListenAO->ao_lock);

                        CTEStructAssert(CurrentConn, tc);
                        if (QPREV(MarkerQ) == CurrentQ &&
                            CurrentConn->tc_context == ConnContext &&
                            !(CurrentConn->tc_flags & CONN_INVALID)) {

                            // We think we have a match. The connection
                            // shouldn't have a TCB associated with it. If it
                            // does, it's an error. InitTCBFromConn will
                            // handle all this.

                            AcceptTCB->tcb_refcnt = 0;
                            REFERENCE_TCB(AcceptTCB);
                            Status = InitTCBFromConn(CurrentConn, AcceptTCB,
                                                     AcceptRequest->RequestConnectionInformation,
                                                     TRUE);

                            // Let's store the connection invariants upfront. 
                            AcceptTCB->tcb_daddr = Src;
                            AcceptTCB->tcb_saddr= Dest;
                            AcceptTCB->tcb_dport= TCPH->tcp_src;
                            AcceptTCB->tcb_sport= TCPH->tcp_dest;

                            if (Status == TDI_SUCCESS) {
                                FoundConn = TRUE;
                                AcceptTCB->tcb_state = TCB_SYN_RCVD;
                                AcceptTCB->tcb_conn = CurrentConn;
                                AcceptTCB->tcb_connid = CurrentConn->tc_connid;
                                CurrentConn->tc_tcb = AcceptTCB;
                                CurrentConn->tc_refcnt++;

                                GetRandomISN((PULONG)&AcceptTCB->tcb_sendnext,
                                             &AcceptTCB->tcb_addrbytes);

                                // Move him from the idle q to the active
                                // queue.
                                REMOVEQ(&CurrentConn->tc_q);
                                ENQUEUE(&ListenAO->ao_activeq, &CurrentConn->tc_q);
                            } else {
                                CTEFreeLockFromDPC(
                                    &CurrentConn->tc_ConnBlock->cb_lock);
                            }

                            // In any case, we're done now.
                            REMOVEQ(MarkerQ);
                            break;
                        }
                        CTEFreeLockFromDPC(&CurrentConn->tc_ConnBlock->cb_lock);
                        CurrentQ = QNEXT(MarkerQ);
                        REMOVEQ(MarkerQ);
                    }
                    if (!FoundConn) {
                        CTEFreeLockFromDPC(&ListenAO->ao_lock);
                    }

                    CTEFreeLockFromDPC(&AddrObjTableLock.Lock);
#if !MILLEN
                }
#endif // !MILLEN

                if (!FoundConn) {
                    // Didn't find a match, or had an error. Status
                    // code is set.
                    // Complete the ConnReq and free the resources.
                    CTEGetLockAtDPC(&AcceptTCB->tcb_lock);
                    CompleteConnReq(AcceptTCB, OptInfo, Status);
                    CTEFreeLockFromDPC(&AcceptTCB->tcb_lock);
                    FreeTCB(AcceptTCB);
                    AcceptTCB = NULL;
                }

                if (FoundConn) {
                    LOCKED_DELAY_DEREF_AO(ListenAO);
                    CTEFreeLockFromDPC(&ListenAO->ao_lock);
                    CTEFreeLockFromDPC(&CurrentConn->tc_ConnBlock->cb_lock);
                } else {
                    DELAY_DEREF_AO(ListenAO);
                }

                return AcceptTCB;

            }                //tdi_more_processing


#if !MILLEN
          AcceptIrpCancelled:
#endif // !MILLEN

            // The event handler didn't take it. Dereference it, free
            // the resources, and return NULL.
            FreeConnReq(ConnReq);
            FreeTCB(AcceptTCB);
            
            // Try again if we can with the next best AO
            if (!SecondTry && (Status == TDI_CONN_REFUSED)) {
                AddrObj * NextAddrObj;
                
                CTEGetLockAtDPC(&AddrObjTableLock.Lock);

                NextAddrObj = GetNextBestAddrObj(Dest, TCPH->tcp_dest,
                                                 PROTOCOL_TCP, ListenAO,
                                                 GAO_FLAG_CHECK_IF_LIST);

                if (NextAddrObj == NULL) {
                    CTEFreeLockFromDPC(&AddrObjTableLock.Lock);
                } else {
                    DELAY_DEREF_AO(ListenAO);

                    ListenAO = NextAddrObj;
                    SecondTry = TRUE;
                    goto funcstart;
                }
            } 

            DELAY_DEREF_AO(ListenAO);
            return NULL;

        } else {
            // We couldn't get a needed resources. Free any that we
            // did get, and fall through to the 'return NULL' code.

            DELAY_DEREF_AO(ListenAO);

            if (ConnReq != NULL)
                FreeConnReq(ConnReq);
            if (AcceptTCB != NULL)
                FreeTCB(AcceptTCB);
        }
    }
    return NULL;
}

// FindMSSAndOptions
//
//  Called when a SYN is received to find the MSS option in a segment. If we
//  don't find one, we assume the worst and return 536.
//
//  Also, parses incoming header for window scaling, timestamp and SACK
//  options. Note that we will enable these options for the connection
//  only if they are enabled on this host.
//
//
//  Input:  TCPH        - TCP header to be searched.
//          SynTCB      - the TCB or SYNTCB to be updated.
//          IsSYNTCB    - if TRUE, 'SynTCB' is of type 'SYNTCB'.
//
//  Returns: MSS to be used.
//
ushort
FindMSSAndOptions(TCPHeader UNALIGNED * TCPH, TCB * SynTCB, BOOLEAN IsSYNTCB)
{
    uint OptSize;
    uchar *OptPtr;
    ushort TempMss = 0;
    BOOLEAN WinScale = FALSE;
    ushort SYN = 0;
    ushort tcboptions;
    short rcvwinscale=0,sndwinscale=0;
    int tsupdate=0,tsrecent=0;

    OptSize = TCP_HDR_SIZE(TCPH) - sizeof(TCPHeader);
    OptPtr = (uchar *) (TCPH + 1);
    SYN = (TCPH->tcp_flags & TCP_FLAG_SYN);

    if (IsSYNTCB) {
        tcboptions = ((SYNTCB *)SynTCB)->syntcb_tcpopts;
        rcvwinscale = ((SYNTCB *)SynTCB)->syntcb_rcvwinscale;
    } else {
        tcboptions = SynTCB->tcb_tcpopts;
        rcvwinscale = SynTCB->tcb_rcvwinscale;
    }

    while ((int)OptSize > 0) {

        if (*OptPtr == TCP_OPT_EOL)
            break;

        if (*OptPtr == TCP_OPT_NOP) {
            OptPtr++;
            OptSize--;
            continue;
        }
        if ((*OptPtr == TCP_OPT_MSS) && (OptSize >= MSS_OPT_SIZE)) {

            if (SYN && (OptPtr[1] == MSS_OPT_SIZE)) {
                TempMss = *(ushort UNALIGNED *) (OptPtr + 2);
                TempMss = net_short(TempMss);
            }
            OptSize -= MSS_OPT_SIZE;
            OptPtr += MSS_OPT_SIZE;

        } else if ((*OptPtr == TCP_OPT_WS) && (OptSize >= WS_OPT_SIZE)) {

            if (SYN && (OptPtr[1] == WS_OPT_SIZE)) {

                sndwinscale = (uint)OptPtr[2];

                IF_TCPDBG(TCP_DEBUG_1323) {
                    TCPTRACE(("WS option %x", sndwinscale));
                }
                tcboptions |= TCP_FLAG_WS;
                WinScale = TRUE;
            }
            OptSize -= WS_OPT_SIZE;
            OptPtr += WS_OPT_SIZE;

        } else if ((*OptPtr == TCP_OPT_TS) && (OptSize >= TS_OPT_SIZE)) {
            // Time stamp options
            if ((OptPtr[1] == TS_OPT_SIZE) && (TcpHostOpts & TCP_FLAG_TS)) {
                int tsval = *(int UNALIGNED *)&OptPtr[2];

                tcboptions |= TCP_FLAG_TS;
                if (SYN) {
                    tsupdate = TCPTime;
                    tsrecent = net_long(tsval);
                }
                IF_TCPDBG(TCP_DEBUG_1323) {
                    TCPTRACE(("TS option %x", SynTCB));
                }
            }
            OptSize -= TS_OPT_SIZE;
            OptPtr += TS_OPT_SIZE;

        } else if ((*OptPtr == TCP_SACK_PERMITTED_OPT)
                   && (OptSize >= SACK_PERMITTED_OPT_SIZE)) {
            // SACK OPtions
            if ((OptPtr[1] == SACK_PERMITTED_OPT_SIZE)
                && (TcpHostOpts & TCP_FLAG_SACK)) {

                tcboptions |= TCP_FLAG_SACK;
                IF_TCPDBG(TCP_DEBUG_SACK) {
                    TCPTRACE(("Rcvd SACK_OPT %x\n", SynTCB));
                }
            }
            OptSize -= SACK_PERMITTED_OPT_SIZE;
            OptPtr += SACK_PERMITTED_OPT_SIZE;

        } else {                // Unknown option.
            if (OptSize > 1) {
                if (OptPtr[1] == 0 || OptPtr[1] > OptSize) {
                    break;        // Bad option length, bail out.
                }

                OptSize -= OptPtr[1];
                OptPtr += OptPtr[1];
            } else {
                break;
            }
        }
    }

    if (WinScale) {
        if (sndwinscale > TCP_MAX_WINSHIFT) {
            sndwinscale = TCP_MAX_WINSHIFT;
        }
    }

    if (IsSYNTCB) {
        ((SYNTCB *)SynTCB)->syntcb_tcpopts = (uchar)tcboptions;
        ((SYNTCB *)SynTCB)->syntcb_tsupdatetime = tsupdate;
        ((SYNTCB *)SynTCB)->syntcb_tsrecent = tsrecent;
        if (!WinScale && rcvwinscale) {
            ((SYNTCB *)SynTCB)->syntcb_defaultwin = TCP_MAXWIN;
            ((SYNTCB *)SynTCB)->syntcb_rcvwinscale = 0;
        }
        ((SYNTCB *)SynTCB)->syntcb_sndwinscale = sndwinscale;

    } else {
        SynTCB->tcb_tcpopts = tcboptions;
        SynTCB->tcb_tsupdatetime = tsupdate;
        SynTCB->tcb_tsrecent = tsrecent;

        if (!WinScale && rcvwinscale) {
            SynTCB->tcb_defaultwin = TCP_MAXWIN;
            SynTCB->tcb_rcvwin = TCP_MAXWIN;
            SynTCB->tcb_rcvwinscale = 0;
        }

        SynTCB->tcb_sndwinscale = sndwinscale;
    }

    if (TempMss) {
        return (TempMss);
    } else {
        return MAX_REMOTE_MSS;
    }
}


//* ACKAndDrop - Acknowledge a segment, and drop it.
//
//  Called from within the receive code when we need to drop a segment that's
//  outside the receive window.
//
//  Input:  RI          - Receive info for incoming segment.
//          RcvTCB      - TCB for incoming segment.
//
//  Returns: Nothing.
//
void
ACKAndDrop(TCPRcvInfo * RI, TCB * RcvTCB)
{
    if (!(RI->tri_flags & TCP_FLAG_RST)) {
        CTEFreeLockFromDPC(&RcvTCB->tcb_lock);
        SendACK(RcvTCB);
        CTEGetLockAtDPC(&RcvTCB->tcb_lock);
    }
    DerefTCB(RcvTCB, DISPATCH_LEVEL);

}

//* ACKData - Acknowledge data.
//
//  Called from the receive handler to acknowledge data. We're given the
//  TCB and the new value of senduna. We walk down the send q. pulling
//  off sends and putting them on the complete q until we hit the end
//  or we acknowledge the specified number of bytes of data.
//
//  NOTE: We manipulate the send refcnt and acked flag without taking a lock.
//  This is OK in the VxD version where locks don't mean anything anyway, but
//  in the port to NT we'll need to add locking. The lock will have to be
//  taken in the transmit complete routine. We can't use a lock in the TCB,
//  since the TCB could go away before the transmit complete happens, and a lock
//  in the TSR would be overkill, so it's probably best to use a global lock
//  for this. If that causes too much contention, we could use a set of locks
//  and pass a pointer to the appropriate lock back as part of the transmit
//  confirm context. This lock pointer would also need to be stored in the
//  TCB.
//
//  Input:  ACKTcb          - TCB from which to pull data.
//          SendUNA         - New value of send una.
//          SendQ           - Queue to be filled with ACK'd requests.
//
//  Returns: Nothing.
//
void
ACKData(TCB * ACKTcb, SeqNum SendUNA, Queue* SendQ)
{
    Queue *End, *Current;        // End and current elements.
    Queue *TempQ, *EndQ;
    Queue *LastCmplt;            // Last one we completed.
    TCPSendReq *CurrentTSR;        // Current send req we're
    // looking at.
    PNDIS_BUFFER CurrentBuffer;    // Current NDIS_BUFFER.
    uint BufLength;
    int Amount, OrigAmount;
    long Result;
    uint Temp;


#if TRACE_EVENT
    PTDI_DATA_REQUEST_NOTIFY_ROUTINE CPCallBack;
    WMIData WMIInfo;
#endif

    CTEStructAssert(ACKTcb, tcb);

    CheckTCBSends(ACKTcb);

    Amount = SendUNA - ACKTcb->tcb_senduna;
    ASSERT(Amount > 0);

    // if the receiver is acking something for which we have
    // a sack entry, remove it.
    if (ACKTcb->tcb_SackRcvd) {
        SackListEntry *Prev, *Current;

        Prev = STRUCT_OF(SackListEntry, &ACKTcb->tcb_SackRcvd, next);
        Current = ACKTcb->tcb_SackRcvd;

        // Scan the list for old sack entries and purge them

        while ((Current != NULL) && SEQ_GT(SendUNA, Current->begin)) {
            Prev->next = Current->next;

            IF_TCPDBG(TCP_DEBUG_SACK) {
                TCPTRACE(("ACKData:Purging old entries  %x %d %d\n", Current, Current->begin, Current->end));
            }
            CTEFreeMem(Current);
            Current = Prev->next;
        }
    }

    // Do a quick check to see if this acks everything that we have. If it does,
    // handle it right away. We can only do this in the ESTABLISHED state,
    // because we blindly update sendnext, and that can only work if we
    // haven't sent a FIN.
    if ((Amount == (int)ACKTcb->tcb_unacked) && ACKTcb->tcb_state == TCB_ESTAB) {

        // Everything is acked.
        ASSERT(!EMPTYQ(&ACKTcb->tcb_sendq));

        TempQ = ACKTcb->tcb_sendq.q_next;

        INITQ(&ACKTcb->tcb_sendq);

        ACKTcb->tcb_sendnext = SendUNA;
        ACKTcb->tcb_senduna = SendUNA;

        ASSERT(ACKTcb->tcb_sendnext == ACKTcb->tcb_sendmax);
        ACKTcb->tcb_cursend = NULL;
        ACKTcb->tcb_sendbuf = NULL;
        ACKTcb->tcb_sendofs = 0;
        ACKTcb->tcb_sendsize = 0;
        ACKTcb->tcb_unacked = 0;

        // Now walk down the list of send requests. If the reference count
        // has gone to 0, put it on the send complete queue.


        EndQ = &ACKTcb->tcb_sendq;
        do {
            CurrentTSR = STRUCT_OF(TCPSendReq, QSTRUCT(TCPReq, TempQ, tr_q), tsr_req);

            CTEStructAssert(CurrentTSR, tsr);

            TempQ = CurrentTSR->tsr_req.tr_q.q_next;

            CurrentTSR->tsr_req.tr_status = TDI_SUCCESS;
            Result = CTEInterlockedDecrementLong(&CurrentTSR->tsr_refcnt);

            ASSERT(Result >= 0);

#if TRACE_EVENT
            CPCallBack = TCPCPHandlerRoutine;
            if (CPCallBack != NULL) {
                ulong GroupType;

                WMIInfo.wmi_destaddr = ACKTcb->tcb_daddr;
                WMIInfo.wmi_destport = ACKTcb->tcb_dport;
                WMIInfo.wmi_srcaddr  = ACKTcb->tcb_saddr;
                WMIInfo.wmi_srcport  = ACKTcb->tcb_sport;
                WMIInfo.wmi_size     = CurrentTSR->tsr_size;
                WMIInfo.wmi_context  = ACKTcb->tcb_cpcontext;

                GroupType = EVENT_TRACE_GROUP_TCPIP + EVENT_TRACE_TYPE_SEND;
                (*CPCallBack)(GroupType, (PVOID)&WMIInfo, sizeof(WMIInfo),
                              NULL);
            }
#endif

            if ((Result <= 0) &&
                !(CurrentTSR->tsr_flags & TSR_FLAG_SEND_AND_DISC)) {
                // No more references are outstanding, the send can be
                // completed.

                // If we've sent directly from this send, NULL out the next
                // pointer for the last buffer in the chain.
                if (CurrentTSR->tsr_lastbuf != NULL) {
                    NDIS_BUFFER_LINKAGE(CurrentTSR->tsr_lastbuf) = NULL;
                    CurrentTSR->tsr_lastbuf = NULL;
                }
                ACKTcb->tcb_totaltime += (TCPTime - CurrentTSR->tsr_time);
                Temp = ACKTcb->tcb_bcountlow;
                ACKTcb->tcb_bcountlow += CurrentTSR->tsr_size;
                ACKTcb->tcb_bcounthi += (Temp > ACKTcb->tcb_bcountlow ? 1 : 0);

                ENQUEUE(SendQ, &CurrentTSR->tsr_req.tr_q);
            }
        } while (TempQ != EndQ);

        CheckTCBSends(ACKTcb);
        return;
    }

    OrigAmount = Amount;
    End = QEND(&ACKTcb->tcb_sendq);
    Current = QHEAD(&ACKTcb->tcb_sendq);

    LastCmplt = NULL;

    while (Amount > 0 && Current != End) {
        CurrentTSR = STRUCT_OF(TCPSendReq, QSTRUCT(TCPReq, Current, tr_q),
                               tsr_req);
        CTEStructAssert(CurrentTSR, tsr);

        if (Amount >= (int)CurrentTSR->tsr_unasize) {
            // This is completely acked. Just advance to the next one.
            Amount -= CurrentTSR->tsr_unasize;

            LastCmplt = Current;

            Current = QNEXT(Current);
            continue;
        }
        // This one is only partially acked. Update his offset and NDIS buffer
        // pointer, and break out. We know that Amount is < the unacked size
        // in this buffer, we we can walk the NDIS buffer chain without fear
        // of falling off the end.
        CurrentBuffer = CurrentTSR->tsr_buffer;
        ASSERT(CurrentBuffer != NULL);
        ASSERT(Amount < (int)CurrentTSR->tsr_unasize);
        CurrentTSR->tsr_unasize -= Amount;

        BufLength = NdisBufferLength(CurrentBuffer) - CurrentTSR->tsr_offset;

        if (Amount >= (int)BufLength) {
            do {
                Amount -= BufLength;
                CurrentBuffer = NDIS_BUFFER_LINKAGE(CurrentBuffer);
                ASSERT(CurrentBuffer != NULL);
                BufLength = NdisBufferLength(CurrentBuffer);
            } while (Amount >= (int)BufLength);

            CurrentTSR->tsr_offset = Amount;
            CurrentTSR->tsr_buffer = CurrentBuffer;

        } else
            CurrentTSR->tsr_offset += Amount;

        Amount = 0;

        break;
    }

    // We should always be able to remove at least Amount bytes, except in
    // the case where a FIN has been sent. In that case we should be off
    // by exactly one. In the debug builds we'll check this.
    ASSERT(0 == Amount || ((ACKTcb->tcb_flags & FIN_SENT) && (1 == Amount)));

    if (SEQ_GT(SendUNA, ACKTcb->tcb_sendnext)) {

        if (Current != End) {
            // Need to reevaluate CurrentTSR, in case we bailed out of the
            // above loop after updating Current but before updating
            // CurrentTSR.
            CurrentTSR = STRUCT_OF(TCPSendReq, QSTRUCT(TCPReq, Current, tr_q),
                                   tsr_req);
            CTEStructAssert(CurrentTSR, tsr);
            ACKTcb->tcb_cursend = CurrentTSR;
            ACKTcb->tcb_sendbuf = CurrentTSR->tsr_buffer;
            ACKTcb->tcb_sendofs = CurrentTSR->tsr_offset;
            ACKTcb->tcb_sendsize = CurrentTSR->tsr_unasize;
        } else {
            ACKTcb->tcb_cursend = NULL;
            ACKTcb->tcb_sendbuf = NULL;
            ACKTcb->tcb_sendofs = 0;
            ACKTcb->tcb_sendsize = 0;
        }

        ACKTcb->tcb_sendnext = SendUNA;
    }
    // Now update tcb_unacked with the amount we tried to ack minus the
    // amount we didn't ack (Amount should be 0 or 1 here).
    ASSERT(Amount == 0 || Amount == 1);


    if (ACKTcb->tcb_unacked) {

        ASSERT(ACKTcb->tcb_unacked >= (uint)OrigAmount - Amount);
        ACKTcb->tcb_unacked -= OrigAmount - Amount;
    }

    ASSERT(*(int *)&ACKTcb->tcb_unacked >= 0);

    ACKTcb->tcb_senduna = SendUNA;

    // If we've acked any here, LastCmplt will be non-null, and Current will
    // point to the send that should be at the start of the queue. Splice
    // out the completed ones and put them on the end of the send completed
    // queue, and update the TCB send q.
    if (LastCmplt != NULL) {
        Queue *FirstCmplt;
        TCPSendReq *FirstTSR, *EndTSR;

        ASSERT(!EMPTYQ(&ACKTcb->tcb_sendq));

        FirstCmplt = QHEAD(&ACKTcb->tcb_sendq);

        // If we've acked everything, just reinit the queue.
        if (Current == End) {
            INITQ(&ACKTcb->tcb_sendq);
        } else {
            // There's still something on the queue. Just update it.
            ACKTcb->tcb_sendq.q_next = Current;
            Current->q_prev = &ACKTcb->tcb_sendq;
        }

        CheckTCBSends(ACKTcb);

        // Now walk down the lists of things acked. If the refcnt on the send
        // is 0, go ahead and put him on the send complete Q. Otherwise set
        // the ACKed bit in the send, and he'll be completed when the count
        // goes to 0 in the transmit confirm.
        //
        // Note that we haven't done any locking here. This will probably
        // need to change in the port to NT.

        // Set FirstTSR to the first TSR we'll complete, and EndTSR to be
        // the first TSR that isn't completed.

        FirstTSR = STRUCT_OF(TCPSendReq, QSTRUCT(TCPReq, FirstCmplt, tr_q), tsr_req);
        EndTSR = STRUCT_OF(TCPSendReq, QSTRUCT(TCPReq, Current, tr_q), tsr_req);

        CTEStructAssert(FirstTSR, tsr);
        ASSERT(FirstTSR != EndTSR);

        // Now walk the list of ACKed TSRs. If we can complete one, put him
        // on the complete queue.


        while (FirstTSR != EndTSR) {

            TempQ = QNEXT(&FirstTSR->tsr_req.tr_q);

            CTEStructAssert(FirstTSR, tsr);
            FirstTSR->tsr_req.tr_status = TDI_SUCCESS;

            // The tsr_lastbuf->Next field is zapped to 0 when the tsr_refcnt
            // goes to 0, so we don't need to do it here.

#if TRACE_EVENT
            CPCallBack = TCPCPHandlerRoutine;
            if (CPCallBack != NULL) {
                ulong GroupType;

                WMIInfo.wmi_destaddr = ACKTcb->tcb_daddr;
                WMIInfo.wmi_destport = ACKTcb->tcb_dport;
                WMIInfo.wmi_srcaddr  = ACKTcb->tcb_saddr;
                WMIInfo.wmi_srcport  = ACKTcb->tcb_sport;
                WMIInfo.wmi_size     = FirstTSR->tsr_size;
                WMIInfo.wmi_context  = ACKTcb->tcb_cpcontext;

                GroupType = EVENT_TRACE_GROUP_TCPIP + EVENT_TRACE_TYPE_SEND;
                (*CPCallBack)(GroupType, (PVOID)&WMIInfo, sizeof(WMIInfo),
                              NULL);
            }
#endif

            // Decrement the reference put on the send buffer when it was
            // initialized indicating the send has been acknowledged.

            if (!(FirstTSR->tsr_flags & TSR_FLAG_SEND_AND_DISC)) {

                Result = CTEInterlockedDecrementLong(&FirstTSR->tsr_refcnt);

                ASSERT(Result >= 0);

                if (Result <= 0) {
                    // No more references are outstanding, the send can be
                    // completed.

                    // If we've sent directly from this send, NULL out the next
                    // pointer for the last buffer in the chain.
                    if (FirstTSR->tsr_lastbuf != NULL) {
                        NDIS_BUFFER_LINKAGE(FirstTSR->tsr_lastbuf) = NULL;
                        FirstTSR->tsr_lastbuf = NULL;
                    }
                    ACKTcb->tcb_totaltime += (TCPTime - FirstTSR->tsr_time);
                    Temp = ACKTcb->tcb_bcountlow;
                    ACKTcb->tcb_bcountlow += FirstTSR->tsr_size;
                    ACKTcb->tcb_bcounthi +=
                        (Temp > ACKTcb->tcb_bcountlow ? 1 : 0);

                    ENQUEUE(SendQ, &FirstTSR->tsr_req.tr_q);
                }
            } else {
                if (EMPTYQ(&ACKTcb->tcb_sendq) &&
                    (FirstTSR->tsr_flags & TSR_FLAG_SEND_AND_DISC)) {
                    ENQUEUE(&ACKTcb->tcb_sendq, &FirstTSR->tsr_req.tr_q);
                    ACKTcb->tcb_fastchk |= TCP_FLAG_REQUEUE_FROM_SEND_AND_DISC;
                    //this will be deleted when CloseTCB will be called on this.
                    CheckTCBSends(ACKTcb);
                    break;
                }
            }

            FirstTSR = STRUCT_OF(TCPSendReq, QSTRUCT(TCPReq, TempQ, tr_q), tsr_req);
        }
    }
}

//* TrimRcvBuf - Trim the front edge of a receive buffer.
//
//  A utility routine to trim the front of a receive buffer. We take in a
//  a count (which may be 0) and adjust the pointer in the first buffer in
//  the chain by that much. If there isn't that much in the first buffer,
//  we move onto the next one. If we run out of buffers we'll return a pointer
//      to the last buffer in the chain, with a size of 0. It's the caller's
//      responsibility to catch this.
//
//  Input:  RcvBuf      - Buffer to be trimmed.
//          Count       - Amount to be trimmed.
//
//  Returns: A pointer to the new start, or NULL.
//
IPRcvBuf *
TrimRcvBuf(IPRcvBuf * RcvBuf, uint Count)
{
    uint TrimThisTime;

    ASSERT(RcvBuf != NULL);

    while (Count) {
        ASSERT(RcvBuf != NULL);

        TrimThisTime = MIN(Count, RcvBuf->ipr_size);
        Count -= TrimThisTime;
        RcvBuf->ipr_buffer += TrimThisTime;
        if ((RcvBuf->ipr_size -= TrimThisTime) == 0) {
            if (RcvBuf->ipr_next != NULL)
                RcvBuf = RcvBuf->ipr_next;
            else {
                // Ran out of buffers. Just return this one.
                break;
            }
        }
    }

    return RcvBuf;

}


IPRcvBuf DummyBuf;

//* PullFromRAQ - Pull segments from the reassembly queue.
//
//  Called when we've received frames out of order, and have some segments
//  on the reassembly queue. We'll walk down the reassembly list, segments that
//  are overlapped by the current rcv. next variable. When we get
//  to one that doesn't completely overlap we'll trim it to fit the next
//  rcv. seq. number, and pull it from the queue.
//
//  Input:  RcvTCB          - TCB to pull from.
//          RcvInfo         - Pointer to TCPRcvInfo structure for current seg.
//          Size            - Pointer to size for current segment. We'll update
//                              this when we're done.
//
//  Returns: Nothing.
//
IPRcvBuf *
PullFromRAQ(TCB * RcvTCB, TCPRcvInfo * RcvInfo, uint * Size)
{
    TCPRAHdr *CurrentTRH;        // Current TCP RA Header being examined.
    TCPRAHdr *TempTRH;            // Temporary variable.
    SeqNum NextSeq;                // Next sequence number we want.
    IPRcvBuf *NewBuf;
    SeqNum NextTRHSeq;            // Seq. number immediately after
    // current TRH.
    int Overlap;                // Overlap between current TRH and
    // NextSeq.

    CTEStructAssert(RcvTCB, tcb);

    CurrentTRH = RcvTCB->tcb_raq;
    NextSeq = RcvTCB->tcb_rcvnext;

    while (CurrentTRH != NULL) {
        CTEStructAssert(CurrentTRH, trh);
        ASSERT(!(CurrentTRH->trh_flags & TCP_FLAG_SYN));

        if (SEQ_LT(NextSeq, CurrentTRH->trh_start)) {
#if DBG
            *Size = 0;
#endif

            //invalidate Sack Block
            if ((RcvTCB->tcb_tcpopts & TCP_FLAG_SACK) && RcvTCB->tcb_SackBlock) {
                int i;
                for (i = 0; i < 3; i++) {
                    if ((RcvTCB->tcb_SackBlock->Mask[i] != 0) &&
                        (SEQ_LT(RcvTCB->tcb_SackBlock->Block[i].end, CurrentTRH->trh_start))) {
                        RcvTCB->tcb_SackBlock->Mask[i] = 0;
                    }
                }
            }

            return NULL;        // The next TRH starts too far down.

        }
        NextTRHSeq = CurrentTRH->trh_start + CurrentTRH->trh_size +
            ((CurrentTRH->trh_flags & TCP_FLAG_FIN) ? 1 : 0);

        if (SEQ_GTE(NextSeq, NextTRHSeq)) {
            // The current TRH is overlapped completely. Free it and continue.
            FreeRBChain(CurrentTRH->trh_buffer);
            TempTRH = CurrentTRH->trh_next;
            CTEFreeMem(CurrentTRH);
            CurrentTRH = TempTRH;
            RcvTCB->tcb_raq = TempTRH;
            if (TempTRH == NULL) {
                // We've just cleaned off the RAQ. We can go back on the
                // fast path now.
                if (--(RcvTCB->tcb_slowcount) == 0) {
                    RcvTCB->tcb_fastchk &= ~TCP_FLAG_SLOW;
                    CheckTCBRcv(RcvTCB);
                }
                break;
            }
        } else {
            Overlap = NextSeq - CurrentTRH->trh_start;
            RcvInfo->tri_seq = NextSeq;
            RcvInfo->tri_flags = CurrentTRH->trh_flags;
            RcvInfo->tri_urgent = CurrentTRH->trh_urg;

            if (Overlap != (int)CurrentTRH->trh_size) {
                NewBuf = FreePartialRB(CurrentTRH->trh_buffer, Overlap);
                *Size = CurrentTRH->trh_size - Overlap;
            } else {
                // This completely overlaps the data in this segment, but the
                // sequence number doesn't overlap completely. There must
                // be a FIN in the TRH. If we called FreePartialRB with this
                // we'd end up returning NULL, which is the signal for failure.
                // Instead we'll just return some bogus value that nobody
                // will look at with a size of 0.
                FreeRBChain(CurrentTRH->trh_buffer);
                ASSERT(CurrentTRH->trh_flags & TCP_FLAG_FIN);
                NewBuf = &DummyBuf;
                *Size = 0;
            }

            RcvTCB->tcb_raq = CurrentTRH->trh_next;
            if (RcvTCB->tcb_raq == NULL) {
                // We've just cleaned off the RAQ. We can go back on the
                // fast path now.
                if (--(RcvTCB->tcb_slowcount) == 0) {
                    RcvTCB->tcb_fastchk &= ~TCP_FLAG_SLOW;
                    CheckTCBRcv(RcvTCB);
                }
            }
            CTEFreeMem(CurrentTRH);
            return NewBuf;
        }

    }

#if DBG
    *Size = 0;
#endif

    //invalidate Sack Block
    if (RcvTCB->tcb_tcpopts & TCP_FLAG_SACK && RcvTCB->tcb_SackBlock) {
        RcvTCB->tcb_SackBlock->Mask[0] = 0;
        RcvTCB->tcb_SackBlock->Mask[1] = 0;
        RcvTCB->tcb_SackBlock->Mask[2] = 0;
        RcvTCB->tcb_SackBlock->Mask[3] = 0;
    }
    return NULL;

}

//* CreateTRH - Create a TCP reassembly header.
//
//  This function tries to create a TCP reassembly header. We take as input
//  a pointer to the previous TRH in the chain, the RcvBuffer to put on,
//  etc. and try to create and link in a TRH. The caller must hold the lock
//  on the TCB when this is called.
//
//  Input:  PrevTRH             - Pointer to TRH to insert after.
//          RcvBuf              - Pointer to IP RcvBuf chain.
//          RcvInfo             - Pointer to RcvInfo for this TRH.
//          Size                - Size in bytes of data.
//
//  Returns: TRUE if we created it, FALSE otherwise.
//
uint
CreateTRH(TCPRAHdr * PrevTRH, IPRcvBuf * RcvBuf, TCPRcvInfo * RcvInfo, int Size)
{
    TCPRAHdr *NewTRH;
    IPRcvBuf *NewRcvBuf;

    ASSERT((Size > 0) || (RcvInfo->tri_flags & TCP_FLAG_FIN));

    NewTRH = CTEAllocMemLow(sizeof(TCPRAHdr), 'SPCT');
    if (NewTRH == NULL) {
        return FALSE;
    }

#if DBG
    NewTRH->trh_sig = trh_signature;
#endif

    NewRcvBuf = AllocTcpIpr(Size, 'SPCT');
    if (NewRcvBuf == NULL) {
        CTEFreeMem(NewTRH);
        return FALSE;
    }
    if (Size != 0)
        CopyRcvToBuffer(NewRcvBuf->ipr_buffer, RcvBuf, Size, 0);

    NewTRH->trh_start = RcvInfo->tri_seq;
    NewTRH->trh_flags = RcvInfo->tri_flags;
    NewTRH->trh_size = Size;
    NewTRH->trh_urg = RcvInfo->tri_urgent;
    NewTRH->trh_buffer = NewRcvBuf;
    NewTRH->trh_end = NewRcvBuf;

    NewTRH->trh_next = PrevTRH->trh_next;
    PrevTRH->trh_next = NewTRH;
    return TRUE;

}


// SendSackInACK - SEnd SACK block in acknowledgement

//
// Called if incoming data is in the window but  left edge
// is not advanced because incoming seq > rcvnext.
// This routine scans the queued up data, constructs SACK block
// points the block in tcb for SendACK.
//
// Entry   RcvTCB
//         IncomingSeq   Seq num of Data coming in
//
// Returns Nothing
void
SendSackInACK(TCB * RcvTCB, SeqNum IncomingSeq)
{
    TCPRAHdr *PrevTRH, *CurrentTRH;        // Prev. and current TRH
    // pointers.
    SeqNum NextTRHSeq;    // Seq. number of first byte

    SACKSendBlock *SackBlock;
    int i, j;

    CTEStructAssert(RcvTCB, tcb);

    // If we have a SACK block use it else create one.
    // Note that we use max of 4 sack blocks
    // Sack block structure:
    // First long word holds index of the
    // 4 sack blocks, starting from 1. zero
    // in index field means no sack block
    //
    //   !--------!--------!--------!--------!
    //   |    1   |  2     |  3     | 4      |
    //   -------------------------------------
    //   |                                   |
    //   -------------------------------------
    //   |                                   |
    //   -------------------------------------

    // Allocate a block if it is not already there

    if (RcvTCB->tcb_SackBlock == NULL) {

        SackBlock = CTEAllocMemN((sizeof(SACKSendBlock)), 'sPCT');

        if (SackBlock == NULL) {

            // Resources failure. Just try to send ack
            // and leave the resource handling to some one else

            CTEFreeLockFromDPC(&RcvTCB->tcb_lock);

            SendACK(RcvTCB);
            return;

        } else {
            RcvTCB->tcb_SackBlock = SackBlock;
            //Initialize the first entry to indicate that this is the new one
            NdisZeroMemory(SackBlock, sizeof(SACKSendBlock));

        }

    } else
        SackBlock = RcvTCB->tcb_SackBlock;

    IF_TCPDBG(TCP_DEBUG_SACK) {
        TCPTRACE(("SendSackInACK %x %x %d\n", SackBlock, RcvTCB, IncomingSeq));
    }

    PrevTRH = STRUCT_OF(TCPRAHdr, &RcvTCB->tcb_raq, trh_next);
    CurrentTRH = PrevTRH->trh_next;

    while (CurrentTRH != NULL) {
        CTEStructAssert(CurrentTRH, trh);

        ASSERT(!(CurrentTRH->trh_flags & TCP_FLAG_SYN));

        NextTRHSeq = CurrentTRH->trh_start + CurrentTRH->trh_size +
            ((CurrentTRH->trh_flags & TCP_FLAG_FIN) ? 1 : 0);

        if ((SackBlock->Mask[0] != (uchar) - 1) && (SEQ_LTE(CurrentTRH->trh_start, IncomingSeq) &&
                                                    SEQ_LTE(IncomingSeq, NextTRHSeq))) {

            if (SackBlock->Mask[0] == 0) {
                //This is the only sack block
                SackBlock->Block[0].begin = CurrentTRH->trh_start;
                SackBlock->Block[0].end = NextTRHSeq;
                SackBlock->Mask[0] = (uchar) - 1;    //Make it valid

            } else {

                if (!((SEQ_LTE(CurrentTRH->trh_start, SackBlock->Block[0].begin) &&
                       SEQ_GTE(NextTRHSeq, SackBlock->Block[0].end)) ||
                      (SEQ_LTE(CurrentTRH->trh_start, SackBlock->Block[0].begin) &&
                       SEQ_LTE(SackBlock->Block[0].begin, NextTRHSeq)) ||
                      (SEQ_LTE(CurrentTRH->trh_start, SackBlock->Block[0].end) &&
                       SEQ_LTE(SackBlock->Block[0].end, NextTRHSeq)))) {

                    // Push the blocks down and fill the top

                    for (i = 2; i >= 0; i--) {
                        SackBlock->Block[i + 1].begin = SackBlock->Block[i].begin;
                        SackBlock->Block[i + 1].end = SackBlock->Block[i].end;
                        SackBlock->Mask[i + 1] = -SackBlock->Mask[i];

                    }
                }
                SackBlock->Block[0].begin = CurrentTRH->trh_start;
                SackBlock->Block[0].end = NextTRHSeq;
                SackBlock->Mask[0] = (uchar) - 1;

                IF_TCPDBG(TCP_DEBUG_SACK) {
                    TCPTRACE(("Sack 0 %d %d \n", CurrentTRH->trh_start, NextTRHSeq));
                }

            }

        } else {

            // process all the sack blocks to see if the currentTRH is
            // valid for those blocks

            for (i = 1; i <= 3; i++) {
                if ((SackBlock->Mask[i] != 0) &&
                    (SEQ_LTE(CurrentTRH->trh_start, SackBlock->Block[i].begin) &&
                     SEQ_LTE(SackBlock->Block[i].begin, NextTRHSeq))) {

                    SackBlock->Block[i].begin = CurrentTRH->trh_start;
                    SackBlock->Block[i].end = NextTRHSeq;
                    SackBlock->Mask[i] = (uchar) - 1;
                }
            }
        }

        PrevTRH = CurrentTRH;
        CurrentTRH = CurrentTRH->trh_next;

    }                            //while

    //Check and set the blocks traversed for validity

    for (i = 0; i <= 3; i++) {

        if (SackBlock->Mask[i] != (uchar) - 1) {
            SackBlock->Mask[i] = 0;
        } else {
            SackBlock->Mask[i] = 1;

            IF_TCPDBG(TCP_DEBUG_SACK) {
                TCPTRACE(("Sack in ack %x %d %d\n", i, SackBlock->Block[i].begin, SackBlock->Block[i].end));
            }
        }
    }

    // Make sure that there are no duplicates
    for (i = 0; i < 3; i++) {

        if (SackBlock->Mask[i]) {
            for (j = i + 1; j < 4; j++) {
                if (SackBlock->Mask[j] && (SackBlock->Block[i].begin == SackBlock->Block[j].begin))
                    IF_TCPDBG(TCP_DEBUG_SACK) {
                    TCPTRACE(("Duplicates!!\n"));
                    }
            }
        }
    }

    CTEFreeLockFromDPC(&RcvTCB->tcb_lock);

    SendACK(RcvTCB);

}

//* PutOnRAQ - Put a segment on the reassembly queue.
//
//  Called during segment reception to put a segment on the reassembly
//  queue. We try to use as few reassembly headers as possible, so if this
//  segment has some overlap with an existing entry in the queue we'll just
//  update the existing entry. If there is no overlap we'll create a new
//  reassembly header. Combining URGENT data with non-URGENT data is tricky.
//  If we get a segment that has urgent data that overlaps the front of a
//  reassembly header we'll always mark the whole chunk as urgent - the value
//  of the urgent pointer will mark the end of urgent data, so this is OK. If it
//  only overlaps at the end, however, we won't combine, since we would have to
//  mark previously non-urgent data as urgent. We'll trim the
//  front of the incoming segment and create a new reassembly header. Also,
//  if we have non-urgent data that overlaps at the front of a reassembly
//  header containing urgent data we can't combine these two, since again we
//  would mark non-urgent data as urgent.
//  Our search will stop if we find an entry with a FIN.
//  We assume that the TCB lock is held by the caller.
//
//  Entry:  RcvTCB          - TCB on which to reassemble.
//          RcvInfo         - Pointer to RcvInfo for new segment.
//          RcvBuf          - IP RcvBuf chain for this segment.
//          Size            - Size in bytes of data in this segment.
//
//  Returns: TRUE or FALSE if it could not put RcvBuf on Queue
//
BOOLEAN
PutOnRAQ(TCB * RcvTCB, TCPRcvInfo * RcvInfo, IPRcvBuf * RcvBuf, uint Size)
{
    TCPRAHdr *PrevTRH, *CurrentTRH;        // Prev. and current TRH
    // pointers.
    SeqNum NextSeq;                // Seq. number of first byte
    // after segment being
    // reassembled.
    SeqNum NextTRHSeq;            // Seq. number of first byte
    // after current TRH.
    uint Created;

    CTEStructAssert(RcvTCB, tcb);
    ASSERT(RcvTCB->tcb_rcvnext != RcvInfo->tri_seq);
    ASSERT(!(RcvInfo->tri_flags & TCP_FLAG_SYN));
    NextSeq = RcvInfo->tri_seq + Size +
        ((RcvInfo->tri_flags & TCP_FLAG_FIN) ? 1 : 0);

    PrevTRH = STRUCT_OF(TCPRAHdr, &RcvTCB->tcb_raq, trh_next);
    CurrentTRH = PrevTRH->trh_next;

    // Walk down the reassembly queue, looking for the correct place to
    // insert this, until we hit the end.
    while (CurrentTRH != NULL) {
        CTEStructAssert(CurrentTRH, trh);

        ASSERT(!(CurrentTRH->trh_flags & TCP_FLAG_SYN));
        NextTRHSeq = CurrentTRH->trh_start + CurrentTRH->trh_size +
            ((CurrentTRH->trh_flags & TCP_FLAG_FIN) ? 1 : 0);

        // First, see if it starts beyond the end of the current TRH.
        if (SEQ_LTE(RcvInfo->tri_seq, NextTRHSeq)) {
            // We know the incoming segment doesn't start beyond the end
            // of this TRH, so we'll either create a new TRH in front of
            // this one or we'll merge the new segment onto this TRH.
            // If the end of the current segment is in front of the start
            // of the current TRH, we'll need to create a new TRH. Otherwise
            // we'll merge these two.
            if (SEQ_LT(NextSeq, CurrentTRH->trh_start))
                break;
            else {
                // There's some overlap. If there's actually data in the
                // incoming segment we'll merge it.
                if (Size != 0) {
                    int FrontOverlap, BackOverlap;
                    IPRcvBuf *NewRB;

                    // We need to merge. If there's a FIN on the incoming
                    // segment that would fall inside this current TRH, we
                    // have a protocol violation from the remote peer. In this
                    // case just return, discarding the incoming segment.
                    if ((RcvInfo->tri_flags & TCP_FLAG_FIN) &&
                        SEQ_LTE(NextSeq, NextTRHSeq))
                        return TRUE;

                    // We have some overlap. Figure out how much.
                    FrontOverlap = CurrentTRH->trh_start - RcvInfo->tri_seq;
                    if (FrontOverlap > 0) {
                        // Have overlap in front. Allocate an IPRcvBuf to
                        // to hold it, and copy it, unless we would have to
                        // combine non-urgent with urgent.
                        if (!(RcvInfo->tri_flags & TCP_FLAG_URG) &&
                            (CurrentTRH->trh_flags & TCP_FLAG_URG)) {
                            if (CreateTRH(PrevTRH, RcvBuf, RcvInfo,
                                          CurrentTRH->trh_start - RcvInfo->tri_seq)) {
                                PrevTRH = PrevTRH->trh_next;
                                CurrentTRH = PrevTRH->trh_next;
                            }
                            FrontOverlap = 0;

                        } else {
                            NewRB = AllocTcpIpr(FrontOverlap, 'BPCT');
                            if (NewRB == NULL) {
                                return TRUE;        // Couldn't get the buffer.
                            }

                            CopyRcvToBuffer(NewRB->ipr_buffer, RcvBuf,
                                            FrontOverlap, 0);
                            CurrentTRH->trh_size += FrontOverlap;
                            NewRB->ipr_next = CurrentTRH->trh_buffer;
                            CurrentTRH->trh_buffer = NewRB;
                            CurrentTRH->trh_start = RcvInfo->tri_seq;
                        }
                    }
                    // We've updated the starting sequence number of this TRH
                    // if we needed to. Now look for back overlap. There can't
                    // be any back overlap if the current TRH has a FIN. Also
                    // we'll need to check for urgent data if there is back
                    // overlap.
                    if (!(CurrentTRH->trh_flags & TCP_FLAG_FIN)) {
                        BackOverlap = RcvInfo->tri_seq + Size - NextTRHSeq;
                        if ((BackOverlap > 0) &&
                            (RcvInfo->tri_flags & TCP_FLAG_URG) &&
                            !(CurrentTRH->trh_flags & TCP_FLAG_URG) &&
                            (FrontOverlap <= 0)) {
                            int AmountToTrim;
                            // The incoming segment has urgent data and overlaps
                            // on the back but not the front, and the current
                            // TRH has no urgent data. We can't combine into
                            // this TRH, so trim the front of the incoming
                            // segment to NextTRHSeq and move to the next
                            // TRH.
                            AmountToTrim = NextTRHSeq - RcvInfo->tri_seq;
                            ASSERT(AmountToTrim >= 0);
                            ASSERT(AmountToTrim < (int)Size);
                            RcvBuf = FreePartialRB(RcvBuf, (uint) AmountToTrim);
                            RcvInfo->tri_seq += AmountToTrim;
                            RcvInfo->tri_urgent -= AmountToTrim;
                            PrevTRH = CurrentTRH;
                            CurrentTRH = PrevTRH->trh_next;
                            //Adjust the incoming size too...
                            Size -= AmountToTrim;
                            continue;
                        }
                    } else
                        BackOverlap = 0;

                    // Now if we have back overlap, copy it.
                    if (BackOverlap > 0) {
                        // We have back overlap. Get a buffer to copy it into.
                        // If we can't get one, we won't just return, because
                        // we may have updated the front and may need to
                        // update the urgent info.
                        NewRB = AllocTcpIpr(BackOverlap, 'BPCT');
                        if (NewRB != NULL) {
                            // Got the buffer.
                            CopyRcvToBuffer(NewRB->ipr_buffer, RcvBuf,
                                            BackOverlap, NextTRHSeq - RcvInfo->tri_seq);
                            CurrentTRH->trh_size += BackOverlap;
                            NewRB->ipr_next = CurrentTRH->trh_end->ipr_next;
                            CurrentTRH->trh_end->ipr_next = NewRB;
                            CurrentTRH->trh_end = NewRB;

                            // This data segment could also contain a FIN. If
                            // so, just set the TRH flag.
                            //
                            // N.B. If there's another reassembly header after
                            // the current one, the data that we're about
                            // to put on the current header might already be
                            // on that subsequent header which, in that event,
                            // will already have the FIN flag set.
                            // Check for that case before recording the FIN.

                            if ((RcvInfo->tri_flags & TCP_FLAG_FIN) &&
                                !CurrentTRH->trh_next) {
                                CurrentTRH->trh_flags |= TCP_FLAG_FIN;
                            }
                        }
                    }
                    // Everything should be consistent now. If there's an
                    // urgent data pointer in the incoming segment, update the
                    // one in the TRH now.
                    if (RcvInfo->tri_flags & TCP_FLAG_URG) {
                        SeqNum UrgSeq;
                        // Have an urgent pointer. If the current TRH already
                        // has an urgent pointer, see which is bigger. Otherwise
                        // just use this one.
                        UrgSeq = RcvInfo->tri_seq + RcvInfo->tri_urgent;
                        if (CurrentTRH->trh_flags & TCP_FLAG_URG) {
                            SeqNum TRHUrgSeq;

                            TRHUrgSeq = CurrentTRH->trh_start +
                                CurrentTRH->trh_urg;
                            if (SEQ_LT(UrgSeq, TRHUrgSeq))
                                UrgSeq = TRHUrgSeq;
                        } else
                            CurrentTRH->trh_flags |= TCP_FLAG_URG;

                        CurrentTRH->trh_urg = UrgSeq - CurrentTRH->trh_start;
                    }
                } else {
                    // We have a 0 length segment. The only interesting thing
                    // here is if there's a FIN on the segment. If there is,
                    // and the seq. # of the incoming segment is exactly after
                    // the current TRH, OR matches the FIN in the current TRH,
                    // we note it.
                    if (RcvInfo->tri_flags & TCP_FLAG_FIN) {
                        if (!(CurrentTRH->trh_flags & TCP_FLAG_FIN)) {
                            if (SEQ_EQ(NextTRHSeq, RcvInfo->tri_seq))
                                CurrentTRH->trh_flags |= TCP_FLAG_FIN;
                            else
                                ASSERT(0);
                        } else {
                            ASSERT(SEQ_EQ((NextTRHSeq - 1), RcvInfo->tri_seq));
                        }
                    }
                }
                return TRUE;
            }
        } else {
            // Look at the next TRH, unless the current TRH has a FIN. If he
            // has a FIN, we won't save any data beyond that anyway.
            if (CurrentTRH->trh_flags & TCP_FLAG_FIN)
                return TRUE;

            PrevTRH = CurrentTRH;
            CurrentTRH = PrevTRH->trh_next;
        }
    }

    // When we get here, we need to create a new TRH. If we create one and
    // there was previously nothing on the reassembly queue, we'll have to
    // move off the fast receive path.

    CurrentTRH = RcvTCB->tcb_raq;
    Created = CreateTRH(PrevTRH, RcvBuf, RcvInfo, (int)Size);

    if (Created && CurrentTRH == NULL) {
        RcvTCB->tcb_slowcount++;
        RcvTCB->tcb_fastchk |= TCP_FLAG_SLOW;
        CheckTCBRcv(RcvTCB);
    } else if (!Created) {

       // Caller needs to know about this failure
       // to free resources

       return FALSE;
    }
    return TRUE;
}

//* HandleFastXmit - Handles fast retransmit
//
//  Called by TCPRcv to transmit a segment
//  without waiting for re-transmit timeout to fire.
//
//  Entry:  RcvTCB   - Connection context for this Rcv
//          RcvInfo  - Pointer to rcvd TCP Header information
//
//  Returns: TRUE if the segment got retransmitted, FALSE
//           in all other cases.
//

BOOLEAN
HandleFastXmit(TCB *RcvTCB, TCPRcvInfo *RcvInfo)
{
    uint CWin;

    RcvTCB->tcb_dup++;

    if ((RcvTCB->tcb_dup == MaxDupAcks)) {

        //
        // Okay. Time to retransmit the segment the
        // receiver is asking for
        //

         if (!(RcvTCB->tcb_flags & FLOW_CNTLD)) {

            //
            // Don't let the slow start threshold go
            // below 2 segments
            //

            RcvTCB->tcb_ssthresh = MAX(
                                   MIN(RcvTCB->tcb_cwin, RcvTCB->tcb_sendwin) / 2,
                                   (uint) RcvTCB->tcb_mss * 2);
        }

        //
        // Recall the segment in question and send it
        // out. Note that tcb_lock will be
        // dereferenced by the caller
        //

        CWin = RcvTCB->tcb_ssthresh + (MaxDupAcks + 1) * RcvTCB->tcb_mss;

        ResetAndFastSend(RcvTCB, RcvTCB->tcb_senduna, CWin);

        return TRUE;

    } else if ((RcvTCB->tcb_dup > MaxDupAcks)) {

        int SendWin;
        uint AmtOutstanding, AmtUnsent;

        if (SEQ_EQ(RcvTCB->tcb_senduna, RcvInfo->tri_ack) &&
            (SEQ_LT(RcvTCB->tcb_sendwl1, RcvInfo->tri_seq) ||
            (SEQ_EQ(RcvTCB->tcb_sendwl1, RcvInfo->tri_seq) &&
             SEQ_LTE(RcvTCB->tcb_sendwl2,RcvInfo->tri_ack)))) {

            RcvTCB->tcb_sendwin = RcvInfo->tri_window;
            RcvTCB->tcb_maxwin = MAX(RcvTCB->tcb_maxwin, RcvInfo->tri_window);
            RcvTCB->tcb_sendwl1 = RcvInfo->tri_seq;
            RcvTCB->tcb_sendwl2 = RcvInfo->tri_ack;
        }

        //
        // Update the cwin to reflect the fact that
        // the dup ack indicates the previous frame
        // was received by the receiver
        //

        RcvTCB->tcb_cwin += RcvTCB->tcb_mss;
        if ((RcvTCB->tcb_cwin + RcvTCB->tcb_mss) < RcvTCB->tcb_sendwin) {
             AmtOutstanding = (uint) (RcvTCB->tcb_sendnext -
                                                    RcvTCB->tcb_senduna);
             AmtUnsent = RcvTCB->tcb_unacked - AmtOutstanding;

             SendWin = (int)(MIN(RcvTCB->tcb_sendwin, RcvTCB->tcb_cwin) -
                                           AmtOutstanding);

             if (SendWin < RcvTCB->tcb_mss) {
                 RcvTCB->tcb_force = 1;
             }
        }

    } else if ((RcvTCB->tcb_dup < MaxDupAcks)) {

        int SendWin;
        uint AmtOutstanding, AmtUnsent;

        if (SEQ_EQ(RcvTCB->tcb_senduna, RcvInfo->tri_ack) &&
            (SEQ_LT(RcvTCB->tcb_sendwl1, RcvInfo->tri_seq) ||
            (SEQ_EQ(RcvTCB->tcb_sendwl1, RcvInfo->tri_seq) &&
            SEQ_LTE(RcvTCB->tcb_sendwl2, RcvInfo->tri_ack)))) {

            RcvTCB->tcb_sendwin = RcvInfo->tri_window;
            RcvTCB->tcb_maxwin = MAX(RcvTCB->tcb_maxwin, RcvInfo->tri_window);

            RcvTCB->tcb_sendwl1 = RcvInfo->tri_seq;
            RcvTCB->tcb_sendwl2 = RcvInfo->tri_ack;

            //
            // Since we've updated the window,
            // remember to send some more.
            //
        }
        //
        // Check if we need to set tcb_force.
        //

        if ((RcvTCB->tcb_cwin + RcvTCB->tcb_mss) < RcvTCB->tcb_sendwin) {

            AmtOutstanding =  (uint) (RcvTCB->tcb_sendnext - RcvTCB->tcb_senduna);

            AmtUnsent = RcvTCB->tcb_unacked - AmtOutstanding;

            SendWin = (int)(MIN(RcvTCB->tcb_sendwin, RcvTCB->tcb_cwin) -
                                           AmtOutstanding);
            if (SendWin < RcvTCB->tcb_mss) {
                 RcvTCB->tcb_force = 1;
            }
        }

    }    // End of all MaxDupAck cases
    return FALSE;

}

//* TCPRcv - Receive a TCP segment.
//
//  This is the routine called by IP when we need to receive a TCP segment.
//  In general, we follow the RFC 793 event processing section pretty closely,
//  but there is a 'fast path' where we make some quick checks on the incoming
//  segment, and if it matches we deliver it immediately.
//
//  Entry:  IPContext   - IPContext identifying physical i/f that
//                          received the data.
//          Dest        - IPAddr of destionation.
//          Src         - IPAddr of source.
//          LocalAddr   - Local address of network which caused this to be
//                          received.
//          SrcAddr     - Address of local interface which received the packet
//          IPH         - IP Header.
//          IPHLength   - Bytes in IPH.
//          RcvBuf      - Pointer to receive buffer chain containing data.
//          Size        - Size in bytes of data received.
//          Flags       - One flag indicates whether this is a bcast or not,
//                        and the other indicates if IP detected unbound adapters
//                        on this indication
//          Protocol    - Protocol this came in on - should be TCP.
//          OptInfo     - Pointer to info structure for received options.
//
//  Returns: Status of reception. Anything other than IP_SUCCESS will cause
//          IP to send a 'port unreachable' message.
//
IP_STATUS
TCPRcv(void *IPContext, IPAddr Dest, IPAddr Src, IPAddr LocalAddr,
       IPAddr SrcAddr, IPHeader UNALIGNED * IPH, uint IPHLength, IPRcvBuf * RcvBuf,
       uint Size, uchar Flags, uchar Protocol, IPOptInfo * OptInfo)
{
    TCPHeader UNALIGNED *TCPH;    // The TCP header.
    TCB *RcvTCB;                // TCB on which to receive the packet.
    TWTCB *RcvTWTCB;

    TCPRcvInfo RcvInfo;            // Local swapped copy of rcv info.
    uint DataOffset;            // Offset from start of header to data.
    uint Actions;
    uint BytesTaken;
    uint NewSize;
    uint index;
    uint Partition;
    PNDIS_PACKET OffLoadPkt;
    int tsval = 0;                    //Timestamp value
    int tsecr = 0;                    //Timestamp to be echoed
    BOOLEAN time_stamp = FALSE;
    BOOLEAN ChkSumOk = FALSE;
    Queue SendQ;
    uint UpdateWindow = FALSE;

#if TRACE_EVENT
    PTDI_DATA_REQUEST_NOTIFY_ROUTINE CPCallBack;
    WMIData WMIInfo;
#endif

    if ((Flags & IS_BOUND) == 0) {
        PartitionDelayQProcessing(FALSE);
    }

    CheckRBList(RcvBuf, Size);

    TCPSIncrementInSegCount();

    // Checksum it, to make sure it's valid.
    TCPH = (TCPHeader *) RcvBuf->ipr_buffer;

    if ((Flags & IS_BROADCAST) == 0) {

        if (RcvBuf->ipr_pClientCnt) {

            PNDIS_PACKET_EXTENSION PktExt;
            NDIS_TCP_IP_CHECKSUM_PACKET_INFO ChksumPktInfo;

            if (RcvBuf->ipr_pMdl) {
                OffLoadPkt = NDIS_GET_ORIGINAL_PACKET((PNDIS_PACKET) RcvBuf->ipr_RcvContext);
                if (!OffLoadPkt) {
                    OffLoadPkt = (PNDIS_PACKET) RcvBuf->ipr_RcvContext;
                }
            } else {
                OffLoadPkt = (PNDIS_PACKET) RcvBuf->ipr_pClientCnt;
            }

            PktExt = NDIS_PACKET_EXTENSION_FROM_PACKET(OffLoadPkt);

            ChksumPktInfo.Value = PtrToUlong(PktExt->NdisPacketInfo[TcpIpChecksumPacketInfo]);

            if (ChksumPktInfo.Receive.NdisPacketTcpChecksumSucceeded) {
                ChkSumOk = TRUE;
#if DBG
                DbgTcpHwChkSumOk++;
#endif

            } else if (ChksumPktInfo.Receive.NdisPacketTcpChecksumFailed) {
#if DBG
                DbgTcpHwChkSumErr++;
#endif

                TStats.ts_inerrs++;
                return IP_SUCCESS;
            }
        }
        if (!ChkSumOk) {
            if (XsumRcvBuf(PHXSUM(Src, Dest, PROTOCOL_TCP, Size), RcvBuf) == 0xffff){
                ChkSumOk = TRUE;
            }
        } else  {

            // Pretch the rcv buffer in to cache
            // to improve copy performance
#if !MILLEN
            PrefetchRcvBuf(RcvBuf);
#endif
        }
        if ((Size >= sizeof(TCPHeader)) && ChkSumOk) {
            // The packet is valid. Get the info we need and byte swap it,
            // and then try to find a matching TCB.

            RcvInfo.tri_seq = net_long(TCPH->tcp_seq);
            RcvInfo.tri_ack = net_long(TCPH->tcp_ack);
            RcvInfo.tri_window = (uint) net_short(TCPH->tcp_window);
            RcvInfo.tri_urgent = (uint) net_short(TCPH->tcp_urgent);
            RcvInfo.tri_flags = (uint) TCPH->tcp_flags;
            DataOffset = TCP_HDR_SIZE(TCPH);

            if (DataOffset <= Size) {

                Size -= DataOffset;
                ASSERT(DataOffset <= RcvBuf->ipr_size);
                RcvBuf->ipr_size -= DataOffset;
                RcvBuf->ipr_buffer += DataOffset;
                RcvBuf->ipr_RcvOffset += DataOffset;

                // FindTCB will lock tcbtablelock, returns with tcb_lock
                // held, if found.

                RcvTCB = FindTCB(Dest, Src, TCPH->tcp_src, TCPH->tcp_dest,
                                 NULL, TRUE, &index);
                Partition = GET_PARTITION(index);
                if (RcvTCB == NULL) {

                    CTEGetLockAtDPC(&pTWTCBTableLock[Partition]);

                    RcvTWTCB = FindTCBTW(Dest, Src, TCPH->tcp_src, TCPH->tcp_dest, index);

                    if (RcvTWTCB != NULL) {
                        // A matching time wait TCB is found for this segment.
                        // It's table is already locked, and the lock will be
                        // released in the following routine, after processing
                        // the segment.

                        TimeWaitAction Action = HandleTWTCB(RcvTWTCB,
                                                            RcvInfo.tri_flags,
                                                            RcvInfo.tri_seq,
                                                            Partition);

                        if (Action == TwaDoneProcessing) {
                            return IP_SUCCESS;
                        } else if (Action == TwaSendReset) {
                            SendRSTFromHeader(TCPH, Size, Src, Dest, OptInfo);
                            return IP_SUCCESS;
                        } else {
                            ASSERT(Action == TwaAcceptConnection);
                        }
                    } else {

                        UCHAR Action = 0;
                        
                        CTEFreeLockFromDPC(&pTWTCBTableLock[Partition]);
                        
                        if (SynAttackProtect) {
                        
                            RcvTCB = FindSynTCB(Dest, Src, TCPH->tcp_src,
                                                TCPH->tcp_dest, RcvInfo, Size,
                                                index, &Action);

                            // If there is any action which needs
                            // to be taken, NULL is returned.
                            // Otherwise we either have a TCB and the
                            // lock on the tcb or NULL if no match
                            // is found.
                            if (Action) {
                                if (Action == SYN_PKT_SEND_RST) {
                                    SendRSTFromHeader(TCPH, Size, Src, Dest,
                                                      OptInfo);
                                }

                                return IP_SUCCESS;
                            }

                            // Update options
                            if (RcvTCB && (OptInfo->ioi_options != NULL)) {
                                if (!(RcvTCB->tcb_flags & CLIENT_OPTIONS)) {
                                    (*LocalNetInfo.ipi_updateopts) (
                                        OptInfo,
                                        &RcvTCB->tcb_opt,
                                        Src,
                                        NULL_IP_ADDR);
                                }   
                            }
                        }
                    }
                }
                if (RcvTCB == NULL) {

                    // Didn't find a matching TCB. If this segment carries a SYN,
                    // find a matching address object and see it it has a listen
                    // indication. If it does, call it. Otherwise send a RST
                    // back to the sender.
                    // Make sure that the source address isn't a broadcast
                    // before proceeding.

                    if ((*LocalNetInfo.ipi_invalidsrc) (Src)) {

                        return IP_SUCCESS;
                    }
                    // If it doesn't have a SYN (and only a SYN), we'll send a
                    // reset.
                    if ((RcvInfo.tri_flags & (TCP_FLAG_SYN | TCP_FLAG_ACK | TCP_FLAG_RST)) ==
                        TCP_FLAG_SYN) {
                        AddrObj *AO;

                        //
                        // This segment had a SYN.
                        //
                        //
                        CTEGetLockAtDPC(&AddrObjTableLock.Lock);

                        // See if we are filtering the
                        // destination interface/port.
                        //
                        if ((!SecurityFilteringEnabled ||
                             IsPermittedSecurityFilter(
                                                       LocalAddr,
                                                       IPContext,
                                                       PROTOCOL_TCP,
                                                       (ulong) net_short(TCPH->tcp_dest))))
                        {

                            //
                            // Find a matching address object, and then try
                            // and find a listening connection on that AO.
                            //
                            AO = GetBestAddrObj(Dest, TCPH->tcp_dest, PROTOCOL_TCP, GAO_FLAG_CHECK_IF_LIST);
                            
                            if (AO != NULL) {

                                BOOLEAN syntcb = FALSE;
                                uint IFIndex;
                                
                                //
                                // Found an AO. Try and find a listening
                                // connection. FindListenConn will free the
                                // lock on the AddrObjTable.
                                //

                                RcvTCB = NULL;

                                IFIndex = (*LocalNetInfo.ipi_getifindexfromindicatecontext)(IPContext);

                                RcvTCB = FindListenConn(AO, Src, Dest,
                                            TCPH->tcp_src, OptInfo, TCPH,
                                            &RcvInfo, IFIndex, &syntcb);

                                if (RcvTCB != NULL) {
                                    uint Inserted;

                                    CTEStructAssert(RcvTCB, tcb);
                                    CTEGetLockAtDPC(&RcvTCB->tcb_lock);

                                    //
                                    // We found a listening connection.
                                    // Initialize it now, and if it is
                                    // actually to be accepted we'll
                                    // send a SYN-ACK also.
                                    //

                                    ASSERT(RcvTCB->tcb_state == TCB_SYN_RCVD);

                                    if (SynAttackProtect) {
                                        AddHalfOpenTCB();
                                    }

                                    RcvTCB->tcb_rcvnext = ++RcvInfo.tri_seq;
                                    RcvTCB->tcb_sendwin = RcvInfo.tri_window;

                                    //
                                    // Find Remote MSS and also if WS, TS or
                                    // sack options are negotiated.
                                    //

                                    RcvTCB->tcb_sndwinscale = 0;
                                    RcvTCB->tcb_remmss =
                                        FindMSSAndOptions(TCPH, RcvTCB, FALSE);

                                    if (RcvTCB->tcb_remmss <= ALIGNED_TS_OPT_SIZE) {

                                        // Turn off TS if MSS is not sufficient
                                        // to hold TS fields.
                                        RcvTCB->tcb_tcpopts &= ~TCP_FLAG_TS;
                                    }

                                    TStats.ts_passiveopens++;
                                    RcvTCB->tcb_fastchk |= TCP_FLAG_IN_RCV;
                                    CTEFreeLockFromDPC(&RcvTCB->tcb_lock);

                                    Inserted = InsertTCB(RcvTCB, TRUE);

                                    //
                                    // Get the lock on it, and see if it's been
                                    // accepted.
                                    //
                                    CTEGetLockAtDPC(&RcvTCB->tcb_lock);
                                    if (!Inserted) {


                                        // Couldn't insert it!.


                                        CompleteConnReq(RcvTCB, OptInfo,
                                                        TDI_CONNECTION_ABORTED);

                                        TryToCloseTCB(RcvTCB, TCB_CLOSE_ABORTED, DISPATCH_LEVEL);
                                        CTEGetLockAtDPC(&RcvTCB->tcb_lock);
                                        DerefTCB(RcvTCB, DISPATCH_LEVEL);
                                        return IP_SUCCESS;
                                    }
                                    RcvTCB->tcb_fastchk &= ~TCP_FLAG_IN_RCV;

                                    if (RcvTCB->tcb_flags & SEND_AFTER_RCV) {
                                        RcvTCB->tcb_flags &= ~SEND_AFTER_RCV;
                                        DelayAction(RcvTCB, NEED_OUTPUT);
                                    }
                                    // 
                                    // We'll need to update the options, in any case.
                                    //
                                    if (OptInfo->ioi_options != NULL) {
                                        if (!(RcvTCB->tcb_flags & CLIENT_OPTIONS)) {
                                            (*LocalNetInfo.ipi_updateopts) (
                                                        OptInfo,
                                                        &RcvTCB->tcb_opt,
                                                        Src,
                                                        NULL_IP_ADDR);
                                        }
                                    }

                                    //
                                    // Notify the callback clients.
                                    //
                                    TcpInvokeCcb(TCP_CONN_CLOSED, 
                                                 TCP_CONN_SYN_RCVD, 
                                                 &RcvTCB->tcb_addrbytes,
                                                 IFIndex);

                                    if (RcvTCB->tcb_flags & CONN_ACCEPTED) {
                                        //
                                        // The connection was accepted. Finish
                                        // the initialization, and send the
                                        // SYN ack.
                                        //
                                        AcceptConn(RcvTCB, FALSE,
                                                   DISPATCH_LEVEL);
                                        return IP_SUCCESS;
                                    } else {

                                        //
                                        // We don't know what to do about the
                                        // connection yet. Return the pending
                                        // listen, dereference the connection,
                                        // and return.
                                        //

                                        CompleteConnReq(RcvTCB, OptInfo, TDI_SUCCESS);

                                        DerefTCB(RcvTCB, DISPATCH_LEVEL);
                                        return IP_SUCCESS;
                                    }

                                }

                                if (syntcb) {
                                    return IP_SUCCESS;
                                }

                                //
                                // No listening connection. AddrObjTableLock
                                // was released by FindListenConn. Fall
                                // through to send RST code.
                                //

                            } else {
                                //
                                // No address object. Free the lock, and fall
                                // through to the send RST code.
                                //
                                CTEFreeLockFromDPC(&AddrObjTableLock.Lock);
                            }
                        } else {
                            
                            //
                            // Operation not permitted. Free the lock, and
                            // fall through to the send RST code.
                            //
                            CTEFreeLockFromDPC(&AddrObjTableLock.Lock);
                        }

                    }
                    // Toss out any segments containing RST.
                    if (RcvInfo.tri_flags & TCP_FLAG_RST)
                        return IP_SUCCESS;

                    //
                    // Not a SYN, no AddrObj available, or port filtered.
                    // Send a RST back.
                    //
                    SendRSTFromHeader(TCPH, Size, Src, Dest, OptInfo);

                    return IP_SUCCESS;
                }
                //
                //TCB is already locked
                //

                CheckTCBRcv(RcvTCB);
                
                RcvTCB->tcb_kacount = 0;

                //scale the incoming window

                if (!(RcvInfo.tri_flags & TCP_FLAG_SYN)) {
                    RcvInfo.tri_window = ((uint) net_short(TCPH->tcp_window) << RcvTCB->tcb_sndwinscale);
                }

                //
                // We need to check if Time stamp or Sack options are present.
                //

                if (RcvTCB->tcb_tcpopts) {

                    int OptSize;
                    uchar *OptPtr;
                    OptSize = TCP_HDR_SIZE(TCPH) - sizeof(TCPHeader);
                    OptPtr = (uchar *) (TCPH + 1);

                    while (OptSize > 0) {

                        if (*OptPtr == TCP_OPT_EOL)
                            break;

                        if (*OptPtr == TCP_OPT_NOP) {
                            OptPtr++;
                            OptSize--;
                            continue;
                        }
                        
                        if ((*OptPtr == TCP_OPT_TS) && (OptSize >= TS_OPT_SIZE) &&
                            (OptPtr[1] == TS_OPT_SIZE)) {

                            if (RcvTCB->tcb_tcpopts & TCP_FLAG_TS) {
                                // remember timestamp and the the echoed time stamp

                                time_stamp = TRUE;
                                tsval = *(int UNALIGNED *)&OptPtr[2];
                                tsval = net_long(tsval);
                                tsecr = *(int UNALIGNED *)&OptPtr[6];
                                tsecr = net_long(tsecr);
                            }
                        } else if ((*OptPtr == TCP_OPT_SACK) && (OptSize > 1)
                                   && (RcvTCB->tcb_tcpopts & TCP_FLAG_SACK)
                                   && (OptSize >= OptPtr[1])) {

                            SackSeg UNALIGNED *SackPtr;

                            SackListEntry *SackList, *Prev, *Current;
                            ushort SackOptionLength;

                            int i;

                            
                            // Sack blocks should not exist until we have
                            // actually sent some data. If we see Sack blocks
                            // before we are in a state where we can send data,
                            // just ignore them. Sack blocks should also be
                            // ignored if there is no ACK on the packet we
                            // received.
                            if ((RcvTCB->tcb_state < TCB_ESTAB) ||
                                (!(RcvInfo.tri_flags & TCP_FLAG_ACK))){
                                goto no_mem;
                            }

                            //SACK Option processing

                            SackPtr = (SackSeg *)(OptPtr + 2);

                            SackOptionLength = OptPtr[1];

                            // There can be at most 40 bytes for options
                            // which means at most 4 SACK blocks will fit
                            // check for this and dicard if too long.
                            if (SackOptionLength > (4*sizeof(SackSeg) + 2)) {
                                CTEFreeLockFromDPC(&RcvTCB->tcb_lock);
                                return IP_SUCCESS;
                            }
                            
                            //
                            // If the incoming sack blocks are with in this
                            // send window Just chain them.
                            // When there are some retransmissions, this list
                            // will be checked to see if retransmission can be
                            // skipped.
                            // Note that when the send window is slided, the
                            // sack list must be cleandup.
                            //

                            Prev = STRUCT_OF(SackListEntry, &RcvTCB->tcb_SackRcvd, next);
                            Current = RcvTCB->tcb_SackRcvd;

                            // Scan the list for old sack entries and purge them
                          
                            while ((Current != NULL) && SEQ_GTE(RcvInfo.tri_ack, Current->begin)) {
                                Prev->next = Current->next;
                                
                                IF_TCPDBG(TCP_DEBUG_SACK) {
                                    TCPTRACE(("Purging old entries %x %d %d\n", Current, Current->begin, Current->end));
                                }
                                CTEFreeMem(Current);
                                Current = Prev->next;
                            }

                            //
                            //Process each sack block in the incoming segment
                            // 8 bytes per block!
                            //

                            for (i = 0; i < (SackOptionLength >> 3); i++) {

                                SeqNum SakBegin, SakEnd;

                                // Get the rcvd bytes begin and end offset

                                SakBegin = net_long(SackPtr->begin);
                                SakEnd = net_long(SackPtr->end);

                                // Sanity check this Sack Block and against our
                                // send variables

                                if (!(SEQ_GT(SakEnd, SakBegin) &&
                                      SEQ_GTE(SakBegin, RcvTCB->tcb_senduna) &&
                                      SEQ_LT(SakBegin, RcvTCB->tcb_sendmax) &&
                                      SEQ_GT(SakEnd, RcvTCB->tcb_senduna) &&
                                      SEQ_LTE(SakEnd, RcvTCB->tcb_sendmax))) {
                                    
                                    SackPtr++;
                                    continue;
                                }
                                IF_TCPDBG(TCP_DEBUG_SACK) {
                                    TCPTRACE(("In sack entry opt %d %d\n", i, RcvTCB->tcb_senduna));
                                }

                                Prev = STRUCT_OF(SackListEntry, &RcvTCB->tcb_SackRcvd, next);
                                Current = RcvTCB->tcb_SackRcvd;

                                //
                                // scan the list and insert the incoming sack
                                // block in the right place, taking care of
                                // overlaps, if any.
                                //

                                while (Current != NULL) {

                                    if (SEQ_GT(Current->begin, SakBegin)) {

                                        //
                                        // Check if this sack block fills the
                                        // hole from previous entry. If so,
                                        // just update the end seq number.
                                        //
                                        if ((Prev != RcvTCB->tcb_SackRcvd) && SEQ_EQ(Prev->end, SakBegin)) {

                                            Prev->end = SakEnd;

                                            IF_TCPDBG(TCP_DEBUG_SACK) {
                                                TCPTRACE(("updating prev %x %d %d %x\n", Prev, Prev->begin, Prev->end, RcvTCB));
                                            }

                                            //
                                            //Make sure that next entry is not
                                            //an overlap.
                                            //

                                            if (SEQ_LTE(Current->begin, SakEnd)) {

                                                ASSERT(SEQ_GT(Current->begin, Prev->begin));
                                                Prev->end = Current->end;
                                                Prev->next = Current->next;
                                                CTEFreeMem(Current);

                                                Current = Prev;
                                                //
                                                // Now we need to scan forward
                                                // and check if sackend
                                                // spans several entries
                                                //
                                                {
                                                    SackListEntry *tmpcurrent = Current->next;

                                                    while (tmpcurrent && SEQ_GTE(Current->end, tmpcurrent->end)) {
                                                        Current->next = tmpcurrent->next;
                                                        CTEFreeMem(tmpcurrent);
                                                        tmpcurrent = Current->next;
                                                    }

                                                    //
                                                    // above check pointed
                                                    // tmpcurrent whose end is
                                                    // > sakend
                                                    // Check if the tmpcurrent
                                                    // entry begin is overlapped
                                                    //
                                                    if (tmpcurrent && SEQ_GTE(Current->end, tmpcurrent->begin)) {

                                                        Current->end = tmpcurrent->end;
                                                        Current->next = tmpcurrent->next;
                                                        CTEFreeMem(tmpcurrent);

                                                    }
                                                }

                                            }
                                            break;

                                        } else if (SEQ_LTE(Current->begin, SakEnd)) {

                                            //
                                            // Current is continuation(may be
                                            // with overlap) of incoming
                                            // sack pair. Update current
                                            //

                                            IF_TCPDBG(TCP_DEBUG_SACK) {
                                                TCPTRACE(("updating in back overlap  %x %d %d %d %d\n", Current, Current->begin, Current->end, SakBegin, SakEnd));
                                            }

                                            Current->begin = SakBegin;

                                            //
                                            // If the end shoots out of the
                                            // current end new end will be the
                                            // current end
                                            // (overlaps at the tail too)
                                            // may overlap several entries.
                                            // So, check them all.
                                            //

                                            if (SEQ_GT(SakEnd, Current->end)) {
                                                SackListEntry *tmpcurrent = Current->next;
                                                Current->end = SakEnd;

                                                while (tmpcurrent && SEQ_GTE(Current->end, tmpcurrent->end)) {
                                                    Current->next = tmpcurrent->next;
                                                    CTEFreeMem(tmpcurrent);
                                                    tmpcurrent = Current->next;
                                                }

                                                //
                                                // above check pointed
                                                // tmpcurrent whose end is >
                                                // sakend.  Check if the
                                                // tmpcurrent entry begin is
                                                // overlapped
                                                //

                                                if (tmpcurrent && SEQ_GTE(Current->end, tmpcurrent->begin)) {

                                                    Current->end = tmpcurrent->end;
                                                    Current->next = tmpcurrent->next;
                                                    CTEFreeMem(tmpcurrent);

                                                }
                                            }
                                            break;

                                        } else {

                                            //
                                            //This is the place where we
                                            //insert the new entry
                                            //

                                            SackList = CTEAllocMemN(sizeof(SackListEntry), 'sPCT');
                                            if (SackList == NULL) {

                                                TCPTRACE(("No mem for sack List \n"));
                                                goto no_mem;
                                            }
                                            IF_TCPDBG(TCP_DEBUG_SACK) {
                                                TCPTRACE(("Inserting Sackentry  %x %d %d %x\n", SackList, SakBegin, SakEnd, RcvTCB));
                                            }

                                            SackList->begin = SakBegin;
                                            SackList->end = SakEnd;
                                            Prev->next = SackList;
                                            SackList->next = Current;
                                            break;
                                        }

                                    } else if (SEQ_EQ(Current->begin, SakBegin)) {

                                        SackListEntry *tmpcurrent = Current->next;
                                        //
                                        // Make sure that the new SakEnd is
                                        // not overlapping any other sak
                                        // entries.
                                        //

                                        if (tmpcurrent && SEQ_GTE(SakEnd, tmpcurrent->begin)) {

                                            Current->end = SakEnd;

                                            //
                                            //Sure, this sack overlaps next
                                            //entry.
                                            //

                                            while (tmpcurrent && SEQ_GTE(Current->end, tmpcurrent->end)) {
                                                Current->next = tmpcurrent->next;
                                                CTEFreeMem(tmpcurrent);
                                                tmpcurrent = Current->next;
                                            }

                                            //
                                            // above check pointed tmpcurrent
                                            // whose end is > sakend
                                            // Check if the tmpcurrent entry
                                            // begin is overlapped
                                            //

                                            if (tmpcurrent && SEQ_GTE(Current->end, tmpcurrent->begin)) {

                                                Current->end = tmpcurrent->end;
                                                Current->next = tmpcurrent->next;
                                                CTEFreeMem(tmpcurrent);

                                            }
                                            break;

                                        } else {

                                            //
                                            // This can still be a duplicate
                                            // Make sure that SakEnd is really
                                            // greater than Current->end
                                            //

                                            if (SEQ_GT(SakEnd, Current->end)) {

                                                IF_TCPDBG(TCP_DEBUG_SACK) {
                                                    TCPTRACE(("updating current  %x %d %d %d\n", Current, Current->begin, Current->end, SakEnd));
                                                }

                                                Current->end = SakEnd;
                                            }
                                            break;
                                        }

                                        //SakBegin > Current->begin

                                    } else if (SEQ_LTE(SakEnd, Current->end)) {

                                        //
                                        //The incoming sack end is within the
                                        //current end so, this overlaps the
                                        //existing sack entry ignore this.
                                        //

                                        break;
                                    //
                                    // incoming seq begin  overlaps the
                                    // current end update the current end.
                                    //
                                    } else if (SEQ_LTE(SakBegin, Current->end)) {

                                        //
                                        //Sakend might well ovelap next
                                        //several entries. Scan for it.
                                        //

                                        SackListEntry *tmpcurrent = Current->next;

                                        Current->end = SakEnd;

                                        while (tmpcurrent && SEQ_GTE(Current->end, tmpcurrent->end)) {
                                            Current->next = tmpcurrent->next;
                                            CTEFreeMem(tmpcurrent);
                                            tmpcurrent = Current->next;
                                        }

                                        //
                                        // above check pointed tmpcurrent
                                        // whose end is > sakend
                                        // Check if the tmpcurrent entry begin
                                        // is overlapped
                                        //

                                        if (tmpcurrent && SEQ_GTE(Current->end, tmpcurrent->begin)) {

                                            Current->end = tmpcurrent->end;
                                            Current->next = tmpcurrent->next;
                                            CTEFreeMem(tmpcurrent);

                                        }
                                        break;

                                    }
                                    Prev = Current;
                                    Current = Current->next;

                                }    //while

                                if (Current == NULL) {
                                    // this is the new sack entry
                                    // create the entry and hang it on tcb.
                                    SackList = CTEAllocMemN(sizeof(SackListEntry), 'sPCT');

                                    if (SackList == NULL) {
                                        TCPTRACE(("No mem for sack List \n"));
                                        goto no_mem;
                                    }
                                    Prev->next = SackList;
                                    SackList->next = NULL;
                                    SackList->begin = SakBegin;
                                    SackList->end = SakEnd;

                                    IF_TCPDBG(TCP_DEBUG_SACK) {
                                        TCPTRACE(("Inserting new Sackentry  %x %d %d %x\n", SackList, SackList->begin, SackList->end, RcvTCB->tcb_SackRcvd));
                                    }
                                }
                                //advance sack ptr to the next sack block
                                // check for consistency????
                                SackPtr++;

                            }    //for

                        }
                      no_mem:;
                        
                        //unknown options
                        if (OptSize > 1) {

                            if (OptPtr[1] == 0 || OptPtr[1] > OptSize)
                                break;    // Bad option length, bail out.

                            OptSize -= OptPtr[1];
                            OptPtr += OptPtr[1];
                        } else
                            break;

                    }            //while
                }
                // if ack is with in the sequence space,that is
                // this seq number is next expected or repeat of previous
                // segment but the right edge is new for us,
                // record the time stamp val of the remote, which will be echoed

                if (time_stamp &&
                    TS_GTE(tsval, RcvTCB->tcb_tsrecent) &&
                    SEQ_LTE(RcvInfo.tri_seq, RcvTCB->tcb_lastack)) {

                    RcvTCB->tcb_tsupdatetime = TCPTime;
                    RcvTCB->tcb_tsrecent = tsval;
                }

                //
                // Do the fast path check. We can hit the fast path if the
                // incoming sequence number matches our receive next and the
                // masked flags match our 'predicted' flags.
                // Also, include PAWS check
                //

                if (RcvTCB->tcb_rcvnext == RcvInfo.tri_seq &&
                    (!time_stamp || TS_GTE(tsval, RcvTCB->tcb_tsrecent)) &&
                    (RcvInfo.tri_flags & TCP_FLAGS_ALL) == RcvTCB->tcb_fastchk)
                {
                    uint    CWin;

                    INITQ(&SendQ);
                    Actions = 0;
                    REFERENCE_TCB(RcvTCB);

                    // Since we are accepting the packet, start the
                    // keepalive timer.
                    if ((RcvTCB->tcb_flags & KEEPALIVE) &&
                        (RcvTCB->tcb_conn != NULL)) {
                       
                        START_TCB_TIMER_R(RcvTCB, KA_TIMER,
                                          RcvTCB->tcb_conn->tc_tcbkatime);
                    }
                    
                    //
                    // The fast path. We know all we have to do here is ack
                    // sends and deliver data. First try and ack data.
                    //

                    if (SEQ_LT(RcvTCB->tcb_senduna, RcvInfo.tri_ack) &&
                        SEQ_LTE(RcvInfo.tri_ack, RcvTCB->tcb_sendmax)) {

                        uint MSS;
                        uint Amount = RcvInfo.tri_ack - RcvTCB->tcb_senduna;

                        //
                        // The ack acknowledes something. Pull the
                        // appropriate amount off the send q.
                        //
                        ACKData(RcvTCB, RcvInfo.tri_ack, &SendQ);

                        //
                        // If this acknowledges something we were running an
                        // RTT on, update that stuff now.
                        //

                        {
                            short RTT = 0;
                            BOOLEAN fUpdateRtt = FALSE;

                            //
                            //if timestamp is true, get the RTT using the echoed
                            //timestamp.
                            //

                            if (time_stamp && tsecr) {
                                RTT = TCPTime - tsecr;
                                fUpdateRtt = TRUE;
                            } else {
                                if (RcvTCB->tcb_rtt != 0 &&
                                            SEQ_GT(RcvInfo.tri_ack,
                                                     RcvTCB->tcb_rttseq)) {
                                    fUpdateRtt = TRUE;
                                    RTT = (short)(TCPTime - RcvTCB->tcb_rtt);
                                }
                            }

                            if (fUpdateRtt) {


                                RcvTCB->tcb_rtt = 0;
                                RTT -= (RcvTCB->tcb_smrtt >> 3);  //alpha = 1/8

                                RcvTCB->tcb_smrtt += RTT;

                                RTT = (RTT >= 0 ? RTT : -RTT);
                                RTT -= (RcvTCB->tcb_delta >> 3);
                                RcvTCB->tcb_delta += RTT + RTT;   //Beta of
                                                                  //1/4 instead
                                                                  // of 1/8

                                RcvTCB->tcb_rexmit = MIN(MAX(REXMIT_TO(RcvTCB),
                                                             MIN_RETRAN_TICKS)+1, MAX_REXMIT_TO);
                            }
                        }

                        
                        // Update the congestion window now.
                        CWin = RcvTCB->tcb_cwin;
                        MSS = RcvTCB->tcb_mss;
                        if (CWin < RcvTCB->tcb_maxwin) {
                            if (CWin < RcvTCB->tcb_ssthresh)
                                CWin += (RcvTCB->tcb_flags & SCALE_CWIN)
                                            ? Amount : MSS;
                            else
                                CWin += MAX((MSS * MSS) / CWin, 1);

                            RcvTCB->tcb_cwin = CWin;
                        }
                        ASSERT(*(int *)&RcvTCB->tcb_cwin > 0);


                        //
                        // We've acknowledged something, so reset the rexmit
                        // count. If there's still stuff outstanding, restart
                        // the rexmit timer.
                        //
                        RcvTCB->tcb_rexmitcnt = 0;
                        if (SEQ_EQ(RcvInfo.tri_ack, RcvTCB->tcb_sendmax))
                            STOP_TCB_TIMER_R(RcvTCB, RXMIT_TIMER);
                        else
                            START_TCB_TIMER_R(RcvTCB, RXMIT_TIMER, RcvTCB->tcb_rexmit);

                        //
                        // Since we've acknowledged data, we need to update
                        // the window.
                        //
                        RcvTCB->tcb_sendwin = RcvInfo.tri_window;
                        RcvTCB->tcb_maxwin = MAX(RcvTCB->tcb_maxwin, RcvInfo.tri_window);
                        RcvTCB->tcb_sendwl1 = RcvInfo.tri_seq;
                        RcvTCB->tcb_sendwl2 = RcvInfo.tri_ack;
                        // We've updated the window, remember to send some more.
                        Actions = (RcvTCB->tcb_unacked ? NEED_OUTPUT : 0);

                        {
                            //
                            // If the receiver has already sent dup acks, but
                            // we are not sending because the SendWin is less
                            // than a segment, then to avoid time outs on the
                            // previous send (receiver is waiting for
                            // retransmitted data but we are not sending the
                            // segment..) prematurely
                            // timeout (set rexmittimer to 1 tick)
                            //

                            int SendWin;
                            uint AmtOutstanding, AmtUnsent;

                            AmtOutstanding = (uint) (RcvTCB->tcb_sendnext -
                                                     RcvTCB->tcb_senduna);
                            AmtUnsent = RcvTCB->tcb_unacked - AmtOutstanding;

                            SendWin = (int)(MIN(RcvTCB->tcb_sendwin,
                                            RcvTCB->tcb_cwin) - AmtOutstanding);

                            if ((RcvTCB->tcb_dup >= MaxDupAcks) && ((int)RcvTCB->tcb_ssthresh > 0)) {
                                //
                                // Fast retransmitted frame is acked
                                // Set cwin to ssthresh so that cwin grows
                                // linearly from here
                                //
                                RcvTCB->tcb_cwin = RcvTCB->tcb_ssthresh;
                            }
                        }

                        RcvTCB->tcb_dup = 0;

                    } else {

                        //
                        // It doesn't ack anything. If it's an ack for something
                        // larger than we've sent then ACKAndDrop it, otherwise
                        // ignore it.
                        //
                        if (SEQ_GT(RcvInfo.tri_ack, RcvTCB->tcb_sendmax)) {
                            ACKAndDrop(&RcvInfo, RcvTCB);
                            return IP_SUCCESS;
                        }
                        //
                        // If it is a pure duplicate ack, check if it is
                        // time to retransmit immediately
                        //

                        else if ((Size == 0) &&
                                 SEQ_EQ(RcvTCB->tcb_senduna, RcvInfo.tri_ack) &&
                                 (SEQ_LT(RcvTCB->tcb_senduna,
                                                        RcvTCB->tcb_sendmax)) &&
                                 (RcvTCB->tcb_sendwin == RcvInfo.tri_window) &&
                                 RcvInfo.tri_window
                                 ) {

                                 // See of fast rexmit can be done

                                 if (HandleFastXmit(RcvTCB, &RcvInfo)) {

                                     return IP_SUCCESS;
                                 }
                                 Actions = (RcvTCB->tcb_unacked ? NEED_OUTPUT : 0);

                        } else {    // not a pure duplicate ack (size == 0 )

                            // Size !=0  or recvr is advertizing new window.
                            // update the window and check if
                            // anything needs to be sent

                            RcvTCB->tcb_dup = 0;

                            if (SEQ_EQ(RcvTCB->tcb_senduna, RcvInfo.tri_ack) &&
                                (SEQ_LT(RcvTCB->tcb_sendwl1, RcvInfo.tri_seq) ||
                                 (SEQ_EQ(RcvTCB->tcb_sendwl1, RcvInfo.tri_seq) &&
                                  SEQ_LTE(RcvTCB->tcb_sendwl2, RcvInfo.tri_ack)))) {
                                RcvTCB->tcb_sendwin = RcvInfo.tri_window;
                                RcvTCB->tcb_maxwin = MAX(RcvTCB->tcb_maxwin,
                                                         RcvInfo.tri_window);
                                RcvTCB->tcb_sendwl1 = RcvInfo.tri_seq;
                                RcvTCB->tcb_sendwl2 = RcvInfo.tri_ack;

                                //
                                // Since we've updated the window, remember to
                                // send some more.
                                //
                                Actions = (RcvTCB->tcb_unacked ? NEED_OUTPUT : 0);
                            }
                        }   // for SEQ_EQ(RcvInfo.tri_ack, RcvTCB->tcb_sendmax)
                            // case


                    }

                    NewSize = MIN((int)Size, RcvTCB->tcb_rcvwin);
                    if (NewSize != 0) {
                        RcvTCB->tcb_fastchk |= TCP_FLAG_IN_RCV;
                        BytesTaken = (*RcvTCB->tcb_rcvhndlr) (RcvTCB, RcvInfo.tri_flags,
                                                              RcvBuf, NewSize);
                        RcvTCB->tcb_rcvnext += BytesTaken;
                        RcvTCB->tcb_rcvwin -= BytesTaken;
                        CheckTCBRcv(RcvTCB);

                        RcvTCB->tcb_fastchk &= ~TCP_FLAG_IN_RCV;

                        Actions |= (RcvTCB->tcb_flags & SEND_AFTER_RCV ?
                                    NEED_OUTPUT : 0);

                        RcvTCB->tcb_flags &= ~SEND_AFTER_RCV;
                        if (BytesTaken != NewSize) {

                            Actions |= NEED_ACK;
                            RcvTCB->tcb_rcvdsegs = 0;
                            STOP_TCB_TIMER_R(RcvTCB, DELACK_TIMER);

                        } else {

                           if (RcvTCB->tcb_rcvdsegs != RcvTCB->tcb_numdelacks) {
                               RcvTCB->tcb_rcvdsegs++;
                               RcvTCB->tcb_flags |= ACK_DELAYED;
                               ASSERT(RcvTCB->tcb_delackticks);
                               START_TCB_TIMER_R(RcvTCB, DELACK_TIMER, RcvTCB->tcb_delackticks);
                           } else {
                               Actions |= NEED_ACK;
                               RcvTCB->tcb_rcvdsegs = 0;
                               STOP_TCB_TIMER_R(RcvTCB, DELACK_TIMER);
                           }

                        }
                    } else {
                        //
                        // The new size is 0. If the original size was not 0,
                        // we must have a 0 rcv. win and hence need to send an
                        // ACK to this probe.
                        //
                        Actions |= (Size ? NEED_ACK : 0);
                    }


                    if (Actions)
                        DelayAction(RcvTCB, Actions);

                    DerefTCB(RcvTCB, DISPATCH_LEVEL);

                    CompleteSends(&SendQ);
                    return IP_SUCCESS;
                }
                //
                // Make sure we can handle this frame. We can't handle it if
                // we're in SYN_RCVD and the accept is still pending, or we're
                // in a non-established state and already in the receive
                // handler.
                //
                if ((RcvTCB->tcb_state == TCB_SYN_RCVD &&
                     !(RcvTCB->tcb_flags & CONN_ACCEPTED) &&
                     !(RcvTCB->tcb_flags & ACTIVE_OPEN)) ||
                    (RcvTCB->tcb_state != TCB_ESTAB && (RcvTCB->tcb_fastchk &
                                                        TCP_FLAG_IN_RCV))) {
                    CTEFreeLockFromDPC(&RcvTCB->tcb_lock);
                    return IP_SUCCESS;
                }
                
                //
                // If it's closed, it's a temporary zombie TCB. Reset the
                // sender.
                //
                if (RcvTCB->tcb_state == TCB_CLOSED || CLOSING(RcvTCB) ||
                    ((RcvTCB->tcb_flags & (GC_PENDING | TW_PENDING)) == GC_PENDING)) {
                    CTEFreeLockFromDPC(&RcvTCB->tcb_lock);
                    SendRSTFromHeader(TCPH, Size, Src, Dest, OptInfo);
                    return IP_SUCCESS;
                }

                //
                // At this point, we have a connection, and it's locked.
                // Following the 'Segment Arrives' section of 793, the next
                // thing to check is if this connection is in SynSent state.
                //

                if (RcvTCB->tcb_state == TCB_SYN_SENT) {

                    ASSERT(RcvTCB->tcb_flags & ACTIVE_OPEN);

                    //
                    // Check the ACK bit. Since we don't send data with our
                    // SYNs, the check we make is for the ack to exactly match
                    // our SND.NXT.
                    //
                    if (RcvInfo.tri_flags & TCP_FLAG_ACK) {
                        
                        // ACK is set.
                        if (!SEQ_EQ(RcvInfo.tri_ack, RcvTCB->tcb_sendnext)) {
                            // Bad ACK value.
                            CTEFreeLockFromDPC(&RcvTCB->tcb_lock);
                            // Send a RST back at him.
                            SendRSTFromHeader(TCPH, Size, Src, Dest, OptInfo);
                            return IP_SUCCESS;
                        }   
                    }
                    if (RcvInfo.tri_flags & TCP_FLAG_RST) {                    
                        //
                        // There's an acceptable RST. We'll persist here,
                        // sending another SYN in PERSIST_TIMEOUT ms, until we
                        // fail from too many retrys.
                        //
                        if (!(RcvTCB->tcb_fastchk & TCP_FLAG_RST_WHILE_SYN)) {
                            RcvTCB->tcb_fastchk |= TCP_FLAG_RST_WHILE_SYN;
                            RcvTCB->tcb_slowcount++;
                        }

                        if (RcvTCB->tcb_rexmitcnt == MaxConnectRexmitCount) {
                            //
                            // We've had a positive refusal, and one more rexmit
                            // would time us out, so close the connection now.
                            //
                            REFERENCE_TCB(RcvTCB);
                            CompleteConnReq(RcvTCB, OptInfo, TDI_CONN_REFUSED);

                            TryToCloseTCB(RcvTCB, TCB_CLOSE_REFUSED, DISPATCH_LEVEL);
                            CTEGetLockAtDPC(&RcvTCB->tcb_lock);
                            DerefTCB(RcvTCB, DISPATCH_LEVEL);
                        } else {
                            START_TCB_TIMER_R(RcvTCB, RXMIT_TIMER, PERSIST_TIMEOUT);
                            CTEFreeLockFromDPC(&RcvTCB->tcb_lock);
                        }
                        return IP_SUCCESS;
                    }
                    // See if we have a SYN. If we do, we're going to change state
                    // somehow (either to ESTABLISHED or SYN_RCVD).
                    if (RcvInfo.tri_flags & TCP_FLAG_SYN) {
                        uint RexmitCnt = RcvTCB->tcb_rexmitcnt;
                        REFERENCE_TCB(RcvTCB);

                        // We have a SYN. Go ahead and record the sequence number and
                        // window info.
                        RcvTCB->tcb_rcvnext = ++RcvInfo.tri_seq;

                        if (RcvInfo.tri_flags & TCP_FLAG_URG) {

                            // Urgent data. Update the pointer.
                            if (RcvInfo.tri_urgent != 0)
                                RcvInfo.tri_urgent--;
                            else
                                RcvInfo.tri_flags &= ~TCP_FLAG_URG;
                        }
                        //
                        // get remote mss and also enable ws, ts or sack options
                        // if they are negotiated and if the host supports them.
                        //

                        RcvTCB->tcb_sndwinscale = 0;
                        RcvTCB->tcb_remmss = FindMSSAndOptions(TCPH, RcvTCB,
                                                               FALSE);


                        //
                        // If there are options, update them now. We already
                        // have an RCE open, so if we have new options we'll
                        // have to close it and open a new one.
                        //
                        if (OptInfo->ioi_options != NULL) {
                            if (!(RcvTCB->tcb_flags & CLIENT_OPTIONS)) {
                                (*LocalNetInfo.ipi_updateopts) (OptInfo,
                                                                &RcvTCB->tcb_opt, Src, NULL_IP_ADDR);
                                (*LocalNetInfo.ipi_closerce) (RcvTCB->tcb_rce);
                                InitRCE(RcvTCB);
                            }
                        } else {
                            RcvTCB->tcb_mss = MIN(RcvTCB->tcb_mss, RcvTCB->tcb_remmss);

                            ASSERT(RcvTCB->tcb_mss > 0);
                            ValidateMSS(RcvTCB);
                        }

                        RcvTCB->tcb_rexmitcnt = 0;
                        STOP_TCB_TIMER_R(RcvTCB, RXMIT_TIMER);

                        AdjustRcvWin(RcvTCB);

                        if (RcvInfo.tri_flags & TCP_FLAG_ACK) {
                            // Our SYN has been acked. Update SND.UNA and stop the
                            // retrans timer.
                            RcvTCB->tcb_senduna = RcvInfo.tri_ack;
                            RcvTCB->tcb_sendwin = RcvInfo.tri_window;
                            RcvTCB->tcb_maxwin = RcvInfo.tri_window;
                            RcvTCB->tcb_sendwl1 = RcvInfo.tri_seq;
                            RcvTCB->tcb_sendwl2 = RcvInfo.tri_ack;
#if TRACE_EVENT
                            CPCallBack = TCPCPHandlerRoutine;
                            if (CPCallBack != NULL) {
                                ulong GroupType;
    
                                WMIInfo.wmi_destaddr = RcvTCB->tcb_daddr;
                                WMIInfo.wmi_destport = RcvTCB->tcb_dport;
                                WMIInfo.wmi_srcaddr  = RcvTCB->tcb_saddr;
                                WMIInfo.wmi_srcport  = RcvTCB->tcb_sport;
                                WMIInfo.wmi_size     = 0;
                                WMIInfo.wmi_context  = RcvTCB->tcb_cpcontext;
    
                                GroupType = EVENT_TRACE_GROUP_TCPIP +
                                            EVENT_TRACE_TYPE_CONNECT;
                                (*CPCallBack)(GroupType, (PVOID)&WMIInfo,
                                              sizeof(WMIInfo), NULL);
                            }
#endif

                            GoToEstab(RcvTCB);

                            //
                            // Indicate callback clients about this connection
                            // going to established state.
                            //
                            TcpInvokeCcb(TCP_CONN_SYN_SENT, TCP_CONN_ESTAB, 
                               &RcvTCB->tcb_addrbytes,
                              (*LocalNetInfo.ipi_getifindexfromindicatecontext)(IPContext));
 
                            //
                            // Set a bit that informs TCBTimeout to notify
                            // the automatic connection driver of this new
                            // connection.  Only set this flag if we
                            // have binded succesfully with the automatic
                            // connection driver.
                            //
                            if (fAcdLoadedG)
                                START_TCB_TIMER_R(RcvTCB, ACD_TIMER, 2);

                            //
                            // Remove whatever command exists on this
                            // connection.
                            //
                            CompleteConnReq(RcvTCB, OptInfo, TDI_SUCCESS);

                            //
                            // If data has been queued, send the first data
                            // segment with an ACK. Otherwise, send a pure ACK.
                            //
                            if (RcvTCB->tcb_unacked) {
                                REFERENCE_TCB(RcvTCB);
                                TCPSend(RcvTCB, DISPATCH_LEVEL);
                            } else {
                                CTEFreeLockFromDPC(&RcvTCB->tcb_lock);
                                SendACK(RcvTCB);
                            }

                            //
                            // Now handle other data and controls. To do this
                            // we need to reaquire the lock, and make sure we
                            // haven't started closing it.
                            //
                            CTEGetLockAtDPC(&RcvTCB->tcb_lock);
                            if (!CLOSING(RcvTCB)) {
                                //
                                // We haven't started closing it. Turn off the
                                // SYN flag and continue processing.
                                //
                                RcvInfo.tri_flags &= ~TCP_FLAG_SYN;
                                if ((RcvInfo.tri_flags & TCP_FLAGS_ALL) != TCP_FLAG_ACK ||
                                    Size != 0)
                                    goto NotSYNSent;
                            }
                            DerefTCB(RcvTCB, DISPATCH_LEVEL);
                            return IP_SUCCESS;
                        } else {
                            // A SYN, but not an ACK. Go to SYN_RCVD.
                            RcvTCB->tcb_state = TCB_SYN_RCVD;
                            RcvTCB->tcb_sendnext = RcvTCB->tcb_senduna;
                            if (SynAttackProtect) {
                                AddHalfOpenTCB();
                                AddHalfOpenRetry(RexmitCnt);
                            }
                            SendSYN(RcvTCB, DISPATCH_LEVEL);

                            CTEGetLockAtDPC(&RcvTCB->tcb_lock);
                            DerefTCB(RcvTCB, DISPATCH_LEVEL);
                            return IP_SUCCESS;
                        }

                    } else {
                        // No SYN, just toss the frame.
                        CTEFreeLockFromDPC(&RcvTCB->tcb_lock);
                        return IP_SUCCESS;
                    }

                }
                REFERENCE_TCB(RcvTCB);

              NotSYNSent:

                //do not allow buffer ownership via slow path
                if (RcvBuf)
                    RcvBuf->ipr_pMdl = NULL;

                // Check for PAWS(RFC 1323)
                // Check for tsrecent and tsval wrap around

                if (time_stamp &&
                    !(RcvInfo.tri_flags & TCP_FLAG_RST) &&
                    RcvTCB->tcb_tsrecent &&
                    TS_LT(tsval, RcvTCB->tcb_tsrecent)) {

                    // Time stamp is not valid
                    // Check if this is because the last update is
                    // 24 days old

                    if ((int)(TCPTime - RcvTCB->tcb_tsupdatetime) > PAWS_IDLE) {
                        //invalidate the ts
                        RcvTCB->tcb_tsrecent = 0;
                    } else {
                        ACKAndDrop(&RcvInfo, RcvTCB);

                        return IP_SUCCESS;
                    }
                }
                
                //
                // Not in the SYN-SENT state. Check the sequence number. If my
                // window is 0, I'll truncate all incoming frames but look at
                // some of the control fields. Otherwise I'll try and make
                // this segment fit into the window.
                //
                if (RcvTCB->tcb_rcvwin != 0) {
                    int StateSize;          // Size, including state info.
                    SeqNum LastValidSeq;    // Sequence number of last valid
                                            // byte at RWE.

                    //
                    // We are offering a window. If this segment starts in
                    // front of my receive window, clip off the front part.
                    //Check for the sanity of received sequence.
                    //This is to fix the 1 bit error(MSB) case in the rcv seq.
                    // Also, check the incoming size.
                    //

                    if ((SEQ_LT(RcvInfo.tri_seq, RcvTCB->tcb_rcvnext)) &&
                        ((int)Size >= 0) &&
                        (RcvTCB->tcb_rcvnext - RcvInfo.tri_seq) > 0)
                    {

                        int AmountToClip, FinByte;

                        if (RcvInfo.tri_flags & TCP_FLAG_SYN) {
                            //
                            // Had a SYN. Clip it off and update the seq number.
                            // This will be clipped off in the next if.
                            // Allow AckAndDrop routine to see the incoming SYN!
                            // RcvInfo.tri_flags &= ~TCP_FLAG_SYN;
                            //
                            RcvInfo.tri_seq++;
                            RcvInfo.tri_urgent--;
                        }
                        // Advance the receive buffer to point at the new data.
                        AmountToClip = RcvTCB->tcb_rcvnext - RcvInfo.tri_seq;
                        ASSERT(AmountToClip >= 0);

                        //
                        // If there's a FIN on this segment, we'll need to
                        // account for it.
                        //
                        FinByte = ((RcvInfo.tri_flags & TCP_FLAG_FIN) ? 1 : 0);

                        if (AmountToClip >= (((int)Size) + FinByte)) {
                            //
                            // Falls entirely before the window. We have more
                            // special case code here - if the ack. number
                            // acks something, we'll go ahead and take it,
                            // faking the sequence number to be rcvnext. This
                            // prevents problems on full duplex connections,
                            // where data has been received but not acked,
                            // and retransmission timers reset the seq. number
                            // to below our rcvnext.
                            //
                            if ((RcvInfo.tri_flags & TCP_FLAG_ACK) &&
                                SEQ_LT(RcvTCB->tcb_senduna, RcvInfo.tri_ack) &&
                                SEQ_LTE(RcvInfo.tri_ack, RcvTCB->tcb_sendmax)) {
                                //
                                // This contains valid ACK info. Fudge the info
                                // to get through the rest of this.
                                //
                                Size = 0;
                                AmountToClip = 0;
                                RcvInfo.tri_seq = RcvTCB->tcb_rcvnext;
                                RcvInfo.tri_flags &=
                                       ~(TCP_FLAG_SYN | TCP_FLAG_FIN |
                                         TCP_FLAG_RST | TCP_FLAG_URG);
#if DBG
                                FinByte = 1;    // Fake out assert below.
#endif
                            } else {

                                ACKAndDrop(&RcvInfo, RcvTCB);
                                return IP_SUCCESS;
                            }
                        }
                        if (RcvInfo.tri_flags & TCP_FLAG_SYN) {
                            RcvInfo.tri_flags &= ~TCP_FLAG_SYN;
                        }
                        //
                        // Trim what we have to. If we can't trim enough, the
                        // frame is too short. This shouldn't happen, but it
                        // it does we'll drop the frame.
                        //
                        Size -= AmountToClip;
                        RcvInfo.tri_seq += AmountToClip;
                        RcvInfo.tri_urgent -= AmountToClip;
                        RcvBuf = TrimRcvBuf(RcvBuf, AmountToClip);
                        ASSERT(RcvBuf != NULL);
                        ASSERT(RcvBuf->ipr_size != 0 ||
                                  (Size == 0 && FinByte));

                        RcvBuf->ipr_pMdl = NULL;

                        if (*(int *)&RcvInfo.tri_urgent < 0) {
                            RcvInfo.tri_urgent = 0;
                            RcvInfo.tri_flags &= ~TCP_FLAG_URG;
                        }
                    }
                    //
                    // We've made sure the front is OK. Now make sure part of
                    // it doesn't fall outside of the right edge of the
                    // window. If it does, we'll truncate the frame (removing
                    // the FIN, if any). If we truncate the whole frame we'll
                    // ACKAndDrop it.
                    //
                    StateSize =
                         Size + ((RcvInfo.tri_flags & TCP_FLAG_SYN) ? 1 : 0) +
                           ((RcvInfo.tri_flags & TCP_FLAG_FIN) ? 1 : 0);

                    if (StateSize)
                        StateSize--;

                    //
                    // Now the incoming sequence number (RcvInfo.tri_seq) +
                    // StateSize it the last sequence number in the segment.
                    // If this is greater than the last valid byte in the
                    // window, we have some overlap to chop off.
                    //

                    ASSERT(StateSize >= 0);
                    LastValidSeq = RcvTCB->tcb_rcvnext + RcvTCB->tcb_rcvwin - 1;
                    if (SEQ_GT(RcvInfo.tri_seq + StateSize, LastValidSeq)) {
                        int AmountToChop;

                        //
                        // At least some part of the frame is outside of our
                        // window. See if it starts outside our window.
                        //

                        if (SEQ_GT(RcvInfo.tri_seq, LastValidSeq)) {
                            //
                            // Falls entirely outside the window. We have
                            // special case code to deal with a pure ack that
                            // falls exactly at our right window edge.
                            // Otherwise we ack and drop it.
                            //
                            if (
                                 !SEQ_EQ(RcvInfo.tri_seq, LastValidSeq + 1) ||
                                 Size != 0 ||
                                 (RcvInfo.tri_flags & (TCP_FLAG_SYN |
                                       TCP_FLAG_FIN))
                               ) {


                                ACKAndDrop(&RcvInfo, RcvTCB);
                                return IP_SUCCESS;
                            }
                        } else {

                            //
                            // At least some part of it is in the window. If
                            // there's a FIN, chop that off and see if that
                            // moves us inside.
                            //
                            if (RcvInfo.tri_flags & TCP_FLAG_FIN) {
                                RcvInfo.tri_flags &= ~TCP_FLAG_FIN;
                                StateSize--;
                            }

                            // Now figure out how much to chop off.
                            AmountToChop = (RcvInfo.tri_seq + StateSize) -
                                                          LastValidSeq;
                            ASSERT(AmountToChop >= 0);
                            Size -= AmountToChop;
                            RcvBuf->ipr_pMdl = NULL;

                        }
                    }
                } else {
                    if (!SEQ_EQ(RcvTCB->tcb_rcvnext, RcvInfo.tri_seq)) {

                        //
                        // If there's a RST on this segment, and he's only off
                        // by 1, take it anyway. This can happen if the remote
                        // peer is probing and sends with the seq. # after the
                        // probe.
                        //
                        if (!(RcvInfo.tri_flags & TCP_FLAG_RST) ||
                            !(SEQ_EQ(RcvTCB->tcb_rcvnext, (RcvInfo.tri_seq - 1)))) {


                            ACKAndDrop(&RcvInfo, RcvTCB);
                            return IP_SUCCESS;
                        } else
                            RcvInfo.tri_seq = RcvTCB->tcb_rcvnext;
                    }
                    //
                    // He's in sequence, but we have a window of 0. Truncate the
                    // size, and clear any sequence consuming bits.
                    //
                    if (Size != 0 ||
                        (RcvInfo.tri_flags & (TCP_FLAG_SYN | TCP_FLAG_FIN))) {
                        RcvInfo.tri_flags &= ~(TCP_FLAG_SYN | TCP_FLAG_FIN);
                        Size = 0;
                        if (!(RcvInfo.tri_flags & TCP_FLAG_RST))
                            DelayAction(RcvTCB, NEED_ACK);
                    }
                }

                //
                // At this point, the segment is in our window and does not
                // overlap on either end. If it's the next seq number we
                // expect, we can handle the data now. Otherwise we'll queue
                // it for later. In either case we'll handle RST and ACK
                // information right now.
                //
                ASSERT((*(int *)&Size) >= 0);

                // Since we are accepting the packet, start the
                // keepalive timer.
                if ((RcvTCB->tcb_flags & KEEPALIVE) &&
                    (RcvTCB->tcb_conn != NULL)) {
                      
                    START_TCB_TIMER_R(RcvTCB, KA_TIMER,
                                      RcvTCB->tcb_conn->tc_tcbkatime);
                }
                    
                
                // Now, following 793, we check the RST bit.
                if (RcvInfo.tri_flags & TCP_FLAG_RST) {
                    uchar Reason;

                    //
                    // We can't go back into the LISTEN state from SYN-RCVD
                    // here, because we may have notified the client via a
                    // listen completing or a connect indication. So, if came
                    // from an active open we'll give back a 'connection
                    // refused' notice. For all other cases
                    // we'll just destroy the connection.
                    //

                    if (RcvTCB->tcb_state == TCB_SYN_RCVD) {
                        if (RcvTCB->tcb_flags & ACTIVE_OPEN)
                            Reason = TCB_CLOSE_REFUSED;
                        else
                            Reason = TCB_CLOSE_RST;
                    } else
                        Reason = TCB_CLOSE_RST;


                    TryToCloseTCB(RcvTCB, Reason, DISPATCH_LEVEL);
                    CTEGetLockAtDPC(&RcvTCB->tcb_lock);

                    if (RcvTCB->tcb_state != TCB_TIME_WAIT) {
                        CTEFreeLockFromDPC(&RcvTCB->tcb_lock);
                        RemoveTCBFromConn(RcvTCB);
                        NotifyOfDisc(RcvTCB, OptInfo, TDI_CONNECTION_RESET,
                                     NULL);
                        CTEGetLockAtDPC(&RcvTCB->tcb_lock);
                    }
                    DerefTCB(RcvTCB, DISPATCH_LEVEL);
                    return IP_SUCCESS;
                }
                // Next check the SYN bit.
                if (RcvInfo.tri_flags & TCP_FLAG_SYN) {
                    //
                    // Again, we can't quietly go back into the LISTEN state
                    // here, even if we came from a passive open.
                    //
                    TryToCloseTCB(RcvTCB, TCB_CLOSE_ABORTED, DISPATCH_LEVEL);
                    SendRSTFromHeader(TCPH, Size, Src, Dest, OptInfo);

                    CTEGetLockAtDPC(&RcvTCB->tcb_lock);

                    if (RcvTCB->tcb_state != TCB_TIME_WAIT) {
                        CTEFreeLockFromDPC(&RcvTCB->tcb_lock);
                        RemoveTCBFromConn(RcvTCB);
                        NotifyOfDisc(RcvTCB, OptInfo, TDI_CONNECTION_RESET,
                                     NULL);
                        CTEGetLockAtDPC(&RcvTCB->tcb_lock);
                    }
                    DerefTCB(RcvTCB, DISPATCH_LEVEL);
                    return IP_SUCCESS;
                }

                //
                // Check the ACK field. If it's not on drop the segment.
                //
                if (!(RcvInfo.tri_flags & TCP_FLAG_ACK)) {
                    DerefTCB(RcvTCB, DISPATCH_LEVEL);
                    return IP_SUCCESS;
                }

                INITQ(&SendQ);

                //
                // If we're in SYN-RCVD, go to ESTABLISHED.
                //
                if (RcvTCB->tcb_state == TCB_SYN_RCVD) {
                    if (SEQ_LT(RcvTCB->tcb_senduna, RcvInfo.tri_ack) &&
                        SEQ_LTE(RcvInfo.tri_ack, RcvTCB->tcb_sendmax)) {
                        // The ack is valid.

                        if (RcvTCB->tcb_fastchk & TCP_FLAG_ACCEPT_PENDING) {
                            AddrObj *AO;
                            BOOLEAN Accepted = FALSE;

                            //
                            // We will be reiniting the tcprexmitcnt to 0.
                            // If we are configured for syn-attack
                            // protection and the rexmit cnt is >1,
                            // decrement the count of connections that are
                            // in the half-open-retried state. Check
                            // whether we are below a low-watermark. If we
                            // are, increase the rexmit count back to
                            // configured values
                            //
                            CTEFreeLockFromDPC(&RcvTCB->tcb_lock);

                            // Check if we still have the listening endpoint
                            CTEGetLockAtDPC(&AddrObjTableLock.Lock);
                            AO = GetBestAddrObj(Dest, TCPH->tcp_dest,
                                                PROTOCOL_TCP,
                                                GAO_FLAG_CHECK_IF_LIST);

                            if (AO && AO->ao_connect == NULL) {

                                //
                                // Lets see if there is one more addr obj
                                // matching the incoming request with
                                // ao_connect != NULL
                                //

                                AddrObj *tmpAO;

                                tmpAO = GetNextBestAddrObj(Dest, TCPH->tcp_dest,
                                                           PROTOCOL_TCP, AO,
                                                           GAO_FLAG_CHECK_IF_LIST);

                                if (tmpAO != NULL) {
                                    AO = tmpAO;
                                }
                            }

                            if (AO != NULL) {
                                Accepted = DelayedAcceptConn(AO, Src,
                                                             TCPH->tcp_src,
                                                             OptInfo, RcvTCB);
                            } else {
                                CTEFreeLockFromDPC(&AddrObjTableLock.Lock);
                                Accepted = FALSE;
                            }

                            if (Accepted) {
                                AcceptConn(RcvTCB, TRUE, DISPATCH_LEVEL);
                            } else {
                                CTEGetLockAtDPC(&RcvTCB->tcb_lock);
                                TryToCloseTCB(RcvTCB, TCB_CLOSE_REFUSED, DISPATCH_LEVEL);
                                CTEGetLockAtDPC(&RcvTCB->tcb_lock);
                                DerefTCB(RcvTCB, DISPATCH_LEVEL);
                                SendRSTFromHeader(TCPH, Size, Src, Dest, OptInfo);
                                return IP_SUCCESS;
                            }
                        }

                        if (SynAttackProtect) {
                            DropHalfOpenTCB(RcvTCB->tcb_rexmitcnt);
                        }
                        RcvTCB->tcb_rexmitcnt = 0;
                        STOP_TCB_TIMER_R(RcvTCB, RXMIT_TIMER);
                        RcvTCB->tcb_senduna++;
                        RcvTCB->tcb_sendwin = RcvInfo.tri_window;
                        RcvTCB->tcb_maxwin = RcvInfo.tri_window;
                        RcvTCB->tcb_sendwl1 = RcvInfo.tri_seq;
                        RcvTCB->tcb_sendwl2 = RcvInfo.tri_ack;

                        GoToEstab(RcvTCB);

                        TcpInvokeCcb(TCP_CONN_SYN_RCVD, TCP_CONN_ESTAB, 
                              &RcvTCB->tcb_addrbytes,
                              (*LocalNetInfo.ipi_getifindexfromindicatecontext)(IPContext));

#if TRACE_EVENT

                        CPCallBack = TCPCPHandlerRoutine;
                        if (CPCallBack != NULL) {
                            ulong GroupType;

                            WMIInfo.wmi_destaddr = RcvTCB->tcb_daddr;
                            WMIInfo.wmi_destport = RcvTCB->tcb_dport;
                            WMIInfo.wmi_srcaddr  = RcvTCB->tcb_saddr;
                            WMIInfo.wmi_srcport  = RcvTCB->tcb_sport;
                            WMIInfo.wmi_size     = 0;
                            WMIInfo.wmi_context  = RcvTCB->tcb_cpcontext;

                            GroupType = EVENT_TRACE_GROUP_TCPIP + EVENT_TRACE_TYPE_ACCEPT;
                            (*CPCallBack) (GroupType, (PVOID)&WMIInfo, sizeof(WMIInfo), NULL);
                        }
#endif

                        // Now complete whatever we can here.
                        CompleteConnReq(RcvTCB, OptInfo, TDI_SUCCESS);
                    } else {

                        if (SynAttackProtect) {

                            //
                            // We are going to be more aggressive in closing
                            // half-open connections when SYN attack protection
                            // is enabled. By closing the connection here, we
                            // are minimizing ISN prediction attacks.
                            //
                            TryToCloseTCB(RcvTCB, TCB_CLOSE_REFUSED,
                                          DISPATCH_LEVEL);
                            CTEGetLockAtDPC(&RcvTCB->tcb_lock);
                        }

                        DerefTCB(RcvTCB, DISPATCH_LEVEL);
                        SendRSTFromHeader(TCPH, Size, Src, Dest, OptInfo);
                        return IP_SUCCESS;
                    }
                } else {
                    // We're not in SYN-RCVD. See if this acknowledges anything.
                    if (SEQ_LT(RcvTCB->tcb_senduna, RcvInfo.tri_ack) &&
                        SEQ_LTE(RcvInfo.tri_ack, RcvTCB->tcb_sendmax)) {
                        uint CWin;
                        uint Amount = RcvInfo.tri_ack - RcvTCB->tcb_senduna;

                        //
                        // The ack acknowledes something. Pull the
                        // appropriate amount off the send q.
                        //
                        ACKData(RcvTCB, RcvInfo.tri_ack, &SendQ);


                        //
                        // If this acknowledges something we were running
                        // an RTT on, update that stuff now.
                        //

                        {
                            short RTT = 0;
                            BOOLEAN fUpdateRtt = FALSE;

                            //
                            // if timestamp is true, get the RTT using the
                            // echoed timestamp.
                            //

                            if (time_stamp && tsecr) {
                                RTT = TCPTime - tsecr;
                                fUpdateRtt = TRUE;
                            } else {
                                if (RcvTCB->tcb_rtt != 0 &&
                                           SEQ_GT(RcvInfo.tri_ack,
                                                   RcvTCB->tcb_rttseq)) {
                                    RTT = (short)(TCPTime - RcvTCB->tcb_rtt);
                                    fUpdateRtt = TRUE;
                                }
                            }

                            if (fUpdateRtt) {


                                RcvTCB->tcb_rtt = 0;
                                RTT -= (RcvTCB->tcb_smrtt >> 3);
                                RcvTCB->tcb_smrtt += RTT;

                                RTT = (RTT >= 0 ? RTT : -RTT);
                                RTT -= (RcvTCB->tcb_delta >> 3);
                                RcvTCB->tcb_delta += RTT + RTT;

                                RcvTCB->tcb_rexmit = MIN(MAX(REXMIT_TO(RcvTCB),
                                                             MIN_RETRAN_TICKS)+1, MAX_REXMIT_TO);
                            }
                        }


                        //
                        // If we're probing for a PMTU black hole we've
                        // found one, so turn off
                        // the detection. The size is already down, so
                        // leave it there.
                        //
                        if (RcvTCB->tcb_flags & PMTU_BH_PROBE) {
                            RcvTCB->tcb_flags &= ~PMTU_BH_PROBE;
                            RcvTCB->tcb_bhprobecnt = 0;
                            if (--(RcvTCB->tcb_slowcount) == 0) {
                                RcvTCB->tcb_fastchk &= ~TCP_FLAG_SLOW;
                                CheckTCBRcv(RcvTCB);
                            }
                        }
                        // Update the congestion window now.
                        CWin = RcvTCB->tcb_cwin;
                        if (CWin < RcvTCB->tcb_maxwin) {
                            if (CWin < RcvTCB->tcb_ssthresh)
                                CWin += (RcvTCB->tcb_flags & SCALE_CWIN)
                                            ? Amount : RcvTCB->tcb_mss;
                            else
                                CWin += MAX((RcvTCB->tcb_mss * RcvTCB->tcb_mss) / CWin, 1);

                            RcvTCB->tcb_cwin = MIN(CWin, RcvTCB->tcb_maxwin);
                        }

                        if ((RcvTCB->tcb_dup > 0) && ((int)RcvTCB->tcb_ssthresh > 0)) {
                            //
                            // Fast retransmitted frame is acked
                            // Set cwin to ssthresh so that cwin grows
                            // linearly from here
                            //
                            RcvTCB->tcb_cwin = RcvTCB->tcb_ssthresh;
                        }

                        RcvTCB->tcb_dup = 0;

                        ASSERT(*(int *)&RcvTCB->tcb_cwin > 0);

                        //
                        // We've acknowledged something, so reset the
                        // rexmit count. If there's still stuff
                        // outstanding, restart the rexmit timer.
                        //
                        RcvTCB->tcb_rexmitcnt = 0;
                        if (!SEQ_EQ(RcvInfo.tri_ack, RcvTCB->tcb_sendmax))
                            START_TCB_TIMER_R(RcvTCB, RXMIT_TIMER, RcvTCB->tcb_rexmit);
                        else
                            STOP_TCB_TIMER_R(RcvTCB, RXMIT_TIMER);

                        //
                        // If we've sent a FIN, and this acknowledges it, we
                        // need to complete the client's close request and
                        // possibly transition our state.
                        //

                        if (RcvTCB->tcb_flags & FIN_SENT) {
                            //
                            // We have sent a FIN. See if it's been
                            // acknowledged. Once we've sent a FIN,
                            // tcb_sendmax can't advance, so our FIN must
                            // have seq. number tcb_sendmax - 1. Thus our
                            // FIN is acknowledged if the incoming ack is
                            // equal to tcb_sendmax.
                            //
                            if (SEQ_EQ(RcvInfo.tri_ack, RcvTCB->tcb_sendmax)) {
                                ushort ConnReqTimeout = 0;
                                //
                                // He's acked our FIN. Turn off the flags,
                                // and complete the request. We'll leave the
                                // FIN_OUTSTANDING flag alone, to force
                                // early outs in the send code.
                                //
                                RcvTCB->tcb_flags &= ~(FIN_NEEDED | FIN_SENT);


                                ASSERT(RcvTCB->tcb_unacked == 0);
                                ASSERT(RcvTCB->tcb_sendnext ==
                                          RcvTCB->tcb_sendmax);

                                //
                                // Now figure out what we need to do. In
                                // FIN_WAIT1 or FIN_WAIT, just complete
                                // the disconnect req. and continue.
                                // Otherwise, it's a bit trickier,
                                // since we can't complete the connreq
                                // until we remove the TCB from it's
                                // connection.
                                //
                                switch (RcvTCB->tcb_state) {

                                case TCB_FIN_WAIT1:

                                    RcvTCB->tcb_state = TCB_FIN_WAIT2;

                                    if (RcvTCB->tcb_fastchk & TCP_FLAG_SEND_AND_DISC) {
                                        //RcvTCB->tcb_flags |= DISC_NOTIFIED;
                                    } else {
                                        if (RcvTCB->tcb_connreq) {
                                            ConnReqTimeout = RcvTCB->tcb_connreq->tcr_timeout;
                                        }
                                        CompleteConnReq(RcvTCB, OptInfo, TDI_SUCCESS);
                                    }

                                    //
                                    // Start a timer in case we never get
                                    // out of FIN_WAIT2. Set the retransmit
                                    // count high to force a timeout the
                                    // first time the timer fires.
                                    //
                                    if (ConnReqTimeout) {
                                        RcvTCB->tcb_rexmitcnt = 1;
                                    } else {
                                        RcvTCB->tcb_rexmitcnt = (uchar) MaxDataRexmitCount;
                                        ConnReqTimeout = (ushort)FinWait2TO;
                                    }



                                    START_TCB_TIMER_R(RcvTCB, RXMIT_TIMER, ConnReqTimeout);

                                    //Fall through to FIN-WAIT-2 processing.
                                case TCB_FIN_WAIT2:
                                    break;
                                case TCB_CLOSING:

                                    //
                                    //Note that we do not care about
                                    //return stat from GracefulClose
                                    //since we do not touch the tcb
                                    //anyway, anymore, even if it is in
                                    //time_wait.
                                    //
                                    GracefulClose(RcvTCB, TRUE, FALSE,
                                                  DISPATCH_LEVEL);

                                    CompleteSends(&SendQ);
                                    return IP_SUCCESS;
                                    break;
                                case TCB_LAST_ACK:
                                    GracefulClose(RcvTCB, FALSE, FALSE,
                                                  DISPATCH_LEVEL);

                                    CompleteSends(&SendQ);
                                    return IP_SUCCESS;
                                    break;
                                default:
                                    ASSERT(0);
                                    break;
                                }
                            }
                        }
                        UpdateWindow = TRUE;


                    } else {
                        //
                        // It doesn't ack anything. If it's an ack for
                        // something larger than we've sent then
                        // ACKAndDrop it, otherwise ignore it. If we're in
                        // FIN_WAIT2, we'll restart the timer.
                        // We don't make this check above because we know no
                        // data can be acked when we're in FIN_WAIT2.
                        //

                        if (RcvTCB->tcb_state == TCB_FIN_WAIT2)
                            START_TCB_TIMER_R(RcvTCB, RXMIT_TIMER, (ushort) FinWait2TO);

                        if (SEQ_GT(RcvInfo.tri_ack, RcvTCB->tcb_sendmax)) {
                            ACKAndDrop(&RcvInfo, RcvTCB);
                            return IP_SUCCESS;

                        } else if ((Size == 0) &&
                                   SEQ_EQ(RcvTCB->tcb_senduna, RcvInfo.tri_ack) &&
                                   (SEQ_LT(RcvTCB->tcb_senduna, RcvTCB->tcb_sendmax)) &&
                                   (RcvTCB->tcb_sendwin == RcvInfo.tri_window) &&
                                   RcvInfo.tri_window) {

                                   // See if fast rexmit can be done

                                   if (HandleFastXmit(RcvTCB, &RcvInfo)){
                                       return IP_SUCCESS;
                                   }
                                   Actions = (RcvTCB->tcb_unacked ? NEED_OUTPUT : 0);
                        } else {

                            // Now update the window if we can.
                            if (SEQ_EQ(RcvTCB->tcb_senduna, RcvInfo.tri_ack) &&
                                (SEQ_LT(RcvTCB->tcb_sendwl1, RcvInfo.tri_seq) ||
                                 (SEQ_EQ(RcvTCB->tcb_sendwl1, RcvInfo.tri_seq) &&
                                  SEQ_LTE(RcvTCB->tcb_sendwl2, RcvInfo.tri_ack)))) {
                                UpdateWindow = TRUE;
                            } else
                                UpdateWindow = FALSE;
                        }
                    }

                    if (UpdateWindow) {
                        RcvTCB->tcb_sendwin = RcvInfo.tri_window;
                        RcvTCB->tcb_maxwin = MAX(RcvTCB->tcb_maxwin,
                                                 RcvInfo.tri_window);
                        RcvTCB->tcb_sendwl1 = RcvInfo.tri_seq;
                        RcvTCB->tcb_sendwl2 = RcvInfo.tri_ack;
                        if (RcvInfo.tri_window == 0) {
                            // We've got a zero window.
                            if (!EMPTYQ(&RcvTCB->tcb_sendq)) {
                                RcvTCB->tcb_flags &= ~NEED_OUTPUT;
                                RcvTCB->tcb_rexmitcnt = 0;
                                START_TCB_TIMER_R(RcvTCB, RXMIT_TIMER, RcvTCB->tcb_rexmit);
                                if (!(RcvTCB->tcb_flags & FLOW_CNTLD)) {
                                    RcvTCB->tcb_flags |= FLOW_CNTLD;
                                    RcvTCB->tcb_slowcount++;
                                    RcvTCB->tcb_fastchk |= TCP_FLAG_SLOW;
                                    CheckTCBRcv(RcvTCB);
                                }
                            }
                        } else {
                            if (RcvTCB->tcb_flags & FLOW_CNTLD) {
                                RcvTCB->tcb_rexmitcnt = 0;
                                RcvTCB->tcb_flags &= ~(FLOW_CNTLD | FORCE_OUTPUT);
                                //
                                // Reset send next to the left edge of the
                                // window, because it might be at
                                // senduna+1 if we've been probing.
                                //
                                ResetSendNext(RcvTCB, RcvTCB->tcb_senduna);

                                if (--(RcvTCB->tcb_slowcount) == 0) {
                                    RcvTCB->tcb_fastchk &= ~TCP_FLAG_SLOW;
                                    CheckTCBRcv(RcvTCB);
                                }
                            }
                            //
                            // Since we've updated the window, see if we
                            // can send some more.
                            //
                            if (RcvTCB->tcb_unacked != 0 ||
                                (RcvTCB->tcb_flags & FIN_NEEDED))
                                DelayAction(RcvTCB, NEED_OUTPUT);

                        }
                    }
                }

                //
                // We've handled all the acknowledgment stuff. If the size
                // is greater than 0 or FIN bit is set process it further, 
                // otherwise it's a pure ack and we're done with it.
                //
                if (Size == 0 && !(RcvInfo.tri_flags & TCP_FLAG_FIN))
                {
                    DerefTCB(RcvTCB, DISPATCH_LEVEL);
                    CompleteSends(&SendQ);
                    return IP_SUCCESS;
                }
                
                //
                // If we're not in a state where we can process
                // incoming data or FINs, there's no point in going
                // further. Just drop this segment.
                //
                if (!DATA_RCV_STATE(RcvTCB->tcb_state) ||
                    (RcvTCB->tcb_flags & GC_PENDING)) {
                    DerefTCB(RcvTCB, DISPATCH_LEVEL);
                    CompleteSends(&SendQ);
                    return IP_SUCCESS;
                }

                //
                // If it's in sequence process it now, otherwise
                // reassemble it.
                //
                if (SEQ_EQ(RcvInfo.tri_seq, RcvTCB->tcb_rcvnext)) {

                    //
                    // If we're already in the recv. handler, this is a
                    // duplicate. We'll just toss it.
                    //
                    if (RcvTCB->tcb_fastchk & TCP_FLAG_IN_RCV) {
                        DerefTCB(RcvTCB, DISPATCH_LEVEL);
                        CompleteSends(&SendQ);
                        return IP_SUCCESS;
                    }
                    RcvTCB->tcb_fastchk |= TCP_FLAG_IN_RCV;

                    //
                    // Now loop, pulling things from the reassembly
                    // queue, until the queue is empty, or we can't
                    // take all of the data, or we hit a FIN.
                    //

                    do {

                        // Handle urgent data, if any.
                        if (RcvInfo.tri_flags & TCP_FLAG_URG) {
                            HandleUrgent(RcvTCB, &RcvInfo, RcvBuf, &Size);

                            //
                            // Since we may have freed the lock, we
                            // need to recheck and see if we're
                            // closing here.
                            //
                            if (CLOSING(RcvTCB))
                                break;

                        }

                        //
                        // OK, the data is in sequence, we've updated
                        // the reassembly queue and handled any urgent
                        // data. If we have any data go ahead and
                        // process it now.
                        //
                        if (Size > 0) {

                            BytesTaken = (*RcvTCB->tcb_rcvhndlr) (RcvTCB,
                                                                  RcvInfo.tri_flags, RcvBuf, Size);
                            RcvTCB->tcb_rcvnext += BytesTaken;
                            RcvTCB->tcb_rcvwin -= BytesTaken;

                            CheckTCBRcv(RcvTCB);

                            if (RcvTCB->tcb_rcvdsegs != RcvTCB->tcb_numdelacks){
                                RcvTCB->tcb_flags |= ACK_DELAYED;
                                RcvTCB->tcb_rcvdsegs++;
                                ASSERT(RcvTCB->tcb_delackticks);
                                START_TCB_TIMER_R(RcvTCB, DELACK_TIMER,
                                                  RcvTCB->tcb_delackticks);
                            } else {
                                DelayAction(RcvTCB, NEED_ACK);
                                RcvTCB->tcb_rcvdsegs = 0;
                                STOP_TCB_TIMER_R(RcvTCB, DELACK_TIMER);
                            }

                            if (BytesTaken != Size) {
                                //
                                // We didn't take everything we could.
                                // No use in further processing, just
                                // bail out.
                                //
                                DelayAction(RcvTCB, NEED_ACK);
                                break;
                            }
                            //
                            // If we're closing now, we're done, so
                            // get out.
                            //
                            if (CLOSING(RcvTCB))
                                break;
                        }
                        //
                        // See if we need to advance over some urgent
                        // data.
                        //
                        if (RcvTCB->tcb_flags & URG_VALID) {
                            uint AdvanceNeeded;

                            //
                            // We only need to adv if we're not doing
                            // urgent inline. Urg inline also has some
                            // implications for when we can clear the
                            // URG_VALID flag. If we're not doing
                            // urgent inline, we can clear it when
                            // rcvnext advances beyond urgent end.
                            // If we are doing inline, we clear it
                            // when rcvnext advances one receive
                            // window beyond urgend.
                            //
                            if (!(RcvTCB->tcb_flags & URG_INLINE)) {

                                if (RcvTCB->tcb_rcvnext == RcvTCB->tcb_urgstart)
                                    RcvTCB->tcb_rcvnext = RcvTCB->tcb_urgend +
                                        1;
                                else
                                    ASSERT(SEQ_LT(RcvTCB->tcb_rcvnext,
                                                     RcvTCB->tcb_urgstart) ||
                                              SEQ_GT(RcvTCB->tcb_rcvnext,
                                                     RcvTCB->tcb_urgend));
                                AdvanceNeeded = 0;
                            } else
                                AdvanceNeeded = RcvTCB->tcb_defaultwin;

                            // See if we can clear the URG_VALID flag.
                            if (SEQ_GT(RcvTCB->tcb_rcvnext - AdvanceNeeded,
                                       RcvTCB->tcb_urgend)) {
                                RcvTCB->tcb_flags &= ~URG_VALID;
                                if (--(RcvTCB->tcb_slowcount) == 0) {
                                    RcvTCB->tcb_fastchk &= ~TCP_FLAG_SLOW;
                                    CheckTCBRcv(RcvTCB);
                                }
                            }
                        }
                        //
                        // We've handled the data. If the FIN bit is
                        // set, we have more processing.
                        //
                        if (RcvInfo.tri_flags & TCP_FLAG_FIN) {
                            uint Notify = FALSE;
                            uint DelayAck = TRUE;

                            RcvTCB->tcb_rcvnext++;

                            PushData(RcvTCB, TRUE);

                            switch (RcvTCB->tcb_state) {

                            case TCB_SYN_RCVD:
                                //
                                // I don't think we can get here - we
                                // should have discarded the frame if it
                                // had no ACK, or gone to established if
                                // it did.
                                //
                                ASSERT(0);
                            case TCB_ESTAB:
                                RcvTCB->tcb_state = TCB_CLOSE_WAIT;
                                //
                                // We left established, we're off the
                                // fast path.
                                //
                                RcvTCB->tcb_slowcount++;
                                RcvTCB->tcb_fastchk |= TCP_FLAG_SLOW;
                                CheckTCBRcv(RcvTCB);

                                Notify = TRUE;
                                break;
                            case TCB_FIN_WAIT1:

                                RcvTCB->tcb_state = TCB_CLOSING;
                                DelayAck = FALSE;
                                //RcvTCB->tcb_refcnt++;

                                CTEFreeLockFromDPC(&RcvTCB->tcb_lock);

                                SendACK(RcvTCB);

                                CTEGetLockAtDPC(&RcvTCB->tcb_lock);

                                if (0 == (RcvTCB->tcb_fastchk & TCP_FLAG_SEND_AND_DISC)) {
                                    Notify = TRUE;
                                }
                                
                                break;
                            case TCB_FIN_WAIT2:

                                // Stop the FIN_WAIT2 timer.
                                DelayAck = FALSE;

                                STOP_TCB_TIMER_R(RcvTCB, RXMIT_TIMER);

                                REFERENCE_TCB(RcvTCB);

                                CTEFreeLockFromDPC(&RcvTCB->tcb_lock);

                                SendACK(RcvTCB);

                                CTEGetLockAtDPC(&RcvTCB->tcb_lock);

                                if (RcvTCB->tcb_fastchk & TCP_FLAG_SEND_AND_DISC) {
                                    GracefulClose(RcvTCB, TRUE, FALSE, DISPATCH_LEVEL);
                                } else {
                                    GracefulClose(RcvTCB, TRUE, TRUE, DISPATCH_LEVEL);
                                }

                                //
                                //graceful close has put this tcb in
                                //timewait state should not access
                                //small tw tcb at this point
                                //
                                CTEGetLockAtDPC(&RcvTCB->tcb_lock);
                                DerefTCB(RcvTCB, DISPATCH_LEVEL);

                                CompleteSends(&SendQ);
                                return IP_SUCCESS;

                                break;
                            default:
                                ASSERT(0);
                                break;
                            }

                            if (DelayAck) {
                                DelayAction(RcvTCB, NEED_ACK);
                            }
                            if (Notify) {
                                CTEFreeLockFromDPC(&RcvTCB->tcb_lock);
                                NotifyOfDisc(RcvTCB, OptInfo,
                                             TDI_GRACEFUL_DISC, NULL);
                                CTEGetLockAtDPC(&RcvTCB->tcb_lock);
                            }
                            break;    // Exit out of WHILE loop.

                        }
                        // If the reassembly queue isn't empty, get what we
                        // can now.
                        RcvBuf = PullFromRAQ(RcvTCB, &RcvInfo, &Size);

                        if (RcvBuf)
                            RcvBuf->ipr_pMdl = NULL;

                        CheckRBList(RcvBuf, Size);

                    } while (RcvBuf != NULL);

                    RcvTCB->tcb_fastchk &= ~TCP_FLAG_IN_RCV;
                    if (RcvTCB->tcb_flags & SEND_AFTER_RCV) {
                        RcvTCB->tcb_flags &= ~SEND_AFTER_RCV;
                        DelayAction(RcvTCB, NEED_OUTPUT);
                    }
                    DerefTCB(RcvTCB, DISPATCH_LEVEL);

                    CompleteSends(&SendQ);
                    return IP_SUCCESS;
                } else {

                    // It's not in sequence. Since it needs further processing,
                    // put in on the reassembly queue.
                    if (DATA_RCV_STATE(RcvTCB->tcb_state) &&
                        !(RcvTCB->tcb_flags & GC_PENDING)) {
                        PutOnRAQ(RcvTCB, &RcvInfo, RcvBuf, Size);

                        //
                        //If SACK option is active, we need to construct
                        // SACK Blocks in ack
                        //

                        if (RcvTCB->tcb_tcpopts & TCP_FLAG_SACK) {

                            SendSackInACK(RcvTCB, RcvInfo.tri_seq);
                        } else {
                            CTEFreeLockFromDPC(&RcvTCB->tcb_lock);

                            SendACK(RcvTCB);
                        }

                        CTEGetLockAtDPC(&RcvTCB->tcb_lock);
                        DerefTCB(RcvTCB, DISPATCH_LEVEL);
                    } else
                        ACKAndDrop(&RcvInfo, RcvTCB);

                    CompleteSends(&SendQ);
                    return IP_SUCCESS;
                }
            } else { // DataOffset <= Size
                TStats.ts_inerrs++;
            }
        } else {
            TStats.ts_inerrs++;
        }
    } else { // IsBCast
        TStats.ts_inerrs++;
    }
    return IP_SUCCESS;
}

#pragma BEGIN_INIT

//* InitTCPRcv - Initialize TCP receive side.
//
//  Called during init time to initialize our TCP receive side.
//
//  Input: Nothing.
//
//  Returns: TRUE.
//
int
InitTCPRcv(void)
{
    uint i;

    //Allocate Time_Proc number of delayqueues
    PerCPUDelayQ = CTEAllocMemBoot(Time_Proc * sizeof(CPUDelayQ));

    if (PerCPUDelayQ == NULL) {
       return FALSE;
    }

    for (i = 0; i < Time_Proc; i++) {
       CTEInitLock(&PerCPUDelayQ[i].TCBDelayLock);
       INITQ(&PerCPUDelayQ[i].TCBDelayQ);
       PerCPUDelayQ[i].TCBDelayRtnCount = 0;
    }


#if MILLEN
    TCBDelayRtnLimit.Value = 1;
#else // MILLEN
    TCBDelayRtnLimit.Value = KeNumberProcessors;
    if (TCBDelayRtnLimit.Value > TCB_DELAY_RTN_LIMIT)
        TCBDelayRtnLimit.Value = TCB_DELAY_RTN_LIMIT;
#endif // !MILLEN

    DummyBuf.ipr_owner = IPR_OWNER_IP;
    DummyBuf.ipr_size = 0;
    DummyBuf.ipr_next = 0;
    DummyBuf.ipr_buffer = NULL;
    return TRUE;
}

//* UnInitTCPRcv - Uninitialize our receive side.
//
//  Called if initialization fails to uninitialize our receive side.
//
//
//  Input:  Nothing.
//
//  Returns: Nothing.
//
void
UnInitTCPRcv(void)
{

}

#pragma END_INIT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\tcpdeliv.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-2000          **/
/********************************************************************/
/* :ts=4 */

//** TCPDELIV.C - TCP deliver data code.
//
//  This file contains the code for delivering data to the user, including
//  putting data into recv. buffers and calling indication handlers.
//

#include "precomp.h"
#include "addr.h"
#include "tcp.h"
#include "tcb.h"
#include "tcprcv.h"
#include "tcpsend.h"
#include "tcpconn.h"
#include "pplasl.h"
#include "tcpdeliv.h"
#include "tlcommon.h"
#include "tcpipbuf.h"
#include "mdl2ndis.h"

extern TCPConnBlock **ConnTable;
extern HANDLE TcpRequestPool;

#if !MILLEN
HANDLE TcprBufferPool;
#ifdef DBG
ULONG  SlistAllocates = 0, NPPAllocates = 0;
#endif
#endif

extern BOOLEAN
 PutOnRAQ(TCB * RcvTCB, TCPRcvInfo * RcvInfo, IPRcvBuf * RcvBuf, uint Size);

NTSTATUS
TCPPrepareIrpForCancel(
                       PTCP_CONTEXT TcpContext,
                       PIRP Irp,
                       PDRIVER_CANCEL CancelRoutine
                       );

ULONG
TCPGetMdlChainByteCount(
                        PMDL Mdl
                        );

NTSTATUS
TCPDataRequestComplete(
                        void *Context,
                        unsigned int Status,
                        unsigned int ByteCount
                        );

VOID
TCPCancelRequest(
                 PDEVICE_OBJECT Device,
                 PIRP Irp
                 );


#if DBG
ULONG DbgChainedRcvPends;
ULONG DbgChainedRcvNonPends;
ULONG DbgRegularRcv;
  #endif


//* FreeRcvReq - Free a rcv request structure.
//
//  Called to free a rcv request structure.
//
//  Input:  FreedReq    - Rcv request structure to be freed.
//
//  Returns: Nothing.
//
__inline
VOID
FreeRcvReq(TCPRcvReq * Request)
{
    CTEStructAssert(Request, trr);
    PplFree(TcpRequestPool, Request);
}

//* GetRcvReq - Get a recv. request structure.
//
//  Called to get a rcv. request structure.
//
//  Input:  Nothing.
//
//  Returns: Pointer to RcvReq structure, or NULL if none.
//
__inline
TCPRcvReq *
GetRcvReq(VOID)
{
    TCPRcvReq *Request;
    LOGICAL FromList;

    Request = PplAllocate(TcpRequestPool, &FromList);
    if (Request) {
#if DBG
        Request->trr_sig = trr_signature;
#endif
        Request->trr_status = TDI_SUCCESS;
    }

    return Request;
}

//* FindLastBuffer - Find the last buffer in a chain.
//
//  A utility routine to find the last buffer in an rb chain.
//
//  Input:  Buf         - Pointer to RB chain.
//
//  Returns: Pointer to last buf in chain.
//
IPRcvBuf *
FindLastBuffer(IPRcvBuf * Buf)
{
    ASSERT(Buf != NULL);

    while (Buf->ipr_next != NULL)
        Buf = Buf->ipr_next;

    return Buf;
}

//* FreePartialRB - Free part of an RB chain.
//
//  Called to adjust an free part of an RB chain. We walk down the chain,
//  trying to free buffers.
//
//  Input:  RB          - RB chain to be adjusted.
//          Size        - Size in bytes to be freed.
//
//  Returns: Pointer to adjusted RB chain.
//
IPRcvBuf *
FreePartialRB(IPRcvBuf * RB, uint Size)
{
    while (Size != 0) {
        IPRcvBuf *TempBuf;

        ASSERT(RB != NULL);

        if (Size >= RB->ipr_size) {
            Size -= RB->ipr_size;
            TempBuf = RB;
            RB = RB->ipr_next;
            if (TempBuf->ipr_owner == IPR_OWNER_TCP)
                FreeTcpIpr(TempBuf);
        } else {
            RB->ipr_size -= Size;
            RB->ipr_buffer += Size;
            break;
        }
    }

    ASSERT(RB != NULL);

    return RB;

}

//
//* FreeRBChain - Free an RB chain.
//
//  Called to free a chain of RBs. If we're the owner of each RB, we'll
//  free it. N.B. The lock on the TCB from which the RBChain is taken from
//  should be held while calling this routine (as there is arithmetic done on
//  the 'tcb_unusedbytes' field).
//
//  Input:  RBChain         - RBChain to be freed.
//
//  Returns: Nothing.
//
void
FreeRBChain(IPRcvBuf * RBChain)
{
    while (RBChain != NULL) {

        if (RBChain->ipr_owner == IPR_OWNER_TCP) {
            IPRcvBuf *Temp;

            Temp = RBChain->ipr_next;
            FreeTcpIpr(RBChain);
            RBChain = Temp;
        } else
            RBChain = RBChain->ipr_next;
    }
}


//* CopyRBChain - Copy a chain of IP rcv buffers.
//
//  Called to copy a chain of IP rcv buffers. We don't copy a buffer if it's
//  already owner by TCP. We assume that all non-TCP owned buffers start
//  before any TCP owner buffers, so we quit when we copy to a TCP owner buffer.
//
//  Input:  OrigBuf             - Buffer chain to copy from.
//          LastBuf             - Where to return pointer to last buffer in
//                                  chain.
//          Size                - Maximum size in bytes to copy.
//
//  Returns: Pointer to new buffer chain.
//
IPRcvBuf *
CopyRBChain(TCB *Tcb, IPRcvBuf * OrigBuf, IPRcvBuf ** LastBuf, uint Size)
{
    IPRcvBuf *FirstBuf, *EndBuf;
    uint BytesToCopy;

    ASSERT(OrigBuf != NULL);
    ASSERT(Size > 0);

    if (OrigBuf->ipr_owner != IPR_OWNER_TCP) {

        BytesToCopy = MIN(Size, OrigBuf->ipr_size);

        // Allocate the buffer from slist and hold a pointer the TCB.
        FirstBuf = AllocTcpIprFromSlist(Tcb, BytesToCopy, 'BPCT');

        if (FirstBuf != NULL) {

            EndBuf = FirstBuf;
            RtlCopyMemory(FirstBuf->ipr_buffer, OrigBuf->ipr_buffer,
                       BytesToCopy);
            Size -= BytesToCopy;
            OrigBuf = OrigBuf->ipr_next;
            while (OrigBuf != NULL && OrigBuf->ipr_owner != IPR_OWNER_TCP
                   && Size != 0) {
                IPRcvBuf *NewBuf;

                BytesToCopy = MIN(Size, OrigBuf->ipr_size);
                NewBuf = AllocTcpIprFromSlist(Tcb, BytesToCopy, 'BPCT');

                if (NewBuf != NULL) {
                    RtlCopyMemory(NewBuf->ipr_buffer, OrigBuf->ipr_buffer,
                               BytesToCopy);
                    EndBuf->ipr_next = NewBuf;
                    EndBuf = NewBuf;
                    Size -= BytesToCopy;
                    OrigBuf = OrigBuf->ipr_next;
                } else {
                    FreeRBChain(FirstBuf);
                    return NULL;
                }
            }
            EndBuf->ipr_next = OrigBuf;
        } else
            return NULL;
    } else {
        FirstBuf = OrigBuf;
        EndBuf = OrigBuf;
        if (Size < OrigBuf->ipr_size)
            OrigBuf->ipr_size = Size;
        Size -= OrigBuf->ipr_size;
    }

    // Now walk down the chain, until we  run out of
    // Size. At this point, Size is the bytes left to 'copy' (it may be 0),
    // and the sizes in buffers FirstBuf...EndBuf are correct.
    while (Size != 0) {

        EndBuf = EndBuf->ipr_next;
        ASSERT(EndBuf != NULL);

        if (Size < EndBuf->ipr_size)
            EndBuf->ipr_size = Size;

        Size -= EndBuf->ipr_size;
    }

    // If there's anything left in the chain, free it now.
    if (EndBuf->ipr_next != NULL) {
        FreeRBChain(EndBuf->ipr_next);
        EndBuf->ipr_next = NULL;
    }
    *LastBuf = EndBuf;

    return FirstBuf;
}

//* PendData - Pend incoming data to a client.
//
//  Called when we need to buffer data for a client because there's no receive
//  down and we can't indicate.
//
//  The TCB lock is held throughout this procedure. If this is to be changed,
//  make sure consistency of tcb_pendingcnt is preserved. This routine is
//  always called at DPC level.
//
//  Input:  RcvTCB              - TCB on which to receive the data.
//          RcvFlags            - TCP flags for the incoming packet.
//          InBuffer            - Input buffer of packet.
//          Size                - Size in bytes of data in InBuffer.
//
//  Returns: Number of bytes of data taken.
//
uint
PendData(TCB * RcvTCB, uint RcvFlags, IPRcvBuf * InBuffer, uint Size)
{
    IPRcvBuf *NewBuf, *LastBuf;

    CTEStructAssert(RcvTCB, tcb);
    ASSERT(Size > 0);
    ASSERT(InBuffer != NULL);

    ASSERT(RcvTCB->tcb_refcnt != 0);
    ASSERT(RcvTCB->tcb_fastchk & TCP_FLAG_IN_RCV);
    //ASSERT(RcvTCB->tcb_currcv == NULL);
    ASSERT(RcvTCB->tcb_rcvhndlr == PendData);

    CheckRBList(RcvTCB->tcb_pendhead, RcvTCB->tcb_pendingcnt);

    NewBuf = CopyRBChain(RcvTCB, InBuffer, &LastBuf, Size);
    if (NewBuf != NULL) {
        // We have a duplicate chain. Put it on the end of the
        // pending q.
        if (RcvTCB->tcb_pendhead == NULL) {
            RcvTCB->tcb_pendhead = NewBuf;
            RcvTCB->tcb_pendtail = LastBuf;
        } else {
            RcvTCB->tcb_pendtail->ipr_next = NewBuf;
            RcvTCB->tcb_pendtail = LastBuf;
        }
        RcvTCB->tcb_pendingcnt += Size;
    } else {
        FreeRBChain(InBuffer);
        Size = 0;
    }

    CheckRBList(RcvTCB->tcb_pendhead, RcvTCB->tcb_pendingcnt);

    return Size;
}

//* BufferData - Put incoming data into client's buffer.
//
//  Called when we believe we have a buffer into which we can put data. We put
//  it in there, and if we've filled the buffer or the incoming data has the
//  push flag set we'll mark the TCB to return the buffer. Otherwise we'll
//  get out and return the data later.
//
//  In NT, this routine is called with the TCB lock held, and holds it for
//  the duration of the call. This is important to ensure consistency of
//  the tcb_pendingcnt field. If we need to change this to free the lock
//  partway through, make sure to take this into account. In particular,
//  TdiReceive zeros pendingcnt before calling this routine, and this routine
//  may update it. If the lock is freed in here there would be a window where
//  we really do have pending data, but it's not on the list or reflected in
//  pendingcnt. This could mess up our windowing computations, and we'd have
//  to be careful not to end up with more data pending than our window allows.
//
//  Input:  RcvTCB              - TCB on which to receive the data.
//          RcvFlags            - TCP rcv flags for the incoming packet.
//          InBuffer            - Input buffer of packet.
//          Size                - Size in bytes of data in InBuffer.
//
//  Returns: Number of bytes of data taken.
//
uint
BufferData(TCB * RcvTCB, uint RcvFlags, IPRcvBuf * InBuffer, uint Size)
{
    uchar *DestBase;             // Destination pointer.
    uint DestOffset;             // Destination offset.
    uchar *SrcPtr;               // Src pointer.
    uint SrcSize, DestSize = 0;  // Sizes of current source and
    // destination buffers.
    uint Copied;                 // Total bytes to copy.
    uint BytesToCopy;            // Bytes of data to copy this time.
    TCPRcvReq *DestReq;          // Current receive request.
    IPRcvBuf *SrcBuf;            // Current source buffer.
    PNDIS_BUFFER DestBuf;        // Current receive buffer.
    uint RcvCmpltd;
    uint Flags;

    CTEStructAssert(RcvTCB, tcb);
    ASSERT(Size > 0);
    ASSERT(InBuffer != NULL);

    ASSERT(RcvTCB->tcb_refcnt != 0);
    ASSERT(RcvTCB->tcb_rcvhndlr == BufferData);

    Copied = 0;
    RcvCmpltd = 0;

    DestReq = RcvTCB->tcb_currcv;

    ASSERT(DestReq != NULL);
    CTEStructAssert(DestReq, trr);

    DestBuf = DestReq->trr_buffer;

    DestSize = MIN(NdisBufferLength(DestBuf) - DestReq->trr_offset,
                   DestReq->trr_size - DestReq->trr_amt);
    DestBase = (uchar *)TcpipBufferVirtualAddress(DestBuf, NormalPagePriority);
    DestOffset = DestReq->trr_offset;

    SrcBuf = InBuffer;
    SrcSize = SrcBuf->ipr_size;
    SrcPtr = SrcBuf->ipr_buffer;

    Flags = (RcvFlags & TCP_FLAG_PUSH) ? TRR_PUSHED : 0;
    RcvCmpltd = Flags;
    DestReq->trr_flags |= Flags;

    do {

        BytesToCopy = MIN(Size - Copied, MIN(SrcSize, DestSize));

        if (DestBase != NULL) {
            RtlCopyMemory(DestBase + DestOffset, SrcPtr, BytesToCopy);
        } else {
            TdiCopyBufferToMdlWithReservedMappingAtDpcLevel(SrcPtr, DestBuf,
                                                            DestOffset,
                                                            BytesToCopy);
        }
        Copied += BytesToCopy;
        DestReq->trr_amt += BytesToCopy;

        // Update our source pointers.
        if ((SrcSize -= BytesToCopy) == 0) {
            IPRcvBuf *TempBuf;

            // We've copied everything in this buffer.
            TempBuf = SrcBuf;
            SrcBuf = SrcBuf->ipr_next;
            if (Size != Copied) {
                ASSERT(SrcBuf != NULL);
                SrcSize = SrcBuf->ipr_size;
                SrcPtr = SrcBuf->ipr_buffer;
            }
            if (TempBuf->ipr_owner == IPR_OWNER_TCP)
                FreeTcpIpr(TempBuf);
        } else
            SrcPtr += BytesToCopy;

        // Now check the destination pointer, and update it if we need to.
        if ((DestSize -= BytesToCopy) == 0) {
            uint DestAvail;

            // Exhausted this buffer. See if there's another one.
            DestAvail = DestReq->trr_size - DestReq->trr_amt;
            DestBuf = NDIS_BUFFER_LINKAGE(DestBuf);

            if (DestBuf != NULL && (DestAvail != 0)) {
                // Have another buffer in the chain. Update things.
                DestSize = MIN(NdisBufferLength(DestBuf), DestAvail);
                DestBase =
                    (uchar *)TcpipBufferVirtualAddress(DestBuf,
                                                       NormalPagePriority);
                DestOffset = 0;
            } else {
                // No more buffers in the chain. See if we have another buffer
                // on the list.
                DestReq->trr_flags |= TRR_PUSHED;

                // If we've been told there's to be no back traffic, get an ACK
                // going right away.
                if (DestReq->trr_flags & TDI_RECEIVE_NO_RESPONSE_EXP)
                    DelayAction(RcvTCB, NEED_ACK);

                RcvCmpltd = TRUE;
                DestReq = DestReq->trr_next;
                if (DestReq != NULL) {
                    DestBuf = DestReq->trr_buffer;
                    DestSize = MIN(NdisBufferLength(DestBuf), DestReq->trr_size);
                    DestBase =
                        (uchar *)TcpipBufferVirtualAddress(DestBuf,
                                                           NormalPagePriority);
                    DestOffset = 0;

                    // If we have more to put into here, set the flags.
                    if (Copied != Size)
                        DestReq->trr_flags |= Flags;

                } else {
                    // All out of buffer space. Reset the data handler pointer.
                    break;
                }
            }
        } else {
            // Current buffer not empty yet.
            DestOffset += BytesToCopy;
        }

        // If we've copied all that we need to, we're done.
    } while (Copied != Size);

    // We've finished copying, and have a few more things to do. We need to
    // update the current rcv. pointer and possibly the offset in the
    // recv. request. If we need to complete any receives we have to schedule
    // that. If there's any data we couldn't copy we'll need to dispose of
    // it.
    RcvTCB->tcb_currcv = DestReq;
    if (DestReq != NULL) {
        DestReq->trr_buffer = DestBuf;
        DestReq->trr_offset = DestOffset;
        RcvTCB->tcb_rcvhndlr = BufferData;
    } else
        RcvTCB->tcb_rcvhndlr = PendData;

    RcvTCB->tcb_indicated -= MIN(Copied, RcvTCB->tcb_indicated);

    if (Size != Copied) {
        IPRcvBuf *NewBuf, *LastBuf;

        ASSERT(DestReq == NULL);

        RcvTCB->tcb_moreflag =1;
        
        // We have data to dispose of. Update the first buffer of the chain
        // with the current src pointer and size, and copy it.
        ASSERT(SrcSize <= SrcBuf->ipr_size);
        ASSERT(
                  ((uint) (SrcPtr - SrcBuf->ipr_buffer)) ==
                  (SrcBuf->ipr_size - SrcSize)
                  );

        SrcBuf->ipr_buffer = SrcPtr;
        SrcBuf->ipr_size = SrcSize;

        NewBuf = CopyRBChain(RcvTCB, SrcBuf, &LastBuf, Size - Copied);
        if (NewBuf != NULL) {
            // We managed to copy the buffer. Push it on the pending queue.
            if (RcvTCB->tcb_pendhead == NULL) {
                RcvTCB->tcb_pendhead = NewBuf;
                RcvTCB->tcb_pendtail = LastBuf;
            } else {
                LastBuf->ipr_next = RcvTCB->tcb_pendhead;
                RcvTCB->tcb_pendhead = NewBuf;
            }
            RcvTCB->tcb_pendingcnt += Size - Copied;
            Copied = Size;

            CheckRBList(RcvTCB->tcb_pendhead, RcvTCB->tcb_pendingcnt);

        } else
            FreeRBChain(SrcBuf);
    } else {
        // We copied Size bytes, but the chain could be longer than that. Free
        // it if we need to.
        if (SrcBuf != NULL)
            FreeRBChain(SrcBuf);
    }

    if (RcvCmpltd != 0) {
        DelayAction(RcvTCB, NEED_RCV_CMPLT);
    } else {
        //instrumentation to catch conreq null in tcb.c
        // ASSERT(DestReq);
        // ASSERT(DestReq->trr_amt);
        // RcvTCB->tcb_lastreq = DestReq;
        START_TCB_TIMER_R(RcvTCB, PUSH_TIMER, PUSH_TO);
    }

    return Copied;

}

//* IndicateData - Indicate incoming data to a client.
//
//  Called when we need to indicate data to an upper layer client. We'll pass
//  up a pointer to whatever we have available, and the client may take some
//  or all of it.
//
//  Input:  RcvTCB              - TCB on which to receive the data.
//          RcvFlags            - TCP rcv flags for the incoming packet.
//          InBuffer            - Input buffer of packet.
//          Size                - Size in bytes of data in InBuffer.
//
//  Returns: Number of bytes of data taken.
//
uint
IndicateData(TCB * RcvTCB, uint RcvFlags, IPRcvBuf * InBuffer, uint Size)
{
    TDI_STATUS Status;
    PRcvEvent Event;
    PVOID EventContext, ConnContext;
    uint BytesTaken = 0;
#if MILLEN
    EventRcvBuffer ERB;
#else // MILLEN
    EventRcvBuffer *ERB = NULL;
    PTDI_REQUEST_KERNEL_RECEIVE RequestInformation;
    PIO_STACK_LOCATION IrpSp;
#endif // !MILLEN
    TCPRcvReq *RcvReq;
    IPRcvBuf *NewBuf;
    ulong IndFlags;
#if TRACE_EVENT
    PTDI_DATA_REQUEST_NOTIFY_ROUTINE CPCallBack;
    WMIData WMIInfo;
#endif

    IPRcvBuf *LastBuf;

    DEBUGMSG(DBG_TRACE && DBG_TDI, (DTEXT("+IndicateData\n")));

    CTEStructAssert(RcvTCB, tcb);
    ASSERT(Size > 0);
    ASSERT(InBuffer != NULL);

    ASSERT(RcvTCB->tcb_refcnt != 0);
    ASSERT(RcvTCB->tcb_fastchk & TCP_FLAG_IN_RCV);
    ASSERT(RcvTCB->tcb_rcvind != NULL);
    ASSERT(RcvTCB->tcb_rcvhead == NULL);
    ASSERT(RcvTCB->tcb_rcvhndlr == IndicateData);

    Event = RcvTCB->tcb_rcvind;
    EventContext = RcvTCB->tcb_ricontext;
    ConnContext = RcvTCB->tcb_conncontext;

    RcvTCB->tcb_indicated = Size;
    RcvTCB->tcb_flags |= IN_RCV_IND;

    IF_TCPDBG(TCP_DEBUG_RECEIVE) {
        TCPTRACE((
                  "Indicating %lu bytes, %lu available\n",
                  InBuffer->ipr_size, Size
                 ));
    }

#if TCP_FLAG_PUSH >= TDI_RECEIVE_ENTIRE_MESSAGE
    IndFlags = TDI_RECEIVE_COPY_LOOKAHEAD | TDI_RECEIVE_NORMAL |
        TDI_RECEIVE_AT_DISPATCH_LEVEL |
        ((RcvFlags & TCP_FLAG_PUSH) >>
         ((TCP_FLAG_PUSH / TDI_RECEIVE_ENTIRE_MESSAGE) - 1));
#else
    IndFlags = TDI_RECEIVE_COPY_LOOKAHEAD | TDI_RECEIVE_NORMAL |
        TDI_RECEIVE_AT_DISPATCH_LEVEL |
        ((RcvFlags & TCP_FLAG_PUSH) <<
         ((TDI_RECEIVE_ENTIRE_MESSAGE / TCP_FLAG_PUSH) - 1));
#endif

#if DBG
    DbgRegularRcv++;
#endif

    if (InBuffer->ipr_pMdl && RcvTCB->tcb_chainedrcvind) {

        PChainedRcvEvent ChainedEvent = RcvTCB->tcb_chainedrcvind;
        if ((RcvTCB->tcb_flags & DISC_NOTIFIED) ||
            (RcvTCB->tcb_pending & RST_PENDING)) {
            CTEFreeLockFromDPC(&RcvTCB->tcb_lock);
            Status = TDI_NOT_ACCEPTED;
        } else {
            CTEFreeLockFromDPC(&RcvTCB->tcb_lock);

            // The size passed to chained-receive should be the size that fits
            // within the receive window. We can do chained-receives only with 
            // a newly received segment, in which case, Size indicates the
            // amount the client can take.
            Status = (*ChainedEvent)(RcvTCB->tcb_chainedrcvcontext, ConnContext,
                                     IndFlags, Size,
                                     InBuffer->ipr_RcvOffset,
                                     InBuffer->ipr_pMdl,
                                     InBuffer->ipr_RcvContext);
        }


#if TRACE_EVENT
        CPCallBack = TCPCPHandlerRoutine;
        if ((CPCallBack != NULL) && (Size > 0)) {
            ulong GroupType;

            WMIInfo.wmi_destaddr = RcvTCB->tcb_daddr;
            WMIInfo.wmi_destport = RcvTCB->tcb_dport;
            WMIInfo.wmi_srcaddr  = RcvTCB->tcb_saddr;
            WMIInfo.wmi_srcport  = RcvTCB->tcb_sport;
            WMIInfo.wmi_size     = Size;
            WMIInfo.wmi_context  = RcvTCB->tcb_cpcontext;

            GroupType = EVENT_TRACE_GROUP_TCPIP + EVENT_TRACE_TYPE_RECEIVE;
            (*CPCallBack) (GroupType, (PVOID) &WMIInfo, sizeof(WMIInfo), NULL);
        }
#endif

        if (Status == STATUS_PENDING) {
            *InBuffer->ipr_pClientCnt = 1;    //indicate to the ndis that
#if DBG
            DbgChainedRcvPends++;
#endif
        } else if (Status == TDI_SUCCESS) {
            *InBuffer->ipr_pClientCnt = 0;
#if DBG
            DbgChainedRcvNonPends++;
#endif
        }

        CTEGetLockAtDPC(&RcvTCB->tcb_lock);
        RcvTCB->tcb_indicated = 0;
        RcvTCB->tcb_flags &= ~IN_RCV_IND;

        if (Status == TDI_NOT_ACCEPTED) {
            BytesTaken = 0;

            if ((RcvTCB->tcb_rcvhead != NULL) && (RcvTCB->tcb_currcv != NULL)) {
                RcvTCB->tcb_rcvhndlr = BufferData;

                //ASSERT(RcvTCB->tcb_rcvhndlr == BufferData);
                BytesTaken += BufferData(RcvTCB, RcvFlags, InBuffer,
                                         Size - BytesTaken);

            } else {
                // Need to copy the chain and pend the data.
                RcvTCB->tcb_rcvhndlr = PendData;
                NewBuf = CopyRBChain(RcvTCB, InBuffer, &LastBuf, Size - BytesTaken);
                if (NewBuf != NULL) {
                    // We have a duplicate chain. Push it on the front of the
                    // pending q.
                    if (RcvTCB->tcb_pendhead == NULL) {
                        RcvTCB->tcb_pendhead = NewBuf;
                        RcvTCB->tcb_pendtail = LastBuf;
                    } else {
                        LastBuf->ipr_next = RcvTCB->tcb_pendhead;
                        RcvTCB->tcb_pendhead = NewBuf;
                    }
                    RcvTCB->tcb_pendingcnt += Size - BytesTaken;
                    BytesTaken = Size;

                    RcvTCB->tcb_moreflag = 3;

                } else {

                    FreeRBChain(InBuffer);
                }
            }
            return BytesTaken;
        }
        return Size;

    }
    if (!Event) {

        // This is to safeguard against a timing window between the
        // time NEED_RST is set and the tcb gets closed.

        RcvTCB->tcb_flags &= ~IN_RCV_IND;
        FreeRBChain(InBuffer);
        return 0;
    }

    RcvReq = GetRcvReq();
    if (RcvReq != NULL) {
        // The indicate handler is saved in the TCB. Just call up into it.
        if ((RcvTCB->tcb_flags & DISC_NOTIFIED) ||
            (RcvTCB->tcb_pending & RST_PENDING)) {
            CTEFreeLockFromDPC(&RcvTCB->tcb_lock);
            Status = TDI_NOT_ACCEPTED;
        } else {
            CTEFreeLockFromDPC(&RcvTCB->tcb_lock);

            // There are two sizes passed to the client here. The first one is
            // the number of bytes indicated in the flat buffer, and the second 
            // is the number of bytes available.
            Status = (*Event) (EventContext, ConnContext,
                               IndFlags, MIN(InBuffer->ipr_size, Size), Size,
                               (PULONG)&BytesTaken, InBuffer->ipr_buffer, &ERB);

            IF_TCPDBG(TCP_DEBUG_RECEIVE) {
                TCPTRACE(("%lu bytes taken, status %lx\n", BytesTaken, Status));
            }
        }

        // See what the client did. If the return status is MORE_PROCESSING,
        // we've been given a buffer. In that case put it on the front of the
        // buffer queue, and if all the data wasn't taken go ahead and copy
        // it into the new buffer chain.
        //
        // Note that the size and buffer chain we're concerned with here is
        // the one that we passed to the client. Since we're in a rcv. handler,
        // any data that has come in would have been put on the reassembly
        // queue.

#if TRACE_EVENT
        CPCallBack = TCPCPHandlerRoutine;
        if ((CPCallBack != NULL) &&
            (Status == TDI_MORE_PROCESSING || Status == TDI_SUCCESS) &&
            (BytesTaken > 0)) {
            ulong GroupType;

            WMIInfo.wmi_destaddr = RcvTCB->tcb_daddr;
            WMIInfo.wmi_destport = RcvTCB->tcb_dport;
            WMIInfo.wmi_srcaddr  = RcvTCB->tcb_saddr;
            WMIInfo.wmi_srcport  = RcvTCB->tcb_sport;
            WMIInfo.wmi_size     = BytesTaken;
            WMIInfo.wmi_context  = RcvTCB->tcb_cpcontext;

            GroupType = EVENT_TRACE_GROUP_TCPIP + EVENT_TRACE_TYPE_RECEIVE;
            (*CPCallBack) (GroupType, (PVOID)&WMIInfo, sizeof(WMIInfo), NULL);
        }
#endif

        if (Status == TDI_MORE_PROCESSING) {

            ASSERT(ERB != NULL);

            IrpSp = IoGetCurrentIrpStackLocation(ERB);

            Status = TCPPrepareIrpForCancel(
                                            (PTCP_CONTEXT) IrpSp->FileObject->FsContext,
                                            ERB,
                                            TCPCancelRequest
                                            );

            if (NT_SUCCESS(Status)) {
                PNDIS_BUFFER pNdisBuffer;

                Status = ConvertMdlToNdisBuffer(ERB, ERB->MdlAddress, &pNdisBuffer);
                ASSERT(Status == TDI_SUCCESS);

                RequestInformation = (PTDI_REQUEST_KERNEL_RECEIVE)
                    & (IrpSp->Parameters);

                RcvReq->trr_rtn = TCPDataRequestComplete;
                RcvReq->trr_context = ERB;
                RcvReq->trr_buffer = pNdisBuffer;
                RcvReq->trr_size = RequestInformation->ReceiveLength;
                RcvReq->trr_uflags = (ushort *)
                    & (RequestInformation->ReceiveFlags);
                RcvReq->trr_flags = (uint) (RequestInformation->ReceiveFlags);
                RcvReq->trr_offset = 0;
                RcvReq->trr_amt = 0;

                CTEGetLockAtDPC(&RcvTCB->tcb_lock);

                RcvTCB->tcb_flags &= ~IN_RCV_IND;

                ASSERT(RcvTCB->tcb_rcvhndlr == IndicateData);

                // Push him on the front of the rcv. queue.
                ASSERT((RcvTCB->tcb_currcv == NULL) ||
                          (RcvTCB->tcb_currcv->trr_amt == 0));

                if (RcvTCB->tcb_rcvhead == NULL) {
                    RcvTCB->tcb_rcvhead = RcvReq;
                    RcvTCB->tcb_rcvtail = RcvReq;
                    RcvReq->trr_next = NULL;
                } else {
                    RcvReq->trr_next = RcvTCB->tcb_rcvhead;
                    RcvTCB->tcb_rcvhead = RcvReq;
                }

                RcvTCB->tcb_currcv = RcvReq;
                RcvTCB->tcb_rcvhndlr = BufferData;

                ASSERT(BytesTaken <= Size);

                RcvTCB->tcb_indicated -= BytesTaken;

                if ((Size -= BytesTaken) != 0) {

                    RcvTCB->tcb_moreflag = 2;

                    // Not everything was taken. Adjust the buffer chain to point
                    // beyond what was taken.
                    InBuffer = FreePartialRB(InBuffer, BytesTaken);

                    ASSERT(InBuffer != NULL);

                    // We've adjusted the buffer chain. Call the BufferData
                    // handler.
                    BytesTaken += BufferData(RcvTCB, RcvFlags, InBuffer, Size);

                } else {
                    // All of the data was taken. Free the buffer chain.
                    FreeRBChain(InBuffer);
                }

                return BytesTaken;
            } else {

                //
                // The IRP was cancelled before it was handed back to us.
                // We'll pretend we never saw it. TCPPrepareIrpForCancel
                // already completed it. The client may have taken data,
                // so we will act as if success was returned.
                //
                ERB = NULL;
                Status = TDI_SUCCESS;
            }
        }
        CTEGetLockAtDPC(&RcvTCB->tcb_lock);

        RcvTCB->tcb_flags &= ~IN_RCV_IND;

        // Status is not more processing. If it's not SUCCESS, the client
        // didn't take any of the data. In either case we now need to
        // see if all of the data was taken. If it wasn't, we'll try and
        // push it onto the front of the pending queue.

        FreeRcvReq(RcvReq);        // This won't be needed.

        if (Status == TDI_NOT_ACCEPTED)
            BytesTaken = 0;

        ASSERT(BytesTaken <= Size);

        RcvTCB->tcb_indicated -= BytesTaken;

        ASSERT(RcvTCB->tcb_rcvhndlr == IndicateData);

        // Check to see if a rcv. buffer got posted during the indication.
        // If it did, reset the recv. handler now.
        if (RcvTCB->tcb_rcvhead != NULL) {
            RcvTCB->tcb_rcvhndlr = BufferData;
        } else if (RcvTCB->tcb_rcvind == NULL) {
            RcvTCB->tcb_rcvhndlr = PendData;
        }

        // See if all of the data was taken.
        if (BytesTaken == Size) {
            ASSERT(RcvTCB->tcb_indicated == 0);
            FreeRBChain(InBuffer);
            return BytesTaken;    // It was all taken.

        }
        // It wasn't all taken. Adjust for what was taken, and push
        // on the front of the pending queue. We also need to check to
        // see if a receive buffer got posted during the indication. This
        // would be weird, but not impossible.
        InBuffer = FreePartialRB(InBuffer, BytesTaken);
        if (RcvTCB->tcb_rcvhead == NULL) {

            RcvTCB->tcb_rcvhndlr = PendData;
            NewBuf = CopyRBChain(RcvTCB, InBuffer, &LastBuf, Size - BytesTaken);
            if (NewBuf != NULL) {
                // We have a duplicate chain. Push it on the front of the
                // pending q.
                if (RcvTCB->tcb_pendhead == NULL) {
                    RcvTCB->tcb_pendhead = NewBuf;
                    RcvTCB->tcb_pendtail = LastBuf;
                } else {
                    LastBuf->ipr_next = RcvTCB->tcb_pendhead;
                    RcvTCB->tcb_pendhead = NewBuf;
                }
                RcvTCB->tcb_pendingcnt += Size - BytesTaken;
                BytesTaken = Size;

                RcvTCB->tcb_moreflag = 3;

            } else {

                FreeRBChain(InBuffer);
            }

            return BytesTaken;
        } else {
            // Just great. There's now a rcv. buffer on the TCB. Call the
            // BufferData handler now.
            ASSERT(RcvTCB->tcb_rcvhndlr == BufferData);

            BytesTaken += BufferData(RcvTCB, RcvFlags, InBuffer,
                                     Size - BytesTaken);

            return BytesTaken;
        }

    } else {
        // Couldn't get a recv. request. We must be really low on resources,
        // so just bail out now.

        RcvTCB->tcb_flags &= ~IN_RCV_IND;
        FreeRBChain(InBuffer);
        return 0;
    }

}

//* IndicatePendingData - Indicate pending data to a client.
//
//  Called when we need to indicate pending data to an upper layer client,
//  usually because data arrived when we were in a state that it couldn't
//  be indicated.
//
//  Many of the comments in the BufferData header about the consistency of
//  tcb_pendingcnt apply here also.
//
//  Input:  RcvTCB              - TCB on which to indicate the data.
//          RcvReq              - Rcv. req. to use to indicate it.
//
//  Returns: Nothing.
//
void
IndicatePendingData(TCB *RcvTCB, TCPRcvReq *RcvReq, CTELockHandle TCBHandle)
{
    TDI_STATUS Status;
    PRcvEvent Event;
    PVOID EventContext, ConnContext;
#if !MILLEN
    EventRcvBuffer *ERB = NULL;
    PTDI_REQUEST_KERNEL_RECEIVE RequestInformation;
    PIO_STACK_LOCATION IrpSp;
#else // !MILLEN
    EventRcvBuffer ERB;
#endif // MILLEN
    IPRcvBuf *NewBuf;
    uint Size;
    uint BytesIndicated;
    uint BytesAvailable;
    uint BytesTaken = 0;
    uchar *DataBuffer;

    CTEStructAssert(RcvTCB, tcb);

    ASSERT(RcvTCB->tcb_refcnt != 0);
    ASSERT(RcvTCB->tcb_rcvind != NULL);
    ASSERT(RcvTCB->tcb_rcvhead == NULL);
    ASSERT(RcvTCB->tcb_pendingcnt != 0);
    ASSERT(RcvReq != NULL);

    for (;;) {
        ASSERT(RcvTCB->tcb_rcvhndlr == PendData);

        // The indicate handler is saved in the TCB. Just call up into it.
        Event = RcvTCB->tcb_rcvind;
        EventContext = RcvTCB->tcb_ricontext;
        ConnContext = RcvTCB->tcb_conncontext;
        BytesIndicated = RcvTCB->tcb_pendhead->ipr_size;
        BytesAvailable = RcvTCB->tcb_pendingcnt;
        DataBuffer = RcvTCB->tcb_pendhead->ipr_buffer;

        RcvTCB->tcb_indicated = RcvTCB->tcb_pendingcnt;
        RcvTCB->tcb_flags |= IN_RCV_IND;
        RcvTCB->tcb_moreflag = 0;

        if ((RcvTCB->tcb_flags & DISC_NOTIFIED) ||
            (RcvTCB->tcb_pending & RST_PENDING)) {
            CTEFreeLock(&RcvTCB->tcb_lock, TCBHandle);
            Status = TDI_NOT_ACCEPTED;
            BytesTaken = 0;
        } else {
            CTEFreeLock(&RcvTCB->tcb_lock, TCBHandle);

            IF_TCPDBG(TCPDebug & TCP_DEBUG_RECEIVE) {
                TCPTRACE(("Indicating pending %d bytes, %d available\n",
                          BytesIndicated, BytesAvailable));
            }

            Status = (*Event) (EventContext, ConnContext,
                               TDI_RECEIVE_COPY_LOOKAHEAD | TDI_RECEIVE_NORMAL |
                               TDI_RECEIVE_ENTIRE_MESSAGE,
                               BytesIndicated, BytesAvailable, (PULONG)&BytesTaken,
                               DataBuffer, &ERB);

            IF_TCPDBG(TCPDebug & TCP_DEBUG_RECEIVE) {
                TCPTRACE(("%d bytes taken\n", BytesTaken));
            }
        }

        // See what the client did. If the return status is MORE_PROCESSING,
        // we've been given a buffer. In that case put it on the front of the
        // buffer queue, and if all the data wasn't taken go ahead and copy
        // it into the new buffer chain.
        if (Status == TDI_MORE_PROCESSING) {

            IF_TCPDBG(TCP_DEBUG_RECEIVE) {
                TCPTRACE(("more processing on receive\n"));
            }

            ASSERT(ERB != NULL);

            IrpSp = IoGetCurrentIrpStackLocation(ERB);

            Status = TCPPrepareIrpForCancel(
                                            (PTCP_CONTEXT) IrpSp->FileObject->FsContext,
                                            ERB,
                                            TCPCancelRequest
                                            );

            if (NT_SUCCESS(Status)) {
                PNDIS_BUFFER pNdisBuffer;

                Status = ConvertMdlToNdisBuffer(ERB, ERB->MdlAddress, &pNdisBuffer);
                ASSERT(Status == TDI_SUCCESS);

                RequestInformation = (PTDI_REQUEST_KERNEL_RECEIVE)
                    & (IrpSp->Parameters);

                RcvReq->trr_rtn = TCPDataRequestComplete;
                RcvReq->trr_context = ERB;
                RcvReq->trr_buffer = pNdisBuffer;
                RcvReq->trr_size = RequestInformation->ReceiveLength;
                RcvReq->trr_uflags = (ushort *)
                    & (RequestInformation->ReceiveFlags);
                RcvReq->trr_flags = (uint) (RequestInformation->ReceiveFlags);
                RcvReq->trr_offset = 0;
                RcvReq->trr_amt = 0;

                CTEGetLock(&RcvTCB->tcb_lock, &TCBHandle);
                RcvTCB->tcb_flags &= ~IN_RCV_IND;

                // Push him on the front of the rcv. queue.
                ASSERT((RcvTCB->tcb_currcv == NULL) ||
                          (RcvTCB->tcb_currcv->trr_amt == 0));

                if (RcvTCB->tcb_rcvhead == NULL) {
                    RcvTCB->tcb_rcvhead = RcvReq;
                    RcvTCB->tcb_rcvtail = RcvReq;
                    RcvReq->trr_next = NULL;
                } else {
                    RcvReq->trr_next = RcvTCB->tcb_rcvhead;
                    RcvTCB->tcb_rcvhead = RcvReq;
                }

                RcvTCB->tcb_currcv = RcvReq;
                RcvTCB->tcb_rcvhndlr = BufferData;

                // Have to pick up the new size and pointers now, since things could
                // have changed during the upcall.
                Size = RcvTCB->tcb_pendingcnt;
                NewBuf = RcvTCB->tcb_pendhead;

                RcvTCB->tcb_pendingcnt = 0;
                RcvTCB->tcb_pendhead = NULL;

                ASSERT(BytesTaken <= Size);

                RcvTCB->tcb_indicated -= BytesTaken;
                if ((Size -= BytesTaken) != 0) {

                    RcvTCB->tcb_moreflag = 4;

                    // Not everything was taken. Adjust the buffer chain to point
                    // beyond what was taken.
                    NewBuf = FreePartialRB(NewBuf, BytesTaken);

                    ASSERT(NewBuf != NULL);

                    // We've adjusted the buffer chain. Call the BufferData
                    // handler.
                    (void)BufferData(RcvTCB, TCP_FLAG_PUSH, NewBuf, Size);
                    CTEFreeLock(&RcvTCB->tcb_lock, TCBHandle);

                } else {
                    // All of the data was taken. Free the buffer chain. Since
                    // we were passed a buffer chain which we put on the head of
                    // the list, leave the rcvhandler pointing at BufferData.
                    ASSERT(RcvTCB->tcb_rcvhndlr == BufferData);
                    ASSERT(RcvTCB->tcb_indicated == 0);
                    ASSERT(RcvTCB->tcb_rcvhead != NULL);

                    FreeRBChain(NewBuf);
                    CTEFreeLock(&RcvTCB->tcb_lock, TCBHandle);
                }

                return;
#if !MILLEN
            } else {
                //
                // The IRP was cancelled before it was handed back to us.
                // We'll pretend we never saw it. TCPPrepareIrpForCancel
                // already completed it. The client may have taken data,
                // so we will act as if success was returned.
                //
                ERB = NULL;
                Status = TDI_SUCCESS;
#endif // !MILLEN
            }

        }
        CTEGetLock(&RcvTCB->tcb_lock, &TCBHandle);

        RcvTCB->tcb_flags &= ~IN_RCV_IND;

        // Status is not more processing. If it's not SUCCESS, the client
        // didn't take any of the data. In either case we now need to
        // see if all of the data was taken. If it wasn't, we're done.

        if (Status == TDI_NOT_ACCEPTED)
            BytesTaken = 0;

        ASSERT(RcvTCB->tcb_rcvhndlr == PendData);

        RcvTCB->tcb_indicated -= BytesTaken;
        Size = RcvTCB->tcb_pendingcnt;
        NewBuf = RcvTCB->tcb_pendhead;

        ASSERT(BytesTaken <= Size);

        // See if all of the data was taken.
        if (BytesTaken == Size) {
            // It was all taken. Zap the pending data information.
            RcvTCB->tcb_pendingcnt = 0;
            RcvTCB->tcb_pendhead = NULL;

            ASSERT(RcvTCB->tcb_indicated == 0);
            if (RcvTCB->tcb_rcvhead == NULL) {
                if (RcvTCB->tcb_rcvind != NULL)
                    RcvTCB->tcb_rcvhndlr = IndicateData;
            } else
                RcvTCB->tcb_rcvhndlr = BufferData;

            FreeRBChain(NewBuf);
            CTEFreeLock(&RcvTCB->tcb_lock, TCBHandle);
            break;
        }
        // It wasn't all taken. Adjust for what was taken, We also need to check
        // to see if a receive buffer got posted during the indication. This
        // would be weird, but not impossible.
        NewBuf = FreePartialRB(NewBuf, BytesTaken);

        ASSERT(RcvTCB->tcb_rcvhndlr == PendData);

        RcvTCB->tcb_moreflag = 5;

        if (RcvTCB->tcb_rcvhead == NULL) {

            RcvTCB->tcb_pendhead = NewBuf;
            RcvTCB->tcb_pendingcnt -= BytesTaken;
            if (RcvTCB->tcb_indicated != 0 || RcvTCB->tcb_rcvind == NULL) {
                CTEFreeLock(&RcvTCB->tcb_lock, TCBHandle);
                break;
            }
            // From here, we'll loop around and indicate the new data that
            // presumably came in during the previous indication.
        } else {
            // Just great. There's now a rcv. buffer on the TCB. Call the
            // BufferData handler now.

            RcvTCB->tcb_rcvhndlr = BufferData;
            RcvTCB->tcb_pendingcnt = 0;
            RcvTCB->tcb_pendhead = NULL;
            BytesTaken += BufferData(RcvTCB, TCP_FLAG_PUSH, NewBuf,
                                     Size - BytesTaken);
            CTEFreeLock(&RcvTCB->tcb_lock, TCBHandle);
            break;
        }

    }                            // for (;;)

    FreeRcvReq(RcvReq);            // This isn't needed anymore.

}

//* DeliverUrgent - Deliver urgent data to a client.
//
//  Called to deliver urgent data to a client. We assume the input
//  urgent data is in a buffer we can keep. The buffer can be NULL, in
//  which case we'll just look on the urgent pending queue for data.
//
//  Input:  RcvTCB      - TCB to deliver on.
//          RcvBuf      - RcvBuffer for urgent data.
//          Size        - Number of bytes of urgent data to deliver.
//
//  Returns: Nothing.
//
void
DeliverUrgent(TCB * RcvTCB, IPRcvBuf * RcvBuf, uint Size,
              CTELockHandle * TCBHandle)
{
    CTELockHandle AOHandle, AOTblHandle;
    TCPRcvReq *RcvReq, *PrevReq;
    uint BytesTaken = 0;
    IPRcvBuf *LastBuf;
#if !MILLEN
    EventRcvBuffer *ERB = NULL;
#else // !MILLEN
    EventRcvBuffer ERB;
#endif // MILLEN
#if TRACE_EVENT
    PTDI_DATA_REQUEST_NOTIFY_ROUTINE CPCallBack;
    WMIData WMIInfo;
#endif
    PRcvEvent ExpRcv;
    PVOID ExpRcvContext;
    PVOID ConnContext;
    TDI_STATUS Status;

    CTEStructAssert(RcvTCB, tcb);
    ASSERT(RcvTCB->tcb_refcnt != 0);

    CheckRBList(RcvTCB->tcb_urgpending, RcvTCB->tcb_urgcnt);

    // See if we have new data, or are processing old data.
    if (RcvBuf != NULL) {
        // We have new data. If the pending queue is not NULL, or we're already
        // in this routine, just put the buffer on the end of the queue.
        if (RcvTCB->tcb_urgpending != NULL || (RcvTCB->tcb_flags & IN_DELIV_URG)) {
            IPRcvBuf *PrevRcvBuf;

            // Put him on the end of the queue.
            PrevRcvBuf = STRUCT_OF(IPRcvBuf, &RcvTCB->tcb_urgpending, ipr_next);
            while (PrevRcvBuf->ipr_next != NULL)
                PrevRcvBuf = PrevRcvBuf->ipr_next;

            PrevRcvBuf->ipr_next = RcvBuf;
            RcvTCB->tcb_urgcnt += Size;
            return;
        }
    } else {
        // The input buffer is NULL. See if we have existing data, or are in
        // this routine. If we have no existing data or are in this routine
        // just return.
        if (RcvTCB->tcb_urgpending == NULL ||
            (RcvTCB->tcb_flags & IN_DELIV_URG)) {
            return;
        } else {
            RcvBuf = RcvTCB->tcb_urgpending;
            Size = RcvTCB->tcb_urgcnt;
            RcvTCB->tcb_urgpending = NULL;
            RcvTCB->tcb_urgcnt = 0;
        }
    }

    ASSERT(RcvBuf != NULL);
    ASSERT(!(RcvTCB->tcb_flags & IN_DELIV_URG));

    // We know we have data to deliver, and we have a pointer and a size.
    // Go into a loop, trying to deliver the data. On each iteration, we'll
    // try to find a buffer for the data. If we find one, we'll copy and
    // complete it right away. Otherwise we'll try and indicate it. If we
    // can't indicate it, we'll put it on the pending queue and leave.
    RcvTCB->tcb_flags |= IN_DELIV_URG;
    RcvTCB->tcb_slowcount++;
    RcvTCB->tcb_fastchk |= TCP_FLAG_SLOW;
    CheckTCBRcv(RcvTCB);

    do {
        CheckRBList(RcvTCB->tcb_urgpending, RcvTCB->tcb_urgcnt);

        BytesTaken = 0;

        // First check the expedited queue.
        if ((RcvReq = RcvTCB->tcb_exprcv) != NULL)
            RcvTCB->tcb_exprcv = RcvReq->trr_next;
        else {
            // Nothing in the expedited rcv. queue. Walk down the ordinary
            // receive queue, looking for a buffer that we can steal.
            PrevReq = STRUCT_OF(TCPRcvReq, &RcvTCB->tcb_rcvhead, trr_next);
            RcvReq = PrevReq->trr_next;
            while (RcvReq != NULL) {
                CTEStructAssert(RcvReq, trr);
                if (RcvReq->trr_flags & TDI_RECEIVE_EXPEDITED) {
                    // This is a candidate.
                    if (RcvReq->trr_amt == 0) {

                        ASSERT(RcvTCB->tcb_rcvhndlr == BufferData);

                        // And he has nothing currently in him. Pull him
                        // out of the queue.
                        if (RcvTCB->tcb_rcvtail == RcvReq) {
                            if (RcvTCB->tcb_rcvhead == RcvReq)
                                RcvTCB->tcb_rcvtail = NULL;
                            else
                                RcvTCB->tcb_rcvtail = PrevReq;
                        }
                        PrevReq->trr_next = RcvReq->trr_next;
                        if (RcvTCB->tcb_currcv == RcvReq) {
                            RcvTCB->tcb_currcv = RcvReq->trr_next;
                            if (RcvTCB->tcb_currcv == NULL) {
                                // We've taken the last receive from the list.
                                // Reset the rcvhndlr.
                                if (RcvTCB->tcb_rcvind != NULL &&
                                    RcvTCB->tcb_indicated == 0)
                                    RcvTCB->tcb_rcvhndlr = IndicateData;
                                else
                                    RcvTCB->tcb_rcvhndlr = PendData;
                            }
                        }
                        break;
                    }
                }
                PrevReq = RcvReq;
                RcvReq = PrevReq->trr_next;
            }
        }

        // We've done our best to get a buffer. If we got one, copy into it
        // now, and complete the request.

        if (RcvReq != NULL) {
            // Got a buffer.
            CTEFreeLock(&RcvTCB->tcb_lock, *TCBHandle);
            BytesTaken = CopyRcvToNdis(RcvBuf, RcvReq->trr_buffer, Size, 0, 0);
#if TRACE_EVENT
            CPCallBack = TCPCPHandlerRoutine;
            if (CPCallBack != NULL) {
                ulong GroupType;

                WMIInfo.wmi_destaddr = RcvTCB->tcb_daddr;
                WMIInfo.wmi_destport = RcvTCB->tcb_dport;
                WMIInfo.wmi_srcaddr  = RcvTCB->tcb_saddr;
                WMIInfo.wmi_srcport  = RcvTCB->tcb_sport;
                WMIInfo.wmi_size     = BytesTaken;
                WMIInfo.wmi_context  = RcvTCB->tcb_cpcontext;

                GroupType = EVENT_TRACE_GROUP_TCPIP + EVENT_TRACE_TYPE_RECEIVE;
                (*CPCallBack) (GroupType, (PVOID) &WMIInfo, sizeof(WMIInfo), NULL);
            }
#endif
            (*RcvReq->trr_rtn) (RcvReq->trr_context, TDI_SUCCESS, BytesTaken);
            FreeRcvReq(RcvReq);
            CTEGetLock(&RcvTCB->tcb_lock, TCBHandle);
            RcvTCB->tcb_urgind -= MIN(RcvTCB->tcb_urgind, BytesTaken);

        } else {
            // No posted buffer. If we can indicate, do so.
            if (RcvTCB->tcb_urgind == 0) {
                TCPConn *Conn;

                // See if he has an expedited rcv handler.
                ConnContext = RcvTCB->tcb_conncontext;
                CTEFreeLock(&RcvTCB->tcb_lock, *TCBHandle);
                CTEGetLock(&AddrObjTableLock.Lock, &AOTblHandle);

                CTEGetLockAtDPC(&((ConnTable[CONN_BLOCKID(RcvTCB->tcb_connid)])->cb_lock));
#if DBG
                ConnTable[CONN_BLOCKID(RcvTCB->tcb_connid)]->line = (uint) __LINE__;
                ConnTable[CONN_BLOCKID(RcvTCB->tcb_connid)]->module = (uchar *) __FILE__;
#endif
                //CTEGetLock(&ConnTableLock, &ConnHandle);
                CTEGetLock(&RcvTCB->tcb_lock, TCBHandle);
                if ((Conn = RcvTCB->tcb_conn) != NULL) {
                    CTEStructAssert(Conn, tc);
                    ASSERT(Conn->tc_tcb == RcvTCB);
                    if ((RcvTCB->tcb_flags & DISC_NOTIFIED) ||
                        (RcvTCB->tcb_pending & RST_PENDING)) {
                        Status = TDI_NOT_ACCEPTED;
                    } else {
                        Status = TDI_SUCCESS;
                    }
                    CTEFreeLock(&RcvTCB->tcb_lock, *TCBHandle);
                    if (Conn->tc_ao != NULL) {
                        AddrObj *AO;

                        AO = Conn->tc_ao;
                        CTEGetLock(&AO->ao_lock, &AOHandle);
                        if (AO_VALID(AO) && (ExpRcv = AO->ao_exprcv) != NULL) {
                            ExpRcvContext = AO->ao_exprcvcontext;
                            CTEFreeLock(&AO->ao_lock, AOHandle);

                            // We're going to indicate.
                            RcvTCB->tcb_urgind = Size;
                            ASSERT(Conn->tc_ConnBlock ==
                                   ConnTable[CONN_BLOCKID(RcvTCB->tcb_connid)]);
                            CTEFreeLockFromDPC(&(Conn->tc_ConnBlock->cb_lock));
                            CTEFreeLock(&AddrObjTableLock.Lock, AOTblHandle);

                            if (Status != TDI_NOT_ACCEPTED) {
                                Status = (*ExpRcv) (ExpRcvContext, ConnContext,
                                                    TDI_RECEIVE_COPY_LOOKAHEAD |
                                                    TDI_RECEIVE_ENTIRE_MESSAGE |
                                                    TDI_RECEIVE_EXPEDITED,
                                                    MIN(RcvBuf->ipr_size, Size),
                                                    Size, (PULONG)&BytesTaken,
                                                    RcvBuf->ipr_buffer, &ERB);
                            }

                            CTEGetLock(&RcvTCB->tcb_lock, TCBHandle);

                            // See what he did with it.
                            if (Status == TDI_MORE_PROCESSING) {
                                uint CopySize;

                                // He gave us a buffer.
                                if (BytesTaken == Size) {
                                    // He gave us a buffer, but took all of
                                    // it. We'll just return it to him.
                                    CopySize = 0;
                                } else {

                                    // We have some data to copy in.
                                    RcvBuf = FreePartialRB(RcvBuf, BytesTaken);

#if !MILLEN
                                    CopySize = CopyRcvToMdl(RcvBuf,
                                                             ERB->MdlAddress,
                                                             TCPGetMdlChainByteCount(ERB->MdlAddress),
                                                             0, 0);
#else //!MILLEN
                                    CopySize = CopyRcvToNdis(RcvBuf,
                                                             ERB.erb_buffer,
                                                             ERB.erb_size,
                                                             0, 0);
#endif // MILLEN

                                }
                                BytesTaken += CopySize;
                                RcvTCB->tcb_urgind -= MIN(RcvTCB->tcb_urgind,
                                                          BytesTaken);
                                CTEFreeLock(&RcvTCB->tcb_lock, *TCBHandle);

#if !MILLEN
                                ERB->IoStatus.Status = TDI_SUCCESS;
                                ERB->IoStatus.Information = CopySize;
                                IoCompleteRequest(ERB, 2);
#else // !MILLEN
                                (*ERB.erb_rtn) (ERB.erb_context, TDI_SUCCESS,
                                                CopySize);
#endif // MILLEN

                                CTEGetLock(&RcvTCB->tcb_lock, TCBHandle);

                            } else {

                                // No buffer to deal with.
                                if (Status == TDI_NOT_ACCEPTED)
                                    BytesTaken = 0;

                                RcvTCB->tcb_urgind -= MIN(RcvTCB->tcb_urgind,
                                                          BytesTaken);

                            }
                            goto checksize;
                        } else    // No rcv. handler.

                            CTEFreeLock(&AO->ao_lock, AOHandle);
                    }
                    // Conn->tc_ao == NULL.
                    ASSERT(Conn->tc_ConnBlock == ConnTable[CONN_BLOCKID(RcvTCB->tcb_connid)]);
                    CTEFreeLockFromDPC(&(Conn->tc_ConnBlock->cb_lock));
                    //CTEFreeLock(&ConnTableLock, ConnHandle);
                    CTEFreeLock(&AddrObjTableLock.Lock, AOTblHandle);
                    CTEGetLock(&RcvTCB->tcb_lock, TCBHandle);
                } else {
                    // RcvTCB has invalid index.
                    //CTEFreeLock(&ConnTableLock, *TCBHandle);

                    CTEFreeLockFromDPC(&((ConnTable[CONN_BLOCKID(RcvTCB->tcb_connid)])->cb_lock));
                    CTEFreeLock(&AddrObjTableLock.Lock, AOTblHandle);
                    *TCBHandle = AOTblHandle;
                }

            }
            // For whatever reason we couldn't indicate the data. At this point
            // we hold the lock on the TCB. Push the buffer onto the pending
            // queue and return.
            CheckRBList(RcvTCB->tcb_urgpending, RcvTCB->tcb_urgcnt);

            LastBuf = FindLastBuffer(RcvBuf);
            LastBuf->ipr_next = RcvTCB->tcb_urgpending;
            RcvTCB->tcb_urgpending = RcvBuf;
            RcvTCB->tcb_urgcnt += Size;
            break;
        }

      checksize:
        // See how much we took. If we took it all, check the pending queue.
        // At this point, we should hold the lock on the TCB.
        if (Size == BytesTaken) {
            // Took it all.
            FreeRBChain(RcvBuf);
            RcvBuf = RcvTCB->tcb_urgpending;
            Size = RcvTCB->tcb_urgcnt;
        } else {
            // We didn't manage to take it all. Free what we did take,
            // and then merge with the pending queue.
            RcvBuf = FreePartialRB(RcvBuf, BytesTaken);
            Size = Size - BytesTaken + RcvTCB->tcb_urgcnt;
            if (RcvTCB->tcb_urgpending != NULL) {

                // Find the end of the current RcvBuf chain, so we can
                // merge.

                LastBuf = FindLastBuffer(RcvBuf);
                LastBuf->ipr_next = RcvTCB->tcb_urgpending;
            }
        }

        RcvTCB->tcb_urgpending = NULL;
        RcvTCB->tcb_urgcnt = 0;

    } while (RcvBuf != NULL);

    CheckRBList(RcvTCB->tcb_urgpending, RcvTCB->tcb_urgcnt);

    RcvTCB->tcb_flags &= ~IN_DELIV_URG;
    if (--(RcvTCB->tcb_slowcount) == 0) {
        RcvTCB->tcb_fastchk &= ~TCP_FLAG_SLOW;
        CheckTCBRcv(RcvTCB);
    }
}


//* PushRequestList - Pushes all or non-empty requests from the list.
//
//  Input:  RcvReq          - First request in the request list to be pushed.
//          PushAll         - Indicates whether all requests need to be pushed
//                            or not.
//
//  Returns: TRUE if any requests were pushed, FALSE otherwise.
//
__inline BOOLEAN
PushRequestList(TCPRcvReq *RcvReq, BOOLEAN PushAll)
{
    BOOLEAN Pushed = FALSE;
    while ((RcvReq != NULL) && (PushAll || (RcvReq->trr_amt != 0))) {
        Pushed = TRUE;
        CTEStructAssert(RcvReq, trr);
        RcvReq->trr_flags |= TRR_PUSHED;
        RcvReq = RcvReq->trr_next;
    }
    return Pushed;
}


//* PushData - Push all or some data back to the client.
//
//  Called when the push-timer fires (to push only non-empty requests) or when
//  a FIN is received (to push all requests).
//
//  Input:  PushTCB         - TCB to be pushed.
//          PushAll         - Indicates whether all requests need to be pushed
//                            or not.
//
//  Returns: Nothing.
//
void
PushData(TCB * PushTCB, BOOLEAN PushAll)
{
    CTEStructAssert(PushTCB, tcb);
    if (PushRequestList(PushTCB->tcb_rcvhead, PushAll) || 
        PushRequestList(PushTCB->tcb_exprcv, PushAll)) {
        DelayAction(PushTCB, NEED_RCV_CMPLT);
    }
}

//* SplitRcvBuf - Split an IPRcvBuf into three pieces.
//
//  This function takes an input IPRcvBuf and splits it into three pieces.
//  The first piece is the input buffer, which we just skip over. The second
//  and third pieces are actually copied, even if we already own them, so
//  that the may go to different places.
//
//  Input:  RcvBuf          - RcvBuf chain to be split.
//          Size            - Total size in bytes of rcvbuf chain.
//          Offset          - Offset to skip over.
//          SecondSize      - Size in bytes of second piece.
//          SecondBuf       - Where to return second buffer pointer.
//          ThirdBuf        - Where to return third buffer pointer.
//
//  Returns: Nothing. *SecondBuf and *ThirdBuf are set to NULL if we can't
//      get memory for them.
//
void
SplitRcvBuf(IPRcvBuf * RcvBuf, uint Size, uint Offset, uint SecondSize,
            IPRcvBuf ** SecondBuf, IPRcvBuf ** ThirdBuf)
{
    IPRcvBuf *TempBuf;
    uint ThirdSize;

    ASSERT(Offset < Size);
    ASSERT(((Offset + SecondSize) < Size) || (((Offset + SecondSize) == Size)
                                                 && ThirdBuf == NULL));

    ASSERT(RcvBuf != NULL);

    // RcvBuf points at the buffer to copy from, and Offset is the offset into
    // this buffer to copy from.
    if (SecondBuf != NULL) {
        // We need to allocate memory for a second buffer.
        TempBuf = AllocTcpIpr(SecondSize, 'BPCT');
        if (TempBuf != NULL) {
            CopyRcvToBuffer(TempBuf->ipr_buffer, RcvBuf, SecondSize, Offset);
            *SecondBuf = TempBuf;
        } else {
            *SecondBuf = NULL;
            if (ThirdBuf != NULL)
                *ThirdBuf = NULL;
            return;
        }
    }
    if (ThirdBuf != NULL) {
        // We need to allocate memory for a third buffer.
        ThirdSize = Size - (Offset + SecondSize);
        TempBuf = AllocTcpIpr(ThirdSize, 'BPCT');

        if (TempBuf != NULL) {
            CopyRcvToBuffer(TempBuf->ipr_buffer, RcvBuf, ThirdSize,
                            Offset + SecondSize);
            *ThirdBuf = TempBuf;
        } else
            *ThirdBuf = NULL;
    }
}

//* HandleUrgent - Handle urgent data.
//
//  Called when an incoming segment has urgent data in it. We make sure there
//  really is urgent data in the segment, and if there is we try to dispose
//  of it either by putting it into a posted buffer or calling an exp. rcv.
//  indication handler.
//
//  This routine is called at DPC level, and with the TCP locked.
//
//  Urgent data handling is a little complicated. Each TCB has the starting
//  and ending sequence numbers of the 'current' (last received) bit of urgent
//  data. It is possible that the start of the current urgent data might be
//  greater than tcb_rcvnext, if urgent data came in, we handled it, and then
//  couldn't take the preceding normal data. The urgent valid flag is cleared
//  when the next byte of data the user would read (rcvnext - pendingcnt) is
//  greater than the end of urgent data - we do this so that we can correctly
//  support SIOCATMARK. We always seperate urgent data out of the data stream.
//  If the urgent valid field is set when we get into this routing we have
//  to play a couple of games. If the incoming segment starts in front of the
//  current urgent data, we truncate it before the urgent data, and put any
//  data after the urgent data on the reassemble queue. These gyrations are
//  done to avoid delivering the same urgent data twice. If the urgent valid
//  field in the TCB is set and the segment starts after the current urgent
//  data the new urgent information will replace the current urgent information.
//
//  Input:  RcvTCB          - TCB to recv the data on.
//          RcvInfo         - RcvInfo structure for the incoming segment.
//          RcvBuf          - Pointer to IPRcvBuf train containing the
//                              incoming segment.
//          Size            - Pointer to size in bytes of data in the segment.
//
//  Returns: Nothing.
//
void
HandleUrgent(TCB * RcvTCB, TCPRcvInfo * RcvInfo, IPRcvBuf * RcvBuf, uint * Size)
{
    uint BytesInFront, BytesInBack;        // Bytes in front of and in
    // back of the urgent data.
    uint UrgSize;                // Size in bytes of urgent data.
    SeqNum UrgStart, UrgEnd;
    IPRcvBuf *EndBuf, *UrgBuf;
    TCPRcvInfo NewRcvInfo;
    CTELockHandle TCBHandle;

    CTEStructAssert(RcvTCB, tcb);
    ASSERT(RcvTCB->tcb_refcnt != 0);
    ASSERT(RcvInfo->tri_flags & TCP_FLAG_URG);
    ASSERT(SEQ_EQ(RcvInfo->tri_seq, RcvTCB->tcb_rcvnext));

    // First, validate the urgent pointer.
    if (RcvTCB->tcb_flags & BSD_URGENT) {
        // We're using BSD style urgent data. We assume that the urgent
        // data is one byte long, and that the urgent pointer points one
        // after the urgent data instead of at the last byte of urgent data.
        // See if the urgent data is in this segment.

        if (RcvInfo->tri_urgent == 0 || RcvInfo->tri_urgent > *Size) {
            // Not in this segment. Clear the urgent flag and return.
            RcvInfo->tri_flags &= ~TCP_FLAG_URG;
            return;
        }
        UrgSize = 1;
        BytesInFront = RcvInfo->tri_urgent - 1;

    } else {

        // This is not BSD style urgent. We assume that the urgent data
        // starts at the front of the segment and the last byte is pointed
        // to by the urgent data pointer.

        BytesInFront = 0;
        UrgSize = MIN(RcvInfo->tri_urgent + 1, *Size);

    }

    BytesInBack = *Size - BytesInFront - UrgSize;

    // UrgStart and UrgEnd are the first and last sequence numbers of the
    // urgent data in this segment.

    UrgStart = RcvInfo->tri_seq + BytesInFront;
    UrgEnd = UrgStart + UrgSize - 1;

    if (!(RcvTCB->tcb_flags & URG_INLINE)) {

        EndBuf = NULL;

        // Now see if this overlaps with any urgent data we've already seen.
        if (RcvTCB->tcb_flags & URG_VALID) {
            // We have some urgent data still around. See if we've advanced
            // rcvnext beyond the urgent data. If we have, this is new urgent
            // data, and we can go ahead and process it (although anyone doing
            // an SIOCATMARK socket command might get confused). If we haven't
            // consumed the data in front of the existing urgent data yet, we'll
            // truncate this seg. to that amount and push the rest onto the
            // reassembly queue. Note that rcvnext should never fall between
            // tcb_urgstart and tcb_urgend.

            ASSERT(SEQ_LT(RcvTCB->tcb_rcvnext, RcvTCB->tcb_urgstart) ||
                      SEQ_GT(RcvTCB->tcb_rcvnext, RcvTCB->tcb_urgend));

            if (SEQ_LT(RcvTCB->tcb_rcvnext, RcvTCB->tcb_urgstart)) {

                // There appears to be some overlap in the data stream. Split
                // the buffer up into pieces that come before the current urgent
                // data and after the current urgent data, putting the latter
                // on the reassembly queue.

                UrgSize = RcvTCB->tcb_urgend - RcvTCB->tcb_urgstart + 1;

                BytesInFront = MIN(RcvTCB->tcb_urgstart - RcvTCB->tcb_rcvnext,
                                   (int)*Size);

                if (SEQ_GT(RcvTCB->tcb_rcvnext + *Size, 
                           RcvTCB->tcb_urgend + 1)) {
                    // We have data after this piece of urgent data.
                    BytesInBack = RcvTCB->tcb_rcvnext + *Size -
                                  RcvTCB->tcb_urgend - 1;
                } else {
                    BytesInBack = 0;
                }

                SplitRcvBuf(RcvBuf, *Size, BytesInFront, UrgSize, NULL,
                            (BytesInBack ? &EndBuf : NULL));

                if (EndBuf != NULL) {
                    // The third part of the segment is guaranteed to not have
                    // any urgent data.
                    NewRcvInfo.tri_seq = RcvTCB->tcb_urgend + 1;
                    NewRcvInfo.tri_flags = (RcvInfo->tri_flags & ~TCP_FLAG_URG);
                    NewRcvInfo.tri_urgent = 0;
                    NewRcvInfo.tri_ack = RcvInfo->tri_ack;
                    NewRcvInfo.tri_window = RcvInfo->tri_window;
                    PutOnRAQ(RcvTCB, &NewRcvInfo, EndBuf, BytesInBack);
                    FreeRBChain(EndBuf);
                }

                *Size = BytesInFront;
                RcvInfo->tri_flags &= ~TCP_FLAG_URG;
                return;
            }
        }
        // We have urgent data we can process now. Split it into its component
        // parts, the first part, the urgent data, and the stuff after the
        // urgent data.
        SplitRcvBuf(RcvBuf, *Size, BytesInFront, UrgSize, &UrgBuf,
                    (BytesInBack ? &EndBuf : NULL));

        // If we managed to split out the end stuff, put it on the queue now.
        if (EndBuf != NULL) {
            NewRcvInfo.tri_seq = RcvInfo->tri_seq + BytesInFront + UrgSize;
            NewRcvInfo.tri_flags = RcvInfo->tri_flags & ~TCP_FLAG_URG;
            NewRcvInfo.tri_ack = RcvInfo->tri_ack;
            NewRcvInfo.tri_window = RcvInfo->tri_window;
            PutOnRAQ(RcvTCB, &NewRcvInfo, EndBuf, BytesInBack);
            FreeRBChain(EndBuf);
        }
        if (UrgBuf != NULL) {
            // We succesfully split the urgent data out.
            if (!(RcvTCB->tcb_flags & URG_VALID)) {
                RcvTCB->tcb_flags |= URG_VALID;
                RcvTCB->tcb_slowcount++;
                RcvTCB->tcb_fastchk |= TCP_FLAG_SLOW;
                CheckTCBRcv(RcvTCB);
            }
            RcvTCB->tcb_urgstart = UrgStart;
            RcvTCB->tcb_urgend = UrgEnd;
            TCBHandle = DISPATCH_LEVEL;
            DeliverUrgent(RcvTCB, UrgBuf, UrgSize, &TCBHandle);
        }
        *Size = BytesInFront;
    } else {
        // Urgent data is to be processed inline. We just need to remember
        // where it is and treat it as normal data. If there's already urgent
        // data, we remember the latest urgent data.

        RcvInfo->tri_flags &= ~TCP_FLAG_URG;

        if (RcvTCB->tcb_flags & URG_VALID) {
            // There is urgent data. See if this stuff comes after the existing
            // urgent data.

            if (SEQ_LTE(UrgEnd, RcvTCB->tcb_urgend)) {
                // The existing urgent data completely overlaps this stuff,
                // so ignore this.
                return;
            }
        } else {
            RcvTCB->tcb_flags |= URG_VALID;
            RcvTCB->tcb_slowcount++;
            RcvTCB->tcb_fastchk |= TCP_FLAG_SLOW;
            CheckTCBRcv(RcvTCB);
        }

        RcvTCB->tcb_urgstart = UrgStart;
        RcvTCB->tcb_urgend = UrgEnd;
    }

    return;
}

//* TdiReceive - Process a receive request.
//
//  This is the main TDI receive request handler. We validate the connection
//  and make sure that we have a TCB in the proper state, then we try to
//  allocate a receive request structure. If that succeeds, we'll look and
//  see what's happening on the TCB - if there's pending data, we'll put it
//  in the buffer. Otherwise we'll just queue the receive for later.
//
//  Input:  Request             - TDI_REQUEST structure for this request.
//          Flags               - Pointer to flags word.
//          RcvLength           - Pointer to length in bytes of receive buffer.
//          Buffer              - Pointer to buffer to take data.
//
//  Returns: TDI_STATUS of request.
//
TDI_STATUS
TdiReceive(PTDI_REQUEST Request, ushort * Flags, uint * RcvLength,
           PNDIS_BUFFER Buffer)
{
    TCPConn *Conn;
    TCB *RcvTCB;
    TCPRcvReq *RcvReq;
    CTELockHandle ConnTableHandle, TCBHandle;
    TDI_STATUS Error;
    ushort UFlags;

    Conn = GetConnFromConnID(PtrToUlong(Request->Handle.ConnectionContext), &ConnTableHandle);

    if (Conn != NULL) {
        CTEStructAssert(Conn, tc);

        RcvTCB = Conn->tc_tcb;
        if (RcvTCB != NULL) {
            CTEStructAssert(RcvTCB, tcb);
            CTEGetLock(&RcvTCB->tcb_lock, &TCBHandle);
            CTEFreeLock(&(Conn->tc_ConnBlock->cb_lock), TCBHandle);
            UFlags = *Flags;

            if ((DATA_RCV_STATE(RcvTCB->tcb_state) ||
                 (RcvTCB->tcb_pendingcnt != 0 && (UFlags & TDI_RECEIVE_NORMAL)) ||
                 (RcvTCB->tcb_urgcnt != 0 && (UFlags & TDI_RECEIVE_EXPEDITED)) ||
                 (RcvTCB->tcb_indicated && (RcvTCB->tcb_state == TCB_CLOSE_WAIT)))
                && !CLOSING(RcvTCB)) {
                // We have a TCB, and it's valid. Get a receive request now.

                CheckRBList(RcvTCB->tcb_pendhead, RcvTCB->tcb_pendingcnt);

                RcvReq = GetRcvReq();
                if (RcvReq != NULL) {

                    RcvReq->trr_rtn = Request->RequestNotifyObject;
                    RcvReq->trr_context = Request->RequestContext;
                    RcvReq->trr_buffer = Buffer;
                    RcvReq->trr_size = *RcvLength;
                    RcvReq->trr_uflags = Flags;
                    RcvReq->trr_offset = 0;
                    RcvReq->trr_amt = 0;
                    RcvReq->trr_flags = (uint) UFlags;
                    if ((UFlags & (TDI_RECEIVE_NORMAL | TDI_RECEIVE_EXPEDITED))
                        != TDI_RECEIVE_EXPEDITED) {
                        // This is not an expedited only receive. Put him
                        // on the normal receive queue.
                        RcvReq->trr_next = NULL;
                        if (RcvTCB->tcb_rcvhead == NULL) {
                            // The receive queue is empty. Put him on the front.
                            RcvTCB->tcb_rcvhead = RcvReq;
                            RcvTCB->tcb_rcvtail = RcvReq;
                        } else {
                            RcvTCB->tcb_rcvtail->trr_next = RcvReq;
                            RcvTCB->tcb_rcvtail = RcvReq;
                        }

                        //if this rcv is for zero length complete this
                        // and indicate pending data again, if any

                        if (RcvReq->trr_size == 0) {

                            REFERENCE_TCB(RcvTCB);
                            RcvReq->trr_flags |=  TRR_PUSHED;
                            CTEFreeLock(&RcvTCB->tcb_lock,ConnTableHandle);
                            CompleteRcvs(RcvTCB);
                            CTEGetLock(&RcvTCB->tcb_lock,&ConnTableHandle);
                            DerefTCB(RcvTCB, ConnTableHandle);

                            return TDI_PENDING;
                        }



                        // If this recv. can't hold urgent data or there isn't
                        // any pending urgent data continue processing.
                        if (!(UFlags & TDI_RECEIVE_EXPEDITED) ||
                            RcvTCB->tcb_urgcnt == 0) {
                            // If tcb_currcv is NULL, there is no currently
                            // active receive. In this case, check to see if
                            // there is pending data and that we are not
                            // currently in a receive indication handler. If
                            // both of these are true then deal with the
                            // pending data.
                            if (RcvTCB->tcb_currcv == NULL) {
                                RcvTCB->tcb_currcv = RcvReq;
                                // No currently active receive.
                                if (!(RcvTCB->tcb_flags & IN_RCV_IND)) {
                                    // Not in a rcv. indication.
                                    RcvTCB->tcb_rcvhndlr = BufferData;
                                    if (RcvTCB->tcb_pendhead == NULL) {
                                        CTEFreeLock(&RcvTCB->tcb_lock,
                                                    ConnTableHandle);
                                        return TDI_PENDING;
                                    } else {
                                        IPRcvBuf *PendBuffer;
                                        uint PendSize;
                                        uint OldRcvWin;

                                        // We have pending data to deal with.
                                        PendBuffer = RcvTCB->tcb_pendhead;
                                        PendSize = RcvTCB->tcb_pendingcnt;
                                        RcvTCB->tcb_pendhead = NULL;
                                        RcvTCB->tcb_pendingcnt = 0;
                                        REFERENCE_TCB(RcvTCB);

                                        // We assume that BufferData holds
                                        // the lock (does not yield) during
                                        // this call. If this changes for some
                                        // reason, we'll have to fix the code
                                        // below that does the window update
                                        // check. See the comments in the
                                        // BufferData() routine for more info.
                                        (void)BufferData(RcvTCB, TCP_FLAG_PUSH,
                                                         PendBuffer, PendSize);
                                        CheckTCBRcv(RcvTCB);
                                        // Now we need to see if the window
                                        // has changed. If it has, send an
                                        // ACK.
                                        OldRcvWin = RcvTCB->tcb_rcvwin;
                                        if (OldRcvWin != RcvWin(RcvTCB)) {
                                            // The window has changed, so send
                                            // an ACK.

                                            DelayAction(RcvTCB, NEED_ACK);
                                        }

                                        DerefTCB(RcvTCB, DISPATCH_LEVEL);
                                        ProcessTCBDelayQ(DISPATCH_LEVEL, FALSE);
                                        KeLowerIrql(ConnTableHandle);
                                        return TDI_PENDING;
                                    }
                                }
                                // In a receive indication. The recv. request
                                // is now on the queue, so just fall through
                                // to the return.

                            }
                            // A rcv. is currently active. No need to do
                            // anything else.
                            CTEFreeLock(&RcvTCB->tcb_lock, ConnTableHandle);
                            return TDI_PENDING;
                        } else {
                            // This buffer can hold urgent data and we have
                            // some pending. Deliver it now.
                            REFERENCE_TCB(RcvTCB);
                            DeliverUrgent(RcvTCB, NULL, 0, &ConnTableHandle);
                            DerefTCB(RcvTCB, ConnTableHandle);
                            return TDI_PENDING;
                        }
                    } else {
                        TCPRcvReq *Temp;

                        // This is an expedited only receive. Just put him
                        // on the end of the expedited receive queue.
                        Temp = STRUCT_OF(TCPRcvReq, &RcvTCB->tcb_exprcv,
                                         trr_next);
                        while (Temp->trr_next != NULL)
                            Temp = Temp->trr_next;

                        RcvReq->trr_next = NULL;
                        Temp->trr_next = RcvReq;
                        if (RcvTCB->tcb_urgpending != NULL) {
                            REFERENCE_TCB(RcvTCB);
                            DeliverUrgent(RcvTCB, NULL, 0, &ConnTableHandle);
                            DerefTCB(RcvTCB, ConnTableHandle);
                            return TDI_PENDING;
                        } else
                            Error = TDI_PENDING;
                    }
                } else {
                    // Couldn't get a rcv. req.
                    Error = TDI_NO_RESOURCES;
                }
            } else {
                // The TCB is in an invalid state.
                Error = TDI_INVALID_STATE;
            }
            CTEFreeLock(&RcvTCB->tcb_lock, ConnTableHandle);
            return Error;
        } else {                // No TCB for connection.

            CTEFreeLock(&((Conn->tc_ConnBlock)->cb_lock), ConnTableHandle);
            Error = TDI_INVALID_STATE;
        }
    } else                        // No connection.

        Error = TDI_INVALID_CONNECTION;

    //CTEFreeLock(&ConnTableLock, ConnTableHandle);
    return Error;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\tlcommon.c ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TLCOMMON.C - Common transport layer code.
//
//  This file contains the code for routines that are common to
//  both TCP and UDP.
//
#include "precomp.h"
#include "tlcommon.h"
#include "tcpipbuf.h"

extern TCPXSUM_ROUTINE tcpxsum_routine;
//extern  uint    tcpxsum(uint Seed, void *Ptr, uint Length);
extern IPInfo LocalNetInfo;

//* TcpipCopyBufferToNdisBuffer
//
// This routine copies data described by the source buffer to the NDIS_BUFFER
// chain described by DestinationNdisBuffer. On NT, this really translates
// directly to TdiCopyBufferToMdl since an NDIS_BUFFER is an MDL.
//
// Input:
//
//  SourceBuffer - pointer to the source buffer
//
//  SourceOffset - Number of bytes to skip in the source data.
//
//  SourceBytesToCopy - number of bytes to copy from the source buffer
//
//  DestinationNdisBuffer - Pointer to a chain of NDIS_BUFFERs describing the
//          destination buffers.
//
//  DestinationOffset - Number of bytes to skip in the destination data.
//
//  BytesCopied - Pointer to a longword where the actual number of bytes
//      transferred will be returned.
#if MILLEN
NTSTATUS
TcpipCopyBufferToNdisBuffer (
    IN PVOID SourceBuffer,
    IN ULONG SourceOffset,
    IN ULONG SourceBytesToCopy,
    IN PNDIS_BUFFER DestinationNdisBuffer,
    IN ULONG DestinationOffset,
    IN PULONG BytesCopied
    )
{
    PUCHAR Dest, Src;
    ULONG DestBytesLeft, BytesSkipped=0;

    *BytesCopied = 0;

    if (SourceBytesToCopy == 0) {
        return STATUS_SUCCESS;
    }

    //
    // Skip Destination bytes.
    //

    Dest = NdisBufferVirtualAddress(DestinationNdisBuffer);
    DestBytesLeft = NdisBufferLength(DestinationNdisBuffer);
    while (BytesSkipped < DestinationOffset) {
        if (DestBytesLeft > (DestinationOffset - BytesSkipped)) {
            DestBytesLeft -= (DestinationOffset - BytesSkipped);
            Dest += (DestinationOffset - BytesSkipped);
            BytesSkipped = DestinationOffset;
            break;
        } else if (DestBytesLeft == (DestinationOffset - BytesSkipped)) {
            DestinationNdisBuffer = DestinationNdisBuffer->Next;
            if (DestinationNdisBuffer == NULL) {
                return STATUS_BUFFER_OVERFLOW;          // no bytes copied.
            }
            BytesSkipped = DestinationOffset;
            Dest = NdisBufferVirtualAddress(DestinationNdisBuffer);
            DestBytesLeft = NdisBufferLength(DestinationNdisBuffer);
            break;
        } else {
            BytesSkipped += DestBytesLeft;
            DestinationNdisBuffer = DestinationNdisBuffer->Next;
            if (DestinationNdisBuffer == NULL) {
                return STATUS_BUFFER_OVERFLOW;          // no bytes copied.
            }
            Dest = NdisBufferVirtualAddress(DestinationNdisBuffer);
            DestBytesLeft = NdisBufferLength(DestinationNdisBuffer);
        }
    }

    //
    // Skip source bytes.
    //

    Src = (PUCHAR)SourceBuffer + SourceOffset;

    //
    // Copy source data into the destination buffer until it's full or
    // we run out of data, whichever comes first.
    //

    while ((SourceBytesToCopy != 0) && (DestinationNdisBuffer != NULL)) {
        if (DestBytesLeft == 0) {
            DestinationNdisBuffer = DestinationNdisBuffer->Next;
            if (DestinationNdisBuffer == NULL) {
                return STATUS_BUFFER_OVERFLOW;
            }
            Dest = NdisBufferVirtualAddress(DestinationNdisBuffer);
            DestBytesLeft = NdisBufferLength(DestinationNdisBuffer);
            continue;                   // skip 0-length MDL's.
        }

        if (DestBytesLeft >= SourceBytesToCopy) {
            RtlCopyBytes (Dest, Src, SourceBytesToCopy);
            *BytesCopied += SourceBytesToCopy;
            return STATUS_SUCCESS;
        } else {
            RtlCopyBytes (Dest, Src, DestBytesLeft);
            *BytesCopied += DestBytesLeft;
            SourceBytesToCopy -= DestBytesLeft;
            Src += DestBytesLeft;
            DestBytesLeft = 0;
        }
    }

    return SourceBytesToCopy == 0 ? STATUS_SUCCESS : STATUS_BUFFER_OVERFLOW;
}
#endif // MILLEN

//* PrefetchRcvbuf in to L1 cache
//  Called when received segment checksum is already computed by
//  the hardware
//
//  Input: IPRcvBuf - Buffer chain indicated by IP
//  returns: None
//
//

#if !MILLEN
__inline
void
PrefetchRcvBuf(IPRcvBuf *BufChain)
{
    while (BufChain) {
        RtlPrefetchMemoryNonTemporal(BufChain->ipr_buffer,BufChain->ipr_size);
        BufChain = BufChain->ipr_next;
    }
}
#endif // !MILLEN

//* XsumSendChain - Checksum a chain of NDIS send buffers.
//
//  Called to xsum a chain of NDIS send buffers. We're given the
//  pseudo-header xsum to start with, and we call xsum on each
//  buffer. We assume that this is a send chain, and that the
//  first buffer of the chain has room for an IP header that we
//  need to skip.
//
//  Input:  PHXsum      - Pseudo-header xsum.
//          BufChain    - Pointer to NDIS_BUFFER chain.
//
//  Returns: The computed xsum.
//

ushort
XsumSendChain(uint PHXsum, PNDIS_BUFFER BufChain)
{
    uint HeaderSize;
    uint OldLength;
    uint SwapCount;
    uchar *Ptr;

    HeaderSize = LocalNetInfo.ipi_hsize;
    OldLength = 0;
    SwapCount = 0;

    //
    // ***** The following line of code can be removed if the pseudo
    //       checksum never has any bits sets in the upper word.
    //

    PHXsum = (((PHXsum << 16) | (PHXsum >> 16)) + PHXsum) >> 16;
    do {

        //
        // If the length of the last buffer was odd, then swap the checksum.
        //

        if ((OldLength & 1) != 0) {
            PHXsum = ((PHXsum & 0xff) << 8) | (PHXsum >> 8);
            SwapCount ^= 1;
        }

#if MILLEN
        //
        // Some TDI Clients on Windows ME have been known to end a buffer
        // chain with a 0 length buffer. Just continue to the next buffer.
        //

        if (NdisBufferLength(BufChain))
#endif // MILLEN
        {
            Ptr = (uchar *) TcpipBufferVirtualAddress(BufChain, NormalPagePriority);

            if (Ptr == NULL) {
                // Return zero checksum. All should recover.
                return (0);
            }

            Ptr = Ptr + HeaderSize;

            //PHXsum = tcpxsum(PHXsum, Ptr, NdisBufferLength(BufChain));
            PHXsum = tcpxsum_routine(PHXsum, Ptr, NdisBufferLength(BufChain));
            HeaderSize = 0;
            OldLength = NdisBufferLength(BufChain);
        }

        BufChain = NDIS_BUFFER_LINKAGE(BufChain);
    } while (BufChain != NULL);

    //
    // If an odd number of swaps were done, then swap the xsum again.
    //
    // N.B. At this point the checksum is only a word.
    //

    if (SwapCount != 0) {
        PHXsum = ((PHXsum & 0xff) << 8) | (PHXsum >> 8);
    }
    return (ushort) PHXsum;
}

//* CopyRcvToNdis - Copy from an IPRcvBuf chain to an NDIS buffer chain.
//
//  This is the function we use to copy from a chain of IP receive buffers
//  to a chain of NDIS buffers. The caller specifies the source and destination,
//  a maximum size to copy, and an offset into the first buffer to start
//  copying from. We copy as much as possible up to the size, and return
//  the size copied.
//
//  Input:  RcvBuf      - Pointer to receive buffer chain.
//          DestBuf     - Pointer to NDIS buffer chain.
//          Size        - Size in bytes to copy.
//          RcvOffset   - Offset into first buffer to copy from.
//          DestOffset  - Offset into dest buffer to start copying at.
//
//  Returns: Bytes copied.
//

uint
CopyRcvToNdis(IPRcvBuf * RcvBuf, PNDIS_BUFFER DestBuf, uint Size,
              uint RcvOffset, uint DestOffset)
{
    uint TotalBytesCopied = 0;    // Bytes we've copied so far.
    uint BytesCopied = 0;        // Bytes copied out of each buffer.
    uint DestSize, RcvSize;        // Size left in current destination and
    // recv. buffers, respectively.
    uint BytesToCopy;            // How many bytes to copy this time.
    NTSTATUS Status;

    PNDIS_BUFFER pTempBuf;

    ASSERT(RcvBuf != NULL);

    ASSERT(RcvOffset <= RcvBuf->ipr_size);

    // The destination buffer can be NULL - this is valid, if odd.
    if (DestBuf != NULL) {

        RcvSize = RcvBuf->ipr_size - RcvOffset;

        //
        // Need to calculate length of full MDL chain. TdiCopyBufferToMdl
        // will do the right thing with multiple MDLs.
        //

        pTempBuf = DestBuf;
        DestSize = 0;

        do {
            DestSize += NdisBufferLength(pTempBuf);
            pTempBuf = NDIS_BUFFER_LINKAGE(pTempBuf);
        }
        while (pTempBuf);

        if (Size < DestSize) {
            DestSize = Size;
        }
        do {
            // Compute the amount to copy, and then copy from the
            // appropriate offsets.
            BytesToCopy = MIN(DestSize, RcvSize);

            Status = TcpipCopyBufferToNdisBuffer(RcvBuf->ipr_buffer, RcvOffset,
                                        BytesToCopy, DestBuf, DestOffset, (PULONG)&BytesCopied);

            if (!NT_SUCCESS(Status)) {
                break;
            }
            ASSERT(BytesCopied == BytesToCopy);

            TotalBytesCopied += BytesCopied;
            DestSize -= BytesCopied;
            DestOffset += BytesCopied;
            RcvSize -= BytesToCopy;

            if (!RcvSize) {
                // Exhausted this buffer.

                RcvBuf = RcvBuf->ipr_next;

                // If we have another one, use it.
                if (RcvBuf != NULL) {
                    RcvOffset = 0;
                    RcvSize = RcvBuf->ipr_size;
                } else {
                    break;
                }
            } else {            // Buffer not exhausted, update offset.

                RcvOffset += BytesToCopy;
            }

        } while (DestSize);

    }
    return TotalBytesCopied;

}

uint
CopyRcvToMdl(IPRcvBuf * RcvBuf, PMDL DestBuf, uint Size,
              uint RcvOffset, uint DestOffset)
{
    uint TotalBytesCopied = 0;    // Bytes we've copied so far.
    uint BytesCopied = 0;        // Bytes copied out of each buffer.
    uint DestSize, RcvSize;        // Size left in current destination and
    // recv. buffers, respectively.
    uint BytesToCopy;            // How many bytes to copy this time.
    NTSTATUS Status;

    PMDL pTempBuf;

    ASSERT(RcvBuf != NULL);

    ASSERT(RcvOffset <= RcvBuf->ipr_size);

    // The destination buffer can be NULL - this is valid, if odd.
    if (DestBuf != NULL) {

        RcvSize = RcvBuf->ipr_size - RcvOffset;

        //
        // Need to calculate length of full MDL chain. TdiCopyBufferToMdl
        // will do the right thing with multiple MDLs.
        //

        pTempBuf = DestBuf;
        DestSize = 0;

        do {
            DestSize += MmGetMdlByteCount(pTempBuf);
            pTempBuf = pTempBuf->Next;
        }
        while (pTempBuf);

        if (Size < DestSize) {
            DestSize = Size;
        }
        do {
            // Compute the amount to copy, and then copy from the
            // appropriate offsets.
            BytesToCopy = MIN(DestSize, RcvSize);

            Status = TdiCopyBufferToMdl(RcvBuf->ipr_buffer, RcvOffset,
                                        BytesToCopy, DestBuf, DestOffset, (PULONG)&BytesCopied);

            if (!NT_SUCCESS(Status)) {
                break;
            }
            ASSERT(BytesCopied == BytesToCopy);

            TotalBytesCopied += BytesCopied;
            DestSize -= BytesCopied;
            DestOffset += BytesCopied;
            RcvSize -= BytesToCopy;

            if (!RcvSize) {
                // Exhausted this buffer.

                RcvBuf = RcvBuf->ipr_next;

                // If we have another one, use it.
                if (RcvBuf != NULL) {
                    RcvOffset = 0;
                    RcvSize = RcvBuf->ipr_size;
                } else {
                    break;
                }
            } else {            // Buffer not exhausted, update offset.

                RcvOffset += BytesToCopy;
            }

        } while (DestSize);

    }
    return TotalBytesCopied;

}


//* CopyRcvToBuffer - Copy from an IPRcvBuf chain to a flat buffer.
//
//  Called during receive processing to copy from an IPRcvBuffer chain to a
//  flag buffer. We skip Offset bytes in the src chain, and then
//  copy Size bytes.
//
//  Input:  DestBuf         - Pointer to destination buffer.
//          SrcRB           - Pointer to SrcRB chain.
//          Size            - Size in bytes to copy.
//          SrcOffset       - Offset in SrcRB to start copying from.
//
//  Returns:    Nothing.
//
void
CopyRcvToBuffer(uchar * DestBuf, IPRcvBuf * SrcRB, uint Size, uint SrcOffset)
{
#if	DBG
    IPRcvBuf *TempRB;
    uint TempSize;
#endif

    ASSERT(DestBuf != NULL);
    ASSERT(SrcRB != NULL);

    // In debug versions check to make sure we're copying a reasonable size
    // and from a reasonable offset.

#if	DBG
    TempRB = SrcRB;
    TempSize = 0;
    while (TempRB != NULL) {
        TempSize += TempRB->ipr_size;
        TempRB = TempRB->ipr_next;
    }

    ASSERT(SrcOffset < TempSize);
    ASSERT((SrcOffset + Size) <= TempSize);
#endif

    // First, skip Offset bytes.
    while (SrcOffset >= SrcRB->ipr_size) {
        SrcOffset -= SrcRB->ipr_size;
        SrcRB = SrcRB->ipr_next;
    }

    while (Size != 0) {
        uint BytesToCopy, SrcSize;

        ASSERT(SrcRB != NULL);

        SrcSize = SrcRB->ipr_size - SrcOffset;
        BytesToCopy = MIN(Size, SrcSize);
        RtlCopyMemory(DestBuf, SrcRB->ipr_buffer + SrcOffset, BytesToCopy);

        if (BytesToCopy == SrcSize) {
            // Copied everything from this buffer.
            SrcRB = SrcRB->ipr_next;
            SrcOffset = 0;
        }
        DestBuf += BytesToCopy;
        Size -= BytesToCopy;
    }

}

//* CopyFlatToNdis - Copy a flat buffer to an NDIS_BUFFER chain.
//
//  A utility function to copy a flat buffer to an NDIS buffer chain. We
//  assume that the NDIS_BUFFER chain is big enough to hold the copy amount;
//  in a debug build we'll  debugcheck if this isn't true. We return a pointer
//  to the buffer where we stopped copying, and an offset into that buffer.
//  This is useful for copying in pieces into the chain.
//
//  Input:  DestBuf     - Destination NDIS_BUFFER chain.
//          SrcBuf      - Src flat buffer.
//          Size        - Size in bytes to copy.
//          StartOffset - Pointer to start of offset into first buffer in
//                          chain. Filled in on return with the offset to
//                          copy into next.
//          BytesCopied - Pointer to a variable into which to store the
//                          number of bytes copied by this operation
//
//  Returns: Pointer to next buffer in chain to copy into.
//


PNDIS_BUFFER
CopyFlatToNdis(PNDIS_BUFFER DestBuf, uchar * SrcBuf, uint Size,
               uint * StartOffset, uint * BytesCopied)
{
    NTSTATUS Status = 0;

    *BytesCopied = 0;

    Status = TcpipCopyBufferToNdisBuffer(SrcBuf, 0, Size, DestBuf, *StartOffset,
                                (PULONG)BytesCopied);

    *StartOffset += *BytesCopied;

    //
    // Always return the first buffer, since the TdiCopy function handles
    // finding the appropriate buffer based on offset.
    //
    return (DestBuf);

}

PMDL
CopyFlatToMdl(PMDL DestBuf, uchar *SrcBuf, uint Size,
              uint *StartOffset, uint *BytesCopied
              )
{
    NTSTATUS Status = 0;

    *BytesCopied = 0;

    Status = TdiCopyBufferToMdl(
        SrcBuf,
        0,
        Size,
        DestBuf,
        *StartOffset,
        (PULONG)BytesCopied);

    *StartOffset += *BytesCopied;

    return (DestBuf);
}


//* BuildTAAddress - Builds a TA Address.
//
//  Called to fill in the fields of a TA Address.
//
//  Input:  TAAddr      - Buffer to be filled in as TA Address structure.
//          Addr        - IP Address to fill in.
//          Port        - Port to be filled in.
//
//  Returns: Pointer to the byte after the end of the current TA Address.
//
FORCEINLINE
PVOID
BuildTAAddress(PTA_ADDRESS TAAddr, IPAddr Addr, ushort Port)
{
    TAAddr->AddressType = TDI_ADDRESS_TYPE_IP;
    TAAddr->AddressLength = sizeof(TDI_ADDRESS_IP);
    ((PTDI_ADDRESS_IP) TAAddr->Address)->sin_port = Port;
    ((PTDI_ADDRESS_IP) TAAddr->Address)->in_addr = Addr;
    memset(((PTDI_ADDRESS_IP) TAAddr->Address)->sin_zero, 0,
           sizeof(((PTDI_ADDRESS_IP) TAAddr->Address)->sin_zero));

    return ((PUCHAR)TAAddr + FIELD_OFFSET(TA_ADDRESS, Address) + 
            TAAddr->AddressLength);
}    


//* BuildTDIAddress - Build a TDI address structure.
//
//  Called when we need to build a TDI address structure. We fill in
//  the specifed buffer with the correct information in the correct
//  format.
//
//  Input:  Buffer      - Buffer to be filled in as TDI address structure.
//          Addr        - IP Address to fill in.
//          Port        - Port to be filled in.
//
//  Returns: Pointer to the byte after the end of the first TA Address.
//
PVOID
BuildTDIAddress(uchar * Buffer, IPAddr Addr, ushort Port)
{
    PTRANSPORT_ADDRESS XportAddr;

    XportAddr = (PTRANSPORT_ADDRESS) Buffer;
    XportAddr->TAAddressCount = 1;

    return BuildTAAddress(XportAddr->Address, Addr, Port);
}


//* AppendTDIAddress - Appends a TA Address to a TDI address structure.
//
//  Called to add another TA Address to a TDI Address strcutre.
//
//  Input:  Buffer      - Buffer pointing to a TDI address structure.
//          Addr        - IP Address to fill in.
//          Port        - Port to be filled in.
//
//  Returns: Pointer to the byte after the end of the last TA Address.
//
PVOID
AppendTDIAddress(uchar * Buffer, uchar * NextAddress, IPAddr Addr, ushort Port)
{
    PTRANSPORT_ADDRESS XportAddr;

    XportAddr = (PTRANSPORT_ADDRESS) Buffer;
    XportAddr->TAAddressCount++;

    return BuildTAAddress((PTA_ADDRESS)NextAddress, Addr, Port);
}


//* UpdateConnInfo - Update a connection information structure.
//
//  Called when we need to update a connection information structure. We
//  copy any options, and create a transport address. If any buffer is
//  too small we return an error.
//
//  Input:  ConnInfo        - Pointer to TDI_CONNECTION_INFORMATION struc
//                              to be filled in.
//          OptInfo         - Pointer to IP options information.
//          SrcAddress      - Source IP address.
//          SrcPort         - Source port.
//
//  Returns: TDI_SUCCESS if it worked, TDI_BUFFER_OVERFLOW for an error.
//
TDI_STATUS
UpdateConnInfo(PTDI_CONNECTION_INFORMATION ConnInfo, IPOptInfo * OptInfo,
               IPAddr SrcAddress, ushort SrcPort)
{
    TDI_STATUS Status = TDI_SUCCESS;    // Default status to return.
    uint AddrLength, OptLength;

    if (ConnInfo != NULL) {
        ConnInfo->UserDataLength = 0;    // No user data.

        // Fill in the options. If the provided buffer is too small,
        // we'll truncate the options and return an error. Otherwise
        // we'll copy the whole IP option buffer.
        if (ConnInfo->OptionsLength) {
            if (ConnInfo->OptionsLength < OptInfo->ioi_optlength) {
                Status = TDI_BUFFER_OVERFLOW;
                OptLength = ConnInfo->OptionsLength;
            } else
                OptLength = OptInfo->ioi_optlength;

            RtlCopyMemory(ConnInfo->Options, OptInfo->ioi_options, OptLength);

            ConnInfo->OptionsLength = OptLength;
        }
        // Options are copied. Build a TRANSPORT_ADDRESS structure in
        // the buffer.
        AddrLength = ConnInfo->RemoteAddressLength;
        if (AddrLength) {

            // Make sure we have at least enough to fill in the count and type.
            if (AddrLength >= TCP_TA_SIZE) {

                // The address fits. Fill it in.
                ConnInfo->RemoteAddressLength = TCP_TA_SIZE;
                BuildTDIAddress(ConnInfo->RemoteAddress, SrcAddress, SrcPort);

            } else {
                ConnInfo->RemoteAddressLength = 0;
                Status = TDI_INVALID_PARAMETER;
            }
        }
    }
    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\tlcommon.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** TLCOMMON.H - Common transport layer definitions.
//
//  This file contains definitions for common transport layer items.
//

#if BACK_FILL
// Max header size for backfilling
#define MAX_BACKFILL_HDR_SIZE 32
#endif


#define PHXSUM(s,d,p,l) (uint)( (uint)*(ushort *)&(s) + \
                        (uint)*(ushort *)((char *)&(s) + sizeof(ushort)) + \
                        (uint)*(ushort *)&(d) + \
                        (uint)*(ushort *)((char *)&(d) + sizeof(ushort)) + \
                        (uint)((ushort)net_short((p))) + \
                        (uint)((ushort)net_short((ushort)(l))) )


#define TCP_TA_SIZE     (offsetof(TRANSPORT_ADDRESS, Address->Address)+ \
                         sizeof(TDI_ADDRESS_IP))
extern  void        PrefetchRcvBuf(IPRcvBuf *Buf);
extern  ushort      XsumSendChain(uint PHXsum, PNDIS_BUFFER BufChain);
extern  ushort      XsumRcvBuf(uint PHXsum, IPRcvBuf *BufChain);
extern  uint        CopyRcvToNdis(IPRcvBuf *RcvBuf, PNDIS_BUFFER DestBuf,
                        uint Size, uint RcvOffset, uint DestOffset);
extern  uint        CopyRcvToMdl(IPRcvBuf *RcvBuf, PMDL DestBuf,
                        uint Size, uint RcvOffset, uint DestOffset);
extern  TDI_STATUS  UpdateConnInfo(PTDI_CONNECTION_INFORMATION ConnInfo,
                        IPOptInfo *OptInfo, IPAddr SrcAddress, ushort SrcPort);

extern  void*       BuildTDIAddress(uchar *Buffer, IPAddr Addr, ushort Port);

extern  void*       AppendTDIAddress(uchar *Buffer, uchar * NextAddress, 
                        IPAddr Addr, ushort Port);

extern  void        CopyRcvToBuffer(uchar *DestBuf, IPRcvBuf *SrcRB, uint Size,
                        uint Offset);

extern  PNDIS_BUFFER CopyFlatToNdis(PNDIS_BUFFER DestBuf, uchar *SrcBuf,
                        uint Size, uint *Offset, uint *BytesCopied);
extern PMDL CopyFlatToMdl(PMDL DestBuf, uchar *SrcBuf,
                        uint Size, uint *Offset, uint *BytesCopied);

extern  void        *TLRegisterProtocol(uchar Protocol, void *RcvHandler,
                        void *XmitHandler, void *StatusHandler,
                        void *RcvCmpltHandler, void *PnPHandler, void *ElistHandler);


// Differentiate copying to an NDIS_BUFFER and an MDL for Millenniun. On
// NT they are the same thing and inlined to the TDI functions.
#if MILLEN
NTSTATUS
TcpipCopyBufferToNdisBuffer (
    IN PVOID SourceBuffer,
    IN ULONG SourceOffset,
    IN ULONG SourceBytesToCopy,
    IN PNDIS_BUFFER DestinationNdisBuffer,
    IN ULONG DestinationOffset,
    IN PULONG BytesCopied
    );
#else // MILLEN
__inline NTSTATUS
TcpipCopyBufferToNdisBuffer (
    IN PVOID SourceBuffer,
    IN ULONG SourceOffset,
    IN ULONG SourceBytesToCopy,
    IN PNDIS_BUFFER DestinationNdisBuffer,
    IN ULONG DestinationOffset,
    IN PULONG BytesCopied
    )
{
    return TdiCopyBufferToMdl(
        SourceBuffer,
        SourceOffset,
        SourceBytesToCopy,
        DestinationNdisBuffer,
        DestinationOffset,
        BytesCopied);
}

#endif // !MILLEN
/*
 * Routine for TCP checksum. This is defined as calls through a function
 * pointer which is set to point at the optimal routine for this
 * processor implementation
 */
typedef
ULONG
(* TCPXSUM_ROUTINE)(
    IN ULONG Checksum,
    IN PUCHAR Source,
    IN ULONG Length
    );

ULONG
tcpxsum_xmmi(
    IN ULONG Checksum,
    IN PUCHAR Source,
    IN ULONG Length
    );

ULONG
tcpxsum(
    IN ULONG Checksum,
    IN PUCHAR Source,
    IN ULONG Length
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\9x\i386\xsum.asm ===
.xlist
include xsum.x86
.list
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\udp.h ===
/********************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** UDP. - UDP protocol definitions.
//
//	This file contains definitions for the UDP protocol functions.
//

#include "dgram.h"

#define	PROTOCOL_UDP	17			// UDP protocol number

//* Structure of a UDP header.
struct UDPHeader {
	ushort		uh_src;				// Source port.
	ushort		uh_dest;			// Destination port.
	ushort		uh_length;			// Length
	ushort		uh_xsum;			// Checksum.
}; /* UDPHeader */

typedef struct UDPHeader UDPHeader;


//* External definition of exported functions.
extern	IP_STATUS	UDPRcv(void *IPContext, IPAddr Dest, IPAddr Src,
                        IPAddr LocalAddr, IPAddr SrcAddr,
                        IPHeader UNALIGNED *IPH, uint IPHLength,
                        IPRcvBuf *RcvBuf,  uint Size, uchar IsBCast,
                        uchar Protocol, IPOptInfo *OptInfo);

extern	void		UDPStatus(uchar StatusType, IP_STATUS StatusCode, IPAddr OrigDest,
						IPAddr OrigSrc, IPAddr Src, ulong Param, void *Data);

extern	void		UDPSend(AddrObj *SrcAO, DGSendReq *SendReq);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\nt\i386\xsum.asm ===
.xlist
include xsum.x86
.list
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\nt\amd64\xsum.asm ===
.xlist
include xsum.amd64
.list
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\9x\ipr9x.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    ipr9x.c

Abstract:

    This file contains the implementation of IP Receive buffer
    list manager. On Windows ME this is done to avoid
    fragmenting the non-paged pool when receive buffers are not
    pre-posted by AFVXD.

Author:

    Scott Holden (sholden) 30-Apr-2000

--*/

#include "precomp.h"
#include "addr.h"
#include "tcp.h"
#include "tcb.h"
#include "tcprcv.h"
#include "tcpsend.h"
#include "tcpconn.h"
#include "tcpdeliv.h"
#include "tlcommon.h"
#include "tcpipbuf.h"
#include "pplasl.h"
#include "mdl2ndis.h"

HANDLE TcpIprDataPoolSmall  = NULL;
HANDLE TcpIprDataPoolMedium = NULL;
HANDLE TcpIprDataPoolLarge  = NULL;

#if DBG
ULONG  TcpIprAllocs      = 0;
ULONG  TcpIprFrees       = 0;
ULONG  TcpIprAllocMisses = 0;
#endif // DBG

//
// The three buffer pool sizes are based on MTU. 576 for PPP, 1500 for ethernet,
// and 8K+ for loopback and ATM. Since for 8K buffers we really need a little
// more than 8K, we will allocate a full three pages
//

#define SMALL_TCP_IPR_BUFFER_SIZE  (sizeof(IPRcvBuf) + sizeof(HANDLE) + 576)
#define MEDIUM_TCP_IPR_BUFFER_SIZE (sizeof(IPRcvBuf) + sizeof(HANDLE) + 1500)
#define LARGE_TCP_IPR_BUFFER_SIZE  (3 * 4096)

//* UnInitTcpIprPools - Destroys TCP IPRcvBuffer lookaside lists.
//
//  Uninitializes the lookasides lists for TCP buffered data.
//
//  Input:   None.
//
//  Returns: None.
//
VOID
UnInitTcpIprPools(VOID)
{
    PplDestroyPool(TcpIprDataPoolSmall);
    PplDestroyPool(TcpIprDataPoolMedium);
    PplDestroyPool(TcpIprDataPoolLarge);
}

//* InitTcpIprPools - Initializes TCP IPRcvBuffer lookaside lists.
//
//  Initializes the lookaside lists for buffer data.
//
//  Input:  None.
//
//  Returns: TRUE, if successful, else FALSE.
//
BOOLEAN
InitTcpIprPools(VOID)
{
    BOOLEAN Status = TRUE;

    TcpIprDataPoolSmall = PplCreatePool(NULL, NULL, 0, 
        SMALL_TCP_IPR_BUFFER_SIZE, 'BPCT', 512);

    if (TcpIprDataPoolSmall == NULL) {
        Status = FALSE;
        goto done;
    }

    TcpIprDataPoolMedium = PplCreatePool(NULL, NULL, 0, 
        MEDIUM_TCP_IPR_BUFFER_SIZE, 'BPCT', 256);

    if (TcpIprDataPoolMedium == NULL) {
        Status = FALSE;
        goto done;
    }

    TcpIprDataPoolLarge = PplCreatePool(NULL, NULL, 0, 
        LARGE_TCP_IPR_BUFFER_SIZE, 'BPCT', 64);

    if (TcpIprDataPoolLarge == NULL) {
        Status = FALSE;
    }

done:

    if (Status == FALSE) {
        UnInitTcpIprPools();
    }

    return (Status);
}

//* AllocTcpIpr - Allocates the IPRcvBuffer from lookaside lists.
//
//  A utility routine to allocate a TCP owned IPRcvBuffer. This routine 
//  attempts to allocate the RB from an appropriate lookaside list, el
//
//  Input:  BufferSize - Size of data to buffer.
//
//  Returns: Pointer to allocated IPR.
//
IPRcvBuf *
AllocTcpIpr(ULONG BufferSize, ULONG Tag)
{
    PCHAR Buffer;
    IPRcvBuf *Ipr = NULL;
    LOGICAL FromList = FALSE;
    ULONG AllocateSize;
    HANDLE BufferPool = NULL;
    ULONG Depth;

    // Real size that we need.
    AllocateSize = BufferSize + sizeof(HANDLE) + sizeof(IPRcvBuf);

    if (AllocateSize <= LARGE_TCP_IPR_BUFFER_SIZE) {
        
        //
        // Pick the buffer pool to allocate from.
        //

        if (AllocateSize <= SMALL_TCP_IPR_BUFFER_SIZE) {
            BufferPool = TcpIprDataPoolSmall;
        } else if (AllocateSize <= MEDIUM_TCP_IPR_BUFFER_SIZE) {
            BufferPool = TcpIprDataPoolMedium;
        } else {
            BufferPool = TcpIprDataPoolLarge;
        }

        Buffer = PplAllocate(BufferPool, &FromList);

    } else {
        
        //
        // Allocate from NP pool.
        //

        Buffer = CTEAllocMemLow(AllocateSize, Tag);
    }
    
    if (Buffer == NULL) {
        goto done;
    }
    
#if DBG
    if (FromList == FALSE) {
        InterlockedIncrement(&TcpIprAllocMisses);
    }
#endif // DBG

    // Store buffer pool so we know how to free the buffer.
    *((HANDLE *)Buffer) = BufferPool;

    // Get IPR.
    Ipr = (IPRcvBuf *) (Buffer + sizeof(HANDLE));

    // Set up IPR fields appropriately.
    Ipr->ipr_owner = IPR_OWNER_TCP;
    Ipr->ipr_next = NULL;
    Ipr->ipr_buffer = (PCHAR) Ipr + sizeof(IPRcvBuf);
    Ipr->ipr_size = BufferSize;

#if DBG
    InterlockedIncrement(&TcpIprAllocs);
#endif // DBG

done:

    return (Ipr);
}

//* FreeTcpIpr - Frees the IPRcvBuffer to the correct lookaside list.
//
//  A utility routine to free a TCP owned IPRcvBuffer.
//
//  Input:  Ipr - Pointer the RB.
//
//  Returns: None.
//
VOID
FreeTcpIpr(IPRcvBuf *Ipr)
{
    HANDLE BufferPool;
    PCHAR Buffer;

    // Get real start of buffer.
    Buffer = (PCHAR) Ipr - sizeof(HANDLE);

    // Get the pool handle.
    BufferPool = *((HANDLE *) Buffer);

    if (BufferPool) {
        PplFree(BufferPool, Buffer);
    } else {
        CTEFreeMem(Buffer);
    }

#if DBG
    InterlockedIncrement(&TcpIprFrees);
#endif // DBG

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\nt\ia64\xsum.s ===
#include <xsum.ia64>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\driver\tcp\udp.c ===
/*******************************************************************/
/**                     Microsoft LAN Manager                      **/
/**               Copyright(c) Microsoft Corp., 1990-1993          **/
/********************************************************************/
/* :ts=4 */

//** UDP.C - UDP protocol code.
//
//  This file contains the code for the UDP protocol functions,
//  principally send and receive datagram.
//

#include "precomp.h"
#include "addr.h"
#include "udp.h"
#include "tlcommon.h"
#include "info.h"
#include "tcpcfg.h"
#include "secfltr.h"
#include "tcpipbuf.h"

#if GPC
#include    "qos.h"
#include    "traffic.h"
#include    "gpcifc.h"
#include    "ntddtc.h"

extern GPC_HANDLE hGpcClient[];
extern ULONG GpcCfCounts[];
extern GPC_EXPORTED_CALLS GpcEntries;
extern ULONG GPCcfInfo;
#endif

NTSTATUS
GetIFAndLink(void *Rce, ULONG * IFIndex, IPAddr * NextHop);

extern ulong DisableUserTOSSetting;
ulong Fastpath = 0;

void *UDPProtInfo = NULL;

extern IPInfo LocalNetInfo;



extern
TDI_STATUS
MapIPError(IP_STATUS IPError, TDI_STATUS Default);

#undef SrcPort

//
//  UDPDeliver - Deliver a datagram to a user.
//
//  This routine delivers a datagram to a UDP user. We're called with
//  the AddrObj to deliver on, and with the AddrObjTable lock held.
//  We try to find a receive on the specified AddrObj, and if we do
//  we remove it and copy the data into the buffer. Otherwise we'll
//  call the receive datagram event handler, if there is one. If that
//  fails we'll discard the datagram.
//
//  Input:  RcvAO       - AO to receive the datagram.
//          SrcIP       - Source IP address of datagram.
//          SrcPort     - Source port of datagram.
//          RcvBuf      - The IPReceive buffer containing the data.
//          RcvSize     - Size received, including the UDP header.
//          TableHandle - Lock handle for AddrObj table.
//          DeliverInfo - Information about the recieved packet.
//
//  Returns: Nothing.
//

void
UDPDeliver(AddrObj * RcvAO, IPAddr SrcIP, ushort SrcPort, IPRcvBuf * RcvBuf,
           uint RcvSize, IPOptInfo * OptInfo, CTELockHandle TableHandle,
           DGDeliverInfo * DeliverInfo)
{

    Queue *CurrentQ;
    CTELockHandle AOHandle;
    DGRcvReq *RcvReq;
    uint BytesTaken = 0;
    uchar AddressBuffer[TCP_TA_SIZE];
    uint RcvdSize;
    EventRcvBuffer *ERB = NULL;
#if TRACE_EVENT
    PTDI_DATA_REQUEST_NOTIFY_ROUTINE    CPCallBack;
    WMIData  WMIInfo;
#endif
    BOOLEAN FreeBuffer = FALSE;
    int BufferSize;
    PVOID BufferToSend = NULL;

    DEBUGMSG(DBG_TRACE && DBG_UDP && DBG_RX,
        (DTEXT("+UDPDeliver(%x, %x, %x, %x, %d, %x...)\n"),
         RcvAO, SrcIP, SrcPort, RcvBuf, RcvSize, OptInfo));

    CTEStructAssert(RcvAO, ao);

    CTEGetLock(&RcvAO->ao_lock, &AOHandle);
    CTEFreeLock(&AddrObjTableLock.Lock, AOHandle);

    //UH = (UDPHeader *) RcvBuf->ipr_buffer;

    if (DeliverInfo->Flags & NEED_CHECKSUM) {
        if (XsumRcvBuf(PHXSUM(SrcIP, DeliverInfo->DestAddr, PROTOCOL_UDP, RcvSize), RcvBuf) != 0xffff) {
            UStats.us_inerrors++;
            DeliverInfo->Flags &= ~NEED_CHECKSUM;
            CTEFreeLock(&RcvAO->ao_lock, TableHandle);
            return;    // Checksum failed.

        }
    }

    if (AO_VALID(RcvAO)) {

        //By default broadcast rcv  is set on AO

        if ((DeliverInfo->Flags & IS_BCAST) && !AO_BROADCAST(RcvAO)) {
            goto loop_exit;
        }
        if ((DeliverInfo->Flags & IS_BCAST) && (DeliverInfo->Flags & SRC_LOCAL)
                && (RcvAO->ao_mcast_loop == 0)) {
            goto loop_exit;
        }
        CurrentQ = QHEAD(&RcvAO->ao_rcvq);

        // Walk the list, looking for a receive buffer that matches.
        while (CurrentQ != QEND(&RcvAO->ao_rcvq)) {
            RcvReq = QSTRUCT(DGRcvReq, CurrentQ, drr_q);

            CTEStructAssert(RcvReq, drr);

            // If this request is a wildcard request, or matches the source IP
            // address, check the port.

            if (IP_ADDR_EQUAL(RcvReq->drr_addr, NULL_IP_ADDR) ||
                IP_ADDR_EQUAL(RcvReq->drr_addr, SrcIP)) {

                // The local address matches, check the port. We'll match
                // either 0 or the actual port.
                if (RcvReq->drr_port == 0 || RcvReq->drr_port == SrcPort) {

                    TDI_STATUS Status;

                    // The ports matched. Remove this from the queue.
                    REMOVEQ(&RcvReq->drr_q);

                    // We're done. We can free the AddrObj lock now.
                    CTEFreeLock(&RcvAO->ao_lock, TableHandle);

                    // Call CopyRcvToNdis, and then complete the request.

                    //KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "RcvAO %x rcvbuf %x size %x\n",RcvAO,RcvReq->drr_buffer,
                    //                    RcvReq->drr_size));

                    RcvdSize = CopyRcvToNdis(RcvBuf, RcvReq->drr_buffer,
                                             RcvReq->drr_size, sizeof(UDPHeader), 0);

                    ASSERT(RcvdSize <= RcvReq->drr_size);

                    Status = UpdateConnInfo(RcvReq->drr_conninfo, OptInfo,
                                            SrcIP, SrcPort);

                    UStats.us_indatagrams++;

#if TRACE_EVENT
                    CPCallBack = TCPCPHandlerRoutine;

                    if (CPCallBack != NULL) {

                        ulong GroupType;

                        WMIInfo.wmi_srcport  = SrcPort;
                        WMIInfo.wmi_srcaddr  = SrcIP;
                        WMIInfo.wmi_destport = DeliverInfo->DestPort;
                        WMIInfo.wmi_destaddr = DeliverInfo->DestAddr;
                        WMIInfo.wmi_size     = RcvdSize;
                        WMIInfo.wmi_context  = RcvAO->ao_owningpid;

                        GroupType = EVENT_TRACE_GROUP_UDPIP + EVENT_TRACE_TYPE_RECEIVE;
                        (*CPCallBack)( GroupType, (PVOID) &WMIInfo, sizeof(WMIInfo), NULL);
                    }

#endif

                    DEBUGMSG(DBG_INFO && DBG_UDP && DBG_RX,
                        (DTEXT("UDPDeliver completing RcvReq %x for Ao %x.\n"),
                         RcvReq, RcvAO));

                    (*RcvReq->drr_rtn) (RcvReq->drr_context, Status, RcvdSize);

                    FreeDGRcvReq(RcvReq);

                    return;
                }
            }
            // Either the IP address or the port didn't match. Get the next
            // one.
            CurrentQ = QNEXT(CurrentQ);
        }

        // We've walked the list, and not found a buffer. Call the recv.
        // handler now.

        if (RcvAO->ao_rcvdg != NULL) {
            PRcvDGEvent RcvEvent = RcvAO->ao_rcvdg;
            PVOID RcvContext = RcvAO->ao_rcvdgcontext;
            TDI_STATUS RcvStatus;
            ULONG Flags = TDI_RECEIVE_COPY_LOOKAHEAD;

            REF_AO(RcvAO);
            CTEFreeLock(&RcvAO->ao_lock, TableHandle);

            BuildTDIAddress(AddressBuffer, SrcIP, SrcPort);

            UStats.us_indatagrams++;
            if (DeliverInfo->Flags & IS_BCAST) {
                // This flag is true if this is a multicast, subnet broadcast,
                // or broadcast.  We need to differentiate to set the right
                // receive flags.
                //
                if (!CLASSD_ADDR(DeliverInfo->DestAddr)) {
                    Flags |= TDI_RECEIVE_BROADCAST;
                } else {
                    Flags |= TDI_RECEIVE_MULTICAST;
                }
            }

            // Set the buffer variables that we will send to the
            // receive event handler.  These may change if we find
            // any socket option that requires ancillary data to be
            // passed to the handler.
            //
            BufferToSend = OptInfo->ioi_options;
            BufferSize = OptInfo->ioi_optlength;

            // If the IP_PKTINFO option was set, then create the control
            // information to be passed to the handler.  Currently only one
            // such option exists, so only one ancillary data object is
            // created.  We should be able to support an array of them as
            // more options are added.
            //
            if (AO_PKTINFO(RcvAO)) {
                BufferToSend = DGFillIpPktInfo(DeliverInfo->DestAddr,
                                               DeliverInfo->LocalAddr,
                                               &BufferSize);
                if (BufferToSend) {
                    FreeBuffer = TRUE;
                    // Set the receive flag so the receive handler knows
                    // we are passing up control info.
                    //
                    Flags |= TDI_RECEIVE_CONTROL_INFO;
                }
            }

            DEBUGMSG(DBG_INFO && DBG_UDP && DBG_RX,
                (DTEXT("UDPDeliver: calling Event %x for Ao %x\n"), RcvEvent, RcvAO));

            RcvStatus = (*RcvEvent) (RcvContext, TCP_TA_SIZE,
                                     (PTRANSPORT_ADDRESS) AddressBuffer, BufferSize,
                                     BufferToSend, Flags,
                                     RcvBuf->ipr_size - sizeof(UDPHeader),
                                     RcvSize - sizeof(UDPHeader), (PULONG)&BytesTaken,
                                     RcvBuf->ipr_buffer + sizeof(UDPHeader), &ERB);

            if (FreeBuffer) {
                ExFreePool(BufferToSend);
            }

            DEBUGMSG(DBG_INFO && DBG_UDP && DBG_RX,
                (DTEXT("UDPDeliver: Event status for AO %x: %x \n"), RcvAO, RcvStatus));

            if (RcvStatus == TDI_MORE_PROCESSING) {
                ASSERT(ERB != NULL);

                // We were passed back a receive buffer. Copy the data in now.

                // He can't have taken more than was in the indicated
                // buffer, but in debug builds we'll check to make sure.

                ASSERT(BytesTaken <= (RcvBuf->ipr_size - sizeof(UDPHeader)));


#if !MILLEN
                {
                    PIO_STACK_LOCATION IrpSp;
                    PTDI_REQUEST_KERNEL_RECEIVEDG DatagramInformation;

                    IrpSp = IoGetCurrentIrpStackLocation(ERB);
                    DatagramInformation = (PTDI_REQUEST_KERNEL_RECEIVEDG)
                        & (IrpSp->Parameters);

                    //
                    // Copy the remaining data to the IRP.
                    //
                    RcvdSize = CopyRcvToMdl(RcvBuf, ERB->MdlAddress,
                                             RcvSize - sizeof(UDPHeader) - BytesTaken,
                                             sizeof(UDPHeader) + BytesTaken, 0);

                    //
                    // Update the return address info
                    //
                    RcvStatus = UpdateConnInfo(
                                               DatagramInformation->ReturnDatagramInformation,
                                               OptInfo, SrcIP, SrcPort);

                    //
                    // Complete the IRP.
                    //
                    ERB->IoStatus.Information = RcvdSize;
                    ERB->IoStatus.Status = RcvStatus;

#if TRACE_EVENT
                    // Calling before Irp Completion. Irp could go away otherwise.
                    CPCallBack = TCPCPHandlerRoutine;
                    if (CPCallBack!=NULL) {
                            ulong GroupType;

                            WMIInfo.wmi_srcport  = SrcPort;
                            WMIInfo.wmi_srcaddr  = SrcIP;
                            WMIInfo.wmi_destport = DeliverInfo->DestPort;
                            WMIInfo.wmi_destaddr = DeliverInfo->DestAddr;
                            WMIInfo.wmi_context  = RcvAO->ao_owningpid;
                            WMIInfo.wmi_size     = (ushort)RcvdSize + BytesTaken;

                            GroupType = EVENT_TRACE_GROUP_UDPIP + EVENT_TRACE_TYPE_RECEIVE;
                            (*CPCallBack)( GroupType, (PVOID) &WMIInfo, sizeof(WMIInfo), NULL);
                     }

#endif
                    IoCompleteRequest(ERB, 2);
                }
#else // !MILLEN
                RcvdSize = CopyRcvToNdis(RcvBuf, ERB->erb_buffer,
                                         RcvSize - sizeof(UDPHeader) - BytesTaken,
                                         sizeof(UDPHeader) + BytesTaken, 0);

                //
                // Call the completion routine.
                //
                (*ERB->erb_rtn)(ERB->erb_context, TDI_SUCCESS, RcvdSize);
#endif // MILLEN

            } else {
                DEBUGMSG(DBG_WARN && RcvStatus != TDI_SUCCESS && RcvStatus != TDI_NOT_ACCEPTED,
                    (DTEXT("WARN> UDPDgRcvHandler returned %x\n"), RcvStatus));

                ASSERT(
                          (RcvStatus == TDI_SUCCESS) ||
                          (RcvStatus == TDI_NOT_ACCEPTED)
                          );

                ASSERT(ERB == NULL);
#if TRACE_EVENT
                CPCallBack = TCPCPHandlerRoutine;
                if (CPCallBack != NULL){
                    ulong GroupType;

                    WMIInfo.wmi_srcport  = SrcPort;
                    WMIInfo.wmi_srcaddr  = SrcIP;
                    WMIInfo.wmi_destport = DeliverInfo->DestPort;
                    WMIInfo.wmi_destaddr = DeliverInfo->DestAddr;
                    WMIInfo.wmi_context  = RcvAO->ao_owningpid;
                    WMIInfo.wmi_size     = (ushort)BytesTaken;

                    GroupType = EVENT_TRACE_GROUP_UDPIP + EVENT_TRACE_TYPE_RECEIVE;
                    (*CPCallBack)( GroupType, (PVOID)(&WMIInfo), sizeof(WMIInfo), NULL);
                }
#endif
            }

            DELAY_DEREF_AO(RcvAO);

            return;

        } else
            UStats.us_inerrors++;

        // When we get here, we didn't have a buffer to put this data into.
        // Fall through to the return case.

    } else
        UStats.us_inerrors++;

  loop_exit:

    CTEFreeLock(&RcvAO->ao_lock, TableHandle);

}

//** UDPSend - Send a datagram.
//
//  The real send datagram routine. We assume that the busy bit is
//  set on the input AddrObj, and that the address of the SendReq
//  has been verified.
//
//  We start by sending the input datagram, and we loop until there's
//  nothing left on the send q.
//
//  Input:  SrcAO       - Pointer to AddrObj doing the send.
//          SendReq     - Pointer to sendreq describing send.
//
//  Returns: Nothing
//
void
UDPSend(AddrObj * SrcAO, DGSendReq * SendReq)
{
    UDPHeader *UH;
    PNDIS_BUFFER UDPBuffer;
    CTELockHandle AOHandle;
    RouteCacheEntry *RCE;        // RCE used for each send.
    IPAddr SrcAddr;                // Source address IP thinks we should
    // use.
    IPAddr DestAddr;
    ushort DestPort;
    uchar DestType = 0;            // Type of destination address.
    ushort UDPXsum;                // Checksum of packet.
    ushort SendSize;            // Size we're sending.
    IP_STATUS SendStatus;        // Status of send attempt.
    ushort MSS;
    uint AddrValid;
    IPOptInfo OptInfo;
    IPAddr BoundAddr;

    CTEStructAssert(SrcAO, ao);
    ASSERT(SrcAO->ao_usecnt != 0);

    //* Loop while we have something to send, and can get
    //  resources to send.
    for (;;) {
        BOOLEAN CachedRCE = FALSE;

        CTEStructAssert(SendReq, dsr);

        // Make sure we have a UDP header buffer for this send. If we
        // don't, try to get one.
        if ((UDPBuffer = SendReq->dsr_header) == NULL) {
            // Don't have one, so try to get one.
            UDPBuffer = GetDGHeader(&UH);
            if (UDPBuffer != NULL) {

                SendReq->dsr_header = UDPBuffer;
            } else {
                // Couldn't get a header buffer. Push the send request
                // back on the queue, and queue the addr object for when
                // we get resources.
                CTEGetLock(&SrcAO->ao_lock, &AOHandle);
                PUSHQ(&SrcAO->ao_sendq, &SendReq->dsr_q);
                PutPendingQ(SrcAO);
                CTEFreeLock(&SrcAO->ao_lock, AOHandle);
                return;
            }
        }
        // At this point, we have the buffer we need. Call IP to get an
        // RCE (along with the source address if we need it), then compute
        // the checksum and send the data.
        ASSERT(UDPBuffer != NULL);

        BoundAddr = SrcAO->ao_addr;

        if (!CLASSD_ADDR(SendReq->dsr_addr)) {
            // This isn't a multicast send, so we'll use the ordinary
            // information.
            OptInfo = SrcAO->ao_opt;
        } else {
            OptInfo = SrcAO->ao_mcastopt;
        }

        //KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "udpsend: ao %x,  %x  %x  %x\n", SrcAO, SendReq, SendReq->dsr_addr,SendReq->dsr_port));

        if (!(SrcAO->ao_flags & AO_DHCP_FLAG)) {

            if (AO_CONNUDP(SrcAO) && SrcAO->ao_rce) {

                if (SrcAO->ao_rce->rce_flags & RCE_VALID) {
                    SrcAddr = SrcAO->ao_rcesrc;
                    RCE = SrcAO->ao_rce;
                    CachedRCE = TRUE;
                } else {
                    // Close the invalid RCE, and reset the cached information
                    CTEGetLock(&SrcAO->ao_lock, &AOHandle);
                    RCE = SrcAO->ao_rce;
                    SrcAO->ao_rce = NULL;
                    SrcAO->ao_rcesrc = NULL_IP_ADDR;
                    CTEFreeLock(&SrcAO->ao_lock, AOHandle);
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                               "udpsend: closing old RCE %x %x\n",
                               SrcAO, RCE));
                    (*LocalNetInfo.ipi_closerce) (RCE);

                    // retrieve the destination address to which the socket
                    // is connected, and use it to open a new RCE, if possible.
                    // N.B. we always open an RCE to the *connected* destination,
                    // rather than the destination to which the user is currently
                    // sending.
                    GetAddress((PTRANSPORT_ADDRESS) SrcAO->ao_RemoteAddress,
                               &DestAddr, &DestPort);
                    SrcAddr = (*LocalNetInfo.ipi_openrce) (DestAddr, BoundAddr,
                                                           &RCE, &DestType,
                                                           &MSS, &OptInfo);
                    if (!IP_ADDR_EQUAL(SrcAddr, NULL_IP_ADDR)) {
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                                   "udpsend: storing new RCE %x %x\n",
                                   SrcAO, RCE));
                        CTEGetLock(&SrcAO->ao_lock, &AOHandle);
                        SrcAO->ao_rce = RCE;
                        SrcAO->ao_rcesrc = SrcAddr;
                        CachedRCE = TRUE;
                        CTEFreeLock(&SrcAO->ao_lock, AOHandle);
                    }
                }
                IF_TCPDBG(TCP_DEBUG_CONUDP)
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                               "udpsend: ao %x,  %x  %x  %x  %x\n", SrcAO,
                               SrcAddr, SrcAO->ao_port, SendReq->dsr_addr,
                               SendReq->dsr_port));

            } else {            // unconnected

                if ((OptInfo.ioi_mcastif) && CLASSD_ADDR(SendReq->dsr_addr)) {
                    uint BoundIf;

                    // mcast_if is set and this is a mcast send
                    BoundIf = (*LocalNetInfo.ipi_getifindexfromaddr)(BoundAddr,IF_CHECK_NONE);

                    // Use the bound IP address only if the 'interfaces match' and the
                    // 'bound address is not NULL'
                    if ((BoundIf == OptInfo.ioi_mcastif) &&
                        (!IP_ADDR_EQUAL(BoundAddr, NULL_IP_ADDR))) {
                            SrcAddr = BoundAddr;
                    } else {
                        SrcAddr = (*LocalNetInfo.ipi_isvalidindex) (OptInfo.ioi_mcastif);
                    }

                    // go thru slow path
                    RCE = NULL;
                } else {

                    SrcAddr = (*LocalNetInfo.ipi_openrce) (SendReq->dsr_addr,
                                                           BoundAddr, &RCE,
                                                           &DestType, &MSS,
                                                           &OptInfo);
                }

            }

            AddrValid = !IP_ADDR_EQUAL(SrcAddr, NULL_IP_ADDR);
            IF_TCPDBG(TCP_DEBUG_CONUDP)
                if (!AddrValid) {
                KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "udpsend: addrinvalid!!\n"));
            }
        } else {
            // This is a DHCP send. He really wants to send from the
            // NULL IP address.
            SrcAddr = NULL_IP_ADDR;
            RCE = NULL;
            AddrValid = TRUE;
        }

        if (AddrValid) {

            //
            // clear the precedence bits and get ready to be set
            // according to the service type
            //
            if (DisableUserTOSSetting)
                OptInfo.ioi_tos &= TOS_MASK;


            if (!CLASSD_ADDR(SendReq->dsr_addr) &&
                !IP_ADDR_EQUAL(BoundAddr, NULL_IP_ADDR)) {
                //
                // Unless we're doing a multicast lookup (which must be strong
                // host), use the bound address as the source.
                //
                SrcAddr = BoundAddr;
            }
            
#if GPC
            if (RCE && GPCcfInfo) {

                //
                // we'll fall into here only if the GPC client is there
                // and there is at least one CF_INFO_QOS installed
                // (counted by GPCcfInfo).
                //

                GPC_STATUS status = STATUS_SUCCESS;
                ulong ServiceType = 0;
                GPC_IP_PATTERN Pattern;

                //
                // if the packet is being sent to a different destination,
                // invalidate the classification handle (CH), to force a database search.
                // o/w, just call to classify with the current CH
                //

                if (SrcAO->ao_destaddr != SendReq->dsr_addr ||
                    SrcAO->ao_destport != SendReq->dsr_port) {

                    SrcAO->ao_GPCHandle = 0;
                }
                //
                // set the pattern
                //
                IF_TCPDBG(TCP_DEBUG_GPC)
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "UDPSend: Classifying dgram ao %x\n", SrcAO));

                Pattern.SrcAddr = SrcAddr;
                Pattern.DstAddr = SendReq->dsr_addr;
                Pattern.ProtocolId = SrcAO->ao_prot;
                Pattern.gpcSrcPort = SrcAO->ao_port;
                Pattern.gpcDstPort = SendReq->dsr_port;
                if (SrcAO->ao_GPCCachedRTE != (void *)RCE->rce_rte) {

                    //
                    // first time we use this RTE, or it has been changed
                    // since the last send
                    //

                    if (GetIFAndLink(RCE,
                                     &SrcAO->ao_GPCCachedIF,
                                     (IPAddr *) & SrcAO->ao_GPCCachedLink) == STATUS_SUCCESS) {

                        SrcAO->ao_GPCCachedRTE = (void *)RCE->rce_rte;
                    }
                    //
                    // invaludate the classification handle
                    //

                    SrcAO->ao_GPCHandle = 0;
                }
                Pattern.InterfaceId.InterfaceId = SrcAO->ao_GPCCachedIF;
                Pattern.InterfaceId.LinkId = SrcAO->ao_GPCCachedLink;


                IF_TCPDBG(TCP_DEBUG_GPC)
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "UDPSend: IF=%x Link=%x\n",
                             Pattern.InterfaceId.InterfaceId,
                             Pattern.InterfaceId.LinkId));
                
                if (!SrcAO->ao_GPCHandle) {

                    IF_TCPDBG(TCP_DEBUG_GPC)
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "UDPsend: Classification Handle is NULL, getting one now.\n"));

                    status = GpcEntries.GpcClassifyPatternHandler(
                                                                  hGpcClient[GPC_CF_QOS],
                                                                  GPC_PROTOCOL_TEMPLATE_IP,
                                                                  &Pattern,
                                                                  NULL,        // context
                                                                  &SrcAO->ao_GPCHandle,
                                                                  0,
                                                                  NULL,
                                                                  FALSE
                                                                  );

                }
                //
                // Only if QOS patterns exist, we get the TOS bits out.
                //

                if (NT_SUCCESS(status) && GpcCfCounts[GPC_CF_QOS]) {

                    status = GpcEntries.GpcGetUlongFromCfInfoHandler(
                                hGpcClient[GPC_CF_QOS],
                                SrcAO->ao_GPCHandle,
                                FIELD_OFFSET(CF_INFO_QOS, TransportInformation),
                                &ServiceType);

                    //
                    // It is likely that the pattern has gone by now
                    // and the handle that we are caching is INVALID.
                    // We need to pull up a new handle and get the
                    // TOS bit again.
                    //
                    if (STATUS_INVALID_HANDLE == status) {

                        IF_TCPDBG(TCP_DEBUG_GPC)
                            KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "UDPsend: RE-Classification is required.\n"));

                        SrcAO->ao_GPCHandle = 0;

                        status = GpcEntries.GpcClassifyPatternHandler(
                                                                      hGpcClient[GPC_CF_QOS],
                                                                      GPC_PROTOCOL_TEMPLATE_IP,
                                                                      &Pattern,
                                                                      NULL,        // context
                                                                      &SrcAO->ao_GPCHandle,
                                                                      0,
                                                                      NULL,
                                                                      FALSE
                                                                      );

                        //
                        // Only if QOS patterns exist, we get the TOS bits out.
                        //
                        if (NT_SUCCESS(status)) {

                            status = GpcEntries.GpcGetUlongFromCfInfoHandler(
                                        hGpcClient[GPC_CF_QOS],
                                        SrcAO->ao_GPCHandle,
                                        FIELD_OFFSET(CF_INFO_QOS, TransportInformation),
                                        &ServiceType);
                        }
                    }
                }
                //
                // Perhaps something needs to be done if GPC_CF_IPSEC has non-zero patterns.
                //

                IF_TCPDBG(TCP_DEBUG_GPC)
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "UDPsend: ServiceType(%d)=%d\n",
                    FIELD_OFFSET(CF_INFO_QOS, TransportInformation), ServiceType));

                SrcAO->ao_opt.ioi_GPCHandle =
                    SrcAO->ao_mcastopt.ioi_GPCHandle = (int)SrcAO->ao_GPCHandle;

                IF_TCPDBG(TCP_DEBUG_GPC)
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "UDPSend:Got CH %x\n", SrcAO->ao_GPCHandle));

                if (status == STATUS_SUCCESS) {

                    SrcAO->ao_destaddr = SendReq->dsr_addr;
                    SrcAO->ao_destport = SendReq->dsr_port;

                } else {
                    IF_TCPDBG(TCP_DEBUG_GPC)
                        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "UDPSend: no service type found, dstip=%x, dstport=%d\n",
                                 SendReq->dsr_addr, SendReq->dsr_port));

                }

                IF_TCPDBG(TCP_DEBUG_GPC)
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "UDPsend: ServiceType=%d\n", ServiceType));

                if (status == STATUS_SUCCESS) {

                    OptInfo.ioi_tos |= ServiceType;
                }

                // Copy GPCHandle in the local option info.

                OptInfo.ioi_GPCHandle =  SrcAO->ao_opt.ioi_GPCHandle;

                IF_TCPDBG(TCP_DEBUG_GPC)
                    KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "UDPsend: TOS set to 0x%x\n", OptInfo.ioi_tos));

            }                    // if (RCE && GPCcfInfo)

#endif

            // The OpenRCE worked. Compute the checksum, and send it.

            UH = TcpipBufferVirtualAddress(UDPBuffer, NormalPagePriority);

            if (UH == NULL) {
                SendStatus = IP_NO_RESOURCES;
            } else {
                UH = (UDPHeader *) ((PUCHAR) UH + LocalNetInfo.ipi_hsize);

                NdisAdjustBufferLength(UDPBuffer, sizeof(UDPHeader));
                NDIS_BUFFER_LINKAGE(UDPBuffer) = SendReq->dsr_buffer;
                UH->uh_src = SrcAO->ao_port;
                UH->uh_dest = SendReq->dsr_port;
                SendSize = SendReq->dsr_size + sizeof(UDPHeader);
                UH->uh_length = net_short(SendSize);
                UH->uh_xsum = 0;

                if (AO_XSUM(SrcAO)) {
                    // Compute the header xsum, and then call XsumNdisChain
                    UDPXsum = XsumSendChain(PHXSUM(SrcAddr, SendReq->dsr_addr,
                                                   PROTOCOL_UDP, SendSize), UDPBuffer);

                    // We need to negate the checksum, unless it's already all
                    // ones. In that case negating it would take it to 0, and
                    // then we'd have to set it back to all ones.
                    if (UDPXsum != 0xffff)
                        UDPXsum = ~UDPXsum;

                    UH->uh_xsum = UDPXsum;

                }
                // We've computed the xsum. Now send the packet.
                UStats.us_outdatagrams++;
#if TRACE_EVENT
                SendReq->dsr_pid      = SrcAO->ao_owningpid;
                SendReq->dsr_srcaddr  = SrcAddr;
                SendReq->dsr_srcport   = SrcAO->ao_port;
#endif

                SendStatus = (*LocalNetInfo.ipi_xmit) (UDPProtInfo, SendReq,
                                                       UDPBuffer, (uint) SendSize, SendReq->dsr_addr, SrcAddr,
                                                       &OptInfo, RCE, PROTOCOL_UDP, SendReq->dsr_context);
            }

            if (!CachedRCE) {
                (*LocalNetInfo.ipi_closerce) (RCE);
            }

            // If it completed immediately, give it back to the user.
            // Otherwise we'll complete it when the SendComplete happens.
            // Currently, we don't map the error code from this call - we
            // might need to in the future.
            if (SendStatus != IP_PENDING)
                DGSendComplete(SendReq, UDPBuffer, SendStatus);

        } else {
            TDI_STATUS Status;

            if (DestType == DEST_INVALID)
                Status = TDI_BAD_ADDR;
            else
                Status = TDI_DEST_UNREACHABLE;

            // Complete the request with an error.
            (*SendReq->dsr_rtn) (SendReq->dsr_context, Status, 0);
            // Now free the request.
            SendReq->dsr_rtn = NULL;
            DGSendComplete(SendReq, UDPBuffer, IP_SUCCESS);
        }

        CTEGetLock(&SrcAO->ao_lock, &AOHandle);

        if (!EMPTYQ(&SrcAO->ao_sendq)) {
            DEQUEUE(&SrcAO->ao_sendq, SendReq, DGSendReq, dsr_q);
            CTEFreeLock(&SrcAO->ao_lock, AOHandle);
        } else {
            CLEAR_AO_REQUEST(SrcAO, AO_SEND);
            CTEFreeLock(&SrcAO->ao_lock, AOHandle);
            return;
        }

    }
}

//* UDPRcv - Receive a UDP datagram.
//
//  The routine called by IP when a UDP datagram arrived. We
//  look up the port/local address pair in our address table,
//  and deliver the data to a user if we find one. For broadcast
//  frames we may deliver it to multiple users.
//
//  Entry:  IPContext   - IPContext identifying physical i/f that
//                          received the data.
//          Dest        - IPAddr of destination.
//          Src         - IPAddr of source.
//          LocalAddr   - Local address of network which caused this to be
//                          received.
//          SrcAddr     - Address of local interface which received the packet
//          IPH         - IP Header.
//          IPHLength   - Bytes in IPH.
//          RcvBuf      - Pointer to receive buffer chain containing data.
//          Size        - Size in bytes of data received.
//          IsBCast     - Boolean indicator of whether or not this came in as
//                          a bcast.
//          Protocol    - Protocol this came in on - should be UDP.
//          OptInfo     - Pointer to info structure for received options.
//
//  Returns: Status of reception. Anything other than IP_SUCCESS will cause
//          IP to send a 'port unreachable' message.
//
IP_STATUS
UDPRcv(void *IPContext, IPAddr Dest, IPAddr Src, IPAddr LocalAddr,
       IPAddr SrcAddr, IPHeader UNALIGNED * IPH, uint IPHLength, IPRcvBuf * RcvBuf,
       uint IPSize, uchar IsBCast, uchar Protocol, IPOptInfo * OptInfo)
{
    UDPHeader UNALIGNED *UH;
    CTELockHandle AOTableHandle;
    AddrObj *ReceiveingAO;
    uint Size;
    uchar DType;
    BOOLEAN firsttime=TRUE;
    DGDeliverInfo DeliverInfo = {0};

    DType = (*LocalNetInfo.ipi_getaddrtype) (Src);

    if (DType == DEST_LOCAL) {
        DeliverInfo.Flags |= SRC_LOCAL;
    }
    // The following code relies on DEST_INVALID being a broadcast dest type.
    // If this is changed the code here needs to change also.
    if (IS_BCAST_DEST(DType)) {
        if (!IP_ADDR_EQUAL(Src, NULL_IP_ADDR) || !IsBCast) {
            UStats.us_inerrors++;
            return IP_SUCCESS;    // Bad src address.

        }
    }
    UH = (UDPHeader *) RcvBuf->ipr_buffer;
    
    // Check if IP payload contains enough bytes for a UDP header to be
    // present.
    if (IPSize < sizeof(UDPHeader)) {
        UStats.us_inerrors++;
        return IP_SUCCESS;
    }
    
    Size = (uint) (net_short(UH->uh_length));
    
    if (Size < sizeof(UDPHeader)) {
        UStats.us_inerrors++;
        return IP_SUCCESS;        // Size is too small.

    }
    if (Size != IPSize) {
        // Size doesn't match IP datagram size. If the size is larger
        // than the datagram, throw it away. If it's smaller, truncate the
        // recv. buffer.
        if (Size < IPSize) {
            IPRcvBuf *TempBuf = RcvBuf;
            uint TempSize = Size;

            while (TempBuf != NULL) {
                TempBuf->ipr_size = MIN(TempBuf->ipr_size, TempSize);
                TempSize -= TempBuf->ipr_size;
                TempBuf = TempBuf->ipr_next;
            }
        } else {
            // Size is too big, toss it.
            UStats.us_inerrors++;
            return IP_SUCCESS;
        }
    }

    if (UH->uh_xsum != 0) {
       //let udpdeliver compute the checksum
       DeliverInfo.Flags |= NEED_CHECKSUM;
    }

    // Set the rest of our DeliverInfo for UDPDeliver to consume.
    //
    DeliverInfo.Flags |= IsBCast ? IS_BCAST : 0;
    DeliverInfo.LocalAddr = LocalAddr;
    DeliverInfo.DestAddr = Dest;
#if TRACE_EVENT
    DeliverInfo.DestPort = UH->uh_dest;
#endif


    CTEGetLock(&AddrObjTableLock.Lock, &AOTableHandle);

    //
    // See if we are filtering the destination interface/port.
    //
    if (!SecurityFilteringEnabled ||
        IsPermittedSecurityFilter(
                                  SrcAddr,
                                  IPContext,
                                  PROTOCOL_UDP,
                                  (ulong) net_short(UH->uh_dest)
        )
        ) {

        // Try to find an AddrObj to give this to. In the broadcast case, we
        // may have to do this multiple times. If it isn't a broadcast, just
        // get the best match and deliver it to them.

        if (!IsBCast) {

            ReceiveingAO = GetBestAddrObj(Dest, UH->uh_dest, PROTOCOL_UDP,
                                          GAO_FLAG_CHECK_IF_LIST);

            if (ReceiveingAO && (ReceiveingAO->ao_rcvdg == NULL)) {
                AddrObj *tmpAO;

                tmpAO = GetNextBestAddrObj(Dest, UH->uh_dest, PROTOCOL_UDP,
                                           ReceiveingAO,
                                           GAO_FLAG_CHECK_IF_LIST);
                
                if (tmpAO != NULL) {
                    ReceiveingAO = tmpAO;
                }
            }
            if (ReceiveingAO != NULL) {

                UDPDeliver(ReceiveingAO, Src, UH->uh_src, RcvBuf, Size,
                           OptInfo, AOTableHandle, &DeliverInfo);
                return IP_SUCCESS;
            } else {

                CTEFreeLock(&AddrObjTableLock.Lock, AOTableHandle);
                //do the checksum and if it fails, just return IP_SUCCESS
                if (UH->uh_xsum != 0) {
                   if (XsumRcvBuf(PHXSUM(Src, Dest, PROTOCOL_UDP, Size), RcvBuf) != 0xffff) {
                        UStats.us_inerrors++;
                        return IP_SUCCESS;    // Checksum failed.
                    }
                }

                UStats.us_noports++;
                return IP_GENERAL_FAILURE;
            }
        } else {
            // This is a broadcast, we'll need to loop.

            AOSearchContext Search;
            uint IfIndex;

            DType = (*LocalNetInfo.ipi_getaddrtype) (Dest);
            //
            // Get interface index, this will needed in multicast delivery.
            //
            IfIndex = (*LocalNetInfo.ipi_getifindexfromnte) (IPContext,IF_CHECK_NONE);

            ReceiveingAO = GetFirstAddrObj(LocalAddr, UH->uh_dest, PROTOCOL_UDP,
                                           &Search);

            //
            // If there is an AO corresponding to the address of the interface
            // over which we got the packet, process it
            //
            if (ReceiveingAO != NULL) {
                do {
                    //
                    // If the packet is broadcast we deliver it to all clients
                    // waiting on the dest. address (or INADDR_ANY) and port.
                    // If the pkt is mcast, we deliver it to all clients that
                    // are members of the mcast group and waiting on the dest
                    // port.  NOTE, if loopback is disabled, we do not deliver
                    // to the guy who sent it

                    if ((DType != DEST_MCAST) ||
                        ((DType == DEST_MCAST) &&
                         MCastAddrOnAO(ReceiveingAO, Dest, Src, IfIndex, LocalAddr))) {
                        UDPDeliver(ReceiveingAO, Src, UH->uh_src, RcvBuf, Size,
                                   OptInfo, AOTableHandle, &DeliverInfo);

                        //turn off chksum check, since it would have been already
                        //computed once


                        CTEGetLock(&AddrObjTableLock.Lock, &AOTableHandle);

                        if (UH->uh_xsum && firsttime && !(DeliverInfo.Flags & NEED_CHECKSUM)){
                           break;
                        }
                        DeliverInfo.Flags &= ~NEED_CHECKSUM;
                        firsttime=FALSE;

                    }
                    ReceiveingAO = GetNextAddrObj(&Search);
                } while (ReceiveingAO != NULL);
            } else
                UStats.us_noports++;
        }

    }

    CTEFreeLock(&AddrObjTableLock.Lock, AOTableHandle);

    return IP_SUCCESS;
}

//* UDPStatus - Handle a status indication.
//
//  This is the UDP status handler, called by IP when a status event
//  occurs. For most of these we do nothing. For certain severe status
//  events we will mark the local address as invalid.
//
//  Entry:  StatusType      - Type of status (NET or HW). NET status
//                              is usually caused by a received ICMP
//                              message. HW status indicate a HW
//                              problem.
//          StatusCode      - Code identifying IP_STATUS.
//          OrigDest        - If this is NET status, the original dest. of
//                              DG that triggered it.
//          OrigSrc         - "   "    "  "    "   , the original src.
//          Src             - IP address of status originator (could be local
//                              or remote).
//          Param           - Additional information for status - i.e. the
//                              param field of an ICMP message.
//          Data            - Data pertaining to status - for NET status, this
//                              is the first 8 bytes of the original DG.
//
//  Returns: Nothing
//
void
UDPStatus(uchar StatusType, IP_STATUS StatusCode, IPAddr OrigDest,
          IPAddr OrigSrc, IPAddr Src, ulong Param, void *Data)
{

    UDPHeader UNALIGNED *UH = (UDPHeader UNALIGNED *) Data;
    CTELockHandle AOTableHandle, AOHandle;
    AddrObj *AO;
    IPAddr WildCardSrc = NULL_IP_ADDR;

    if (StatusType == IP_NET_STATUS) {
        ushort destport = UH->uh_dest;
        ushort Srcport = UH->uh_src;

        //KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "UdpStatus: srcport %x OrigDest %x UHdest %x \n",Srcport,OrigDest, destport));

        CTEGetLock(&AddrObjTableLock.Lock, &AOTableHandle);

        AO = GetBestAddrObj(WildCardSrc, Srcport, PROTOCOL_UDP, 0);

        if (AO == NULL) {
            //Let us try with local addrss
            AO = GetBestAddrObj(OrigSrc, Srcport, PROTOCOL_UDP, 0);
        }
        if (AO != NULL) {

            CTEGetLock(&AO->ao_lock, &AOHandle);

            CTEFreeLock(&AddrObjTableLock.Lock, AOTableHandle);

            //KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "UdpStatus: Found AO %x Ip stat %x\n", AO, StatusCode));

            if (AO_VALID(AO) && (AO->ao_errorex != NULL)) {

                PErrorEx ErrEvent = AO->ao_errorex;
                PVOID ErrContext = AO->ao_errorexcontext;
                TA_IP_ADDRESS *TAaddress;

                REF_AO(AO);
                CTEFreeLock(&AO->ao_lock, AOHandle);

                TAaddress = ExAllocatePoolWithTag(NonPagedPool, sizeof(TA_IP_ADDRESS), 'uPCT');
                if (TAaddress) {
                    TAaddress->TAAddressCount = 1;
                    TAaddress->Address[0].AddressType = TDI_ADDRESS_TYPE_IP;
                    TAaddress->Address[0].AddressLength = TDI_ADDRESS_LENGTH_IP;

                    TAaddress->Address[0].Address[0].sin_port = destport;
                    TAaddress->Address[0].Address[0].in_addr = OrigDest;
                    memset(TAaddress->Address[0].Address[0].sin_zero,
                        0,
                        sizeof(TAaddress->Address[0].Address[0].sin_zero));

                    (*ErrEvent) (ErrContext, MapIPError(StatusCode, TDI_DEST_UNREACHABLE), TAaddress);

                    ExFreePool(TAaddress);

                }
                //KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL, "UdpStatus: Indicated error %x\n",MapIPError(StatusCode,TDI_DEST_UNREACHABLE) ));
                DELAY_DEREF_AO(AO);

                return;
            }
            CTEFreeLock(&AO->ao_lock, AOHandle);
        } else {

            CTEFreeLock(&AddrObjTableLock.Lock, AOTableHandle);
        }

        return;
    }
    // If this is a HW status, it could be because we've had an address go
    // away.
    if (StatusType == IP_HW_STATUS) {

        if (StatusCode == IP_ADDR_DELETED) {
            //
            // An address has gone away. OrigDest identifies the address.
            //

            //
            // Delete any security filters associated with this address
            //
            DeleteProtocolSecurityFilter(OrigDest, PROTOCOL_UDP);


            return;
        }
        if (StatusCode == IP_ADDR_ADDED) {

            //
            // An address has materialized. OrigDest identifies the address.
            // Data is a handle to the IP configuration information for the
            // interface on which the address is instantiated.
            //
            AddProtocolSecurityFilter(OrigDest, PROTOCOL_UDP,
                                      (NDIS_HANDLE) Data);
            return;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\samples\kmcancel\precomp.h ===
#include <ndis.h>
#include <cxport.h>
#include <ip.h>         // for IPRcvBuf
#include <ipinfo.h>     // for route-lookup defs
#include <ntddip.h>     // for \Device\Ip I/O control codes
#include <ntddtcp.h>    // for \Device\Tcp I/O control codes
#include <ipfltinf.h>   // for firewall defs
#include <ipfilter.h>   // for firewall defs
#include <tcpinfo.h>    // for TCP_CONN_*
#include <tdiinfo.h>    // for CONTEXT_SIZE, TDIObjectID
#include <tdistat.h>    // for TDI status codes
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\samples\kmcancel\kmcancel.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    kmcancel.c

Abstract:

    This module contains code to verify handling of IRP cancelation requests.

Author:

    Abolade Gbadegesin (aboladeg)   05-June-2000

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

#define THREAD_COUNT 10
#define REQUEST_COUNT 50
#define DD_TARGET_DEVICE_NAME   DD_IP_DEVICE_NAME
#define TARGET_IO_CONTROL_CODE  IOCTL_IP_RTCHANGE_NOTIFY_REQUEST

//
// Target driver state.
//

PDEVICE_OBJECT TargetDeviceObject = NULL;
PFILE_OBJECT TargetFileObject = NULL;

//
// Thread-management state.
//

ULONG KmcThreadCount;
KEVENT KmcStopEvent;
KSEMAPHORE KmcStopSemaphore;


//
// FUNCTION PROTOTYPES (alphabetically)
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
KmcRequestCompletionRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

VOID
KmcRequestThread(
    PVOID Context
    );

VOID
KmcUnloadDriver(
    IN PDRIVER_OBJECT  DriverObject
    );

VOID
KmcUpdateThread(
    PVOID Context
    );


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    ULONG i;
    NTSTATUS Status;
    HANDLE ThreadHandle;
    UNICODE_STRING UnicodeString;

    KdPrint(("DriverEntry\n"));
    DriverObject->DriverUnload = KmcUnloadDriver;
    KmcThreadCount = 0;
    KeInitializeEvent(&KmcStopEvent, NotificationEvent, FALSE);
    KeInitializeSemaphore(&KmcStopSemaphore, 0, MAXLONG);

    //
    // Obtain the target driver's device-object
    //

    RtlInitUnicodeString(&UnicodeString, DD_TARGET_DEVICE_NAME);
    Status =
        IoGetDeviceObjectPointer(
            &UnicodeString,
            SYNCHRONIZE|GENERIC_READ|GENERIC_WRITE,
            &TargetFileObject,
            &TargetDeviceObject
            );
    if (!NT_SUCCESS(Status)) {
        KdPrint(("DriverEntry: error %x getting IP object\n", Status));
        return Status;
    }

    ObReferenceObject(TargetDeviceObject);


    //
    // Start the request/update threads.
    // The request threads are responsible for issuing the I/O control
    // whose cancelation is being verified, and the update threads are
    // responsible for triggering completion of those I/O control requests
    // in order to highlight any potential race-conditions.
    //

    for (i = 0; i < THREAD_COUNT; i++) {
        Status =
            PsCreateSystemThread(
                &ThreadHandle,
                GENERIC_ALL,
                NULL,
                NULL,
                NULL,
                KmcUpdateThread,
                NULL
                );
        if (NT_SUCCESS(Status)) {
            ZwClose(ThreadHandle);
            ++KmcThreadCount;
        }
        Status =
            PsCreateSystemThread(
                &ThreadHandle,
                GENERIC_ALL,
                NULL,
                NULL,
                NULL,
                KmcRequestThread,
                NULL
                );
        if (NT_SUCCESS(Status)) {
            ZwClose(ThreadHandle);
            ++KmcThreadCount;
        }
    }

    return STATUS_SUCCESS;

} // DriverEntry

typedef struct _KMC_REQUEST {
    IO_STATUS_BLOCK IoStatus;
    PIRP Irp;
    ULONG ReferenceCount;
} KMC_REQUEST, *PKMC_REQUEST;


NTSTATUS
KmcRequestCompletionRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )
{
    PKMC_REQUEST Request = (PKMC_REQUEST)Context;
    if (InterlockedDecrement(&Request->ReferenceCount) == 0) {
        IoFreeIrp(Request->Irp);
        ExFreePool(Request);
    }
    return STATUS_MORE_PROCESSING_REQUIRED;
} // KmcCompletionRoutine


VOID
KmcRequestThread(
    PVOID Context
    )
{
    ULONG i, Index;
    LARGE_INTEGER Interval;
    PIRP Irp;
    PIO_STACK_LOCATION IrpSp;
    KIRQL OldIrql;
    PKMC_REQUEST Request, RequestArray[REQUEST_COUNT];

    for (; !KeReadStateEvent(&KmcStopEvent); ) {

        //
        // Queue a series of requests to the driver.
        //

        Index = 0;
        RtlZeroMemory(RequestArray, sizeof(RequestArray));
        for (i = 0; i < REQUEST_COUNT; i++) {
            Request = ExAllocatePool(NonPagedPool, sizeof(*Request));
            if (!Request) {
                continue;
            }
            RtlZeroMemory(Request, sizeof(*Request));

            Irp = IoAllocateIrp(TargetDeviceObject->StackSize, FALSE);
            if (!Irp) {
                continue;
            }
            Request->Irp = Irp;

            Irp->RequestorMode = KernelMode;
            Irp->Tail.Overlay.Thread = PsGetCurrentThread();
            Irp->Tail.Overlay.OriginalFileObject = TargetFileObject;
            IoSetCompletionRoutine(
                Irp,
                KmcRequestCompletionRoutine,
                Request,
                TRUE,
                TRUE,
                TRUE
                );

            IrpSp = IoGetNextIrpStackLocation(Irp);
            IrpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
            IrpSp->Parameters.DeviceIoControl.IoControlCode =
                TARGET_IO_CONTROL_CODE;
            IrpSp->DeviceObject = TargetDeviceObject;
            IrpSp->FileObject = TargetFileObject;

            Request->ReferenceCount = 2;
            RequestArray[Index++] = Request;
            IoCallDriver(TargetDeviceObject, Request->Irp);
        }

        //
        // Delay execution for a short interval, and cancel the requests.
        //

        Interval.QuadPart = -10 * 1000 * 50;
        KeDelayExecutionThread(KernelMode, FALSE, &Interval);

        for (i = 0; i < REQUEST_COUNT; i++) {
            if (Request = RequestArray[i]) {
                IoCancelIrp(Request->Irp);
                if (InterlockedDecrement(&Request->ReferenceCount) == 0) {
                    IoFreeIrp(Request->Irp);
                    ExFreePool(Request);
                }
            }
        }
    }

    KeReleaseSemaphore(&KmcStopSemaphore, 0, 1, FALSE);

} // KmcRequestThread


VOID
KmcUnloadDriver(
    IN PDRIVER_OBJECT DriverObject
    )
{
    KdPrint(("KmcUnloadDriver\n"));

    //
    // Signal all threads to stop, and wait for them to exit.
    //

    KeSetEvent(&KmcStopEvent, 0, FALSE);
    while (KmcThreadCount--) {
        KeWaitForSingleObject(
            &KmcStopSemaphore, Executive, KernelMode, FALSE, NULL
            );
    }

    //
    // Release references to the IP device object
    //

    ObDereferenceObject(TargetFileObject);
    ObDereferenceObject(TargetDeviceObject);

} // KmcUnloadDriver


extern
VOID
LookupRoute(
    IPRouteLookupData* RouteLookupData,
    IPRouteEntry* RouteEntry
    );

VOID
KmcUpdateThread(
    PVOID Context
    )
{
    KEVENT Event;
    LARGE_INTEGER Interval;
    IO_STATUS_BLOCK IoStatus;
    PIRP Irp;
    IPRouteEntry RouteEntry;
    IPRouteLookupData RouteLookupData;
    NTSTATUS Status;

    //
    // Retrieve information from IP for use in triggering route-changes.
    //

    RtlZeroMemory(&RouteEntry, sizeof(RouteEntry));
    RouteLookupData.Version = 0;
    RouteLookupData.SrcAdd = 0;
    RouteLookupData.DestAdd = 0x100000a; // 10.0.0.1
    LookupRoute(&RouteLookupData, &RouteEntry);

    RouteEntry.ire_dest = 0x100000a; // 10.0.0.1
    RouteEntry.ire_mask = 0xffffffff;
    RouteEntry.ire_proto = IRE_PROTO_NETMGMT;

    //
    // Repeatedly issue changes to the IP routing table, until told to exit.
    //

    KeInitializeEvent(&Event, SynchronizationEvent, FALSE);
    for (; !KeReadStateEvent(&KmcStopEvent); ) {

        Interval.QuadPart = -10 * 1000 * 50;
        KeDelayExecutionThread(KernelMode, FALSE, &Interval);

        Irp =
            IoBuildDeviceIoControlRequest(
                IOCTL_IP_SET_ROUTEWITHREF,
                TargetDeviceObject,
                &RouteEntry,
                sizeof(RouteEntry),
                NULL,
                0,
                FALSE,
                &Event,
                &IoStatus
                );
        if (!Irp) { continue; }
        Status = IoCallDriver(TargetDeviceObject, Irp);
        if (Status == STATUS_PENDING) {
            KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
        }
    }

    KeReleaseSemaphore(&KmcStopSemaphore, 0, 1, FALSE);
        
} // KmcUpdateThread
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\samples\limitbcast\limitbcast.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    limitbcast.c

Abstract:

    This module implements a program demonstrating the use of the
    SIO_LIMIT_BROADCASTS socket option. The default behavior of the system
    is to send limited broadcasts (i.e. broadcasts sent to 255.255.255.255)
    on all local interfaces, which violates the IETF Host Requirements stating
    that limited broadcasts appear only on the sending socket's interface.
    This socket option allows an application to specify that a socket's
    limited-broadcasts obey the traditional semantics.

Author:

    Abolade Gbadegesin (aboladeg)   29-October-1998

Revision History:

--*/

#include <winsock2.h>
#include <mstcpip.h>
#include <stdio.h>
#include <stdlib.h>

int __cdecl
main(
    int argc,
    char* argv[]
    )
{
    SOCKADDR_IN DestAddrIn;
    SOCKADDR_IN LocalAddrIn;
    ULONG Option;
    SOCKET Socket;
    WSADATA WsaData;

    //
    // Check command-line arguments
    //

    ZeroMemory(&LocalAddrIn, sizeof(LocalAddrIn));
    LocalAddrIn.sin_family = AF_INET;
    if (argc != 3 ||
        !(LocalAddrIn.sin_addr.s_addr = inet_addr(argv[1])) ||
        !(LocalAddrIn.sin_port = ntohs((USHORT)atol(argv[2])))) {
        printf("Usage: %s <local IP address> <target port>\n", argv[0]);
        return 0;
    }

    //
    // Initialize Windows sockets, create a UDP socket,
    // and enable broadcasts on the socket.
    // Then bind it to the specified local IP address.
    //

    WSAStartup(0x0202, &WsaData);
    if ((Socket = socket(AF_INET, SOCK_DGRAM, 0)) == INVALID_SOCKET) {
        printf("socket: %d\n", WSAGetLastError());
        return 0;
    }
    Option = 1;
    if (setsockopt(
            Socket, SOL_SOCKET, SO_BROADCAST, (PCHAR)&Option, sizeof(Option)
            ) == SOCKET_ERROR) {
        printf("setsockopt: %d\n", WSAGetLastError());
    }
    if (bind(Socket, (PSOCKADDR)&LocalAddrIn, sizeof(LocalAddrIn))
            == SOCKET_ERROR) {
        printf("bind: %d\n", WSAGetLastError());
        return 0;
    }

    //
    // Initialize the destination address,
    // and enter a loop where we prompt for the limit-broadcasts setting
    // and send a message using the specified setting.
    //

    ZeroMemory(&DestAddrIn, sizeof(DestAddrIn));
    DestAddrIn.sin_family = AF_INET;
    DestAddrIn.sin_addr.s_addr = INADDR_BROADCAST;
    DestAddrIn.sin_port = LocalAddrIn.sin_port;
    do {
        ULONG Length;
        ULONG LimitBroadcasts;
        printf("Enter a value (0 or 1) for the SIO_LIMIT_BROADCASTS option.\n");
        printf("bcast> ");
        if (!scanf("%d", &LimitBroadcasts)) {
            break;
        }
        if (WSAIoctl(
                Socket, SIO_LIMIT_BROADCASTS,
                (PCHAR)&LimitBroadcasts, sizeof(LimitBroadcasts),
                NULL, 0, &Length, NULL, NULL
                ) == SOCKET_ERROR) {
            printf("WSAIoctl: %d\n", WSAGetLastError());
        }
        if (sendto(
                Socket,
                (PCHAR)&DestAddrIn,
                sizeof(DestAddrIn),
                0,
                (PSOCKADDR)&DestAddrIn,
                sizeof(DestAddrIn)
                ) == SOCKET_ERROR) {
            printf("sendto: %d\n", WSAGetLastError());
        }
    } while(TRUE);
    closesocket(Socket);
    WSACleanup();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\samples\connopt\connopt.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    connotp.c

Abstract:

    This module demonstrates the use of the SO_CONNOPT socket option
    to include IP-layer options in outgoing TCP and UDP messages.
    It allows a TCP connection to be established to a specified target,
    such that all segments for the connection contain a source-route.

Author:

    Abolade Gbadegesin (aboladeg)   7-October-1999

Revision History

--*/

#include <winsock2.h>
#include <mswsock.h>
#include <stdio.h>
#include <stdlib.h>

#define IP_OPT_LSRR 0x83

int __cdecl
main(
    int argc,
    char* argv[]
    )
{
    SOCKET Socket;
    SOCKADDR_IN SockAddrIn;
    WSADATA wd;

    //
    // Check arguments, initialize Windows Sockets,
    // and create a new TCP socket for the outgoing connection.
    //

    if (argc < 3) {
        printf("Usage: connopt <server-IP-address> <server-port> <hop>*\n");
        return 0;
    }
    WSAStartup(0x202, &wd);
    Socket = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
    if (Socket == INVALID_SOCKET) {
        printf("socket: %d\n", WSAGetLastError());
    } else {

        //
        // Bind the socket in preparation for constructing the source route.
        //

        SockAddrIn.sin_family = AF_INET;
        SockAddrIn.sin_addr.s_addr = INADDR_ANY;
        SockAddrIn.sin_port = 0;
        if (bind(
                Socket, (PSOCKADDR)&SockAddrIn, sizeof(SockAddrIn)
                ) == SOCKET_ERROR) {
            printf("bind: %d\n", WSAGetLastError());
        } else {
            ULONG i;
            UCHAR IpOptions[256] = {IP_OPT_LSRR, 0, 4, 0};
            ULONG IpOptionsLength = 4;

            //
            // Construct a source route from the command-line parameters,
            // in the format in which it would appear in the IP header.
            // Install the resulting buffer using SO_CONNOPT.
            //

            for (i = 0; i < (ULONG)argc - 3; i++) {
                *(ULONG UNALIGNED *)(IpOptions + 3 + i * 4) =
                    inet_addr(argv[i + 3]);
            }
            {
                *(ULONG UNALIGNED *)(IpOptions + 3 + i * 4) =
                    inet_addr(argv[1]);
                i++;
            }
            IpOptionsLength += i * 4;
            IpOptions[1] = (UCHAR)IpOptionsLength - 1;
            IpOptions[IpOptionsLength - 1] = 0;
            if (setsockopt(
                    Socket, SOL_SOCKET, SO_CONNOPT, IpOptions, IpOptionsLength
                    ) == SOCKET_ERROR) {
                printf("setsockopt: %d\n", WSAGetLastError());
            } else {

                //
                // Establish a connection the the target,
                // and send a few messages.
                //

                SockAddrIn.sin_family = AF_INET;
                SockAddrIn.sin_addr.s_addr = inet_addr(argv[1]);
                SockAddrIn.sin_port = htons((SHORT)atol(argv[2]));
                if (connect(
                        Socket, (PSOCKADDR)&SockAddrIn, sizeof(SockAddrIn)
                        ) == SOCKET_ERROR) {
                    printf("connect: %d\n", WSAGetLastError());
                } else {
                    CHAR Message[4096] = "Text string.\n";
                    for (i = 0; i < 20; i++) {
                        send(Socket, Message, sizeof(Message), 0);
                    }
                    shutdown(Socket, SD_SEND);
                    closesocket(Socket);
                }
            }
        }
    }
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\samples\mcastloop\mcastloop.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    mcastloop.c

Abstract:

    This module demonstrates the working of loopback support for IP multicast.
    It consists of a main thread which joins a multicast group and listens
    for messages, as well as a sending thread which sends to the same group.

Author:

    Abolade Gbadegesin (aboladeg)   3-March-2000

Revision History:

--*/

#include <winsock2.h>
#include <ws2tcpip.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

ULONG LocalAddress;
ULONG MulticastAddress;
USHORT MulticastPort;

ULONG WINAPI
SendThread(
    PVOID Unused
    )
{
    SOCKADDR_IN SockAddr;
    SOCKET Socket;

    //
    // Create a new UDP socket, bind it to any local IP address,
    // and set the multicast interface on which to receive messages.
    //

    Socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    SockAddr.sin_family = AF_INET;
    SockAddr.sin_port = 0;
    SockAddr.sin_addr.s_addr = INADDR_ANY;
    if (bind(
            Socket, (PSOCKADDR)&SockAddr, sizeof(SOCKADDR_IN)
            ) == SOCKET_ERROR) {
        printf("SendThread: bind: %d\n", WSAGetLastError());
    } else {
        if (setsockopt(
                Socket, IPPROTO_IP, IP_MULTICAST_IF, (PCHAR)&LocalAddress,
                sizeof(LocalAddress)
                ) == SOCKET_ERROR) {
            printf("SendThread: setsockopt: %d\n", WSAGetLastError());
        } else {
            ULONG i;
            CHAR Buffer[64];

            //
            // Generate messages until interrupted.
            //

            SockAddr.sin_port = MulticastPort;
            SockAddr.sin_addr.s_addr = MulticastAddress;
            for (i = 0;; i++, Sleep(1000)) {
                sprintf(Buffer, "Text string %d.", i);
                if (sendto(
                        Socket, Buffer, sizeof(Buffer), 0,
                        (PSOCKADDR)&SockAddr, sizeof(SockAddr)
                        ) == SOCKET_ERROR) {
                    printf("SendThread: sendto: %d\n", WSAGetLastError());
                } else {
                    printf("SendThread: %s\n", Buffer);
                }
            }
        }
    }
    return 0;
}

int __cdecl
main(
    int argc,
    char* argv[]
    )
{
    HANDLE Handle;
    ULONG Length;
    SOCKET Socket;
    SOCKADDR_IN SockAddr;
    ULONG ThreadId;
    WSADATA wd;

    //
    // Check arguments, initialize Windows Sockets, and bind it to the local
    // IP address specified as the multicast source interface.
    //

    if (argc != 3) {
        printf("Usage: %s <local IP address> <multicast IP address>\n", argv[0]);
        return 0;
    }

    WSAStartup(0x202, &wd);
    Socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    SockAddr.sin_family = AF_INET;
    SockAddr.sin_port = 0;
    SockAddr.sin_addr.s_addr = inet_addr(argv[1]);
    if (bind(
            Socket, (PSOCKADDR)&SockAddr, sizeof(SOCKADDR_IN)
            ) == SOCKET_ERROR) {
        printf("bind: %d\n", WSAGetLastError());
    } else {

        //
        // Retrieve the local IP address selected for the socket,
        // and use it to request multicast group membership.
        //

        Length = sizeof(SOCKADDR_IN);
        if (getsockname(
                Socket, (PSOCKADDR)&SockAddr, &Length
                ) == SOCKET_ERROR) {
            printf("getsockname: %d\n", WSAGetLastError());
        } else {
            struct ip_mreq IpMreq;
            IpMreq.imr_multiaddr.s_addr = inet_addr(argv[2]);
            IpMreq.imr_interface.s_addr = INADDR_ANY;
            if (setsockopt(
                    Socket, IPPROTO_IP, IP_ADD_MEMBERSHIP, (PCHAR)&IpMreq,
                    sizeof(IpMreq)
                    ) == SOCKET_ERROR) {
                printf("setsockopt: %d\n", WSAGetLastError());
            } else {

                //
                // Start the thread which will send multicast packets,
                // and begin receiving input.
                //

                MulticastAddress = inet_addr(argv[2]);
                MulticastPort = SockAddr.sin_port;
                LocalAddress = SockAddr.sin_addr.s_addr;
                Handle = CreateThread(NULL, 0, SendThread, NULL, 0, &ThreadId);
                if (!Handle) {
                    printf("CreateThread: %d\n", GetLastError());
                } else {
                    CHAR Buffer[576];
                    ULONG BufferLength;
                    CloseHandle(Handle);

                    for (;; Sleep(1000)) {
                        Length = sizeof(SOCKADDR_IN);
                        ZeroMemory(Buffer, sizeof(Buffer));
                        BufferLength =
                            recvfrom(
                                Socket, Buffer, sizeof(Buffer), 0,
                                (PSOCKADDR)&SockAddr, &Length
                                );
                        if (BufferLength == SOCKET_ERROR) {
                            printf("recvfrom: %d\n", WSAGetLastError());
                        } else {
                            printf("ReceiveThread: %s\n", Buffer);
                        }
                    }
                }
            }
        }
    }
    closesocket(Socket);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\samples\rcvall\rcvall.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    rcvall.c

Abstract:

    This module demonstrates the use of the SIO_RCVALL socket I/O control
    to enable promiscuous reception.

Author:

    Abolade Gbadegesin (aboladeg)   28-April-2000

Revision History:

--*/

#include <winsock2.h>
#include <mstcpip.h>
#include <stdio.h>
#include <stdlib.h>
#include <process.h>

#define IO_CONTROL_THREADS 20
#define SENDS_PER_ROUND 5000
#define IO_CONTROLS_PER_ROUND 500

CRITICAL_SECTION CriticalSection;
SOCKET Socket;

VOID __cdecl
IoControlThread(
    PVOID Parameter
    )
{
    HANDLE ConsoleHandle;
    CONSOLE_SCREEN_BUFFER_INFO Csbi;
    ULONG i, j;
    ULONG Length;
    ULONG Option;

    //
    // Enter an infinite loop in which promiscuous reception is repeatedly
    // enabled and disabled.
    //

    ConsoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);
    GetConsoleScreenBufferInfo(ConsoleHandle, &Csbi);
    Csbi.dwCursorPosition.X = 40;

    for (i = 0;;i++) {

        EnterCriticalSection(&CriticalSection);
        if (PtrToUlong(Parameter) == 0) {
            SetConsoleCursorPosition(ConsoleHandle, Csbi.dwCursorPosition);
            printf("IoControlThread: round %u", i);
        }
        LeaveCriticalSection(&CriticalSection);

        for (j = 0; j < IO_CONTROLS_PER_ROUND; j++) {
            Option = 1;
            WSAIoctl(
                Socket, SIO_RCVALL, &Option, sizeof(Option), NULL, 0,
                &Length, NULL, NULL
                );
            Option = 0;
            WSAIoctl(
                Socket, SIO_RCVALL, &Option, sizeof(Option), NULL, 0,
                &Length, NULL, NULL
                );
        }
    }
}

int __cdecl
main(
    int argc,
    char* argv[]
    )
{
    HANDLE ConsoleHandle;
    CONSOLE_SCREEN_BUFFER_INFO Csbi;
    ULONG i, j;
    ULONG Length;
    SOCKADDR_IN SockAddrIn;
    PSOCKADDR SockAddrp = (PSOCKADDR)&SockAddrIn;
    SOCKET UdpSocket;
    WSADATA wd;

    __try {
        InitializeCriticalSection(&CriticalSection);
    } __except(EXCEPTION_EXECUTE_HANDLER) {
        printf("InitializeCriticalSection: %x\n", GetExceptionCode());
        return 0;
    }

    WSAStartup(0x202, &wd);

    //
    // Create a datagram socket, connect it to the broadcast address,
    // and retrieve the assigned address to determine the 'best' interface
    // to use in binding our raw socket.
    //

    Socket = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
    if (Socket == INVALID_SOCKET) {
        printf("socket: %d\n", WSAGetLastError());
        return 0;
    }
    ZeroMemory(&SockAddrIn, sizeof(SockAddrIn));
    SockAddrIn.sin_family = AF_INET;
    SockAddrIn.sin_port = 0;
    SockAddrIn.sin_addr.s_addr = htonl(INADDR_BROADCAST);
    if (connect(Socket, SockAddrp, sizeof(SockAddrIn)) == SOCKET_ERROR) {
        printf("connect: %d\n", WSAGetLastError());
        return 0;
    }
    Length = sizeof(SockAddrIn);
    if (getsockname(Socket, SockAddrp, &Length) == SOCKET_ERROR) {
        printf("getsockname: %d\n", WSAGetLastError());
        return 0;
    }
    printf(
        "addr=%s port=%u\n",
        inet_ntoa(SockAddrIn.sin_addr), SockAddrIn.sin_port
        );
    closesocket(Socket);

    //
    // Create a raw socket and bind it to the address retrieved above.
    //

    Socket = socket(AF_INET, SOCK_RAW, IPPROTO_RAW);
    if (Socket == INVALID_SOCKET) {
        printf("socket: %d\n", WSAGetLastError());
        return 0;
    }
    if (bind(Socket, SockAddrp, sizeof(SockAddrIn)) == SOCKET_ERROR) {
        printf("bind: %d\n", WSAGetLastError());
        return 0;
    }

    //
    // Launch the threads which will continuously enable and disable
    // promiscuous reception.
    //

    for (i = 0; i < IO_CONTROL_THREADS; i++) {
        _beginthread(IoControlThread, 0, UlongToPtr(i));
    }

    //
    // Enter a loop in which we continously send a small amount of data
    // to our own raw socket, just to exercise TCP/IP's synchronization.
    //

    ConsoleHandle = GetStdHandle(STD_OUTPUT_HANDLE);
    GetConsoleScreenBufferInfo(ConsoleHandle, &Csbi);
    Csbi.dwCursorPosition.X = 0;

    for (i = 0;; i++) {

        EnterCriticalSection(&CriticalSection);
        SetConsoleCursorPosition(ConsoleHandle, Csbi.dwCursorPosition);
        printf("Main thread: round %u", i);
        LeaveCriticalSection(&CriticalSection);

        for (j = 0; j < SENDS_PER_ROUND; j++) {
            sendto(Socket, (PCHAR)SockAddrp, Length, 0, SockAddrp, Length);
        }
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\samples\rtchange\rtchange.c ===
/*++

Copyright (c) 2000, Microsoft Corporation

Module Name:

    rtchange.c

Abstract:

    This module contains a program demonstrating the use of the TCP/IP driver's
    route-change notification facilities.

Author:

    Abolade Gbadegesin (aboladeg)   15-April-2000

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <winsock2.h>
#include <stdio.h>
#include <stdlib.h>
#include <ntddip.h>
#include <ipinfo.h>

char*
ntoa(
    ULONG IpAddress
    )
{
    return inet_ntoa(*(struct in_addr*)&IpAddress);
}

NTSTATUS
NotifyRouteChange(
    HANDLE FileHandle,
    ULONG IoControlCode,
    ULONG NotifyIpAddress,
    BOOLEAN OutputRequired
    )
{
    HANDLE EventHandle;
    PVOID InputBuffer;
    ULONG InputBufferLength;
    IO_STATUS_BLOCK IoStatus;
    IPNotifyData NotifyData = {0};
    IPRouteNotifyOutput NotifyOutput = {0};
    PVOID OutputBuffer;
    ULONG OutputBufferLength;
    NTSTATUS Status;

    if (NotifyIpAddress == INADDR_NONE) {
        InputBuffer = NULL;
        InputBufferLength = 0;
    } else if (NotifyIpAddress == INADDR_ANY) {
        NotifyData.Add = 0;
        InputBuffer = &NotifyData;
        InputBufferLength = sizeof(NotifyData);
    } else {
        NotifyData.Add = NotifyIpAddress;
        InputBuffer = &NotifyData;
        InputBufferLength = sizeof(NotifyData);
    }

    if (OutputRequired) {
        OutputBuffer = &NotifyOutput;
        OutputBufferLength = sizeof(NotifyOutput);
    } else {
        OutputBuffer = NULL;
        OutputBufferLength = 0;
    }

    Status =
        NtCreateEvent(
            &EventHandle, EVENT_ALL_ACCESS, NULL,
            SynchronizationEvent, FALSE
            );
    if (!NT_SUCCESS(Status)) {
        printf("NtCreateEvent=%x\n", Status);
    } else {

        Status =
            NtDeviceIoControlFile(
                FileHandle,
                EventHandle,
                NULL,
                NULL,
                &IoStatus,
                IOCTL_IP_RTCHANGE_NOTIFY_REQUEST,
                InputBuffer,
                InputBufferLength,
                OutputBuffer,
                OutputBufferLength
                );
        if (Status == STATUS_PENDING) {
            printf("NtDeviceIoControlFile=%x, waiting\n", Status);
            NtWaitForSingleObject(EventHandle, FALSE, NULL);
            Status = IoStatus.Status;
        }
        printf("NtDeviceIoControlFile=%x\n", Status);
        NtClose(EventHandle);

        if (NT_SUCCESS(Status) && OutputRequired) {
            printf("\tDestination:  %s\n", ntoa(NotifyOutput.irno_dest));
            printf("\tMask:         %s\n", ntoa(NotifyOutput.irno_mask));
            printf("\tNext-hop:     %s\n", ntoa(NotifyOutput.irno_nexthop));
            printf("\tProtocol:     %d\n", NotifyOutput.irno_proto);
            printf("\tIndex:        %d\n", NotifyOutput.irno_ifindex);
        }
    }
    return Status;
}

typedef struct {
    IO_STATUS_BLOCK IoStatus;
    IPRouteNotifyOutput NotifyOutput;
} ROUTE_NOTIFY_CONTEXT, *PROUTE_NOTIFY_CONTEXT;

VOID NTAPI
NotifyRouteCompletionRoutine(
    PVOID Context,
    PIO_STATUS_BLOCK IoStatus,
    ULONG Reserved
    )
{
    PROUTE_NOTIFY_CONTEXT NotifyContext = (PROUTE_NOTIFY_CONTEXT)Context;
    printf("NotifyRouteCompletionRoutine(%p, %x)\n", Context, IoStatus->Status);
    if (NT_SUCCESS(IoStatus->Status)) {
        PIPRouteNotifyOutput NotifyOutput = &NotifyContext->NotifyOutput;
        printf("\tDestination:  %s\n", ntoa(NotifyOutput->irno_dest));
        printf("\tMask:         %s\n", ntoa(NotifyOutput->irno_mask));
        printf("\tNext-hop:     %s\n", ntoa(NotifyOutput->irno_nexthop));
        printf("\tProtocol:     %d\n", NotifyOutput->irno_proto);
        printf("\tIndex:        %d\n", NotifyOutput->irno_ifindex);
    }
}

ULONG
QueueNotifyRouteChange(
    HANDLE FileHandle,
    IPNotifyVersion Version,
    ULONG NotificationCount
    )
{
    ULONG i;
    PVOID InputBuffer;
    ULONG InputBufferLength;
    PROUTE_NOTIFY_CONTEXT NotifyContext;
    IPNotifyData NotifyData = {0};
    PVOID OutputBuffer;
    ULONG OutputBufferLength;
    NTSTATUS Status;

    NotifyData.Version = Version;
    NotifyData.Add = 0;
    InputBuffer = &NotifyData;
    InputBufferLength = sizeof(NotifyData);

    for (i = 0; i < NotificationCount; i++) {
        NotifyContext = (PROUTE_NOTIFY_CONTEXT)malloc(sizeof(*NotifyContext));
        if (!NotifyContext) {
            printf("QueueNotifyRouteChange: malloc=<null>\n");
            break;
        } else {
            printf("QueueNotifyRouteChange: queuing %p\n", NotifyContext);
            ZeroMemory(NotifyContext, sizeof(*NotifyContext));
            Status =
                NtDeviceIoControlFile(
                    FileHandle,
                    NULL,
                    NotifyRouteCompletionRoutine,
                    NotifyContext,
                    &NotifyContext->IoStatus,
                    IOCTL_IP_RTCHANGE_NOTIFY_REQUEST,
                    InputBuffer,
                    InputBufferLength,
                    &NotifyContext->NotifyOutput,
                    sizeof(NotifyContext->NotifyOutput)
                    );
            printf("NtDeviceIoControlFile=%x\n", Status);
        }
    }

    return i;
}

int __cdecl
main(
    int argc,
    char* argv[]
    )
{
    HANDLE FileHandle;
    IO_STATUS_BLOCK IoStatus;
    OBJECT_ATTRIBUTES ObjectAttributes;
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;

    //
    // Open a handle to the IP device-object.
    //

    RtlInitUnicodeString(&UnicodeString, DD_IP_DEVICE_NAME);
    InitializeObjectAttributes(
        &ObjectAttributes,
        &UnicodeString,
        OBJ_CASE_INSENSITIVE,
        NULL,
        NULL
        );
    Status =
        NtCreateFile(
            &FileHandle,
            GENERIC_READ|GENERIC_WRITE|SYNCHRONIZE,
            &ObjectAttributes,
            &IoStatus,
            NULL,
            0,
            FILE_SHARE_READ|FILE_SHARE_WRITE,
            FILE_OPEN_IF,
            0,
            NULL,
            0
            );
    if (!NT_SUCCESS(Status)) {
        printf("NtCreateFile=%x\n", Status);
        return 0;
    }

    //
    // Continually prompt for instructions until interrupted.
    //

    for (;;) {
        ULONG Selection;
        BOOLEAN OutputRequired = TRUE;
        IPNotifyVersion Version = IPNotifySynchronization;

        printf("Simple route-change notification:\n");
        printf("\t1.  Submit NULL route-change request [no output]\n");
        printf("\t2.  Submit NULL route-change request\n");
        printf("\t3.  Submit general route-change request [no output]\n");
        printf("\t4.  Submit general route-change request\n");
        printf("\t5.  Submit specific route-change request [no output]\n");
        printf("\t6.  Submit specific route-change request\n");

        printf("Extended route-change notification:\n");
        printf("\t7.  Submit NULL route-change request [no output]\n");
        printf("\t8.  Submit NULL route-change request\n");
        printf("\t9.  Submit general route-change request [no output]\n");
        printf("\t10. Submit general route-change request\n");
        printf("\t11. Submit specific route-change request [no output]\n");
        printf("\t12. Submit specific route-change request\n");

        printf("\t13. Submit multiple general route-change requests\n");
        printf("\t    using 'notification' semantics.\n");
        printf("\t14. Submit multiple general route-change requests\n");
        printf("\t    using 'synchronization' semantics.\n");

        printf("\nEnter selection: ");
        if (!scanf("%d", &Selection)) {
            break;
        }
        switch(Selection) {
            case 1:
                OutputRequired = FALSE;
            case 2: {
                Status =
                    NotifyRouteChange(
                        FileHandle, IOCTL_IP_RTCHANGE_NOTIFY_REQUEST,
                        INADDR_NONE, OutputRequired
                        );
                printf("NotifyRouteChange=%x\n", Status);
                break;
            }
            case 3:
                OutputRequired = FALSE;
            case 4: {
                Status =
                    NotifyRouteChange(
                        FileHandle, IOCTL_IP_RTCHANGE_NOTIFY_REQUEST,
                        INADDR_ANY, OutputRequired
                        );
                printf("NotifyRouteChange=%x\n", Status);
                break;
            }
            case 5:
                OutputRequired = FALSE;
            case 6: {
                UCHAR Destination[16];

                printf("Enter destination: ");
                if (!scanf("%s", Destination)) {
                    break;
                }
                Status =
                    NotifyRouteChange(
                        FileHandle, IOCTL_IP_RTCHANGE_NOTIFY_REQUEST,
                        inet_addr(Destination), OutputRequired
                        );
                printf("NotifyRouteChange=%x\n", Status);
                break;
            }
            case 7:
                OutputRequired = FALSE;
            case 8: {
                Status =
                    NotifyRouteChange(
                        FileHandle, IOCTL_IP_RTCHANGE_NOTIFY_REQUEST_EX,
                        INADDR_NONE, OutputRequired
                        );
                printf("NotifyRouteChange=%x\n", Status);
                break;
            }
            case 9:
                OutputRequired = FALSE;
            case 10: {
                Status =
                    NotifyRouteChange(
                        FileHandle, IOCTL_IP_RTCHANGE_NOTIFY_REQUEST_EX,
                        INADDR_ANY, OutputRequired
                        );
                printf("NotifyRouteChange=%x\n", Status);
                break;
            }
            case 11:
                OutputRequired = FALSE;
            case 12: {
                UCHAR Destination[16];

                printf("Enter destination: ");
                if (!scanf("%s", Destination)) {
                    break;
                }
                Status =
                    NotifyRouteChange(
                        FileHandle, IOCTL_IP_RTCHANGE_NOTIFY_REQUEST_EX,
                        inet_addr(Destination), OutputRequired
                        );
                printf("NotifyRouteChange=%x\n", Status);
                break;
            }

            case 13:
                Version = IPNotifyNotification;
            case 14: {
                LARGE_INTEGER Timeout;
                ULONG NotificationCount = 0;

                printf("Enter number of requests to queue: ");
                if (!scanf("%d", &NotificationCount)) {
                    break;
                }

                NotificationCount =
                    QueueNotifyRouteChange(
                        FileHandle, Version, NotificationCount
                        );

                for (; NotificationCount; --NotificationCount) {
                    Timeout.LowPart = 0;
                    Timeout.HighPart = MINLONG;
                    NtDelayExecution(TRUE, &Timeout);
                }

                break;
            }
        }
    }
    
    NtClose(FileHandle);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\exe\main.c ===
/*++

Copyright (c) 1991  Microsoft Corporation

Module Name:

    MAIN.C

Abstract:

    This is the main routine for the TCP/IP Services.

Author:

    David Treadwell (davidtr)   7-27-93

Revision History:

--*/

//
// INCLUDES
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winsvc.h>             // Service control APIs
#include <rpc.h>

#include "tcpsvcs.h"

//
// Service entry points -- thunks to real service entry points.
//

VOID
StartDns (
    IN DWORD argc,
    IN LPTSTR argv[]
    );

VOID
StartSimpTcp (
    IN DWORD argc,
    IN LPTSTR argv[]
    );

VOID
StartDhcpServer (
    IN DWORD argc,
    IN LPTSTR argv[]
    );

VOID
StartFtpSvc (
    IN DWORD argc,
    IN LPTSTR argv[]
    );

VOID
StartLpdSvc (
    IN DWORD argc,
    IN LPTSTR argv[]
    );

VOID
StartBinlSvc (
    IN DWORD argc,
    IN LPTSTR argv[]
    );

//
// Local function used by the above to load and invoke a service DLL.
//

VOID
TcpsvcsStartService (
    IN LPTSTR DllName,
    IN DWORD argc,
    IN LPTSTR argv[]
    );

//
// Used if the services Dll or entry point can't be found
//

VOID
AbortService(
    LPWSTR  ServiceName,
    DWORD   Error
    );

//
// Dispatch table for all services. Passed to NetServiceStartCtrlDispatcher.
//
// Add new service entries here and in the DLL name list.
//

SERVICE_TABLE_ENTRY TcpServiceDispatchTable[] = {
                        { TEXT("Dns"),            StartDns         },
                        { TEXT("SimpTcp"),        StartSimpTcp     },
                        { TEXT("DhcpServer"),     StartDhcpServer  },
                        { TEXT("FtpSvc"),         StartFtpSvc      },
                        { TEXT("LpdSvc"),         StartLpdSvc      },
                        { TEXT("BinlSvc"),        StartBinlSvc     },
                        { NULL,                   NULL             }
                        };

//
// DLL names for all services.
//

#define DNS_DLL TEXT("dnssvc.dll")
#define SIMPTCP_DLL TEXT("simptcp.dll")
#define DHCP_SERVER_DLL TEXT("dhcpssvc.dll")
#define FTPSVC_DLL TEXT("ftpsvc.dll")
#define LPDSVC_DLL TEXT("lpdsvc.dll")
#define BINLSVC_DLL TEXT("binlsvc.dll")

//
// Global parameter data passed to each service.
//

TCPSVCS_GLOBAL_DATA TcpsvcsGlobalData;

//
// Global parameters to manage RPC server listen.
//

DWORD TcpSvcsGlobalNumRpcListenCalled = 0;
CRITICAL_SECTION TcpsvcsGlobalRpcListenCritSect;


DWORD
TcpsvcStartRpcServerListen(
    VOID
    )
/*++

Routine Description:

    This function starts RpcServerListen for this process. The first
    service that is calling this function will actually start the
    RpcServerListen, subsequent calls are just noted down in num count.

Arguments:

    None.

Return Value:

    None.

--*/
{

    RPC_STATUS Status = RPC_S_OK;

    //
    // LOCK global data.
    //

    EnterCriticalSection( &TcpsvcsGlobalRpcListenCritSect );

    //
    // if this is first RPC service, start RPC server listen.
    //

    if( TcpSvcsGlobalNumRpcListenCalled == 0 ) {

        Status = RpcServerListen(
                    1,                              // minimum num threads.
                    RPC_C_LISTEN_MAX_CALLS_DEFAULT, // max concurrent calls.
                    TRUE );                         // don't wait

    }

    TcpSvcsGlobalNumRpcListenCalled++;

    //
    // UNLOCK global data.
    //

    LeaveCriticalSection( &TcpsvcsGlobalRpcListenCritSect );

    return( Status );
}


DWORD
TcpsvcStopRpcServerListen(
    VOID
    )
/*++

Routine Description:

Arguments:

    None.

Return Value:

    None.

--*/
{
    RPC_STATUS Status = RPC_S_OK;

    //
    // LOCK global data.
    //

    EnterCriticalSection( &TcpsvcsGlobalRpcListenCritSect );

    if( TcpSvcsGlobalNumRpcListenCalled != 0 ) {

        TcpSvcsGlobalNumRpcListenCalled--;

        //
        // if this is last RPC service shutting down, stop RPC server
        // listen.
        //

        if( TcpSvcsGlobalNumRpcListenCalled == 0 ) {

            Status = RpcMgmtStopServerListening(0);

            //
            // wait for all RPC threads to go away.
            //

            if( Status == RPC_S_OK) {
                Status = RpcMgmtWaitServerListen();
            }
        }

    }

    //
    // UNLOCK global data.
    //

    LeaveCriticalSection( &TcpsvcsGlobalRpcListenCritSect );

    return( Status );

}


VOID __cdecl
main(
    VOID
    )

/*++

Routine Description:

    This is the main routine for the LANMan services.  It starts up the
    main thread that is going to handle the control requests from the
    service controller.

    It basically sets up the ControlDispatcher and, on return, exits
    from this main thread.  The call to NetServiceStartCtrlDispatcher
    does not return until all services have terminated, and this process
    can go away.

    The ControlDispatcher thread will start/stop/pause/continue any
    services.  If a service is to be started, it will create a thread
    and then call the main routine of that service.  The "main routine"
    for each service is actually an intermediate function implemented in
    this module that loads the DLL containing the server being started
    and calls its entry point.


Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  Disable hard-error popups.
    //

    SetErrorMode( SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX );

    //
    // Initialize Global Data.
    //

    InitializeCriticalSection( &TcpsvcsGlobalRpcListenCritSect );
    TcpSvcsGlobalNumRpcListenCalled = 0;

    TcpsvcsGlobalData.StartRpcServerListen = TcpsvcStartRpcServerListen;
    TcpsvcsGlobalData.StopRpcServerListen = TcpsvcStopRpcServerListen;

    //
    // Call StartServiceCtrlDispatcher to set up the control interface.
    // The API won't return until all services have been terminated. At that
    // point, we just exit.
    //

    if (! StartServiceCtrlDispatcher (
                TcpServiceDispatchTable
                )) {
        //
        // Log an event for failing to start control dispatcher
        //
        DbgPrint("TCPSVCS: Failed to start control dispatcher %lu\n",
                     GetLastError());
    }

    ExitProcess(0);
}


VOID
StartDns (
    IN DWORD argc,
    IN LPTSTR argv[]
    )

/*++

Routine Description:

    This is the thunk routine for the DNS service.  It loads the DLL
    that contains the service and calls its main routine.

Arguments:

    argc, argv - Passed through to the service

Return Value:

    None.

--*/

{
    //
    // Call TcpsvcsStartService to load and run the service.
    //

    TcpsvcsStartService( DNS_DLL, argc, argv );

    return;

} // StartDns


VOID
StartSimpTcp (
    IN DWORD argc,
    IN LPTSTR argv[]
    )

/*++

Routine Description:

    This is the thunk routine for the simple TCP/IP services.  It loads
    the DLL that contains the service and calls its main routine.

Arguments:

    argc, argv - Passed through to the service

Return Value:

    None.

--*/

{
    //
    // Call TcpsvcsStartService to load and run the service.
    //

    TcpsvcsStartService( SIMPTCP_DLL, argc, argv );

    return;

} // StartSimpTcp


VOID
StartDhcpServer (
    IN DWORD argc,
    IN LPTSTR argv[]
    )

/*++

Routine Description:

    This is the thunk routine to start dhcp server services.  It loads
    the DLL that contains the service and calls its main routine.

Arguments:

    argc, argv - Passed through to the service

Return Value:

    None.

--*/

{
    //
    // Call TcpsvcsStartService to load and run the service.
    //

    TcpsvcsStartService( DHCP_SERVER_DLL, argc, argv );

    return;

} // StartDhcpServer



VOID
StartFtpSvc (
    IN DWORD argc,
    IN LPTSTR argv[]
    )

/*++

Routine Description:

    This is the thunk routine for the FTP Server service.  It loads
    the DLL that contains the service and calls its main routine.

Arguments:

    argc, argv - Passed through to the service

Return Value:

    None.

--*/

{
    //
    // Call TcpsvcsStartService to load and run the service.
    //

    TcpsvcsStartService( FTPSVC_DLL, argc, argv );

    return;

} // StartFtpSvc


VOID
StartLpdSvc (
    IN DWORD argc,
    IN LPTSTR argv[]
    )

/*++

Routine Description:

    This is the thunk routine for the LPD Server service.  It loads
    the DLL that contains the service and calls its main routine.

Arguments:

    argc, argv - Passed through to the service

Return Value:

    None.

--*/

{
    //
    // Call TcpsvcsStartService to load and run the service.
    //

    TcpsvcsStartService( LPDSVC_DLL, argc, argv );

    return;

} // StartLdpSvc


VOID
StartBinlSvc (
    IN DWORD argc,
    IN LPTSTR argv[]
    )

/*++

Routine Description:

    This is the thunk routine for the LPD Server service.  It loads
    the DLL that contains the service and calls its main routine.

Arguments:

    argc, argv - Passed through to the service

Return Value:

    None.

--*/

{
    //
    // Call TcpsvcsStartService to load and run the service.
    //

    TcpsvcsStartService( BINLSVC_DLL, argc, argv );

    return;

} // StartBinlSvc


VOID
TcpsvcsStartService (
    IN LPTSTR DllName,
    IN DWORD argc,
    IN LPTSTR argv[]
    )

/*++

Routine Description:

    This routine loads the DLL that contains a service and calls its
    main routine.

Arguments:

    DllName - name of the DLL

    argc, argv - Passed through to the service

Return Value:

    None.

--*/

{
    HMODULE dllHandle;
    PTCPSVCS_SERVICE_DLL_ENTRY serviceEntry;
    BOOL ok;
    DWORD Error;
    TCHAR *FileName;
    TCHAR DllPath[MAX_PATH + 12 + 3];

    ASSERT(lstrlen(DllName) <= 12);

    if (GetSystemDirectory(DllPath, MAX_PATH) == 0) {
        Error = GetLastError();
        DbgPrint("TCPSVCS: Failed to get system directory: %ld\n", Error);
        AbortService(argv[0], Error);
        return;
    }
    lstrcat(DllPath, TEXT("\\"));

    FileName = DllPath + lstrlen(DllPath);

    lstrcpy( FileName, DllName);

    //
    // Load the DLL that contains the service.
    //

    dllHandle = GetModuleHandle( DllPath );
    if ( dllHandle == NULL ) {
        dllHandle = LoadLibrary( DllPath );
        if ( dllHandle == NULL ) {
            Error = GetLastError();
            DbgPrint("TCPSVCS: Failed to load DLL %ws: %ld\n", DllName, Error);
            AbortService(argv[0], Error);
            return;
        }
    }

    //
    // Get the address of the service's main entry point.  This
    // entry point has a well-known name.
    //

    serviceEntry = (PTCPSVCS_SERVICE_DLL_ENTRY)GetProcAddress(
                                                dllHandle,
                                                TCPSVCS_ENTRY_POINT_STRING
                                                );
    if ( serviceEntry == NULL ) {
        Error = GetLastError();
        DbgPrint("TCPSVCS: Can't find entry %s in DLL %ws: %ld\n",
                     TCPSVCS_ENTRY_POINT_STRING, DllName, Error);
        AbortService(argv[0], Error);
    } else {

        //
        // Call the service's main entry point.  This call doesn't return
        // until the service exits.
        //

        serviceEntry( argc, argv, &TcpsvcsGlobalData );

    }

    //
    // Return with the DLL still loaded.
    // The next start-attempt will detect that the module is still loaded.
    //

    return;

} // TcpsvcsStartService


VOID
DummyCtrlHandler(
    DWORD   Opcode
    )
/*++

Routine Description:

    This is a dummy control handler which is only used if we can't load
    a services DLL entry point.  Then we need this so we can send the
    status back to the service controller saying we are stopped, and why.

Arguments:

    OpCode - Ignored

Return Value:

    None.

--*/

{
    return;

} // DummyCtrlHandler


VOID
AbortService(
    LPWSTR  ServiceName,
    DWORD   Error)
/*++

Routine Description:

    This is called if we can't load the entry point for a service.  It
    gets a handle so it can call SetServiceStatus saying we are stopped
    and why.

Arguments:

    ServiceName - the name of the service that couldn't be started
    Error - the reason it couldn't be started

Return Value:

    None.

--*/
{
    SERVICE_STATUS_HANDLE GenericServiceStatusHandle;
    SERVICE_STATUS GenericServiceStatus;

    GenericServiceStatus.dwServiceType        = SERVICE_WIN32;
    GenericServiceStatus.dwCurrentState       = SERVICE_STOPPED;
    GenericServiceStatus.dwControlsAccepted   = SERVICE_CONTROL_STOP;
    GenericServiceStatus.dwCheckPoint         = 0;
    GenericServiceStatus.dwWaitHint           = 0;
    GenericServiceStatus.dwWin32ExitCode      = Error;
    GenericServiceStatus.dwServiceSpecificExitCode = 0;

    GenericServiceStatusHandle = RegisterServiceCtrlHandler(
                ServiceName,
                DummyCtrlHandler);

    if (GenericServiceStatusHandle == (SERVICE_STATUS_HANDLE)0) {
        DbgPrint("[TCPSVCS] RegisterServiceCtrlHandler failed %d\n",
            GetLastError());
    }
    else if (!SetServiceStatus (GenericServiceStatusHandle,
                &GenericServiceStatus)) {
        DbgPrint("[TCPSVCS] SetServiceStatus error %ld\n", GetLastError());
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\lpd\debug.c ===
/*************************************************************************
 *                        Microsoft Windows NT                           *
 *                                                                       *
 *                  Copyright(c) Microsoft Corp., 1994                   *
 *                                                                       *
 * Revision History:                                                     *
 *                                                                       *
 *   Jan. 24,94    Koti     Created                                      *
 *                                                                       *
 * Description:                                                          *
 *                                                                       *
 *   This file contains debug support routines for the LPD Service.      *
 *   This file is based on (in fact, borrowed and then modified) on the  *
 *   debug.c in the ftpsvc module.                                       *
 *                                                                       *
 *************************************************************************/

#include <stdio.h>
#include "lpd.h"


#if DBG

//
//  Private constants.
//

#define LPD_OUT_FILE           "lpdout.log"
#define LPD_ERR_FILE           "lpderr.log"

#define MAX_PRINTF_OUTPUT       1024            // characters
#define LPD_OUTPUT_LABEL       "LPDSVC"

#define DEBUG_HEAP              0               // enable/disable heap debugging


//
//  Private globals.
//

FILE              * pErrFile;                   // Debug output log file.
FILE              * pOutFile;                   // Debug output log file.
BOOL              fFirstTimeErr=TRUE;
BOOL              fFirstTimeOut=TRUE;

//
// every LocalAlloc gets linked to this list and LocalFree gets unlinked
// (so that we can catch any memory leaks!)
//
LIST_ENTRY        DbgMemList;

//
// synchronization for DbgMemList
//

CRITICAL_SECTION CS;


//
//  Public functions.
//

/*******************************************************************

    NAME:       DbgInit

    SYNOPSIS:   Peforms initialization for debug memory allocator

    ENTRY:      void

     HISTORY:
        Frankbee     05-Jun-1996 Created.

********************************************************************/

VOID
DbgInit()
{
   InitializeCriticalSection( &CS );
}

/*******************************************************************

    NAME:       DbgUninit

    SYNOPSIS:   Peforms cleanup for debug memory allocator

    ENTRY:      void

     HISTORY:
        Frankbee     05-Jun-1996 Created.

********************************************************************/

VOID
DbgUninit()
{
   DeleteCriticalSection( &CS );
}


//
//  Public functions.
//

/*******************************************************************

    NAME:       LpdAssert

    SYNOPSIS:   Called if an assertion fails.  Displays the failed
                assertion, file name, and line number.  Gives the
                user the opportunity to ignore the assertion or
                break into the debugger.

    ENTRY:      pAssertion - The text of the failed expression.

                pFileName - The containing source file.

                nLineNumber - The guilty line number.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
VOID
LpdAssert( VOID  * pAssertion,
           VOID  * pFileName,
           ULONG   nLineNumber
)
{
    RtlAssert( pAssertion, pFileName, nLineNumber, NULL );

}   // LpdAssert

/*******************************************************************

    NAME:       LpdPrintf

    SYNOPSIS:   Customized debug output routine.

    ENTRY:      Usual printf-style parameters.

    HISTORY:
        KeithMo     07-Mar-1993 Created.

********************************************************************/
VOID
LpdPrintf(
    CHAR * pszFormat,
    ...
)
{
    CHAR    szOutput[MAX_PRINTF_OUTPUT];
    DWORD   dwErrcode;
    va_list ArgList;
    DWORD   cchOutputLength;
    PSTR    pszErrorBuffer;

    dwErrcode = GetLastError();

    sprintf( szOutput,
             "%s (%lu): ",
             LPD_OUTPUT_LABEL,
             GetCurrentThreadId() );

    va_start( ArgList, pszFormat );
    vsprintf( szOutput + strlen(szOutput), pszFormat, ArgList );
    va_end( ArgList );

    cchOutputLength = FormatMessage( FORMAT_MESSAGE_FROM_SYSTEM + FORMAT_MESSAGE_ALLOCATE_BUFFER,
                                     NULL,
                                     dwErrcode,
                                     0,
                                     (LPTSTR)&pszErrorBuffer,
                                     1,
                                     NULL
                                   );

    if ( cchOutputLength == 0 )
    {
      sprintf( szOutput + strlen(szOutput), "                  Error = %ld\n",dwErrcode);
      pszErrorBuffer = NULL;
    }
    else
    {
      pszErrorBuffer[ cchOutputLength - 1 ] = '\0';

      sprintf( szOutput + strlen(szOutput),
               "                  Error = %ld (%s)\n",
               dwErrcode,
               pszErrorBuffer );
    }

    if ( pszErrorBuffer != NULL )
    {
      //
      // Why is "LocalFree" in parentheses?  Because LocalFree might be #define'd
      // to a debugging function, but pszErrorBuffer was LocalAlloc()'d with the
      // normal function.  The parens prevent macro expansion and guarantee that
      // we call the real LocalFree() function.
      //
      (LocalFree)( pszErrorBuffer );
    }

    if( pErrFile == NULL )
    {
        if ( fFirstTimeErr )
        {
           pErrFile = fopen( LPD_ERR_FILE, "w+" );
           fFirstTimeErr = FALSE;
        }
        else
           pErrFile = fopen( LPD_ERR_FILE, "a+" );
    }

    if( pErrFile != NULL )
    {
        fputs( szOutput, pErrFile );
        fflush( pErrFile );
    }

}   // LpdPrintf

/*******************************************************************

    NAME:       StripPath

    SYNOPSIS:   Given a fully qualified filename, returns the filename
                sans path

    ENTRY:      char *szPath  - filename, possibly including path

    RETURNS:    filename

    HISTORY:
        Frankbee    6/18/96 Created.

********************************************************************/


char *
StripPath( char *szPath )
{
   char *p;

   p = szPath + strlen( szPath );

   while( p != szPath && *p != '\\' )
      p--;

   if ( *p == '\\' )
      ++p;

   return p;

}

/*******************************************************************

    NAME:       DbgDumpLeaks

    SYNOPSIS:   Checks DbgMemList for memory that wasn't deallocated.
                For each leaked block, the following is written to
                the error log:

                  - Filename
                  - Line #
                  - Requested Size

    ENTRY:      VOID
    RETURNS:    VOID

    HISTORY:
        Frankbee    6/18/96   Created

********************************************************************/


void
DbgDumpLeaks()
{
   LIST_ENTRY *p = DbgMemList.Flink;

   if ( IsListEmpty( &DbgMemList ) )
      return; // no leaks


   LPD_DEBUG("DbgDumpLeaks: memory leaks detected:\n");

   while ( p != &DbgMemList )
   {
      DbgMemBlkHdr *pHdr = (DbgMemBlkHdr*) p;
      LpdPrintf(  "%s, line %d: %d byte block\n", pHdr->szFile, pHdr->dwLine,
                                                  pHdr->ReqSize );

      p = p->Flink;
   }

   LPD_ASSERT(0);

}


/*******************************************************************

    NAME:       DbgAllocMem

    SYNOPSIS:   Keep track of all allocated memory so we can catch
                memory leak when we unload
                This is only on debug builds.  On non-debug builds
                this function doesn't exist: calls directly go to
                LocalAlloc

    ENTRY:      pscConn - connection which is requesting memory
                flag - whatever flags are passed in
                ReqSize - how much memory is needed

    RETURNS:    PVOID - pointer to the memory block that client will
                use directly.

    HISTORY:
        Koti     3-Dec-1994 Created.

********************************************************************/

//
// IMPORTANT: we are undef'ing LocalAlloc because we need to make a
//            call to the actual function here!.  That's why
//            this function and this undef are at the end of the file.
//
#undef LocalAlloc

PVOID
DbgAllocMem( PSOCKCONN pscConn,
             DWORD     flag,
             DWORD     ReqSize,
             DWORD     dwLine,
             char     *szFile
)
{

    DWORD          ActualSize;
    PVOID          pBuffer;
    DbgMemBlkHdr  *pMemHdr;
    PVOID          pRetAddr;


    ActualSize = ReqSize + sizeof(DbgMemBlkHdr);
    pBuffer = LocalAlloc( flag, ActualSize );
    if ( !pBuffer )
    {
        LPD_DEBUG("DbgAllocMem: couldn't allocate memory: returning!\n");
        return( NULL );
    }

    pMemHdr = (DbgMemBlkHdr *)pBuffer;

    pMemHdr->Verify  = DBG_MEMALLOC_VERIFY;
    pMemHdr->ReqSize = ReqSize;
    pMemHdr->dwLine  = dwLine;
    strncpy (pMemHdr->szFile, StripPath (szFile), DBG_MAXFILENAME);
    pMemHdr->szFile[DBG_MAXFILENAME-1] = '\0';

    pMemHdr->Owner[0] = (DWORD_PTR)pscConn;

  //
  // for private builds on x86 machines, remove the #if 0
  // (this code saves stack trace as to exactly who allocated memory)
  //
#if 0
    pRetAddr = &pMemHdr->Owner[0];

    _asm
    {
        push   ebx
        push   ecx
        push   edx
        mov    ebx, pRetAddr
        mov    eax, ebp
        mov    edx, dword ptr [eax+4]           ; return address
        mov    dword ptr [ebx], edx
        mov    eax, dword ptr [eax]             ; previous frame pointer
        pop    edx
        pop    ecx
        pop    ebx
    }
#endif

    InitializeListHead(&pMemHdr->Linkage);

    EnterCriticalSection( &CS );
    InsertTailList(&DbgMemList, &pMemHdr->Linkage);
    LeaveCriticalSection( &CS );

    return( (PCHAR)pBuffer + sizeof(DbgMemBlkHdr) );
}

/*******************************************************************

    NAME:       DbgReAllocMem

    SYNOPSIS:   Keep track of all allocated memory so we can catch
                memory leak when we unload
                This is only on debug builds.  On non-debug builds
                this function doesn't exist: calls directly go to
                LocalReAlloc

    ENTRY:      pscConn - connection which is requesting memory
                pPartBuf - the originally allocated buffer
                ReqSize - how much memory is needed
                flag - whatever flags are passed in

    RETURNS:    PVOID - pointer to the memory block that client will
                use directly.

    HISTORY:
        Koti     3-Dec-1994 Created.

********************************************************************/
//
// IMPORTANT: we are undef'ing LocalReAlloc because we need to make a
//            call to the actual function here!.  That's why
//            this function and this undef are at the end of the file.
//
#undef LocalReAlloc
PVOID
DbgReAllocMem(
    PSOCKCONN pscConn,
    PVOID     pPartBuf,
    DWORD     ReqSize,
    DWORD     flag,
    DWORD     dwLine,
    char     *szFile
)
{

    DbgMemBlkHdr  *pMemHdr;
    DbgMemBlkHdr  *pNewMemHdr;
    PVOID          pRetAddr;


    if ( !pPartBuf )
    {
        LPD_DEBUG("DbgReAllocMem: invalid memory: returning!\n");
        return( NULL );
    }

    pMemHdr = (DbgMemBlkHdr *)((PCHAR)pPartBuf - sizeof(DbgMemBlkHdr));

    if( pMemHdr->Verify != DBG_MEMALLOC_VERIFY )
    {
        LPD_DEBUG("DbgReAllocMem: invalid memory being realloced: returning!\n");
        return( NULL );
    }

    EnterCriticalSection( &CS );
    RemoveEntryList(&pMemHdr->Linkage);
    LeaveCriticalSection( &CS );

    pNewMemHdr = LocalReAlloc((PCHAR)pMemHdr, ReqSize+sizeof(DbgMemBlkHdr), flag);
    if (!pNewMemHdr)
    {
        LPD_DEBUG("DbgReAllocMem: LocalReAlloc failed: returning!\n");
        return( NULL );
    }

    pMemHdr = pNewMemHdr;
    pMemHdr->Verify = DBG_MEMALLOC_VERIFY;
    pMemHdr->ReqSize = ReqSize;
    pMemHdr->dwLine  = dwLine;
    strncpy( pMemHdr->szFile, StripPath( szFile ), DBG_MAXFILENAME );
    pMemHdr->szFile[ DBG_MAXFILENAME - 1 ] = '\0';

    pMemHdr->Owner[0] = (DWORD_PTR)pscConn;

  //
  // for private builds on x86 machines, remove the #if 0
  // (this code saves stack trace as to exactly who allocated memory)
  //
#if 0
    pRetAddr = &pMemHdr->Owner[0];

    _asm
    {
        push   ebx
        push   ecx
        push   edx
        mov    ebx, pRetAddr
        mov    eax, ebp
        mov    edx, dword ptr [eax+4]           ; return address
        mov    dword ptr [ebx], edx
        mov    eax, dword ptr [eax]             ; previous frame pointer
        pop    edx
        pop    ecx
        pop    ebx
    }
#endif

    InitializeListHead(&pMemHdr->Linkage);

    EnterCriticalSection( &CS );
    InsertTailList(&DbgMemList, &pMemHdr->Linkage);
    LeaveCriticalSection( &CS );

    return( (PCHAR)pMemHdr + sizeof(DbgMemBlkHdr) );
}
/*******************************************************************

    NAME:       DbgFreeMem

    SYNOPSIS:   This routine removes the memory block from our list and
                frees the memory by calling the CTE function CTEFreeMem

    ENTRY:      pBufferToFree - memory to free (caller's buffer)

    RETURNS:    nothing

    HISTORY:
        Koti     11-Nov-1994 Created.

********************************************************************/

//
// IMPORTANT: we are undef'ing CTEFreeMem because we need to make a
//            call to the actual CTE function CTEFreeMem.  That's why
//            this function and this undef are at the end of the file.
//
#undef LocalFree

VOID
DbgFreeMem( PVOID  pBufferToFree )
{

    DbgMemBlkHdr  *pMemHdr;


    if ( !pBufferToFree )
    {
        return;
    }

    pMemHdr = (DbgMemBlkHdr *)((PCHAR)pBufferToFree - sizeof(DbgMemBlkHdr));

    if( pMemHdr->Verify != DBG_MEMALLOC_VERIFY )
    {
        LPD_DEBUG("DbgFreeMem: attempt to free invalid memory: returning!\n");
        LPD_ASSERT(0);
        return;
    }

    //
    // change our signature: if we are freeing some memory twice, we'll know!
    //
    pMemHdr->Verify -= 1;

    EnterCriticalSection( &CS );
    RemoveEntryList(&pMemHdr->Linkage);
    LeaveCriticalSection( &CS );

    LocalFree( (PVOID)pMemHdr );
}

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\lpd\debug.h ===
/*************************************************************************
 *                        Microsoft Windows NT                           *
 *                                                                       *
 *                  Copyright(c) Microsoft Corp., 1994                   *
 *                                                                       *
 * Revision History:                                                     *
 *                                                                       *
 *   Jan. 24,94    Koti     Created                                      *
 *                                                                       *
 * Description:                                                          *
 *                                                                       *
 *   This file contains debug support routines for the LPD Service.      *
 *   This file is based on (in fact, borrowed and then modified) on the  *
 *   debug.h in the ftpsvc module.                                       *
 *                                                                       *
 *************************************************************************/


#ifndef _DEBUG_H_
#define _DEBUG_H_


#if DBG


/* #define LPD_DEBUG_OUTPUT_TO_DEBUGGER   0x40000000L */
/* #define LPD_DEBUG_OUTPUT_TO_LOG_FILE   0x80000000L */


#define DBG_MEMALLOC_VERIFY            0x0BEEFCAFE
#define DBG_MAXFILENAME                24

typedef struct {
    LIST_ENTRY    Linkage;          // to keep linked list of allocated blocks
    DWORD         Verify;           // our signature
    DWORD         ReqSize;          // original size as requested by caller
    DWORD_PTR     Owner[4];         // stack trace: who did the alloc
    DWORD         dwLine;           // where was this block
    char          szFile[24];       // allocated?
} DbgMemBlkHdr;

//
//  Debug output function.
//

VOID LpdPrintf( CHAR * pszFormat, ... );

#define LPD_DEBUG(args) LpdPrintf (args)


//
//  Assert & require.
//

VOID LpdAssert( VOID  * pAssertion,
                 VOID  * pFileName,
                 ULONG   nLineNumber );

#define LPD_ASSERT(exp) if (!(exp)) LpdAssert( #exp, __FILE__, __LINE__ )

//
// Initialization/Uninitialization
//

VOID DbgInit();
VOID DbgUninit();

#define DBG_INIT() DbgInit()
#define DBG_UNINIT() DbgUninit()

//
// memory allocation tracking
//

VOID DbgDumpLeaks();

#define DBG_DUMPLEAKS() DbgDumpLeaks();

//
// function tracing
//

#ifdef LPD_TRACE

#define DBG_TRACEIN( fn )  LpdPrintf( "Entering %s.\n", fn )
#define DBG_TRACEOUT( fn ) LpdPrintf( "Leaving %s.\n",  fn )

#else // LPD_TRACE

#define DBG_TRACEIN( fn )
#define DBG_TRACEOUT( fn )

#endif

#else   // !DBG

//
//  No debug output.
//


#define LPD_DEBUG(args)


//
//  Null assert & require.
//

#define LPD_ASSERT(exp)

//
// Null initialization/Uninitialization
//

#define DBG_INIT()
#define DBG_UNINIT()

//
// memory allocation tracking
//

#define DBG_DUMPLEAKS()

//
// function tracing
//

#define DBG_TRACEIN( fn )
#define DBG_TRACEOUT( fn )

#endif  // DBG


#endif  // _DEBUG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\lpd\lpd.h ===
/*************************************************************************
 *                        Microsoft Windows NT                           *
 *                                                                       *
 *                  Copyright(c) Microsoft Corp., 1994                   *
 *                                                                       *
 * Revision History:                                                     *
 *                                                                       *
 *   Jan. 22,94    Koti     Created                                      *
 *                                                                       *
 * Description:                                                          *
 *                                                                       *
 *   This file contains defines and structure definitions needed for LPD *
 *                                                                       *
 *************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include <stdio.h>
#include <stdlib.h>
#include <winspool.h>

#include <ntlsapi.h>
#include <time.h>


#include "lpdstruc.h"
#include "lpdextrn.h"
#include "debug.h"
#include "lpdmsg.h"

#include "trace.h"


#if DBG
#define LocalAlloc(flag, Size)  DbgAllocMem( pscConn, flag, Size, __LINE__, __FILE__ );
#define LocalReAlloc(Buffer, Size, flag)  DbgReAllocMem(pscConn, Buffer, Size, flag, __LINE__, __FILE__ );
#define LocalFree(Buffer)       DbgFreeMem(Buffer);
PVOID DbgAllocMem( PSOCKCONN pscConn, DWORD flag, DWORD ReqSize, DWORD dwLine, char *szFile );
VOID DbgFreeMem( PVOID  pBufferToFree );
PVOID DbgReAllocMem( PSOCKCONN pscConn, PVOID pPartBuf, DWORD ReqSize, DWORD flag, DWORD dwLine, char *szFile );
#endif

#define WCS_LEN(dwAnsiLen)  ( sizeof( WCHAR ) * ( dwAnsiLen ))
#define  LPD_FLD_OWNER      12
#define  LPD_FLD_STATUS     10
#define  LPD_FLD_JOBNAME    20
#define  LPD_FLD_JOBID      6
#define  LPD_FLD_SIZE       10
#define  LPD_FLD_PAGES      7
#define  LPD_FLD_PRIORITY   7
#define  LPD_LINE_SIZE      (  LPD_FLD_OWNER   + LPD_FLD_STATUS  \
                             + LPD_FLD_JOBNAME + LPD_FLD_JOBID + LPD_FLD_SIZE \
                             + LPD_FLD_PAGES   + LPD_FLD_PRIORITY    \
                             + sizeof( LPD_NEWLINE ) )

// this string also defined in lprmon.h in ....lprmon\monitor: the two strings must
// be identical!
#define LPD_JOB_PREFIX      "job=lpd"

// we tell spooler "give me status of these many jobs"

#define  LPD_MAXJOBS_ENUM   500

// guess for LPD init time: 10 seconds

#define  LPD_WAIT_HINT      10000

#define  WINSOCK_VER_MAJOR  1
#define  WINSOCK_VER_MINOR  1

#define  LPD_PORT           515

// max no. bytes we try to get at one time via recv

#define  LPD_BIGBUFSIZE     32000

// most commands are 50 or 60 bytes or so long, so 5000 should be plenty!

#define  LPD_MAX_COMMAND_LEN  5000

#define  LPD_MAX_USERS        50

#define  LPD_MAX_QUEUE_LENGTH 100

// just to have an upper limit: control file bigger than 10MB deserves to be rejected!
#define  LPD_MAX_CONTROL_FILE_LEN 10000000


//
// stuff for .mc messages
// you may have to change hese definitions if you add messages
//

#define  LPD_FIRST_STRING LPD_LOGO
#define  LPD_LAST_STRING  LPD_DEFAULT_DOC_NAME
#define  LPD_CSTRINGS (LPD_LAST_STRING - LPD_FIRST_STRING + 1)

#define GETSTRING( dwID )  (g_ppszStrings[ dwID - LPD_FIRST_STRING ])


// Linefeed character that terminates every command

#define  LF                 ('\n')
#define  LPD_ACK            0
#define  LPD_NAK            1

#define  LPD_CONTROLFILE    1
#define  LPD_DATAFILE       2

// the print formats

#define  LPD_PF_RAW_DATA    1
#define  LPD_PF_TEXT_DATA   2

#define  LPD_SHORT          1
#define  LPD_LONG           2


#define  IS_WHITE_SPACE( ch )   ( (ch == ' ') || (ch == '\t') || (ch == '\r') )

#define  IS_LINEFEED_CHAR( ch ) ( ch == LF )
#define  IS_NULL_CHAR( ch ) ( ch == '\0' )


// LPD Command codes

#define  LPDC_RESUME_PRINTING       1
#define  LPDC_RECEIVE_JOB           2
#define  LPDC_SEND_SHORTQ           3
#define  LPDC_SEND_LONGQ            4
#define  LPDC_REMOVE_JOBS           5

// LPD Job Subcommands

#define  LPDCS_ABORT_JOB            1
#define  LPDCS_RECV_CFILE           2
#define  LPDCS_RECV_DFILE           3


// LPD States (most correspond to command codes)

#define  LPDS_INIT                  0
#define  LPDS_RESUME_PRINTING       1
#define  LPDS_RECEIVE_JOB           2
#define  LPDS_SEND_SHORTQ           3
#define  LPDS_SEND_LONGQ            4
#define  LPDS_REMOVE_JOBS           5
#define  LPDS_ALL_WENT_WELL         10

// LPD States corresponding to the subcommands

#define  LPDSS_ABORTING_JOB         21
#define  LPDSS_RECVD_CFILENAME      22
#define  LPDSS_RECVD_CFILE          23
#define  LPDSS_RECVD_DFILENAME      24
#define  LPDSS_SPOOLING             25



// LPD Error codes

#define  LPDERR_BASE        (20000)
#define  LPDERR_NOBUFS      (LPDERR_BASE + 1)
#define  LPDERR_NORESPONSE  (LPDERR_BASE + 2)
#define  LPDERR_BADFORMAT   (LPDERR_BASE + 3)
#define  LPDERR_NOPRINTER   (LPDERR_BASE + 4)
#define  LPDERR_JOBABORTED  (LPDERR_BASE + 5)
#define  LPDERR_GODKNOWS    (LPDERR_BASE + 6)

#define CONNECTION_CLOSED   3


// Recv timeout is 60 seconds, so we don't keep worker threads
// tied to dead or dud clients. --- MohsinA, 01-May-97.

#define RECV_TIMEOUT        60
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\lpd\init.c ===
/*************************************************************************
 *                        Microsoft Windows NT                           *
 *                                                                       *
 *                  Copyright(c) Microsoft Corp., 1994                   *
 *                                                                       *
 * Revision History:                                                     *
 *                                                                       *
 *   Jan. 23,94    Koti     Created                                      *
 *                                                                       *
 * Description:                                                          *
 *                                                                       *
 *   This file contains functions for starting and stopping LPD service  *
 *                                                                       *
 *************************************************************************/



#include "lpd.h"


// Globals:

SERVICE_STATUS         ssSvcStatusGLB;

SERVICE_STATUS_HANDLE  hSvcHandleGLB = 0;

HANDLE                 hEventShutdownGLB;

HANDLE                 hEventLastThreadGLB;

HANDLE                 hLogHandleGLB;

// head of the linked list of SOCKCONN structures (one link per connection)

SOCKCONN               scConnHeadGLB;

// to guard access to linked list of pscConn

CRITICAL_SECTION       csConnSemGLB;

// max users that can be connected concurrently

DWORD                  dwMaxUsersGLB;

DWORD                  MaxQueueLength;

BOOL                   fJobRemovalEnabledGLB=TRUE;

BOOL                   fAllowPrintResumeGLB=TRUE;

BOOL                   fAlwaysRawGLB=FALSE;

DWORD                  dwRecvTimeout;

BOOL                   fShuttingDownGLB=FALSE;

CHAR                   szNTVersion[8];

CHAR                   *g_ppszStrings[ LPD_CSTRINGS ];

// Info shared by all threads, protected by CRITICAL_SECTION.

COMMON_LPD             Common;

/*****************************************************************************
 *                                                                           *
 * LoadStrings():                                                            *
 *    Load a bunch of strings defined in the .mc file.                       *
 *                                                                           *
 * Returns:                                                                  *
 *    TRUE if everything went ok                                             *
 *    FALSE if a string couldn't be loaded                                   *
 *                                                                           *
 * Parameters:                                                               *
 *    None                                                                   *
 *                                                                           *
 * History:                                                                  *
 *    June.27, 96   Frankbee   Created                                       *
 *                                                                           *
 *****************************************************************************/


BOOL LoadStrings()
{
   DWORD    dwSuccess;
   HMODULE  hModule;
   DWORD    dwID;

   memset (g_ppszStrings, 0, LPD_CSTRINGS * sizeof (CHAR * ));

   hModule = LoadLibrary( TEXT(LPD_SERVICE_NAME) );
   if (hModule == NULL)
   {
       return(FALSE);
   }

   for ( dwID = LPD_FIRST_STRING; dwID <= LPD_LAST_STRING; dwID++ )
   {

       // &g_ppszStrings[(dwID - LPD_FIRST_STRING)][0],

      dwSuccess = FormatMessage (FORMAT_MESSAGE_ALLOCATE_BUFFER |
                                 FORMAT_MESSAGE_FROM_HMODULE,
                                 hModule, // search local process
                                 dwID,
                                 MAKELANGID( LANG_NEUTRAL, SUBLANG_DEFAULT),
                                 (LPSTR)(g_ppszStrings + (dwID - LPD_FIRST_STRING)),
                                 1,
                                 NULL);

      if (!dwSuccess)
      {
          DEBUG_PRINT(("lpd:init.c:29, dwID=%d FormatMessage failed\n", dwID));
          goto error;
      }
   }

   FreeLibrary( hModule );
   return TRUE;

  error:
   FreeStrings();
   FreeLibrary( hModule );

   return FALSE;
}

/*****************************************************************************
 *                                                                           *
 * FreeStrings():                                                            *
 *    Frees the strings loaded by LoadStrings()                              *
 *                                                                           *
 * Returns:                                                                  *
 *     VOID                                                                  *                                                                           *
 * Parameters:                                                               *
 *    None                                                                   *
 *                                                                           *
 * History:                                                                  *
 *    June.27, 96   Frankbee   Created                                       *
 *                                                                           *
 *****************************************************************************/


VOID FreeStrings()
{
   int i;

    for ( i = 0; i < LPD_CSTRINGS; i++ )
    {
        if (g_ppszStrings[i])
        {
            (LocalFree) (g_ppszStrings[i]);
        }
    }

    //
    // clear the string table
    //
    memset (g_ppszStrings, 0, LPD_CSTRINGS * sizeof (CHAR * ));
}


/*****************************************************************************
 *                                                                           *
 * InitStuff():                                                              *
 *    This function initializes hEventShutdown and other global vars         *
 *                                                                           *
 * Returns:                                                                  *
 *    TRUE if everything went ok                                             *
 *    FALSE if something went wrong                                          *
 *                                                                           *
 * Parameters:                                                               *
 *    None                                                                   *
 *                                                                           *
 * History:                                                                  *
 *    Jan.23, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

BOOL InitStuff( )
{

   USHORT  usVersion;
   UCHAR   uchTemp;

#ifdef DBG
   // MohsinA, 06-Mar-97. lpd isn't starting.
   beginlogging( MOSH_LOG_FILE );
#endif


   if ( !LoadStrings() )
   {
      LPD_DEBUG( "LoadStrings() failed in InitStuf\n" );
      return FALSE;
   }

   if ( !InitLogging() )
   {
      LPD_DEBUG( "InitLogging() FAILed, continuing anyway ...\n" );
   }

#if DBG
   InitializeListHead(&DbgMemList);
#endif

      // main thread blocks for ever on this event, before doing a shutdown

   hEventShutdownGLB = CreateEvent( NULL, FALSE, FALSE, NULL );


      // when the main thread is ready to shutdown, if there are any active
      // threads servicing clients, then main thread blocks on this event
      // (the last thread to leave sets the event)

   hEventLastThreadGLB = CreateEvent( NULL, FALSE, FALSE, NULL );

   if ( ( hEventShutdownGLB == (HANDLE)NULL ) ||
        ( hEventLastThreadGLB == (HANDLE)NULL ) )
   {
      LPD_DEBUG( "CreateEvent() failed in InitStuff\n" );
      return( FALSE );
   }


   scConnHeadGLB.pNext = NULL;

   // == Doubly linked list,
   // == isempty() iff scConnHeadGLB.pNext == &scConnHeadGLB.
   // ==            && scConnHeadGLB.pPrev == &scConnHeadGLB.
   // scConnHeadGLB.pNext = scConnHeadGLB.pPrev = &scConnHeadGLB;


   // scConnHeadGLB.cbClients = 0;     // Obselete.

   memset( &Common, 0, sizeof(Common) );

   // csConnSemGLB is the critical section object (guards access to
   // scConnHeadGLB, head of the psc linked list)

   InitializeCriticalSection( &csConnSemGLB );

   // perform debug build initialization
   DBG_INIT();


   ReadRegistryValues();

   // store the version number of NT

   usVersion  = (USHORT)GetVersion();
   uchTemp    = (UCHAR)usVersion;        // low byte => major version number
   usVersion >>= 8;                      // high byte => minor version number
   sprintf( szNTVersion,"%d.%d",uchTemp,(UCHAR)usVersion );


   return( TRUE );


}  // end InitStuff( )




/*****************************************************************************
 *                                                                           *
 * ReadRegistryValues():                                                     *
 *    This function initializes all variables that we read via registry. If  *
 *    there is a problem and we can't read the registry, we ignore the       *
 *    problem and initialize the variables with our defaults.                *
 *                                                                           *
 * Returns:                                                                  *
 *    Nothing                                                                *
 *                                                                           *
 * Parameters:                                                               *
 *    None                                                                   *
 *                                                                           *
 * History:                                                                  *
 *    Jan.30, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

VOID ReadRegistryValues( VOID )
{

   HKEY      hLpdKey;
   DWORD     dwErrcode;
   DWORD     dwType, dwValue, dwValueSize;



   // first set defaults

   dwMaxUsersGLB = LPD_MAX_USERS;

   MaxQueueLength = LPD_MAX_QUEUE_LENGTH;

   fJobRemovalEnabledGLB = TRUE;

   fAllowPrintResumeGLB = TRUE;

   fAlwaysRawGLB = FALSE;

   dwRecvTimeout = RECV_TIMEOUT;

   dwErrcode = RegOpenKeyEx( HKEY_LOCAL_MACHINE, LPD_PARMS_REGISTRY_PATH,
                             0, KEY_ALL_ACCESS, &hLpdKey );

   if ( dwErrcode != ERROR_SUCCESS )
   {
      return;
   }


   // Read in the dwMaxUsersGLB parm

   dwValueSize = sizeof( DWORD );

   dwErrcode = RegQueryValueEx( hLpdKey, LPD_PARMNAME_MAXUSERS, NULL,
                                &dwType, (LPBYTE)&dwValue, &dwValueSize );

   if ( (dwErrcode == ERROR_SUCCESS) && (dwType == REG_DWORD) )
   {
      dwMaxUsersGLB = dwValue;
   }

   //
   // Read in the MaxQueueLength
   //

   dwValueSize = sizeof( DWORD );

   dwErrcode = RegQueryValueEx( hLpdKey, LPD_PARMNAME_MAX_QUEUE_LENGTH, NULL,
                                &dwType, (LPBYTE)&dwValue, &dwValueSize );

   if ( (dwErrcode == ERROR_SUCCESS) && (dwType == REG_DWORD) )
   {
      MaxQueueLength = dwValue;
   }

   //
   // Read in the fJobRemovalEnabledGLB parm

   dwValueSize = sizeof( DWORD );

   dwErrcode = RegQueryValueEx( hLpdKey, LPD_PARMNAME_JOBREMOVAL, NULL,
                                &dwType, (LPBYTE)&dwValue, &dwValueSize );

   if ( (dwErrcode == ERROR_SUCCESS) && (dwType == REG_DWORD) &&
        ( dwValue == 0 ) )
   {
      fJobRemovalEnabledGLB = FALSE;
   }


   // Read in the fAllowPrintResumeGLB parm

   dwValueSize = sizeof( DWORD );

   dwErrcode = RegQueryValueEx( hLpdKey, LPD_PARMNAME_PRINTRESUME, NULL,
                                &dwType, (LPBYTE)&dwValue, &dwValueSize );

   if ( (dwErrcode == ERROR_SUCCESS) && (dwType == REG_DWORD) &&
        ( dwValue == 0 ) )
   {
      fAllowPrintResumeGLB = FALSE;
   }

   // Read in the fAlwaysRawGLB parm

   dwValueSize = sizeof( DWORD );

   dwErrcode = RegQueryValueEx( hLpdKey, LPD_PARMNAME_ALWAYSRAW, NULL,
                                &dwType, (LPBYTE)&dwValue, &dwValueSize );

   if ( (dwErrcode == ERROR_SUCCESS) && (dwType == REG_DWORD) &&
        ( dwValue == 1 ) )
   {
      fAlwaysRawGLB = TRUE;
   }

   // Read in the dwRecvTimeout parm

   dwValueSize = sizeof( DWORD );

   dwErrcode = RegQueryValueEx( hLpdKey, LPD_PARMNAME_RECV_TIMEOUT, NULL,
                                &dwType, (LPBYTE)&dwValue, &dwValueSize );

   if ( (dwErrcode == ERROR_SUCCESS) && (dwType == REG_DWORD) )
   {
      dwRecvTimeout = dwValue;
   }

   RegCloseKey (hLpdKey);
 
}  // end ReadRegistryValues()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\lpd\job.c ===
/*************************************************************************
 *                        Microsoft Windows NT                           *
 *                                                                       *
 *                  Copyright(c) Microsoft Corp., 1994                   *
 *                                                                       *
 * Revision History:                                                     *
 *                                                                       *
 *   Jan. 24,94    Koti     Created                                      *
 *   Jan. 29,96    JBallard Modified                                     *
 *                                                                       *
 * Description:                                                          *
 *                                                                       *
 *   This file contains functions for carrying out LPD printing          *
 *                                                                       *
 *************************************************************************/



#include "lpd.h"


extern FILE              * pErrFile;   // Debug output log file.

BOOL GetSpoolFileName(
    HANDLE hPrinter,
    PSOCKCONN pscConn,
    PCHAR *ppwchSpoolPath
);

VOID CleanupConn( PSOCKCONN pscConn);

/*****************************************************************************
 *                                                                           *
 * ProcessJob():                                                             *
 *    This function receives the subcommand from the client to expect the    *
 *    control file, then accepts the control file, then the subcommand to    *
 *    expect the data file, then accepts the data and then hands it over to  *
 *    the spooler to print.                                                  *
 *    If the very first subcommand was to abort the job, we just return.     *
 *                                                                           *
 * Returns:                                                                  *
 *    Nothing                                                                *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *                                                                           *
 * History:                                                                  *
 *    Jan.24 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

VOID ProcessJob( PSOCKCONN pscConn )
{

    // the main functionality of LPD implemented in this function!

    CHAR         chSubCmdCode;
    DWORD        cbTotalDataLen;
    DWORD        cbBytesSpooled;
    DWORD        cbBytesToRead;
    DWORD        cbDataBufLen;
    DWORD        cbBytesRemaining;
    DWORD        dwErrcode;
    CHAR         chAck;
    HANDLE       hDFile;
    PDFILE_ENTRY pDFile;
    PCHAR        lpFileName;
    PCHAR        pchDataBuf;

    DWORD        ClientCmd;
    // initialize the printer that the client wants to use

#ifdef DBG
    if( !pscConn || !pscConn->pchPrinterName
        || strstr( pscConn->pchPrinterName, "debug" )
    ){
        print__sockconn( "ProcessJob: entered", pscConn );
    }
#endif


    if ( InitializePrinter( pscConn ) != NO_ERROR )
    {
        PCHAR   aszStrings[2];

        aszStrings[0] = pscConn->pchPrinterName;
        aszStrings[1] = pscConn->szIPAddr;

        LpdReportEvent( LPDLOG_NONEXISTENT_PRINTER, 2, aszStrings, 0 );

        pscConn->fLogGenericEvent = FALSE;

        return;       // fatal error: exit
    }

    // thank the client for the command.  If we couldn't send, quit

    if ( ReplyToClient( pscConn, LPD_ACK ) != NO_ERROR )
    {
        LPD_DEBUG( "ProcessJob(): couldn't ACK to \"receive job\"\n" );

        return;
    }


    // 2 subcommands expected: "receive control file" and "receive data file"
    // They can come in any order.  (One of the two subcommands can also be
    // "abort this job" in which case we abort the job and return).

    for ( ; ; )
    {

        // don't need the previous one (in fact, pchCommand field is reused)

        if ( pscConn->pchCommand != NULL )
        {
            LocalFree( pscConn->pchCommand );

            pscConn->pchCommand = NULL;
        }

        // get the first subcommand from the client
        //   ------------------------------    N = 02, 03, or 01
        //   | N | Count | SP | Name | LF |    Count => control file length
        //   ------------------------------    Name => controlfile name

        ClientCmd = GetCmdFromClient( pscConn );
        switch ( ClientCmd  )
        {
        case CONNECTION_CLOSED:

            // performance enhancement: close the socket here and then start
            // printing: printing could take several seconds,
            // so don't tie up client


            if ( pscConn->sSock != INVALID_SOCKET )
            {
                SureCloseSocket( pscConn->sSock );
                pscConn->sSock = INVALID_SOCKET;
            }

            // if we came this far, everything went as planned.
            // tell spooler that we are done spooling: go ahead and print!

            PrintData( pscConn );
            pscConn->wState = LPDS_ALL_WENT_WELL;
            return;

        case NO_ERROR:

            // Not yet done, back to outer loop.

            break;

        case SOCKET_ERROR:

        default:

            // If we didn't get a subcommand from client, it's bad news!
            // client died or something catastophic like that!

            LOGIT(("ProcessJob:GetCmdFromClient %d failed %d.\n",
                   ClientCmd, GetLastError() ));

            return;    // the thread exits without doing anything
        }

        chSubCmdCode = pscConn->pchCommand[0];

        switch (chSubCmdCode) {

        case LPDCS_RECV_CFILE:    // N = 02 ("receive control file")

            // client is going to give us a control file: prepare for it

            pscConn->wState = LPDSS_RECVD_CFILENAME;


            // get the controlfile name, file size out of the command

            if ( ParseSubCommand( pscConn, &cbTotalDataLen, &lpFileName ) != NO_ERROR )
            {
                PCHAR   aszStrings[2]={ pscConn->szIPAddr, NULL };

                LpdReportEvent( LPDLOG_BAD_FORMAT, 1, aszStrings, 0 );

                pscConn->fLogGenericEvent = FALSE;

                return;               // fatal error: exit
            }

            // tell client we got the name of the controlfile ok

            if ( ReplyToClient( pscConn, LPD_ACK ) != NO_ERROR )
            {
                return;               // fatal error: exit
            }


            // Get the control file (we already know how big it is)

            if ( GetControlFileFromClient( pscConn, cbTotalDataLen, lpFileName ) != NO_ERROR )
            {
                LPD_DEBUG( "GetControlFileFromClient() failed in ProcessJob()\n" );

                return;
            }

            pscConn->wState = LPDSS_RECVD_CFILE;

            // tell client we got the controlfile and things look good so far!

            if ( ReplyToClient( pscConn, LPD_ACK ) != NO_ERROR )
            {
                LOGIT(("ProcessJob:%d: ReplyToClient failed %d\n",
                       __LINE__, GetLastError() ));

                return;               // fatal error: exit
            }

            break;


        case LPDCS_RECV_DFILE:        // N = 03 ("receive data file")

            pscConn->wState = LPDSS_RECVD_DFILENAME;

            // tell client we got the name of the datafile ok

            if ( ReplyToClient( pscConn, LPD_ACK ) != NO_ERROR )
            {
                LOGIT(("ProcessJob:%d: ReplyToClient failed %d\n",
                       __LINE__, GetLastError() ));

                return;               // fatal error: exit
            }


            // get the datafile name, data size out of the command

            if ( ParseSubCommand( pscConn, &cbTotalDataLen, &lpFileName ) != NO_ERROR )
            {

                PCHAR   aszStrings[2]={ pscConn->szIPAddr, NULL };

                LpdReportEvent( LPDLOG_BAD_FORMAT, 1, aszStrings, 0 );

                pscConn->fLogGenericEvent = FALSE;

                LOGIT(("ProcessJob:%d: ParseSubCommand failed %d\n",
                       __LINE__, GetLastError() ));

                return;        // fatal error: exit
            }


            // at this point, we know exactly how much data is coming.
            // Allocate buffer to hold the data.  If data is more than
            // LPD_BIGBUFSIZE, keep reading and spooling several times
            // over until data is done

            pscConn->wState = LPDSS_SPOOLING;

            pDFile = LocalAlloc( LMEM_FIXED, sizeof(DFILE_ENTRY) );

            if (pDFile == NULL) {
                LocalFree( lpFileName );

                LOGIT(("ProcessJob:%d: LocalAlloc failed %d\n",
                       __LINE__, GetLastError() ));

                return;        // Fatal Error
            }

            pDFile->cbDFileLen = cbTotalDataLen;
            pDFile->pchDFileName = lpFileName;

            if ( !GetSpoolFileName( pscConn->hPrinter, pscConn, &lpFileName ) )
            {
                LPD_DEBUG( "ERROR: GetSpoolFileName() failed in ProcessJob\n" );
                LocalFree( pDFile->pchDFileName );
                LocalFree( pDFile );
                return;
            }

            //
            // GetTempFileName has already created this file, so use OPEN_ALWAYS.
            // Also, use FILE_ATTRIBUTE_TEMPORARY so that it will be faster
            // FILE_FLAG_SEQUENTIAL_SCAN, ntbug 79854, MohsinA, 03-Jun-97.
            //

            pDFile->hDataFile = CreateFile( lpFileName,
                                            GENERIC_READ|GENERIC_WRITE,
                                            FILE_SHARE_READ,
                                            NULL,
                                            OPEN_ALWAYS,
                                            FILE_ATTRIBUTE_NORMAL
                                            |FILE_ATTRIBUTE_TEMPORARY
                                            |FILE_FLAG_DELETE_ON_CLOSE
                                            |FILE_FLAG_SEQUENTIAL_SCAN
                                            ,
                                            NULL );


            LocalFree( lpFileName );

            if ( pDFile->hDataFile == INVALID_HANDLE_VALUE )
            {
                LPD_DEBUG( "ERROR: CreatFile() failed in ProcessJob \n" );
                LocalFree( pDFile->pchDFileName );
                LocalFree( pDFile );
                return;
            }

            cbBytesToRead = (cbTotalDataLen > LPD_BIGBUFSIZE ) ?
            LPD_BIGBUFSIZE : cbTotalDataLen;

            pchDataBuf = LocalAlloc( LMEM_FIXED, cbBytesToRead );

            if ( pchDataBuf == NULL )
            {
                LOGIT(("ProcessJob:%d: LocalAlloc failed %d\n",
                       __LINE__, GetLastError() ));

                CloseHandle(pDFile->hDataFile);
                pDFile->hDataFile = INVALID_HANDLE_VALUE;
                LocalFree( pDFile->pchDFileName );
                LocalFree( pDFile );
                return;       // fatal error: exit
            }

            cbBytesSpooled = 0;

            cbBytesRemaining = cbTotalDataLen;

            // keep receiving until we have all the data client said it
            // would send

            while( cbBytesSpooled < cbTotalDataLen )
            {
                if ( ReadData( pscConn->sSock, pchDataBuf,
                                 cbBytesToRead ) != NO_ERROR )
                {
                    LPD_DEBUG( "ProcessJob:ReadData failed, job aborted)\n" );

                    LocalFree( pchDataBuf );
                    CloseHandle(pDFile->hDataFile);
                    pDFile->hDataFile = INVALID_HANDLE_VALUE;
                    LocalFree( pDFile->pchDFileName );
                    LocalFree( pDFile );
                    return;       // fatal error: exit
                }

                cbDataBufLen = cbBytesToRead;

                if ( SpoolData( pDFile->hDataFile, pchDataBuf, cbDataBufLen ) != NO_ERROR )
                {
                    LPD_DEBUG( "SpoolData() failed in ProcessJob(): job aborted)\n" );

                    LocalFree( pchDataBuf );
                    CloseHandle(pDFile->hDataFile);
                    pDFile->hDataFile = INVALID_HANDLE_VALUE;
                    LocalFree( pDFile->pchDFileName );
                    LocalFree( pDFile );
                    return;       // fatal error: exit
                }

                cbBytesSpooled += cbBytesToRead;

                cbBytesRemaining -= cbBytesToRead;

                cbBytesToRead = (cbBytesRemaining > LPD_BIGBUFSIZE ) ?
                LPD_BIGBUFSIZE : cbBytesRemaining;

            }

            LocalFree( pchDataBuf );

            InsertTailList( &pscConn->DFile_List, &pDFile->Link );

            // LPR client sends one byte (of 0 bits) after sending data

            dwErrcode = ReadData( pscConn->sSock, &chAck, 1 );

            if ( ( dwErrcode != NO_ERROR ) || (chAck != LPD_ACK ) )
            {
                return;
            }

            // tell client we got the data and things look good so far!

            if ( ReplyToClient( pscConn, LPD_ACK ) != NO_ERROR )
            {

                LOGIT(("ProcessJob:%d: ReplyToClient failed %d\n",
                       __LINE__, GetLastError() ));

                return;               // fatal error: exit
            }
            break;


        case LPDCS_ABORT_JOB:         // N = 01 ("abort this job")

            // client asked us to abort the job: tell him "ok" and quit!

            ReplyToClient( pscConn, LPD_ACK );

            pscConn->wState = LPDS_ALL_WENT_WELL;    // we did what client wanted

            return;


            // unknown subcommand: log the event and quit

        default:
        {
            PCHAR   aszStrings[2]={ pscConn->szIPAddr, NULL };

            LpdReportEvent( LPDLOG_MISBEHAVED_CLIENT, 1, aszStrings, 0 );

            pscConn->fLogGenericEvent = FALSE;

            LPD_DEBUG( "ProcessJob(): invalid subcommand, request rejected\n" );

            return;
        }

        }

    }  // done processing both subcommands

}  // end ProcessJob()

/*****************************************************************************
 *                                                                           *
 * GetControlFileFromClient():                                               *
 *    This function receives the control file from the client.  In the       *
 *    previsous subcommand, the client told us how many bytes there are in   *
 *    the control file.                                                      *
 *    Also,after reading all the bytes, we read the 1 byte "ack" from client *
 *                                                                           *
 * Returns:                                                                  *
 *    NO_ERROR if everything went well                                       *
 *    ErrorCode if something went wrong somewhere                            *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *                                                                           *
 * History:                                                                  *
 *    Jan.24, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

DWORD
GetControlFileFromClient( PSOCKCONN pscConn, DWORD FileSize, PCHAR FileName )
{

   PCHAR    pchAllocBuf;
   DWORD    cbBytesToRead;
   PCFILE_ENTRY pCFile;


   if (FileSize > LPD_MAX_CONTROL_FILE_LEN)
   {
       return( (DWORD)LPDERR_NOBUFS );
   }

   pCFile = LocalAlloc( LMEM_FIXED, sizeof(CFILE_ENTRY) );
   if (pCFile == NULL) {
       return( (DWORD)LPDERR_NOBUFS );
   }

   pCFile->cbCFileLen = FileSize;
   pCFile->pchCFileName = FileName;

      // we know how big the control file is going to be: alloc space for it
      // Client sends one byte after sending the control file: read it along
      // with the rest of the data

   cbBytesToRead = FileSize + 1;

   pchAllocBuf = LocalAlloc( LMEM_FIXED, cbBytesToRead );

   if (pchAllocBuf == NULL)
   {
      LocalFree( pCFile );

      return( (DWORD)LPDERR_NOBUFS );
   }

   // now read the data (and the trailing byte) into this allocated buffer

   if ( ReadData( pscConn->sSock, pchAllocBuf, cbBytesToRead ) != NO_ERROR )
   {
      LocalFree( pCFile );

      LocalFree( pchAllocBuf );

      return( LPDERR_NORESPONSE );
   }

      // if the trailing byte is not zero, treat it as job aborted (though
      // we don't expect this to happen really)

   if ( pchAllocBuf[cbBytesToRead-1] != 0 )
   {
      LocalFree( pchAllocBuf );

      LocalFree( pCFile );

      LPD_DEBUG( "GetControlFileFromClient: got data followed by a NAK!\n");

      return( LPDERR_JOBABORTED );
   }

   pCFile->pchCFile = pchAllocBuf;
   InsertTailList( &pscConn->CFile_List, &pCFile->Link );

   return( NO_ERROR );


}  // end GetControlFileFromClient()


/*****************************************************************************
 *                                                                           *
 * GetSpoolFileName():                                                       *
 *    This function figures out where to put the spool file.                 *
 *                                                                           *
 * Returns:                                                                  *
 *    TRUE if spool location found.                                          *
 *    FALSE if no spool location available.                                  *
 *                                                                           *
 * Parameters:                                                               *
 *    hPrinter (IN): Handle to printer for which we are spooling             *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *    ppchSpoolPath (IN-OUT): Address of pointer which will receive the      *
 *         spool path.                                                       *
 *                                                                           *
 * History:                                                                  *
 *    Nov.21, 94   JBallard                                                  *
 *                                                                           *
 *****************************************************************************/
BOOL
GetSpoolFileName
(
  HANDLE hPrinter,
  PSOCKCONN pscConn,
  PCHAR *ppchSpoolPath
)
/*++

Routine Description:

  This function comes up with a name for a spool file that we should be
  able to write to.

  Note: The file name returned has already been created.

Arguments:

  hPrinter - handle to the printer that we want a spool file for.

  ppchSpoolFileName: pointer that will receive an allocated buffer
                      containing the file name to spool to.  CALLER
                      MUST FREE.  Use LocalFree().


Return Value:

  TRUE if everything goes as expected.
  FALSE if anything goes wrong.

--*/
{
  PBYTE         pBuffer = NULL;
  DWORD         dwAllocSize;
  DWORD         dwNeeded;
  PCHAR         pchSpoolPath = NULL;
  DWORD         dwRetval;

  pchSpoolPath = LocalAlloc( LMEM_FIXED, 2 * MAX_PATH + 1 );

  if ( pchSpoolPath == NULL )
  {
    goto Failure;
  }

  //
  //  In order to find out where the spooler's directory is, we add
  //  call GetPrinterData with DefaultSpoolDirectory.
  //

  dwAllocSize = WCS_LEN( MAX_PATH + 1 );

  for (;;)
  {
    pBuffer = LocalAlloc( LMEM_FIXED, dwAllocSize );

    if ( pBuffer == NULL )
    {
        goto Failure;
    }

    if ( GetPrinterData( hPrinter,
                         SPLREG_DEFAULT_SPOOL_DIRECTORY,
                         NULL,
                         pBuffer,
                         dwAllocSize,
                         &dwNeeded ) == ERROR_SUCCESS )
    {
      break;
    }

    if ( ( dwNeeded < dwAllocSize ) ||( GetLastError() != ERROR_MORE_DATA ))
    {
      goto Failure;
    }

    //
    // Free the current buffer and increase the size that we try to allocate
    // next time around.
    //

    LocalFree( pBuffer );

    dwAllocSize = dwNeeded;
  }

  if( !GetTempFileName( (LPSTR)pBuffer, "LprSpl", 0, pchSpoolPath ))
  {
      goto Failure;
  }

  //
  //  At this point, the spool file name should be done.  Free the structure
  //  we used to get the spooler temp dir and return.
  //

  LocalFree( pBuffer );

  *ppchSpoolPath = pchSpoolPath;

  return( TRUE );

Failure:

  //
  //  Clean up and fail.
  //
  if ( pBuffer != NULL )
  {
    LocalFree( pBuffer );
  }

  if ( pchSpoolPath != NULL )
  {
    LocalFree( pchSpoolPath );
  }

  return( FALSE );
}

VOID CleanupCFile( PCFILE_ENTRY pCFile )
{
    if (pCFile->pchCFileName != NULL) {
        LocalFree( pCFile->pchCFileName );
        pCFile->pchCFileName = NULL;
    }
    if (pCFile->pchCFile != NULL) {
        LocalFree( pCFile->pchCFile );
        pCFile->pchCFile = NULL;
    }
    LocalFree( pCFile );
}

VOID CleanupDFile( PDFILE_ENTRY pDFile )
{
    if (pDFile->pchDFileName != NULL) {
        LocalFree( pDFile->pchDFileName );
        pDFile->pchDFileName = NULL;
    }
    if (pDFile->hDataFile != INVALID_HANDLE_VALUE) {
        CloseHandle(pDFile->hDataFile);
    }
    LocalFree( pDFile );
}

VOID CleanupConn( PSOCKCONN pscConn)
{
    LIST_ENTRY  *pTmpList;
    CFILE_ENTRY *pCFile;
    DFILE_ENTRY *pDFile;

    while ( !IsListEmpty( &pscConn->CFile_List ) ) {
        pTmpList = RemoveHeadList( &pscConn->CFile_List );
        pCFile = CONTAINING_RECORD( pTmpList,
                                    CFILE_ENTRY,
                                    Link );
        CleanupCFile( pCFile );
    }

    while ( !IsListEmpty( &pscConn->DFile_List ) ) {
        pTmpList = RemoveHeadList( &pscConn->DFile_List );
        pDFile = CONTAINING_RECORD( pTmpList,
                                    DFILE_ENTRY,
                                    Link );
        CleanupDFile( pDFile );
    }

    return;
}



=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\lpd\lpdstruc-x.c ===
// Dump structs of lpdstruc.h
// Generated by g:\mosh\perl\pdbg.bat.

#include "lpd.h"
#include "lpdstruc-x.h"

// ==================================================
// lpdstruc.h:22

void
print__controlfile_info( char* message, struct _controlfile_info * s )
{
    if(  message   ){
       logit( "%s\n", message );
    }
    if(  s == NULL ){
       logit( "struct _controlfile_info is NULL.\n");
       return;
    }
    logit("struct _controlfile_info = {\n" );
    logit("  pchClass        = %s\n", (s->pchClass)? (s->pchClass):"NONE" );
    logit("  pchHost         = %s\n", (s->pchHost)? (s->pchHost):"NONE" );
    logit("  dwCount         = %d\n", s->dwCount );
    logit("  pchJobName      = %s\n", (s->pchJobName)? (s->pchJobName):"NONE" );
    logit("  pchBannerName   = %s\n", (s->pchBannerName)? (s->pchBannerName):"NONE" );
    logit("  pchMailName     = %s\n", (s->pchMailName)? (s->pchMailName):"NONE" );
    logit("  pchSrcFile      = %s\n", (s->pchSrcFile)? (s->pchSrcFile):"NONE" );
    logit("  pchUserName     = %s\n", (s->pchUserName)? (s->pchUserName):"NONE" );
    logit("  pchSymLink      = %s\n", (s->pchSymLink)? (s->pchSymLink):"NONE" );
    logit("  pchTitle        = %s\n", (s->pchTitle)? (s->pchTitle):"NONE" );
    logit("  pchUnlink       = %s\n", (s->pchUnlink)? (s->pchUnlink):"NONE" );
    logit("  dwWidth         = %d\n", s->dwWidth );
    logit("  pchTrfRFile     = %s\n", (s->pchTrfRFile)? (s->pchTrfRFile):"NONE" );
    logit("  pchTrfIFile     = %s\n", (s->pchTrfIFile)? (s->pchTrfIFile):"NONE" );
    logit("  pchTrfBFile     = %s\n", (s->pchTrfBFile)? (s->pchTrfBFile):"NONE" );
    logit("  pchTrfSFile     = %s\n", (s->pchTrfSFile)? (s->pchTrfSFile):"NONE" );
    logit("  pchCIFFile      = %s\n", (s->pchCIFFile)? (s->pchCIFFile):"NONE" );
    logit("  pchDVIFile      = %s\n", (s->pchDVIFile)? (s->pchDVIFile):"NONE" );
    logit("  pchFrmtdFile    = %s\n", (s->pchFrmtdFile)? (s->pchFrmtdFile):"NONE" );
    logit("  pchPlotFile     = %s\n", (s->pchPlotFile)? (s->pchPlotFile):"NONE" );
    logit("  pchUnfrmtdFile  = %s\n", (s->pchUnfrmtdFile)? (s->pchUnfrmtdFile):"NONE" );
    logit("  pchDitroffFile  = %s\n", (s->pchDitroffFile)? (s->pchDitroffFile):"NONE" );
    logit("  pchPscrptFile   = %s\n", (s->pchPscrptFile)? (s->pchPscrptFile):"NONE" );
    logit("  pchPRFrmtFile   = %s\n", (s->pchPRFrmtFile)? (s->pchPRFrmtFile):"NONE" );
    logit("  pchFortranFile  = %s\n", (s->pchFortranFile)? (s->pchFortranFile):"NONE" );
    logit("  pchTroffFile    = %s\n", (s->pchTroffFile)? (s->pchTroffFile):"NONE" );
    logit("  pchRasterFile   = %s\n", (s->pchRasterFile)? (s->pchRasterFile):"NONE" );
    logit("  szPrintFormat   = %s\n", (s->szPrintFormat)? (s->szPrintFormat):"NONE" );
    logit("  usNumCopies     = %d\n", s->usNumCopies );
    logit( "}; // struct _controlfile_info.\n");
    return;
} /* print__controlfile_info */

// ==================================================
// lpdstruc.h:69

void
print__qstatus( char* message, struct _qstatus * s )
{
    if(  message   ){
       logit( "%s\n", message );
    }
    if(  s == NULL ){
       logit( "struct _qstatus is NULL.\n");
       return;
    }
    logit("struct _qstatus = {\n" );
    logit("  pchUserName     = %s\n", (s->pchUserName)? (s->pchUserName):"NONE" );
    logit("  cbActualUsers   = %d\n",  s->cbActualUsers );
    logit("  cbActualJobIds  = %d\n",  s->cbActualJobIds );
    logit( "}; // struct _qstatus.\n");
    return;
} /* print__qstatus */

// ==================================================
// lpdstruc.h:81

void
print__cfile_entry( char* message, struct _cfile_entry * s )
{
    if(  message   ){
       logit( "%s\n", message );
    }
    if(  s == NULL ){
       logit( "struct _cfile_entry is NULL.\n");
       return;
    }
    logit("struct _cfile_entry = {\n" );
    logit("  Link         = 0x%08x\n", s->Link );
    logit("  pchCFileName = %s\n", (s->pchCFileName)? (s->pchCFileName):"NONE" );
    logit("  pchCFile     = %s\n", (s->pchCFile)? (s->pchCFile):"NONE" );
    logit("  cbCFileLen   = %d\n",  s->cbCFileLen );
    logit( "}; // struct _cfile_entry.\n");
    return;
} /* print__cfile_entry */

// ==================================================
// lpdstruc.h:92

void
print__dfile_entry( char* message, struct _dfile_entry * s )
{
    if(  message   ){
       logit( "%s\n", message );
    }
    if(  s == NULL ){
       logit( "struct _dfile_entry is NULL.\n");
       return;
    }
    logit("struct _dfile_entry = {\n" );
    logit("  Link         = 0x%08x\n", s->Link );
    logit("  pchDFileName = %s\n",    (s->pchDFileName)? (s->pchDFileName):"NONE" );
    logit("  cbDFileLen   = %d\n",     s->cbDFileLen );
    logit("  hDataFile    = 0x%08x\n", s->hDataFile );
    logit( "}; // struct _dfile_entry.\n");
    return;
} /* print__dfile_entry */

// ==================================================
// lpdstruc.h:103

void
print__sockconn( char* message, struct _sockconn * s )
{
    if(  message   ){
       logit( "%s\n", message );
    }
    if(  s == NULL ){
       logit( "struct _sockconn is NULL.\n");
       return;
    }
    logit("struct _sockconn = {\n" );
    logit("  pNext             = 0x%08x\n", s->pNext );
    //  logit("  cbClients     = %d\n",     s->cbClients ));
    logit("  sSock             = 0x%08x\n", s->sSock );
    logit("  dwThread          = 0x%08x\n", s->dwThread );
    logit("  wState            = %d\n",     s->wState );
    logit("  fLogGenericEvent  = 0x%08x\n", s->fLogGenericEvent );
    logit("  pchCommand        = %s\n",    (s->pchCommand)? (s->pchCommand):"NONE" );
    logit("  cbCommandLen      = %d\n",     s->cbCommandLen );
    logit("  CFile_List        = 0x%08x\n", s->CFile_List );
    logit("  DFile_List        = 0x%08x\n", s->DFile_List );
    logit("  pchUserName       = %s\n",    (s->pchUserName)? (s->pchUserName):"NONE" );
    logit("  pchPrinterName    = %s\n",    (s->pchPrinterName)? (s->pchPrinterName):"NONE" );
    logit("  hPrinter          = 0x%08x\n", s->hPrinter );
    logit("  dwJobId           = %d\n",     s->dwJobId );
    logit("  LicenseHandle     = 0x%08x\n", s->LicenseHandle );
    logit("  fMustFreeLicense  = 0x%08x\n", s->fMustFreeLicense );
    logit("  pqStatus          = 0x%08x\n",(s->pqStatus? (s-> pqStatus):0) );
    logit("  bDataTypeOverride = 0x%08x\n", s->bDataTypeOverride );
    logit( "}; // struct _sockconn.\n");
    return;
} /* print__sockconn */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\lpd\lpdstruc-x.h ===
// ==================================================
// lpdstruc.h:22 

void
print__controlfile_info( char* message, struct _controlfile_info * s );
// ==================================================
// lpdstruc.h:69 

void
print__qstatus( char* message, struct _qstatus * s );
// ==================================================
// lpdstruc.h:81 

void
print__cfile_entry( char* message, struct _cfile_entry * s );
// ==================================================
// lpdstruc.h:92 

void
print__dfile_entry( char* message, struct _dfile_entry * s );
// ==================================================
// lpdstruc.h:103 

void
print__sockconn( char* message, struct _sockconn * s );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\lpd\lpdextrn.h ===
/*************************************************************************
 *                        Microsoft Windows NT                           *
 *                                                                       *
 *                  Copyright(c) Microsoft Corp., 1994                   *
 *                                                                       *
 * Revision History:                                                     *
 *                                                                       *
 *   Jan. 22,94    Koti     Created                                      *
 *                                                                       *
 * Description:                                                          *
 *                                                                       *
 *   This file contains all externs and prototypes of functions.         *
 *                                                                       *
 *************************************************************************/


#include <tcpsvcs.h>


// externs

extern SERVICE_STATUS         ssSvcStatusGLB;

extern SERVICE_STATUS_HANDLE  hSvcHandleGLB;

extern HANDLE                 hEventShutdownGLB;

extern HANDLE                 hEventLastThreadGLB;

extern HANDLE                 hLogHandleGLB;

extern SOCKCONN               scConnHeadGLB;

extern CRITICAL_SECTION       csConnSemGLB;

extern COMMON_LPD             Common;

extern DWORD                  dwMaxUsersGLB;

extern DWORD                  MaxQueueLength;

extern BOOL                   fJobRemovalEnabledGLB;

extern BOOL                   fAllowPrintResumeGLB;

extern BOOL                   fAlwaysRawGLB;

extern DWORD                  dwRecvTimeout;

extern BOOL                   fShuttingDownGLB;

extern CHAR                   szNTVersion[8];

extern LIST_ENTRY             DbgMemList;

extern CHAR                  *g_ppszStrings[];




// Prototypes

VOID ServiceEntry( DWORD dwArgc, LPTSTR *lpszArgv,
                    PTCPSVCS_GLOBAL_DATA pGlobalData );

VOID LPDCntrlHandler( DWORD dwControl );

BOOL TellSrvcController( DWORD dwCurrentState, DWORD dwWin32ExitCode,
                            DWORD dwCheckPoint, DWORD dwWaitHint);

VOID LPDCntrlHandler( DWORD dwControl );

DWORD StartLPD( DWORD dwArgc, LPTSTR *lpszArgv );

VOID StopLPD( VOID );

DWORD LoopOnAccept( LPVOID lpArgv );

VOID SureCloseSocket( SOCKET sSockToClose );

DWORD ReplyToClient( PSOCKCONN pscConn, WORD wResponse );

DWORD GetCmdFromClient( PSOCKCONN pscConn );

DWORD GetControlFileFromClient( PSOCKCONN pscConn, DWORD FileSize, PCHAR FileName );

BOOL LicensingApproval( PSOCKCONN pscConn );

DWORD ReadData(   SOCKET sDestSock, PCHAR pchBuf, DWORD cbBytesToRead );
DWORD ReadDataEx( SOCKET sDestSock, PCHAR pchBuf, DWORD cbBytesToRead );

DWORD SendData( SOCKET sDestSock, PCHAR pchBuf, DWORD cbBytesToSend );

DWORD        ServiceTheClient( PSOCKCONN pscConn );
DWORD WINAPI WorkerThread(     LPVOID    pscConn );

VOID TerminateConnection( PSOCKCONN pscConn );

VOID ProcessJob( PSOCKCONN pscConn );

VOID SendQueueStatus( PSOCKCONN  pscConn, WORD  wMode );

DWORD RemoveJobs( PSOCKCONN pscConn );

DWORD ParseSubCommand( PSOCKCONN  pscConn, DWORD *FileLen, PCHAR *FileName );

DWORD ParseControlFile( PSOCKCONN pscConn, PCFILE_ENTRY pCFileEntry );

BOOL ParseQueueName( PSOCKCONN pscConn );

BOOL InitStuff( VOID );

DWORD ResumePrinting( PSOCKCONN pscConn );

DWORD InitializePrinter( PSOCKCONN pscConn );

DWORD UpdateJobInfo( PSOCKCONN pscConn, PCFILE_INFO pCFileInfo );

DWORD UpdateJobType( PSOCKCONN pscConn, PCHAR pchDataBuf, DWORD cbDataLen);

PCHAR StoreIpAddr( PSOCKCONN pscConn );

VOID ShutdownPrinter( PSOCKCONN pscConn );

DWORD SpoolData( HANDLE hSpoolFile, PCHAR pchDataBuf, DWORD cbDataBufLen );

DWORD PrintData( PSOCKCONN pcsConn );

DWORD PrintIt( PSOCKCONN pscConn, PCFILE_ENTRY pCFileEntry, PCFILE_INFO pCFileInfo, PCHAR pFileName );

VOID AbortThisJob( PSOCKCONN pscConn );

VOID LpdFormat( PCHAR pchDest, PCHAR pchSource, DWORD dwLimit );

DWORD ParseQueueRequest( PSOCKCONN pscConn, BOOL fAgent );

INT   FillJobStatus( PSOCKCONN pscConn, PCHAR pchDest,
                    PJOB_INFO_2 pji2QState, DWORD dwNumJobs );

VOID GetClientInfo( PSOCKCONN pscConn );

VOID GetServerInfo( PSOCKCONN pscConn );

BOOL InitLogging( VOID );

VOID LpdReportEvent( DWORD idMessage, WORD wNumStrings,
                     CHAR *aszStrings[], DWORD dwErrcode );

VOID EndLogging( VOID );

VOID ReadRegistryValues( VOID );

VOID CleanupCFile( PCFILE_ENTRY pCFile );

VOID CleanupDFile( PDFILE_ENTRY pDFile );

VOID FreeStrings();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\lpd\lpdstruc.h ===
/*************************************************************************
 *                        Microsoft Windows NT                           *
 *                                                                       *
 *                  Copyright(c) Microsoft Corp., 1994                   *
 *                                                                       *
 * Revision History:                                                     *
 *                                                                       *
 *   Jan. 22,94    Koti     Created                                      *
 *   23-Jan-97     MohsinA  Fixes                                        *
 *                                                                       *
 * Description:                                                          *
 *                                                                       *
 *   This file contains structure and data type definitions used for LPD *
 *                                                                       *
 *************************************************************************/


// see rfc1179, section 7.0 and the following structure will be obvious


struct _controlfile_info
{
    PCHAR  pchClass;            // 'C'
    PCHAR  pchHost;             // 'H' (must exist)
    DWORD  dwCount;             // 'I'
    PCHAR  pchJobName;          // 'J'
    PCHAR  pchBannerName;       // 'L'
    PCHAR  pchMailName;         // 'M' (not implemented)
    PCHAR  pchSrcFile;          // 'N'
    PCHAR  pchUserName;         // 'P' (must exist)
    PCHAR  pchSymLink;          // 'S' (not implemented)
    PCHAR  pchTitle;            // 'T'
    PCHAR  pchUnlink;           // 'U' (not implemented)
    DWORD  dwWidth;             // 'W'
    PCHAR  pchTrfRFile;         // '1' (not implemented)
    PCHAR  pchTrfIFile;         // '2' (not implemented)
    PCHAR  pchTrfBFile;         // '3' (not implemented)
    PCHAR  pchTrfSFile;         // '4' (not implemented)
    PCHAR  pchCIFFile;          // 'c' (not implemented)
    PCHAR  pchDVIFile;          // 'd' (not implemented)
    PCHAR  pchFrmtdFile;        // 'f'
    PCHAR  pchPlotFile;         // 'g' (not implemented)
    PCHAR  pchUnfrmtdFile;      // 'l'
    PCHAR  pchDitroffFile;      // 'n' (not implemented)
    PCHAR  pchPscrptFile;       // 'o'
    PCHAR  pchPRFrmtFile;       // 'p' (not implemented)
    PCHAR  pchFortranFile;      // 'r' (not implemented)
    PCHAR  pchTroffFile;        // 't' (not implemented)
    PCHAR  pchRasterFile;       // 'v' (not implemented)


    // what did we conclude from the control file?

    PCHAR  szPrintFormat;
    USHORT usNumCopies;         // not in rfc, but we will put it in!
};

typedef struct _controlfile_info CFILE_INFO;
typedef CFILE_INFO  *PCFILE_INFO;

// if client request status of jobs for specific users and/or jobs, then
// he can only specify a max of these many users and a max of these many
// job ids in one lpq command (yes, this should be ample!)

#define  LPD_SP_STATUSQ_LIMIT  10


struct _qstatus
{
    PCHAR    pchUserName;
    PCHAR    ppchUsers[LPD_SP_STATUSQ_LIMIT];
    DWORD    cbActualUsers;
    DWORD    adwJobIds[LPD_SP_STATUSQ_LIMIT];
    DWORD    cbActualJobIds;
};

typedef struct _qstatus QSTATUS;
typedef QSTATUS *PQSTATUS;

struct _cfile_entry
{
    LIST_ENTRY   Link;
    PCHAR        pchCFileName;     // 0x20 name of control file
    PCHAR        pchCFile;         // 0x24 control file
    DWORD        cbCFileLen;       // 0x28 length of control file
};

typedef struct _cfile_entry CFILE_ENTRY;
typedef CFILE_ENTRY *PCFILE_ENTRY;

struct _dfile_entry
{
    LIST_ENTRY   Link;
    PCHAR        pchDFileName;     // 0xa0 name of data file
    DWORD        cbDFileLen;       // 0xa8 how many bytes in bufr are data
    HANDLE       hDataFile;
};

typedef struct _dfile_entry DFILE_ENTRY;
typedef DFILE_ENTRY *PDFILE_ENTRY;

struct _sockconn
{
    struct _sockconn *pNext;

    // WORD         cbClients;        // used only by the Head

    SOCKET       sSock;            // socket which connects us to client
    DWORD        dwThread;         // thread id of this thread
    WORD         wState;           // state of the connection
    BOOL         fLogGenericEvent; // whether any specific event is logged

    PCHAR        pchCommand;       // request command from client
    DWORD        cbCommandLen;     // length of the request command
    LIST_ENTRY   CFile_List;       // Linked list of control files
    LIST_ENTRY   DFile_List;       // Linked list of data files

    PCHAR        pchUserName;      // name of user
    PCHAR        pchPrinterName;   // name of printer we have to print to
    HANDLE       hPrinter;         // handle to this printer
    DWORD        dwJobId;          // id of this job as spooler sees it

    LS_HANDLE    LicenseHandle;    // handle used in licensing approval
    BOOL         fMustFreeLicense; // so that we know when to free it
    PQSTATUS     pqStatus;         // used only if client requests status

    CHAR         szIPAddr[INET6_ADDRSTRLEN];     // ip address of the client

    BOOL         bDataTypeOverride;// Whether or not we auto-sensed a job type

    CHAR         szServerIPAddr[INET6_ADDRSTRLEN]; // ip address of the server

    struct _sockconn *pPrev;        // doubly linked list, queue.

#ifdef PROFILING
    time_t       time_queued;
    time_t       time_start;
    time_t       time_done;
#endif
};

typedef struct _sockconn SOCKCONN;
typedef SOCKCONN *PSOCKCONN;

//
// All thread share this data.
// Update to this always protected by CRITICAL_SECTION csConnSemGLB.
//

struct _common_lpd {
    int AliveThreads;
    int TotalAccepts;
    int MaxThreads;
    int TotalErrors;
    int IdleCounter;
    int QueueLength;
};

typedef struct _common_lpd COMMON_LPD;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\lpd\log.c ===
/*************************************************************************
 *                        Microsoft Windows NT                           *
 *                                                                       *
 *                  Copyright(c) Microsoft Corp., 1994                   *
 *                                                                       *
 * Revision History:                                                     *
 *                                                                       *
 *   Jan. 29,94    Koti     Created                                      *
 *                                                                       *
 * Description:                                                          *
 *                                                                       *
 *   This file contains the functions that invoke all the EventLogging   *
 *   related functions.                                                  *
 *                                                                       *
 *************************************************************************/



#include "lpd.h"


/*****************************************************************************
 *                                                                           *
 * InitLogging():                                                            *
 *    This function prepares for future logging by registersing.             *
 *                                                                           *
 * Returns:                                                                  *
 *    TRUE if it succeeded                                                   *
 *    FALSE if it didn't                                                     *
 *                                                                           *
 * Parameters:                                                               *
 *    None                                                                   *
 *                                                                           *
 * History:                                                                  *
 *    Jan.29, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

BOOL InitLogging( VOID )
{

   hLogHandleGLB = RegisterEventSource( NULL, LPD_SERVICE_NAME );

   if ( hLogHandleGLB == (HANDLE)NULL )
   {
      LPD_DEBUG( "InitLogging(): RegisterEventSource failed\n" );

      return( FALSE );
   }

   return( TRUE );

}  // end InitLogging()





/*****************************************************************************
 *                                                                           *
 * LpdReportEvent():                                                         *
 *    This is the function where logging of events actually takes place.     *
 *                                                                           *
 * Returns:                                                                  *
 *    Nothing                                                                *
 *                                                                           *
 * Parameters:                                                               *
 *    idMessage (IN): ID of the message to be put in the log file            *
 *    wNumStrings (IN): number of strings in the "variable parts" of message *
 *    aszStrings (IN): the "variable parts" of the message                   *
 *    dwErrcode (IN): error code for the (failed) event                      *
 *                                                                           *
 * History:                                                                  *
 *    Jan.29, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

VOID
LpdReportEvent( DWORD idMessage, WORD wNumStrings,
                CHAR  *aszStrings[], DWORD dwErrcode )
{

   WORD    wType;
   DWORD   cbRawData=0;
   PVOID   pRawData=NULL;


   if ( hLogHandleGLB == NULL )
   {
      DEBUG_PRINT (("LpdReportEvent(): Log handle is NULL!  EventId <0x%x> not logged\n", idMessage));
      return;
   }

   if ( NT_INFORMATION( idMessage) )
   {
      wType = EVENTLOG_INFORMATION_TYPE;
   }
   else if ( NT_WARNING( idMessage) )
   {
      wType = EVENTLOG_WARNING_TYPE;
   }
   else if ( NT_ERROR( idMessage) )
   {
      wType = EVENTLOG_ERROR_TYPE;
   }
   else
   {
      LPD_DEBUG( "LpdReportEvent(): Unknown type of error message\n" );

      wType = EVENTLOG_ERROR_TYPE;
   }


   if ( dwErrcode != 0 )
   {
      pRawData = &dwErrcode;

      cbRawData = sizeof( dwErrcode );
   }

   ReportEvent( hLogHandleGLB, wType, 0, idMessage, NULL, wNumStrings,
                cbRawData, (LPCTSTR *)aszStrings, pRawData );
   return;

}  // end LpdReportEvent()





/*****************************************************************************
 *                                                                           *
 * EndLogging():                                                             *
 *    This function ends logging by deregistering the handle.                *
 *                                                                           *
 * Returns:                                                                  *
 *    Nothing.                                                               *
 *                                                                           *
 * Parameters:                                                               *
 *    None                                                                   *
 *                                                                           *
 * History:                                                                  *
 *    Jan.29, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

VOID EndLogging( VOID )
{

   if ( hLogHandleGLB == NULL )
   {
      LPD_DEBUG( "EndLogging(): Log handle is NULL!\n" );

      return;
   }

   DeregisterEventSource( hLogHandleGLB );

   return;

}  // end EndLogging()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\lpd\process.c ===
/*************************************************************************
 *                        Microsoft Windows NT                           *
 *                                                                       *
 *                  Copyright(c) Microsoft Corp., 1994-1997.             *
 *                                                                       *
 * Revision History:                                                     *
 *                                                                       *
 *   Jan. 24,94    Koti     Created                                      *
 *   03-May-97     MohsinA  Performance Thread Pooling                   *
 * Description:                                                          *
 *                                                                       *
 *   This file contains functions that process requests from LPR clients *
 *                                                                       *
 *************************************************************************/



#include "lpd.h"

VOID CleanupConn( PSOCKCONN pscConn);

// ========================================================================
//
//  SYNOPSIS: Thread Pooling Performance Fix.
//  AUTHOR:   MohsinA, 25-Apr-97.
//  HISTORY:  Boeing needs scalable lpd servers.
//
//  Notes:
//     This is a worker thread
//     that pulls pscConn from the global queue and services them.
//     It is created from LoopOnAccept when there are many jobs and
//     too few WorkerThread(s).
//     WorkerThread dies when there are too many idle threads or
//     when shutting down.
//

DWORD WorkerThread( PSOCKCONN pscConn )
{
    DWORD            threadid      = GetCurrentThreadId();
    int              stayalive     = 1;    // bool, loop break in cs.
    int              fIamLastThread= 0;

    int              SLEEP_TIME    = 4000; // in ms, constant per thread.
    int              time_slept    = 0;    // in ms, sum.
    int              num_jobs      = 0;    // ordinal sum.

    COMMON_LPD       local_common;

#ifdef PROFILING
    time_t           time_start    = time(NULL);
    time_t           time_done     = 0;
#endif

    // We randomize the sleep time, as we don't want all the
    // threads to wake up together. srand must be seeded for each thread.

#ifdef PROFILING
    srand( time_start );
#endif
    SLEEP_TIME = 2000 + (rand() & 0x7ff);         // 2000 to 4000.


    // We can't use this pscConn as another thread could have pulled it out.
    // Instead we go and pull another pscConn from the queue.

    pscConn  = NULL;

    while( stayalive ){

        //
        // Shutdown after emptying the queue below.
        // fShuttingDownGLB will clean the job in ServiceTheClient.
        //

        EnterCriticalSection( &csConnSemGLB );
        {
            if( scConnHeadGLB.pNext ){

                // == Remove one from the head.

                pscConn             = scConnHeadGLB.pNext;
                scConnHeadGLB.pNext = pscConn->pNext;

                pscConn->pNext      = NULL;
                Common.QueueLength--;

                // == Remove one from the tail.
                // PSOCKCONN x     = &scConnHeadGLB;
                // int       count = Common.QueueLength;
                //
                // while( x->pNext->pNext ){
                //     x = x->pNext;
                //     --count;
                //     assert( 0 < count );
                // }
                // pscConn  = x->pNext;
                // Common.QueueLength--;
                // x->pNext = NULL;
            }else{

                //
                // One thread dies after 16 idle SLEEP_TIME.
                //

                if( fShuttingDownGLB || ( Common.IdleCounter > 32 ) ){
                    Common.IdleCounter /= 2;
                    stayalive = 0;
                }else{
                    Common.IdleCounter++;
                }
                pscConn = NULL;
            }
            assert( Common.AliveThreads >= 0 );
            assert( Common.QueueLength  >= 0 );
            local_common = Common;                 // struct copy, for readonly.
        }
        LeaveCriticalSection( &csConnSemGLB );

        if( pscConn )
        {
            num_jobs++;
            ServiceTheClient( pscConn );
        }
        else if( stayalive )
        {
            // LOGIT(( "PROFILING: thread %3d sleeping %d, IdleCounter=%d\n",
            //       threadid, SLEEP_TIME, local_common.IdleCounter ));
            Sleep( SLEEP_TIME );
            time_slept += SLEEP_TIME;
        }

    } // while stayalive.

    // ====================================================================

#ifdef PROFILING
    time_done = time(NULL);
    LOGIT(("PROFILING: thread %3d ends, jobs=%d, life=%d, slept=%d,\n"
           "    AliveThreads=%d -1, MaxThreads=%d,\n"
           "    TotalAccepts=%d, TotalErrors=%d, IdleCounter=%d\n"
           "    Time now is %s"
           ,
           threadid, num_jobs, time_done - time_start, time_slept/1000,
           local_common.AliveThreads,  local_common.MaxThreads,
           local_common.TotalAccepts,  local_common.TotalErrors,
           local_common.IdleCounter,
           ctime(&time_done)
    ));
#else
    LOGIT(("WorkerThread: thread %3d ends.\n", threadid ));
#endif

    EnterCriticalSection( &csConnSemGLB );
    {
        Common.AliveThreads--;

        fIamLastThread = (Common.AliveThreads < 1 );
    }
    LeaveCriticalSection( &csConnSemGLB );


    if( fIamLastThread && fShuttingDownGLB ){
        LOGIT(("WorkerThread: Last worker thread exiting\n"));
        SetEvent( hEventLastThreadGLB );
    }

    return NO_ERROR;  // Thread Ends.
}


/*
 ****************************************************************************
 *                                                                           *
 * ServiceTheClient():                                                       *
 *    This function reads and interprets the request from the LPR client and *
 *    takes appropriate action.  In that sense, this routine is the heart of *
 *    LPD service.                                                           *
 *                                                                           *
 * Returns:                                                                  *
 *    NO_ERROR (always)                                                      *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *                                                                           *
 * History:                                                                  *
 *    Jan.24, 94   Koti   Created                                            *
 *                                                                           *
 ****************************************************************************
 */



DWORD ServiceTheClient( PSOCKCONN pscConn )
{

    DWORD    dwErrcode;
    DWORD    dwResponse;
    CHAR     chCmdCode;
    DWORD    threadid  = GetCurrentThreadId();


    pscConn->fLogGenericEvent = TRUE;
    pscConn->dwThread         = threadid;
    pscConn->hPrinter         = (HANDLE)INVALID_HANDLE_VALUE;

#ifdef PROFILING
    pscConn->time_start       = time(NULL);
#endif

    if ( fShuttingDownGLB  ){
        LOGIT(("ServiceTheClient: Thread %3d shutting down.\n", threadid ));
        goto ServiceTheClient_BAIL;
    }

    // who are we connected to?

    GetClientInfo( pscConn );

    //
    // get server ip address, since print clustering allows one
    // node to have multiple ip addresses.  Depending on the ip
    // address, we'll go to different sets of print queues on the node.
    //
    // Albert Ting cluster change, MohsinA, 07-Mar-97.
    //

    GetServerInfo( pscConn );

    // get command from the client
    //   -----------------          command 02 => "Receive Job"
    //   | 02 | Queue LF |          Queue => Queue or Printer to print on
    //   -----------------

    if ( GetCmdFromClient( pscConn ) != NO_ERROR )
    {
        // didn't get a command from client: it's bad news!

        LPD_DEBUG( "GetCmdFromClient() failed in ServiceTheClient()!\n" );

        goto ServiceTheClient_BAIL;
    }


    // get name of the queue (printer) from the command.  If it's not
    // formatted properly, quit!

    if ( !ParseQueueName( pscConn ) )
    {
        PCHAR   aszStrings[2]={ pscConn->szIPAddr, NULL };

        LpdReportEvent( LPDLOG_BAD_FORMAT, 1, aszStrings, 0 );

        pscConn->fLogGenericEvent = FALSE;

        LPD_DEBUG( "ParseQueueName() failed in ServiceTheClient()!\n" );

        goto ServiceTheClient_BAIL;
    }


    // ====================================================================

    chCmdCode = pscConn->pchCommand[0];

    switch( chCmdCode )
    {
    case LPDC_RECEIVE_JOB:

        pscConn->wState = LPDS_RECEIVE_JOB;

        ProcessJob( pscConn );
        CleanupConn( pscConn );

        if ( pscConn->wState != LPDS_ALL_WENT_WELL )
        {
            AbortThisJob( pscConn );

            if ( pscConn->fLogGenericEvent )
            {
                PCHAR   aszStrings[2]={ pscConn->szIPAddr, NULL };

                LpdReportEvent( LPDLOG_DIDNT_WORK, 1, aszStrings, 0 );
            }
        }

        if (pscConn->fMustFreeLicense)
        {
            NtLSFreeHandle(pscConn->LicenseHandle);
        }
        break;


    case LPDC_RESUME_PRINTING:

        pscConn->wState = LPDS_RESUME_PRINTING;

        if ( fAllowPrintResumeGLB )
        {
            dwResponse = ( ResumePrinting( pscConn ) == NO_ERROR ) ?
            LPD_ACK : LPD_NAK;
        }
        else
        {
            dwResponse = LPD_NAK;
        }

        dwErrcode = ReplyToClient( pscConn, (WORD)dwResponse );

        break;


    case LPDC_SEND_SHORTQ:

    case LPDC_SEND_LONGQ:

        pscConn->wState = LPDS_SEND_LONGQ;

        if ( ParseQueueRequest( pscConn, FALSE ) != NO_ERROR )
        {
            LPD_DEBUG( "ServiceTheClient(): ParseQueueRequest() failed\n" );

            break;
        }

        SendQueueStatus( pscConn, LPD_LONG );

        break;


    case LPDC_REMOVE_JOBS:

        if ( !fJobRemovalEnabledGLB )
        {
            break;
        }

        pscConn->wState = LPDS_REMOVE_JOBS;

        if ( ParseQueueRequest( pscConn, TRUE ) != NO_ERROR )
        {
            LPD_DEBUG( "ServiceTheClient(): ParseQueueRequest() failed\n" );

            break;
        }

        if ( RemoveJobs( pscConn ) == NO_ERROR )
        {
            ReplyToClient( pscConn, LPD_ACK );
        }

        break;

    default:

        break;
    }

    // ====================================================================

    if ( pscConn->wState != LPDS_ALL_WENT_WELL ){
        goto ServiceTheClient_BAIL;
    }

#ifdef PROFILING
    pscConn->time_done = time(NULL);
    LOGIT(("PROFILING: ok, thread %3d, time_queued %s"
           "           wait=%d, work=%d\n",
           threadid,
           ctime(&pscConn->time_queued),
           pscConn->time_start - pscConn->time_queued,
           pscConn->time_done  - pscConn->time_start
    ));
#endif

    // close the connection down and terminate the thread

    TerminateConnection( pscConn );
    pscConn = NULL;

    return NO_ERROR;

    // ====================================================================
    // if we reached here, then a non-recoverable error occured somewhere:
    // try to inform the client (by sending a NAK) and terminate the thread

  ServiceTheClient_BAIL:

#ifdef PROFILING
    pscConn->time_done = time(NULL);
    LOGIT(("PROFILING: bail, thread %3d, job times %8d, wait=%d work=%d\n",
           threadid,
           pscConn->time_queued,
           pscConn->time_start - pscConn->time_queued,
           pscConn->time_done  - pscConn->time_start
    ));
#endif

    LPD_DEBUG( "Reached ServiceTheClient_BAIL.\n" );
    ReplyToClient( pscConn, LPD_NAK );
    TerminateConnection( pscConn );
    pscConn = NULL;

    return NO_ERROR;

}  // end ServiceTheClient()


/*****************************************************************************
 *                                                                           *
 * TerminateConnection():                                                    *
 *    This function releases all the memory that was allocated while         *
 *    processing the client's requests, closes the printer, closes the       *
 *    socket connection, removes its structure (pscConn) from the global     *
 *    linked list and frees the memory allocated for pscConn itself.         *
 *    Also, if the main thread is waiting on this thread for shutdown then   *
 *    this function sets hEventLastThreadGLB event to tell the main thread   *
 *    that this thread is done.                                              *
 *                                                                           *
 * Returns:                                                                  *
 *    Nothing                                                                *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *                                                                           *
 * History:                                                                  *
 *    Jan.24, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

VOID TerminateConnection( PSOCKCONN pscConn )
{

    // PSOCKCONN   pscCurrent;
    // BOOL        fIamLastThread=FALSE;

    // it should never be NULL at this point!  But check it anyway!

    if ( pscConn == (PSOCKCONN) NULL )
    {
        LPD_DEBUG( "TerminateConnection(): pscConn NULL at entry\n" );
        return;
    }

    ShutdownPrinter( pscConn );

    if ( pscConn->hPrinter != (HANDLE)INVALID_HANDLE_VALUE )
    {
        LPD_DEBUG( "TerminateConnection: hPrinter not closed\n" );
    }

    // close the socket

    if ( pscConn->sSock != INVALID_SOCKET )
    {
        SureCloseSocket( pscConn->sSock );
    }

    //
    // release memory in every field of the structure
    //

    if ( pscConn->pchCommand != NULL )
        LocalFree( pscConn->pchCommand );

    if ( pscConn->pchPrinterName != NULL )
        LocalFree( pscConn->pchPrinterName );

    //
    // no memory was allocated for ppchUsers[] and adwJobIds[].  They just
    // pointed to parts of what's freed by ( pscConn->pchCommand ) above.
    //

    if ( pscConn->pqStatus != NULL )
        LocalFree( pscConn->pqStatus );

    // EnterCriticalSection( &csConnSemGLB );
    // {
    //
    //  if( Common.AliveThreads <= 1 ){
    //     fIamLastThread = TRUE;
    //  }
    //
    //  //
    //  // // remove this structure from the link
    //  //
    //  // pscCurrent = &scConnHeadGLB;
    //  //
    //  // while( pscCurrent ){
    //  //     if (pscConn == pscCurrent->pNext)
    //  //         break;
    //  //     pscCurrent = pscCurrent->pNext;
    //  //
    //  //     // what if we can't find our pscConn in the list at all?
    //  //     // this should NEVER ever happen, but good to check!
    //  //
    //  //     if( pscCurrent == NULL)
    //  //     {
    //  //         LocalFree( pscConn );
    //  //         LPD_DEBUG( "TerminateConnection(): "
    //  //                    "couldn't find pscConn "
    //  //                    " in the list!\n" );
    //  //         LeaveCriticalSection( &csConnSemGLB );
    //  //         return;
    //  //     }
    //  // }
    //  // pscCurrent->pNext = pscConn->pNext;
    // }
    // LeaveCriticalSection( &csConnSemGLB );

    memset( pscConn, 0, sizeof( SOCKCONN ) );

    LocalFree( pscConn );

    // //
    // // if shutdown is in progress and we are the last active thread, tell
    // // the poor main thread (blocked for us to finish) that we're done!
    // //
    //
    // if( fIamLastThread && fShuttingDownGLB ){
    //     LOGIT(("TerminateConnection: Last worker thread exiting\n"));
    //     SetEvent( hEventLastThreadGLB );
    // }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\lpd\service.c ===
/*************************************************************************
 *                        Microsoft Windows NT                           *
 *                                                                       *
 *                  Copyright(c) Microsoft Corp., 1994                   *
 *                                                                       *
 * Revision History:                                                     *
 *                                                                       *
 *   Jan. 22,94    Koti     Created                                      *
 *                                                                       *
 * Description:                                                          *
 *                                                                       *
 *   This file contains functions that enable LPD service to interact    *
 *   with the Service Controller                                         *
 *                                                                       *
 *************************************************************************/


#include "lpd.h"
#include <tcpsvcs.h>


/*****************************************************************************
 *                                                                           *
 * Service  Entry():                                                         *
 *    Entry point called by the Service Controller.  This function returns   *
 *    only when the service is stopped.                                      *
 *                                                                           *
 * Returns:                                                                  *
 *    Nothing                                                                *
 *                                                                           *
 * Parameters:                                                               *
 *    dwArgc (IN): number of arguments passed in                             *
 *    lpszArgv (IN): arguments to this function (array of null-terminated    *
 *                   strings).  First arg is the name of the service and the *
 *                   remaining are the ones passed by the calling process.   *
 *                   (e.g. net start lpd /p:xyz)                             *
 *                                                                           *
 * History:                                                                  *
 *    Jan.22, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

VOID ServiceEntry( DWORD dwArgc, LPTSTR *lpszArgv,
                    PTCPSVCS_GLOBAL_DATA pGlobalData )
{

    DWORD   dwErrcode;

    DBG_TRACEIN( "ServiceEntry" );

    // Register our control handler

    hSvcHandleGLB = RegisterServiceCtrlHandler (LPD_SERVICE_NAME, LPDCntrlHandler );
    if (hSvcHandleGLB == 0)
    {
        LOGIT(( "ServiceEntry: RegisterServiceCtrlHandler() failed %d\n", GetLastError() ));
        return;
    }

    // Initialize events, objects; event logging etc.
    if (!InitStuff())
    {
        LPD_DEBUG( "ServiceEntry: InitStuff() failed\n" );
        return;
    }

    // Tell the Service Controller that we are starting
    if (!TellSrvcController( SERVICE_START_PENDING, NO_ERROR, 1, LPD_WAIT_HINT ))
    {
        LPD_DEBUG ("ServiceEntry: TellSrvcController(SERVICE_START_PENDING)" " failed\n");

        EndLogging();
        FreeStrings();
        DeleteCriticalSection (&csConnSemGLB);
        return;
    }

    // Ok, this is where we start the service (and keep it running)
    dwErrcode = StartLPD (dwArgc, lpszArgv);
    if (dwErrcode != NO_ERROR)
    {
        LOGIT (("ServiceEntry: StartLPD() failed %d\n", GetLastError()));
        LpdReportEvent( LPDLOG_LPD_DIDNT_START, 0, NULL, dwErrcode);

        EndLogging();
        FreeStrings();
        DeleteCriticalSection (&csConnSemGLB);
        return;
    }


    // Tell the Service Controller that we are up and running
    // If we have trouble telling srv controller, stop LPD and return

    if (!TellSrvcController (SERVICE_RUNNING, NO_ERROR, 0, 0))
    {
        LPD_DEBUG( "TellSrvcController(): stopping LPD and quitting!\n" );

        StopLPD ();
        TellSrvcController (SERVICE_STOPPED, NO_ERROR, 0, 0);

        EndLogging();
        FreeStrings();
        DeleteCriticalSection (&csConnSemGLB);
        DBG_TRACEOUT ("ServiceEntry");
        return;
    }

    LPD_DEBUG ("Started LpdSvc successfully\n");
    LpdReportEvent (LPDLOG_LPD_STARTED, 0, NULL, 0);

    // wait here until SetEvent is invoked (i.e. LPD is stopped or shutdown)
    WaitForSingleObject (hEventShutdownGLB, INFINITE);

    // ************************************
    // ******* Time to stop Service *******
    // ************************************

    // Tell the Service Controller that we are going to stop now!
    if (!TellSrvcController (SERVICE_STOP_PENDING, NO_ERROR, 1, LPD_WAIT_HINT))
    {
        LPD_DEBUG( "TellSrvcController( SERVICE_STOP_PENDING, .. ) failed\n" );
    }

    // Stop the LPD service

    StopLPD();
    FreeStrings();
    DBG_DUMPLEAKS();
    LPD_DEBUG ("ServiceEntry: Stopped LpdSvc successfully\n");
    LpdReportEvent (LPDLOG_LPD_STOPPED, 0, NULL, 0);
    EndLogging ();
    DBG_UNINIT ();
    DeleteCriticalSection (&csConnSemGLB);

#ifdef DBG
    if(LogFile)
    {
        stoplogging( LogFile );
    }
#endif

    // if we can still connect, tell the Service Controller that we are gone!
    if ( hSvcHandleGLB != 0 )
    {
        TellSrvcController( SERVICE_STOPPED, NO_ERROR, 0, 0 );
    }

}  // end ServiceEntry()





/*****************************************************************************
 *                                                                           *
 * TellSrvcController():                                                     *
 *    This function updates the status of our service (LPD) with the Service *
 *    Controller.                                                            *
 *                                                                           *
 * Returns:                                                                  *
 *    TRUE if everything went ok                                             *
 *    FALSE if something went wrong                                          *
 *                                                                           *
 * Parameters:                                                               *
 *    The four parameters correspond to the 2nd, 4th, 6th and 7th parameters *
 *    respectively of the SERVICE_STATUS structure passed to the             *
 *    SetServiceStatus call.                                                 *
 *                                                                           *
 * History:                                                                  *
 *    Jan.22, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

BOOL TellSrvcController( DWORD dwCurrentState, DWORD dwWin32ExitCode,
                         DWORD dwCheckPoint, DWORD dwWaitHint)
{

   BOOL   fResult;

   LOGIT(( "Entering TellSrvcController %d\n", dwCurrentState ));


   // initialize the service status structure

   ssSvcStatusGLB.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
   ssSvcStatusGLB.dwCurrentState = dwCurrentState;
   ssSvcStatusGLB.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                    SERVICE_ACCEPT_PAUSE_CONTINUE |
                                    SERVICE_ACCEPT_SHUTDOWN;
   ssSvcStatusGLB.dwWin32ExitCode = dwWin32ExitCode;
   ssSvcStatusGLB.dwServiceSpecificExitCode = NO_ERROR;
   ssSvcStatusGLB.dwCheckPoint = dwCheckPoint;
   ssSvcStatusGLB.dwWaitHint = dwWaitHint;


   // Tell the Service Controller what our status is

   fResult = SetServiceStatus( hSvcHandleGLB, &ssSvcStatusGLB );


   DBG_TRACEOUT( "TellSrvcController" );

   return (fResult);

}  // end TellSrvcController()





/*****************************************************************************
 *                                                                           *
 * LPDCntrlHandler():                                                        *
 *    This function gets called (indirectly by the Service Controller)       *
 *    whenever there is a control request for the LPD service.  Depending on *
 *    the control request, this function takes appropriate action.           *
 *                                                                           *
 * Returns:                                                                  *
 *    Nothing                                                                *
 *                                                                           *
 * Parameters:                                                               *
 *    dwControl (IN): The requested control code.                            *
 *                                                                           *
 * History:                                                                  *
 *    Jan.22, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

VOID LPDCntrlHandler( DWORD dwControl )
{

    BOOL   fMustStopSrvc=FALSE;
    time_t now;

    time( &now );
    LOGIT(("Entering LPDCntrlHandler %d at %s", dwControl, ctime(&now) ));

    switch( dwControl )
    {
        // Treat _STOP and _SHUTDOWN in the same manner
    case SERVICE_CONTROL_STOP:
        LOGIT(("LPDCntrlHandler: SERVICE_CONTROL_STOP\n"));

    case SERVICE_CONTROL_SHUTDOWN:
        LOGIT(("LPDCntrlHandler: SERVICE_CONTROL_SHUTDOWN\n"));
        ssSvcStatusGLB.dwCurrentState = SERVICE_STOP_PENDING;
        ssSvcStatusGLB.dwCheckPoint = 0;

        fMustStopSrvc = TRUE;
        break;

        // don't accept any new connections: the service is now PAUSED
    case SERVICE_CONTROL_PAUSE:
        LOGIT(("LPDCntrlHandler: SERVICE_CONTROL_PAUSE\n"));
        ssSvcStatusGLB.dwCurrentState = SERVICE_PAUSED;
        break;

        // the service was paused earlier: continue it now
    case SERVICE_CONTROL_CONTINUE:
        LOGIT(("LPDCntrlHandler: SERVICE_CONTROL_CONTINUE\n"));
        ssSvcStatusGLB.dwCurrentState = SERVICE_RUNNING;
        break;

        // we don't do anything with this
    case SERVICE_CONTROL_INTERROGATE:
        LOGIT(("LPDCntrlHandler: SERVICE_CONTROL_INTERROGATE\n"));
        break;

    default:
        LOGIT(("Unknown control word received in LPDCntrlHandler\n"));
        break;
    }

    // Update the status (even if it didn't change!) with Service Controller

    SetServiceStatus( hSvcHandleGLB, &ssSvcStatusGLB );


    // If we must stop or shutdown the service, set our shutdown event

    if ( fMustStopSrvc )
    {
        fShuttingDownGLB = 1;
        SetEvent( hEventShutdownGLB );
        LOGIT(("LPDCntrlHandler: fShuttingDownGLB=%d\n", fShuttingDownGLB ));
    }

    DBG_TRACEOUT( "LPDCntrlHandler" );

}  // end LPDCntrlHandler()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\lpd\parse.c ===
/*************************************************************************
 *                        Microsoft Windows NT                           *
 *                                                                       *
 *                  Copyright(c) Microsoft Corp., 1994                   *
 *                                                                       *
 * Revision History:                                                     *
 *                                                                       *
 *   Jan. 24,94    Koti     Created                                      *
 *                                                                       *
 * Description:                                                          *
 *                                                                       *
 *   This file contains functions for parsing the commands/control file  *
 *   sent by the LPR client.                                             *
 *                                                                       *
 *************************************************************************/



#include "lpd.h"

/*****************************************************************************
 *                                                                           *
 * LicensingApproval():                                                      *
 *    This function passes the username or hostname to the licensing dll.    *
 *    The dll does whatever it needs to do and returns either a success in   *
 *    which case we continue with printing, or a failure in which case we    *
 *    refuse to print.                                                       *
 *                                                                           *
 * Returns:                                                                  *
 *    TRUE if licensing approves and we should continue with printing        *
 *    FALSE if licensing disapproves and we should refuse printing           *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *                                                                           *
 * History:                                                                  *
 *    Nov.21, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

BOOL LicensingApproval( PSOCKCONN pscConn )
{

   NT_LS_DATA        LsData;
   LS_STATUS_CODE    err;
   LS_HANDLE         LicenseHandle;
   BOOL              fRetval;


   fRetval = FALSE;

   LsData.DataType = NT_LS_USER_NAME;
   LsData.Data = (VOID *) pscConn->pchUserName;
   LsData.IsAdmin = FALSE;

   err = NtLicenseRequest(LPD_SERVICE_USRFRIENDLY_NAME,
                          szNTVersion,
                          &LicenseHandle,
                          &LsData);

   switch (err)
   {
     case LS_SUCCESS:
        pscConn->LicenseHandle = LicenseHandle;
        pscConn->fMustFreeLicense = TRUE;
        fRetval = TRUE;
        break;

     case LS_INSUFFICIENT_UNITS:
        LPD_DEBUG( "LicensingApproval(): request rejected\n" );
        break;

     case LS_RESOURCES_UNAVAILABLE:
        LPD_DEBUG( "LicensingApproval(): no resources\n" );
        break;

     default:
        LPD_DEBUG( "LicensingApproval(): got back an unknown error code\n" );
   }

   return( fRetval );

}  // end LicensingApproval()


/*****************************************************************************
 *                                                                           *
 * ParseQueueName():                                                         *
 *    This function parses the first comand from the client to retrieve the  *
 *    name of the queue (printer).                                           *
 *                                                                           *
 * Returns:                                                                  *
 *    TRUE if we successfully got the queue name                             *
 *    FALSE if something went wrong somewhere                                *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *                                                                           *
 * Notes:                                                                    *
 *    We are parsing a string (command) that's of the following form:        *
 *                                                                           *
 *      ------------------                                                   *
 *      | N | Queue | LF |            where N=02 or 03                       *
 *      ------------------                  Queue = name of the queue        *
 *      1byte  .....  1byte                                                  *
 *                                                                           *
 *    This may not work in the case of GetQueue commands since the format    *
 *    may include space and list, too.  ParseQueueRequest takes care of it.  *
 *                                                                           *
 * History:                                                                  *
 *    Jan.25, 94   Koti   Created                                            *
 *    Mar 04, 97,  MohsinA  Albert Ting Cluster prefix with ip address.      *
 *****************************************************************************/

BOOL ParseQueueName( PSOCKCONN  pscConn )
{

    PCHAR             pchPrinterName;
    DWORD             cbPrinterNameLen;
    DWORD             cbServerPrefixLen;


    // make sure Queue length is at least 1 byte
    // (i.e. command is at least 3 bytes long)

    if ( pscConn->cbCommandLen < 3 ){
        LPD_DEBUG( "Bad command in GetQueueName(): len < 3 bytes\n" );
        return( FALSE );
    }
    if( pscConn->szServerIPAddr == NULL ){
        LPD_DEBUG( "ParseQueueName_: pscConn->szServerIPAddr NULL.\n" );
        return FALSE ;
    }

    // What they call Queue in rfc1179, we call it Printer!
    //
    // We need to fully qualify the printer name with \\x.x.x.x\printer
    // since there may be multiple addresses with print clustering.
    // Prepend "\\x.x.x.x\" to regular name.

    cbPrinterNameLen = pscConn->cbCommandLen - 2 +
    2 + strlen( pscConn->szServerIPAddr ) + 1;


    pchPrinterName = LocalAlloc( LMEM_FIXED, cbPrinterNameLen+1 );

    if ( pchPrinterName == NULL ){
        LPD_DEBUG( "LocalAlloc failed in GetQueueName()\n" );
        return( FALSE );
    }

    // Format the prefix of the printer name \\x.x.x.x\.

    sprintf( pchPrinterName, "\\\\%s\\", pscConn->szServerIPAddr );
    cbServerPrefixLen = strlen( pchPrinterName );

    // Append the printer name.

    strncpy( &pchPrinterName[cbServerPrefixLen],
             &(pscConn->pchCommand[1]),
             cbPrinterNameLen - cbServerPrefixLen );

    pchPrinterName[cbPrinterNameLen] = '\0';

    pscConn->pchPrinterName = pchPrinterName;


    return( TRUE );

}  // end ParseQueueName()

/*****************************************************************************
 *                                                                           *
 * ParseSubCommand():                                                        *
 *    This function parses the subcommand to get the count and of how many   *
 *    bytes are to come (as control file or data) and name of the control    *
 *    file or data file, as the case may be.  pscConn->wState decides which  *
 *    subcommand is being parsed.                                            *
 *                                                                           *
 * Returns:                                                                  *
 *    NO_ERROR if everything went well                                       *
 *    ErrorCode if something went wrong somewhere                            *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *                                                                           *
 * Notes:                                                                    *
 *    We are parsing a string (subcommand) that's of the following form:     *
 *                                                                           *
 *      ------------------------------                                       *
 *      | N | Count | SP | Name | LF |       where N = 02 for Control file   *
 *      ------------------------------                 03 for Data file      *
 *      1byte  ..... 1byte ....  1byte                                       *
 *                                                                           *
 * History:                                                                  *
 *    Jan.25, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

DWORD ParseSubCommand( PSOCKCONN  pscConn, DWORD *FileLen, PCHAR *FileName )
{

   PCHAR    pchFileName=NULL;
   PCHAR    pchPtr;
   DWORD    dwFileLen=0;
   DWORD    dwFileNameLen=0;
   DWORD    dwParseLen;
   DWORD    dwParsedSoFar;
   WORD     i;


   pchPtr = &pscConn->pchCommand[1];

   dwParseLen = pscConn->cbCommandLen;

   dwParsedSoFar = 1;      // since we're starting from 2nd byte


   // pchPtr now points at the "Count" field of the subcommand


      // find out how long the file is

   dwFileLen = atol( pchPtr );

   if ( dwFileLen <= 0 )
   {
      return( LPDERR_BADFORMAT );
   }

      // go to the next field

   while ( !IS_WHITE_SPACE( *pchPtr ) )
   {
      pchPtr++;

      if ( ++dwParsedSoFar >= dwParseLen )
      {
         return( LPDERR_BADFORMAT );
      }
   }

      // skip any trailing white space

   while ( IS_WHITE_SPACE( *pchPtr ) )
   {
      pchPtr++;

      if ( ++dwParsedSoFar >= dwParseLen )
      {
         return( LPDERR_BADFORMAT );
      }
   }


   // pchPtr now points at the "Name" field of the subcommand


      // find out how long the filename is (the subcommand is terminated
      // by LF character)

   while( pchPtr[dwFileNameLen] != LF )
   {
      dwFileNameLen++;

      if ( ++dwParsedSoFar >= dwParseLen )
      {
         return( LPDERR_BADFORMAT );
      }
   }


   pchFileName = (PCHAR)LocalAlloc( LMEM_FIXED, (dwFileNameLen + 1) );

   if ( pchFileName == NULL )
   {
      return( LPDERR_NOBUFS );
   }

   for ( i=0; i<dwFileNameLen; i++ )
   {
      pchFileName[i] = pchPtr[i];
   }
   pchFileName[dwFileNameLen] = '\0';

      // is it a control file name or data file name that we parsed?

   *FileName = pchFileName;

   *FileLen = dwFileLen;

   return( NO_ERROR );


}  // end ParseSubCommand()

/*****************************************************************************
 *                                                                           *
 * ParseQueueRequest():                                                      *
 *    This function parses the subcommand sent by the client to request the  *
 *    status of the queue or to request removing of job(s).                  *
 *                                                                           *
 * Returns:                                                                  *
 *    NO_ERROR if everything went well                                       *
 *    ErrorCode if something went wrong somewhere                            *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *    fAgent (IN): whether to look for the Agent field.                      *
 *                                                                           *
 * Notes:                                                                    *
 *    We are parsing a string that's like one of the following:              *
 *                                                                           *
 *      ------------------------------      N=03 (Short Q), 04 (Long Q)      *
 *      | N | Queue | SP | List | LF |      Queue = name of the Q (printer)  *
 *      ------------------------------      List = user name and/or job-ids  *
 *      1byte  ..... 1byte .....  1byte                                      *
 *  OR                                                                       *
 *      --------------------------------------------                         *
 *      | 05 | Queue | SP | Agent | SP | List | LF |                         *
 *      --------------------------------------------                         *
 *      1byte  ..... 1byte .....  1byte       1byte                          *
 *                                                                           *
 * History:                                                                  *
 *    Jan.25, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

DWORD ParseQueueRequest( PSOCKCONN pscConn, BOOL fAgent )
{

   PCHAR      pchPrinterName;
   PCHAR      pchPrinterNameFQN;
   PCHAR      pchPtr;
   DWORD      cbPrinterNameLen;
   DWORD      cbPrefixLen;
   DWORD      dwParseLen;
   DWORD      dwParsedSoFar;
   PQSTATUS   pqStatus;


   //
   // ParseQueueName had allocated it: free it and reparse because
   // it was parsed for the most common case, not for the Queue case
   //

   if (pscConn->pchPrinterName)
   {
      LocalFree( pscConn->pchPrinterName );

      pscConn->pchPrinterName = NULL;
   }


   // get the printer (queue) name from the command request

      // make sure Queue length is at least 1 byte
      // (i.e. command is at least 4 bytes long)

   if ( pscConn->cbCommandLen < 4 )
   {
      LPD_DEBUG( "ParseQueueRequest(): error: len shorter than 4 bytes\n" );

      return( LPDERR_BADFORMAT );
   }

   cbPrefixLen = 2 + strlen( pscConn->szServerIPAddr ) + 1;

   // alloc buffer to store printer name (yes, allocating more than needed)

   pchPrinterName = LocalAlloc( LMEM_FIXED, (pscConn->cbCommandLen+cbPrefixLen) );

   if ( pchPrinterName == NULL )
   {
      LPD_DEBUG( "LocalAlloc failed in GetQueueName()\n" );

      return( LPDERR_NOBUFS );
   }

   pchPrinterNameFQN = pchPrinterName;

   // Format the prefix of the printer name \\x.x.x.x\.
   sprintf( pchPrinterName, "\\\\%s\\", pscConn->szServerIPAddr );

   // advance the pointer to point to start of the printer name
   pchPrinterName += strlen( pchPrinterName );

   dwParseLen = pscConn->cbCommandLen;

   cbPrinterNameLen = 0;

   pchPtr = &(pscConn->pchCommand[1]);

   while ( !IS_WHITE_SPACE( *pchPtr ) && ( *pchPtr != LF ) )
   {
      pchPrinterName[cbPrinterNameLen] = *pchPtr;

      pchPtr++;

      cbPrinterNameLen++;

      if (cbPrinterNameLen >= dwParseLen )
      {
         LPD_DEBUG( "ParseQueueRequest(): bad request (no SP found!)\n" );
         LocalFree( pchPrinterNameFQN );
         return( LPDERR_BADFORMAT );
      }
   }

   pchPrinterName[cbPrinterNameLen] = '\0';

   pscConn->pchPrinterName = pchPrinterNameFQN;

   dwParsedSoFar = cbPrinterNameLen + 1;   // we started parsing from 2nd byte


      // skip any trailing white space

   while ( IS_WHITE_SPACE( *pchPtr ) )
   {
      pchPtr++;

      if ( ++dwParsedSoFar >= dwParseLen )
      {
         return( LPDERR_BADFORMAT );
      }
   }

      // quite often, lpq won't specify any users or job-ids (i.e., the "List"
      // field in the command is skipped).  If so, we are done!

   if ( *pchPtr == LF )
   {
      return( NO_ERROR );
   }

      // first, create a QSTATUS structure

   pscConn->pqStatus = (PQSTATUS)LocalAlloc( LMEM_FIXED, sizeof(QSTATUS) );

   if ( pscConn->pqStatus == NULL )
   {
      return( LPDERR_NOBUFS );
   }

   pqStatus = pscConn->pqStatus;

   pqStatus->cbActualJobIds = 0;

   pqStatus->cbActualUsers = 0;

   pqStatus->pchUserName = NULL;

      // if we have been called to parse command code 05 ("Remove Jobs")
      // then get the username out of the string

   if ( fAgent )
   {
      pqStatus->pchUserName = pchPtr;

         // skip this field and go to the "List" field

      while ( !IS_WHITE_SPACE( *pchPtr ) )
      {
         pchPtr++;

         if ( ++dwParsedSoFar >= dwParseLen )
         {
            return( LPDERR_BADFORMAT );
         }
      }

      *pchPtr++ = '\0';

         // skip any trailing white space

      while ( IS_WHITE_SPACE( *pchPtr ) )
      {
         pchPtr++;

         if ( ++dwParsedSoFar >= dwParseLen )
         {
            return( LPDERR_BADFORMAT );
         }
      }
   }

   while ( *pchPtr != LF )
   {
         // if we reached the limit, stop parsing!

      if ( ( pqStatus->cbActualJobIds == LPD_SP_STATUSQ_LIMIT ) ||
           ( pqStatus->cbActualUsers == LPD_SP_STATUSQ_LIMIT ) )
      {
         break;
      }

         // skip any trailing white space

      while ( IS_WHITE_SPACE( *pchPtr ) )
      {
         pchPtr++;

         if ( ++dwParsedSoFar >= dwParseLen )
         {
            return( LPDERR_BADFORMAT );
         }
      }

      if ( *pchPtr == LF )
      {
        *pchPtr = '\0';
         return( NO_ERROR );
      }

         // is this a job id?

      if ( isdigit( *pchPtr ) )
      {
         pqStatus->adwJobIds[pqStatus->cbActualJobIds++] = atol( pchPtr );
      }
      else  // nope, it's user name
      {
         pqStatus->ppchUsers[pqStatus->cbActualUsers++] = pchPtr;
      }

      while ( !IS_WHITE_SPACE( *pchPtr ) && ( *pchPtr != LF ) )
      {
         pchPtr++;

         if ( ++dwParsedSoFar >= dwParseLen )
         {
            return( LPDERR_BADFORMAT );
         }
      }

         // if we reached LF, we are done

      if ( *pchPtr == LF )
      {
        *pchPtr = '\0';
         return( NO_ERROR );
      }

         // go to the next username or jobid, or end

      *pchPtr++ = '\0';
      dwParsedSoFar++;

      if (dwParsedSoFar >= dwParseLen)
      {
        return( LPDERR_BADFORMAT );
      }
   }

   return( NO_ERROR );


}  // end ParseQueueRequest()


/*****************************************************************************
 *                                                                           *
 * ParseControlFile():                                                       *
 *    This function parses contrl file and assigns values to the appropriate *
 *    fields of the CFILE_INFO structure.                                    *
 *                                                                           *
 * Returns:                                                                  *
 *    NO_ERROR if parsing went well                                          *
 *    LPDERR_BADFORMAT if the control file didn't conform to rfc1179         *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *                                                                           *
 * History:                                                                  *
 *    Jan.29, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

DWORD ParseControlFile( PSOCKCONN pscConn, PCFILE_ENTRY pCFile )
{

    CFILE_INFO    CFileInfo;
    PCHAR         pchCFile;
    DWORD         dwBytesParsedSoFar;
    BOOL          DocReady;
    PCHAR         DocName;
    BOOL          fUnsupportedCommand;


#ifdef DBG
    if( !pscConn || !pscConn->pchPrinterName
        || strstr( pscConn->pchPrinterName, "debug" )
    ){
        print__sockconn( "ParseControlFile: entered", pscConn );
    }
#endif


    memset( (PCHAR)&CFileInfo, 0, sizeof( CFILE_INFO ) );

    if ( pCFile->pchCFile == NULL )
    {
        LPD_DEBUG( "ParseControlFile(): pchCFile NULL on entry\n" );

        return( LPDERR_BADFORMAT );
    }

    if (pscConn==NULL ){
        LPD_DEBUG( "ParseControlFile(): pscConn NULL on entry\n" );
        return( LPDERR_BADFORMAT );
    }

    pchCFile           = pCFile->pchCFile;
    dwBytesParsedSoFar = 0;

    // default: most likely, only one copy is needed
    CFileInfo.usNumCopies      = 1;

    // default: most likely, it's "raw" data
    CFileInfo.szPrintFormat    = LPD_RAW_STRING;

    // loop through and parse the entire file, as per rfc 1179, sec.7.
    DocReady                   = FALSE;

    CFileInfo.pchSrcFile       = NULL;
    CFileInfo.pchTitle         = NULL;
    CFileInfo.pchUnlink        = NULL;
    DocName                    = NULL;
    fUnsupportedCommand        = FALSE;


    while( dwBytesParsedSoFar < pCFile->cbCFileLen )
    {
        switch( *pchCFile++ )
        {
        case  'C' : CFileInfo.pchClass = pchCFile;
            break;

        case  'H' : CFileInfo.pchHost = pchCFile;
            break;

        case  'I' : CFileInfo.dwCount = atol( pchCFile );
            break;

        case  'J' : CFileInfo.pchJobName = pchCFile;
            break;

        case  'L' : CFileInfo.pchBannerName = pchCFile;
            break;

        case  'M' : CFileInfo.pchMailName = pchCFile;
            break;

        case  'N' : if (CFileInfo.pchSrcFile != NULL) {
                DocReady = TRUE;
                break;
            }
            CFileInfo.pchSrcFile = pchCFile;
            break;

        case  'P' : CFileInfo.pchUserName = pchCFile;
            pscConn->pchUserName = pchCFile;
            break;

        case  'S' : CFileInfo.pchSymLink = pchCFile;
            break;

        case  'T' : if (CFileInfo.pchTitle != NULL) {
                DocReady = TRUE;
                break;
            }
            CFileInfo.pchTitle = pchCFile;
            break;

        case  'U' : if (CFileInfo.pchUnlink != NULL) {
            DocReady = TRUE;
            break;
        }
        CFileInfo.pchUnlink = pchCFile;
        break;

        case  'W' : CFileInfo.dwWidth = atol( pchCFile );
            break;

        case  '1' : CFileInfo.pchTrfRFile = pchCFile;
            break;

        case  '2' : CFileInfo.pchTrfIFile = pchCFile;
            break;

        case  '3' : CFileInfo.pchTrfBFile = pchCFile;
            break;

        case  '4' : CFileInfo.pchTrfSFile = pchCFile;
            break;

        case  'K' :
        case  '#' : CFileInfo.usNumCopies = (WORD)atoi(pchCFile);
            break;

        case  'f' : if (DocName != NULL) {
            DocReady = TRUE;
            break;
        }
        CFileInfo.pchFrmtdFile = pchCFile;
        CFileInfo.szPrintFormat = LPD_TEXT_STRING;
        if ( fAlwaysRawGLB ) {
            CFileInfo.szPrintFormat = LPD_RAW_STRING;
        }
        DocName = pchCFile;
        break;

        case  'g' : CFileInfo.pchPlotFile = pchCFile;
            // fall through

        case  'n' : CFileInfo.pchDitroffFile = pchCFile;

        case  'o' : CFileInfo.pchPscrptFile = pchCFile;

        case  't' : CFileInfo.pchTroffFile = pchCFile;

        case  'v' : CFileInfo.pchRasterFile = pchCFile;
            fUnsupportedCommand = TRUE;

        case  'l' : if (DocName != NULL) {
            DocReady = TRUE;
            break;
        }
        CFileInfo.pchUnfrmtdFile = pchCFile;
        if ( fAlwaysRawGLB ) {
            CFileInfo.szPrintFormat = LPD_RAW_STRING;
        }
        DocName = pchCFile;
        break;



        case  'p' : if (DocName != NULL) {
            DocReady = TRUE;
            break;
        }
        CFileInfo.pchPRFrmtFile = pchCFile;
        CFileInfo.szPrintFormat = LPD_TEXT_STRING;
        if ( fAlwaysRawGLB ) {
            CFileInfo.szPrintFormat = LPD_RAW_STRING;
        }
        DocName = pchCFile;
        break;

        case  'r' : if (DocName != NULL) {
            DocReady = TRUE;
            break;
        }
        CFileInfo.pchFortranFile = pchCFile;

        // if someone really sends 'r', treat it like text file

        CFileInfo.szPrintFormat = LPD_TEXT_STRING;
        if ( fAlwaysRawGLB ) {
            CFileInfo.szPrintFormat = LPD_RAW_STRING;
        }
        DocName = pchCFile;
        break;


        // unknown command!  Ignore it
        default:
            fUnsupportedCommand = TRUE;
            break;

        }  // end of switch( *pchCFile )


        if (DocReady) {
            pchCFile--;
            if ( ( CFileInfo.pchHost == NULL ) ||
                 ( CFileInfo.pchUserName == NULL ) )
            {
                return( LPDERR_BADFORMAT );
            }

            if (!LicensingApproval( pscConn ))
            {
                return( LPDERR_BADFORMAT );
            }

            if (DocName != NULL) {
                PrintIt(pscConn, pCFile, &CFileInfo, DocName);
            }

            // Look for more work, first initialize correctly.
            // - MohsinA, 23-Jan-97.

            DocReady                   = FALSE;
            CFileInfo.usNumCopies      = 1;
            CFileInfo.szPrintFormat    = LPD_RAW_STRING;
            CFileInfo.pchSrcFile       = NULL;
            CFileInfo.pchTitle         = NULL;
            CFileInfo.pchUnlink        = NULL;
            DocName                    = NULL;
            fUnsupportedCommand        = FALSE;

            continue;
        }

        // we finished looking at the first char of the line

        dwBytesParsedSoFar++;

        // move to the end of the line

        while ((dwBytesParsedSoFar < pCFile->cbCFileLen) && (!IS_LINEFEED_CHAR (*pchCFile)))
        {
            pchCFile++;
            dwBytesParsedSoFar++;
        }

        // convert LF into 0 so each of our substrings above is now
        // a properly null-terminated string

        *pchCFile = '\0';

        pchCFile++;

        dwBytesParsedSoFar++;

    }  // end of while( dwBytesParsedSoFar < pCFile->cbCFileLen )

    if( fUnsupportedCommand )
    {
        char *pszSource;

        if ( CFileInfo.pchUserName )
            pszSource = CFileInfo.pchUserName;
        else if ( CFileInfo.pchHost )
            pszSource = CFileInfo.pchHost;
        else
            pszSource = "Unknown";

        LpdReportEvent( LPDLOG_UNSUPPORTED_PRINT, 1, &pszSource, 0 );
    }


    if(DocName != NULL ){
        PrintIt(pscConn, pCFile, &CFileInfo, DocName);
    }

#ifdef DBG
    if( !CFileInfo.pchSrcFile
        || strstr( CFileInfo.pchSrcFile, "debug" )
    ){
        print__controlfile_info( "ParseControlFile: all ok", &CFileInfo );
        print__sockconn(         "ParseControlFile: entered", pscConn );
        print__cfile_entry(      "ParseControlFile: ", pCFile );
    }
#endif

    return( NO_ERROR );

} // end ParseControlFile()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\lpd\trace.h ===
//   Name:  Mohsin Ahmed
//   Email: MohsinA@microsoft.com
//   Date:  Fri Jan 24 10:33:54 1997
//   File:  d:/nt/PRIVATE/net/sockets/tcpsvcs/lpd/trace.c
//   Synopsis: Too many bugs, need to keep track in the field.
//   Notes:    Redefines all macros in debug.h to log everything.

#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <ctype.h>
#include <time.h>           // for ctime
#include <string.h>
#include <stdarg.h>         // for va_list.
#include <assert.h>         // for assert.
#include <windef.h>       
#include <winbase.h>        // for OutputDebugString.

#include "lpdstruc-x.h"


#ifndef _TRACE_H_
#define _TRACE_H_ 1

#define MOSH_LOG_FILE    "%windir%\\system32\\spool\\"  "lpd.log"
#define MODULE           "lpd"
#define LEN_DbgPrint     1000


extern FILE*             LogFile;
extern char              LogFileName[];

FILE * beginlogging( char * FileName );
FILE * stoplogging(  FILE * LogFile );
int    logit(      char * format, ... );
void   LogTime( void );

#ifdef DBG

#define  DEBUG_PRINT(S)      DbgPrint S
#define  LOGIT(S)            logit S
#define  LOGTIME             LogTime()

#undef   LPD_DEBUG
#define  LPD_DEBUG( S )      logit( S )

#undef   DBG_TRACEIN
#define  DBG_TRACEIN( fn )   logit( "Entering %s\n", fn )

#undef   DBG_TRACEOUT
#define  DBG_TRACEOUT( fn )  logit( "Leaving  %s\n", fn )

#else
#define DEBUG_PRINT(S)      /* Nothing */
#define LOGIT(S)            /* Nothing */
#define LOGTIME             /* Nothing */
#endif


#endif // _TRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\lpd\print.c ===
/*
                         Microsoft Windows NT
                 Copyright(c) Microsoft Corp., 1994-1997

  File: //KERNEL/RAZZLE3/src/sockets/tcpsvcs/lpd/print.c

  Revision History:

    Jan. 24,94    Koti     Created
    05-May-97     MohsinA  Thread Pooling and Perf.

  Description:
    This file contains all the functions that make calls to the Spooler
    to print or manipulate a print job.

*/



#include "lpd.h"


BOOL IsPrinterDataSet( IN HANDLE hPrinter, IN LPTSTR pszParameterName );
BOOL IsDataTypeRaw( PCHAR pchDataBuf, int cchBufferLen );

extern FILE              * pErrFile;                   // Debug output log file.
#define MAX_PCL_SEARCH_DEPTH 4096

/*****************************************************************************
 *                                                                           *
 * ResumePrinting():                                                         *
 *    This function issues the PRINTER_CONTROL_RESUME to the spooler.        *
 *                                                                           *
 * Returns:                                                                  *
 *    NO_ERROR if everything went well                                       *
 *    ErrorCode if something went wrong somewhere                            *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *                                                                           *
 * History:                                                                  *
 *    Jan.25, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

DWORD ResumePrinting( PSOCKCONN pscConn )
{

   HANDLE     hPrinter;
   PCHAR      aszStrings[2];



   if( pscConn->pchPrinterName == NULL ){
      LPD_DEBUG( "ResumePrinting(): pscConn->pchPrinterName NULL.\n" );
      return( LPDERR_NOPRINTER );
   }

   if( !OpenPrinter( pscConn->pchPrinterName, &hPrinter, NULL ) ){
      LPD_DEBUG( "OpenPrinter() failed in ResumePrinting()\n" );
      return( LPDERR_NOPRINTER );
   }

   pscConn->hPrinter = hPrinter;

   if ( !SetPrinter( hPrinter, 0, NULL, PRINTER_CONTROL_RESUME ) )
   {
      LPD_DEBUG( "SetPrinter() failed in ResumePrinting()\n" );

      return( LPDERR_NOPRINTER );
   }


   aszStrings[0] = pscConn->szIPAddr;
   aszStrings[1] = pscConn->pchPrinterName;

   LpdReportEvent( LPDLOG_PRINTER_RESUMED, 2, aszStrings, 0 );

   pscConn->wState = LPDS_ALL_WENT_WELL;


   return( NO_ERROR );

}



/*****************************************************************************
 *                                                                           *
 * InitializePrinter():                                                      *
 *    This function lays the ground work with the spooler so that we can     *
 *    print the job after receiving data from the client.                    *
 *                                                                           *
 * Returns:                                                                  *
 *    NO_ERROR if initialization went well                                   *
 *    ErrorCode if something went wrong somewhere                            *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *                                                                           *
 * History:                                                                  *
 *    Jan.25, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

DWORD InitializePrinter( PSOCKCONN pscConn )
{

    HANDLE                 hPrinter;
    DWORD                  dwActualSize;
    DWORD                  dwErrcode;
    BOOL                   fBagIt = FALSE;
    PPRINTER_INFO_2        p2Info;
    PRINTER_DEFAULTS       prtDefaults;
    LONG                   lcbDevModeSize;
    LONG                   lRetval;
    PDEVMODE               pLocalDevMode;

    // Make sure a printer by this name exists!

    if ( ( pscConn->pchPrinterName == NULL )
         || ( !OpenPrinter( pscConn->pchPrinterName, &hPrinter, NULL ) ) )
    {
        LPD_DEBUG( "OpenPrinter() failed in InitializePrinter()\n" );

        return( LPDERR_NOPRINTER );
    }

    pscConn->hPrinter = hPrinter;

    // allocate a 4k buffer..

    p2Info = (PPRINTER_INFO_2)LocalAlloc( LMEM_FIXED, 4096 );

    if ( p2Info == NULL )
    {
        LPD_DEBUG( "4K LocalAlloc() failed in InitializePrinter\n" );

        return( LPDERR_NOBUFS );
    }

    // do a GetPrinter so that we know what the default pDevMode is.  Then
    // we will modify the fields of our interest and do OpenPrinter again

    if ( !GetPrinter(hPrinter, 2, (LPBYTE)p2Info, 4096, &dwActualSize) )
    {
        if ( GetLastError() == ERROR_INSUFFICIENT_BUFFER )
        {
            LocalFree( p2Info );

            // 4k buffer wasn't enough: allocate however much that's needed

            p2Info = (PPRINTER_INFO_2)LocalAlloc( LMEM_FIXED, dwActualSize );

            if ( p2Info == NULL )
            {
                LPD_DEBUG( "LocalAlloc() failed in InitializePrinter\n" );

                return( LPDERR_NOBUFS );
            }

            if ( !GetPrinter(hPrinter, 2, (LPBYTE)p2Info, dwActualSize, &dwActualSize) )
            {
                LPD_DEBUG( "InitializePrinter(): GetPrinter failed again\n" );

                fBagIt = TRUE;
            }
        }
        else
        {
            fBagIt = TRUE;
        }
    }

    if ( fBagIt )
    {
        LPD_DEBUG( "InitializePrinter(): GetPrinter failed\n" );

        LocalFree( p2Info );

        return( LPDERR_NOPRINTER );
    }

    //
    // QFE: t-heathh - 25 Aug 1994 - Fixes 24342
    //
    // In the case where a printer has not yet been configured, the
    // pDevMode may come back NULL.  In this case, we  need to call
    // DocumentProperties to fill in the DevMode for us.
    //

    if ( p2Info->pDevMode == NULL )
    {
        // Get the size of the needed buffer.

        lcbDevModeSize = DocumentProperties(  NULL,        // No Dialog box, please
                                              hPrinter,
                                              pscConn->pchPrinterName,
                                              NULL,        // No output buf
                                              NULL,        // No input buf
                                              0 );         // ( flags = 0 ) => return size of out buf

        if ( lcbDevModeSize < 0L )
        {
            LPD_DEBUG( "DocumentProperties not able to return needed BufSize\n" );

            LocalFree( p2Info );

            return( LPDERR_NOBUFS );
        }

        pLocalDevMode = LocalAlloc( LMEM_FIXED, lcbDevModeSize );

        if ( pLocalDevMode == NULL )
        {
            LPD_DEBUG( "Cannot allocate local DevMode\n" );

            LocalFree( p2Info );

            return( LPDERR_NOBUFS );
        }

        lRetval = DocumentProperties(  NULL,
                                       hPrinter,
                                       pscConn->pchPrinterName,
                                       pLocalDevMode,
                                       NULL,
                                       DM_OUT_BUFFER );

        if ( lRetval < 0 )
        {
            LPD_DEBUG( "Document properties won't fill-in DevMode buffer.\n" );

            LocalFree( pLocalDevMode );
            LocalFree( p2Info );

            return( LPDERR_NOBUFS );
        }

        p2Info->pDevMode = pLocalDevMode;

    }
    else
    {
        pLocalDevMode = NULL;
    }
    p2Info->pDevMode->dmCopies = 1;

    //
    // Since we haven't even read the Data file yet, we can't have an override
    //

    pscConn->bDataTypeOverride = FALSE;

    // If not, set to default and UpdateJobInfo will correct it later

    prtDefaults.pDatatype = LPD_RAW_STRING;

    // Close it: we will open it again after modifying the pDevMode struct

    ShutdownPrinter( pscConn );

    prtDefaults.pDevMode = p2Info->pDevMode;

    prtDefaults.DesiredAccess = PRINTER_ACCESS_USE | PRINTER_ACCESS_ADMINISTER;

    if ( !OpenPrinter( pscConn->pchPrinterName, &hPrinter, &prtDefaults) )

    {
        LPD_DEBUG( "InitializePrinter(): second OpenPrinter() failed\n" );

        LocalFree( p2Info );

        if ( pLocalDevMode != NULL )
        {
            LocalFree( pLocalDevMode );
            pLocalDevMode = NULL;
        }

        return( LPDERR_NOPRINTER );
    }

    if ( pLocalDevMode != NULL )
    {
        LocalFree( pLocalDevMode );
        pLocalDevMode = NULL;
    }

    LocalFree( p2Info );

    pscConn->hPrinter = hPrinter;
    return( NO_ERROR );

}  // end InitializePrinter()



/*****************************************************************************
 *                                                                           *
 * UpdateJobInfo():                                                          *
 *    This function does a SetJob so that the spooler has more info about    *
 *    the job/client.                                                        *
 *                                                                           *
 * Returns:                                                                  *
 *    NO_ERROR if initialization went well                                   *
 *    ErrorCode if something went wrong somewhere                            *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *                                                                           *
 * History:                                                                  *
 *    Jan.25, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

DWORD UpdateJobInfo( PSOCKCONN pscConn, PCFILE_INFO pCFileInfo )
{

    PJOB_INFO_2            pji2GetJob;
    DWORD                  dwNeeded;
    PCHAR                  pchTmpBuf;
    int                    ErrCode;
    int                    len;
    PCHAR                  pchModHostName=NULL;

    // first do a GetJob (that way we know all fields are valid to begin
    // with, and we only change the ones we want)

    // Mr.Spooler, how big a buffer should I allocate?

    if ( !GetJob( pscConn->hPrinter, pscConn->dwJobId, 2, NULL, 0, &dwNeeded ) )
    {
        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        {
            return( LPDERR_GODKNOWS );
        }
    }
    pji2GetJob = LocalAlloc( LMEM_FIXED, dwNeeded );

    if ( pji2GetJob == NULL )
    {
        return( LPDERR_NOBUFS );
    }

    if ( !GetJob( pscConn->hPrinter, pscConn->dwJobId, 2,
                  (LPBYTE)pji2GetJob, dwNeeded, &dwNeeded ) )
    {
        LocalFree( pji2GetJob );

        return( LPDERR_GODKNOWS );
    }


    // store ip address, so we can match ip addr if the client later
    // sends request to delete this job (yes, that's our security!)


    pchTmpBuf = StoreIpAddr( pscConn );

    if (pchTmpBuf) {
        pji2GetJob->pUserName = pchTmpBuf;
    } else {
        pji2GetJob->pUserName = pCFileInfo->pchUserName;
    }

    pji2GetJob->pNotifyName = pCFileInfo->pchUserName;

    // Fill in the Job title.

    if ( pCFileInfo->pchTitle != NULL ) {
        pji2GetJob->pDocument = pCFileInfo->pchTitle;
    } else if ( pCFileInfo->pchSrcFile != NULL ) {
        pji2GetJob->pDocument = pCFileInfo->pchSrcFile;
    } else if ( pCFileInfo->pchJobName != NULL ) {
        pji2GetJob->pDocument = pCFileInfo->pchJobName;
    } else {
        pji2GetJob->pDocument = GETSTRING( LPD_DEFAULT_DOC_NAME );
    }


    if ( pCFileInfo->pchHost != NULL )
    {
        len = strlen(pCFileInfo->pchHost) + strlen(LPD_JOB_PREFIX) + 2;

        pchModHostName = LocalAlloc( LMEM_FIXED, len);

        if (pchModHostName)
        {
            // convert HostName to job=lpdHostName so lpr knows we set the name
            strcpy(pchModHostName, LPD_JOB_PREFIX);
            strcat(pchModHostName, pCFileInfo->pchHost);

            pji2GetJob->pParameters = pchModHostName;
        }
    }

    //
    // Set the datatype to what the control files reflects, unless the
    // auto-sense code has already overriden the control file.
    //
    // Illogical? Printit() might have overridden it or it is NULL.
    // - MohsinA, 23-Jan-97.
    //
    // if( !pscConn->bDataTypeOverride )?
    // if( pji2GetJob->pDatatype == NULL ){
    //     pji2GetJob->pDatatype = pCFileInfo->szPrintFormat;
    // }

    pji2GetJob->Position = JOB_POSITION_UNSPECIFIED;

    ErrCode =
    SetJob( pscConn->hPrinter, pscConn->dwJobId, 2, (LPBYTE)pji2GetJob, 0 );

    if( ErrCode ){
        LPD_DEBUG("lpd:UpdateJobInfo: SetJob failed\n");
    }

    LocalFree( pji2GetJob );

    if (pchTmpBuf)
    {
        LocalFree( pchTmpBuf );
    }

    if (pchModHostName)
    {
        LocalFree( pchModHostName );
    }

    return( NO_ERROR );

}  // end UpdateJobInfo()


/* ========================================================================

Routine Description:

  This function looks at the data file contents and the registry settings to
  see if the control file specified data type shall be overridden.

Arguments:

  pscConn - Pointer to a SOCKCONN that has already received the first part
            of the data file.

Returns:

  NO_ERROR in the usual case, various error codes otherwise


*/

DWORD UpdateJobType(
    PSOCKCONN pscConn,
    PCHAR     pchDataBuf,
    DWORD     cbDataLen
)
{

    PJOB_INFO_2            pji2GetJob;
    DWORD                  dwNeeded;
    PCHAR                  pchTmpBuf;
    BOOL                   override = FALSE;
    int                    ErrCode;

    // first do a GetJob (that way we know all fields are valid to begin
    // with, and we only change the ones we want)
    // Mr.Spooler, how big a buffer should I allocate?

    if ( !GetJob( pscConn->hPrinter, pscConn->dwJobId, 2, NULL, 0, &dwNeeded ) )
    {
        if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
        {
            LPD_DEBUG("lpd:UpdateJobType: GetJob failed/1.\n");
            return( LPDERR_GODKNOWS );
        }
    }
    pji2GetJob = LocalAlloc( LMEM_FIXED, dwNeeded );

    if ( pji2GetJob == NULL )
    {
        LPD_DEBUG("lpd:UpdateJobType: no mem.\n");
        return( LPDERR_NOBUFS );
    }

    if ( !GetJob( pscConn->hPrinter, pscConn->dwJobId, 2,
                  (LPBYTE)pji2GetJob, dwNeeded, &dwNeeded ) )
    {
        LPD_DEBUG("lpd:UpdateJobType: GetJob failed/2.\n");
        LocalFree( pji2GetJob );
        return( LPDERR_GODKNOWS );
    }


    //
    // Set the datatype to NULL so that we will know if it isn't explicitly
    // set by the registry.
    //

    //
    // See if this printer has a registry setting that tells us to always
    // print the job as RAW data.  This registry value is accessed through
    // the {Get|Set}PrinterData API that will always know where to look
    // for printer settings.
    //

    // MohsinA, 23-Jan-97.

    if ( IsPrinterDataSet( pscConn->hPrinter,
                           TEXT( LPD_PARMNAME_PRINTER_PASS_THROUGH ))
    ){
        #if DBG
        LpdPrintf(  "Printer %s has registry setting for PASS_THROUGH mode.\n",
                    pscConn->pchPrinterName );
        #endif
        override = TRUE;

        // else not PASS_THROUGH and AUTO-DETECT for raw job type.

    }else if( !IsPrinterDataSet( pscConn->hPrinter,
                                  TEXT( LPD_PARMNAME_DONT_DETECT ))
               && IsDataTypeRaw( pchDataBuf, cbDataLen )
    ){
        // We detect PS or PCL, so make it raw.
        override = TRUE;
    }


    if ( override ){
        #if DBG
        LpdPrintf( "Printer %s override to raw mode.\n",
                    pscConn->pchPrinterName );
        #endif

        pscConn->bDataTypeOverride = TRUE;
        pji2GetJob->pDatatype      = LPD_RAW_STRING;

        ErrCode =
        SetJob( pscConn->hPrinter, pscConn->dwJobId, 2, (LPBYTE)pji2GetJob, 0 );

        if( ErrCode ){
            LPD_DEBUG("lpd:UpdateJobType: SetJob failed.\n");
            LocalFree( pji2GetJob );
            return LPDERR_GODKNOWS;
        }
    }

    LocalFree( pji2GetJob );

    return( NO_ERROR );
}  // end UpdateJobInfo()


/*****************************************************************************
 *                                                                           *
 * StoreIpAddr():                                                            *
 *    This function returns a buffer that contains the user name with the    *
 *    ip address appended to it, so that if a request comes in later to      *
 *    delete the job, we match the ipaddrs (some security at least!)         *
 *                                                                           *
 * Returns:                                                                  *
 *    Pointer to a buffer that contains the modified user name               *
 *    NULL    If the name is not modified (unlikely, but possible if lpd and *
 *            lprmon point to each other!), or if malloc fails.              *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN) : pointer to SOCKCONN structure for this connection       *
 *                                                                           *
 * Notes:     Caller must free the buffer that's allocated here              *
 *                                                                           *
 * History:                                                                  *
 *    Jan.17, 95   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

PCHAR StoreIpAddr( PSOCKCONN pscConn )
{

   DWORD       dwBufLen;
   PCHAR       pchBuf;
   PCHAR       pchUserName;
   DWORD       i;
   DWORD       dwDots=0;
   BOOL        fOpenPara=FALSE, fClosePara=FALSE;


   pchUserName = pscConn->pchUserName;


   //
   // if the user name was "Koti" then it will be "Koti (11.101.4.25)" after
   // this function.
   // In some configurations (e.g. point lpd to lprmon and lprmon back to lpd)
   // we could keep appending ipaddrs for each instance of the job.  First
   // find out if ipaddr is already appended
   //
   dwBufLen = strlen (pchUserName);

   for (i=0; i<dwBufLen; i++)
   {
      switch( *(pchUserName+i) )
      {
         case '(': fOpenPara = TRUE;
                   break;
         case ')': fClosePara = TRUE;
                   break;
         case '.': dwDots++;
                   break;
      }
   }

   //
   // if name already contains the ipaddr, don't append again
   //
   if (fOpenPara && fClosePara && dwDots >= 3)
   {
      return( NULL );
   }

   // buffer to store a string in the form    "Koti (11.101.4.25)"
   dwBufLen += INET6_ADDRSTRLEN + 4;

   pchBuf = LocalAlloc (LMEM_FIXED, dwBufLen);
   if (pchBuf == NULL)
   {
      LPD_DEBUG( "StoreIpAddr(): LocalAlloc failed\n" );
      return( NULL );
   }

   sprintf (pchBuf, "%s (%s)", pchUserName, pscConn->szIPAddr);
   return( pchBuf );

}  // end StoreIpAddr()


// ========================================================================
//
// Sends profiling information back on socket qsock.
// Scans the wait queue and reports clients/peers also.
//
// Created: MohsinA, 05-May-97.
//

#ifdef PROFILING

void
SendProfileStatus( SOCKET qsock )
{
    char        buff[4000], buff2[NI_MAXHOST];
    int         buflen;
    COMMON_LPD  local_common = Common;   // struct copy, for readonly.
    PSOCKCONN   pscConn = NULL;   // S0186, B#101002, MohsinA, 18/8/97.
    SOCKCONN    local_sockconn;

    int         again = 1;
    int         ok;
    int         count = 0;

    SOCKET      csocket;
    SOCKADDR_STORAGE csock_addr;
    int         csock_len;

    // ====================================================================
    // First send the Common information.

    buflen =
    sprintf(buff,
            "--- PROFILING NT 5.0 LPD Server of %s %s ---\n"
            "AliveThreads=%d, MaxThreads=%d, TotalAccepts=%d,\n"
            "TotalErrors=%d,  QueueLength=%d\n"
            ,
            __DATE__, __TIME__,
            local_common.AliveThreads,
            local_common.MaxThreads,
            local_common.TotalAccepts,
            local_common.TotalErrors,
            local_common.QueueLength
    );

    if( buflen > 0 ){
        assert( buflen < sizeof( buff ) );
        SendData( qsock, buff, buflen );
    }

    // ====================================================================
    // Now scan the wait queue.

    EnterCriticalSection( &csConnSemGLB );

    while( again && !fShuttingDownGLB ){

        {
            if( pscConn == NULL ){             // First time?
                pscConn = scConnHeadGLB.pNext;
            }else{
                pscConn = pscConn->pNext;
            }

            if( pscConn == NULL ){
                again = 0;
            }else{
                local_sockconn = *pscConn;                // struct copy.
                csocket        =  local_sockconn.sSock;
                csock_len      =  sizeof(csock_addr);
                ok             =  getpeername( csocket,
                                               (SOCKADDR *) &csock_addr,
                                               &csock_len  );
            }
        }

        if( fShuttingDownGLB || !again )
            break;

        count++;
        assert( count <= local_common.QueueLength );

        if( ok == SOCKET_ERROR ){
            buflen = sprintf( buff, "(%d) Bad peer, err=%d, queued at %s",
                              count,
                              GetLastError(),
                              ctime(&local_sockconn.time_queued )
            );
        }else{
            buflen = NI_MAXHOST;
            WSAAddressToString((LPSOCKADDR)&csock_addr, csock_len, NULL,
                               buff2, &buflen);

            buflen = sprintf( buff, "(%d) Client %s queued since %s",
                              count,
                              buff2,
                              ctime(&local_sockconn.time_queued )
            );
        }

        if( buflen > 0 ){
            assert( buflen < sizeof( buff ) );
            SendData( qsock, buff, buflen );
        }

    } // end while pscConn.

    LeaveCriticalSection( &csConnSemGLB );

    return;
}
#endif


/*****************************************************************************
 *                                                                           *
 * SendQueueStatus():                                                        *
 *    This function retrieves the status of all the jobs on the printer of   *
 *    our interest and sends over to the client.  If the client specified    *
 *    users and/or job-ids in the status request then we send status of jobs *
 *    of only those users and/or those job-ids.                              *
 *                                                                           *
 * Returns:                                                                  *
 *    Nothing                                                                *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *    wMode (IN): whether short or long status info is requested             *
 *                                                                           *
 * History:                                                                  *
 *    Jan.25, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

VOID SendQueueStatus( PSOCKCONN  pscConn, WORD  wMode )
{
   BOOL         fResult;
   HANDLE       hPrinter;
   DWORD        dwBufSize;
   DWORD        dwHdrsize;
   DWORD        dwNumJobs;
   PCHAR        pchSndBuf=NULL;
   PCHAR        pchSpoolerBuf=NULL;
   BOOL         fNoPrinter=FALSE;
   BOOL         fAtLeastOneJob=TRUE;
   CHAR         szPrinterNameAndStatus[300];
   int          nResult;


   // for now, we return the same status info regardless of whether
   // the client asked for Short or Long queue Status.  This might
   // be enough since we are giving adequate info anyway


#ifdef PROFILING
   SendProfileStatus( pscConn->sSock );
#endif


   if ( ( pscConn->pchPrinterName == NULL )
        || ( !OpenPrinter( pscConn->pchPrinterName, &hPrinter, NULL ) ) )
   {
       LPD_DEBUG( "OpenPrinter() failed in SendQueueStatus()\n" );

       fNoPrinter = TRUE;

       goto SendQueueStatus_BAIL;
   }

   pscConn->hPrinter = hPrinter;


   pchSpoolerBuf = LocalAlloc( LMEM_FIXED, 4096 );
   if ( pchSpoolerBuf == NULL )
   {
       goto SendQueueStatus_BAIL;
   }

   // store the printer name (we might append status to it)

   strcpy( szPrinterNameAndStatus, pscConn->pchPrinterName );

   // do a get printer to see how the printer is doing

   if ( GetPrinter(pscConn->hPrinter, 2, pchSpoolerBuf, 4096, &dwBufSize) )
   {
      if ( ((PPRINTER_INFO_2)pchSpoolerBuf)->Status == PRINTER_STATUS_PAUSED )
      {
         strcat( szPrinterNameAndStatus, GETSTRING( LPD_PRINTER_PAUSED ) );
      }
      else if ( ((PPRINTER_INFO_2)pchSpoolerBuf)->Status == PRINTER_STATUS_PENDING_DELETION )
      {
         strcat( szPrinterNameAndStatus, GETSTRING( LPD_PRINTER_PENDING_DEL ) );
      }
   }
   else
   {
      LPD_DEBUG( "GetPrinter() failed in SendQueueStatus()\n" );
   }

    // Since OpenPrinter succeeded, we will be sending to the client
    // at least dwHdrsize bytes that includes the printername

    dwHdrsize =   strlen( GETSTRING( LPD_LOGO ) )
    + strlen( GETSTRING( LPD_PRINTER_TITLE) )
    + strlen( szPrinterNameAndStatus )
    + strlen( GETSTRING( LPD_QUEUE_HEADER ))
    + strlen( GETSTRING( LPD_QUEUE_HEADER2))
    + strlen( LPD_NEWLINE );


    //
    // query spooler for all the jobs currently pending
    // (we have already allocate 4K buffer)
    //
    dwBufSize = 4096;

    while(1)
    {
        fResult = EnumJobs( pscConn->hPrinter, 0, LPD_MAXJOBS_ENUM, 2,
                            pchSpoolerBuf, dwBufSize, &dwBufSize, &dwNumJobs );


        // most common case: will work the first time
        if (fResult == TRUE)
        {
            break;
        }

        // it's possible spooler got a new job, and our buffer is now small
        // so it returns ERROR_INSUFFICIENT_BUFFER.  Other than that, quit!

        if ( (fResult == FALSE) &&
             ( GetLastError() != ERROR_INSUFFICIENT_BUFFER ) )
        {
            goto SendQueueStatus_BAIL;
        }

        LocalFree( pchSpoolerBuf );

        // spooler wants more memory: allocate it
        pchSpoolerBuf = LocalAlloc( LMEM_FIXED, dwBufSize );

        if ( pchSpoolerBuf == NULL )
        {
            goto SendQueueStatus_BAIL;
        }
    }

    if (dwNumJobs == 0)
    {
        fAtLeastOneJob = FALSE;
    }

    // header, and one line per job that's queued (potentially, dwNumJobs=0)

    dwBufSize = dwHdrsize + ( dwNumJobs * LPD_LINE_SIZE );

    // to put a newline at the end of display!

    dwBufSize += sizeof( LPD_NEWLINE );

    ShutdownPrinter( pscConn );


    // this is the buffer we use to send the data out

    pchSndBuf = LocalAlloc( LMEM_FIXED, dwBufSize );

    if ( pchSndBuf == NULL )
    {
        goto SendQueueStatus_BAIL;
    }

    // copy the dwHdrsize bytes of header

    nResult = sprintf( pchSndBuf, "%s%s%s%s%s%s",    GETSTRING( LPD_LOGO ),
                       GETSTRING( LPD_PRINTER_TITLE ),
                       szPrinterNameAndStatus,
                       GETSTRING( LPD_QUEUE_HEADER ),
                       GETSTRING( LPD_QUEUE_HEADER2 ),
                       LPD_NEWLINE );


    //
    // watch for buffer overwrites
    //

    LPD_ASSERT( nResult == (int) dwHdrsize );

    // if there are any jobs, fill the buffer with status
    // of each of the jobs

    if ( fAtLeastOneJob )
    {
        nResult += FillJobStatus( pscConn, (pchSndBuf + dwHdrsize ),
                                 (PJOB_INFO_2)pchSpoolerBuf, dwNumJobs );
        LPD_ASSERT ((int) dwBufSize >= nResult);
        if (nResult > (int) dwBufSize)
        {
            nResult = (int) dwBufSize;
        }
    }


    // not much can be done if SendData fails!

    SendData( pscConn->sSock, pchSndBuf, nResult);


    if ( pchSpoolerBuf != NULL )
    {
        LocalFree( pchSpoolerBuf );
    }

    LocalFree( pchSndBuf );


    pscConn->wState = LPDS_ALL_WENT_WELL;

    return;


    // if we reached here, some error occured while getting job status.
    // Tell the client that we had a problem!

  SendQueueStatus_BAIL:

    ShutdownPrinter( pscConn );

    if ( pchSndBuf != NULL )
    {
        LocalFree( pchSndBuf );
    }

    if ( pchSpoolerBuf != NULL )
    {
        LocalFree( pchSpoolerBuf );
    }

    // just add size of all possible error messages, so we have room for
    // the largest message!
    dwBufSize =  strlen( GETSTRING( LPD_LOGO ) ) + strlen( GETSTRING( LPD_QUEUE_ERRMSG ) )
    + strlen( GETSTRING( LPD_QUEUE_NOPRINTER ) );

    pchSndBuf = LocalAlloc( LMEM_FIXED, dwBufSize );

    if ( pchSndBuf == NULL )
    {
        return;
    }

    if ( fNoPrinter )
    {
        LPD_DEBUG( "Rejected status request for non-existent printer\n" );

        sprintf( pchSndBuf, "%s%s", GETSTRING( LPD_LOGO ), GETSTRING( LPD_QUEUE_NOPRINTER ) );
    }
    else
    {
        LPD_DEBUG( "Something went wrong in SendQueueStatus()\n" );

        sprintf( pchSndBuf, "%s%s", GETSTRING( LPD_LOGO ), GETSTRING( LPD_QUEUE_ERRMSG ) );
    }

    // Not much can be done about an error here: don't bother checking!

    SendData( pscConn->sSock, pchSndBuf, dwBufSize );

    LocalFree( pchSndBuf );


    return;

}  // end SendQueueStatus()






/*****************************************************************************
 *                                                                           *
 * ShutDownPrinter():                                                        *
 *    This function closes the printer in our context.                       *
 *                                                                           *
 * Returns:                                                                  *
 *    Nothing                                                                *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *                                                                           *
 * History:                                                                  *
 *    Jan.25, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

VOID ShutdownPrinter( PSOCKCONN pscConn )
{

   if ( pscConn->hPrinter == (HANDLE)INVALID_HANDLE_VALUE )
   {
      return;
   }

   if ( ClosePrinter( pscConn->hPrinter ) )
   {
      pscConn->hPrinter = (HANDLE)INVALID_HANDLE_VALUE;
   }
   else
   {
      LPD_DEBUG( "ShutDownPrinter: ClosePrinter failed\n" );
   }

   return;

}  // end ShutdownPrinter()




/*****************************************************************************
 *                                                                           *
 * SpoolData():                                                              *
 *    This function writes the data that we got from client into spool file. *
 *                                                                           *
 * Returns:                                                                  *
 *    NO_ERROR if things went well                                           *
 *    ErrorCode if something didn't go right                                 *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *                                                                           *
 * History:                                                                  *
 *    Jan.25, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

DWORD SpoolData( HANDLE hSpoolFile, PCHAR pchDataBuf, DWORD cbDataBufLen )
{

    DWORD    dwBytesWritten;
    BOOL     fRetval;


    fRetval = WriteFile( hSpoolFile, pchDataBuf,
                         cbDataBufLen, &dwBytesWritten, NULL );

    // if WriteFile failed, or if fewer bytes got written, quit!

    if ( (fRetval == FALSE) || (dwBytesWritten != cbDataBufLen) )
    {
        LPD_DEBUG( "WriteFile() failed in SpoolData\n" );

        return( LPDERR_NOPRINTER );
    }

    return( NO_ERROR );


}  // end SpoolData()


/*****************************************************************************
 *                                                                           *
 * PrintData():                                                              *
 *    This function tells the spooler that we are done writing to the spool  *
 *    file and that it should go ahead and dispatch it.                      *
 *                                                                           *
 * Returns:                                                                  *
 *    NO_ERROR  if everything went ok                                        *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *                                                                           *
 * History:                                                                  *
 *    Jan.25, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

DWORD PrintData( PSOCKCONN pscConn )
{
    CFILE_ENTRY *pCFile;
    DWORD   dwRetval;
    LIST_ENTRY  *pTmpList;

    while ( !IsListEmpty( &pscConn->CFile_List ) ) {

        pTmpList = RemoveHeadList( &pscConn->CFile_List );
        pCFile = CONTAINING_RECORD( pTmpList,
                                    CFILE_ENTRY,
                                    Link );


        if ( (dwRetval = ParseControlFile( pscConn, pCFile )) != NO_ERROR )
        {
            PCHAR   aszStrings[2]={ pscConn->szIPAddr, NULL };

            LpdReportEvent( LPDLOG_BAD_FORMAT, 1, aszStrings, 0 );
            pscConn->fLogGenericEvent = FALSE;
            LPD_DEBUG( "ParseControlFile() failed in ProcessJob()\n" );
            CleanupCFile( pCFile );
            return( dwRetval );               // the thread exits
         }

         CleanupCFile( pCFile );
    }

   return( NO_ERROR );

}  // end PrintData()

/*****************************************************************************
 *                                                                           *
 * PrintIt():                                                                *
 *    This function tells the spooler that we are done writing to the spool  *
 *    file and that it should go ahead and dispatch it.                      *
 *                                                                           *
 * Returns:                                                                  *
 *    Nothing                                                                *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *                                                                           *
 * History:                                                                  *
 *                                                                           *
 *****************************************************************************/

DWORD
PrintIt(
    PSOCKCONN    pscConn,
    PCFILE_ENTRY pCFileEntry,
    PCFILE_INFO  pCFileInfo,
    PCHAR        pFileName
)
{
    DOC_INFO_1   dc1Info;
    PDFILE_ENTRY pDFile;
    DWORD        cbTotalDataLen;
    DWORD        cbBytesSpooled;
    DWORD        cbBytesToSpool;
    DWORD        cbDataBufLen;
    DWORD        cbBytesRemaining;
    DWORD        cbBytesActuallySpooled;
    PCHAR        pchDataBuf;
    DWORD        dwRetval;
    BOOL         fRetval;
    USHORT       cbCount;

#ifdef DBG
    if( !pCFileInfo || !pCFileInfo->pchSrcFile
        || strstr( pCFileInfo->pchSrcFile, "debug" )
    ){
        print__controlfile_info( "PrintIt: ", pCFileInfo );
        print__cfile_entry( "Printit: ", pCFileEntry );
    }
#endif

    memset( &dc1Info, 0, sizeof( dc1Info ) );

    // Defaults.

    dc1Info.pDatatype = LPD_RAW_STRING;

    // Get the job title if any.

    if ( pCFileInfo->pchTitle != NULL ) {
        dc1Info.pDocName = pCFileInfo->pchTitle;
    } else if ( pCFileInfo->pchSrcFile != NULL ) {
        dc1Info.pDocName = pCFileInfo->pchSrcFile;
    } else if ( pCFileInfo->pchJobName != NULL ) {
        dc1Info.pDocName = pCFileInfo->pchJobName;
    } else {
        dc1Info.pDocName
        = pCFileInfo->pchTitle
        = pCFileInfo->pchJobName
        = pCFileInfo->pchSrcFile
        = pFileName;
    }

    dc1Info.pOutputFile = NULL;         // we aren't writing to file

    //
    // If datatype is known, set it.
    // Doesn't it default to raw? -  MohsinA, 23-Jan-97.
    //

    if( pCFileInfo->szPrintFormat != NULL ) {
        dc1Info.pDatatype = pCFileInfo->szPrintFormat;
    }

    for (cbCount = 0; cbCount < pCFileInfo->usNumCopies; cbCount++) {

        pscConn->dwJobId = StartDocPrinter( pscConn->hPrinter, 1, (LPBYTE)&dc1Info ) ;

        if ( pscConn->dwJobId == 0 )
        {
            LPD_DEBUG( "InitializePrinter(): StartDocPrinter() failed\n" );

            return( LPDERR_NOPRINTER );
        }

        UpdateJobInfo( pscConn, pCFileInfo );

#ifdef DBG
        if( !pCFileInfo || !pCFileInfo->pchSrcFile
            || strstr( pCFileInfo->pchSrcFile, "debug" )
        ){
            print__controlfile_info( "PrintIt: after UpdateJobInfo ", pCFileInfo );
            print__cfile_entry( "Printit: after UpdateJobInfo", pCFileEntry );
        }
#endif

        if (!IsListEmpty( &pscConn->DFile_List ) ) {

            pDFile = (PDFILE_ENTRY)pscConn->DFile_List.Flink;
            while (strncmp( pDFile->pchDFileName, pFileName, strlen(pFileName) ) != 0 ) {
                pDFile = (PDFILE_ENTRY)pDFile->Link.Flink;
                if (pDFile == (PDFILE_ENTRY)&pscConn->DFile_List) {
                    return( LPDERR_BADFORMAT );
                }
            }

            dwRetval = SetFilePointer( pDFile->hDataFile, 0, NULL, FILE_BEGIN );

            if (dwRetval == 0xFFFFFFFF) {
                LPD_DEBUG( "ERROR: SetFilePointer() failed in PrintIt\n" );
                return( LPDERR_GODKNOWS );
            }

            cbTotalDataLen = pDFile->cbDFileLen;

            cbBytesToSpool = (cbTotalDataLen > LPD_BIGBUFSIZE ) ?
            LPD_BIGBUFSIZE : cbTotalDataLen;

            pchDataBuf = LocalAlloc( LMEM_FIXED, cbBytesToSpool );

            if ( pchDataBuf == NULL )
            {
                CloseHandle(pDFile->hDataFile);
                pDFile->hDataFile = INVALID_HANDLE_VALUE;
                return( (DWORD)LPDERR_NOBUFS );
            }

            cbBytesSpooled = 0;

            cbBytesRemaining = cbTotalDataLen;

            // keep receiving until we have all the data client said it
            // would send

            while( cbBytesSpooled < cbTotalDataLen )
            {
                fRetval = ReadFile( pDFile->hDataFile,
                                    pchDataBuf,
                                    cbBytesToSpool,
                                    &cbBytesActuallySpooled,
                                    NULL );
                if ( (!fRetval) || (cbBytesActuallySpooled != cbBytesToSpool) )
                {
                    LPD_DEBUG( "ReadFile() failed in PrintIt(): job aborted)\n" );

                    LocalFree( pchDataBuf );
                    CloseHandle(pDFile->hDataFile);
                    pDFile->hDataFile = INVALID_HANDLE_VALUE;
                    return( LPDERR_NOPRINTER );
                }

                // MohsinA, 23-Jan-97?

                if ( cbBytesSpooled == 0 ) {
                    UpdateJobType( pscConn, pchDataBuf, cbBytesToSpool );
                }

                cbDataBufLen = cbBytesToSpool;

                fRetval = WritePrinter( pscConn->hPrinter,
                                        pchDataBuf,
                                        cbBytesToSpool,
                                        &cbBytesActuallySpooled);

                if ( (fRetval==FALSE) || (cbBytesToSpool != cbBytesActuallySpooled) )
                {
                    LPD_DEBUG( "WritePrinter() failed in PrintIt():job aborted)\n" );

                    LocalFree( pchDataBuf );
                    CloseHandle(pDFile->hDataFile);
                    pDFile->hDataFile = INVALID_HANDLE_VALUE;
                    return( LPDERR_NOPRINTER );
                }

                cbBytesSpooled += cbBytesToSpool;

                cbBytesRemaining -= cbBytesToSpool;

                cbBytesToSpool = (cbBytesRemaining > LPD_BIGBUFSIZE ) ?
                LPD_BIGBUFSIZE : cbBytesRemaining;

            }

            LocalFree( pchDataBuf );

            if ( !EndDocPrinter( pscConn->hPrinter ) )
            {
                LPD_DEBUG( "EndDocPrinter() failed in PrintData\n" );
                return( LPDERR_NOPRINTER );
            }
        }
    }

    return(NO_ERROR);

}  // end PrintIt()



/*****************************************************************************
 *                                                                           *
 * AbortThisJob():                                                           *
 *    This function tells the spooler to abort the specified job.            *
 *                                                                           *
 * Returns:                                                                  *
 *    Nothing                                                                *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *                                                                           *
 * History:                                                                  *
 *    Jan.25, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

VOID AbortThisJob( PSOCKCONN pscConn )
{
    assert( pscConn );

    if( pscConn->hPrinter == INVALID_HANDLE_VALUE )
    {
        LOGIT(("lpd:AbortThisJob: invalid hPrinter %d.\n",
               pscConn->hPrinter ));
        return;
    }

    // not much can be done if there is an error: don't bother checking

    if (!SetJob( pscConn->hPrinter,
                 pscConn->dwJobId,
                 0,
                 NULL,
                 JOB_CONTROL_CANCEL )
    )
    {
        LPD_DEBUG( "AbortThisJob: SetJob failed\n");
    }

    if ( !EndDocPrinter( pscConn->hPrinter ) )
    {
        LPD_DEBUG( "EndDocPrinter() failed in AbortThisJob\n" );
    }

    LPD_DEBUG( "AbortThisJob(): job aborted\n" );

    return;


}  // end AbortThisJob()


/*****************************************************************************
 *                                                                           *
 * RemoveJobs():                                                             *
 *    This function removes all the jobs the user has asked us to remove,    *
 *    after verifying that the job was indeed sent originally by the same    *
 *    user (ip addresses of machine sending the original job and the request *
 *    to remove it should match).                                            *
 *                                                                           *
 * Returns:                                                                  *
 *    NO_ERROR if everything went ok                                         *
 *    Errorcode if job couldn't be deleted                                   *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *                                                                           *
 * History:                                                                  *
 *    Jan.25, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

DWORD RemoveJobs( PSOCKCONN pscConn )
{
    PQSTATUS      pqStatus;
    PJOB_INFO_1   pji1GetJob;
    BOOL          fSuccess=TRUE;
    HANDLE        hPrinter;
    DWORD         dwNeeded;
    DWORD         dwBufLen;
    PCHAR         pchUserName;
    PCHAR         pchIPAddr;
    DWORD         i, j;

    if ( (pqStatus = pscConn->pqStatus) == NULL )
    {
        return( LPDERR_BADFORMAT );
    }


    if ( ( pscConn->pchPrinterName == NULL )
         || ( !OpenPrinter( pscConn->pchPrinterName, &hPrinter, NULL ) ) )
    {
        LPD_DEBUG( "OpenPrinter() failed in RemoveJobs()\n" );

        return( LPDERR_NOPRINTER );
    }

    pscConn->hPrinter = hPrinter;

    // the "List" field can contain UserNames or JobId's of the jobs to be
    // removed.  Even though we parse UserNames into the ppchUsers[] array
    // (in pqStatus struct), we only use the JobId's, and not use the UserNames
    // at all.  Reason is we only want to remove jobs that the user submitted
    // and not allow a user to specify other usernames.

    // try to remove every job the user has asked us to remove

    for ( i=0; i<pqStatus->cbActualJobIds; i++ )
    {

        // ask GetJob how big a buffer we must pass.  If the errorcode is
        // anything other than ERROR_INSUFFICIENT_BUFFER, the job must be
        // done (so JobId is invalid), and we won't do anything

        if ( !GetJob( pscConn->hPrinter, pqStatus->adwJobIds[i], 1,
                      NULL, 0, &dwNeeded ) )
        {
            if ( GetLastError() != ERROR_INSUFFICIENT_BUFFER )
            {
                LPD_DEBUG( "lpd:RemoveJobs: GetJob failed.\n" );
                fSuccess = FALSE;

                continue;
            }
        }

        pji1GetJob = LocalAlloc( LMEM_FIXED, dwNeeded );

        if ( pji1GetJob == NULL )
        {
            LPD_DEBUG("lpd:RemoveJobs: no mem\n");
            return( LPDERR_NOBUFS );
        }


        if ( !GetJob( pscConn->hPrinter, pqStatus->adwJobIds[i], 1,
                      (LPBYTE)pji1GetJob, dwNeeded, &dwNeeded ) )
        {
            fSuccess = FALSE;

            LocalFree( pji1GetJob );

            continue;
        }


        // pUserName is in the form    "Koti (11.101.4.25)"
        // (we store the string in this exact format (in UpdateJobInfo()))
        // Also, jobs coming from unix can't use space in user name, so if
        // we do find a space, it must be the one we introduced (before '(' )

        pchUserName = pji1GetJob->pUserName;

        dwBufLen = strlen( pchUserName );

        pchIPAddr = pchUserName;

        j = 0;
        while( *pchIPAddr != ')' )       // first convert the last ')' to '\0'
        {
            pchIPAddr++;

            j++;

            //
            // if we traversed the entire name and didn't find ')', something
            // isn't right (e.g. not one of our jobs): just skip this one
            //
            if (j >= dwBufLen)
            {
                LocalFree( pji1GetJob );
                break;
            }
        }

        if (j >= dwBufLen)
        {
            continue;
        }

        *pchIPAddr = '\0';         // convert the ')' to '\0'

        pchIPAddr = pchUserName;

        while ( !IS_WHITE_SPACE( *pchIPAddr ) )
        {
            pchIPAddr++;
        }

        *pchIPAddr = '\0';         // convert the space to \0

        //
        // just make sure that it's what we had set earlier
        //
        if ( *(pchIPAddr+1) != '(' )
        {
            LocalFree( pji1GetJob );
            continue;
        }

        pchIPAddr += 2;            // skip over the new \0 and the '('

        // make sure the job was indeed submitted by the same user from
        // the same machine (that's the extent of our security!)

        if ( ( strcmp( pchUserName, pqStatus->pchUserName ) != 0 ) ||
             ( strcmp( pchIPAddr, pscConn->szIPAddr ) != 0 ) )
        {
            PCHAR      aszStrings[4];

            aszStrings[0] = pscConn->szIPAddr;
            aszStrings[1] = pqStatus->pchUserName;
            aszStrings[2] = pchUserName;
            aszStrings[3] = pchIPAddr;

            LpdReportEvent( LPDLOG_UNAUTHORIZED_REQUEST, 4, aszStrings, 0 );

            LPD_DEBUG( "Unauthorized request in RemoveJobs(): refused\n" );

            fSuccess = FALSE;

            LocalFree( pji1GetJob );

            continue;
        }

        // now that we've crossed all hurdles, delete the job!

        SetJob( pscConn->hPrinter, pqStatus->adwJobIds[i],
                0, NULL, JOB_CONTROL_CANCEL );

        LocalFree( pji1GetJob );

    }


    if ( !fSuccess )
    {
        return( LPDERR_BADFORMAT );
    }


    pscConn->wState = LPDS_ALL_WENT_WELL;

    return( NO_ERROR );

}  // end RemoveJobs()




/*****************************************************************************
 *                                                                           *
 * FillJobStatus():                                                          *
 *    This function takes output from the EnumJobs() call and puts into a    *
 *    buffer info about the job that's of interest to us.                    *
 *                                                                           *
 * Returns:                                                                  *
 *    Nothing                                                                *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): pointer to SOCKCONN structure for this connection    *
 *    pchDest (OUT): buffer into which we put info about the jobs            *
 *    pji2QStatus (IN): buffer we got as output from the EnumJobs() call     *
 *    dwNumJobs (IN): how many jobs does data in pji2QStatus pertain to.     *
 *                                                                           *
 * History:                                                                  *
 *    Jan.25, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

INT FillJobStatus( PSOCKCONN pscConn, PCHAR pchDest,
                   PJOB_INFO_2 pji2QStatus, DWORD dwNumJobs )
{

    DWORD      i, j;
    BOOL       fUsersSpecified=FALSE;
    BOOL       fJobIdsSpecified=FALSE;
    BOOL       fMatchFound;
    PQSTATUS   pqStatus;
    CHAR       szFormat[8];
    PCHAR      pchStart = pchDest;


    // if users/job-ids not specified, we return status on all jobs

    if ( (pqStatus = pscConn->pqStatus) == NULL )
    {
        fMatchFound = TRUE;
    }

    // looks like users and/or job-ids is specified

    else
    {
        if ( pqStatus->cbActualUsers > 0 )
        {
            fUsersSpecified = TRUE;
        }

        if ( pqStatus->cbActualJobIds > 0 )
        {
            fJobIdsSpecified = TRUE;
        }

        fMatchFound = FALSE;          // flip the default
    }


    // if user or job-ids or both are specified, then we fill in data only
    // if we find a match.  if neither is specified (most common case)
    // then we report all jobs (default for fMatchFound does the trick)

    for ( i=0; i<dwNumJobs; i++, pji2QStatus++ )
    {
        if ( fUsersSpecified )
        {
            for ( j=0; j<pqStatus->cbActualUsers; j++ )
            {
                if (_stricmp( pji2QStatus->pUserName, pqStatus->ppchUsers[j] ) == 0)
                {
                    fMatchFound = TRUE;
                    break;
                }
            }
        }

        if ( (!fMatchFound) && (fJobIdsSpecified) )
        {
            for ( j=0; j<pqStatus->cbActualJobIds; j++ )
            {
                if ( pji2QStatus->JobId == pqStatus->adwJobIds[j] )
                {
                    fMatchFound = TRUE;
                    break;
                }
            }
        }

        if ( !fMatchFound )
        {
            continue;
        }

        // put in the desired fields for each (selected) of the jobs

        LpdFormat( pchDest, pji2QStatus->pUserName, LPD_FLD_OWNER );
        pchDest += LPD_FLD_OWNER;

        //
        // Since we can have multiple bits set, but print only 1 status, so
        // first handle the error bits
        //
        if (pji2QStatus->Status & JOB_STATUS_ERROR)
        {
            LpdFormat( pchDest, GETSTRING( LPD_STR_ERROR ), LPD_FLD_STATUS );
        }
        else if (pji2QStatus->Status & JOB_STATUS_OFFLINE)
        {
            LpdFormat( pchDest, GETSTRING( LPD_STR_OFFLINE), LPD_FLD_STATUS );
        }
        else if (pji2QStatus->Status & JOB_STATUS_PAPEROUT)
        {
            LpdFormat( pchDest, GETSTRING( LPD_STR_PAPEROUT), LPD_FLD_STATUS );
        }
        else if (pji2QStatus->Status & JOB_STATUS_USER_INTERVENTION)
        {
            LpdFormat( pchDest, GETSTRING( LPD_STR_USER_INTERVENTION ), LPD_FLD_STATUS );
        }
        else if (pji2QStatus->Status & JOB_STATUS_BLOCKED_DEVQ)
        {
            LpdFormat( pchDest, GETSTRING( LPD_STR_BLOCKED_DEVQ ), LPD_FLD_STATUS );
        }
        //
        // Now, handle the processing states
        //
        else if (pji2QStatus->Status & JOB_STATUS_PRINTING)
        {
            LpdFormat( pchDest, GETSTRING( LPD_STR_PRINTING), LPD_FLD_STATUS );
        }
        else if (pji2QStatus->Status & JOB_STATUS_SPOOLING)
        {
            LpdFormat( pchDest, GETSTRING( LPD_STR_SPOOLING), LPD_FLD_STATUS );
        }
        else if (pji2QStatus->Status & JOB_STATUS_DELETING)
        {
            LpdFormat( pchDest, GETSTRING( LPD_STR_DELETING), LPD_FLD_STATUS );
        }
        //
        // Now, handle the processed states
        //
        else if (pji2QStatus->Status & JOB_STATUS_DELETED)
        {
            LpdFormat( pchDest, GETSTRING( LPD_STR_DELETED ), LPD_FLD_STATUS );
        }
        else if (pji2QStatus->Status & JOB_STATUS_PAUSED)
        {
            LpdFormat( pchDest, GETSTRING( LPD_STR_PAUSED ), LPD_FLD_STATUS );
        }
        else if (pji2QStatus->Status & JOB_STATUS_PRINTED)
        {
            LpdFormat( pchDest, GETSTRING( LPD_STR_PRINTED), LPD_FLD_STATUS );
        }
        //
        // Remaining cases
        //
        else if (pji2QStatus->Status & JOB_STATUS_RESTART)
        {
            LpdFormat( pchDest, GETSTRING( LPD_STR_RESTART ), LPD_FLD_STATUS );
        }
        else
        {
            LpdFormat( pchDest, GETSTRING( LPD_STR_PENDING), LPD_FLD_STATUS );
        }

        pchDest += LPD_FLD_STATUS;

        LpdFormat( pchDest, pji2QStatus->pDocument, LPD_FLD_JOBNAME );
        pchDest += LPD_FLD_JOBNAME;

        sprintf( szFormat, "%s%d%s", "%", LPD_FLD_JOBID, "d" );
        sprintf( pchDest, szFormat, pji2QStatus->JobId );
        pchDest += LPD_FLD_JOBID;

        sprintf( szFormat, "%s%d%s", "%", LPD_FLD_SIZE, "d" );
        sprintf( pchDest, szFormat, pji2QStatus->Size );
        pchDest += LPD_FLD_SIZE;

        sprintf( szFormat, "%s%d%s", "%", LPD_FLD_PAGES, "d" );
        sprintf( pchDest, szFormat, pji2QStatus->TotalPages );
        pchDest += LPD_FLD_PAGES;

        sprintf( szFormat, "%s%d%s", "%", LPD_FLD_PRIORITY, "d" );
        sprintf( pchDest, szFormat, pji2QStatus->Priority );
        pchDest += LPD_FLD_PRIORITY;

        strncpy (pchDest, LPD_NEWLINE, sizeof(LPD_NEWLINE));
        pchDest += sizeof( LPD_NEWLINE ) -1;

        if (pqStatus)
        {
            //
            // If a specific job was requested, then we should
            // re-determine the criteria!
            //
            fMatchFound = FALSE;
        }
    }  // for ( i=0; i<dwNumJobs; i++, pji2QStatus++ )


    strncpy (pchDest, LPD_NEWLINE, sizeof(LPD_NEWLINE));
    pchDest += sizeof( LPD_NEWLINE );

    return (INT)(pchDest - pchStart);
}  // end FillJobStatus()


/*****************************************************************************
 *                                                                           *
 * LpdFormat():                                                              *
 *    This function copies exactly the given number of bytes from source     *
 *    to dest buffer, by truncating or padding with spaces if need be.  The  *
 *    byte copied into the dest buffer is always a space.                    *
 *                                                                           *
 * Returns:                                                                  *
 *    Nothing                                                                *
 *                                                                           *
 * Parameters:                                                               *
 *    pchDest (OUT): destination buffer                                      *
 *    pchSource (IN): source buffer                                          *
 *    dwLimit (IN): number of bytes to copy                                  *
 *                                                                           *
 * History:                                                                  *
 *    Jan.25, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

VOID LpdFormat( PCHAR pchDest, PCHAR pchSource, DWORD dwLimit )
{

    DWORD    dwCharsToCopy;
    BOOL     fPaddingNeeded;
    DWORD    i;


    if( pchSource ){
        dwCharsToCopy = strlen( pchSource );
    }else{
        DEBUG_PRINT(("LpdFormat NULL pchSource\n"));
        dwCharsToCopy = 0;
    }

    if ( dwCharsToCopy < (dwLimit-1) )
    {
        fPaddingNeeded = TRUE;
    }
    else
    {
        fPaddingNeeded = FALSE;
        dwCharsToCopy = dwLimit-1;
    }

    for ( i=0; i<dwCharsToCopy; i++ )
    {
        pchDest[i] = pchSource[i];
    }

    if ( fPaddingNeeded )
    {
        for ( i=dwCharsToCopy; i<dwLimit-1; i++ )
        {
            pchDest[i] = ' ';
        }
    }

    // make sure last byte is a space

    pchDest[dwLimit-1] = ' ';



}  // end LpdFormat()


/* ========================================================================

Routine Description:

  Uses spooler-provided APIs to determine if the named registry DWORD is
  a non-zero value.  If the registry key does not exist, it is created,
  with a value of zero.

Arguments:

  hPrinter - A handle to the printer whose configuration is queried.  In
             order for writing the default value to work, this handle
             must have been opened with PRINTER_ACCESS_ADMINISTER

  pszParameterName - The name of the registry key to retrieve and test.

Return Value:

  TRUE if the registry key exists for this printer and contains a non-zero
  value.  FALSE is returned in all other cases.


*/


BOOL
IsPrinterDataSet(
    IN HANDLE hPrinter,
    IN LPTSTR pszParameterName
)
{
    DWORD                  dwRegValue;
    DWORD                  dwRegType;
    DWORD                  cbValueSize;
    DWORD                  dwErrcode;

    if ( ( GetPrinterData( hPrinter,
                           pszParameterName,
                           &dwRegType,
                           ( LPBYTE )&dwRegValue,
                           sizeof( dwRegValue ),
                           &cbValueSize ) == ERROR_SUCCESS ) &&
         ( dwRegType == REG_DWORD ) &&
         ( cbValueSize == sizeof( DWORD ) ) )
    {
        if ( dwRegValue )
        {
#if DBG
            LpdPrintf(  "Printer ox%08X has registry setting for %S.\n",
                        hPrinter,
                        pszParameterName );
#endif

            return( TRUE );
        }
    }
    else
    {
#if DBG
        LpdPrintf( "lpd:IsPrinterDataSet: GetPrinterData() failed.\n");
#endif

        //
        // Either the registry value in question is not in the registry, or it is
        // not a REG_DWORD that we can read.  The following code adds the setting
        // and defaults it to zero (0).  While this will not change the operation
        // of the print queue, it will make it easier for a user wishing to do so
        // to find the correct registry parameter.  Notice that this paragraph is
        // fully justified.
        //
        // If this fails we don't really care, so we don't check the return value
        //

        dwRegValue = 0;

        dwErrcode =
        SetPrinterData( hPrinter,
                        pszParameterName,
                        REG_DWORD,
                        ( LPBYTE )&dwRegValue,
                        sizeof( dwRegValue ) );

#if DBG
        LpdPrintf(  "lpd: wrote %S == %d for printer 0x%08X, dwErrcode is %s.\n",
                    pszParameterName,
                    dwRegValue,
                    hPrinter,
                    ( dwErrcode == ERROR_SUCCESS ) ? "Succesful" : "ERROR" );
#endif
    }

    return( FALSE );
}


/*

Routine Description:

  This function looks at the data file contents and attempts to determine if
  they are 'RAW' PostScript or PCL

Arguments:

  pchDataBuf - Pointer to the _beginning_ of the data file.

  cchBufferLen - Number of characters pointed to.

Returns:

  TRUE if the job type is detected as raw, FALSE if it is not.

*/


BOOL
IsDataTypeRaw(
  PCHAR pchDataBuf,
  int cchBufferLen
)
{
  PCHAR pchData;
  int cchAmountToSearch;
  int cchAmountSearched;

  ASSERT( STRING_LENGTH_POSTSCRIPT_HEADER == strlen( STRING_POSTSCRIPT_HEADER ) );

  //
  // Because some PS print drivers may send blank lines, end-of-file marks, and
  // other control characters at the beginning of the print data, the following
  // loop scans through these and skips them. The Windows 3.1 PostScript driver
  // was notorious for doing this, as an example.
  //

  for ( pchData = pchDataBuf; ( pchData - pchDataBuf ) < cchBufferLen; pchData ++ )
  {
    if ( *pchData >= 0x20 )
    {
      break;
    }
  }

  if ( (( cchBufferLen - ( pchData - pchDataBuf )) >= STRING_LENGTH_POSTSCRIPT_HEADER ) &&
       ( memcmp( pchData, STRING_POSTSCRIPT_HEADER, STRING_LENGTH_POSTSCRIPT_HEADER ) == 0 ))
  {
    LPD_DEBUG( "Printed data was detected as PostScript\n" );
    return( TRUE );
  }

  //
  // The job was not determined to be PostScript, so check to see if it is PCL.
  //

  pchData = pchDataBuf;

  cchAmountToSearch = min( cchBufferLen, MAX_PCL_SEARCH_DEPTH );
  cchAmountSearched = 0;

  while ( cchAmountSearched < cchAmountToSearch )
  {
    pchData = memchr( pchData, 0x1B, cchAmountToSearch - cchAmountSearched );

    if ( pchData == NULL )
    {
      break;
    }

    cchAmountSearched = (int)(pchData - pchDataBuf);

    if ( ( cchAmountSearched + 3 ) < cchAmountToSearch )
    {
      pchData++;
      cchAmountSearched++;

      if ( *pchData != '&' )
      {
        continue;
      }

      pchData++;
      cchAmountSearched++;

      if ( *pchData != 'l' )
      {
        continue;
      }

      pchData++;
      cchAmountSearched++;

      while (( cchAmountSearched < cchAmountToSearch )  && ( isdigit( *pchData )))
      {
        pchData++;
        cchAmountSearched++;
      }

      if (( cchAmountSearched < cchAmountToSearch ) && ( isalpha( *pchData )))
      {
        LPD_DEBUG( "Printed data was detected as PCL\n" );

        return( TRUE );
      }
    }

    // reached end of buffer
    else
    {
        break;
    }
  }

  LPD_DEBUG( "Printed data was not detected as anything special (like PS or PCL)\n" );

  return( FALSE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\lpd\sockets.c ===
/*************************************************************************
 *                        Microsoft Windows NT                           *
 *                                                                       *
 *                  Copyright(c) Microsoft Corp., 1994                   *
 *                                                                       *
 * Revision History:                                                     *
 *                                                                       *
 *   Jan. 23,94    Koti     Created                                      *
 *                                                                       *
 * Description:                                                          *
 *                                                                       *
 *   This file contains the functions that actually get the LPD service  *
 *   running, and also all the functions that deal with socket interface *
 *                                                                       *
 *************************************************************************/



#include "lpd.h"

typedef struct _FAMILY {
    int    family;
    int    socklen;
    HANDLE hAcceptThread;
    SOCKET sListener;       // the socket that listens for ever
    int    iErrcode;
} FAMILY;

FAMILY family[] = {
    { AF_INET,  sizeof(SOCKADDR_IN),  NULL },
    { AF_INET6, sizeof(SOCKADDR_IN6), NULL },
};

#define NUM_FAMILIES (sizeof(family) / sizeof(FAMILY))

DWORD
StartLPDFamily(int famidx)
{
    SOCKADDR_STORAGE saiSs;
    INT           iErrcode;
    BOOL          fExclsv;
    SERVENT       *pserv;
    DWORD         dwNewThreadId;
    DWORD         dwErrcode;

    // Create the socket (which will be the listening socket)

    family[famidx].sListener = socket( family[famidx].family, SOCK_STREAM, 0 );

    if ( family[famidx].sListener == INVALID_SOCKET )
    {
        iErrcode = WSAGetLastError();

        LPD_DEBUG( "socket() failed\n" );

        return( (DWORD)iErrcode );
    }


    //
    // set this port to be "Exclusive" so that no other app can grab it
    //

    fExclsv = TRUE;

    if (setsockopt( family[famidx].sListener,
                    SOL_SOCKET,
                    SO_EXCLUSIVEADDRUSE,
                    (CHAR *)&fExclsv,
                    sizeof(fExclsv) ) != 0)
    {
        LPD_DEBUG( "setsockopt SO_EXCLUSIVEADDRUSE failed\n");
    }


    // bind the socket to the LPD port
    memset(&saiSs, 0, sizeof(saiSs));

    pserv = getservbyname( "printer", "tcp" );

    if ( pserv == NULL )
    {
        SS_PORT(&saiSs) = htons( LPD_PORT );
    }
    else
    {
        SS_PORT(&saiSs) = pserv->s_port;
    }

    saiSs.ss_family = (short)family[famidx].family;

    iErrcode = bind( family[famidx].sListener, (LPSOCKADDR)&saiSs, sizeof(saiSs) );

    if ( iErrcode == SOCKET_ERROR )
    {

        iErrcode = WSAGetLastError();

        LPD_DEBUG( "bind() failed\n" );

        closesocket(family[famidx].sListener);

        family[famidx].sListener = INVALID_SOCKET;

        return( (DWORD)iErrcode );
    }


    // put the socket to listen,
    // backlog should be 50 not 5, MohsinA, 07-May-97.

    iErrcode = listen( family[famidx].sListener, 50 );

    if ( iErrcode == SOCKET_ERROR )
    {
        iErrcode = WSAGetLastError();

        LPD_DEBUG( "listen() failed\n" );

        closesocket(family[famidx].sListener);

        family[famidx].sListener = INVALID_SOCKET;

        return( (DWORD)iErrcode );
    }

    // Create the thread that keeps looping on accept

    family[famidx].hAcceptThread = CreateThread( NULL, 0, LoopOnAccept,
                                    IntToPtr(famidx), 0, &dwNewThreadId );

    if ( family[famidx].hAcceptThread == (HANDLE)NULL )
    {
        dwErrcode = GetLastError();

        LPD_DEBUG( "StartLPD:CreateThread() failed\n" );

        closesocket(family[famidx].sListener);

        family[famidx].sListener = INVALID_SOCKET;

        return( dwErrcode );
    }

    return( 0 );
}

/*****************************************************************************
 *                                                                           *
 * StartLPD():                                                               *
 *    This function does everything that's needed to accept an incoming call *
 *    (create a socket, listen, create a thread that loops on accept)        *
 *                                                                           *
 * Returns:                                                                  *
 *    NO_ERROR if everything went ok                                         *
 *    Error code (returned by the operation that failed) otherwise           *
 *                                                                           *
 * Parameters:                                                               *
 *    dwArgc (IN): number of arguments passed in                             *
 *    lpszArgv (IN): arguments to this function (array of null-terminated    *
 *                   strings).  First arg is the name of the service and the *
 *                   remaining are the ones passed by the calling process.   *
 *                   (e.g. net start lpd /p:xyz)                             *
 *                                                                           *
 * History:                                                                  *
 *    Jan.23, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

DWORD StartLPD( DWORD dwArgc, LPTSTR *lpszArgv )
{

    INT           iErrcode, i;
    HANDLE        hNewThread;
    WSADATA       wsaData;


    // for now, we ignore dwArgc and lpszArgv.  Plan is to support
    // command line (and/or registry configurable) parameters to the
    // "net start lpd" command.  At that time, we need to use them.


    // initialize winsock dll

    iErrcode = WSAStartup( MAKEWORD(WINSOCK_VER_MAJOR, WINSOCK_VER_MINOR),
                           &wsaData );
    if (iErrcode != 0)
    {
        LPD_DEBUG( "WSAStarup() failed\n" );

        return( (DWORD)iErrcode );
    }

    // initialize families and only fail if ALL of them fail.

    for (i=0; i<NUM_FAMILIES; i++) {
        family[i].iErrcode = StartLPDFamily(i);
    }
    if ((family[0].iErrcode != 0) && (family[1].iErrcode != 0)) {
        return( family[0].iErrcode );
    }

    // everything went fine: the LPD service is now running!

    return( NO_ERROR );


}  // end StartLPD()


void
StopLPDFamily(INT iFamIdx)
{
    DWORD   dwResult;

    if (family[iFamIdx].sListener == INVALID_SOCKET) {
        // Not started
        return;
    }

    SureCloseSocket( family[iFamIdx].sListener );

    //
    // accept() can take some time to return after the accept socket has
    // been closed.  wait for the accept thread to exit before continuing.
    // This will prevent an access violation in the case where WSACleanup
    // is called before accept() returns.
    //

    LPD_DEBUG( "Waiting for the accept thread to exit\n" );
    dwResult = WaitForSingleObject( family[iFamIdx].hAcceptThread, INFINITE );
    LPD_ASSERT( WAIT_OBJECT_0 == dwResult );
    CloseHandle( family[iFamIdx].hAcceptThread );
}


/*****************************************************************************
 *                                                                           *
 * StopLPD():                                                                *
 *    This function stops the LPD service by closing the listener socket     *
 *    (so that new connections are not accepted), and by allowing all the    *
 *    active threads to finish their job and terminate on their own.         *
 *                                                                           *
 * Returns:                                                                  *
 *    None                                                                   *
 *                                                                           *
 * Parameters:                                                               *
 *    None                                                                   *
 *                                                                           *
 * History:                                                                  *
 *    Jan.23, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

VOID StopLPD( VOID )
{

    BOOL    fClientsConnected=FALSE;
    INT     i;

    DBG_TRACEIN( "StopLPD" );

    //
    // first of all, set the flag!  This is the *only* place where we
    // change the value, so need not worry about guarding it.
    // This flag will cause all worker threads to exit.
    //

    fShuttingDownGLB = TRUE;

    //
    // stop accepting new connections,
    // This will wake the accept(), and LoopOnAccept will exit.
    //

    for (i=0; i<NUM_FAMILIES; i++) {
        StopLPDFamily(i);
    }

    EnterCriticalSection( &csConnSemGLB );
    {
        if( Common.AliveThreads > 0 ){
            fClientsConnected = TRUE;
        }
    }
    LeaveCriticalSection( &csConnSemGLB );


    // wait here until the last thread to leave sets the event

    if ( fClientsConnected )
    {
        LPD_DEBUG( "Waiting for last worker thread to exit\n" );
        WaitForSingleObject( hEventLastThreadGLB, INFINITE );
        LPD_DEBUG( "Waiting for last worker thread done.\n" );
    }

    WSACleanup();

    DBG_TRACEOUT( "StopLPD" );;
    return;

}  // end StopLPD()


/*****************************************************************************
 *                                                                           *
 * LoopOnAccept():                                                           *
 *    This function is executed by the new thread that's created in StartLPD *
 *    When a new connection request arrives, this function accepts it and    *
 *    creates a new thread which goes off and processes that connection.     *
 *                                                                           *
 * Returns:                                                                  *
 *    NO_ERROR (always)                                                      *
 *                                                                           *
 * Parameters:                                                               *
 *    lpArgv (IN): address family index                                      *
 *                                                                           *
 * History:                                                                  *
 *    Jan.23, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

DWORD LoopOnAccept( LPVOID lpArgv )
{
    INT           iFamIdx = (INT)(INT_PTR)lpArgv;
    SOCKET        sNewConn;
    SOCKADDR_STORAGE saAddr;
    INT           cbAddr;
    INT           iErrcode;
    PSOCKCONN     pscConn = NULL;
    PSOCKCONN     pConnToFree = NULL;
    PSOCKCONN     pPrevConn = NULL;
    BOOLEAN       fLinkedIn=FALSE;
    HANDLE        hNewThread;
    DWORD         dwNewThreadId;
    DWORD         dwErrcode;
    int           MoreThread;
    COMMON_LPD    local_common;
    int           QueueTooLong;

    DBG_TRACEIN( "LoopOnAccept " );
    cbAddr = sizeof( saAddr );

    // loop forever, trying to accept new calls

    while( TRUE )
    {
        LPD_DEBUG( "Calling accept.\n");

        MoreThread = 0;
        hNewThread = NULL;

        sNewConn = accept( family[iFamIdx].sListener, (LPSOCKADDR)&saAddr, &cbAddr );

        if ( sNewConn == INVALID_SOCKET )
        {
            iErrcode = WSAGetLastError();

            LOGIT(("LoopOnAccept(): accept failed err=%d\n", iErrcode ));

            if ( iErrcode == WSAEINTR )
            {
                //
                // sListener closed, it's shutdown time:
                // exit loop (& thread!)
                //
                break;
            }
            else
            {
                // some error: ignore; go back & wait! (didn't connect anyway)

                LOGIT(("LoopOnAccept(): bad accept err=%d\n", iErrcode ));

                continue;
            }
        }else{          // it's a good connection

            // Allocate a PSOCKCONN structure for this connection

            pscConn = (PSOCKCONN)LocalAlloc( LMEM_FIXED, sizeof(SOCKCONN) );

            // Create a new thread to deal with this connection

            if ( pscConn != NULL )
            {
                memset( (PCHAR)pscConn, 0, sizeof( SOCKCONN ) );

                InitializeListHead( &pscConn->CFile_List );
                InitializeListHead( &pscConn->DFile_List );

                pscConn->sSock = sNewConn;

                pscConn->fLogGenericEvent = TRUE;
                pscConn->dwThread    = 0;  // GetCurrentThreadId();
                pscConn->hPrinter    = (HANDLE)INVALID_HANDLE_VALUE;
#ifdef PROFILING
                pscConn->time_queued = time(NULL);
#endif

                EnterCriticalSection( &csConnSemGLB );
                {
                    Common.TotalAccepts++;

                    //
                    // scConnHeadGLB is the head and not used for jobs.
                    // Insertheadlist pscConn, WorkerThread will pull
                    // it out and process it.
                    //

                    if ((Common.QueueLength >= Common.AliveThreads) &&
                        (Common.AliveThreads < (int) dwMaxUsersGLB ))
                    {
                        MoreThread = (int)TRUE;
                    }

                    if( Common.QueueLength < (int) MaxQueueLength ){
                        QueueTooLong        = 0;

                        pscConn->pNext      = scConnHeadGLB.pNext;
                        scConnHeadGLB.pNext = pscConn;
                        fLinkedIn = TRUE;

                        // = Doubly linked now, MohsinA, 28-May-97.
                        // pscConn->pPrev         = &scConnHeadGLB;
                        // pscConn->pNext->pPrev  = pscConn;

                        Common.QueueLength++;
                    }else{
                        QueueTooLong        = 1;
                        MoreThread          = 0;
                        fLinkedIn = FALSE;
                    }

                    assert( Common.QueueLength  > 0  );
                    assert( Common.AliveThreads >= 0 );
                    assert( Common.TotalAccepts > 0  );
                }
                LeaveCriticalSection( &csConnSemGLB );

                if( MoreThread ){
                    hNewThread = CreateThread( NULL,
                                               0,
                                               WorkerThread,
                                               NULL,         // was pscConn
                                               0,
                                               &dwNewThreadId );


                    if( hNewThread == NULL ){
                        LPD_DEBUG( "LoopOnAccept: CreateThread failed\n" );
                    }
                }else{
                    hNewThread = NULL;
                    LOGIT(("LoopOnAccept: no new thread, dwMaxUsersGLB=%d.\n",
                           dwMaxUsersGLB ));
                }
            }
            else
            {
                LPD_DEBUG( "LoopOnAccept: LocalAlloc(pscConn) failed\n" );
            }


            // Update the global information.

            EnterCriticalSection( &csConnSemGLB );
            {
                if( MoreThread && hNewThread )
                    Common.AliveThreads++;
                if( Common.MaxThreads < Common.AliveThreads )
                    Common.MaxThreads = Common.AliveThreads;
                if( (pscConn == NULL)
                    || (MoreThread && ! hNewThread)
                    || QueueTooLong
                ){
                    Common.TotalErrors++;
                }
                local_common = Common;   // struct copy, for readonly.
            }
            LeaveCriticalSection( &csConnSemGLB );

            //
            // Something went wrong? close the new connection, do cleanup.
            // Q. What if CreateThread fails? does another thread
            //    picks up this job automatically?
            // A. Yes, another thread will process it.
            //    We shouldn't even expect it to be at the head
            //    of the queue since we left the CS above.
            //

            if( (pscConn == NULL)
                || (MoreThread && !hNewThread )
                || QueueTooLong
            ){
                dwErrcode = GetLastError();

                pConnToFree = NULL;

                if (!fLinkedIn)
                {
                    pConnToFree = pscConn;
                }

                //
                // we had already linked it in: try to find it first
                //
                else
                {
                    EnterCriticalSection( &csConnSemGLB );

                    // if there is no other thread alive and if we hit an error

                    if( pscConn && ( Common.AliveThreads == 0 ) )
                    {
                        pPrevConn = &scConnHeadGLB;
                        pConnToFree = scConnHeadGLB.pNext;

                        while (pConnToFree)
                        {
                            if (pConnToFree == pscConn)
                            {
                                pPrevConn->pNext = pConnToFree->pNext;
                                break;
                            }

                            pPrevConn = pConnToFree;
                            pConnToFree = pConnToFree->pNext;
                        }
                    }
                    LeaveCriticalSection( &csConnSemGLB );
                }

                if (pConnToFree)
                {
                    LocalFree( pConnToFree );
                    pscConn = NULL;
                    SureCloseSocket( sNewConn );
                }

                LpdReportEvent( LPDLOG_OUT_OF_RESOURCES, 0, NULL, 0 );

            }else{
#ifdef PROFILING
                LOGIT(("PROFILING: LoopOnAccept:\n"
                       "    QueueLength=%d,  MaxQueueLength=%d,\n"
                       "    AliveThreads=%d, TotalAccepts=%d, TotalErrors=%d\n"
                       ,
                       local_common.QueueLength,  MaxQueueLength,
                       local_common.AliveThreads,
                       local_common.TotalAccepts,
                       local_common.TotalErrors  ));
#endif
            }

            if( hNewThread ){
                CloseHandle( hNewThread );
            }
        }

    }  // while( TRUE )

    // ====================================================================
    // we reach here only when shutdown is happening.  The thread exits here.

    DBG_TRACEOUT( "LoopOnAccept exit." );
    return NO_ERROR;


}  // end LoopOnAccept()





/*****************************************************************************
 *                                                                           *
 * SureCloseSocket():                                                        *
 *    This function closes a given socket.  It first attempts a graceful     *
 *    close.  If that fails for some reason, then it does a "hard" close     *
 *                                                                           *
 * Returns:                                                                  *
 *    Nothing                                                                *
 *                                                                           *
 * Parameters:                                                               *
 *    sSockToClose (IN): socket descriptor of the socket to close            *
 *                                                                           *
 * History:                                                                  *
 *    Jan.23, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

VOID SureCloseSocket( SOCKET sSockToClose )
{

    LINGER   lLinger;


    if (sSockToClose == INVALID_SOCKET)
    {
        LPD_DEBUG( "SureCloseSocket: bad socket\n" );

        return;
    }


    // try to do a graceful close

    if ( closesocket(sSockToClose) == 0 )
    {
        return;
    }


    //for some reason, we couldn't close the socket: do a "hard" close now

    LPD_DEBUG( "SureCloseSocket: graceful close did not work; doing hard close\n" );

    lLinger.l_onoff = 1;          // non-zero integer to say SO_LINGER
    lLinger.l_linger = 0;         // timeout=0 seconds to say "hard" close


    // don't bother to check return code: can't do much anyway!

    setsockopt( sSockToClose, SOL_SOCKET, SO_LINGER,
                (CHAR *)&lLinger, sizeof(lLinger) );

    closesocket( sSockToClose );


}  // end SureCloseSocket()





/*****************************************************************************
 *                                                                           *
 * ReplyToClient():                                                          *
 *    This function sends an ACK or a NAK to the LPR client                  *
 *                                                                           *
 * Returns:                                                                  *
 *    NO_ERROR if reply sent                                                 *
 *    Errorcode if something didn't go well                                  *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN): PSOCKCONN structure for this connection                  *
 *    wResponse (IN): what needs to be sent - ACK or NAK                     *
 *                                                                           *
 * History:                                                                  *
 *    Jan.24, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

DWORD ReplyToClient( PSOCKCONN pscConn, WORD wResponse )
{

    // we will always send only one byte in this function!

    CHAR    szSndBuf[2];
    INT     iErrcode;


    szSndBuf[0] = (CHAR)wResponse;       // ACK or NAK

    iErrcode = send( pscConn->sSock, szSndBuf, 1, 0 );

    if ( iErrcode == 1 )
    {
        return( NO_ERROR );
    }

    if ( iErrcode == SOCKET_ERROR )
    {
        LPD_DEBUG( "send() failed in ReplyToClient()\n" );
    }

    return( iErrcode );


}  // end ReplyToClient()





/*****************************************************************************
 *                                                                           *
 * GetCmdFromClient():                                                       *
 *    This function reads a command sent by the LPR client (keeps reading    *
 *    until it finds '\n' (LF) in the stream, since every command ends with  *
 *    a LF).  It allocates memory for the command.                           *
 *                                                                           *
 * Returns:                                                                  *
 *    NO_ERROR if everything went ok                                         *
 *    Errorcode if something goes wrong (e.g. connection goes away etc.)     *
 *                                                                           *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): PSOCKCONN structure for this connection              *
 *                                                                           *
 * History:                                                                  *
 *    Jan.24, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

DWORD GetCmdFromClient( PSOCKCONN pscConn )
{

    INT       cbBytesRead;
    INT       cbBytesReadSoFar;
    INT       cbBytesToRead;
    INT       cbCmdLen;
    INT       i;
    BOOL      fCompleteCmd=FALSE;
    CHAR      szCmdBuf[500];
    PCHAR     pchAllocedBuf=NULL;
    PCHAR     pchNewAllocedBuf=NULL;
    SOCKET    sDestSock;
    DWORD     dwErrcode = SOCKET_ERROR;

    int             rdready;
    struct fd_set   rdsocks;
    struct timeval  timeo = { dwRecvTimeout, 0 };

    cbCmdLen = 0;

    cbBytesReadSoFar = 0;

    sDestSock = pscConn->sSock;


    // allocate a 1 byte buffer, so that we can use reallocate in a loop

    pchAllocedBuf = (PCHAR)LocalAlloc( LMEM_FIXED, 1 );

    if ( pchAllocedBuf == NULL )
    {
        LPD_DEBUG( "First LocalAlloc failed in GetCmdFromClient()\n" );

        goto GetCmdFromClient_BAIL;
    }

    // Keep reading in a loop until we receive one complete command
    // (with rfc1179, we shouldn't get more bytes than one command,
    // though less than one command is possible)

    //
    // What if the client never sends nor closes? we never Timeout?
    // We loose a worker thread - MohsinA, 01-May-97.
    //

    do {


        FD_ZERO(&rdsocks);
        FD_SET(sDestSock, &rdsocks);
        rdready = select( 1, &rdsocks, 0, 0, &timeo);

        if(  rdready == 0 )
        {
            LOGIT(("GetCmdFromClient: select timeout.\n"));
            goto GetCmdFromClient_BAIL;
        }else if( rdready == SOCKET_ERROR ){
            LOGIT(("GetCmdFromClient: select error %d.\n", GetLastError()));
            goto GetCmdFromClient_BAIL;
        }

        cbBytesRead = recv( sDestSock, szCmdBuf, sizeof(szCmdBuf), 0 );

        if ( cbBytesRead <= 0 )
        {
            if ( pchAllocedBuf != NULL )
            {
                LocalFree( pchAllocedBuf );
            }
            return CONNECTION_CLOSED;
        }

        cbBytesToRead = cbBytesRead;

        // see if we have received one complete command

        for( i=0; i<cbBytesRead; i++)
        {
            if ( szCmdBuf[i] == LF )
            {
                fCompleteCmd = TRUE;

                cbCmdLen = (i+1) + (cbBytesReadSoFar);

                cbBytesToRead = (i+1);

                break;
            }
        }

        // our needs are now bigger: reallocate memory
        // alloc 1 more for NULL byte
        pchNewAllocedBuf = (PCHAR)LocalReAlloc (pchAllocedBuf,
                                                cbBytesToRead+cbBytesReadSoFar + 1,
                                                LMEM_MOVEABLE);
        if (pchNewAllocedBuf == NULL)
        {
            LPD_DEBUG( "Second LocalAlloc failed in GetCmdFromClient()\n" );
            goto GetCmdFromClient_BAIL;
        }
        pchAllocedBuf = pchNewAllocedBuf;
        pchNewAllocedBuf = NULL;


        // now copy those bytes into our buffer

        strncpy( (pchAllocedBuf+cbBytesReadSoFar), szCmdBuf, cbBytesToRead );

        cbBytesReadSoFar += cbBytesRead;

        // if some bad implementation of LPR fails to follow spec and
        // never puts LF, then we don't want to be stuck here forever!

        if ( cbBytesReadSoFar > LPD_MAX_COMMAND_LEN )
        {
            LPD_DEBUG( "GetCmdFromClient(): command len exceeds our max\n" );

            goto GetCmdFromClient_BAIL;
        }


    } while( (!fCompleteCmd) || (cbBytesReadSoFar < cbCmdLen) );

    pchAllocedBuf[cbCmdLen] = '\0';

    pscConn->pchCommand = pchAllocedBuf;

    pscConn->cbCommandLen = cbCmdLen;

    return( NO_ERROR );

    //
    //  if we reach here, something went wrong: return NULL and
    //  the caller will understand!
    //

  GetCmdFromClient_BAIL:

    LOGIT(("GetCmdFromClient: failed, err=%d\n", GetLastError() ));

    if ( pchAllocedBuf != NULL )
    {
        LocalFree( pchAllocedBuf );
    }

    return dwErrcode;

}





/*****************************************************************************
 *                                                                           *
 * ReadData():                                                               *
 *    This function reads the specified number of bytes into the given       *
 *    buffer from the given socket.  This function blocks until all the      *
 *    required data is available (or error occurs).                          *
 *                                                                           *
 * Returns:                                                                  *
 *    NO_ERROR if everything went ok                                         *
 *    Errorcode if something goes wrong (e.g. connection goes away etc.)     *
 *                                                                           *
 * Parameters:                                                               *
 *    sDestSock (IN): socket from which to read or receive data              *
 *    pchBuf (OUT): buffer into which to store the data                      *
 *    cbBytesToRead (IN): how many bytes to read                             *
 *                                                                           *
 * History:                                                                  *
 *    Jan.24, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

DWORD ReadData( SOCKET sDestSock, PCHAR pchBuf, DWORD cbBytesToRead )
{


   DWORD    cbBytesExpctd;
   DWORD    cbBytesRead;

   int             rdready;
   struct fd_set   rdsocks;
   struct timeval  timeo = { dwRecvTimeout, 0 };


   cbBytesExpctd = cbBytesToRead;

   do{

       FD_ZERO(&rdsocks);
       FD_SET(sDestSock, &rdsocks);
       rdready = select( 1, &rdsocks, 0, 0, &timeo);

       if(  rdready == 0 ){
           LOGIT(("ReadData: select timeout.\n"));
           goto ReadData_Bail;
       }else if( rdready == SOCKET_ERROR ){
           LOGIT(("ReadData: select error %d.\n", GetLastError()));
           goto ReadData_Bail;
       }

      cbBytesRead = recv( sDestSock, pchBuf, cbBytesExpctd, 0 );

      if ( (cbBytesRead == SOCKET_ERROR) || (cbBytesRead == 0) )
      {
         goto ReadData_Bail;
      }

      cbBytesExpctd -= cbBytesRead;
      pchBuf        += cbBytesRead;

   } while( cbBytesExpctd != 0 );


   return( NO_ERROR );

  ReadData_Bail:

   LOGIT(("ReadData: failed %d\n", GetLastError() ));
   return LPDERR_NORESPONSE;

}  // end ReadData()


// ========================================================================
// We sleep while file is downloaded from the socket.
// Performance fix, MohsinA, 23-Apr-97.
//

DWORD ReadDataEx( SOCKET sDestSock, PCHAR pchBuf, DWORD cbBytesToRead )
{
    BOOL       ok;
    DWORD      err;
    DWORD      BytesRead = 0;
    OVERLAPPED ol = { 0,0,0,0,0 };

    while( cbBytesToRead ){

        ok = ReadFile( (HANDLE) sDestSock,
                       pchBuf,
                       cbBytesToRead,
                       &BytesRead,
                       &ol             );

        if(  ok  ){
            cbBytesToRead -= BytesRead;
            pchBuf        += BytesRead;
            continue;
        }

        // Else ReadFile is pending?

        err = GetLastError();
        switch( err ){
        case ERROR_IO_PENDING :
            ok = GetOverlappedResult( (HANDLE) sDestSock,
                                      &ol,
                                      &BytesRead,
                                      TRUE         );
            if( ! ok ){
                err = GetLastError();
                LOGIT(("lpd:ReadDataEx:GetOverlappedResult failed %d.\n",
                       err ));
                return LPDERR_NORESPONSE;
            }
            break;
        case ERROR_HANDLE_EOF :
            return NO_ERROR;
        default:
            LOGIT(("lpd:ReadDataEx:ReadFileEx failed %d.\n", err ));
            return LPDERR_NORESPONSE;
        }

    } // while.

    return( NO_ERROR );
}


/*****************************************************************************
 *                                                                           *
 * SendData():                                                               *
 *    This function attempts to send the specified number of bytes over the  *
 *    given socket.  The function blocks until send() returns.               *
 *                                                                           *
 * Returns:                                                                  *
 *    NO_ERROR if everything went ok                                         *
 *    Errorcode if data couldn't be sent (e.g. connection goes away etc.)    *
 *                                                                           *
 * Parameters:                                                               *
 *    sDestSock (IN): socket over which to send data                         *
 *    pchBuf (IN): buffer containing data                                    *
 *    cbBytesToSend (IN): how many bytes to send                             *
 *                                                                           *
 * History:                                                                  *
 *    Jan.24, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

DWORD SendData( SOCKET sDestSock, PCHAR pchBuf, DWORD cbBytesToSend )
{

   INT    iErrcode;


   iErrcode = send( sDestSock, pchBuf, cbBytesToSend, 0 );

   if ( iErrcode == SOCKET_ERROR )
   {
      LPD_DEBUG( "send() failed in SendData()\n" );
   }

   return( (DWORD)iErrcode );



}  // end SendData()




/*****************************************************************************
 *                                                                           *
 * GetClientInfo();                                                          *
 *    This function retrieves info about the client (for now, only the IP    *
 *    address).  This info is used during logging.                           *
 *                                                                           *
 * Returns:                                                                  *
 *    Nothing                                                                *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): PSOCKCONN structure for this connection              *
 *                                                                           *
 * History:                                                                  *
 *    Jan.24, 94   Koti   Created                                            *
 *                                                                           *
 *****************************************************************************/

VOID GetClientInfo( PSOCKCONN pscConn )
{

   INT            iErrcode;
   INT            iLen, iLen2;
   SOCKADDR_STORAGE saName;


   iLen = sizeof(saName);

   iErrcode = getpeername( pscConn->sSock, (SOCKADDR *)&saName, &iLen );

   if ( iErrcode == 0 )
   {
       iLen2 = sizeof(pscConn->szIPAddr);
       SS_PORT(&saName) = 0;
       iErrcode = WSAAddressToString((SOCKADDR*)&saName, iLen, NULL,
                                     pscConn->szIPAddr, &iLen2);
   }


   if (iErrcode == SOCKET_ERROR)
   {
      LPD_DEBUG( "GetClientInfo(): couldn't retrieve ip address!\n" );

      strcpy( pscConn->szIPAddr, GETSTRING( LPD_ERMSG_NO_IPADDR) );

      return;
   }

   LOGTIME;
   LOGIT(("GetClientInfo: %s:%d\n",
          pscConn->szIPAddr,
          htons(SS_PORT(&saName)) ));


}  // end GetClientInfo()


/*****************************************************************************
 *                                                                           *
 * GetServerInfo();                                                          *
 *    This function retrieves info about the Server (for now, only the IP    *
 *    address).  This info is used during logging.                           *
 *                                                                           *
 * Returns:                                                                  *
 *    Nothing                                                                *
 * Parameters:                                                               *
 *    pscConn (IN-OUT): PSOCKCONN structure for this connection              *
 *                                                                           *
 * History: From Albert Ting, Printer Group, 4-Mar-97.                       *
 *          MohsinA.                                                         *
 *****************************************************************************/

VOID GetServerInfo( PSOCKCONN pscConn )
{

   INT            iErrcode;
   INT            iLen, iLen2;
   SOCKADDR_STORAGE saName;


   iLen = sizeof(saName);

   iErrcode = getsockname( pscConn->sSock, (SOCKADDR *)&saName, &iLen );

   if ( iErrcode == 0 ){
       iLen2 = sizeof(pscConn->szServerIPAddr);
       SS_PORT(&saName) = 0;
       iErrcode = WSAAddressToString((SOCKADDR*)&saName, iLen, NULL,
                                     pscConn->szServerIPAddr, &iLen2);
   }

   if (iErrcode == SOCKET_ERROR){
      LPD_DEBUG( "GetServerInfo(): couldn't retrieve ip address!\n" );
      strcpy( pscConn->szServerIPAddr, GETSTRING( LPD_ERMSG_NO_IPADDR) );
      return;
   }

}  // end GetServerInfo()
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\lpd\trace.c ===
//   Name:  Mohsin Ahmed
//   Email: MohsinA@microsoft.com
//   Date:  Fri Jan 24 10:33:54 1997
//   File:  d:/nt/PRIVATE/net/sockets/tcpsvcs/lpd/trace.c
//   Synopsis: Too many bugs, need to keep track in the field.

#include "lpd.h"

char   LogFileName[1000];
FILE * LogFile = NULL;

// ========================================================================

void
LogTime( void )
{
    time_t now;
    time( &now );
    LOGIT(( " Time %s",  ctime( &now ) ));
}

// ========================================================================
// Opens filename in append mode.
// LogFileName is set to filename or debugger.
// On success:   LogFile handle
// On failure:   NULL
// ========================================================================

CRITICAL_SECTION csLogit;


FILE *
beginlogging( char * filename )
{
    int       ok;

    if( ! filename ){
        DbgPrint( "lpd No log file?\n");
        return 0;
    }

    if( LogFile ){
        DbgPrint( "lpd: Already logging.\n");
        return 0;
    }

    assert( LogFile == NULL );

    ok = ExpandEnvironmentStringsA( filename,
                                    LogFileName,
                                    sizeof( LogFileName )  );

    if( !ok ){
        DbgPrint("ExpandEnvironmentStrings(%s) failed, err=%d\n",
                 filename, GetLastError() );
        strcpy( LogFileName, "<debugger>" );
    }else{

        LogFile = fopen( LogFileName, "a+" );

        if( LogFile == NULL ){
            DbgPrint( "lpd: Cannot open LogFileName=%s\n", LogFileName );
            strcpy( LogFileName, "<debugger>" );
        }
    }

    if( LogFile ){

        InitializeCriticalSection( &csLogit );

        LogTime();
        fprintf( LogFile, "==========================================\n");
        fprintf( LogFile, "lpd: LogFileName=%s\n", LogFileName );
        fprintf( LogFile, "built %s %s\n", __DATE__, __TIME__ );
        fprintf( LogFile, "from %s\n", __FILE__ );
        fprintf( LogFile, "==========================================\n");
    }else{
        DbgPrint("lpd: started, built %s %s.\n", __DATE__, __TIME__ );
    }

    return LogFile;
}

// ========================================================================
// Like printf but send output to LogFile if open, else to Debugger.
// ========================================================================

static DWORD lasttickflush;

int
logit( char * format, ... )
{
    va_list ap;
    char    message[LEN_DbgPrint];
    int     message_len;
    DWORD   thistick;

    va_start( ap, format );
    message_len = _vsnprintf (message,LEN_DbgPrint, format, ap );
    message[LEN_DbgPrint-1] = '\0';
    va_end( ap );
//    assert( message_len < LEN_DbgPrint );

    if( LogFile ){

        EnterCriticalSection( &csLogit );
        fputs (message, LogFile);
        LeaveCriticalSection( &csLogit );


        // Don't flush more than once a second.
        thistick = GetTickCount();
        if( abs( thistick - lasttickflush  ) > 1000 ){
            lasttickflush = thistick;
            fflush( LogFile );
        }
    }else{
        DbgPrint( message );
    }
    return message_len;
}

// ========================================================================
// Closes the log file if open.
// ========================================================================

FILE *
stoplogging( FILE * LogFile )
{
    if( LogFile ){
        LogTime();
        LOGIT(( "lpd stoplogging\n"));
        fclose( LogFile );
        LogFile = NULL;
        // DeleteCriticalSection( &csLogit );
    }
    DbgPrint( "lpd: stopped logging.\n" );
    return LogFile;
}

// ========================================================================
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\rip\errorlog.h ===
/********************************************************************/
/**            Copyright(c) 1992 Microsoft Corporation.            **/
/********************************************************************/

//***
//
// Filename:  errorlog.h
//
// Description: 
//
// History:
//            Feb. 21,1995.  Gurdeep Singh Pall  Created original version.
//
//***

// Don't change the comments following the manifest constants without
// understanding how mapmsg works.
//

#define RIPLOG_BASE                                         29000

#define RIPLOG_SERVICE_STARTED                              (RIPLOG_BASE + 1)
/*
 * Microsoft RIP for Internet Protocol Service started successfully.
 */

#define RIPLOG_CANNOT_CREATE_NOTIFICATION_EVENT             (RIPLOG_BASE + 2)
/*
 * IPRIP was unable to open configuration change event.
 * Please try freeing some system resources.
 */

#define RIPLOG_REGISTER_FAILED                              (RIPLOG_BASE + 3)
/*
 * IPRIP could not register the service with the Service Control Manager.
 * Please make certain the service is correctly installed.
 */

#define RIPLOG_SETSTATUS_FAILED                             (RIPLOG_BASE + 4)
/*
 * IPRIP was unable to update the status of the service.
 */

#define RIPLOG_CREATEMUTEX_FAILED                           (RIPLOG_BASE + 5)
/*
 * IPRIP was unable to create a mutex for synchronization.
 * Please try freeing some system resources.
 */

#define RIPLOG_CREATEEVENT_FAILED                           (RIPLOG_BASE + 6)
/*
 * IPRIP was unable to create an event for synchronization.
 * Please try freeing some system resources.
 */

#define RIPLOG_REGINIT_FAILED                               (RIPLOG_BASE + 7)
/*
 * IPRIP was unable to load some parameters from the registry.
 * Please make certain the service is correctly installed.
 */

#define RIPLOG_IFINIT_FAILED                                (RIPLOG_BASE + 8)
/*
 * IPRIP was unable to load the list of interfaces on the system:
 * either there are insufficient resources, or no network interfaces
 * are configured.
 */

#define RIPLOG_ROUTEINIT_FAILED                             (RIPLOG_BASE + 9)
/*
 * IPRIP was unable to load the list of routes on the system:
 * either there are insufficient resources, or IP routing is disabled.
 */

#define RIPLOG_WSOCKINIT_FAILED                             (RIPLOG_BASE + 10)
/*
 * IPRIP was unable to initialize the Windows Sockets DLL.
 * Please make certain the correct version of Windows Sockets is installed.
 */

#define RIPLOG_CREATESOCK_FAILED_GENERIC                    (RIPLOG_BASE + 11)
/* 
 * IPRIP was unable to create a socket. The network subsystem may have failed,
 * or there may be insufficient resources to complete the request.
 */

#define RIPLOG_BINDSOCK_FAILED                              (RIPLOG_BASE + 12)
/*
 * IPRIP was unable to bind a socket to IP address %1.
 * The data is the error code.
 */

#define RIPLOG_CREATETHREAD_FAILED                          (RIPLOG_BASE + 13)
/*
 * IPRIP was unable to create a thread.
 * Please try freeing some system resources.
 */

#define RIPLOG_RECVFROM_FAILED                              (RIPLOG_BASE + 14)
/*
 * IPRIP was unable to receive an incoming RIP packet.
 */

#define RIPLOG_RECVSIZE_TOO_GREAT                           (RIPLOG_BASE + 15)
/*
 * A message was received which was too large.
 */

#define RIPLOG_FORMAT_ERROR                                 (RIPLOG_BASE + 16)
/*
 * A message was received whose formatting was in error.
 * Either the version was invalid, or one of the reserved fields
 * contained data.
 */

#define RIPLOG_INVALIDPORT                                  (RIPLOG_BASE + 17)
/*
 * A message was received which was not sent from IPRIP port 520.
 */

#define RIPLOG_SERVICE_STOPPED                              (RIPLOG_BASE + 18)
/*
 * IPRIP has stopped.
 */

#define RIPLOG_SENDTO_FAILED                                (RIPLOG_BASE + 19)
/*
 * IPRIP was unable to send a RIP message.
 */

#define RIPLOG_SOCKINIT_FAILED                              (RIPLOG_BASE + 20)
/*
 * IPRIP was unable to bind to one or more IP addresses.
 */

#define RIPLOG_REINIT_FAILED                                (RIPLOG_BASE + 21)
/*
 * IPRIP was unable to re-initialize after an IP address changed.
 */

#define RIPLOG_VERSION_ZERO                                 (RIPLOG_BASE + 22)
/*
 * IPRIP received a RIP packet with a version field of zero.
 * The packet has been discarded.
 */

#define RIPLOG_RT_ALLOC_FAILED                              (RIPLOG_BASE + 23)
/*
 * IPRIP was unable to allocate memory for a routing table entry.
 */

#define RIPLOG_RTAB_INIT_FAILED                             (RIPLOG_BASE + 24)
/*
 * IPRIP was unable to initialize its routing table.
 * The data is the error code.
 */

#define RIPLOG_STAT_INIT_FAILED                             (RIPLOG_BASE + 25)
/*
 * IPRIP was unable to initialize its statistics table.
 * The data is the error code.
 */

#define RIPLOG_READBINDING_FAILED                           (RIPLOG_BASE + 26)
/*
 * IPRIP was unable to read its interface bindings from the registry.
 * The data is the error code.
 */

#define RIPLOG_IFLIST_ALLOC_FAILED                          (RIPLOG_BASE + 27)
/*
 * IPRIP was unable to allocate memory for its interface list.
 * The data is the error code.
 */

#define RIPLOG_CREATESOCK_FAILED                            (RIPLOG_BASE + 28)
/*
 * IPRIP was unable to create a socket for address %1.
 * The data is the error code.
 */

#define RIPLOG_SET_BCAST_FAILED                             (RIPLOG_BASE + 29)
/*
 * IPRIP was unable to enable broadcasting on the socket for address %1.
 * The data is the error code.
 */

#define RIPLOG_SET_REUSE_FAILED                             (RIPLOG_BASE + 30)
/*
 * IPRIP was unable to enable address re-use on the socket for address %1.
 * The data is the error code.
 */

#define RIPLOG_ADD_ROUTE_FAILED                             (RIPLOG_BASE + 31)
/*
 * IPRIP was unable to add a route to the system route table.
 * The data is the error code.
 */

#define RIPLOG_DELETE_ROUTE_FAILED                          (RIPLOG_BASE + 32)
/*
 * IPRIP was unable to delete a route from the system route table.
 * The data is the error code.
 */

#define RIPLOG_AF_UNKNOWN                                   (RIPLOG_BASE + 33)
/*
 * Address family unknown in route to %1 with next-hop %2.
 * The route has been discarded.
 */

#define RIPLOG_CLASS_INVALID                                (RIPLOG_BASE + 34)
/*
 * Class D or E address are invalid, ignoring route to %1 with next-hop %2.
 * The route has been discarded.
 */

#define RIPLOG_LOOPBACK_INVALID                             (RIPLOG_BASE + 35)
/*
 * Loop-back addresses are invalid, ignoring route to %1 with next-hop %2.
 * The route has been discarded.
 */

#define RIPLOG_BROADCAST_INVALID                            (RIPLOG_BASE + 36)
/*
 * Broadcast addresses are invalid, ignoring route to %1 with next-hop %2.
 * The route has been discarded.
 */

#define RIPLOG_HOST_INVALID                                 (RIPLOG_BASE + 37)
/*
 * IPRIP is configured to discard host routes, so a route to %1
 * with next-hop %2 has been discarded.
 */

#define RIPLOG_DEFAULT_INVALID                              (RIPLOG_BASE + 38)
/*
 * IPRIP is configured to discard default routes, so a route to %1
 * with next-hop %2 has been discarded.
 */

#define RIPLOG_NEW_LEARNT_ROUTE                             (RIPLOG_BASE + 39)
/*
 * IPRIP has learnt a new route to %1 with next-hop %2 and metric %3.
 */

#define RIPLOG_METRIC_CHANGE                                (RIPLOG_BASE + 40)
/*
 * IPRIP's route to %1 with next-hop %2 now has metric %3.
 */

#define RIPLOG_ROUTE_REPLACED                               (RIPLOG_BASE + 41)
/*
 * IPRIP's route to %1 now has next-hop %2 and metric %3.
 */

#define RIPLOG_ADDRESS_CHANGE                               (RIPLOG_BASE + 42)
/*
 * IPRIP has detected an IP address change, and is reconfiguring.
 */


#define RIPLOG_ROUTE_REMOVED                                (RIPLOG_BASE + 43)
/*
 * IPRIP's route to %1 with next-hop %2 is being removed.
 */

#define RIPLOG_ROUTE_TIMEOUT                                (RIPLOG_BASE + 44)
/*
 * IPRIP's route to %1 with next-hop %2 has timed-out.
 */

#define RIPLOG_FINAL_UPDATES                                (RIPLOG_BASE + 45)
/*
 * IPRIP is sending out final updates.
 */

#define RIPLOG_REGISTRY_PARAMETERS                          (RIPLOG_BASE + 46)
/*
 * IPRIP is using the following parameters:
 * %1
 */

#define RIPLOG_SERVICE_AREADY_STARTED                       (RIPLOG_BASE + 47)
/*
 * RIP listener service has already been started
 */

#define RIPLOG_SERVICE_INIT_FAILED                          (RIPLOG_BASE + 48)
/*
 * RIP listener service failed during initialization 
 */

#define RIPLOG_FILTER_ALLOC_FAILED                          (RIPLOG_BASE + 49)
/*
 * IPRIP was unable to allocate memory for its filter tables.
 * The data is the error code
 * %1
 */

#define RIPLOG_ADDR_ALLOC_FAILED                            (RIPLOG_BASE + 50)
/*
 * IPRIP was unable to allocate memory for its address tables.
 * The data is the error code
 * %1
 */

#define RIPLOG_ADDR_INIT_FAILED                             (RIPLOG_BASE + 51)
/*
 * IPRIP was unable to initialize its address tables.
 * The data is the error code
 * %1
 */

#define RIPLOG_SET_MCAST_IF_FAILED                          (RIPLOG_BASE + 52)
/*
 * IPRIP could not request multicasting on the local interface
 * with IP address %1.
 * The data is the error code.
 */

#define RIPLOG_JOIN_GROUP_FAILED                            (RIPLOG_BASE + 53)
/*
 * IPRIP could not join the multicast group 224.0.0.9
 * on the local interface with IP address %1.
 * The data is the error code.
 */

#define RIPLOG_WSAEVENTSELECT_FAILED                        (RIPLOG_BASE + 54)
/*
 * IPRIP was unable to do WSAEventSelect on a socket
 * bound to the local interface with IP address %1.
 * The data is the error code.
 */

#define RIPLOG_WSAENUMNETWORKEVENTS_FAILED                  (RIPLOG_BASE + 55)
/*
 * IPRIP was unable to enumerate network events on a socket
 * bound to the local interface with IP address %1.
 * The data is the error code.
 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\rip\map.c ===
/*
 *============================================================================
 * Copyright (c) 1994-95, Microsoft Corp.
 *
 * File:    map.c
 *
 * Routes can be added to and deleted from the IP routing table by other
 * means. Therefore, it is necessary for any protocol using these functions
 * to reload the routing tables periodically.
 *============================================================================
 */

#include "pchrip.h"
#pragma hdrstop

//----------------------------------------------------------------------------
// GetIpAddressTable
//
// This function retrieves the list of addresses for the logical interfaces
// configured on this system.
//----------------------------------------------------------------------------

DWORD
GetIPAddressTable(
    OUT PMIB_IPADDRROW *lplpAddrTable,
    OUT LPDWORD lpdwAddrCount
)
{

    DWORD                   dwSize = 0, dwErr = 0;
    PMIB_IPADDRTABLE        pmiatTable = NULL;
    

    

    *lplpAddrTable = NULL;
    *lpdwAddrCount = 0;
    

    do
    {

        //
        // retrieve ip address table.  First call to find size of
        // structure to be allocated.
        //
        
        dwErr = GetIpAddrTable( pmiatTable, &dwSize, TRUE );

        if ( dwErr != ERROR_INSUFFICIENT_BUFFER )
        {
            dbgprintf( "GetIpAddrTable failed with error %x\n", dwErr );

            RipLogError( RIPLOG_ADDR_INIT_FAILED, 0, NULL, dwErr );

            break;
        }


        //
        // allocate requiste buffer
        //
        
        pmiatTable = HeapAlloc( GetProcessHeap(), 0 , dwSize );

        if ( pmiatTable == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            
            dbgprintf( "GetIpAddrTable failed with error %x\n", dwErr );

            RipLogError( RIPLOG_ADDR_ALLOC_FAILED, 0, NULL, dwErr );

            break;
        }


        //
        // now retrieve address table
        //

        dwErr = GetIpAddrTable( pmiatTable, &dwSize, TRUE );
                    
        if ( dwErr != NO_ERROR )
        {
            dbgprintf( "GetIpAddrTable failed with error %x\n", dwErr );

            RipLogError( RIPLOG_ADDR_INIT_FAILED, 0, NULL, dwErr );

            break;
        }

        *lpdwAddrCount = pmiatTable-> dwNumEntries;

        *lplpAddrTable = pmiatTable-> table;

        return NO_ERROR;
        
    } while ( FALSE );


    //
    // Error condition
    //

    if ( pmiatTable ) 
    {
        HeapFree( GetProcessHeap(), 0, pmiatTable );
    }

    return dwErr;
}


//----------------------------------------------------------------------------
// FreeIPAddressTable
//
// This function releases the memory allocated for the IP address table by
// the GetIpAddressTable API.
//----------------------------------------------------------------------------

DWORD
FreeIPAddressTable(
    IN PMIB_IPADDRROW lpAddrTable
    )
{

    PMIB_IPADDRTABLE pmiatTable = NULL;


    pmiatTable = CONTAINING_RECORD( lpAddrTable, MIB_IPADDRTABLE, table );

    if ( pmiatTable != NULL )
    {
        HeapFree( GetProcessHeap(), 0, pmiatTable );

        return NO_ERROR;    
    }

    return ERROR_INVALID_PARAMETER;
}


//----------------------------------------------------------------------------
// GetRouteTable
//
// This function retrieves the route table.
//----------------------------------------------------------------------------

DWORD
GetRouteTable(
    OUT LPIPROUTE_ENTRY *lplpRouteTable,
    OUT LPDWORD lpdwRouteCount
    )
{

    DWORD                   dwErr = (DWORD) -1, dwSize = 0;
    PMIB_IPFORWARDTABLE     pmiftTable = NULL;

    

    *lplpRouteTable = NULL;
    *lpdwRouteCount = 0;


    do
    {

        //
        // get size of buffer required.
        //
        
        dwErr = GetIpForwardTable( pmiftTable, &dwSize, TRUE );

        if ( dwErr != ERROR_INSUFFICIENT_BUFFER )
        {
            dbgprintf( "GetIpNetTable failed with error %x\n", dwErr );

            RipLogError( RIPLOG_ROUTEINIT_FAILED, 0, NULL, dwErr );

            break;
        }


        //
        // allocate requiste buffer space
        //

        pmiftTable = HeapAlloc( GetProcessHeap(), 0, dwSize );

        if ( pmiftTable == NULL )
        {
            dwErr = ERROR_NOT_ENOUGH_MEMORY;
            
            dbgprintf( "GetIpAddrTable failed with error %x\n", dwErr );

            RipLogError( RIPLOG_RTAB_INIT_FAILED, 0, NULL, dwErr );

            break;
        }


        //
        // now retrieve route table
        //

        dwErr = GetIpForwardTable( pmiftTable, &dwSize, TRUE );
                    
        if ( dwErr != NO_ERROR )
        {
            dbgprintf( "GetIpNetTable failed with error %x\n", dwErr );

            RipLogError( RIPLOG_RTAB_INIT_FAILED, 0, NULL, dwErr );

            break;
        }

        *lpdwRouteCount = pmiftTable-> dwNumEntries;

        *lplpRouteTable = (LPIPROUTE_ENTRY) pmiftTable-> table;

        return NO_ERROR;
        
    } while ( FALSE );


    //
    // Error condition
    //

    if ( pmiftTable ) 
    {
        HeapFree( GetProcessHeap(), 0, pmiftTable );
    }

    return dwErr;
}


//----------------------------------------------------------------------------
// FreeIPRouteTable
//
// This function releases the memory allocated for the IP route table by
// the GetIpAddressTable API.
//----------------------------------------------------------------------------

DWORD
FreeRouteTable(
    IN LPIPROUTE_ENTRY lpRouteTable
    )
{

    PMIB_IPFORWARDTABLE pmiftTable = NULL;


    pmiftTable = CONTAINING_RECORD( lpRouteTable, MIB_IPFORWARDTABLE, table );

    if ( pmiftTable != NULL )
    {
        HeapFree( GetProcessHeap(), 0, pmiftTable );

        return NO_ERROR;    
    }

    return ERROR_INVALID_PARAMETER;
}


//----------------------------------------------------------------------------
// AddRoute
//
// This function adds a route to the IP stack
//----------------------------------------------------------------------------

DWORD
AddRoute(
    IN DWORD dwProtocol,
    IN DWORD dwType,
    IN DWORD dwIndex,
    IN DWORD dwDestVal,
    IN DWORD dwMaskVal,
    IN DWORD dwGateVal,
    IN DWORD dwMetric
    )
{

    DWORD                   dwErr = 0;

    MIB_IPFORWARDROW        mifr;

    
    ZeroMemory( &mifr, sizeof( MIB_IPFORWARDROW ) );

    mifr.dwForwardDest      = dwDestVal;
    mifr.dwForwardMask      = dwMaskVal;
    mifr.dwForwardPolicy    = 0;
    mifr.dwForwardNextHop   = dwGateVal;
    mifr.dwForwardIfIndex   = dwIndex;
    mifr.dwForwardType      = dwType;
    mifr.dwForwardProto     = MIB_IPPROTO_NT_AUTOSTATIC;
    mifr.dwForwardMetric1   = dwMetric;


    dwErr = CreateIpForwardEntry( &mifr );

    if ( dwErr == ERROR_ALREADY_EXISTS )
    {
        //
        // Bug # : 405469
        //
        //  For the case where IPRIP (Rip Listener) is running at the
        //  same time as the RemoteAccess service.
        //  In this case the IPHLPAPI go via the IPRTRMGR to the stack
        //  and trying to create a route that already exists will fail
        //  with ERROR_ALREADY_EXISTS.  To work around this case, set
        //  the forward entry.
        //
        
        dwErr = SetIpForwardEntry( &mifr );
    }
    
    if ( dwErr != NO_ERROR )
    {
        dbgprintf( "Create/Set IpForwardEntry failed with error %x\n", dwErr );

        RipLogError( RIPLOG_ADD_ROUTE_FAILED, 0, NULL, dwErr );
    }

    return dwErr;
}



//----------------------------------------------------------------------------
// DelRoute
//
// This function deletes a route to the IP stack
//----------------------------------------------------------------------------

DWORD
DeleteRoute(
    IN DWORD dwIndex,
    IN DWORD dwDestVal,
    IN DWORD dwMaskVal,
    IN DWORD dwGateVal
    )
{

    DWORD                   dwErr = 0;

    MIB_IPFORWARDROW        mifr;

    
    ZeroMemory( &mifr, sizeof( MIB_IPFORWARDROW ) );


    mifr.dwForwardDest      = dwDestVal;
    mifr.dwForwardMask      = dwMaskVal;
    mifr.dwForwardPolicy    = 0;
    mifr.dwForwardProto     = MIB_IPPROTO_NT_AUTOSTATIC;
    mifr.dwForwardNextHop   = dwGateVal;
    mifr.dwForwardIfIndex   = dwIndex;


    dwErr = DeleteIpForwardEntry( &mifr );

    if ( dwErr != NO_ERROR )
    {
        dbgprintf( "DeleteIpForwardEntry failed with error %x\n", dwErr );

        RipLogError( RIPLOG_DELETE_ROUTE_FAILED, 0, NULL, dwErr );
    }

    return dwErr;
}


//----------------------------------------------------------------------------
// DelRoute
//
// This function deletes a route to the IP stack
//----------------------------------------------------------------------------

DWORD
ReloadIPAddressTable(
    OUT PMIB_IPADDRROW *lplpAddrTable,
    OUT LPDWORD lpdwAddrCount
    )
{
    return GetIPAddressTable( lplpAddrTable, lpdwAddrCount );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\rip\map.h ===
/*
 *============================================================================
 * Copyright (c) 1994-95, Microsoft Corp.
 *
 * File:    map.h
 *
 * Contains declarations for the functions that map old style routetab
 * functions to the iphlpapi functions.
 *
 *      AddRoute
 *      DeleteRoute
 *      GetRouteTable
 *      FreeRouteTable
 *      GetInterfaceTable
 *      FreeInterfaceTable
 *
 * The structures required by these functions are also declared here:
 *
 *      IPROUTING_ENTRY
 *      IPINTERFACE_ENTRY
 *
 * Routes can be added to and deleted from the IP routing table by other
 * means. Therefore, it is necessary for any protocol using these functions
 * to reload the routing tables periodically.
 *============================================================================
 */

#ifndef _MAP_H_
#define _MAP_H_



/*
 *---------------------------------------------------------------
 * Any one of these values can be passed as the route entry type
 * when calling the AddRoute() function.
 *---------------------------------------------------------------
 */
#define IRE_TYPE_OTHER      1
#define IRE_TYPE_INVALID    2
#define IRE_TYPE_DIRECT     3
#define IRE_TYPE_INDIRECT   4



/*
 *-------------------------------------------------------------
 * Any one of these values can be passed as the protocol type
 * when calling AddRoute() or DeleteRoute()
 *-------------------------------------------------------------
 */
#define IRE_PROTO_OTHER     1
#define IRE_PROTO_LOCAL     2
#define IRE_PROTO_NETMGMT   3
#define IRE_PROTO_ICMP      4
#define IRE_PROTO_EGP       5
#define IRE_PROTO_GGP       6
#define IRE_PROTO_HELLO     7
#define IRE_PROTO_RIP       8
#define IRE_PROTO_IS_IS     9
#define IRE_PROTO_ES_IS     10
#define IRE_PROTO_CISCO     11
#define IRE_PROTO_BBN       12
#define IRE_PROTO_OSPF      13
#define IRE_PROTO_BGP       14



/*
 *-------------------------------------------------------------
 * This value may be passed as the metric to functions which
 * require a metric, in cases where the metric is irrelevant
 *-------------------------------------------------------------
 */
#define IRE_METRIC_UNUSED   0xffffffff


/*
 *-------------------------------------------------------------
 * These constants are used in the definition of IF_ENTRY
 *-------------------------------------------------------------
 */
#define MAX_PHYSADDR_SIZE       8
#define	MAX_IFDESCR_LEN			256



/*
 *-------------------------------------------------------------
 * This structure is used by GetIPAddressTable() to return
 * information about logical IP interfaces on the system
 *-------------------------------------------------------------
 */
typedef struct _IPADDRESS_ENTRY {
    DWORD       iae_address;          /* IP address of this entry  */
    DWORD       iae_index;            /* index of interface for this entry */
    DWORD       iae_netmask;          /* subnet mask of this entry */
    DWORD       iae_bcastaddr;
    DWORD       iae_reasmsize;
    USHORT      iae_context;
    USHORT      iae_pad;
} IPADDRESS_ENTRY, *LPIPADDRESS_ENTRY;



/*
 *-------------------------------------------------------------
 * This structure is used by GetRouteTable() to return
 * information about routing table entries.
 *-------------------------------------------------------------
 */
typedef struct _IPROUTE_ENTRY {
    DWORD       ire_dest;       /* destination IP addr, network order */
    DWORD       ire_mask;       /* network mask, network order        */
    DWORD       ire_policy;     /* policy duh(?) */
    DWORD       ire_nexthop;    /* next hop IP addr, network order    */
    DWORD       ire_index;      /* route entry index                  */
    DWORD       ire_type;       /* routing type for this entry        */
    DWORD       ire_proto;      /* routing protocol for this entry    */
    DWORD       ire_age;        /* age of this entry                  */
    DWORD       ire_nexthopas;  /* next hop as */
    DWORD       ire_metric1;    /* destination metric, host order     */
    DWORD       ire_metric2;    /* unused                             */
    DWORD       ire_metric3;    /* unused                             */
    DWORD       ire_metric4;    /* unused                             */
    DWORD       ire_metric5;    /* unused                             */
} IPROUTE_ENTRY, *LPIPROUTE_ENTRY;



/*
 *------------------------------------------------------------------
 * Function:    GetIPAddressTable
 *
 * Parameters:
 *      LPIPADDRESS_ENTRY
 *             *lplpAddrTable     pointer to an LPIPADDRESS_ENTRY
 *                                which receives the IP address table
 *      LPDWORD lpdwAddrCount     pointer to a DWORD which receives
 *                                the number of addresses in the table
 *
 * This function allocates and fills in an array of address entry
 * structures corresponding to the logical IP interfaces in
 * the system. It also stores the number of entries in the array
 * in the DWORD pointed to by lpdwAddrCount.
 *
 * Call FreeIPAddressTable to free the memory allocated for the
 * address table.
 *
 * If the function fails, it sets *lpdwAddrCount to zero and
 * *lplpAddrTable to NULL.
 *
 * It returns 0 if successful and non-zero otherwise
 *------------------------------------------------------------------
 */
DWORD
GetIPAddressTable(
    OUT PMIB_IPADDRROW *lplpAddrTable,
    OUT LPDWORD lpdwAddrCount
    );



/*
 *------------------------------------------------------------------
 * Function:    FreeIPAddressTable
 *
 * Parameters:
 *      LPIPADDRESS_ENTRY
 *              lpAddrTable       the address table to be freed.
 *
 * This function frees the memory allocated for an address table.
 * It returns 0 if successful and non-zero otherwise.
 *------------------------------------------------------------------
 */
DWORD
FreeIPAddressTable(
    IN PMIB_IPADDRROW lpAddrTable
    );



/*
 *------------------------------------------------------------------
 * Function:    GetRouteTable
 *
 * Parameters:
 *      LPIPROUTE_ENTRY
 *              *lplpRouteTable   pointer to an LPIPROUTE_ENTRY
 *                                which receives the routing table
 *      DWORD   *lpdwRouteCount   pointer to a DWORD which receives
 *                                the number of routing entries
 *
 * This function allocates and fills in an array of routing table
 * entries from the Tcpip driver. It also sets the number of
 * entries in the array in the DWORD pointed to by lpdwRouteCount.
 *
 * In the IPROUTE_ENTRY structure, the only metric used by
 * the Tcpip stack is IPROUTE_ENTRY.ire_metric1; the other metric
 * fields should be ignored.
 *
 * Call FreeRouteTable to free the memory allocated for the
 * routing table.
 *
 * If the function fails, it sets *lpdwRouteCount to zero and
 * *lplpRouteTable to NULL.
 *
 * It returns 0 if successful and non-zero otherwise
 *------------------------------------------------------------------
 */
DWORD
GetRouteTable(
    OUT LPIPROUTE_ENTRY *lplpRouteTable,
    OUT LPDWORD lpdwRouteCount
    );



/*
 *------------------------------------------------------------------
 * Function:    FreeRouteTable
 *
 * Parameters:
 *      LPIPROUTE_ENTRY
 *              lpRouteTable    the routing table to be freed.
 *
 * This function frees the memory allocated for a routing table.
 * It returns 0 if successful and non-zero otherwise.
 *------------------------------------------------------------------
 */
DWORD
FreeRouteTable(
    IN LPIPROUTE_ENTRY lpRouteTable
    );



/*
 *------------------------------------------------------------------
 * Function:    AddRoute
 *
 * Parameters:
 *      DWORD dwProtocol        protocol of specified route
 *      DWORD dwType            type of specified route
 *      DWORD dwIndex           index of interface on which to add
 *      DWORD dwDestVal         destination IP addr (network order)
 *      DWORD dwMaskVal         destination subnet mask, or zero
 *                              if no subnet (network order)
 *      DWORD dwGateVal         next hop IP addr (network order)
 *      DWORD dwMetric          metric
 *
 * This function adds a new route (or updates an existing route)
 * for the specified protocol, on the specified interface.
 * (See above for values which can be used as protocol numbers,
 * as well as values which can be used as route entry types.)
 * If the route identified by dwIndex.dwDestVal.dwMaskVal.dwGateVal
 * already exists, it is updated with the specified protocol,
 * type, and metric.
 * The TCP stack will return an error on an attempt to add a route
 * whose destination is destination is longer than its mask.
 * In other words, this function fails if (dwDestVal & ~dwMaskVal)
 * is non-zero.
 *
 * Returns 0 if successful, non-zero otherwise.
 *------------------------------------------------------------------
 */
DWORD
AddRoute(
    IN DWORD dwProtocol,
    IN DWORD dwType,
    IN DWORD dwIndex,
    IN DWORD dwDestVal,
    IN DWORD dwMaskVal,
    IN DWORD dwGateVal,
    IN DWORD dwMetric
    );


/*
 *------------------------------------------------------------------
 * Function:    DeleteRoute
 *
 * Parameters:
 *      DWORD   dwIndex         index of interface from which to delete
 *      DWORD   dwDestVal       destination IP addr (network order)
 *      DWORD   dwMaskVal       subnet mask (network order)
 *      DWORD   dwGateVal       next hop IP addr (network order)
 *
 * This function deletes a route to the specified destination.
 *
 * Returns 0 if successful, non-zero otherwise.
 *------------------------------------------------------------------
 */
DWORD
DeleteRoute(
    IN DWORD dwIndex,
    IN DWORD dwDestVal,
    IN DWORD dwMaskVal,
    IN DWORD dwGateVal
    );


/*
 *------------------------------------------------------------------
 * Function:    ReloadIPAddressTable
 *
 * Parameters:
 *      LPIPADDRESS_ENTRY
 *             *lplpAddrTable     pointer to an LPIPADDRESS_ENTRY
 *                                which receives the IP address table
 *      LPDWORD lpdwAddrCount     pointer to a DWORD which receives
 *                                the number of addresses in the table
 *
 * This function first queries the TCP/IP stack to rebuild its
 * IP interface and IP address tables.
 * Then this function allocates and fills in an array of address entry
 * structures corresponding to the logical IP interfaces in
 * the system. It also stores the number of entries in the array
 * in the DWORD pointed to by lpdwAddrCount.
 *
 * Call FreeIPAddressTable to free the memory allocated for the
 * address table.
 *
 * If the function fails, it sets *lpdwAddrCount to zero and
 * *lplpAddrTable to NULL.
 *
 * It returns 0 if successful and non-zero otherwise
 *------------------------------------------------------------------
 */
DWORD
ReloadIPAddressTable(
    OUT PMIB_IPADDRROW *lplpAddrTable,
    OUT LPDWORD lpdwAddrCount
    );


#endif /* _MAP_H_ */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\rip\eventlog.h ===
/********************************************************************/
/**           Copyright(c) 1992 Microsoft Corporation.             **/
/********************************************************************/

//***
//
// Filename:  eventlog.h
//
// Description: 
//
// History:
//   Dec 09,1992  J. Perry Hannah (perryh)  Created original version.
//
//***



VOID Audit(
    IN WORD wEventType,
    IN DWORD dwMessageId,
    IN WORD cNumberOfSubStrings,
    IN LPSTR *plpwsSubStrings
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\rip\pchrip.h ===
//****************************************************************************
//
//		       Microsoft Windows NT RIP
//
//		       Copyright 1995-96
//
//
//  Revision History
//
//
//  12/23/97    V Raman             Created precompiled header
//
//
//  Description: Main RIP Service Functions
//
//****************************************************************************

#ifndef _PCH_RIP_H_
#define _PCH_RIP_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windef.h>
#include <winbase.h>
#include <winsvc.h>
#include <winsock2.h>
#include <ws2tcpip.h>

#include <ctype.h>
#include <errno.h>
#include <io.h>
#include <malloc.h>
#include <process.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>

#include <dhcpcapi.h>
#include <rtutils.h>

#include "ipinfo.h"
#include "llinfo.h"
#include "ntddtcp.h"
#include "tdiinfo.h"

#include "eventlog.h"
#include "errorlog.h"
#include "rip.h"

#include "iprtrmib.h"
#include "iphlpapi.h"

#if 1

#include "map.h"

#else

#include "routetab.h"

#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\rip\rip.c ===
//****************************************************************************
//
//               Microsoft Windows NT RIP
//
//               Copyright 1995-96
//
//
//  Revision History
//
//
//  2/26/95    Gurdeep Singh Pall  Picked up from JBallard's team
//
//  7/09/99    Raghu Gatta - RIP Listener is now RIPv2 compliant
//
//  Description: Main RIP Service Functions
//
//****************************************************************************

#include "pchrip.h"
#pragma hdrstop

//-----------------------------------------------------------------------
// global definitions
//-----------------------------------------------------------------------
RIP_PARAMETERS      g_params;
RIP_GLOBALS         g_ripcfg;

#ifdef ROUTE_FILTERS

PRIP_FILTERS        g_prfAnnounceFilters = NULL;
PRIP_FILTERS        g_prfAcceptFilters = NULL;

CRITICAL_SECTION    g_csAccFilters;
CRITICAL_SECTION    g_csAnnFilters;
#endif


CRITICAL_SECTION    g_csRoutes;
CRITICAL_SECTION    g_csParameters;
CRITICAL_SECTION    g_csAddrtables;

#ifndef CHICAGO
SERVICE_STATUS_HANDLE g_hService;
#endif

HANDLE              g_stopEvent;
HANDLE              g_addressChangeEvent;
HANDLE              g_netEvent;
HANDLE              g_triggerEvent;

HANDLE              g_hUpdateThread;


DWORD               g_dwTraceID = (DWORD)-1;
DWORD               g_dwCurrentState;
DWORD               g_dwCheckPoint;
DWORD               g_dwWaitHint;

#ifndef CHICAGO
HMODULE             g_hmodule;
#endif

#define INDEX_NETEVENT              0
#define INDEX_STOPEVENT             (INDEX_NETEVENT     + 1)
#define INDEX_ADDRESSCHANGEEVENT    (INDEX_STOPEVENT    + 1) 
#define TOTAL_WAITEVENTS            (INDEX_ADDRESSCHANGEEVENT   + 1)

//-----------------------------------------------------------------------
// Function:    NetclassMask
//
// returns the mask used to extract the network address from an
// Internet address
//-----------------------------------------------------------------------
DWORD NetclassMask(DWORD dwAddress) {
     // net masks are returned in network byte order
    if (CLASSA_ADDR(dwAddress)) {
        return CLASSA_MASK;
    }
    else
    if (CLASSB_ADDR(dwAddress)) {
        return CLASSB_MASK;
    }
    else
    if (CLASSC_ADDR(dwAddress)) {
        return CLASSC_MASK;
    }
    else {
        return 0;
    }
}



//-----------------------------------------------------------------------
// Function:    SubnetMask
//
// Given an IP address, return the sub-network mask. This function
// assumes the address table is already locked.
//-----------------------------------------------------------------------
DWORD SubnetMask(DWORD dwAddress) {
    DWORD dwNetmask;
    LPRIP_ADDRESS lpaddr, lpend;

    // subnet mask should be zero for default routes
    if (dwAddress == 0) { return 0; }

    // if its a broadcast address return all ones
    if (dwAddress == INADDR_BROADCAST) { return INADDR_BROADCAST; }

    //dwNetmask = NetclassMask(dwAddress);
    dwNetmask = NETCLASS_MASK(dwAddress);

    // if the network part is zero, return the network mask
    if ((dwAddress & ~dwNetmask) == 0) {
        return dwNetmask;
    }

    lpend = g_ripcfg.lpAddrTable + g_ripcfg.dwAddrCount;
    for (lpaddr = g_ripcfg.lpAddrTable; lpaddr < lpend; lpaddr++) {

        // if the address is found, return the subnet mask
        if ((dwAddress & dwNetmask) ==
            (lpaddr->dwAddress & NetclassMask(lpaddr->dwAddress))) {
            return lpaddr->dwNetmask;
        }
    }

    // address not found, return the network class mask
    return dwNetmask;
}




//-----------------------------------------------------------------------
// Function:    IsBroadcastAddress
//
// Returns TRUE if the given IP address is an all-ones bcast
// or a class A, B, or C net broadcast. IP address is assumed to be
// in network order (which is the reverse of Intel byte ordering.)
//-----------------------------------------------------------------------
BOOL IsBroadcastAddress(DWORD dwAddress) {
    if ((dwAddress == INADDR_BROADCAST) ||
        (CLASSA_ADDR(dwAddress) && ((dwAddress & ~CLASSA_MASK) ==
                                    ~CLASSA_MASK)) ||
        (CLASSB_ADDR(dwAddress) && ((dwAddress & ~CLASSB_MASK) ==
                                    ~CLASSB_MASK)) ||
        (CLASSC_ADDR(dwAddress) && ((dwAddress & ~CLASSC_MASK) ==
                                    ~CLASSC_MASK))) {
        return TRUE;
    }

    return FALSE;
}



//-----------------------------------------------------------------------
// Function:    IsLocalAddr
//
// Returns TRUE if the given IP address belongs to one of the interfaces
// on the local host. Assumes that the IP address is in network order
// and that the address table is already locked.
//-----------------------------------------------------------------------
BOOL IsLocalAddr(DWORD dwAddress) {
    LPRIP_ADDRESS lpaddr, lpend;

    lpend = g_ripcfg.lpAddrTable + g_ripcfg.dwAddrCount;
    for (lpaddr = g_ripcfg.lpAddrTable; lpaddr < lpend; lpaddr++) {
        if (dwAddress == lpaddr->dwAddress) {
            return TRUE;
        }
    }

    return FALSE;
}



BOOL IsDisabledLocalAddress(DWORD dwAddress) {
    LPRIP_ADDRESS lpaddr, lpend;

    lpend = g_ripcfg.lpAddrTable + g_ripcfg.dwAddrCount;
    for (lpaddr = g_ripcfg.lpAddrTable; lpaddr < lpend; lpaddr++) {
        if ((lpaddr->dwFlag & ADDRFLAG_DISABLED) != 0 &&
            (dwAddress == lpaddr->dwAddress)) {
            return TRUE;
        }
    }

    return FALSE;
}



//-----------------------------------------------------------------------
// Function:    IsHostAddress
//
// Returns TRUE if the given IP address has a non-zero host part.
// Assumes that the IP address is in network order and that
// the address table is already locked.
//-----------------------------------------------------------------------
BOOL IsHostAddress(DWORD dwAddress) {
    DWORD dwNetmask;

    // find most specific netmask we have for the address
    dwNetmask = SubnetMask(dwAddress);

    // if host part is non-zero, assume it is a host address
    if ((dwAddress & (~dwNetmask)) != 0) {
        return TRUE;
    }
    return FALSE;
}



//-----------------------------------------------------------------------
// Function:    ProcessRIPEntry
//
// This function examines a single entry in a RIP packet and
// adds it to the hash table if necessary.
//-----------------------------------------------------------------------
DWORD ProcessRIPEntry(LPRIP_ADDRESS lpaddr, IN_ADDR srcaddr,
                      LPRIP_ENTRY rip_entry, BYTE chVersion) {
    IN_ADDR addr;
    BOOL bIsHostAddr;
    CHAR szAddress[32] = {0};
    CHAR szSrcaddr[32] = {0};
    CHAR szMetric[12];
    LPSTR ppszArgs[3] = { szAddress, szSrcaddr, szMetric };
    LPHASH_TABLE_ENTRY rt_entry;
    DWORD rt_metric, rip_metric;
    DWORD dwHost, dwDefault, dwRouteTimeout;
    DWORD dwOverwriteStatic, dwGarbageTimeout;
    DWORD dwInd = 0;
    DWORD dwNetwork, dwNetmask, dwNetclassmask;
    DWORD dwLocalNet, dwLocalMask, dwNexthop;
    CHAR *pszTemp;

    addr.s_addr = rip_entry->dwAddress;
    pszTemp = inet_ntoa(addr);

    if (pszTemp != NULL) {
        strcpy(szAddress, pszTemp);
    }

    pszTemp = inet_ntoa(srcaddr);

    if (pszTemp != NULL) {
        strcpy(szSrcaddr, pszTemp);
    }

    // ignore metrics greater than infinity
    if (ntohl(rip_entry->dwMetric) > METRIC_INFINITE) {
        dbgprintf("metric > %d, ignoring route to %s with next hop of %s",
                  METRIC_INFINITE, szAddress, szSrcaddr);

        InterlockedIncrement(&lpaddr->lpstats->dwBadRouteResponseEntries);
        return 0;
    }

    // ignore class D and E addresses
    if (CLASSD_ADDR(rip_entry->dwAddress) ||
        CLASSE_ADDR(rip_entry->dwAddress)) {
        dbgprintf("class D or E addresses are invalid, "
                  "ignoring route to %s with next hop of %s",
                  szAddress, szSrcaddr);
        RipLogWarning(RIPLOG_CLASS_INVALID, 2, ppszArgs, 0);

        InterlockedIncrement(&lpaddr->lpstats->dwBadRouteResponseEntries);
        return 0;
    }

    // ignore loopback routes
    if (IP_LOOPBACK_ADDR(rip_entry->dwAddress)) {
        dbgprintf("loopback addresses are invalid, "
                  "ignoring route to %s with next hop of %s",
                  szAddress, szSrcaddr);
        RipLogWarning(RIPLOG_LOOPBACK_INVALID, 2, ppszArgs, 0);

        InterlockedIncrement(&lpaddr->lpstats->dwBadRouteResponseEntries);
        return 0;
    }

    dwNetwork = rip_entry->dwAddress;

    //
    // calculate mask for all RIP versions
    //

    if (rip_entry->dwSubnetmask == 0) {

        // get the best subnetmask possible
        dwNetmask = SubnetMask(dwNetwork);

        // determine NetclassMask
        if (dwNetwork == 0) {
            dwNetclassmask = 0;
        }
        else if (dwNetwork == INADDR_BROADCAST) {
            dwNetclassmask = INADDR_BROADCAST;
        }
        else {
            dwNetclassmask = NETCLASS_MASK(rip_entry->dwAddress);
        }

    }
    else {

        dwNetmask = rip_entry->dwSubnetmask;

        //
        // double-check the netclass mask, to accomodate supernets
        //
        dwNetclassmask = NETCLASS_MASK(dwNetwork);

        if (dwNetclassmask > dwNetmask) {
            dwNetclassmask = dwNetmask;
        }
    }

    //
    // make sure route is not to a broadcast address;
    // double-check to make sure this isn't a host route,
    // which will look like a broadcast address since ~dwNetmask
    // will be 0 and thus (dwNetwork & ~dwNetmask) == ~dwNetmask
    //

    if ((dwNetwork & ~dwNetclassmask) == ~dwNetclassmask ||
        (~dwNetmask && (dwNetwork & ~dwNetmask) == ~dwNetmask)) {
        dbgprintf("broadcast addresses are invalid, "
                  "ignoring route to %s with next hop of %s",
                  szAddress, szSrcaddr);
        RipLogWarning(RIPLOG_BROADCAST_INVALID, 2, ppszArgs, 0);

        InterlockedIncrement(&lpaddr->lpstats->dwBadRouteResponseEntries);
        return 0;
    }

    //
    // make sure that the nexthop is on a local net
    //
    //
    // In case of P2P connections, the subnet mask of the interface
    // is all ones. So do an additional check to make sure that we 
    // don't end up rejecting routes received over a P2P connection.
    //

    dwNexthop   = srcaddr.s_addr;
    dwLocalMask = lpaddr->dwNetmask;
    dwLocalNet  = lpaddr->dwAddress & dwLocalMask;
    
    if ( ((dwNexthop & dwLocalMask) != dwLocalNet) && 
            (dwLocalMask != 0xFFFFFFFF) ) {
            
        dbgprintf("Dropped route %s with next hop %s because "
                  "NextHop is not on the same subnet as the "
                  "interface on which the route was received",
                  szAddress,
                  szSrcaddr);
        return 0;
    }        
    
#ifdef ROUTE_FILTERS

    //
    // run the route thru' the accept filters
    //

    if ( g_prfAcceptFilters != NULL )
    {
        for ( dwInd = 0; dwInd < g_prfAcceptFilters-> dwCount; dwInd++ )
        {
            if ( g_prfAcceptFilters-> pdwFilter[ dwInd ] ==
                 rip_entry-> dwAddress )
            {
                dbgprintf("Dropped route %s with next hop %s because"
                          "of accept filter",
                          szAddress, szSrcaddr);
                return 0;
            }
        }
    }

#endif


    RIP_LOCK_PARAMS();
    dwHost = g_params.dwAcceptHost;
    dwDefault = g_params.dwAcceptDefault;
    dwRouteTimeout = g_params.dwRouteTimeout;
    dwGarbageTimeout = g_params.dwGarbageTimeout;
    dwOverwriteStatic = g_params.dwOverwriteStaticRoutes;
    RIP_UNLOCK_PARAMS();

    // ignore host routes unless configured otherwise
    if (bIsHostAddr = ((dwNetwork & ~dwNetmask) != 0)) {
        if (dwHost == 0) {
            dbgprintf("IPRIP is configured to discard host routes, "
                      "ignoring route to %s with next hop of %s",
                      szAddress, szSrcaddr);
            RipLogInformation(RIPLOG_HOST_INVALID, 2, ppszArgs, 0);

            InterlockedIncrement(&lpaddr->lpstats->dwBadRouteResponseEntries);
            return 0;
        }
    }

    // ignore default routes unless configured otherwise
    if (rip_entry->dwAddress == 0) {
        if (dwDefault == 0) {
            dbgprintf("IPRIP is configured to discard default routes, "
                      "ignoring route to %s with next hop of %s",
                      szAddress, szSrcaddr);
            RipLogInformation(RIPLOG_DEFAULT_INVALID, 2, ppszArgs, 0);

            InterlockedIncrement(&lpaddr->lpstats->dwBadRouteResponseEntries);
            return 0;
        }
    }

    rip_metric = ntohl(rip_entry->dwMetric);

    // do not add a new entry if its metric would be infinite
    if ((rip_metric + 1) >= METRIC_INFINITE &&
        !RouteTableEntryExists(lpaddr->dwIndex, rip_entry->dwAddress)) {
        dbgprintf("metric == %d, ignoring new route to %s with next hop of %s",
                  METRIC_INFINITE, szAddress, szSrcaddr);

        return 0;
    }


    // find the entry, or create one if necessary
    rt_entry = GetRouteTableEntry(lpaddr->dwIndex, rip_entry->dwAddress,
                                  dwNetmask);

    if (rt_entry == NULL) {
        dbgprintf("could not allocate memory for new entry");
        RipLogError(RIPLOG_RT_ALLOC_FAILED, 0, NULL, ERROR_NOT_ENOUGH_MEMORY);
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // if this was a static route and RIP is not allowed
    // to overwrite static routes, return; exception is default routes,
    // which we overwrite if we are configured to accept default routes,
    // even if there is an existing static default route
    //
    if (rt_entry->dwFlag != NEW_ENTRY &&
        (rt_entry->dwProtocol == IRE_PROTO_LOCAL ||
         rt_entry->dwProtocol == IRE_PROTO_NETMGMT) &&
        rt_entry->dwDestaddr != 0) {

        if (dwOverwriteStatic == 0) {
            InterlockedIncrement(&lpaddr->lpstats->dwBadRouteResponseEntries);
            return 0;
        }
    }


    rt_metric = rt_entry->dwMetric;
    rip_metric = min(METRIC_INFINITE, rip_metric + 1);
    _ltoa(rip_metric, szMetric, 10);

    if (rt_entry->dwFlag == NEW_ENTRY) {

        dbgprintf("New route entry, destination == %s, "
                  "next hop == %s, metric == %s",
                  szAddress, szSrcaddr,  szMetric);
        RipLogInformation(RIPLOG_NEW_LEARNT_ROUTE, 3, ppszArgs, 0);

        rt_entry->dwIndex = lpaddr->dwIndex;
        rt_entry->dwFlag = (TIMEOUT_TIMER | ROUTE_CHANGE);
        rt_entry->lTimeout = (LONG)dwRouteTimeout;
        rt_entry->dwDestaddr = rip_entry->dwAddress;
        rt_entry->dwNexthop = srcaddr.s_addr;
        rt_entry->dwProtocol = IRE_PROTO_RIP;
        rt_entry->dwMetric = rip_metric;
        if (bIsHostAddr) {
            rt_entry->dwFlag |= ROUTE_HOST;
            rt_entry->dwNetmask = HOSTADDR_MASK;
        }
        else {
            rt_entry->dwNetmask = dwNetmask;
        }

    }
    else
    if (rt_entry->dwNexthop == srcaddr.s_addr) {
        // this is from the next hop gateway for the existing entry

        // this may have been a local route before; now it is a RIP route
        rt_entry->dwProtocol = IRE_PROTO_RIP;
        rt_entry->dwIndex = lpaddr->dwIndex;

        // reset its timer if it is not pending garbage-collection
        if (rt_metric != METRIC_INFINITE &&
            (rt_entry->dwFlag & GARBAGE_TIMER) == 0) {
            rt_entry->lTimeout = (LONG)dwRouteTimeout;
        }

        // if the metric changed, or the metric has gone to METRIC_INFINITE,
        // update the route
        if (rt_metric != rip_metric ||
            (rt_metric == METRIC_INFINITE &&
             (rt_entry->dwFlag & GARBAGE_TIMER) == 0)) {

            dbgprintf("Metric change, destination == %s, "
                      "next hop == %s, metric == %s",
                      szAddress, szSrcaddr, szMetric);
            RipLogInformation(RIPLOG_METRIC_CHANGE, 3, ppszArgs, 0);

            // is the route going away?
            if (rip_metric == METRIC_INFINITE &&
                (rt_entry->dwFlag & GARBAGE_TIMER) == 0) {
                dbgprintf("METRIC IS UNREACHABLE");

                // we do not know about it
                rt_entry->dwFlag &= ~TIMEOUT_TIMER;
                rt_entry->dwFlag |= (GARBAGE_TIMER | ROUTE_CHANGE);
                if (bIsHostAddr) {
                    rt_entry->dwFlag |= ROUTE_HOST;
                }
                rt_entry->lTimeout = (LONG)dwGarbageTimeout;
                rt_entry->dwMetric = METRIC_INFINITE;
            }
            else {
                // route isn't going away, metric just changed
                rt_entry->dwFlag &= ~GARBAGE_TIMER;
                rt_entry->dwFlag |= (TIMEOUT_TIMER | ROUTE_CHANGE);
                rt_entry->lTimeout = (LONG)dwRouteTimeout;
                rt_entry->dwDestaddr = rip_entry->dwAddress;
                if (bIsHostAddr) {
                    rt_entry->dwFlag |= ROUTE_HOST;
                    rt_entry->dwNetmask = HOSTADDR_MASK;
                }
                else {
                    rt_entry->dwNetmask = dwNetmask;
                }
                rt_entry->dwNexthop = srcaddr.s_addr;
                rt_entry->dwMetric = rip_metric;
            }

        }

    }
    else
    if (rip_metric < rt_metric) {
        // not from original next hop for this route,
        // but this is a better route
        dbgprintf("New preferred route, destination == %s, "
                  "next hop == %s, metric == %s",
                  szAddress, szSrcaddr, szMetric);
        RipLogInformation(RIPLOG_ROUTE_REPLACED, 3, ppszArgs, 0);

        // if this route is pending garbage-collection,
        // remove the old entry before accepting a new next hop
        if (rt_entry->dwProtocol == IRE_PROTO_RIP &&
            (rt_entry->dwFlag & GARBAGE_TIMER) != 0) {
            UpdateSystemRouteTable(rt_entry, FALSE);
        }

        // this may have been a local route before; now it is a RIP route
        rt_entry->dwProtocol = IRE_PROTO_RIP;

        rt_entry->dwFlag &= ~GARBAGE_TIMER;
        rt_entry->dwFlag |= (TIMEOUT_TIMER | ROUTE_CHANGE);
        rt_entry->dwIndex = lpaddr->dwIndex;
        rt_entry->lTimeout = (LONG)dwRouteTimeout;
        rt_entry->dwDestaddr = rip_entry->dwAddress;
        if (bIsHostAddr) {
            rt_entry->dwFlag |= ROUTE_HOST;
            rt_entry->dwNetmask = HOSTADDR_MASK;
        }
        else {
            rt_entry->dwNetmask = dwNetmask;
        }
        rt_entry->dwNexthop = srcaddr.s_addr;
        rt_entry->dwMetric = rip_metric;
    }

    // we always update the route in the system table
    rt_entry->dwFlag |= ROUTE_UPDATE;
    InterlockedExchange(&g_ripcfg.dwRouteChanged, 1);

#if 0
        DbgPrintf(
            "RIP entry : Protocol %x, Index %x, dest addr %x, dest mask %x\n",
            rt_entry->dwProtocol, rt_entry->dwIndex, rt_entry->dwDestaddr, rt_entry->dwNetmask
            );

        DbgPrintf(
            "Next Hop %x, Metric %x\n\n", rt_entry->dwNexthop, rt_entry->dwMetric
            );
#endif

    return 0;
}




//-----------------------------------------------------------------------
// Function:    ProcessRIPQuery
//
// fills in a RIP packet entry with information from our routing table,
// if we have a matching entry in our table.
//-----------------------------------------------------------------------
DWORD ProcessRIPQuery(LPRIP_ADDRESS lpaddr, LPRIP_ENTRY rip_entry) {
    LPHASH_TABLE_ENTRY rt_entry;


#ifdef ROUTE_FILTERS

    DWORD   dwInd = 0;

    //
    // run the route thru' the announce filters
    //

    if ( g_prfAnnounceFilters != NULL )
    {
        for ( dwInd = 0; dwInd < g_prfAnnounceFilters-> dwCount; dwInd++ )
        {
            if ( g_prfAnnounceFilters-> pdwFilter[ dwInd ] ==
                 rip_entry-> dwAddress )
            {
                dbgprintf(
                    "setting metric for route %s to infinite in RIP query",
                    inet_ntoa(
                        *( (struct in_addr*) &(rip_entry-> dwAddress ) )
                        )
                    );

                rip_entry-> dwMetric = htonl(METRIC_INFINITE);
                return 0;
            }
        }
    }

#endif


    // RFC 1058 page 25
    // If routing table entry exists then pick up the metric.
    // Otherwise return a metric of METRIC_INFINITE.

    if (RouteTableEntryExists(lpaddr->dwIndex, rip_entry->dwAddress) &&
        (rt_entry = GetRouteTableEntry(lpaddr->dwIndex,
                                       rip_entry->dwAddress,
                                       rip_entry->dwSubnetmask)) != NULL) {
        rip_entry->dwMetric = htonl(rt_entry->dwMetric);
    }
    else {
        rip_entry->dwMetric = htonl(METRIC_INFINITE);
    }

    return 0;
}



//-----------------------------------------------------------------------
// Function:    ServiceMain
//
// This is the entry point of the service, and the function which
// handles all network input processing.
//-----------------------------------------------------------------------
VOID FAR PASCAL ServiceMain(IN DWORD dwNumServicesArgs,
                                    IN LPSTR *lpServiceArgVectors) {

    WSADATA wsaData;

    HANDLE hWaitEvents[TOTAL_WAITEVENTS];

    DWORD dwErr, dwOption, dwThread;
    SERVICE_STATUS status = {SERVICE_WIN32, SERVICE_STOPPED,
                             SERVICE_ACCEPT_STOP, NO_ERROR, 0, 0, 0};

#ifndef CHICAGO
    CHAR achModule[MAX_PATH];
#else
    DWORD dwCurrTime, dwLastReload, dwReloadIntr;
    
    dwLastReload = dwCurrTime = GetTickCount();
    dwReloadIntr = IP_ADDRESS_RELOAD_INTR * 1000;
#endif


    // register with tracing DLL so errors can be reported below.
    g_dwTraceID = TraceRegister(RIP_SERVICE);

    if (g_dwTraceID == INVALID_TRACEID)
    {
        g_params.dwLoggingLevel = LOGLEVEL_ERROR;
        RipLogError(RIPLOG_SERVICE_INIT_FAILED, 0, NULL, GetLastError());
        return;
    }
    
#ifndef CHICAGO
    // register the service and get a service status handle
    g_hService = RegisterServiceCtrlHandler(RIP_SERVICE,
                                            serviceHandlerFunction);

    if (g_hService == 0) {
        dbgprintf("IPRIP could not register as a service, error code %d",
                  GetLastError());
        RipLogError(RIPLOG_REGISTER_FAILED, 0, NULL, GetLastError());
        return;
    }
#endif


    dbgprintf("IPRIP is starting up...");


    // Prepare a status structure to pass to the service controller
    InterlockedExchange(&g_dwWaitHint, 60000);
    InterlockedExchange(&g_dwCheckPoint, 100);
    InterlockedExchange(&g_dwCurrentState, SERVICE_START_PENDING);

    status.dwControlsAccepted = 0;
    status.dwWaitHint = g_dwWaitHint;
    status.dwWin32ExitCode = NO_ERROR;
    status.dwCheckPoint = g_dwCheckPoint;
    status.dwServiceSpecificExitCode = 0;
    status.dwServiceType = SERVICE_WIN32;
    status.dwCurrentState = g_dwCurrentState;


#ifndef CHICAGO
    if (!SetServiceStatus(g_hService, &status)) {
        dbgprintf("IPRIP could not report its status, error code %d",
                  GetLastError());
        RipLogError(RIPLOG_SETSTATUS_FAILED, 0, NULL, GetLastError());
        return;
    }
#endif

    RIP_CREATE_PARAMS_LOCK();
    RIP_CREATE_ADDRTABLE_LOCK();
    RIP_CREATE_ROUTETABLE_LOCK();

#ifdef ROUTE_FILTERS

    RIP_CREATE_ANNOUNCE_FILTERS_LOCK();
    RIP_CREATE_ACCEPT_FILTERS_LOCK();

#endif

    // first of all, start Winsock
    if (WSAStartup(MAKEWORD(2, 0), &wsaData)) {
        dbgprintf("error %d initializing Windows Sockets.", WSAGetLastError());
        RipLogError(RIPLOG_WSOCKINIT_FAILED, 0, NULL, WSAGetLastError());

        RIPServiceStop(); return;
    }
    
    // confirm that Winsock dll supports 2.0
    if ( LOBYTE(wsaData.wVersion) != 2 ||
            HIBYTE(wsaData.wVersion) != 0 ) {
        // The dll doesn't support Winsock 2.0. So exit.
        // We need 2.0 for WSAEventSelect and WSAEnumNetworkEvents
        dbgprintf("could not find winsock dll that supports version 2.0");
        RipLogError(RIPLOG_WSOCKINIT_FAILED, 0, NULL, WSAVERNOTSUPPORTED);

        RIPServiceStop(); return;
    }

    // load operating parameters from the registry
    dwErr = LoadParameters();
    if (dwErr != 0) {

        dbgprintf("could not load registry parameters, error code %d", dwErr);
        RipLogError(RIPLOG_REGINIT_FAILED, 0, NULL, dwErr);

        RIPServiceStop(); return;
    }

    // load the IP local routes table
    dwErr = InitializeRouteTable();
    if (dwErr != 0) {
        dbgprintf("could not initialize routing table, error code %d", dwErr);
        RipLogError(RIPLOG_RTAB_INIT_FAILED, 0, NULL, dwErr);

        RIPServiceStop(); return;
    }


    dwErr = InitializeStatsTable();
    if (dwErr != 0) {
        dbgprintf("could not initialize statistics, error code %d", dwErr);
        RipLogError(RIPLOG_STAT_INIT_FAILED, 0, NULL, dwErr);

        RIPServiceStop(); return;
    }


    // create network event. This event is passed to WSAEventSelect.
    // WSAEventSelect is posted on each socket in the LoadAddressSockets
    // function. We need to create this event before calling 
    // InitializeAddressTable
    
    g_netEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if ( g_netEvent == NULL ) {
        dwErr = GetLastError();
        dbgprintf("could not create Network event, error code %d", dwErr);
        RipLogError(RIPLOG_CREATEEVENT_FAILED, 0, NULL, dwErr);

        RIPServiceStop(); return;
    }
    

    // no other threads running, so no need for synchronization
    dwErr = InitializeAddressTable(TRUE);
    if (dwErr != 0) {
        dbgprintf("could not initialize sockets, error code %d", dwErr);
        RipLogError(RIPLOG_IFINIT_FAILED, 0, NULL, dwErr);

        RIPServiceStop(); return;
    }


    // Create service stop event
    g_stopEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
    if ( g_stopEvent == NULL ) {
        dwErr = GetLastError();
        dbgprintf("could not create Service Stop event, error code %d", dwErr);
        RipLogError(RIPLOG_CREATEEVENT_FAILED, 0, NULL, dwErr);

        RIPServiceStop(); return;
    }

    // Create triggered update request event
    g_triggerEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
    if ( g_triggerEvent == NULL ) {
        dwErr = GetLastError();
        dbgprintf("could not create Trigger event, error code %d", dwErr);
        RipLogError(RIPLOG_CREATEEVENT_FAILED, 0, NULL, dwErr);

        RIPServiceStop(); return;
    }

    // Open the event for DHCP address change notifications
    g_addressChangeEvent = DhcpOpenGlobalEvent();

    // if we can't open this handle then we simple quit this thread
    if (g_addressChangeEvent == NULL) {
        dbgprintf("could not create address change notification event, "
                  "error code %d", GetLastError());
        RipLogError(RIPLOG_CREATEEVENT_FAILED, 0, NULL, GetLastError());

        RIPServiceStop();
        return;
    }

#ifndef CHICAGO
    // In order to avoid having the DLL unloaded from underneath our threads,
    // we increment the DLL refcount as each thread is created.
    //
    // retrieve the module-name for this DLL.

    GetModuleFileName(g_hmodule, achModule, MAX_PATH);
#endif


    // Create the thread which handles timed operations
    g_hUpdateThread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)UpdateThread,
                           NULL, 0, &dwThread);
    if (g_hUpdateThread == NULL) {
        dbgprintf("could not create route update thread, error code %lu",
                  GetLastError());
        RipLogError(RIPLOG_CREATETHREAD_FAILED, 0, NULL, GetLastError());

        RIPServiceStop(); 
        return;
    }


#ifndef CHICAGO

    // Increment the DLL refcount for the above thread
    LoadLibrary(achModule);
#endif

    // broadcast the initial requests for full routing information
    // from all the neighboring routers
    BroadcastRouteTableRequests();

    // Everything initialized fine:
    // Prepare a status structure to pass to the service controller
    InterlockedExchange(&g_dwWaitHint, 0);
    InterlockedExchange(&g_dwCheckPoint, 0);
    InterlockedExchange(&g_dwCurrentState, SERVICE_RUNNING);

    status.dwWaitHint = g_dwWaitHint;
    status.dwCheckPoint = g_dwCheckPoint;
    status.dwCurrentState = g_dwCurrentState;
    status.dwControlsAccepted = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_SHUTDOWN;

#ifndef CHICAGO
    SetServiceStatus(g_hService, &status);
#endif

    RipLogInformation(RIPLOG_SERVICE_STARTED, 0, NULL, 0);


    hWaitEvents[INDEX_NETEVENT]           = 
            g_netEvent;                 // Manual Reset: FALSE
    hWaitEvents[INDEX_STOPEVENT]          = 
            g_stopEvent;                // Manual Reset: TRUE
    hWaitEvents[INDEX_ADDRESSCHANGEEVENT] = 
            g_addressChangeEvent;       // Manual Reset: TRUE
                                        // Event created by
                                        // DhcpOpenGlobalEvent


    // enter the main input processing loop
    while (TRUE) {
        INT length, size;
        IN_ADDR addr;
        DWORD dwSilentRIP;
        SOCKADDR_IN srcaddr;
        BOOL bLocalAddr;
        BOOL bPacketValid;
        BYTE buffer[RIP_MESSAGE_SIZE];
        LPRIP_HEADER lpheader;
        LPRIP_ADDRESS lpaddr, lpend;
        DWORD dwResult, dwUpdateFreq, dwTrigger;
        DWORD dwWaitEndCode;
        WSANETWORKEVENTS wsaNetEvents;

        
        // this is where we wait for something to come down the wire

#ifndef CHICAGO

        dwWaitEndCode = 
                WaitForMultipleObjects(
                    TOTAL_WAITEVENTS,
                    hWaitEvents,
                    FALSE,
                    INFINITE);
            
#else

        //
        // hack for Win95 since there is no mechanism to wait
        // for DHCP address change notification.
        // set an interval after which the IP addresses will
        // be reloaded by the IPRIP.
        //

        dwCurrTime = GetTickCount();

        if ( (dwCurrTime > (dwLastReload + dwReloadIntr) ) ||
             (dwCurrTime < dwLastReload) )
        {
            dwWaitEndCode = WAIT_TIMEOUT;
        }
        else
        {

            dwWaitEndCode = 
                    WaitForMultipleObjects(
                        TOTAL_WAITEVENTS,
                        hWaitEvents,
                        FALSE,
                        dwReloadIntr);    
        }
        
#endif

        if (dwWaitEndCode != WAIT_OBJECT_0) {
            
            // check if g_stopEvent event was signalled
            if ((dwWaitEndCode - WAIT_OBJECT_0) == INDEX_STOPEVENT) 
            {

                dbgprintf("service received stop request, shutting down");
                WaitForSingleObject(g_hUpdateThread, INFINITE);

                RIPServiceStop(); 
                return;
            }
            else
            if (
                ((dwWaitEndCode - WAIT_OBJECT_0) == INDEX_ADDRESSCHANGEEVENT)
#ifdef CHICAGO
                || ( dwWaitEndCode == WAIT_TIMEOUT )
#endif
               )
            {

                dbgprintf("service detected IP address change, reconfiguring");
                RipLogInformation(RIPLOG_ADDRESS_CHANGE, 0, NULL, 0);

                RIP_LOCK_ADDRTABLE();
                dwErr = InitializeAddressTable(FALSE);
                RIP_UNLOCK_ADDRTABLE();

                if (dwErr != 0 ||
                    (dwErr = BroadcastRouteTableRequests()) != 0) {

                    // re-init failed, log error and quit
                    RipLogError(RIPLOG_REINIT_FAILED, 0, NULL, dwErr);

                    SetEvent(g_stopEvent);
                    WaitForSingleObject(g_hUpdateThread, INFINITE);
                    RIPServiceStop(); 
                    return;
                }

#ifdef CHICAGO
                dwLastReload = GetTickCount();
#endif
                continue;
            }
            
            else
            {
                dbgprintf("ServiceMain: WaitForMultipleObjects failed. Error: %d",
                                 GetLastError());

                continue;
            }
        }

        // neither stop request nor reconfig request, so some data
        // must have arrived. lock address table and go through
        // the sockets to see which ones are ready for reading

        RIP_LOCK_ADDRTABLE();

        lpend = g_ripcfg.lpAddrTable + g_ripcfg.dwAddrCount;
        for (lpaddr = g_ripcfg.lpAddrTable; lpaddr < lpend; lpaddr++) {

            if (lpaddr->sock != INVALID_SOCKET){

                dwErr = WSAEnumNetworkEvents(
                                lpaddr->sock,
                                NULL,
                                &wsaNetEvents);
                if (dwErr == SOCKET_ERROR) {
                    dbgprintf("error doing WSAEnumNetworkEvents on address %s, "
                                "error code %d", inet_ntoa(addr),
                                WSAGetLastError());
                    RipLogInformation(RIPLOG_WSAENUMNETWORKEVENTS_FAILED, 0,
                                        NULL, WSAGetLastError());

                    continue;
                }
                
                // see if there is something to read on this socket
                if ( !(wsaNetEvents.lNetworkEvents & FD_READ) ) {
                    continue;
                }
                
                // read the incoming message
                size = sizeof(srcaddr);
                length = recvfrom(lpaddr->sock, buffer, RIP_MESSAGE_SIZE, 0,
                                  (SOCKADDR *)&srcaddr, &size);

                if (length == 0 || length == SOCKET_ERROR) {
                    dwErr = WSAGetLastError();

                    // Even though FD_READ is set, recvfrom can still fail with
                    // WSAEWOULDBLOCK. 
                    // So, if recvfrom failed with WSAEWOULDBLOCK we should not
                    // log it as an error. 
                    if ( length == SOCKET_ERROR && dwErr == WSAEWOULDBLOCK) {
                        continue;
                    }
                    
                    addr.s_addr = lpaddr->dwAddress;
                    dbgprintf("error receiving data on local address %s, "
                              "error code %d", inet_ntoa(addr),
                              WSAGetLastError());

                    InterlockedIncrement(&lpaddr->lpstats->dwReceiveFailures);

                    if (WSAGetLastError() == WSAEMSGSIZE) {
                        RipLogInformation(RIPLOG_RECVSIZE_TOO_GREAT, 0, NULL, 0);
                    }
                    else {
                        RipLogInformation(RIPLOG_RECVFROM_FAILED, 0,
                                       NULL, WSAGetLastError());
                    }

                    continue;
                }

#if 0
                DbgPrintf( "\n\n\nData received from %s on socket %d\n", inet_ntoa( srcaddr.sin_addr ), lpaddr-> sock );
                DbgPrintf( "socket bound to %s\n\n", inet_ntoa( *( (struct in_addr *) &(lpaddr-> dwAddress) ) ) );
#endif
                // data received, so place a template over it
                lpheader = (LPRIP_HEADER)buffer;

                // validate the packet
                if (lpheader->chVersion == 0) {
                    dbgprintf("version in RIP header is 0, "
                              "discarding packet");

                    InterlockedIncrement(&lpaddr->lpstats->dwBadPacketsReceived);
                    RipLogInformation(RIPLOG_VERSION_ZERO, 0, NULL, 0);
                    continue;
                }
                else
                if (lpheader->chVersion == 1 && lpheader->wReserved != 0) {
                    dbgprintf("reserved field in RIPv1 header is non-zero, "
                              "discarding packet");

                    InterlockedIncrement(&lpaddr->lpstats->dwBadPacketsReceived);
                    RipLogInformation(RIPLOG_FORMAT_ERROR, 0, NULL, 0);
                    continue;
                }
                else
                if (lpheader->chVersion == 2 && lpheader->wReserved != 0) {
                    dbgprintf("reserved field in RIPv2 header is non-zero, "
                              "discarding packet");

                    InterlockedIncrement(&lpaddr->lpstats->dwBadPacketsReceived);
                    RipLogInformation(RIPLOG_FORMAT_ERROR, 0, NULL, 0);
                    continue;
                }

                if (lpheader->chCommand == RIP_REQUEST) {

                    ProcessRIPRequest(lpaddr, &srcaddr, buffer, length);
                }
                else
                if (lpheader->chCommand == RIP_RESPONSE) {

                    ProcessRIPResponse(lpaddr, &srcaddr, buffer, length);

                    // tell the update thread to process the changes just made
                    // to the table;
                    // this could include adding routes to the IP table
                    // and/or sending out triggered updates
                    if (g_ripcfg.dwRouteChanged != 0) {
                        SetEvent(g_triggerEvent);
                    }

                }
            }
        }


        RIP_UNLOCK_ADDRTABLE();

    }
}




//-----------------------------------------------------------------------
// Function:    ProcessRIPRequest
//
// Handles processing of requests. Validates packets, and sends
// responses.
//-----------------------------------------------------------------------
VOID ProcessRIPRequest(LPRIP_ADDRESS lpaddr, LPSOCKADDR_IN lpsrcaddr,
                       BYTE buffer[], int length) {
    INT iErr;
    IN_ADDR addr;
    BYTE chVersion;
    BOOL bValidated;
    DWORD dwSilentRIP;
    CHAR szAddress[32];
    LPRIP_HEADER lpheader;
    LPRIP_ENTRY lpentry, lpbufend;
    CHAR *pszTemp;

    RIP_LOCK_PARAMS();
    dwSilentRIP = g_params.dwSilentRIP;
    RIP_UNLOCK_PARAMS();

    // if this is a regular request and RIP is silent, do nothing
    if (dwSilentRIP != 0) { // && lpsrcaddr->sin_port == htons(RIP_PORT)) {
        return;
    }

    // ignore requests from our own interfaces
    if (IsLocalAddr(lpsrcaddr->sin_addr.s_addr)) {
        return;
    }

    InterlockedIncrement(&lpaddr->lpstats->dwRequestsReceived);

    // place a template over the first entry
    lpentry = (LPRIP_ENTRY)(buffer + sizeof(RIP_HEADER));
    lpbufend = (LPRIP_ENTRY)(buffer + length);
    lpheader = (LPRIP_HEADER)buffer;
    chVersion = lpheader->chVersion;

    // print a message
    addr.s_addr = lpaddr->dwAddress;
    pszTemp = inet_ntoa(addr);

    if (pszTemp != NULL) {
        strcpy(szAddress, pszTemp);
    }

    dbgprintf("received RIP v%d request from %s on address %s",
              chVersion, inet_ntoa(lpsrcaddr->sin_addr), szAddress);

    // if this is a request for the entire routing table, send it
    if (length == (sizeof(RIP_HEADER) + sizeof(RIP_ENTRY)) &&
        lpentry->wAddrFamily == 0 &&
        lpentry->dwMetric == htonl(METRIC_INFINITE)) {

        // transmit the entire routing table, subject
        // to split-horizon and poisoned reverse processing
        TransmitRouteTableContents(lpaddr, lpsrcaddr, FALSE);
        return;
    }


#ifdef ROUTE_FILTERS

    RIP_LOCK_ANNOUNCE_FILTERS();

#endif

    // this is a request for specific entries,
    // validate the entries first
    bValidated = TRUE;
    for ( ; (lpentry + 1) <= lpbufend; lpentry++) {
        // validate the entry first
        if (chVersion == 1 && (lpentry->wReserved != 0 ||
                               lpentry->dwReserved1 != 0 ||
                               lpentry->dwReserved2 != 0)) {
            bValidated = FALSE;
            break;
        }

        // now process it
        ProcessRIPQuery(lpaddr, lpentry);
    }


#ifdef ROUTE_FILTERS

    RIP_UNLOCK_ANNOUNCE_FILTERS();

#endif


    // if packet was validated and fields filled in, send it back
    if (bValidated) {

        // update the command field
        lpheader->chCommand = RIP_RESPONSE;

        iErr = sendto(lpaddr->sock, buffer, length, 0,
                      (LPSOCKADDR)lpsrcaddr, sizeof(SOCKADDR_IN));
        if (iErr == SOCKET_ERROR) {
            dbgprintf("error sending response to %s from local interface %s",
                       inet_ntoa(lpsrcaddr->sin_addr), szAddress);

            InterlockedIncrement(&lpaddr->lpstats->dwSendFailures);

            RipLogInformation(RIPLOG_SENDTO_FAILED, 0, NULL, WSAGetLastError());
        }
        else {
            InterlockedIncrement(&lpaddr->lpstats->dwResponsesSent);
        }
    }
}



//-----------------------------------------------------------------------
// Function:    ProcessRIPResponse
//
// Handles processing of response packets. Validates packets,
// and updates the tables if necessary.
//-----------------------------------------------------------------------
VOID ProcessRIPResponse(LPRIP_ADDRESS lpaddr, LPSOCKADDR_IN lpsrcaddr,
                        BYTE buffer[], int length) {
    IN_ADDR addr;
    BYTE chVersion;
    CHAR szAddress[32];
    LPRIP_HEADER lpheader;
    LPRIP_ENTRY lpentry, lpbufend;
    LPRIP_AUTHENT_ENTRY lpaentry;
    CHAR *pszTemp;

    // ignore responses from ports other than 520
    if (lpsrcaddr->sin_port != htons(RIP_PORT)) {
        dbgprintf("response is from invalid port (%d), discarding");

        InterlockedIncrement(&lpaddr->lpstats->dwBadPacketsReceived);

        RipLogWarning(RIPLOG_INVALIDPORT, 0, NULL, 0);
        return;
    }

    // ignore responses from our own interfaces
    if (IsLocalAddr(lpsrcaddr->sin_addr.s_addr)) {
        return;
    }

    InterlockedIncrement(&lpaddr->lpstats->dwResponsesReceived);

    // place templates over the buffer
    lpentry = (LPRIP_ENTRY)(buffer + sizeof(RIP_HEADER));
    lpbufend = (LPRIP_ENTRY)(buffer + length);
    lpheader = (LPRIP_HEADER)buffer;
    chVersion = lpheader->chVersion;
    lpaentry = (LPRIP_AUTHENT_ENTRY) lpentry;

    // seems OK, print a message
    addr.s_addr = lpaddr->dwAddress;
    pszTemp = inet_ntoa(addr);

    if (pszTemp != NULL) {
        strcpy(szAddress, pszTemp);
    }

    dbgprintf("received RIP v%d response from %s on address %s",
              chVersion, inet_ntoa(lpsrcaddr->sin_addr), szAddress);

#ifdef ROUTE_FILTERS

    RIP_LOCK_ACCEPT_FILTERS();

#endif

    //
    // take care of RIPv2 auth entry
    // - ignoring auth entry till we decide on a way to allow this
    //   to be configurable
    //
    if (chVersion == 2) {
        // if its an auth entry, ignore and continue
        if (ntohs(lpaentry->wAddrFamily) == ADDRFAMILY_AUTHENT) {
            lpentry++;
        }
    }

    //
    // validate each entry, then process it
    //

    for ( ; (lpentry + 1) <= lpbufend; lpentry++) {

        //
        // for non RIPv2 reserved fields must be checked
        //

        if (chVersion == 1) {

            //
            // check route entry fields
            //
            if (ntohs(lpentry->wAddrFamily) != AF_INET ||
                lpentry->wReserved != 0                 ||
                lpentry->dwReserved1 != 0               ||
                lpentry->dwReserved2 != 0) {

                //
                // update stats on ignored entries
                //
                InterlockedIncrement(&lpaddr->lpstats->dwBadRouteResponseEntries);

                RipLogInformation(RIPLOG_FORMAT_ERROR, 0, NULL, 0);
                continue;
            }

            // entry looks OK, so process it
            ProcessRIPEntry(lpaddr, lpsrcaddr->sin_addr, lpentry, chVersion);
        }
        else
        if (chVersion == 2) {

            //
            // check route entry fields
            //
            if (ntohs(lpentry->wAddrFamily) != AF_INET) {

                //
                // update stats on ignored entries
                //
                InterlockedIncrement(&lpaddr->lpstats->dwBadRouteResponseEntries);

                RipLogInformation(RIPLOG_FORMAT_ERROR, 0, NULL, 0);
                continue;
            }

            // entry looks OK, so process it
            ProcessRIPEntry(lpaddr, lpsrcaddr->sin_addr, lpentry, chVersion);
        }
        else {

            // following routing\ip\rip semantics
            //
            // this packet's version is greater than 2, so we ignore
            // the contents of the reserved fields
            //

            //
            // check route entry fields
            //
            if (ntohs(lpentry->wAddrFamily) != AF_INET) {

                //
                // update stats on ignored entries
                //
                InterlockedIncrement(&lpaddr->lpstats->dwBadRouteResponseEntries);

                RipLogInformation(RIPLOG_FORMAT_ERROR, 0, NULL, 0);
                continue;
            }

            //
            // entry is alright, clear reserved fields and process
            //
            lpentry->wRoutetag    = 0;
            lpentry->dwSubnetmask = 0;
            lpentry->dwNexthop    = 0;

            // entry looks OK, so process it
            ProcessRIPEntry(lpaddr, lpsrcaddr->sin_addr, lpentry, chVersion);
        }
    }

#ifdef ROUTE_FILTERS

    RIP_UNLOCK_ACCEPT_FILTERS();

#endif

}


//-----------------------------------------------------------------------
// Function: serviceHandlerFunction()
//
// Handles all service controller requests.
//-----------------------------------------------------------------------
VOID serviceHandlerFunction(DWORD dwControl) {
    SERVICE_STATUS status;

    dbgprintf("Service received control request %d", dwControl);

    switch (dwControl) {

    case SERVICE_CONTROL_INTERROGATE:
    case SERVICE_CONTROL_PAUSE:
    case SERVICE_CONTROL_CONTINUE:
        // increment checkpoint if necessary
        if (g_dwCheckPoint != 0) {
            InterlockedExchange(&g_dwCheckPoint, g_dwCheckPoint + 100);
        }

        status.dwWaitHint = g_dwWaitHint;
        status.dwWin32ExitCode = NO_ERROR;
        status.dwServiceType = SERVICE_WIN32;
        status.dwServiceSpecificExitCode = 0;
        status.dwCheckPoint = g_dwCheckPoint;
        status.dwCurrentState = g_dwCurrentState;
        status.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                    SERVICE_ACCEPT_SHUTDOWN;

#ifndef CHICAGO
        SetServiceStatus (g_hService, &status);
#endif
        break;

    case SERVICE_CONTROL_STOP:
    case SERVICE_CONTROL_SHUTDOWN:

        SetEvent(g_stopEvent);   // start cleanup

        InterlockedExchange(&g_dwWaitHint, 120000);
        InterlockedExchange(&g_dwCheckPoint, 100);
        InterlockedExchange(&g_dwCurrentState, SERVICE_STOP_PENDING);

        status.dwWaitHint = g_dwWaitHint;
        status.dwWin32ExitCode = NO_ERROR;
        status.dwCheckPoint = g_dwCheckPoint;
        status.dwServiceType = SERVICE_WIN32;
        status.dwServiceSpecificExitCode = 0;
        status.dwCurrentState = g_dwCurrentState;
        status.dwControlsAccepted = SERVICE_ACCEPT_STOP;

#ifndef CHICAGO
        SetServiceStatus(g_hService, &status);
#endif

        break;
    }

}



//-----------------------------------------------------------------------
// Function:    RIPServiceStop
//
// Handles freeing of resources, closing handles and sockets,
// and sending final status message to the service controller.
//-----------------------------------------------------------------------
void RIPServiceStop() {
    LPRIP_ADDRESS lpaddr, lpend;
    SERVICE_STATUS stopstatus = {SERVICE_WIN32, SERVICE_STOPPED, 0,
                                 NO_ERROR, 0, 0, 0};

    CleanupRouteTable();
    CleanupStatsTable();

    lpend = g_ripcfg.lpAddrTable + g_ripcfg.dwAddrCount;
    for (lpaddr = g_ripcfg.lpAddrTable; lpaddr < lpend; lpaddr++) {
        if (lpaddr->sock != INVALID_SOCKET) { closesocket(lpaddr->sock); }
    }

    WSACleanup();

    if (g_triggerEvent != NULL) {
        CloseHandle(g_triggerEvent); g_triggerEvent = NULL;
    }
    if (g_netEvent != NULL) {
        CloseHandle(g_netEvent); g_netEvent = NULL;
    }
    if (g_addressChangeEvent != NULL) {
        CloseHandle(g_addressChangeEvent); g_addressChangeEvent = NULL;
    }
    if (g_stopEvent != NULL) {
        CloseHandle(g_stopEvent); g_stopEvent = NULL;
    }
    if (g_ripcfg.hTCPDriver != NULL) {
        CloseHandle(g_ripcfg.hTCPDriver); g_ripcfg.hTCPDriver = NULL;
    }

    // need to log this before we destroy the locks
    RipLogInformation(RIPLOG_SERVICE_STOPPED, 0, NULL, 0);

    RIP_DESTROY_PARAMS_LOCK();
    RIP_DESTROY_ADDRTABLE_LOCK();
    RIP_DESTROY_ROUTETABLE_LOCK();


#ifdef ROUTE_FILTERS
    RIP_DESTROY_ANNOUNCE_FILTERS_LOCK();
    RIP_DESTROY_ACCEPT_FILTERS_LOCK();
#endif

    dbgprintf("Main thread stopping.");

    TraceDeregister(g_dwTraceID);

    g_dwTraceID = (DWORD)-1;

#ifndef CHICAGO
    SetServiceStatus(g_hService, &stopstatus);
#endif

}


#ifdef ROUTE_FILTERS

PRIP_FILTERS
LoadFilters(
    IN      HKEY                hKeyParams,
    IN      LPSTR               lpszKeyName
)
{

    LPSTR pszFilter = NULL;
    LPSTR pszIndex = NULL;

    DWORD dwSize = 0, dwErr = NO_ERROR, dwType = 0, dwCount = 0, dwInd = 0;

    PRIP_FILTERS prfFilter = NULL;



    //
    // route filters (added as a hotfix).
    //

    //
    // Routes included in a RIP annoucement can be filtered.
    //
    // Route filters are configured by setting the value "AnnounceRouteFilters"
    // or "AcceptRouteFilters"
    // under the Parameters key.  These are reg_multi_sz (or whatever it is
    // formally called).  Multiple filters can be set in each multistring.
    // Each entry represents a network that will be filtered out when RIP
    // announces/accepts routes.
    //

    do
    {
        dwSize = 0;

        dwErr = RegQueryValueExA(
                    hKeyParams, lpszKeyName, NULL,
                    &dwType, (LPBYTE) NULL, &dwSize
                    );

        if ( dwErr != ERROR_SUCCESS ||
             dwType != REG_MULTI_SZ ||
             dwSize <= 1 )
        {
            //
            // either there is no key by this name or it is the
            // wrong type.  Nothing else to be done at this point
            //

            break;
        }


        //
        // Appears to be a valid key with some data in it.
        //

        pszFilter = HeapAlloc(
                        GetProcessHeap(), HEAP_ZERO_MEMORY, dwSize + 1
                        );

        if ( pszFilter == NULL )
        {
            dbgprintf(
                "Failed to allocate filter string : size = %d", dwSize
                );

            RipLogError(
                RIPLOG_FILTER_ALLOC_FAILED, 0, NULL, ERROR_NOT_ENOUGH_MEMORY
                );

            break;
        }


        //
        // retrieve key contents
        //

        dwErr = RegQueryValueExA(
                    hKeyParams, lpszKeyName, NULL,
                    &dwType, (LPBYTE) pszFilter, &dwSize
                    );

        if ( dwErr != NO_ERROR || dwType != REG_MULTI_SZ || dwSize <= 1 )
        {
            dbgprintf(
                "Failed to retrieve %s filters : error = %d", lpszKeyName,
                dwErr
                );

            break;
        }


        //
        // Convert the filter multi string to ip addresses
        //

        //
        // count the number of filters
        //

        pszIndex = pszFilter;

        while ( *pszIndex != '\0' )
        {
            dwCount++;
            pszIndex += strlen( pszIndex ) + 1;
        }


        if ( dwCount == 0 )
        {
            dbgprintf( "No filters found" );

            break;
        }



        //
        // allocate filter structure
        //

        prfFilter = HeapAlloc(
                        GetProcessHeap(), HEAP_ZERO_MEMORY,
                        sizeof( RIP_FILTERS ) + ( dwCount - 1) * sizeof(
DWORD )
                        );

        if ( prfFilter == NULL )
        {
            dbgprintf(
                "Failed to allocate filter table : size = %d", dwSize
                );

            RipLogError(
                RIPLOG_FILTER_ALLOC_FAILED, 0, NULL, ERROR_NOT_ENOUGH_MEMORY
                );

            break;
        }


        //
        // fill it up
        //

        prfFilter-> dwCount = dwCount;

        pszIndex = pszFilter;

        for ( dwInd = 0; dwInd < dwCount; dwInd++ )
        {
            prfFilter-> pdwFilter[ dwInd ] = inet_addr( pszIndex );
            pszIndex += strlen( pszIndex ) + 1;
        }

    } while ( FALSE );


    if ( pszFilter != NULL )
    {
        HeapFree( GetProcessHeap(), 0, pszFilter );
    }


    if ( prfFilter != NULL )
    {
        //
        // Print the list of configured filters
        //

        dbgprintf( "Number of filters : %d", prfFilter-> dwCount );

        for ( dwInd = 0; dwInd < prfFilter-> dwCount; dwInd++ )
        {
            dbgprintf(
                "Filter #%d : %x (%s)", dwInd,
                prfFilter-> pdwFilter[ dwInd ],
                inet_ntoa( *( (struct in_addr*)
                    &(prfFilter-> pdwFilter[ dwInd ] ) ) )
                );
        }
    }

    return prfFilter;
}

#endif


//-----------------------------------------------------------------------
//
//--------------------------- WINNT Specific ----------------------------
//
//-----------------------------------------------------------------------

#ifndef CHICAGO

//-----------------------------------------------------------------------
// Function:    DllMain
//
// DLL entry-point; saves the module handle for later use.
//-----------------------------------------------------------------------

BOOL APIENTRY
DllMain(
    HMODULE     hmodule,
    DWORD       dwReason,
    VOID*       pReserved
    ) {

    if (dwReason == DLL_PROCESS_ATTACH) { g_hmodule = hmodule; }

    return TRUE;
}


//-----------------------------------------------------------------------
// Function:    LoadParameters
//
// Reads various configuration flags from the registry.
//-----------------------------------------------------------------------

DWORD LoadParameters() {
    DWORD valuesize;
    DWORD dwErr, dwType, dwIndex, dwValue;

    HKEY hkeyParams;
    DWORD dwRouteTimeout, dwGarbageTimeout;
    DWORD dwLoggingLevel, dwUpdateFrequency;
    DWORD dwMaxTriggerFrequency, dwOverwriteStaticRoutes;

    DWORD dwSize = MAX_PATH;
    HKEY hkey = NULL;
    WCHAR Buffer[MAX_PATH+1];

    RegCloseKey( hkey );

    dwErr =  RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_RIP_PARAMS, &hkeyParams);
    if (dwErr != ERROR_SUCCESS) {
        return GetLastError();
    }


#ifdef ROUTE_FILTERS

    RIP_LOCK_ANNOUNCE_FILTERS();

    if ( g_prfAnnounceFilters != NULL ) {
        HeapFree( GetProcessHeap(), 0, g_prfAnnounceFilters );
    }

    g_prfAnnounceFilters = LoadFilters( hkeyParams, REGVAL_ANNOUCE_FILTERS );

    RIP_UNLOCK_ANNOUNCE_FILTERS();


    RIP_LOCK_ACCEPT_FILTERS();

    if ( g_prfAcceptFilters != NULL ) {
        HeapFree( GetProcessHeap(), 0, g_prfAcceptFilters );
    }

    g_prfAcceptFilters = LoadFilters( hkeyParams, REGVAL_ACCEPT_FILTERS );

    RIP_UNLOCK_ACCEPT_FILTERS();

#endif


    RIP_LOCK_PARAMS();

    // always run in SilentRIP mode.
    {
        g_params.dwSilentRIP = 1;
    }

    // read the value for accepting host routes
    valuesize = sizeof(DWORD);
    dwErr = RegQueryValueEx(hkeyParams, REGVAL_ACCEPT_HOST, NULL,
                            &dwType, (LPBYTE)&dwValue, &valuesize);
    if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD) {
        g_params.dwAcceptHost = dwValue;
    }
    else {
        g_params.dwAcceptHost = DEF_ACCEPT_HOST;
    }

    // read the value for announcing host routes
    valuesize = sizeof(DWORD);
    dwErr = RegQueryValueEx(hkeyParams, REGVAL_ANNOUNCE_HOST, NULL,
                            &dwType, (LPBYTE)&dwValue, &valuesize);
    if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD) {
        g_params.dwAnnounceHost = dwValue;
    }
    else {
        g_params.dwAnnounceHost = DEF_ANNOUNCE_HOST;
    }

    // read the value for accepting default routes
    valuesize = sizeof(DWORD);
    dwErr = RegQueryValueEx(hkeyParams, REGVAL_ACCEPT_DEFAULT, NULL,
                            &dwType, (LPBYTE)&dwValue, &valuesize);
    if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD) {
        g_params.dwAcceptDefault = dwValue;
    }
    else {
        g_params.dwAcceptDefault = DEF_ACCEPT_DEFAULT;
    }

    // read the value for announcing default routes
    valuesize = sizeof(DWORD);
    dwErr = RegQueryValueEx(hkeyParams, REGVAL_ANNOUNCE_DEFAULT, NULL,
                            &dwType, (LPBYTE)&dwValue, &valuesize);
    if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD) {
        g_params.dwAnnounceDefault = dwValue;
    }
    else {
        g_params.dwAnnounceDefault = DEF_ANNOUNCE_DEFAULT;
    }

    // read value for split-horizon processing
    valuesize = sizeof(DWORD);
    dwErr = RegQueryValueEx(hkeyParams, REGVAL_SPLITHORIZON, NULL,
                            &dwType, (LPBYTE)&dwValue, &valuesize);
    if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD) {
        g_params.dwSplitHorizon = dwValue;
    }
    else {
        g_params.dwSplitHorizon = DEF_SPLITHORIZON;
    }

    // read value for poisoned-reverse processing
    valuesize = sizeof(DWORD);
    dwErr = RegQueryValueEx(hkeyParams, REGVAL_POISONREVERSE, NULL,
                            &dwType, (LPBYTE)&dwValue, &valuesize);
    if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD) {
        g_params.dwPoisonReverse = dwValue;
    }
    else {
        g_params.dwPoisonReverse = DEF_POISONREVERSE;
    }

    // read value for triggered update sending
    valuesize = sizeof(DWORD);
    dwErr = RegQueryValueEx(hkeyParams, REGVAL_TRIGGEREDUPDATES, NULL,
                            &dwType, (LPBYTE)&dwValue, &valuesize);
    if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD) {
        g_params.dwTriggeredUpdates = dwValue;
    }
    else {
        g_params.dwTriggeredUpdates = DEF_TRIGGEREDUPDATES;
    }

    // read value for triggered update frequency
    valuesize = sizeof(DWORD);
    dwErr = RegQueryValueEx(hkeyParams, REGVAL_TRIGGERFREQUENCY, NULL,
                            &dwType, (LPBYTE)&dwValue, &valuesize);
    if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD) {
        dwMaxTriggerFrequency = dwValue * 1000;
    }
    else {
        dwMaxTriggerFrequency = DEF_TRIGGERFREQUENCY;
    }

    // read value for route timeouts
    valuesize = sizeof(DWORD);
    dwErr = RegQueryValueEx(hkeyParams, REGVAL_ROUTETIMEOUT, NULL,
                            &dwType, (LPBYTE)&dwValue, &valuesize);
    if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD) {
        dwRouteTimeout = dwValue * 1000;
    }
    else {
        dwRouteTimeout = DEF_ROUTETIMEOUT;
    }

    // read values for update frequency
    valuesize = sizeof(DWORD);
    dwErr = RegQueryValueEx(hkeyParams, REGVAL_UPDATEFREQUENCY, NULL,
                            &dwType, (LPBYTE)&dwValue, &valuesize);
    if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD) {
        dwUpdateFrequency = dwValue * 1000;
    }
    else {
        dwUpdateFrequency = DEF_UPDATEFREQUENCY;
    }

    // read values for garbage timeouts
    valuesize = sizeof(DWORD);
    dwErr = RegQueryValueEx(hkeyParams, REGVAL_GARBAGETIMEOUT, NULL,
                            &dwType, (LPBYTE)&dwValue, &valuesize);
    if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD) {
        dwGarbageTimeout = dwValue * 1000;
    }
    else {
        dwGarbageTimeout = DEF_GARBAGETIMEOUT;
    }

    // read values for logging level
    valuesize = sizeof(DWORD);
    dwErr = RegQueryValueEx(hkeyParams, REGVAL_OVERWRITESTATIC, NULL,
                            &dwType, (LPBYTE)&dwValue, &valuesize);
    if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD) {
        dwOverwriteStaticRoutes = dwValue;
    }
    else {
        dwOverwriteStaticRoutes = DEF_OVERWRITESTATIC;
    }

    // read values for logging level
    valuesize = sizeof(DWORD);
    dwErr = RegQueryValueEx(hkeyParams, REGVAL_LOGGINGLEVEL, NULL,
                            &dwType, (LPBYTE)&dwValue, &valuesize);
    if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD) {
        dwLoggingLevel = dwValue;
    }
    else {
        dwLoggingLevel = DEF_LOGGINGLEVEL;
    }

    // read value for MaxTimedOpsInterval
    valuesize = sizeof(DWORD);
    dwErr = RegQueryValueEx(hkeyParams, REGVAL_MAXTIMEDOPSINTERVAL, NULL,
                            &dwType, (LPBYTE)&dwValue, &valuesize);
    if (dwErr == ERROR_SUCCESS && dwType == REG_DWORD && dwValue) {
        g_params.dwMaxTimedOpsInterval = dwValue * 1000;
    }
    else {
        g_params.dwMaxTimedOpsInterval = DEF_MAXTIMEDOPSINTERVAL;
    }


    RegCloseKey(hkeyParams);

    // adjust values if out of acceptable range
    if (dwRouteTimeout > MAX_ROUTETIMEOUT) {
        dwRouteTimeout = MAX_ROUTETIMEOUT;
    }
    else
    if (dwRouteTimeout < MIN_ROUTETIMEOUT) {
        dwRouteTimeout = MIN_ROUTETIMEOUT;
    }

    if (dwGarbageTimeout > MAX_GARBAGETIMEOUT) {
        dwGarbageTimeout = MAX_GARBAGETIMEOUT;
    }
    else
    if (dwGarbageTimeout < MIN_GARBAGETIMEOUT) {
        dwGarbageTimeout = MIN_GARBAGETIMEOUT;
    }

    if (dwUpdateFrequency > MAX_UPDATEFREQUENCY) {
        dwUpdateFrequency = MAX_UPDATEFREQUENCY;
    }
    else
    if (dwUpdateFrequency < MIN_UPDATEFREQUENCY) {
        dwUpdateFrequency = MIN_UPDATEFREQUENCY;
    }

    if (dwMaxTriggerFrequency > MAX_TRIGGERFREQUENCY) {
        dwMaxTriggerFrequency = MAX_TRIGGERFREQUENCY;
    }
    else
    if (dwMaxTriggerFrequency < MIN_TRIGGERFREQUENCY) {
        dwMaxTriggerFrequency = MIN_TRIGGERFREQUENCY;
    }

    g_params.dwRouteTimeout = dwRouteTimeout;
    g_params.dwGarbageTimeout = dwGarbageTimeout;
    g_params.dwUpdateFrequency = dwUpdateFrequency;
    g_params.dwMaxTriggerFrequency = dwMaxTriggerFrequency;
    g_params.dwLoggingLevel = dwLoggingLevel;
    g_params.dwOverwriteStaticRoutes = dwOverwriteStaticRoutes;

    dbgprintf("%s == %d", REGVAL_LOGGINGLEVEL, dwLoggingLevel);
    dbgprintf("%s == %d", REGVAL_ROUTETIMEOUT, dwRouteTimeout / 1000);
    dbgprintf("%s == %d", REGVAL_GARBAGETIMEOUT, dwGarbageTimeout / 1000);
    dbgprintf("%s == %d", REGVAL_UPDATEFREQUENCY, dwUpdateFrequency / 1000);
    dbgprintf("%s == %d", REGVAL_ACCEPT_HOST, g_params.dwAcceptHost);
    dbgprintf("%s == %d", REGVAL_ANNOUNCE_HOST, g_params.dwAnnounceHost);
    dbgprintf("%s == %d", REGVAL_ACCEPT_DEFAULT, g_params.dwAcceptDefault);
    dbgprintf("%s == %d", REGVAL_ANNOUNCE_DEFAULT, g_params.dwAnnounceDefault);
    dbgprintf("%s == %d", REGVAL_SPLITHORIZON, g_params.dwSplitHorizon);
    dbgprintf("%s == %d", REGVAL_POISONREVERSE, g_params.dwPoisonReverse);
    dbgprintf("%s == %d", REGVAL_TRIGGEREDUPDATES, g_params.dwTriggeredUpdates);
    dbgprintf("%s == %d", REGVAL_OVERWRITESTATIC, dwOverwriteStaticRoutes);
    dbgprintf("%s == %d", REGVAL_TRIGGERFREQUENCY,
                          g_params.dwMaxTriggerFrequency / 1000);

    if (g_params.dwSilentRIP != 0) {
        dbgprintf("IPRIP is configured to be silent.");
    }
    else {
        dbgprintf("IPRIP is configured to be active.");
    }

    if (dwLoggingLevel >= LOGLEVEL_INFORMATION) {
        // log the parameters IPRIP is using
        //
        CHAR szBuffer[2048], *lplpszArgs[] = { szBuffer };

        sprintf(szBuffer,
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d",
                REGVAL_LOGGINGLEVEL, dwLoggingLevel,
                REGVAL_ROUTETIMEOUT, dwRouteTimeout / 1000,
                REGVAL_GARBAGETIMEOUT, dwGarbageTimeout / 1000,
                REGVAL_UPDATEFREQUENCY, dwUpdateFrequency / 1000,
                REGVAL_ACCEPT_HOST, g_params.dwAcceptHost,
                REGVAL_ANNOUNCE_HOST, g_params.dwAnnounceHost,
                REGVAL_ACCEPT_DEFAULT, g_params.dwAcceptDefault,
                REGVAL_ANNOUNCE_DEFAULT, g_params.dwAnnounceDefault,
                REGVAL_SPLITHORIZON, g_params.dwSplitHorizon,
                REGVAL_POISONREVERSE, g_params.dwPoisonReverse,
                REGVAL_TRIGGEREDUPDATES, g_params.dwTriggeredUpdates,
                REGVAL_OVERWRITESTATIC, dwOverwriteStaticRoutes,
                REGVAL_TRIGGERFREQUENCY, g_params.dwMaxTriggerFrequency / 1000,
                REGVAL_SILENTRIP, g_params.dwSilentRIP);

        RipLogInformation(RIPLOG_REGISTRY_PARAMETERS, 1, lplpszArgs, 0);

    }


    RIP_UNLOCK_PARAMS();


    return 0;
}


#else

//-----------------------------------------------------------------------
//
//--------------------------- Windows 95 Specific -----------------------
//
//-----------------------------------------------------------------------

//
// named event
//

#define     RIP_LISTENER_EVENT      TEXT( "RIP.Listener.Event" )


HINSTANCE   hInst;                  // current instance
HWND        hWnd;                   // Main window handle.


//
// resource strings
//

char szAppName[64];                 // The name of this application
char szTitle[32];                   // The title bar text
char szHelpStr[32];                 // Help flag "Help"
char szQuestStr[32];                // Abriev. Help Flag "?"
char szCloseStr[32];                // Close flag "close"
char szDestroyStr[32];              // Destroy flag "destroy"
char szHelpText1[256];              // Help String
char szHelpText2[64];               // Help String
char szHelpText3[128];              // Help String


//
// local function prototypes
//

BOOL
InitApplication(
    HINSTANCE   hInstance
    );

BOOL
InitInstance(
    HINSTANCE   hInstance,
    int         nCmdShow
    );

BOOL
GetStrings(
    HINSTANCE hInstance
    );

LRESULT CALLBACK WndProc(
    HWND hWnd,                      // window handle
    UINT message,                   // type of message
    WPARAM uParam,                  // additional information
    LPARAM lParam                   // additional information
    );


//-----------------------------------------------------------------------
// Function:    GetStrings
//
// Retrieve resource strings
//-----------------------------------------------------------------------

BOOL GetStrings(HINSTANCE hInstance)
{
    if (LoadString(hInstance, IDS_TITLE_BAR, szTitle, sizeof(szTitle)) == 0)
    {
        goto ErrorExit;
    }

    if (LoadString(hInstance, IDS_APP_NAME, szAppName, sizeof(szAppName)) == 0)
    {
        goto ErrorExit;
    }

    if (LoadString(hInstance, IDS_HELP_TEXT1, szHelpText1, sizeof(szHelpText1)) == 0)
    {
        goto ErrorExit;
    }

    if (LoadString(hInstance, IDS_HELP_TEXT2, szHelpText2, sizeof(szHelpText2)) == 0)
    {
        goto ErrorExit;
    }

    return TRUE;


ErrorExit:

    return FALSE;


}

//-----------------------------------------------------------------------
// Functions : InitInstance
//
// save instance handle and create main window.
//-----------------------------------------------------------------------

BOOL
InitInstance(
    HINSTANCE   hInstance,
    int         nCmdShow
    )
{

    //
    // Save the instance handle in static variable, which will be used in
    // many subsequence calls from this application to Windows.
    //
    // Store instance handle in our global variable
    //

    hInst = hInstance;


    //
    // Create a main window for this application instance.
    //

    hWnd = CreateWindow(
        szAppName,
        szTitle,
        WS_EX_TRANSPARENT,                      // Window style.
        0, 0, CW_USEDEFAULT, CW_USEDEFAULT, // Use default positioning CW_USEDEAULT
        NULL,            // Overlapped windows have no parent.
        NULL,            // Use the window class menu.
        hInstance,       // This instance owns this window.
        NULL             // We don't use any data in our WM_CREATE
    );


    //
    // If window could not be created, return "failure"
    //

    if (!hWnd)
    {
        dbgprintf( "Failed to create window" );
        return (FALSE);
    }


    //
    // Make the window visible; update its client area; and return "success"
    //

    ShowWindow(hWnd, nCmdShow); // Show the window
    UpdateWindow(hWnd);         // Sends WM_PAINT message

    return (TRUE);              // We succeeded...
}


//-----------------------------------------------------------------------------
// Function : InitApplication
//
// initialize window data and register window class
//-----------------------------------------------------------------------------

BOOL InitApplication(HINSTANCE hInstance)
{
    WNDCLASS  wc;
    DWORD     LastError;

    //
    // Fill in window class structure with parameters that
    // describe the main window.
    //

    wc.style         = CS_HREDRAW | CS_VREDRAW;// Class style(s).
    wc.lpfnWndProc   = WndProc;                // Window Procedure
    wc.cbClsExtra    = 0;                      // No per-class extra data.
    wc.cbWndExtra    = 0;                      // No per-window extra data.
    wc.hInstance     = hInstance;              // Owner of this class
    wc.hIcon         = NULL;
    wc.hCursor       = NULL;
    wc.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);// Default color
    wc.lpszMenuName  = szAppName;              // Menu name from .RC
    wc.lpszClassName = szAppName;              // Name to register as


    //
    // Register the window class and return success/failure code.
    //

    if ( !RegisterClass(&wc) )
    {
        dbgprintf( "Failed to register class" );
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

//-----------------------------------------------------------------------------
// Function : WndProc
//
// process messages
//-----------------------------------------------------------------------------

LRESULT CALLBACK WndProc(
    HWND hWnd,              // window handle
    UINT message,           // type of message
    WPARAM uParam,          // additional information
    LPARAM lParam           // additional information
    )
{
    switch (message)
    {
        case WM_ENDSESSION:
        case WM_QUERYENDSESSION:

            if (lParam == 0)
            {
                dbgprintf ( "IPRIP : Received shutdown message\n" );
            }
            if (lParam == 1 ) //EWX_REALLYLOGOFF
            {
                dbgprintf ( "IPRIP : Received logoff message\n" );
            }

            return(1);


        case WM_DESTROY:  // message: window being destroyed

            PostQuitMessage(0);
            return(0);


        default:          // Pass it on if unproccessed
            return (DefWindowProc(hWnd, message, uParam, lParam));
    }
}


//-----------------------------------------------------------------------
// Function:    LoadParameters
//
// Reads various configuration flags from the registry.
//-----------------------------------------------------------------------

DWORD LoadParameters()
{


    RIP_LOCK_PARAMS();

    g_params.dwSilentRIP                = 1;

    g_params.dwAcceptHost               = DEF_ACCEPT_HOST;
    g_params.dwAnnounceHost             = DEF_ANNOUNCE_HOST;

    g_params.dwAcceptDefault            = DEF_ACCEPT_DEFAULT;
    g_params.dwAnnounceDefault          = DEF_ANNOUNCE_DEFAULT;

    g_params.dwSplitHorizon             = DEF_SPLITHORIZON;
    g_params.dwPoisonReverse            = DEF_POISONREVERSE;

    g_params.dwTriggeredUpdates         = DEF_TRIGGEREDUPDATES;
    g_params.dwMaxTriggerFrequency      = DEF_TRIGGERFREQUENCY;

    g_params.dwRouteTimeout             = DEF_ROUTETIMEOUT;
    g_params.dwUpdateFrequency          = DEF_UPDATEFREQUENCY;
    g_params.dwGarbageTimeout           = DEF_GARBAGETIMEOUT;

    g_params.dwOverwriteStaticRoutes    = DEF_OVERWRITESTATIC;

    g_params.dwLoggingLevel             = DEF_LOGGINGLEVEL;


    dbgprintf("%s == %d", REGVAL_LOGGINGLEVEL, g_params.dwLoggingLevel);
    dbgprintf("%s == %d", REGVAL_ROUTETIMEOUT, g_params.dwRouteTimeout / 1000);
    dbgprintf("%s == %d", REGVAL_GARBAGETIMEOUT, g_params.dwGarbageTimeout / 1000);
    dbgprintf("%s == %d", REGVAL_UPDATEFREQUENCY, g_params.dwUpdateFrequency / 1000);
    dbgprintf("%s == %d", REGVAL_ACCEPT_HOST, g_params.dwAcceptHost);
    dbgprintf("%s == %d", REGVAL_ANNOUNCE_HOST, g_params.dwAnnounceHost);
    dbgprintf("%s == %d", REGVAL_ACCEPT_DEFAULT, g_params.dwAcceptDefault);
    dbgprintf("%s == %d", REGVAL_ANNOUNCE_DEFAULT, g_params.dwAnnounceDefault);
    dbgprintf("%s == %d", REGVAL_SPLITHORIZON, g_params.dwSplitHorizon);
    dbgprintf("%s == %d", REGVAL_POISONREVERSE, g_params.dwPoisonReverse);
    dbgprintf("%s == %d", REGVAL_TRIGGEREDUPDATES, g_params.dwTriggeredUpdates);
    dbgprintf("%s == %d", REGVAL_OVERWRITESTATIC, g_params.dwOverwriteStaticRoutes);
    dbgprintf("%s == %d", REGVAL_TRIGGERFREQUENCY,
                          g_params.dwMaxTriggerFrequency / 1000);


    if (g_params.dwSilentRIP != 0)
    {
        dbgprintf("IPRIP is configured to be silent.");
    }
    else
    {
        dbgprintf("IPRIP is configured to be active.");
    }

    if (g_params.dwLoggingLevel >= LOGLEVEL_INFORMATION)
    {
        //
        // log the parameters IPRIP is using
        //

        CHAR szBuffer[2048], *lplpszArgs[] = { szBuffer };

        sprintf(szBuffer,
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d"
                "\r\n%s: %d",
                REGVAL_LOGGINGLEVEL, g_params.dwLoggingLevel,
                REGVAL_ROUTETIMEOUT, g_params.dwRouteTimeout / 1000,
                REGVAL_GARBAGETIMEOUT, g_params.dwGarbageTimeout / 1000,
                REGVAL_UPDATEFREQUENCY, g_params.dwUpdateFrequency / 1000,
                REGVAL_ACCEPT_HOST, g_params.dwAcceptHost,
                REGVAL_ANNOUNCE_HOST, g_params.dwAnnounceHost,
                REGVAL_ACCEPT_DEFAULT, g_params.dwAcceptDefault,
                REGVAL_ANNOUNCE_DEFAULT, g_params.dwAnnounceDefault,
                REGVAL_SPLITHORIZON, g_params.dwSplitHorizon,
                REGVAL_POISONREVERSE, g_params.dwPoisonReverse,
                REGVAL_TRIGGEREDUPDATES, g_params.dwTriggeredUpdates,
                REGVAL_OVERWRITESTATIC, g_params.dwOverwriteStaticRoutes,
                REGVAL_TRIGGERFREQUENCY, g_params.dwMaxTriggerFrequency / 1000,
                REGVAL_SILENTRIP, g_params.dwSilentRIP);

        RipLogInformation(RIPLOG_REGISTRY_PARAMETERS, 1, lplpszArgs, 0);
    }


    RIP_UNLOCK_PARAMS();


    return 0;
}

//-----------------------------------------------------------------------
// Function:    WinMain
//
// Launches the RIP service and waits for it to terminate
//-----------------------------------------------------------------------

INT APIENTRY
WinMain(
    HINSTANCE   hInstance,
    HINSTANCE   hPrevInstance,
    LPSTR       lpCmdLine,
    int         nCmdShow
    )
{

    MSG     msg;
    HANDLE  RipListenerEvent, hThread, hKernel32 = NULL;
    DWORD   threadId, LastError;
    BOOL    fRegSrvcProc = FALSE;
    FARPROC pRegSrvcProc;


    LPCSTR  event_name = RIP_LISTENER_EVENT;
    DWORD   err;


    //
    // Get entry point RegisterServiceProcess
    //

/*
    if ( (GetVersion() & 0x000000ff) == 0x04 )
    {
        if ((hKernel32 = GetModuleHandle("kernel32.dll")) == NULL)
        {
            //
            // This should never happen but we'll try and
            // load the library anyway
            //

            if ((hKernel32 = LoadLibrary("kernel32.dll")) == NULL)
            {
                fRegSrvcProc = FALSE;
            }
        }

        if (hKernel32)
        {
            if ((pRegSrvcProc = GetProcAddress(hKernel32,"RegisterServiceProcess")) == NULL)
            {
                fRegSrvcProc = FALSE;
            }
            else
            {
                fRegSrvcProc = TRUE;
            }
        }
    }
    else
    {
        fRegSrvcProc = FALSE;
    }

*/

    //
    // Other instances of RIP listener running?
    //

    RipListenerEvent = OpenEvent( SYNCHRONIZE, FALSE, event_name ) ;

    if ( RipListenerEvent == NULL)
    {
        if ( (RipListenerEvent = CreateEvent( NULL, FALSE, TRUE, event_name ) ) == NULL)
        {
            LastError = GetLastError();

            dbgprintf(
                "IPRIP Create Event failed, error code %d",
                  LastError
                  );

            RipLogError( RIPLOG_CREATEEVENT_FAILED, 0, NULL, LastError );

            return 1;
        }

    }

    else
    {
        //
        // another instance is running
        //

        HANDLE hParentWin;

        dbgprintf( "IPRIP : Service already running\n" );

        RipLogError( RIPLOG_SERVICE_AREADY_STARTED, 0, NULL, 0 );

        return 1;
    }



    //
    // retrieve resource strings
    //

    if ( !GetStrings(hInstance) )
    {
        dbgprintf( "IPRIP : Service failed to initialize\n" );

        RipLogError( RIPLOG_SERVICE_INIT_FAILED, 0, NULL, 0 );

        return 1;
    }


    //
    // required initialization for windows apps.
    //

    if( !InitApplication( hInstance ) )
    {
        dbgprintf( "IPRIP : Service failed to initialize\n" );

        RipLogError( RIPLOG_SERVICE_INIT_FAILED, 0, NULL, 0 );

        return 1;
    }


    if (!InitInstance(hInstance, SW_HIDE))
    {
        dbgprintf( "IPRIP : Service failed to initialize\n" );

        RipLogError( RIPLOG_SERVICE_INIT_FAILED, 0, NULL, 0 );

        return 1;
    }


    //
    // Launch main service controller thread
    //

    if ( ( hThread = CreateThread(
                        NULL,
                        0,
                        (LPTHREAD_START_ROUTINE)ServiceMain,
                        NULL,
                        0,
                        &threadId
                    )
         ) == 0)
    {
        dbgprintf( "IPRIP : Failed thread creation\n" );

        RipLogError( RIPLOG_CREATETHREAD_FAILED, 0, NULL, 0 );

        return 1;
    }


    //
    // Register service process
    //

/*
    if (fRegSrvcProc)
    {
        (*pRegSrvcProc)(GetCurrentProcessId(), RSP_SIMPLE_SERVICE);
    }
*/

    //
    // Acquire and dispatch messages until a WM_QUIT message is received.
    //

    while (GetMessage(&msg, NULL, 0, 0))
    {
        TranslateMessage(&msg);         // Translates virtual key codes
        DispatchMessage(&msg);          // Dispatches message to window
    }


    //
    // Un register service process
    //

/*
    if (fRegSrvcProc)
    {
        (*pRegSrvcProc)(GetCurrentProcessId(), RSP_UNREGISTER_SERVICE);
    }
*/

    dbgprintf( "IPRIP : Service terminated\n" );

    RipLogError( RIPLOG_SERVICE_STOPPED, 0, NULL, 0 );

    return(0);


    UNREFERENCED_PARAMETER(lpCmdLine);
}

//   Name:  Mohsin Ahmed
//   Email: MohsinA@microsoft.com
//   Date:  Mon Nov 04 13:53:46 1996
//   File:  s:/tcpcmd/common2/debug.c
//   Synopsis: Win95 Woes, don't have ntdll.dll on win95.

#include <windows.h>
#define MAX_DEBUG_OUTPUT 1024

void DbgPrintf( char * format, ... )
{
    va_list args;
    char    out[MAX_DEBUG_OUTPUT];
    int     cch=0;

    // cch = wsprintf( out, MODULE_NAME ":"  );

    va_start( args, format );
    wvsprintf( out + cch, format, args );
    va_end( args );

    OutputDebugString(  out );
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\rip\rip.h ===
//****************************************************************************
//
//               Microsoft Windows NT RIP
//
//               Copyright 1995-96
//
//
//  Revision History
//
//
//  2/26/95    Gurdeep Singh Pall  Picked up from JBallard's team
//
//
//  Description: Globals, headers, defines.
//
//****************************************************************************


#define CLASSA_ADDR(a)  (( (*((uchar *)&(a))) & 0x80) == 0)
#define CLASSB_ADDR(a)  (( (*((uchar *)&(a))) & 0xc0) == 0x80)
#define CLASSC_ADDR(a)  (( (*((uchar *)&(a))) & 0xe0) == 0xc0)
#define CLASSD_ADDR(a)  (( (*((uchar *)&(a))) & 0xf0) == 0xe0)
#define CLASSE_ADDR(a)  ((( (*((uchar *)&(a))) & 0xf0) == 0xf0) && \
                        ((a) != 0xffffffff))

#define CLASSA_MASK     0x000000ff
#define CLASSB_MASK     0x0000ffff
#define CLASSC_MASK     0x00ffffff
#define CLASSD_MASK     0x000000e0
#define CLASSE_MASK     0xffffffff

#define IP_LOOPBACK_ADDR(x) (((x) & 0xff) == 0x7f)

#define IS_BROADCAST_ADDR(a)                                                \
            ((a) == INADDR_BROADCAST ||                                     \
             (CLASSA_ADDR(a) && (((a) & ~CLASSA_MASK) == ~CLASSA_MASK)) ||  \
             (CLASSB_ADDR(a) && (((a) & ~CLASSB_MASK) == ~CLASSB_MASK)) ||  \
             (CLASSC_ADDR(a) && (((a) & ~CLASSC_MASK) == ~CLASSC_MASK))) 

#define HOSTADDR_MASK   0xffffffff

#define NETCLASS_MASK(a)                                        \
            (CLASSA_ADDR(a) ? CLASSA_MASK :                     \
            (CLASSB_ADDR(a) ? CLASSB_MASK :                     \
            (CLASSC_ADDR(a) ? CLASSC_MASK :                     \
            (CLASSD_ADDR(a) ? CLASSD_MASK : CLASSE_MASK))))

#define HASH_TABLE_SIZE                 101
#define NEW_ENTRY                       0x0001
#define TIMEOUT_TIMER                   0x0002
#define GARBAGE_TIMER                   0x0004
#define ROUTE_CHANGE                    0x0008
#define ROUTE_UPDATE                    0x0010
#define ROUTE_ZOMBIE                    0x0020
#define ROUTE_HOST                      0x0040

#define ADDRFLAG_DISABLED               0x01

#define RIP_MESSAGE_SIZE                512

#define RIP_SERVICE                     "IPRIP"

//
// definitions for IPRIP packet fields
//
#define RIP_REQUEST                     1
#define RIP_RESPONSE                    2
#define RIP_PORT                        520
#define METRIC_INFINITE                 16
#define RIP_MULTIADDR                   ((DWORD)0x090000E0)

//
// authentication definitions
//
#define RIP_MAX_AUTHKEY_SIZE            16
#define RIP_AUTHTYPE_NONE               1
#define RIP_AUTHTYPE_SIMPLE_PASSWORD    2
#define RIP_AUTHTYPE_MD5                3
#define ADDRFAMILY_AUTHENT                0xFFFF


#define MAX_ADDRESS_COUNT               128

#define DHCP_ADDR_CHANGE_EVENT          "DHCPNEWIPADDRESS"

#define RIP_STATS_TABLE_NAME            "IPRIP Statistics"
#define RIP_DUMP_ROUTES_NAME            "IPRIP Dump Routes"
#define RIP_DUMP_REPLY                  "Dump Routes Reply"
#define RIP_DUMP_REQUEST                "Dump Routes Request"


//-----------------------------------------------------------------------
// type definitions
//-----------------------------------------------------------------------

// the following struct is used to store information about routes
// see the comment for the RIP_GLOBALS for more information about
// accessing these. All addresses and masks are in network order.
typedef struct _HASH_TABLE_ENTRY {
    struct _HASH_TABLE_ENTRY   *next;
    struct _HASH_TABLE_ENTRY   *prev;
    DWORD                       dwIndex;
    DWORD                       dwDestaddr;
    DWORD                       dwNetmask;
    DWORD                       dwNexthop;
    DWORD                       dwMetric;   // the metric is in host order
    DWORD                       dwFlag;
    LONG                        lTimeout;
    DWORD                       dwProtocol;
} HASH_TABLE_ENTRY, *LPHASH_TABLE_ENTRY;


// the following two types are templates used on network packets.
// therefore, we require bytes to be packed.

// rgatta : changing reserved fields to unions for RIPv2 compatibility

#pragma pack(1)

typedef struct {
    BYTE chCommand;
    BYTE chVersion;
    WORD wReserved;
} RIP_HEADER, *LPRIP_HEADER;

typedef struct {
    WORD  wAddrFamily;
    union {
        WORD  wReserved;
        WORD  wRoutetag;
    };
    DWORD dwAddress;
    union {
        DWORD dwReserved1;
        DWORD dwSubnetmask;
    };
    union {
        DWORD dwReserved2;
        DWORD dwNexthop;
    };
    DWORD dwMetric;
} RIP_ENTRY, *LPRIP_ENTRY;

typedef struct {
    WORD wAddrFamily;
    WORD wAuthType;
    BYTE AuthKey[RIP_MAX_AUTHKEY_SIZE];

} RIP_AUTHENT_ENTRY, *LPRIP_AUTHENT_ENTRY;

#pragma pack()


// this struct is used to save operational parameters
// read from the registry. There is a single instance
// for the process, so for read/write access to the fields,
// first acquire the parameters lock by calling RIP_LOCK_PARAMS(),
// and release it by calling RIP_UNLOCK_PARAMS()
typedef struct {
    DWORD dwSilentRIP;
    DWORD dwAcceptHost;
    DWORD dwAnnounceHost;
    DWORD dwLoggingLevel;
    DWORD dwAcceptDefault;
    DWORD dwAnnounceDefault;
    DWORD dwSplitHorizon;
    DWORD dwPoisonReverse;
    DWORD dwRouteTimeout;
    DWORD dwGarbageTimeout;
    DWORD dwUpdateFrequency;
    DWORD dwTriggeredUpdates;
    DWORD dwMaxTriggerFrequency;
    DWORD dwOverwriteStaticRoutes;
    DWORD dwMaxTimedOpsInterval;
} RIP_PARAMETERS, *LPRIP_PARAMETERS;


#ifdef ROUTE_FILTERS

typedef struct {
    DWORD dwCount;
    DWORD pdwFilter[1];
} RIP_FILTERS, *PRIP_FILTERS;

#endif


// this struct is used to save statistics for each RIP interface
// All writes to these fields are done using InterlockedIncrement,
// by whichever thread is holding the address table lock.
// Interlocking is called for because these variables are in
// file-mapped memory, and may be read by other processes.
// Thus, it is important that all the fields here are DWORDs
typedef struct {
    DWORD dwAddress;
    DWORD dwSendFailures;
    DWORD dwReceiveFailures;
    DWORD dwRequestsSent;
    DWORD dwResponsesSent;
    DWORD dwRequestsReceived;
    DWORD dwResponsesReceived;
    DWORD dwBadPacketsReceived;
    DWORD dwBadRouteResponseEntries;
    DWORD dwTriggeredUpdatesSent;
} RIP_ADDRESS_STATISTICS, *LPRIP_ADDRESS_STATISTICS;


typedef struct {
    DWORD                       dwAddrCount;
    DWORD                       dwRouteCount;
    DWORD                       dwSystemAddRouteFailures;
    DWORD                       dwSystemDeleteRouteFailures;
    DWORD                       dwRoutesAddedToSystemTable;
    DWORD                       dwRoutesDeletedFromSystemTable;
    RIP_ADDRESS_STATISTICS      lpAddrStats[MAX_ADDRESS_COUNT];
} RIP_STATISTICS, *LPRIP_STATISTICS;


// The following struct contains information stored for each IP address
// in use by RIP. For information on the field lpstats, see above
typedef struct {
    SOCKET sock;
    DWORD  dwFlag;
    DWORD  dwIndex;
    DWORD  dwAddress;
    DWORD  dwNetmask;
    LPRIP_ADDRESS_STATISTICS lpstats;
} RIP_ADDRESS, *LPRIP_ADDRESS;


// The following struct contains several variables
// used in more than one thread. All changes to the first three
// are made using the InterlockedExchange function, so they can
// be safely read directly.
// For read/write access to dwAddrCount and lpAddrTable, first acquire the
// address table lock by calling RIP_LOCK_ADDRTABLE(), and then release it
// by calling RIP_UNLOCK_ADDRTABLE()
// For read/write access to lpRouteTable, first acquire the route table lock
// by calling RIP_LOCK_ROUTETABLE(), and release it by calling
// RIP_UNLOCK_ROUTETABLE().
// For nested locking, the following rules apply:
//   1. When getting both the address table lock and the parameters lock
//          always call RIP_LOCK_ADDRTABLE() before RIP_LOCK_PARAMS()
//   2. When getting both the address table lock and the route table lock
//          always call RIP_LOCK_ADDRTABLE() before RIP_LOCK_ROUTETABLE()
//   3. When getting both the route table lock and the parameters lock,
//          always call RIP_LOCK_ROUTETABLE() before RIP_LOCK_PARAMS()
//   4. Never hold more than two of the above locks simultaneously
typedef struct {
    DWORD               dwRouteChanged;
    DWORD               dwLastTriggeredUpdate;
    DWORD               dwMillisecsTillFullUpdate;

    HANDLE              hTCPDriver;
    DWORD               dwAddrCount;
    RIP_ADDRESS         lpAddrTable[MAX_ADDRESS_COUNT];
    LPRIP_STATISTICS    lpStatsTable;
    HASH_TABLE_ENTRY   *lpRouteTable[HASH_TABLE_SIZE];
} RIP_GLOBALS, *LPRIP_GLOBALS;


//-----------------------------------------------------------------------
// string for product type/version verfication
//-----------------------------------------------------------------------
#define REGKEY_PRODUCT_OPTION   TEXT("SYSTEM\\CurrentControlSet\\Control\\ProductOptions")
#define REGVAL_PRODUCT_TYPE     TEXT("ProductType")
#define WINNT_WORKSTATION       TEXT("WinNt")

//-----------------------------------------------------------------------
// strings used for registry access
//-----------------------------------------------------------------------
#define REGKEY_RIP_LINKAGE      "System\\CurrentControlSet\\Services" \
                                "\\IpRip\\Linkage"
#define REGKEY_RIP_DISABLED     "System\\CurrentControlSet\\Services" \
                                "\\IpRip\\Linkage\\Disabled"
#define REGVAL_BIND             "Bind"
#define REGVAL_ENABLEDHCP       "EnableDHCP"
#define REGVAL_DHCPIPADDRESS    "DhcpIPAddress"
#define REGVAL_IPADDRESS        "IPAddress"
#define REGVAL_DHCPNETMASK      "DhcpSubnetMask"
#define REGVAL_NETMASK          "SubnetMask"
#define REGKEY_SERVICES         "System\\CurrentControlSet\\Services"
#define REGKEY_PARAMETERS       "\\Parameters"
#define REGKEY_TCPIP            "\\TCPIP"


#define REGKEY_TCPIP_PARAMS     "SYSTEM\\CurrentControlSet\\Services" \
                                "\\TCPIP\\Parameters"
#define REGKEY_RIP_PARAMS       "SYSTEM\\CurrentControlSet\\Services" \
                                "\\IpRip\\Parameters"
#define REGVAL_ACCEPT_HOST      "AcceptHostRoutes"
#define REGVAL_ANNOUNCE_HOST    "AnnounceHostRoutes"
#define REGVAL_ACCEPT_DEFAULT   "AcceptDefaultRoutes"
#define REGVAL_ANNOUNCE_DEFAULT "AnnounceDefaultRoutes"
#define REGVAL_SPLITHORIZON     "EnableSplitHorizon"
#define REGVAL_POISONREVERSE    "EnablePoisonedReverse"
#define REGVAL_LOGGINGLEVEL     "LoggingLevel"
#define REGVAL_ROUTETIMEOUT     "RouteTimeout"
#define REGVAL_GARBAGETIMEOUT   "GarbageTimeout"
#define REGVAL_UPDATEFREQUENCY  "UpdateFrequency"
#define REGVAL_TRIGGEREDUPDATES "EnableTriggeredUpdates"
#define REGVAL_TRIGGERFREQUENCY "MaxTriggeredUpdateFrequency"
#define REGVAL_OVERWRITESTATIC  "OverwriteStaticRoutes"
#define REGVAL_MAXTIMEDOPSINTERVAL "MaxTimedOpsInterval"


#define REGVAL_IP_ENABLEROUTER  "IPEnableRouter"
#define REGVAL_SILENTRIP        "SilentRIP"


#ifdef ROUTE_FILTERS
#define REGVAL_ANNOUCE_FILTERS  "AnnounceRouteFilters"
#define REGVAL_ACCEPT_FILTERS   "AcceptRouteFilters"
#endif



#define LOGLEVEL_NONE           0
#define LOGLEVEL_ERROR          1
#define LOGLEVEL_WARNING        2
#define LOGLEVEL_INFORMATION    3

// all values pertaining to time are in milliseconds,
// but are read as seconds from the registry
#define DEF_SILENTRIP           0
#define DEF_ACCEPT_HOST         0
#define DEF_ANNOUNCE_HOST       0
#define DEF_ACCEPT_DEFAULT      0
#define DEF_ANNOUNCE_DEFAULT    0
#define DEF_SPLITHORIZON        1
#define DEF_POISONREVERSE       1
#define DEF_GETROUTEFREQUENCY   (60 * 1000)
#define DEF_LOGGINGLEVEL        LOGLEVEL_ERROR
#define DEF_ROUTETIMEOUT        (180 * 1000)
#define DEF_LOCALROUTETIMEOUT   (90 * 1000)
#define DEF_GARBAGETIMEOUT      (120 * 1000)
#define DEF_UPDATEFREQUENCY     (30 * 1000)
#define DEF_TRIGGEREDUPDATES    1
#define DEF_TRIGGERFREQUENCY    (5 * 1000)
#define DEF_OVERWRITESTATIC     0
#define DEF_MAXTIMEDOPSINTERVAL (10 * 1000)

#define MIN_LOGGINGLEVEL        LOGLEVEL_NONE
#define MIN_ROUTETIMEOUT        (15 * 1000)
#define MIN_GARBAGETIMEOUT      (15 * 1000)
#define MIN_UPDATEFREQUENCY     (15 * 1000)
#define MIN_TRIGGERFREQUENCY    (1 * 1000)

#define MAX_LOGGINGLEVEL        LOGLEVEL_INFORMATION
#define MAX_ROUTETIMEOUT        ((60 * 60 * 24 * 3) * 1000)
#define MAX_GARBAGETIMEOUT      ((60 * 60 * 24 * 3) * 1000)
#define MAX_UPDATEFREQUENCY     ((60 * 60 * 24) * 1000)
#define MAX_TRIGGERFREQUENCY    ((60 * 60 * 24) * 1000)


#define STOP_REASON_QUIT        0
#define STOP_REASON_ADDRCHANGE  1


//-----------------------------------------------------------------------
// global data declarations
//-----------------------------------------------------------------------
extern RIP_PARAMETERS       g_params;
extern RIP_GLOBALS          g_ripcfg;

#ifdef ROUTE_FILTERS

extern PRIP_FILTERS         g_prfAnnounceFilters;
extern PRIP_FILTERS         g_prfAcceptFilters;

extern CRITICAL_SECTION     g_csAccFilters;
extern CRITICAL_SECTION     g_csAnnFilters;

#endif

extern CRITICAL_SECTION     g_csRoutes;   
extern CRITICAL_SECTION     g_csParameters;
extern CRITICAL_SECTION     g_csAddrtables;   

extern DWORD                g_dwTraceID;
extern HANDLE               g_stopEvent;
extern HANDLE               g_addressChangeEvent;
extern HANDLE               g_netEvent;
extern HANDLE               g_triggerEvent;

extern HANDLE               g_hUpdateThread;

#ifndef CHICAGO
extern HMODULE              g_hmodule;
#endif


//-----------------------------------------------------------------------
// macro functions
//-----------------------------------------------------------------------
#define HASH_VALUE(ad)          (((ad & 0xff) +          \
                                 ((ad >> 8) & 0xff) +    \
                                 ((ad >> 16) & 0xff) +   \
                                 ((ad >> 24) & 0xff)) % HASH_TABLE_SIZE)

#define RIP_CREATE_ROUTETABLE_LOCK() InitializeCriticalSection(&g_csRoutes)
#define RIP_DESTROY_ROUTETABLE_LOCK() DeleteCriticalSection(&g_csRoutes)
#define RIP_LOCK_ROUTETABLE()       EnterCriticalSection(&g_csRoutes)
#define RIP_UNLOCK_ROUTETABLE()     LeaveCriticalSection(&g_csRoutes)

#define RIP_CREATE_PARAMS_LOCK()    InitializeCriticalSection(&g_csParameters)
#define RIP_DESTROY_PARAMS_LOCK()   DeleteCriticalSection(&g_csParameters)
#define RIP_LOCK_PARAMS()           EnterCriticalSection(&g_csParameters)
#define RIP_UNLOCK_PARAMS()         LeaveCriticalSection(&g_csParameters)

#define RIP_CREATE_ADDRTABLE_LOCK() InitializeCriticalSection(&g_csAddrtables)
#define RIP_DESTROY_ADDRTABLE_LOCK() DeleteCriticalSection(&g_csAddrtables)
#define RIP_LOCK_ADDRTABLE()       EnterCriticalSection(&g_csAddrtables)  
#define RIP_UNLOCK_ADDRTABLE()     LeaveCriticalSection(&g_csAddrtables)


#ifdef ROUTE_FILTERS

#define RIP_CREATE_ANNOUNCE_FILTERS_LOCK()  \
        InitializeCriticalSection( &g_csAnnFilters )
        
#define RIP_DESTROY_ANNOUNCE_FILTERS_LOCK() \
        DeleteCriticalSection( &g_csAnnFilters )
        
#define RIP_LOCK_ANNOUNCE_FILTERS()         \
        EnterCriticalSection( &g_csAnnFilters )
        
#define RIP_UNLOCK_ANNOUNCE_FILTERS()       \
        LeaveCriticalSection( &g_csAnnFilters )


#define RIP_CREATE_ACCEPT_FILTERS_LOCK()  \
        InitializeCriticalSection( &g_csAccFilters )
        
#define RIP_DESTROY_ACCEPT_FILTERS_LOCK() \
        DeleteCriticalSection( &g_csAccFilters )
        
#define RIP_LOCK_ACCEPT_FILTERS()         \
        EnterCriticalSection( &g_csAccFilters )
        
#define RIP_UNLOCK_ACCEPT_FILTERS()                \
        LeaveCriticalSection( &g_csAccFilters )

#endif



//-----------------------------------------------------------------------
// function prototypes
//-----------------------------------------------------------------------
DWORD               UpdateThread(LPVOID lpvParam);
ULONG               AddressChangeNotificationThread(LPVOID lpvParam);
VOID                serviceHandlerFunction(DWORD dwControl);
VOID FAR PASCAL     serviceMainFunction(IN DWORD dwNumServicesArgs,
                                        IN LPSTR *lpServiceArgVectors);

DWORD               InitializeRouteTable();
VOID                CleanupRouteTable();
VOID                CheckRouteTableEntries();
LPHASH_TABLE_ENTRY  GetRouteTableEntry(DWORD dwIndex, DWORD dwDestaddr,
                                       DWORD dwNetmask);
BOOL                RouteTableEntryExists(DWORD dwIndex, DWORD dwDestaddr);

VOID                DumpRouteTableEntries(BOOL bChangesOnly);
VOID                ProcessRouteTableChanges(BOOL bTriggered);
VOID                ClearChangeFlags();

DWORD               SubnetMask(DWORD dwAddress);
DWORD               NetclassMask(DWORD dwAddress);

INT                 LoadRouteTable(BOOL bFirstTime);
DWORD               UpdateSystemRouteTable(LPHASH_TABLE_ENTRY rt_entry,
                                           BOOL bAdd);

VOID                dbgprintf(LPSTR szFormat, ...);

DWORD               LoadParameters();
DWORD               InitializeAddressTable(BOOL bFirstTime);
DWORD               InitializeStatsTable();
VOID                CleanupStatsTable();

BOOL                IsHostAddress(DWORD dwAddress);
BOOL                IsLocalAddr(DWORD dwAddress);
BOOL                IsDisabledLocalAddress(DWORD dwAddress);
BOOL                IsBroadcastAddress(DWORD dwAddress);

DWORD               BroadcastRouteTableRequests();
DWORD               BroadcastRouteTableContents(BOOL bTriggered,
                                                BOOL bChangesOnly);
VOID                TransmitRouteTableContents(LPRIP_ADDRESS lpaddr,
                                               LPSOCKADDR_IN lpdestaddr,
                                               BOOL bChangesOnly);
VOID                InitUpdateBuffer(BYTE buffer[], LPRIP_ENTRY *lplpentry,
                                     LPDWORD lpdwSize);
VOID                AddUpdateEntry(BYTE buffer[], LPRIP_ENTRY *lplpentry,
                                   LPDWORD lpdwSize, LPRIP_ADDRESS lpaddr,
                                   LPSOCKADDR_IN lpdestaddr, DWORD dwAddress,
                                   DWORD dwMetric);
VOID                FinishUpdateBuffer(BYTE buffer[], LPDWORD lpdwSize,
                                       LPRIP_ADDRESS lpaddr,
                                       LPSOCKADDR_IN lpdestaddr);

VOID                ProcessRIPRequest(LPRIP_ADDRESS lpaddr,
                                      LPSOCKADDR_IN lpsrcaddr,
                                      BYTE buffer[], int length);
VOID                ProcessRIPResponse(LPRIP_ADDRESS lpaddr,
                                       LPSOCKADDR_IN lpsrcaddr,
                                       BYTE buffer[], int length);
DWORD               ProcessResponse(RIP_ADDRESS *lpAddress);
DWORD               ProcessRIPEntry(LPRIP_ADDRESS lpaddr, IN_ADDR srcaddr,
                                    LPRIP_ENTRY rip_entry, BYTE chVersion);
DWORD               ProcessRIPQuery(LPRIP_ADDRESS lpaddr,
                                    LPRIP_ENTRY rip_entry);

VOID                DoTimedOperations(DWORD dwMillisecsSinceLastCall);

/* add option to disable triggered updates */
/* pass socket address to process_rip_entry and process_rip_query */
/* add index field to rt_entry */



VOID                RIPServiceStop();
VOID                RipLogError(DWORD dwMsgID, WORD wNumString,
                             LPSTR *lplpStrings, DWORD dwErr);
VOID                RipLogWarning(DWORD dwMsgID, WORD wNumString,
                               LPSTR *lplpStrings, DWORD dwErr);
VOID                RipLogInformation(DWORD dwMsgID, WORD wNumString,
                                   LPSTR *lplpStrings, DWORD dwErr);

#ifdef ROUTE_FILTERS

PRIP_FILTERS
LoadFilters(
    IN      HKEY                hKeyParams,
    IN      LPSTR               lpszKeyName
);

#endif


//-----------------------------------------------------------------------------
//
//                          WIN 95 String resources
//
//-----------------------------------------------------------------------------

#ifdef CHICAGO

#define IDS_STRING_BASE             4096
#define IDS_APP_NAME                IDS_STRING_BASE + 0
#define IDS_TITLE_BAR               IDS_STRING_BASE + 1
#define IDS_HELP_TEXT1              IDS_STRING_BASE + 6
#define IDS_HELP_TEXT2              IDS_STRING_BASE + 7

#define IP_ADDRESS_RELOAD_INTR      120


//
// SYNOPSIS: One debug statememt in time can save nine.
// Last modified Time-stamp: <25-Nov-96 17:49>
// History:
//     MohsinA, 14-Nov-96.
//

void DbgPrintf( char * format, ... );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\rip\nt\makefile.inc ===
$(O)\nlstxt.mc: ..\errorlog.h
    mapmsg NET RIPLOG_BASE ..\errorlog.h > $@
    $(MC) -v -h $(O) -r $(O) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\rip\route.h ===
/*
 * Copyright (c) 1980, 1986 Regents of the University of California.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms are permitted
 * provided that the above copyright notice and this paragraph are
 * duplicated in all such forms and that any documentation,
 * advertising materials, and other materials related to such
 * distribution and use acknowledge that the software was developed
 * by the University of California, Berkeley.  The name of the
 * University may not be used to endorse or promote products derived
 * from this software without specific prior written permission.
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND WITHOUT ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED
 * WARRANTIES OF MERCHANTIBILITY AND FITNESS FOR A PARTICULAR PURPOSE.
 *
 *	@(#)route.h	7.4 (Berkeley) 6/27/88
 */

/*
 * Kernel resident routing tables.
 *
 * The routing tables are initialized when interface addresses
 * are set by making entries for all directly connected interfaces.
 */

/*
 * A route consists of a destination address and a reference
 * to a routing entry.  These are often held by protocols
 * in their control blocks, e.g. inpcb.
 */
struct route {
	struct	rtentry *ro_rt;
	struct	sockaddr ro_dst;
};

/*
 * We distinguish between routes to hosts and routes to networks,
 * preferring the former if available.  For each route we infer
 * the interface to use from the gateway address supplied when
 * the route was entered.  Routes that forward packets through
 * gateways are marked so that the output routines know to address the
 * gateway rather than the ultimate destination.
 */
struct rtentry {
	u_long	rt_hash;		/* to speed lookups */
	struct	sockaddr rt_dst;	/* key */
	struct	sockaddr rt_gateway;	/* value */
	short	rt_flags;		/* up/down?, host/net */
	short	rt_refcnt;		/* # held references */
	u_long	rt_use;			/* raw # packets forwarded */
	struct	ifnet *rt_ifp;		/* the answer: interface to use */
};

#define	RTF_UP		0x1		/* route useable */
#define	RTF_GATEWAY	0x2		/* destination is a gateway */
#define	RTF_HOST	0x4		/* host entry (net otherwise) */
#define	RTF_DYNAMIC	0x10		/* created dynamically (by redirect) */
#define	RTF_MODIFIED	0x20		/* modified dynamically (by redirect) */

/*
 * Routing statistics.
 */
struct	rtstat {
	short	rts_badredirect;	/* bogus redirect calls */
	short	rts_dynamic;		/* routes created by redirects */
	short	rts_newgateway;		/* routes modified by redirects */
	short	rts_unreach;		/* lookups which failed */
	short	rts_wildcard;		/* lookups satisfied by a wildcard */
};

#ifdef KERNEL
#define	RTFREE(rt) \
	if ((rt)->rt_refcnt == 1) \
		rtfree(rt); \
	else \
		(rt)->rt_refcnt--;

#ifdef	GATEWAY
#define	RTHASHSIZ	64
#else
#define	RTHASHSIZ	8
#endif
#if	(RTHASHSIZ & (RTHASHSIZ - 1)) == 0
#define RTHASHMOD(h)	((h) & (RTHASHSIZ - 1))
#else
#define RTHASHMOD(h)	((h) % RTHASHSIZ)
#endif
struct	mbuf *rthost[RTHASHSIZ];
struct	mbuf *rtnet[RTHASHSIZ];
struct	rtstat	rtstat;
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\simple\eventlog.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    eventlog.c

Abstract:

    This module contains routines that allow the simple TCP/IP services 
    to log events.  

Author:

    David Treadwell (davidtr) 08-02-1993

Revision History:

--*/

#include <simptcp.h>

//
//  Private globals.
//

HANDLE EventSource;


//
//  Private prototypes.
//

VOID
LogEventWorker (
    DWORD   Message,
    WORD    EventType,
    WORD    SubStringCount,
    CHAR    *SubStrings[],
    DWORD   ErrorCode
    );


INT
SimpInitializeEventLog (
    VOID
    )
{
    //
    //  Register as an event source.
    //

    EventSource = RegisterEventSource( NULL, TEXT("SimpTcp") );

    if( EventSource == NULL ) {
        return GetLastError();
    }

    return NO_ERROR;

} // SimpInitializeEventLog


VOID
SimpTerminateEventLog(
    VOID
    )
{
    //
    //  Deregister as an event source.
    //

    if( EventSource != NULL )
    {
        if( !DeregisterEventSource( EventSource ) )
        {
            INT err = GetLastError();
        }

        EventSource = NULL;
    }

} // SimpTerminateEventLog


VOID
SimpLogEvent(
    DWORD   Message,
    WORD    SubStringCount,
    CHAR    *SubStrings[],
    DWORD   ErrorCode
    )
{
    WORD Type;

    //
    // Determine the type of event to log based on the severity field of 
    // the message id.  
    //

    if( NT_INFORMATION(Message) ) {

        Type = EVENTLOG_INFORMATION_TYPE;

    } else if( NT_WARNING(Message) ) {

        Type = EVENTLOG_WARNING_TYPE;

    } else if( NT_ERROR(Message) ) {

        Type = EVENTLOG_ERROR_TYPE;

    } else {
        ASSERT( FALSE );
        Type = EVENTLOG_ERROR_TYPE;
    }

    //
    // Log it!
    //

    LogEventWorker(
        Message,
        Type,
        SubStringCount,
        SubStrings,
        ErrorCode
        );

} // SimpLogEvent


VOID
LogEventWorker(
    DWORD   Message,
    WORD    EventType,
    WORD    SubStringCount,
    CHAR    *SubStrings[],
    DWORD   ErrorCode
    )
{
    VOID    *RawData  = NULL;
    DWORD   RawDataSize = 0;

    ASSERT( ( SubStringCount == 0 ) || ( SubStrings != NULL ) );

    if( ErrorCode != 0 ) {
        RawData  = &ErrorCode;
        RawDataSize = sizeof(ErrorCode);
    }

    if( !ReportEvent(  EventSource,                     // hEventSource
                       EventType,                       // fwEventType
                       0,                               // fwCategory
                       Message,                         // IDEvent
                       NULL,                            // pUserSid,
                       SubStringCount,                  // cStrings
                       RawDataSize,                     // cbData
                       (LPCTSTR *)SubStrings,           // plpszStrings
                       RawData ) )                      // lpvData
    {                 
        INT err = GetLastError();
        DbgPrint( "cannot report event, error %lu\n", err );
    }

} // LogEventWorker
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\rip\table.h ===
#define net_part(addr)  ((addr) & net_mask(addr))


#define MASKA   0x000000FFL
#define MASKB   0x0000FFFFL
#define MASKC   0x00FFFFFFL
#define CLSHFT  5               /* Make C generate hyper-optimized case */

#define CLA0    0               /* It takes the same arg; you mask it off, */
#define CLA1    1               /* shift, and then do a case statment with */
#define CLA2    2               /* some code having more than one label. */
#define CLA3    3               /* Values for class A */
#define CLB0    4
#define CLB1    5               /* B */
#define CLC     6               /* C */
#define CLI     7               /* Illegal */

#define BROADCAST 0x00000000L

#define CASTA   0x00FFFFFFL
#define CASTB   0x0000FFFFL
#define CASTC   0x000000FFL

#define HASH_TABLE_SIZE 64
#define NEW_ENTRY           0x01
#define TIMEOUT_TIMER       0x02
#define GARBAGE_TIMER       0x04
#define ROUTE_CHANGE        0x08


typedef
struct _hash_entry {
    struct _hash_entry *prev;
    struct _hash_entry *next;
    unsigned long      dest_addr;
    unsigned long      next_hop;
    unsigned long      metric;
    unsigned long      flag;
    unsigned long      timeout;
    long               refcount;
    unsigned long      protocoltype;
} HASH_TABLE_ENTRY;

typedef
struct {
    BYTE            command;
    BYTE            version;
    unsigned short  resrvd1;
} RIP_HEADER;

typedef
struct {
    unsigned short  addr_fam;
    union {
        unsigned short  resrvd2;
        unsigned short  routetag;
    };
    unsigned long   ipaddr;
    union {
        unsigned long   resrvd3;
        unsigned long   subnetmask;
    };
    union {
        unsigned long   resrvd4;
        unsigned long   nexthop;
    };
    unsigned long   metric;
} RIP_ENTRY;

struct InterfaceEntry {
    DWORD  ipAdEntAddr;            // IP address of this entry
    DWORD  ipAdEntIfIndex;         // IF for this entry
    DWORD  ipAdEntNetMask;         // subnet mask of this entry
};

typedef struct InterfaceEntry InterfaceEntry ;


#define RECVBUFSIZE 576
#define SENDBUFSIZE 576

//
// Debugging functions
//

extern int nLogLevel;
extern int nLogType;

#define DBGCONSOLEBASEDLOG   0x1
#define DBGFILEBASEDLOG      0x2
#define DBGEVENTLOGBASEDLOG  0x4

VOID dbgprintf(
    IN INT nLevel,
    IN LPSTR szFormat,
    IN ...
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\rip\util.c ===
//****************************************************************************
//
//               Microsoft Windows NT RIP
//
//               Copyright 1995-96
//
//
//  Revision History
//
//
//  3/12/95    Gurdeep Singh Pall    Created
//
//
//  Description: General utility functions:
//
//****************************************************************************

#include "pchrip.h"
#pragma hdrstop


DWORD LoadAddressSockets();
DWORD OpenTcp();
DWORD TCPSetInformationEx(LPVOID lpvInBuffer, LPDWORD lpdwInSize,
                          LPVOID lpvOutBuffer, LPDWORD lpdwOutSize);
DWORD TCPQueryInformationEx(LPVOID lpvInBuffer, LPDWORD lpdwInSize,
                            LPVOID lpvOutBuffer, LPDWORD lpdwOutSize);


//-------------------------------------------------------------------
// Function:        LogEntry
// Parameters:
//      WORD        wEventType      type of event (ERROR, WARNING, etc)
//      DWORD       dwMsgID         ID of message string
//      WORD        wNumStrings     number of strings in lplpStrings
//      LPSTR      *lplpStrings     array of strings
//      DWORD       dwErr           error code
//-------------------------------------------------------------------
void LogEntry(WORD wEventType, DWORD dwMsgID, WORD wNumStrings,
              LPSTR *lplpStrings, DWORD dwErr) {
    DWORD dwSize;
    LPVOID lpvData;
    HANDLE     hLog;
    PSID pSidUser = NULL;

    hLog = RegisterEventSource(NULL, RIP_SERVICE);

    dwSize = (dwErr == NO_ERROR) ? 0 : sizeof(dwErr);
    lpvData = (dwErr == NO_ERROR) ? NULL : (LPVOID)&dwErr;
      ReportEvent(hLog, wEventType, 0, dwMsgID, pSidUser,
                wNumStrings, dwSize, lplpStrings, lpvData);

    DeregisterEventSource(hLog);
}


//-------------------------------------------------------------------
// Function:    RipLogError
// Parameters:
//      see LogEntry for parameter description
//-------------------------------------------------------------------
void RipLogError(DWORD dwMsgID, WORD wNumStrings,
              LPSTR *lplpStrings, DWORD dwErr) {
    DWORD dwLevel;
    dwLevel = g_params.dwLoggingLevel;
    if (dwLevel < LOGLEVEL_ERROR) { return; }
    LogEntry(EVENTLOG_ERROR_TYPE, dwMsgID, wNumStrings, lplpStrings, dwErr);
}


//-------------------------------------------------------------------
// Function:    LogWarning
// Parameters:
//      see LogEntry for parameter description
//-------------------------------------------------------------------
void RipLogWarning(DWORD dwMsgID, WORD wNumStrings,
                LPSTR *lplpStrings, DWORD dwErr) {
    DWORD dwLevel;
    dwLevel = g_params.dwLoggingLevel;
    if (dwLevel < LOGLEVEL_WARNING) { return; }
    LogEntry(EVENTLOG_WARNING_TYPE, dwMsgID, wNumStrings, lplpStrings, dwErr);
}


//-------------------------------------------------------------------
// Function:    LogInformation
// Parameters:
//      see LogEntry for parameter description
//-------------------------------------------------------------------
void RipLogInformation(DWORD dwMsgID, WORD wNumStrings,
                    LPSTR *lplpStrings, DWORD dwErr) {
    DWORD dwLevel;
    dwLevel = g_params.dwLoggingLevel;
    if (dwLevel < LOGLEVEL_INFORMATION) { return; }
    LogEntry(EVENTLOG_INFORMATION_TYPE, dwMsgID,
             wNumStrings, lplpStrings, dwErr);
}


//-------------------------------------------------------------------
// Function:    Audit
//-------------------------------------------------------------------
VOID Audit(IN WORD wEventType, IN DWORD dwMessageId,
           IN WORD cNumberOfSubStrings, IN LPSTR *plpwsSubStrings) {

    HANDLE hLog;
    PSID pSidUser = NULL;

    // Audit enabled

    hLog = RegisterEventSourceA(NULL, RIP_SERVICE);

    ReportEventA(hLog, wEventType, 0, dwMessageId, pSidUser,
                 cNumberOfSubStrings, 0, plpwsSubStrings, (PVOID)NULL);

    DeregisterEventSource( hLog );
}



//-------------------------------------------------------------------
// Function:    dbgprintf
//-------------------------------------------------------------------
VOID dbgprintf(LPSTR lpszFormat, ...) {
    va_list arglist;
    va_start(arglist, lpszFormat);
    TraceVprintf(g_dwTraceID, lpszFormat, arglist);
    va_end(arglist);
}



//-------------------------------------------------------------------
// Function:    InitializeAddressTable
//
// Assumes the address table is locked.
//-------------------------------------------------------------------
DWORD InitializeAddressTable(BOOL bFirstTime)  {

    LPRIP_ADDRESS lpaddr, lpaddrend;
    LPRIP_ADDRESS_STATISTICS lpstats;
    DWORD dwErr, dwCount, *lpdw, *lpdwend;
    PMIB_IPADDRROW lpTable, lpiae, lpiaeend;

    // first close old sockets, if necessary
    if (!bFirstTime) {
        lpaddrend = g_ripcfg.lpAddrTable + g_ripcfg.dwAddrCount;
        for (lpaddr = g_ripcfg.lpAddrTable; lpaddr < lpaddrend; lpaddr++) {
            if (lpaddr->sock != INVALID_SOCKET) {
                closesocket(lpaddr->sock);
                lpaddr->sock = INVALID_SOCKET;
            }
        }
    }

    dwErr = GetIPAddressTable(&lpTable, &dwCount);
    if (dwErr != 0) { return dwErr; }

    if (dwCount > MAX_ADDRESS_COUNT) { dwCount = MAX_ADDRESS_COUNT; }

    lpaddr  = g_ripcfg.lpAddrTable;
    lpstats = g_ripcfg.lpStatsTable->lpAddrStats;
    lpiaeend = lpTable + dwCount;
    g_ripcfg.dwAddrCount = dwCount;

    for (lpiae = lpTable; lpiae < lpiaeend; lpiae++) {
        if (!lpiae->dwAddr || IP_LOOPBACK_ADDR(lpiae->dwAddr)) {
            --g_ripcfg.dwAddrCount; continue;
        }
        lpaddr->dwIndex = lpiae->dwIndex;
        lpaddr->dwAddress = lpiae->dwAddr;
        lpaddr->dwNetmask = lpiae->dwMask;
        lpaddr->dwFlag = 0;
        lpdwend = (LPDWORD)(lpstats + 1);
        for (lpdw = (LPDWORD)lpstats; lpdw < lpdwend; lpdw++) {
            InterlockedExchange(lpdw, 0);
        }
        InterlockedExchange(&lpstats->dwAddress, lpaddr->dwAddress);
        lpaddr->lpstats = lpstats;
        lpstats++;
        lpaddr++;
    }

    FreeIPAddressTable(lpTable);

    // also update the stats address count
    InterlockedExchange(&g_ripcfg.lpStatsTable->dwAddrCount,
                        g_ripcfg.dwAddrCount);

    // if no addresses, bail out now
    if (g_ripcfg.dwAddrCount == 0) {
        dbgprintf("no IP addresses available for routing");
        return NO_ERROR;
    }

    // open sockets for each interface we have, and set options on the sockets
    dwErr = LoadAddressSockets();
    return dwErr;
}

//-------------------------------------------------------------------
// Function:    InitializeStatsTable
//
// Creates a mapping of our statistics table in shareable memory
// so interested processes can examine RIP's behavior.
//-------------------------------------------------------------------
DWORD InitializeStatsTable() {
    DWORD dwErr;

    g_ripcfg.lpStatsTable = NULL;


    // set up a pointer to the memory
    g_ripcfg.lpStatsTable = HeapAlloc(GetProcessHeap(), 0,
                                      sizeof(RIP_STATISTICS));

    if (g_ripcfg.lpStatsTable == NULL) {

        dwErr = ERROR_NOT_ENOUGH_MEMORY;
        dbgprintf( "InitializeStatsTable failed with error %x\n", dwErr );
        RipLogError( RIPLOG_ADDR_ALLOC_FAILED, 0, NULL, dwErr );

        return dwErr;
    }

    ZeroMemory(g_ripcfg.lpStatsTable, sizeof(RIP_STATISTICS));

    return 0;
}


VOID CleanupStatsTable() {
    if (g_ripcfg.lpStatsTable != NULL) {
        InterlockedExchange(&g_ripcfg.lpStatsTable->dwAddrCount, 0);
        HeapFree(GetProcessHeap(), 0, g_ripcfg.lpStatsTable);
        g_ripcfg.lpStatsTable = NULL;
    }
}


//--------------------------------------------------------------------------
// Function:    LoadAddressSockets
//
// Opens, configures, and binds sockets for each address in the table
//--------------------------------------------------------------------------
DWORD LoadAddressSockets() {
    IN_ADDR addr;
    CHAR szAddress[24] = {0};
    CHAR *ppszArgs[] = { szAddress };
    CHAR *pszTemp;
    SOCKADDR_IN sinsock;
    DWORD dwOption, dwErr;
    LPRIP_ADDRESS lpaddr, lpend;
    struct ip_mreq imOption;

    lpend = g_ripcfg.lpAddrTable + g_ripcfg.dwAddrCount;
    for (lpaddr = g_ripcfg.lpAddrTable; lpaddr < lpend; lpaddr++) {

        if ((lpaddr->dwFlag & ADDRFLAG_DISABLED) != 0) {
            continue;
        }

        addr.s_addr = lpaddr->dwAddress;
        pszTemp = inet_ntoa(addr);

        if (pszTemp != NULL) {
            strcpy(szAddress, pszTemp);
        }

        lpaddr->sock = socket(AF_INET, SOCK_DGRAM, 0);
        if (lpaddr->sock == INVALID_SOCKET) {
            dwErr = WSAGetLastError();
            dbgprintf("error %d creating socket for address %s",
                      dwErr, szAddress);
            RipLogError(RIPLOG_CREATESOCK_FAILED, 1, ppszArgs,  dwErr);
            continue;
        }

        dwOption = 1;
        dwErr = setsockopt(lpaddr->sock, SOL_SOCKET, SO_BROADCAST,
                           (LPBYTE)&dwOption, sizeof(dwOption));
        if (dwErr == SOCKET_ERROR) {
            dwErr = WSAGetLastError();
            dbgprintf("error %d enabling broadcast for address %s",
                      dwErr, szAddress);
            RipLogError(RIPLOG_SET_BCAST_FAILED, 1, ppszArgs, dwErr);

            // this socket is useless if we can't broadcast on it
            closesocket(lpaddr->sock);
            lpaddr->sock = INVALID_SOCKET;
            continue;
        }

        dwOption = 1;
        dwErr = setsockopt(lpaddr->sock, SOL_SOCKET, SO_REUSEADDR,
                           (LPBYTE)&dwOption, sizeof(dwOption));
        if (dwErr == SOCKET_ERROR) {
            dwErr = WSAGetLastError();
            dbgprintf("error %d enabling reuse of address %s",
                      dwErr, szAddress);
            RipLogError(RIPLOG_SET_REUSE_FAILED, 1, ppszArgs, dwErr);
        }

        sinsock.sin_family = AF_INET;
        sinsock.sin_port = htons(RIP_PORT);
        sinsock.sin_addr.s_addr = lpaddr->dwAddress;
        dwErr = bind(lpaddr->sock, (LPSOCKADDR)&sinsock, sizeof(SOCKADDR_IN));
        if (dwErr == SOCKET_ERROR) {
            dwErr = WSAGetLastError();
            dbgprintf("error %d binding address %s to RIP port",
                      dwErr, szAddress);
            RipLogError(RIPLOG_BINDSOCK_FAILED, 1, ppszArgs, dwErr);

            closesocket(lpaddr->sock);
            lpaddr->sock = INVALID_SOCKET;
            continue;
        }
#if DBG
        dbgprintf( "socket %d bound to %s\n\n", lpaddr-> sock, inet_ntoa( *( (struct in_addr *) &(lpaddr-> dwAddress) ) ) );
#endif

        //
        // enable multicasting also
        //

        sinsock.sin_addr.s_addr = lpaddr->dwAddress;

        dwErr = setsockopt(lpaddr->sock, IPPROTO_IP, IP_MULTICAST_IF,
                           (PBYTE)&sinsock.sin_addr, sizeof(IN_ADDR));
        if (dwErr == SOCKET_ERROR) {
            dwErr = WSAGetLastError();
            dbgprintf("error %d setting interface %d (%s) as multicast",
                      dwErr, lpaddr->dwIndex, szAddress);
            RipLogError(RIPLOG_SET_MCAST_IF_FAILED, 1, ppszArgs, dwErr);

            closesocket(lpaddr->sock);
            lpaddr->sock = INVALID_SOCKET;
            continue;
        }


        //
        // join the IPRIP multicast group
        //

        imOption.imr_multiaddr.s_addr = RIP_MULTIADDR;
        imOption.imr_interface.s_addr = lpaddr->dwAddress;

        dwErr = setsockopt(lpaddr->sock, IPPROTO_IP, IP_ADD_MEMBERSHIP,
                          (PBYTE)&imOption, sizeof(imOption));
        if (dwErr == SOCKET_ERROR) {
            dwErr = WSAGetLastError();
            dbgprintf("error %d enabling multicast on interface %d (%s)",
                      dwErr, lpaddr->dwIndex, szAddress);
            RipLogError(RIPLOG_JOIN_GROUP_FAILED, 1, ppszArgs, dwErr);

            closesocket(lpaddr->sock);
            lpaddr->sock = INVALID_SOCKET;
            continue;
        }

        dwErr = WSAEventSelect(
                    lpaddr->sock,
                    g_netEvent,
                    FD_READ);
        if (dwErr == SOCKET_ERROR) {
            dwErr = WSAGetLastError();
            dbgprintf("error %d doing WSAEventSelect on interface %d (%s)",
                      dwErr, lpaddr->dwIndex, szAddress);
            RipLogError(RIPLOG_WSAEVENTSELECT_FAILED, 1, ppszArgs, dwErr);

            closesocket(lpaddr->sock);
            lpaddr->sock = INVALID_SOCKET;
            continue;
        }
            
    }

    return 0;
}



//--------------------------------------------------------------------------
// Function:    LoadRouteTable
//
// Get the transports routing table. This is called with firsttime set
// to TRUE when RIP loads. After that it is called with firsttime set
// to FALSE. Assumes the route table is locked.
//--------------------------------------------------------------------------
int LoadRouteTable(BOOL bFirstTime) {
    IN_ADDR addr;
    LPHASH_TABLE_ENTRY rt_entry;
    CHAR szDest[32] = {0};
    CHAR szNexthop[32] = {0};
    CHAR *pszTemp;
    DWORD dwRouteTimeout, dwErr, dwRouteCount;
    LPIPROUTE_ENTRY lpRouteEntryTable, lpentry, lpentend;


    dwErr = GetRouteTable(&lpRouteEntryTable, &dwRouteCount);
    if (dwErr != 0) {
        return dwErr;
    }

    dwRouteTimeout = g_params.dwRouteTimeout;

    // now prune unwanted entries, and add the others to our hash table.
    // we only load RIP, static, and SNMP routes, and for non-RIP routes
    // we set the timeout to 90 seconds,
    //
    lpentend = lpRouteEntryTable + dwRouteCount;
    for (lpentry = lpRouteEntryTable; lpentry < lpentend; lpentry++) {
        if (lpentry->ire_metric1 < METRIC_INFINITE &&
            (lpentry->ire_proto == IRE_PROTO_RIP ||
             lpentry->ire_proto == IRE_PROTO_LOCAL ||
             lpentry->ire_proto == IRE_PROTO_NETMGMT) &&
            !IP_LOOPBACK_ADDR(lpentry->ire_dest) &&
            !IP_LOOPBACK_ADDR(lpentry->ire_nexthop) &&
            !CLASSD_ADDR(lpentry->ire_dest) &&
            !CLASSE_ADDR(lpentry->ire_dest) &&
            !IsBroadcastAddress(lpentry->ire_dest) &&
            !IsDisabledLocalAddress(lpentry->ire_nexthop)) {

            rt_entry = GetRouteTableEntry(lpentry->ire_index,
                                          lpentry->ire_dest,
                                          lpentry->ire_mask);

            // If we hit low memory conditions, get out of the loop.
            //
            if (rt_entry == NULL) {
                dwErr = ERROR_OUTOFMEMORY;
                break;
            }

            // only update the route with information from
            // the system table if it is a route that was learnt
            // from the system table; this is so if it is a new route
            // or if it is an old static or SNMP-added route
            //
            if ((rt_entry->dwFlag & NEW_ENTRY) ||
                 rt_entry->dwProtocol == IRE_PROTO_LOCAL ||
                 rt_entry->dwProtocol == IRE_PROTO_NETMGMT) {

                // if the route is new and this isn't the first time
                // we have loaded the system routing table, set change flag
                //
                if (!bFirstTime && (rt_entry->dwFlag & NEW_ENTRY)) {

                    rt_entry->dwFlag |= ROUTE_CHANGE;

                    addr.s_addr = lpentry->ire_dest;
                    pszTemp = inet_ntoa(addr);

                    if (pszTemp != NULL) {
                        strcpy(szDest, pszTemp);
                    }

                    addr.s_addr = lpentry->ire_nexthop;
                    pszTemp = inet_ntoa(addr);

                    if (pszTemp != NULL) {
                        strcpy(szNexthop, pszTemp);
                    }

                    dbgprintf("new entry: dest=%s, nexthop=%s, "
                              "metric=%d, protocol=%d", szDest, szNexthop,
                              lpentry->ire_metric1, lpentry->ire_proto);
                }

                rt_entry->dwFlag &= ~NEW_ENTRY;

                // we need to reset all these parameters
                // because any of them may have changed since
                // the last time the system route table was loaded.
                //
                rt_entry->dwIndex = lpentry->ire_index;
                rt_entry->dwProtocol = lpentry->ire_proto;
                rt_entry->dwDestaddr = lpentry->ire_dest;
                rt_entry->dwNetmask = lpentry->ire_mask;
                rt_entry->dwNexthop = lpentry->ire_nexthop;
                rt_entry->dwMetric = lpentry->ire_metric1;
                if (rt_entry->dwProtocol == IRE_PROTO_RIP) {
                    rt_entry->lTimeout = (LONG)dwRouteTimeout;
                }
                else {
                    rt_entry->lTimeout = DEF_LOCALROUTETIMEOUT;
                }
                rt_entry->dwFlag &= ~GARBAGE_TIMER;
                rt_entry->dwFlag |= TIMEOUT_TIMER;

                // if our estimate is that this is a host route
                // and its mask tells us it is a host route
                // then we mark it as being a host route
                //
                if (IsHostAddress(rt_entry->dwDestaddr) &&
                    rt_entry->dwNetmask == HOSTADDR_MASK) {
                    rt_entry->dwFlag |= ROUTE_HOST;
                }
            }
        }
    }

    FreeRouteTable(lpRouteEntryTable);
    return dwErr;
}



//--------------------------------------------------------------------------
// Function:                UpdateSystemRouteTable
//
// Parameters:
//      LPHASH_TABLE_ENTRY  rt_entry    the entry to update
//      BOOL                bAdd        if true, the entry is added
//                                      otherwise, the entry is deleted
//
// Returns:     DWORD:
//
//
// Add a new route to the route table.  Note: due to MIB's use of
// the destination address as an instance number, and also due to
// TCP/IP stack allowing multiple entries for a single destination,
// an ambiguity can exist.  If there is already an entry for this
// destination.  This will have the effect of changing the existing
// entry, rather than creating a new one.
// This function assumes the address table is locked.
//--------------------------------------------------------------------------
DWORD UpdateSystemRouteTable(LPHASH_TABLE_ENTRY rt_entry, BOOL bAdd) {
    IN_ADDR addr;
    DWORD dwErr, dwRouteType;

    // never delete or update a route which was not created by RIP
    if (rt_entry->dwProtocol != IRE_PROTO_RIP) {
        return 0;
    }

    if (bAdd) {
        dwRouteType = (IsLocalAddr(rt_entry->dwNexthop) ? IRE_TYPE_DIRECT
                                                           : IRE_TYPE_INDIRECT);

#if 0
        DbgPrintf(
            "AddRoute : Protocol %x, Index %x, dest addr %x, dest mask %x\n",
            rt_entry->dwProtocol, rt_entry->dwIndex, rt_entry->dwDestaddr, rt_entry->dwNetmask
            );

        DbgPrintf(
            "Next Hop %x, Metric %x\n\n", rt_entry->dwNexthop, rt_entry->dwMetric
            );
#endif

        dwErr = AddRoute(rt_entry->dwProtocol, dwRouteType, rt_entry->dwIndex,
                         rt_entry->dwDestaddr, rt_entry->dwNetmask,
                         rt_entry->dwNexthop, rt_entry->dwMetric);
    }
    else {
        dwErr = DeleteRoute(rt_entry->dwIndex, rt_entry->dwDestaddr,
                            rt_entry->dwNetmask, rt_entry->dwNexthop);
    }

    if (dwErr == STATUS_SUCCESS) {
        if (bAdd) {
            InterlockedIncrement(
                &g_ripcfg.lpStatsTable->dwRoutesAddedToSystemTable);
        }
        else {
            InterlockedIncrement(
                &g_ripcfg.lpStatsTable->dwRoutesDeletedFromSystemTable);
        }
    }
    else {

        if (bAdd) {
            dbgprintf("error %X adding route to system table", dwErr);
            RipLogError(RIPLOG_ADD_ROUTE_FAILED, 0, NULL, dwErr);

            InterlockedIncrement(
                &g_ripcfg.lpStatsTable->dwSystemAddRouteFailures);
        }
        else {
            dbgprintf("error %X deleting route from system table", dwErr);
            RipLogError(RIPLOG_DELETE_ROUTE_FAILED, 0, NULL, dwErr);

            InterlockedIncrement(
                &g_ripcfg.lpStatsTable->dwSystemDeleteRouteFailures);
        }
    }

    return dwErr;
}



#ifndef CHICAGO

//------------------------------------------------------------------
// Function:    OpenTcp
//
// Parameters:
//      none.
//
// Opens the handle to the Tcpip driver.
//------------------------------------------------------------------
DWORD OpenTcp() {
    NTSTATUS status;
    UNICODE_STRING nameString;
    IO_STATUS_BLOCK ioStatusBlock;
    OBJECT_ATTRIBUTES objectAttributes;

    // Open the ip stack for setting routes and parps later.
    //
    // Open a Handle to the TCP driver.
    //
    RtlInitUnicodeString(&nameString, DD_TCP_DEVICE_NAME);

    InitializeObjectAttributes(&objectAttributes, &nameString,
                               OBJ_CASE_INSENSITIVE, NULL, NULL);

    status = NtCreateFile(&g_ripcfg.hTCPDriver,
                          SYNCHRONIZE | FILE_READ_DATA | FILE_WRITE_DATA,
                          &objectAttributes, &ioStatusBlock, NULL,
                          FILE_ATTRIBUTE_NORMAL,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          FILE_OPEN_IF, 0, NULL, 0);

    return (status == STATUS_SUCCESS ? 0 : ERROR_OPEN_FAILED);

}



//---------------------------------------------------------------------
// Function:        TCPQueryInformationEx
//
// Parameters:
//      TDIObjectID *ID            The TDI Object ID to query
//      void        *Buffer        buffer to contain the query results
//      LPDWORD     *BufferSize    pointer to the size of the buffer
//                                 filled in with the amount of data.
//      UCHAR       *Context       context value for the query. should
//                                 be zeroed for a new query. It will be
//                                 filled with context information for
//                                 linked enumeration queries.
//
// Returns:
//      An NTSTATUS value.
//
//  This routine provides the interface to the TDI QueryInformationEx
//      facility of the TCP/IP stack on NT.
//---------------------------------------------------------------------
DWORD TCPQueryInformationEx(LPVOID lpvInBuffer, LPDWORD lpdwInSize,
                            LPVOID lpvOutBuffer, LPDWORD lpdwOutSize) {
    NTSTATUS status;
    IO_STATUS_BLOCK isbStatusBlock;

    if (g_ripcfg.hTCPDriver == NULL) {
        OpenTcp();
    }

    status = NtDeviceIoControlFile(g_ripcfg.hTCPDriver, // Driver handle
                                   NULL,                // Event
                                   NULL,                // APC Routine
                                   NULL,                // APC context
                                   &isbStatusBlock,     // Status block
                                   IOCTL_TCP_QUERY_INFORMATION_EX,  // Control
                                   lpvInBuffer,         // Input buffer
                                   *lpdwInSize,         // Input buffer size
                                   lpvOutBuffer,        // Output buffer
                                   *lpdwOutSize);       // Output buffer size

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(g_ripcfg.hTCPDriver, TRUE, NULL);
        status = isbStatusBlock.Status;
    }

    if (status != STATUS_SUCCESS) {
        *lpdwOutSize = 0;
    }
    else {
        *lpdwOutSize = (ULONG)isbStatusBlock.Information;
    }

    return status;
}




//---------------------------------------------------------------------------
// Function:        TCPSetInformationEx
//
// Parameters:
//
//      TDIObjectID *ID         the TDI Object ID to set
//      void      *lpvBuffer    data buffer containing the information
//                              to be set
//      DWORD     dwBufferSize  the size of the data buffer.
//
//  This routine provides the interface to the TDI SetInformationEx
//  facility of the TCP/IP stack on NT.
//---------------------------------------------------------------------------
DWORD TCPSetInformationEx(LPVOID lpvInBuffer, LPDWORD lpdwInSize,
                          LPVOID lpvOutBuffer, LPDWORD lpdwOutSize) {
    NTSTATUS status;
    IO_STATUS_BLOCK isbStatusBlock;

    if (g_ripcfg.hTCPDriver == NULL) {
        OpenTcp();
    }

    status = NtDeviceIoControlFile(g_ripcfg.hTCPDriver, // Driver handle
                                   NULL,                // Event
                                   NULL,                // APC Routine
                                   NULL,                // APC context
                                   &isbStatusBlock,     // Status block
                                   IOCTL_TCP_SET_INFORMATION_EX,    // Control
                                   lpvInBuffer,         // Input buffer
                                   *lpdwInSize,         // Input buffer size
                                   lpvOutBuffer,        // Output buffer
                                   *lpdwOutSize);       // Output buffer size

    if (status == STATUS_PENDING) {
        status = NtWaitForSingleObject(g_ripcfg.hTCPDriver, TRUE, NULL);
        status = isbStatusBlock.Status;
    }

    if (status != STATUS_SUCCESS) {
        *lpdwOutSize = 0;
    }
    else {
        *lpdwOutSize = (ULONG)isbStatusBlock.Information;
    }

    return status;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\rip\tables.c ===
//****************************************************************************
//
//               Microsoft Windows NT RIP
//
//               Copyright 1995-96
//
//
//  Revision History
//
//
//  2/26/95    Gurdeep Singh Pall  Picked up from JBallard's team
//
//
//  Description: RIP Tables Manipulation Functions
//
//****************************************************************************

#include "pchrip.h"
#pragma hdrstop


//-----------------------------------------------------------------------------
// Function:    InitializeRouteTable
//
// Initializes hash table
//-----------------------------------------------------------------------------
DWORD InitializeRouteTable() {

    LPHASH_TABLE_ENTRY *lplpentry, *lplpend;

    lplpend = g_ripcfg.lpRouteTable + HASH_TABLE_SIZE;
    for (lplpentry = g_ripcfg.lpRouteTable; lplpentry < lplpend; lplpentry++) {
        *lplpentry = NULL;
    }

    return 0;
}



//-----------------------------------------------------------------------------
// Function:    GetRouteTableEntry
//
// Looks for an entry with the specified address and mask, learnt using the
// specified interface. If the entry is not found, one is created.
//-----------------------------------------------------------------------------
LPHASH_TABLE_ENTRY GetRouteTableEntry(DWORD dwIndex, DWORD dwAddress,
                                      DWORD dwNetmask) {
    INT hashval;
    IN_ADDR addr;
    LPHASH_TABLE_ENTRY rt_entry;
    LPHASH_TABLE_ENTRY prev_rt_entry;

    hashval = HASH_VALUE(dwAddress);
    ASSERT(hashval < HASH_TABLE_SIZE);

    RIP_LOCK_ROUTETABLE();

    prev_rt_entry = rt_entry = g_ripcfg.lpRouteTable[hashval];

    while (rt_entry != NULL) {
        if ((rt_entry->dwDestaddr == dwAddress) &&
            (rt_entry->dwNetmask == dwNetmask)) {
            break;
        }
        prev_rt_entry = rt_entry;
        rt_entry = rt_entry->next;
    }

    if (rt_entry == NULL) {
        // entry was not found, so allocate a new one
        rt_entry = malloc(sizeof(HASH_TABLE_ENTRY));
        if (rt_entry == NULL) {
            dbgprintf("could not allocate memory for routing-table entry");
        }
        else {
            rt_entry->next = NULL;
            rt_entry->dwFlag = NEW_ENTRY;
            rt_entry->dwIndex = dwIndex;
            rt_entry->dwProtocol = IRE_PROTO_RIP;
            rt_entry->dwDestaddr = dwAddress;
            if (prev_rt_entry != NULL) {
                rt_entry->prev = prev_rt_entry;
                prev_rt_entry->next = rt_entry;
            }
            else {
                rt_entry->prev = NULL;
                g_ripcfg.lpRouteTable[hashval] = rt_entry;
            }

            InterlockedIncrement(&g_ripcfg.lpStatsTable->dwRouteCount);
        }
    }

    RIP_UNLOCK_ROUTETABLE();

//    check_rt_entries();

    return rt_entry;
}



//-----------------------------------------------------------------------------
// Function:    RouteTableEntryExists
//
// This function returns TRUE if an entry to the specified address
// exists with the specified index.
//-----------------------------------------------------------------------------
BOOL RouteTableEntryExists(DWORD dwIndex, DWORD dwAddress) {
    INT hashval;
    LPHASH_TABLE_ENTRY rt_entry;

    hashval = HASH_VALUE(dwAddress);

    RIP_LOCK_ROUTETABLE();

    rt_entry = g_ripcfg.lpRouteTable[hashval];
    while (rt_entry != NULL) {
        if (rt_entry->dwDestaddr == dwAddress) {
            break;
        }

        rt_entry = rt_entry->next;
    }

    RIP_UNLOCK_ROUTETABLE();

    return (rt_entry == NULL ? FALSE : TRUE);
}



//-----------------------------------------------------------------------------
// Function:    AddZombieRouteTableEntry
//
// This function adds a special route-table entry known as a Zombie
// route entry. In the case of border gateways which summarize attached
// subnets and send a single entry for the network, and in the case
// of routers whose interfaces have different subnet masks, the destination
// that RIP will send will be different from the destination in RIP's table.
// This makes it possible for the destination to get bounced back at RIP by
// some other router; RIP would then add an entry for the bogus route, and
// advertise the route back again, and a count to infinity would commence.
//
// Zombie entries exist to prevent this from happening:
//      they have metrics of zero, so they will not be replaced
//          by RIP-learnt routes (all of which have a metric of at least 1);
//      they are excluded from updates sent
//      they are excluded from updates written to the system routing table
//      they can be timed-out
// The above conditions ensure that zombies do not interfere with the working
// of RIP, EXCEPT in the case where they prevent RIP from adding a normal entry
// for a route which was summarized in a previous update and which is therefore
// not really a RIP route at all.
//-----------------------------------------------------------------------------
DWORD AddZombieRouteTableEntry(LPRIP_ADDRESS lpaddr, DWORD dwNetwork,
                               DWORD dwNetmask) {
    LPHASH_TABLE_ENTRY rt_entry;

    rt_entry = GetRouteTableEntry(lpaddr->dwIndex, dwNetwork, dwNetmask);
    if (rt_entry == NULL) {
        dbgprintf("could not make entry for network in routing table");
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    // don't want to overwrite an existing entry, if there is one
    if ((rt_entry->dwFlag & NEW_ENTRY) == 0 &&
        (rt_entry->dwFlag & ROUTE_ZOMBIE) == 0) {
        return 0;
    }

    // since the only reason this entry exists is because a
    // subnet we are sending is being summarized or truncated, we have to
    // set up values to make sure this entry is not considered in
    // normal processing; (e.g. metric of 0 to make sure it is not
    // replaced by a RIP-learnt route)
    // however, we do allow it to be timed out
    rt_entry->dwIndex = (DWORD)~0;
    rt_entry->dwFlag = (GARBAGE_TIMER | ROUTE_ZOMBIE);
    rt_entry->lTimeout = (LONG)DEF_GARBAGETIMEOUT;
    rt_entry->dwDestaddr = dwNetwork;
    rt_entry->dwNetmask = dwNetmask;
    rt_entry->dwNexthop = 0;
    rt_entry->dwProtocol = IRE_PROTO_OTHER;
    rt_entry->dwMetric = 0;
    return 0;
}


//-----------------------------------------------------------------------------
// Function:    DeleteRouteTableEntry
//
// This function removes a route from the route table. Assumes
// that the route table is already locked
//-----------------------------------------------------------------------------
VOID DeleteRouteTableEntry(int pos, LPHASH_TABLE_ENTRY rt_entry) {
    IN_ADDR addr;
    CHAR szDest[32] = {0};
    CHAR* pszTemp;

    if (rt_entry == NULL) { return; }

    addr.s_addr = rt_entry->dwDestaddr;
    pszTemp = inet_ntoa(addr);

    if (pszTemp != NULL) {
        strcpy(szDest, pszTemp);
    }

    dbgprintf("Removing entry %d with destination IP address %s "
              "from interface %d in RIP routing table",
              pos, szDest, rt_entry->dwIndex);

    if (rt_entry->prev != NULL) {
        rt_entry->prev->next = rt_entry->next;
        if (rt_entry->next != NULL) {
            rt_entry->next->prev = rt_entry->prev;
        }
    }
    else {
        g_ripcfg.lpRouteTable[pos] = rt_entry->next;
        if (rt_entry->next != NULL) {
            rt_entry->next->prev = NULL;
        }
    }

    InterlockedDecrement(&g_ripcfg.lpStatsTable->dwRouteCount);

    // delete the route from the IP table as well
    if ((rt_entry->dwFlag & ROUTE_ZOMBIE) == 0) {
        UpdateSystemRouteTable(rt_entry, FALSE);
    }

    free(rt_entry);

    return;
}


void check_rt_entries() {
    int pos;
    LPHASH_TABLE_ENTRY rt_entry;
    LPHASH_TABLE_ENTRY prev_rt_entry = NULL ;

    RIP_LOCK_ROUTETABLE();
    for (pos = 0; pos < HASH_TABLE_SIZE; pos++) {
        rt_entry = g_ripcfg.lpRouteTable[pos];
        while (rt_entry != NULL) {
            if (rt_entry == rt_entry->next) {
                DebugBreak();
            }
            if (rt_entry == rt_entry->prev) {
                DebugBreak();
            }
            if (rt_entry->prev != NULL) {
                if (rt_entry->prev != prev_rt_entry) {
                    DebugBreak();
                }
            }
            prev_rt_entry = rt_entry;
            rt_entry = rt_entry->next;
        }
    }

    RIP_UNLOCK_ROUTETABLE();
    return;
}


//-----------------------------------------------------------------------------
// Function:    ProcessRouteTableChanges
//
// Process the changes, updating metrics for routes. If necessary,
// this function will trigger an update.
// Assumes address table is locked.
//-----------------------------------------------------------------------------
void ProcessRouteTableChanges(BOOL bTriggered) {
    int pos;
    BOOL bNeedTriggeredUpdate;
    LPHASH_TABLE_ENTRY rt_entry;
    DWORD dwLastTrigger, dwMsecsTillUpdate;
    DWORD dwSystime, dwSilentRIP, dwTrigger, dwTriggerFrequency;

//    check_rt_entries();

    RIP_LOCK_PARAMS();

    dwSilentRIP = g_params.dwSilentRIP;
    dwTrigger = g_params.dwTriggeredUpdates;
    dwTriggerFrequency = g_params.dwMaxTriggerFrequency;

    RIP_UNLOCK_PARAMS();


    RIP_LOCK_ROUTETABLE();

    bNeedTriggeredUpdate = FALSE;
    for (pos = 0; pos < HASH_TABLE_SIZE; pos++) {
        rt_entry = g_ripcfg.lpRouteTable[pos];
        while (rt_entry != NULL) {
            if ((rt_entry->dwFlag & ROUTE_CHANGE) == 0 &&
                (rt_entry->dwFlag & ROUTE_UPDATE) == 0) {
                rt_entry = rt_entry->next;
                continue;
            }

            if ((rt_entry->dwFlag & ROUTE_CHANGE) != 0) {
                bNeedTriggeredUpdate = TRUE;
            }

            // update if this is a RIP-learnt route
            if (rt_entry->dwProtocol == IRE_PROTO_RIP) {
                UpdateSystemRouteTable(rt_entry, TRUE);
            }

            // clear the update flag, now that the route
            // has been updated in the system table
            rt_entry->dwFlag &= ~ROUTE_UPDATE;
            rt_entry = rt_entry->next;
        }
    }

    dwSystime = GetTickCount();
    dwLastTrigger = g_ripcfg.dwLastTriggeredUpdate;
    dwMsecsTillUpdate = g_ripcfg.dwMillisecsTillFullUpdate;

    // adjust the times if the clock has wrapped around past zero
    if (dwSystime < dwLastTrigger) {
        dwSystime += (DWORD)~0 - dwLastTrigger;
        dwLastTrigger = 0;
    }

    // we generate a triggered update iff:
    //   1. this call was made because of a response received
    //   2. we are not in silent RIP mode
    //   3. triggered updates are not disabled
    //   4. the minimum configured interval between triggered updates
    //      has elapsed
    //   5. the time till the next regular update is greater than the
    //      configured minimum interval between triggered updates
    // if the system clock has wrapped around to zero, skip the condition 4;
    // we know the clock has wrapped around if dwSystime is less than
    // the last triggered update time

    if (bTriggered && bNeedTriggeredUpdate &&
        dwSilentRIP == 0 &&
        dwTrigger != 0 &&
        (dwSystime - dwLastTrigger) >= dwTriggerFrequency &&
        dwMsecsTillUpdate >= dwTriggerFrequency) {

        // update the last triggered update time
        InterlockedExchange(&g_ripcfg.dwLastTriggeredUpdate, GetTickCount());

        // send out the routing table, but only include changes
        BroadcastRouteTableContents(bTriggered, TRUE);

    }

    ClearChangeFlags();

    InterlockedExchange(&g_ripcfg.dwRouteChanged, 0);

    RIP_UNLOCK_ROUTETABLE();

    return;
}



//-----------------------------------------------------------------------------
// Function:    ClearChangeFlags
//
// This function clears all the change flags in the table after an update.
// Assumes that the routing table is locked.
//-----------------------------------------------------------------------------
VOID ClearChangeFlags() {
    int pos;
    LPHASH_TABLE_ENTRY rt_entry;

    for (pos = 0; pos < HASH_TABLE_SIZE; pos++) {
        rt_entry = g_ripcfg.lpRouteTable[pos];
        while (rt_entry != NULL) {
            rt_entry->dwFlag &= ~ROUTE_CHANGE;
            rt_entry = rt_entry->next;
        }
    }

}



//-----------------------------------------------------------------------------
// Function:    DoTimedOperations()
//
// This function updates the routing table entries' timers periodically,
// and handles deletion of timed-out routes.
//-----------------------------------------------------------------------------
VOID DoTimedOperations(DWORD dwMillisecsSinceLastCall) {
    int pos;
    IN_ADDR addr;
    DWORD dwGarbageTimeout;
    HASH_TABLE_ENTRY *rt_entry;
    HASH_TABLE_ENTRY *rt_entry_next;
    char szDest[32] = {0};
    char szNexthop[32] = {0};
    char* pszTemp;

    // read the garbage timeout and adjust for number of times
    // this routine will be called over the interval
    RIP_LOCK_PARAMS();

    dwGarbageTimeout = g_params.dwGarbageTimeout;

    RIP_UNLOCK_PARAMS();


    RIP_LOCK_ROUTETABLE();

    for (pos = 0; pos < HASH_TABLE_SIZE; pos++) {
        rt_entry = g_ripcfg.lpRouteTable[pos];
        while (rt_entry != NULL) {
            rt_entry_next = rt_entry->next;

            if (rt_entry->lTimeout > (LONG)dwMillisecsSinceLastCall) {
                rt_entry->lTimeout -= dwMillisecsSinceLastCall;
            }
            else {

                // timeout is all the way down

                addr.s_addr = rt_entry->dwDestaddr;
                pszTemp = inet_ntoa(addr);

                if (pszTemp != NULL) {
                    strcpy(szDest, pszTemp);
                }

                addr.s_addr = rt_entry->dwNexthop;
                pszTemp = inet_ntoa(addr);

                if (pszTemp != NULL) {
                    strcpy(szNexthop, pszTemp);
                }

                if (rt_entry->dwFlag & TIMEOUT_TIMER) {

                    dbgprintf("Timing out route to %s over netcard %d, "
                              "with next hop of %s",
                              szDest, rt_entry->dwIndex, szNexthop);

                    rt_entry->lTimeout = (LONG)dwGarbageTimeout;
                    rt_entry->dwFlag &= ~TIMEOUT_TIMER;
                    rt_entry->dwFlag |= (GARBAGE_TIMER | ROUTE_CHANGE);
                    rt_entry->dwMetric = METRIC_INFINITE;
                    InterlockedExchange(&g_ripcfg.dwRouteChanged, 1);
                }
                else
                if (rt_entry->dwFlag & GARBAGE_TIMER) {

                    // time to delete this

                    addr.s_addr = rt_entry->dwDestaddr;
                    pszTemp = inet_ntoa(addr);

                    if (pszTemp != NULL) {
                        strcpy(szDest, pszTemp);
                    }

                    dbgprintf("Deleting route to %s over netcard %d "
                              "with next hop of %s",
                               szDest, rt_entry->dwIndex, szNexthop);

                    DeleteRouteTableEntry(pos, rt_entry);
                }
            }

            rt_entry = rt_entry_next;
        }
    }

    RIP_UNLOCK_ROUTETABLE();

    return;
}



DWORD BroadcastRouteTableRequests() {
    INT iErr;
    DWORD dwSize;
    LPRIP_ENTRY lpentry;
    SOCKADDR_IN destaddr;
    LPRIP_HEADER lpheader;
    BYTE buffer[RIP_MESSAGE_SIZE];
    LPRIP_ADDRESS lpaddr, lpend;

    RIP_LOCK_ADDRTABLE();

    if (g_ripcfg.dwAddrCount > 0) {

        destaddr.sin_family = AF_INET;
        destaddr.sin_port = htons(RIP_PORT);

        lpheader = (LPRIP_HEADER)buffer;
        lpheader->chCommand = RIP_REQUEST;
        lpheader->wReserved = 0;

        lpentry = (LPRIP_ENTRY)(buffer + sizeof(RIP_HEADER));
        lpentry->dwAddress = 0;
        lpentry->wReserved = 0;
        lpentry->wAddrFamily = 0;
        lpentry->dwReserved1 = 0;
        lpentry->dwReserved2 = 0;
        lpentry->dwMetric = htonl(METRIC_INFINITE);

        dwSize = sizeof(RIP_HEADER) + sizeof(RIP_ENTRY);

        lpend = g_ripcfg.lpAddrTable + g_ripcfg.dwAddrCount;
        for (lpaddr = g_ripcfg.lpAddrTable; lpaddr < lpend; lpaddr++) {

            // skip disabled interfaces
            if (lpaddr->sock == INVALID_SOCKET) {
                continue;
            }


            // send out broadcast requests as RIPv1 packets
            lpheader->chVersion = 1;

            // set the destination to the broadcast address on this subnet
            destaddr.sin_addr.s_addr = (lpaddr->dwAddress |
                                        ~lpaddr->dwNetmask);

            iErr = sendto(lpaddr->sock, buffer, dwSize, 0,
                          (LPSOCKADDR)&destaddr, sizeof(SOCKADDR_IN));
            if (iErr == SOCKET_ERROR) {
                dbgprintf("error %d occurred broadcasting route table request "
                          "on netcard %d using IP address %s",
                          WSAGetLastError(), lpaddr->dwIndex,
                          inet_ntoa(destaddr.sin_addr));

                InterlockedIncrement(&lpaddr->lpstats->dwSendFailures);

                RipLogInformation(RIPLOG_SENDTO_FAILED, 0, NULL, WSAGetLastError());
            }
            else {
                InterlockedIncrement(&lpaddr->lpstats->dwRequestsSent);
            }


            // send out multicast requests as RIPv2 packets
            lpheader->chVersion = 2;

            // set the destination to the RIP multicast address on this net
            destaddr.sin_addr.s_addr = RIP_MULTIADDR;

            iErr = sendto(lpaddr->sock, buffer, dwSize, 0,
                          (LPSOCKADDR)&destaddr, sizeof(SOCKADDR_IN));
            if (iErr == SOCKET_ERROR) {
                dbgprintf("error %d occurred multicasting route table request "
                          "on netcard %d using IP address %s",
                          WSAGetLastError(), lpaddr->dwIndex,
                          inet_ntoa(destaddr.sin_addr));

                InterlockedIncrement(&lpaddr->lpstats->dwSendFailures);

                RipLogInformation(RIPLOG_SENDTO_FAILED, 0, NULL, WSAGetLastError());
            }
            else {
                InterlockedIncrement(&lpaddr->lpstats->dwRequestsSent);
            }
        }
    }

    RIP_UNLOCK_ADDRTABLE();

    return 0;
}



VOID InitUpdateBuffer(BYTE buffer[], LPRIP_ENTRY *lplpentry, LPDWORD lpdwSize) {
    LPRIP_HEADER lpheader;

    lpheader = (LPRIP_HEADER)buffer;
    lpheader->chCommand = RIP_RESPONSE;
    lpheader->chVersion = 1;
    lpheader->wReserved = 0;
    *lplpentry = (LPRIP_ENTRY)(buffer + sizeof(RIP_HEADER));
    *lpdwSize= sizeof(RIP_HEADER);
}



VOID AddUpdateEntry(BYTE buffer[], LPRIP_ENTRY *lplpentry, LPDWORD lpdwSize,
                    LPRIP_ADDRESS lpaddr, LPSOCKADDR_IN lpdestaddr,
                    DWORD dwAddress, DWORD dwMetric) {
    DWORD length;
    LPRIP_ENTRY lpentry;

#ifdef ROUTE_FILTERS

    DWORD dwInd = 0;


    //
    // run the route thru' the announce filters
    //

    if ( g_prfAnnounceFilters != NULL )
    {
        for ( dwInd = 0; dwInd < g_prfAnnounceFilters-> dwCount; dwInd++ )
        {
            if ( g_prfAnnounceFilters-> pdwFilter[ dwInd ] == dwAddress )
            {
                dbgprintf(
                    "Skipped route %s with next hop %s because"
                    "of announce filter",
                    inet_ntoa( *( (struct in_addr*)
                        &( g_prfAnnounceFilters-> pdwFilter[ dwInd ] ) ))
                    );

                return;
            }
        }
    }
#endif


    if ((*lpdwSize + sizeof(RIP_ENTRY)) > RIP_MESSAGE_SIZE) {
        length = sendto(lpaddr->sock, buffer, *lpdwSize, 0,
                        (LPSOCKADDR)lpdestaddr, sizeof(SOCKADDR_IN));
        if (length == SOCKET_ERROR || length < *lpdwSize) {
            dbgprintf("error %d sending update", WSAGetLastError());

            InterlockedIncrement(&lpaddr->lpstats->dwSendFailures);

            RipLogInformation(RIPLOG_SENDTO_FAILED, 0, NULL, 0);
        }
        else {
            InterlockedIncrement(&lpaddr->lpstats->dwResponsesSent);
        }

        // reinitialize the buffer that was passed in
        InitUpdateBuffer(buffer, lplpentry, lpdwSize);
    }

    lpentry = *lplpentry;
    lpentry->wReserved = 0;
    lpentry->wAddrFamily = htons(AF_INET);
    lpentry->dwAddress = dwAddress;
    lpentry->dwReserved1 = 0;
    lpentry->dwReserved2 = 0;
    lpentry->dwMetric = htonl(dwMetric);

    *lpdwSize += sizeof(RIP_ENTRY);

    ++(*lplpentry);
}



VOID FinishUpdateBuffer(BYTE buffer[], LPDWORD lpdwSize,
                        LPRIP_ADDRESS lpaddr, LPSOCKADDR_IN lpdestaddr) {
    DWORD length;

    // do nothing if no entries were added
    if (*lpdwSize <= sizeof(RIP_HEADER)) {
        return;
    }

    length = sendto(lpaddr->sock, buffer, *lpdwSize, 0,
                         (LPSOCKADDR)lpdestaddr, sizeof(SOCKADDR_IN));
    if (length == SOCKET_ERROR || length < *lpdwSize) {
        dbgprintf("error %d sending update", GetLastError());

        InterlockedIncrement(&lpaddr->lpstats->dwSendFailures);

        RipLogInformation(RIPLOG_SENDTO_FAILED, 0, NULL, 0);
    }
    else {
        InterlockedIncrement(&lpaddr->lpstats->dwResponsesSent);
    }
}



//-------------------------------------------------------------------------
// the following struct and three functions are used
// to implement subnet hiding. when a subnet is summarized,
// the network which is its summary is added to a list using the
// function AddToAddressList. When another subnet of the same network
// needs to be summarized, it is first searched for using the function
// IsInAddressList, and if it is found, it is not re-advertised.
// After the update is over, the list is freed.
//-------------------------------------------------------------------------
typedef struct _ADDRESS_LIST {
    struct _ADDRESS_LIST   *next;
    DWORD                   dwAddress;
    DWORD                   dwNetmask;
} ADDRESS_LIST, *LPADDRESS_LIST;


DWORD AddToAddressList(LPADDRESS_LIST *lplpList, DWORD dwAddress,
                       DWORD dwNetmask) {
    LPADDRESS_LIST lpal;

    lpal = HeapAlloc(GetProcessHeap(), 0, sizeof(ADDRESS_LIST));
    if (lpal == NULL) { return ERROR_NOT_ENOUGH_MEMORY; }

    lpal->dwAddress = dwAddress;
    lpal->dwNetmask = dwNetmask;
    lpal->next = *lplpList;
    *lplpList = lpal;

    return 0;
}

BOOL IsInAddressList(LPADDRESS_LIST lpList, DWORD dwAddress) {
    LPADDRESS_LIST lpal;

    for (lpal = lpList; lpal != NULL; lpal = lpal->next) {
        if (lpal->dwAddress == dwAddress) {
            return TRUE;
        }
    }

    return FALSE;
}

VOID FreeAddressList(LPADDRESS_LIST lpList) {
    LPADDRESS_LIST lpal, lpnext;

    for (lpal = lpList; lpal != NULL; lpal = lpnext) {
        lpnext = lpal->next;
        HeapFree(GetProcessHeap(), 0, lpal);
    }
}



//-----------------------------------------------------------------------------
// Function:    TransmitRouteTableContents
//
// Sends the route tables contents, either as unicast or broadcast
// depending on the destination address specified. This function assumes
// that the address table is locked.
//-----------------------------------------------------------------------------
VOID TransmitRouteTableContents(LPRIP_ADDRESS lpaddr,
                                LPSOCKADDR_IN lpdestaddr,
                                BOOL bChangesOnly) {
    INT pos;
    DWORD dwSize;
    LPADDRESS_LIST lpnet, lpSummaries;
    LPRIP_ENTRY lpentry;
    LPHASH_TABLE_ENTRY rt_entry;
    BYTE buffer[RIP_MESSAGE_SIZE];
    DWORD dwNexthopNetaddr, dwDestNetaddr;
    DWORD dwSplit, dwPoison, dwHost, dwDefault;
    DWORD dwDestNetclassMask, dwEntryNetclassMask;
    DWORD dwEntryAddr, dwDestNetclassAddr, dwEntryNetclassAddr;

    dwDestNetaddr = (lpdestaddr->sin_addr.s_addr &
                     SubnetMask(lpdestaddr->sin_addr.s_addr));
    dwDestNetclassMask = NetclassMask(lpdestaddr->sin_addr.s_addr);
    dwDestNetclassAddr = (lpdestaddr->sin_addr.s_addr & dwDestNetclassMask);

    RIP_LOCK_PARAMS();
    dwHost = g_params.dwAnnounceHost;
    dwSplit = g_params.dwSplitHorizon;
    dwPoison = g_params.dwPoisonReverse;
    dwDefault = g_params.dwAnnounceDefault;
    RIP_UNLOCK_PARAMS();

    InitUpdateBuffer(buffer, &lpentry, &dwSize);


    // start out with an empty list of summarized networks
    lpSummaries = NULL;


    RIP_LOCK_ROUTETABLE();


#ifdef ROUTE_FILTERS
    RIP_LOCK_ANNOUNCE_FILTERS();
#endif

    for (pos = 0; pos < HASH_TABLE_SIZE; pos++) {
        rt_entry = g_ripcfg.lpRouteTable[pos];
        while (rt_entry != NULL) {

            // if we're supposed to only send changes
            // and this entry hasn't changed, skip it
            if (bChangesOnly &&
                (rt_entry->dwFlag & ROUTE_CHANGE) == 0) {

                rt_entry = rt_entry->next;
                continue;
            }

            // ignore network summary entries
            if ((rt_entry->dwFlag & ROUTE_ZOMBIE) != 0) {
                rt_entry = rt_entry->next;
                continue;
            }

            // copy the destination to be advertised
            dwEntryAddr = rt_entry->dwDestaddr;

            // if this is the route to the network for the outgoing interface
            // don't send it
            //
            if (dwEntryAddr == dwDestNetaddr) {
                rt_entry = rt_entry->next;
                continue;
            }

            // if host route announcements are disabled,
            // and this is a host route, don't add this entry
            if (dwHost == 0 &&
                (rt_entry->dwFlag & ROUTE_HOST) != 0) {
                rt_entry = rt_entry->next;
                continue;
            }

            // if default route announcements are disabled
            // and this is a default route, don't add this entry
            if (dwDefault == 0 &&
                dwEntryAddr == 0) {
                rt_entry = rt_entry->next;
                continue;
            }


            // if this update is being sent to a network different
            // from the network of the destination in the route entry,
            // or if the destination was truncated due to different
            // subnetmask lengths, summarize the route entry's destination,
            // also, if the entry is network route, we need
            // to remember it so we don't re-advertise it when
            // summarizing subnets

            dwEntryNetclassMask = NetclassMask(dwEntryAddr);
            dwEntryNetclassAddr = (dwEntryAddr & dwEntryNetclassMask);

            // special case exception is default route
            if (dwEntryAddr != 0 &&
                (dwDestNetclassAddr != dwEntryNetclassAddr ||
                 dwEntryAddr == dwEntryNetclassAddr)) {

                // if the network for the entry has already been
                // advertised, don't advertise it again
                if (IsInAddressList(lpSummaries, dwEntryNetclassAddr)) {

                    rt_entry = rt_entry->next;
                    continue;
                }

                // add an entry for the network to the list
                // of networks used as summaries so far
                AddToAddressList(&lpSummaries, dwEntryNetclassAddr,
                                 dwEntryNetclassMask);

                // now we will advertise the NETWORK, not the original address
                dwEntryAddr = dwEntryNetclassAddr;
            }
            else
            if (dwEntryAddr != 0 &&
                (rt_entry->dwFlag & ROUTE_HOST) == 0 &&
                 lpaddr->dwNetmask < rt_entry->dwNetmask) {

                // this is neither a host route nor a default route
                // and the subnet mask on the outgoing interface
                // is shorter than the one for the entry, so the entry
                // must be truncated so it is not considered a host route
                // by the routers who will receive this update
                // the comparison assumes netmasks are in network byte order

                dwEntryAddr &= lpaddr->dwNetmask;

                // skip the entry if the truncated destination
                // turns out to have been advertised already
                if (IsInAddressList(lpSummaries, dwEntryAddr)) {

                    rt_entry = rt_entry->next;
                    continue;
                }

                AddToAddressList(&lpSummaries, dwEntryAddr, lpaddr->dwNetmask);
            }

            // we only do poisoned-reverse/split-horizon on RIP routes
            //
            if (dwSplit == 0 ||
                rt_entry->dwProtocol != IRE_PROTO_RIP) {

                // always add the entry in this case;
                // we increment the metric for a static route
                // when sending it on interfaces other than
                // the interface to which the route is attached

                if (lpaddr->dwIndex == rt_entry->dwIndex) {
                    AddUpdateEntry(buffer, &lpentry, &dwSize, lpaddr,
                                   lpdestaddr, dwEntryAddr,
                                   rt_entry->dwMetric);
                }
                else {
                    AddUpdateEntry(buffer, &lpentry, &dwSize, lpaddr,
                                   lpdestaddr, dwEntryAddr,
                                   rt_entry->dwMetric + 1);
                }
            }
            else
            if (dwSplit != 0 && dwPoison == 0) {

                // don't advertise the route if this update is
                // being sent to the network from which we learnt
                // the route; we can tell by looking at the nexthop,
                // and comparing its subnet number to the subnet number
                // of the destination network

                dwNexthopNetaddr = (rt_entry->dwNexthop &
                                    SubnetMask(rt_entry->dwNexthop));

                if (dwNexthopNetaddr != dwDestNetaddr) {
                    AddUpdateEntry(buffer, &lpentry, &dwSize, lpaddr,
                                   lpdestaddr, dwEntryAddr,
                                   rt_entry->dwMetric);
                }
            }
            else
            if (dwSplit != 0 && dwPoison != 0) {

                // if the update is being sent to the network from which
                // the route was learnt to begin with, poison any routing loops
                // by saying the metric is infinite

                dwNexthopNetaddr = (rt_entry->dwNexthop &
                                    SubnetMask(rt_entry->dwNexthop));

                if (dwNexthopNetaddr == dwDestNetaddr) {
                    // this is the case which calls for poison reverse

                    AddUpdateEntry(buffer, &lpentry, &dwSize, lpaddr,
                                   lpdestaddr, dwEntryAddr,
                                   METRIC_INFINITE);
                }
                else {
                    AddUpdateEntry(buffer, &lpentry, &dwSize, lpaddr,
                                   lpdestaddr, dwEntryAddr,
                                   rt_entry->dwMetric);
                }
            }

            rt_entry = rt_entry->next;
        }
    }

    // remember the summarized networks in case some router
    // broadcasts them back at us
    for (lpnet = lpSummaries; lpnet != NULL; lpnet = lpnet->next) {
        AddZombieRouteTableEntry(lpaddr, lpnet->dwAddress, lpnet->dwNetmask);
    }


#ifdef ROUTE_FILTERS

    RIP_UNLOCK_ANNOUNCE_FILTERS();
#endif

    RIP_UNLOCK_ROUTETABLE();

    // done with the list of summarized networks
    FreeAddressList(lpSummaries);

    FinishUpdateBuffer(buffer, &dwSize, lpaddr, lpdestaddr);
}




//-----------------------------------------------------------------------------
// Function:    BroadcastRouteTableContents
//
// This function handles both triggered updates and regular updates.
// Depending on the value of bChangesOnly, it may exclude unchanged routes
// from the update.
// Assumes the address table is locked.
//-----------------------------------------------------------------------------
DWORD BroadcastRouteTableContents(BOOL bTriggered, BOOL bChangesOnly) {
    SOCKADDR_IN destaddr;
    LPRIP_ADDRESS lpaddr, lpend;


    destaddr.sin_family = AF_INET;
    destaddr.sin_port = htons(RIP_PORT);

    lpend = g_ripcfg.lpAddrTable + g_ripcfg.dwAddrCount;
    for (lpaddr = g_ripcfg.lpAddrTable; lpaddr < lpend; lpaddr++) {
        if (lpaddr->sock == INVALID_SOCKET) {
            continue;
        }

        destaddr.sin_addr.s_addr = (lpaddr->dwAddress | ~lpaddr->dwNetmask);
        TransmitRouteTableContents(lpaddr, &destaddr, bChangesOnly);

        if (bTriggered) {
            InterlockedIncrement(&lpaddr->lpstats->dwTriggeredUpdatesSent);
        }
    }


    return 0;
}


#ifndef CHICAGO
#define POS_REGEVENT    0
#define POS_TRIGEVENT   1
#define POS_STOPEVENT   2
#define POS_LASTEVENT   3
#else
#define POS_TRIGEVENT   0
#define POS_STOPEVENT   1
#define POS_LASTEVENT   2
#endif

#define DEF_TIMEOUT     (10 * 1000)


DWORD UpdateThread(LPVOID Param) {
    DWORD dwErr;
    HKEY hkeyParams;
    HANDLE hEvents[POS_LASTEVENT];
    LONG lMillisecsTillFullUpdate, lMillisecsTillRouteRefresh;
    DWORD dwWaitTimeout, dwGlobalTimeout;
    DWORD dwTickCount, dwTickCountBeforeWait, dwTickCountAfterWait;
    DWORD dwUpdateFrequency, dwSilentRIP, dwMillisecsSinceTimedOpsDone;

#ifndef CHICAGO
    dwErr =  RegOpenKey(HKEY_LOCAL_MACHINE, REGKEY_RIP_PARAMS, &hkeyParams);
    if (dwErr == ERROR_SUCCESS) {
        hEvents[POS_REGEVENT] = CreateEvent(NULL,FALSE,FALSE,NULL);
        if (hEvents[POS_REGEVENT] != NULL) {
            dwErr = RegNotifyChangeKeyValue(hkeyParams, FALSE,
                                            REG_NOTIFY_CHANGE_LAST_SET |
                                            REG_NOTIFY_CHANGE_ATTRIBUTES |
                                            REG_NOTIFY_CHANGE_NAME,
                                            hEvents[POS_REGEVENT], TRUE);
        }
    }
#endif

    hEvents[POS_STOPEVENT] = g_stopEvent;
    hEvents[POS_TRIGEVENT] = g_triggerEvent;

    // get the update frequency, in seconds
    RIP_LOCK_PARAMS();
    dwSilentRIP = g_params.dwSilentRIP;
    dwUpdateFrequency = g_params.dwUpdateFrequency;
    dwGlobalTimeout = g_params.dwMaxTimedOpsInterval;
    RIP_UNLOCK_PARAMS();

    lMillisecsTillFullUpdate = (LONG)dwUpdateFrequency;
    lMillisecsTillRouteRefresh = DEF_GETROUTEFREQUENCY;


    dwMillisecsSinceTimedOpsDone = 0;

    while (1) {

        // set the time till the next full update
        InterlockedExchange(&g_ripcfg.dwMillisecsTillFullUpdate,
                            (DWORD)lMillisecsTillFullUpdate);

        // set the time we need the next wait to last;
        // it has to be the minimum of the times till there is work to do;
        // uses a two-comparison sort to find the smallest of three items
        dwWaitTimeout = dwGlobalTimeout;
        if (dwWaitTimeout > (DWORD)lMillisecsTillFullUpdate) {
            dwWaitTimeout = lMillisecsTillFullUpdate;
        }
        if (dwWaitTimeout > (DWORD)lMillisecsTillRouteRefresh) {
            dwWaitTimeout = lMillisecsTillRouteRefresh;
        }


        // get the time before entering the wait
        dwTickCountBeforeWait = GetTickCount();

        // enter the wait
        //---------------
        dwErr = WaitForMultipleObjects(POS_LASTEVENT, hEvents, FALSE,
                                       dwWaitTimeout) ;

        dwTickCountAfterWait = GetTickCount();

        // we have to find out how long the wait lasted, taking care
        // in case the system timer wrapped around to zero
        if (dwTickCountAfterWait < dwTickCountBeforeWait) {
            dwTickCountAfterWait += (DWORD)~0 - dwTickCountBeforeWait;
            dwTickCountBeforeWait = 0;
        }

        dwTickCount = dwTickCountAfterWait - dwTickCountBeforeWait;
        dwMillisecsSinceTimedOpsDone += dwTickCount;


        // wait returned, now see why
        //---------------------------
        if (dwErr == WAIT_TIMEOUT) {

            // every minute we read local routes again -
            // this is to deal with somebody adding
            // static routes. note that deleted static routes
            // get deleted every 90 seconds.

            lMillisecsTillRouteRefresh -= dwWaitTimeout;
            if (lMillisecsTillRouteRefresh <= 0) {
                lMillisecsTillRouteRefresh = DEF_GETROUTEFREQUENCY;

            }

            // ProcessRouteTableChanges and BroadcastRouteTableContents
            // both assume the address table is locked; lock it before
            // doing timed operations, too, for good measure

            RIP_LOCK_ADDRTABLE();


            // update timers, passing the number of milliseconds
            // since we last called DoTimedOperations
            DoTimedOperations(dwMillisecsSinceTimedOpsDone);

            dwMillisecsSinceTimedOpsDone = 0;

            // if anything changed, process the changes
            // but tell the function not to send update packets
            if (g_ripcfg.dwRouteChanged != 0) {
                ProcessRouteTableChanges(FALSE);
            }

            // update the time till the next update,
            // and send the update if it is due
            lMillisecsTillFullUpdate -= dwWaitTimeout;

            if (lMillisecsTillFullUpdate <= 0) {
                lMillisecsTillFullUpdate = dwUpdateFrequency;

                // send out the periodic update
                if (dwSilentRIP == 0) {

                    // this is not triggered, and we need to broadcast
                    // the entire table, instead of just the changes

                    BroadcastRouteTableContents(FALSE, FALSE);
                }
            }

            RIP_UNLOCK_ADDRTABLE();


            // this continue is here because there is some processing
            // done below for the cases where the wait is interrupted
            // before it could timeout; this skips that code
            //----------------------------------------------
            continue;
        }
        else
#ifndef CHICAGO
        if (dwErr == WAIT_OBJECT_0 + POS_REGEVENT) {

            // registry was changed
            LoadParameters();

            // get the update frequency, converted to milliseconds
            RIP_LOCK_PARAMS();

            dwSilentRIP = g_params.dwSilentRIP;
            dwUpdateFrequency = g_params.dwUpdateFrequency;
            dwGlobalTimeout = g_params.dwMaxTimedOpsInterval;

            RIP_UNLOCK_PARAMS();


            RegNotifyChangeKeyValue(hkeyParams, FALSE,
                                    REG_NOTIFY_CHANGE_LAST_SET |
                                    REG_NOTIFY_CHANGE_ATTRIBUTES |
                                    REG_NOTIFY_CHANGE_NAME,
                                    hEvents[POS_REGEVENT], TRUE);

        }
        else
#endif
        if (dwErr == WAIT_OBJECT_0 + POS_TRIGEVENT) {
            RIP_LOCK_ADDRTABLE();
            ProcessRouteTableChanges(TRUE);
            RIP_UNLOCK_ADDRTABLE();

        }
        else
        if (dwErr == WAIT_OBJECT_0 + POS_STOPEVENT) {
            // perform graceful shutdown
            //
            // first, set all metrics to METRIC_INFINITE - 1
            // next, send out four full updates at intervals
            // of between 2 and 4 seconds
            int pos;
            LPHASH_TABLE_ENTRY rt_entry;

            RIP_LOCK_ADDRTABLE();
            RIP_LOCK_ROUTETABLE();

            dbgprintf("sending out final updates.");

            // setting metrics to 15
            for (pos = 0; pos < HASH_TABLE_SIZE; pos++) {
                rt_entry = g_ripcfg.lpRouteTable[pos];
                while (rt_entry != NULL) {
                    if (rt_entry->dwMetric != METRIC_INFINITE) {
                        rt_entry->dwMetric = METRIC_INFINITE - 1;
                    }
                    rt_entry = rt_entry->next;
                }
            }

            // sending out final full updates
            if (dwSilentRIP == 0) {
                srand((unsigned)time(NULL));
                for (pos = 0; pos < 4; pos++) {
                    BroadcastRouteTableContents(FALSE, FALSE);
                    Sleep(2000 + (int)((double)rand() / RAND_MAX * 2000.0));
                }
            }

            RIP_UNLOCK_ROUTETABLE();
            RIP_UNLOCK_ADDRTABLE();

            // break out of the infinite loop

#ifndef CHICAGO
            CloseHandle(hEvents[POS_REGEVENT]);
#endif
            break;
        }

        // these are only executed if the wait ended
        // for some reason other than a timeout;
        //--------------------------------------
        lMillisecsTillFullUpdate -= min(lMillisecsTillFullUpdate,
                                        (LONG)dwTickCount);
        lMillisecsTillRouteRefresh -= min(lMillisecsTillRouteRefresh,
                                          (LONG)dwTickCount);

        //
        // Make sure DoTimedOperations() runs at least every
        // MaxTimedOpsInterval seconds.
        // We grab the address table lock for good measure.
        //

        if (dwMillisecsSinceTimedOpsDone >= g_params.dwMaxTimedOpsInterval) {

            RIP_LOCK_ADDRTABLE();

            DoTimedOperations(dwMillisecsSinceTimedOpsDone);
            dwMillisecsSinceTimedOpsDone = 0;

            // if anything changed, process the changes
            // but tell the function not to send update packets
            if (g_ripcfg.dwRouteChanged != 0) {
                ProcessRouteTableChanges(FALSE);
            }

            RIP_UNLOCK_ADDRTABLE();
        }

   }

   dbgprintf("update thread stopping.");

#ifndef CHICAGO
    FreeLibraryAndExitThread(g_hmodule, 0);
#endif

    return(0);
}


//-----------------------------------------------------------------------------
// Function:    CleanupRouteTable
//
// Called at shutdown time - runs through all the routes in the route table
// deleting from the system the routes that were learnt through RIP.
//-----------------------------------------------------------------------------
VOID CleanupRouteTable() {
    INT pos;
    LPHASH_TABLE_ENTRY rt_entry, prev_rt_entry;

    RIP_LOCK_ROUTETABLE();

    // Walk the whole hash table - deleting all RIP added routes
    // from each bucket

    dbgprintf("deleting RIP routes from system table.");

    for (pos = 0; pos < HASH_TABLE_SIZE; pos++) {
        prev_rt_entry = rt_entry = g_ripcfg.lpRouteTable[pos];

        while (rt_entry != NULL) {
            prev_rt_entry = rt_entry;
            rt_entry = rt_entry->next;

            if (prev_rt_entry->dwProtocol == IRE_PROTO_RIP) {
                // remove the route from IP's routing table
                UpdateSystemRouteTable(prev_rt_entry, FALSE);
            }

            free(prev_rt_entry);
        }

        g_ripcfg.lpRouteTable[pos] = NULL;
    }

    RIP_UNLOCK_ROUTETABLE();

    // if a route dump was made to shared memory, close the handle
    RIP_LOCK_ADDRTABLE();

    RIP_UNLOCK_ADDRTABLE();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\admin\admutils.cpp ===
//---------------------------------------------------------
//   Copyright (c) 1999-2000 Microsoft Corporation
//
//   utilfunctions.cpp
//
//   vikram K.R.C.  (vikram_krc@bigfoot.com)
//
//   Some generic functions to do command line administration 
//              (May-2000)
//---------------------------------------------------------

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntlsa.h>
#include "resource.h" //resource.h should be before any other .h file that has resource ids.
#include "admutils.h"
#include "common.h"
#include <stdio.h>
#include <stdarg.h>
#include <shlwapi.h>
#include <tchar.h>
#include <assert.h>
#include <conio.h>
#include <winsock.h>
#include <windns.h>               //for #define DNS_MAX_NAME_BUFFER_LENGTH 256

#include <Lmuse.h>
#include <Lm.h>

#include "sfucom.h"

#include <lm.h>
#include <commctrl.h>
#include <OleAuto.h >

#include <string.h>
#include <stdlib.h>
#include "atlbase.h"

#define WINLOGONNT_KEY  TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define NETLOGONPARAMETERS_KEY  TEXT("System\\CurrentControlSet\\Services\\Netlogon\\Parameters")
#define TRUSTEDDOMAINLIST_VALUE TEXT("TrustedDomainList")
#define CACHEPRIMARYDOMAIN_VALUE    TEXT("CachePrimaryDomain")
#define CACHETRUSTEDDOMAINS_VALUE   TEXT("CacheTrustedDomains")
#define DOMAINCACHE_KEY TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon\\DomainCache")
#define DCACHE_VALUE    TEXT("DCache")
#define WINLOGONNT_DCACHE_KEY    TEXT("DCache")


//FOR USING THE CLIGRPENUM INTERFACE...(it is used in the function
//IsValidDomain)
//the following are hash defined in the CligrpEnum.cpp file.

#define GROUP 1
#define MEMBER 2
#define NTDOMAIN 3
#define MACHINE 4

//Globals

BSTR bstrLogin=NULL;
BSTR bstrPasswd=NULL;
BSTR bstrNameSpc= NULL;

SC_HANDLE g_hServiceManager=NULL;
SC_HANDLE g_hServiceHandle=NULL;
SERVICE_STATUS g_hServiceStatus;

WCHAR   *local_host = L"\\\\localhost";

BOOL g_fNetConnectionExists = FALSE;

STRING_LIST g_slNTDomains;

//externs 
//from tnadmutl.cpp

extern wchar_t* g_arCLASSname[_MAX_CLASS_NAMES_];
    //the hive names....
extern int  g_arNUM_PROPNAME[_MAX_PROPS_];
    //Number of properties in the registry each one corresponds to.
extern HKEY g_hkeyHKLM;
    //to store the handle to the registry. 
extern HKEY g_arCLASShkey[_MAX_CLASS_NAMES_];
    //array to hold the handles to the keys of the class hives.
extern WCHAR    g_szMsg[MAX_BUFFER_SIZE] ;
    //array to store the string loaded.
extern HMODULE  g_hResource;
    //handle to the strings library.
HMODULE g_hXPResource;
    //handle to the XPSP1 strings library.
extern HANDLE g_stdout;

StrList* g_pStrList=NULL;


#ifdef __cplusplus
extern "C" {
#endif

//Global Variables...
//externs from nfsadmin.y file.

extern int g_nError;
      // the error flag, 1 error, 0 no error.
extern int g_nPrimaryOption;
      //_tSERVER, _tCLIENT, _tGW or _tHELP
extern int g_nSecondaryOption;
      //Start,Stop,Config,etc kind of things.
extern int g_nTertiaryOption;      
extern int g_nConfigOptions;
      //the Config Options.
extern ConfigProperty g_arPROP[_MAX_PROPS_][_MAX_NUMOF_PROPNAMES_];
extern wchar_t* g_arVALOF[_MAX_PROPS_];
      //the given values of properties in the command line

#ifdef __cplusplus
}
#endif
BOOL g_fCoInitSuccess = FALSE;

/*
 * wzName should not be NULL. (Caller's responsibility)
 */
HRESULT DoNetUseGetInfo(WCHAR *wzName, BOOL *fConnectionExists)
{
    HRESULT hRes=S_OK;

    WCHAR wzResource[DNS_MAX_NAME_BUFFER_LENGTH+1];

    USE_INFO_0 *pUseInfo0;  
    API_RET_TYPE   uReturnCode;               // API return code

    *fConnectionExists = FALSE;

    if (NULL == wzName)
    {
        return E_FAIL;
    }

    _snwprintf(wzResource,DNS_MAX_NAME_BUFFER_LENGTH, L"%s\\ipc$", wzName);

    wzResource[DNS_MAX_NAME_BUFFER_LENGTH] = L'\0'; // Ensure NULL termination

    uReturnCode=NetUseGetInfo(NULL,
                              wzResource,
                              0,
                              (LPBYTE *)&pUseInfo0);

    if(NERR_Success != uReturnCode)
    {
        // If no network connection exists, return S_OK as it
        // is not an error for us.
        
        if(ERROR_NOT_CONNECTED == uReturnCode)
            goto End;
        PrintFormattedErrorMessage(uReturnCode);
        hRes=E_FAIL;
    }
    else
    {
       // Debug Messages
        /*
       wprintf(L"   Local device   : %s\n",  pUseInfo0->ui0_local);
       wprintf(L"   Remote device  : %Fs\n", pUseInfo0->ui0_remote);
        */ 

       
       // NetUseGetInfo function allocates memory for the buffer
       // Hence need to free the same.
       
       NetApiBufferFree(pUseInfo0);
       *fConnectionExists = TRUE;
    }
    
End:
    return hRes;
}


HRESULT DoNetUseAdd(WCHAR* wzLoginname, WCHAR* wzPassword,WCHAR* wzCname)
{
    HRESULT hRes=S_OK;
    USE_INFO_2 ui2Info;
    DWORD dw=-1;
    WCHAR* wzName=NULL;
    int fValid=0;
    int retVal=0;
    char szHostName[DNS_MAX_NAME_BUFFER_LENGTH];
    int count;
    WCHAR* wzTemp=NULL;
    WCHAR szTemp[MAX_BUFFER_SIZE];

    ui2Info.ui2_local=NULL;
    ui2Info.ui2_remote=NULL;

    
    if(wzCname!=NULL &&
        _wcsicmp(wzCname, L"localhost") &&
        _wcsicmp(wzCname, local_host) 
        )
    {   
        //Validate the MACHINE
        
        if(FAILED(hRes=IsValidMachine(wzCname, &fValid)))
            return hRes;
        else if(!fValid)
        {
            if(0==LoadString(g_hResource,IDR_MACHINE_NOT_AVAILABLE,szTemp,MAX_BUFFER_SIZE))
                return GetLastError();
            _snwprintf(g_szMsg, MAX_BUFFER_SIZE -1, szTemp,wzCname);
            MyWriteConsole(g_stdout, g_szMsg, wcslen(g_szMsg));
            hRes= E_FAIL;
            goto End;
        }

        //format properly
        if((wzName=(wchar_t*)malloc((3+wcslen(wzCname))*sizeof(wchar_t)))==NULL)
           return E_OUTOFMEMORY;
       
        if(NULL==StrStrI(wzCname,L"\\\\"))
        {
           wcscpy(wzName,L"\\\\");
           wcscat(wzName,wzCname);
        }
        else if(wzCname==StrStrI(wzCname,L"\\\\"))
            wcscpy(wzName,wzCname);
        else
            {
            hRes=E_INVALIDARG;
            goto End;
            }
        // See whether a network connection already exists for
        // resource ipc$.
        if(FAILED(hRes = DoNetUseGetInfo(wzName, &g_fNetConnectionExists)))
            goto End;

        // Network Connection already exists. 
        if(g_fNetConnectionExists)
            goto End;

    }
    else if(NULL==wzLoginname)
        goto End;
    else //We should send the localhost's name in absolute terms ...otherwise it gives error "duplicate name exists"
   	{ 
   	     WORD wVersionRequested; //INGR
	     WSADATA wsaData; //INGR

    	// Start up winsock
    	wVersionRequested = MAKEWORD( 1, 1 ); //INGR
    	if (0==WSAStartup(wVersionRequested, &wsaData)) 
        { //INGR
    		
   			if(SOCKET_ERROR!=(gethostname(szHostName,DNS_MAX_NAME_BUFFER_LENGTH)))
   			{
   		        if((wzName=(WCHAR *)malloc((3+strlen(szHostName))*sizeof(WCHAR)))==NULL)
                     return E_OUTOFMEMORY;
                
                 wcscpy(wzName,L"\\\\");
                 if(NULL==(wzTemp=DupWStr(szHostName)))
                 {
                     free(wzName);
                     return E_OUTOFMEMORY;
                 }
         		 wzName=wcscat(wzName,wzTemp);
         		 free(wzTemp);
   			}
   			else
   			{
   			    hRes = GetLastError();
   			    g_nError = hRes;
   			    PrintFormattedErrorMessage(hRes);
   			    goto End;
   			}
   			        
            WSACleanup(); //INGR

    	}	
    	else
    	      wzName=local_host;
     }    
    count = (7 + wcslen(wzName)); // name + \ipc$

    ui2Info.ui2_remote=(wchar_t*)malloc(count * sizeof(wchar_t));
    if(NULL==ui2Info.ui2_remote)
        {
        hRes=E_OUTOFMEMORY;
        goto End;
        }

    _snwprintf(ui2Info.ui2_remote, count, L"%s\\ipc$", wzName); // calculated size, no risks
           
    ui2Info.ui2_password=wzPassword;
    ui2Info.ui2_asg_type=USE_IPC;

    if(NULL==wzLoginname)
    {
        ui2Info.ui2_username=NULL;
        ui2Info.ui2_domainname=NULL;
    }
    else if(NULL==StrStrI(wzLoginname,L"\\"))
    {
        ui2Info.ui2_username=wzLoginname;
        ui2Info.ui2_domainname=NULL;
    }
    else
    {
        wzTemp=ui2Info.ui2_username=_wcsdup(wzLoginname);
        if(NULL==wzTemp)
            {
            hRes=E_OUTOFMEMORY;
            goto End;
            }
        
        ui2Info.ui2_domainname=wcstok(wzTemp,L"\\");
        ui2Info.ui2_username=wcstok(NULL,L"\\");        
    }

    NET_API_STATUS nError;
    nError = NetUseAdd(NULL, 2, (LPBYTE) &ui2Info, &dw);
    
    if (NERR_Success != nError)
    {
        LPVOID lpMsgBuf;
        FormatMessage( 
                FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                FORMAT_MESSAGE_FROM_SYSTEM | 
                FORMAT_MESSAGE_IGNORE_INSERTS,
                NULL,
                nError,
                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),// Default language
                (LPTSTR) &lpMsgBuf,
                0,
                NULL);

        _tprintf(L"\n%s\n",(LPCTSTR)lpMsgBuf);
        LocalFree( lpMsgBuf );            
        hRes=E_FAIL;    // To return E_FAIL from the function
        goto End;
    }

    End:
        if(wzName && (wzName != local_host))
            free(wzName);
        
        if(ui2Info.ui2_remote)
            free(ui2Info.ui2_remote);

        return hRes;
}


HRESULT DoNetUseDel(WCHAR* wzCname)
{
    HRESULT hRes=S_OK;
    int retVal=-1;
    WCHAR wzName[DNS_MAX_NAME_BUFFER_LENGTH+1] = { 0 };
    int   nWritten = 0;

    // The network connection was there before invoking the admin tool
    // So, don't delete it
    if(g_fNetConnectionExists)
        goto End;
    
    
    if(NULL!=wzCname &&
        _wcsicmp(wzCname, L"localhost") &&
        _wcsicmp(wzCname, local_host) 
        )
    {        
        
        if(NULL==StrStrI(wzCname,L"\\\\"))
        {
            nWritten = _snwprintf(wzName, ARRAYSIZE(wzName) - 1, L"\\\\%s", wzCname);
            if (nWritten < 0)
            {
                hRes=E_INVALIDARG;
                goto End;
            }
        }
        else if(wzCname==StrStrI(g_arVALOF[_p_CNAME_],L"\\\\"))
        {
            wcsncpy(wzName, wzCname, (ARRAYSIZE(wzName) - 1));
            wzName[(ARRAYSIZE(wzName) - 1)] = 0;
            nWritten = wcslen(wzName);
        }
         else
            {
            hRes=E_INVALIDARG;
            goto End;
            }

        wcsncpy(wzName+nWritten, L"\\ipc$", (ARRAYSIZE(wzName) - 1 - nWritten));
        wzName[ARRAYSIZE(wzName)-1] = L'\0';
        
        retVal=NetUseDel( NULL,
                        wzName,
                        USE_LOTS_OF_FORCE
                       );
        
        
        if(retVal!=NERR_Success)
            {
            hRes=retVal;
            goto End;
            }
    }

End:
    
    return hRes;
}
/*--
    This function gets a handle to Registry.    
--*/

HRESULT GetConnection(WCHAR* wzCname)
{
    int fValid=0;
    HRESULT hRes=S_OK;

    wchar_t* wzName=NULL;
    LONG apiReturn=0L;

    //probably already got the key
    if(g_hkeyHKLM!=NULL)
        return S_OK;

                        
    if(wzCname!=NULL)
    {
        if((wzName=(wchar_t*)malloc((3+wcslen(wzCname))*sizeof(wchar_t)))==NULL)
        {
            ShowError(IDS_E_OUTOFMEMORY);
            hRes = E_OUTOFMEMORY;
            goto End;
        }
        if(NULL==StrStrI(wzCname,L"\\\\"))
        {
           wcscpy(wzName,L"\\\\");
           wcscat(wzName,wzCname);
        }
        else if(wzCname==StrStrI(wzCname,L"\\\\"))
            wcscpy(wzName,wzCname);
        else
        {
            hRes = E_INVALIDARG;
            goto End;
        }
    }
    
    //connecting to the registry.

    apiReturn = ERROR_SUCCESS;
    apiReturn = RegConnectRegistry(  wzName,
                             HKEY_LOCAL_MACHINE,
                             &g_hkeyHKLM
                             );

    if (ERROR_SUCCESS != apiReturn)
    {
        PrintFormattedErrorMessage(apiReturn);
        hRes = E_FAIL;
    }

End:
    if(wzName) free(wzName);

    return hRes;
}


/*--
    the GetSerHandle() function gets the service handle to the admin
--*/

HRESULT GetSerHandle(LPCTSTR lpServiceName,DWORD dwScmDesiredAccess, DWORD dwRegDesiredAccess,BOOL fSuppressMsg)
{

        wchar_t* wzCname;
        HRESULT hRes=S_OK;
        WCHAR szTemp[MAX_BUFFER_SIZE];

        if(g_arVALOF[_p_CNAME_]!=NULL && StrStrI(g_arVALOF[_p_CNAME_],L"\\")!=g_arVALOF[_p_CNAME_])
        {
                if((wzCname=(wchar_t *)malloc((3+wcslen(g_arVALOF[_p_CNAME_]))*sizeof(wchar_t)))==NULL)
                {
                    ShowError(IDS_E_OUTOFMEMORY);
                    return E_FAIL;
                }
                wcscpy(wzCname,L"\\\\");
                wcscat(wzCname,g_arVALOF[_p_CNAME_]);
        }
        else
                wzCname=g_arVALOF[_p_CNAME_];

        if (g_hServiceManager)
            CloseServiceHandle(g_hServiceManager);
        
        if ((g_hServiceManager = OpenSCManager(wzCname,SERVICES_ACTIVE_DATABASE,dwScmDesiredAccess))==NULL)
        {
            DWORD dwErrorCode=0;
            dwErrorCode = GetLastError();
        	if(ERROR_ACCESS_DENIED == dwErrorCode)
        	{
                hRes = ERROR_ACCESS_DENIED; // Need to return this error
                ShowError(IDR_NOT_PRIVILEGED);
                fwprintf(stdout,L" %s\n",(g_arVALOF[_p_CNAME_] ? g_arVALOF[_p_CNAME_] : L"localhost"));
        	}
        	else
        		PrintFormattedErrorMessage(dwErrorCode);
    	}
        else if ((g_hServiceHandle= OpenService(g_hServiceManager,lpServiceName,dwRegDesiredAccess))==NULL) 
            if((hRes=GetLastError())==ERROR_SERVICE_DOES_NOT_EXIST && (FALSE==fSuppressMsg))
            {
                ShowError(IDR_SERVICE_NOT_INSTALLED);
                fwprintf(stdout,L" %s.\n", lpServiceName); 
                
                if (0 == LoadString(g_hResource, IDR_VERIFY_SERVICE_INSTALLED, szTemp, MAX_BUFFER_SIZE))
                {
                    return GetLastError();
                }
                _snwprintf(g_szMsg, MAX_BUFFER_SIZE -1, szTemp,(g_arVALOF[_p_CNAME_] ? g_arVALOF[_p_CNAME_] : L"localhost"));
                MyWriteConsole(g_stdout, g_szMsg, wcslen(g_szMsg));

            }
        return hRes;
}

/*--
    to close the service handles
--*/
HRESULT CloseHandles()
{
    BOOL bRet = FALSE;
    HRESULT hRes = S_OK;
    if(g_hServiceHandle )
    {
        bRet = CloseServiceHandle(g_hServiceHandle);
        g_hServiceHandle = NULL;
        if(!bRet)
            hRes = GetLastError();
    }
    if(g_hServiceManager)
    {
        bRet = CloseServiceHandle(g_hServiceManager);
        g_hServiceManager= NULL;
        if(!bRet)
            hRes = GetLastError();
    }
    return hRes;
}


/*-- StartSer Starts the Service after getting its handle by using
    GetSerHandle function
--*/
HRESULT StartSfuService(LPCTSTR lpServiceName)
{
    HRESULT hRes=S_OK;
    SERVICE_STATUS serStatus;
 
    DWORD dwOldCheckPoint; 
    DWORD dwStartTickCount;
    DWORD dwWaitTime;
    DWORD dwStatus;
 
    if(FAILED(hRes=GetSerHandle(lpServiceName,SC_MANAGER_ALL_ACCESS,SERVICE_ALL_ACCESS,FALSE)))
         goto End;

    if(hRes == ERROR_ACCESS_DENIED)
    {
       // Don't know why ERROR_ACCESS_DENIED escaped FAILED() macro. Anyway,
       // returning that error here.
       goto End;
    }
    else if(StartService(g_hServiceHandle, NULL, NULL))
    {
        
        if (!QueryServiceStatus( 
                g_hServiceHandle,   // handle to service 
                &serStatus) )  // address of status information structure
        {
            hRes = GetLastError();
            ShowErrorFallback(IDS_E_SERVICE_NOT_STARTED, _T("\nError occured while starting the service."));
        	if(hRes != ERROR_IO_PENDING)    //not an interesting error to print
        		PrintFormattedErrorMessage(hRes);
            goto End;
        }
        
        dwStartTickCount = GetTickCount();
        dwOldCheckPoint = serStatus.dwCheckPoint;

        while (serStatus.dwCurrentState == SERVICE_START_PENDING) 
        { 
            // Do not wait longer than the wait hint. A good interval is 
            // one tenth the wait hint, but no less than 1 second and no 
            // more than 10 seconds. 
     
            dwWaitTime = serStatus.dwWaitHint / 10;

            if( dwWaitTime < 1000 )
                dwWaitTime = 1000;
            else if ( dwWaitTime > 10000 )
                dwWaitTime = 10000;

            Sleep( dwWaitTime );

            // Check the status again. 
     
            if (!QueryServiceStatus( 
                    g_hServiceHandle,   // handle to service 
                    &serStatus) )  // address of structure
                break; 
     
            if ( serStatus.dwCheckPoint > dwOldCheckPoint )
            {
                // The service is making progress.

                dwStartTickCount = GetTickCount();
                dwOldCheckPoint = serStatus.dwCheckPoint;
            }
            else
            {
                if(GetTickCount()-dwStartTickCount > serStatus.dwWaitHint)
                {
                    // No progress made within the wait hint
                    break;
                }
            }
        } 

        if (serStatus.dwCurrentState == SERVICE_RUNNING) 
        {
            PrintMessageEx(g_stdout,IDS_SERVICE_STARTED, _T("\nThe service was started successfully.\n"));
            goto End;
        }
    }

    if((hRes=GetLastError())==ERROR_SERVICE_ALREADY_RUNNING)
    {
    	/* StartService returns SERVICE_ALREADY_RUNNING even when the
    	   service is in wierd state. For instance, when the service is in the
    	   state STOP_PENDING, we print - The service was controlled successfully
    	   To avoid this, we issue a control to the service and see if it can respond. If
    	   it can't appropriate error message is printed
    	*/
    	if (ControlService(g_hServiceHandle, SERVICE_CONTROL_INTERROGATE, &serStatus))
		{
		    PrintMessageEx(g_stdout,IDR_ALREADY_STARTED, _T("\nThe service is already started.\n"));
			hRes = S_OK;
		}
    	else
    	{
    		hRes = GetLastError();
    		ShowErrorFallback(IDS_E_SERVICE_NOT_STARTED, _T("\nError occured while starting the service."));
        	if(hRes != ERROR_IO_PENDING)    //not an interesting error to print
        		PrintFormattedErrorMessage(hRes);
    	}
     }
    else if(hRes==ERROR_ACCESS_DENIED)
        ShowError(IDR_NOT_PRIVILEGED);
    else
    {
        ShowErrorFallback(IDS_E_SERVICE_NOT_STARTED, _T("\nError occured while starting the service."));
    	if(hRes != ERROR_IO_PENDING)    //not an interesting error to print
        	PrintFormattedErrorMessage(hRes);
    }

End:
    CloseHandles();
	return hRes;
}

/*--
QuerySfuService function queries the service for its status.

--*/
HRESULT QuerySfuService(LPCTSTR lpServiceName)
{
    HRESULT hRes;
    if(FAILED(hRes=GetSerHandle(lpServiceName,SC_MANAGER_CONNECT,SERVICE_QUERY_STATUS,FALSE)))
        return hRes;

    if(hRes == ERROR_ACCESS_DENIED)
    {
       // Don't know why ERROR_ACCESS_DENIED escaped FAILED() macro. Anyway,
       // returning that error here.
        return hRes;
    }

    else if(QueryServiceStatus(g_hServiceHandle,&g_hServiceStatus))
        return CloseHandles();
    else
        return GetLastError();
}
/*--
    ControlSfuService Stops Pauses Continues the Service after
    getting its handle by using GetSerHandle function.

--*/

HRESULT ControlSfuService(LPCTSTR lpServiceName,DWORD dwControl)
{
	LPSERVICE_STATUS lpStatus = (SERVICE_STATUS *) malloc (sizeof(SERVICE_STATUS));

	if(lpStatus==NULL)
	{
	    ;//bugbug print an error
	    return E_OUTOFMEMORY;
	}

	HRESULT hr = S_FALSE;
	int queryCounter =0;
	DWORD dwState = 0;

	if(FAILED(dwState= GetSerHandle(lpServiceName,SC_MANAGER_ALL_ACCESS,SERVICE_ALL_ACCESS,FALSE)))
	    {free(lpStatus);return dwState;}

	if(dwState == ERROR_ACCESS_DENIED)
	{
	   // Don't know why ERROR_ACCESS_DENIED escaped FAILED() macro. Anyway,
	   // returning that error here.
	   free(lpStatus);
	    return dwState;
	}

	//Check the return value of ControlService. If not null, then loop 
	//with QueryServiceStatus
	if (ControlService(g_hServiceHandle,dwControl,lpStatus))
	{
            switch(dwControl)
	    {
	        case(SERVICE_CONTROL_PAUSE) :
	            dwState = SERVICE_PAUSED;
		        break;
	        case(SERVICE_CONTROL_CONTINUE) :
	            dwState = SERVICE_RUNNING; 
		        break;    
	        case(SERVICE_CONTROL_STOP):
	            dwState = SERVICE_STOPPED; 
	    	    break;
	    } 
            for (;queryCounter <= _MAX_QUERY_CONTROL_; queryCounter++)
	    {
	        if( QueryServiceStatus( g_hServiceHandle, lpStatus )  )
	        {
	            
	            //Check if state required is attained
	            if ( lpStatus->dwCurrentState != dwState )
	            {
	                if ( lpStatus->dwWaitHint )
	                {
	                    Sleep(lpStatus->dwWaitHint);
	                }
	                else
	                    Sleep(500);
	            }
	            else
	            {
                        switch(dwControl)
                        {
                            case SERVICE_CONTROL_PAUSE:
                                PrintMessageEx(g_stdout,IDR_SERVICE_PAUSED,_T("\nThe service has been paused.\n"));
                                break;
                            case SERVICE_CONTROL_CONTINUE:
                                PrintMessageEx(g_stdout,IDR_SERVICE_CONTINUED,_T("\nThe service has been resumed.\n"));
                                break;
                            case SERVICE_CONTROL_STOP:
                                PrintMessage(g_stdout,IDR_SERVICE_CONTROLLED);
                                break;
                        }
	                hr = S_OK;
	                break;
	            }
	        }
	        else
	        {
                hr = GetLastError();
                PrintFormattedErrorMessage(hr);
                break;
	      	}
	    }
	    if (queryCounter > _MAX_QUERY_CONTROL_)
	    {
	        // We couldn't get to the state which we wanted to
	        // within the no. of iterations. So print that the
	        // service was not controlled successfully.
                switch(dwControl)
                {
                    case SERVICE_CONTROL_PAUSE:
                        PrintMessageEx(g_stdout,IDR_SERVICE_NOT_PAUSED,_T("\nThe service could not be paused.\n"));
                        break;
                    case SERVICE_CONTROL_CONTINUE:
                        PrintMessageEx(g_stdout,IDR_SERVICE_NOT_CONTINUED,_T("\nThe service could not be resumed.\n"));
                        break;
                    case SERVICE_CONTROL_STOP:
                        PrintMessage(g_stdout,IDR_SERVICE_NOT_CONTROLLED);
                        break;
                }
	        hr = S_OK;
	               
	    }
		
	}
	else
	{
		hr = GetLastError();
		PrintFormattedErrorMessage(hr);
	}

	free (lpStatus);
	if(FAILED(hr))
	    return hr;

    return CloseHandles();
}


/* -- 
    GetBit(int Options,int bit) function returns the BIT in the position
    bit in the Options{it acts as a bit array}
--*/

int GetBit(int Options,int nbit)
{
    int ni=0x01,nj=0;
    ni=ni<<nbit;

    if(ni&Options)
        return 1;
    else
        return 0;
}

/* -- 
    SetBit(int Options,int bit) function Sets the BIT in the position
    bit in the Options{it acts as a bit array}.
--*/
int SetBit(int Options,int nbit)
{
    int ni=1,nj=0;
    ni=ni<<nbit;
    
    Options=ni|Options;
    return Options;
}

/*--
    this function prints out the help message for the command
--*/
HRESULT PrintMessage(HANDLE fp,int nMessageid)
{
    HRESULT hRes = S_OK;
    HANDLE hOut = fp;
    int nRet = 0;
    DWORD dwWritten = 0;
    if( hOut == NULL )
        hOut = g_stdout;
    if(LoadString(g_hResource, nMessageid, g_szMsg, MAX_BUFFER_SIZE)==0)
       return GetLastError();
    MyWriteConsole(hOut,g_szMsg,_tcslen(g_szMsg));
    return hRes;
}


/*--
    this function prints out the help message for the command and falls
    back to english string if loadstring fails
--*/
HRESULT PrintMessageEx(HANDLE fp,int nMessageid, LPCTSTR szEng)
{
    HRESULT hRes = S_OK;
    int nRet = 0;
    HANDLE hOut = fp;
    DWORD dwWritten = 0;
    if( hOut == NULL )
        hOut = g_stdout;

    TnLoadString(nMessageid, g_szMsg, MAX_BUFFER_SIZE,szEng);
    MyWriteConsole(hOut,g_szMsg,_tcslen(g_szMsg));
    return hRes;
}

/*--This function takes the parameter corresponding to the error code,
    prints it out and puts back all the classes
    and quits the program.
 --*/

BOOL
FileIsConsole(
    HANDLE fp
    )
{
    unsigned htype;

    htype = GetFileType(fp);
    htype &= ~FILE_TYPE_REMOTE;
    return htype == FILE_TYPE_CHAR;
}


void
MyWriteConsole(
    HANDLE  fp,
    LPWSTR  lpBuffer,
    DWORD   cchBuffer
    )
{
    //
    // Jump through hoops for output because:
    //
    //    1.  printf() family chokes on international output (stops
    //        printing when it hits an unrecognized character)
    //
    //    2.  WriteConsole() works great on international output but
    //        fails if the handle has been redirected (i.e., when the
    //        output is piped to a file)
    //
    //    3.  WriteFile() works great when output is piped to a file
    //        but only knows about bytes, so Unicode characters are
    //        printed as two Ansi characters.
    //

    if (FileIsConsole(fp))
    {
	WriteConsole(fp, lpBuffer, cchBuffer, &cchBuffer, NULL);
    }
    else
    {
        LPSTR  lpAnsiBuffer = (LPSTR) LocalAlloc(LMEM_FIXED, cchBuffer * sizeof(WCHAR));

        if (lpAnsiBuffer != NULL)
        {
            cchBuffer = WideCharToMultiByte(CP_OEMCP,
                                            0,
                                            lpBuffer,
                                            cchBuffer,
                                            lpAnsiBuffer,
                                            cchBuffer * sizeof(WCHAR),
                                            NULL,
                                            NULL);

            if (cchBuffer != 0)
            {
                WriteFile(fp, lpAnsiBuffer, cchBuffer, &cchBuffer, NULL);
            }

            LocalFree(lpAnsiBuffer);
        }
    }
}

int ShowError(int nError)
{

    g_nError=nError;

    if(LoadString(g_hResource, nError, g_szMsg, MAX_BUFFER_SIZE)==0)
        return 1; //failed to loadString
    MyWriteConsole(g_stdout,g_szMsg, wcslen(g_szMsg));

    return 0;  //successfully shown error
}

/*--This function takes the parameter corresponding to the error code
    and it's English String, prints it out and puts back all the classes
    and quits the program.
 --*/

int ShowErrorFallback(int nError, LPCTSTR szEng)
{

    g_nError=nError;

    TnLoadString(nError,g_szMsg,MAX_BUFFER_SIZE,szEng);
    MyWriteConsole(g_stdout,g_szMsg, wcslen(g_szMsg));

    return 0;  //successfully shown error
}


// This function takes the input string for g_szMsg which is expected to
// contain a "%s" init. We have several usage of such string across the
// admintools and hence this function. Incase we have more that one %s
// then we can not use this function.

int ShowErrorEx(int nError,WCHAR *wzFormatString)
{
    g_nError=nError;

    if(LoadString(g_hResource, nError, g_szMsg, MAX_BUFFER_SIZE)==0)
    	        return 1; //failed to loadString
    	
    wprintf(g_szMsg,wzFormatString);
    fflush (stdout);
    return 0;  //successfully shown error
}

/*--
    GetClass function gets handles to all the class hives, into the array
    g_arCLASShkey, using the handle to the HKLM we have from 
    GetConnection
--*/

HRESULT GetClassEx(int nProperty, int nNumProp, BOOL bPrintErrorMessages, REGSAM samDesired)
{
    int i=g_arPROP[nProperty][nNumProp].classname;
    LONG retVal;

    if(g_arCLASShkey[i]!=NULL)
        return S_OK;
 
     retVal=RegOpenKeyEx(
                      g_hkeyHKLM,// handle to open key
                      g_arCLASSname[i],  // subkey name
                      0,  // reserved
                      samDesired, // security access mask
                      g_arCLASShkey+i // handle to open key
                        );
    if(retVal!=ERROR_SUCCESS)
    {
        if (bPrintErrorMessages)
        {
            PrintFormattedErrorMessage(retVal);
        }
            
        return E_FAIL;
    }

    return S_OK;
}



/*--
    PutClasses() function closes the keys to the hives.    
--*/

HRESULT PutClasses()
{
    int ni=0;
    SCODE sc=S_OK;
    
    for(ni=0;ni<_MAX_CLASS_NAMES_;ni++)
    {
        if(g_arCLASShkey[ni]==NULL)
            continue;          // this class was not got, so no need to put.

        if(RegCloseKey(g_arCLASShkey[ni])!=ERROR_SUCCESS)
            sc=GetLastError();
        g_arCLASShkey[ni]=NULL;
    }

    if(g_hkeyHKLM!=NULL)
    {
        if (RegCloseKey(g_hkeyHKLM)!=ERROR_SUCCESS)
            return GetLastError();
        g_hkeyHKLM=NULL;
    }
    
    return sc;
}

/*--
    GetProperty() function gets value of the required property from the
    hive.


    //NOTE:
// In case of REG_MULTI_SZ type
//we are storing  linked list of strings and not returning anything in variant
//the linked list 'g_pStrList' needs to be freed by the caller

//the caller needs to remember this


--*/
HRESULT GetProperty(int nProperty, int nNumofprop, VARIANT *pvarVal)
{
    if(g_arPROP[nProperty][nNumofprop].propname==NULL)
        return E_FAIL;

    LONG retVal=ERROR_SUCCESS;
    DWORD size;
    DWORD dType;

    UINT uVar;
    wchar_t szString[MAX_BUFFER_SIZE]={0};
    wchar_t* szMultiStr=NULL;

    StrList * pHeadList=NULL;
    StrList * pTailList=NULL;
    StrList * pTemp= NULL ;

    if(g_arCLASShkey[g_arPROP[nProperty][nNumofprop].classname]==NULL)
		{
		retVal=E_ABORT;
		goto End;
		}
    
    switch (V_VT(&g_arPROP[nProperty][nNumofprop].var))
    {
        case VT_I4:
            
            size=sizeof(UINT);
            retVal=RegQueryValueEx(g_arCLASShkey[g_arPROP[nProperty][nNumofprop].classname],
                                  g_arPROP[nProperty][nNumofprop].propname,
                                  NULL,
                                  &dType,
                                  (LPBYTE)&uVar,
                                  (LPDWORD)&size
                                  );
            if(retVal!=ERROR_SUCCESS)
            {
                // If this was because of the registry value not found
                // display a proper error message instead of "the system
                // can not find the file specified"                
                if(ERROR_FILE_NOT_FOUND==retVal)
                    PrintMissingRegValueMsg(nProperty,nNumofprop);
                else
                    PrintFormattedErrorMessage(retVal);
                    
                goto End;
            }

            V_I4(pvarVal)=uVar;
            
            break;

            
        case VT_BSTR:
            
            size=MAX_BUFFER_SIZE*sizeof(wchar_t); 

            retVal=RegQueryValueEx(g_arCLASShkey[g_arPROP[nProperty][nNumofprop].classname],
                                  g_arPROP[nProperty][nNumofprop].propname,
                                  NULL,
                                  &dType,
                                  (LPBYTE)szString,
                                  (LPDWORD)&size
                                );
            if(retVal!=ERROR_SUCCESS)
            {
                // If this was because of the registry value not found
                // display a proper error message instead of "the system
                // can not find the file specified"
                if(ERROR_FILE_NOT_FOUND==retVal)
                    PrintMissingRegValueMsg(nProperty,nNumofprop);
                else
                    PrintFormattedErrorMessage(retVal);

                    goto End;
            }
            
            V_BSTR(pvarVal)=SysAllocString(szString);
            if(NULL==V_BSTR(pvarVal))
            {
                ShowError(IDS_E_OUTOFMEMORY);
                retVal=E_OUTOFMEMORY;
                goto End;
            }

            break;
        case VT_ARRAY:
            pvarVal=NULL;
            retVal=RegQueryValueEx(g_arCLASShkey[g_arPROP[nProperty][nNumofprop].classname],
                                  g_arPROP[nProperty][nNumofprop].propname,
                                  NULL,
                                  &dType,
                                  NULL,
                                  (LPDWORD)&size
                                );
            if(retVal==ERROR_SUCCESS)
            {
                szMultiStr=(wchar_t*)malloc(size * sizeof(char));
                if(szMultiStr==NULL)
                    {
                    retVal = E_OUTOFMEMORY;
                    goto End;
                    }
                //since the size returned is in bytes we use sizeof(char)

                retVal=RegQueryValueEx(g_arCLASShkey[g_arPROP[nProperty][nNumofprop].classname],
                                  g_arPROP[nProperty][nNumofprop].propname,
                                  NULL,
                                  &dType,
                                  (LPBYTE)szMultiStr,
                                  (LPDWORD)&size
                                );

            }

            if (retVal!=ERROR_SUCCESS)
            {
                if(ERROR_FILE_NOT_FOUND==retVal)
                    PrintMissingRegValueMsg(nProperty,nNumofprop);
                else
                    PrintFormattedErrorMessage(retVal);
                    
                goto End;
                   
            }
            else 
            { //form a linked list containing the strings

                //get all the strings into a linked list
                // and their count into 'count'
                
                int      count = 0 ;
                DWORD      length = 0 ;
                WCHAR* wzTemp = szMultiStr;

                
                if (size >= 2)
                {
                	// take away the last two zeroes of a reg_multi_sz
                	size -= 2;
	                
	                while( wzTemp  && *wzTemp  && (length < size/sizeof(WCHAR))) 
	                {                
	                    pTemp= (StrList *) malloc( sizeof( StrList ) );
	                    if(pTemp==NULL)
	                        {
	                        retVal=E_OUTOFMEMORY;
	                        goto End;
	                        }

	                    count++;
	                    // add 1 so that you go past the null.
	                    length+=wcslen(wzTemp ) + 1;
	                    
	                    if((pTemp->Str=_wcsdup(wzTemp))==NULL)
	                        {
	                        retVal=E_OUTOFMEMORY;
	                        goto End;
	                        }
	                    // insertion logic is being changed.
	                    // insert at the tail.
	                    if (NULL == pTailList)
	                    {
	                        // first insertion
	                        pHeadList = pTemp;
	                        pTailList = pTemp;
	                        pTemp->next = NULL;
	                        pTemp = NULL; // the memory pointed by pTemp will be taken care by the linked list.
	                    }
	                    else
	                    {
	                        // normal insertion
	                        pTailList->next = pTemp;
	                        pTemp->next = NULL;
	                        pTailList = pTemp;
	                        pTemp = NULL; // the memory pointed by pTemp will be taken care by the linked list.
	                    }
	                    
	                    
	                    wzTemp = szMultiStr + length;
	                }
                }
//NOTE:
// We are doing a trick here....in case of multi_reg_sz
//we are storing strings in a linked list pointed by g_pStrList
//they need to be freed by the caller
                g_pStrList=pHeadList;
                //including 1 wide char '\0' for multi_sz end
                
                
              }                
            
            break;

        default:
            ;
    }
    

End:

    StrList* temp=NULL;
    if(retVal==E_OUTOFMEMORY)
        while(pHeadList!=NULL)
        {
            temp=pHeadList;
            if(pHeadList->Str)
                free(pHeadList->Str);
            pHeadList=pHeadList->next;
            free(temp);
        }

    if(pTemp)
    {
        SAFE_FREE(pTemp->Str);
        free(pTemp);
    }
    
    if(szMultiStr)
        free(szMultiStr);


    if(retVal!=ERROR_SUCCESS)
        return E_FAIL;
    else
        return ERROR_SUCCESS;
}


/*--
    PutProperty puts the property by using its classObject's handle.
    Incase you pass NULL in place of pvarVal, it does not put the property.


   //NOTE:
// In case of MULTI_REG_SZ type
// caller stores linked list of strings and does not pass anything in variant
//the linked list 'g_pStrList' needs to be freed by the callee (here)

//the caller needs to remember this

--*/
HRESULT PutProperty(int nProperty, int nNumofprop, VARIANT* pvarVal)
{
    HRESULT retVal=S_OK;
    CONST BYTE *lpData=NULL;
    DWORD cbData=0;
    DWORD dType;
    wchar_t* wzTemp=NULL;
    StrList* pTempList=NULL;
    int len=0;

    if(g_arPROP[nProperty][nNumofprop].fDontput==1)
        goto End;

    
    switch(V_VT(&g_arPROP[nProperty][nNumofprop].var))
    {
        case VT_I4:
            lpData=(CONST BYTE *) &V_I4(pvarVal);
            cbData=sizeof(DWORD);
            dType=REG_DWORD;
            break;
        case VT_BSTR:
            if(V_BSTR(pvarVal))
            {
                lpData=(CONST BYTE *)(wchar_t*)V_BSTR(pvarVal);
                cbData=(wcslen((wchar_t*)V_BSTR(pvarVal))+1)*sizeof(wchar_t);
            }
            else
            {
                lpData = NULL;
                cbData=0;
            }
            dType=REG_SZ;
            break;

        case VT_ARRAY:
            //package passed in array into lpData well
            
            dType=REG_MULTI_SZ;

            //calculate the no. of bytes reqd.
            pTempList = g_pStrList;
            while(pTempList!=NULL)
            {
                cbData += ((wcslen(pTempList->Str)+1)*sizeof(wchar_t));
                pTempList = pTempList->next;
            }
            cbData += sizeof(wchar_t); //for extra '\0' in MULTI_SZ; Note: for blank entries, only one '\0' is reqd. so this is also OK.

            if(NULL==(wzTemp=(wchar_t*)malloc(cbData)))
            {
                retVal=E_OUTOFMEMORY;
                goto End;
            }

            while(g_pStrList!=NULL)
            {
                wcscpy(wzTemp+len,g_pStrList->Str);
                len+=wcslen(g_pStrList->Str)+1;
                
                pTempList=g_pStrList;
                g_pStrList=g_pStrList->next;

                if(pTempList->Str)
                    free(pTempList->Str);
                free(pTempList);
            }

            // fill the last two bytes NULL , as required to terminate a MULTI_SZ
            *(wzTemp+len) = L'\0';
         
            lpData=(CONST BYTE*)wzTemp;

            break;
            

        default :
            {   
                if(0==LoadString(g_hResource,IDS_E_UNEXPECTED,g_szMsg,MAX_BUFFER_SIZE))
	                  return GetLastError();
	           MyWriteConsole(g_stdout,g_szMsg, wcslen(g_szMsg));
	           retVal= E_FAIL;
	           goto End;
            }   
            ;
    }
    if(lpData)
    {
        retVal=RegSetValueEx(
                           g_arCLASShkey[g_arPROP[nProperty][nNumofprop].classname], // handle to key
                           g_arPROP[nProperty][nNumofprop].propname, // value name
                            0,      // reserved
                           dType,// value type
                           lpData,  // value data
                           cbData         // size of value data
                           );
        if(FAILED(retVal))
        {
            WCHAR *lpMsgBuf;

            if (0 != FormatMessageW( 
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                    FORMAT_MESSAGE_FROM_SYSTEM | 
                    FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    retVal,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                // Default language
                    (LPWSTR)&lpMsgBuf,
                    0,
                    NULL 
                    ))
            {
                MyWriteConsole(g_stdout,lpMsgBuf, wcslen(lpMsgBuf));
                LocalFree( lpMsgBuf );
            }
        }        
        goto End;
   }

    
End:
    if(wzTemp)
        free(wzTemp);
    return retVal;
}




/*--
   DupWStr takes a char string, and returns a wchar string.
   Note that it allocates the memory required for the wchar string, So we
   need to free it explicitly if after use.

   if it has quotes surrounding it, then it is snipped off

 --*/
wchar_t* DupWStr(char *szStr)
{
    wchar_t* wzStr=NULL;
    char*    szString=NULL;

    if(szStr==NULL)
        return NULL;

    int nLen=strlen(szStr);
    if(NULL==(szString=(char*)malloc((nLen+1)*sizeof(char))))
        return NULL;
    
    if(szStr[0]!='"')
        strcpy(szString,szStr);
    else
    {
    	int nPos;
    	if(szStr[nLen-1]!='"') //ending double quotes not there.
    		nPos=1;//then no need to skip the last two. One is enough
    	else
    		nPos=2;
        strcpy(szString,szStr+1);
        szString[nLen-nPos]='\0';
    }
    
    nLen=MultiByteToWideChar(GetConsoleCP(),0,szString,-1,NULL,NULL);
    if (0 == nLen)
	{
		free(szString);
		return NULL;
	}
    wzStr=(wchar_t *) malloc(nLen*sizeof(wchar_t));
    if(wzStr==NULL)
    {
       free(szString);
       return NULL;
    }

    if (!MultiByteToWideChar(GetConsoleCP(), 0, szString, -1, wzStr, nLen ))
    {
    	free(szString);
    	free(wzStr);
    	return NULL;
    }

    if(szString)
        free(szString);
    return wzStr;
}

/*--
   DupCStr takes a wchar string, and returns a char string.
   Note that it allocates the memory required for the char string, So we
   need to free it explicitly if after use.

   If memory allocation fails (or if input is NULL), it returns a NULL pointer.
 --*/
 
char* DupCStr(wchar_t *wzStr)
{
    char* szStr=NULL;

    if(wzStr==NULL)
        return NULL;
    
    int cbMultiByte = WideCharToMultiByte( GetACP(),NULL,wzStr,-1,szStr,0,NULL,NULL);

    if (0 == cbMultiByte) 
    {
        return NULL;
    }
    
    szStr = (char *) malloc(cbMultiByte);

    if (NULL == szStr)
    {
        return NULL;
    }

    cbMultiByte = WideCharToMultiByte( GetConsoleCP(),NULL,wzStr,-1,szStr,
                        cbMultiByte,NULL,NULL);

    if (0 == cbMultiByte) 
    {
        free(szStr);
        szStr = NULL;
    }

    return szStr;
}

/*--
    function(s) to resolve and check if the given machine is
    valid or not
--*/

HRESULT IsValidMachine(wchar_t* wzCname , int *fValid)
{

    HRESULT hRes=S_OK;
    struct sockaddr_in addr;
    char * nodeName=NULL;
    int cbMultiByte;
    *fValid= 0;

    wchar_t* wzName=NULL;
    if(wzCname==NULL)
    {
            *fValid=1;
            goto End;
    }
    else
    {
        if(NULL==(wzName=(wchar_t*)malloc((wcslen(wzCname)+1)*sizeof(wchar_t))))
        {
            hRes=E_OUTOFMEMORY;
            goto End;
        }
        if(StrStrI(wzCname,L"\\")!=NULL)
        {
           wcscpy(wzName,wzCname+2);
        }
        else
            wcscpy(wzName,wzCname);
    }

    
    
    cbMultiByte = WideCharToMultiByte( GetACP(),NULL,wzName,-1,nodeName,
                        0,NULL,NULL);

    nodeName = (char *) malloc(cbMultiByte*sizeof(char));
    if(!nodeName)
    {
        hRes=E_OUTOFMEMORY;
        goto End;
    }
    WideCharToMultiByte( GetConsoleCP(),NULL,wzName,-1,nodeName,
                        cbMultiByte,NULL,NULL);
            
    if (Get_Inet_Address (&addr, nodeName)) 
        *fValid = 1;

End:
    if(nodeName)
        free(nodeName);
    if(wzName)
        free(wzName);
    
    return hRes;
    
}

BOOL Get_Inet_Address(struct sockaddr_in *addr, char *host)
{
    register struct hostent *hp;
    WORD wVersionRequested; //INGR
    WSADATA wsaData; //INGR

    // Start up winsock
    wVersionRequested = MAKEWORD( 1, 1 ); //INGR
    if (WSAStartup(wVersionRequested, &wsaData) != 0) { //INGR
    return (FALSE);
    }

    // Get the address
    memset(addr, 0, sizeof(*addr)); 
    //bzero((TCHAR *)addr, sizeof *addr);
    addr->sin_addr.s_addr = (u_long) inet_addr(host);
    if (addr->sin_addr.s_addr == -1 || addr->sin_addr.s_addr == 0) {
      if ((hp = gethostbyname(host)) == NULL) {
        return (FALSE);
      }
      memcpy(&addr->sin_addr,hp->h_addr,  hp->h_length );
      //bcopy(hp->h_addr, (TCHAR *)&addr->sin_addr, hp->h_length);
    }
    addr->sin_family = AF_INET;

    WSACleanup(); //INGR
    return (TRUE);
}

/*--
 Function to get the Trusted Domains and then check if the given
 domain is one among them
 --*/

HRESULT IsValidDomain(wchar_t* wzDomainName, int *fValid)
{
	HRESULT hRes = E_FAIL;
	TCHAR szName[MAX_PATH];
	DWORD dwLen = sizeof(szName);

	ZeroMemory(szName,sizeof(szName));

	*fValid = 0;
    if(_wcsicmp(wzDomainName,L".")==0||_wcsicmp(wzDomainName,L"localhost")==0||_wcsicmp(wzDomainName,local_host)==0)
    {
        *fValid=1;
        return S_OK;
    }
    //If it's a local machine, g_arVALOF[_p_CNAME_] will be NULL. So pass "localhost".
    if(FAILED(hRes=LoadNTDomainList(g_arVALOF[_p_CNAME_] ?g_arVALOF[_p_CNAME_] : SZLOCALMACHINE)))
    	return hRes;

	//compare given domain with all the domains in the list.
	if(g_slNTDomains.count != 0)
	{
		DWORD i;
		for(i=0;i<g_slNTDomains.count;i++)
		{
			if(_wcsicmp(g_slNTDomains.strings[i],wzDomainName)==0)
			{
				*fValid=1;
				break;
			}
		}
	}    
    return S_OK;
}


/* This Function CheckForPassword() takes the password from the stdout after prompting for the same;
   This function is called if the user name (Login name) is specified with out password */
   
HRESULT CheckForPassword(void)
{
    HRESULT hRes=S_OK;
    HANDLE  hStdin; 
    DWORD fdwMode, fdwOldMode; 
    
    
	if(g_arVALOF[_p_USER_]!=NULL&&NULL==g_arVALOF[_p_PASSWD_])
    {   //Password is not specified and hence go get it.
        if(NULL==(g_arVALOF[_p_PASSWD_]=(wchar_t*)malloc(MAX_BUFFER_SIZE*sizeof(wchar_t))))
            {
                hRes=E_OUTOFMEMORY;
                return hRes;
            }

        int i;
        PrintMessage(g_stdout, IDR_PASSWD_PROMPT);

        hStdin = GetStdHandle(STD_INPUT_HANDLE); 

        if (hStdin == INVALID_HANDLE_VALUE)
            goto ElsePart;
            
        if (GetConsoleMode(hStdin, &fdwOldMode)) 
        {
            fdwMode = fdwOldMode & 
                ~(ENABLE_ECHO_INPUT); 
            if (! SetConsoleMode(hStdin, fdwMode)) 
                goto ElsePart;
            if(NULL==fgetws(g_arVALOF[_p_PASSWD_],MAX_BUFFER_SIZE,stdin))
            {
                hRes = E_FAIL;
                return hRes;
            }
            wchar_t *szLast = wcsrchr(g_arVALOF[_p_PASSWD_],L'\n');
            if(szLast)
            {
                *szLast = L'\0';
            }
            SetConsoleMode(hStdin, fdwOldMode);
        }
        else
        {
        // Here we get the password char by char(with echo off)
        // and we can't support backspace and del chars here.

        // this code will be executed only if we could not get/set 
        // the console of the user to ECHO_OFF
ElsePart:
             for(i=0;i<MAX_BUFFER_SIZE-1;i++)
             {
                 g_arVALOF[_p_PASSWD_][i]=(wchar_t)_getch();
                 if(g_arVALOF[_p_PASSWD_][i]==L'\r'||g_arVALOF[_p_PASSWD_][i]==L'\n')
                     break;
             }
             puts("\n\n");
             g_arVALOF[_p_PASSWD_][i]=L'\0';
        }
    }
	else if (NULL==g_arVALOF[_p_USER_]&&g_arVALOF[_p_PASSWD_]!=NULL)  //Only password is specified hence error
		{
		 	hRes=E_FAIL;
		 	ShowError(IDS_E_LOGINNOTSPECIFIED);
		}	
	return hRes;
}
void ConvertintoSeconds(int nProperty,int *nSeconds)
{

		int FirstTok=_wtoi(wcstok(g_arVALOF[nProperty],L":"));
        wchar_t* mins=wcstok(NULL,L":");
        wchar_t* secs=wcstok(NULL,L":");
        if(NULL == secs)
		 {
		 	if(NULL == mins) 
		 		{	
		 		*nSeconds=FirstTok;
		 		return;
		 		}
		 	else
		 		{
             FirstTok*=60;
             FirstTok+=_wtoi(mins);
             *nSeconds=FirstTok;
             return;
		 		}
          }
        else
          {
             FirstTok*=60;
             FirstTok+=_wtoi(mins);
             FirstTok*=60;
             FirstTok+=_wtoi(secs);
             *nSeconds=FirstTok;
             return;
           }
           
}
void PrintFormattedErrorMessage(LONG LErrorCode)
{
    WCHAR *lpMsgBuf;

    if (0 != FormatMessageW( 
                    FORMAT_MESSAGE_ALLOCATE_BUFFER | 
                    FORMAT_MESSAGE_FROM_SYSTEM | 
                    FORMAT_MESSAGE_IGNORE_INSERTS,
                    NULL,
                    LErrorCode,
                    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
                                // Default language
                    (LPWSTR)&lpMsgBuf,
                    0,
                    NULL 
                    ))
    {
        MyWriteConsole(g_stdout,lpMsgBuf, wcslen(lpMsgBuf));
        LocalFree( lpMsgBuf );
    }
}

HRESULT getHostNameFromIP(char *szCname, WCHAR** wzCname)
{
    struct hostent *hostinfo;
    WSADATA      wsaData; 
    u_long res;
    HRESULT hRes=S_OK;
    
    if (WSAStartup(MAKEWORD (1,1),&wsaData) != 0)
    {
         return E_FAIL;
    }
    
    if ((res = inet_addr ( szCname )) != INADDR_NONE )
    {
        if ((hostinfo = gethostbyaddr ((char*) &res, sizeof(res),AF_INET))
             == NULL)
        {           
            // Handle error here
            hRes=E_FAIL;
            goto End;
        }
         // At this point hostinfo->h_name contains host name in ASCII
         //  convert it to UNICODE before returning.

        if(NULL == (*wzCname=DupWStr(hostinfo->h_name)))
        {
            hRes=E_OUTOFMEMORY;
            goto End;
        }
        
    }
   else
   {
        if(NULL == (*wzCname=DupWStr(szCname)))
        {
            hRes=E_OUTOFMEMORY;
            goto End;
        }
   }
 End:
  WSACleanup();
  return hRes;
}   

HRESULT GetDomainHostedByThisMc( LPWSTR szDomain )
{
    OBJECT_ATTRIBUTES    obj_attr = { 0 };
    LSA_HANDLE          policy;
    NTSTATUS            nStatus = STATUS_SUCCESS;
    LSA_UNICODE_STRING szSystemName ;
    LSA_UNICODE_STRING *machine_to_open = NULL;
    WCHAR szName[MAX_PATH] = L"";
    USHORT dwLen = 0;
    WCHAR *wzCName=NULL;
    char *szCName=NULL;
    HRESULT hRes=S_OK;
    szSystemName.Buffer = NULL;
    int                 count;
   
    if( !szDomain )
    {
        hRes=E_FAIL;
        goto GetDomainHostedByThisMcAbort;
    }

    obj_attr.Length = sizeof(obj_attr);
    szDomain[0]        = L'\0';
    if(g_arVALOF[_p_CNAME_])
    {
// Whistler : LsaOpenPolicy fails due to build environment in whistler if the 
// computer name is given in IP address format. Hence, we get the host name from
// the IP address, incase it is a Whistler build. 

// This works fine for Garuda. In Future, make sure you remove this unnecessary
// work around.
#ifdef WHISTLER_BUILD
        
         if(NULL == (szCName=DupCStr(g_arVALOF[_p_CNAME_])))
        {
            hRes=E_OUTOFMEMORY;
            goto GetDomainHostedByThisMcAbort;
        }

        if(S_OK != (hRes=getHostNameFromIP(szCName,&wzCName)))
        {
            goto GetDomainHostedByThisMcAbort;
        }
#else

       if(NULL==(wzCName=_wcsdup(g_arVALOF[_p_CNAME_])))
       {
            hRes=E_OUTOFMEMORY;
            goto GetDomainHostedByThisMcAbort;
       }
#endif
        // dwLen is used to allocate memory to szSystemName.Buffer
       dwLen = (USHORT)wcslen(g_arVALOF[_p_CNAME_]) + 1;

       count = wcslen(wzCName);

       //count CANNOT be zero- Grammar will not allow empty computer names!!
       if(0==count)
       {
            hRes=IDS_E_INVALIDARG;
            goto GetDomainHostedByThisMcAbort;
       }
       
       if (((count > 1) && (wzCName[0] != L'\\' ) && (wzCName[1] != L'\\')) || (count==1))
       {
           dwLen += (USHORT)wcslen(SLASH_SLASH);
       }

       szSystemName.Buffer = (WCHAR *) malloc(dwLen*sizeof(WCHAR));
       if(szSystemName.Buffer==NULL)
       {
           hRes=E_OUTOFMEMORY;
           goto GetDomainHostedByThisMcAbort;
       }

       if (((count > 1) && (wzCName[0] != L'\\' ) && (wzCName[1] != L'\\'))|| (count==1))
       {
           wcscpy(szSystemName.Buffer, SLASH_SLASH); //no overflow. Fixed length.
       }
       else
       {
           szSystemName.Buffer[0]=L'\0';
       }

       szSystemName.MaximumLength = dwLen * sizeof(WCHAR);
       szSystemName.Length= szSystemName.MaximumLength - sizeof(WCHAR);

       wcsncat(szSystemName.Buffer, wzCName, dwLen - 1 - wcslen(szSystemName.Buffer));

       machine_to_open = &szSystemName;
    }

    nStatus = LsaOpenPolicy(
                machine_to_open,
                &obj_attr,
                POLICY_VIEW_LOCAL_INFORMATION,
                &policy
                );

    if (NT_SUCCESS(nStatus))
    {
        POLICY_ACCOUNT_DOMAIN_INFO  *info = NULL;

        nStatus = LsaQueryInformationPolicy(
                    policy,
                    PolicyAccountDomainInformation,
                    (PVOID *)&info
                    );

        if (NT_SUCCESS(nStatus)) 
        {
            hRes = S_OK;
            wcscpy( szDomain, info->DomainName.Buffer );
            LsaFreeMemory(info);
        }

        LsaClose(policy);
    }

GetDomainHostedByThisMcAbort:
    if(wzCName)
        free(wzCName);
    if(szCName)
        free(szCName);
    if(szSystemName.Buffer)
        free(szSystemName.Buffer);

    
    return hRes;
}





BOOL CheckForInt(int nProperty)
{
      char *szVal=NULL;
      BOOL fRet=FALSE;
      
      szVal = DupCStr(g_arVALOF[nProperty]);
      if(szVal)
      {
    	   if( atof(szVal) - _wtoi(g_arVALOF[nProperty]) )
    	       fRet = FALSE;
          else 
          	fRet = TRUE;
      }

      	SAFE_FREE(szVal);
      	return fRet;      	    
}

//  This function changes the user specified Computer name into the IP address
//  format and returns that. It also stores the specified name in the global 
//  variable g_szCName for future reference(in Printsettings()).

//  This is needed if we want to convert the etc\hosts alias name into the IP 
//  address as they themselves will not get resolve in NetUseAdd().

//  This function is called in this way in <fooadmin.y>
//               g_arVALOF[_p_CNAME_]=CopyHostName(yytext)
//  The above line replaces the call to DupWStr directly(FYI).
//
//   WE HAVE DECIDED NOT TO FIX THIS (WINDOWS BUG 153111) AS IT SLOWS
//   DOWN THE PERFORMANCE OF THE UTILS(It takes time to resolve--call
//   to gethostbyname()
/*


//  This will create the memory required and they need to be freed explicitly.
//  Please free the memory allocated to g_szCName as well.


WCHAR *CopyHostName(CHAR *szCName)
{
	//  Inorder to print the name of the computer in the same way as the user specified
	//  we store that in a global variable and use the same in PrintSettings()


     struct sockaddr_in addr;
     WCHAR *wzIPAddress=NULL;

     
     g_szCName=DupWStr(szCName);
     if(Get_Inet_Address(&addr,szCName))
     {
        wzIPAddress=DupWStr(inet_ntoa(addr.sin_addr));
          
     }

     return wzIPAddress;
 }   



*/        

// This function checks for the maximum integer and even 
// pops up the appropriate error message
// This function takes the integer value in g_arVALOF[]
// char array and compares with TEXT_MAX_INTEGER_VALUE
// if exceeds bails out with the error

HRESULT CheckForMaxInt(WCHAR *wzValue,DWORD ErrorCode)
{
    HRESULT hRes=S_OK;

    UINT SpecIntLen = wcslen(wzValue);
    UINT MaxIntLen = wcslen(TEXT_MAX_INTEGER_VALUE);

// If the length of the value exceeds the max integer length => 
// clearly error
// else
//   if same length, then strcmp will help in determining whether the value
//   exceeds the max limit.
    if(SpecIntLen > MaxIntLen)
        goto Error;
    else if ((SpecIntLen == MaxIntLen) && (wcscmp(wzValue,TEXT_MAX_INTEGER_VALUE)>0))
           goto Error;
    else goto End;
Error:
     hRes=E_FAIL;
     ShowError(ErrorCode);
     goto End;
   
End:
    return hRes;
}


// This function does a pre-analysis of the command line and copies the appropriate 
// values into the global variable. This is for handling two cases.
//      (1) To take care of DBCS chars that may appear in the command line. Since the
//         actual lexical analyser can not handle DBCS and the we couldn't make use 
//         of the multi-byte conversion aptly (will result in two many special cases
//         in lex specification), hence we are preprocessing the command line and 
//         eliminating the processing of DBCS in lex.
//      (2) Some admintools, they take so complicated parameters that we can not put 
//          them into specification. The actual problem is that there are several such
//          parameters and they can take any character theoritically.:(

// Arguments:
//
//      (1) argc: Number of arguments in the command line.
//                To make sure that we are exceeding the limits
//      (2) argv: The actual command line parameters
//      (3) nProperty: This is the index to where the "value" of the option
//                  is tobe stored.
//      (4) option: This is the actual option (text string), we are trying to
//                  analyze and this guyz value should be store appropriately.
//      (5) currentOp: This is an index to the current argument that is being
//                  analyzed.
//      (6) nextOp: <OUT>  This is an index to the next command line argument
//                  that needs to be taken care.
//      (7) Success: <OUT> Flag which indicates whether we have done something
//                  to the command line parameters (did the option match)
//      (8) IsSpaceAllowed: This is a flag to indicate whether the case (5)
//                  below as a valid scenario.


// This function returns ERROR_SUCCESS on Success
// else error is returned

DWORD PreAnalyzer(int argc,
                 WCHAR *argv[],
                 int nProperty,
                 WCHAR *wzOption,
                 int nCurrentOp,
                 int *nNextOp,
                 BOOL *fSuccess,
                 BOOL IsSpaceAllowed
                 )
{
    // *******************************************************************//
    // These are the five ways in which the actual command line
    // arguments can be specified.
    // 
    //  Case (1) : <option>=<value>
    //  Case (2) : <option>=space<value>
    //  Case (3) : <option>space=space<value>
    //  Case (4) : <option>space=<value>
    //  Case (5) : <option>space<value>
    //
    // We need to take care of all the five case while analyzing
    // *******************************************************************//


    DWORD nOptionStrLen = wcslen(wzOption);
    
    //  buffer: This buffer stores the argv[i] and argv[i+1] (if exists)
    //          and used for processing the argument.
    
    WCHAR wzBuffer[_MAX_PATH + 1];

    DWORD nStartIndex,nRunIndex;

    BOOL fEqualToFound = FALSE;

    DWORD nRetVal = ERROR_SUCCESS;

    DWORD nBufferLength;

    DWORD dwSize;

    *fSuccess = FALSE;
    
    // Initializing the next op to current op
    *nNextOp=nCurrentOp;

    // Check whether wzOption is the current op.
    // if not return.

    if(_wcsnicmp(wzOption,argv[nCurrentOp],nOptionStrLen))
         goto End;

    // Buffer is framed

    wzBuffer[_MAX_PATH] = L'\0';    // Ensure NULL termination

    wcsncpy(wzBuffer, argv[nCurrentOp], _MAX_PATH);

    if(argc>nCurrentOp+1)
    {
        // We have one more command line argument (i+1)
        // so concat it to the buffer

        INT used_up_length = wcslen(wzBuffer);

        _snwprintf(
            wzBuffer + used_up_length, 
            _MAX_PATH - used_up_length, 
            L" %s",
            argv[nCurrentOp+1]
            );
    }

    nBufferLength = wcslen(wzBuffer);
    
    nStartIndex = nOptionStrLen;

    nRunIndex = nStartIndex;

    // Skip space and any "=" sign inbetween
    while((nRunIndex < nStartIndex + 3 ) && (nRunIndex < nBufferLength))
    {
        if(L'=' == wzBuffer[nRunIndex])
        {
            if(fEqualToFound)
                break;
            else
            {
                fEqualToFound = TRUE;
                nRunIndex++;
                continue;
            }
        }
        else
            if(L' ' == wzBuffer[nRunIndex])
            {
                nRunIndex++;
                continue;
            }
        else
            break;
    }

    // Filter missing value for the option

    if(nRunIndex>=nBufferLength)
    {
        if(nRunIndex == nOptionStrLen + 2)
        {
            // Case (3) 
            // Check whether the option is missing.

            if(NULL == argv[nCurrentOp+2])
            {
                nRetVal=E_FAIL;
                goto End;
            }
            else
                // Increment nRunIndex to point to next valid input
                    nRunIndex++;
        }
        else
        { // Missing value for (1),(2),(4) and (5)
            nRetVal = E_FAIL;
            goto End;
        }
    }

    // If no "=" is present and also space is not allowed
    // as a valid scenario, then invalid according to usage
    
    if((!fEqualToFound)&&(!IsSpaceAllowed))
    {
        nRetVal = IDR_TELNET_CONTROL_VALUES;
        goto End;
    }

    // Now we expect the actual value of the option at the nRunIndex.
    // So, based on the value of nRunIndex, we can say which argv[]
    // has the value and can take any actions if required.

    switch(nRunIndex - nStartIndex)
    {
        case 1:
            // Falls under Cases (1) or (5) as stated above
            if(L'=' == wzBuffer[nOptionStrLen])
            {
                // Clearly case (1)
                if(NULL == (g_arVALOF[nProperty] = _wcsdup(argv[nCurrentOp]+nOptionStrLen+1)))
                {
                    nRetVal = IDS_E_OUTOFMEMORY;// Error
                    ShowError(IDS_E_OUTOFMEMORY);
                    goto End;
                }
                *nNextOp = nCurrentOp ;
                *fSuccess = TRUE;
            }
            else
            { // case (5)
                if(NULL == (g_arVALOF[nProperty] = _wcsdup(argv[nCurrentOp+1])))
                {
                    nRetVal = IDS_E_OUTOFMEMORY;// Error
                    ShowError(IDS_E_OUTOFMEMORY);
                    goto End;
                }
                *nNextOp = nCurrentOp + 1;
                *fSuccess = TRUE;
            }
            break;
            
        case 2:
            // Falls under Cases (2) and (4)
            if(L'=' == argv[nCurrentOp+1][0])
            {
                // Case (4)
                // Skip the "=" and then copy.

                if(NULL == (g_arVALOF[nProperty] = _wcsdup(argv[nCurrentOp+1]+1)))
                {
                    nRetVal = IDS_E_OUTOFMEMORY;// Error
                    ShowError(IDS_E_OUTOFMEMORY);
                    goto End;
                }
                *nNextOp = nCurrentOp + 1;
                *fSuccess = TRUE;
            }
            else
            {
                // Case (2)
                if(NULL == (g_arVALOF[nProperty] = _wcsdup(argv[nCurrentOp+1])))
                {
                    nRetVal = IDS_E_OUTOFMEMORY;// Error
                    ShowError(IDS_E_OUTOFMEMORY);
                    goto End;
                }
                *nNextOp = nCurrentOp + 1;
                *fSuccess = TRUE;
            }
            break;
            
        case 3:
            // Falls under case (3)
            if (NULL == (g_arVALOF[nProperty] = _wcsdup(argv[nCurrentOp+2])))
            {
                nRetVal = IDS_E_OUTOFMEMORY;// Error
                ShowError(IDS_E_OUTOFMEMORY);
                goto End;
            }
            *nNextOp = nCurrentOp + 2;
            *fSuccess = TRUE;
            break;

        case 0:
            // Something unexpected encountered
            // Give it to the actual analyzer for analyzis.

            *nNextOp = nCurrentOp;
            break;
    }

if(ERROR_SUCCESS == nRetVal)    
{
    if(NULL==g_arVALOF[nProperty])
    {
         nRetVal = E_FAIL;
         goto End;
    }
}
 
End:
    return nRetVal;
}


// This function will print the missing registry value information

// Why didn't we add the following string to Cladmin.rc? The reasons are
//      (1) We don't want to get Whistler and Garuda Telnet out of sync
//      (2) This code should NEVER get executed and it is only for the
//          the instrumentation. We can remove this before shipping.

#define    IDS_E_MISSING_REGVALUE		L"The registry value '%s' is missing.\n"


DWORD PrintMissingRegValueMsg(int nProperty, int nNumofprop)
{
    WCHAR szRegValue[_MAX_PATH + 1];

    wcsncpy(g_szMsg, IDS_E_MISSING_REGVALUE, ARRAYSIZE(g_szMsg)-1);
    g_szMsg[ARRAYSIZE(g_szMsg)-1]=L'\0';

    _snwprintf(
        szRegValue,
        _MAX_PATH, 
        L"%s\\%s", 
        g_arCLASSname[g_arPROP[nProperty][nNumofprop].classname],
        g_arPROP[nProperty][nNumofprop].propname);

    szRegValue[_MAX_PATH] = L'\0';  // ensure NULL termination

    fwprintf(stdout, g_szMsg, szRegValue );

    return S_OK;
}
void HelperFreeStringList(PSTRING_LIST pList)
{
    if(pList && pList->count && pList->strings)
    {
        DWORD i;

        for(i=0; i < pList->count; ++i)
        {
            if(pList->strings[i])
                delete [] pList->strings[i];
        }

        delete pList->strings;

        pList->count = 0;
        pList->strings = NULL;
    }
}

HRESULT LoadNTDomainList(LPTSTR szMachine)
{
    HRESULT hRes = S_OK;
    int dwSize=0, dwType=0;
    DWORD nIndex = 0;
    LPTSTR lpComputer = NULL, lpDomains = NULL, lpPrimary = NULL;
    LPBYTE lpBuffer = NULL;        

    //MessageBoxW(NULL, (LPWSTR)L"LoadNTDomainList", L"LoadNTDomainList1", MB_OK);
    //
    // Add all trusted domains to the list
    //
    dwSize = GetTrustedDomainList(szMachine,&lpDomains, &lpPrimary);

    //
    // free previous values
    //
    HelperFreeStringList(&g_slNTDomains);
    //
    // initialize list again
    //
    g_slNTDomains.count = 0;
    //
    // two for primary domain
    // and this computer
    // one more in case dwSize is -1
    // hence total is 3
    //
    g_slNTDomains.strings = new LPTSTR[dwSize + 3];
    ATLASSERT(g_slNTDomains.strings != NULL);
    if(NULL==g_slNTDomains.strings)
    {
        ShowError(IDS_E_OUTOFMEMORY);
        hRes = E_OUTOFMEMORY;
        goto Done;       
    }
    ZeroMemory(g_slNTDomains.strings, (dwSize + 3)*sizeof(LPTSTR));

    if((dwSize > 0) && lpDomains)
    {
        LPTSTR ptr = lpDomains;
        //
        // add domains to our list
        //
        while(*ptr)
        {
            ptr = _tcsupr(ptr);
        	g_slNTDomains.strings[g_slNTDomains.count] = new TCHAR[_tcslen(ptr) + 1];
            ATLASSERT(g_slNTDomains.strings[g_slNTDomains.count] != NULL);
            ZeroMemory(g_slNTDomains.strings[g_slNTDomains.count], (_tcslen(ptr) + 1)*sizeof(TCHAR));
            _tcscpy(g_slNTDomains.strings[g_slNTDomains.count], ptr);
            ptr += _tcslen(ptr) + 1;
            g_slNTDomains.count++;
        }
        delete [] lpDomains;
        lpDomains = NULL;
    }

    
    if(lpPrimary && *lpPrimary)
    {
        lpPrimary = _tcsupr(lpPrimary);

        for(nIndex=0;nIndex<g_slNTDomains.count;nIndex++)
        {
            if(!_tcsicmp(lpPrimary, g_slNTDomains.strings[nIndex]))
                break;
        }

        if(nIndex == g_slNTDomains.count)
        {
            // 
            // lpPrimary was not in the list of domains that we
            // got. add it.
            //
        	g_slNTDomains.strings[g_slNTDomains.count] = new TCHAR[_tcslen(lpPrimary) + 1];
            ATLASSERT(g_slNTDomains.strings[g_slNTDomains.count] != NULL);
            ZeroMemory(g_slNTDomains.strings[g_slNTDomains.count], (_tcslen(lpPrimary) + 1)*sizeof(TCHAR));
            _tcscpy(g_slNTDomains.strings[g_slNTDomains.count], lpPrimary);
            g_slNTDomains.count++;
        }
    }

    //
    // Add our computer to be selected if this machine is not the
    // domain controler (which should already be in the list)
    //
    //Pass NULL if local machine. Else machine name.
    NetServerGetInfo(_wcsicmp(szMachine,SZLOCALMACHINE) ? szMachine : NULL, 101, &lpBuffer);
    if(lpBuffer && ((LPSERVER_INFO_101)lpBuffer)->sv101_type &
          ((DWORD)SV_TYPE_DOMAIN_CTRL | (DWORD)SV_TYPE_DOMAIN_BAKCTRL))
    {        
        /*
        we got this computer as one of the domains. no need to add it to the 
        list again. just do nothing.
        */
		;
    }
    else
    {
        TCHAR szName[MAX_PATH + 2];
        ZeroMemory(szName, sizeof(szName));
        DWORD dwLen = sizeof(szName);
        //if it's not a local machine, keep it as it is. Else make it \\localhost.
            if (_tcsicmp(szMachine,SZLOCALMACHINE))
            {   
                if( _tcslen(szMachine) > (MAX_PATH - 2) )
                    goto Done;

                if (_tcsncmp(szMachine,L"\\\\",2))
                    _tcscpy(szName,L"\\\\");
                _tcscat(szName,szMachine);
                _tcsupr(szName);
            }
            else if(GetComputerName(szName + 2, &dwLen))
            {
                szName[0] = TEXT('\\');
                szName[1] = TEXT('\\');                
            }
            else 
                goto Done;

            //
            // add this also to our list of domains
            //
        	g_slNTDomains.strings[g_slNTDomains.count] = new TCHAR[_tcslen(szName) + 1];
            ATLASSERT(g_slNTDomains.strings[g_slNTDomains.count] != NULL);
            ZeroMemory(g_slNTDomains.strings[g_slNTDomains.count], (_tcslen(szName) + 1)*sizeof(TCHAR));
            _tcscpy(g_slNTDomains.strings[g_slNTDomains.count], szName);
            g_slNTDomains.count++;
    }

Done:
    if(lpBuffer)
    {
        NetApiBufferFree(lpBuffer);
    }

    if(lpPrimary)
    {
        delete [] lpPrimary;
    }

 	return hRes;
}

int GetTrustedDomainList(LPTSTR szMachine, LPTSTR * list, LPTSTR * primary)
{
    //BOOL stat = TRUE;
    DWORD ret=0, size=0, type=0;
    LPTSTR cache = NULL, trusted = NULL;
    HKEY hKey=NULL;
    CRegKey key;
    HKEY    hKeyRemoteRegistry = NULL;    

    STRING_LIST slValues = {0, NULL};
    
    *list = NULL;


	if (FAILED(RegConnectRegistry(_wcsicmp(szMachine,SZLOCALMACHINE) ? szMachine : NULL,
                HKEY_LOCAL_MACHINE,
                &hKeyRemoteRegistry)))
    {
        goto ABORT;
    }


    if(key.Open(hKeyRemoteRegistry, WINLOGONNT_KEY) == ERROR_SUCCESS)
    {
        size = 0;
        
        if(key.QueryValue(*primary, CACHEPRIMARYDOMAIN_VALUE, &size) == ERROR_SUCCESS)
        {
            *primary = new TCHAR[size+1];           
            ATLASSERT(primary != NULL);

            if(*primary)
            {
                ZeroMemory(*primary, (size+1)*sizeof(TCHAR));

                if(key.QueryValue(*primary, CACHEPRIMARYDOMAIN_VALUE, &size) != ERROR_SUCCESS)
                {
                    goto ABORT;
                }
                else
                {
                    key.Close();
                    // don't quit. we have to get the list of trusted domains also.
                }
            }
        }
        else
        {
            key.Close();
            goto ABORT;
        }
    }
    else
    {
        goto ABORT;
    }

    //
    // Get trusted domains. In NT40 the CacheTrustedDomains 
    // under winlogon doesn't exist. I did find that Netlogon has a field 
    // called TrustedDomainList which seems to be there in both NT351 and NT40.
    // Winlogon has a field called DCache which seem to cache the trusted
    // domains. I'm going to check Netlogon:TrustedDomainList first. If it
    // fails: Check for Winlogon:CacheTrustedDomains then Winlogon:DCache.
    // Warning -- Winlogon:CacheTrustedDomains is a REG_SZ and
    // Netlogon:TrustedDomainList and Winlogon:DCache are REG_MULTI_SZ.
    // Note -- see 4.0 Resource Kit documentation regarding some of these
    // values
    //
    if(key.Open(hKeyRemoteRegistry, NETLOGONPARAMETERS_KEY) == ERROR_SUCCESS)
    {
        size = 0;

        if(key.QueryValue(trusted, TRUSTEDDOMAINLIST_VALUE, &size) == ERROR_SUCCESS)
        {
            trusted = new TCHAR[size + 1];
            ATLASSERT(trusted != NULL);

            if(trusted)
            {
                ZeroMemory(trusted, (size+1)*sizeof(TCHAR));
         
                if(key.QueryValue(trusted, TRUSTEDDOMAINLIST_VALUE, &size) != ERROR_SUCCESS)
                {
                    key.Close();
                    delete [] trusted;
                    trusted = NULL;
                    *list = NULL;
                    //goto ABORT;
                }
                else
                {
                    *list = trusted;
                    key.Close();
                }
            }
            else
            {
                key.Close();
                goto ABORT;
            }
        }
        else
        {
            key.Close();
            *list = NULL;            
        }        
    }
    
    if(!(*list) && (key.Open(hKeyRemoteRegistry, WINLOGONNT_KEY) == ERROR_SUCCESS))
    {
        size = 0;

        if(key.QueryValue(cache, CACHETRUSTEDDOMAINS_VALUE, &size) == ERROR_SUCCESS)
        {
            cache = new TCHAR[size + 1];
            ATLASSERT(cache != NULL);

            if(cache)
            {
                ZeroMemory(cache, size);

                if(key.QueryValue(cache, CACHETRUSTEDDOMAINS_VALUE, &size) == ERROR_SUCCESS)
                {        
                    //
                    // comma separated list
                    //
                    LPTSTR lpComma = NULL;
                    LPTSTR lpDelim = TEXT(",");

                    lpComma = _tcstok(cache, lpDelim);

                    while(lpComma)
                    {
                        lpComma = _tcstok(NULL, lpDelim);
                    }
                    
                    *list = cache;
                }
                else
                {
                    key.Close();
                    delete [] cache;
                    cache = NULL;
                    *list = NULL;
                }
            }
            else
            {
                key.Close();
                goto ABORT;
            }               
        }
        else
        {
            *list = NULL;
            key.Close();
        }
    }
    
    if(!(*list) && (key.Open(hKeyRemoteRegistry, WINLOGONNT_KEY) == ERROR_SUCCESS))
    {        
        size = 0;

        if(key.QueryValue(trusted, DCACHE_VALUE, &size) == ERROR_SUCCESS)
        {
            trusted = new TCHAR[size + 1];
            ATLASSERT(trusted != NULL);

            if(trusted)
            {
                if(key.QueryValue(trusted, DCACHE_VALUE, &size) == ERROR_SUCCESS)
                {
                    *list = trusted;
                }
                else
                {
                    key.Close();
                    delete [] trusted;
                    trusted = NULL;
                    *list = NULL;
                }
            }
            else
            {
                key.Close();
                goto ABORT;
            }
        }
        else
        {
            key.Close();
            *list = NULL;            
        }
    }

    // VikasT
    // Apparantely, on NT5 DCache doesn't exist. I found that there is a key
    // under Winlogon named DomainCache that has all the cached domains.
    // So, lets get that
    //
    //if(!(*list) && (RegOpenkeyEx(hKeyRemoteRegistry, DOMAINCACHE_KEY, 0, KEY_READ, &hKey) == ERROR_SUCCESS))
    //if(!(*list) && (RegOpenkey(hKeyRemoteRegistry, DOMAINCACHE_KEY, &hKey) == ERROR_SUCCESS))
    if(!(*list) && (key.Open(hKeyRemoteRegistry, DOMAINCACHE_KEY) == ERROR_SUCCESS))
    {        
        size = 0;
        TCHAR * pszTemp = NULL;
        TCHAR   szTemp[MAX_PATH];
        DWORD   dwNumberOfValues = 0;
        DWORD   dwIndex = 0;
        DWORD   dwCharCount = MAX_PATH;
        HRESULT hrResult = ERROR_SUCCESS;

        hKey = HKEY(key);
        //
        // first find out how many values are present
        //
        hrResult = RegQueryInfoKey(
            hKey, //handle of key to query 
            NULL, // address of buffer for class string 
            NULL, // address of size of class string buffer 
            NULL, // reserved 
            NULL, // address of buffer for number of subkeys 
            NULL, // address of buffer for longest subkey name length 
            NULL, // address of buffer for longest class string length 
            &dwNumberOfValues, // address of buffer for number of value entries 
            NULL, // address of buffer for longest value name length 
            NULL, // address of buffer for longest value data length 
            NULL, // address of buffer for security descriptor length 
            NULL  // address of buffer for last write time 
            ); 
 
        if(hrResult != ERROR_SUCCESS)
            goto ABORT;

        slValues.count = dwNumberOfValues;
        slValues.strings = new LPTSTR[slValues.count];
        ATLASSERT(slValues.strings != NULL);
        if(slValues.strings == NULL)
            goto ABORT;

        ZeroMemory(slValues.strings, slValues.count * sizeof(LPTSTR));

        for(dwIndex = 0;dwIndex<dwNumberOfValues;dwIndex++)
        {
            dwCharCount = MAX_PATH;

            if(RegEnumValue(hKey, dwIndex, szTemp, &dwCharCount, NULL, NULL, NULL, NULL) == ERROR_NO_MORE_ITEMS)
                break;
            
            slValues.strings[dwIndex] = new TCHAR[dwCharCount+1];
            ATLASSERT(slValues.strings[dwIndex] != NULL);
            if(slValues.strings[dwIndex] == NULL)
                goto ABORT;
            ZeroMemory(slValues.strings[dwIndex], (dwCharCount+1) * sizeof(TCHAR));
            _tcscpy(slValues.strings[dwIndex], szTemp);
            // add up the return buffer size
            size += dwCharCount+1;
        }

        if(dwNumberOfValues > 0)
        {
            trusted = new TCHAR[size + 1];
            ATLASSERT(trusted != NULL);
            if( trusted == NULL )
            {
                goto ABORT;
            }

            ZeroMemory(trusted, (size+1)*sizeof(TCHAR));
            pszTemp = trusted;
            for(dwIndex = 0;dwIndex<slValues.count;dwIndex++)
            {
                _tcscpy(pszTemp, slValues.strings[dwIndex]);
                pszTemp += _tcslen(slValues.strings[dwIndex]) + 1;
            }
        }
        *list = trusted;
        size = dwNumberOfValues;
    }

    goto Done;

ABORT:
    // set the return value;
    size = (DWORD)-1;
    if(*primary != NULL)
    {
        delete [] *primary;
        *primary = NULL;
    }

    if(trusted != NULL)
    {
        delete [] trusted;
        trusted = NULL;
    }

    if(cache != NULL)
    {
        delete [] cache;
        cache = NULL;
    }

Done:
    if (hKeyRemoteRegistry != NULL)
    {
        RegCloseKey(hKeyRemoteRegistry);
        hKeyRemoteRegistry = NULL;
    }

    
    if(hKey != NULL)
    {
        RegCloseKey(hKey);
        hKey = NULL;
        key.m_hKey = NULL;
    }

    HelperFreeStringList(&slValues);

    return size;
}

/*
    Description:
        This function will try to load the string from XPSP1RES.DLL if the dll is present. Else
        it will try to load from the normal resource dll. If that fails, it will copy the English string
        into the destination buffer
    Parameters:
        [in] Message ID of the resource string to be loaded.
        [out] Destination string.
        [in] Maximum size of destination buffer.
        [in] English string to be copied if everything else fails
    Return value:
        Number of TCHARs.
*/
int TnLoadString(int msg_id, LPTSTR string, int max_size_of_buffer, LPCTSTR english_string)
{
    int retval = 0;

    //try loading from cladmin.dll or the image itself 
    if(g_hResource)
    {
        retval = LoadString(g_hResource,msg_id,string,max_size_of_buffer);
        if(retval != 0) 
            goto Done; //Resource string loaded from the cladmin.dll or image.
    }
    //Try loading from XP Res dll only if the OS version is XP
    if(g_hXPResource)
    {
        retval = LoadString(g_hXPResource,msg_id,string,max_size_of_buffer);
        if(retval != 0) 
            goto Done; //Resource string loaded from xpsp1res.dll
    }
    //Everything failed. Copy the English string and set retval to number of characters
    //in English string
    _tcsncpy(string,english_string,max_size_of_buffer-1);
    string[max_size_of_buffer-1] = _T('\0');
    retval = _tcslen(english_string);
Done:
    return retval;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\admin\common.h ===
//---------------------------------------------------------
//   Copyright (c) 1999-2000 Microsoft Corporation
//
//   common.h
//
//   vikram K.R.C. (vikram_krc@bigfoot.com)
//
//   The header file common to telnet command line admin tool's code
//   and the other code.
//          (May-2000)
//---------------------------------------------------------

#ifndef __commonh__
#define __commonh__

#define _MAX_CLASS_NAMES_     3
#define _MAX_PROPS_            19
#define _MAX_NUMOF_PROPNAMES_   3
#define _MAX_QUERY_CONTROL_     10

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\simple\simptcp.h ===
/*++

Copyright (c) 1993 Microsoft Corporation

Module Name:

    simptcp.h

Abstract:

    Main header file for simple TCP/IP services.

Author:

    David Treadwell (davidtr)    02-Aug-1993

Revision History:

--*/

#pragma once

#define FD_SETSIZE      65536
#define LISTEN_BACKLOG  5

#include <stdio.h>
#include <stdlib.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <winsock2.h>
#include <ws2tcpip.h>
#include "tcpsvcs.h"
#include "simpmsg.h"
#include "time.h"
#include "winnls.h"


#define ALLOCATE_HEAP(a) RtlAllocateHeap( RtlProcessHeap( ), 0, a )
#define FREE_HEAP(p) RtlFreeHeap( RtlProcessHeap( ), 0, p )

INT
SimpInitializeEventLog (
    VOID
    );

VOID
SimpTerminateEventLog(
    VOID
    );

VOID
SimpLogEvent(
    DWORD   Message,
    WORD    SubStringCount,
    CHAR    *SubStrings[],
    DWORD   ErrorCode
    );


#ifdef DBG
#define DEBUG_PRINT(X) DbgPrint X
#else
#define DEBUG_PRINT(X) /* Nothing */
#endif

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\simple\simptcp.c ===
/*++

Copyright (c) 1992 Microsoft Corporation

Module Name:

    Simpsvc.c

Abstract:

    Supports several simple TCP/IP services in a single thread: TCP Echo,
    UDP Echo, Daytime, Null, Chargen.

Author:

    David Treadwell (davidtr)    3-Mar-1993

Revision History:

--*/

#include "simptcp.h"

#define MAX_UDP_CHARGEN_RESPONSE 7030
#define MAX_DATE_BUFFER_SIZE 2000

// Number of services, counting tcp and udp versions as separate
#define NUM_SERVICES 10

typedef struct _FAMILY {
    short  family;
    SOCKET tcpEcho;
    SOCKET udpEcho;
    SOCKET tcpDaytime;
    SOCKET udpDaytime;
    SOCKET tcpDiscard;
    SOCKET udpDiscard;
    SOCKET tcpChargen;
    SOCKET udpChargen;
    SOCKET tcpQotd;
    SOCKET udpQotd;
} FAMILY;

FAMILY family[] = {
 { AF_INET,  INVALID_SOCKET,INVALID_SOCKET,INVALID_SOCKET,INVALID_SOCKET,
             INVALID_SOCKET,INVALID_SOCKET,INVALID_SOCKET,INVALID_SOCKET,
             INVALID_SOCKET,INVALID_SOCKET },

 { AF_INET6, INVALID_SOCKET,INVALID_SOCKET,INVALID_SOCKET,INVALID_SOCKET,
             INVALID_SOCKET,INVALID_SOCKET,INVALID_SOCKET,INVALID_SOCKET,
             INVALID_SOCKET,INVALID_SOCKET },
};

#define NUM_FAMILIES (sizeof(family) / sizeof(FAMILY))

DWORD IoBufferSize = 4096;
PCHAR IoBuffer = NULL;

WSADATA WsaData;

RTL_CRITICAL_SECTION CriticalSection;
BOOL InitializedCriticalSection = FALSE;

typedef struct _TCP_CLIENT_INFO {
    SOCKET SocketHandle;
    SOCKADDR_STORAGE RemoteAddress;
    INT RemoteAddressLen;
    HANDLE ThreadHandle;
    SHORT ServicePort;
} TCP_CLIENT_INFO, *PTCP_CLIENT_INFO;

#define MAX_TCP_CLIENTS 1000
PTCP_CLIENT_INFO TcpClients = NULL;

#define LISTEN_BACKLOG 5

#define MAX_IDLE_TICKS 10 * 60 * 1000    // 10 minutes
#define SELECT_TIMEOUT 5 * 60            // 5 minutes

DWORD MaxTcpClients = MAX_TCP_CLIENTS;
DWORD MaxIdleTicks = MAX_IDLE_TICKS;
DWORD SelectTimeout = SELECT_TIMEOUT;


PFD_SET ReadfdsStore, Readfds;

SHORT TcpEchoPort;
SHORT UdpEchoPort;
SHORT TcpDiscardPort;
SHORT UdpDiscardPort;
SHORT TcpChargenPort;
SHORT UdpChargenPort;
SHORT TcpDaytimePort;
SHORT UdpDaytimePort;
SHORT TcpQotdPort;
SHORT UdpQotdPort;

#define INVALID_PORT 0

BOOL DoTcpEcho = TRUE;
BOOL DoUdpEcho = TRUE;
BOOL DoTcpDiscard = TRUE;
BOOL DoUdpDiscard = TRUE;
BOOL DoTcpChargen = TRUE;
BOOL DoUdpChargen = TRUE;
BOOL DoTcpDaytime = TRUE;
BOOL DoUdpDaytime = TRUE;
BOOL DoTcpQotd = TRUE;
BOOL DoUdpQotd = TRUE;

struct {
    PBOOL Boolean;
    PWSTR ValueName;
} RegistryBooleans[] = {
    &DoTcpEcho, L"EnableTcpEcho",
    &DoUdpEcho, L"EnableUdpEcho",
    &DoTcpDiscard, L"EnableTcpDiscard",
    &DoUdpDiscard, L"EnableUdpDiscard",
    &DoTcpChargen, L"EnableTcpChargen",
    &DoUdpChargen, L"EnableUdpChargen",
    &DoTcpDaytime, L"EnableTcpDaytime",
    &DoUdpDaytime, L"EnableUdpDaytime",
    &DoTcpQotd, L"EnableTcpQotd",
    &DoUdpQotd, L"EnableUdpQotd",
    NULL, NULL
};

struct {
    PDWORD Dword;
    PWSTR ValueName;
} RegistryDwords[] = {
    &MaxTcpClients, L"MaxTcpClients",
    &MaxIdleTicks, L"MaxIdleTicks",
    &SelectTimeout, L"SelectTimeout",
    &IoBufferSize, L"IoBufferSize",
    NULL, NULL
};

SERVICE_STATUS SimpServiceStatus;
SERVICE_STATUS_HANDLE SimpServiceStatusHandle;

HANDLE SimpPauseEvent = NULL;
SOCKET SimpQuitSocket;

BOOL SimpServiceExit = FALSE;

PVOID ChargenBuffer = NULL;
DWORD ChargenBufferSize;

PVOID QotdBuffer = NULL;
DWORD QotdQuoteCount;
struct {
    DWORD QuoteLength;
    PCHAR Quote;
} *QotdStrings = NULL;
PWSTR QotdFileName = NULL;
HANDLE QotdFileHandle = NULL;
HANDLE QotdFileMapping = NULL;

VOID
AnnounceServiceStatus (
    VOID
    );

VOID
ControlResponse(
    DWORD opCode
    );

VOID
AbortTcpClient (
    IN SOCKET Socket
    );

INT
AcceptTcpClient (
    IN SOCKET ListenSocket,
    IN SHORT Port
    );

VOID
DeleteTcpClient (
    IN DWORD ArraySlot,
    IN BOOLEAN Graceful
    );

VOID
DoSimpleServices (
    VOID
    );


VOID
FormatDaytimeResponse (
    IN PCHAR Buffer,
    IN PDWORD BufferLength
    );

VOID
FormatQotdResponse (
    IN PCHAR Buffer,
    IN PDWORD BufferLength
    );

SHORT
GetServicePort (
    IN PCHAR Service,
    IN PCHAR Protocol
    );

INT
InitializeChargen (
    VOID
    );

INT
InitializeQotdQuotes (
    VOID
    );

INT
ReadRegistry (
    VOID
    );

BOOL
OpenTcpSocket (
    OUT SOCKET *pSocket,
    IN  INT     FamIdx,
    IN  SHORT   Port
    );

BOOL
OpenUdpSocket (
    OUT SOCKET *pSocket,
    IN  INT     FamIdx,
    IN  SHORT   Port
    );

INT
SimpInitializeEventLog (
    VOID
    );

VOID
SimpTerminateEventLog(
    VOID
    );

VOID
SimpLogEvent(
    DWORD   Message,
    WORD    SubStringCount,
    CHAR    *SubStrings[],
    DWORD   ErrorCode
    );

DWORD
ThreadEntry (
    LPVOID lpThreadParameter
    );

INT
ProcessFamily(
    IN INT FamIdx)
{
    INT err=NO_ERROR;
    INT i;
    SOCKADDR_STORAGE remoteAddr;
    INT remoteAddrLength;
    u_long one = 1;

        if ( family[FamIdx].tcpEcho != INVALID_SOCKET && FD_ISSET( family[FamIdx].tcpEcho, Readfds ) ) {
            i = AcceptTcpClient( family[FamIdx].tcpEcho, TcpEchoPort );
        }

        if ( family[FamIdx].tcpDiscard != INVALID_SOCKET && FD_ISSET( family[FamIdx].tcpDiscard, Readfds ) ) {
            i = AcceptTcpClient( family[FamIdx].tcpDiscard, TcpDiscardPort );
        }

        if ( family[FamIdx].tcpDaytime != INVALID_SOCKET && FD_ISSET( family[FamIdx].tcpDaytime, Readfds ) ) {

            SOCKET acceptSocket;
            DWORD length=IoBufferSize;

            //
            // A client is making a TCP daytime request.  First accept
            // the connection, then send the current time-of-day string
            // to the client, then close the socket.
            //

            acceptSocket = accept( family[FamIdx].tcpDaytime, NULL, NULL );

            if ( acceptSocket != INVALID_SOCKET ) {
                FormatDaytimeResponse( IoBuffer, &length );
                send( acceptSocket, IoBuffer, length, 0 );
                err = closesocket( acceptSocket );
                ASSERT( err != SOCKET_ERROR );
            }
        }

        if ( family[FamIdx].tcpChargen != INVALID_SOCKET && FD_ISSET( family[FamIdx].tcpChargen, Readfds ) ) {
            i = AcceptTcpClient( family[FamIdx].tcpChargen, TcpChargenPort );
            if ( i != -1 ) {
                one = 1;
                err = ioctlsocket( TcpClients[i].SocketHandle, FIONBIO, &one );
                if ( err == SOCKET_ERROR ) {
                    DeleteTcpClient( i, FALSE );
                }
            }
        }

        if ( family[FamIdx].tcpQotd != INVALID_SOCKET && FD_ISSET( family[FamIdx].tcpQotd, Readfds ) ) {

            SOCKET acceptSocket;
            DWORD length = IoBufferSize;

            //
            // A client is making a TCP Qotd request.  First accept
            // the connection, then send the quote of the day
            // to the client, then close the socket.
            //

            acceptSocket = accept( family[FamIdx].tcpQotd, NULL, NULL );
            
            if ( acceptSocket != INVALID_SOCKET ) {
                FormatQotdResponse( IoBuffer, &length );
                send( acceptSocket, IoBuffer, length, 0 );
                err = closesocket( acceptSocket );
                ASSERT( err != SOCKET_ERROR );
            }
        }

        // ================================================================
        // Udp services.

        if ( family[FamIdx].udpEcho != INVALID_SOCKET && FD_ISSET( family[FamIdx].udpEcho, Readfds ) ) {

            remoteAddrLength = sizeof(remoteAddr);

            err = recvfrom(
                      family[FamIdx].udpEcho,
                      IoBuffer,
                      IoBufferSize,
                      0,
                      (PSOCKADDR)&remoteAddr,
                      &remoteAddrLength
                      );

            if( ntohs(SS_PORT(&remoteAddr)) > IPPORT_RESERVED
                && err != SOCKET_ERROR )
            {
                    err = sendto(
                        family[FamIdx].udpEcho,
                        IoBuffer,
                        err,
                        0,
                        (PSOCKADDR)&remoteAddr,
                        remoteAddrLength
                    );
            }
        }

        if ( family[FamIdx].udpDiscard != INVALID_SOCKET && FD_ISSET( family[FamIdx].udpDiscard, Readfds ) ) {
            err = recvfrom(
                      family[FamIdx].udpDiscard,
                      IoBuffer,
                      IoBufferSize,
                      0,
                      NULL,
                      NULL
                      );
            ASSERT( err != SOCKET_ERROR );

            // Nothing to sendto in this case.
        }

        if ( family[FamIdx].udpDaytime != INVALID_SOCKET && FD_ISSET( family[FamIdx].udpDaytime, Readfds ) ) {

            DWORD length;

            remoteAddrLength = sizeof(remoteAddr);

            err = recvfrom(
                      family[FamIdx].udpDaytime,
                      IoBuffer,
                      IoBufferSize,
                      0,
                      (PSOCKADDR)&remoteAddr,
                      &remoteAddrLength
                      );


            if( (ntohs(SS_PORT(&remoteAddr)) > IPPORT_RESERVED) && (err != SOCKET_ERROR) )
            {
                length=IoBufferSize;
                FormatDaytimeResponse( IoBuffer, &length );

                err = sendto(
                    family[FamIdx].udpDaytime,
                    IoBuffer,
                    length,
                    0,
                    (PSOCKADDR)&remoteAddr,
                    remoteAddrLength
                );
            }
        }

        if ( family[FamIdx].udpChargen != INVALID_SOCKET && FD_ISSET( family[FamIdx].udpChargen, Readfds ) ) {

            DWORD length;

            remoteAddrLength = sizeof(remoteAddr);

            err = recvfrom(
                      family[FamIdx].udpChargen,
                      IoBuffer,
                      IoBufferSize,
                      0,
                      (PSOCKADDR)&remoteAddr,
                      &remoteAddrLength
                      );


            // Infinite loop attack, when we get a request from
            // another service. - MohsinA, 30-Jun-97.

            if( (ntohs(SS_PORT(&remoteAddr)) > IPPORT_RESERVED) && (err != SOCKET_ERROR) )
            {
                srand( GetTickCount( ) );

                length = (rand( ) * MAX_UDP_CHARGEN_RESPONSE) / RAND_MAX;
                if (length > ChargenBufferSize) {
                    length=ChargenBufferSize;
                }
                err = sendto(
                    family[FamIdx].udpChargen,
                    ChargenBuffer,
                    length,
                    0,
                    (PSOCKADDR)&remoteAddr,
                    remoteAddrLength
                );

            }
        }

        if ( family[FamIdx].udpQotd != INVALID_SOCKET && FD_ISSET( family[FamIdx].udpQotd, Readfds ) ) {

            DWORD length = IoBufferSize;

            remoteAddrLength = sizeof(remoteAddr);

            err = recvfrom(
                      family[FamIdx].udpQotd,
                      IoBuffer,
                      IoBufferSize,
                      0,
                      (PSOCKADDR)&remoteAddr,
                      &remoteAddrLength
                      );

            if( (ntohs(SS_PORT(&remoteAddr)) > IPPORT_RESERVED) && (err != SOCKET_ERROR) )
            {
                FormatQotdResponse( IoBuffer, &length );

                err = sendto(
                    family[FamIdx].udpQotd,
                    IoBuffer,
                    length,
                    0,
                    (PSOCKADDR)&remoteAddr,
                    remoteAddrLength
                );
            }
        }

    return err;
}


VOID
ServiceEntry (
    IN DWORD argc,
    IN LPWSTR argv[],
    IN PTCPSVCS_GLOBAL_DATA pGlobalData
    )

/*++

Routine Description:

    This is the "main" routine for the simple TCP/IP services.  The
    containing process will call this routine when we're supposed to
    start up.

Arguments:

Return Value:

    None.

--*/

{
    INT err=ERROR_GEN_FAILURE;
    TIMEVAL timeout;
    INT i, FamIdx;
    DWORD maxFdSetSize;
    NTSTATUS status;
    BOOL bOk;

    //
    // Initialize all the status fields so that subsequent calls to
    // SetServiceStatus need to only update fields that changed.
    //

    SimpServiceStatus.dwServiceType = SERVICE_WIN32;
    SimpServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    SimpServiceStatus.dwControlsAccepted = 0;
    SimpServiceStatus.dwCheckPoint = 1;
    SimpServiceStatus.dwWaitHint = 30000;  // 30 seconds

    SimpServiceStatus.dwWin32ExitCode = NO_ERROR;
    SimpServiceStatus.dwServiceSpecificExitCode = NO_ERROR;

    //
    // Initialize server to receive service requests by registering the
    // control handler.
    //

    SimpServiceStatusHandle = RegisterServiceCtrlHandler(
                                   TEXT("SimpTcp"),
                                   ControlResponse
                                   );

    if ( SimpServiceStatusHandle == 0 ) {
        err = GetLastError();
        goto exit;
    }

    AnnounceServiceStatus( );

    //
    // Initialize our critical section.
    //

    status = RtlInitializeCriticalSection( &CriticalSection );
    if ( !NT_SUCCESS(status) ) {
        goto exit;
    }

    InitializedCriticalSection = TRUE;

    //
    // Initialize the eventlog.
    //

    err = SimpInitializeEventLog( );
    ASSERT( err == NO_ERROR );

    //
    // Read all registry information.
    //

    err = ReadRegistry( );
    if ( err != NO_ERROR ) {
        goto exit;
    }

    //
    // Allocate memory for the IO buffer.
    //

    IoBuffer = RtlAllocateHeap( RtlProcessHeap( ), 0, IoBufferSize );

    //
    // Allocate memory for the array of TCP clients.
    //

    TcpClients = RtlAllocateHeap(
                     RtlProcessHeap( ),
                     0,
                     MaxTcpClients * sizeof(TcpClients[0])
                     );
    if ( TcpClients == NULL ) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // Initialize the chargen data buffer.
    //

    if ( DoTcpChargen || DoUdpChargen ) {
        err = InitializeChargen( );
        if ( err != NO_ERROR ) {
            DoUdpChargen = FALSE;
            DoTcpChargen = FALSE;
        }
    }

    //
    // Initialize the quote of the day quotes.
    //

    if ( DoTcpQotd || DoUdpQotd ) {
        err = InitializeQotdQuotes( );
        if ( err != NO_ERROR ) {
            DoUdpQotd = FALSE;
            DoTcpQotd = FALSE;
        }
    }

    //
    // Initialize client socket array.
    //

    for ( i = 0; (DWORD)i < MaxTcpClients; i++ ) {
        TcpClients[i].SocketHandle = INVALID_SOCKET;
        TcpClients[i].ThreadHandle = NULL;
    }

    //
    // Determine how large our FD_SET structures must be, then allocate
    // space for them.  We have 1 quit socket, plus 10 services * 2 families.
    //

    maxFdSetSize = FIELD_OFFSET(fd_set, fd_array[1 + NUM_FAMILIES * NUM_SERVICES]);


    Readfds = RtlAllocateHeap( RtlProcessHeap( ), 0, maxFdSetSize );
    ReadfdsStore = RtlAllocateHeap( RtlProcessHeap( ), 0, maxFdSetSize );

    if ( Readfds == NULL || ReadfdsStore == NULL ) {
        err = ERROR_NOT_ENOUGH_MEMORY;
        goto exit;
    }

    //
    // Initialize the pause event.  We use this event to stop activity
    // when the service is paused.
    //

    SimpPauseEvent = CreateEvent( NULL, TRUE, TRUE, NULL );
    if ( SimpPauseEvent == NULL ) {
        err = GetLastError( );
        goto exit;
    }

    //
    // Initialize the Windows Sockets DLL.
    //

    err = WSAStartup( 0x0101, &WsaData );
    if ( err == SOCKET_ERROR ) {
        err = GetLastError( );
        goto exit;
    }

    //
    // Initialize the FD sets we'll use.
    //

    FD_ZERO( ReadfdsStore );

    //
    // Open the "quit" socket.  We close this socket when we need to
    // shut down in order to wake up the main thread from it's select()
    // and begin shutdown.
    //

    SimpQuitSocket = socket( AF_INET, SOCK_DGRAM, 0 );
    if ( SimpQuitSocket != INVALID_SOCKET ) {
        FD_SET( SimpQuitSocket, ReadfdsStore );
    } else {
        err = GetLastError( );
        goto exit;
    }

    //
    // First find the port numbers for all our services.
    //

    TcpEchoPort = GetServicePort( "echo", "tcp" );
    if ( TcpEchoPort == INVALID_PORT && DoTcpEcho ) {
        SimpLogEvent(
            SIMPTCP_CANT_FIND_TCP_ECHO_PORT,
            0,
            NULL,
            WSAGetLastError( )
            );

        DoTcpEcho = FALSE;
    }

    UdpEchoPort = GetServicePort( "echo", "udp" );
    if ( UdpEchoPort == INVALID_PORT && DoUdpEcho ) {
        SimpLogEvent(
            SIMPTCP_CANT_FIND_UDP_ECHO_PORT,
            0,
            NULL,
            WSAGetLastError( )
            );

        DoUdpEcho = FALSE;
    }

    TcpDiscardPort = GetServicePort( "discard", "tcp" );
    if ( TcpDiscardPort == INVALID_PORT && DoTcpDiscard ) {
        SimpLogEvent(
            SIMPTCP_CANT_FIND_TCP_DISCARD_PORT,
            0,
            NULL,
            WSAGetLastError( )
            );

        DoTcpDiscard = FALSE;
    }

    UdpDiscardPort = GetServicePort( "discard", "udp" );
    if ( UdpDiscardPort == INVALID_PORT && DoUdpDiscard ) {
        SimpLogEvent(
            SIMPTCP_CANT_FIND_UDP_DISCARD_PORT,
            0,
            NULL,
            WSAGetLastError( )
            );

        DoUdpDiscard = FALSE;
    }

    TcpDaytimePort = GetServicePort( "daytime", "tcp" );
    if ( TcpDaytimePort == INVALID_PORT && DoTcpDaytime ) {
        SimpLogEvent(
            SIMPTCP_CANT_FIND_TCP_DAYTIME_PORT,
            0,
            NULL,
            WSAGetLastError( )
            );

        DoTcpDaytime = FALSE;
    }

    UdpDaytimePort = GetServicePort( "daytime", "udp" );
    if ( UdpDaytimePort == INVALID_PORT && DoUdpDaytime ) {
        SimpLogEvent(
            SIMPTCP_CANT_FIND_UDP_DAYTIME_PORT,
            0,
            NULL,
            WSAGetLastError( )
            );

        DoUdpDaytime = FALSE;
    }

    TcpChargenPort = GetServicePort( "chargen", "tcp" );
    if ( TcpChargenPort == INVALID_PORT && DoTcpChargen ) {
        SimpLogEvent(
            SIMPTCP_CANT_FIND_TCP_CHARGEN_PORT,
            0,
            NULL,
            WSAGetLastError( )
            );

        DoTcpChargen = FALSE;
    }

    UdpChargenPort = GetServicePort( "chargen", "udp" );
    if ( UdpChargenPort == INVALID_PORT && DoUdpChargen ) {
        SimpLogEvent(
            SIMPTCP_CANT_FIND_UDP_CHARGEN_PORT,
            0,
            NULL,
            WSAGetLastError( )
            );

        DoUdpChargen = FALSE;
    }

    TcpQotdPort = GetServicePort( "qotd", "tcp" );
    if ( TcpQotdPort == INVALID_PORT && DoTcpQotd ) {
        SimpLogEvent(
            SIMPTCP_CANT_FIND_TCP_QOTD_PORT,
            0,
            NULL,
            WSAGetLastError( )
            );

        DoTcpQotd = FALSE;
    }

    UdpQotdPort = GetServicePort( "qotd", "udp" );
    if ( UdpQotdPort == INVALID_PORT && DoUdpQotd ) {
        SimpLogEvent(
            SIMPTCP_CANT_FIND_UDP_QOTD_PORT,
            0,
            NULL,
            WSAGetLastError( )
            );

        DoUdpQotd = FALSE;
    }

    //
    // Open, bind, and listen on the necessary ports.
    //

    if ( DoTcpEcho ) {
        bOk = FALSE;
        for (i=0; i<NUM_FAMILIES; i++) {
            bOk |= OpenTcpSocket( &family[i].tcpEcho, i, TcpEchoPort );
        }
        if ( !bOk ) {
            SimpLogEvent(
                SIMPTCP_CANT_OPEN_TCP_ECHO_PORT,
                0,
                NULL,
                WSAGetLastError( )
                );
        }
    }

    if ( DoUdpEcho ) {
        bOk = FALSE;
        for (i=0; i<NUM_FAMILIES; i++) {
            bOk |= OpenUdpSocket( &family[i].udpEcho, i, UdpEchoPort );
        }
        if ( !bOk ) {
            SimpLogEvent(
                SIMPTCP_CANT_OPEN_UDP_ECHO_PORT,
                0,
                NULL,
                WSAGetLastError( )
                );
        }
    }

    if ( DoTcpDiscard ) {
        bOk = FALSE;
        for (i=0; i<NUM_FAMILIES; i++) {
            bOk |= OpenTcpSocket( &family[i].tcpDiscard, i, TcpDiscardPort );
        }
        if ( !bOk ) {
            SimpLogEvent(
                SIMPTCP_CANT_OPEN_TCP_DISCARD_PORT,
                0,
                NULL,
                WSAGetLastError( )
                );
        }
    }

    if ( DoUdpDiscard ) {
        bOk = FALSE;
        for (i=0; i<NUM_FAMILIES; i++) {
            bOk |= OpenUdpSocket( &family[i].udpDiscard, i, UdpDiscardPort );
        }
        if ( !bOk ) {
            SimpLogEvent(
                SIMPTCP_CANT_OPEN_UDP_DISCARD_PORT,
                0,
                NULL,
                WSAGetLastError( )
                );
        }
    }

    if ( DoTcpDaytime ) {
        bOk = FALSE;
        for (i=0; i<NUM_FAMILIES; i++) {
            bOk |= OpenTcpSocket( &family[i].tcpDaytime, i, TcpDaytimePort );
        }
        if ( !bOk ) {
            SimpLogEvent(
                SIMPTCP_CANT_OPEN_TCP_DAYTIME_PORT,
                0,
                NULL,
                WSAGetLastError( )
                );
        }
    }

    if ( DoUdpDaytime ) {
        bOk = FALSE;
        for (i=0; i<NUM_FAMILIES; i++) {
            bOk |= OpenUdpSocket( &family[i].udpDaytime, i, UdpDaytimePort );
        }
        if ( !bOk ) {
            SimpLogEvent(
                SIMPTCP_CANT_OPEN_UDP_DAYTIME_PORT,
                0,
                NULL,
                WSAGetLastError( )
                );
        }
    }

    if ( DoTcpChargen ) {
        bOk = FALSE;
        for (i=0; i<NUM_FAMILIES; i++) {
            bOk |= OpenTcpSocket( &family[i].tcpChargen, i, TcpChargenPort );
        }
        if ( !bOk ) {
            SimpLogEvent(
                SIMPTCP_CANT_OPEN_TCP_CHARGEN_PORT,
                0,
                NULL,
                WSAGetLastError( )
                );
        }
    }

    if ( DoUdpChargen ) {
        bOk = FALSE;
        for (i=0; i<NUM_FAMILIES; i++) {
            bOk |= OpenUdpSocket( &family[i].udpChargen, i, UdpChargenPort );
        }
        if ( !bOk ) {
            SimpLogEvent(
                SIMPTCP_CANT_OPEN_UDP_CHARGEN_PORT,
                0,
                NULL,
                WSAGetLastError( )
                );
        }
    }

    if ( DoTcpQotd ) {
        bOk = FALSE;
        for (i=0; i<NUM_FAMILIES; i++) {
            bOk |= OpenTcpSocket( &family[i].tcpQotd, i, TcpQotdPort );
        }
        if ( !bOk ) {
            SimpLogEvent(
                SIMPTCP_CANT_OPEN_TCP_QOTD_PORT,
                0,
                NULL,
                WSAGetLastError( )
                );
        }
    }

    if ( DoUdpQotd ) {
        bOk = FALSE;
        for (i=0; i<NUM_FAMILIES; i++) {
            bOk |= OpenUdpSocket( &family[i].udpQotd, i, UdpQotdPort );
        }
        if ( !bOk ) {
            SimpLogEvent(
                SIMPTCP_CANT_OPEN_UDP_QOTD_PORT,
                0,
                NULL,
                WSAGetLastError( )
                );
        }
    }

    //
    // Announce that we have successfully started.
    //

    SimpServiceStatus.dwCurrentState = SERVICE_RUNNING;
    SimpServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                         SERVICE_ACCEPT_PAUSE_CONTINUE;
    SimpServiceStatus.dwCheckPoint = 0;
    SimpServiceStatus.dwWaitHint = 0;

    AnnounceServiceStatus( );

    //
    // Loop waiting for connect attempts or datagrams, and service them
    // when they arrive.
    //

    for (;;) {

        //
        // First initialize the FD sets we'll actually use for select().
        //

        RtlCopyMemory( Readfds, ReadfdsStore, maxFdSetSize );

        //
        // Now wait for something to happen.  Timeout occaisonally
        // so that we can kill idle TCP clients.
        //

        timeout.tv_sec = SelectTimeout;
        timeout.tv_usec = 0;

        err = select( 0, Readfds, NULL, NULL, &timeout );

        //
        // If the service is shutting down, stop processing requests
        // and exit.
        //

        if ( SimpServiceExit ) {
            err = NO_ERROR;
            goto exit;
        }

        if ( err == SOCKET_ERROR ) {

            //
            // This is bad.  We should do something intelligent here.
            //
            int MappedErr;
            MappedErr= WSAGetLastError();

            //
            // Log an error and quit
            //
            SimpLogEvent(
                SIMPTCP_SOCKET_ERROR_SERVICE_FAILURE,
                0,
                NULL,
                MappedErr
            );
            
            err = MappedErr;
            closesocket( SimpQuitSocket );
            
            goto exit;
        }

        //
        // If the service is paused, wait for it to become unpaused.
        //

        err = WaitForSingleObject( SimpPauseEvent, INFINITE );
        ASSERT( err != WAIT_FAILED );

        //
        // Figure out what happened and act accordingly.
        //
        for (FamIdx=0; FamIdx<NUM_FAMILIES; FamIdx++)
        {
            err = ProcessFamily(FamIdx);
        }


    } // infinite loop.

exit:

    //
    // Announce that we're going down.
    //

    SimpServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
    SimpServiceStatus.dwCheckPoint = 1;
    SimpServiceStatus.dwWaitHint = 20000;   // 20 seconds

    SimpServiceStatus.dwWin32ExitCode = err;
    SimpServiceStatus.dwServiceSpecificExitCode = err;

    AnnounceServiceStatus( );

    //
    // Delete our critical section.
    //

    if ( InitializedCriticalSection ) {
        InitializedCriticalSection = FALSE;
        RtlDeleteCriticalSection( &CriticalSection );
    }

    //
    // Close all opened listening sockets.
    //

    for (i=0; i<NUM_FAMILIES; i++) {
    if ( family[i].tcpEcho != INVALID_SOCKET ) {
        closesocket( family[i].tcpEcho );
    }
    if ( family[i].udpEcho != INVALID_SOCKET ) {
        closesocket( family[i].udpEcho );
    }
    if ( family[i].tcpDiscard != INVALID_SOCKET ) {
        closesocket( family[i].tcpDiscard );
    }
    if ( family[i].udpDiscard != INVALID_SOCKET ) {
        closesocket( family[i].udpDiscard );
    }
    if ( family[i].tcpDaytime != INVALID_SOCKET ) {
        closesocket( family[i].tcpDaytime );
    }
    if ( family[i].udpDaytime != INVALID_SOCKET ) {
        closesocket( family[i].udpDaytime );
    }
    if ( family[i].tcpChargen != INVALID_SOCKET ) {
        closesocket( family[i].tcpChargen );
    }
    if ( family[i].udpChargen != INVALID_SOCKET ) {
        closesocket( family[i].udpChargen );
    }
    }

    //
    // Close all connected TCP sockets.
    //

    for ( i = 0; TcpClients != NULL && (DWORD)i < MaxTcpClients; i++ ) {

        if ( TcpClients[i].SocketHandle != INVALID_SOCKET ) {
            AbortTcpClient( TcpClients[i].SocketHandle );
        }
    }

    //
    // Should wait here for all threads to exit!
    //

    //
    // Deinitialize the eventlog.
    //

    SimpTerminateEventLog( );

    //
    // Free allocated memory.
    //

    if ( IoBuffer != NULL ) {
        RtlFreeHeap( RtlProcessHeap( ), 0, IoBuffer );
    }

    if ( TcpClients != NULL ) {
        RtlFreeHeap( RtlProcessHeap( ), 0, TcpClients );
    }

    if ( Readfds != NULL ) {
        RtlFreeHeap( RtlProcessHeap( ), 0, Readfds );
    }

    if ( ReadfdsStore != NULL ) {
        RtlFreeHeap( RtlProcessHeap( ), 0, ReadfdsStore );
    }

    if ( ChargenBuffer != NULL ) {
        RtlFreeHeap( RtlProcessHeap( ), 0, ChargenBuffer );
    }

    if ( QotdBuffer != NULL ) {
        UnmapViewOfFile( QotdBuffer );
    }

    if ( QotdFileMapping != NULL ) {
        CloseHandle( QotdFileMapping );
    }

    if ( QotdFileHandle != NULL ) {
        CloseHandle( QotdFileHandle );
    }

    if ( QotdFileName != NULL ) {
        RtlFreeHeap( RtlProcessHeap( ), 0, QotdFileName );
    }

    if ( QotdStrings != NULL ) {
        RtlFreeHeap( RtlProcessHeap( ), 0, QotdStrings );
    }

    //
    // Free SimpPauseEvent's memory
    //
    if (SimpPauseEvent)
        CloseHandle(SimpPauseEvent);
    
    //
    // Announce that we're down.
    //

    SimpServiceStatus.dwCurrentState = SERVICE_STOPPED;
    SimpServiceStatus.dwControlsAccepted = 0;
    SimpServiceStatus.dwCheckPoint = 0;
    SimpServiceStatus.dwWaitHint = 0;

    SimpServiceStatus.dwWin32ExitCode = err;
    SimpServiceStatus.dwServiceSpecificExitCode = err;

    AnnounceServiceStatus( );

    return;

} // ServiceEntry


BOOL
OpenTcpSocket (
    OUT SOCKET *pSocket,
    IN  INT      FamIdx,
    IN  SHORT    Port
    )
{
    SOCKADDR_STORAGE localAddr;
    INT localAddrLen;
    INT err;
    INT one = 1;

    *pSocket = socket( family[FamIdx].family, SOCK_STREAM, 0 );
    if ( *pSocket == INVALID_SOCKET ) {
        return FALSE;
    }

    RtlZeroMemory( &localAddr, sizeof(localAddr) );
    SS_PORT(&localAddr) = Port;
    localAddr.ss_family = family[FamIdx].family;


    err =
    setsockopt( *pSocket,
                SOL_SOCKET,
                SO_EXCLUSIVEADDRUSE,
                (char *) &one,
                sizeof(  one  )
                );
    if( err ){
        DEBUG_PRINT(("simptcp: OpenTcpSocket: ExclusiveAddressUse failed %d\n",
                     GetLastError() ));
        closesocket(*pSocket);
        *pSocket = INVALID_SOCKET;
        return FALSE;
    }

    err = bind( *pSocket, (PSOCKADDR)&localAddr, sizeof(localAddr) );
    if ( err ==SOCKET_ERROR ) {
        closesocket(*pSocket);
        *pSocket = INVALID_SOCKET;
        return FALSE;
    }

    err = listen( *pSocket, LISTEN_BACKLOG );
    if ( err == SOCKET_ERROR ) {
        closesocket(*pSocket);
        *pSocket = INVALID_SOCKET;
        return FALSE;
    }

    err = setsockopt( *pSocket, SOL_SOCKET, SO_KEEPALIVE, (char *)&one, sizeof(one) );
    if ( err == INVALID_SOCKET ) {
        closesocket(*pSocket);
        *pSocket = INVALID_SOCKET;
        return FALSE;
    }

    FD_SET( *pSocket, ReadfdsStore );
    return TRUE;

} // OpenTcpSocket


BOOL
OpenUdpSocket (
    OUT SOCKET *pSocket,
    IN  INT     FamIdx,
    IN  SHORT   Port
    )
{
    SOCKADDR_STORAGE localAddr;
    INT         localAddrLen;
    INT         err;
    DWORD       broadcast_off = 0;
    DWORD       on = 1;

    *pSocket = socket( family[FamIdx].family, SOCK_DGRAM, 0 );
    if ( *pSocket == INVALID_SOCKET ) {
        return FALSE;
    }

    RtlZeroMemory( &localAddr, sizeof(localAddr) );
    SS_PORT(&localAddr) = Port;
    localAddr.ss_family = family[FamIdx].family;

    err =
    setsockopt( *pSocket,
                SOL_SOCKET,
                SO_EXCLUSIVEADDRUSE,
                (LPBYTE) &on,
                sizeof(  on  )
                );
    if( err ){
        DEBUG_PRINT(("simptcp: OpenUdpSocket: ExclusiveAddressUse failed %d\n",
                     GetLastError() ));
        closesocket(*pSocket);
        *pSocket = INVALID_SOCKET;
        return FALSE;
    }


    err = bind( *pSocket, (PSOCKADDR)&localAddr, sizeof(localAddr) );
    if ( err == SOCKET_ERROR ) {
        closesocket(*pSocket);
        *pSocket = INVALID_SOCKET;
        return FALSE;
    }

    err =
    setsockopt( *pSocket,
                SOL_SOCKET,
                SO_BROADCAST,
                (LPBYTE) &broadcast_off,
                sizeof(  broadcast_off )
                );

    if( err ){
        DEBUG_PRINT(("simptcp: OpenUdpSocket: broadcast_off failed %d\n",
                     GetLastError() ));
        closesocket(*pSocket);
        *pSocket = INVALID_SOCKET;
        return FALSE;
    }

    FD_SET( *pSocket, ReadfdsStore );
    return TRUE;

} // OpenUdpSocket


INT
AcceptTcpClient (
    IN SOCKET ListenSocket,
    IN SHORT Port
    )
{
    SOCKADDR_STORAGE remoteSockaddr;
    INT remoteSockaddrLength;
    DWORD i;
    SOCKET acceptSocket;
    DWORD threadId;
    NTSTATUS status;

    //
    // Always accept the socket first.
    //

    remoteSockaddrLength = sizeof(remoteSockaddr);

    acceptSocket =
        accept( ListenSocket, (PSOCKADDR)&remoteSockaddr, &remoteSockaddrLength );
    if ( acceptSocket == INVALID_SOCKET ) {
        return -1;
    }

    //
    // Use a critical section to protect access to our database of
    // TCP clients.
    //

    status = RtlEnterCriticalSection( &CriticalSection );
    ASSERT( NT_SUCCESS(status) );

    //
    // Attempt to find a TCP client slot.
    //

    for ( i = 0; i < MaxTcpClients; i++ ) {
        if ( TcpClients[i].SocketHandle == INVALID_SOCKET ) {
            break;
        }
    }

    //
    // If we're at the max count of TCP sockets, abort this new
    // socket.
    //

    if ( i >= MaxTcpClients ) {
        AbortTcpClient( acceptSocket );
        status = RtlLeaveCriticalSection( &CriticalSection );
        ASSERT( NT_SUCCESS(status) );
        return -1;
    }

    //
    // Initialize info about this client.
    //

    TcpClients[i].SocketHandle = acceptSocket;
    RtlCopyMemory(
        &TcpClients[i].RemoteAddress,
        &remoteSockaddr,
        sizeof(remoteSockaddr)
        );
    TcpClients[i].ServicePort = Port;

    //
    // We're in multi-threaded mode, so we'll create a separate thread
    // to handle this client.
    //

    TcpClients[i].ThreadHandle = CreateThread(
                                     NULL,
                                     0,
                                     ThreadEntry,
                                     UlongToPtr(i),
                                     0,
                                     &threadId
                                     );
    if ( TcpClients[i].ThreadHandle == NULL ) {
        AbortTcpClient( acceptSocket );
        TcpClients[i].SocketHandle = INVALID_SOCKET;
        status = RtlLeaveCriticalSection( &CriticalSection );
        ASSERT( NT_SUCCESS(status) );
        return -1;
    }

    //
    // The created thread will handle the connected client.
    //

    status = RtlLeaveCriticalSection( &CriticalSection );
    ASSERT( NT_SUCCESS(status) );

    return -1;

} // AcceptTcpClient


VOID
AbortTcpClient (
    IN SOCKET Socket
    )
{
    LINGER lingerInfo;
    INT err;

    //
    // First set the linger timeout on the socket to 0.  This will cause
    // the connection to be reset.
    //

    lingerInfo.l_onoff = 1;
    lingerInfo.l_linger = 0;

    err = setsockopt(
              Socket,
              SOL_SOCKET,
              SO_LINGER,
              (char *)&lingerInfo,
              sizeof(lingerInfo)
              );

    if ( err == SOCKET_ERROR ) {

        //
        // There's not too much we can do.  Just close the socket.
        //

        ASSERT(FALSE);
        closesocket( Socket );
        return;
    }

    //
    // Now close the socket.
    //

    err = closesocket( Socket );
    ASSERT( err != SOCKET_ERROR );

    return;

} // AbortTcpClient


VOID
DeleteTcpClient (
    IN DWORD ArraySlot,
    IN BOOLEAN Graceful
    )
{
    INT err;
    NTSTATUS status;

    status = RtlEnterCriticalSection( &CriticalSection );
    ASSERT( NT_SUCCESS(status) );

    ASSERT( TcpClients[ArraySlot].SocketHandle != INVALID_SOCKET );

    //
    // If this is to be an abortive disconnect, reset the connection.
    // Otherwise just close it normally.
    //

    if ( !Graceful ) {

        AbortTcpClient( TcpClients[ArraySlot].SocketHandle );

    } else {

        LINGER lingerInfo;
        INT one;

        //
        // Set the socket to blocking.
        //

        one = 0;
        ioctlsocket( TcpClients[ArraySlot].SocketHandle, FIONBIO, &one );

        //
        // Set the socket to linger no more than 60 seconds.
        //

        lingerInfo.l_onoff = 1;
        lingerInfo.l_linger = 60;

        setsockopt( TcpClients[ArraySlot].SocketHandle, SOL_SOCKET,
                        SO_LINGER, (char *)&lingerInfo, sizeof(lingerInfo) );

        err = closesocket( TcpClients[ArraySlot].SocketHandle );
        ASSERT( err != SOCKET_ERROR );
    }

    //
    // Close the thread handle, if appropriate.
    //

    if ( TcpClients[ArraySlot].ThreadHandle != NULL ) {
        CloseHandle( TcpClients[ArraySlot].ThreadHandle );
        TcpClients[ArraySlot].ThreadHandle = NULL;
    }

    //
    // Set the handle in the TCP clients array to INVALID_SOCKET so that we
    // know that it is free.
    //

    TcpClients[ArraySlot].SocketHandle = INVALID_SOCKET;

    status = RtlLeaveCriticalSection( &CriticalSection );
    ASSERT( NT_SUCCESS(status) );

    return;

} // DeleteTcpClient


VOID
FormatDaytimeResponse (
    IN PCHAR Buffer,
    IN PDWORD BufferLength
    )
{
    SYSTEMTIME timeStruct;
    int Status;
    int StringSize;

    char Buf1[MAX_DATE_BUFFER_SIZE];
    char Buf2[MAX_DATE_BUFFER_SIZE];


    *BufferLength=sprintf(Buffer,"");

    GetLocalTime( &timeStruct );
    Status = GetDateFormatA((LCID)LOCALE_SYSTEM_DEFAULT,
                           0,
                           &timeStruct,
                           NULL,
                           Buf1,
                           MAX_DATE_BUFFER_SIZE);

    if (Status == 0) {
        return;
    }

    Status = GetTimeFormatA((LCID)LOCALE_SYSTEM_DEFAULT,
                           0,
                           &timeStruct,
                           NULL,
                           Buf2,
                           MAX_DATE_BUFFER_SIZE);

    if (Status == 0) {
        return;
    }

    *BufferLength=sprintf(Buffer,"%s %s\n",Buf2,Buf1);

    return;

} // FormatDaytimeResponse



VOID
FormatQotdResponse (
    IN PCHAR Buffer,
    IN PDWORD BufferLength
    )
{
    INT index;
    UINT Length;
    
        
    if (QotdQuoteCount == 0) {
        sprintf(Buffer,"");
        *BufferLength=strlen(Buffer);
        return;
    }

    //
    // Choose a random quote index.
    //

    index = (rand( ) * (QotdQuoteCount - 1)) / RAND_MAX;

    //
    // Copy the quote into the output buffer. We want to make sure
    // we don't overflow the "Buffer" passed in.
    //

    Length = QotdStrings[index].QuoteLength;
    
    if (*BufferLength < Length) {
        Length = *BufferLength;
    } else {
        *BufferLength = Length;
    }
    
    strncpy( Buffer, QotdStrings[index].Quote, Length);
    
    return;

} // FormatDaytimeResponse


INT
InitializeQotdQuotes (
    VOID
    )
{

    BY_HANDLE_FILE_INFORMATION fileInformation;
    PCHAR buffer;
    DWORD i,CurQuoteIndex;


    if ( QotdFileName == NULL ) {
        return ERROR_FILE_NOT_FOUND;
    }

    //
    // Open the file containing quote information.
    //

    QotdFileHandle = CreateFileW(
                         QotdFileName,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL
                         );
    if ( QotdFileHandle == INVALID_HANDLE_VALUE ) {
        SimpLogEvent(
            SIMPTCP_CANT_OPEN_QUOTE_FILE,
            0,
            NULL,
            GetLastError( )
            );
        return GetLastError( );
    }

    //
    // Determine the size of the QOTD file.
    //

    if ( !GetFileInformationByHandle( QotdFileHandle, &fileInformation ) ) {
        SimpLogEvent(
            SIMPTCP_CANT_OPEN_QUOTE_FILE,
            0,
            NULL,
            GetLastError( )
            );
        return GetLastError( );
    }

    //
    // Create a file mapping for the quotes file and map it into
    // the address space of this process.
    //

    QotdFileMapping = CreateFileMapping(
                          QotdFileHandle,
                          NULL,
                          PAGE_READONLY,
                          0,
                          0,
                          NULL
                          );
    if ( QotdFileMapping == NULL ) {
        SimpLogEvent(
            SIMPTCP_CANT_OPEN_QUOTE_FILE,
            0,
            NULL,
            GetLastError( )
            );
        return GetLastError( );
    }

    QotdBuffer = MapViewOfFile(
                     QotdFileMapping,
                     FILE_MAP_READ,
                     0,
                     0,
                     0
                     );
    if ( QotdBuffer == NULL ) {
        SimpLogEvent(
            SIMPTCP_CANT_OPEN_QUOTE_FILE,
            0,
            NULL,
            GetLastError( )
            );
        return GetLastError( );
    }

    //
    // Count the number of lines in the file.  The number of lines
    // corresponds to the number of quotes.
    //

    QotdQuoteCount = 0;
    buffer = (PCHAR)QotdBuffer;

    for ( i = 0; i < fileInformation.nFileSizeLow; i++ ) {
        if ( *buffer++ == '%' ) {
            QotdQuoteCount++;
        }
    }

    //
    // Allocate a buffer to hold the quote array.
    //

    QotdStrings = RtlAllocateHeap(
                      RtlProcessHeap( ),
                      0,
                      sizeof(QotdStrings[0]) * QotdQuoteCount
                      );

    if ( QotdStrings == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }


    //
    // Initialize the quote array.
    //
    buffer = (PCHAR)QotdBuffer;

    CurQuoteIndex=0;
    for ( i = 0; i < QotdQuoteCount; i++ ) {

        QotdStrings[CurQuoteIndex].Quote = buffer;

        while ( (DWORD_PTR)buffer < (DWORD_PTR)QotdBuffer +
                    fileInformation.nFileSizeLow &&
                *buffer++ != '%' );

        QotdStrings[CurQuoteIndex].QuoteLength =
            (DWORD)((DWORD_PTR)buffer - (DWORD_PTR)QotdStrings[CurQuoteIndex].Quote) - 1;
        buffer += 2;

        //
        // If this quote if longer than the IO buffer size, skip over
        // it.  We can't use it.
        //

        if ( QotdStrings[CurQuoteIndex].QuoteLength < IoBufferSize ) {
            // Got a valid one
            CurQuoteIndex++;
        }
    }

    QotdQuoteCount=CurQuoteIndex;

    //
    // Initialize the random-number generator.
    //

    srand( GetTickCount( ) );

    return NO_ERROR;

} // InitializeQotdQuotes


#define CHARGEN_LINE_LENGTH 72
#define CHARGEN_REAL_LINE_LENGTH (CHARGEN_LINE_LENGTH + 2)
#define CHARGEN_MIN_CHAR ' '
#define CHARGEN_MAX_CHAR '~'
#define CHARGEN_DIFFERENCE (CHARGEN_MAX_CHAR - CHARGEN_MIN_CHAR)
#define CHARGEN_LINE_COUNT (CHARGEN_DIFFERENCE)
#define CHARGEN_BUFFER_LENGTH ((CHARGEN_LINE_LENGTH + 2) * (CHARGEN_LINE_COUNT))


INT
InitializeChargen (
    VOID
    )
{
    DWORD line;
    BYTE startChar = 0;
    DWORD i;

    //
    // Allocate a buffer for the chargen data.
    //

    ChargenBufferSize = CHARGEN_BUFFER_LENGTH;

    ChargenBuffer = RtlAllocateHeap(
                        RtlProcessHeap( ),
                        0,
                        ChargenBufferSize
                        );
    if ( ChargenBuffer == NULL ) {
        return ERROR_NOT_ENOUGH_MEMORY;
    }

    //
    // Fill in the buffer with the required pattern.
    //

    for ( line = 0; line < CHARGEN_LINE_COUNT; line++ ) {

        for ( i = 0; i < CHARGEN_LINE_LENGTH; i++ ) {

            *((PCHAR)ChargenBuffer + (line * CHARGEN_REAL_LINE_LENGTH) + i) =
                (CHAR)( ((startChar + i) % CHARGEN_DIFFERENCE) + CHARGEN_MIN_CHAR);
        }

        *((PCHAR)ChargenBuffer + (line * CHARGEN_REAL_LINE_LENGTH) + i) = 0x0D;
        *((PCHAR)ChargenBuffer + (line * CHARGEN_REAL_LINE_LENGTH) + i + 1) = 0x0A;

        startChar++;
    }

    return NO_ERROR;

} // InitializeQotdQuotes



SHORT
GetServicePort (
    IN PCHAR Service,
    IN PCHAR Protocol
    )
{
    PSERVENT serviceEntry;

    //
    // Get a servent structure for the specified service.
    //

    serviceEntry = getservbyname( Service, Protocol );

    if ( serviceEntry == NULL ) {
        // log an error!
        return INVALID_PORT;
    }

    //
    // Return the port for the specified service.
    //

    return serviceEntry->s_port;

} // GetServicePort


VOID
AnnounceServiceStatus (
    VOID
    )

/*++

Routine Description:

    Announces the service's status to the service controller.

Arguments:

    None.

Return Value:

    None.

--*/

{
    //
    // Service status handle is NULL if RegisterServiceCtrlHandler failed.
    //

    if ( SimpServiceStatusHandle == 0 ) {
        return;
    }

    //
    // Call SetServiceStatus, ignoring any errors.
    //

    SetServiceStatus(SimpServiceStatusHandle, &SimpServiceStatus);

} // AnnounceServiceStatus


VOID
ControlResponse(
    DWORD opCode
    )

{
    BOOL announce = TRUE;
    BOOL err;

    //
    // Determine the type of service control message and modify the
    // service status, if necessary.
    //

    switch( opCode ) {

        case SERVICE_CONTROL_STOP:

            //
            // Announce that we are in the process of stopping.
            //

            SimpServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
            AnnounceServiceStatus( );

            //
            // Remember that we're stopping.
            //

            SimpServiceExit = TRUE;

            //
            // Close a socket that the main select()er thread is
            // waiting on.  This will cause the select to wake up
            // and shutdown processing to commence.
            //

            closesocket( SimpQuitSocket );

            //
            // Let the main thread announce when the stop is done.
            //

            announce = FALSE;

            break;

        case SERVICE_CONTROL_PAUSE:

            //
            // Announce that we are in the process of pausing.
            //

            SimpServiceStatus.dwCurrentState = SERVICE_PAUSE_PENDING;
            AnnounceServiceStatus( );

            //
            // Remember that we're paused.
            //

            err = ResetEvent( SimpPauseEvent );
            ASSERT( err );

            //
            // Announce that we're now paused.
            //

            SimpServiceStatus.dwCurrentState = SERVICE_PAUSED;

            break;

        case SERVICE_CONTROL_CONTINUE:

            //
            // Announce that continue is pending.
            //

            SimpServiceStatus.dwCurrentState = SERVICE_CONTINUE_PENDING;
            AnnounceServiceStatus( );

            //
            // Remember that we're no longer paused.
            //

            err = SetEvent( SimpPauseEvent );
            ASSERT( err );

            //
            // Announce that we're active now.
            //

            SimpServiceStatus.dwCurrentState = SERVICE_RUNNING;

            break;

        case SERVICE_CONTROL_INTERROGATE:

            break;

        default:

            break;
    }

    if ( announce ) {
        AnnounceServiceStatus( );
    }

} // ControlResponse


INT
ReadRegistry (
    VOID
    )
{
    HKEY simptcpKey = NULL;
    ULONG error;
    ULONG i;
    DWORD dwordBuffer;
    DWORD bufferLength;
    DWORD type;
    DWORD qotdFileNameLength, Length;
    PWSTR fileName;

    //
    // First open our parameters key.
    //

    error = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                L"SYSTEM\\CurrentControlSet\\Services\\SimpTcp\\Parameters",
                0,
                MAXIMUM_ALLOWED,
                &simptcpKey
                );
    if ( error != NO_ERROR ) {
        return error;
    }

    //
    // Read BOOLEANs from the registry.
    //

    for ( i = 0; RegistryBooleans[i].Boolean != NULL; i++ ) {

        bufferLength = sizeof(dwordBuffer);

        error = RegQueryValueExW(
                    simptcpKey,
                    RegistryBooleans[i].ValueName,
                    NULL,
                    &type,
                    (PVOID)&dwordBuffer,
                    &bufferLength
                    );

        //
        // If we fail to read one of these for some reason, just skip it
        // and move on to the next one.
        //

        if ( error != NO_ERROR ) {
            continue;
        }

        if ( dwordBuffer == 0 ) {
            *RegistryBooleans[i].Boolean = FALSE;
        } else {
            *RegistryBooleans[i].Boolean = TRUE;
        }
    }

    //
    // Read DWORDs from the registry.
    //

    for ( i = 0; RegistryDwords[i].Dword != NULL; i++ ) {

        bufferLength = sizeof(RegistryDwords[i].Dword);

        RegQueryValueExW(
            simptcpKey,
            RegistryDwords[i].ValueName,
            NULL,
            &type,
            (PVOID)RegistryDwords[i].Dword,
            &bufferLength
            );
    }

    //
    // Read other known values from the registry.  Determine the size
    // of the QOTD file name.  We need this so that we can allocate
    // enough memory to hold it.
    //

    qotdFileNameLength = 0;

    error = RegQueryValueExW(
                simptcpKey,
                L"QotdFileName",
                NULL,
                &type,
                NULL,
                &qotdFileNameLength
                );

    if ( error == ERROR_MORE_DATA || error == NO_ERROR ) {

        fileName = RtlAllocateHeap(
                       RtlProcessHeap( ),
                       0,
                       qotdFileNameLength
                       );
        if ( fileName == NULL ) {
            return NO_ERROR;
        }

        error = RegQueryValueExW(
                    simptcpKey,
                    L"QotdFileName",
                    NULL,
                    &type,
                    (PVOID)fileName,
                    &qotdFileNameLength
                    );
        if ( error != NO_ERROR ) {
            RtlFreeHeap( RtlProcessHeap( ), 0, fileName );
            return NO_ERROR;
        }

        //
        // Expand the file name.
        //

        qotdFileNameLength = ExpandEnvironmentStringsW( fileName, NULL, 0 );

        if (qotdFileNameLength == 0) {
            RtlFreeHeap( RtlProcessHeap( ), 0, fileName );
            return GetLastError();
        }
        
        QotdFileName = RtlAllocateHeap(
                           RtlProcessHeap( ),
                           0,
                           qotdFileNameLength * sizeof(UNICODE_NULL)
                           );
        if ( QotdFileName == NULL ) {
            RtlFreeHeap( RtlProcessHeap( ), 0, fileName );
            return NO_ERROR;
        }

        Length = ExpandEnvironmentStringsW( fileName, QotdFileName,
                                           qotdFileNameLength );
        if (Length == 0) {
            RtlFreeHeap( RtlProcessHeap( ), 0, fileName );
            RtlFreeHeap( RtlProcessHeap( ), 0, QotdFileName );
            return GetLastError();
        }
        
    }

    return NO_ERROR;

} // ReadRegistry


DWORD
ThreadEntry (
    LPVOID lpThreadParameter
    )
{
    DWORD i = PtrToUlong(lpThreadParameter);
    PVOID ioBuffer;
    INT err;
    BOOLEAN graceful = TRUE;

    //
    // First, set the send and receive timeouts for the socket.  This
    // prevents a dead client from tying up our resources for too long.
    //

    err = setsockopt( TcpClients[i].SocketHandle, SOL_SOCKET, SO_SNDTIMEO,
                          (char *)&MaxIdleTicks, sizeof(MaxIdleTicks) );
    if ( err == SOCKET_ERROR ) {
        DeleteTcpClient( i, FALSE );
        return 0;
    }

    err = setsockopt( TcpClients[i].SocketHandle, SOL_SOCKET, SO_RCVTIMEO,
                          (char *)&MaxIdleTicks, sizeof(MaxIdleTicks) );
    if ( err == SOCKET_ERROR ) {
        DeleteTcpClient( i, FALSE );
        return 0;
    }

    //
    // Get a buffer to use locally for IO on the socket.
    //

    ioBuffer = RtlAllocateHeap( RtlProcessHeap( ), 0, IoBufferSize );
    if ( ioBuffer == NULL ) {
        DeleteTcpClient( i, FALSE );
        return 0;
    }

    //
    // Now service the client as appropriate.
    //

    if ( TcpClients[i].ServicePort == TcpEchoPort ) {

        //
        // If there is data on a client's echo socket,
        // receive some data and send it back.
        //

        do {

            err = recv(
                      TcpClients[i].SocketHandle,
                      ioBuffer,
                      IoBufferSize,
                      0
                      );
            if ( err == SOCKET_ERROR ) {
                graceful = FALSE;
            }

            if ( err > 0 ) {

                err = send(
                          TcpClients[i].SocketHandle,
                          ioBuffer,
                          err,
                          0
                          );
                if ( err == SOCKET_ERROR ) {
                    graceful = FALSE;
                }

            } else if ( err < 0 ) {

                graceful = FALSE;
            }

        } while ( err > 0 );
        
    } else if ( TcpClients[i].ServicePort == TcpChargenPort ) {

        INT one;
        INT error;
        TIMEVAL timeout;

        //
        // Set the socket to nonblocking.
        //

        one = 1;
        err = ioctlsocket( TcpClients[i].SocketHandle, FIONBIO, &one );
        if ( err == SOCKET_ERROR ) {
            graceful = FALSE;
        }

        //
        // Calculate the select() timeout.
        //

        timeout.tv_sec = MaxIdleTicks / 1000;
        timeout.tv_usec = MaxIdleTicks % 1000;

        //
        // Loop sending data.
        //

        do {

            err = send(
                      TcpClients[i].SocketHandle,
                      ChargenBuffer,
                      ChargenBufferSize,
                      0
                      );

            if ( err == SOCKET_ERROR ) {

                error = GetLastError( );

                if ( error != WSAEWOULDBLOCK ) {

                    graceful = FALSE;

                } else {

                    struct {
                        INT Count;
                        SOCKET Handle;
                    } readfds = { 0, 0 };
                    struct {
                        INT Count;
                        SOCKET Handle;
                    } writefds = { 0, 0 };

                    //
                    // The socket's send queue is blocked.  Wait for it to
                    // become unblocked.
                    //

                    FD_SET( TcpClients[i].SocketHandle, (PFD_SET)&readfds );
                    FD_SET( TcpClients[i].SocketHandle, (PFD_SET)&writefds );

                    err = select(
                              1,
                              (PFD_SET)&readfds,
                              (PFD_SET)&writefds,
                              NULL,
                              &timeout
                              );
                    if ( err <= 0 ) {
                        graceful = FALSE;
                    }
                }
            }

            err = recv(
                      TcpClients[i].SocketHandle,
                      ioBuffer,
                      IoBufferSize,
                      0
                      );
            if ( err == SOCKET_ERROR ) {
                if ( WSAGetLastError( ) != WSAEWOULDBLOCK ) {
                    graceful = FALSE;
                } else {
                    err = 1;
                }
            }

        } while ( err > 0 );

    } else if ( TcpClients[i].ServicePort == TcpDiscardPort ) {

        //
        // If there is data on a client's socket, just
        // receive some data and discard it.
        //

        do {

            err = recv(
                      TcpClients[i].SocketHandle,
                      ioBuffer,
                      IoBufferSize,
                      0
                      );
            if ( err == SOCKET_ERROR ) {
                graceful = FALSE;
            }

        } while ( err > 0 );

    } else {

        //
        // Something bad has happened.  Internal data
        // structures are corrupt.
        //

        ASSERT( FALSE );
    }

    //
    // Free the socket and the IO buffer and return.
    //

    DeleteTcpClient( i, graceful );
    RtlFreeHeap( RtlProcessHeap( ), 0, ioBuffer );

    return 0;

} // ThreadEntry
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\admin\resource.h ===
//{{NO_DEPENDENCIES}}
    // Microsoft Developer Studio generated include file.
    // Used by sfu.rc
    //

#ifndef WHISTLER_BUILD
	#include "resourc2.h"
#endif

#define IDR_TELNET_USAGE            200 //will not be used. Use IDR_NEW_TELNET_USAGE.
#define IDR_TELNET_ILLEGAL          201
#define IDR_NEW_TELNET_USAGE        206
#define IDR_TELNET_MUTUALLY_EXCLUSIVE_OPTIONS 207
#define IDR_MACHINE_NOT_AVAILABLE	211
#define IDR_SERVICE_NOT_INSTALLED	213
#define IDR_NOT_PRIVILEGED			214
#define IDR_TELNET_CONTROL_VALUES   221
#define IDR_TELNET_SECURITY_VALUES  222
#define IDR_CTRLAKEYMAP_VALUES      224
#define IDR_MAXFAIL_VALUES          225
#define IDR_MAXCONN_VALUES          226
#define IDR_TELNETPORT_VALUES       227
#define IDR_TIMEOUT_INTEGER_VALUES  228
#define IDR_KILLALL_VALUES          229
#define IDR_TIMEOUTACTIVE_VALUES    230
#define IDR_FILESIZE_VALUES         231
#define IDR_FOLDER_SPECIFIED        232
#define IDR_FILENAME_VALUES			237
#define IDR_UNSPECIFIED				244
#define IDR_ERROR_DRIVE_NOT_EXIST	246
#define IDR_ERROR_DRIVE_NOT_SPECIFIED 247
#define IDR_NOFILENAME				250
#define IDR_NO_AUTHENTICATION_MECHANISM 251 
#define IDR_SETTINGS_UPDATED		254
#define IDR_INVALID_MODE_OF_OPERATION   255
#define IDR_SESSION                 256
#define IDR_INVALID_SESSION         257
#define IDR_NO_MESSAGE              258
#define IDR_MESSAGE                 259
#define IDR_NO_ACTIVE_SESSION       261
#define IDR_SERVICE_CONTROLLED		262
#define IDR_AUDITLOCATION           263
#define IDR_AUDIT                   264
#define IDR_TIMEOUTACTIVE_TIMEOUT_MUTUAL_EXCLUSION 267
#define IDR_INVALID_NTDOMAIN		271
#define IDR_USERNAME 				 280
#define IDR_CLIENT                   281 
#define IDR_LOGONDATE               282  
#define IDR_IDLETIME                 284
#define IDR_MACHINE_SETTINGS                                   296
#define IDR_ALT_KEY_MAPPING                                    297
#define IDR_IDLE_SESSION_TIMEOUT                               298
#define IDR_MAX_CONNECTIONS                                    299
#define IDR_TELNET_PORT                                        300
#define IDR_MAX_FAILED_LOGIN_ATTEMPTS                          301
#define IDR_END_TASKS_ON_DISCONNECT                            302
#define IDR_MODE_OF_OPERATION                                  303
#define IDR_MAX_AUDIT_FILE_SIZE                                304
#define IDR_AUDIT_LOGS                                         305
#define  IDR_AUTHENTICATION_MECHANISM                           307
#define  IDR_STATE                                              308
#define  IDR_DEFAULT_DOMAIN                                     309

#define  IDR_YES                								401
#define  IDR_NO                									402
#define	IDR_TIME_HOURS											403
#define	IDR_TIME_MINUTES										404
#define	IDR_TIME_SECONDS										405
#define	IDR_MAPPING_NOT_ON										406
#define	IDR_STATUS_STOPPED										407
#define	IDR_STATUS_RUNNING										408
#define	IDR_STATUS_PAUSED										409
#define	IDR_STATUS_START_PENDING								410
#define	IDR_STATUS_STOP_PENDING									411
#define	IDR_STATUS_CONTINUE_PENDING								412
#define	IDR_STATUS_PAUSE_PENDING								413
#define IDR_SERVICE_PAUSED                      414
#define IDR_SERVICE_CONTINUED                   415
#define IDR_SERVICE_NOT_PAUSED                  416
#define IDR_SERVICE_NOT_CONTINUED               417

#define  IDR_AUDITING                                           325
#define IDR_DOMAIN 					 							330
#define IDR_TELNET_SESSIONS                                     333
#define IDR_MAXCONN_VALUES_WHISTLER                             340
#define IDR_MESSAGE_SENT                                        351
#define IDR_MAXCONN_VALUES_WORKSTATION                          357
#define IDR_SERVICE_NOT_CONTROLLED					397
#define IDR_INVALID_TELNET_SERVER_VERSION                       398
#define IDS_MISSING_FILE_OR_ARGUMENT_EX                         399
#define IDR_ALREADY_STARTED			                            400

#define	IDR_NEXT_STRING_RESOURCE_RESOURCE_H							425


#define	IDS_E_OPTIONGROUP 		                1245
#define	IDS_E_OUTOFMEMORY 		                1246
#define	IDS_E_UNEXPECTED 		                1258
#define        IDS_DUP_OPTION_ON_CL                     2285
#define        IDR_LONG_COMMAND_LINE                   2347
#define        IDR_PASSWD_PROMPT                       2348
#define        IDR_VERIFY_SERVICE_INSTALLED			2359
#define         IDS_E_LOGINNOTSPECIFIED              2382
#define         IDS_E_CANNOT_CONTACT_TELNETSERVER    2392
#define         IDS_E_CANNOT_MANAGE_TELNETSERVER     2401
#define IDS_SERVICE_STARTED         2501
#define IDS_E_SERVICE_NOT_STARTED        2502
#define	IDS_E_INVALIDARG 		                    2503

#define	IDS_NEXT_STRING_RESOURCE_RESOURCE_H							2504

/**********************************************************
				PLEASE READ THIS
	Use the ranges 400 - 600 for IDR resources
	Use the ranges 2500 - 2700 for IDS resources
	When these ranges are exhausted pick new ranges
	based on the available ranges from resourc2.h
**********************************************************/

    #ifdef APSTUDIO_INVOKED						
    #ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        229
#define _APS_NEXT_COMMAND_VALUE         32769
#define _APS_NEXT_CONTROL_VALUE         233
#define _APS_NEXT_SYMED_VALUE           109
    #endif
    #endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\admin\makefile.inc ===
#---------------------------------------------------------
#   Copyright (c) 1999-2000 Microsoft Corporation
#
#   makefile.inc
#
#   vikram K.R.C. (vikram_krc@bigfoot.com)
#
#----------------------------------------------------------------------------------
#    If you have flex and bison installed on your machine, and you want to modify
#    the grammar, uncomment the following lines.
#---------------------------------------------------------------------------------



#tnadminy.c:tnadmin.y telnet.h
#	bison -dv tnadmin.y -o tnadminy.c

#tnadminl.c:tnadmin.l telnet.h
#	flex -otnadminl.c  -i tnadmin.l
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\admin\telnet.h ===
//---------------------------------------------------------
//   Copyright (c) 1999-2000 Microsoft Corporation
//
//   telnet.h
//
//   vikram K.R.C. (vikram_krc@bigfoot.com)
//
//   The header file for the telnet command line admin tool.
//          (May-2000)
//---------------------------------------------------------


#ifndef _TNADMIN_FUNCTIONS_HEADER_
#define _TNADMIN_FUNCTIONS_HEADER_

#include <wbemidl.h>
#include <stdio.h>

#ifdef __cplusplus
extern "C" {
#endif




#define _p_CTRLAKEYMAP_       3
#define _p_TIMEOUTACTIVE_     4
#define _p_MAXCONN_           5
#define _p_PORT_               6
#define _p_MAXFAIL_            7
#define _p_KILLALL_             8
#define _p_MODE_               9
#define _p_AUDITLOCATION_     10
#define _p_SEC_                 11
#define _p_DOM_                12
#define _p_AUDIT_              13
#define _p_TIMEOUT_            14
#define _p_FNAME_              15
#define _p_FSIZE_               16
//registry notification property
#define _p_DEFAULTS_            17
#define _p_INSTALLPATH_         18

//#define _p_STATE_                4
//#define _p_SESSID_              17




//secvalues
#define NTLM_BIT    0
#define PASSWD_BIT 1

#define ADMIN_BIT 0
#define USER_BIT  1
#define FAIL_BIT   2




//functions.

//telnet specific functions
	//initializes
int Initialize(void);
	//deal with the options
	//deals with config options in entirety.
HRESULT DoTnadmin(void);
HRESULT GetCorrectVariant(int nProperty,int nWhichone, VARIANT* pvar);
	//prints the present settings.
HRESULT PrintSettings(void);

	//functions to deal with sessions.
	//get handle to the interface.
HRESULT SesidInit(void);
	//get all the sessions.
HRESULT ListUsers(void);
	//if a session id is given check if it is present.
int CheckSessionID(void);

	//to show session(s)
HRESULT ShowSession(void);
	//to message session(s)
HRESULT MessageSession();
	//to kill session(s)
HRESULT TerminateSession(void);
//to free the allocated memory
void Quit(void);

HRESULT ConvertUTCtoLocal(WCHAR* bUTCYear, WCHAR* bUTCMonth, WCHAR* bUTCDayOfWeek, WCHAR* bUTCDay, WCHAR* bUTCHour, WCHAR* bUTCMinute, WCHAR* bUTCSecond, BSTR * bLocalDate);
// This function IsMaxConnChangeAllowed() is no longer used. So commenting out now
// BOOL IsMaxConnChangeAllowed();
HRESULT IsWhistlerTheOS(BOOL *fWhistler);
BOOL IsSFUInstalled();
//WCHAR* setDefaultDomainToLocaldomain();
BOOL setDefaultDomainToLocaldomain(WCHAR wzDomain[]);

void formatShowSessionsDisplay();
BOOL IsServerClass();


#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\admin\admutils.h ===
//---------------------------------------------------------
//   Copyright (c) 1999-2000 Microsoft Corporation
//
//   admutils.h
//
//   vikram K.R.C.  (vikram_krc@bigfoot.com)
//
//   The header file for the command line admin tools.
//          (May-2000)
//---------------------------------------------------------

#ifndef _ADMIN_FUNCTIONS_HEADER_
#define _ADMIN_FUNCTIONS_HEADER_

#include <wbemidl.h>
#include <stdio.h>
#include <winsock2.h>

#ifndef WHISTLER_BUILD
#include "allutils.h"
#else
// the other definition is in commfunc.h
typedef struct _StrList
{
    TCHAR *Str;
    struct _StrList *next;
}StrList;
#endif

#ifdef __cplusplus
extern "C" {
#endif

// Arraysize(buf) returns the no. of chars in the buffer
// Please do not use it for dynamic arrays. This will
// work only for static buffers.
#ifndef ARRAYSIZE
#define ARRAYSIZE(buf)   (sizeof(buf) / sizeof((buf)[0]))
#endif

typedef struct _STRING_LIST
{
	DWORD count;
	LPTSTR *strings;
} STRING_LIST, *PSTRING_LIST;

#define TEXT_MAX_INTEGER_VALUE  L"2147483647"
#define MAX_LEN_FOR_CODEPAGE 6
#define SZLOCALMACHINE  L"localhost"


#define MAX_COMMAND_LINE 500
#define MAX_BUFFER_SIZE   4096

//FOR XPSP1. If the variables are not defined, that means they are not present in .rc
//and .h files. Hardcode the values that fall in the range obtained for Telnet resources
//in xpsp1res.h
#ifndef IDR_NEW_TELNET_USAGE
#define IDR_NEW_TELNET_USAGE                20001
#endif
#ifndef IDR_YES
#define IDR_YES                             20002
#endif
#ifndef IDR_NO
#define IDR_NO                              20003
#endif
#ifndef IDR_TIME_HOURS
#define IDR_TIME_HOURS                      20004
#endif
#ifndef IDR_TIME_MINUTES
#define IDR_TIME_MINUTES                    20005
#endif
#ifndef IDR_TIME_SECONDS
#define IDR_TIME_SECONDS                    20006
#endif
#ifndef IDR_MAPPING_NOT_ON
#define IDR_MAPPING_NOT_ON                  20007
#endif
#ifndef IDR_STATUS_STOPPED
#define IDR_STATUS_STOPPED                  20008
#endif
#ifndef IDR_STATUS_RUNNING
#define IDR_STATUS_RUNNING                  20009
#endif
#ifndef IDR_STATUS_PAUSED
#define IDR_STATUS_PAUSED                   20010
#endif
#ifndef IDR_STATUS_START_PENDING
#define IDR_STATUS_START_PENDING            20011
#endif
#ifndef IDR_STATUS_STOP_PENDING
#define IDR_STATUS_STOP_PENDING             20012
#endif
#ifndef IDR_STATUS_CONTINUE_PENDING
#define IDR_STATUS_CONTINUE_PENDING         20013
#endif
#ifndef IDR_STATUS_PAUSE_PENDING
#define IDR_STATUS_PAUSE_PENDING            20014
#endif
#ifndef IDR_ALREADY_STARTED 
#define IDR_ALREADY_STARTED                 20015
#endif
#ifndef IDS_SERVICE_STARTED
#define IDS_SERVICE_STARTED                 20016
#endif
#ifndef IDS_E_SERVICE_NOT_STARTED
#define IDS_E_SERVICE_NOT_STARTED           20017
#endif
#ifndef IDR_SERVICE_PAUSED
#define IDR_SERVICE_PAUSED                  20018
#endif
#ifndef IDR_SERVICE_CONTINUED
#define IDR_SERVICE_CONTINUED               20019
#endif
#ifndef IDR_SERVICE_NOT_PAUSED
#define IDR_SERVICE_NOT_PAUSED              20020
#endif
#ifndef IDR_SERVICE_NOT_CONTINUED
#define IDR_SERVICE_NOT_CONTINUED           20021
#endif
#ifndef IDS_E_INVALIDARG
#define IDS_E_INVALIDARG                    20022
#endif

#define SLASH_SLASH L"\\\\"

#define _p_CNAME_               0
#define _p_USER_                 1
#define _p_PASSWD_              2

int GetTrustedDomainList(LPTSTR szMachine, LPTSTR * list, LPTSTR * primary);
void HelperFreeStringList(PSTRING_LIST pList);
HRESULT LoadNTDomainList(LPTSTR szMachine);

extern BOOL g_fCoInitSuccess;

//Structure defn to store all the information
typedef struct
{
    int classname;
    wchar_t* propname;
    VARIANT var;
    int fDontput;
}ConfigProperty;

// Some defines used to access the name of the computer from the registry
#define   REG_SUBKEY_COMPUTER_NAME  L"SYSTEM\\CurrentControlSet\\Control\\ComputerName\\ActiveComputerName"
#define   REG_ENTRY_COMPUTER_NAME   L"ComputerName"


// If at all if needed to increase the no. of mapping servers names that
// can be configurable thru sfuadmin.exe, just change the #define here
#define MAX_NO_OF_MAPPING_SERVERS 1

//common functions for all the sfu-admins.

#define GetClass(x, y)  GetClassEx((x), (y), TRUE, KEY_ALL_ACCESS)
#define SAFE_FREE(x) {if ((x)) {free((x));(x)=NULL;}}

//authenticate to the remote computer
HRESULT DoNetUseAdd(WCHAR*wzLoginname, WCHAR* wzPassword,WCHAR* wzCname);
HRESULT DoNetUseDel(WCHAR* wzCname);
    // to connect to the registry on the specified computer
    
HRESULT GetConnection(WCHAR* wzCname);
    //to get a handle to a specfic class(hive)
HRESULT GetClassEx(int, int, BOOL bPrintErrorMessages, REGSAM samDesired);
    //close all the open hives.
HRESULT PutClasses();

    //read the value of the property
HRESULT GetProperty(int , int , VARIANT* );
    //set the value of the property
HRESULT PutProperty(int , int , VARIANT* );

    //to get handle to the service and do start/stop/etc.
HRESULT GetSerHandle(LPCTSTR lpServiceName,DWORD dwScmDesiredAccess, DWORD dwRegDesiredAccess,BOOL fSuppressMsg);
HRESULT CloseHandles(void);
HRESULT StartSfuService(LPCTSTR lpServiceName);
HRESULT ControlSfuService(LPCTSTR lpServiceName,DWORD dwControl);
HRESULT QuerySfuService(LPCTSTR lpServiceName);

    //for printing out any message by loading from strings dll.
HRESULT PrintMessage(HANDLE fp, int);
    //for printing out any message by loading the string from correct resource and 
    //display english message if everything else fails.
HRESULT PrintMessageEx(HANDLE fp, int, LPCTSTR);    
    //for printing out error messages by loading from strings dll.
int ShowError(int);
int ShowErrorEx(int nError,WCHAR *wzFormatString);
int ShowErrorFallback(int, LPCTSTR);
BOOL FileIsConsole(  HANDLE fp );
void MyWriteConsole(    HANDLE fp, LPWSTR lpBuffer, DWORD cchBuffer);

    //get and set bit(in pos given by second arg) in int( the first arg)
int GetBit(int , int );
int SetBit(int , int );
    //returns a WCHAR string .
wchar_t* DupWStr(char *str);
    //returns Char string from wchar String
char* DupCStr(wchar_t *wzStr);
    //Is it a valid machine???
HRESULT IsValidMachine(wchar_t*, int*);
BOOL Get_Inet_Address(struct sockaddr_in *addr, char *host);
HRESULT getHostNameFromIP(char *szCname, WCHAR** wzCname);
    //To determine if the specified domain a valid domain.
HRESULT IsValidDomain(wchar_t *wsDomainName, int *fValid);

  //Check for Password; If only user name specified, get password. If the other way round, report error
HRESULT CheckForPassword(void);
void ConvertintoSeconds(int nProperty,int * nSeconds);
void PrintFormattedErrorMessage(LONG ErrorCode);
HRESULT GetDomainHostedByThisMc( LPWSTR szDomain );
BOOL CheckForInt(int nProperty);
HRESULT CheckForMaxInt(WCHAR *wzValue,DWORD ErrorCode);
DWORD PreAnalyzer(int argc,WCHAR *argv[],int nProperty,WCHAR *wzOption,
                    int nCurrentOp,int *nNextOp, BOOL *fSuccess,BOOL IsSpaceAllowed);
DWORD PrintMissingRegValueMsg(int nProperty, int nNumofprop);

int TnLoadString(int msg_id, LPTSTR string, int max_size_of_buffer, LPCTSTR english_string);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\admin\tnadminy.h ===
#define _TNADMIN 257
#define _HELP 258
#define _COMPNAME 259
#define _START 260
#define _STOP 261
#define _PAUSE 262
#define _CONTINUE 263
#define _S 264
#define _K 265
#define _M 266
#define _CONFIG 267
#define _INTEGER 268
#define _SESID 269
#define _DOM 270
#define _CTRLKEYMAP 271
#define _Y 272
#define _N 273
#define _tU 274
#define _tP 275
#define _TIMEOUT 276
#define _TIME 277
#define _TIMEOUTACTIVE 278
#define _MAXFAIL 279
#define _MAXCONN 280
#define _PORT 281
#define _KILLALL 282
#define _SEC 283
#define _SECVAL 284
#define _FNAME 285
#define _FSIZE 286
#define _MODE 287
#define _CONSOLE 288
#define _EQ 289
#define _STREAM 290
#define _AUDITLOCATION 291
#define _AUDIT 292
#define _AUDITVAL 293
#define _EVENTLOG 294
#define _DONE 295
#define _ANYTHING 296
#define _FILENAME 297
#define _ERROR 298
#define _FILEN 299
#define _BOTH 300
#define _MINUSNTLM 301
#define _MINUSPASSWD 302
#define _MINUSUSER 303
#define _MINUSFAIL 304
#define _MINUSADMIN 305
#define _PLUSNTLM 306
#define _PLUSPASSWD 307
#define _PLUSUSER 308
#define _PLUSFAIL 309
#define _PLUSADMIN 310
#define _ENDINPUT 311
#define _DUNNO 312
typedef union
{
  char* str;
  int token;
} YYSTYPE;
extern YYSTYPE yylval;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\admin\tnadm_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0158 */
/* at Wed May 20 16:00:16 1998
 */
/* Compiler settings for TlntSvr.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED


const IID IID_IManageTelnetSessions= {0x034634FD,0xBA3F,0x11D1,{0x85,0x6A,0x00,0xA0,0xC9,0x44,0x13,0x8C}};

const CLSID CLSID_EnumTelnetClientsSvr = {0xFE9E48A4,0xA014,0x11D1,{0x85,0x5C,0x00,0xA0,0xC9,0x44,0x13,0x8C}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\admin\tlntsvr.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0279 */
/* at Wed May 24 12:39:29 2000
 */
/* Compiler settings for TlntSvr.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __TlntSvr_h__
#define __TlntSvr_h__

/* Forward Declarations */ 

#ifndef __IEnumClients_FWD_DEFINED__
#define __IEnumClients_FWD_DEFINED__
typedef interface IEnumClients IEnumClients;
#endif 	/* __IEnumClients_FWD_DEFINED__ */


#ifndef __IGetEnumClients_FWD_DEFINED__
#define __IGetEnumClients_FWD_DEFINED__
typedef interface IGetEnumClients IGetEnumClients;
#endif 	/* __IGetEnumClients_FWD_DEFINED__ */


#ifndef __IManageTelnetSessions_FWD_DEFINED__
#define __IManageTelnetSessions_FWD_DEFINED__
typedef interface IManageTelnetSessions IManageTelnetSessions;
#endif 	/* __IManageTelnetSessions_FWD_DEFINED__ */


#ifndef __EnumTelnetClientsSvr_FWD_DEFINED__
#define __EnumTelnetClientsSvr_FWD_DEFINED__

#ifdef __cplusplus
typedef class EnumTelnetClientsSvr EnumTelnetClientsSvr;
#else
typedef struct EnumTelnetClientsSvr EnumTelnetClientsSvr;
#endif /* __cplusplus */

#endif 	/* __EnumTelnetClientsSvr_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

/* interface __MIDL_itf_TlntSvr_0000 */
/* [local] */ 

typedef struct _TELNET_CLIENT_INFO
    {
    WCHAR username[ 256 ];
    WCHAR domain[ 256 ];
    WCHAR peerhostname[ 256 ];
    long uniqueId;
    SYSTEMTIME logonTime;
    DWORD NoOfPids;
    /* [size_is] */ DWORD __RPC_FAR *pId;
    /* [size_is] */ WCHAR ( __RPC_FAR *processName )[ 256 ];
    }	TELNET_CLIENT_INFO;



extern RPC_IF_HANDLE __MIDL_itf_TlntSvr_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_TlntSvr_0000_v0_0_s_ifspec;

#ifndef __IEnumClients_INTERFACE_DEFINED__
#define __IEnumClients_INTERFACE_DEFINED__

/* interface IEnumClients */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IEnumClients;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FE9E48A3-A014-11D1-855C-00A0C944138C")
    IEnumClients : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ TELNET_CLIENT_INFO __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IEnumClients __RPC_FAR *__RPC_FAR *ppenum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TerminateSession( 
            /* [in] */ DWORD uniqueId) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IEnumClientsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IEnumClients __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IEnumClients __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IEnumClients __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Next )( 
            IEnumClients __RPC_FAR * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ TELNET_CLIENT_INFO __RPC_FAR *__RPC_FAR *rgelt,
            /* [out] */ ULONG __RPC_FAR *pceltFetched);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Skip )( 
            IEnumClients __RPC_FAR * This,
            /* [in] */ ULONG celt);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Reset )( 
            IEnumClients __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Clone )( 
            IEnumClients __RPC_FAR * This,
            /* [out] */ IEnumClients __RPC_FAR *__RPC_FAR *ppenum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TerminateSession )( 
            IEnumClients __RPC_FAR * This,
            /* [in] */ DWORD uniqueId);
        
        END_INTERFACE
    } IEnumClientsVtbl;

    interface IEnumClients
    {
        CONST_VTBL struct IEnumClientsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IEnumClients_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IEnumClients_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IEnumClients_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IEnumClients_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IEnumClients_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IEnumClients_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IEnumClients_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#define IEnumClients_TerminateSession(This,uniqueId)	\
    (This)->lpVtbl -> TerminateSession(This,uniqueId)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IEnumClients_Next_Proxy( 
    IEnumClients __RPC_FAR * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ TELNET_CLIENT_INFO __RPC_FAR *__RPC_FAR *rgelt,
    /* [out] */ ULONG __RPC_FAR *pceltFetched);


void __RPC_STUB IEnumClients_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IEnumClients_Skip_Proxy( 
    IEnumClients __RPC_FAR * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IEnumClients_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IEnumClients_Reset_Proxy( 
    IEnumClients __RPC_FAR * This);


void __RPC_STUB IEnumClients_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IEnumClients_Clone_Proxy( 
    IEnumClients __RPC_FAR * This,
    /* [out] */ IEnumClients __RPC_FAR *__RPC_FAR *ppenum);


void __RPC_STUB IEnumClients_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IEnumClients_TerminateSession_Proxy( 
    IEnumClients __RPC_FAR * This,
    /* [in] */ DWORD uniqueId);


void __RPC_STUB IEnumClients_TerminateSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IEnumClients_INTERFACE_DEFINED__ */


#ifndef __IGetEnumClients_INTERFACE_DEFINED__
#define __IGetEnumClients_INTERFACE_DEFINED__

/* interface IGetEnumClients */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IGetEnumClients;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("FE9E48A2-A014-11D1-855C-00A0C944138C")
    IGetEnumClients : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetEnumClients( 
            /* [retval][out] */ IEnumClients __RPC_FAR *__RPC_FAR *ppretval) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IGetEnumClientsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IGetEnumClients __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IGetEnumClients __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IGetEnumClients __RPC_FAR * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetEnumClients )( 
            IGetEnumClients __RPC_FAR * This,
            /* [retval][out] */ IEnumClients __RPC_FAR *__RPC_FAR *ppretval);
        
        END_INTERFACE
    } IGetEnumClientsVtbl;

    interface IGetEnumClients
    {
        CONST_VTBL struct IGetEnumClientsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IGetEnumClients_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IGetEnumClients_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IGetEnumClients_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IGetEnumClients_GetEnumClients(This,ppretval)	\
    (This)->lpVtbl -> GetEnumClients(This,ppretval)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IGetEnumClients_GetEnumClients_Proxy( 
    IGetEnumClients __RPC_FAR * This,
    /* [retval][out] */ IEnumClients __RPC_FAR *__RPC_FAR *ppretval);


void __RPC_STUB IGetEnumClients_GetEnumClients_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IGetEnumClients_INTERFACE_DEFINED__ */


#ifndef __IManageTelnetSessions_INTERFACE_DEFINED__
#define __IManageTelnetSessions_INTERFACE_DEFINED__

/* interface IManageTelnetSessions */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_IManageTelnetSessions;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("034634FD-BA3F-11D1-856A-00A0C944138C")
    IManageTelnetSessions : public IDispatch
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetTelnetSessions( 
            /* [retval][out] */ BSTR __RPC_FAR *pszSessionData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE TerminateSession( 
            /* [in] */ DWORD dwUniqueId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendMsgToASession( 
            /* [in] */ DWORD dwUniqueId,
            /* [in] */ BSTR szMsg) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendMsgToAllSessions( 
            /* [in] */ BSTR szMsg) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IManageTelnetSessionsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            IManageTelnetSessions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            IManageTelnetSessions __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            IManageTelnetSessions __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            IManageTelnetSessions __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            IManageTelnetSessions __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            IManageTelnetSessions __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            IManageTelnetSessions __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTelnetSessions )( 
            IManageTelnetSessions __RPC_FAR * This,
            /* [retval][out] */ BSTR __RPC_FAR *pszSessionData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *TerminateSession )( 
            IManageTelnetSessions __RPC_FAR * This,
            /* [in] */ DWORD dwUniqueId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendMsgToASession )( 
            IManageTelnetSessions __RPC_FAR * This,
            /* [in] */ DWORD dwUniqueId,
            /* [in] */ BSTR szMsg);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *SendMsgToAllSessions )( 
            IManageTelnetSessions __RPC_FAR * This,
            /* [in] */ BSTR szMsg);
        
        END_INTERFACE
    } IManageTelnetSessionsVtbl;

    interface IManageTelnetSessions
    {
        CONST_VTBL struct IManageTelnetSessionsVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IManageTelnetSessions_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IManageTelnetSessions_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IManageTelnetSessions_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IManageTelnetSessions_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define IManageTelnetSessions_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define IManageTelnetSessions_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define IManageTelnetSessions_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define IManageTelnetSessions_GetTelnetSessions(This,pszSessionData)	\
    (This)->lpVtbl -> GetTelnetSessions(This,pszSessionData)

#define IManageTelnetSessions_TerminateSession(This,dwUniqueId)	\
    (This)->lpVtbl -> TerminateSession(This,dwUniqueId)

#define IManageTelnetSessions_SendMsgToASession(This,dwUniqueId,szMsg)	\
    (This)->lpVtbl -> SendMsgToASession(This,dwUniqueId,szMsg)

#define IManageTelnetSessions_SendMsgToAllSessions(This,szMsg)	\
    (This)->lpVtbl -> SendMsgToAllSessions(This,szMsg)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IManageTelnetSessions_GetTelnetSessions_Proxy( 
    IManageTelnetSessions __RPC_FAR * This,
    /* [retval][out] */ BSTR __RPC_FAR *pszSessionData);


void __RPC_STUB IManageTelnetSessions_GetTelnetSessions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IManageTelnetSessions_TerminateSession_Proxy( 
    IManageTelnetSessions __RPC_FAR * This,
    /* [in] */ DWORD dwUniqueId);


void __RPC_STUB IManageTelnetSessions_TerminateSession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IManageTelnetSessions_SendMsgToASession_Proxy( 
    IManageTelnetSessions __RPC_FAR * This,
    /* [in] */ DWORD dwUniqueId,
    /* [in] */ BSTR szMsg);


void __RPC_STUB IManageTelnetSessions_SendMsgToASession_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IManageTelnetSessions_SendMsgToAllSessions_Proxy( 
    IManageTelnetSessions __RPC_FAR * This,
    /* [in] */ BSTR szMsg);


void __RPC_STUB IManageTelnetSessions_SendMsgToAllSessions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IManageTelnetSessions_INTERFACE_DEFINED__ */



#ifndef __TLNTSVRLib_LIBRARY_DEFINED__
#define __TLNTSVRLib_LIBRARY_DEFINED__

/* library TLNTSVRLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_TLNTSVRLib;

EXTERN_C const CLSID CLSID_EnumTelnetClientsSvr;

#ifdef __cplusplus

class DECLSPEC_UUID("FE9E48A4-A014-11D1-855C-00A0C944138C")
EnumTelnetClientsSvr;
#endif
#endif /* __TLNTSVRLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\admin\tnadminy.c ===
#ifndef lint
static char yysccsid[] = "@(#)yaccpar	1.9 (Berkeley) 02/21/93";
#endif
#define YYBYACC 1
#define YYMAJOR 1
#define YYMINOR 9
#define yyclearin (yychar=(-1))
#define yyerrok (yyerrflag=0)
#define YYRECOVERING (yyerrflag!=0)
#define YYPREFIX "yy"
#line 14 "tnadmin.y"

 #include <stdio.h>
 
 #include "telnet.h"
 #include "common.h"
 #include "resource.h"
 #include "admutils.h"
 #include <string.h>
 #include <ctype.h>
 #include <windows.h>
 #include <locale.h>
 #pragma warning(disable:4102)
 
 #define alloca malloc
 #define strdup _strdup
 #define L_TNADMIN_TEXT L"tnadmin"

 #define BAIL_ON_SNWPRINTF_ERR()		if ( nTmpWrite < 0 ) \
        					           	{ \
        						            ShowError(IDR_LONG_COMMAND_LINE); \
        						            goto End; \
        					           	} \

 extern int yy_scan_string (char *input_buffer);
 extern int yyparse();
 extern char *yytext;
 SCODE sc;

/*functions of yacc and lex.*/
int yyerror(char *s);
int yylex();

/*between yacc and lex*/
extern int g_fMessage;
extern int g_fComp;
extern int g_fNormal;
extern char * szCompname;


/*global variables....*/
int g_nError=0; /*Error indicator, initialsed to no error.:-)*/
wchar_t* g_arVALOF[_MAX_PROPS_];
int g_nPrimaryOption=-1;
        /*option indicator.*/
int g_nConfigOptions=0;

int g_nTimeoutFlag=0;  /*o means in hh:mm:ss 1 means ss format.*/

ConfigProperty g_arPROP[_MAX_PROPS_][_MAX_NUMOF_PROPNAMES_];
		/*array of structures of properties.*/

int g_nSesid=-1;
WCHAR wzMessageString[MAX_COMMAND_LINE];
BSTR g_bstrMessage=NULL;
WCHAR szMsg[MAX_BUFFER_SIZE] = {0};

int g_nSecOn=0;
int g_nSecOff=0;
int g_nAuditOn=0;
int g_nAuditOff=0;

int minus=0;
char *szYesno=NULL;
wchar_t* wzTemp=NULL;

extern nMoccur;
#line 81 "tnadmin.y"
typedef union
{
  char* str;
  int token;
} YYSTYPE;
#line 85 "tnadminy.c"
#define _TNADMIN 257
#define _HELP 258
#define _COMPNAME 259
#define _START 260
#define _STOP 261
#define _PAUSE 262
#define _CONTINUE 263
#define _S 264
#define _K 265
#define _M 266
#define _CONFIG 267
#define _INTEGER 268
#define _SESID 269
#define _DOM 270
#define _CTRLKEYMAP 271
#define _Y 272
#define _N 273
#define _tU 274
#define _tP 275
#define _TIMEOUT 276
#define _TIME 277
#define _TIMEOUTACTIVE 278
#define _MAXFAIL 279
#define _MAXCONN 280
#define _PORT 281
#define _KILLALL 282
#define _SEC 283
#define _SECVAL 284
#define _FNAME 285
#define _FSIZE 286
#define _MODE 287
#define _CONSOLE 288
#define _EQ 289
#define _STREAM 290
#define _AUDITLOCATION 291
#define _AUDIT 292
#define _AUDITVAL 293
#define _EVENTLOG 294
#define _DONE 295
#define _ANYTHING 296
#define _FILENAME 297
#define _ERROR 298
#define _FILEN 299
#define _BOTH 300
#define _MINUSNTLM 301
#define _MINUSPASSWD 302
#define _MINUSUSER 303
#define _MINUSFAIL 304
#define _MINUSADMIN 305
#define _PLUSNTLM 306
#define _PLUSPASSWD 307
#define _PLUSUSER 308
#define _PLUSFAIL 309
#define _PLUSADMIN 310
#define _ENDINPUT 311
#define _DUNNO 312
#define YYERRCODE 256
short yylhs[] = {                                        -1,
    0,    0,    0,    1,    1,    2,    2,    2,    3,    3,
    3,    3,    3,    5,    3,    7,    3,    9,    3,    3,
    3,    6,    6,    6,    8,    8,   10,    4,    4,    4,
   12,   12,   13,   13,   14,   14,   15,   15,   15,   16,
   16,   11,   11,   11,   11,   11,   11,   11,   11,   11,
   11,   11,   11,   11,   11,   11,   17,   11,   11,   11,
   11,   11,   11,   19,   11,   11,   18,   18,   18,   18,
   18,   20,   20,   20,   20,   20,   20,   20,
};
short yylen[] = {                                         2,
    3,    5,    6,    2,    1,    2,    2,    0,    1,    1,
    1,    1,    2,    0,    3,    0,    3,    0,    3,    1,
    1,    1,    1,    1,    3,    1,    1,    1,    1,    0,
    1,    0,    1,    1,    1,    1,    1,    1,    1,    1,
    1,    2,    4,    4,    4,    4,    4,    4,    4,    4,
    4,    4,    4,    4,    4,    4,    0,    5,    2,    4,
    4,    4,    4,    0,    5,    0,    2,    2,    2,    2,
    0,    2,    2,    2,    2,    2,    2,    0,
};
short yydefred[] = {                                      0,
    0,    0,    8,    4,    0,   21,   27,    9,   10,   11,
   12,    0,   14,   16,   18,    6,    7,    1,    8,   20,
   29,   28,   13,    0,    0,   66,    0,   15,   24,   22,
   23,   17,    0,    0,    2,    8,   66,   42,    0,    0,
    0,    0,    0,    0,    0,   57,   59,    0,    0,    0,
   64,    0,    0,   31,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   44,   33,   34,   43,
   46,   41,   40,   45,   48,   47,   50,   49,   52,   51,
   54,   53,   56,   55,   71,   61,   60,   35,   36,   62,
   37,   38,   39,   63,   78,    0,    0,   68,   70,   67,
   69,   73,   75,   77,   72,   74,   76,
};
short yydgoto[] = {                                       2,
    3,    5,   19,   23,   24,   32,   25,   33,   26,   20,
   34,   55,   70,   90,   94,   74,   62,   96,   66,   97,
};
short yysindex[] = {                                   -244,
 -238,    0,    0,    0, -256,    0,    0,    0,    0,    0,
    0, -155,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0, -155, -185,    0, -236,    0,    0,    0,
    0,    0, -224, -180,    0,    0,    0,    0, -235, -235,
 -235, -235, -235, -235, -235,    0,    0, -235, -235, -235,
    0, -144, -180,    0, -240, -190, -220, -253, -233, -176,
 -200, -235, -171, -276, -167, -235,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0, -181, -186,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,
};
short yyrindex[] = {                                      0,
 -216,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,  185,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,  185,    0,    0,    0,    0,    0,    0,
    0,    0,  245,  205,    0,    0,    0,    0, -179, -189,
 -179, -152, -152, -152, -179,    0,    0, -152, -214, -165,
    0,   81,  225,    0,    0,    0,    0,    0,    0,    0,
    0,   57,    0,    0,    0,    1,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,  109,  147,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,
};
short yygindex[] = {                                      0,
    0,   -2,   62,   84,    0,    0,    0,    0,    0,    0,
   73,   20,  -20,    0,    0,    0,    0,    0,    0,    0,
};
#define YYTABLESIZE 556
short yytable[] = {                                       6,
   32,    7,   77,    8,    9,   10,   11,   12,   13,   14,
   15,   88,    1,   89,   78,   67,   27,   16,   17,    6,
    4,    7,   79,    8,    9,   10,   11,   12,   13,   14,
   15,   68,   69,   52,   80,   75,   76,   16,   17,    5,
   84,    5,   37,    5,    5,    5,    5,    5,    5,    5,
    5,   68,   69,   54,   18,   83,   32,    5,    5,   56,
   57,   58,   59,   60,   61,   71,   32,   63,   64,   65,
   29,   68,   69,   32,   35,   32,   32,   72,   32,   81,
    3,   85,   30,   31,   86,   95,   73,   32,   36,   38,
   39,   82,   32,   32,    5,   40,   87,   41,   42,   43,
   44,   45,   46,   32,   47,   48,   49,   28,   58,   53,
   50,   51,   21,   22,    0,   32,  102,  103,  104,   98,
   99,  105,  106,  107,  100,  101,   91,    0,   32,   16,
   17,   92,   93,   32,   32,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   65,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   30,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   26,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   25,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,   19,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,   32,    0,   32,    0,
   32,   32,   32,   32,   32,   32,   32,   32,    0,    0,
   32,   32,    0,    0,   32,   32,   32,    0,   32,   32,
   32,   32,   32,   32,    0,   32,   32,   32,    0,    0,
    0,   32,   32,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,   32,   32,   32,    0,    0,   32,   32,
   32,   32,   32,    0,   32,    0,   32,   32,   32,   32,
   32,   32,   32,   32,    0,    0,   32,   32,    0,    0,
   32,   32,   32,    0,   32,   32,   32,   32,   32,   32,
    0,   32,   32,   32,    0,    0,    0,   32,   32,    0,
    0,    0,    0,    0,    0,    0,    0,   32,   32,    0,
    0,    0,   32,   32,   58,    0,   58,   32,   58,   58,
   58,   58,   58,   58,   58,   58,    0,    0,   58,   58,
    0,    0,   58,   58,   58,    0,   58,   58,   58,   58,
   58,   58,    0,   58,   58,   58,    0,    0,    0,   58,
   58,    0,   65,    0,   65,    0,   65,   65,   65,   65,
   65,   65,   65,   65,    0,    0,   65,   65,    0,   58,
   65,   65,   65,    0,   65,   65,   65,   65,   65,   65,
    0,   65,   65,   65,    0,    0,    0,   65,   65,    0,
   30,    0,   30,    0,   30,   30,   30,   30,   30,   30,
   30,   30,    0,    0,    0,    0,    0,   65,   30,   30,
   26,    0,   26,    0,   26,   26,   26,   26,   26,   26,
   26,   26,    0,    0,    0,    0,    0,    0,   26,   26,
   25,    0,   25,    0,   25,   25,   25,   25,   25,   25,
   25,   25,    0,    0,    0,   30,    0,    0,   25,   25,
   19,    0,   19,    0,   19,   19,   19,   19,   19,   19,
   19,    0,    0,    0,    0,   26,    0,    0,   19,   19,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   25,    0,    0,    0,    0,
    0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
    0,    0,    0,    0,    0,   19,
};
short yycheck[] = {                                     256,
    0,  258,  256,  260,  261,  262,  263,  264,  265,  266,
  267,  288,  257,  290,  268,  256,   19,  274,  275,  256,
  259,  258,  256,  260,  261,  262,  263,  264,  265,  266,
  267,  272,  273,   36,  268,  256,   57,  274,  275,  256,
   61,  258,  267,  260,  261,  262,  263,  264,  265,  266,
  267,  272,  273,  289,  311,  256,    0,  274,  275,   40,
   41,   42,   43,   44,   45,  256,  256,   48,   49,   50,
  256,  272,  273,  288,  311,  290,  256,  268,  268,  256,
    0,   62,  268,  269,  256,   66,  277,  277,   27,  270,
  271,  268,  272,  273,  311,  276,  268,  278,  279,  280,
  281,  282,  283,  256,  285,  286,  287,   24,    0,   37,
  291,  292,  268,  269,   -1,  268,  303,  304,  305,  301,
  302,  308,  309,  310,  306,  307,  294,   -1,  294,  274,
  275,  299,  300,  299,  300,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,    0,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,    0,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,    0,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,    0,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,    0,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,  256,   -1,  258,   -1,
  260,  261,  262,  263,  264,  265,  266,  267,   -1,   -1,
  270,  271,   -1,   -1,  274,  275,  276,   -1,  278,  279,
  280,  281,  282,  283,   -1,  285,  286,  287,   -1,   -1,
   -1,  291,  292,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,  303,  304,  305,   -1,   -1,  308,  309,
  310,  311,  256,   -1,  258,   -1,  260,  261,  262,  263,
  264,  265,  266,  267,   -1,   -1,  270,  271,   -1,   -1,
  274,  275,  276,   -1,  278,  279,  280,  281,  282,  283,
   -1,  285,  286,  287,   -1,   -1,   -1,  291,  292,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,  301,  302,   -1,
   -1,   -1,  306,  307,  256,   -1,  258,  311,  260,  261,
  262,  263,  264,  265,  266,  267,   -1,   -1,  270,  271,
   -1,   -1,  274,  275,  276,   -1,  278,  279,  280,  281,
  282,  283,   -1,  285,  286,  287,   -1,   -1,   -1,  291,
  292,   -1,  256,   -1,  258,   -1,  260,  261,  262,  263,
  264,  265,  266,  267,   -1,   -1,  270,  271,   -1,  311,
  274,  275,  276,   -1,  278,  279,  280,  281,  282,  283,
   -1,  285,  286,  287,   -1,   -1,   -1,  291,  292,   -1,
  256,   -1,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,   -1,   -1,   -1,   -1,   -1,  311,  274,  275,
  256,   -1,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,   -1,   -1,   -1,   -1,   -1,   -1,  274,  275,
  256,   -1,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,  267,   -1,   -1,   -1,  311,   -1,   -1,  274,  275,
  256,   -1,  258,   -1,  260,  261,  262,  263,  264,  265,
  266,   -1,   -1,   -1,   -1,  311,   -1,   -1,  274,  275,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  311,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,   -1,
   -1,   -1,   -1,   -1,   -1,  311,
};
#define YYFINAL 2
#ifndef YYDEBUG
#define YYDEBUG 0
#endif
#define YYMAXTOKEN 312
#if YYDEBUG
char *yyname[] = {
"end-of-file",0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,"_TNADMIN","_HELP","_COMPNAME",
"_START","_STOP","_PAUSE","_CONTINUE","_S","_K","_M","_CONFIG","_INTEGER",
"_SESID","_DOM","_CTRLKEYMAP","_Y","_N","_tU","_tP","_TIMEOUT","_TIME",
"_TIMEOUTACTIVE","_MAXFAIL","_MAXCONN","_PORT","_KILLALL","_SEC","_SECVAL",
"_FNAME","_FSIZE","_MODE","_CONSOLE","_EQ","_STREAM","_AUDITLOCATION","_AUDIT",
"_AUDITVAL","_EVENTLOG","_DONE","_ANYTHING","_FILENAME","_ERROR","_FILEN",
"_BOTH","_MINUSNTLM","_MINUSPASSWD","_MINUSUSER","_MINUSFAIL","_MINUSADMIN",
"_PLUSNTLM","_PLUSPASSWD","_PLUSUSER","_PLUSFAIL","_PLUSADMIN","_ENDINPUT",
"_DUNNO",
};
char *yyrule[] = {
"$accept : tncmd",
"tncmd : tnadmin commonOptions _ENDINPUT",
"tncmd : tnadmin commonOptions op1 commonOptions _ENDINPUT",
"tncmd : tnadmin commonOptions op1 commonOptions op1 commonOptions",
"tnadmin : _TNADMIN _COMPNAME",
"tnadmin : _TNADMIN",
"commonOptions : commonOptions _tU",
"commonOptions : commonOptions _tP",
"commonOptions :",
"op1 : _START",
"op1 : _STOP",
"op1 : _PAUSE",
"op1 : _CONTINUE",
"op1 : _S sesid",
"$$1 :",
"op1 : _K $$1 sesid",
"$$2 :",
"op1 : _M $$2 messageoptions",
"$$3 :",
"op1 : _CONFIG $$3 configoptions",
"op1 : help",
"op1 : error",
"messageoptions : _INTEGER",
"messageoptions : _SESID",
"messageoptions : error",
"configoptions : configoptions _CONFIG configop",
"configoptions : configop",
"help : _HELP",
"sesid : _SESID",
"sesid : _INTEGER",
"sesid :",
"equals : _EQ",
"equals :",
"yn : _Y",
"yn : _N",
"cs : _CONSOLE",
"cs : _STREAM",
"efb : _EVENTLOG",
"efb : _FILEN",
"efb : _BOTH",
"time : _TIME",
"time : _INTEGER",
"configop : configop _DOM",
"configop : configop _CTRLKEYMAP equals yn",
"configop : configop _CTRLKEYMAP equals error",
"configop : configop _TIMEOUT equals time",
"configop : configop _TIMEOUT equals error",
"configop : configop _TIMEOUTACTIVE equals yn",
"configop : configop _TIMEOUTACTIVE equals error",
"configop : configop _MAXFAIL equals _INTEGER",
"configop : configop _MAXFAIL equals error",
"configop : configop _MAXCONN equals _INTEGER",
"configop : configop _MAXCONN equals error",
"configop : configop _PORT equals _INTEGER",
"configop : configop _PORT equals error",
"configop : configop _KILLALL equals yn",
"configop : configop _KILLALL equals error",
"$$4 :",
"configop : configop _SEC $$4 equals secval",
"configop : configop _FNAME",
"configop : configop _FSIZE equals _INTEGER",
"configop : configop _FSIZE equals error",
"configop : configop _MODE equals cs",
"configop : configop _AUDITLOCATION equals efb",
"$$5 :",
"configop : configop _AUDIT $$5 equals auditval",
"configop :",
"secval : secval _PLUSNTLM",
"secval : secval _MINUSNTLM",
"secval : secval _PLUSPASSWD",
"secval : secval _MINUSPASSWD",
"secval :",
"auditval : auditval _PLUSUSER",
"auditval : auditval _MINUSUSER",
"auditval : auditval _PLUSFAIL",
"auditval : auditval _MINUSFAIL",
"auditval : auditval _PLUSADMIN",
"auditval : auditval _MINUSADMIN",
"auditval :",
};
#endif
#ifdef YYSTACKSIZE
#undef YYMAXDEPTH
#define YYMAXDEPTH YYSTACKSIZE
#else
#ifdef YYMAXDEPTH
#define YYSTACKSIZE YYMAXDEPTH
#else
#define YYSTACKSIZE 500
#define YYMAXDEPTH 500
#endif
#endif
int yydebug;
int yynerrs;
int yyerrflag;
int yychar;
short *yyssp;
YYSTYPE *yyvsp;
YYSTYPE yyval;
YYSTYPE yylval;
short yyss[YYSTACKSIZE];
YYSTYPE yyvs[YYSTACKSIZE];
#define yystacksize YYSTACKSIZE
#line 425 "tnadmin.y"

int
yyerror(char *s)
{
    g_nError=1;
    return 0;
}

int __cdecl
wmain(int argc, wchar_t **argv)
{
    wchar_t input_buffer[MAX_COMMAND_LINE+1]={0};
    int i, nWritten=0;
    int nTmpWrite = 0, nMsgWrite = 0;
    int nUoccur=0,nPoccur=0;
    int NextOp;
    int nIndex;
    DWORD dwErrorCode;
    BOOL fSuccess = FALSE;
    char szCodePage[MAX_LEN_FOR_CODEPAGE];
    HRESULT hRes=S_OK;

    switch (GetConsoleOutputCP())
    {
    case 932:
    case 949:
	    setlocale(LC_ALL,"");
        SetThreadLocale(
            MAKELCID(
                    MAKELANGID( PRIMARYLANGID(GetSystemDefaultLangID()),
                                SUBLANG_ENGLISH_US),
                    SORT_DEFAULT
                    )
            );
        break;
    case 936:
		setlocale(LC_ALL,"");
		SetThreadLocale(
            MAKELCID(
                    MAKELANGID( PRIMARYLANGID(GetSystemDefaultLangID()),
                                SUBLANG_CHINESE_SIMPLIFIED),
                    SORT_DEFAULT
                    )
            );
        break;
    case 950:
    	setlocale(LC_ALL,"");
        SetThreadLocale(
            MAKELCID(
                    MAKELANGID( PRIMARYLANGID(GetSystemDefaultLangID()),
                                SUBLANG_CHINESE_TRADITIONAL),
                    SORT_DEFAULT
                    )
            );
        break;
    default:
	    sprintf(szCodePage,".%d",GetConsoleCP());  //a dot is added based on syntax of setlocale(), for defining a locale based on codepage.
	    setlocale(LC_ALL, szCodePage);
        break;
    }

    Initialize();
    nTmpWrite = _snwprintf(input_buffer, ARRAYSIZE(input_buffer)-1, L_TNADMIN_TEXT);
    BAIL_ON_SNWPRINTF_ERR();
    nWritten+=nTmpWrite;
    
    for (i = 1; i < argc; i++)
    {
        fSuccess = FALSE;
        if(0==_wcsicmp(L"-u",argv[i]))
        {
        	if(nUoccur)
        	{
        		ShowError(IDS_DUP_OPTION_ON_CL);
        		fprintf(stdout,"'%s'.\n","u");
        		goto End;
        	}
        	else
        		nUoccur=1;

        	i++;
           	if(i<argc)
                   g_arVALOF[_p_USER_]=_wcsdup(argv[i]);
           	else
           	{
           		ShowErrorEx(IDS_MISSING_FILE_OR_ARGUMENT_EX,L"-u");
           		goto End;
           	}
           	
            nTmpWrite=_snwprintf(input_buffer+nWritten, ARRAYSIZE(input_buffer)-nWritten-1, L" -u");
            BAIL_ON_SNWPRINTF_ERR();
            nWritten+=nTmpWrite;
           	continue;
        }
        else if(0==_wcsicmp(L"-p",argv[i]))
        {
        	if(nPoccur)
        	{
        		ShowError(IDS_DUP_OPTION_ON_CL);
        		fprintf(stdout,"'%s'.\n","p");
        		goto End;
        	}
        	else
        		nPoccur=1;
        		
           i++;
           if(i<argc)
                   g_arVALOF[_p_PASSWD_]=_wcsdup(argv[i]);
           else
           {
           		ShowErrorEx(IDS_MISSING_FILE_OR_ARGUMENT_EX,L"-p");
           		goto End;
           }
           nTmpWrite=_snwprintf(input_buffer+nWritten, ARRAYSIZE(input_buffer)-nWritten-1, L" -p");
           BAIL_ON_SNWPRINTF_ERR();
           nWritten+=nTmpWrite;
           
           continue;
        }
        //Processing of -m option
        else if(0==_wcsicmp(L"-m",argv[i]))
        {

           nTmpWrite=_snwprintf(input_buffer+nWritten, ARRAYSIZE(input_buffer)-nWritten-1, L" -m");
           BAIL_ON_SNWPRINTF_ERR();
           nWritten+=nTmpWrite;
           
           i++;
           // The next argument should be the session id or all
           // So, copy that to the input_buffer and let that be 
           // dealt by our lex

           if(i<argc)
           {
               nTmpWrite=_snwprintf(input_buffer+nWritten, ARRAYSIZE(input_buffer)-nWritten-1, L" %s", argv[i]);
               BAIL_ON_SNWPRINTF_ERR();
               nWritten+=nTmpWrite;
            }
           else
               goto MessageError;
           i++;
           if(i<argc)
           {
                // Then all the remaining command line arguments are
                // part of the message itself. So, copy them into the
                // global variable.
                	
                nTmpWrite=_snwprintf(wzMessageString, ARRAYSIZE(wzMessageString)-1, L"%s ", argv[i]);
                BAIL_ON_SNWPRINTF_ERR();
                // Don't increment nWritten here as we are not writing in to input_buffer
                nMsgWrite=nTmpWrite;
            	
                for(nIndex = i+1; nIndex < argc; nIndex++)
                {
                    nTmpWrite=_snwprintf(wzMessageString+nMsgWrite, ARRAYSIZE(wzMessageString)-1-nMsgWrite, L"%s ", argv[nIndex]);
                    BAIL_ON_SNWPRINTF_ERR();
                    nMsgWrite+=nTmpWrite;
                }
                g_bstrMessage=SysAllocString(wzMessageString);
               	
                break;
			}
           else
           {
MessageError:			
           		ShowErrorEx(IDS_MISSING_FILE_OR_ARGUMENT_EX,L"-m");
           		goto End;
           }
        }
        // Processing of actual filename is not given to Lexical analyser as
        // it may contail DBCS chars which our lexical analyser won't take
        // So, taking care of this analysis in pre-analysis part and giving
        // the actual analyser only the option and not the actual filename
        // This also holds good for domain name
        
        if(ERROR_SUCCESS!=(dwErrorCode = PreAnalyzer(argc,argv,_p_FNAME_,L"fname",i,&NextOp,&fSuccess,0)))
        {
            if(E_FAIL==dwErrorCode)
                ShowError(IDR_FILENAME_VALUES);
            else ShowError(dwErrorCode);
            goto End;
        }

        if(fSuccess)
        {
            // Some processing had take place in the PreAnalyzer
            nTmpWrite=_snwprintf(input_buffer+nWritten, ARRAYSIZE(input_buffer)-nWritten-1, L" fname");
            BAIL_ON_SNWPRINTF_ERR();
            nWritten+=nTmpWrite;
            
            i=NextOp;
            continue;
        }

        // Fall through for taking care of remaining options.

        // Similar treatment for Dom option

         if(ERROR_SUCCESS!=(dwErrorCode = PreAnalyzer(argc,argv,_p_DOM_,L"dom",i,&NextOp,&fSuccess,0)))
         {
            if(E_FAIL==dwErrorCode)
                ShowError(IDR_INVALID_NTDOMAIN);
            else ShowError(dwErrorCode);         
            goto End;
         }

        if(fSuccess)
        {
            // Some processing had take place in the PreAnalyzer
            nTmpWrite=_snwprintf(input_buffer+nWritten, ARRAYSIZE(input_buffer)-nWritten-1, L" dom");
            BAIL_ON_SNWPRINTF_ERR();
            nWritten+=nTmpWrite;
            
            i=NextOp;
            continue;
        }
        
Skip:
    	if(MAX_COMMAND_LINE<nWritten+wcslen(argv[i]))
    	{
    		ShowError(IDR_LONG_COMMAND_LINE);
			goto End;
        }

        if(NULL==wcsstr(argv[i],L" "))
            nTmpWrite = _snwprintf(input_buffer+nWritten, ARRAYSIZE(input_buffer)-nWritten-1, L" %s", argv[i]);
        else
            nTmpWrite = _snwprintf(input_buffer+nWritten, ARRAYSIZE(input_buffer)-nWritten-1, L" \"%s\"", argv[i]);
        // the following statements are common for both if and else statements
        BAIL_ON_SNWPRINTF_ERR();
        nWritten+=nTmpWrite;
            
    }

    nTmpWrite = _snwprintf(input_buffer+nWritten, ARRAYSIZE(input_buffer)-nWritten-1, L" #\n\0");
    BAIL_ON_SNWPRINTF_ERR();
    nWritten+=nTmpWrite;

    yy_scan_string(DupCStr(input_buffer));    
    
    yyparse ();

    if (g_nError)
    {
    	ShowError(IDR_TELNET_ILLEGAL);
        goto End;
    }

    hRes = DoTnadmin();
    if (hRes != S_OK && !g_nError)
        g_nError = 1; //general error status


End:

    Quit();
    return g_nError;
}
      
    
    

#line 717 "tnadminy.c"
#define YYABORT goto yyabort
#define YYREJECT goto yyabort
#define YYACCEPT goto yyaccept
#define YYERROR goto yyerrlab
int
yyparse()
{
    register int yym, yyn; register short yystate;
#if YYDEBUG
    register char *yys;
    extern char *getenv();

    if (yys = getenv("YYDEBUG"))
    {
        yyn = *yys;
        if (yyn >= '0' && yyn <= '9')
            yydebug = yyn - '0';
    }
#endif

    yynerrs = 0;
    yyerrflag = 0;
    yychar = (-1);

    yyssp = yyss;
    yyvsp = yyvs;
    *yyssp = yystate = 0;

yyloop:
    if (yyn = yydefred[yystate]) goto yyreduce;
    if (yychar < 0)
    {
        if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, reading %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
    }
    if ((yyn = yysindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: state %d, shifting to state %d\n",
                    YYPREFIX, yystate, yytable[yyn]);
#endif
        if (yyssp >= yyss + yystacksize - 1)
        {
            goto yyoverflow;
        }
        *++yyssp = yystate = yytable[yyn];
        *++yyvsp = yylval;
        yychar = (-1);
        if (yyerrflag > 0)  --yyerrflag;
        goto yyloop;
    }
    if ((yyn = yyrindex[yystate]) && (yyn += yychar) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yychar)
    {
        yyn = yytable[yyn];
        goto yyreduce;
    }
    if (yyerrflag) goto yyinrecovery;
#ifdef lint
    goto yynewerror;
#endif
 
    yyerror("syntax error");
#ifdef lint
    goto yyerrlab;
#endif
 
    ++yynerrs;
yyinrecovery:
    if (yyerrflag < 3)
    {
        yyerrflag = 3;
        for (;;)
        {
            if ((yyn = yysindex[*yyssp]) && (yyn += YYERRCODE) >= 0 &&
                    yyn <= YYTABLESIZE && yycheck[yyn] == YYERRCODE)
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: state %d, error recovery shifting\
 to state %d\n", YYPREFIX, *yyssp, yytable[yyn]);
#endif
                if (yyssp >= yyss + yystacksize - 1)
                {
                    goto yyoverflow;
                }
                *++yyssp = yystate = yytable[yyn];
                *++yyvsp = yylval;
                goto yyloop;
            }
            else
            {
#if YYDEBUG
                if (yydebug)
                    printf("%sdebug: error recovery discarding state %d\n",
                            YYPREFIX, *yyssp);
#endif
                if (yyssp <= yyss) goto yyabort;
                --yyssp;
                --yyvsp;
            }
        }
    }
    else
    {
        if (yychar == 0) goto yyabort;
#if YYDEBUG
        if (yydebug)
        {
            yys = 0;
            if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
            if (!yys) yys = "illegal-symbol";
            printf("%sdebug: state %d, error recovery discards token %d (%s)\n",
                    YYPREFIX, yystate, yychar, yys);
        }
#endif
        yychar = (-1);
        goto yyloop;
    }
yyreduce:
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: state %d, reducing by rule %d (%s)\n",
                YYPREFIX, yystate, yyn, yyrule[yyn]);
#endif
    yym = yylen[yyn];
    yyval = yyvsp[1-yym];
    switch (yyn)
    {
case 3:
#line 110 "tnadmin.y"
{ /* error production for more than one mutually exclusive options.*/
               ShowError(IDR_TELNET_MUTUALLY_EXCLUSIVE_OPTIONS);
           }
break;
case 4:
#line 116 "tnadmin.y"
{
                    g_arVALOF[_p_CNAME_]=DupWStr(yytext);
                }
break;
case 9:
#line 129 "tnadmin.y"
{g_nPrimaryOption=_START;}
break;
case 10:
#line 130 "tnadmin.y"
{g_nPrimaryOption=_STOP;}
break;
case 11:
#line 131 "tnadmin.y"
{g_nPrimaryOption=_PAUSE;}
break;
case 12:
#line 132 "tnadmin.y"
{g_nPrimaryOption=_CONTINUE;}
break;
case 13:
#line 133 "tnadmin.y"
{g_nPrimaryOption=_S;      }
break;
case 14:
#line 134 "tnadmin.y"
{g_nPrimaryOption=_K;      }
break;
case 16:
#line 135 "tnadmin.y"
{g_nPrimaryOption=_M;}
break;
case 18:
#line 136 "tnadmin.y"
{g_nPrimaryOption=_CONFIG;}
break;
case 21:
#line 139 "tnadmin.y"
{
		        fprintf(stdout,"%s:",yytext);
                ShowError(IDR_TELNET_CONTROL_VALUES);
#ifdef WHISTLER_BUILD
               	TnLoadString(IDR_NEW_TELNET_USAGE,szMsg,MAX_BUFFER_SIZE,TEXT("\nUsage: tlntadmn [computer name] [common_options] start | stop | pause | continue | -s | -k | -m | config config_options \n\tUse 'all' for all sessions.\n\t-s sessionid          List information about the session.\n\t-k sessionid\t Terminate a session. \n\t-m sessionid\t Send message to a session. \n\n\tconfig\t Configure telnet server parameters.\n\ncommon_options are:\n\t-u user\t Identity of the user whose credentials are to be used\n\t-p password\t Password of the user\n\nconfig_options are:\n\tdom = domain\t Set the default domain for user names\n\tctrlakeymap = yes|no\t Set the mapping of the ALT key\n\ttimeout = hh:mm:ss\t Set the Idle Session Timeout\n\ttimeoutactive = yes|no Enable idle session timeout.\n\tmaxfail = attempts\t Set the maximum number of login failure attempts\n\tbefore disconnecting.\n\tmaxconn = connections\t Set the maximum number of connections.\n\tport = number\t Set the telnet port.\n\tsec = [+/-]NTLM [+/-]passwd\n\t Set the authentication mechanism\n\tmode = console|stream\t Specify the mode of operation.\n"));
#else
	TnLoadString(IDR_NEW_TELNET_USAGE,szMsg,MAX_BUFFER_SIZE,TEXT("\nUsage: tnadmin [computer name] [common_options] start | stop | pause | continue | -s | -k | -m | config config_options \n\tUse 'all' for all sessions.\n\t-s sessionid          List information about the session.\n\t-k sessionid\t Terminate a session. \n\t-m sessionid\t Send message to a session. \n\n\tconfig\t Configure telnet server parameters.\n\ncommon_options are:\n\t-u user\t Identity of the user whose credentials are to be used\n\t-p password\t Password of the user\n\nconfig_options are:\n\tdom = domain\t Set the default domain for user names\n\tctrlakeymap = yes|no\t Set the mapping of the ALT key\n\ttimeout = hh:mm:ss\t Set the Idle Session Timeout\n\ttimeoutactive = yes|no Enable idle session timeout.\n\tmaxfail = attempts\t Set the maximum number of login failure attempts\n\tbefore disconnecting.\n\tmaxconn = connections\t Set the maximum number of connections.\n\tport = number\t Set the telnet port.\n\tsec = [+/-]NTLM [+/-]passwd\n\t Set the authentication mechanism\n\tmode = console|stream\t Specify the mode of operation.\n"));
#endif
		        MyWriteConsole(GetStdHandle(STD_OUTPUT_HANDLE),szMsg,wcslen(szMsg));
		        return(1);
            }
break;
case 22:
#line 154 "tnadmin.y"
{g_nSesid=atoi(yytext);}
break;
case 23:
#line 155 "tnadmin.y"
{g_nSesid=-1;}
break;
case 24:
#line 157 "tnadmin.y"
{
                ShowError(IDR_SESSION);  
                return(1);
             }
break;
case 27:
#line 167 "tnadmin.y"
{g_nPrimaryOption=_HELP;return 0;}
break;
case 28:
#line 171 "tnadmin.y"
{g_nSesid=-1;}
break;
case 29:
#line 172 "tnadmin.y"
{g_nSesid=atoi(yytext);}
break;
case 30:
#line 173 "tnadmin.y"
{if(g_nPrimaryOption == _K)
          				 {
          				 	ShowError(IDR_SESSION);
          				 	return(1);
          				 }
          					g_nSesid=-1;}
break;
case 33:
#line 186 "tnadmin.y"
{szYesno="yes";}
break;
case 34:
#line 187 "tnadmin.y"
{szYesno="no";}
break;
case 40:
#line 194 "tnadmin.y"
{g_nTimeoutFlag=0;}
break;
case 41:
#line 195 "tnadmin.y"
{g_nTimeoutFlag=1;}
break;
case 42:
#line 200 "tnadmin.y"
{
                 g_nConfigOptions=SetBit(g_nConfigOptions,_p_DOM_);
          /*         g_arVALOF[_p_DOM_]=DupWStr(yytext);*/
             }
break;
case 43:
#line 205 "tnadmin.y"
{
                 g_nConfigOptions=SetBit(g_nConfigOptions,_p_CTRLAKEYMAP_);
                  g_arVALOF[_p_CTRLAKEYMAP_]=DupWStr(szYesno);
             }
break;
case 44:
#line 210 "tnadmin.y"
{
                ShowError(IDR_CTRLAKEYMAP_VALUES);
                return(1);
                /*Quit();*/
             }
break;
case 45:
#line 216 "tnadmin.y"
{
                 g_nConfigOptions=SetBit(g_nConfigOptions,_p_TIMEOUT_);
                 g_arVALOF[_p_TIMEOUT_]=DupWStr(yytext);
             }
break;
case 46:
#line 221 "tnadmin.y"
{
                ShowError(IDR_TIMEOUT_INTEGER_VALUES );
                return(1);
             }
break;
case 47:
#line 226 "tnadmin.y"
{
                 g_nConfigOptions=SetBit(g_nConfigOptions,_p_TIMEOUTACTIVE_);
                   g_arVALOF[_p_TIMEOUTACTIVE_]=DupWStr(szYesno);
             }
break;
case 48:
#line 231 "tnadmin.y"
{
                 ShowError(IDR_TIMEOUTACTIVE_VALUES);
                return(1);
             }
break;
case 49:
#line 236 "tnadmin.y"
{
                 g_nConfigOptions=SetBit(g_nConfigOptions,_p_MAXFAIL_);
                   g_arVALOF[_p_MAXFAIL_]=DupWStr(yytext);
             }
break;
case 50:
#line 241 "tnadmin.y"
{
                ShowError(IDR_MAXFAIL_VALUES );
                return(1);
             }
break;
case 51:
#line 246 "tnadmin.y"
{
                 g_nConfigOptions=SetBit(g_nConfigOptions,_p_MAXCONN_);
                 g_arVALOF[_p_MAXCONN_]=DupWStr(yytext);
             }
break;
case 52:
#line 251 "tnadmin.y"
{
             /* Removing this check, as we have decided that we are not going to restrict*/
             /* max connections on Whistler.*/
             	/*if(!IsMaxConnChangeAllowed())
             		ShowError(IDR_MAXCONN_VALUES_WHISTLER);
             	else*/
	                ShowError(IDR_MAXCONN_VALUES );
                return(1);
             }
break;
case 53:
#line 261 "tnadmin.y"
{
                 g_nConfigOptions=SetBit(g_nConfigOptions,_p_PORT_);
                 g_arVALOF[_p_PORT_]=DupWStr(yytext);
             }
break;
case 54:
#line 266 "tnadmin.y"
{
                ShowError(IDR_TELNETPORT_VALUES );
                return(1);
             }
break;
case 55:
#line 271 "tnadmin.y"
{
                 g_nConfigOptions=SetBit(g_nConfigOptions,_p_KILLALL_);
                   g_arVALOF[_p_KILLALL_]=DupWStr(szYesno);
             }
break;
case 56:
#line 276 "tnadmin.y"
{
                ShowError(IDR_KILLALL_VALUES );
                return(1);
             }
break;
case 57:
#line 280 "tnadmin.y"
{g_fComp=0;}
break;
case 58:
#line 281 "tnadmin.y"
{ 
                    g_fComp=1;
                    if(g_nSecOff||g_nSecOn)
                       g_nConfigOptions=SetBit(g_nConfigOptions,_p_SEC_);
                    else
                    {    
                        ShowError(IDR_TELNET_SECURITY_VALUES);
                        return(1);
                    }
             }
break;
case 59:
#line 292 "tnadmin.y"
{
                g_nConfigOptions=SetBit(g_nConfigOptions,_p_FNAME_);
               /* g_arVALOF[_p_FNAME_]=DupWStr(yytext);*/
             }
break;
case 60:
#line 298 "tnadmin.y"
{
                 g_arVALOF[_p_FSIZE_]=DupWStr(yytext);
                 g_nConfigOptions=SetBit(g_nConfigOptions,_p_FSIZE_);
             }
break;
case 61:
#line 303 "tnadmin.y"
{
                ShowError(IDR_FILESIZE_VALUES );
                return(1);
             }
break;
case 62:
#line 308 "tnadmin.y"
{
                 g_arVALOF[_p_MODE_]=DupWStr(yytext);
                 g_nConfigOptions=SetBit(g_nConfigOptions,_p_MODE_);
             }
break;
case 63:
#line 313 "tnadmin.y"
{
                 g_nConfigOptions=SetBit(g_nConfigOptions,_p_AUDITLOCATION_);
                 g_arVALOF[_p_AUDITLOCATION_]=DupWStr(yytext);
             }
break;
case 64:
#line 317 "tnadmin.y"
{g_fComp=0;}
break;
case 65:
#line 318 "tnadmin.y"
{
                 g_fComp=1;
                 if(g_nAuditOff||g_nAuditOn)
                    g_nConfigOptions=SetBit(g_nConfigOptions,_p_AUDIT_);
                 else
                 {
                    ShowError(IDS_E_OPTIONGROUP);
                 }
            }
break;
case 67:
#line 330 "tnadmin.y"
{
                if(GetBit(g_nSecOn,NTLM_BIT)||GetBit(g_nSecOff,NTLM_BIT))
                {
                  ShowError(IDS_E_OPTIONGROUP);
                  }
               else
                    g_nSecOn=SetBit(g_nSecOn,NTLM_BIT);
            }
break;
case 68:
#line 339 "tnadmin.y"
{
                if(GetBit(g_nSecOn,NTLM_BIT)||GetBit(g_nSecOff,NTLM_BIT))
                {
                  ShowError(IDS_E_OPTIONGROUP);
                  }
               else
                    g_nSecOff=SetBit(g_nSecOff,NTLM_BIT);
            }
break;
case 69:
#line 348 "tnadmin.y"
{
               if(GetBit(g_nSecOn,PASSWD_BIT)||GetBit(g_nSecOff,PASSWD_BIT))
               {
               	  ShowError(IDS_E_OPTIONGROUP);
               }
               else
                    g_nSecOn=SetBit(g_nSecOn,PASSWD_BIT);
           }
break;
case 70:
#line 357 "tnadmin.y"
{
               if(GetBit(g_nSecOn,PASSWD_BIT)||GetBit(g_nSecOff,PASSWD_BIT))
               {
               	  ShowError(IDS_E_OPTIONGROUP);
               }
               else
                    g_nSecOff=SetBit(g_nSecOff,PASSWD_BIT);
           }
break;
case 72:
#line 369 "tnadmin.y"
{
                if(GetBit(g_nAuditOn,USER_BIT)||GetBit(g_nAuditOff,USER_BIT))
                {
                  ShowError(IDS_E_OPTIONGROUP);
                  }
                else
                    g_nAuditOn=SetBit(g_nAuditOn,USER_BIT);
            }
break;
case 73:
#line 378 "tnadmin.y"
{
                if(GetBit(g_nAuditOn,USER_BIT)||GetBit(g_nAuditOff,USER_BIT))
                {
                  ShowError(IDS_E_OPTIONGROUP);
                  }
                else
                    g_nAuditOff=SetBit(g_nAuditOff,USER_BIT);
            }
break;
case 74:
#line 387 "tnadmin.y"
{
                if(GetBit(g_nAuditOn,FAIL_BIT)||GetBit(g_nAuditOff,FAIL_BIT))
                {
                	ShowError(IDS_E_OPTIONGROUP);
                }
                else
                    g_nAuditOn=SetBit(g_nAuditOn,FAIL_BIT);
            }
break;
case 75:
#line 396 "tnadmin.y"
{
                if(GetBit(g_nAuditOn,FAIL_BIT)||GetBit(g_nAuditOff,FAIL_BIT))
                {
                	ShowError(IDS_E_OPTIONGROUP);
                }
                else
                    g_nAuditOff=SetBit(g_nAuditOff,FAIL_BIT);
            }
break;
case 76:
#line 405 "tnadmin.y"
{
                if(GetBit(g_nAuditOn,ADMIN_BIT)||GetBit(g_nAuditOff,ADMIN_BIT))
                {
                  ShowError(IDS_E_OPTIONGROUP);
                  }
                else
                    g_nAuditOn=SetBit(g_nAuditOn,ADMIN_BIT);
            }
break;
case 77:
#line 414 "tnadmin.y"
{
                if(GetBit(g_nAuditOn,ADMIN_BIT)||GetBit(g_nAuditOff,ADMIN_BIT))
                {
                  ShowError(IDS_E_OPTIONGROUP);
                  }
                else
                    g_nAuditOff=SetBit(g_nAuditOff,ADMIN_BIT);
            }
break;
#line 1257 "tnadminy.c"
    }
    yyssp -= yym;
    yystate = *yyssp;
    yyvsp -= yym;
    yym = yylhs[yyn];
    if (yystate == 0 && yym == 0)
    {
#if YYDEBUG
        if (yydebug)
            printf("%sdebug: after reduction, shifting from state 0 to\
 state %d\n", YYPREFIX, YYFINAL);
#endif
        yystate = YYFINAL;
        *++yyssp = YYFINAL;
        *++yyvsp = yyval;
        if (yychar < 0)
        {
            if ((yychar = yylex()) < 0) yychar = 0;
#if YYDEBUG
            if (yydebug)
            {
                yys = 0;
                if (yychar <= YYMAXTOKEN) yys = yyname[yychar];
                if (!yys) yys = "illegal-symbol";
                printf("%sdebug: state %d, reading %d (%s)\n",
                        YYPREFIX, YYFINAL, yychar, yys);
            }
#endif
        }
        if (yychar == 0) goto yyaccept;
        goto yyloop;
    }
    if ((yyn = yygindex[yym]) && (yyn += yystate) >= 0 &&
            yyn <= YYTABLESIZE && yycheck[yyn] == yystate)
        yystate = yytable[yyn];
    else
        yystate = yydgoto[yym];
#if YYDEBUG
    if (yydebug)
        printf("%sdebug: after reduction, shifting from state %d \
to state %d\n", YYPREFIX, *yyssp, yystate);
#endif
    if (yyssp >= yyss + yystacksize - 1)
    {
        goto yyoverflow;
    }
    *++yyssp = yystate;
    *++yyvsp = yyval;
    goto yyloop;
yyoverflow:
    yyerror("yacc stack overflow");
yyabort:
    return (1);
yyaccept:
    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\client\commands.c ===
/*
commands.c
Copyright (c) Microsoft Corporation.  All rights reserved.
Implementation of Telnet Commands
*/

#pragma warning( disable: 4201 )
#pragma warning( disable: 4100 )

#include <windows.h>      /* required for all Windows applications */
#include <tchar.h>
#include <stdio.h>
#include <stdlib.h>
#include <winsock2.h>
#include "commands.h"
#include "WinTel.h"       /* specific to this program   */
#include "debug.h"
#include "trmio.h"
#include "telnet.h"

extern WI gwi;
extern HINSTANCE ghInstance;
extern HANDLE g_hRemoteNEscapeModeDataSync;
extern HANDLE g_hCaptureConsoleEvent;
extern WCHAR  g_szKbdEscape[];
extern BOOL   g_bIsEscapeCharValid;
extern BOOL bDoVtNTFirstTime;
extern BOOL fPrintMessageToSessionConsole;
BOOL   bOnlyOnce = 1;
BOOL   bBufferSizeChanged = 0;
BOOL   bWindowSizeChanged = 0;
BOOL   bMaxWindow = 0;
extern SMALL_RECT srOldClientWindow;
extern TCHAR g_szLogFile[];
extern g_fSentWillNaws;
void   SetWindowSize( HANDLE );
void   GetErrMsgString( DWORD, LPTSTR* );

BOOL StuffEscapeIACs( PUCHAR* ppBufDest, UCHAR bufSrc[], DWORD* pdwSize );

void ConvertAndSendVTNTData( LPTSTR pData, int iLen );

void *SfuZeroMemory(
        void    *ptr,
        unsigned int   cnt
        )
{
    volatile char *vptr = (volatile char *)ptr;

    while (cnt)
    {
        *vptr = 0;
        vptr ++;
        cnt --;
    }

    return ptr;
}

BOOL PromptUser()
{    
    DWORD dwLength = 1;
    INPUT_RECORD irRec;

    ResetEvent( g_hCaptureConsoleEvent );        
    ui.bPromptForNtlm = TRUE;
    irRec.EventType = FOCUS_EVENT;
    irRec.Event.FocusEvent.bSetFocus = TRUE;
    WriteConsoleInput( gwi.hInput, &irRec, dwLength, &dwLength );

    WaitForSingleObject( g_hCaptureConsoleEvent, INFINITE );

    return ui.bSendCredsToRemoteSite;
}

//NULL as the last arg is a MUST when you are using Write function
void Write(LPTSTR lpszFmtStr, ...)
{
    DWORD dwWritten;
    DWORD dwSize = 0;
    va_list vaArgList;
    TCHAR *szBuf = NULL;
    TCHAR *szArg = lpszFmtStr;

    if( !lpszFmtStr )
    {
        return;
    }

    va_start( vaArgList, lpszFmtStr );
    while( szArg )
    {
        dwSize += wcslen( szArg );
        szArg  =  va_arg( vaArgList, LPWSTR );
    }

    va_end( vaArgList );

    szBuf = ( TCHAR *) malloc( ( dwSize + 1 ) * sizeof( TCHAR ) );
    if( !szBuf )
    {
        return;
    }
    szBuf[dwSize] = 0;
    va_start( vaArgList, lpszFmtStr );
    //PREFIX gives "untrusted function". We want to use _vsntprintf(). Won't fix.
    _vsntprintf( szBuf, dwSize,lpszFmtStr, vaArgList );
    va_end( vaArgList );
    WriteConsole(gwi.hOutput, szBuf, _tcslen(szBuf), &dwWritten, NULL);

    free( szBuf );
}

void WriteMessage( DWORD dwMsgId, WCHAR szEnglishString[] )
{
    WCHAR szMsg[ MAX_STRING_LENGTH ];

    if( !LoadString( ghInstance, dwMsgId, szMsg, MAX_STRING_LENGTH ) )
    {
        lstrcpyn( szMsg, szEnglishString, MAX_STRING_LENGTH - sizeof(WCHAR) );
    }

    Write( szMsg, NULL );
}


void FreeLoggingDataStructs()
{
    if( g_rgciCharInfo != NULL )
        (void)LocalFree( (HLOCAL)g_rgciCharInfo );

    if (g_rgchRow != NULL)
        (void)LocalFree( (HLOCAL)g_rgchRow );

    g_rgchRow               = NULL;
    g_rgciCharInfo          = NULL;    
}


BOOL CloseTelnetSession(LPTSTR szCommand)
{
    CONSOLE_SCREEN_BUFFER_INFO csbInfo;

    if( FGetCodeMode(eCodeModeIMEFarEast) && bOnlyOnce && (gwi.hOutput != g_hTelnetPromptConsoleBuffer)) 
    {
        bOnlyOnce = 0;
        GetConsoleScreenBufferInfo( g_hSessionConsoleBuffer, &csbInfo );
        
        if( bBufferSizeChanged )
        {
            csbInfo.dwSize.Y -= 1;
            SetConsoleScreenBufferSize( g_hSessionConsoleBuffer, 
                    csbInfo.dwSize );
        }
        if( bWindowSizeChanged )
        {
            csbInfo.srWindow.Bottom -= 1;
            SetConsoleWindowInfo( g_hSessionConsoleBuffer, TRUE, 
                    &csbInfo.srWindow);
        }
    }
    bDoVtNTFirstTime = 1;
    if( fConnected )
    {
        fConnected = FHangupConnection(&gwi, &(gwi.nd));
    }
    
    if( ui.bLogging )
    {
        FreeLoggingDataStructs();
    }
    ui.dwMaxRow = 0;
    ui.dwMaxCol = 0;

    srOldClientWindow.Left  = srOldClientWindow.Right  = 0;
    srOldClientWindow.Top   = srOldClientWindow.Bottom = 0;

    SetEvent( g_hRemoteNEscapeModeDataSync );

    SetConsoleTitle( szAppName );

    g_fSentWillNaws = FALSE; //so that it does naws when we connect again.
    return FALSE;
}

extern CHAR* rgchTermType[];

BOOL DisplayParameters(LPTSTR szCommand)
{
    TCHAR szTermType[81];
    DWORD dwLen = 0;

    SfuZeroMemory(szTermType, sizeof(szTermType));

    if( g_bIsEscapeCharValid )
    {
        Write( g_szKbdEscape, NULL );
    }
    else
    {
        TCHAR szMsg[ MAX_STRING_LENGTH ];
        LoadString( ghInstance, IDS_NO_ESCAPE , szMsg, MAX_STRING_LENGTH );
        Write( szMsg, NULL );
    }

    if ( ui.bWillAUTH )
        Write( szWillAuth, NULL );
    else
        Write( szWontAuth, NULL );

    if( ui.fDebug & fdwLocalEcho )
        Write( szLocalEchoOn, NULL );
    else
        Write( szLocalEchoOff, NULL );

    if( ui.bLogging )
    {
        TCHAR szFileNameTitle[ MAX_STRING_LENGTH + 1 ];
        WriteMessage( IDS_LOGGING_ON, ( LPTSTR ) TEXT( MSG_LOGGING_ON ) );
        LoadString( ghInstance, IDS_LOGFILE_NAME, szFileNameTitle, MAX_STRING_LENGTH );
        Write( szFileNameTitle, g_szLogFile, NULL );
    }

    if( ui.dwCrLf )
    {
        WriteMessage( IDS_CRLF, ( LPTSTR ) _T( MSG_CRLF ) );
    }
    else
    {
        WriteMessage( IDS_CR, ( LPTSTR ) _T( MSG_CR ) );
    }
    if( g_bSendBackSpaceAsDel )
    {
        WriteMessage( IDS_BACKSPACEASDEL, ( LPTSTR ) _T( MSG_BACKSPACEASDEL ) );
    }
    if( g_bSendDelAsBackSpace )
    {
        WriteMessage( IDS_DELASBACKSPACE, ( LPTSTR ) _T( MSG_DELASBACKSPACE ) );
    }

    if( (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80)) && 
                FIsVT80(&gwi.trm) && (gwi.trm.RequestedTermType != TT_VTNT) )
    {
        int i =0;

        for(i=0 ; i<NUMBER_OF_KANJI ; ++i)
        {
            if( gwi.trm.dwKanjiFlags & KanjiList[i].KanjiEmulationID )
            {
                Write( szVT100KanjiEmulation, NULL );
                Write( KanjiList[i].KanjiDescription, NULL );
                break;
            }
        }

        Write( TEXT("\n"), NULL );
    }

    {
        DWORD dwSize = 0;
        WCHAR wchTemp[1] = {0L};
        dwSize = GetEnvironmentVariable( TEXT( SFUTLNTMODE ), wchTemp, 0 );
        if( dwSize > 0 )
        {
            TCHAR *szMode = NULL;
            szMode = ( TCHAR * ) malloc( ( dwSize + 1 )* sizeof( TCHAR ) );
			if( szMode != NULL )
			{
            	dwSize = GetEnvironmentVariable( TEXT( SFUTLNTMODE ), szMode, dwSize + 1 );
	            if( _tcsicmp( szMode, TEXT( CONSOLE )) == 0 )
    	        {
        	        dwSize = 0; //indicating console mode
            	}
	            else
    	        {
	                WriteMessage( IDS_CURRENT_MODE, ( LPTSTR )TEXT( MSG_CURRENT_MODE ) );
    	            WriteMessage( IDS_STREAM_ONLY,  ( LPTSTR )TEXT( MSG_STREAM_ONLY ) );
        	    }
            	free( szMode );
			}
        }
    
        if( dwSize == 0 )
        {
            //console mode
            WriteMessage( IDS_CURRENT_MODE, ( LPTSTR )TEXT( MSG_CURRENT_MODE ) );
            WriteMessage( IDS_CONSOLE_ONLY, ( LPTSTR )TEXT( MSG_CONSOLE_ONLY ) );
        }
    }  

//#if defined(FE_IME)
//    if( ui.fDebug & fdwEnableIMESupport )
//    {
//        Write( szEnableIMEOn, NULL );
//    }
//#endif /* FE_IME */
	dwLen = sizeof(szTermType)/sizeof(WCHAR);
  	szTermType[dwLen -1] = 0;      
    _snwprintf( szTermType,dwLen -1, ( LPTSTR )TEXT("%S"), rgchTermType[gwi.trm.RequestedTermType] );
    Write( szPrefTermType, szTermType, NULL );

    // when we are connected we need to say what we are connected at.
    if ( fConnected && gwi.trm.SentTermType != TT_UNKNOWN )
    {
        _snwprintf( szTermType,(sizeof(szTermType)/sizeof(WCHAR))-1, ( LPTSTR )TEXT("%S"), rgchTermType[gwi.trm.SentTermType]);
        Write( szNegoTermType, szTermType, NULL );
    }

    return FALSE;
}

/* This initialization happens on every OpenTelnetSession() 
and the meemory is freed on every CloseTelnetSession() */
BOOL InitLoggingDataStructs()
{
    UINT uiSize = 0;

    if( g_rgchRow )
    {
        //This is needed because rows and cols may have changed
        FreeLoggingDataStructs();
    }

    uiSize = (UINT)(sizeof(CHAR_INFO) * ui.dwMaxCol);

    if( FGetCodeMode( eCodeModeFarEast ) )
    {
        uiSize *= 3; // accounting for a lot of multi byte chars
    }

    g_rgciCharInfo = (PCHAR_INFO)LocalAlloc(LPTR, uiSize );
    g_rgchRow = (UCHAR *)LocalAlloc(LPTR, uiSize );

    if ( !g_rgchRow || !g_rgciCharInfo )
    {
        ui.bLogging = FALSE;
        return FALSE;
    }

    return TRUE;
}

BOOL CloseLogging()
{
    CloseHandle(ui.hLogFile);
    ui.hLogFile = NULL;

    return TRUE;
}

BOOL StopLogging()
{
    ui.bLogging = FALSE;
    FreeLoggingDataStructs();

    return TRUE;
}

BOOL InitLogFile( LPTSTR szCommand )
{
    if( ui.hLogFile )
    {
        CloseLogging( );
    }

    ui.hLogFile = CreateFile( szCommand, GENERIC_WRITE, FILE_SHARE_READ|FILE_SHARE_DELETE, NULL, 
        CREATE_ALWAYS, 0, NULL);
    if (ui.hLogFile == INVALID_HANDLE_VALUE)
    {           
        LPWSTR szErrMsg = NULL;
        ui.bLogging = FALSE;
        ui.hLogFile = NULL;
        GetErrMsgString( GetLastError(), &szErrMsg );
        Write( szErrMsg, L"\r\n", NULL );
        LocalFree( szErrMsg );
        return FALSE;
    }
    
    return TRUE;
}

BOOL  StartLogging( )
{
    ui.bLogging = FALSE;
    if( !ui.hLogFile )  //If we have valid logfile
    {
        return FALSE;
    }

    ui.bLogging = TRUE;

    if( ui.dwMaxRow != 0 && ui.dwMaxCol != 0 )
    {
        InitLoggingDataStructs();
    }

    return TRUE;
}

INT GetRequestedTermType( LPTSTR pszTerm )
{
    if( !_tcsicmp( pszTerm, ( LPTSTR )TEXT("ansi") ))
        return 0;
    if( !_tcsicmp( pszTerm, ( LPTSTR )TEXT("vt100") ))
        return 1;
    if( !_tcsicmp( pszTerm, ( LPTSTR )TEXT("vt52") ))
        return 2;
    if( !_tcsicmp( pszTerm, ( LPTSTR )TEXT("vtnt") ))
        return 3;

    return -1;
}

void SqueezeWhiteSpace( TCHAR s[] )
{
    INT i,j;

    if( s == NULL )
    {
        return;
    } 

    for( i = 0, j= 0; s[i] != _T('\0'); i++ )
        if( !iswspace( s[i] ) )
        {
            s[j++] = s[i];
        }
    s[j] = _T('\0');
}

void RemoveLeadingNTrailingWhiteSpaces( LPTSTR *pOption )
{
    DWORD dwIndex = 0;

    if( *pOption == NULL )
    {
        return;
    }

    dwIndex = wcslen( *pOption );
    if( dwIndex <= 0 )
    {
        return;
    }

    while( iswspace( (*pOption)[ dwIndex - 1 ] ) && dwIndex > 0  )
    {
        dwIndex--;
    }

    (*pOption)[ dwIndex ] = L'\0';

    while( iswspace( *( *pOption ) ) )
    {
        (*pOption)++;
    }    

}

BOOL SendOptions( LPTSTR pOption )
{

    if( pOption == NULL )
    {
        WriteMessage( IDS_SEND_FORMAT, ( LPTSTR )TEXT( MSG_SEND_FORMAT ) );
        return FALSE;
    }

    RemoveLeadingNTrailingWhiteSpaces( &pOption );

    if( *pOption== _T('?') )
    {
        WriteMessage( IDS_SEND_HELP, ( LPTSTR )TEXT( MSG_SEND_HELP ) );
        return FALSE;
    }

    if( !fConnected )
    {
        WriteMessage( IDS_NOT_CONNECTED, ( LPTSTR )TEXT( MSG_NOT_CONNECTED ) );
        return FALSE;
    }
    if( !_tcsicmp( pOption, ( LPTSTR )TEXT("AO") ) )
    {
        /* Our server does nothing on receiving AO. This is for other servers */
        FSendTelnetCommands(gwi.hwnd, (char)AO);
        WriteMessage( IDS_SENT_AO, ( LPTSTR )TEXT( MSG_SENT_AO ) );
        return FALSE;
    }

    if( !_tcsicmp( pOption, ( LPTSTR )TEXT("AYT") ) )
    {
        FSendTelnetCommands(gwi.hwnd, (char)AYT);
        WriteMessage( IDS_SENT_AYT, ( LPTSTR )TEXT( MSG_SENT_AYT ) );
        
        return FALSE;
    }

    if( !_tcsicmp( pOption, ( LPTSTR )TEXT("ESC") ) )
	{
		if(gwi.trm.CurrentTermType == TT_VTNT)
		{
			ConvertAndSendVTNTData(&g_chEsc,1);
		}
		else
		{
			FSendChars( gwi.hwnd, &g_chEsc, sizeof( g_chEsc ) / sizeof( WCHAR ) );
		}
		WriteMessage( IDS_SENT_ESC, ( LPTSTR )TEXT( MSG_SENT_ESC ) );
		return FALSE;;
	}

    if( !_tcsicmp( pOption, ( LPTSTR )TEXT("IP") ) )
    {
        FSendTelnetCommands(gwi.hwnd, (char)IP);
        WriteMessage( IDS_SENT_IP, ( LPTSTR )TEXT( MSG_SENT_IP ) );
        return FALSE;
    }

    if( !_tcsicmp( pOption, ( LPTSTR )TEXT("SYNCH") ) )
    {
        FSendSynch( gwi.hwnd );
        WriteMessage( IDS_SENT_SYNCH, ( LPTSTR )TEXT( MSG_SENT_SYNCH ) );
        return FALSE;
    }

    if( !_tcsicmp( pOption, ( LPTSTR )TEXT("BRK") ) )
    {
        FSendTelnetCommands(gwi.hwnd, (char)BREAK );
        WriteMessage( IDS_SENT_BRK, ( LPTSTR )TEXT( MSG_SENT_BRK ) );
        return FALSE;
    }
        

    //If none of the above send as it is
    {
        WCHAR szMsg[ MAX_STRING_LENGTH + 1 ];
		if(gwi.trm.CurrentTermType == TT_VTNT)
		{
			ConvertAndSendVTNTData(pOption,wcslen(pOption));
		}
		else
		{
	        FSendChars( gwi.hwnd, pOption, wcslen( pOption ) );
		}

        if( !LoadString( ghInstance, IDS_SENT_CHARS, szMsg, MAX_STRING_LENGTH ) )
	    {
	        wcscpy( szMsg, TEXT( MSG_SENT_CHARS ) ); //no overflow. LoadString will return NULL terminated string.
	    }

	    Write( szMsg, pOption, NULL );                

    }

    return FALSE;
}


/*++ If the data to be sent to the server is VTNT data, it cannot be sent as it is. This function
will convert the given string ( pData ) into INPUT_RECORDS and send it through the socket. This
is needed since the server expects VTNT data in INPUT_RECORD format and not in characters.
--*/
void ConvertAndSendVTNTData( LPTSTR pData, int iLen )
{
    INPUT_RECORD sInputRecord;
    
    PUCHAR destBuf = NULL;
    DWORD dwSize = 0;
    int iIndex = 0;
    
    while(iLen)
    {
	    sInputRecord.EventType = KEY_EVENT;
	    sInputRecord.Event.KeyEvent.bKeyDown = TRUE;
	    sInputRecord.Event.KeyEvent.uChar.UnicodeChar = pData[iIndex];

	    dwSize = sizeof( INPUT_RECORD );    
		if( !StuffEscapeIACs( &destBuf, (PUCHAR) &sInputRecord, &dwSize ) )
	    {
	        FWriteToNet(&gwi, (char *)&sInputRecord, sizeof(INPUT_RECORD));
	    }
	    else
	    {
	        FWriteToNet( &gwi, ( CHAR* )destBuf, dwSize );
	        dwSize = 0;
	    }
	    iIndex++;
	    iLen --;
    }
if(destBuf)
	free( destBuf );
}

BOOL SetOptions( LPTSTR pOption )
{
    TCHAR szLoggingOn[ MAX_STRING_LENGTH ];

    if( pOption == NULL )
    {
        Write( szSetFormat, NULL );
        return FALSE;
    }

    RemoveLeadingNTrailingWhiteSpaces( &pOption );

    if( *pOption== _T('?') )
    {
        Write( szSetHelp, NULL );
        return FALSE;
    }
    if( !_tcsicmp( pOption, ( LPTSTR )TEXT("BSASDEL") ) )
    {
        g_bSendBackSpaceAsDel = TRUE;
        WriteMessage( IDS_BACKSPACEASDEL, ( LPTSTR )TEXT( MSG_BACKSPACEASDEL ) );
        return FALSE;
    }
    if( !_tcsicmp( pOption, ( LPTSTR )TEXT("CRLF") ) )
    {
        SetLineMode( &( gwi.trm ) );
        ui.dwCrLf=TRUE;
        WriteMessage( IDS_CRLF, ( LPTSTR )TEXT( MSG_CRLF ) );
        return FALSE;
    }
    if( !_tcsicmp( pOption, ( LPTSTR )TEXT("DELASBS") ) )
    {
        g_bSendDelAsBackSpace = TRUE;
        WriteMessage( IDS_DELASBACKSPACE, ( LPTSTR )TEXT( MSG_DELASBACKSPACE ) );
        return FALSE;
    }
    if( !_tcsnicmp( pOption, ( LPTSTR )TEXT("MODE"), wcslen( ( LPTSTR )TEXT("MODE") ) )
                    && iswspace( *( pOption + wcslen( ( LPTSTR )TEXT("MODE") ) ) ) )

    {
        TCHAR* pMode = NULL;

        pOption += wcslen( ( LPTSTR )TEXT("MODE") );
        pMode = _tcstok( pOption, ( LPTSTR )_T(" \t") );

        if( pMode )
        {
            SqueezeWhiteSpace( pMode );
            if( pMode[ 0 ] != L'\0'  )
            {
                if( !_tcsicmp( pMode, ( LPTSTR )TEXT( STREAM )) )
                {
                    if( !SetEnvironmentVariable( TEXT( SFUTLNTMODE ), TEXT( STREAM ) ) )
                    {
                        DWORD dwError = 0;
                        ASSERT( 0 );
                        dwError = GetLastError();
                    }
                    WriteMessage( IDS_STREAM, ( LPTSTR )TEXT( MSG_STREAM ) );
                    return FALSE;
                }
                else if( !_tcsicmp( pMode, ( LPTSTR )TEXT( CONSOLE ) ) )
                {
                    if( !SetEnvironmentVariable( TEXT( SFUTLNTMODE ), TEXT( CONSOLE ) ) )
                    {
                        DWORD dwError = 0;
                        ASSERT( 0 );
                        dwError = GetLastError();
                    }
                    WriteMessage( IDS_CONSOLE, ( LPTSTR )TEXT( MSG_CONSOLE ) );
                    return FALSE;
                }
                else
                {
                    WriteMessage(IDS_SUPPORTED_MODES, (LPTSTR) TEXT ( MSG_SUPPORTED_MODES) );
                    return FALSE;
                }
            }
        }        
    }
    if( !_tcsicmp( pOption, ( LPTSTR )TEXT("NTLM") ) )
    {
        ui.bWillAUTH = 1;
        Write( szWillAuth, NULL );
        return FALSE;
    }
    if( !_tcsicmp( pOption, ( LPTSTR )TEXT("LOCALECHO") ) )
    {
        ui.fDebug |= fdwLocalEcho;
        Write( szLocalEchoOn, NULL );
        return FALSE;
    }

    if( !_tcsnicmp( pOption, ( LPTSTR )TEXT("LOGFILE"),
                    wcslen( ( LPTSTR )TEXT("LOGFILE") ) )
                    && iswspace( *( pOption + wcslen( ( LPTSTR )TEXT("LOGFILE") ) ) ) )
    {
        TCHAR szMsg[ MAX_STRING_LENGTH ];
        TCHAR* pTerm = NULL;

        pOption += wcslen( ( LPTSTR )TEXT("LOGFILE") );
        pTerm = _tcstok( pOption, ( LPTSTR )_T(" \t") );

        if( pTerm )
        {
            SqueezeWhiteSpace( pTerm );
            if( !InitLogFile( pTerm ) )
            {
                LoadString( ghInstance, IDS_BAD_LOGFILE, szMsg, MAX_STRING_LENGTH );
                Write( szMsg, NULL );
                return FALSE;
            }
        }
        
        LoadString( ghInstance, IDS_LOGFILE_NAME, szMsg, MAX_STRING_LENGTH );        
        Write( szMsg, pTerm, NULL );
        wcsncpy( g_szLogFile, pTerm, MAX_PATH );

        StartLogging( );

        LoadString( ghInstance, IDS_LOGGING_ON, szLoggingOn, MAX_STRING_LENGTH );
        Write( szLoggingOn, NULL );
        return FALSE;
    }

    if( !_tcsicmp( pOption, ( LPTSTR )TEXT("LOGGING") ) )
    {        
        if( StartLogging() )
        {
            LoadString( ghInstance, IDS_LOGGING_ON, szLoggingOn, MAX_STRING_LENGTH );            
        }
        else
        {
            LoadString( ghInstance, IDS_NO_LOGFILE, szLoggingOn, MAX_STRING_LENGTH );
        }

        Write( szLoggingOn, NULL );
        return FALSE;
    }
   
    if( ( !_tcsnicmp( pOption, ( LPTSTR )TEXT("ESCAPE"), wcslen( ( LPTSTR )TEXT("ESCAPE") ) ) )
                    && ( iswspace( *( pOption + wcslen( ( LPTSTR )TEXT("ESCAPE") ) ) ) ||
                     *( pOption + wcslen( ( LPTSTR )TEXT("ESCAPE") ) ) == L'\0'  ) ) 
    {

        TCHAR* pTerm = NULL;

        pOption += wcslen( ( LPTSTR )TEXT("ESCAPE") );
        pTerm = _tcstok( pOption, ( LPTSTR )_T(" \t") );

        if( pTerm )
        {
            SqueezeWhiteSpace( pTerm );
            if( pTerm[ 0 ] != L'\0'  )
            {
                SetEscapeChar( pTerm[ 0 ] );
            }
        }
        g_bIsEscapeCharValid = TRUE;
        Write( g_szKbdEscape, NULL );
        return FALSE;
    }

    if( !_tcsnicmp( pOption, ( LPTSTR )TEXT("TERM"), 
                    wcslen( ( LPTSTR )TEXT("TERM") ) ) 
                    && iswspace( *( pOption + wcslen( ( LPTSTR )TEXT("TERM") ) ) ) )
    {
        TCHAR* pTerm = NULL;

        pOption += wcslen( ( LPTSTR )TEXT("TERM") );
        pTerm = _tcstok( pOption, ( LPTSTR )_T(" \t") );

        if( pTerm )
        {
            int iTermType;
            SqueezeWhiteSpace( pTerm );

            if( (iTermType = GetRequestedTermType( pTerm )) < 0 )
            {
                Write( szSupportedTerms, NULL );
                return FALSE;
            }
            else
            {
                gwi.trm.RequestedTermType = iTermType;                
            }

            Write( szPrefTermType, pTerm, NULL );

            if (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80))
            {
                ui.fDebug &= ~(fdwVT52Mode|fdwVT80Mode);
                ui.fDebug &= ~(fdwKanjiModeMask);
                ClearVT80(&gwi.trm);
                ClearKanjiStatus(&gwi.trm, CLEAR_ALL);
                ClearKanjiFlag(&gwi.trm);
                SetupCharSet(&gwi.trm);
            }
        }
        return FALSE;
    }
    if((GetACP() == JAP_CODEPAGE ) && (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80)) &&     
        !_tcsnicmp( pOption, ( LPTSTR )TEXT("CODESET"), wcslen( ( LPTSTR )TEXT("CODESET") ) ) 
                    && iswspace( *( pOption + wcslen( ( LPTSTR )TEXT("CODESET") ) ) ) )
    {
        TCHAR* pCodeset = NULL;

        pOption += wcslen( ( LPTSTR )TEXT("CODESET") );
        RemoveLeadingNTrailingWhiteSpaces( &pOption );
        pCodeset = pOption;

        if( pCodeset )
         {           
            int i;
            for(i=0 ; i<NUMBER_OF_KANJI ; ++i)
            {
                if(!_tcsicmp(KanjiList[i].KanjiDescription, pCodeset)) {
                    SetVT80(&gwi.trm);
                    ui.fDebug &= ~fdwKanjiModeMask;
                    ClearKanjiFlag(&gwi.trm);
                    ui.fDebug |= KanjiList[i].KanjiID;
                    ui.fDebug |= fdwVT80Mode;
                    SetKanjiMode(&gwi.trm,KanjiList[i].KanjiEmulationID);
                    SetupCharSet(&gwi.trm); 
                    Write( szVT100KanjiEmulation, NULL );
                    Write( KanjiList[i].KanjiDescription, NULL );    
                    Write( ( LPTSTR ) _T( "\r\n" ), NULL );
                    return FALSE;
                }
            } 

            if( i >= NUMBER_OF_KANJI )
            {
                WriteMessage(IDS_SET_CODESET_FORMAT, (LPTSTR) TEXT ( MSG_SET_CODESET_FORMAT) );
            }
        }
        return FALSE;
    }

    Write( szSetFormat, NULL );
    return FALSE;
}


BOOL UnsetOptions( LPTSTR pOption )
{
    if ( pOption == NULL )
    {
        Write( szUnsetFormat, NULL );
        return FALSE;
    }

    RemoveLeadingNTrailingWhiteSpaces( &pOption );

    if ( *pOption == _T('?') )
    {
        Write( szUnsetHelp, NULL );
        return FALSE;
    }
    if( !_tcsicmp( pOption, ( LPTSTR )TEXT("BSASDEL") ) )
    {
        g_bSendBackSpaceAsDel = FALSE;
        WriteMessage( IDS_BACKSPACEASBACKSPACE, ( LPTSTR )TEXT( MSG_BACKSPACEASBACKSPACE ) );
        return FALSE;
    }
    if( !_tcsicmp( pOption, ( LPTSTR )TEXT("CRLF") ) )
    {
        ClearLineMode( &( gwi.trm ) );
        ui.dwCrLf= FALSE;
        WriteMessage( IDS_CR, ( LPTSTR )TEXT( MSG_CR ) );
        return FALSE;
    }
    if( !_tcsicmp( pOption, ( LPTSTR )TEXT("DELASBS") ) )
    {
        g_bSendDelAsBackSpace = FALSE;
        WriteMessage( IDS_DELASDEL, ( LPTSTR )TEXT( MSG_DELASDEL ) );
        return FALSE;
    }
    if ( !_tcsicmp( pOption, ( LPTSTR )TEXT("NTLM") ) )
    {
        ui.bWillAUTH = 0;
        Write( szWontAuth, NULL );
        return FALSE;
    }
    if ( !_tcsicmp( pOption, ( LPTSTR )TEXT("LOCALECHO") ) )
    {
        ui.fDebug &= ~fdwLocalEcho;
        Write( szLocalEchoOff, NULL );
        return FALSE;
    }

    if( !_tcsicmp( pOption, ( LPTSTR )TEXT("LOGGING") ) )
    {
        TCHAR szLoggingOff[ MAX_STRING_LENGTH ];
        LoadString( ghInstance, IDS_LOGGING_OFF, szLoggingOff, MAX_STRING_LENGTH );
        Write( szLoggingOff, NULL );
        StopLogging();
        return FALSE;
    }

    if ( !_tcsicmp( pOption, ( LPTSTR )TEXT("ESCAPE") ) )
    {
        TCHAR szMsg[ MAX_STRING_LENGTH ];

        g_bIsEscapeCharValid = FALSE;
        LoadString( ghInstance, IDS_NO_ESCAPE , szMsg, MAX_STRING_LENGTH );
        Write( szMsg, NULL );
        return FALSE;
    }
    if ((GetACP() == JAP_CODEPAGE ) && (FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80)) && !_tcsicmp( pOption, ( LPTSTR )TEXT("CODESET") ) )        
    {
        TCHAR szNoEmulation[ MAX_STRING_LENGTH ];
        ui.fDebug &= ~(fdwVT52Mode|fdwVT80Mode);
        ui.fDebug &= ~(fdwKanjiModeMask);
        ClearVT80(&gwi.trm);
        ClearKanjiStatus(&gwi.trm, CLEAR_ALL);
        ClearKanjiFlag(&gwi.trm);
        SetupCharSet(&gwi.trm);  
        LoadString( ghInstance, IDS_NO_EMULATION, szNoEmulation, MAX_STRING_LENGTH );
        Write( szNoEmulation, NULL );
        return FALSE;
    }
    Write( szUnsetFormat, NULL );
    return FALSE;
}

/*#if defined(FE_IME)
BOOL EnableIMEOptions( LPTSTR pOption )
{
    do {
        if ( pOption == NULL )
        {
            Write( szEnableIMEFormat, NULL );
            break;
        }

        if ( *pOption == _T('?') )
        {
            Write( szEnableIMEHelp, NULL );
            break;
        }

        if ( !_tcsicmp( pOption, TEXT("IME") ) )
        {
            ui.fDebug |= fdwEnableIMESupport;
            break;
        }
        else
        {
            Write( szEnableIMEFormat, NULL );
            break;
        }
    } while ( FALSE );

    return FALSE;
}

BOOL DisableIMEOptions( LPTSTR pOption )
{
    do {
        if ( pOption == NULL )
        {
            Write( szDisableIMEFormat, NULL );
            break;
        }

        if ( *pOption == _T('?') )
        {
            Write( szDisableIMEHelp, NULL );
            break;
        }

        if ( !_tcsicmp( pOption, TEXT("IME") ) )
        {
            ui.fDebug &= ~(fdwEnableIMESupport);
            break;
        }
        else
        {
            Write( szDisableIMEFormat, NULL );
            break;
        }
    } while ( FALSE );

    return FALSE;
}
**/
//#endif /* FE_IME */


//
// (a-roopb) Added below routine to fix to bug 1007
//
LPTSTR SkipLeadingWhiteSpaces( LPTSTR szCommand )
{
    int i=0;

    while( szCommand[i] && _istspace( szCommand[i] ) )
    {
        ++i;
    }
    
    return szCommand+i;
}

extern DWORD HandleTelnetSession( WI* pwi );

void ClearInitialScreen( HANDLE hConsole )
{
    DWORD dwNumWritten;
    COORD dwWriteCoord;
    dwWriteCoord.X = 0; dwWriteCoord.Y = 0;

    FillConsoleOutputCharacter( hConsole,
     ' ', ( gwi.sbi.dwSize.X ) * ( gwi.sbi.dwSize.Y ),
     dwWriteCoord, &dwNumWritten );
    FillConsoleOutputAttribute( hConsole, gwi.sbi.wAttributes,
     ( gwi.sbi.dwSize.X ) * ( gwi.sbi.dwSize.Y ), dwWriteCoord,
     &dwNumWritten );
}


//This sets a global variable with the port number
void GetPortNumber( )
{
    CHAR szPortString[ cchMaxHostName ];
    struct servent *serv;

    rgService = TELNET_PORT ;

    if( IsCharAlpha( g_szPortNameOrNo[0] ) ) 
    {
        _snprintf( szPortString,cchMaxHostName-1, "%lS", g_szPortNameOrNo );
        if((serv = getservbyname( szPortString, "tcp")) != NULL) 
        {
            rgService = htons( (SHORT)serv->s_port );
        }
        else
        {
        	rgService = 0;
        }
    } 
    else if( IsCharAlphaNumeric( g_szPortNameOrNo[0] ) )
    {
        rgService = _ttoi( g_szPortNameOrNo );
    }
    return;
}

void PrepareForNAWS( )
{
   // Now we need to set the correct sizes.
   // ui.dwMaxRow     = gwi.sbi.dwMaximumWindowSize.Y;
   //ui.dwMaxCol     = gwi.sbi.dwMaximumWindowSize.X;
   //This change is meant for making the client provide scrolling
    ui.dwMaxRow     = gwi.sbi.dwSize.Y;
    ui.dwMaxCol     = gwi.sbi.dwSize.X;
}


BOOL OpenTelnetSession( LPTSTR pszCommand )
{
    DWORD dwWritten;
    DWORD dwRead;
    LPTSTR pszPort;
    LPTSTR pszHost;
    CHAR szHstNam[MAX_PATH + 1] = { 0 };
    WCHAR szTitleName[MAX_PATH + 2 + MAX_PATH ]; 
    TCHAR szCommand[255] = { 0 };
    DWORD dwMode = ( DWORD )-1;
    COORD coOrgin = { 0, 0 };

	gwi.eState=Connecting;
    if( pszCommand == NULL )
    {
        WriteConsole( gwi.hOutput, szOpenTo, _tcslen(szOpenTo), &dwWritten, 
            NULL );
        if( ReadConsole( gwi.hInput, szCommand, 
            ( sizeof( szCommand ) /sizeof( TCHAR) )- sizeof( TCHAR ) , &dwRead, NULL ) )
        {
            // no input ??
            if( dwRead == 2 ) 
            {
                WriteConsole( gwi.hOutput, szOpenUsage, _tcslen(szOpenUsage), 
                    &dwWritten, NULL );
                return FALSE;
            }
        }
        else
        {
            //error ; do something ?
            return FALSE;
        }

        // Null Terminate the string and remove the newline characters.
        szCommand[ dwRead - 1 ] = 0;
        szCommand[ dwRead - 2 ] = 0;

        //
        // (a-roopb) Added below 5 lines to fix to bug 1007
        //
        pszCommand = SkipLeadingWhiteSpaces( szCommand );
        if( !_tcslen(pszCommand) )
        {
            WriteConsole( gwi.hOutput, szOpenUsage, _tcslen(szOpenUsage), &dwWritten, NULL );
            return FALSE;
        }
    }

    if ( fConnected )
    {
        CloseTelnetSession( NULL );
    }

    pszHost = _tcstok( pszCommand, ( LPTSTR )TEXT(" ") );
    pszPort = _tcstok( NULL, ( LPTSTR )TEXT("") );
    
    g_szPortNameOrNo[ 0 ] = 0;
    if( pszPort != NULL )
    {
        _tcsncpy( g_szPortNameOrNo, pszPort , cchMaxHostName - 1);
    }
    GetPortNumber();
    if(pszHost!=NULL)
    {
    	_tcsncpy( rgchHostName, pszHost, min( _tcslen(pszHost)+1, cchMaxHostName - 1 ) );
    }
    else
    {
    	return FALSE;
    }
    rgchHostName[cchMaxHostName - 1]= _T('\0');

    // need to get the current window size before creating the session.
    // This is needed both for NAWS negotiation and also for creating a matching
    // session buffer.
    GetConsoleScreenBufferInfo( g_hTelnetPromptConsoleBuffer, &gwi.sbi );
    SetWindowSize( g_hSessionConsoleBuffer );

    if( FGetCodeMode( eCodeModeIMEFarEast ) )
    {
        if( ( gwi.sbi.srWindow.Bottom - gwi.sbi.srWindow.Top + 1 )
                == gwi.sbi.dwMaximumWindowSize.Y )
        {
            gwi.sbi.dwSize.Y -= 1;
            gwi.sbi.srWindow.Bottom -= 1;
            bMaxWindow = 1;
        }
    }

   PrepareForNAWS();

    if( ui.bLogging )
    {
        if( !InitLoggingDataStructs() )
        {
            return FALSE;
        }
    }

    //
    // (a-roopb) Hack to fix bug 1092. Users may set the terminal emulation type
    // before session start and DoTermReset sets the emulation types etc. to 
    // defaults. So we reset the emulation type after call to DoTermReset.
    //
    if ((FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80)) && ui.fDebug & fdwKanjiModeMask)
    {
        dwMode = ui.fDebug & fdwKanjiModeMask;
    }
    else
    {
        dwMode = ( DWORD )-1;
    }

    
    DoTermReset(&gwi, &gwi.trm);

    //
    // (a-roopb) Hack to fix bug 1092. Users may set the terminal emulation type
    // before session start and DoTermReset sets the emulation types etc. to 
    // default. So we reset the emulation type again here to user chosen one.
    //
    if((FGetCodeMode(eCodeModeFarEast) && FGetCodeMode(eCodeModeVT80)) && 
    	!(dwMode & 0x80000000) )
    {
        int i;

        for( i=0 ; i<NUMBER_OF_KANJI ; ++i )
        {
            if( dwMode == KanjiList[i].KanjiID ) 
            {
                SetVT80(&gwi.trm);
                ui.fDebug &= ~fdwKanjiModeMask;
                ClearKanjiFlag(&gwi.trm);
                ui.fDebug |= KanjiList[i].KanjiID;
                SetKanjiMode(&gwi.trm,KanjiList[i].KanjiEmulationID);
                SetupCharSet(&gwi.trm);
                break;
            }
        }
    }

    if( fPrintMessageToSessionConsole )
    {
        gwi.hOutput = g_hSessionConsoleBuffer;
    }
    
    WriteConsole( gwi.hOutput, szConnecting, _tcslen(szConnecting), &dwWritten, NULL);
    WriteConsole( gwi.hOutput, pszHost, _tcslen(pszHost), &dwWritten, NULL);
    WriteConsole( gwi.hOutput, ( LPTSTR )TEXT("..."), _tcslen( ( LPTSTR )TEXT("...")), &dwWritten, NULL);

    WideCharToMultiByte( GetACP(), 0, pszHost, -1, szHstNam, MAX_PATH, NULL, NULL );

    wcsncpy( szTitleName, szAppName, MAX_PATH );
    szTitleName[ MAX_PATH + 1 ] = L'\0';
    wcscat( szTitleName, ( LPTSTR )L" " ); // no overflow
    wcsncat( szTitleName, pszHost, MAX_PATH );
    szTitleName[ MAX_PATH + 1 + MAX_PATH ] = L'\0';
    SetConsoleTitle( szTitleName );

    fConnected = FConnectToServer(&gwi, szHstNam, &(gwi.nd));

    if( fPrintMessageToSessionConsole )
    {
        fPrintMessageToSessionConsole = FALSE;
        gwi.hOutput = g_hTelnetPromptConsoleBuffer;
    }

    if( fConnected == TRUE )
    {
        COORD dwSizeIME = gwi.sbi.dwSize;
        SMALL_RECT rectIME;

        if( FGetCodeMode(eCodeModeIMEFarEast) )
        {
           dwSizeIME.X = gwi.sbi.dwSize.X;
           dwSizeIME.Y = gwi.sbi.dwSize.Y += 1;
        }

        if( FGetCodeMode(eCodeModeIMEFarEast) )
        {
            if( !SetConsoleScreenBufferSize( g_hSessionConsoleBuffer,
                        dwSizeIME ) )
            {
                fConnected = FHangupConnection(&gwi, &(gwi.nd));
                return FALSE;
            }
        }

        ClearInitialScreen(g_hSessionConsoleBuffer);

        memcpy( &rectIME, &gwi.sbi.srWindow, sizeof(SMALL_RECT) ); // no overflow
        if( FGetCodeMode(eCodeModeIMEFarEast) )
        {
            rectIME.Bottom += 1;

            //
            // Since we are increasing the size, we need to first resize the console window
            // and then the buffer otherwise it won't work
            //
            bWindowSizeChanged = 
                    SetConsoleWindowInfo( g_hSessionConsoleBuffer, TRUE, &rectIME );
            bBufferSizeChanged = 
                    SetConsoleScreenBufferSize( g_hSessionConsoleBuffer, dwSizeIME );
            if( bMaxWindow )
            {
                bWindowSizeChanged = bBufferSizeChanged = 0;
            }
        }

        SetConsoleCursorPosition( g_hSessionConsoleBuffer, coOrgin );
        srOldClientWindow = rectIME;

        gwi.nd.fRespondedToWillEcho = FALSE;
        gwi.nd.fRespondedToWillSGA  = FALSE;
        gwi.nd.fRespondedToDoAUTH = FALSE;
        gwi.nd.fRespondedToDoNAWS = FALSE;

        gwi.trm.dwCurChar = 0;
        gwi.trm.dwCurLine = 0;
        HandleTelnetSession(&gwi);        
        Write( ( LPTSTR )TEXT("\r\n"), NULL );
    }

    return FALSE;
}

BOOL CopyNPastePromptScreen( )
{
    PCHAR_INFO pcInfo = NULL;
    CONSOLE_SCREEN_BUFFER_INFO  csbInfoOfPrompt; 
    COORD coSize        = { 0, 0 };
    COORD coBufferStart = { 0, 0 };
    SMALL_RECT srRead   = { 0, 0, 0, 0 };
    SHORT wScreenSize   = 0;

    if( GetConsoleScreenBufferInfo( g_hTelnetPromptConsoleBuffer, &csbInfoOfPrompt ) )
    {
        wScreenSize   = ( SHORT )( csbInfoOfPrompt.srWindow.Bottom - 
                        csbInfoOfPrompt.srWindow.Top + 1 );

        srRead.Right  = ( SHORT )( csbInfoOfPrompt.dwSize.X - 1 );
        coSize.X      = csbInfoOfPrompt.dwSize.X;
        coSize.Y      = srRead.Bottom = wScreenSize;

        pcInfo = ( PCHAR_INFO ) malloc( sizeof( CHAR_INFO ) * 
            ( csbInfoOfPrompt.dwSize.X ) * ( wScreenSize ) );

        if( pcInfo )
        {
            while( srRead.Top <= csbInfoOfPrompt.dwSize.Y - 1 )
            {
                if( ReadConsoleOutput( g_hTelnetPromptConsoleBuffer, pcInfo,
                    coSize, coBufferStart, &srRead ) )
                {
                    WriteConsoleOutput( g_hSessionConsoleBuffer, pcInfo, coSize, coBufferStart, &srRead  );

                    srRead.Top    = ( SHORT ) ( srRead.Top + wScreenSize );
                    srRead.Bottom = ( SHORT ) ( srRead.Bottom + wScreenSize );
                    if( srRead.Bottom > csbInfoOfPrompt.dwSize.Y - 1 )
                    {
                        srRead.Bottom = ( SHORT ) ( csbInfoOfPrompt.dwSize.Y - 1 );
                    }
                }
                else
                {                    
                    break;
                }                
            }

            free( pcInfo );

            SetConsoleWindowInfo( g_hSessionConsoleBuffer, TRUE, 
                                  &csbInfoOfPrompt.srWindow );
            SetConsoleCursorPosition( g_hSessionConsoleBuffer, 
                                      csbInfoOfPrompt.dwCursorPosition );        

            return( TRUE );

        }
        
    }
    return( FALSE );
}


BOOL QuitTelnet(LPTSTR szCommand)
{
    // Exit gracefully.

    if( ui.bLogging )
    {
        //Close file handles if any
        CloseLogging();
    }

    CopyNPastePromptScreen( );

    CloseTelnetSession(NULL);

    PostMessage(gwi.hwnd, WM_QUIT, 0, 0L);

    return TRUE;
}

BOOL PrintStatus( LPTSTR szCommand )
{
    TCHAR szHstNam[512];
    TCHAR szTermType[81];

    if ( fConnected )
    {
        _snwprintf( szHstNam,511, ( LPTSTR )TEXT("%S"), gwi.nd.szHostName );
        Write( szConnectedTo, szHstNam, NULL );

        if( gwi.trm.SentTermType != TT_UNKNOWN ) 
        {            
            _snwprintf(szTermType,80, ( LPTSTR )TEXT("%S"), rgchTermType[gwi.trm.SentTermType]);
            Write( szNegoTermType, szTermType, NULL );
        }
    }
    else
    {
        Write( szNotConnected, NULL );
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\admin\tnadmutl.cpp ===
//-------------------------------------------------------------------
//   Copyright (c) 1999-2000 Microsoft Corporation
//
//   tnadminutils.cpp
//
//    Vikram/Manoj Jain/Srivatsan K/Harendra
//
//    Functions to do administration of telnet daemon.
//         (May-2000)
//-------------------------------------------------------------------
#include "telnet.h"
#include "common.h"
#include "resource.h" //resource.h should be before any other .h file that has resource ids.
#include "admutils.h"
#include <stdio.h>
#include <conio.h>
#include <tchar.h>
#include <shlwapi.h>
#include <wbemidl.h>
#include <wchar.h>
#include <windns.h>
#include <winnlsp.h>
#include "tnadminy.h"
    //this file has utility functions to set authentication...

#include "tlntsvr.h"

#define L_TELNETSERVER_TEXT     "tlntsvr"
#define MAX_VALUE_MAXCONN       2147483647

//Global variables

wchar_t* g_arCLASSname[ _MAX_CLASS_NAMES_ ];
        //array to store the different class object paths
HKEY g_arCLASShkey[_MAX_CLASS_NAMES_];
HKEY g_hkeyHKLM=NULL;
int  g_arNUM_PROPNAME[_MAX_PROPS_];
WCHAR     g_szMsg[MAX_BUFFER_SIZE] = {0} ;
HMODULE     g_hResource;
HANDLE      g_stdout;
extern HMODULE     g_hXPResource;

BOOL g_fWhistler = FALSE;

// Don't even think about changing the two strings -- BaskarK, they NEED to be in sync with tlntsvr\enclisvr.cpp
// the separators used to identify various portions of a session as well as session begin/end

WCHAR   *session_separator = L",";
WCHAR   *session_data_separator = L"\\";

extern BSTR bstrLogin;
extern BSTR bstrPasswd;
extern BSTR bstrNameSpc;

extern SERVICE_STATUS g_hServiceStatus;

//wchar_t *g_szCName=NULL; (See the comment in the PrintSettings() function
//all three files extern
#ifdef __cplusplus
extern "C" {
#endif

extern long int g_nConfigOptions;
extern int g_nError; //Error indicator, initialsed to no error.:-)
extern wchar_t* g_arVALOF[_MAX_PROPS_];

extern int g_nPrimaryOption;
        //option indicator.
extern int g_nTimeoutFlag;  //o means in hh:mm:ss 1 means ss format.
extern int g_nSesid;

extern BSTR g_bstrMessage;
extern ConfigProperty g_arPROP[_MAX_PROPS_][_MAX_NUMOF_PROPNAMES_];

extern int g_nAuditOff;
extern int g_nAuditOn;
extern int g_nSecOff;
extern int g_nSecOn;

#ifdef __cplusplus
}
#endif
        
IManageTelnetSessions* g_pIManageTelnetSessions = NULL;
// Pointer to the Session Manager Interface;-)
int g_nNumofSessions=0;
wchar_t** g_ppwzSessionInfo=NULL;

//will be allocated in ListUsers.An array of session infosize=g_nNumofSessions.

// The following function is a replica of SafeCoInitialize() from Commfunc library
// Please check with the header of function there.
// Why a local copy? We are not checking in the comm func library sources
// for Whistler - hence we can not link to that library for telnet.

HRESULT Telnet_SafeCoInitializeEx()
{
	HRESULT hCoIni = S_OK;

    // Initialize the COM library on this thread.
    hCoIni = CoInitializeEx( NULL, COINIT_MULTITHREADED );
   
    if(S_OK!=hCoIni)
    {
        if (S_FALSE == hCoIni)
        {
            // The COM library is already initialized on this thread
            // This is not an error as we already have what
            // we are asking for.
            // But this code should never get executed - Safe programming
        }
        else
            return hCoIni;
    }

    return S_OK;
}


// The following two functions are copied from commfunc.cpp. Any change made in
// these functions in commfunc.cpp should be copied here.
// This function calls LoadLibrary() after framing the complete path of the dll.
// Arguments:
//      wzEnvVar    [IN]    : Environment Variable which needs to be expanded.
//      wzSubDir    [IN]    : Sub directory under which the dll is located. This will
//                           concatenated to the expanded env var. This field can
//                           be null. You should not specify "\" here.
//      wzDllName [IN] : Name of the DLL to be loaded in widechars
//      pdwRetVal [OUT]: Pointer to a DWord to hold the return value.
//
// Return Value:
//      On success returns handle to the library.
//      On failure returns NULL;
// Notes: Please check the pdwRetVal parameter incase this function returns NULL
//
// Possible values for dwRetVal:
//
//      =============================================================
//      |   ERROR_SUCCESS                   Successful loading of library.               |
//      |   ERROR_INSUFFICIENT_BUFFER        If the buffer is not sufficient to hold the     |
//      |                                       dll name.                              |
//      |   ERROR_ENVVAR_NOT_FOUND          If the environment variable is not found.    |
//      |   ERROR_INVALID_DATA               If the environment variable is absent.       |
//      |   GetLastError()                       If LoadLibrary() fails.                     |
//      =============================================================
//

HMODULE TnSafeLoadLibraryViaEnvVarW(WCHAR *wzEnvVar, WCHAR* wzSubDir, WCHAR *wzDllName, DWORD* pdwRetVal)
{
    HMODULE hLibrary = NULL;
    WCHAR wzDllPath[3*MAX_PATH+1] = {0};
    DWORD dwNoOfCharsUsed = 0;

    // Validate the input.

    if (NULL == pdwRetVal)
        goto Abort;
    
    if( (NULL == wzEnvVar) || (0==wcscmp(wzEnvVar,L"")) || (NULL == wzDllName) || (0==wcscmp(wzDllName,L"")))
    {
            *pdwRetVal=ERROR_INVALID_DATA;
            goto Abort;
    }

    *pdwRetVal = ERROR_SUCCESS;

    dwNoOfCharsUsed=GetEnvironmentVariableW(wzEnvVar, wzDllPath, ARRAYSIZE(wzDllPath)-1);
    if(0!=dwNoOfCharsUsed)
    {
        // Add the last '\' if absent
        if(wzDllPath[dwNoOfCharsUsed-1]!=L'\\')
        {
            wzDllPath[dwNoOfCharsUsed]=L'\\';
            dwNoOfCharsUsed++;
            // Check for buffer overflow.
            if(dwNoOfCharsUsed > ARRAYSIZE(wzDllPath)-1)
            {
                *pdwRetVal = ERROR_INSUFFICIENT_BUFFER;
                goto Abort;
            }
        }
        // If SubDir is present, frame the path as %EnvVar%SubDir\DllName
        // else %EnvVar%DllName
        if(NULL!=wzSubDir)
        {
            if(_snwprintf(wzDllPath+dwNoOfCharsUsed,
                ARRAYSIZE(wzDllPath)-dwNoOfCharsUsed-1,
                L"%s\\%s",
                wzSubDir,
                wzDllName) < 0)
            {
                // _snwprintf failed
                *pdwRetVal = ERROR_INSUFFICIENT_BUFFER;
                goto Abort;
            }
        }
        else
        {
            wcsncpy(wzDllPath+dwNoOfCharsUsed, wzDllName, ARRAYSIZE(wzDllPath)-dwNoOfCharsUsed-1);
        }
        // ensuring null termination
        wzDllPath[ARRAYSIZE(wzDllPath)-1]=L'\0';
    }
    else
    {
        // The system could not find the environment variable.
        *pdwRetVal = ERROR_ENVVAR_NOT_FOUND;
        goto Abort;
    }

    // Load the library
    hLibrary = LoadLibraryExW(wzDllPath,NULL,LOAD_LIBRARY_AS_DATAFILE);
    if(NULL == hLibrary)
        *pdwRetVal = GetLastError();
    
Abort:
    return hLibrary;
}

// This function calls ZeroMemory() and makes sure that this call is not optimized
// out by the compiler.
// Arguments:
//      Destination   [IN]    : Pointer to the starting address of the block of memory 
//							 to fill with zeros
//      cbLength     [IN]    : Size, in bytes, of the block of memory to fill with zeros.
// Return Value:
//     	void function.
// Author: srivatsk

void TnSfuZeroMemory(PVOID Destination, SIZE_T cbLength)
{
	ZeroMemory(Destination, cbLength);
	*(volatile char*)Destination; // this is dummy statement to prevent optimization
	// Why *(volatile char*)Destination? To make sure that the compiler doesn't optimize
	// away the ZeroMemory() call thinking that we are not going
	// to access this memory anymore :)
	return;
}

// The following two functions are copied from allutils.cpp. Any change made in
// these functions in allutils.cpp should be copied here.
// This function loads the resource dll "Cladmin.dll" from %SFUDIR%\common
// and stores the handle in global variable g_hResource.
// Add code here to take care of loading resources for non-english locales.
// This function has been changed to load XPSP1RES.DLL in case it is present.
// This is only tlntadmn.exe specific change and should not be copied back to 
// allutils.cpp. If present, XPSP1RES.DLL will be present in %SystemRoot%\System32
DWORD TnLoadResourceDll()
{
    //Load the Strings library "cladmin.dll".
    // if not found, it should get the English resources from the exe.
    DWORD dwRetVal = ERROR_SUCCESS;
    OSVERSIONINFOEX osvi = { 0 };
    g_hXPResource = NULL;
    // No need to check for the dwRetVal field of SafeLoadSystemLibrary; As incase of
    // failure, we will default to English resources from the exe.
    // We need to add check here while taking care of non-english locales.
    if (NULL == g_hResource)
    {
        g_hResource = GetModuleHandle(NULL);
    }
    
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);
    if ( !GetVersionEx((OSVERSIONINFO *) &osvi ) )
    {
        //OSVERSIONINFOEX is supported from NT4 SP6 on. So GetVerEx() should succeed.
        goto Done;
    }
    //Load XPSPxRes.dll only if OS is XP and Service pack is x where 'x' is service pack number
    //e.g. 1 in case of XPSP1
    if(osvi.dwPlatformId == VER_PLATFORM_WIN32_NT && osvi.wProductType == VER_NT_WORKSTATION && osvi.wServicePackMajor > 0)
    {
        //OS is Windows XP.
        g_hXPResource = LoadLibraryExW(L"xpsp1res.dll",NULL,LOAD_LIBRARY_AS_DATAFILE);
    }
    //no need to see if the the LoadLibrary failed. It will succeed only on XPSP1 in which case,
    //some resources may need to be loaded from the dll.
Done:    
    return ERROR_SUCCESS;
}


// This function is used to clear the passwd and should be called once you no 
// longer require the passwd field. This function also frees the memory and makes 
// it null so that nobody else call make use of it in the future.
// Zeroing the memory is done by calling SfuZeroMemory() which makes sure 
// that ZeroMemory() call is not optimized away by the compiler. 

void TnClearPasswd()
{
        if(g_arVALOF[_p_PASSWD_])
        {
            TnSfuZeroMemory(g_arVALOF[_p_PASSWD_], wcslen(g_arVALOF[_p_PASSWD_])*sizeof(WCHAR));
            free(g_arVALOF[_p_PASSWD_]);
            g_arVALOF[_p_PASSWD_]=NULL;
        }
}


/* -- 
    int Initialize(void) function initialises the class-object-paths,
    and also property class dependency.
    Then gets a handle to WbemLocator,
    Connects to the server and gets a handle to WbemServices
    with proper authentication.

    Note that: if the passed in namespace is null then, it defaults to
    "root\\sfuadmin"
--*/

int Initialize(void)
{

    int i;
    for(i=0;i<_MAX_CLASS_NAMES_;i++)
    {    
        g_arCLASShkey[i]=NULL;
        g_arCLASSname[i]=NULL;
    }
    int j;

    for(i=0;i<_MAX_PROPS_;i++)
    {    for(j=0;j<_MAX_NUMOF_PROPNAMES_;j++)
        {
            g_arPROP[i][j].fDontput=0;
            g_arPROP[i][j].propname=NULL;
        }
        g_arVALOF[i]=NULL;
        g_arNUM_PROPNAME[i]=0;
    }

    //Load the Strings library "cladmin.dll".
    // if not found, it should get the English resources from the exe.
    
    DWORD dwRetVal = TnLoadResourceDll();
    if(ERROR_SUCCESS!=dwRetVal)
    {
        return dwRetVal;
    }

    HRESULT hCoIni = Telnet_SafeCoInitializeEx();

    if (S_OK!=hCoIni)
        // Oops! This function can not return hResult :( and so returning -1 to indicate
        // error. but unfortunately none of the callers are using the return value of this
        // function.
        return -1;
    g_stdout = GetStdHandle(STD_OUTPUT_HANDLE);
    // Set the flag so that we call CoUnint...()
    g_fCoInitSuccess = TRUE;
  
    //Default values can be set over here.
    g_nConfigOptions=0;



    //Defining the class object paths for tnadmin....
    g_arCLASSname[0]=L"SOFTWARE\\Microsoft\\TelnetServer\\1.0";
    g_arCLASSname[1]=L"SOFTWARE\\Microsoft\\TelnetServer\\1.0\\ReadConfig";
    g_arCLASSname[2]=L"SOFTWARE\\Microsoft\\Services For Unix\\AppsInstalled\\Telnet Server";

    //Assigning different properties to their respective classes...
    g_arPROP[_p_CTRLAKEYMAP_][0].classname=0;
    g_arPROP[_p_TIMEOUT_][0].classname=0;
    g_arPROP[_p_MAXCONN_][0].classname=0;
    g_arPROP[_p_PORT_][0].classname=0;
    g_arPROP[_p_MAXFAIL_][0].classname=0;
    g_arPROP[_p_KILLALL_][0].classname=0;
    g_arPROP[_p_MODE_][0].classname=0;
    g_arPROP[_p_AUDITLOCATION_][0].classname=0;
    g_arPROP[_p_SEC_][0].classname=0;
    g_arPROP[_p_DOM_][0].classname=0;
    g_arPROP[_p_AUDIT_][0].classname=0;

    g_arPROP[_p_TIMEOUTACTIVE_][0].classname=0;
    g_arPROP[_p_FNAME_][0].classname=0;
    g_arPROP[_p_FSIZE_][0].classname=0;
    g_arPROP[_p_DEFAULTS_][0].classname=1;
    g_arPROP[_p_INSTALLPATH_][0].classname=2;
    //these two come from Active X, so will take care separately..
    //CLASSOF_AR[_p_SESSID_]=;
    //CLASSOF_AR[_p_STATE_]=;


    //giving properties number of names they are actually associated with....

    g_arNUM_PROPNAME[_p_CTRLAKEYMAP_]=1;
    g_arNUM_PROPNAME[_p_TIMEOUT_]=2;
    g_arNUM_PROPNAME[_p_MAXCONN_]=1;
    g_arNUM_PROPNAME[_p_PORT_]=1;
    g_arNUM_PROPNAME[_p_MAXFAIL_]=1;
    g_arNUM_PROPNAME[_p_KILLALL_]=1;
    g_arNUM_PROPNAME[_p_MODE_]=1;
    g_arNUM_PROPNAME[_p_AUDITLOCATION_]=2;
    g_arNUM_PROPNAME[_p_SEC_]=1;
    g_arNUM_PROPNAME[_p_DOM_]=1;
    g_arNUM_PROPNAME[_p_AUDIT_]=3;
    g_arNUM_PROPNAME[_p_TIMEOUTACTIVE_]=2;
    g_arNUM_PROPNAME[_p_FNAME_]=1;
    g_arNUM_PROPNAME[_p_FSIZE_]=1;
    g_arNUM_PROPNAME[_p_DEFAULTS_]=1;
    g_arNUM_PROPNAME[_p_INSTALLPATH_]=1;//not used

    //giving properties their actual property_names as in the registry....

    g_arPROP[_p_CTRLAKEYMAP_][0].propname=L"AltKeyMapping";
    g_arPROP[_p_TIMEOUT_][0].propname=L"IdleSessionTimeout";
    g_arPROP[_p_TIMEOUT_][1].propname=L"IdleSessionTimeoutBkup";
    g_arPROP[_p_MAXCONN_][0].propname=L"MaxConnections";
    g_arPROP[_p_PORT_][0].propname=L"TelnetPort";
    g_arPROP[_p_MAXFAIL_][0].propname=L"MaxFailedLogins";
    g_arPROP[_p_KILLALL_][0].propname=L"DisconnectKillAllApps";
    g_arPROP[_p_MODE_][0].propname=L"ModeOfOperation";
    g_arPROP[_p_AUDITLOCATION_][0].propname=L"EventLoggingEnabled";
    g_arPROP[_p_AUDITLOCATION_][1].propname=L"LogToFile";           
    g_arPROP[_p_SEC_][0].propname=L"SecurityMechanism";
    g_arPROP[_p_DOM_][0].propname=L"DefaultDomain";
    g_arPROP[_p_AUDIT_][0].propname=L"LogAdminAttempts";
    g_arPROP[_p_AUDIT_][1].propname=L"LogNonAdminAttempts";
    g_arPROP[_p_AUDIT_][2].propname=L"LogFailures";
    g_arPROP[_p_TIMEOUTACTIVE_][0].propname=L"IdleSessionTimeout";
    g_arPROP[_p_TIMEOUTACTIVE_][1].propname=L"IdleSessionTimeoutBkup";
    g_arPROP[_p_FNAME_][0].propname=L"LogFile";
    g_arPROP[_p_FSIZE_][0].propname=L"LogFileSize";
    g_arPROP[_p_DEFAULTS_][0].propname=L"Defaults";
    g_arPROP[_p_INSTALLPATH_][0].propname=L"InstallPath";//not used

    //giving the properties their type.

    V_VT(&g_arPROP[_p_CTRLAKEYMAP_][0].var)=VT_I4;
    V_VT(&g_arPROP[_p_TIMEOUT_][0].var)=VT_I4;
    V_VT(&g_arPROP[_p_TIMEOUT_][1].var)=VT_I4;
    V_VT(&g_arPROP[_p_MAXCONN_][0].var)=VT_I4;
    V_VT(&g_arPROP[_p_PORT_][0].var)=VT_I4;
    V_VT(&g_arPROP[_p_MAXFAIL_][0].var)=VT_I4;
    V_VT(&g_arPROP[_p_KILLALL_][0].var)=VT_I4;
    V_VT(&g_arPROP[_p_MODE_][0].var)=VT_I4;
    V_VT(&g_arPROP[_p_AUDITLOCATION_][0].var)=VT_I4;
    V_VT(&g_arPROP[_p_AUDITLOCATION_][1].var)=VT_I4;  
    V_VT(&g_arPROP[_p_SEC_][0].var)=VT_I4;
    V_VT(&g_arPROP[_p_DOM_][0].var)=VT_BSTR;
    V_VT(&g_arPROP[_p_AUDIT_][0].var)=VT_I4;
    V_VT(&g_arPROP[_p_AUDIT_][1].var)=VT_I4;
    V_VT(&g_arPROP[_p_AUDIT_][2].var)=VT_I4;
    V_VT(&g_arPROP[_p_TIMEOUTACTIVE_][0].var)=VT_I4;
    V_VT(&g_arPROP[_p_TIMEOUTACTIVE_][1].var)=VT_I4;
    V_VT(&g_arPROP[_p_FNAME_][0].var)=VT_BSTR;
    V_VT(&g_arPROP[_p_FSIZE_][0].var)=VT_I4;
    V_VT(&g_arPROP[_p_DEFAULTS_][0].var)=VT_I4;
    V_VT(&g_arPROP[_p_INSTALLPATH_][0].var)=VT_BSTR;


    
return 0;

}

/*--
    DoTnadmindoes the actual work corresponding the command line,
    Depending   upon the option given.
--*/

HRESULT DoTnadmin(void)
{
    int nProperty,nj;
    SCODE sc;
    SCODE hRes;
    SetThreadUILanguage(0);
    if(g_nError)
        return E_FAIL;

    if(_HELP==g_nPrimaryOption)
    {
#ifdef WHISTLER_BUILD
        PrintMessageEx(g_stdout,IDR_NEW_TELNET_USAGE,TEXT("\nUsage: tlntadmn [computer name] [common_options] start | stop | pause | continue | -s | -k | -m | config config_options \n\tUse 'all' for all sessions.\n\t-s sessionid          List information about the session.\n\t-k sessionid\t Terminate a session. \n\t-m sessionid\t Send message to a session. \n\n\tconfig\t Configure telnet server parameters.\n\ncommon_options are:\n\t-u user\t Identity of the user whose credentials are to be used\n\t-p password\t Password of the user\n\nconfig_options are:\n\tdom = domain\t Set the default domain for user names\n\tctrlakeymap = yes|no\t Set the mapping of the ALT key\n\ttimeout = hh:mm:ss\t Set the Idle Session Timeout\n\ttimeoutactive = yes|no Enable idle session timeout.\n\tmaxfail = attempts\t Set the maximum number of login failure attempts\n\tbefore disconnecting.\n\tmaxconn = connections\t Set the maximum number of connections.\n\tport = number\t Set the telnet port.\n\tsec = [+/-]NTLM [+/-]passwd\n\t Set the authentication mechanism\n\tmode = console|stream\t Specify the mode of operation.\n"));
#else
        PrintMessageEx(g_stdout,IDR_NEW_TELNET_USAGE,TEXT("\nUsage: tnadmin [computer name] [common_options] start | stop | pause | continue | -s | -k | -m | config config_options \n\tUse 'all' for all sessions.\n\t-s sessionid          List information about the session.\n\t-k sessionid\t Terminate a session. \n\t-m sessionid\t Send message to a session. \n\n\tconfig\t Configure telnet server parameters.\n\ncommon_options are:\n\t-u user\t Identity of the user whose credentials are to be used\n\t-p password\t Password of the user\n\nconfig_options are:\n\tdom = domain\t Set the default domain for user names\n\tctrlakeymap = yes|no\t Set the mapping of the ALT key\n\ttimeout = hh:mm:ss\t Set the Idle Session Timeout\n\ttimeoutactive = yes|no Enable idle session timeout.\n\tmaxfail = attempts\t Set the maximum number of login failure attempts\n\tbefore disconnecting.\n\tmaxconn = connections\t Set the maximum number of connections.\n\tport = number\t Set the telnet port.\n\tsec = [+/-]NTLM [+/-]passwd\n\t Set the authentication mechanism\n\tmode = console|stream\t Specify the mode of operation.\n"));
#endif
        hRes = S_OK;
        return hRes;           
    }
    
    //remote execution
    
    if(NULL!=g_arVALOF[_p_CNAME_]&&(0==_wcsicmp(g_arVALOF[_p_CNAME_],L"localhost")||0==_wcsicmp(g_arVALOF[_p_CNAME_],L"\\\\localhost")))
    {
        free(g_arVALOF[_p_CNAME_]);
        g_arVALOF[_p_CNAME_]=NULL;
//        g_szCName=NULL; Not used any more
    }
    
     if(FAILED(hRes=CheckForPassword())) //Get password if not specified
          return hRes;

    
//Checking if the telnet server exists

    if(FAILED(sc=(DoNetUseAdd(g_arVALOF[_p_USER_],g_arVALOF[_p_PASSWD_],g_arVALOF[_p_CNAME_]))))
                    return sc;

    // We don't have to keep the password anymore except while handling sessions
    // related options.
    if((g_nPrimaryOption!=_S)&&(g_nPrimaryOption!=_K)&&(g_nPrimaryOption!=_M))
    {
        TnClearPasswd();
    }
    
    if(FAILED(hRes=(GetConnection(g_arVALOF[_p_CNAME_]))))
                    goto End;

    if(FAILED(hRes = IsWhistlerTheOS(&g_fWhistler)))
        goto End;

    // If the telnet server is not of Whistler and SFU, then it would be from Win2K
    // We do not support remote administration for this. So need to special case ...

    if(FALSE == g_fWhistler)
    {
        if(FAILED(hRes=GetClassEx(_p_INSTALLPATH_, 0, false, MAXIMUM_ALLOWED)))
        {
            ShowError(IDR_INVALID_TELNET_SERVER_VERSION);
            hRes = E_FAIL;
            goto End;
        }
        else
        {
            if(g_arCLASShkey[g_arPROP[_p_INSTALLPATH_][0].classname] != NULL &&
               RegCloseKey(g_arCLASShkey[g_arPROP[_p_INSTALLPATH_][0].classname]) != ERROR_SUCCESS)
            {
               hRes = GetLastError();
               goto End;
            }
            g_arCLASShkey[g_arPROP[_p_INSTALLPATH_][0].classname] = NULL;
        }
    }

    if(FALSE == g_fWhistler)
        if(S_OK!=(hRes=GetSerHandle(L"tlntsvr",GENERIC_READ,SERVICE_QUERY_STATUS,FALSE))||S_OK!=(hRes=CloseHandles()))
             goto End;

    switch (g_nPrimaryOption)
    {
        case _START :
            hRes=StartSfuService(L"tlntsvr");
            break;
            
        case _STOP  :
            hRes=ControlSfuService(L"tlntsvr",SERVICE_CONTROL_STOP);
            break;
        case _PAUSE :
            hRes=ControlSfuService(L"tlntsvr",SERVICE_CONTROL_PAUSE);
            break;
        case _CONTINUE:
            hRes=ControlSfuService(L"tlntsvr",SERVICE_CONTROL_CONTINUE);
            break;

        case _S :
            ShowSession();
            break;
        case _K :
            TerminateSession();
            break;
        case _M :
            MessageSession();
            break;
        case _CONFIG:

            if(g_nConfigOptions)
            {
                g_nConfigOptions=SetBit(g_nConfigOptions,_p_DEFAULTS_);
                                                
                for(nProperty=0;nProperty<_MAX_PROPS_;nProperty++)
                {if(GetBit(g_nConfigOptions,nProperty))
                     {
                         for(nj=0;nj<g_arNUM_PROPNAME[nProperty];nj++)
                         {

                              if(FAILED(hRes=GetClass(nProperty,nj)))
                                    goto End;
                             if(FAILED(hRes=GetCorrectVariant(nProperty,nj,&g_arPROP[nProperty][nj].var)))
                                 goto End;
                         }
                     }
                }
                if(g_nError)
                    break;
                for(nProperty=0;nProperty<_MAX_PROPS_;nProperty++)
                if(GetBit(g_nConfigOptions,nProperty))
                     {
                         for(nj=0;nj<g_arNUM_PROPNAME[nProperty];nj++)
                            if(FAILED(hRes=PutProperty(nProperty,nj,&g_arPROP[nProperty][nj].var)))
                                goto End;   
                     }
                
                
                if(FAILED(hRes=PutClasses()))
                    goto End;

                PrintMessage(g_stdout,IDR_SETTINGS_UPDATED);
                break;
            }

        default  :
                          
                for(nProperty=0;nProperty<_MAX_PROPS_;nProperty++)
                {   
                    if(nProperty==_p_INSTALLPATH_)
                        continue;
                    
                     for(nj=0;nj<g_arNUM_PROPNAME[nProperty];nj++)
                     {
                         if(FAILED(hRes=GetClass(nProperty,nj)))
                             goto End;
                         if(FAILED(hRes=GetProperty(nProperty,nj,&g_arPROP[nProperty][nj].var)))
                             goto End;
                     }
                     
                }
                
             
                if(FAILED(hRes=PutClasses()))
                    goto End;
                if(FAILED(hRes=QuerySfuService(L"tlntsvr")))
                    goto End;
                
                hRes=PrintSettings();

                break;
    }

End:
    (void)DoNetUseDel(g_arVALOF[_p_CNAME_]);
    
    return hRes;
}


/*--
    The function GetCorrectVariant makes a variant out of the wchar_t * of 
    the value of each option and returns the variant
        this function is called by DoTnadmin(), to get the correct variants
    and they are put using PutProperty() function.

    This function also performs checks as to if the input is valid or not.
    such as : if the input is in valid range or not, etc.

    Note that Variant is malloced here, so has to be freed once used.
--*/

HRESULT GetCorrectVariant(int nProperty,int nPropattrib, VARIANT* pvarVal)
{
    VARIANT vVar={0};
    HRESULT hRes=ERROR_SUCCESS;
    int fValid=0;
    WCHAR sztempDomain[_MAX_PATH];

    switch (nProperty) 
    { 
        case _p_CTRLAKEYMAP_ :
        case _p_KILLALL_ :
            
                V_VT(pvarVal)=VT_I4;
                if(_wcsicmp(g_arVALOF[nProperty],L"yes")>=0)
                    V_I4(pvarVal)=1;
                else
                    V_I4(pvarVal)=0;
                break;
                
        case _p_MAXCONN_ :    
                V_VT(pvarVal)=VT_I4;
                V_I4(pvarVal)=_wtoi(g_arVALOF[nProperty]);

                // Why checking for MaxInt? We are anyway checking it for <0?
                // Answer: _wtoi() function may end up giving us a positive number
                // whose value is < MAXINT when we give a very long input.
                // Hence checking for MaxINT leaves us in the safe side.

                if(FAILED(hRes=CheckForMaxInt(g_arVALOF[nProperty],IDR_MAXCONN_VALUES)))
                    break;

                // We have decided to allow as many connections as possible on Whistler
                // too making it no different than Win2K
                /*   	if(!IsMaxConnChangeAllowed()) //Checking for Whistler and SFU not installed.
                	{ //We allow him to make it 1 or 0
                		if((V_I4(pvarVal)>2) || (V_I4(pvarVal)<0)) //less than zero for cases where the integer value is greater than 2147483647
               			{
                			ShowError(IDR_MAXCONN_VALUES_WHISTLER);
                			break;
                		}
                   	}*/
                if((V_I4(pvarVal)<0) || (V_I4(pvarVal)>MAX_VALUE_MAXCONN))  //Incase the value exceeds the maximum limit that an integer can store
                {                   //then it is converted as a negative number
                	ShowError(IDR_MAXCONN_VALUES);
                	break;
                }
                break;

        case _p_PORT_       :
                V_VT(pvarVal)=VT_I4;
                V_I4(pvarVal)=_wtoi(g_arVALOF[nProperty]) ;
                
                if(FAILED(hRes=CheckForMaxInt(g_arVALOF[nProperty],IDR_TELNETPORT_VALUES)))
                    break;
                
                if((V_I4(pvarVal)>1023)||(V_I4(pvarVal)<=0))
                    ShowError(IDR_TELNETPORT_VALUES);
                break;
                
        case _p_MAXFAIL_  : 
                V_VT(pvarVal)=VT_I4;
                V_I4(pvarVal)=_wtoi(g_arVALOF[nProperty]) ;

                if(FAILED(hRes=CheckForMaxInt(g_arVALOF[nProperty],IDR_MAXFAIL_VALUES)))
                    break;
                
                if((V_I4(pvarVal)>100)||(V_I4(pvarVal)<=0))
                    ShowError(IDR_MAXFAIL_VALUES);
                break;
        case _p_FSIZE_       :
                V_VT(pvarVal)=VT_I4;
                hRes=GetProperty(_p_FNAME_,0,&vVar);
                if(FAILED(hRes))
                    return hRes;
                // The first check in the following condition (V_BSTR(&vVar)==NULL) is added to avoid
                // deferencing of NULL pointer in _wcsicmp(). But this can NEVER be null as we check
                // for the error case in GetProperty() - added to get rid of Prefix issue
                  if(((V_BSTR(&vVar)==NULL) || (_wcsicmp(V_BSTR(&vVar),L"")==NULL)) && ((wchar_t*)V_BSTR(&g_arPROP[_p_FNAME_][0].var)==NULL))
                  {
                  	   ShowError(IDR_NOFILENAME);
                  	   break;
                  }
                V_I4(pvarVal)=_wtoi(g_arVALOF[nProperty]);

                if(FAILED(hRes=CheckForMaxInt(g_arVALOF[nProperty],IDR_FILESIZE_VALUES)))
                    break;
                
                if((V_I4(pvarVal)<0)||(V_I4(pvarVal)>4096))
                    ShowError(IDR_FILESIZE_VALUES);
                
                break;
        case _p_MODE_    :
                V_VT(pvarVal)=VT_I4;
                if(_wcsicmp(g_arVALOF[nProperty],L"stream")<0) 
                                               //Since console<stream.
                    V_I4(pvarVal)=1;
                else
                    V_I4(pvarVal)=2;
                break;
        case _p_AUDITLOCATION_    :
                V_VT(pvarVal)=VT_I4;

                if(nPropattrib==0)
                    if(_wcsicmp(g_arVALOF[nProperty],L"file")<0)
                            V_I4(pvarVal)=1;
                    else 
                            V_I4(pvarVal)=0;
                else
                        if(_wcsicmp(g_arVALOF[nProperty],L"eventlog")<0||_wcsicmp(g_arVALOF[nProperty],L"file")>=0)
                            V_I4(pvarVal)=1;
                        else 
                            V_I4(pvarVal)=0;
                break;
#if 0 // This option has been removed

        case _p_FNAME_    :
             {
                wchar_t* wzFile=(wchar_t*)malloc(3*sizeof(wchar_t));
                if(wzFile==NULL)
                    return E_OUTOFMEMORY;
                wzFile[0]=g_arVALOF[_p_FNAME_][0];

                if((wzFile[1]=g_arVALOF[_p_FNAME_][1])!=L':'||(wzFile[2]=g_arVALOF[_p_FNAME_][2])!=L'\\')
                    {ShowError(IDR_ERROR_DRIVE_NOT_SPECIFIED);free(wzFile);break;}

                //file[3]=g_arVALOF[_p_FNAME_][3];
                wzFile[3]=L'\0';

                if(DRIVE_FIXED!=GetDriveType(wzFile))
                    ShowError(IDR_ERROR_DRIVE_NOT_EXIST);
                free(wzFile);

				wchar_t* wzFileName=_wcsdup(g_arVALOF[_p_FNAME_]);
				if(FAILED(hRes=CreateFileIfNotExist(wzFileName)))
				{
                    free(wzFileName);				    
					return hRes;
				}
                free(wzFileName);
             }
#endif
        case _p_DOM_    :
             if( nProperty==_p_DOM_ )
             {
                if(wcsncmp(g_arVALOF[nProperty],SLASH_SLASH,2)==0)
                {
                    ShowError(IDR_INVALID_NTDOMAIN);
                    break;
                }
                if(FAILED(hRes=IsValidDomain(g_arVALOF[nProperty],&fValid)))
                    return hRes;
                if(fValid == 0)
                {
                    // try again with '\\' at the beginning - don't modify the original function that returns 
                    // the local machine name with '\\' appended to it
                    wcscpy(sztempDomain,SLASH_SLASH);
                    wcsncat(sztempDomain,g_arVALOF[nProperty],_MAX_PATH -sizeof(SLASH_SLASH)-sizeof(WCHAR));
                    if(FAILED(hRes=IsValidDomain(sztempDomain,&fValid)))
                        return hRes;
                }
                if(fValid==0)
                {
                    ShowError(IDR_INVALID_NTDOMAIN);
                    break;
                }
             }   
                V_VT(pvarVal)=VT_BSTR;
                V_BSTR(pvarVal)=SysAllocString(g_arVALOF[nProperty]);
                break;
        case _p_AUDIT_  :
                V_VT(pvarVal)=VT_I4;
                if(nPropattrib==0)
                    if(GetBit(g_nAuditOff,ADMIN_BIT)) 
                        V_I4(pvarVal)=0;
                    else if(GetBit(g_nAuditOn,ADMIN_BIT))
                        V_I4(pvarVal)=1;
                    else
                        g_arPROP[_p_AUDIT_][0].fDontput=1;
                else if(nPropattrib==1)
                    if(GetBit(g_nAuditOff,USER_BIT)) 
                        V_I4(pvarVal)=0;
                    else if(GetBit(g_nAuditOn,USER_BIT))
                        V_I4(pvarVal)=1;
                    else
                        g_arPROP[_p_AUDIT_][1].fDontput=1;
                else
                    if(GetBit(g_nAuditOff,FAIL_BIT)) 
                        V_I4(pvarVal)=0;
                    else if(GetBit(g_nAuditOn,FAIL_BIT))
                        V_I4(pvarVal)=1;
                    else
                        g_arPROP[_p_AUDIT_][2].fDontput=1;
                break;
        case _p_TIMEOUTACTIVE_ :

                if(nPropattrib==1)  // Do not meddle with the backup property.
                    {g_arPROP[_p_TIMEOUTACTIVE_][nPropattrib].fDontput=1;break;}
                
                V_VT(pvarVal)=VT_I4;
                if(0==_wcsicmp(g_arVALOF[nProperty],L"yes"))
                {
                    if(FAILED(hRes=GetProperty(_p_TIMEOUTACTIVE_,1,&vVar)))
                        return hRes;
                    V_I4(pvarVal)=V_I4(&vVar);
                }
                else
                    V_I4(pvarVal)=-1;
                
                break;
                
        case _p_TIMEOUT_:  //By this time timeoutactive is already set or put.
        
                if(GetBit(g_nConfigOptions,_p_TIMEOUTACTIVE_)&&(_wcsicmp(g_arVALOF[_p_TIMEOUTACTIVE_],L"yes")<0))
                {
                    g_arPROP[_p_TIMEOUT_][nPropattrib].fDontput=1;
                    ShowError(IDR_TIMEOUTACTIVE_TIMEOUT_MUTUAL_EXCLUSION);
                    return E_FAIL;//Check this return Value
                }

                V_VT(pvarVal)=VT_I4;
                if(g_nTimeoutFlag)
                {
                    V_I4(pvarVal)=_wtoi(g_arVALOF[nProperty]);
                }
                else
                {
                    if(CheckForInt(nProperty))
                    {
                          	int nSeconds;
                           	if(0==nPropattrib)
                           	{
                                ConvertintoSeconds(nProperty,&nSeconds);
                            	V_I4(pvarVal)=nSeconds;
                           	}
                           	// Now that we have destroyed whatever value we had in the global
                           	// variable by the use of wcstok, we need to copy from the already
                           	// computed value
                           	else //incase nPropattrib is 1 
                           	    V_I4(pvarVal)=V_I4(& g_arPROP[nProperty][0].var);
                    }	
                }
                if(V_I4(pvarVal)>60*60*2400||V_I4(pvarVal)<=0)
                {
                    ShowError(IDR_TIMEOUT_INTEGER_VALUES);
                    hRes=E_FAIL;
                }   
                break;
        
        case _p_SEC_    :

                V_VT(pvarVal)=VT_I4;
                if(FAILED(hRes=GetProperty(_p_SEC_,0,&vVar)))
                    return hRes;

                if(GetBit(g_nSecOn,PASSWD_BIT))//+passwd
                    if(GetBit(g_nSecOn,NTLM_BIT))      //+ntlm
                            V_I4(pvarVal)=6;
                    else if(GetBit(g_nSecOff,NTLM_BIT)) //-ntlm
                            V_I4(pvarVal)=4;
                    else
                    {
                        if(V_I4(&vVar)!=2)
                            g_arPROP[nProperty][nPropattrib].fDontput=1;
                        else
                            V_I4(pvarVal)=6;
                    }
                else if(GetBit(g_nSecOff,PASSWD_BIT)) //-passwd
                    if(GetBit(g_nSecOn,NTLM_BIT))          //+ntlm
                            V_I4(pvarVal)=2;
                    else if(GetBit(g_nSecOff,NTLM_BIT))     //-ntlm
                    {    
                            ShowError(IDR_NO_AUTHENTICATION_MECHANISM);
                            g_arPROP[nProperty][nPropattrib].fDontput=1;
                    }
                    else
                    {
                        if(V_I4(&vVar)==4)
                        {    
                            ShowError(IDR_NO_AUTHENTICATION_MECHANISM);
                            g_arPROP[nProperty][nPropattrib].fDontput=1;
                        }
                        else if(V_I4(&vVar)==2)
                            g_arPROP[_p_SEC_][nPropattrib].fDontput=1;
                        else
                            V_I4(pvarVal)=2;
                    }
                else
                    if(GetBit(g_nSecOn,NTLM_BIT)) //+ntlm
                    {
                        if(V_I4(&vVar)!=4)
                            g_arPROP[nProperty][nPropattrib].fDontput=1;
                        else
                            V_I4(pvarVal)=6;
                    }
                    else if(GetBit(g_nSecOff,NTLM_BIT)) //-ntlm
                    {
                        if(V_I4(&vVar)==2)
                        {    
                            ShowError(IDR_NO_AUTHENTICATION_MECHANISM);
                            g_arPROP[nProperty][nPropattrib].fDontput=1;
                        }
                        else if(V_I4(&vVar)==4)
                            g_arPROP[_p_SEC_][nPropattrib].fDontput=1;
                        else
                            V_I4(pvarVal)=4;
                    }
                    else
                    {    
                        ShowError(IDR_NO_AUTHENTICATION_MECHANISM);
                        g_arPROP[nProperty][nPropattrib].fDontput=1;
                    }
                break;

        case _p_DEFAULTS_ :
            if(nPropattrib==0)
                {    
                    if(FAILED(hRes=GetProperty(nProperty,0, &vVar)))
                    {
                        g_nError=1;
                        //error occurred in getting the value.
                        //error in notification
                        break;
                    }
                 
                    V_I4(pvarVal)=((V_I4(&vVar)>0) ? 0 : 1);
                }
                else
                    g_arPROP[nProperty][nPropattrib].fDontput=1;
                break;
                    
        case _p_CNAME_    :
        case _p_INSTALLPATH_ :
        default :
                g_arPROP[nProperty][nPropattrib].fDontput=1;
                break;

    }
    return hRes;
} 



/*--
    PrintSettings Gets the present values int the registry corresponding to the
    tnadmin and prints it out.
--*/

HRESULT PrintSettings(void)
{
    int nLen=0, temp_count;
    int nCheck=0;
	WCHAR wzDomain[DNS_MAX_NAME_BUFFER_LENGTH];
	WCHAR szTemp[MAX_BUFFER_SIZE] = { 0 };

    nLen=LoadString(g_hResource,IDR_MACHINE_SETTINGS, szTemp, MAX_BUFFER_SIZE );
    if(0 == nLen) return GetLastError();
    _putws(L"\n");
    _snwprintf(g_szMsg, MAX_BUFFER_SIZE -1, szTemp,(NULL == g_arVALOF[_p_CNAME_]) ? L"localhost" : g_arVALOF[_p_CNAME_]);
    MyWriteConsole(g_stdout, g_szMsg, wcslen(g_szMsg));
    
//  The following line(commented out) is used when we had g_szCName to 
//  store the computer name as g_arVALOF[_p_CNAME_] stores the same in 
//  the IP address format.
//  But we decided not to go for it as it will lead to serious perf issues

    nLen = 0;
    nCheck=LoadString(g_hResource, IDR_ALT_KEY_MAPPING, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen);
    if(nCheck==0) return GetLastError();
    nLen += nCheck;
    // check whether we have room left in the buffer.
    if (nLen >= ARRAYSIZE(g_szMsg))
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

//ctrlakeymap
    if(V_I4(&g_arPROP[_p_CTRLAKEYMAP_][0].var))
    {
       nCheck=TnLoadString(IDR_YES, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen,_T("\tYES\n"));
       if(nCheck==0) return GetLastError();
       nLen += nCheck;
        // check whether we have room left in the buffer.
        if (nLen >= ARRAYSIZE(g_szMsg))
        {
            return ERROR_INSUFFICIENT_BUFFER;
        }
    }
    else
    {
       nCheck=TnLoadString(IDR_NO, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen,_T("\tYES\n"));
       if(nCheck==0) return GetLastError();
       nLen += nCheck;
        // check whether we have room left in the buffer.
        if (nLen >= ARRAYSIZE(g_szMsg))
        {
            return ERROR_INSUFFICIENT_BUFFER;
        }
    }
        
//timeout
    nCheck=LoadString(g_hResource, IDR_IDLE_SESSION_TIMEOUT, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen);
    if(nCheck==0) return GetLastError();
    nLen += nCheck;
    // check whether we have room left in the buffer.
    if (nLen >= ARRAYSIZE(g_szMsg))
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    if(V_I4(&g_arPROP[_p_TIMEOUT_][0].var)==-1)
    {
    	nCheck=TnLoadString(IDR_MAPPING_NOT_ON, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen,_T("\tNot On\n"));
    	if(nCheck==0) return GetLastError();    	
        nLen += nCheck;
        // check whether we have room left in the buffer.
        if (nLen >= ARRAYSIZE(g_szMsg))
        {
            return ERROR_INSUFFICIENT_BUFFER;
        }
    }
    else
    {
        int nTime=V_I4(&g_arPROP[_p_TIMEOUT_][0].var);
        int nQuotient=nTime/3600;
        nTime=nTime-nQuotient*3600;
        if(nQuotient)
        {
        	temp_count = _snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1,L"\t%d ",nQuotient);
            if (temp_count < 0) {
                return ERROR_INSUFFICIENT_BUFFER;
            }
            nLen += temp_count;
	    	nCheck=TnLoadString(IDR_TIME_HOURS, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen,_T("hours"));
	    	if(nCheck==0) return GetLastError();    	
            nLen += nCheck;
            // check whether we have room left in the buffer.
            if (nLen >= ARRAYSIZE(g_szMsg))
            {
                return ERROR_INSUFFICIENT_BUFFER;
            }
        
            nQuotient=nTime/60;
            nTime=nTime-nQuotient*60;
            if(nQuotient)
            {
            	temp_count = _snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1,L" %d ",nQuotient);
                if (temp_count < 0) {
                    return ERROR_INSUFFICIENT_BUFFER;
                }
                nLen += temp_count;
            	nCheck=TnLoadString(IDR_TIME_MINUTES, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen,_T("minutes"));
            	if(nCheck==0) return GetLastError();    	
                nLen += nCheck;
                // check whether we have room left in the buffer.
                if (nLen >= ARRAYSIZE(g_szMsg))
                {
                    return ERROR_INSUFFICIENT_BUFFER;
                }
                
            	temp_count = _snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1,L" %d ",nTime);
                if (temp_count < 0) {
                    return ERROR_INSUFFICIENT_BUFFER;
                }
                nLen += temp_count;
            	nCheck=TnLoadString(IDR_TIME_SECONDS, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen,_T("seconds\n"));
            	if(nCheck==0) return GetLastError();    	
                nLen += nCheck;
                // check whether we have room left in the buffer.
                if (nLen >= ARRAYSIZE(g_szMsg))
                {
                    return ERROR_INSUFFICIENT_BUFFER;
                }
                
            }
            else if(nTime)
            {
            	temp_count = _snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1,L" %d ",nTime);
                if (temp_count < 0) {
                    return ERROR_INSUFFICIENT_BUFFER;
                }
                nLen += temp_count;
            	nCheck=TnLoadString(IDR_TIME_SECONDS, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen,_T("seconds\n"));
            	if(nCheck==0) return GetLastError();
                nLen += nCheck;
                // check whether we have room left in the buffer.
                if (nLen >= ARRAYSIZE(g_szMsg))
                {
                    return ERROR_INSUFFICIENT_BUFFER;
                }
            }
            else
            {
                wcsncpy(g_szMsg+nLen, L"\n", ARRAYSIZE(g_szMsg)-nLen-1);
                g_szMsg[ARRAYSIZE(g_szMsg)-1]=L'\0';
                nLen += 1; // for L"\n"
                if (nLen >= ARRAYSIZE(g_szMsg))
                    return ERROR_INSUFFICIENT_BUFFER;
            }
        }
        else if(nTime)
        {
            nQuotient=nTime/60;
            nTime=nTime-nQuotient*60;
            if(nQuotient)
            {
            	temp_count = _snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1,L"\t%d ",nQuotient);
                if (temp_count < 0) {
                    return ERROR_INSUFFICIENT_BUFFER;
                }
                nLen += temp_count;
            	nCheck = TnLoadString(IDR_TIME_MINUTES, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen,_T("minutes"));
            	if(nCheck==0) return GetLastError();
                nLen += nCheck;
                // check whether we have room left in the buffer.
                if (nLen >= ARRAYSIZE(g_szMsg))
                {
                    return ERROR_INSUFFICIENT_BUFFER;
                }
                
            	temp_count = _snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1,L" %d ",nTime);
                if (temp_count < 0) {
                    return ERROR_INSUFFICIENT_BUFFER;
                }
                nLen += temp_count;
            	nCheck = TnLoadString(IDR_TIME_SECONDS, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen,_T("seconds\n"));
            	if(nCheck==0) return GetLastError();
                nLen += nCheck;
                // check whether we have room left in the buffer.
                if (nLen >= ARRAYSIZE(g_szMsg))
                {
                    return ERROR_INSUFFICIENT_BUFFER;
                }
            }
            else
            {
            	temp_count = _snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1, L"\t%d ",nTime);
                if (temp_count < 0) {
                    return ERROR_INSUFFICIENT_BUFFER;
                }
                nLen += temp_count;
            	nCheck = TnLoadString(IDR_TIME_SECONDS, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen,_T("seconds\n"));
            	if(nCheck==0) return GetLastError();
                nLen += nCheck;
                // check whether we have room left in the buffer.
                if (nLen >= ARRAYSIZE(g_szMsg))
                {
                    return ERROR_INSUFFICIENT_BUFFER;
                }
            }
        }
        else
        {
            wcsncpy(g_szMsg+nLen, L"\t0 ", ARRAYSIZE(g_szMsg)-nLen-1);
            g_szMsg[ARRAYSIZE(g_szMsg)-1]=L'\0';
            nLen += wcslen(L"\t0 "); 
            if (nLen >= ARRAYSIZE(g_szMsg)) {
                return ERROR_INSUFFICIENT_BUFFER;
            }
        	nCheck = TnLoadString(IDR_TIME_SECONDS, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen,_T("seconds\n"));
        	if(nCheck==0) return GetLastError();
            nLen += nCheck;
            // check whether we have room left in the buffer.
            if (nLen >= ARRAYSIZE(g_szMsg))
            {
                return ERROR_INSUFFICIENT_BUFFER;
            }
        }
    }
//maxconnections
    nCheck = LoadString(g_hResource, IDR_MAX_CONNECTIONS, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen);
    if(nCheck==0) return GetLastError();
    nLen += nCheck;
    // check whether we have room left in the buffer.
    if (nLen >= ARRAYSIZE(g_szMsg))
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    temp_count = _snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1,L"\t%d\n",V_I4(&g_arPROP[_p_MAXCONN_][0].var));
    if (temp_count < 0) {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    nLen += temp_count;
//port
    nCheck = LoadString(g_hResource, IDR_TELNET_PORT, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen);
    if(nCheck==0) return GetLastError();
    nLen += nCheck;
    // check whether we have room left in the buffer.
    if (nLen >= ARRAYSIZE(g_szMsg))
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    temp_count = _snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1,L"\t%d\n",V_I4(&g_arPROP[_p_PORT_][0].var));
    if (temp_count < 0) {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    nLen += temp_count;
//maxfail
    nCheck = LoadString(g_hResource, IDR_MAX_FAILED_LOGIN_ATTEMPTS, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen);
    if(nCheck==0) return GetLastError();
    nLen += nCheck;
    // check whether we have room left in the buffer.
    if (nLen >= ARRAYSIZE(g_szMsg))
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    temp_count = _snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1,L"\t%d\n",V_I4(&g_arPROP[_p_MAXFAIL_][0].var));
    if (temp_count < 0) {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    nLen += temp_count;
//kill on disconnect
	nCheck = LoadString(g_hResource, IDR_END_TASKS_ON_DISCONNECT, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen);
    if(nCheck==0) return GetLastError();
    nLen += nCheck;
    // check whether we have room left in the buffer.
    if (nLen >= ARRAYSIZE(g_szMsg))
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    if(V_I4(&g_arPROP[_p_KILLALL_][0].var)==1)
    {
       nCheck = TnLoadString(IDR_YES, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen,_T("\tYES\n"));
       if(nCheck==0) return GetLastError();
       nLen += nCheck;
        // check whether we have room left in the buffer.
        if (nLen >= ARRAYSIZE(g_szMsg))
        {
            return ERROR_INSUFFICIENT_BUFFER;
        }
    }
    else
    {
       nCheck = TnLoadString(IDR_NO, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen,_T("\tNO\n"));
       if(nCheck==0) return GetLastError();
       nLen += nCheck;
        // check whether we have room left in the buffer.
        if (nLen >= ARRAYSIZE(g_szMsg))
        {
            return ERROR_INSUFFICIENT_BUFFER;
        }
    }
 
//mode
    nCheck = LoadString(g_hResource, IDR_MODE_OF_OPERATION, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen);
    if(nCheck==0) return GetLastError();
    nLen += nCheck;
    // check whether we have room left in the buffer.
    if (nLen >= ARRAYSIZE(g_szMsg))
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    temp_count = _snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1, L"\t%s\n",(V_I4(&g_arPROP[_p_MODE_][0].var)==1) ? L"Console" : L"Stream");
    if (temp_count < 0) {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    nLen += temp_count;
    MyWriteConsole(g_stdout,g_szMsg,wcslen(g_szMsg));
//sec
    nLen=0;
    nLen = LoadString(g_hResource,IDR_AUTHENTICATION_MECHANISM, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen);
    if(0 == nLen) return GetLastError();
    // check whether we have room left in the buffer.
    if (nLen >= ARRAYSIZE(g_szMsg))
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    switch(V_I4(&g_arPROP[_p_SEC_][0].var))
    {
        case 2 :
            wcsncpy(g_szMsg+nLen, L"\tNTLM\n", ARRAYSIZE(g_szMsg)-nLen-1);
            g_szMsg[ARRAYSIZE(g_szMsg)-1]=L'\0';
            nLen += wcslen(L"\tNTLM\n"); 
            if (nLen >= ARRAYSIZE(g_szMsg)) {
                return ERROR_INSUFFICIENT_BUFFER;
            }
            
            break;
        case 4 :
            wcsncpy(g_szMsg+nLen, L"\tPassword\n", ARRAYSIZE(g_szMsg)-nLen-1);
            g_szMsg[ARRAYSIZE(g_szMsg)-1]=L'\0';
            nLen += wcslen(L"\tPassword\n"); 
            if (nLen >= ARRAYSIZE(g_szMsg)) {
                return ERROR_INSUFFICIENT_BUFFER;
            }
            
            break;
        default :
            wcsncpy(g_szMsg+nLen, L"\tNTLM, Password\n", ARRAYSIZE(g_szMsg)-nLen-1);
            g_szMsg[ARRAYSIZE(g_szMsg)-1]=L'\0';
            nLen += wcslen(L"\tNTLM, Password\n"); 
            if (nLen >= ARRAYSIZE(g_szMsg)) {
                return ERROR_INSUFFICIENT_BUFFER;
            }

            break;
    }
//default domain
    nCheck=LoadString(g_hResource, IDR_DEFAULT_DOMAIN, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen);
    if(nCheck==0) return GetLastError();
    nLen += nCheck;
    // check whether we have room left in the buffer.
    if (nLen >= ARRAYSIZE(g_szMsg))
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }
    
    if(NULL==wcscmp(V_BSTR(&g_arPROP[_p_DOM_][0].var), L"."))
    {
        if(setDefaultDomainToLocaldomain(wzDomain))
        {
            temp_count = _snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1, L"\t%s\n",wzDomain);
            if (temp_count < 0) {
                return ERROR_INSUFFICIENT_BUFFER;
            }
            nLen += temp_count;
        }
        else
        {
            temp_count = _snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1, L"\t%s\n",V_BSTR(&g_arPROP[_p_DOM_][0].var));
            if (temp_count < 0) {
                return ERROR_INSUFFICIENT_BUFFER;
            }
            nLen += temp_count;
        }
    }
    else
    {
	    temp_count = _snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1,L"\t%s\n",V_BSTR(&g_arPROP[_p_DOM_][0].var));
        if (temp_count < 0) {
            return ERROR_INSUFFICIENT_BUFFER;
        }
        nLen += temp_count;
    }
//state of the service
    nCheck = LoadString(g_hResource, IDR_STATE, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen);
    if(nCheck==0) return GetLastError();
    nLen += nCheck;
    // check whether we have room left in the buffer.
    if (nLen >= ARRAYSIZE(g_szMsg))
    {
        return ERROR_INSUFFICIENT_BUFFER;
    }

    switch(g_hServiceStatus.dwCurrentState)
    {
        case SERVICE_STOPPED :
	    	nCheck = TnLoadString(IDR_STATUS_STOPPED, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen,_T("\tStopped\n"));
	    	if(nCheck==0) return GetLastError();
	    	break;
        case SERVICE_RUNNING :
	    	nCheck = TnLoadString(IDR_STATUS_RUNNING, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen,_T("\tRunning\n"));
	    	if(nCheck==0) return GetLastError();
	    	break;
        case SERVICE_PAUSED  :
	    	nCheck = TnLoadString(IDR_STATUS_PAUSED, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen,_T("\tPaused\n"));
	    	if(nCheck==0) return GetLastError();
	    	break;
        case SERVICE_START_PENDING:
	    	nCheck = TnLoadString(IDR_STATUS_START_PENDING, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen,_T("\tStart Pending\n"));
	    	if(nCheck==0) return GetLastError();    	
	    	break;
        case SERVICE_STOP_PENDING :
	    	nCheck = TnLoadString(IDR_STATUS_STOP_PENDING, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen,_T("\tStop Pending\n"));
	    	if(nCheck==0) return GetLastError();    	
	    	break;
        case SERVICE_CONTINUE_PENDING:
	    	nCheck = TnLoadString(IDR_STATUS_CONTINUE_PENDING, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen,_T("\tContinue Pending\n"));
	    	if(nCheck==0) return GetLastError();    	
	    	break;
        case SERVICE_PAUSE_PENDING:
	    	nCheck = TnLoadString(IDR_STATUS_PAUSE_PENDING, g_szMsg+nLen, MAX_BUFFER_SIZE-nLen,_T("\tPause Pending\n"));
	    	if(nCheck==0) return GetLastError();    	
	    	break;
        default :
            nCheck = 0;
            break;
    }
    nLen += nCheck;

    MyWriteConsole(g_stdout,g_szMsg,wcslen(g_szMsg));

    return S_OK;
}

/*--
    SesidInit() functions gets the handle to the session
    manager interface.
--*/

#define FOUR_K  4096

HRESULT SesidInit()
{
    HRESULT hr = S_OK;
    COSERVERINFO  serverInfo = { 0 };
    MULTI_QI qi = {&IID_IManageTelnetSessions, NULL, S_OK};
    CLSCTX          server_type_for_com = CLSCTX_LOCAL_SERVER;
    COAUTHINFO      com_auth_info = { 0 };
    COAUTHIDENTITY  com_auth_identity = { 0 };
    wchar_t         full_user_name[FOUR_K + 1] = { 0 }; // hack for now

    
    if (g_arVALOF[_p_CNAME_])  // a remote box has been specified
    {
        server_type_for_com = CLSCTX_REMOTE_SERVER;

        serverInfo.pwszName    = g_arVALOF[_p_CNAME_];

        // printf("BASKAR: Remote Machine name added\n");
    }

    if (g_arVALOF[_p_USER_]) // A user name has been specified, so go with it
    {
        wchar_t     *delimited;

        wcsncpy(full_user_name, g_arVALOF[_p_USER_], FOUR_K);

        delimited = StrStrIW(full_user_name, L"\\");

        if (delimited) 
        {
            *delimited = L'\0';
            delimited ++;

            com_auth_identity.Domain = full_user_name;
            com_auth_identity.User = delimited;

            // printf("BASKAR: Domain\\User name added\n");
        }
        else
        {
            com_auth_identity.User = full_user_name;

            // printf("BASKAR: Just User name added\n");
        }

        com_auth_identity.UserLength = lstrlenW(com_auth_identity.User);

        if (com_auth_identity.Domain) 
        {
            com_auth_identity.DomainLength = lstrlenW(com_auth_identity.Domain);
        }

        if (g_arVALOF[_p_PASSWD_]) 
        {
            com_auth_identity.Password = g_arVALOF[_p_PASSWD_];

            com_auth_identity.PasswordLength = lstrlenW(com_auth_identity.Password);

            // printf("BASKAR: Password added\n");
        }

        com_auth_identity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

        com_auth_info.dwAuthnSvc = RPC_C_AUTHN_WINNT;
        com_auth_info.dwAuthzSvc = RPC_C_AUTHZ_NONE;
        com_auth_info.pwszServerPrincName = NULL;
        com_auth_info.dwAuthnLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
        com_auth_info.dwImpersonationLevel = RPC_C_IMP_LEVEL_IMPERSONATE;
        com_auth_info.pAuthIdentityData = &com_auth_identity;
        com_auth_info.dwCapabilities = EOAC_NONE;

        serverInfo.pAuthInfo = &com_auth_info;

        // printf("BASKAR: Auth Info added\n");
    }

    // No need to worry about the CoInitialize() as we have done that in Initialize()
    // function.

    hr = CoCreateInstanceEx( 
            CLSID_EnumTelnetClientsSvr, 
            NULL,             
            server_type_for_com,
            &serverInfo, 
            1,
            &qi
            );

    // We no longer require password - clear it
    TnClearPasswd();

    if( SUCCEEDED(hr) && SUCCEEDED(qi.hr) )
    {
        // if (g_arVALOF[_p_USER_])
        // {
        //     hr = CoSetProxyBlanket(
        //             (IUnknown*)qi.pItf,  // This is the proxy interface
        //             com_auth_info.dwAuthnSvc,
        //             com_auth_info.dwAuthzSvc,
        //             com_auth_info.pwszServerPrincName,
        //             com_auth_info.dwAuthnLevel,
        //             com_auth_info.dwImpersonationLevel,
        //             &com_auth_identity,
        //             com_auth_info.dwCapabilities
        //             );
        // }
        // Now get the interface
        g_pIManageTelnetSessions = ( IManageTelnetSessions* )qi.pItf;
    }
    else
    {
        g_pIManageTelnetSessions= NULL;

        if (hr == E_ACCESSDENIED) 
        {
            ShowError(IDS_E_CANNOT_MANAGE_TELNETSERVER);
        }
        else
        {
            ShowError(IDS_E_CANNOT_CONTACT_TELNETSERVER);
        }
        hr = E_FAIL;
    }  

    return hr;
}

#undef FOUR_K

/*--
    This function gets a handle to session manager interface
    using sesidinit and also gets all the sessions into an array.
--*/

HRESULT ListUsers() 
{

    BSTR bstrSessionInfo;
    HRESULT hRes=S_OK;
    wchar_t *wzAllSession;

    //List Users gets all the session Info into this BSTR.
    if(g_pIManageTelnetSessions == NULL )
    {
        if(FAILED(hRes=SesidInit()))
            return hRes;
    }
    
    // DebugBreak();
    if(g_pIManageTelnetSessions == NULL )
    {
       // Still you didn't get the interface handle
       // what else can we do? In case of any error in getting the handle, we would
       // have printed the error message in SesidInit(). So just bail out here.
       // This code path should never get executed.
       return S_FALSE;
    }

    hRes =g_pIManageTelnetSessions->GetTelnetSessions(&bstrSessionInfo);
    
    if( FAILED( hRes ) || (NULL == bstrSessionInfo))
    {
        _tprintf( TEXT("Error: GetEnumClients(): 0x%x\n"), hRes ); 
                                            //Load a String here.
        return hRes;
    }

    wzAllSession=(wchar_t *)bstrSessionInfo;

    //parsing the bstrSessionInfo into each session and placing it into the
    //global array g_ppwzSessionInfo for other functions to use it.
    
    g_nNumofSessions=_wtoi(wcstok(wzAllSession,session_separator));
    if(!g_nNumofSessions)
    {
        return hRes;
    }

    if((g_ppwzSessionInfo=(wchar_t**)malloc(g_nNumofSessions*sizeof(wchar_t*)))==NULL)
    {
        ShowError(IDS_E_OUTOFMEMORY);//BB
        return E_OUTOFMEMORY;
    }
    for(int i=0;i<g_nNumofSessions;i++)
    {
        g_ppwzSessionInfo[i]=wcstok(NULL,session_separator);
    }

    return hRes;
}

/*--
    TerminateSession terminates all sessions or given sessionid's session.
--*/


HRESULT TerminateSession(void )
{
    HRESULT hRes=S_OK;int i;

    if(FAILED(hRes=ListUsers()))
    	goto End;

    if(g_nNumofSessions==0)
    {
        if(LoadString(g_hResource,IDR_NO_ACTIVE_SESSION,g_szMsg,MAX_BUFFER_SIZE)==0)
            return GetLastError();
        MyWriteConsole(g_stdout,g_szMsg,wcslen(g_szMsg));
        return S_OK;
    }

    if(g_nSesid!=-1&&CheckSessionID()==0)
    {    ShowError(IDR_INVALID_SESSION);
        return S_OK;
    }

    
    for(i=0;i<g_nNumofSessions;i++)
    {
        wchar_t* wzId=wcstok(g_ppwzSessionInfo[i],session_data_separator);
        if(g_nSesid!=-1)
            if(g_nSesid!=_wtoi(wzId))
                continue;
        
        hRes= g_pIManageTelnetSessions->TerminateSession(_wtoi(wzId));
    }
    
    if( FAILED( hRes ) )
    {
        _tprintf( TEXT("Error: GetEnumClients(): 0x%x\n"), hRes );
                                            //Load a String here.
        return E_FAIL;
    }
End:
   return hRes;
}



/*--
    This function gets a handle to session manager interface
    using sesidinit and list users and sends message to the
    corresponding sessions.
--*/


HRESULT MessageSession(void)
{
    HRESULT hRes=S_OK;
    int i=0;
    if(FAILED(hRes=ListUsers()))
    	goto End;
    if(g_nNumofSessions==0)
    {
        if(LoadString(g_hResource,IDR_NO_ACTIVE_SESSION,g_szMsg,MAX_BUFFER_SIZE)==0)
            return GetLastError();
        MyWriteConsole(g_stdout,g_szMsg,wcslen(g_szMsg));
        return S_OK;
    }

    if(g_nSesid!=-1&&CheckSessionID()==0)
    {   
        ShowError(IDR_INVALID_SESSION);
        return S_OK;
    }


    if(g_nSesid!=-1)
         hRes = g_pIManageTelnetSessions->SendMsgToASession(g_nSesid,g_bstrMessage);
    else
    {
        for(i=0;i<g_nNumofSessions;i++)
        {
            wchar_t* wzId=wcstok(g_ppwzSessionInfo[i],session_data_separator);
            if(g_nSesid!=-1)
                if(g_nSesid!=_wtoi(wzId))
                    continue;
            hRes= g_pIManageTelnetSessions->SendMsgToASession(_wtoi(wzId),g_bstrMessage);
        }

    }
    
    if( FAILED( hRes ) )
    {
        _tprintf( TEXT("Error: GetEnumClients(): 0x%x\n"), hRes );
                                                //Load a String here.
        return E_FAIL;
    }

   if(0==LoadString(g_hResource,IDR_MESSAGE_SENT,g_szMsg,MAX_BUFFER_SIZE))
   	  return GetLastError();
   MyWriteConsole(g_stdout,g_szMsg,wcslen(g_szMsg));
End:   
   return hRes;
   
}


/*--
    This function gets a handle to session manager interface
    using sesidinit and list users and shows all the corresponding sessions.
--*/


HRESULT ShowSession(void)
{
	HRESULT hRes=S_OK;
	int nLen=0, temp_count;
    int nCheck=0,i;
    if(FAILED(hRes=ListUsers()))
    	goto Error;

    if(g_nNumofSessions==0)
    {
        if(LoadString(g_hResource,IDR_NO_ACTIVE_SESSION,g_szMsg,MAX_BUFFER_SIZE)==0)
            return GetLastError();
        MyWriteConsole(g_stdout,g_szMsg,wcslen(g_szMsg));
        return S_OK;
    }
    if(g_nSesid!=-1&&CheckSessionID()==0)
    {    ShowError(IDR_INVALID_SESSION);
        return S_OK;
    }
    
   
    
    temp_count = _snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1,L"\n%d",g_nNumofSessions);
    if (temp_count < 0) {
        return E_FAIL;
    }
    nLen += temp_count;
    nCheck = LoadString(g_hResource,IDR_TELNET_SESSIONS,g_szMsg+nLen,MAX_BUFFER_SIZE-nLen);
    if (nCheck == 0) {
        return E_FAIL;
    }
    nLen += nCheck;
    
    MyWriteConsole(g_stdout,g_szMsg,wcslen(g_szMsg));

    // The following buffers are used to get the strings and print. They can not exceed Max_Path
    WCHAR     szMsg1[MAX_PATH+1];
    WCHAR     szMsg2[MAX_PATH+1];
    WCHAR     szMsg3[MAX_PATH+1];
    WCHAR     szMsg4[MAX_PATH+1];
    WCHAR     szMsg5[MAX_PATH+1];
    WCHAR     szTemp[MAX_BUFFER_SIZE] = { 0 };

    if(LoadString(g_hResource,IDR_DOMAIN,szMsg1, ARRAYSIZE(szMsg1)-1)==0)
        return E_FAIL;
    if(LoadString(g_hResource,IDR_USERNAME,szMsg2,ARRAYSIZE(szMsg2)-1)==0)
        return E_FAIL;
    if(LoadString(g_hResource,IDR_CLIENT,szMsg3,ARRAYSIZE(szMsg3)-1)==0)
        return E_FAIL;
    if(LoadString(g_hResource,IDR_LOGONDATE,szMsg4,ARRAYSIZE(szMsg4)-1)==0)
        return E_FAIL;
    //IDR_LOGONDATE itself contains the IDR_LOGONTIME also
   // if(LoadString(g_hResource,IDR_LOGONTIME,szMsg5,ARRAYSIZE(szMsg5)-1)==0)
     //   return E_FAIL;
    if(LoadString(g_hResource,IDR_IDLETIME,szMsg5,ARRAYSIZE(szMsg5)-1)==0)
        return E_FAIL;
    /*

    Getting some problem with this LoadString and swprintf interleaving here...hence the above
    brute force approach.
    
    nLen+=LoadString(g_hResource,IDR_DOMAIN,szMsg+nLen,MAX_BUFFER_SIZE-nLen);
    nLen+=_snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1,L"%s",",");

    nLen+=LoadString(g_hResource,IDR_USERNAME,szMsg+nLen,MAX_BUFFER_SIZE-nLen);
    nLen+=_snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1,L"%s",L",");

    nLen+=LoadString(g_hResource,IDR_CLIENT,szMsg+nLen,MAX_BUFFER_SIZE-nLen);
    nLen+=_snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1,L",");

    nLen+=LoadString(g_hResource,IDR_LOGONDATE,szMsg+nLen,MAX_BUFFER_SIZE-nLen);
    nLen+=_snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1,L",");

    nLen+=LoadString(g_hResource,IDR_LOGONTIME,szMsg+nLen,MAX_BUFFER_SIZE-nLen);
    nLen+=_snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1,L",");

    nLen+=LoadString(g_hResource,IDR_IDLETIME,szMsg+nLen,MAX_BUFFER_SIZE-nLen);
    _putws(szMsg);
    */
    
    //Stores the Formatted headed in the g_szMsg
    formatShowSessionsDisplay();
    _snwprintf(szTemp,MAX_BUFFER_SIZE-1,g_szMsg,L"ID",szMsg1,szMsg2,szMsg3,szMsg4,szMsg5);
    MyWriteConsole(g_stdout,szTemp,wcslen(szTemp));
    nLen = _snwprintf(szTemp,MAX_BUFFER_SIZE-1,g_szMsg,L" ",L" ",L" ",L" ",L" ",L"(hh:mm:ss)");
    MyWriteConsole(g_stdout,szTemp,wcslen(szTemp));
    for(i=1;i<nLen;i++)
    	putwchar(L'-');
    
    nLen=0;
  

        
    for(i=0;i<g_nNumofSessions;i++)
    {
        wchar_t* wzId=wcstok(g_ppwzSessionInfo[i],session_data_separator);
        if(g_nSesid!=-1)
            if(g_nSesid!=_wtoi(wzId))
                continue;
        
        wchar_t* wzDomain=wcstok(NULL,session_data_separator);
        wchar_t* wzUser=wcstok(NULL,session_data_separator);
        wchar_t* wzClient=wcstok(NULL,session_data_separator);

        if (NULL == wzDomain) 
        {
            wzDomain = L"";
        }
        if (NULL == wzUser) 
        {
            wzUser = L"";
        }
        if (NULL == wzClient) 
        {
            wzClient = L"";
        }

        
        wchar_t* wzYear=wcstok(NULL,session_data_separator);
        wchar_t* wzMonth=wcstok(NULL,session_data_separator);
        wchar_t* wzDayOfWeek=wcstok(NULL,session_data_separator);
        wchar_t* wzDay=wcstok(NULL,session_data_separator);
        wchar_t* wzHour=wcstok(NULL,session_data_separator);
        wchar_t* wzMinute=wcstok(NULL,session_data_separator);
        wchar_t* wzSecond=wcstok(NULL,session_data_separator);
        BSTR wzLocalDate;
        if(FAILED(hRes=ConvertUTCtoLocal(wzYear,wzMonth,wzDayOfWeek,wzDay,wzHour,wzMinute,wzSecond,& wzLocalDate)))
        	goto Error;
        wchar_t* wzIdleTimeInSeconds=wcstok(NULL,session_data_separator); //There is a constant that not required and hence that is skipped
        wzIdleTimeInSeconds=wcstok(NULL,session_data_separator);//Getting the Idle time in seconds
        wchar_t wzIdleTime[MAX_PATH + 1]; // To store time. CAN NOT EXCEED MAX_PATH
        wzHour=_itow(_wtoi(wzIdleTimeInSeconds)/3600,wzHour,10);
        int RemSeconds=_wtoi(wzIdleTimeInSeconds)%3600;

        wchar_t         local_minute[3];
        wchar_t         local_second[3];

        wzMinute=(wchar_t*) local_minute;
        wzSecond=(wchar_t*) local_second;

        wzMinute=_itow(RemSeconds/60,wzMinute,10);
        RemSeconds=_wtoi(wzIdleTimeInSeconds)%60;
        wzSecond=_itow(RemSeconds,wzSecond,10);
        if(1==wcslen(wzMinute))   //Add one more zero, if it is of single digit
        {
        	wcscat(wzMinute,L"0");     //append at the last and reverse it
        	wzMinute=_wcsrev(wzMinute);
        }
       
		if(1==wcslen(wzSecond))
        {
        	wcscat(wzSecond,L"0");
        	wzSecond=_wcsrev(wzSecond);
        } 

        _snwprintf(wzIdleTime, ARRAYSIZE(wzIdleTime)-1, L"%s:%s:%s", wzHour, wzMinute, wzSecond);

        wzIdleTime[ARRAYSIZE(wzIdleTime)-1] = L'\0';    // ensure NULL termination

        putwchar(L'\n');
        _snwprintf(szTemp,MAX_BUFFER_SIZE-1,g_szMsg,wzId,wzDomain,wzUser,wzClient,wzLocalDate,wzIdleTime);
        MyWriteConsole(g_stdout,szTemp,wcslen(szTemp));

    //free the memory allotted

        if (wzLocalDate) SysFreeString(wzLocalDate);
    }
Error:
    return hRes;
}


/*--
    CheckSessionID checks if the given session-Id is valid or not.
    Should be called only when Session id is given by the user.
--*/

int CheckSessionID(void)
{
    for(int i=0;i<g_nNumofSessions;i++)
    {
        wchar_t* wzStr=_wcsdup(g_ppwzSessionInfo[i]);
        int wzID=_wtoi(wcstok(wzStr,session_data_separator));
        if(g_nSesid==wzID)
            return 1;
        free(wzStr);
    }
    return 0;
}

/*--
To free any allocated memories.

--*/
void Quit(void)
{
    if(g_bstrMessage)
        SysFreeString(g_bstrMessage);
    if(bstrLogin)
        SysFreeString(bstrLogin);
    if(bstrPasswd)
        SysFreeString(bstrPasswd);
    if(bstrNameSpc)
        SysFreeString(bstrPasswd);
    for(int i=0;i<_MAX_PROPS_;i++)
        if(g_arVALOF[i])
            free(g_arVALOF[i]);

    if(V_BSTR(&g_arPROP[_p_DOM_][0].var))
        SysFreeString(V_BSTR(&g_arPROP[_p_DOM_][0].var));
    if(V_BSTR(&g_arPROP[_p_FNAME_][0].var))
        SysFreeString(V_BSTR(&g_arPROP[_p_FNAME_][0].var));

    if(g_hResource)
        FreeLibrary(g_hResource);
    if(g_hXPResource)
        FreeLibrary(g_hXPResource);
    
    if(g_fCoInitSuccess)
        CoUninitialize();
}


HRESULT ConvertUTCtoLocal(WCHAR *wzUTCYear, WCHAR *wzUTCMonth, WCHAR *wzUTCDayOfWeek, WCHAR *wzUTCDay, WCHAR *wzUTCHour, WCHAR *wzUTCMinute, WCHAR *wzUTCSecond, BSTR * bLocalDate)
{
	HRESULT             hRes=S_OK;
	SYSTEMTIME          UniversalTime = { 0 }, 
                        LocalTime = { 0 };
    DATE                dtCurrent = { 0 };
    DWORD               dwFlags = VAR_VALIDDATE;
	UDATE               uSysDate = { 0 }; //local time 

	*bLocalDate = NULL;
      
	UniversalTime.wYear 	    = (WORD)_wtoi(wzUTCYear);
    UniversalTime.wMonth 	    = (WORD)_wtoi(wzUTCMonth);
	UniversalTime.wDayOfWeek 	= (WORD)_wtoi(wzUTCDayOfWeek);
	UniversalTime.wDay 	        = (WORD)_wtoi(wzUTCDay);
	UniversalTime.wDay 	        = (WORD)_wtoi(wzUTCDay);
	UniversalTime.wMinute       = (WORD)_wtoi(wzUTCMinute);
	UniversalTime.wHour 	    = (WORD)_wtoi(wzUTCHour);
	UniversalTime.wSecond       = (WORD)_wtoi(wzUTCSecond);
	UniversalTime.wMilliseconds = 0;

	SystemTimeToTzSpecificLocalTime(NULL,&UniversalTime,&LocalTime);
	memcpy(&uSysDate.st,&LocalTime,sizeof(SYSTEMTIME));

    hRes = VarDateFromUdate( &uSysDate, dwFlags, &dtCurrent );

	if(SUCCEEDED(hRes))
    {
        hRes=VarBstrFromDate( dtCurrent, 
                MAKELCID( MAKELANGID( LANG_NEUTRAL, SUBLANG_SYS_DEFAULT ), SORT_DEFAULT ), 
                LOCALE_NOUSEROVERRIDE, bLocalDate);
    }
	    	
	return hRes;
}

//This function is to notify whether the user is allowed to change the maximum number of connections that could be established
//on the Telnet Server. It is to be noted that the user is not allowed to change the maximum number of connections to more than
//two(2 is default) if he is using Whistler and SFU is not installed.

// Commented out this function, as no more use it.
// WE HAVE DECIDED TO MAKE THE BEHAVIOR SIMILAR TO WIN2K AND NO DIFFERENT
// SO NO SPL. CHECK REQUIRED FOR WHISTLER (WINDOWS XP)
/*int IsMaxConnChangeAllowed()
{
  BOOL fAllow=TRUE;
  if(IsWhistlerTheOS())
  	if(!IsSFUInstalled())
  		fAllow=FALSE;
  return fAllow;
}*/


HRESULT IsWhistlerTheOS(BOOL *fWhistler)
{
	HKEY hReg=NULL;
	DWORD nSize = 256;
	DWORD nType=REG_SZ;
	TCHAR szDataBuffer[256];
	HRESULT hRes = S_OK;
	*fWhistler = FALSE;

	if(NULL==g_hkeyHKLM)
	{
	    // Connect to the registry if not already done
	    if(FAILED(hRes = GetConnection(g_arVALOF[_p_CNAME_])))
	        goto End;
	    
	}
	if(ERROR_SUCCESS==(hRes=RegOpenKeyEx(g_hkeyHKLM,
                           _T("SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion"),
                           0,
                           KEY_QUERY_VALUE,
                           &hReg)))
		   if(ERROR_SUCCESS ==	(hRes=RegQueryValueEx(hReg,
		   		           _T("CurrentBuildNumber"),
		   		           NULL,
		   		           &nType,
		   		           (LPBYTE)szDataBuffer,
		   		           &nSize)))
		   	{
		   		if(wcscmp(szDataBuffer,L"2195")>0)
		   			*fWhistler=TRUE;
		   	}

    // Print the error message.
    if(FAILED(hRes))
        PrintFormattedErrorMessage(LONG(hRes));

	if(hReg)
		RegCloseKey(hReg);
End:	
	return hRes;
}

BOOL IsSFUInstalled()
{
       HKEY hRegistry=NULL;
       HKEY hHive=NULL;
	DWORD nSize;
	char *szDataBuffer;
	BOOL fSFU=FALSE;
	if(ERROR_SUCCESS == RegConnectRegistry(g_arVALOF[_p_CNAME_],
		                                   HKEY_LOCAL_MACHINE,
		                                   &hRegistry))
	{
		   if(ERROR_SUCCESS==	 RegOpenKeyEx(hRegistry,
                           _T("SOFTWARE\\Microsoft\\Services For UNIX"),
                           0,
                           KEY_READ,
                           &hHive))
                fSFU=TRUE;                           
	}
	if(hHive)
	    RegCloseKey(hHive);
	if(hRegistry)
	    RegCloseKey(hRegistry);
	return fSFU;
}


//This is only for the display and this will not change the current registry value;
//The value in the registry is retained. (Which is ".")
BOOL setDefaultDomainToLocaldomain(WCHAR wzDomain[])
{	
	if(S_OK!=GetDomainHostedByThisMc(wzDomain))
	    return FALSE;
	return TRUE;	
}

void formatShowSessionsDisplay()
{
	int i,temp_count;
	int nLen=0;
	wchar_t* ppwzSessionInfo=NULL;
	unsigned int nMaxDomainFieldLength=0;
	unsigned int nMaxUserFieldLength=0;
	unsigned int nMaxClientFieldLength=0;


	 for(i=0;i<g_nNumofSessions;i++)
	 {
	       ppwzSessionInfo=_wcsdup(g_ppwzSessionInfo[i]);
	       wcstok(ppwzSessionInfo,session_data_separator);
	       WCHAR* wzDomain=wcstok(NULL,session_data_separator);
	       WCHAR* wzUser=wcstok(NULL,session_data_separator);
           WCHAR* wzClient=wcstok(NULL,session_data_separator);

           /*
                For some strange reason wcstok on : returns NULL if there us an empty string between ::
                so any of the above tokens could be NULL
            */

	       if (wzDomain && (nMaxDomainFieldLength < wcslen(wzDomain)))
           {
	       	   nMaxDomainFieldLength=wcslen(wzDomain);
           }
	       if (wzUser && (nMaxUserFieldLength < wcslen(wzUser)))
           {
	       	   nMaxUserFieldLength=wcslen(wzUser);
           }
	       if (wzClient && (nMaxClientFieldLength < wcslen(wzClient)))
           {
               nMaxClientFieldLength=wcslen(wzClient);
           }
	       free(ppwzSessionInfo);
	  }

 

		nMaxDomainFieldLength+=2;  //adding 2 for spaces (arbit)
		nMaxUserFieldLength+=2;
		nMaxClientFieldLength+=2;

///	       "\n%-3s%-11s%-14s%-11s%-11s%-11s%-4s\n"
///           id   domain user  client logondate time idletime
/// Hard code to 11 and 14 so that they have a good look
		if(nMaxDomainFieldLength < 11)
			nMaxDomainFieldLength=11;
		if(nMaxUserFieldLength < 14)
			nMaxUserFieldLength=14;
		if(nMaxClientFieldLength < 11)
			nMaxClientFieldLength=11;

        _putws(L"\n");

	    nLen=wcslen(wcscpy(g_szMsg,L"%-6s"));
	    temp_count = _snwprintf(g_szMsg+nLen, MAX_BUFFER_SIZE-nLen-1,L"%%-%ds%%-%ds%%-%ds",nMaxDomainFieldLength,nMaxUserFieldLength,nMaxClientFieldLength);
        if (temp_count < 0) {
            return;
        }
        nLen += temp_count;
	    wcscpy(g_szMsg+nLen,L"%-22s%-4s\n");
			//IDR_SESSION_HEADER_FORMAT
}

//The function queries the registry and returns whether the OS belongs to ServerClass.
BOOL IsServerClass()
{
	HKEY hReg=NULL;
	DWORD nSize = 256;
	DWORD nType=REG_SZ;
	TCHAR szDataBuffer[256];
	LONG LError;
	BOOL fServerClass=FALSE;
	
	if(ERROR_SUCCESS==	RegOpenKeyEx(g_hkeyHKLM,
                           _T("SYSTEM\\CurrentControlSet\\Control\\ProductOptions"),
                           0,
                           KEY_QUERY_VALUE,
                           &hReg))
		   if(ERROR_SUCCESS ==	(LError=RegQueryValueEx(hReg,
		   		           _T("ProductType"),
		   		           NULL,
		   		           &nType,
		   		           (LPBYTE)szDataBuffer,
		   		           &nSize)))
		   	{
		   		if((NULL==_wcsicmp(szDataBuffer,L"ServerNT")) || (NULL == _wcsicmp(szDataBuffer,L"LanmanNT")))
		   			fServerClass=TRUE;
		   	}

	if(hReg)
		RegCloseKey(hReg);
	return fServerClass;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\admin\tnadminl.c ===
#line 2 "tnadminl.c"
/* A lexical scanner generated by flex */

/* Scanner skeleton version:
 * $Header: /home/daffy/u0/vern/flex/RCS/flex.skl,v 2.91 96/09/10 16:58:48 vern Exp $
 */

#define FLEX_SCANNER
#define YY_FLEX_MAJOR_VERSION 2
#define YY_FLEX_MINOR_VERSION 5

#include <stdio.h>


/* cfront 1.2 defines "c_plusplus" instead of "__cplusplus" */
#ifdef c_plusplus
#ifndef __cplusplus
#define __cplusplus
#endif
#endif


#ifdef __cplusplus

#include <stdlib.h>
#ifndef _MSC_VER
  #include <unistd.h>
#endif

/* Use prototypes in function declarations. */
#define YY_USE_PROTOS

/* The "const" storage-class-modifier is valid. */
#define YY_USE_CONST

#else	/* ! __cplusplus */

#if __STDC__

#define YY_USE_PROTOS
#define YY_USE_CONST

#endif	/* __STDC__ */
#endif	/* ! __cplusplus */

#ifdef __TURBOC__
 #pragma warn -rch
 #pragma warn -use
#include <io.h>
#include <stdlib.h>
#define YY_USE_CONST
#define YY_USE_PROTOS
#endif

#ifdef YY_USE_CONST
#define yyconst const
#else
#define yyconst
#endif


#ifdef YY_USE_PROTOS
#define YY_PROTO(proto) proto
#else
#define YY_PROTO(proto) ()
#endif

/* Returned upon end-of-file. */
#define YY_NULL 0

/* Promotes a possibly negative, possibly signed char to an unsigned
 * integer for use as an array index.  If the signed char is negative,
 * we want to instead treat it as an 8-bit unsigned char, hence the
 * double cast.
 */
#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)

/* Enter a start condition.  This macro really ought to take a parameter,
 * but we do it the disgusting crufty way forced on us by the ()-less
 * definition of BEGIN.
 */
#define BEGIN yy_start = 1 + 2 *

/* Translate the current start state into a value that can be later handed
 * to BEGIN to return to the state.  The YYSTATE alias is for lex
 * compatibility.
 */
#define YY_START ((yy_start - 1) / 2)
#define YYSTATE YY_START

/* Action number for EOF rule of a given start state. */
#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)

/* Special action meaning "start processing a new file". */
#define YY_NEW_FILE yyrestart( yyin )

#define YY_END_OF_BUFFER_CHAR 0

/* Size of default input buffer. */
#define YY_BUF_SIZE 16384

typedef struct yy_buffer_state *YY_BUFFER_STATE;

extern int yyleng;
extern FILE *yyin, *yyout;

#define EOB_ACT_CONTINUE_SCAN 0
#define EOB_ACT_END_OF_FILE 1
#define EOB_ACT_LAST_MATCH 2

/* The funky do-while in the following #define is used to turn the definition
 * int a single C statement (which needs a semi-colon terminator).  This
 * avoids problems with code like:
 *
 * 	if ( condition_holds )
 *		yyless( 5 );
 *	else
 *		do_something_else();
 *
 * Prior to using the do-while the compiler would get upset at the
 * "else" because it interpreted the "if" statement as being all
 * done when it reached the ';' after the yyless() call.
 */

/* Return all but the first 'n' matched characters back to the input stream. */

#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
		*yy_cp = yy_hold_char; \
		YY_RESTORE_YY_MORE_OFFSET \
		yy_c_buf_p = yy_cp = yy_bp + n - YY_MORE_ADJ; \
		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
		} \
	while ( 0 )

#define unput(c) yyunput( c, yytext_ptr )

/* The following is because we cannot portably get our hands on size_t
 * (without autoconf's help, which isn't available because we want
 * flex-generated scanners to compile on their own).
 */
typedef unsigned int yy_size_t;


struct yy_buffer_state
	{
	FILE *yy_input_file;

	char *yy_ch_buf;		/* input buffer */
	char *yy_buf_pos;		/* current position in input buffer */

	/* Size of input buffer in bytes, not including room for EOB
	 * characters.
	 */
	yy_size_t yy_buf_size;

	/* Number of characters read into yy_ch_buf, not including EOB
	 * characters.
	 */
	int yy_n_chars;

	/* Whether we "own" the buffer - i.e., we know we created it,
	 * and can realloc() it to grow it, and should free() it to
	 * delete it.
	 */
	int yy_is_our_buffer;

	/* Whether this is an "interactive" input source; if so, and
	 * if we're using stdio for input, then we want to use getc()
	 * instead of fread(), to make sure we stop fetching input after
	 * each newline.
	 */
	int yy_is_interactive;

	/* Whether we're considered to be at the beginning of a line.
	 * If so, '^' rules will be active on the next match, otherwise
	 * not.
	 */
	int yy_at_bol;

	/* Whether to try to fill the input buffer when we reach the
	 * end of it.
	 */
	int yy_fill_buffer;

	int yy_buffer_status;
#define YY_BUFFER_NEW 0
#define YY_BUFFER_NORMAL 1
	/* When an EOF's been seen but there's still some text to process
	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
	 * shouldn't try reading from the input source any more.  We might
	 * still have a bunch of tokens to match, though, because of
	 * possible backing-up.
	 *
	 * When we actually see the EOF, we change the status to "new"
	 * (via yyrestart()), so that the user can continue scanning by
	 * just pointing yyin at a new input file.
	 */
#define YY_BUFFER_EOF_PENDING 2
	};

static YY_BUFFER_STATE yy_current_buffer = 0;

/* We provide macros for accessing buffer states in case in the
 * future we want to put the buffer states in a more general
 * "scanner state".
 */
#define YY_CURRENT_BUFFER yy_current_buffer


/* yy_hold_char holds the character lost when yytext is formed. */
static char yy_hold_char;

static int yy_n_chars;		/* number of characters read into yy_ch_buf */


int yyleng;

/* Points to current character in buffer. */
static char *yy_c_buf_p = (char *) 0;
static int yy_init = 1;		/* whether we need to initialize */
static int yy_start = 0;	/* start state number */

/* Flag which is used to allow yywrap()'s to do buffer switches
 * instead of setting up a fresh yyin.  A bit of a hack ...
 */
static int yy_did_buffer_switch_on_eof;

void yyrestart YY_PROTO(( FILE *input_file ));

void yy_switch_to_buffer YY_PROTO(( YY_BUFFER_STATE new_buffer ));
void yy_load_buffer_state YY_PROTO(( void ));
YY_BUFFER_STATE yy_create_buffer YY_PROTO(( FILE *file, int size ));
void yy_delete_buffer YY_PROTO(( YY_BUFFER_STATE b ));
void yy_init_buffer YY_PROTO(( YY_BUFFER_STATE b, FILE *file ));
void yy_flush_buffer YY_PROTO(( YY_BUFFER_STATE b ));
#define YY_FLUSH_BUFFER yy_flush_buffer( yy_current_buffer )

YY_BUFFER_STATE yy_scan_buffer YY_PROTO(( char *base, yy_size_t size ));
YY_BUFFER_STATE yy_scan_string YY_PROTO(( yyconst char *yy_str ));
YY_BUFFER_STATE yy_scan_bytes YY_PROTO(( yyconst char *bytes, int len ));

static void *yy_flex_alloc YY_PROTO(( yy_size_t ));
static void *yy_flex_realloc YY_PROTO(( void *, yy_size_t ));
static void yy_flex_free YY_PROTO(( void * ));

#define yy_new_buffer yy_create_buffer

#define yy_set_interactive(is_interactive) \
	{ \
	if ( ! yy_current_buffer ) \
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
	yy_current_buffer->yy_is_interactive = is_interactive; \
	}

#define yy_set_bol(at_bol) \
	{ \
	if ( ! yy_current_buffer ) \
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE ); \
	yy_current_buffer->yy_at_bol = at_bol; \
	}

#define YY_AT_BOL() (yy_current_buffer->yy_at_bol)


#define YY_USES_REJECT

#define yywrap() 1
#define YY_SKIP_YYWRAP
typedef unsigned char YY_CHAR;
FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
typedef int yy_state_type;
extern char *yytext;
#define yytext_ptr yytext

static yy_state_type yy_get_previous_state YY_PROTO(( void ));
static yy_state_type yy_try_NUL_trans YY_PROTO(( yy_state_type current_state ));
static int yy_get_next_buffer YY_PROTO(( void ));
static void yy_fatal_error YY_PROTO(( yyconst char msg[] ));

/* Done after the current pattern has been matched and before the
 * corresponding action - sets up yytext.
 */
#define YY_DO_BEFORE_ACTION \
	yytext_ptr = yy_bp; \
	yyleng = (int) (yy_cp - yy_bp); \
	yy_hold_char = *yy_cp; \
	*yy_cp = '\0'; \
	yy_c_buf_p = yy_cp;

#define YY_NUM_RULES 40
#define YY_END_OF_BUFFER 41
static yyconst short int yy_acclist[281] =
    {   0,
       37,   37,   41,   37,   39,   40,   38,   39,   40,    3,
       40,   39,   40,   37,   39,   40,   39,   40,   37,   39,
       40,   37,   39,   40,   39,   40,   34,   35,   37,   39,
       40,   34,   35,   37,   39,   40,   34,   35,   37,   39,
       40,   34,   35,   37,   39,   40,   33,   39,   40,   39,
       40,   37,   39,   40,   37,   39,   40,   37,   39,   40,
       37,   39,   40,   37,   39,   40,   17,   37,   39,   40,
       37,   39,   40,   37,   39,   40,   37,   39,   40,   18,
       37,   39,   40,   37,   37,   38,    1,    2,   37,   37,
       37,   37,   37,   37,   37,    2,   37,   34,   35,   37,

       37,   34,   35,   37,   34,   35,   37,   34,   37,   37,
       37,   37,   37,   37,   37,   37,   37,   17,   37,   37,
       37,   37,   37,   37,   37,   37,   37,   12,   13,   37,
        6,   37,   11,    5,   37,   37,   37,   35,   37,   35,
       37,   34,   37,   37,   37,   37,   37,   36,   37,   37,
       37,   15,   37,   37,   37,   37,   37,   37,   37,   37,
       25,   37,   37,   37,   37,   37,   37,   18,   37,   37,
       37,   37,   37,   37,   37,   37,   37,   37,   37,   37,
       37,   37,   37,   37,   37,   37,   30,   37,   27,   37,
       37,   37,   23,   37,   37,    8,   37,   37,   37,   37,

       27,   26,   37,   37,   37,   37,   37,   35,   37,   35,
       37,   37,   37,   37,   37,   37,   37,   37,   37,    9,
       37,    7,   37,   37,   37,   37,   37,   37,   37,   37,
       14,   37,   37,   37,   37,   37,   37,   37,   29,   37,
       32,   37,   37,   37,   29,   28,   37,   37,   37,   37,
       31,   37,   37,   37,   24,   37,   22,   37,   21,   37,
       19,   37,    4,   37,   37,   37,   10,   37,   37,   37,
       37,   37,   37,   37,   16,   37,   37,   37,   20,   37
    } ;

static yyconst short int yy_accept[198] =
    {   0,
        1,    2,    3,    4,    7,   10,   12,   14,   17,   19,
       22,   25,   27,   32,   37,   42,   47,   50,   52,   55,
       58,   61,   64,   67,   71,   74,   77,   80,   84,   85,
       86,   87,   88,   88,   88,   90,   91,   92,   93,   94,
       95,   96,   97,   98,  101,  102,  105,  108,  110,  111,
      112,  113,  114,  115,  116,  117,  118,  120,  121,  122,
      123,  124,  125,  126,  127,  128,  128,  128,  129,  130,
      131,  132,  133,  134,  135,  136,  137,  138,  140,  142,
      144,  145,  146,  147,  148,  150,  151,  152,  154,  155,
      156,  157,  158,  159,  160,  161,  163,  164,  165,  166,

      167,  168,  170,  170,  170,  171,  172,  173,  174,  175,
      176,  177,  178,  179,  180,  181,  182,  183,  184,  185,
      186,  187,  189,  191,  192,  193,  195,  196,  198,  199,
      200,  201,  202,  202,  204,  205,  206,  207,  208,  210,
      212,  213,  214,  215,  216,  217,  218,  219,  220,  222,
      224,  225,  226,  227,  227,  228,  229,  230,  231,  233,
      234,  235,  236,  237,  238,  239,  241,  243,  244,  245,
      246,  248,  249,  250,  251,  253,  254,  255,  257,  259,
      261,  263,  265,  266,  267,  269,  270,  271,  272,  273,
      274,  275,  277,  278,  279,  281,  281

    } ;

static yyconst YY_CHAR yy_ec[256] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
        1,    1,    4,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    2,    1,    1,    5,    1,    1,    1,    1,    1,
        1,    1,    6,    1,    7,    8,    9,   10,   11,   12,
       13,   13,   14,   15,   15,   15,   15,   16,    1,    1,
       17,    1,   18,    1,   20,    1,   21,   22,   23,   24,
       25,    1,   26,    1,   27,   28,   29,   30,   31,   32,
        1,   33,   34,   35,   36,   37,   38,   39,   40,    1,
        1,   19,    1,    1,    1,    1,   20,    1,   21,   22,

       23,   24,   25,    1,   26,    1,   27,   28,   29,   30,
       31,   32,    1,   33,   34,   35,   36,   37,   38,   39,
       40,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,

        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1
    } ;

static yyconst YY_CHAR yy_meta[41] =
    {   0,
        1,    2,    2,    2,    1,    2,    1,    1,    2,    1,
        1,    1,    1,    1,    1,    1,    2,    1,    2,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1
    } ;

static yyconst short int yy_base[198] =
    {   0,
        0,    0,  499,  490,  495,  500,  500,   38,   12,   39,
      488,  477,   68,   34,   40,   48,  500,  475,   37,   56,
       59,   48,   69,   62,   78,   80,   84,   88,  485,  484,
      489,  500,  455,  469,  479,   93,   97,   77,  100,  105,
      114,  500,  115,  121,  127,  133,  139,  145,  152,   96,
       64,  160,  161,  163,  162,  164,  478,  166,  168,  165,
       98,  172,  167,  169,  173,  457,  450,  500,  500,  171,
      500,  174,  500,  500,  201,  206,  214,  220,  179,  475,
      227,  235,  103,  241,  473,  236,  249,  472,  250,  176,
      251,  177,  253,  254,  175,  471,  256,  258,  257,  259,

      261,  470,  448,  441,  255,  260,  285,  459,  465,  291,
      297,  207,  305,  464,  265,  306,  267,  312,  313,  314,
      315,  463,  462,  316,  317,  461,  318,  459,  319,  320,
      321,  500,  428,  457,  322,  353,  271,  359,  365,  456,
      323,  264,  326,  328,  330,  351,  336,  335,  454,  421,
      374,  375,  376,  401,  377,  376,  384,  405,  344,  385,
      392,  393,  396,  397,  398,  341,  339,  399,  401,  500,
      338,  407,  425,  431,  334,  402,  407,  333,  273,  271,
      440,  268,  441,  211,  180,  404,  442,  448,  422,  450,
      406,  170,  451,  453,  113,  500,   42

    } ;

static yyconst short int yy_def[198] =
    {   0,
      196,    1,  196,  197,  196,  196,  196,  197,  196,  197,
      197,  196,  197,   13,   13,   13,  196,  196,  197,  197,
      197,  197,  197,  197,  197,  197,  197,  197,  197,  197,
      196,  196,  196,  196,  197,  197,  197,  197,  197,  197,
      197,  196,  197,   13,   43,   13,   13,   13,   43,  197,
      197,  197,  197,  197,  197,  197,  197,  197,  197,  197,
      197,  197,  197,  197,  197,  196,  196,  196,  196,  197,
      196,  197,  196,  196,   43,   43,   43,   43,  197,   48,
       43,   43,   82,   82,  197,  197,  197,  197,  197,  197,
      197,  197,  197,  197,  197,  197,  197,  197,  197,  197,

      197,  197,  196,  196,  197,  197,   43,   77,  197,   43,
       78,  197,  197,  197,  197,  197,  197,  197,  197,  197,
      197,  197,  197,  197,  197,  197,  197,  197,  197,  197,
      197,  196,  196,  197,  197,  197,  136,  136,   43,  197,
      197,  197,  197,  197,  197,  197,  197,  197,  197,  197,
      197,  197,  197,  196,  197,   43,  197,  197,  197,  197,
      197,  197,  197,  197,  197,  197,  197,  197,  197,  196,
      197,   43,   43,   43,  197,  197,  197,  197,  197,  197,
      197,  197,  197,  197,  197,  197,  197,  197,  197,  197,
      197,  197,  197,  197,  197,    0,  196

    } ;

static yyconst short int yy_nxt[541] =
    {   0,
        4,    5,    6,    7,    8,    9,   10,   11,   12,   13,
       13,   14,   15,   15,   16,    4,   17,    4,   18,   19,
       20,   21,    4,    4,    4,    4,   22,    4,   23,   24,
        4,   25,    4,   26,   27,    4,    4,    4,    4,   28,
       32,   33,   29,   34,   30,   30,   30,   46,   47,   47,
       47,   47,   47,   47,   47,   30,   35,   48,   48,   48,
       48,   48,   48,   30,   50,   36,   30,   37,   38,   30,
       39,   30,   40,   54,   41,   43,   30,   44,   44,   44,
       44,   44,   44,   45,   30,   30,   51,   30,   55,   53,
       52,   30,   57,   86,   68,   30,   58,   59,   69,   56,

       30,   71,   61,   30,   30,   30,   73,   30,   60,   63,
       65,   70,   30,   64,   62,   74,  113,  114,   96,   72,
       30,   30,   30,   85,   75,   75,   76,   77,   77,   77,
       48,   48,   48,   48,   48,   48,   78,   78,   78,   78,
       78,   79,   48,   48,   48,   48,   48,   80,   80,   80,
       80,   80,   80,   80,   80,   80,   80,   80,   80,   80,
       81,   82,   82,   83,   84,   84,   84,   30,   30,   30,
       30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
       30,   30,   30,   30,   30,   91,   30,   30,  101,   88,
       89,   97,   87,   92,  110,  100,  120,   95,  105,  121,

       90,   93,   98,   94,   99,  123,  102,  106,  107,  126,
       77,   77,   77,  107,   30,   77,   77,   77,   30,  108,
      109,  107,  110,  109,  109,  109,  109,  109,  109,   79,
       79,   79,   79,   79,   79,  110,  111,  111,  111,  111,
      111,  112,   43,   30,   84,   84,   84,   84,   84,   84,
      114,  114,  114,  114,  114,  114,   30,   30,   30,  115,
       30,   30,   30,   30,   30,   30,   30,   30,   30,  116,
      117,   30,   30,  122,   30,   30,  118,  119,   30,  129,
       30,  130,  131,  134,  157,  158,  124,  125,  127,  128,
      141,  160,  143,  135,  136,  136,  137,  138,  138,  138,

      139,  139,  139,  139,  139,  140,  112,  112,  112,  112,
      112,  112,   43,   30,  114,  114,  114,  114,  114,   30,
       30,   30,   30,   30,   30,   30,   30,   30,   30,   30,
       30,  144,  145,   30,  147,   30,  142,   30,  151,  149,
       30,   30,   30,   30,  146,   30,   30,  159,   30,  153,
      152,   30,  150,  148,  162,  161,  166,  163,   30,  155,
      156,  165,  138,  138,  138,  138,  138,  138,  158,  158,
      158,  158,  158,  158,  140,  140,  140,  140,  140,  140,
      164,   30,   30,   30,   30,  172,  172,  173,  174,  174,
      174,  156,   30,  158,  158,  158,  158,  158,  171,   30,

       30,  169,  167,   30,   30,   30,   30,  175,   30,   30,
      168,   30,  156,   30,   30,  177,  174,  174,  174,  174,
      174,  174,  170,  178,  185,  180,  179,  176,   30,   30,
      182,  193,  188,  181,  174,  174,  174,  174,  183,  184,
      184,  184,  184,  184,  184,  184,  186,   30,   30,   30,
      184,  184,  184,  184,  184,   30,  191,   30,   30,  187,
       30,   30,  189,   30,   30,  154,   30,  190,   30,   30,
       30,   43,  107,   29,  133,  195,  132,   30,   30,   30,
       30,  192,   30,  104,  103,   30,   30,  194,   67,   66,
       31,   30,   30,   49,   42,   30,   31,   30,  196,    3,

      196,  196,  196,  196,  196,  196,  196,  196,  196,  196,
      196,  196,  196,  196,  196,  196,  196,  196,  196,  196,
      196,  196,  196,  196,  196,  196,  196,  196,  196,  196,
      196,  196,  196,  196,  196,  196,  196,  196,  196,  196
    } ;

static yyconst short int yy_chk[541] =
    {   0,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
        8,    9,  197,    9,   19,    8,   10,   14,   14,   15,
       15,   15,   15,   15,   15,   22,   10,   16,   16,   16,
       16,   16,   16,   20,   19,   10,   21,   10,   10,   24,
       10,   51,   10,   22,   10,   13,   23,   13,   13,   13,
       13,   13,   13,   13,   38,   25,   20,   26,   23,   21,
       20,   27,   24,   51,   36,   28,   24,   25,   37,   23,

       36,   39,   26,   50,   37,   61,   40,   39,   25,   27,
       28,   38,   40,   27,   26,   41,   83,   83,   61,   39,
      195,   41,   43,   50,   43,   43,   43,   43,   43,   43,
       44,   44,   44,   44,   44,   44,   45,   45,   45,   45,
       45,   45,   46,   46,   46,   46,   46,   46,   47,   47,
       47,   47,   47,   47,   48,   48,   48,   48,   48,   48,
       48,   49,   49,   49,   49,   49,   49,   52,   53,   55,
       54,   56,   60,   58,   63,   59,   64,  192,   70,   62,
       65,   72,   95,   90,   92,   56,   79,  185,   64,   53,
       54,   62,   52,   58,   79,   63,   90,   60,   70,   90,

       55,   59,   62,   59,   62,   92,   65,   72,   75,   95,
       75,   75,   75,   76,  112,   76,   76,   76,  184,   76,
       76,   77,  112,   77,   77,   77,   77,   77,   77,   78,
       78,   78,   78,   78,   78,   78,   81,   81,   81,   81,
       81,   81,   82,   86,   82,   82,   82,   82,   82,   82,
       84,   84,   84,   84,   84,   84,   87,   89,   91,   86,
       93,   94,  105,   97,   99,   98,  100,  106,  101,   86,
       86,  142,  115,   91,  117,  182,   87,   89,  180,   99,
      179,  100,  101,  105,  137,  137,   93,   94,   97,   98,
      115,  142,  117,  106,  107,  107,  107,  107,  107,  107,

      110,  110,  110,  110,  110,  110,  111,  111,  111,  111,
      111,  111,  113,  116,  113,  113,  113,  113,  113,  118,
      119,  120,  121,  124,  125,  127,  129,  130,  131,  135,
      141,  118,  119,  143,  121,  144,  116,  145,  129,  125,
      178,  175,  148,  147,  120,  171,  167,  141,  166,  131,
      130,  159,  127,  124,  144,  143,  148,  145,  146,  135,
      136,  147,  136,  136,  136,  136,  136,  136,  138,  138,
      138,  138,  138,  138,  139,  139,  139,  139,  139,  139,
      146,  151,  152,  153,  155,  156,  156,  156,  156,  156,
      156,  157,  160,  157,  157,  157,  157,  157,  155,  161,

      162,  153,  151,  163,  164,  165,  168,  160,  169,  176,
      152,  186,  158,  191,  177,  162,  172,  172,  172,  172,
      172,  172,  154,  163,  176,  165,  164,  161,  150,  189,
      169,  191,  186,  168,  173,  173,  173,  173,  173,  173,
      174,  174,  174,  174,  174,  174,  177,  181,  183,  187,
      183,  183,  183,  183,  183,  188,  189,  190,  193,  181,
      194,  149,  187,  140,  134,  133,  128,  188,  126,  123,
      122,  114,  109,  108,  104,  194,  103,  102,   96,   88,
       85,  190,   80,   67,   66,   57,   35,  193,   34,   33,
       31,   30,   29,   18,   12,   11,    5,    4,    3,  196,

      196,  196,  196,  196,  196,  196,  196,  196,  196,  196,
      196,  196,  196,  196,  196,  196,  196,  196,  196,  196,
      196,  196,  196,  196,  196,  196,  196,  196,  196,  196,
      196,  196,  196,  196,  196,  196,  196,  196,  196,  196
    } ;

static yy_state_type yy_state_buf[YY_BUF_SIZE + 2], *yy_state_ptr;
static char *yy_full_match;
static int yy_lp;
#define REJECT \
{ \
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */ \
yy_cp = yy_full_match; /* restore poss. backed-over text */ \
++yy_lp; \
goto find_rule; \
}
#define yymore() yymore_used_but_not_detected
#define YY_MORE_ADJ 0
#define YY_RESTORE_YY_MORE_OFFSET
char *yytext;
#line 1 "tnadmin.l"
#define INITIAL 0
/*------------------------------------------------------------------
   Copyright (c) 1998-1999 Microsoft Corporation

   tnadmin.l generates tnadminl.c (using flex)

   vikram (vikram_krc@bigfoot.com)

   This lex file recognises tokens in the command line and passes it to the
   command line parser.(tnadmin.y)
-----------------------------------------------------------------*/
#line 13 "tnadmin.l"
   #include <string.h>
   #include <stdlib.h>
   #include "tnadminy.h"

   #define YY_NEVER_INTERACTIVE 1
   #define fileno _fileno 
   #define strdup _strdup

   int nMoccur=-1;
   char **filelist;
   int currentfile=1;

//between yacc and lex
   int g_fMessage=0;
   int g_fComp=1;
   int g_fNormal=1;
   char * szCompname=NULL;
   
#line 619 "tnadminl.c"

/* Macros after this point can all be overridden by user definitions in
 * section 1.
 */

#ifndef YY_SKIP_YYWRAP
#ifdef __cplusplus
extern "C" int yywrap YY_PROTO(( void ));
#else
extern int yywrap YY_PROTO(( void ));
#endif
#endif

#ifndef YY_NO_UNPUT
static void yyunput YY_PROTO(( int c, char *buf_ptr ));
#endif

#ifndef yytext_ptr
static void yy_flex_strncpy YY_PROTO(( char *, yyconst char *, int ));
#endif

#ifdef YY_NEED_STRLEN
static int yy_flex_strlen YY_PROTO(( yyconst char * ));
#endif

#ifndef YY_NO_INPUT
#ifdef __cplusplus
static int yyinput YY_PROTO(( void ));
#else
static int input YY_PROTO(( void ));
#endif
#endif

#if YY_STACK_USED
static int yy_start_stack_ptr = 0;
static int yy_start_stack_depth = 0;
static int *yy_start_stack = 0;
#ifndef YY_NO_PUSH_STATE
static void yy_push_state YY_PROTO(( int new_state ));
#endif
#ifndef YY_NO_POP_STATE
static void yy_pop_state YY_PROTO(( void ));
#endif
#ifndef YY_NO_TOP_STATE
static int yy_top_state YY_PROTO(( void ));
#endif

#else
#define YY_NO_PUSH_STATE 1
#define YY_NO_POP_STATE 1
#define YY_NO_TOP_STATE 1
#endif

#ifdef YY_MALLOC_DECL
YY_MALLOC_DECL
#else
#if __STDC__
#ifndef __cplusplus
#include <stdlib.h>
#endif
#else
/* Just try to get by without declaring the routines.  This will fail
 * miserably on non-ANSI systems for which sizeof(size_t) != sizeof(int)
 * or sizeof(void*) != sizeof(int).
 */
#endif
#endif

/* Amount of stuff to slurp up with each read. */
#ifndef YY_READ_BUF_SIZE
#define YY_READ_BUF_SIZE 8192
#endif

/* Copy whatever the last rule matched to the standard output. */

#ifndef ECHO
/* This used to be an fputs(), but since the string might contain NUL's,
 * we now use fwrite().
 */
#define ECHO (void) fwrite( yytext, yyleng, 1, yyout )
#endif

/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
 * is returned in "result".
 */
#ifndef YY_INPUT
#define YY_INPUT(buf,result,max_size) \
	if ( yy_current_buffer->yy_is_interactive ) \
		{ \
		int c = '*', n; \
		for ( n = 0; n < max_size && \
			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
			buf[n] = (char) c; \
		if ( c == '\n' ) \
			buf[n++] = (char) c; \
		if ( c == EOF && ferror( yyin ) ) \
			YY_FATAL_ERROR( "input in flex scanner failed" ); \
		result = n; \
		} \
	else if ( ((result = fread( buf, 1, max_size, yyin )) == 0) \
		  && ferror( yyin ) ) \
		YY_FATAL_ERROR( "input in flex scanner failed" );
#endif

/* No semi-colon after return; correct usage is to write "yyterminate();" -
 * we don't want an extra ';' after the "return" because that will cause
 * some compilers to complain about unreachable statements.
 */
#ifndef yyterminate
#define yyterminate() return YY_NULL
#endif

/* Number of entries by which start-condition stack grows. */
#ifndef YY_START_STACK_INCR
#define YY_START_STACK_INCR 25
#endif

/* Report a fatal error. */
#ifndef YY_FATAL_ERROR
#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
#endif

/* Default declaration of generated scanner - a define so the user can
 * easily add parameters.
 */
#ifndef YY_DECL
#define YY_DECL int yylex YY_PROTO(( void ))
#endif

/* Code executed at the beginning of each rule, after yytext and yyleng
 * have been set up.
 */
#ifndef YY_USER_ACTION
#define YY_USER_ACTION
#endif

/* Code executed at the end of each rule. */
#ifndef YY_BREAK
#define YY_BREAK break;
#endif

#define YY_RULE_SETUP \
	YY_USER_ACTION

YY_DECL
	{
	register yy_state_type yy_current_state;
	register char *yy_cp, *yy_bp;
	register int yy_act;

#line 54 "tnadmin.l"


#line 773 "tnadminl.c"

	if ( yy_init )
		{
		yy_init = 0;

#ifdef YY_USER_INIT
		YY_USER_INIT;
#endif

		if ( ! yy_start )
			yy_start = 1;	/* first start state */

		if ( ! yyin )
			yyin = stdin;

		if ( ! yyout )
			yyout = stdout;

		if ( ! yy_current_buffer )
			yy_current_buffer =
				yy_create_buffer( yyin, YY_BUF_SIZE );

		yy_load_buffer_state();
		}

	while ( 1 )		/* loops until end-of-file is reached */
		{
		yy_cp = yy_c_buf_p;

		/* Support of yytext. */
		*yy_cp = yy_hold_char;

		/* yy_bp points to the position in yy_ch_buf of the start of
		 * the current run.
		 */
		yy_bp = yy_cp;

		yy_current_state = yy_start;
		yy_state_ptr = yy_state_buf;
		*yy_state_ptr++ = yy_current_state;
yy_match:
		do
			{
			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
				{
				yy_current_state = (int) yy_def[yy_current_state];
				if ( yy_current_state >= 197 )
					yy_c = yy_meta[(unsigned int) yy_c];
				}
			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
			*yy_state_ptr++ = yy_current_state;
			++yy_cp;
			}
		while ( yy_base[yy_current_state] != 500 );

yy_find_action:
		yy_current_state = *--yy_state_ptr;
		yy_lp = yy_accept[yy_current_state];
find_rule: /* we branch to this label when backing up */
		for ( ; ; ) /* until we find what rule we matched */
			{
			if ( yy_lp && yy_lp < yy_accept[yy_current_state + 1] )
				{
				yy_act = yy_acclist[yy_lp];
					{
					yy_full_match = yy_cp;
					break;
					}
				}
			--yy_cp;
			yy_current_state = *--yy_state_ptr;
			yy_lp = yy_accept[yy_current_state];
			}

		YY_DO_BEFORE_ACTION;


do_action:	/* This label is used only to access EOF actions. */


		switch ( yy_act )
	{ /* beginning of action switch */
case 1:
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
yy_c_buf_p = yy_cp = yy_bp + 1;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 56 "tnadmin.l"
{return _ENDINPUT;}
	YY_BREAK
case 2:
YY_RULE_SETUP
#line 57 "tnadmin.l"
{if(g_fNormal==0)REJECT;return _HELP;}
	YY_BREAK
case YY_STATE_EOF(INITIAL):
#line 58 "tnadmin.l"
{return 0;}
	YY_BREAK
case 3:
YY_RULE_SETUP
#line 59 "tnadmin.l"
{return(0);}
	YY_BREAK
case 4:
YY_RULE_SETUP
#line 60 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_TNADMIN);}
	YY_BREAK
case 5:
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
yy_c_buf_p = yy_cp = yy_bp + 2;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 61 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_tU);}
	YY_BREAK
case 6:
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
yy_c_buf_p = yy_cp = yy_bp + 2;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 62 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_tP);}
	YY_BREAK
case 7:
YY_RULE_SETUP
#line 63 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_START);}
	YY_BREAK
case 8:
YY_RULE_SETUP
#line 64 "tnadmin.l"
{if(g_fNormal==0)REJECT;return( _STOP);}
	YY_BREAK
case 9:
YY_RULE_SETUP
#line 65 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_PAUSE);}
	YY_BREAK
case 10:
YY_RULE_SETUP
#line 66 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_CONTINUE);}
	YY_BREAK
case 11:
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
yy_c_buf_p = yy_cp = yy_bp + 2;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 67 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_S);}
	YY_BREAK
case 12:
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
yy_c_buf_p = yy_cp = yy_bp + 2;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 68 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_K);}
	YY_BREAK
case 13:
*yy_cp = yy_hold_char; /* undo effects of setting up yytext */
yy_c_buf_p = yy_cp = yy_bp + 2;
YY_DO_BEFORE_ACTION; /* set up yytext again */
YY_RULE_SETUP
#line 69 "tnadmin.l"
{if(g_fNormal==0)REJECT;nMoccur=0;return(_M);}
	YY_BREAK
case 14:
YY_RULE_SETUP
#line 70 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_CONFIG);}
	YY_BREAK
case 15:
YY_RULE_SETUP
#line 71 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_DOM);}
	YY_BREAK
case 16:
YY_RULE_SETUP
#line 72 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_CTRLKEYMAP);}
	YY_BREAK
case 17:
YY_RULE_SETUP
#line 73 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_N);}
	YY_BREAK
case 18:
YY_RULE_SETUP
#line 74 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_Y);}
	YY_BREAK
case 19:
YY_RULE_SETUP
#line 75 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_TIMEOUT);}
	YY_BREAK
case 20:
YY_RULE_SETUP
#line 76 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_TIMEOUTACTIVE);}
	YY_BREAK
case 21:
YY_RULE_SETUP
#line 77 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_MAXFAIL);}
	YY_BREAK
case 22:
YY_RULE_SETUP
#line 78 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_MAXCONN);}
	YY_BREAK
case 23:
YY_RULE_SETUP
#line 79 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_PORT);}
	YY_BREAK
case 24:
YY_RULE_SETUP
#line 80 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_KILLALL);}
	YY_BREAK
case 25:
YY_RULE_SETUP
#line 81 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_SEC);}
	YY_BREAK
case 26:
YY_RULE_SETUP
#line 82 "tnadmin.l"
{if(g_fNormal==0)REJECT;return _MINUSNTLM;}
	YY_BREAK
case 27:
YY_RULE_SETUP
#line 83 "tnadmin.l"
{if(g_fNormal==0)REJECT;return _PLUSNTLM;}
	YY_BREAK
case 28:
YY_RULE_SETUP
#line 84 "tnadmin.l"
{if(g_fNormal==0)REJECT;return _MINUSPASSWD;}
	YY_BREAK
case 29:
YY_RULE_SETUP
#line 85 "tnadmin.l"
{if(g_fNormal==0)REJECT;return _PLUSPASSWD;}
	YY_BREAK
case 30:
YY_RULE_SETUP
#line 86 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_MODE);}
	YY_BREAK
case 31:
YY_RULE_SETUP
#line 87 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_CONSOLE);}
	YY_BREAK
case 32:
YY_RULE_SETUP
#line 88 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_STREAM);}
	YY_BREAK
case 33:
YY_RULE_SETUP
#line 89 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_EQ);}
	YY_BREAK
case 34:
YY_RULE_SETUP
#line 90 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_INTEGER);}
	YY_BREAK
case 35:
YY_RULE_SETUP
#line 91 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_TIME);}
	YY_BREAK
case 36:
YY_RULE_SETUP
#line 92 "tnadmin.l"
{if(g_fNormal==0)REJECT;return(_SESID);}
	YY_BREAK
case 37:
YY_RULE_SETUP
#line 93 "tnadmin.l"
{if(g_fComp==0)
                REJECT;
               szCompname=strdup(yytext);return(_COMPNAME);}
	YY_BREAK
case 38:
YY_RULE_SETUP
#line 96 "tnadmin.l"
{}
	YY_BREAK
case 39:
YY_RULE_SETUP
#line 97 "tnadmin.l"
{return _DUNNO;}
	YY_BREAK
case 40:
YY_RULE_SETUP
#line 98 "tnadmin.l"
ECHO;
	YY_BREAK
#line 1081 "tnadminl.c"

	case YY_END_OF_BUFFER:
		{
		/* Amount of text matched not including the EOB char. */
		int yy_amount_of_matched_text = (int) (yy_cp - yytext_ptr) - 1;

		/* Undo the effects of YY_DO_BEFORE_ACTION. */
		*yy_cp = yy_hold_char;
		YY_RESTORE_YY_MORE_OFFSET

		if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_NEW )
			{
			/* We're scanning a new file or input source.  It's
			 * possible that this happened because the user
			 * just pointed yyin at a new source and called
			 * yylex().  If so, then we have to assure
			 * consistency between yy_current_buffer and our
			 * globals.  Here is the right place to do so, because
			 * this is the first action (other than possibly a
			 * back-up) that will match for the new input source.
			 */
			yy_n_chars = yy_current_buffer->yy_n_chars;
			yy_current_buffer->yy_input_file = yyin;
			yy_current_buffer->yy_buffer_status = YY_BUFFER_NORMAL;
			}

		/* Note that here we test for yy_c_buf_p "<=" to the position
		 * of the first EOB in the buffer, since yy_c_buf_p will
		 * already have been incremented past the NUL character
		 * (since all states make transitions on EOB to the
		 * end-of-buffer state).  Contrast this with the test
		 * in input().
		 */
		if ( yy_c_buf_p <= &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			{ /* This was really a NUL. */
			yy_state_type yy_next_state;

			yy_c_buf_p = yytext_ptr + yy_amount_of_matched_text;

			yy_current_state = yy_get_previous_state();

			/* Okay, we're now positioned to make the NUL
			 * transition.  We couldn't have
			 * yy_get_previous_state() go ahead and do it
			 * for us because it doesn't know how to deal
			 * with the possibility of jamming (and we don't
			 * want to build jamming into it because then it
			 * will run more slowly).
			 */

			yy_next_state = yy_try_NUL_trans( yy_current_state );

			yy_bp = yytext_ptr + YY_MORE_ADJ;

			if ( yy_next_state )
				{
				/* Consume the NUL. */
				yy_cp = ++yy_c_buf_p;
				yy_current_state = yy_next_state;
				goto yy_match;
				}

			else
				{
				yy_cp = yy_c_buf_p;
				goto yy_find_action;
				}
			}

		else switch ( yy_get_next_buffer() )
			{
			case EOB_ACT_END_OF_FILE:
				{
				yy_did_buffer_switch_on_eof = 0;

				if ( yywrap() )
					{
					/* Note: because we've taken care in
					 * yy_get_next_buffer() to have set up
					 * yytext, we can now set up
					 * yy_c_buf_p so that if some total
					 * hoser (like flex itself) wants to
					 * call the scanner after we return the
					 * YY_NULL, it'll still work - another
					 * YY_NULL will get returned.
					 */
					yy_c_buf_p = yytext_ptr + YY_MORE_ADJ;

					yy_act = YY_STATE_EOF(YY_START);
					goto do_action;
					}

				else
					{
					if ( ! yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
					}
				break;
				}

			case EOB_ACT_CONTINUE_SCAN:
				yy_c_buf_p =
					yytext_ptr + yy_amount_of_matched_text;

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_match;

			case EOB_ACT_LAST_MATCH:
				yy_c_buf_p =
				&yy_current_buffer->yy_ch_buf[yy_n_chars];

				yy_current_state = yy_get_previous_state();

				yy_cp = yy_c_buf_p;
				yy_bp = yytext_ptr + YY_MORE_ADJ;
				goto yy_find_action;
			}
		break;
		}

	default:
		YY_FATAL_ERROR(
			"fatal flex scanner internal error--no action found" );
	} /* end of action switch */
		} /* end of scanning one token */
	} /* end of yylex */


/* yy_get_next_buffer - try to read in a new buffer
 *
 * Returns a code representing an action:
 *	EOB_ACT_LAST_MATCH -
 *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
 *	EOB_ACT_END_OF_FILE - end of file
 */

static int yy_get_next_buffer()
	{
	register char *dest = yy_current_buffer->yy_ch_buf;
	register char *source = yytext_ptr;
	register int number_to_move, i;
	int ret_val;

	if ( yy_c_buf_p > &yy_current_buffer->yy_ch_buf[yy_n_chars + 1] )
		YY_FATAL_ERROR(
		"fatal flex scanner internal error--end of buffer missed" );

	if ( yy_current_buffer->yy_fill_buffer == 0 )
		{ /* Don't try to fill the buffer, so this is an EOF. */
		if ( yy_c_buf_p - yytext_ptr - YY_MORE_ADJ == 1 )
			{
			/* We matched a single character, the EOB, so
			 * treat this as a final EOF.
			 */
			return EOB_ACT_END_OF_FILE;
			}

		else
			{
			/* We matched some text prior to the EOB, first
			 * process it.
			 */
			return EOB_ACT_LAST_MATCH;
			}
		}

	/* Try to read more data. */

	/* First move last chars to start of buffer. */
	number_to_move = (int) (yy_c_buf_p - yytext_ptr) - 1;

	for ( i = 0; i < number_to_move; ++i )
		*(dest++) = *(source++);

	if ( yy_current_buffer->yy_buffer_status == YY_BUFFER_EOF_PENDING )
		/* don't do the read, it's not guaranteed to return an EOF,
		 * just force an EOF
		 */
		yy_current_buffer->yy_n_chars = yy_n_chars = 0;

	else
		{
		int num_to_read =
			yy_current_buffer->yy_buf_size - number_to_move - 1;

		while ( num_to_read <= 0 )
			{ /* Not enough room in the buffer - grow it. */
#ifdef YY_USES_REJECT
			YY_FATAL_ERROR(
"input buffer overflow, can't enlarge buffer because scanner uses REJECT" );
#else

			/* just a shorter name for the current buffer */
			YY_BUFFER_STATE b = yy_current_buffer;

			int yy_c_buf_p_offset =
				(int) (yy_c_buf_p - b->yy_ch_buf);

			if ( b->yy_is_our_buffer )
				{
				int new_size = b->yy_buf_size * 2;

				if ( new_size <= 0 )
					b->yy_buf_size += b->yy_buf_size / 8;
				else
					b->yy_buf_size *= 2;

				b->yy_ch_buf = (char *)
					/* Include room in for 2 EOB chars. */
					yy_flex_realloc( (void *) b->yy_ch_buf,
							 b->yy_buf_size + 2 );
				}
			else
				/* Can't grow it, we don't own it. */
				b->yy_ch_buf = 0;

			if ( ! b->yy_ch_buf )
				YY_FATAL_ERROR(
				"fatal error - scanner input buffer overflow" );

			yy_c_buf_p = &b->yy_ch_buf[yy_c_buf_p_offset];

			num_to_read = yy_current_buffer->yy_buf_size -
						number_to_move - 1;
#endif
			}

		if ( num_to_read > YY_READ_BUF_SIZE )
			num_to_read = YY_READ_BUF_SIZE;

		/* Read in more data. */
		YY_INPUT( (&yy_current_buffer->yy_ch_buf[number_to_move]),
			yy_n_chars, num_to_read );

		yy_current_buffer->yy_n_chars = yy_n_chars;
		}

	if ( yy_n_chars == 0 )
		{
		if ( number_to_move == YY_MORE_ADJ )
			{
			ret_val = EOB_ACT_END_OF_FILE;
			yyrestart( yyin );
			}

		else
			{
			ret_val = EOB_ACT_LAST_MATCH;
			yy_current_buffer->yy_buffer_status =
				YY_BUFFER_EOF_PENDING;
			}
		}

	else
		ret_val = EOB_ACT_CONTINUE_SCAN;

	yy_n_chars += number_to_move;
	yy_current_buffer->yy_ch_buf[yy_n_chars] = YY_END_OF_BUFFER_CHAR;
	yy_current_buffer->yy_ch_buf[yy_n_chars + 1] = YY_END_OF_BUFFER_CHAR;

	yytext_ptr = &yy_current_buffer->yy_ch_buf[0];

	return ret_val;
	}


/* yy_get_previous_state - get the state just before the EOB char was reached */

static yy_state_type yy_get_previous_state()
	{
	register yy_state_type yy_current_state;
	register char *yy_cp;

	yy_current_state = yy_start;
	yy_state_ptr = yy_state_buf;
	*yy_state_ptr++ = yy_current_state;

	for ( yy_cp = yytext_ptr + YY_MORE_ADJ; yy_cp < yy_c_buf_p; ++yy_cp )
		{
		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
			{
			yy_current_state = (int) yy_def[yy_current_state];
			if ( yy_current_state >= 197 )
				yy_c = yy_meta[(unsigned int) yy_c];
			}
		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
		*yy_state_ptr++ = yy_current_state;
		}

	return yy_current_state;
	}


/* yy_try_NUL_trans - try to make a transition on the NUL character
 *
 * synopsis
 *	next_state = yy_try_NUL_trans( current_state );
 */

#ifdef YY_USE_PROTOS
static yy_state_type yy_try_NUL_trans( yy_state_type yy_current_state )
#else
static yy_state_type yy_try_NUL_trans( yy_current_state )
yy_state_type yy_current_state;
#endif
	{
	register int yy_is_jam;

	register YY_CHAR yy_c = 1;
	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
		{
		yy_current_state = (int) yy_def[yy_current_state];
		if ( yy_current_state >= 197 )
			yy_c = yy_meta[(unsigned int) yy_c];
		}
	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
	yy_is_jam = (yy_current_state == 196);
	if ( ! yy_is_jam )
		*yy_state_ptr++ = yy_current_state;

	return yy_is_jam ? 0 : yy_current_state;
	}


#ifndef YY_NO_UNPUT
#ifdef YY_USE_PROTOS
static void yyunput( int c, register char *yy_bp )
#else
static void yyunput( c, yy_bp )
int c;
register char *yy_bp;
#endif
	{
	register char *yy_cp = yy_c_buf_p;

	/* undo effects of setting up yytext */
	*yy_cp = yy_hold_char;

	if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
		{ /* need to shift things up to make room */
		/* +2 for EOB chars. */
		register int number_to_move = yy_n_chars + 2;
		register char *dest = &yy_current_buffer->yy_ch_buf[
					yy_current_buffer->yy_buf_size + 2];
		register char *source =
				&yy_current_buffer->yy_ch_buf[number_to_move];

		while ( source > yy_current_buffer->yy_ch_buf )
			*--dest = *--source;

		yy_cp += (int) (dest - source);
		yy_bp += (int) (dest - source);
		yy_current_buffer->yy_n_chars =
			yy_n_chars = yy_current_buffer->yy_buf_size;

		if ( yy_cp < yy_current_buffer->yy_ch_buf + 2 )
			YY_FATAL_ERROR( "flex scanner push-back overflow" );
		}

	*--yy_cp = (char) c;


	yytext_ptr = yy_bp;
	yy_hold_char = *yy_cp;
	yy_c_buf_p = yy_cp;
	}
#endif	/* ifndef YY_NO_UNPUT */


#ifdef __cplusplus
static int yyinput()
#else
static int input()
#endif
	{
	int c;

	*yy_c_buf_p = yy_hold_char;

	if ( *yy_c_buf_p == YY_END_OF_BUFFER_CHAR )
		{
		/* yy_c_buf_p now points to the character we want to return.
		 * If this occurs *before* the EOB characters, then it's a
		 * valid NUL; if not, then we've hit the end of the buffer.
		 */
		if ( yy_c_buf_p < &yy_current_buffer->yy_ch_buf[yy_n_chars] )
			/* This was really a NUL. */
			*yy_c_buf_p = '\0';

		else
			{ /* need more input */
			int offset = (int)(yy_c_buf_p - yytext_ptr);
			++yy_c_buf_p;

			switch ( yy_get_next_buffer() )
				{
				case EOB_ACT_LAST_MATCH:
					/* This happens because yy_g_n_b()
					 * sees that we've accumulated a
					 * token and flags that we need to
					 * try matching the token before
					 * proceeding.  But for input(),
					 * there's no matching to consider.
					 * So convert the EOB_ACT_LAST_MATCH
					 * to EOB_ACT_END_OF_FILE.
					 */

					/* Reset buffer status. */
					yyrestart( yyin );

					/* fall through */

				case EOB_ACT_END_OF_FILE:
					{
					if ( yywrap() )
						return EOF;

					if ( ! yy_did_buffer_switch_on_eof )
						YY_NEW_FILE;
#ifdef __cplusplus
					return yyinput();
#else
					return input();
#endif
					}

				case EOB_ACT_CONTINUE_SCAN:
					yy_c_buf_p = yytext_ptr + offset;
					break;
				}
			}
		}

	c = *(unsigned char *) yy_c_buf_p;	/* cast for 8-bit char's */
	*yy_c_buf_p = '\0';	/* preserve yytext */
	yy_hold_char = *++yy_c_buf_p;


	return c;
	}


#ifdef YY_USE_PROTOS
void yyrestart( FILE *input_file )
#else
void yyrestart( input_file )
FILE *input_file;
#endif
	{
	if ( ! yy_current_buffer )
		yy_current_buffer = yy_create_buffer( yyin, YY_BUF_SIZE );

	yy_init_buffer( yy_current_buffer, input_file );
	yy_load_buffer_state();
	}


#ifdef YY_USE_PROTOS
void yy_switch_to_buffer( YY_BUFFER_STATE new_buffer )
#else
void yy_switch_to_buffer( new_buffer )
YY_BUFFER_STATE new_buffer;
#endif
	{
	if ( yy_current_buffer == new_buffer )
		return;

	if ( yy_current_buffer )
		{
		/* Flush out information for old buffer. */
		*yy_c_buf_p = yy_hold_char;
		yy_current_buffer->yy_buf_pos = yy_c_buf_p;
		yy_current_buffer->yy_n_chars = yy_n_chars;
		}

	yy_current_buffer = new_buffer;
	yy_load_buffer_state();

	/* We don't actually know whether we did this switch during
	 * EOF (yywrap()) processing, but the only time this flag
	 * is looked at is after yywrap() is called, so it's safe
	 * to go ahead and always set it.
	 */
	yy_did_buffer_switch_on_eof = 1;
	}


#ifdef YY_USE_PROTOS
void yy_load_buffer_state( void )
#else
void yy_load_buffer_state()
#endif
	{
	yy_n_chars = yy_current_buffer->yy_n_chars;
	yytext_ptr = yy_c_buf_p = yy_current_buffer->yy_buf_pos;
	yyin = yy_current_buffer->yy_input_file;
	yy_hold_char = *yy_c_buf_p;
	}


#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_create_buffer( FILE *file, int size )
#else
YY_BUFFER_STATE yy_create_buffer( file, size )
FILE *file;
int size;
#endif
	{
	YY_BUFFER_STATE b;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_buf_size = size;

	/* yy_ch_buf has to be 2 characters longer than the size given because
	 * we need to put in 2 end-of-buffer characters.
	 */
	b->yy_ch_buf = (char *) yy_flex_alloc( b->yy_buf_size + 2 );
	if ( ! b->yy_ch_buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );

	b->yy_is_our_buffer = 1;

	yy_init_buffer( b, file );

	return b;
	}


#ifdef YY_USE_PROTOS
void yy_delete_buffer( YY_BUFFER_STATE b )
#else
void yy_delete_buffer( b )
YY_BUFFER_STATE b;
#endif
	{
	if ( ! b )
		return;

	if ( b == yy_current_buffer )
		yy_current_buffer = (YY_BUFFER_STATE) 0;

	if ( b->yy_is_our_buffer )
		yy_flex_free( (void *) b->yy_ch_buf );

	yy_flex_free( (void *) b );
	}


#ifndef YY_ALWAYS_INTERACTIVE
#ifndef YY_NEVER_INTERACTIVE
extern int isatty YY_PROTO(( int ));
#endif
#endif

#ifdef YY_USE_PROTOS
void yy_init_buffer( YY_BUFFER_STATE b, FILE *file )
#else
void yy_init_buffer( b, file )
YY_BUFFER_STATE b;
FILE *file;
#endif


	{
	yy_flush_buffer( b );

	b->yy_input_file = file;
	b->yy_fill_buffer = 1;

#if YY_ALWAYS_INTERACTIVE
	b->yy_is_interactive = 1;
#else
#if YY_NEVER_INTERACTIVE
	b->yy_is_interactive = 0;
#else
	b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
#endif
#endif
	}


#ifdef YY_USE_PROTOS
void yy_flush_buffer( YY_BUFFER_STATE b )
#else
void yy_flush_buffer( b )
YY_BUFFER_STATE b;
#endif

	{
	if ( ! b )
		return;

	b->yy_n_chars = 0;

	/* We always need two end-of-buffer characters.  The first causes
	 * a transition to the end-of-buffer state.  The second causes
	 * a jam in that state.
	 */
	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;

	b->yy_buf_pos = &b->yy_ch_buf[0];

	b->yy_at_bol = 1;
	b->yy_buffer_status = YY_BUFFER_NEW;

	if ( b == yy_current_buffer )
		yy_load_buffer_state();
	}


#ifndef YY_NO_SCAN_BUFFER
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_buffer( char *base, yy_size_t size )
#else
YY_BUFFER_STATE yy_scan_buffer( base, size )
char *base;
yy_size_t size;
#endif
	{
	YY_BUFFER_STATE b;

	if ( size < 2 ||
	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
	     base[size-1] != YY_END_OF_BUFFER_CHAR )
		/* They forgot to leave room for the EOB's. */
		return 0;

	b = (YY_BUFFER_STATE) yy_flex_alloc( sizeof( struct yy_buffer_state ) );
	if ( ! b )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );

	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
	b->yy_buf_pos = b->yy_ch_buf = base;
	b->yy_is_our_buffer = 0;
	b->yy_input_file = 0;
	b->yy_n_chars = b->yy_buf_size;
	b->yy_is_interactive = 0;
	b->yy_at_bol = 1;
	b->yy_fill_buffer = 0;
	b->yy_buffer_status = YY_BUFFER_NEW;

	yy_switch_to_buffer( b );

	return b;
	}
#endif


#ifndef YY_NO_SCAN_STRING
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_string( yyconst char *yy_str )
#else
YY_BUFFER_STATE yy_scan_string( yy_str )
yyconst char *yy_str;
#endif
	{
	int len;
	for ( len = 0; yy_str[len]; ++len )
		;

	return yy_scan_bytes( yy_str, len );
	}
#endif


#ifndef YY_NO_SCAN_BYTES
#ifdef YY_USE_PROTOS
YY_BUFFER_STATE yy_scan_bytes( yyconst char *bytes, int len )
#else
YY_BUFFER_STATE yy_scan_bytes( bytes, len )
yyconst char *bytes;
int len;
#endif
	{
	YY_BUFFER_STATE b;
	char *buf;
	yy_size_t n;
	int i;

	/* Get memory for full buffer, including space for trailing EOB's. */
	n = len + 2;
	buf = (char *) yy_flex_alloc( n );
	if ( ! buf )
		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );

	for ( i = 0; i < len; ++i )
		buf[i] = bytes[i];

	buf[len] = buf[len+1] = YY_END_OF_BUFFER_CHAR;

	b = yy_scan_buffer( buf, n );
	if ( ! b )
		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );

	/* It's okay to grow etc. this buffer, and we should throw it
	 * away when we're done.
	 */
	b->yy_is_our_buffer = 1;

	return b;
	}
#endif


#ifndef YY_NO_PUSH_STATE
#ifdef YY_USE_PROTOS
static void yy_push_state( int new_state )
#else
static void yy_push_state( new_state )
int new_state;
#endif
	{
	if ( yy_start_stack_ptr >= yy_start_stack_depth )
		{
		yy_size_t new_size;

		yy_start_stack_depth += YY_START_STACK_INCR;
		new_size = yy_start_stack_depth * sizeof( int );

		if ( ! yy_start_stack )
			yy_start_stack = (int *) yy_flex_alloc( new_size );

		else
			yy_start_stack = (int *) yy_flex_realloc(
					(void *) yy_start_stack, new_size );

		if ( ! yy_start_stack )
			YY_FATAL_ERROR(
			"out of memory expanding start-condition stack" );
		}

	yy_start_stack[yy_start_stack_ptr++] = YY_START;

	BEGIN(new_state);
	}
#endif


#ifndef YY_NO_POP_STATE
static void yy_pop_state()
	{
	if ( --yy_start_stack_ptr < 0 )
		YY_FATAL_ERROR( "start-condition stack underflow" );

	BEGIN(yy_start_stack[yy_start_stack_ptr]);
	}
#endif


#ifndef YY_NO_TOP_STATE
static int yy_top_state()
	{
	return yy_start_stack[yy_start_stack_ptr - 1];
	}
#endif

#ifndef YY_EXIT_FAILURE
#define YY_EXIT_FAILURE 2
#endif

#ifdef YY_USE_PROTOS
static void yy_fatal_error( yyconst char msg[] )
#else
static void yy_fatal_error( msg )
char msg[];
#endif
	{
	(void) fprintf( stderr, "%s\n", msg );
	exit( YY_EXIT_FAILURE );
	}



/* Redefine yyless() so it works in section 3 code. */

#undef yyless
#define yyless(n) \
	do \
		{ \
		/* Undo effects of setting up yytext. */ \
		yytext[yyleng] = yy_hold_char; \
		yy_c_buf_p = yytext + n; \
		yy_hold_char = *yy_c_buf_p; \
		*yy_c_buf_p = '\0'; \
		yyleng = n; \
		} \
	while ( 0 )


/* Internal utility routines. */

#ifndef yytext_ptr
#ifdef YY_USE_PROTOS
static void yy_flex_strncpy( char *s1, yyconst char *s2, int n )
#else
static void yy_flex_strncpy( s1, s2, n )
char *s1;
yyconst char *s2;
int n;
#endif
	{
	register int i;
	for ( i = 0; i < n; ++i )
		s1[i] = s2[i];
	}
#endif

#ifdef YY_NEED_STRLEN
#ifdef YY_USE_PROTOS
static int yy_flex_strlen( yyconst char *s )
#else
static int yy_flex_strlen( s )
yyconst char *s;
#endif
	{
	register int n;
	for ( n = 0; s[n]; ++n )
		;

	return n;
	}
#endif


#ifdef YY_USE_PROTOS
static void *yy_flex_alloc( yy_size_t size )
#else
static void *yy_flex_alloc( size )
yy_size_t size;
#endif
	{
	return (void *) malloc( size );
	}

#ifdef YY_USE_PROTOS
static void *yy_flex_realloc( void *ptr, yy_size_t size )
#else
static void *yy_flex_realloc( ptr, size )
void *ptr;
yy_size_t size;
#endif
	{
	/* The cast to (char *) in the following accommodates both
	 * implementations that use char* generic pointers, and those
	 * that use void* generic pointers.  It works with the latter
	 * because both ANSI C and C++ allow castless assignment from
	 * any pointer type to void*, and deal with argument conversions
	 * as though doing an assignment.
	 */
	return (void *) realloc( (char *) ptr, size );
	}

#ifdef YY_USE_PROTOS
static void yy_flex_free( void *ptr )
#else
static void yy_flex_free( ptr )
void *ptr;
#endif
	{
	free( ptr );
	}

#if YY_MAIN
int main()
	{
	yylex();
	return 0;
	}
#endif
#line 98 "tnadmin.l"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\client\commands.h ===
/*
 Telnet Command Definitions.
Copyright (c) Microsoft Corporation.  All rights reserved.
  commands.h
*/

#ifndef __COMMANDS_H__
#define __COMMANDS_H__

typedef BOOL (*LPTELNET_COMMAND)(
    LPTSTR lpCommand
    );

typedef struct _tagTelnetCommand
{
	TCHAR* sName;
    LPTELNET_COMMAND pCmdHandler;
} TelnetCommand;

// These functions return FALSE to continue processing.
// Returning TRUE means quit - we are done with the processing.
BOOL CloseTelnetSession(LPTSTR);
BOOL DisplayParameters(LPTSTR);
BOOL OpenTelnetSession(LPTSTR);
BOOL QuitTelnet(LPTSTR);
BOOL PrintStatus(LPTSTR);
BOOL PrintHelpStr(LPTSTR);

BOOL SendOptions(LPTSTR);

BOOL SetOptions(LPTSTR);
BOOL UnsetOptions(LPTSTR);

BOOL EnableIMEOptions(LPTSTR);
BOOL DisableIMEOptions(LPTSTR);

void Write(LPTSTR lpszFmtStr, ...);
void ClearInitScreen();
BOOL PromptUser();
BOOL FileIsConsole(  HANDLE fp );
void MyWriteConsole(    HANDLE fp, LPWSTR lpBuffer, DWORD cchBuffer);

#ifdef __cplusplus

extern "C"
{

#endif

extern void *SfuZeroMemory(
        void    *ptr,
        unsigned int   cnt
        );

#ifdef __cplusplus

}

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\client\debug.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
#if DBG==1


void DbgPrint( char * format, ... );
#define DEBUG_PRINT(X)  DbgPrint X

#define ASSERT( expr )                                                       \
{                                                                            \
    if ( !(expr) )                                                           \
    {                                                                        \
        WCHAR Msg[200];                                                       \
        int rv;                                                              \
        wsprintf( Msg, ( LPTSTR )L"Assertion failed: %s, line %d.\n(%s) == FALSE\n\nIssue breakpoint?\n", \
 __FILE__, __LINE__, #expr );                                             \
        rv = MessageBox( NULL, Msg, ( LPTSTR )L"Assertion failed:", MB_ICONSTOP | MB_YESNO );  \
        if ( rv == IDYES ){ DebugBreak(); }                                   \
    }                                                                         \
}

#else  // !DBG

#define DEBUG_PRINT(X)  /* nothing */

#define ASSERT( expr ) 

#endif  // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\client\resource.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by wintel.rc
//

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        101
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\client\debug.c ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
//   Name:  Mohsin Ahmed
//   Email: MohsinA@microsoft.com
//   Date:  Mon Nov 04 13:53:46 1996
//   File:  s:/tcpcmd/common2/debug.c
//   Synopsis: Win95 Woes, don't have ntdll.dll on win95.

#include <windows.h>
#include <stdio.h>
#ifdef DBG
#define MAX_DEBUG_OUTPUT 1024

void DbgPrint( char * format, ... )
{
    va_list args;
    char    out[MAX_DEBUG_OUTPUT];
    int     cch=0;

    // cch = wsprintf( out, MODULE_NAME ":"  );

    va_start( args, format );
    _vsnprintf( out + cch,MAX_DEBUG_OUTPUT-1,format, args );
    va_end( args );

    OutputDebugStringA(  out );
}



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\client\security.c ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
/*
security.cpp
*/

#include <windows.h>      /* required for all Windows applications */
#include <stdlib.h>
#include <stdio.h>
#include <stddef.h>
#define SECURITY_WIN32
#include <sspi.h>
#include <rpc.h>
#include <rpcdce.h>

#include "debug.h"
#include "wintel.h"
#include "telnet.h"
#include "commands.h"

static CredHandle hCredential = { 0, 0 };
static CtxtHandle hContext = { 0, 0 };
static PSecPkgInfo  pspi;

#define DEFAULT_BUFFER_SIZE     4096

BOOL StuffEscapeIACs( PUCHAR* ppBufDest, UCHAR bufSrc[], DWORD* pdwSize );

void NTLMCleanup()
{
    FreeCredentialsHandle(&hCredential);
    if(pspi)
    {
	    FreeContextBuffer( pspi );
	    pspi=NULL;
    }
}


BOOL StartNTLMAuth(WI *pwi)
{
	unsigned char *sbuf = NULL;
    PUCHAR destBuf = NULL;
    DWORD dwSize = 0;
    BOOL bRetVal = FALSE;

    int inx;

    TimeStamp  tsExpiry;
    SECURITY_STATUS secStatus;
    SecBufferDesc   OutBuffDesc;
    SecBuffer       OutSecBuff;
    ULONG      fContextAttr;
    
    HANDLE hProc = NULL;
    HANDLE hAccessToken = NULL;
    TOKEN_INFORMATION_CLASS tic;
    DWORD dwSizeReqd;
    VOID* tokenData = NULL;
    SID_NAME_USE sidType;
    DWORD dwStrSize1 = MAX_PATH + 1;
    DWORD dwStrSize2 = MAX_PATH + 1;
    SEC_WINNT_AUTH_IDENTITY AuthIdentity;

    WCHAR szWideUser[ MAX_PATH + 1 ] ;
    WCHAR szWideDomain[ MAX_PATH + 1 ] ;

	OutSecBuff.pvBuffer = NULL;
	
    /*
    added code to get user name and domain so we can pass it 
    AcquireCredentialsHandle(); this is to prevent optimization happening in NT
    for the case where client and server are on same machine, in which case the
    same user in different sessions gets the same Authentication Id thereby 
    affecting our process clean up in telnet server 
    */

    hProc = OpenProcess( PROCESS_ALL_ACCESS, FALSE, 
        GetCurrentProcessId() );
    if( hProc == NULL )
    {
    	goto End;
    }

    if( !OpenProcessToken( hProc, TOKEN_QUERY, &hAccessToken )) 
    {
        CloseHandle( hProc );
        goto End;
    }

    //get user info
    tic = TokenUser;
    //find out how much memory is reqd.
    GetTokenInformation( hAccessToken, tic, NULL, 0, &dwSizeReqd );
    
    //allocate that memory
    tokenData = (TOKEN_USER*) malloc( dwSizeReqd );
    
    // and check if the allocation succeeded
    if (!tokenData) {
        CloseHandle( hProc );
        CloseHandle( hAccessToken );
        goto End;
    }

    //actually get the user info
    if( !GetTokenInformation( hAccessToken, tic, tokenData, dwSizeReqd, 
        &dwSizeReqd ) )
    {
        CloseHandle( hProc );
        CloseHandle( hAccessToken );
        goto End;
    }
    
    CloseHandle( hProc );
    CloseHandle( hAccessToken );

    //convert user SID into a name and domain
    if( !LookupAccountSid( NULL, ((TOKEN_USER*) tokenData)->User.Sid, 
        szWideUser, &dwStrSize1, szWideDomain, &dwStrSize2, &sidType ) )
    {
        goto End;
    }
    
    SfuZeroMemory( &AuthIdentity, sizeof(AuthIdentity) );

    if( szWideDomain != NULL ) 
    {
        AuthIdentity.Domain = szWideDomain;
        AuthIdentity.DomainLength = wcslen(szWideDomain) ;
    }

    if( szWideUser != NULL ) 
    {
        AuthIdentity.User = szWideUser;
        AuthIdentity.UserLength = wcslen(szWideUser) ;
    }

    ///    leave password empty via SfuZeroMemory above
    ///    if ( Password != NULL ) 
    ///    {
    ///        AuthIdentity.Password = Password;
    ///        AuthIdentity.PasswordLength = lstrlen(Password);
    ///    }

    AuthIdentity.Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    if ( SEC_E_OK != (secStatus = AcquireCredentialsHandle(
                        NULL, // SEC_CHAR * pszPrincipal,  // name of principal
                        ( LPTSTR ) L"NTLM", //SEC_CHAR * pszPackage, // name of package
                        SECPKG_CRED_OUTBOUND, //ULONG fCredentialUse,  // flags indicating use
                        NULL, // PLUID pvLogonID,       // pointer to logon identifier
                        (PVOID) &AuthIdentity, //PVOID pAuthData,       // package-specific data
                        NULL, //PVOID pGetKeyFn,       // pointer to GetKey function
                        NULL, //PVOID pvGetKeyArgument,  // value to pass to GetKey
                        &hCredential,  // credential handle
                        &tsExpiry))    // life time of the returned credentials);

            )
    {
        goto End;
    }


    secStatus = QuerySecurityPackageInfo(( LPTSTR ) L"NTLM", &pspi);

    if ( secStatus != SEC_E_OK || !pspi)
    {
    	goto End;
    }

    //
    //  Prepare our output buffer.  We use a temporary buffer because
    //  the real output buffer will most likely need to be uuencoded
    //

    OutBuffDesc.ulVersion = 0;
    OutBuffDesc.cBuffers  = 1;
    OutBuffDesc.pBuffers  = &OutSecBuff;

    OutSecBuff.cbBuffer   = pspi->cbMaxToken;
    OutSecBuff.BufferType = SECBUFFER_TOKEN;
    OutSecBuff.pvBuffer   = malloc(pspi->cbMaxToken);
    
    if( !OutSecBuff.pvBuffer ) {
		goto End;
    }

    // We will start using sbuf after the call to the below API
    // So allocate it here and bail out if allocation fails
    sbuf = (unsigned char*)malloc(DEFAULT_BUFFER_SIZE);
    if (!sbuf)
    {
    	goto End;
    }

    secStatus = InitializeSecurityContext(
                        &hCredential,  // handle to the credentials
                        NULL, // handle of partially formed context
                        NULL, //SEC_CHAR * pszTargetName,  // name of the target of the context
                        ISC_REQ_REPLAY_DETECT, // required context attributes
                        0,      //ULONG Reserved1,       // reserved; must be zero
                        SECURITY_NATIVE_DREP, //ULONG TargetDataRep,   // data representation on the target
                        NULL,       //PSecBufferDesc pInput, // pointer to the input buffers
                        0,          //ULONG Reserved2,       // reserved; must be zero
                        &hContext,  // receives the new context handle
                        &OutBuffDesc,  // pointer to the output buffers
                        &fContextAttr,  // receives the context attributes
                        &tsExpiry);   // receives the life span of the security context);

    switch ( secStatus )
    {
    case SEC_I_CONTINUE_NEEDED:

		sbuf[0] = IAC;
        sbuf[1] = SB;
        sbuf[2] = TO_AUTH;
        sbuf[3] = AU_IS;
		sbuf[4] = AUTH_TYPE_NTLM;
        sbuf[5] = AUTH_CLIENT_TO_SERVER | AUTH_HOW_ONE_WAY;
        sbuf[6] = NTLM_AUTH;
        inx = 7;

        dwSize = sizeof(OutSecBuff) - sizeof(LPSTR);
        if( !StuffEscapeIACs( &destBuf, ( UCHAR *)&OutSecBuff, &dwSize ) )
        {
        	//copy maximum 'n' bytes where 'n' is minimum of the available sbuf and size of data to copy.
		   	if(DEFAULT_BUFFER_SIZE > dwSize+inx+2) //for IAC SE
			{
			    memcpy( sbuf+inx, (LPSTR)&OutSecBuff, sizeof(OutSecBuff) - sizeof(LPSTR));
			    inx += sizeof(OutSecBuff) - sizeof(LPSTR);
			}
        }
        else
        {
        	//copy maximum 'n' bytes where 'n' is minimum of the available sbuf and size of data to copy.
        	if(DEFAULT_BUFFER_SIZE > dwSize+inx+2) //for IAC SE
        	{
        		memcpy( sbuf+inx, destBuf, dwSize);
			    inx += dwSize;
        	}
        }
		if(destBuf)
		{
			free( destBuf );
			destBuf = NULL;
		}

		dwSize = OutSecBuff.cbBuffer;
        if( !StuffEscapeIACs( &destBuf, OutSecBuff.pvBuffer, &dwSize ) )
        {
        	if(DEFAULT_BUFFER_SIZE > OutSecBuff.cbBuffer+inx+2) //for IAC SE
        	{
    			memcpy( sbuf+inx, OutSecBuff.pvBuffer, OutSecBuff.cbBuffer); //no overflow. Check already present.
		    	inx += OutSecBuff.cbBuffer;
        	}
        }
        else
        {
	        if(DEFAULT_BUFFER_SIZE > dwSize+inx+2) //for IAC SE
        	{
    	        memcpy( sbuf+inx, destBuf, dwSize );//no overflow. Check already present.
			    inx += dwSize;
	        }
        }
		if(destBuf)
		{
			free( destBuf );
			destBuf = NULL;
		}
	
		sbuf[inx++] = IAC;
        sbuf[inx++] = SE;
 
        FWriteToNet( pwi, ( char * )sbuf, inx );
        break;
    case SEC_I_COMPLETE_AND_CONTINUE:
    case SEC_I_COMPLETE_NEEDED:
    default:
        goto End;
    }

    pwi->eState = Authenticating;
    bRetVal = TRUE;
End:    
	if(tokenData)
		free( tokenData );
	if(OutSecBuff.pvBuffer)
	    free(OutSecBuff.pvBuffer);
	if(sbuf)
	    free(sbuf);
	return bRetVal;

}


BOOL DoNTLMAuth(WI *pwi, PUCHAR pBuffer, DWORD dwSize)
{
    SECURITY_STATUS secStatus;
    SecBufferDesc   InBuffDesc;
    SecBuffer       InSecBuff;
    SecBuffer	   *pInSecBuff = NULL;
    SecBufferDesc   OutBuffDesc;
    SecBuffer       OutSecBuff;
    BOOL		   bStatus=FALSE;
    ULONG fContextAttr;
    TimeStamp tsExpiry;

	unsigned char *sbuf = NULL;
    PUCHAR destBuf = NULL;
    int inx;

    OutSecBuff.pvBuffer = NULL;

	pInSecBuff = (SecBuffer *)malloc(sizeof(SecBuffer));
	if( NULL == pInSecBuff )
	{
		goto Done;
	}
	
    // Copy the 1st two fields of SecBuffer from pBuffer to pInSecBuffer. Use memcpy because
    // pBuffer is not guaranteed to be an aligned pointer.
    // Use offsetof to copy whatever is there before pvBuffer.
    memcpy((PVOID)pInSecBuff, (PVOID)pBuffer, offsetof(SecBuffer, pvBuffer));//Attack ? Size not known.

    // now set pvBuffer to point into the pBuffer area.
    pInSecBuff->pvBuffer    = (PVOID)(pBuffer+offsetof(SecBuffer,pvBuffer));

	if(	dwSize<(sizeof(SecBuffer)) ||
		dwSize<(offsetof(SecBuffer,pvBuffer)+ pInSecBuff->cbBuffer)  ||
		!pspi
	 )
	{
		goto Done;
	}
    //
    //  Prepare our Input buffer - Note the server is expecting the client's
    //  negotiation packet on the first call
    //

    InBuffDesc.ulVersion = 0;
    InBuffDesc.cBuffers  = 1;
    InBuffDesc.pBuffers  = &InSecBuff;

    InSecBuff.cbBuffer   = pInSecBuff->cbBuffer;
    InSecBuff.BufferType = pInSecBuff->BufferType;
    InSecBuff.pvBuffer   = pInSecBuff->pvBuffer;

    //
    //  Prepare our output buffer.  We use a temporary buffer because
    //  the real output buffer will most likely need to be uuencoded
    //

    OutBuffDesc.ulVersion = 0;
    OutBuffDesc.cBuffers  = 1;
    OutBuffDesc.pBuffers  = &OutSecBuff;

    OutSecBuff.cbBuffer   = pspi->cbMaxToken;
    OutSecBuff.BufferType = SECBUFFER_TOKEN;
    OutSecBuff.pvBuffer   = malloc(pspi->cbMaxToken);

    if( !OutSecBuff.pvBuffer ) {
        goto Done;
    }

    sbuf = (unsigned char*)malloc(DEFAULT_BUFFER_SIZE);
    if (!sbuf)
    {
        goto Done;
    }

    secStatus = InitializeSecurityContext(
                        &hCredential,  // handle to the credentials
                        &hContext, // handle of partially formed context
                        ( LPTSTR ) L"NTLM",//SEC_CHAR * pszTargetName,  // name of the target of the context
                        ISC_REQ_DELEGATE |
                        ISC_REQ_REPLAY_DETECT, // required context attributes
                        0,      //ULONG Reserved1,       // reserved; must be zero
                        SECURITY_NATIVE_DREP, //ULONG TargetDataRep,   // data representation on the target
                        &InBuffDesc, // pointer to the input buffers
                        0,          //ULONG Reserved2,       // reserved; must be zero
                        &hContext,  // receives the new context handle
                        &OutBuffDesc,  // pointer to the output buffers
                        &fContextAttr,  // receives the context attributes
                        &tsExpiry);   // receives the life span of the security context);

    switch ( secStatus ) {
    case SEC_E_OK:
    case SEC_I_CONTINUE_NEEDED:
		sbuf[0] = IAC;
        sbuf[1] = SB;
        sbuf[2] = TO_AUTH;
        sbuf[3] = AU_IS;
		sbuf[4] = AUTH_TYPE_NTLM;
        sbuf[5] = AUTH_CLIENT_TO_SERVER | AUTH_HOW_ONE_WAY;
        sbuf[6] = NTLM_RESPONSE;
        inx = 7;

        dwSize = sizeof(OutSecBuff) - sizeof(LPSTR);
        if( !StuffEscapeIACs( &destBuf, (UCHAR *)&OutSecBuff, &dwSize ) )
        {
	        if(DEFAULT_BUFFER_SIZE > dwSize+inx+2) //for IAC SE
        	{
			    memcpy( sbuf+inx, (LPSTR)&OutSecBuff, sizeof(OutSecBuff) - sizeof(LPSTR) );//no overflow. Check already present.
			    inx += sizeof(OutSecBuff) - sizeof(LPSTR);
	        }
        }
        else
        {
	        if(DEFAULT_BUFFER_SIZE > dwSize+inx+2) //for IAC SE
        	{
    	        memcpy( sbuf+inx, destBuf, dwSize );//no overflow. Check already present.
			    inx += dwSize;
	        }
        }
		if(destBuf)
		{
			free( destBuf );
			destBuf = NULL;
		}
		dwSize = OutSecBuff.cbBuffer;
        if( !StuffEscapeIACs( &destBuf, OutSecBuff.pvBuffer, &dwSize ) )
        {
    		if(DEFAULT_BUFFER_SIZE > OutSecBuff.cbBuffer+inx+2) //for IAC SE
    		{
    			memcpy( sbuf+inx, OutSecBuff.pvBuffer, OutSecBuff.cbBuffer);
		    	inx += OutSecBuff.cbBuffer;
    		}
        }
        else
        {
        	if(DEFAULT_BUFFER_SIZE > dwSize+inx+2) //for IAC SE
        	{
            	memcpy( sbuf+inx, destBuf, dwSize );
			    inx += dwSize;
        	}
        }
		if(destBuf)
		{
			free( destBuf );
			destBuf = NULL;
		}

		sbuf[inx++] = IAC;
        sbuf[inx++] = SE;

        FWriteToNet(pwi, ( char * )sbuf, inx);
        
		break;

    case SEC_I_COMPLETE_NEEDED: 
    case SEC_I_COMPLETE_AND_CONTINUE:
    default:
        goto Done;
    }
	bStatus=TRUE;
Done:
    if (sbuf) 
    {
    	free(sbuf);
    }
	if (pInSecBuff) 
	{
		free(pInSecBuff);
	}
    if (OutSecBuff.pvBuffer) 
    {
    	free(OutSecBuff.pvBuffer);
    }
    pwi->eState=AuthChallengeRecvd;
    return(bStatus);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\client\global.c ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
/****************************************************************************
        Declares global variables for WinTel.
****************************************************************************/
#include <windows.h>            
#pragma warning (disable: 4201)	// disable "nonstandard extension used : nameless struct/union"
#include <commdlg.h>
#pragma warning (default: 4201)
#include <stdlib.h>
#include "WinTel.h"             

UI     ui = {0};

int    iCursorHeight = 1;      // height of cursor 
int    iCursorWidth = 1;       // width of cursor 

BOOL   fConnected = FALSE;     // if we're connected to a machine 
BOOL   fHungUp = FALSE;

CHAR_INFO *g_rgciCharInfo = NULL;
UCHAR   *g_rgchRow = NULL;              /* template of empty row for quick-copying */

int    rgService = 0;

#ifdef _DEBUG
UCHAR DebugBuffer[256];
#endif

DWORD g_dwSockErr = 0;

BOOL  g_bSendDelAsBackSpace;
BOOL  g_bSendBackSpaceAsDel;

WCHAR g_chEsc = DEFAULT_ESCAPE_CHAR;
SHORT g_EscCharShiftState = DEFAULT_SHIFT_STATE;

// name of host we're connected to 
TCHAR rgchHostName[cchMaxHostName] = {0};
TCHAR g_szPortNameOrNo[cchMaxHostName] = {0};

UCHAR rgchCharSetWorkArea[256];
CHAR* szUser = NULL;
BOOL  g_bDontNAWSReceived = FALSE;
TCHAR g_szLogFile[ MAX_PATH + 1 ];

UCHAR rgchNullChars[128] = 
{
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

UCHAR rgchJISRomanChars[128] = 
{
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F
};

UCHAR rgchJISKanjiChars[128] = 
{
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F
};

UCHAR rgchEUCKanjiChars[128] =
{
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

UCHAR rgchDECKanjiChars[128] =
{
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

UCHAR rgchIBMAnsiChars[128] = 
{
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F
};

UCHAR rgchGraphicsChars[128] =
{
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
0x04, 0xB2, 0x09, 0x0C, 0x0D, 0x0A, 0xF8, 0xF0, 0x68, 0x0B, 0xD9, 0xBF, 0xDA, 0xC0, 0xC5, 0xC4,
0xC4, 0xC4, 0xC4, 0xC4, 0xC3, 0xB4, 0xC1, 0xC2, 0xB3, 0xF3, 0xF2, 0xE3, 0x7C, 0x9C, 0xF9, 0x7F,
};

UCHAR rgchKatakanaChars[128] = 
{
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

UCHAR rgchDefaultRightChars[128] =
{
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

UCHAR rgchNormalChars[256] =
{
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7A, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F,
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};

UCHAR rgchAlternateChars[256] =
{
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0A, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1A, 0x1B, 0x1C, 0x1D, 0x1E, 0x1F,
0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5A, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,
0x04, 0xB2, 0x09, 0x0C, 0x0D, 0x0A, 0xF8, 0xF0, 0x68, 0x0B, 0xD9, 0xBF, 0xDA, 0xC0, 0xC5, 0xC4,
0xC4, 0xC4, 0xC4, 0xC4, 0xC3, 0xB4, 0xC1, 0xC2, 0xB3, 0xF3, 0xF2, 0xE3, 0x7C, 0x9C, 0xF9, 0x7F,
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8A, 0x8B, 0x8C, 0x8D, 0x8E, 0x8F,
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9A, 0x9B, 0x9C, 0x9D, 0x9E, 0x9F,
0xA0, 0xA1, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6, 0xA7, 0xA8, 0xA9, 0xAA, 0xAB, 0xAC, 0xAD, 0xAE, 0xAF,
0xB0, 0xB1, 0xB2, 0xB3, 0xB4, 0xB5, 0xB6, 0xB7, 0xB8, 0xB9, 0xBA, 0xBB, 0xBC, 0xBD, 0xBE, 0xBF,
0xC0, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7, 0xC8, 0xC9, 0xCA, 0xCB, 0xCC, 0xCD, 0xCE, 0xCF,
0xD0, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6, 0xD7, 0xD8, 0xD9, 0xDA, 0xDB, 0xDC, 0xDD, 0xDE, 0xDF,
0xE0, 0xE1, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6, 0xE7, 0xE8, 0xE9, 0xEA, 0xEB, 0xEC, 0xED, 0xEE, 0xEF,
0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7, 0xF8, 0xF9, 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, 0xFF
};



//United Kingdom Set
UCHAR rgchUKChars[256] = {
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
0x20, 0x21, 0x22, 0x9c, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f,
0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f,
0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f,
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
};



// Special Graphics
UCHAR rgchSpecialGraphicsChars[256] = {
0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,
0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,
0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f,
0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f,
0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f,
0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x04, 0x5d, 0x5e, 0xdb,
0x04, 0xb1, 0x09, 0x0c, 0x0d, 0x0a, 0xf8, 0xf1, 0x68, 0x0b, 0xd9, 0xbf, 0xda, 0xc0, 0xc5, 0xa9,
0xa9, 0xc4, 0x5f, 0x5f, 0xc3, 0xb4, 0xc1, 0xc2, 0xb3, 0xf3, 0xf2, 0xe3, 0x2f, 0x9c, 0xfe, 0x7f,
0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f,
0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f,
0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf,
0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf,
0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf,
0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf,
0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef,
0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff
};

/* VT100 NOTES
Special Graphics Characters 

        If the Special Graphics set is selected, the graphics for ASCII codes
0137 through 0176 will be replaced according to the following table (see the
SCS control sequence).


Octal    ASCII      Special              Octal    ASCII     Special
Code    graphic     graphic              code    graphic    graphic
-------------------------------------------------------------------------------
0137      _         Blank                0157       o       Horiz Line - scan 1
0140      \         Diamond              0160       p       Horiz Line - scan 3
0141      a         Checkerboard         0161       q       Horiz Line - scan 5
0142      b         Digraph: HT          0162       r       Horiz Line - scan 7
0143      c         Digraph: FF          0163       s       Horiz Line - scan 9
0144      d         Digraph: CR          0164       t       Left "T" (|-)
0145      e         Digraph: LF          0165       u       Right "T" (-|)
0146      f         Degree Symbol        0166       v       Bottom "T" (|._)
0147      g         +/- Symbol           0167       w       Top "T" (T)
0150      h         Digraph: NL          0170       x       Vertical Bar (|)
0151      i         Digraph: VT          0171       y       Less/Equal (<._)
0152      j         Lower-right corner   0172       z       Grtr/Egual (>._)
0153      k         Upper-right corner   0173       {       Pi symbol
0154      l         Upper-left corner    0174       |       Not equal (=./)
0155      m         Lower-left corner    0175       }       UK pound symbol
0156      n         Crossing lines (+)   0176       ~       Centered dot


NOTE 1: Codes 0152-0156 and 0164-0170 are used to draw rectangular grids" each
piece of this set is contiguous with other so the lines formed will beunbroken.


NOTE 2: Codes 0157-0163 give better vertical resolution than dashes and
underlines when drawing graphs; using these segments, 120 x 132 resolution may
be obtained in 132 column mode with the Advanced Video Option installed.

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\client\telnet.h ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
#ifndef TELNET_INCLUDED
#define TELNET_INCLUDED

/*
 * Definitions for the TELNET protocol.
 */
#define IAC     255             /* interpret as command: */
#define DONT    254             /* you are not to use option */
#define DO      253             /* please, you use option */
#define WONT    252             /* I won't use option */
#define WILL    251             /* I will use option */
#define SB      250             /* interpret as subnegotiation */
#define GA      249             /* you may reverse the line */
#define EL      248             /* erase the current line */
#define EC      247             /* erase the current character */
#define AYT     246             /* are you there */
#define AO      245             /* abort output--but let prog finish */
#define IP      244             /* interrupt process--permanently */
#define BREAK   243             /* break */
#define DM      242             /* data mark--for connect. cleaning */
#define NOP     241             /* nop */
#define SE      240             /* end sub negotiation */

#define SYNCH   242             /* for telfunc calls */

/* Telnet options - Names have been truncated to be unique in 7 chars */


#define TO_BINARY       0       /* 8-bit data path */
#define TO_ECHO         1       /* echo */
#define TO_RCP          2       /* prepare to reconnect */
#define TO_SGA          3       /* suppress go ahead */
#define TO_NAMS         4       /* approximate message size */
#define TO_STATUS       5       /* give status */
#define TO_TM           6       /* timing mark */
#define TO_RCTE         7       /* remote controlled transmission and echo */
#define TO_NL           8       /* negotiate about output line width */
#define TO_NP           9       /* negotiate about output page size */
#define TO_NCRD         10      /* negotiate about CR disposition */
#define TO_NHTS         11      /* negotiate about horizontal tabstops */
#define TO_NHTD         12      /* negotiate about horizontal tab disposition */
#define TO_NFFD         13      /* negotiate about formfeed disposition */
#define TO_NVTS         14      /* negotiate about vertical tab stops */
#define TO_NVTD         15      /* negotiate about vertical tab disposition */
#define TO_NLFD         16      /* negotiate about output LF disposition */
#define TO_XASCII       17      /* extended ascic character set */
#define TO_LOGOUT       18      /* force logout */
#define TO_BM           19      /* byte macro */
#define TO_DET          20      /* data entry terminal */
#define TO_SUPDUP       21      /* supdup protocol */
#define TO_TERM_TYPE    24      /* terminal type */
#define TO_NAWS         31      // Negotiate About Window Size
#define TO_TOGGLE_FLOW_CONTROL 33  /* Enable & disable Flow control */
#define TO_ENVIRON      36      /* Environment Option */
#define TO_NEW_ENVIRON  39      /* New Environment Option */
#define TO_EXOPL        255     /* extended-options-list */

#define TO_AUTH         37      

/* Define (real) long names to be the shorter ones */

#define TELOPT_BINARY   TO_BINARY
#define TELOPT_ECHO     TO_ECHO
#define TELOPT_RCP      TO_RCP
#define TELOPT_SGA      TO_SGA
#define TELOPT_NAMS     TO_NAMS
#define TELOPT_STATUS   TO_STATUS
#define TELOPT_TM       TO_TM
#define TELOPT_RCTE     TO_RCTE
#define TELOPT_NAOL     TO_NL
#define TELOPT_NAOP     TO_NP
#define TELOPT_NAOCRD   TO_NCRD
#define TELOPT_NAOHTS   TO_NHTS
#define TELOPT_NAOHTD   TO_NHTD
#define TELOPT_NAOFFD   TO_NFFD
#define TELOPT_NAOVTS   TO_NVTS
#define TELOPT_NAOVTD   TO_NVTD
#define TELOPT_NAOLFD   TO_NLFD
#define TELOPT_XASCII   TO_XASCII
#define TELOPT_LOGOUT   TO_LOGOUT
#define TELOPT_BM       TO_BM
#define TELOPT_DET      TO_DET
#define TELOPT_SUPDUP   TO_SUPDUP
#define TELOPT_EXOPL    TO_EXOPL

#define TT_SEND         1
#define TT_IS           0

#define VAR             0
#define VALUE           1
#define ESC             2
#define USERVAR         3



#define AU_IS		0
#define AU_SEND		1
#define AU_REPLY    2
#define AU_NAME     3

//Authentication Types
#define AUTH_TYPE_NULL   0
#define AUTH_TYPE_NTLM   15

//Modifiers
#define AUTH_WHO_MASK 1
#define AUTH_CLIENT_TO_SERVER 0
#define AUTH_SERVER_TO_CLIENT 1

#define AUTH_HOW_MASK 2
#define AUTH_HOW_ONE_WAY 0
#define AUTH_HOW_MUTUAL 2

// NTLM Schemes
#define NTLM_AUTH       0
#define NTLM_CHALLENGE  1
#define NTLM_RESPONSE   2
#define NTLM_ACCEPT     3
#define NTLM_REJECT     4


#ifdef TELCMDS
char *telcmds[] = {
        "SE", "NOP", "DMARK", "BRK", "IP", "AO", "AYT", "EC",
        "EL", "GA", "SB", "WILL", "WONT", "DO", "DONT", "IAC",
};
#endif

#ifdef TELOPTS
char *telopts[] = {
        "BINARY", "ECHO", "RCP", "SUPPRESS GO AHEAD", "NAME",
        "STATUS", "TIMING MARK", "RCTE", "NAOL", "NAOP",
        "NAOCRD", "NAOHTS", "NAOHTD", "NAOFFD", "NAOVTS",
        "NAOVTD", "NAOLFD", "EXTEND ASCII", "LOGOUT", "BYTE MACRO",
        "DATA ENTRY TERMINAL", "SUPDUP"
};
#endif

#endif  //TELNET_INCLUDED
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\client\sources.inc ===
TARGETNAME=telnet
TARGETPATH=obj
TARGETTYPE=PROGRAM

C_DEFINES= $(C_DEFINES) -DUSETCP -DRESDLL -D_UNICODE -DUNICODE -DWHISTLER_BUILD

USE_MSVCRT = 1
USE_CRTDLL = 1

INCLUDES=..\..\server\TlntSess;..\..\common\inc\;

UMTYPE=console
UMENTRY=wmain

SOURCES= ..\commands.c \
         ..\global.c   \
         ..\netio.c    \
	 ..\security.c \
         ..\trmio.c    \
	 ..\zone.cpp   \
         ..\wintel.c   \
         ..\wintelsz.c \
         ..\wintel.rc  \
         ..\debug.c

MISCFILES=..\TelnetClient.sld

TARGETLIBS= \
   ..\..\common\LocResMan\TGT_LIB\$(O)\locresman.lib \
   $(BASEDIR)\public\sdk\lib\*\user32.lib   \
   $(BASEDIR)\public\sdk\lib\*\netapi32.lib \
   $(BASEDIR)\public\sdk\lib\*\wsock32.lib \
   $(BASEDIR)\public\sdk\lib\*\ws2_32.lib \
   $(BASEDIR)\public\sdk\lib\*\security.lib \
   $(BASEDIR)\public\sdk\lib\*\imm32.lib \
   $(BASEDIR)\public\sdk\lib\*\shell32.lib \
   $(BASEDIR)\public\sdk\lib\*\oleaut32.lib \
   $(BASEDIR)\public\sdk\lib\*\ole32.lib \
   $(BASEDIR)\public\sdk\lib\*\uuid.lib \
   $(BASEDIR)\public\sdk\lib\*\gdi32.lib
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tcpip\services\telnet\client\netio.c ===
//Copyright (c) Microsoft Corporation.  All rights reserved.
/****************************************************************************

        FILE: NetIO.c

        Functions for connecting to machines and handling data transfers
        between machines.

        TABS:

                Set for 4 spaces.

****************************************************************************/

#include <stdio.h>
#include <windows.h>                    // required for all Windows applications
#include <lmcons.h>
#include <tchar.h>
#pragma warning (disable: 4201)			// disable "nonstandard extension used : nameless struct/union"
#include <commdlg.h>
#pragma warning (default: 4201)
#include <stdlib.h>
#include "WinTel.h"     				// specific to this program
#include "commands.h"
#include "debug.h"

#pragma warning( disable : 4100 )
#ifdef USETCP
#include "telnet.h"
#endif

char *rgchTermType[] = { "ANSI", "VT100", "VT52", "VTNT" };

extern void NTLMCleanup();
extern BOOL DoNTLMAuth(WI *pwi, PUCHAR pBuffer, DWORD dwSize);
extern int SafeSetSocketOptions(SOCKET s);

BOOL g_fSentWillNaws = FALSE;
static BOOL FAttemptServerConnect(WI *pwi, LPSTR, LPNETDATA);
static void xfGetData(char, char *, DWORD, int);
#ifdef USETCP 
#ifdef TELXFER 
static DWORD xfGetSomeData(char *, DWORD, int);
#endif //TELXFER
#endif //USETCP

static void xfPutc(char, int);

static int term_inx = 0;

extern BOOL StartNTLMAuth(WI *);
extern TCHAR szUserName[ UNLEN + 1 ];
extern CHAR* szUser;

TCHAR szCombinedFailMsg [255];

extern HANDLE g_hControlHandlerEvent;
extern HANDLE g_hCaptureConsoleEvent;
extern HANDLE g_hAsyncGetHostByNameEvent;
extern HANDLE g_hRemoteNEscapeModeDataSync;
extern BOOL   g_fConnectFailed;

void
GetErrMsgString( DWORD dwErrNum, LPTSTR *lpBuffer )
{
    DWORD  dwStatus = 0;
    LCID    old_thread_locale;

    switch (GetACP())
    {
        // for Hebrew and arabic winerror.h is not localized..so get the english one for all these
    case 1256:
    case 1255:

        old_thread_locale = GetThreadLocale();

        SetThreadLocale(
            MAKELCID(
                    MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),
                    SORT_DEFAULT
                    )
            );
        break;

    default:
        old_thread_locale = -1;
    
    }

    dwStatus = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER | 
		FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, 
		NULL, dwErrNum, LANG_NEUTRAL, ( LPTSTR )lpBuffer, 0, NULL );

    if( !dwStatus )
    {
        *lpBuffer = NULL;
    }

    if (old_thread_locale != -1) 
    {
        SetThreadLocale(old_thread_locale);
    }

    return;
}

BOOL
FConnectToServer(WI *pwi, LPSTR szHostName, LPNETDATA lpData)
{
    BOOL fResult;

    // Before we Connect we make sure we are not connected.
    // This ASSERT should never blowup !!
    ASSERT(fConnected==FALSE);

    // We initialize stuff for this connection.
    pwi->trm.SentTermType = TT_UNKNOWN;
    pwi->trm.CurrentTermType = TT_ANSI; /* this is our default term type*/

    fResult = FAttemptServerConnect(pwi, szHostName, lpData);

    if( fResult != TRUE )
    {
        TCHAR szStr[ cchMaxHostName ];
        g_fConnectFailed = TRUE;

        if( g_szPortNameOrNo[ 0 ] == 0 )
        {
            _sntprintf( g_szPortNameOrNo,cchMaxHostName-1,( LPCTSTR )L"%d", rgService );
        }

        _sntprintf( szStr, cchMaxHostName -1 ,szOnPort, g_szPortNameOrNo );
        _sntprintf(szCombinedFailMsg,ARRAY_SIZE(szCombinedFailMsg)-1,_T("%s%s"),szConnectFailedMsg,szStr);

        g_szPortNameOrNo[ 0 ] = 0;

        if( g_dwSockErr == 0 )
        {
            //Not an error we want to inform abt
            ErrorMessage( szCombinedFailMsg, szConnectFailed );
        }
        else
        {
            DWORD dwWritten = 0;
            LPTSTR lpBuffer = NULL;

            GetErrMsgString( g_dwSockErr, &lpBuffer );
			if( lpBuffer )
			{
				ConnectTimeErrorMessage( szCombinedFailMsg,  lpBuffer );
				LocalFree( lpBuffer );
			}
			else
			{
				ErrorMessage( szCombinedFailMsg, szConnectFailed );
			}
        }
    }

    return fResult;
}

#ifdef USETCP

/***      FPostReceive - post an asynchronous receive
 */
BOOL
FPostReceive(LPNETDATA lpData)
{

#ifdef  NBTEST
    OutputDebugString("PostReceive In\n");
#endif

#ifdef  NBTEST
    OutputDebugString("PostReceive Out\n");
#endif
    return TRUE;
}

int
FWriteToNet(WI *pwi, LPSTR addr, int cnt)
{
	
    int len = 0, retries = 0;
	if(pwi->nd.hsd == INVALID_SOCKET)
	{
		len = SOCKET_ERROR;
		goto Done;
	}
    do
    {
        len = send( pwi->nd.hsd, addr, cnt, 0 );
        retries ++;
    }
    while ((len == SOCKET_ERROR) && (WSAGetLastError() == WSAEWOULDBLOCK) && (retries < 5));
Done:
    return(len);
}

BOOL
FCommandPending(WI *pwi)
{
    return(FALSE);
}

/*

void 
FSendTM( HWND hwnd )
{
    WI *pwi = (WI *)GetWindowLongPtr(hwnd, WL_TelWI);
    unsigned char sbuf[] = { IAC, DO, TO_TM };

    ui.fFlushOut = 1;
    send( pwi->nd.hsd, ( char * )sbuf, sizeof( sbuf ), 0);
}
*/

//Our server still doesn't support urgent data handling..
void
FSendSynch(HWND hwnd)
{
    WI *pwi = (WI *)GetWindowLongPtr(hwnd, WL_TelWI);
    unsigned char sbuf[] = { IAC, DM };

    send( pwi->nd.hsd, ( char * )sbuf, 1, 0 );

    send( pwi->nd.hsd, ( char * )( sbuf + 1 ), 1, MSG_OOB );
}

void
FSendTelnetCommands( HWND hwnd, char chCommand )
{
    WI *pwi = (WI *)GetWindowLongPtr(hwnd, WL_TelWI);
    unsigned char sbuf[]={ IAC , 0 };

    sbuf[1] = chCommand;

    send( pwi->nd.hsd, ( char * )sbuf, sizeof( sbuf ), 0 );
}

void
FSendChars(HWND hwnd, WCHAR rgchChar[], int iLength )
{
    WI *pwi = (WI *)GetWindowLongPtr(hwnd, WL_TelWI);    
    CHAR rgchMBChar[ SMALL_STRING ];

    iLength = WideCharToMultiByte( GetConsoleCP(), 0, rgchChar, iLength, 
                                    rgchMBChar, (SMALL_STRING - sizeof(CHAR)), NULL, NULL );

    send( pwi->nd.hsd, rgchMBChar, iLength, 0 );
}


void
FDisableFlush(HWND hwnd)
{
    WI *pwi = (WI *)GetWindowLongPtr(hwnd, WL_TelWI);

    if (ui.fFlushOut) {
        ui.fFlushOut = 0;
        DoIBMANSIOutput(pwi, &pwi->trm, strlen( ( CHAR * ) szNewLine), szNewLine);
#ifdef TCPTEST
        OutputDebugString("Disable Flush\n");
#endif
    }
}

void
FProcessDont(WI *pwi, LPSTR *ps)
{
    unsigned char sbuf[16];

    sbuf[0] = IAC;
    sbuf[1] = WONT;

    switch (*(unsigned char FAR *)(*ps)) {

    default:
        sbuf[2] = *(unsigned char FAR *)(*ps);
        break;
    }

    FWriteToNet(pwi, ( char* )sbuf, 3);

    if( *(*ps) == TO_NAWS )
    {
        g_bDontNAWSReceived = TRUE;
    }
}

void DoNawsSubNegotiation( WI *pwi )
{
    unsigned char sbuf[16];
    INT iIndex = 0;

    sbuf[iIndex++] = IAC;
    sbuf[iIndex++] = SB;
    sbuf[iIndex++] = TO_NAWS;
    sbuf[iIndex++] = 0;
    sbuf[iIndex++] = ( UCHAR ) ( (pwi->sbi.srWindow.Right - pwi->sbi.srWindow.Left) + 1 ) ;
    sbuf[iIndex++] = 0;
    sbuf[iIndex++] = ( UCHAR )( ( pwi->sbi.srWindow.Bottom - pwi->sbi.srWindow.Top ) + 1 );
    sbuf[iIndex++] = IAC;
    sbuf[iIndex++] = SE;

    FWriteToNet(pwi, ( char* )sbuf, iIndex );
}

void
FProcessDo(WI *pwi, LPSTR *ps)
{
    unsigned char sbuf[16];
    BOOL bWriteToNet = TRUE;

    sbuf[0] = IAC;
    sbuf[1] = WONT;

    switch (*(unsigned char FAR *)(*ps)) {
    case TO_NEW_ENVIRON:
        sbuf[1] = WILL;
        sbuf[2] = TO_NEW_ENVIRON;
        break;
    
    case TO_NAWS:
        {
            INT iIndex = 1;

            if( !g_fSentWillNaws )
            {
                sbuf[iIndex++] = WILL;
                sbuf[iIndex++] = TO_NAWS;
                FWriteToNet(pwi, ( char* )sbuf, iIndex );
                g_fSentWillNaws = TRUE;
            }

            DoNawsSubNegotiation( pwi );
            pwi->nd.fRespondedToDoNAWS = TRUE;
            bWriteToNet = FALSE;
        }
        break;

    case TO_ECHO:
        sbuf[1] = WILL;
        sbuf[2] = TO_ECHO;
        break;

    case TO_BINARY:
        sbuf[1] = WILL;
        sbuf[2] = TO_BINARY;
        break;

    case TO_TERM_TYPE:        /* terminal type */
        sbuf[1] = WILL;
        sbuf[2] = TO_TERM_TYPE;


        if( !pwi->nd.fRespondedToDoNAWS && !g_fSentWillNaws )
        {
            sbuf[3] = IAC;
            sbuf[4] = WILL;
            sbuf[5] = TO_NAWS;
            bWriteToNet = FALSE;
            FWriteToNet(pwi, ( char* )sbuf, 6);
            g_fSentWillNaws = TRUE;
        }

        // haven't sent the termtype over yet.
        pwi->trm.SentTermType = TT_UNKNOWN;
        break;
    
    case TO_AUTH:

        if( pwi->nd.fRespondedToDoAUTH )
            return;

        if( ui.bWillAUTH )
            sbuf[1] = WILL;
        sbuf[2] = TO_AUTH;
        pwi->nd.fRespondedToDoAUTH = TRUE;
        break;

    case TO_SGA: // will SUPPRESS-GO-AHEAD
        sbuf[1] = WILL;
        sbuf[2] = TO_SGA;

        break;

    default:
        sbuf[2] = *(unsigned char FAR *)(*ps);
        break;
    }
    
    if ( bWriteToNet )
    {
        FWriteToNet(pwi, ( char* )sbuf, 3);
    }
}

void
FProcessWont(WI *pwi, LPSTR *ps)
{
    unsigned char sbuf[16];

    sbuf[0] = IAC;
    sbuf[1] = DONT;

    switch (*(unsigned char FAR *)(*ps)) {

    case TO_ECHO:
        sbuf[2] = TO_ECHO;
        break;
    case TO_TERM_TYPE:
        sbuf[2] = TO_TERM_TYPE;
        break;
    case TO_TM:
        FDisableFlush(pwi->hwnd);
        return;
    default:
        sbuf[2] = *(unsigned char FAR *)(*ps);
        break;
    }
    FWriteToNet(pwi, ( char* )sbuf, 3);
}

void
FProcessWill(WI *pwi, LPSTR *ps)
{
    unsigned char sbuf[16];
    BOOL bWriteToNet = TRUE;

    sbuf[0] = IAC;
    sbuf[1] = DONT;

    switch (*(unsigned char FAR *)(*ps)) {

    case TO_ECHO:

        if( pwi->nd.fRespondedToWillEcho )
            return;

        sbuf[1] = DO;
        sbuf[2] = TO_ECHO;
        pwi->nd.fRespondedToWillEcho = TRUE;
        break;

    case TO_TM:
        FDisableFlush(pwi->hwnd);
        return;

    case TO_SGA:

        if( pwi->nd.fRespondedToWillSGA )
            return;

        sbuf[1] = DO;
        sbuf[2] = TO_SGA;
        pwi->nd.fRespondedToWillSGA = TRUE;
        break;

    case TO_BINARY:

        sbuf[1] = DO;
        sbuf[2] = TO_BINARY;
        
        break;

#if 0
    case TO_NTLM:

        if ( pwi->nd.fRespondedToWillNTLM )
            return;

        if ( ui.bDoNTLM )
            sbuf[1] = DO;
        sbuf[2] = TO_NTLM;
        pwi->nd.fRespondedToWillNTLM = TRUE;
        if ( ui.bDoNTLM )
        {
            bWriteToNet = FALSE;
            FWriteToNet(pwi, sbuf, 3);
            StartNTLMAuth(pwi);
        }
        break;
#endif

    default:
        sbuf[2] = *(unsigned char FAR *)(*ps);
        break;
    }
    if ( bWriteToNet )
        FWriteToNet(pwi, ( char* )sbuf, 3);
}



BOOL StuffEscapeIACs( PUCHAR* ppBufDest, UCHAR bufSrc[], DWORD* pdwSize )
{
    size_t length;
    int cursorDest = 0;
    int cursorSrc = 0;
    BOOL found = FALSE;
    PUCHAR pDest = NULL;
    
    if( *pdwSize <= 0 )
    {
        return ( found );
    }

    //get the location of the first occurrence of IAC
    pDest = (PUCHAR) memchr( bufSrc, IAC, *pdwSize ); //attack? pdwsize could not be traced back to see if it's always valid.
    
    if( pDest == NULL )
    {
        return ( found );
    }

    *ppBufDest = (PUCHAR) malloc( *pdwSize * 2 );
    if( *ppBufDest == NULL )
    {
        ASSERT( ( 0, 0 ) );
        return ( found );
    }
    
    while( pDest != NULL )
    {
        //copy data upto and including that point
        length = (pDest - ( bufSrc + cursorSrc)) + 1 ;
        memcpy( *ppBufDest + cursorDest, bufSrc + cursorSrc, length ); //attack? length could not be traced back to see if it's always valid.
        cursorDest += length;

        //stuff another TC_IAC
        (*ppBufDest)[ cursorDest ] = IAC;
        cursorDest++;
        
        cursorSrc += length;
        pDest = (PUCHAR) memchr( bufSrc + cursorSrc, IAC, 
                *pdwSize - cursorSrc ); //attack? pdwsize could not be traced back to see if it's always valid.
    }
    
    //copy remaining data
    memcpy( *ppBufDest + cursorDest, bufSrc + cursorSrc,
        *pdwSize - cursorSrc ); //attack? pdwsize could not be traced back to see if it's always valid.

    
    if( cursorDest )
    {
        *pdwSize += cursorDest - cursorSrc;
        found = TRUE;
    }
    
    return ( found );
}

INT GetVariable( UCHAR rgchBuffer[], CHAR szVar[] )
{
    INT iIndex = 0;
    INT iVarIndex = 0;

    while( iIndex < MAX_BUFFER_SIZE && iVarIndex < MAX_STRING_LENGTH 
           && rgchBuffer[ iIndex ] != VAR 
           && rgchBuffer[ iIndex ] != USERVAR 
           && ( !( rgchBuffer[ iIndex ] == IAC && rgchBuffer[ iIndex + 1 ] == SE ) )
           )
    {
        if( rgchBuffer[ iIndex ] == ESC )
        {
            //ignore ESC and take the next char as part of name
            iIndex++;
        }
        szVar[ iVarIndex++ ] = rgchBuffer[ iIndex++ ];
    }

    szVar[ iVarIndex ] = 0;
    return iIndex;
}


void PutDefaultVarsInBuffer( UCHAR ucBuffer[], INT *iIndex )
{
    ASSERT( iIndex );

    if( wcscmp( szUserName, ( LPTSTR )L"" ) != 0 )
    {
        DWORD dwNum;

		ASSERT( szUser );

        if( *iIndex + 
            ( strlen( USER ) + 1 ) + 
            ( strlen( szUser ) + 1 ) + 
            ( strlen( SYSTEMTYPE ) + 1 ) + 
            ( strlen( WIN32_STRING ) + 1 ) > MAX_STRING_LENGTH )
        {
            ASSERT( 0 );
            return;
        }

        {
            //variable USER
            ucBuffer[ ( *iIndex )++ ] = VAR;
            strcpy( ucBuffer + ( *iIndex ), USER ); //no overflow. USER is const char *
            *iIndex = *iIndex + strlen( USER ) ;
            ucBuffer[ ( *iIndex )++ ] = VALUE;
            strcpy(ucBuffer+( *iIndex ), szUser ); //no overflow. SzUser is valid, NULL terminated.
            *iIndex = ( *iIndex ) + strlen( szUser);
        }

        {
            //variable SYSTEMTYPE
            ucBuffer[( *iIndex )++] = VAR;
            strcpy(ucBuffer+( *iIndex ), SYSTEMTYPE ); //no overflow. SYSTEMTYPE is const char *
            *iIndex = ( *iIndex ) + strlen( SYSTEMTYPE );
            ucBuffer[( *iIndex )++] = VALUE;
            strcpy(ucBuffer+( *iIndex ), WIN32_STRING );//no overflow. WIN32_STRING is const char *
            *iIndex = ( *iIndex ) + strlen( WIN32_STRING );
        }
    }

    return;
}

void
FProcessSB(WI * pwi, LPSTR *ps, int *recvsize)
{
    unsigned char sbuf[16];
    int inx;
    int i = 0;
    int cbLeft = *recvsize;

    //
    //  Is the end of this option in the receive buffer?
    //

    while ( cbLeft )
    {
        if ( ((unsigned char) (*ps)[i]) == (unsigned char) SE )
            goto Found;

        cbLeft--;
        i++;
    }

    //
    //  We ran out of buffer before finding the end of the option.  IAC and
    //  SB were already eaten so add them
    //

#ifdef  TCPTEST
    OutputDebugString("FProcessSB: saving incomplete option for next recv\n");

#endif

    pwi->nd.lpTempBuffer[0] = (unsigned char) IAC;
    pwi->nd.lpTempBuffer[1] = (unsigned char) SB;

    for ( i = 2, cbLeft = (*recvsize+2); i < cbLeft; i++ )
        pwi->nd.lpTempBuffer[i] = (*ps)[i-2];

    pwi->nd.cbOld = *recvsize + 2;
    *recvsize = 0;

    return;

Found:
    switch (*(unsigned char FAR *)(*ps)) {

    case TO_NEW_ENVIRON:

        //MBSC user name value now available in szUser

        if( *(unsigned char FAR *)(*ps+1) == TT_SEND )
        {
            PUCHAR ucServerSentBuffer = *ps;

            UCHAR  ucBuffer[ MAX_BUFFER_SIZE + 2 ];
            int   iIndex = 0;
            ucBuffer[ iIndex++ ] = ( UCHAR )IAC;
            ucBuffer[ iIndex++] = ( UCHAR )SB;
            ucBuffer[ iIndex++] = TO_NEW_ENVIRON;
            ucBuffer[ iIndex++] = TT_IS;
            inx =  iIndex;
            if( *(unsigned char FAR *)(ucServerSentBuffer+2) == IAC && 
                    *(unsigned char FAR *)(ucServerSentBuffer+3) == SE )
            {
                PutDefaultVarsInBuffer( ucBuffer, &inx );
            }

            else
            {
                ucServerSentBuffer = ucServerSentBuffer + 2 ;  // eat TO_NEW_ENVIRON, TT_SEND
                while ( !( *ucServerSentBuffer == IAC && *(ucServerSentBuffer+1) == SE )  
                        && inx < MAX_BUFFER_SIZE  ) 
                {
                    CHAR szVar[ MAX_STRING_LENGTH ];
                    CHAR *pcVal = NULL;

                    switch( *(unsigned char FAR *)(ucServerSentBuffer) )
                    {
                        case VAR:
                            ( ucServerSentBuffer )++; //eat VAR
                            if( ( *ucServerSentBuffer == IAC &&
                                  *(ucServerSentBuffer+1) == SE ) ||
                                  *ucServerSentBuffer == USERVAR )
                            {
                                //send defaults
                                PutDefaultVarsInBuffer( ucBuffer, &inx );
                            }
                            else
                            {
                                ucServerSentBuffer += GetVariable( ucServerSentBuffer, szVar ); //GetVariable returns consumed net data
                                if( inx + strlen( szVar ) + 1 < MAX_BUFFER_SIZE )
                                {
                                    ucBuffer[ inx++ ] = VAR;

                                    //copy name of the variable
                                    strncpy( ucBuffer+inx, szVar, MAX_BUFFER_SIZE - inx);
                                    inx += strlen( szVar );
                                }

                                //now copy the value if defined
                                if( strcmp( szVar, USER ) == 0 )
                                {
                                    if( inx + strlen( szUser ) + 1 < MAX_BUFFER_SIZE  )
                                    {
                                        ucBuffer[inx++] = VALUE;
                                        strncpy(ucBuffer+inx, szUser, MAX_BUFFER_SIZE - inx );
                                        inx = inx + strlen( szUser);
                                    }
                                }
                                else if( strncmp( szVar, SYSTEMTYPE, strlen( SYSTEMTYPE ) ) == 0 )
                                {
                                    if( inx + strlen( WIN32_STRING ) + 1 < MAX_BUFFER_SIZE )
                                    {
                                        ucBuffer[inx++] = VALUE;
                                        strncpy(ucBuffer+ inx, WIN32_STRING,MAX_BUFFER_SIZE - inx );
                                        inx = inx + strlen( WIN32_STRING );
                                    }
                                }
                                else
                                {
                                    //do nothing. It means, variable is undefined
                                }
                            }
                            break;

                        case USERVAR:
                            ( ucServerSentBuffer )++; //eat USERVAR
                            if( ( *ucServerSentBuffer == IAC &&
                                    *(ucServerSentBuffer+1) == SE ) ||
                                    *ucServerSentBuffer == VAR )
                            {
                                //send defaults ie; NONE
                            }
                            else
                            {
                                //Send the variable that is asked for

                                DWORD dwSize = 0;
                                
                                ucServerSentBuffer += GetVariable( ucServerSentBuffer, szVar );
                                if( inx + strlen( szVar ) + 1 < MAX_BUFFER_SIZE )
                                {
                                    ucBuffer[inx++] = USERVAR;
                                    strncpy( ucBuffer+inx, szVar,MAX_BUFFER_SIZE - inx );
                                    inx += strlen( szVar );
                                }
                                
                                dwSize = GetEnvironmentVariableA( szVar, NULL, 0 );

                                if( dwSize > 0 )
                                {
                                    pcVal = ( CHAR * ) malloc( dwSize + DELTA ); //This delta is meant for 
                                                                                 //holding any ESC chars
                                    if( !pcVal )
                                    {
                                        return;
                                    }
                                        
                                    if( GetEnvironmentVariableA( szVar, pcVal, dwSize ) )
                                    {
                                        INT x = 0;
                                        INT iNeedForEsc = 0;
                                        CHAR cVar = VAR, cUserVar = USERVAR;

                                        x = strlen( pcVal ) - 1;
                                        while( x >= 0  )
                                        {
                                            if( pcVal[ x ] >= cVar && pcVal[ x ] <= cUserVar )
                                            {
                                                //needs an ESC char
                                                iNeedForEsc++;
                                            }

                                            x--;
                                        }

                                        if( iNeedForEsc && iNeedForEsc < DELTA )
                                        {
                                            x = strlen( pcVal );

                                            //Null char is same as of VAR. So, special case.
                                            pcVal[ x + iNeedForEsc ] = pcVal[ x-- ];

                                            while( x >= 0 )
                                            {                                                
                                                pcVal[ x + iNeedForEsc ] = pcVal[ x ];
                                                if( pcVal[ x ] >= cVar && pcVal[ x ] <= cUserVar )
                                                {
                                                    //needs an ESC char
                                                    iNeedForEsc--; 
                                                    pcVal[ x + iNeedForEsc ] = ESC;                                                                                                       
                                                }

                                                x--;
                                            }
                                        }

                                        if( inx + strlen( pcVal ) + 1 < MAX_STRING_LENGTH )
                                        {
                                            //write VALUE keyword
                                            ucBuffer[inx++] = VALUE;
                                        
                                            //write actual value
                                            strncpy(ucBuffer+ inx, pcVal,MAX_BUFFER_SIZE - inx );
                                            inx = inx + strlen( pcVal );
                                        }
                                    }
                                    free( pcVal );
                                }
                            }
                            break;

                        default:
                            ASSERT( 0 ); //This should not happen. Only types we know are VAR and USERVAR
                            break;
                    }
                }
            }

            ucBuffer[inx++] = ( UCHAR )IAC;
            ucBuffer[inx++] = ( UCHAR )SE;
            FWriteToNet(pwi, ucBuffer, inx);
        }

        break;

    case TO_TERM_TYPE:

        // This is guaranteed to happen after an authentication has happened so we can start obeying the 
        // local echo settings...

        ui.fDebug |= ui.honor_localecho;    // restore the saved echo settings.

        if( *(unsigned char FAR *)(*ps+1) == TT_SEND )
        {

            sbuf[0] = IAC;
            sbuf[1] = SB;
            sbuf[2] = TO_TERM_TYPE;
            sbuf[3] = TT_IS;
            inx = 4;

            if( pwi->trm.SentTermType == TT_UNKNOWN && 
                pwi->trm.RequestedTermType != TT_UNKNOWN )
            {
                // we haven't started the negotiation yet and the user has specified
                // a preferred term type, so we start with that.
                // RequestedTermType here is the user's setting not the server's.
                pwi->trm.CurrentTermType = pwi->trm.RequestedTermType;
                pwi->trm.FirstTermTypeSent = pwi->trm.CurrentTermType;
            }
            else
            {
                pwi->trm.CurrentTermType = (pwi->trm.CurrentTermType + 1) % 4;

                if( pwi->trm.CurrentTermType == pwi->trm.FirstTermTypeSent )
                    pwi->trm.CurrentTermType = pwi->trm.SentTermType;
            }
			//write maximum number of n bytes where n = sizeof(sbuf)-CurrentLength(sbuf)-2BytesForIACandSE-1ForNULL
            strncpy( (char *) sbuf+4, rgchTermType[pwi->trm.CurrentTermType],16 - strlen(sbuf) -2 -1); 
            inx += strlen(rgchTermType[pwi->trm.CurrentTermType]);

            sbuf[inx++] = IAC;
            sbuf[inx++] = SE;

            // set the Sent TermType to what we just sent
            pwi->trm.SentTermType = pwi->trm.CurrentTermType ;


            FWriteToNet(pwi, ( char * )sbuf, inx);
        }

        break;

#if 1
    case TO_AUTH:

        if( (*(unsigned char FAR *)(*ps+1) == AU_SEND) && (*(unsigned char FAR *)(*ps+2) == AUTH_TYPE_NTLM) ) 
        {
			if ( pwi->eState!= Connecting || !PromptUser() || !StartNTLMAuth(pwi) )
            {
                // there has been an error.

                pwi->eState = Telnet;

                sbuf[0] = IAC;
                sbuf[1] = SB;
                sbuf[2] = TO_AUTH;
                sbuf[3] = AU_IS;
                sbuf[4] = AUTH_TYPE_NULL;
                sbuf[5] = 0;
                sbuf[6] = IAC;
                sbuf[7] = SE;

                FWriteToNet(pwi, ( char * )sbuf, 8);

            }
        } 
        else if( (*(unsigned char FAR *)(*ps+1) == AU_REPLY) && (*(unsigned char FAR *)(*ps+2) == AUTH_TYPE_NTLM) ) 
        {
            // ps + 3 is the modifier and for NTLM it is AUTH_CLIENT_TO_SERVER & AUTH_ONE_WAY.
            // ps + 4 is the NTLM accept or NTLM challenge or NTLM reject
            
            switch ( *(unsigned char FAR *)(*ps+4) )
            {

            case NTLM_CHALLENGE:
                if( pwi->eState != Authenticating || !DoNTLMAuth(pwi, (unsigned char FAR *)(*ps+5), *recvsize-5) )
                {
                    // there has been an error.

                    pwi->eState = Telnet;

                    sbuf[0] = IAC;
                    sbuf[1] = SB;
                    sbuf[2] = TO_AUTH;
                    sbuf[3] = AU_IS;
                    sbuf[4] = AUTH_TYPE_NULL;
                    sbuf[5] = 0;
                    sbuf[6] = IAC;
                    sbuf[7] = SE;

                    FWriteToNet(pwi, ( char * )sbuf, 8);
                }
                break;
            case NTLM_ACCEPT:
            	//fall through
            case NTLM_REJECT:
            	//fall through
            default:
                pwi->eState = Telnet;
				if( pwi->eState == Authenticating || pwi->eState == AuthChallengeRecvd )
				{
	                NTLMCleanup();
				}
                break;
            }

        }
        else
        {
            pwi->eState = Telnet;

            sbuf[0] = IAC;
            sbuf[1] = SB;
            sbuf[2] = TO_AUTH;
            sbuf[3] = AU_IS;
            sbuf[4] = AUTH_TYPE_NULL;
            sbuf[5] = 0;
            sbuf[6] = IAC;
            sbuf[7] = SE;

            FWriteToNet(pwi, ( char * )sbuf, 8);
        }

        break;
#endif

    default:

        break;
    }


    while (*(unsigned char FAR *)(*ps) != SE) {
        (*ps) = (char FAR *)(*ps) + 1;
        *recvsize = *recvsize - 1;
    }

    //
    //  Do one more to step over the SE
    //

    (*ps) = (char FAR *)(*ps) + 1;
    *recvsize = *recvsize - 1;

}

void
FProcessIAC(
    HWND    hwnd,
    WI *    pwi,
    LPSTR * ps,
    LPSTR * pd,
    int *   recvsize,
    int *   t_size)
{
    UCHAR ch = *(unsigned char FAR *)(*ps);

    ui.nottelnet = FALSE;   // We can safely say that we are talking to a telnet server now...

    //
    //  The IAC has already been subtracted from *recvsize
    //

    //
    //  Make sure we have enough recv buffer to process the rest of the IAC
    //  We know the DO, DONT etc. options always take two bytes plus the IAC.
    //

    if ( ((ch == DONT || ch == DO ||
           ch == WILL || ch == WONT) && *recvsize < 2) ||
          (ch != SB && *recvsize < 1) )
    {
        int i;

#ifdef  TCPTEST
        OutputDebugString("FProcessIAC: saving incomplete option for next recv\n");
#endif

        //
        //  IAC was previously eaten
        //

        pwi->nd.lpTempBuffer[0] = (unsigned char) IAC;

        for ( i = 1; i < (*recvsize+1); i++ )
            pwi->nd.lpTempBuffer[i] = (*ps)[i-1];

        pwi->nd.cbOld = *recvsize + 1;
        *recvsize = 0;

        return;
    }

    switch (*(unsigned char FAR *)(*ps)) {

    case DONT:
        (*ps) = (char FAR *)(*ps) + 1;

        /* process options */
        FProcessDont(pwi, ps);

#ifdef  TCPTEST
        OutputDebugString("DONT \n");
#endif

        (*ps) = (char FAR *)(*ps) + 1;
        *recvsize = *recvsize - 2;
        break;

    case DO:

        (*ps) = (char FAR *)(*ps) + 1;

        /* process options */
        FProcessDo(pwi, ps);
#ifdef  TCPTEST
        OutputDebugString("DO \n");
#endif

        (*ps) = (char FAR *)(*ps) + 1;

        *recvsize = *recvsize - 2;
        break;

    case WONT:

        (*ps) = (char FAR *)(*ps) + 1;

        /* process options */
        FProcessWont(pwi, ps);
#ifdef  TCPTEST
        OutputDebugString("WONT \n");
#endif

        (*ps) = (char FAR *)(*ps) + 1;

        *recvsize = *recvsize - 2;
        break;

    case WILL:

        (*ps) = (char FAR *)(*ps) + 1;

        /* process options */
        FProcessWill(pwi, ps);

#ifdef  TCPTEST
        OutputDebugString("WILL \n");
#endif

        (*ps) = (char FAR *)(*ps) + 1;

        *recvsize = *recvsize - 2;
        break;

    case SB:

        (*ps) = (char FAR *)(*ps) + 1;

        *recvsize -= 1;

        /* process options */
        FProcessSB(pwi, ps, recvsize);
        break;

    default:

        (*ps) = (char FAR *)(*ps) + 1;

        *recvsize -= 1;
        break;

    }

}

#ifdef TCPTEST
VOID DumpBuffer( VOID FAR * pbuff, DWORD cb )
 {
#define NUM_CHARS 16
    DWORD i, limit;
    CHAR TextBuffer[NUM_CHARS + 1];
    LPBYTE BufferPtr;

    if ( !pbuff )
    {
        OutputDebugString("No buffer\n");
        return;
    }


    BufferPtr = (LPBYTE) pbuff;

    //
    // Hex dump of the bytes
    //
    limit = ((cb - 1) / NUM_CHARS + 1) * NUM_CHARS;

    for (i = 0; i < limit; i++) {

        if (i < cb) {

            snprintf(DebugBuffer,sizeof(DebugBuffer)-1, "%02x ", BufferPtr[i]);
            OutputDebugString( DebugBuffer );

            if (BufferPtr[i] < 31 ) {
                TextBuffer[i % NUM_CHARS] = '.';
            } else if (BufferPtr[i] == '\0') {
                TextBuffer[i % NUM_CHARS] = ' ';
            } else {
                TextBuffer[i % NUM_CHARS] = (CHAR) BufferPtr[i];
            }

        } else {

            OutputDebugString("   ");
            TextBuffer[i % NUM_CHARS] = ' ';
        }

        if ((i + 1) % NUM_CHARS == 0) {
            TextBuffer[NUM_CHARS] = 0;
            snprintf(DebugBuffer,sizeof(DebugBuffer)-1, "  %s\n", TextBuffer);
            OutputDebugString( DebugBuffer );
        }
    }
}
#endif

void FProcessSessionData( int cBytes, PUCHAR pchNBBuffer, WI *pwi )
{
	WaitForSingleObject( g_hCaptureConsoleEvent, INFINITE );

    WaitForSingleObject( g_hRemoteNEscapeModeDataSync, INFINITE );
	if( pwi->hOutput != g_hSessionConsoleBuffer )
	{
		pwi->hOutput = g_hSessionConsoleBuffer;
	    SetConsoleActiveScreenBuffer(g_hSessionConsoleBuffer);
	}
/*This is needed so that we don't write data to the session even after disconnection of client */
    if( !fConnected )
    {
        return;
    } 

    ResetEvent( g_hRemoteNEscapeModeDataSync );
    if( pwi->trm.CurrentTermType == TT_VTNT )
    {
        if( !DoVTNTOutput(pwi, &pwi->trm, cBytes, pchNBBuffer) )
        {
            //
            // The following two lines were originally added as a
            // mechanism of defaulting to VT100 in case of some servers
            // accepting VTNT, during term type negotiation, even though
            // in reality they do not support VTNT. Specifically, Linux
            // was showing this behavior during our testing. But the
            // function DoVTNTOutput returns FALSE even in other cases
            // such as, when we get some junk data from the server. In
            // such cases we should not call DoIBMANSIOutput (bug 1119).
            //
            pwi->trm.CurrentTermType = TT_ANSI;
            DoIBMANSIOutput(pwi, &pwi->trm, cBytes, pchNBBuffer);
        }
    }
    else
    {
        DoIBMANSIOutput(pwi, &pwi->trm, cBytes, pchNBBuffer);
    }

    pwi->ichTelXfer = 0;
    SetEvent( g_hRemoteNEscapeModeDataSync );
}


void
FProcessFDRead(HWND hwnd)
{
    WI *pwi = (WI *)GetWindowLongPtr(hwnd, WL_TelWI);
    int recvsize, t_size;
    LPSTR ps, pd;

    //
    //  pwi->nd.cbOld Is the number of bytes left over from the previous
    //  packet that we kept in pwi->nd.lpTempBuffer
    //

    if ((recvsize=recv(pwi->nd.hsd,
                       pwi->nd.lpTempBuffer + pwi->nd.cbOld,
                       READ_BUF_SZ - pwi->nd.cbOld,
                       0)) < 0) 
    {
             return;
    }

    //
    // Fix to bug 284
    //
    Sleep(0);

    recvsize += pwi->nd.cbOld;
    pwi->nd.cbOld = 0;

    ps = pwi->nd.lpTempBuffer;
    pd = pwi->nd.lpReadBuffer;
    t_size = 0;

    while( recvsize-- ) 
    {

        if( *(unsigned char FAR *) ps == (unsigned char)IAC ) 
        {

            if( recvsize == 0 ) 
            {
                pwi->nd.lpTempBuffer[0] = (unsigned char) IAC;
                pwi->nd.cbOld = 1;
                break;
            }

            ps++;

            if( *(unsigned char FAR *)ps == (unsigned char)IAC ) 
            {

                //
                //  This was an escaped IAC so put it in the normal
                //  input buffer
                //

                ps++;
                *(unsigned char FAR *)pd = (unsigned char)IAC;
                pd++;

                r