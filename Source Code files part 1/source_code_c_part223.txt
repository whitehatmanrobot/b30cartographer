

Arguments:

    lpRegString - string loaded from the registry
    lpExeString - string loaded from the app's resource section

Return Value:

    same as wcscmp: 0 for equal, nonzero non-equal

--*/
{
    LPCWSTR pRegStar;

    if (wcscmp(lpRegString, lpExeString) == 0) {
        // an exact match
        return 0;
    }
    // not an exact match - see if the registry key contains a wildcard
    pRegStar = wcschr(lpRegString, L'*');
    if (!pRegStar) {
        // No wildcard in the registry key, so no match
        return -1;
    }
    if (pRegStar == lpRegString) {
        // Wildcard is the first character - match everything
        return 0;
    }
    // Compare only upto the character before the '*'
    return wcsncmp(lpRegString, lpExeString,
                   pRegStar - lpRegString);
}

BOOL
CheckMapArguments(
    HKEY hkeyMapping,
    LPCWSTR lpApplicationName,
    LPCWSTR lpProductName,
    LPCWSTR lpInternalName,
    LPCWSTR lpProductVersion,
    LPWSTR  lpMappedApplicationName,
    DWORD   dwMappedApplicationNameSize,
    BOOL    fPrefixMappedApplicationName,
    LPCWSTR lpCommandLine,
    LPWSTR *lplpMappedCommandLine
    )
/*++

Routine Description:

    Attempts to map a Win16 application and command line to their ported version
    using a single entry in the NtVdm64 mapping in the registry.

Arguments:

    hkeyMapping - open registry keyfor the mapping entry
    lpApplicationName - Win16 file name (with path)
    lpExeName - Win16 file name wihtout path
    lpProductName - value of ProductName Version resource of lpApplicationName
    lpProductVersion - value of ProductVersion version resource of lpApplicationName
    lpMappedApplicationName - returns the name of the ported version
               of lpApplicationName
    dwMappedApplicationNameSize - size of lpMappedApplicationName buffer
    fPrefixMappedApplicationName
        - TRUE means that the original lpApplicationName was NULL.
               The application name was stripped from the head of
               lpCommandLine.
               The mapped application name needs to be added to the
               head of the mapped command line.
        - FALSE means that the original lpAPplicationName was non-NULL.
               the lpCommandLine argument is identical to the original
               lpCommandLine argument.
    lpCommandLine - see comment for fPrefixMappedApplicationName.
    lplpMappedCommandLine - returns the mapped command line
               caller must free the returned pointer using RtlFreeHeap

Return Value:

    TRUE if the mapping was successful

--*/
{
    WCHAR achBuffer[MAX_PATH+1];
    DWORD dwBufferLength;
    DWORD dwType;
    LONG result;

    dwBufferLength = ARRAYSIZE(achBuffer);
    result = RegQueryValueExW(hkeyMapping, L"ProductName", 0, &dwType, (LPBYTE)achBuffer, &dwBufferLength);
    if (ERROR_SUCCESS != result || dwType != REG_SZ) {
        DEBUG_PRINT(("NtVdm64: Failed to open ProductName REG_SZ key. Result %x. Type %x\n", result, dwType));
        return FALSE;
    }
    if (CompareStrings(achBuffer, lpProductName)) {
        DEBUG_PRINT(("NtVdm64: ProductName mismatch %ws vs %ws\n", achBuffer, lpProductName));
        return FALSE;
    }

    dwBufferLength = ARRAYSIZE(achBuffer);
    result = RegQueryValueExW(hkeyMapping, L"InternalName", 0, &dwType, (LPBYTE)achBuffer, &dwBufferLength);
    if (ERROR_SUCCESS != result || dwType != REG_SZ) {
        DEBUG_PRINT(("NtVdm64: Failed to open InternalName REG_SZ key. Result %x. Type %x\n", result, dwType));
        return FALSE;
    }
    if (CompareStrings(achBuffer, lpInternalName)) {
        DEBUG_PRINT(("NtVdm64: InternalName mismatch %ws vs %ws\n", achBuffer, lpInternalName));
        return FALSE;
    }

    dwBufferLength = ARRAYSIZE(achBuffer);
    result = RegQueryValueExW(hkeyMapping, L"ProductVersion", 0, &dwType, (LPBYTE)achBuffer, &dwBufferLength);
    if (ERROR_SUCCESS != result || dwType != REG_SZ) {
        DEBUG_PRINT(("NtVdm64: Failed to open ProductVersion REG_SZ key. Result %x. Type %x\n", result, dwType));
        return FALSE;
    }
    if (CompareStrings(achBuffer, lpProductVersion)) {
        DEBUG_PRINT(("NtVdm64: ProductVersion mismatch %ws vs %ws\n", achBuffer, lpProductVersion));
        return FALSE;
    }

    dwBufferLength = ARRAYSIZE(achBuffer);
    result = RegQueryValueExW(hkeyMapping, L"MappedExeName", 0, &dwType, (LPBYTE)achBuffer, &dwBufferLength);
    if (ERROR_SUCCESS != result) {
        DEBUG_PRINT(("NtVdm64: Failed to open MappedExeName REG_SZ key. Result %x.\n", result));
        return FALSE;
    }

    if (dwType == REG_EXPAND_SZ) {
        WCHAR achBuffer2[MAX_PATH+1];
        wcscpy(achBuffer2, achBuffer);
        dwBufferLength = ExpandEnvironmentStringsW(achBuffer2, achBuffer, ARRAYSIZE(achBuffer));
        if (dwBufferLength == 0 || dwBufferLength > ARRAYSIZE(achBuffer)) {
            DEBUG_PRINT(("NtVdm64: MappedExeName failed to expand environment strings in %ws. Length %x\n", achBuffer, dwBufferLength));
            return FALSE;
        }
    } else if (dwType != REG_SZ) {
        DEBUG_PRINT(("NtVdm64: MappedExeName value doesn't have string type. Type %x\n", dwType));
        return FALSE;
    }

    if (dwBufferLength > dwMappedApplicationNameSize) {
        DEBUG_PRINT(("NtVdm64: MappedExeName too long. Length %x\n", dwBufferLength));
        return FALSE;
    }
    wcscpy(lpMappedApplicationName, achBuffer);

    if (!MapCommandLine(hkeyMapping, lpApplicationName, lpMappedApplicationName, fPrefixMappedApplicationName, lpCommandLine, lplpMappedCommandLine)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
MapArguments(
    LPCWSTR lpApplicationName,
    LPWSTR lpMappedApplicationName,
    DWORD dwMappedApplicationNameSize,
    BOOL fPrefixMappedApplicationName,
    LPCWSTR lpCommandLine,
    LPWSTR *lplpMappedCommandLine
    )
/*++

Routine Description:

    Maps a Win16 application and command line to their ported version
    using the NtVdm64 mapping in the registry.

Arguments:

    lpApplicationName - Win16 file name not optional
    lpMappedApplicationName - returns the name of the ported version
               of lpApplicationName
    dwMappedApplicationNameSize - size of lpMappedApplicationName buffer
    fPrefixMappedApplicationName
        - TRUE means that the original lpApplicationName was NULL.
               The application name was stripped from the head of
               lpCommandLine.
               The mapped application name needs to be added to the
               head of the mapped command line.
        - FALSE means that the original lpAPplicationName was non-NULL.
               the lpCommandLine argument is identical to the original
               lpCommandLine argument.
    lpCommandLine - see comment for fPrefixMappedApplicationName.
    lplpMappedCommandLine - returns the mapped command line
               caller must free the returned pointer using RtlFreeHeap

Return Value:

    TRUE if the mapping was successful

--*/
{
    HKEY hkeyMappingRoot;
    LONG result;
    DWORD dwIndex;
    WCHAR achSubKeyName[MAX_PATH+1];
    DWORD dwSubKeyNameLength;
    BOOL mapped;
    WCHAR achExeNameBuffer[MAX_PATH+1];
    LPWSTR lpExeName;
    WCHAR achProductName[MAX_PATH+1];
    WCHAR achInternalName[MAX_PATH+1];
    WCHAR achProductVersion[MAX_PATH+1];

    //
    // get the .exe name without the preceding path
    //
    if (0 == SearchPathW(
                        NULL,
                        lpApplicationName,
                        (PWSTR)L".exe",
                        MAX_PATH,
                        achExeNameBuffer,
                        &lpExeName
                        )) {
        DEBUG_PRINT(("NtVdm64: SearchPathW failed: %ws\n", lpApplicationName));
        return FALSE;
    }


    if (!WowGetProductNameVersion(lpApplicationName,
                                  achProductName,
                                  ARRAYSIZE(achProductName),
                                  achInternalName,
                                  ARRAYSIZE(achInternalName),
                                  achProductVersion,
                                  ARRAYSIZE(achProductVersion))) {
        return FALSE;
    }

    mapped = FALSE;
    result = RegOpenKeyW(HKEY_LOCAL_MACHINE,
                         L"SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\NtVdm64",
                         &hkeyMappingRoot
                         );
    if (ERROR_SUCCESS != result) {
        DEBUG_PRINT(("NtVdm64: Failed to Open NtVdm64 Registry Key : %x\n", result));
        return FALSE;
    }
    dwIndex = 0;

    dwSubKeyNameLength = ARRAYSIZE(achSubKeyName);
    while (!mapped && ERROR_SUCCESS == (result = RegEnumKeyW(hkeyMappingRoot, dwIndex, achSubKeyName, dwSubKeyNameLength))) {

        HKEY hkeyMapping;

        result = RegOpenKeyW(hkeyMappingRoot, achSubKeyName, &hkeyMapping);
        if (ERROR_SUCCESS == result) {
            mapped = CheckMapArguments(hkeyMapping,
                                       lpApplicationName,
                                       achProductName,
                                       achInternalName,
                                       achProductVersion,
                                       lpMappedApplicationName,
                                       dwMappedApplicationNameSize,
                                       fPrefixMappedApplicationName,
                                       lpCommandLine,
                                       lplpMappedCommandLine);
            RegCloseKey(hkeyMapping);
        }

        dwSubKeyNameLength = ARRAYSIZE(achSubKeyName);
        dwIndex += 1;
    }

    RegCloseKey(hkeyMappingRoot);

    if ( !mapped )
       DEBUG_PRINT(("NtVdm64: Unknown 16bit app or given parameters are wrong\n"));


    return mapped;
}

extern
BOOL STDAPICALLTYPE ApphelpCheckExe(
    LPCWSTR lpApplicationName,
    BOOL    bApphelp,
    BOOL    bShim,
    BOOL    bUseModuleName);

BOOL
CheckAppCompat(
    LPCWSTR lpApplicationName
    )
/*++
    Check application compatibility database for blocked application,
    possibly show UI advising user of a problem
--*/
{


    return ApphelpCheckExe(lpApplicationName,
                           TRUE,
                           FALSE,
                           FALSE);
}

BOOL
WINAPI
NtVdm64CreateProcess(
    BOOL fPrefixMappedApplicationName,
    LPCWSTR lpApplicationName,
    LPCWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
/*++

Routine Description:

    Checks if there is a ported version of the Win16 lpApplicationName and
    if so creates a process with the ported version.

Arguments:

    fPrefixMappedApplicationName
        - TRUE means that the original lpApplicationName was NULL.
               The application name was stripped from the head of
               lpCommandLine.
               The mapped application name needs to be added to the
               head of the mapped command line.
        - FALSE means that the original lpAPplicationName was non-NULL.
               the lpCommandLine argument is identical to the original
               lpCommandLine argument.
    lpApplicationName - Win16 file name not optional
    lpCommandLine - see comment for fPrefixMappedApplicationName.

    other arguments are identical to CreateProcessW.

Return Value:

    Same as CreateProcessW

--*/
{
    WCHAR achMappedApplicationName[MAX_PATH+1];
    LPWSTR lpMappedCommandLine;
    BOOL Result;

    ASSERT(lpApplicationName);

    //
    // check appcompat
    //
    if (!CheckAppCompat(lpApplicationName)) {
        SetLastError(ERROR_CANCELLED);
        return FALSE;
    }


    if (lpCommandLine == NULL) {
        lpCommandLine = L"";
    }

    lpMappedCommandLine = NULL;
    Result = MapArguments(lpApplicationName,
                          achMappedApplicationName,
                          ARRAYSIZE(achMappedApplicationName),
                          fPrefixMappedApplicationName,
                          lpCommandLine,
                          &lpMappedCommandLine);

    if (Result) {
        Result = CreateProcessW((fPrefixMappedApplicationName ?
                                    NULL :
                                    achMappedApplicationName),
                                lpMappedCommandLine,
                                lpProcessAttributes,
                                lpThreadAttributes,
                                bInheritHandles,
                                dwCreationFlags,
                                lpEnvironment,
                                lpCurrentDirectory,
                                lpStartupInfo,
                                lpProcessInformation);
        if (lpMappedCommandLine) {
            RtlFreeHeap(RtlProcessHeap(), 0, lpMappedCommandLine);
        }
    } else {
        SetLastError(ERROR_BAD_EXE_FORMAT);
    }

    return Result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\regremap\w64shim.c ===
/*++

Copyright (c) 2002-  Microsoft Corporation

Module Name:

    w64shim.c 

Abstract:

    This module implement Handle redirection for registry redirection.

Author:

    ATM Shafiqul Khalid (askhalid) 12-March-2002

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <ntregapi.h>

#include "psapi.h"

#define _WOW64REFLECTOR_

#include "regremap.h"
#include "wow64reg.h"
#include "wow64reg\reflectr.h"


#ifdef _WOW64DLLAPI_
#include "wow64.h"
#else
#define ERRORLOG 1  //this one is completely dummy
#define LOGPRINT(x)
#define WOWASSERT(p)
#endif //_WOW64DLLAPI_


//HANDLE hIsDel = INVALID_HANDLE_VALUE;

HANDLE h_IsDel;

BOOL
InitWow64Shim ( )
/*++

Routine Description:

    Initialize Shim engine for wow64.

Arguments:

    None.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

    <TBD> this might allocate more memory and free up later.
--*/
{
    
        PPEB Peb = NtCurrentPeb ();
        PUNICODE_STRING Name = &Peb->ProcessParameters->ImagePathName;
        if ((Name->Length > 22) && (_wcsnicmp ( Name->Buffer + (Name->Length/2)-11, L"\\_isdel.exe",11) == 0)) {
            //
            // Image is _isdel.exe

                OBJECT_ATTRIBUTES   ObjectAttributes;
                NTSTATUS Status;
                IO_STATUS_BLOCK   statusBlock;
                UNICODE_STRING FileNameU;

                //
                // Open the file
                //
                if (!RtlDosPathNameToNtPathName_U(Name->Buffer,
                                                  &FileNameU,
                                                  NULL,
                                                  NULL)) {
                    // probably out-of-memory
                    return FALSE;
                }

                InitializeObjectAttributes(&ObjectAttributes,
                                           &FileNameU,
                                           OBJ_CASE_INSENSITIVE,
                                           NULL,
                                           NULL);

                Status = NtOpenFile(&h_IsDel,
                                FILE_READ_DATA,
                                &ObjectAttributes,
                                &statusBlock,
                                0, //FILE_SHARE_READ, //don't share
                                0);
                //
                // Nothing much we can do if the operation fails, its a plain hack.
                //

                RtlFreeHeap(RtlProcessHeap(), 0, FileNameU.Buffer);
        }
    return TRUE;
}

BOOL
CloseWow64Shim ()
{
    //
    //  close all the resources allocated during shim Init.
    //
    if ( h_IsDel != INVALID_HANDLE_VALUE ) {
        NtClose (h_IsDel);
        h_IsDel = INVALID_HANDLE_VALUE;
    }
    return TRUE;
}

#ifdef DBG

NTSTATUS
LogDriverAccess  (
        IN POBJECT_ATTRIBUTES ObjectAttributes
    )
/*++

Routine Description:

    If the application if trying to access driver [.sys] file, this API will dump a warning 
    message in the debugger. In the long run this routine might call some API to include 
    appropriate message to the event log so that administrator can diagnose this instance.
    In general creating 32bit driver files (mostly installation) on IA64 doesn't make any 
    sense at all and admin might need to know what are those files and which apps are touhing
    them.

    
Arguments:

    ObjectAttributes - object application is trying to access.

Return Value:

    None.

--*/
{
    WCHAR DriverNameBuff[MAX_PATH];
    WCHAR ImageNameBuff[MAX_PATH];
    DWORD CopyLength;

//
// Those definition will move in a header file while logging event.
//
#define WOW64_DRIVER_EXT_NAME L".sys"
#define WOW64_DRIVER_EXT_NAME_LENGTH (sizeof (WOW64_DRIVER_EXT_NAME)/sizeof(WCHAR) - 1 ) 

    try {
    if ( ( ObjectAttributes->ObjectName->Length > ( WOW64_DRIVER_EXT_NAME_LENGTH << 1 )) 
        && !_wcsnicmp ( ObjectAttributes->ObjectName->Buffer - WOW64_DRIVER_EXT_NAME_LENGTH + (ObjectAttributes->ObjectName->Length>>1), WOW64_DRIVER_EXT_NAME, WOW64_DRIVER_EXT_NAME_LENGTH)) {

        PPEB Peb = NtCurrentPeb ();
        PUNICODE_STRING ImageName;
        RTL_UNICODE_STRING_BUFFER DosNameStrBuf;
        UNICODE_STRING NtNameStr;
        
        if (Peb->ProcessParameters == NULL)
            return STATUS_SUCCESS;

        ImageName = &Peb->ProcessParameters->ImagePathName;
        RtlInitUnicodeStringBuffer(&DosNameStrBuf, 0, 0);

        CopyLength = min (ObjectAttributes->ObjectName->Length, sizeof (DriverNameBuff) - sizeof (UNICODE_NULL)); //skip \??\ ==>8 byte
        RtlCopyMemory (DriverNameBuff, (PBYTE)ObjectAttributes->ObjectName->Buffer + ObjectAttributes->ObjectName->Length - CopyLength, CopyLength);
        DriverNameBuff[CopyLength>>1] = UNICODE_NULL; //make sure NULL terminated

        RtlInitUnicodeString(&NtNameStr, DriverNameBuff);
        if ( NT_SUCCESS(RtlAssignUnicodeStringBuffer(&DosNameStrBuf, &NtNameStr)) &&
            NT_SUCCESS(RtlNtPathNameToDosPathName(0, &DosNameStrBuf, NULL, NULL)))  {
                 
                DosNameStrBuf.String.Buffer[DosNameStrBuf.String.Length>>1] = UNICODE_NULL;  // make sure NULL terminated is case it has been formatted.

                //
                // Extract Image name
                //
                ImageNameBuff[0] = UNICODE_NULL;
                if (ImageName->Length >0) {
                    ASSERT (ImageName->Buffer != NULL);

                    CopyLength = min (ImageName->Length, sizeof (ImageNameBuff) - sizeof (UNICODE_NULL));
                    RtlCopyMemory (ImageNameBuff, (PBYTE)ImageName->Buffer + ImageName->Length - CopyLength, CopyLength);
                    ImageNameBuff[CopyLength>>1] = UNICODE_NULL; //make sure NULL terminated
                }

                LOGPRINT((ERRORLOG,"Wow64-driver access warning: [%S] is a 32bit application trying to create/access 32bit driver [%S]\n", ImageNameBuff, DosNameStrBuf.String.Buffer));
                //
                //  BUGBUG: deny access to write files.
                //          Check file creation flag and also \drivers string.
                //
                return STATUS_ACCESS_DENIED;  
            }
            RtlFreeUnicodeStringBuffer(&DosNameStrBuf);
    }
    } except( EXCEPTION_EXECUTE_HANDLER){

        return STATUS_SUCCESS;
    }
    return STATUS_SUCCESS;
}
#endif 

BOOL
CheckAndThunkFileName  (
        IN OUT POBJECT_ATTRIBUTES ObjectAttributes,
        IN OUT PULONG pShareAccess,
        IN ULONG DesiredAccess,
        IN ULONG Option,
        IN ULONG DespositionFlag,
        IN ULONG CallFlag   //0 for NtOpenFile and 1- for NtCreateFile
    )
{
    NTSTATUS Ret;
    PUNICODE_STRING Name = ObjectAttributes->ObjectName;
    PUNICODE_STRING NewName = NULL;

    //
    // Check if any install shield stuff
    // Following code should be active in the process that does deal with 16bit process.
    // Need to initialize some flag possibly NtVdm64
    //


    try {

        //
        //  filter access for scripbuilder that pass 
        //  (ShareAccess= 0, DesAcc = 0x80100080, Options 0x60, Desposition = 1) that need to be failed 
        //  and (7, 0x100100, 204020, 0) and (7, 10080, 204040, 0) that doesn't need redirection
        //

        if (*pShareAccess == 0x7)
            return FALSE; //shared delete don't need any redirection
        //
        //
        //
        if (CallFlag == 0)  // Don't redirect OpenCall for the time being this was a hack for Scriptbuilder
            return FALSE;

    if ((Name->Length > 22) && (_wcsnicmp ( Name->Buffer + (Name->Length/2)-11, L"\\_isdel.exe",11) == 0)) {
        // Check if the name is \_isdel.exe
   

            PPEB Peb = NtCurrentPeb ();
            PUNICODE_STRING ImageName = &Peb->ProcessParameters->ImagePathName;
             if (
                (ImageName->Length > 36) &&             //check if its scriptbuilder
                (_wcsnicmp ( ImageName->Buffer + (ImageName->Length/2)-18, L"\\scriptbuilder.exe",18) == 0)
                ) {
    


                    //
                    // The memory allocation contains a terminating NULL character, but the
                    // Unicode string's Length does not.
                    //

                    SIZE_T SystemRootLength = wcslen(USER_SHARED_DATA->NtSystemRoot);
                    SIZE_T NameLength = sizeof(L"\\??\\")-sizeof(WCHAR) +
                                        SystemRootLength*sizeof(WCHAR) +
                                        sizeof(L'\\') +
                                        sizeof(WOW64_SYSTEM_DIRECTORY_U)-sizeof(WCHAR) +
                                        sizeof(L"\\InstallShield\\_isdel.exe");

                    NewName = Wow64AllocateTemp(sizeof(UNICODE_STRING)+NameLength);
                    NewName->Length = (USHORT)NameLength-sizeof(WCHAR);
                    NewName->MaximumLength = NewName->Length;
                    NewName->Buffer = (PWSTR)(NewName+1);
                    wcscpy(NewName->Buffer, L"\\??\\");
                    wcscpy(&NewName->Buffer[4], USER_SHARED_DATA->NtSystemRoot);
                    NewName->Buffer[4+SystemRootLength] = '\\';
                    wcscpy(&NewName->Buffer[4+SystemRootLength+1], WOW64_SYSTEM_DIRECTORY_U);
                    wcscpy(&NewName->Buffer[4+SystemRootLength+1+(sizeof(WOW64_SYSTEM_DIRECTORY_U)-sizeof (UNICODE_NULL))/sizeof(WCHAR)], L"\\InstallShield\\_isdel.exe");
                    ObjectAttributes->ObjectName = NewName;
                    ObjectAttributes->RootDirectory = NULL;

                    //
                    // DbgPrint ("\nPatched _isDel.exe Flag %x, %x, %x, %x, %x", *pShareAccess, DesiredAccess, Option,  DespositionFlag, CallFlag);
                    //

                    if ( pShareAccess != NULL )
                        *pShareAccess = 0;
                }

    } //if check _isdel
    } except( NULL, EXCEPTION_EXECUTE_HANDLER){

        return FALSE;
    }

    return TRUE;
}

NTSTATUS
Wow64NtCreateFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN PLARGE_INTEGER AllocationSize OPTIONAL,
    IN ULONG FileAttributes,
    IN ULONG ShareAccess,
    IN ULONG CreateDisposition,
    IN ULONG CreateOptions,
    IN PVOID EaBuffer OPTIONAL,
    IN ULONG EaLength
    )

/*++

Routine Description:

    This service opens or creates a file, or opens a device.  It is used to
    establish a file handle to the open device/file that can then be used
    in subsequent operations to perform I/O operations on.  For purposes of
    readability, files and devices are treated as "files" throughout the
    majority of this module and the system service portion of the I/O system.
    The only time a distinction is made is when it is important to determine
    which is really being accessed.  Then a distinction is also made in the
    comments.

Arguments:

    FileHandle - A pointer to a variable to receive the handle to the open file.

    DesiredAccess - Supplies the types of access that the caller would like to
        the file.

    ObjectAttributes - Supplies the attributes to be used for file object (name,
        SECURITY_DESCRIPTOR, etc.)

    IoStatusBlock - Specifies the address of the caller's I/O status block.

    AllocationSize - Initial size that should be allocated to the file.  This
        parameter only has an affect if the file is created.  Further, if
        not specified, then it is taken to mean zero.

    FileAttributes - Specifies the attributes that should be set on the file,
        if it is created.

    ShareAccess - Supplies the types of share access that the caller would like
        to the file.

    CreateDisposition - Supplies the method for handling the create/open.

    CreateOptions - Caller options for how to perform the create/open.

    EaBuffer - Optionally specifies a set of EAs to be applied to the file if
        it is created.

    EaLength - Supplies the length of the EaBuffer.

Return Value:

    The function value is the final status of the create/open operation.

--*/

{
    NTSTATUS Ret;

#ifdef DBG
    Ret = LogDriverAccess  ( ObjectAttributes);
     if (!NT_SUCCESS (Ret))
         return Ret;
#endif

    if ( CreateDisposition == FILE_OPEN ){ 

                CheckAndThunkFileName  (
                            ObjectAttributes,
                            &ShareAccess,
                            DesiredAccess,
                            CreateOptions,
                            CreateDisposition,
                            1
                            );
            }


    Ret = NtCreateFile(
                FileHandle,
                DesiredAccess,
                ObjectAttributes,
                IoStatusBlock,
                AllocationSize,
                FileAttributes,
                ShareAccess,
                CreateDisposition,
                CreateOptions,
                EaBuffer,
                EaLength
                );

    return Ret;
}

NTSTATUS
Wow64NtOpenFile(
    OUT PHANDLE FileHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG ShareAccess,
    IN ULONG OpenOptions
    )
{

    NTSTATUS Ret;

    CheckAndThunkFileName  (
            ObjectAttributes,
            &ShareAccess,
            DesiredAccess,
            OpenOptions,
            0,
            0
            );

    Ret = NtOpenFile(
                    FileHandle,
                    DesiredAccess,
                    ObjectAttributes,
                    IoStatusBlock,
                    ShareAccess,
                    OpenOptions
                    );

    return Ret;
}

/****************************************************************************/

#define TOTAL_GUARD_REGION_RESERVE 0x3000 //64K memory 
#define SIGNATURE_SIZE 0x1000      //a small window in the reserved region to put signature

DWORD dwCount=0;
DWORD dwCountMax=0x5000;

NTSTATUS
Wow64DbgNtAllocateVirtualMemory (
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN ULONG_PTR ZeroBits,
    IN OUT PSIZE_T RegionSize,
    IN ULONG AllocationType,
    IN ULONG Protect
    )
{ 
    NTSTATUS St;
    NTSTATUS St1;

       PVOID Base1=NULL;
       SIZE_T RegionSizeExtra = 0;

       if ((dwCount++ > dwCountMax) && (*BaseAddress == NULL) && (MEM_RESERVE & AllocationType) && (*RegionSize = 0x10000 )) {
           *RegionSize +=TOTAL_GUARD_REGION_RESERVE;
           RegionSizeExtra = TOTAL_GUARD_REGION_RESERVE;
           //DbgPrint ("Guard page %x %x A:%x P:%x\n", *BaseAddress, *RegionSize, AllocationType, Protect);
       }

        St = NtAllocateVirtualMemory (
                    ProcessHandle,
                    BaseAddress,
                    ZeroBits,
                    RegionSize,
                    AllocationType,
                    Protect
                    );

        if (NT_SUCCESS (St) && RegionSizeExtra ) {
            //
            // Commit some pages and return memory in the middle
            //
            SIZE_T R1 = SIGNATURE_SIZE;
            PWCHAR Name;

            Base1 = *BaseAddress;
            *BaseAddress = (PVOID)((ULONGLONG)(*BaseAddress)+RegionSizeExtra);
            *RegionSize -=TOTAL_GUARD_REGION_RESERVE;
            St1 = NtAllocateVirtualMemory (
                    ProcessHandle,
                    &Base1,
                    ZeroBits,
                    &R1,
                    MEM_COMMIT,
                    PAGE_READWRITE
                    );

            //
            // Write the signature
            //

            if (NT_SUCCESS (St1)) {
                    Name = (PWCHAR)(Base1);
                    wcscpy (Name, L"ATM Shafiqul Khalid");
            }
            
        } //if extra region is to be committed.

        return St;
}

NTSTATUS
Wow64DbgNtFreeVirtualMemory(
    IN HANDLE ProcessHandle,
    IN OUT PVOID *BaseAddress,
    IN OUT PSIZE_T RegionSize,
    IN ULONG FreeType
     )
{
    NTSTATUS st;
    PVOID Base1;
    PWCHAR Name = (PWCHAR)(((ULONGLONG)*BaseAddress)-TOTAL_GUARD_REGION_RESERVE);
    MEMORY_BASIC_INFORMATION MemoryInformation;

    if ((dwCount > dwCountMax) && (MEM_RELEASE & FreeType)) {

        try {

            st = NtQueryVirtualMemory(ProcessHandle,
                                      Name,
                                      MemoryBasicInformation,
                                      &MemoryInformation,
                                      sizeof(MEMORY_BASIC_INFORMATION),
                                      NULL);

            if (NT_SUCCESS(st) && MemoryInformation.State == MEM_COMMIT)
            if (wcsncmp (Name, L"ATM Shafiqul Khalid", 20 )==0) {
                *RegionSize += TOTAL_GUARD_REGION_RESERVE;
                *BaseAddress = (PVOID)((ULONGLONG)(*BaseAddress)-TOTAL_GUARD_REGION_RESERVE);

                

                //DbgPrint ("#########Freeing Guarded Memory#########");
            }

        } except( NULL, EXCEPTION_EXECUTE_HANDLER){
            ;
        }
        
    }

    st = NtFreeVirtualMemory(
                ProcessHandle,
                BaseAddress,
                RegionSize,
                FreeType
                );
    return st;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\regremap\regsetup\setup.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    setup.h

Abstract:

    This file define function used only in the setup/reflector thread

Author:

    ATM Shafiqul Khalid (askhalid) 16-Feb-2000

Revision History:

--*/

#ifndef __SETUP_H__
#define __SETUP_H__

 

#define TEST_NODE_NAME L"TEST"
#define VALUE_KEY_UPDATE_TIME_DIFF 10  // minimum difference in sec to Keyupdate and reflector thread scan

 

 

#endif //__SETUP_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\regremap\regsetup\main.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This module will do the necessary things to setup initial registry for the redirection
    purpose.

//
//  Test case scenario
//      1. Open a ISN node and list content
//      2. Create a ISN node do 1.
//      3. Open a non ISN node and list
//      4. Create a non ISN node and list content
//

  Outstanding issue:
    reflector: If Key has been created on one side, we can reflect that on the other side.
               Deletion: Without any additional attribute it's impossible to track.

Author:

    ATM Shafiqul Khalid (askhalid) 18-Nov-1999

Revision History:

--*/


#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include "wow64reg.h"
#include <assert.h>
#include "..\wow64reg\reflectr.h"
#include <shlwapi.h>


VOID
CleanupWow64NodeKey ()

/*++

Routine Description

    Remove the entry for wow64.

Arguments:

    None.


Return Value:

    None.

--*/

{
    DWORD Ret;
    HKEY Key;

    Ret = RegOpenKey (  HKEY_LOCAL_MACHINE, L"SOFTWARE\\Microsoft", &Key);

    if ( Ret == ERROR_SUCCESS ) {

        Ret = SHDeleteKey ( Key, L"WOW64");
        if ( Ret != ERROR_SUCCESS )
                Wow64RegDbgPrint ( ("\n sorry! couldn't delete the key...SOFTWARE\\Microsoft\\WOW64"));
        RegCloseKey (Key);
    } else
        Wow64RegDbgPrint ( ("\nSOFTWARE\\Microsoft\\WOW64 node is missing setup will creat that.") );

}

LPTSTR NextParam (
    LPTSTR lpStr
    )
/*++

Routine Description

    Point to the next parameter in the commandline.

Arguments:

    lpStr - pointer to the current command line


Return Value:

    TRUE if the function succeed, FALSE otherwise.

--*/
{
	WCHAR ch = L' ';
		

    if (lpStr == NULL )
        return NULL;

    if ( *lpStr == 0 )
        return lpStr;

    while (  ( *lpStr != 0 ) && ( lpStr[0] != ch )) {

		if ( ( lpStr [0] == L'\"')  || ( lpStr [0] == L'\'') )
			ch = lpStr [0];

        lpStr++;
	}

	if ( ch !=L' ' ) lpStr++;

    while ( ( *lpStr != 0 ) && (lpStr[0] == L' ') )
        lpStr++;

    return lpStr;
}

DWORD CopyParam (
    LPTSTR lpDestParam,
    LPTSTR lpCommandParam
    )
/*++

Routine Description

    Copy the current parameter to lpDestParam.

Arguments:

    lpDestParam - that receive current parameter
    lpCommandParam - pointer to the current command line


Return Value:

    TRUE if the function succeed, FALSE otherwise.

--*/

{
	DWORD dwLen = 0;
	WCHAR ch = L' ';

	*lpDestParam = 0;
	
	if ( ( lpCommandParam [0] == L'\"')  || ( lpCommandParam [0] == L'\'') ) {
		ch = lpCommandParam [0];
		lpCommandParam++;
	};


    while ( ( lpCommandParam [0] ) != ch && ( lpCommandParam [0] !=0 ) ) {
        *lpDestParam++ = *lpCommandParam++;
		dwLen++;

		if ( dwLen>255 ) return FALSE;
	}

	if ( ch != L' ' && ch != lpCommandParam [0] )
		return FALSE;
	else lpCommandParam++;

    *lpDestParam = 0;

	return TRUE;

}

///////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////

BOOL
ParseCommand ()


/*++

Routine Description

    Parse command line parameters. Get different options from
    command line parameters.

Arguments:

    None.


Return Value:

    TRUE if the function succeed, FALSE otherwise.

--*/

{

    LPTSTR lptCmdLine1 = GetCommandLine ();


    LPTSTR lptCmdLine = NextParam ( lptCmdLine1 );


    if ( lptCmdLine== NULL || lptCmdLine[0] == 0 )
        return FALSE;

    printf ("\nRunning Wow64 registry setup program.....\n");

    while (  ( lptCmdLine != NULL ) && ( lptCmdLine[0] != 0 )  ) {

        if ( lptCmdLine[0] != '-' )
            return FALSE;

        switch ( lptCmdLine[1] ) {

        case L'c':
                  printf ("\nCopying from 32bit to 64bit isn't implemented yet");
                  break;
        case L'C':          //  CopyRegistryKey
                  SetInitialCopy ();
                  PopulateReflectorTable ();
                  CreateIsnNode();
                  break;

        case L'd':
            printf ("\nRemove all the Keys from 32bit side that were copied from 64bit side");
            CleanpRegistry ( );
            break;

        case L'D':
            printf ("\nRemove all the Keys from 32bit side that were copied from 64bit side");
            CleanpRegistry ();
            break;

       case L'p':
       case L'P':  // populate registry
            CleanupWow64NodeKey ();
            PopulateReflectorTable ();
            break;

       case 't':
           {

               InitializeIsnTableReflector ();
                CreateIsnNodeSingle( 4 );
                CreateIsnNodeSingle( 5 );
           }
            break;

        case L'r':
        case L'R':
            //
            //  run the reflector codes;
            //

            InitReflector ();
            if ( !RegisterReflector () ) {
                    printf ("\nSorry! reflector couldn't be register");
                    UnRegisterReflector ();
                    return FALSE;
            }

            printf ("\nSleeping for 100 min to test reflector codes ...........\n");
            Sleep (1000*60*100);

            UnRegisterReflector ();
            break;

        default:
            return FALSE;
            break;
        }

        lptCmdLine = NextParam ( lptCmdLine );
    }

    return TRUE;
}

int __cdecl
main()
{


    if (!ParseCommand ()) {

        printf ( "\nUsages: w64setup [-c] [-C] [-d] [-D] [-r]\n");
        printf ( "\n        -c Copy from 32bit to 64bit side of the registry");
        printf ( "\n        -C Copy from 64bit to 32bit side of the registry");
        printf ( "\n");
        printf ( "\n        -d Remove all the Keys from 32bit side that were copied from 64bit side");
        printf ( "\n        -D Remove all the Keys from 64bit side that were copied from 32bit side");

        printf ( "\n");
        printf ( "\n        -r Run reflector thread");

        printf ("\n");
        return 0;

    }



    printf ("\nDone.");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\regremap\regremap.c ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation

Module Name:

    regredir.c

Abstract:

    This module contains the APis to redirect 32bit registry calls. All 32bit wow process must
    use following set of wowregistry APIs to manipulate registry so that 32-bit and 64-bit registry
    can co exist in the same system registry.

    Some functionality hasn't been optimized yet. After successful implementation those need to
    be optimized.

Author:

    ATM Shafiqul Khalid (askhalid) 15-Oct-1999

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <ntregapi.h>
#include <stdlib.h>

#include "regremap.h"
#include "wow64reg.h"
#include "wow64reg\reflectr.h"

//#include "wow64.h"

BOOL
IsAccessDeniedOnKeyByHandle (
    HANDLE hKey,
    DWORD *FilteredAccess
    );

PVOID
Wow64AllocateTemp(
    SIZE_T Size
    );

//#define WOW64_LOG_REGISTRY
#ifdef WOW64_LOG_REGISTRY
    WCHAR TempBuff[MAX_PATH];
    DWORD TempLen = MAX_PATH;
#endif 

#ifdef LOG_REGISTRY

void
LogMsgKeyHandle (
    char *str,
    HANDLE hKey,
    DWORD res
    )
{
    WCHAR AbsPath[MAX_PATH];
    DWORD Len = MAX_PATH;

    HandleToKeyName (hKey, AbsPath, &Len);
    LOGPRINT( (ERRORLOG, "\nDEBUG: requested Node:%S Status:%x, Msg:%s", AbsPath, res, str));


};
#endif

BOOL
ShimRegistryValue (
    HANDLE hKey,
    PWCHAR Value,
    DWORD  dwDataSize,
    PWCHAR PatchedValue,
    DWORD  *pdwPatchedSize,
    BOOL   *bPatched
    )
/*++

Routine Description:

    Shimming place where registry value will be repatched.

Arguments:

    Handle - Handle to the key that need to be checked for possible shimming.

    Value - the value that need to repatched.

    pdwDataSize - size of the data in terms of byte. This also receive new size if 
            that changes due to repatching.
    PatchedValue - new value if we patch anything.
    pdwPatchedSize - the new size.
    bPatched - TRUE if the value has been patched, FALUE otherwise.

Return Value:

    TRUE if the operation goes OK.
    FALSE otherwise.

--*/

{

    BOOL Wow64RegIsPossibleShim ( HANDLE hKey );
    
    WCHAR PathName[_MAX_PATH], *t;
    DWORD dwLen = dwDataSize/sizeof (WCHAR);

    //
    // Check if the handle has special tag for possible shimming.
    //

    *bPatched = FALSE;

    //if (dwLen > _MAX_PATH-2)  //caller must not pass a pathname bigger than MAX_PATH-6
    //    return TRUE;

    t = (PWCHAR) (Value);
    wcsncpy(PathName, t, dwLen);
    PathName[dwLen] = UNICODE_NULL;  //so that string 
    PathName[dwLen+1] = UNICODE_NULL;  //to remove one check lateron 

    

    
    //
    // 1. Shim case one
    //
    // If the key fall under RunKeys and 
    // If (x86) is inserted  [i.e., Program Files (x86) is present] and 
    // the string contains .exe and 
    // doesnt contain  
    // And the path point to a physical file. 
    //
    //  then add a quote marks.
    //


    if ( wcsstr (PathName, L"\\Program Files (x86)\\")) {
        PWCHAR  p;

        if ((p=wcsistr (PathName, L".exe")) != NULL)
            if ((*(p+4) == L' ') || (*(p+4) == UNICODE_NULL) ) {

                UNICODE_STRING  FileNameU;
                HANDLE          FileHandle;
                OBJECT_ATTRIBUTES   ObjectAttributes;
                NTSTATUS Status;
                IO_STATUS_BLOCK   statusBlock;

                if (!Wow64RegIsPossibleShim (hKey))
                    return TRUE;  //return as it is

                //
                // make sure the file exists on disk.
                //
                *(p+4) = UNICODE_NULL;

                //
                // Convert the Win32 pathname to an NT pathname
                //
                if (!RtlDosPathNameToNtPathName_U(PathName,
                                                  &FileNameU,
                                                  NULL,
                                                  NULL)) {
                    // probably out-of-memory
                    return FALSE;
                }


                //
                // Open the file
                //
                InitializeObjectAttributes(&ObjectAttributes,
                                           &FileNameU,
                                           OBJ_CASE_INSENSITIVE,
                                           NULL,
                                           NULL);

                Status = NtOpenFile(&FileHandle,
                                FILE_READ_DATA,
                                &ObjectAttributes,
                                &statusBlock,
                                FILE_SHARE_READ,
                                0);
                RtlFreeHeap(RtlProcessHeap(), 0, FileNameU.Buffer);
                

                if (NT_SUCCESS(Status)) {
                    //
                    // Must shim
                    //

                    NtClose (FileHandle);
                    *bPatched= TRUE;
                    PatchedValue[0] = L'\"';
                    wcscpy (&PatchedValue[1], PathName);
                    dwLen = wcslen (PatchedValue);
                    PatchedValue[dwLen]=L'\"';  // close quote mart
                    if (*(p+5)!= UNICODE_NULL) {
                        PatchedValue[dwLen+1] = L' '; // additional Space
                        //
                        //  copy rest of the items
                        //
                        wcscpy (&PatchedValue[dwLen+2], p+5);
                    } else
                        PatchedValue[dwLen+1]=UNICODE_NULL;  // close quote mart

                    *pdwPatchedSize = dwDataSize + 2*sizeof(WCHAR); //size of two double quote

                }
            }
    } //end of shim case 1.

    return TRUE;
}
//
//  Need to move in the header file
//
NTSTATUS
RemapNtCreateKey(
    OUT PHANDLE phPatchedHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    );

NTSTATUS
Wow64NtCreateKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    )
/*++

Routine Description:

    An existing registry key may be opened, or a new one created,
    with NtCreateKey.

    If the specified key does not exist, an attempt is made to create it.
    For the create attempt to succeed, the new node must be a direct
    child of the node referred to by KeyHandle.  If the node exists,
    it is opened.  Its value is not affected in any way.

    Share access is computed from desired access.

    NOTE:

        If CreateOptions has REG_OPTION_BACKUP_RESTORE set, then
        DesiredAccess will be ignored.  If the caller has the
        privilege SeBackupPrivilege asserted, a handle with
        KEY_READ | ACCESS_SYSTEM_SECURITY will be returned.
        If SeRestorePrivilege, then same but KEY_WRITE rather
        than KEY_READ.  If both, then both access sets.  If neither
        privilege is asserted, then the call will fail.

Arguments:

    KeyHandle - Receives a Handle which is used to access the
        specified key in the Registration Database.

    DesiredAccess - Specifies the access rights desired.

    ObjectAttributes - Specifies the attributes of the key being opened.
        Note that a key name must be specified.  If a Root Directory is
        specified, the name is relative to the root.  The name of the
        object must be within the name space allocated to the Registry,
        that is, all names beginning "\Registry".  RootHandle, if
        present, must be a handle to "\", or "\Registry", or a key
        under "\Registry".

        RootHandle must have been opened for KEY_CREATE_SUB_KEY access
        if a new node is to be created.

        NOTE:   Object manager will capture and probe this argument.

    TitleIndex - Specifies the index of the localized alias for
        the name of the key.  The title index specifies the index of
        the localized alias for the name.  Ignored if the key
        already exists.

    Class - Specifies the object class of the key.  (To the registry
        this is just a string.)  Ignored if NULL.

    CreateOptions - Optional control values:

        REG_OPTION_VOLATILE - Object is not to be stored across boots.

    Disposition - This optional parameter is a pointer to a variable
        that will receive a value indicating whether a new Registry
        key was created or an existing one opened:

        REG_CREATED_NEW_KEY - A new Registry Key was created
        REG_OPENED_EXISTING_KEY - An existing Registry Key was opened

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{

    NTSTATUS St;
    BOOL bRet = FALSE;
    ULONG Disposition_Temp = 0;

    try {

    if ( Disposition == NULL )
        Disposition = &Disposition_Temp; 


    St = RemapNtCreateKey  (
                            KeyHandle,
                            DesiredAccess,
                            ObjectAttributes,
                            TitleIndex,
                            Class ,
                            CreateOptions,
                            Disposition
                            );

    
        

        //
        // if total failure for thunked key, try if you can pull that key from 64bit hive.
        // May be reflector should be running 
        //

        //
        // 2nd try only if no patch is required.
        // i.e., success with NULL handle returned
        //

        if ( NT_SUCCESS(St) && *KeyHandle == NULL )
            St = NtCreateKey(
                                KeyHandle,
                                (~KEY_WOW64_RES) & DesiredAccess,
                                ObjectAttributes,
                                TitleIndex,
                                Class ,
                                CreateOptions,
                                Disposition
                                );

#ifdef WOW64_LOG_REGISTRY
        if (NT_SUCCESS(St)) {
            TempLen = MAX_PATH;
            ObjectAttributesToKeyName (
                                    ObjectAttributes,
                                    TempBuff,
                                    TempLen,
                                    &bRet,
                                    NULL
                                    );

            HandleToKeyName (*KeyHandle, TempBuff, &TempLen);
            if (TempLen > 10 && wcsistr (TempBuff, L"ControlSet"))
                DbgPrint( "\nNtCreateKeyEx OUT:[%S] Status:%x F:%x", TempBuff, DesiredAccess);
        }


#endif    

    if (NT_SUCCESS(St)) 
        Wow64RegSetKeyDirty (*KeyHandle ); // Need some clean/sync up on exit

    if ( *Disposition == REG_CREATED_NEW_KEY )
            UpdateKeyTag ( *KeyHandle,TAG_KEY_ATTRIBUTE_32BIT_WRITE );

    } except( NULL, EXCEPTION_EXECUTE_HANDLER){

        St =  GetExceptionCode ();
    }
    return St;
}

NTSTATUS
Wow64NtDeleteKey(
    IN HANDLE KeyHandle
    )
/*++

Routine Description:

    A registry key may be marked for delete, causing it to be removed
    from the system.  It will remain in the name space until the last
    handle to it is closed.

Arguments:

    KeyHandle - Specifies the handle of the Key to delete, must have
        been opened for DELETE access.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{

    NTSTATUS St;    
    HKEY hRemap;

    hRemap = Wow64OpenRemappedKeyOnReflection (KeyHandle);

    St = NtDeleteKey(
                        KeyHandle
                        );
    if (NT_SUCCESS (St) && ( hRemap != NULL ) )
        Wow64RegDeleteKey (hRemap, NULL);

    if ( hRemap != NULL )
        NtClose ( hRemap );

    return St;
}

NTSTATUS
Wow64NtDeleteValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName
    )
/*++

Routine Description:

    One of the value entries of a registry key may be removed with this
    call.  To remove the entire key, call NtDeleteKey.

    The value entry with ValueName matching ValueName is removed from the key.
    If no such entry exists, an error is returned.

Arguments:

    KeyHandle - Specifies the handle of the key containing the value
        entry of interest.  Must have been opend for KEY_SET_VALUE access.

    ValueName - The name of the value to be deleted.  NULL is a legal name.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{

    NTSTATUS St;

    St = NtDeleteValueKey(
                            KeyHandle,
                            ValueName
                            );

    if (NT_SUCCESS(St)) 
        Wow64RegSetKeyDirty (KeyHandle ); // Need some clean/sync up on exit

    return St;
}


NTSTATUS
Wow64NtEnumerateKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    The sub keys of an open key may be enumerated with NtEnumerateKey.

    NtEnumerateKey returns the name of the Index'th sub key of the open
    key specified by KeyHandle.  The value STATUS_NO_MORE_ENTRIES will be
    returned if value of Index is larger than the number of sub keys.

    Note that Index is simply a way to select among child keys.  Two calls
    to NtEnumerateKey with the same Index are NOT guaranteed to return
    the same results.

    If KeyInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    KeyHandle - Handle of the key whose sub keys are to be enumerated.  Must
        be open for KEY_ENUMERATE_SUB_KEY access.

    Index - Specifies the (0-based) number of the sub key to be returned.

    KeyInformationClass - Specifies the type of information returned in
        Buffer.  One of the following types:

        KeyBasicInformation - return last write time, title index, and name.
            (see KEY_BASIC_INFORMATION structure)

        KeyNodeInformation - return last write time, title index, name, class.
            (see KEY_NODE_INFORMATION structure)

    KeyInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyInformation in bytes.

    ResultLength - Number of bytes actually written into KeyInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/

{

    //
    // if the handle is to ISN node then time to enumerate the right one
    //

    BOOL bRealigned=FALSE;
    PVOID pTempKeyInfo;

    NTSTATUS RetVal;

    try {

    if ( (SIZE_T)(KeyInformation) & (0x07) ) {
        // allocate a buffer with correct alignment, to pass to the Win64 API
        pTempKeyInfo = KeyInformation;
        KeyInformation = Wow64AllocateTemp(Length);
        RtlCopyMemory(KeyInformation, pTempKeyInfo, Length);
        bRealigned = TRUE;
    }

    RetVal = NtEnumerateKey(
                            KeyHandle,
                            Index,
                            KeyInformationClass,
                            KeyInformation,
                            Length,
                            ResultLength
                            );

    if (!NT_ERROR(RetVal) && bRealigned) {
        RtlCopyMemory((PVOID)pTempKeyInfo, KeyInformation, Length);
    }

    } except( NULL, EXCEPTION_EXECUTE_HANDLER){

        RetVal =  GetExceptionCode ();
    }

    return RetVal;
}


NTSTATUS
Wow64NtEnumerateValueKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    The value entries of an open key may be enumerated
    with NtEnumerateValueKey.

    NtEnumerateValueKey returns the name of the Index'th value
    entry of the open key specified by KeyHandle.  The value
    STATUS_NO_MORE_ENTRIES will be returned if value of Index is
    larger than the number of sub keys.

    Note that Index is simply a way to select among value
    entries.  Two calls to NtEnumerateValueKey with the same Index
    are NOT guaranteed to return the same results.

    If KeyValueInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    KeyHandle - Handle of the key whose value entries are to be enumerated.
        Must have been opened with KEY_QUERY_VALUE access.

    Index - Specifies the (0-based) number of the sub key to be returned.

    KeyValueInformationClass - Specifies the type of information returned
    in Buffer. One of the following types:

        KeyValueBasicInformation - return time of last write,
            title index, and name.  (See KEY_VALUE_BASIC_INFORMATION)

        KeyValueFullInformation - return time of last write,
            title index, name, class.  (See KEY_VALUE_FULL_INFORMATION)

    KeyValueInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyValueInformation in bytes.

    ResultLength - Number of bytes actually written into KeyValueInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/

{


    return NtEnumerateValueKey(
                             KeyHandle,
                             Index,
                             KeyValueInformationClass,
                             KeyValueInformation,
                             Length,
                             ResultLength
                             );


}


NTSTATUS
Wow64NtFlushKey(
    IN HANDLE KeyHandle
    )
/*++

Routine Description:

    Changes made by NtCreateKey or NtSetKey may be flushed to disk with
    NtFlushKey.

    NtFlushKey will not return to its caller until any changed data
    associated with KeyHandle has been written to permanent store.

    WARNING: NtFlushKey will flush the entire registry tree, and thus will
    burn cycles and I/O.

Arguments:

    KeyHandle - Handle of open key to be flushed.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/

{
    return   NtFlushKey(
                        KeyHandle
                        );
}


NTSTATUS
Wow64NtInitializeRegistry(
    IN USHORT BootCondition
    )
/*++

Routine Description:

    This routine is called in 2 situations:

    1) It is called from SM after autocheck (chkdsk) has
    run and the paging files have been opened.  It's function is
    to bind in memory hives to their files, and to open any other
    files yet to be used.

    2) It is called from SC after the current boot has been accepted
    and the control set used for the boot process should be saved
    as the LKG control set.

    After this routine accomplishes the work of situation #1 and
      #2, further requests for such work will not be carried out.

Arguments:

    BootCondition -

         REG_INIT_BOOT_SM -     The routine has been called from SM
                                in situation #1.

         REG_INIT_BOOT_SETUP -  The routine has been called to perform
                                situation #1 work but has been called
                                from setup and needs to do some special
                                work.

        REG_INIT_BOOT_ACCEPTED_BASE + Num
                        (where 0 < Num < 1000) - The routine has been called
                                                 in situation #2. "Num" is the
                                                 number of the control set
                                                 to which the boot control set
                                                 should be saved.

Return Value:

    NTSTATUS - Result code from call, among the following:

        STATUS_SUCCESS - it worked
        STATUS_ACCESS_DENIED - the routine has already done the work
                               requested and will not do it again.

--*/
{
    return NtInitializeRegistry(
                                BootCondition
                                );

}

NTSTATUS
Wow64NtNotifyChangeKey(
    IN HANDLE KeyHandle,
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    )
/*++

Routine Description:

    Notification of key creation, deletion, and modification may be
    obtained by calling NtNotifyChangeKey.

    NtNotifyChangeKey monitors changes to a key - if the key or
    subtree specified by KeyHandle are modified, the service notifies
    its caller.  It also returns the name(s) of the key(s) that changed.
    All names are specified relative to the key that the handle represents
    (therefore a NULL name represents that key).  The service completes
    once the key or subtree has been modified based on the supplied
    CompletionFilter.  The service is a "single shot" and therefore
    needs to be reinvoked to watch the key for further changes.

    The operation of this service begins by opening a key for KEY_NOTIFY
    access.  Once the handle is returned, the NtNotifyChangeKey service
    may be invoked to begin watching the values and subkeys of the
    specified key for changes.  The first time the service is invoked,
    the BufferSize parameter supplies not only the size of the user's
    Buffer, but also the size of the buffer that will be used by the
    Registry to store names of keys that have changed.  Likewise, the
    CompletionFilter and WatchTree parameters on the first call indicate
    how notification should operate for all calls using the supplied
    KeyHandle.   These two parameters are ignored on subsequent calls
    to the API with the same instance of KeyHandle.

    Once a modification is made that should be reported, the Registry will
    complete the service.  The names of the files that have changed since
    the last time the service was called will be placed into the caller's
    output Buffer.  The Information field of IoStatusBlock will contain
    the number of bytes placed in Buffer, or zero if too many keys have
    changed since the last time the service was called, in which case
    the application must Query and Enumerate the key and sub keys to
    discover changes.  The Status field of IoStatusBlock will contain
    the actual status of the call.

    If Asynchronous is TRUE, then Event, if specified, will be set to
    the Signaled state.  If no Event parameter was specified, then
    KeyHandle will be set to the Signaled state.  If an ApcRoutine
    was specified, it is invoked with the ApcContext and the address of the
    IoStatusBlock as its arguments.  If Asynchronous is FALSE, Event,
    ApcRoutine, and ApcContext are ignored.

    This service requires KEY_NOTIFY access to the key that was
    actually modified

    The notify "session" is terminated by closing KeyHandle.

Arguments:

    KeyHandle-- Supplies a handle to an open key.  This handle is
        effectively the notify handle, because only one set of
        notify parameters may be set against it.

    Event - An optional handle to an event to be set to the
        Signaled state when the operation completes.

    ApcRoutine - An optional procedure to be invoked once the
        operation completes.  For more information about this
        parameter see the NtReadFile system service description.

        If PreviousMode == Kernel, this parameter is an optional
        pointer to a WORK_QUEUE_ITEM to be queued when the notify
        is signaled.

    ApcContext - A pointer to pass as an argument to the ApcRoutine,
        if one was specified, when the operation completes.  This
        argument is required if an ApcRoutine was specified.

        If PreviousMode == Kernel, this parameter is an optional
        WORK_QUEUE_TYPE describing the queue to be used. This argument
        is required if an ApcRoutine was specified.

    IoStatusBlock - A variable to receive the final completion status.
        For more information about this parameter see the NtCreateFile
        system service description.

    CompletionFilter -- Specifies a set of flags that indicate the
        types of operations on the key or its value that cause the
        call to complete.  The following are valid flags for this parameter:

        REG_NOTIFY_CHANGE_NAME -- Specifies that the call should be
            completed if a subkey is added or deleted.

        REG_NOTIFY_CHANGE_ATTRIBUTES -- Specifies that the call should
            be completed if the attributes (e.g.: ACL) of the key or
            any subkey are changed.

        REG_NOTIFY_CHANGE_LAST_SET -- Specifies that the call should be
            completed if the lastWriteTime of the key or any of its
            subkeys is changed.  (Ie. if the value of the key or any
            subkey is changed).

        REG_NOTIFY_CHANGE_SECURITY -- Specifies that the call should be
            completed if the security information (e.g. ACL) on the key
            or any subkey is changed.

    WatchTree -- A BOOLEAN value that, if TRUE, specifies that all
        changes in the subtree of this key should also be reported.
        If FALSE, only changes to this key, its value, and its immediate
        subkeys (but not their values nor their subkeys) are reported.

    Buffer -- A variable to receive the name(s) of the key(s) that
        changed.  See REG_NOTIFY_INFORMATION.

    BufferSize -- Specifies the length of Buffer.

    Asynchronous  -- If FALSE, call will not return until
        complete (synchronous) if TRUE, call may return STATUS_PENDING.

Obs:
    Since NtNotifyChangeMultipleKeys, this routine is kept only for bacwards compatibility

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{

    return NtNotifyChangeKey(
                            KeyHandle,
                            Event ,
                            ApcRoutine ,
                            ApcContext ,
                            IoStatusBlock,
                            CompletionFilter,
                            WatchTree,
                            Buffer,
                            BufferSize,
                            Asynchronous
                            );
}


NTSTATUS
Wow64NtNotifyChangeMultipleKeys(
    IN HANDLE MasterKeyHandle,
    IN ULONG Count,
    IN OBJECT_ATTRIBUTES SlaveObjects[],
    IN HANDLE Event OPTIONAL,
    IN PIO_APC_ROUTINE ApcRoutine OPTIONAL,
    IN PVOID ApcContext OPTIONAL,
    OUT PIO_STATUS_BLOCK IoStatusBlock,
    IN ULONG CompletionFilter,
    IN BOOLEAN WatchTree,
    OUT PVOID Buffer,
    IN ULONG BufferSize,
    IN BOOLEAN Asynchronous
    )
/*++

Routine Description:

    Notificaion of creation, deletion and modification on multiple keys
    may be obtained with NtNotifyChangeMultipleKeys.

    NtNotifyMultipleKeys monitors changes to any of the MasterKeyHandle
    or one of SlaveObjects and/or their subtrees, whichever occurs first.
    When an event on these keys is triggered, the notification is considered
    fulfilled, and has to be "armed" again, in order to watch for further
    changes.

    The mechanism is similar to the one described in NtNotifyChangeKey.

    The MasterKeyHandle key, give the caller control over the lifetime
    of the notification. The notification will live as long as the caller
    keeps the MasterKeyHandle open, or an event is triggered.

    The caller doesn't have to open the SlaveKeys. He will provide the
    routine with an array of OBJECT_ATTRIBUTES, describing the slave objects.
    The routine will open the objects, and ensure keep a reference on them
    untill the back-end side will close them.

    The notify "session" is terminated by closing MasterKeyHandle.

Obs:
    For the time being, the routine supports only one slave object. When more
    than one slave object is provided, the routine will signal an error of
    STATUS_INVALID_PARAMETER.
    However, the interface is designed for future enhancements (taking an
    array of slave objects), that may be provided with future versions(w2001).

    When no slave object is supplied (i.e. Count == 0) we have the identical
    behavior as for NtNotifyChangeKey.

Arguments:

    MasterKeyHandle - Supplies a handle to an open key.  This handle is
        the "master handle". It has control overthe lifetime of the
        notification.

    Count - Number of slave objects. For the time being, this should be 1

    SlaveObjects - Array of slave objects. Only the attributes of the
        objects are provided, so the caller doesn't have to take care
        of them.

    Event,ApcRoutine,ApcContext,IoStatusBlock,CompletionFilter,WatchTree,
    Buffer,BufferSize,Asynchronous - same as for NtNotifyChangeKey

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/

{
    return NtNotifyChangeMultipleKeys(
                                        MasterKeyHandle,
                                        Count,
                                        SlaveObjects,
                                        Event,
                                        ApcRoutine,
                                        ApcContext,
                                        IoStatusBlock,
                                        CompletionFilter,
                                        WatchTree,
                                        Buffer,
                                        BufferSize,
                                        Asynchronous
                                        );

}

NTSTATUS
Wow64NtOpenKey(
    OUT PHANDLE KeyHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    )
/*++

Routine Description:

    A registry key which already exists may be opened with NtOpenKey.

    Share access is computed from desired access.

Arguments:

    KeyHandle - Receives a  Handle which is used to access the
        specified key in the Registration Database.

    DesiredAccess - Specifies the access rights desired.

    ObjectAttributes - Specifies the attributes of the key being opened.
        Note that a key name must be specified.  If a Root Directory
        is specified, the name is relative to the root.  The name of
        the object must be within the name space allocated to the
        Registry, that is, all names beginning "\Registry".  RootHandle,
        if present, must be a handle to "\", or "\Registry", or a
        key under "\Registry".  If the specified key does not exist, or
        access requested is not allowed, the operation will fail.

        NOTE:   Object manager will capture and probe this argument.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    NTSTATUS St;
    
    try {

    St = OpenIsnNodeByObjectAttributes  (
                                ObjectAttributes,
                                DesiredAccess,
                                KeyHandle );


    if ( NT_SUCCESS(St) &&  (*KeyHandle == NULL) ) { //should follow the normal route

        St = NtOpenKey(
                            KeyHandle,
                            (~KEY_WOW64_RES) & DesiredAccess,
                            ObjectAttributes
                            );
    }

#ifdef WOW64_LOG_REGISTRY
    if (NT_SUCCESS(St)) {
        TempLen = MAX_PATH;
        ObjectAttributesToKeyName (
                                ObjectAttributes,
                                TempBuff,
                                TempLen,
                                &bRet,
                                NULL
                                );

        HandleToKeyName (*KeyHandle, TempBuff, &TempLen);
        if (TempLen > 10 && wcsistr (TempBuff, L"ControlSet"))
            DbgPrint( "\nNtOpenKeyEx OUT:[%S] Status:%x F:%x", TempBuff, St, DesiredAccess);
    }


#endif 

    } except( NULL, EXCEPTION_EXECUTE_HANDLER){

        St =  GetExceptionCode ();
    }

    return St;

}

NTSTATUS
Wow64NtQueryKey(
    IN HANDLE KeyHandle,
    IN KEY_INFORMATION_CLASS KeyInformationClass,
    IN PVOID KeyInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    Data about the class of a key, and the numbers and sizes of its
    children and value entries may be queried with NtQueryKey.

    If KeyValueInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

    NOTE: The returned lengths are guaranteed to be at least as
          long as the described values, but may be longer in
          some circumstances.

Arguments:

    KeyHandle - Handle of the key to query data for.  Must have been
        opened for KEY_QUERY_KEY access.

    KeyInformationClass - Specifies the type of information
        returned in Buffer.  One of the following types:

        KeyBasicInformation - return last write time, title index, and name.
            (See KEY_BASIC_INFORMATION)

        KeyNodeInformation - return last write time, title index, name, class.
            (See KEY_NODE_INFORMATION)

        KeyFullInformation - return all data except for name and security.
            (See KEY_FULL_INFORMATION)

    KeyInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyInformation in bytes.

    ResultLength - Number of bytes actually written into KeyInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    BOOL bRealigned=FALSE;
    PVOID pTempKeyInfo;

    NTSTATUS RetVal;

    try {

    if ( (SIZE_T)(KeyInformation) & (0x07) ) {
        // allocate a buffer with correct alignment, to pass to the Win64 API
        pTempKeyInfo = KeyInformation;
        KeyInformation = Wow64AllocateTemp(Length);
        RtlCopyMemory(KeyInformation, pTempKeyInfo, Length);
        bRealigned = TRUE;
    }

    RetVal = NtQueryKey(
                        KeyHandle,
                        KeyInformationClass,
                        KeyInformation,
                        Length,
                        ResultLength
                        );

    if (!NT_ERROR(RetVal) && bRealigned) {
        RtlCopyMemory((PVOID)pTempKeyInfo, KeyInformation, Length);
    }

    } except( NULL, EXCEPTION_EXECUTE_HANDLER){

        RetVal =  GetExceptionCode ();
    }

    return RetVal;
}


NTSTATUS
Wow64NtQueryValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN KEY_VALUE_INFORMATION_CLASS KeyValueInformationClass,
    IN PVOID KeyValueInformation,
    IN ULONG Length,
    IN PULONG ResultLength
    )
/*++

Routine Description:

    The ValueName, TitleIndex, Type, and Data for any one of a key's
    value entries may be queried with NtQueryValueKey.

    If KeyValueInformation is not long enough to hold all requested data,
    STATUS_BUFFER_OVERFLOW will be returned, and ResultLength will be
    set to the number of bytes actually required.

Arguments:

    KeyHandle - Handle of the key whose value entries are to be
        enumerated.  Must be open for KEY_QUERY_VALUE access.

    Index - Specifies the (0-based) number of the sub key to be returned.

    ValueName  - The name of the value entry to return data for.

    KeyValueInformationClass - Specifies the type of information
        returned in KeyValueInformation.  One of the following types:

        KeyValueBasicInformation - return time of last write, title
            index, and name.  (See KEY_VALUE_BASIC_INFORMATION)

        KeyValueFullInformation - return time of last write, title
            index, name, class.  (See KEY_VALUE_FULL_INFORMATION)

    KeyValueInformation -Supplies pointer to buffer to receive the data.

    Length - Length of KeyValueInformation in bytes.

    ResultLength - Number of bytes actually written into KeyValueInformation.

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

    TMP: The IopQueryRegsitryValues() routine in the IO system assumes
         STATUS_OBJECT_NAME_NOT_FOUND is returned if the value being queried
         for does not exist.

--*/
{
    BOOL bRealigned=FALSE;
    PVOID pTempKeyInfo;

    NTSTATUS RetVal;

    try {

        if ( (SIZE_T)(KeyValueInformation) & (0x07) ) {
            // allocate a buffer with correct alignment, to pass to the Win64 API
            pTempKeyInfo = KeyValueInformation;
            KeyValueInformation = Wow64AllocateTemp(Length);
            RtlCopyMemory(KeyValueInformation, pTempKeyInfo, Length);
            bRealigned = TRUE;
        }

        RetVal =  NtQueryValueKey(
                                    KeyHandle,
                                    ValueName,
                                    KeyValueInformationClass,
                                    KeyValueInformation,
                                    Length,
                                    ResultLength
                                    );

        if (!NT_ERROR(RetVal) && bRealigned) {
            RtlCopyMemory((PVOID)pTempKeyInfo, KeyValueInformation, Length);
        }

    } except( NULL, EXCEPTION_EXECUTE_HANDLER){

        RetVal =  GetExceptionCode ();
    }

    return RetVal;
}



NTSTATUS
Wow64NtRestoreKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle,
    IN ULONG Flags
    )
/*++

Routine Description:

    A file in the format created by NtSaveKey may be loaded into
    the system's active registry with NtRestoreKey.  An entire subtree
    is created in the active registry as a result.  All of the
    data for the new sub-tree, including such things as security
    descriptors, will be read from the source file.  The data will
    not be interpreted in any way.

    This call (unlike NtLoadKey, see below) copies the data.  The
    system will NOT be using the source file after the call returns.

    If the flag REG_WHOLE_HIVE_VOLATILE is specified, a new hive
    can be created.  It will be a memory only copy.  The restore
    must be done to the root of a hive (e.g. \registry\user\<name>)

    If the flag is NOT set, then the target of the restore must
    be an existing hive.  The restore can be done to an arbitrary
    location within an existing hive.

    Caller must have SeRestorePrivilege privilege.

    If the flag REG_REFRESH_HIVE is set (must be only flag) then the
    the Hive will be restored to its state as of the last flush.

    The hive must be marked NOLAZY_FLUSH, and the caller must have
    TCB privilege, and the handle must point to the root of the hive.
    If the refresh fails, the hive will be corrupt, and the system
    will bugcheck.  Notifies are flushed.  The hive file will be resized,
    the log will not.  If there is any volatile space in the hive
    being refreshed, STATUS_UNSUCCESSFUL will be returned.  (It's much
    too obscure a failure to warrant a new error code.)

    If the flag REG_FORCE_RESTORE is set, the restore operation is done
    even if the KeyHandle has open subkeys by other applications

Arguments:

    KeyHandle - refers to the Key in the registry which is to be the
                root of the new tree read from the disk.  This key
                will be replaced.

    FileHandle - refers to file to restore from, must have read access.

    Flags   - If REG_WHOLE_HIVE_VOLATILE is set, then the copy will
              exist only in memory, and disappear when the machine
              is rebooted.  No hive file will be created on disk.

              Normally, a hive file will be created on disk.

Return Value:

    NTSTATUS - values TBS.


--*/
{
    return NtRestoreKey(
                        KeyHandle,
                        FileHandle,
                        Flags
                        );
}



NTSTATUS
Wow64NtSaveKey(
    IN HANDLE KeyHandle,
    IN HANDLE FileHandle
    )
/*++

Routine Description:

    A subtree of the active registry may be written to a file in a
    format suitable for use with NtRestoreKey.  All of the data in the
    subtree, including such things as security descriptors will be written
    out.

    Caller must have SeBackupPrivilege privilege.

Arguments:

    KeyHandle - refers to the Key in the registry which is the
                root of the tree to be written to disk.  The specified
                node will be included in the data written out.

    FileHandle - a file handle with write access to the target file
                 of interest.

Return Value:

    NTSTATUS - values TBS

--*/
{
    return NtSaveKey(
                    KeyHandle,
                    FileHandle
                    );
}


NTSTATUS
Wow64NtSaveMergedKeys(
    IN HANDLE HighPrecedenceKeyHandle,
    IN HANDLE LowPrecedenceKeyHandle,
    IN HANDLE FileHandle
    )
/*++

Routine Description:

    Two subtrees of the registry can be merged. The resulting subtree may
    be written to a file in a format suitable for use with NtRestoreKey.
    All of the data in the subtree, including such things as security
    descriptors will be written out.

    Caller must have SeBackupPrivilege privilege.

Arguments:

    HighPrecedenceKeyHandle - refers to the key in the registry which is the
                root of the HighPrecedence tree. I.e., when a key is present in
                both trees headded by the two keys, the key underneath HighPrecedence
                tree will always prevail. The specified
                node will be included in the data written out.

    LowPrecedenceKeyHandle - referrs to the key in the registry which is the
                root of the "second choice" tree. Keys from this trees get saved
                when there is no equivalent key in the tree headded by HighPrecedenceKey

    FileHandle - a file handle with write access to the target file
                 of interest.

Return Value:

    NTSTATUS - values TBS

--*/
{
    return NtSaveMergedKeys(
                                HighPrecedenceKeyHandle,
                                LowPrecedenceKeyHandle,
                                FileHandle
                                );
}


NTSTATUS
Wow64NtSetValueKey(
    IN HANDLE KeyHandle,
    IN PUNICODE_STRING ValueName,
    IN ULONG TitleIndex OPTIONAL,
    IN ULONG Type,
    IN PVOID Data,
    IN ULONG DataSize
    )
/*++

Routine Description:

    A value entry may be created or replaced with NtSetValueKey.

    If a value entry with a Value ID (i.e. name) matching the
    one specified by ValueName exists, it is deleted and replaced
    with the one specified.  If no such value entry exists, a new
    one is created.  NULL is a legal Value ID.  While Value IDs must
    be unique within any given key, the same Value ID may appear
    in many different keys.

Arguments:

    KeyHandle - Handle of the key whose for which a value entry is
        to be set.  Must be opened for KEY_SET_VALUE access.

    ValueName - The unique (relative to the containing key) name
        of the value entry.  May be NULL.

    TitleIndex - Supplies the title index for ValueName.  The title
        index specifies the index of the localized alias for the ValueName.

    Type - The integer type number of the value entry.

    Data - Pointer to buffer with actual data for the value entry.

    DataSize - Size of Data buffer.


Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{
    WCHAR ThunkData[_MAX_PATH];
    PWCHAR pCorrectData = (PWCHAR)Data;
    ULONG CorrectDataSize = DataSize;
    BOOL bPatched;
    NTSTATUS St = STATUS_SUCCESS;


    //
    // thunk  %ProgramFiles%  ==> %ProgramFiles(x86)% 
    //        %commonprogramfiles% ==> %commonprogramfiles(x86)%
    //
/*
    if (IsAccessDeniedOnKeyByHandle (KeyHandle)){
        WCHAR PatchedIsnNode[WOW64_MAX_PATH];
        WCHAR AbsPath[WOW64_MAX_PATH];
        DWORD Len = WOW64_MAX_PATH;

        //
        // Create the key at different Location
        //
        
        HandleToKeyName (KeyHandle, PatchedIsnNode, &Len);
        
        wcscpy (AbsPath, L"\\REGISTRY\\MACHINE\\SYSTEM");
        wcscat (AbsPath, PatchedIsnNode);

        KeyHandle = OpenNode (AbsPath);
        if ( NULL == KeyHandle ) {
            CreateNode (AbsPath);
            KeyHandle = OpenNode (AbsPath);
        } //BUGBUG: free opened handle
        DbgPrint ("Reopening Keys at: %S\n", AbsPath);

        //return STATUS_ACCESS_DENIED;
    }
   */
    try {
        
        if ((DataSize > 0) &&
            (DataSize < ( _MAX_PATH*sizeof (WCHAR) - 10) && 
            ((Type == REG_SZ) || (Type == REG_EXPAND_SZ) )) )  { //(x86)==>10 byte

            PWCHAR p;
            PWCHAR t;

            //
            // do the thunking here.
            //


            memcpy ( (PBYTE ) &ThunkData[0], (PBYTE)Data, DataSize);
            ThunkData [DataSize/sizeof (WCHAR) ] = UNICODE_NULL; // make sure NULL terminated
        
            if ( (p = wcsstr (ThunkData, L"%ProgramFiles%" )) != NULL ){

                p +=13; //skip at the end of %ProgramFiles

            } else if ( (p = wcsstr (ThunkData, L"%commonprogramfiles%")) != NULL ){

                p +=19; //skip at the end of %commonprogramfiles
            
            }

            if (p) {

                t = pCorrectData + (p - ThunkData);
                wcscpy(p, L"(x86)"); //(x86)
                wcscat(p, t);        //copy rest of the string

                pCorrectData = ThunkData;
                CorrectDataSize += sizeof (L"(x86)");

            } else if ( (p=wcsistr (Data, L"\\System32\\")) != NULL) {
                
                if (IsOnReflectionByHandle ( KeyHandle ) ) {
                    wcsncpy (p, L"\\SysWow64\\",10);
                }
            }
        

            //
            // Call additional value patching routine here.
            //
        
            ShimRegistryValue (
                KeyHandle,
                pCorrectData,    //new data
                CorrectDataSize, //new size
                ThunkData,
                &CorrectDataSize,
                &bPatched
                );
        
            if (bPatched ) {
                pCorrectData = ThunkData;
            }      

        }
    } except (EXCEPTION_EXECUTE_HANDLER) {

          St = GetExceptionCode ();
    }

    //
    // Check if the operation should proceed. The key might be on access denied list.
    //

    if (NT_SUCCESS (St)) {
        
        St = NtSetValueKey(
            KeyHandle,
            ValueName,
            TitleIndex  ,
            Type,
            (PVOID)pCorrectData,
            CorrectDataSize
            );
    
        if (NT_SUCCESS(St)) {
            Wow64RegSetKeyDirty (KeyHandle ); // Need some clean/sync up on exit
        }
    }

    return St;
}


NTSTATUS
Wow64NtLoadKey(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile
    )

/*++

Routine Description:

    A hive (file in the format created by NtSaveKey) may be linked
    into the active registry with this call.  UNLIKE NtRestoreKey,
    the file specified to NtLoadKey will become the actual backing
    store of part of the registry (that is, it will NOT be copied.)

    The file may have an associated .log file.

    If the hive file is marked as needing a .log file, and one is
    not present, the call will fail.

    The name specified by SourceFile must be such that ".log" can
    be appended to it to generate the name of the log file.  Thus,
    on FAT file systems, the hive file may not have an extension.

    Caller must have SeRestorePrivilege privilege.

    This call is used by logon to make the user's profile available
    in the registry.  It is not intended for use doing backup,
    restore, etc.  Use NtRestoreKey for that.

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

    SourceFile - specifies a file.  while file could be remote,
                that is strongly discouraged.

Return Value:

    NTSTATUS - values TBS.

--*/

{
    return NtLoadKey(TargetKey, SourceFile);
}


NTSTATUS
Wow64NtLoadKey2(
    IN POBJECT_ATTRIBUTES TargetKey,
    IN POBJECT_ATTRIBUTES SourceFile,
    IN ULONG Flags
    )

/*++

Routine Description:

    A hive (file in the format created by NtSaveKey) may be linked
    into the active registry with this call.  UNLIKE NtRestoreKey,
    the file specified to NtLoadKey will become the actual backing
    store of part of the registry (that is, it will NOT be copied.)

    The file may have an associated .log file.

    If the hive file is marked as needing a .log file, and one is
    not present, the call will fail.

    The name specified by SourceFile must be such that ".log" can
    be appended to it to generate the name of the log file.  Thus,
    on FAT file systems, the hive file may not have an extension.

    Caller must have SeRestorePrivilege privilege.

    This call is used by logon to make the user's profile available
    in the registry.  It is not intended for use doing backup,
    restore, etc.  Use NtRestoreKey for that.

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

    SourceFile - specifies a file.  while file could be remote,
                that is strongly discouraged.

    Flags - specifies any flags that should be used for the load operation.
            The only valid flag is REG_NO_LAZY_FLUSH.


Return Value:

    NTSTATUS - values TBS.

--*/

{

    return NtLoadKey2(
                        TargetKey,
                        SourceFile,
                        Flags
                        );

}


NTSTATUS
Wow64NtUnloadKey(
    IN POBJECT_ATTRIBUTES TargetKey
    )
/*++

Routine Description:

    Drop a subtree (hive) out of the registry.

    Will fail if applied to anything other than the root of a hive.

    Cannot be applied to core system hives (HARDWARE, SYSTEM, etc.)

    Can be applied to user hives loaded via NtRestoreKey or NtLoadKey.

    If there are handles open to the hive being dropped, this call
    will fail.  Terminate relevent processes so that handles are
    closed.

    This call will flush the hive being dropped.

    Caller must have SeRestorePrivilege privilege.

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

Return Value:

    NTSTATUS - values TBS.

--*/

{
    return NtUnloadKey(
     TargetKey
    );
}


NTSTATUS
Wow64NtSetInformationKey(
    IN HANDLE KeyHandle,
    IN KEY_SET_INFORMATION_CLASS KeySetInformationClass,
    IN PVOID KeySetInformation,
    IN ULONG KeySetInformationLength
    )

{
    return NtSetInformationKey(
                                KeyHandle,
                                KeySetInformationClass,
                                KeySetInformation,
                                KeySetInformationLength
                                );
}


NTSTATUS
Wow64NtReplaceKey(
    IN POBJECT_ATTRIBUTES NewFile,
    IN HANDLE             TargetHandle,
    IN POBJECT_ATTRIBUTES OldFile
    )
/*++

Routine Description:

    A hive file may be "replaced" under a running system, such
    that the new file will be the one actually used at next
    boot, with this call.

    This routine will:

        Open newfile, and verify that it is a valid Hive file.

        Rename the Hive file backing TargetHandle to OldFile.
        All handles will remain open, and the system will continue
        to use the file until rebooted.

        Rename newfile to match the name of the hive file
        backing TargetHandle.

    .log and .alt files are ignored

    The system must be rebooted for any useful effect to be seen.

    Caller must have SeRestorePrivilege.

Arguments:

    NewFile - specifies the new file to use.  must not be just
              a handle, since NtReplaceKey will insist on
              opening the file for exclusive access (which it
              will hold until the system is rebooted.)

    TargetHandle - handle to a registry hive root

    OldFile - name of file to apply to current hive, which will
              become old hive

Return Value:

    NTSTATUS - values TBS.

--*/
{
    return NtReplaceKey(
                            NewFile,
                            TargetHandle,
                            OldFile
                            );
}



NTSTATUS
Wow64NtQueryMultipleValueKey(
    IN HANDLE KeyHandle,
    IN PKEY_VALUE_ENTRY ValueEntries,
    IN ULONG EntryCount,
    OUT PVOID ValueBuffer,
    IN OUT PULONG BufferLength,
    OUT OPTIONAL PULONG RequiredBufferLength
    )
/*++

Routine Description:

    Multiple values of any key may be queried atomically with
    this api.

Arguments:

    KeyHandle - Supplies the key to be queried.

    ValueNames - Supplies an array of value names to be queried

    ValueEntries - Returns an array of KEY_VALUE_ENTRY structures, one for each value.

    EntryCount - Supplies the number of entries in the ValueNames and ValueEntries arrays

    ValueBuffer - Returns the value data for each value.

    BufferLength - Supplies the length of the ValueBuffer array in bytes.
                   Returns the length of the ValueBuffer array that was filled in.

    RequiredBufferLength - if present, Returns the length in bytes of the ValueBuffer
                    array required to return all the values of this key.

Return Value:

    NTSTATUS

--*/
{
  return NtQueryMultipleValueKey(  KeyHandle,
                                   ValueEntries,
                                   EntryCount,
                                   ValueBuffer,
                                   BufferLength,
                                   RequiredBufferLength
                                  );
}


NTSTATUS
Wow64NtQueryOpenSubKeys(
    IN POBJECT_ATTRIBUTES TargetKey,
    OUT PULONG  HandleCount
    )
/*++

Routine Description:

    Dumps all the subkeys of the target key that are kept open by some other
    process; Returns the number of open subkeys


Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

Return Value:

    NTSTATUS - values TBS.

--*/
{
 return NtQueryOpenSubKeys( TargetKey, HandleCount );
}

NTSTATUS
Wow64NtSetSecurityObject (
    IN HANDLE Handle,
    IN SECURITY_INFORMATION SecurityInformation,
    IN PSECURITY_DESCRIPTOR SecurityDescriptor
    )

/*++

Routine Description:

    This routine is used to invoke an object's security routine.  It
    is used to set the object's security state.

Arguments:

    Handle - Supplies the handle for the object being modified

    SecurityInformation - Indicates the type of information we are
        interested in setting. e.g., owner, group, dacl, or sacl.

    SecurityDescriptor - Supplies the security descriptor for the
        object being modified.

Return Value:

    An appropriate NTSTATUS value

--*/
{
    //
    // Check if the handle points to a particular key, then if the API succeed 
    // Reflect that.
    //

    NTSTATUS St;
    NTSTATUS Status;
    POBJECT_TYPE_INFORMATION pTypeInfo;

    
    CHAR Buffer[1024];
    pTypeInfo = (POBJECT_TYPE_INFORMATION) Buffer;

    Status = NtQueryObject(Handle,
                           ObjectTypeInformation,
                           pTypeInfo,
                           sizeof (Buffer),
                           NULL
                           );

    St =  NtSetSecurityObject (
                                Handle,
                                SecurityInformation,
                                SecurityDescriptor
                                );

    //
    // If NT_SUCCESS (St) && the handle point on to a registry Key set the handle for reflection.
    //

    if (NT_SUCCESS (St) && NT_SUCCESS (Status)){


        if ( _wcsnicmp ( pTypeInfo->TypeName.Buffer, L"Key", 3) == 0)
            Wow64RegSetKeyDirty (Handle); // Need some clean/sync up on exit     
    }

    return St;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\regremap\test\main.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This module
//  Test case scenario
//      1. Open implement some test case scenario for regremap module.

//a ISN node and list content
//      2. Create a ISN node do 1.
//      3. Open a non ISN node and list
//      4. Create a non ISN node and list content
//

Author:

    ATM Shafiqul Khalid (askhalid) 10-Nov-1999

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include "wow64reg.h"
#include "..\wow64reg\reflectr.h"

#define TEST_NODE_NAME L"TEST"
#define GUID_STR L"{00000000-E877-11CE-9F68-00AA00574A40}"

typedef struct _TEST_NODE_TYPE {
    HKEY hKey;
    WCHAR Name[256];
    WCHAR SubKey[256];
}TEST_NODE_TYPE;

TEST_NODE_TYPE TestNodeList [] = {
    {HKEY_CLASSES_ROOT, L"test1002", UNICODE_NULL},
    {HKEY_CURRENT_USER, L"software\\classes\\test1002", UNICODE_NULL},
    {HKEY_LOCAL_MACHINE, L"software\\classes\\test1002", UNICODE_NULL},
    //{HKEY_USERS,""""""}
    };

#define TEST_NODE_NUM (sizeof (TestNodeList)/sizeof (TEST_NODE_TYPE) )

//should move into right header file
BOOL
NonMergeableValueCLSID (
    HKEY SrcKey,
    HKEY DestKey
    );
BOOL
GetKeyTime (
    HKEY SrcKey,
    ULONGLONG *Time
    );

BOOL
MergeKeySrcDest(
    PWCHAR Src,
    PWCHAR Dest
    );

BOOL
GetWow6432ValueKey (
    HKEY hKey,
    WOW6432_VALUEKEY *pValue
    );

BOOL
MergeK1K2Value (
    HKEY SrcKey,
    HKEY DestKey,
    DWORD dwFlag
    );

LONG
Wow64RegCreateKeyEx(
  HKEY hKey,                // handle to an open key
  LPCTSTR lpSubKey,         // address of subkey name
  DWORD Reserved,           // reserved
  LPTSTR lpClass,           // address of class string
  DWORD dwOptions,          // special options flag
  REGSAM samDesired,        // desired security access
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                            // address of key security structure
  PHKEY phkResult,          // address of buffer for opened handle
  LPDWORD lpdwDisposition   // address of disposition value buffer
);

BOOL
AnalyzeNode (
    PWCHAR pKeyName,
    BOOL bSync
    )
{
    WCHAR Name[256];
    WCHAR Mirror[256];
    DWORD AccessFlag;
    DWORD Ret;
    ULONGLONG Time1, Time2;
    WCHAR *GUIDName;
    
    
    WOW6432_VALUEKEY WowValue1;
    WOW6432_VALUEKEY WowValue2;

    DWORD dwLen = sizeof (Mirror)/sizeof(Mirror[0]);

    HKEY Key1;
    HKEY Key2;

    if (pKeyName == NULL )
        return FALSE;

    if (pKeyName[0] == UNICODE_NULL )
        return FALSE;


    wcscpy (Name, L"\\REGISTRY\\MACHINE\\SOFTWARE\\");
    if (_wcsnicmp (pKeyName, L"\\REGISTRY", 9 ) !=0 ) {
        wcscat (Name, pKeyName);
    } else wcscpy (Name, pKeyName);

    printf ("\nAnalyzing key [%S]\n", Name );

    //print the time stamp, value on the both side etc

    Key1 = OpenNode (Name);
    if (Key1 == NULL) {
        printf ("\nSorry! couldn't open the Key %S", Name );
        return FALSE;
    }

    //BUGBUG following operation should succeed but don't work for classes\wow6432node\.doc input
    //Possible bug in the WOW64RegOpenKeyEx
    /*Ret = RegOpenKeyEx(
                Key1,
                NULL,//NULL,
                0,//OpenOption,
                KEY_ALL_ACCESS | ( AccessFlag = Is64bitNode (Name)? KEY_WOW64_32KEY : KEY_WOW64_64KEY ),
                &Key2
                );

    if ( ERROR_SUCCESS != Ret ){
        printf ("\nSorry! couldn't open mirror of the Key %S", Name );
        return FALSE;
    }
    HandleToKeyName ( Key2, Mirror, &dwLen );
    */

    //Need to be removed this section
    
    GetMirrorName (Name, Mirror);
    Key2 = OpenNode (Mirror);
    if (Key2 == NULL) {
        printf ("\nSorry! couldn't open the mirror Key %S", Name );
        return FALSE;
    }

    printf ("\nOpened Mirror Key at %S", Mirror);

    //now print all the timing information

    printf ("\nExtension Test....");
    if ( NonMergeableValueCLSID (Key1, Key2 ))
        printf ("\nValue of those keys can't be merged...reasons: 1. not an extension 2. Handler don't exist");
    else
        printf ("\nValue of those keys will be merged by reflector");

    GUIDName = wcsstr (Name, L"\\CLSID\\{");
    if ( GUIDName != NULL ) {
        HKEY KeyGuid;

        DWORD SubkeyNumber=1;

        GUIDName +=7;
        printf ("\nGUID Test......%S", GUIDName);
        *(GUIDName -1) = UNICODE_NULL;
        KeyGuid = OpenNode (Name);
        *(GUIDName -1) = L'\\';

        MarkNonMergeableKey (GUIDName, KeyGuid, &SubkeyNumber);

        if ( SubkeyNumber>0)
            printf ("\nThe guid will be merged....");
        else
            printf ("\nthe guid isn't going to be merged");
    }



    GetKeyTime (Key1, &Time1);
    GetKeyTime (Key2, &Time2);
    printf ("\nOriginal TimeStamp on Keys Src:%p, Dest:%p", Time1, Time2);

    GetWow6432ValueKey ( Key1, &WowValue1);
    GetWow6432ValueKey ( Key2, &WowValue2);

    printf ("\nWowAttribute associated with Keys Src Value type:%d, Timestamp %p", WowValue1.ValueType, WowValue1.TimeStamp);
    printf ("\nWowAttribute associated with Keys Des Value type:%d, Timestamp %p", WowValue2.ValueType, WowValue2.TimeStamp);
    printf ("\nValueType 1=>Copy, 2=>Reflected, 3=>NonReflectable..\n(Timestamp,Value)=>0 wow attrib isn't there");

    if ( bSync ) {
        printf ("\n Merging Value/Keys.....");
        //MergeK1K2Value (Key1, Key2, 0);
        MergeKeySrcDest(Name, Mirror);
    }
    
    /*if ( bSync ) {
        printf ("\n Merging Value/Keys.....");
        //MergeK1K2Value (Key1, Key2, 0);
        MergeKeySrcDest(Name, Mirror);
    }

    if ( bSync ) {
        printf ("\n Merging Value/Keys.....");
        //MergeK1K2Value (Key1, Key2, 0);
        MergeKeySrcDest(Name, Mirror);
    }

    Sleep (1000*10);
    */
    return TRUE;
}

BOOL
DeleteNode (
    HKEY hKey,
    PWCHAR Name
    )
{
    return FALSE;
}

LONG
Wow64CreateOpenNode(
    HKEY hKey,
    PWCHAR Name,
    HKEY *phKey,
    DWORD dwOption,
    WCHAR Mode
    )
{
        WCHAR Buff [MAX_PATH + 1];
        DWORD dwBuffLen = MAX_PATH + 1;
        DWORD Ret;
        *phKey=NULL;

        Ret = Wow64RegCreateKeyEx(
                            hKey,        // handle to an open key
                            Name,                  // address of subkey name
                            0,                        // reserved
                            NULL,                     // address of class string
                            REG_OPTION_NON_VOLATILE,  // special options flag
                            KEY_ALL_ACCESS | dwOption,           // desired security access
                            NULL,                     // address of key security structure
                            phKey,                     // address of buffer for opened handle
                            NULL                     // address of disposition value buffer
                            );


        Buff[0]=UNICODE_NULL;
        if (*phKey == NULL) {
                HandleToKeyName ( hKey, Buff, &dwBuffLen );
                printf ("\nRegCreateEx failed....error: Flag:%d Ret:%d %S<\\>%S", dwOption, Ret, Buff, Name);
        }
            else if (Mode==L'V'){
                HandleToKeyName ( *phKey, Buff, &dwBuffLen );
                printf ("\nWow64RegCreateEx succeeded with ....[%S]", Buff);
            }

            return Ret;
}

LONG
CreateOpenNode(
    HKEY hKey,
    PWCHAR Name,
    HKEY *phKey,
    DWORD dwOption,
    WCHAR Mode
    )
{
        WCHAR Buff [MAX_PATH + 1];
        DWORD dwBuffLen = MAX_PATH + 1;
        DWORD Ret;
        *phKey=NULL;

        Ret = RegCreateKeyEx(
                            hKey,        // handle to an open key
                            Name,                  // address of subkey name
                            0,                        // reserved
                            NULL,                     // address of class string
                            REG_OPTION_NON_VOLATILE,  // special options flag
                            KEY_ALL_ACCESS | dwOption,           // desired security access
                            NULL,                     // address of key security structure
                            phKey,                     // address of buffer for opened handle
                            NULL                     // address of disposition value buffer
                            );


        Buff[0]=UNICODE_NULL;
        if (*phKey == NULL) {
                HandleToKeyName ( hKey, Buff, &dwBuffLen );
                printf ("\nRegCreateEx failed....error: Flag:%d Ret:%d %S<\\>%S", dwOption, Ret, Buff, Name);
        }
            else if (Mode==L'V'){
                HandleToKeyName ( *phKey, Buff, &dwBuffLen );
                printf ("\nRegCreateEx succeeded with ....[%S]", Buff);
            }


    if ( (( dwOption & KEY_WOW64_64KEY )&& ( wcsstr(Buff, L"Wow6432Node") != NULL ) ) ||  
        ( dwOption & KEY_WOW64_32KEY ) && ( wcsstr(Buff, L"Wow6432Node") == NULL ))
        printf ("\nSorry! key was created at wrong location..");

     return Ret;
}

OpenKey (
    HKEY hKey,
    PWCHAR Name,
    HKEY *phKey,
    DWORD dwOption,
    WCHAR Mode
    )
{
        WCHAR Buff [MAX_PATH + 1];
        DWORD dwBuffLen = MAX_PATH + 1;
        DWORD Ret;
        *phKey=NULL;

        Ret = RegOpenKeyEx(
                            hKey,
                            Name,
                            0,//OpenOption,
                            KEY_ALL_ACCESS | dwOption ,
                            phKey
                            );

        Buff[0]=UNICODE_NULL;

        if (*phKey == NULL) {

                HandleToKeyName ( hKey, Buff, &dwBuffLen );
                printf ("\nRegOpenEx failed....error: Flag:%d Ret:%d %S<\\>%S", dwOption, Ret, Buff, Name);

        }   else if (Mode==L'V'){

                HandleToKeyName ( *phKey, Buff, &dwBuffLen );
                printf ("\nRegOpenEx succeeded with ....[%S]", Buff);
            }

            return Ret;
}


BOOL
VerifyNode (
    HKEY hKey,
    PWCHAR OpenName,
    PWCHAR RealName
    )
{

    return FALSE;
}


HKEY
OpenListNode (
    HKEY OpenNode,
    WCHAR *NodeName,
    DWORD OpenOption
    )
{
    HKEY Key=NULL;
    LONG Ret, lCount =0;
    WCHAR Name [MAX_PATH + 1];

    DWORD dwBuffLen = MAX_PATH + 1;

    if ( NodeName == NULL )
        return NULL;
/*
#ifndef _WIN64
    //
    // just to test the library in the 32bit environment
    //
    if (OpenOption)
        Ret = Wow64RegOpenKeyEx(
                            OpenNode,
                            NodeName,
                            0,//OpenOption,
                            KEY_ALL_ACCESS | OpenOption ,
                            &Key
                            );
    else

#endif
*/
        Ret = RegOpenKeyEx(
                            OpenNode,
                            NodeName,
                            0,//OpenOption,
                            KEY_ALL_ACCESS | OpenOption ,
                            &Key
                            );

    if ( Key!= NULL )
        printf ( "\nOpen Operation successful [%S]", NodeName);
    else  {
        printf ( "\nOpen Operation Failed [%S] %X", NodeName, Ret);
        return NULL;
    }

    //
    // Now enumerate some value or key's to see what is there
    //

    lCount = 0;

    for(;;) {
        Ret =  RegEnumKey( Key, lCount, Name, MAX_PATH);
        if ( Ret != ERROR_SUCCESS ) break;

        printf ("\nKeyName: [%S]", Name);
        lCount++;
    }

    //
    //  Print the real name of the Key
    //
    HandleToKeyName ( Key, Name, &dwBuffLen );
    printf ("\nThe Real Name of the Key was [%S]", Name);

    return Key;
}


void BasicRegReMapTest()
{
    HKEY hSystem;
    HKEY Key;
    HKEY Key1;

    RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                L"SYSTEM",
                0,//OpenOption,
                KEY_ALL_ACCESS,
                &hSystem
                );

    printf ("\nHello! Im in the regremap piece this will print different view of a tree\n");

    printf ("\nOpening Native tree");
    Key = OpenListNode (hSystem, TEST_NODE_NAME, 0);
    RegCloseKey(Key);

    printf ("\n\nOpening Explicitly 32-bit tree");
    Key = OpenListNode (hSystem, TEST_NODE_NAME, KEY_WOW64_32KEY);

    {
        printf ("\nReopening 64bit key using handle to 32bit Key");
        Key1 = OpenListNode (Key, L"64bit Key1", KEY_WOW64_64KEY);
        RegCloseKey(Key1);
    }

    RegCloseKey(Key);

    printf ("\n\nOpening Explicitly 64-bit Tree");
    Key = OpenListNode (hSystem, TEST_NODE_NAME, KEY_WOW64_64KEY);

    {
        printf ("\nReopening 32bit key using handle to 64bit Key");
        Key1 = OpenListNode (Key, L"32bit Key1", KEY_WOW64_32KEY);
        RegCloseKey(Key1);
    }

    RegCloseKey(Key);
    RegCloseKey(hSystem);

    printf ("\nDone.");
}

void TestCreateHKCR ()
{
    HKEY hCR=NULL;
    HKEY Key=NULL;

    DWORD Ret;

    WCHAR Name [MAX_PATH + 1];

    DWORD dwBuffLen = MAX_PATH + 1;

    Ret = RegCreateKeyEx(
                            HKEY_CLASSES_ROOT,        // handle to an open key
                            L".001",                  // address of subkey name
                            0,                        // reserved
                            NULL,                     // address of class string
                            REG_OPTION_NON_VOLATILE,  // special options flag
                            KEY_ALL_ACCESS,        // desired security access
                            NULL,                     // address of key security structure
                            &hCR,                     // address of buffer for opened handle
                            NULL                     // address of disposition value buffer
                            );


    if (Ret == ERROR_SUCCESS ) {
        printf ("\nHello! checking key creation at classes root");
        HandleToKeyName ( hCR, Name, &dwBuffLen );
        printf ("\nThe Real Name of the Key was [%S]", Name);
        RegCloseKey(hCR);
    }
    else printf ("\nCouldn't create key .001 at HKEY_CLASSES_ROOT %d", Ret );
}

void TestOpenHKCR (DWORD x, DWORD y)
{
    //
    //  Need to make it work for true 64bit
    //

    HKEY hCR=NULL;
    HKEY Key=NULL;

    DWORD Ret;

    WCHAR Name [MAX_PATH + 1];

    DWORD dwBuffLen = MAX_PATH + 1;

    printf ("\n...Hello....");
    Ret = RegOpenKeyEx(
                HKEY_CURRENT_USER,
                L"Software",//NULL,
                0,//OpenOption,
                KEY_ALL_ACCESS | KEY_WOW64_32KEY,
                &hCR
                );

    if (Ret == ERROR_SUCCESS ) {
        printf ("\nHello! checking key open at classes root");
        HandleToKeyName ( hCR, Name, &dwBuffLen );
        printf ("\nThe Real Name of the Key was [%S] %p %p", Name, hCR, HKEY_CLASSES_ROOT);
        //RegCloseKey(hCR);
        //Name[wcslen(Name)-12]=UNICODE_NULL;
        //hCR = OpenNode (Name);
    }
    else printf ("\nCouldn't open HKEY_CLASSES_ROOT" );


    Ret = RegOpenKeyEx(
                HKEY_CURRENT_USER,
                L"software\\classes\\software\\classes\\abcdef\\xyzw.XYZW.1\\ShellNew",
                0,//OpenOption,
                KEY_READ | KEY_WOW64_32KEY,
                &Key
                );

    if (Ret == ERROR_SUCCESS ) {
        printf ("\n\nHello! checking key open at subkey under HKEY_CLASSES_ROOT");
        HandleToKeyName ( Key, Name, &dwBuffLen );
        printf ("\nThe Real Name of the Key was [%S]", Name);
        RegCloseKey(Key);
    }
    else printf ("\nCouldn't open subkey under HKEY_CLASSES_ROOT error%d", Ret);
}

void TestPredefinedHandle ()
{
    WCHAR Name [MAX_PATH];
    DWORD Ret;
    DWORD dwBuffLen = MAX_PATH + 1;
    HKEY Key1;

    Ret = OpenKey( HKEY_CLASSES_ROOT, NULL, &Key1, KEY_WOW64_64KEY, L'N');
    dwBuffLen = MAX_PATH + 1;
    HandleToKeyName ( Key1, Name, &dwBuffLen );
    RegCloseKey (Key1);
    if (!Is64bitNode (Name))
        printf ("\nCouldn't get 64bit HKCR using KEY_WOW64_64KEY: %S", Name);

    Ret = OpenKey( HKEY_CLASSES_ROOT, NULL, &Key1, KEY_WOW64_32KEY, L'N');
    dwBuffLen = MAX_PATH + 1;
    HandleToKeyName ( Key1, Name, &dwBuffLen );
    RegCloseKey (Key1);
    if (Is64bitNode (Name))
        printf ("\nCouldn't get 32bit HKCR using KEY_WOW64_32KEY: %S", Name);

    Ret = OpenKey( HKEY_CURRENT_USER, L"Software\\Classes", &Key1, KEY_WOW64_64KEY, L'N');
    dwBuffLen = MAX_PATH + 1;
    HandleToKeyName ( Key1, Name, &dwBuffLen );
    RegCloseKey (Key1);
    if (!Is64bitNode (Name))
        printf ("\nCouldn't get 64bit HKCU Software\\Classes using KEY_WOW64_64KEY: %S", Name);

    Ret = OpenKey( HKEY_CURRENT_USER, L"Software\\Classes", &Key1, KEY_WOW64_32KEY, L'N');
    dwBuffLen = MAX_PATH + 1;
    HandleToKeyName ( Key1, Name, &dwBuffLen );
    RegCloseKey (Key1);
    if (Is64bitNode (Name))
        printf ("\nCouldn't get 32bit HKCU Software\\Classes using KEY_WOW64_32KEY: %S %d", Name, Ret);

}

InProcLocalServerTest ()
{
    //
    // Create a server on the 64bit side with Inproc, and check on the 32bit if its get reflected.
    //

    HKEY Key1;
    HKEY Key2;
    WCHAR KeyName[256];
    DWORD Ret=0;

    wcscpy (KeyName, L"CLSID\\");
    wcscat (KeyName, GUID_STR);
    
   

    printf  ("\nTesting of GUID\\{Inproc Server, Local Server}...");

    Ret += CreateOpenNode (HKEY_CLASSES_ROOT, KeyName, &Key1, 0, L'N');
    Ret += CreateOpenNode (Key1, L"InprocServer32", &Key2, 0, L'N');
    RegCloseKey (Key1);
    RegCloseKey (Key2);
    //
    // Try to open on the 32bit side
    //

    if (OpenKey (HKEY_CLASSES_ROOT, KeyName, &Key1, KEY_WOW64_32KEY, L'V') == 0) {
        RegCloseKey (Key1);  //Key Shouldn'e be on the 32bit side
        Ret += -1;
    }

    //
    // You Need to add for test of local server...
    //

    if (Ret ==0)
        printf ("\nGUID Test Succeed......");
    else printf ("\nGUID test with Inprocserver failed..");
    


    //Delete the Key
    
}
void
OpenCreateKeyTest ()
{

    DWORD Ret=0;
    DWORD xx;

    HKEY Key1;
    HKEY Key2;

    InProcLocalServerTest ();

    TestPredefinedHandle ();

#define TEST_NODE1 L".0xxxxxx"

    printf ("\n//_______________Test 32bit side____________________//");

    Ret = 0;

    // create 64==>TestNode
    Ret += CreateOpenNode( HKEY_CLASSES_ROOT, TEST_NODE1, &Key1, KEY_WOW64_64KEY, L'V');
    //create 32==>TestNode\GUIDSTR
    Ret += CreateOpenNode(Key1, GUID_STR, &Key2, KEY_WOW64_32KEY, L'V');

    RegCloseKey (Key2);

    //open 32==>TestNode
    Ret += OpenKey( HKEY_CLASSES_ROOT, TEST_NODE1, &Key2, KEY_WOW64_32KEY, L'V' );

    //Delete 32\TestNode==>GUID
    if ((xx=RegDeleteKey (Key2, GUID_STR ))!= ERROR_SUCCESS )
        printf ("\nSorry! couldn't delete key %S Err:%d", GUID_STR, xx);
    Ret +=xx;

    RegCloseKey(Key2);
    RegCloseKey(Key1);

    //delete 32==>TestNode
    Ret +=OpenKey (HKEY_CLASSES_ROOT, NULL, &Key1, KEY_WOW64_32KEY, L'V');
    if ( (xx=RegDeleteKey (Key1, TEST_NODE1))!= ERROR_SUCCESS )
        printf ("\nSorry! couldn't delete key from 32bit tree=>%S Err:%d", TEST_NODE1, xx);
    Ret +=xx;
    RegCloseKey (Key1);

    //delete 64==>TestNode
    Ret +=OpenKey (HKEY_CLASSES_ROOT, NULL, &Key1, KEY_WOW64_64KEY, L'V');
    if ((xx= RegDeleteKey (Key1, TEST_NODE1))!= ERROR_SUCCESS )
        printf ("\nSorry! couldn't delete key from 64bit tree=>%S Err:%d", TEST_NODE1, xx);
    Ret +=xx;
    RegCloseKey (Key1);


    if (Ret != ERROR_SUCCESS )
        printf ("\nTest failed....");
    else
        printf ("\nTest succeed...");




    printf ("\n//_______________Test 64bit side____________________//");

    Ret = 0;
#define TEST_NODE2 L".0000######"
    // create 32==>TestNode
    Ret += CreateOpenNode( HKEY_CLASSES_ROOT, TEST_NODE2, &Key1, KEY_WOW64_32KEY, L'V');
    //create 64==>TestNode\GUIDSTR
    Ret += CreateOpenNode(Key1, GUID_STR, &Key2, KEY_WOW64_64KEY, L'V');

    RegCloseKey (Key2);

    //Open 64==>TestNode
    Ret += OpenKey( HKEY_CLASSES_ROOT, TEST_NODE2, &Key2, KEY_WOW64_64KEY, L'V' );

    //Delete 64\TestNode==>GUID
    if ((xx=RegDeleteKey (Key2, GUID_STR ))!= ERROR_SUCCESS )
        printf ("\nSorry! couldn't delete key %S Err:%d", GUID_STR, xx);
    Ret +=xx;

    RegCloseKey(Key2);
    RegCloseKey(Key1);


    //Delete 64==>TestNode
    Ret +=OpenKey (HKEY_CLASSES_ROOT, NULL, &Key1, KEY_WOW64_64KEY, L'V');
    if ((xx= RegDeleteKey (Key1, TEST_NODE2))!= ERROR_SUCCESS )
        printf ("\nSorry! couldn't delete key from 64bit tree=>%S  Err:%d", TEST_NODE2, xx);
    Ret +=xx;
    RegCloseKey (Key1);

    //Delete 32==>TestNode
    Ret +=OpenKey (HKEY_CLASSES_ROOT, NULL, &Key1, KEY_WOW64_32KEY, L'V');
    if ( (xx=RegDeleteKey (Key1, TEST_NODE2))!= ERROR_SUCCESS )
        printf ("\nSorry! couldn't delete key from 32bit tree=>%S Err:%d", TEST_NODE2, xx);
    Ret +=xx;
    RegCloseKey (Key1);

    if (Ret != ERROR_SUCCESS )
        printf ("\nTest failed....");
    else
        printf ("\nTest succeed...");

}

TestCreateOpenNode ()
{
    DWORD Count;
    DWORD i;
    HKEY hKey=NULL;
    DWORD Ret;

    Count =  TEST_NODE_NUM;

    for ( i=0; i<Count;i++) {
        Ret = CreateOpenNode (
                TestNodeList[i].hKey,
                TestNodeList[i].Name,
                &hKey,
                0,
                L'V'
                );
        if (hKey == NULL ) {
            printf ("\n Couldn't create/open Key %S",TestNodeList[i]);
            continue;
        }
    }

}

VOID
TestSharedResources ()
{

    //#define TEST_USER_CLASSES_ROOT L"\\REGISTRY\\MACHINE\\SYSTEM\\TEST345"
    #define TEST_USER_CLASSES_ROOT L"\\REGISTRY\\USER\\S-1-5-21-397955417-626881126-188441444-2721867_Classes"
    HANDLE hEvent;
    WCHAR Name[256];

    wcscpy (Name, TEST_USER_CLASSES_ROOT);

    if (!CreateNode (Name))
        printf ("\nSorry! Couldn't create key.. %S", TEST_USER_CLASSES_ROOT );

    Wow64RegNotifyLoadHive ( Name);

    //Wow64RegNotifyUnloadHive ( Name );

}

VOID 
TestTypeLib ()
{
  HKEY SrcKey;
  HKEY DestKey;
  printf ("\nTesting Typelib copy info...");

  SrcKey = OpenNode (L"\\REGISTRY\\MACHINE\\Software\\classes\\TypeLib");
  RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,        // handle to an open key
                            L"SOFTWARE\\Classes\\Wow6432Node\\TypeLib",  // address of subkey name
                            0,                        // reserved
                            NULL,                     // address of class string
                            REG_OPTION_NON_VOLATILE,  // special options flag
                            KEY_ALL_ACCESS,           // desired security access
                            NULL,                     // address of key security structure
                            &DestKey,                     // address of buffer for opened handle
                            NULL                     // address of disposition value buffer
                            );

  printf ("\n OpenHandle  %p %p", SrcKey, DestKey);
  ProcessTypeLib ( SrcKey, DestKey, FALSE );
}

VOID
TestRegReflectKey ()
{

  HKEY SrcKey;
  printf ("\nTesting RegSyncKey copy info...");

  SrcKey = OpenNode (L"\\REGISTRY\\MACHINE\\Software");

  printf ("\nRegReflectKey returned with  %d", RegReflectKey (SrcKey, L"1\\2\\3", 0) );
  RegCloseKey (SrcKey);
}

VOID
Test4()
{
    LONG lRes = 0;
    HKEY hKey = NULL;
    HKEY hKey32 = NULL;

    lRes = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        L"Software",
                        0,
                        KEY_ALL_ACCESS | KEY_WOW64_32KEY,
                        &hKey
                        );
    if(lRes != ERROR_SUCCESS)
    {
        return;
    }

    lRes = RegCreateKeyEx(
                            hKey,
                            L"_Key",
                            0,
                            NULL,
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS | KEY_WOW64_32KEY,
                            NULL,
                            &hKey32,
                            NULL
                            );
    if(lRes != 0)
    {
        printf("key not created\n");
        return;
    }
    RegCloseKey(hKey32);
}
void TestRegistry()
{
    HKEY hKey = NULL;
    HKEY Key1;
    HKEY Key2;

    //Test4();

    //RegOpenKeyEx ( HKEY_LOCAL_MACHINE, L"Software", 0, KEY_ALL_ACCESS, &hKey );
    //hKey = OpenNode (L"\\REGISTRY\\MACHINE");
    //CreateOpenNode(hKey, L"Software", &Key1, KEY_WOW64_32KEY, L'V');
    //CreateOpenNode(Key1, L"YYYzzz", &Key2, KEY_WOW64_32KEY, L'V');




    //TestRegReflectKey ();


    //TestSharedResources ();

    //TestTypeLib ();
    //BasicRegReMapTest();
    //TestOpenHKCR(1,2);
    printf ("\n\n2nd test.....OpenCreateKeyTest ()");
    OpenCreateKeyTest ();
    //TestCreateHKCR ();

}

LPTSTR NextParam (
    LPTSTR lpStr
    )
/*++

Routine Description

    Point to the next parameter in the commandline.

Arguments:

    lpStr - pointer to the current command line


Return Value:

    TRUE if the function succeed, FALSE otherwise.

--*/
{
	WCHAR ch = L' ';
		

    if (lpStr == NULL )
        return NULL;

    if ( *lpStr == 0 )
        return lpStr;

    while (  ( *lpStr != 0 ) && ( lpStr[0] != ch )) {

		if ( ( lpStr [0] == L'\"')  || ( lpStr [0] == L'\'') )
			ch = lpStr [0];

        lpStr++;
	}

	if ( ch !=L' ' ) lpStr++;

    while ( ( *lpStr != 0 ) && (lpStr[0] == L' ') )
        lpStr++;

    return lpStr;
}

DWORD CopyParam (
    LPTSTR lpDestParam,
    LPTSTR lpCommandParam
    )
/*++

Routine Description

    Copy the current parameter to lpDestParam.

Arguments:

    lpDestParam - that receive current parameter
    lpCommandParam - pointer to the current command line


Return Value:

    TRUE if the function succeed, FALSE otherwise.

--*/

{
	DWORD dwLen = 0;
	WCHAR ch = L' ';

	*lpDestParam = 0;
	
	if ( ( lpCommandParam [0] == L'\"')  || ( lpCommandParam [0] == L'\'') ) {
		ch = lpCommandParam [0];
		lpCommandParam++;
	};


    while ( ( lpCommandParam [0] ) != ch && ( lpCommandParam [0] !=0 ) ) {
        *lpDestParam++ = *lpCommandParam++;
		dwLen++;

		if ( dwLen>255 ) return FALSE;
	}

	if ( ch != L' ' && ch != lpCommandParam [0] )
		return FALSE;
	else lpCommandParam++;

    *lpDestParam = 0;

	return TRUE;

}

///////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////

BOOL
ParseCommand ()


/*++

Routine Description

    Parse command line parameters. Get different options from
    command line parameters.

Arguments:

    None.


Return Value:

    TRUE if the function succeed, FALSE otherwise.

--*/

{

    BOOL bSync = FALSE;

    LPTSTR lptCmdLine1 = GetCommandLine ();


    LPTSTR lptCmdLine = NextParam ( lptCmdLine1 );

    if ( lptCmdLine[0] == 0 )
        return FALSE;

    printf ("\nRunning Wow64 registry testing tool\n");

    while (  ( lptCmdLine != NULL ) && ( lptCmdLine[0] != 0 )  ) {

        if ( lptCmdLine[0] != '-' )
            return FALSE;

        switch ( lptCmdLine[1] ) {

        case L'C':  //sync ClsID
        case L'c':
            Wow64SyncCLSID ();
            break;

        case L'd':
            printf ("\n<TBD>Remove all the Keys from 32bit side that were copied from 64bit side");
            //CleanpRegistry ( );
            break;

        case L'D':
            printf ("\n<TBD>Remove all the Keys from 32bit side that were copied from 64bit side");
            //CleanpRegistry ();
            break;

       case L'p':
       case L'P':  // populate registry
            //CleanupWow64NodeKey ();
            PopulateReflectorTable ();
            break;

       case 't':
       case 'T':
            TestRegistry ();
            break;

        case L'r':
        case L'R':
            //
            //  run the reflector codes;
            //

            InitReflector ();
            if ( !RegisterReflector () ) {
                    printf ("\nSorry! reflector couldn't be register");
                    UnRegisterReflector ();
                    return FALSE;
            }

            printf ("\nSleeping for 100 min to test reflector codes ...........\n");
            Sleep (1000*60*100);

            UnRegisterReflector ();
            break;

        case L's':
        case L'S':
            bSync = TRUE;
            break;

        case L'a':
        case L'A':
            //
            // Analyze a key
            //
            AnalyzeNode (&lptCmdLine[2], bSync);
            break;


        default:
            return FALSE;
            break;
        }

        lptCmdLine = NextParam ( lptCmdLine );
    }

    return TRUE;
}

BOOL foo ()
{
WCHAR PathName[256];

wcscpy (PathName, L"c:\\Program Files (x86)\\foo.exe");


{
				UNICODE_STRING  FileNameU;
				HANDLE          FileHandle;
				OBJECT_ATTRIBUTES   ObjectAttributes;
				NTSTATUS Status;
				IO_STATUS_BLOCK   statusBlock;
				//

				//
				// Convert the Win32 pathname to an NT pathname
				//
				printf ("\nne w name %S", PathName);
				if (!RtlDosPathNameToNtPathName_U(PathName,
												  &FileNameU,
												  NULL,
												  NULL)) {
					// probably out-of-memory
					return FALSE;
				}

				printf ("\nne w name %S", FileNameU.Buffer);

				//
				// Open the file
				//
				InitializeObjectAttributes(&ObjectAttributes,
										   &FileNameU,
										   OBJ_CASE_INSENSITIVE,
										   NULL,
										   NULL);

				Status = NtOpenFile(&FileHandle,
								FILE_READ_DATA,
								NULL,
								&statusBlock,
								FILE_SHARE_READ,
								0);

				RtlFreeHeap(RtlProcessHeap(), 0, FileNameU.Buffer);
				

			    if (NT_SUCCESS(Status)) {
					printf ("\nfoo");
				} else printf ("\nFailed %x",Status);
			}
return 0;
}

TestDebugRegistryRedirectionOnClose ()
{
#if DBG
	VOID
DebugRegistryRedirectionOnClose (
    HANDLE KeyHandle,
	PWCHAR Message
    );

	HKEY hKey = OpenNode (L"\\REGISTRY\\MACHINE\\SOFTWARE");
	DebugRegistryRedirectionOnClose (hKey, L"Hello");
	NtClose (hKey);
#endif

}

void
InitializeWow64OnBoot1(
    DWORD dwFlag
    )
/*++

Routine Description:

  Called from advapi to get an handle to remapped key that is on reflection list.

Arguments:

  dwFlag - define the point where this function were invoked.
    1- means were invoked from csr service
    2- means this were invoked by setup.

Return Value:

  None.
--*/
{
    DWORD Ret;
    HKEY Key;
    NTSTATUS st;
    
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING KeyName;

	//
	// Delete the link key if that does exist.
	//
    RtlInitUnicodeString (&KeyName, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Classes");
    InitializeObjectAttributes (&Obja, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );
	
    st = NtOpenKey (&Key, KEY_ALL_ACCESS, &Obja);
	if (NT_SUCCESS(st)) {
		st = NtDeleteKey (Key);
		NtClose (Key);
	}


    RtlInitUnicodeString (&KeyName, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Classes");
    InitializeObjectAttributes (&Obja, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );

    st = NtCreateKey(
                    &Key,
                    KEY_ALL_ACCESS | KEY_CREATE_LINK,
                    &Obja,
                    0,
                    NULL ,
                    REG_OPTION_NON_VOLATILE | REG_OPTION_OPEN_LINK | REG_OPTION_CREATE_LINK,  // special options flag
                    NULL
                    );
    
    if (NT_SUCCESS(st)) {

        RtlInitUnicodeString (&KeyName, L"SymbolicLinkValue");
        st = NtSetValueKey(
                                Key,
                                &KeyName,
                                0  ,
                                REG_LINK,
                                (PBYTE)WOW64_32BIT_MACHINE_CLASSES_ROOT,
                                (DWORD ) (wcslen (WOW64_32BIT_MACHINE_CLASSES_ROOT) * sizeof (WCHAR))
                                );

        
        NtClose(Key);
        if ( !NT_SUCCESS(st) ) {
#if DBG
			DbgPrint ( "Wow64-InitializeWow64OnBoot: Couldn't create symbolic link%S\n", WOW64_32BIT_MACHINE_CLASSES_ROOT);
#endif
            return;
        }
    }
    return;
}
int __cdecl
main()
{

	InitializeWow64OnBoot1 (0);
 //foo();
 //TestDebugRegistryRedirectionOnClose();
 /*   if (!ParseCommand ()) {

        printf ( "\nUsages: w64setup [-c] [-C] [-d] [-D] [-r]\n");
        printf ( "\n        -c Copy from 32bit to 64bit side of the registry");
        printf ( "\n        -C Copy from 64bit to 32bit side of the registry");
        printf ( "\n");
        printf ( "\n        -d Remove all the Keys from 32bit side that were copied from 64bit side");
        printf ( "\n        -D Remove all the Keys from 64bit side that were copied from 32bit side");

        printf ( "\n");
        printf ( "\n        -r Run reflector thread");
        printf ( "\n        -A Analyze a key if that going to be reflected");

        printf ("\n");
        return 0;

    }
*/

    printf ("\nDone.");
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\regremap\regmisc.c ===
/*++

Copyright (c) 1999-2001  Microsoft Corporation 

Module Name:

    regmisc.c

Abstract:

    This module implement some function used in the registry redirector.

Author:

    ATM Shafiqul Khalid (askhalid) 29-Oct-1999

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <ntregapi.h>

#include "regremap.h"
#include "wow64reg.h"
#include "wow64reg\reflectr.h"


#ifdef _WOW64DLLAPI_
#include "wow64.h"
#else
#define ERRORLOG 1  //this one is completely dummy
#define LOGPRINT(x)
#define WOWASSERT(p)
#endif //_WOW64DLLAPI_


#include "regremap.h"
#include "wow64reg.h"

ASSERTNAME;

//#define LOG_REGISTRY
const WCHAR IsnNodeListPath[]={WOW64_REGISTRY_SETUP_KEY_NAME};

#define KEY_NAME(x) {x,((sizeof (x) / sizeof (WCHAR))-1)}

typedef struct _REGKEY_LIST {
    WCHAR KeyPath[256];
    DWORD Len;
} REGKEY_LIST;


//
// Table that will have the list of ISN node. Need to allocate runtime.
//

#define WOW64_ISN_NODE_MAX_NUM 12  // this is internal to wow64 setup might use different size of table
NODETYPE IsnNode[WOW64_ISN_NODE_MAX_NUM]={
    {L"\\REGISTRY\\MACHINE\\SOFTWARE\\CLASSES"},
    {L"\\REGISTRY\\MACHINE\\SOFTWARE"},
    {L"\\REGISTRY\\USER\\*\\SOFTWARE\\CLASSES"},  // ISN node table is always upcase.
    {L"\\REGISTRY\\USER\\*_CLASSES"},
    {L"\\REGISTRY\\MACHINE\\SYSTEM\\TEST"},
    {L""}
    };

//
// 64bit IE load mail client dll inproc breaking interop functionality.
// The are some Dll get loaded Inproc {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Clients\\mail"}, //Email Client Key 
//
// Must keep 32-bit and 64-bit uninstall keys separate to ensure the correct environment
// variables are used for REG_EXPAND_SZ and to make sure we run the correct bitness of rundll32.exe.
// {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\UnInstall"},    // UnInstall Key
//

REGKEY_LIST ExemptRedirectedKey[]={
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\SystemCertificates"),    // Certificate Key
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Cryptography\\Services"),    // Cryptography Service
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\HCP"),    // HelpCenter Key
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\EnterpriseCertificates"),    // Enterprise Service
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\MSMQ"),    //  MSMQ registry 
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList"),    //  Profiles
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Perflib"), // Performance counters
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Print"), // Spooler Printers
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Ports"), // Spooler Ports
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Policies"),       // policie keys
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Group Policy"),       // policie keys
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Policies"), //Policy Keys
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup\\OC Manager"), //OC Manager Keys
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Software\\Microsoft\\Shared Tools\\MSInfo"), //share MSinfo Key
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Setup"), //Share setup Keys
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\CTF\\TIP"), //CTF\TIP Key
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\CTF\\SystemShared"),
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Fonts"), //Share fonts
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\RAS"),    //  RAS keys need to be shared
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Driver Signing"),    //  Share Driver signing Keys
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Non-Driver Signing"),    //  Share Driver signing Keys
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Cryptography\\Calais\\Current"), // SmartCard subsytem pipe name
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Cryptography\\Calais\\Readers"), // SmartCard installed readers
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones"), // Share time zone key
    KEY_NAME(L""), // Two additional NULL String for additional space. 
    KEY_NAME(L"")
    };


//
// A note about PerfLib... in ntos\config, the init code creates a special
// key called PerfLib\009 and if you call NtOpenKey on that path, it returns
// back HKEY_PERFORMANCE_DATA, not a regular kernel registry handle to
// \\REGISTRY\\MACHINE\\stuff.  Instead, HKEY_PERFORMANCE_DATA is intercepted
// in usermode by advapi32.dll.  The Counters and Help REG_MULTI_SZ values
// don't really exist - they are synthesized by advapi32 based on the
// contents of the perf*.dat files in system32.  This works OK for 32-bit
// advapi32 on WOW64 as advapi opens the *.dat files using NtOpenFile
// with an OBJECT_ATTRIBUTES containing "\SystemRoot\System32\..." which
// doesn't get intercepted by the system32 remapper.
//

//
// Don't let 32bit apps modify ControlSet Keys, exceptions defined by another set of keys.
//
REGKEY_LIST DenyKeyAccess[]={
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet*"),
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet"),
        KEY_NAME(L"")
    };

//
// Owner under services should be able to modify. i.e., if 32bit apps create some keys they can modify them.
//

REGKEY_LIST ExemptDenyKeyAccessOwner[]={
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet*\\Services"),
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services"),
        KEY_NAME(L"")
    };

//
// 32bit apps can do whatever they want. generally shareavle across 32bit/64bit apps.
//

REGKEY_LIST ExemptDenyKeyAccess[]={
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet*\\Services\\Control\\Session Manager"),
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\Control\\Session Manager"),
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SYSTEM\\ControlSet*\\Services\\EventLog"),
    KEY_NAME(L"\\REGISTRY\\MACHINE\\SYSTEM\\CurrentControlSet\\Services\\EventLog"),
        KEY_NAME(L"")
    };


PWCHAR
wcsistr(
    PWCHAR string1,
    PWCHAR string2
    )
{
    PWCHAR p1;
    PWCHAR p2;

    if ((NULL == string2) || (NULL == string1))
    {
        // do whatever wcsstr would do
        return wcsstr(string1, string2);
    }

    

    while (*string1)
    {
        for (p1 = string1, p2 = string2;
             *p1 && *p2 && towlower(*p1) == towlower(*p2);
             ++p1, ++p2)
        {
            // nothing
        }

        if (!*p2) 
        {
            // we found a match!
            return (PWCHAR)string1;   // cast away const!
        }

        ++string1;
    }

    return NULL;
}

PWCHAR
wcsstrWow6432Node (
    PWCHAR pSrc
    )
{
    
    return  wcsistr (pSrc, NODE_NAME_32BIT);
    
}

PWCHAR
wcsstrWithWildCard (
    PWCHAR srcStr,
    PWCHAR destIsnNode
    )
/*++

Routine Description:

    a customised version of wcsstr with wild card support. For example the
    substring might have '*' character which can be matched with any key name.

Arguments:

    srcStr - The string where the substring need to be searched for.
    destIsnNode - the string to search.

Return Value:

    TRUE if the operation succeed, FALSE otherwise.
--*/


{
    //multiple wildcard isn't allowed?

    PWCHAR src = srcStr;
    PWCHAR dest = destIsnNode;

    PWCHAR p, t;
    DWORD count;

    for (;;) {

        if (*dest == UNICODE_NULL)
            return ( *src == UNICODE_NULL)? src : src+1;  //source might point to SLASH

        if (*src == UNICODE_NULL)
            return NULL;

        count = wcslen (dest);
        if ( ( p = wcschr( dest,'*') ) == NULL ) {
            if ( _wcsnicmp (src, dest, count) == 0 ){

                //
                // xx\Test shouldn't show xx\test345 as an ISN node.
                //
                if ( src [ count ] != UNICODE_NULL && src [ count ] != L'\\' ) //terminator need tobe NULL or slash
                    return NULL;

                return  (*(src+count) != UNICODE_NULL ) ? src+count+1: src+count; // xx\test return pointer at test if dest is xx.
            }
            else
                return NULL;
        }

        count = (DWORD) (p-dest);
       // LOGPRINT( (ERRORLOG, "\nFinding [%S] withing %S, p=%S Val%d",dest, src, p, count ));


        if (_wcsnicmp (src, dest, count) !=0)  // checking the initial state
            return NULL;

        //
        // need to check *_Classes type ISN Node
        //
        p++;  //skip the wild card
        t=src+count;
        while ( *t != L'\\' && *t != UNICODE_NULL )
            t++;

        for ( count=0;*p != L'\\' && *p != UNICODE_NULL; p++, count++)
            ;
        if (_wcsnicmp (p-count, t-count, count) != 0)
            return NULL;

      //  LOGPRINT( (ERRORLOG, "\nFinding 2nd[%S] withing %S, p=%S",dest, src, p ));
        src = t;
        dest = p;
    }

    return NULL;
}

HKEY
OpenNode (
    PWCHAR NodeName
    )
/*++

Routine Description:

    Open a given key for generic access.

Arguments:

    NodeName - name of the key to check.

Return Value:

    NULL in case of failure.
    Valid handle otherwise.
--*/

{
    NTSTATUS st;
    HKEY  hKey;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING KeyName;


    RtlInitUnicodeString (&KeyName, NodeName);
    InitializeObjectAttributes (&Obja, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );

    st = NtOpenKey (&hKey, KEY_ALL_ACCESS, &Obja);

    if (!NT_SUCCESS(st))
        return NULL;

    return hKey;
}

VOID
CloseNode (
HANDLE Key
)
{
    NtClose (Key);
}

NTSTATUS
IsNodeExist (
    PWCHAR NodeName
    )
/*++

Routine Description:

    Check if the given key exist if not create the key.

Arguments:

    NodeName - name of the key to check.

Return Value:

    TRUE if the operation succeed, FALSE otherwise.
--*/

{

    NTSTATUS st;
    HANDLE  hKey;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING KeyName;


    RtlInitUnicodeString (&KeyName, NodeName);
    InitializeObjectAttributes (&Obja, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );

    st = NtOpenKey (&hKey, KEY_READ, &Obja);

    if (!NT_SUCCESS(st))
        return st;

    NtClose (hKey);
    //LOGPRINT( (ERRORLOG, "\nValid IsnNode [%S]",NodeName ));
    return st;

}

BOOL
CreateNode (
    PWCHAR Path
    )
/*++

Routine Description:

    Create all the node along the path if missing. Called by background
    thread working on the setup.

Arguments:

    Path - name of path to the key.

Return Value:

    TRUE if the operation succeed, FALSE otherwise.
--*/

{
    //
    // isolate individual nodes and backtrack
    //
    NTSTATUS st;
    HANDLE  hKey;
    HANDLE  hKeyCreate;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING KeyName;
    PWCHAR pTrace;
    PWCHAR p;


    pTrace = Path+wcslen (Path); //pTrace point at the end of path
    p=pTrace;

    for (;;) {
        RtlInitUnicodeString (&KeyName, Path);
        InitializeObjectAttributes (&Obja, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );

        st = NtOpenKey (&hKey, KEY_WRITE | KEY_READ, &Obja);

        if ( st == STATUS_OBJECT_NAME_NOT_FOUND ) {
            //backtrack until you hit the line
            while ( *p != L'\\' && p!= Path)
                p--;

            //LOGPRINT( (ERRORLOG, "\nTest Code[%S]",p ));
            if ( p == Path ) break;
            *p = UNICODE_NULL;
            continue;
        }

        break;
    }

    if (!NT_SUCCESS(st)) {
        //fixup the string and return
        for ( ;p != pTrace;p++ )
            if ( *p == UNICODE_NULL) *p=L'\\';

        return FALSE;
    }

    //
    // now create key from point p until p hit pTrace
    //

    while ( p != pTrace ) {

        *p = L'\\'; //added the char back
        p++; //p will point a non NULL string

        RtlInitUnicodeString (&KeyName, p);
        InitializeObjectAttributes (&Obja, &KeyName, OBJ_CASE_INSENSITIVE, hKey, NULL );

        st = NtCreateKey(
                        &hKeyCreate,
                        KEY_WRITE | KEY_READ,
                        &Obja,
                        0,
                        NULL ,
                        REG_OPTION_NON_VOLATILE,
                        NULL
                        );

        if (!NT_SUCCESS(st))  {
            LOGPRINT( (ERRORLOG, "\nCouldn't create Key named[%S]",p ));
            break;
        }

        NtClose (hKey);
        hKey = hKeyCreate;

        while ( *p != UNICODE_NULL ) p++;
    }

    NtClose (hKey);

    if (!NT_SUCCESS(st)) {
        for ( ;p != pTrace;p++ )
            if ( *p == UNICODE_NULL) *p=L'\\';
        return FALSE;
    }
    return TRUE;
}

BOOL
CheckAndCreateNode (
    IN PWCHAR Name
    )
/*++

Routine Description:

    Check if the given key exist if not create the key. called by background
    thread working on the setup.

Arguments:

    Name - name of the key to check.

Return Value:

    TRUE if the operation succeed, FALSE otherwise.
--*/
{
    ISN_NODE_TYPE Node;
    PWCHAR p;
    //
    // if parent doesn't exist you shouldn't create the child
    //

    if (!NT_SUCCESS(IsNodeExist (Name)) ) {

        p  = wcsstrWow6432Node (Name);
        if ( p != NULL ) {
            wcsncpy (Node.NodeValue, Name, p-Name-1);
            Node.NodeValue[p-Name-1] = UNICODE_NULL;
        }
        else
            return FALSE;

        if (NT_SUCCESS(IsNodeExist (Node.NodeValue)) )
            return CreateNode (Name);
    }
    return TRUE;

}


//
//  Opaque field might contain some information about the key on the 32bit side.
//

BOOL
IsIsnNode (
   PWCHAR wStr,
   PWCHAR *pwStrIsn
   )
/*++

Routine Description:

    Will determine if the given path has any ISN node.

Arguments:

    wStr - string to that might contain some ISN node.
    pwStrDest - point to the node after ISN node.

Return Value:

    TRUE if the string has any ISN node, FALSE otherwise
--*/
{
    int Index=0;



    //
    // Check if the provided string is already on the 32 bit tree, if so we can
    //   just ignore that
    //

    //
    // check if input string has any known symbolic link like \registry\user\sid_Classes that need to remap to a different location
    //


    for (;;) {

        if ( IsnNode [Index][0]==UNICODE_NULL ) break;

        if ( (*pwStrIsn = wcsstrWithWildCard (wStr, IsnNode[Index] ) ) != NULL )
            return TRUE;

        Index++;
    };


    *pwStrIsn = NULL;
    return FALSE;
}

NTSTATUS 
ObjectAttributesToKeyName (
    POBJECT_ATTRIBUTES ObjectAttributes,
    PWCHAR AbsPath,
    DWORD  AbsPathLenIn,
    BOOL *bPatched,
    DWORD *ParentLen
    )
/*++

Routine Description:

    Determine the text equivalent for key handle

Arguments:

    ObjectAttributes define the object attribute Keyname need to be constracted.
    AbsPath Unicode string to receive the Name of the key.
    bPatched - TRUE if the Name has been compressed/expanded that
               the original object can't refer. Caller need to construct
               a new obj attribute.
               unchanged otherwise.
    ParentLen - Length of the parent name.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS Status;
    ULONG Length;
    ULONG AbsPathLen = 0;
    BYTE *pAbsPath = (PBYTE)AbsPath;

    POBJECT_NAME_INFORMATION ObjectName = (POBJECT_NAME_INFORMATION)AbsPath;  //Smartly use user buffer

    
    if (ParentLen)
        *ParentLen = 0;

    if (ObjectAttributes == NULL)
        return STATUS_INVALID_PARAMETER;

    if (ObjectAttributes->RootDirectory) {

        Status = NtQueryObject(ObjectAttributes->RootDirectory,
                           ObjectNameInformation,
                           ObjectName,
                           AbsPathLenIn,
                           &Length
                           );

        if ( !NT_SUCCESS(Status) )
             return Status;
    } else {

        AbsPathLen = ObjectAttributes->ObjectName->Length;

        if (AbsPathLenIn <= AbsPathLen)
            return STATUS_BUFFER_OVERFLOW;

        memcpy ( pAbsPath, (PBYTE)ObjectAttributes->ObjectName->Buffer, AbsPathLen );
        *(WCHAR *)(pAbsPath+AbsPathLen) = UNICODE_NULL;
    
        if (ParentLen)
            *ParentLen = AbsPathLen; // length of the parent handle
        return STATUS_SUCCESS;
    }

    //
    //  copy the root and sub path
    //
    AbsPathLen = ObjectName->Name.Length;
    memcpy ( pAbsPath, (PBYTE)ObjectName->Name.Buffer, AbsPathLen);

    if ( ObjectAttributes->ObjectName->Length > 1 ) { // Valid object name need to be greater

        *(WCHAR *)(pAbsPath+AbsPathLen) = L'\\';
        AbsPathLen += sizeof ( L'\\');


        if (AbsPathLenIn <= (AbsPathLen+ObjectAttributes->ObjectName->Length))
            return STATUS_BUFFER_OVERFLOW;

        memcpy (
            pAbsPath+AbsPathLen,
            ObjectAttributes->ObjectName->Buffer,
            ObjectAttributes->ObjectName->Length
            );

        AbsPathLen += ObjectAttributes->ObjectName->Length;
    }

    *(WCHAR *)(pAbsPath+AbsPathLen) = UNICODE_NULL;
    //
    // Compress the path in case multiple wow6432node exist
    //
    for (;;) {
        PWCHAR p, t;

        if ( (p=wcsstrWow6432Node (AbsPath)) != NULL ) {

            if ( (t=wcsstrWow6432Node(p+1)) != NULL) {

                wcscpy (p,t);
                *bPatched = TRUE;
            }
            else break;

        } else break;
    }

    return STATUS_SUCCESS;
}

BOOL
HandleToKeyName (
    HANDLE Key,
    PWCHAR KeyName,
    DWORD * dwLen
    )
/*++

Routine Description:

    Determine the text equivalent for key handle

Arguments:

    Key - is key handle for which to obtain its text
    KeyName - Unicode string to receive the Name of the key.
    dwLen   - Length of the buffer pointed by KeyName. (Number of unicode char)

Return Value:

    TRUE if the handle text is fetched OK.  FALSE if not (ie. error or
    Key is an illegal handle, etc.)

--*/
{
    NTSTATUS Status;
    ULONG Length;

    DWORD NameLen;

    POBJECT_NAME_INFORMATION ObjectName;

    ObjectName = (POBJECT_NAME_INFORMATION)KeyName;  //use the user buffer to make the call to save space on stack.

    KeyName[0]= UNICODE_NULL;
    if (Key == NULL) {
        KeyName[0]= UNICODE_NULL;
        return FALSE;
    }

    Status = NtQueryObject(Key,
                       ObjectNameInformation,
                       ObjectName,
                       *dwLen-8,
                       &Length
                       );
    NameLen = ObjectName->Name.Length/sizeof(WCHAR);

    if (!NT_SUCCESS(Status) || !Length || Length >= (*dwLen-8)) {
        DbgPrint ("HandleToKeyName: NtQuery Object failed St:%x, Handle: %x\n", Status, Key);
        KeyName[0]= UNICODE_NULL;
        return FALSE;
    }

    //
    //  buffer overflow condition check
    //

    if (*dwLen < ( NameLen + 8+ 2) ) {

        *dwLen = 2 + NameLen + 8;
        DbgPrint ("HandleToKeyName: Buffer over flow.\n");
        KeyName[0]= UNICODE_NULL;
        return FALSE;  //buffer overflow
    }

    wcsncpy(KeyName, ObjectName->Name.Buffer, NameLen);
    KeyName[NameLen]=UNICODE_NULL;
    return TRUE;
}


BOOL
Map32bitTo64bitKeyName (
    IN  PWCHAR Name32Key,
    OUT PWCHAR Name64Key
    )
/*++

Routine Description:

    Return a key name valid in the 64-bit registry side. It's the caller responsibility
    to give enough space in the output buffer. Its internal routine and no boundary
    checking is done here.

Arguments:

    Name32Key - Input 32bit/64 bit Key name.
    Name64Key - Receiving Buffer that will hold the equivalent 64bit Key.

Return Value:

    TRUE if the remapping become successful.
    FALSE otherwise.

--*/
{

    //
    //  just remove 32bit related patch from the name if anything like that exist.
    //  If the key is already on the 64bit side don't bother return the whole copy.
    //

    PWCHAR NodeName32Bit;
    DWORD Count;

    try {
        if ( ( NodeName32Bit = wcsstrWow6432Node (Name32Key)) == NULL) {  // nothing to remap

            wcscpy (Name64Key, Name32Key);
            return TRUE;
        }

        Count = (DWORD)(NodeName32Bit - Name32Key);
        wcsncpy (Name64Key, Name32Key, Count-1);
        Name64Key[Count-1]=UNICODE_NULL;

        if (NodeName32Bit[NODE_NAME_32BIT_LEN] == L'\\')
        wcscpy (
            Name64Key + Count-1,
            NodeName32Bit + NODE_NAME_32BIT_LEN); //One if to skip the char'/'

    } except( NULL, EXCEPTION_EXECUTE_HANDLER){

        return FALSE;
    }

    return TRUE; //any complete path can have only one instance of NODE_NAME_32BIT
}

BOOL
IsAccessDeniedOnKey (
    IN  PWCHAR SrcKey,
    DWORD *FilteredAccess,
    BOOL bCreateCall
    )
/*++

Routine Description:

    Check if access should be denied on the key.

Arguments:

    SrcKey - Input 32bit/64 bit Key name.
    *FilteredAccess - 
    bCreateCall TRUE indicates the call path is on Key Creation.
                FALSE means simply OpenCall.

Return Value:

    TRUE if given access should be filtered.
    FALSE otherwise.

--*/
{
    //
    // Make 64bit only path
    //
  
    DWORD dwIndex;
    BOOL bKeyExists = FALSE;
    DWORD dwAttribute = 0;
    HKEY hKeyTemp;
    extern BOOL bEnableCurrentControlSetProtection;

    if ( (*FilteredAccess & KEY_WOW64_64KEY) || (!bEnableCurrentControlSetProtection) )
        return FALSE; //shouldn't  block this call in any case

    if ( (!bCreateCall) && !(*FilteredAccess & ~(KEY_READ) ))
        return FALSE; //benign OpenCall without update access

    for ( dwIndex = 0; ExemptDenyKeyAccess[dwIndex].KeyPath[0] != UNICODE_NULL; dwIndex++ ) {
        if (wcsstrWithWildCard (SrcKey, ExemptDenyKeyAccess[dwIndex].KeyPath) != NULL) {
            //
            // allow access always. ALL access are gauranteed.
            //
            return FALSE; 
        }
    }


    //
    // Check owner based access.
    //

    for ( dwIndex = 0; ExemptDenyKeyAccessOwner[dwIndex].KeyPath[0] != UNICODE_NULL; dwIndex++ ) {
        if (wcsstrWithWildCard (SrcKey, ExemptDenyKeyAccessOwner[dwIndex].KeyPath) != NULL) {

            hKeyTemp = OpenNode (SrcKey);
            if ( NULL != hKeyTemp ) {
                bKeyExists = TRUE;
                QueryKeyTag ( hKeyTemp, &dwAttribute );
                NtClose (hKeyTemp);
            }
            //
            // allow access always. Only Owner get full access to the key it owns, otherwise filtered access.
            //
            // Open call  - should be filter on unowned key, 
            // CreateCall - new key creation should proceede unfiltered.
            //

            if ( bKeyExists && !(dwAttribute & TAG_KEY_ATTRIBUTE_32BIT_WRITE) ) {
                *FilteredAccess = KEY_READ;
            }
            //DbgPrint ("Wow64-ControlSet:filtering access:[%S][Call:%x, Exist:%x, Attrib:%x]\n", SrcKey, bCreateCall, bKeyExists, dwAttribute);
            return FALSE; //call shouldn't be blocked
        }
    } //for-loop


    for ( dwIndex = 0; DenyKeyAccess[dwIndex].KeyPath[0] != UNICODE_NULL; dwIndex++ ) 
        if (wcsstrWithWildCard (SrcKey, DenyKeyAccess[dwIndex].KeyPath) != NULL) {

            hKeyTemp = OpenNode (SrcKey);
            if ( NULL != hKeyTemp ) {
                bKeyExists = TRUE;
                NtClose (hKeyTemp);
            }
            //
            // Yes, update access need to be denied.
            //
            // Open Call - should succeed here with filtered access
            // Create Call - Must fail
            //
            //*FilteredAccess &= (~KEY_WRITE); //filter access for all case
            *FilteredAccess = KEY_READ;
            if (bCreateCall && !bKeyExists) {
                //DbgPrint ("Wow64-ControlSet:dening access to Registry Key: %S[Call:%x, Exist:%x]\n", SrcKey, bCreateCall, bKeyExists);
                return TRUE;  // you can't allow a new key creation here.
            }
            //DbgPrint ("Wow64-ControlSet:Allowing ReadOnly access:[%S][Call:%x, Exist:%x]\n", SrcKey, bCreateCall, bKeyExists);
            return FALSE;
        }

    return FALSE;
}


BOOL
AdvapiAccessDenied (
    HKEY hKey, 
    const WCHAR * lpSubKey, 
    PWCHAR ParentName, 
    DWORD dwLen,
    DWORD *pAccessMask,
    BOOL bCreateCall
    )
/*++

Routine Description:

    This API dedermine if the target call with given parameter should fail or 
    Access need to be filtered.

Arguments:

    hKey - Input 32bit/64 bit Key name.
    lpSubKeyName - pointer to the subkey name.
    ParentName - Buffer caller supply to retrieve parent name.
    dwLen -Length of the buffer.
    pAccessMask -this poin to the current access mask.
                 On return this might return reasonable accessmask.
    Flag - 1 - means caller will perform a open call.
           2 - means caller will perform a Create call.


Return Value:

    TRUE if given access should be denied on the key.
    FALSE otherwise.

--*/
{
    
    BOOL bDenyAccess;

    bDenyAccess = IsAccessDeniedOnKey (ParentName, pAccessMask, bCreateCall);

    if (bDenyAccess) {
        //DbgPrint ("ADVAPI-Wow64:dening access to Registry Key: %S\n", ParentName);
        return TRUE;
    }

    return FALSE;
}

BOOL
IsExemptRedirectedKey (
    IN  PWCHAR SrcKey,
    OUT PWCHAR DestKey
    )
/*++

Routine Description:

    Check if the the source key point to the list of exempt key from redirection. 
    If so DestKey will have the right value.

Arguments:

    Name64Key - Input 32bit/64 bit Key name.
    Name32Key - Receiving Buffer that will hold the equivalent 32bit Key.

Return Value:

    TRUE if the Key is on the list of exempt key from redirection.
    FALSE otherwise.

--*/
{
    //
    // Make 64bit only path
    //
    PWCHAR NodeName32Bit;
    DWORD dwIndex =0;

    wcscpy (DestKey, SrcKey);
    if ( ( NodeName32Bit = wcsstrWow6432Node (DestKey)) != NULL) {  // nothing to remap patch is already there

            NodeName32Bit--;
            wcscpy (NodeName32Bit, NodeName32Bit+sizeof (NODE_NAME_32BIT)/sizeof (WCHAR));
        }
    
    for ( dwIndex = 0; ExemptRedirectedKey[dwIndex].KeyPath[0] != UNICODE_NULL; dwIndex++ ) 
        if (_wcsnicmp (DestKey, ExemptRedirectedKey[dwIndex].KeyPath, ExemptRedirectedKey[dwIndex].Len ) == 0)
            return TRUE;
        
    return FALSE;
}

BOOL
Map64bitTo32bitKeyName (
    IN  PWCHAR Name64Key,
    OUT PWCHAR Name32Key
    )
/*++

Routine Description:

    Return a key name valid in the 32-bit registry side. It's the caller responsibility
    to give enough space in the output buffer. Its internal routine and no boundary
    checking is done here.

Arguments:

    Name64Key - Input 32bit/64 bit Key name.
    Name32Key - Receiving Buffer that will hold the equivalent 32bit Key.

Return Value:

    TRUE if the remapping become successful.
    FALSE otherwise.

--*/
{

    //
    //  just add 32bit related patch from the name if anything like that exist.
    //  or fall under the ISN nodes.
    //



    PWCHAR NodeName32Bit;
    DWORD Count;

    try { 

        if (IsExemptRedirectedKey (Name64Key, Name32Key) )
            return TRUE;

        if ( ( NodeName32Bit = wcsstrWow6432Node (Name64Key)) != NULL) {  // nothing to remap patch is already there

            wcscpy (Name32Key, Name64Key);
            return TRUE;
        }

        if (!IsIsnNode ( Name64Key, &NodeName32Bit))  {

            wcscpy (Name32Key, Name64Key);
            return TRUE;
        }


        Count = (DWORD)(NodeName32Bit - Name64Key); // Displacement offset where the patch shoud go.

        //
        //  consider the case when 32bit apps need to create/open the real ISN node which doesn't exist
        //

        wcsncpy (Name32Key,Name64Key, Count);

        if   (Name32Key[Count-1] != L'\\') {
            Name32Key[Count] = L'\\';
            Count++;
        }

        wcscpy (Name32Key+Count, NODE_NAME_32BIT);


        if ( *NodeName32Bit != UNICODE_NULL ) {
            wcscat (Name32Key, L"\\");
            wcscat (Name32Key, NodeName32Bit);

        }

    } except( NULL, EXCEPTION_EXECUTE_HANDLER){

        return FALSE;
    }

    return TRUE; //any complete path can have only one instance of NODE_NAME_32BIT
}

NTSTATUS
OpenIsnNodeByObjectAttributes  (
    POBJECT_ATTRIBUTES ObjectAttributes,
    ACCESS_MASK DesiredAccess,
    PHANDLE phPatchedHandle
    )
/*++

Routine Description:
    If this Keyhandle is an open handle to an ISN node then this function
    return a handle to the node on the 32 bit tree. If not then we create the whole
    path and see if any ISN node is there. If so we Get the path on the 32bit tree and
    return Open that key.

    Scenario:
    1. Absolute path made from Directory root and relative path don't contain any ISN node.
       -Open that normally.
    2. Directory Handle point to the immediate parent of ISN node and the relative path is
       just an ISN node.
       -if 32 bit equivalent of ISN node exist open that and return that. If the 32 bit node
       doesn't exist create one and return that. [Problem open Directory Handle might not
       have  create access.
    3  Directory Handle point to an ISN node and relative path is just an immediate chield.
       - This can never happen. If we follow the algorithm, directory handly can't point on
       to an ISN node but on 32 bit equivalent node.
    4. Same as 2 but relative path might be grand child or far bellow.
       - If 32 bit equivalent node isn't there just create that and open the rest.

    How 32 bit Apps can open an ISN node:
    <TBD> the proposal is a s follows:
    1. Redirector will maintain a list of exempt handle that were created to access ISN node.
    2. Any open call relative to those handle will also be on the exemped list.
    3. NtClose thunk will remove


Arguments:

    KeyHandle - Handle to the node on the 64 bit tree.
    phPatchedHandle - receive the appropriate handle if this function succeed.


Return Value:

    NTSTATUS;

--*/
{
    UNICODE_STRING Parent;
    NTSTATUS st;
    OBJECT_ATTRIBUTES Obja;
    WCHAR PatchedIsnNode[WOW64_MAX_PATH+256];
    WCHAR AbsPath[WOW64_MAX_PATH+256];
    BOOL bPatched;

    DWORD ParentLen;

    //
    //  Make the complete path in a AbsPath
    //

    



    *phPatchedHandle=NULL; 

    st = ObjectAttributesToKeyName ( 
                                    ObjectAttributes, 
                                    AbsPath,
                                    sizeof (AbsPath) - 30,
                                    &bPatched, 
                                    &ParentLen );

    if (!NT_SUCCESS(st)) {
        LOGPRINT( (ERRORLOG, "Wow64:Couldn't retrieve ObjectName\n"));
        return st;
    }


    if (DesiredAccess & KEY_WOW64_64KEY) {

        if (!Map32bitTo64bitKeyName ( AbsPath, PatchedIsnNode ))
            return -1;  //severe problem shouldn't happen
    } else {

        PWCHAR p;

        if (!Map64bitTo32bitKeyName ( AbsPath, PatchedIsnNode ))
            return -1;  //severe problem shouldn't happen
    }


    DesiredAccess = DesiredAccess & (~KEY_WOW64_RES);

    //
    //  no change can be optimize by returning different value from Map64bitTo32bitKeyName
    //  Caller need to handle this
    //

    //
    // Check if access mask need to be filtered.
    //
    IsAccessDeniedOnKey (
            PatchedIsnNode,
            &DesiredAccess,
            FALSE
            );

    RtlInitUnicodeString (&Parent, PatchedIsnNode);
    InitializeObjectAttributes (&Obja, &Parent, ObjectAttributes->Attributes, NULL, ObjectAttributes->SecurityDescriptor ); //you have to use caller's context

    st = NtOpenKey (phPatchedHandle, DesiredAccess, &Obja);

#ifdef WOW64_LOG_REGISTRY
    if (!NT_SUCCESS (st))
        Wow64RegDbgPrint (( "RemapNtOpenKeyEx OUT: couldn't open %S\n", PatchedIsnNode));
#endif

    return st;
}

NTSTATUS
RemapNtCreateKey(
    OUT PHANDLE phPatchedHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes,
    IN ULONG TitleIndex,
    IN PUNICODE_STRING Class OPTIONAL,
    IN ULONG CreateOptions,
    OUT PULONG Disposition OPTIONAL
    )
/*++

Routine Description:

    An existing registry key may be opened, or a new one created,
    with NtCreateKey.

    If the specified key does not exist, an attempt is made to create it.
    For the create attempt to succeed, the new node must be a direct
    child of the node referred to by KeyHandle.  If the node exists,
    it is opened.  Its value is not affected in any way.

    Share access is computed from desired access.

    NOTE:

        If CreateOptions has REG_OPTION_BACKUP_RESTORE set, then
        DesiredAccess will be ignored.  If the caller has the
        privilege SeBackupPrivilege asserted, a handle with
        KEY_READ | ACCESS_SYSTEM_SECURITY will be returned.
        If SeRestorePrivilege, then same but KEY_WRITE rather
        than KEY_READ.  If both, then both access sets.  If neither
        privilege is asserted, then the call will fail.

Arguments:

    KeyHandle - Receives a Handle which is used to access the
        specified key in the Registration Database.

    DesiredAccess - Specifies the access rights desired.

    ObjectAttributes - Specifies the attributes of the key being opened.
        Note that a key name must be specified.  If a Root Directory is
        specified, the name is relative to the root.  The name of the
        object must be within the name space allocated to the Registry,
        that is, all names beginning "\Registry".  RootHandle, if
        present, must be a handle to "\", or "\Registry", or a key
        under "\Registry".

        RootHandle must have been opened for KEY_CREATE_SUB_KEY access
        if a new node is to be created.

        NOTE:   Object manager will capture and probe this argument.

    TitleIndex - Specifies the index of the localized alias for
        the name of the key.  The title index specifies the index of
        the localized alias for the name.  Ignored if the key
        already exists.

    Class - Specifies the object class of the key.  (To the registry
        this is just a string.)  Ignored if NULL.

    CreateOptions - Optional control values:

        REG_OPTION_VOLATILE - Object is not to be stored across boots.

    Disposition - This optional parameter is a pointer to a variable
        that will receive a value indicating whether a new Registry
        key was created or an existing one opened:

        REG_CREATED_NEW_KEY - A new Registry Key was created
        REG_OPENED_EXISTING_KEY - An existing Registry Key was opened

Return Value:

    NTSTATUS - Result code from call, among the following:

        <TBS>

--*/
{

    UNICODE_STRING Parent;
    NTSTATUS st;
    OBJECT_ATTRIBUTES Obja;
    WCHAR PatchedIsnNode[WOW64_MAX_PATH];
    WCHAR AbsPath[WOW64_MAX_PATH];

    BOOL bPatched=FALSE;
    DWORD ParentLen;


    //
    //  Make the complete path in a AbsPath
    //

 
    if (ARGUMENT_PRESENT(phPatchedHandle)){
        *phPatchedHandle=NULL;
    }

    st = ObjectAttributesToKeyName (
                                    ObjectAttributes,
                                    AbsPath,
                                    sizeof (AbsPath)-30,   //Keep 15 char space
                                    &bPatched,
                                    &ParentLen);
    if (!NT_SUCCESS(st)) {
        WOWASSERT(FALSE );
        return st; 
    }

    if ( IsAccessDeniedOnKey (
                        AbsPath,
                        &DesiredAccess,
                        TRUE
                        ))
                        return STATUS_ACCESS_DENIED;


    if (DesiredAccess & KEY_WOW64_64KEY) {

        if (!Map32bitTo64bitKeyName ( AbsPath, PatchedIsnNode )) {
            WOWASSERT(FALSE );
            return STATUS_SUCCESS;  //severe problem shouldn't happen
        }
    } else {

        PWCHAR p;

        if (!Map64bitTo32bitKeyName ( AbsPath, PatchedIsnNode )){
            WOWASSERT(FALSE );
            return STATUS_SUCCESS;  //severe problem shouldn't happen
        }
    }

    DesiredAccess = DesiredAccess & (~KEY_WOW64_RES);

    if (!bPatched)   // the abspath hasn't been patched
    if ( !wcscmp (AbsPath, PatchedIsnNode ))
        return STATUS_SUCCESS; // no change can be optimize by returning different value from Map64bitTo32bitKeyName


    RtlInitUnicodeString (&Parent, PatchedIsnNode);
    InitializeObjectAttributes (&Obja,
                                &Parent,
                                ObjectAttributes->Attributes,
                                NULL,
                                ObjectAttributes->SecurityDescriptor
                                ); //you have to use caller's context

    st = NtCreateKey(
                    phPatchedHandle,
                    DesiredAccess,
                    &Obja,
                    TitleIndex,
                    Class ,
                    CreateOptions,
                    Disposition
                    );
    return st;

}

NTSTATUS
Wow64NtPreUnloadKeyNotify(
    IN POBJECT_ATTRIBUTES TargetKey
    )
/*++

Routine Description:

    This call will notify Wow64 service that wow64 need to release any open handle
    to the hive that is going to be unloaded.

    Drop a subtree (hive) out of the registry.

    Will fail if applied to anything other than the root of a hive.

    Cannot be applied to core system hives (HARDWARE, SYSTEM, etc.)

    Can be applied to user hives loaded via NtRestoreKey or NtLoadKey.

    If there are handles open to the hive being dropped, this call
    will fail.  Terminate relevent processes so that handles are
    closed.

    This call will flush the hive being dropped.

    Caller must have SeRestorePrivilege privilege.

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"

Return Value:

    NTSTATUS - values TBS.

--*/

{
    //todo
    return 0;
}
  

NTSTATUS
Wow64NtPostLoadKeyNotify(
    IN POBJECT_ATTRIBUTES TargetKey
    )

/*++

Routine Description:

    If  Load operation succeed, it will notify wow64 service that it
    can listen to the registry operation on the given hive.

    This function can be invoked from NtLoadKey and NtLoadKey2 APIs.

    A hive (file in the format created by NtSaveKey) may be linked
    into the active registry with this call.  UNLIKE NtRestoreKey,
    the file specified to NtLoadKey will become the actual backing
    store of part of the registry (that is, it will NOT be copied.)

    The file may have an associated .log file.

    If the hive file is marked as needing a .log file, and one is
    not present, the call will fail.

    Caller must have SeRestorePrivilege privilege.

    This call is used by logon to make the user's profile available
    in the registry.  It is not intended for use doing backup,
    restore, etc.  Use NtRestoreKey for that.

Arguments:

    TargetKey - specifies the path to a key to link the hive to.
                path must be of the form "\registry\user\<username>"


Return Value:

    NTSTATUS - values TBS.

--*/
{
    //todo
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\regremap\wowhndl.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    regmisc.c 

Abstract:

    This module implement Handle redirection for registry redirection.

Author:

    ATM Shafiqul Khalid (askhalid) 16-June-2000

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <ntregapi.h>

#define _WOW64REFLECTOR_

#include "regremap.h"
#include "wow64reg.h"
#include "wow64reg\reflectr.h"


#ifdef _WOW64DLLAPI_
#include "wow64.h"
#else
#define ERRORLOG 1  //this one is completely dummy
#define LOGPRINT(x)
#define WOWASSERT(p)
#endif //_WOW64DLLAPI_


#define REFLECTOR_ENABLE_KEY L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\WOW64\\Reflector Setup"
#define REFLECTOR_DISABLE_KEY L"\\Registry\\Machine\\System\\Setup"
#define WOW64_REDIRECTOR_CONFIG_KEY L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\WOW64"

#ifdef DBG
VOID
DebugRegistryRedirectionOnClose (
    HANDLE KeyHandle,
    PWCHAR Message
    );
DWORD LogID = 0;
#endif

BOOL
HandleRunOnce (
    WCHAR *SrcNode
    );

BOOL 
ReflectClassGuid (
    PWCHAR SrcName,
    DWORD dwDirection
    );

VOID
InitRegistry ();

BOOL 
SyncGuidKey (
    HANDLE hSrc, 
    HANDLE hDest,
    DWORD dwDirection,
    DWORD __bNewlyCreated
    );

BOOL
Wow64ReflectSecurity (
    HKEY SrcKey,
    HKEY DestKey
    );

//
//IsOnReflectionList: has hardcoded  \\registry\\user\\<sid>_Classes.
//
DWORD  ReflectListLen[18] ={0};
WCHAR  ReflectList[18][128]={
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes"},    // alias to the classes root on the user hives
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Classes"},    // alias to the classes root on the user hives
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Wow6432Node"},    // alias to the classes root on the user hives
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run"},    // Runonce Key
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\RunOnce"},    // Runonce Key
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx"},    // Runonce Key
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\COM3"},    // COM+ Key
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\COM3"},    // COM+ Key
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Ole"},    // OLE Key
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Ole"},    // OLE Key
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\EventSystem"},    // EventSystem
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\EventSystem"},    // EventSystem
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\RPC"},    // RPC
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\RPC"},    // RPC
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\TEST"},    // Test Node
    { L"\\REGISTRY\\MACHINE\\SOFTWARE\\TEST"},    // Test Node
    { L""}
    };


typedef struct {

    HANDLE hBase;   // handle to the original object
    HANDLE hRemap;  // handle to the remapped object
    DWORD  Status;  // will have different attribute set.
    DWORD  dwCount; // Handle count- according to dragos, we can ignore because multiple open get different handle.
    DWORD  Attribute; //attribute to hold Key attribute
} WOW64_HANDLE;

#define TABLE_SEGMENT_MAX 500
#define SEGMENT_SIZE      256
#define DIRECTION_32_TO_64 10
#define DIRECTION_64_TO_32 11

//
// Flag while copying value Key.
//
#define DEFAULT_FLAG                    0x00000000
#define DELETE_SRC_VALUEKEY             0x00000010
#define DONT_DELETE_DEST_VALUEKEY       0x00000020
#define PATCH_VALUE_KEY_NAME            0x00000040
#define SYNC_VALUE_IF_REFLECTED_KEYS    0x00000080
#define DONT_SYNC_IF_DLL_SURROGATE      0x00000100

#define WOW64_HANDLE_DIRTY   0x00000001  // some update operation was done using this handle
#define WOW64_HANDLE_INUSE   0x00000002  // Tag this handle block not free
#define WOW64_HANDLE_POSSIBLE_SHIM 0x00000004  // this key is possible hit for shimming

#define HashValue (x) ((((x)>>24) + ((x)>>16) + (x)>>8 + (x)) % SEGMENT_SIZE )

#define MyNtClose(hRemap) if (hRemap != NULL) { NtClose (hRemap); hRemap = NULL;}

BOOL bEnableCurrentControlSetProtection = FALSE;

RTL_CRITICAL_SECTION HandleTable;
BOOL bHandleTableInit=FALSE;

//
// BUGBUG: This module implement simplifiled version of handle redirection using linear list. 
//   This must have to be implemented by a hash table if possible.
//


PVOID List[TABLE_SEGMENT_MAX];
WOW64_HANDLE HandleList[SEGMENT_SIZE];  //hopefully this will be good enough for open key handle. It can always allocate dynamically.


BOOL bReflectorStatusOn = FALSE;

LogMsg (
    HANDLE hKey,
    PWCHAR Msg
    )
{
    WCHAR Name[WOW64_MAX_PATH];
    DWORD Len = WOW64_MAX_PATH;

    HandleToKeyName (hKey, Name, &Len);
    DbgPrint ("\nMsg:%S Key:%S",Msg, Name );
}

PVOID
RegRemapAlloc (
    DWORD dwSize
    )
/*++

Routine Description:

    Allocate memory.

Arguments:

    dwSize - size of memory to allocate.

Return Value:

    return appropriate buffer.

--*/
{
    PVOID pBuffer;

    //
    //  For performance reason you might allocate big chunk and then reuse.
    //

    pBuffer = RtlAllocateHeap (
                RtlProcessHeap(),
                0,
                dwSize);

    return pBuffer;
}

VOID
RegRemapFree (
    PVOID pBuffer
    )
/*++

Routine Description:

    Free allocated mery.

Arguments:

    dwSize - size of memory to allocate.

Return Value:

    None.

--*/
{

    //
    //  For performance reason you might allocate big chunk and then reuse.
    //

    if ( pBuffer == NULL)
        return;

    RtlFreeHeap (
                RtlProcessHeap(),
                0,
                pBuffer
                );

    return;
}

BOOL
InitHandleTable ( )
/*++

Routine Description:

    Initialize the table with appropriate allocation and value if its not initialized yet.

Arguments:

    None.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

    <TBD> this might allocate more memory and free up later.
--*/
{
    HKEY hWowSetupKey;
    
    HKEY  hKey;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING KeyName;
    UNICODE_STRING ValueName;
    NTSTATUS Status;

    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation = NULL;
    BYTE Buff[sizeof (KEY_VALUE_PARTIAL_INFORMATION)+10];

    
    memset (List, 0, sizeof (List));
    memset (HandleList, 0, sizeof (HandleList));

    List [0]= HandleList;



    RtlInitUnicodeString (&KeyName, REFLECTOR_DISABLE_KEY);
    InitializeObjectAttributes (&Obja, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );

    Status = NtOpenKey (&hKey, KEY_READ, &Obja);

    if (NT_SUCCESS(Status)) {
        
        DWORD Res;
        DWORD Len = sizeof (Buff);  

        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)Buff;
        RtlInitUnicodeString (&ValueName, L"SystemSetupInProgress");
        Status = NtQueryValueKey(
                                hKey,
                                &ValueName,
                                KeyValuePartialInformation,
                                KeyValueInformation,
                                Len,
                                &Len
                                );
        NtClose (hKey);  // reflection should be disable because setup is on its way.

        if (NT_SUCCESS(Status)) {
            if ( *(LONG *)KeyValueInformation->Data != 0) 
                return TRUE;  //system setup is in progress no reflection

        } else  return TRUE;
    } else return TRUE;


    //
    // Initialize Internal ISN node table to remap keys.
    //

    Status = RtlInitializeCriticalSection( &HandleTable );
    if (!NT_SUCCESS (Status))
        return FALSE;
    bHandleTableInit=TRUE;

    bReflectorStatusOn = TRUE;  //Now reflector is on.

#ifdef  DBG
    //
    // Check if the systemwide flag is turned off.
    //

    RtlInitUnicodeString (&KeyName, WOW64_REDIRECTOR_CONFIG_KEY);
    InitializeObjectAttributes (&Obja, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );

    Status = NtOpenKey (&hKey, KEY_READ, &Obja);

    if (NT_SUCCESS(Status)) {

        DWORD Res;
        DWORD Len = sizeof (Buff);  

        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)Buff;
        RtlInitUnicodeString (&ValueName, L"DisableReflector");
        Status = NtQueryValueKey(
                                hKey,
                                &ValueName,
                                KeyValuePartialInformation,
                                KeyValueInformation,
                                Len,
                                &Len
                                );
        NtClose (hKey);  // reflection should be disable because setup is on its way.

        if (NT_SUCCESS(Status)) {
            if ( *(LONG *)KeyValueInformation->Data != 0) 
                bReflectorStatusOn = FALSE;  //Now reflector is off if user set the flag for debug purpose.

        } 
    } 

#endif //DBG

    //
    // Check if CurrentControlSet hive need to be procted
    //
    
    RtlInitUnicodeString (&KeyName, WOW64_REDIRECTOR_CONFIG_KEY);
    InitializeObjectAttributes (&Obja, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );

    Status = NtOpenKey (&hKey, KEY_READ, &Obja);

    if (NT_SUCCESS(Status)) {

        DWORD Res;
        DWORD Len = sizeof (Buff);  

        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)Buff;
        RtlInitUnicodeString (&ValueName, L"EnableCurrentControlSetProtection");
        Status = NtQueryValueKey(
                                hKey,
                                &ValueName,
                                KeyValuePartialInformation,
                                KeyValueInformation,
                                Len,
                                &Len
                                );
        NtClose (hKey);  // reflection should be disable because setup is on its way.

        if (NT_SUCCESS(Status)) {
            if ( *(LONG *)KeyValueInformation->Data != 0) 
                bEnableCurrentControlSetProtection = TRUE;  //Now reflector is off if user set the flag for debug purpose.

        } 
    }


#ifdef _WOW64DLLAPI_ //only linked with wow64 not with advapi32
    

    try {
        InitWow64Shim ();
        } except( NULL, EXCEPTION_EXECUTE_HANDLER){
    }
#endif 

    return TRUE;
}

WOW64_HANDLE *
GetFreeHandleBlock (
    HANDLE hKey
    )
/*++

Routine Description:

    Return a free block from the handle table.

Arguments:

    hKey - Handle to the key that will be inserted into the table.

Return Value:

    Return a free block on the table.

    
--*/
{
    WOW64_HANDLE *pList;

    DWORD i,k;

    RtlEnterCriticalSection(&HandleTable);

    for (i=0;i<TABLE_SEGMENT_MAX && List[i] != NULL;i++) {

        pList = (WOW64_HANDLE *)List[i];
        for (k=0;k<SEGMENT_SIZE;k++)

            if (pList[k].hBase == NULL && (!(WOW64_HANDLE_INUSE & pList[k].Status )) ) {

                //
                // Mark the entry in use
                //
                pList[k].Status = WOW64_HANDLE_INUSE;
                RtlLeaveCriticalSection(&HandleTable);
                return &pList[k];
            }
    }

    RtlLeaveCriticalSection(&HandleTable);
    return NULL;
}

WOW64_HANDLE *
GetHandleBlock (
    HANDLE hKey
    )
/*++

Routine Description:

    Return a the block having information associated with the given handle.

Arguments:

    hKey - Handle to the key that need to be investigated.

Return Value:

    Return a the block that has the handle.

    
--*/
{
    WOW64_HANDLE *pList;
    DWORD i,k;

    for (i=0;i<TABLE_SEGMENT_MAX, List[i] != NULL;i++) {

        pList = (WOW64_HANDLE *)List[i];
        for (k=0;k<SEGMENT_SIZE;k++)

            if (pList[k].hBase == hKey)
                return &pList[k];
    }

    return NULL;
}

HANDLE
GetWow64Handle (
    HANDLE hKey
    )
/*++

Routine Description:

    Return a handle to the remapped key if any.

Arguments:

    hKey - Handle to the key that need ramapped information.

Return Value:

    Handle to the remapped key.
    NULL if no remapped key is there.

    
--*/
{
    WOW64_HANDLE *pHandleBlock = GetHandleBlock (hKey);

    if (  pHandleBlock == NULL )
        return NULL;
    
    return pHandleBlock->hRemap;
}

BOOL
IsWow64Handle (
    HANDLE hKey
    )
/*++

Routine Description:

    Check if the handle has been tagged to watch while closing.

Arguments:

    hKey - Handle to the key that need to be checked.

Return Value:

    TRUE if the handle is on the TABLE.
    FALSE otherwise.
    
--*/
{
    return GetHandleBlock (hKey) != NULL;
}

WOW64_HANDLE * 
InsertWow64Handle (
    HANDLE  hKeyBase,
    HANDLE  hKeyRemap
    )
/*++

Routine Description:

    Allocate some resources so that some manipulation can be done in case of 
    Key changes.

Arguments:

    hKey - Handle to the base key that need to be marked.

Return Value:

    Valid block that refer to the handle.
--*/

{
    
    WCHAR SrcNode[WOW64_MAX_PATH];
    DWORD dwLen = WOW64_MAX_PATH;


    WOW64_HANDLE *pHandleBlock = NULL;

    pHandleBlock = GetHandleBlock (hKeyBase);

    if (hKeyBase == NULL || hKeyRemap == NULL)
        return NULL;

    if (  pHandleBlock == NULL ) { // new handle
        //
        // Get the path name and if the key is on the reflection list add it.
        //
        if (!HandleToKeyName ( hKeyBase, SrcNode, &dwLen ))
            return NULL;

        //
        // Make sure The name is on the List otherwise forget.
        //
        if ( !IsOnReflectionList (SrcNode))
            return NULL;

        pHandleBlock = GetFreeHandleBlock (hKeyBase);
    }
    

    if ( pHandleBlock == NULL)
        return NULL;

    pHandleBlock->hRemap = hKeyRemap;
    pHandleBlock->hBase = hKeyBase;

    return pHandleBlock;
}

BOOL
Wow64RegSetKeyPossibleShim (
    HANDLE hKey
    )
/*++

Routine Description:

    Tag the handle for future operation. Not same as dirty

Arguments:

    hKey - Handle to the base key that need to be marked.

Return Value:

    TRUE if the key is on the list of reflection.
    FALSE otherwise.
--*/

{

    
    WOW64_HANDLE *pHandleBlock;
    
    hKey = (HANDLE)((SIZE_T)hKey & ~3);  //ignore the last 2 bits


    if (!bReflectorStatusOn)
        return TRUE;  //reflector isn't enable yet.

    if (( pHandleBlock = InsertWow64Handle (hKey, hKey)) == NULL)  // bugbug: not regular insert
        return FALSE;
    
    pHandleBlock->Status |= WOW64_HANDLE_POSSIBLE_SHIM;
    return TRUE;
}

BOOL
Wow64RegIsPossibleShimFromTable (
    HANDLE hKey
    )
/*++

Routine Description:

    Tag the handle for future operation. Not same as dirty

Arguments:

    hKey - Handle to the base key that need to be marked.

Return Value:

    TRUE if the key is on the list of reflection.
    FALSE otherwise.
--*/

{

    
    WOW64_HANDLE *pHandleBlock;
    
    hKey = (HANDLE)((SIZE_T)hKey & ~3);  //ignore the last 2 bits


    if (!bReflectorStatusOn)
        return FALSE;  //reflector isn't enable yet.

    if ((pHandleBlock = GetHandleBlock (hKey)) == NULL )
        return FALSE;
    
    if ( pHandleBlock->Status & WOW64_HANDLE_POSSIBLE_SHIM )
        return TRUE;

    return FALSE;

    
}

BOOL
Wow64RegSetKeyDirty (
    HANDLE hKey
    )
/*++

Routine Description:

    Mark the handle dirty, i.e., some value has been changed associated to this Key.

Arguments:

    hKey - Handle to the base key that need to be marked.

Return Value:

    TRUE if the key is on the list of reflection.
    FALSE otherwise.
--*/

{

    
    WOW64_HANDLE *pHandleBlock;
    
    hKey = (HANDLE)((SIZE_T)hKey & ~3);  //ignore the last 2 bits


    if (!bReflectorStatusOn)
        return TRUE;  //reflector isn't enable yet.

    if (( pHandleBlock = InsertWow64Handle (hKey, hKey)) == NULL)
        return FALSE;
    
    pHandleBlock->Status |= WOW64_HANDLE_DIRTY;
    return TRUE;
}

VOID
CloseWow64Handle (
    WOW64_HANDLE *pHandleBlock
    )
{
    RtlEnterCriticalSection(&HandleTable);
    pHandleBlock->hBase = NULL;
    pHandleBlock->hRemap = NULL;
    pHandleBlock->Status = 0;
    pHandleBlock->Attribute = 0;
    RtlLeaveCriticalSection(&HandleTable);
}

BOOL
Wow64RegCloseKey (
    HANDLE hKey
    )
/*++

Routine Description:

    Remove entry associated with the handle.

Arguments:

    hKey - Handle to the key that is being closed.

Return Value:

    TRUE if function succeed.
    FALSE otherwise.
--*/
{

    WOW64_HANDLE *pHandleBlock;
    hKey = (HANDLE)((SIZE_T)hKey & ~3);  //ignore the last 2 bits

    if (!bReflectorStatusOn)
        return TRUE;  //reflector isn't enable yet.

    if ((pHandleBlock = GetHandleBlock (hKey)) == NULL )
        return FALSE;
    
    

    if (pHandleBlock->Status & WOW64_HANDLE_DIRTY)  // if the handle is dirty sync the node
        NtSyncNode ( hKey, NULL, FALSE ); //BUGBUG

    if ( pHandleBlock->hRemap!= hKey )
        MyNtClose ( pHandleBlock->hRemap ); // if Same then just allocating block

    CloseWow64Handle ( pHandleBlock );


    //
    // Call sync APi. to synchronize the registry reflection
    //


    return TRUE;

}

void
CleanupReflector (
    DWORD dwFlag
    )
/*++

Routine Description:

  This routine is called while apps is shutting down. This will give reflector a chance to
  reflect any leftover handle than need reflection.

  This can be called from multiple places, like NtTerminateProcess, Advapi32 dll 
  detach or shutdown routine.

  

Arguments:

  dwFlag - for future use to track from where this call came from.

Return Value:

  None.
--*/
{
        WOW64_HANDLE *pList;
    DWORD i,k;

    for (i=0;i<TABLE_SEGMENT_MAX, List[i] != NULL;i++) {

        pList = (WOW64_HANDLE *)List[i];
        for (k=0;k<SEGMENT_SIZE;k++)

            if ((pList[k].hBase != NULL) && (pList[k].Status & WOW64_HANDLE_DIRTY) )
                Wow64RegCloseKey(pList[k].hBase);
    }
}


NTSTATUS 
Wow64NtClose(
    IN HANDLE Handle
    )
/*++

Routine Description:

    Intercept NtClose Call.

Arguments:

    Handle - Handle to the object that is being closed.

Return Value:

    return valid NTSTATUS
--*/
{
    if ( (Handle) && (Handle != INVALID_HANDLE_VALUE )   ) //filter invalid handle.
        Wow64RegCloseKey ( Handle );
    return NtClose ( Handle ); //let process continue as it was on nx86
}

BOOL
IsOnReflectionList (
    PWCHAR Path
    )
/*++

Routine Description:

    Check if the given path is on the list of reflection.

Arguments:

    Path - Path to the key that need to be chacked for reflection.

Return Value:

    TRUE if the key is on the list of reflection.
    FALSE otherwise.
--*/
{
    DWORD i =0;

    //
    // Check exception to the list, non reflectable like uninstaller/TypeLib etc
    //

    //
    // _Classes \Registry\user\sid_Classes is reflected by default.
    //

    
    //if ( wcslen (Path) >= 69) //sizeof \Registry\user\sid_Classes
    //if ( wcsncmp (Path+61, L"_Classes", 8) == 0 ) //69 is the size of user classes sid and 61 is for sanity check
    if ( wcsistr (Path, L"_Classes"))
        return TRUE;

    if (ReflectListLen[0]==0) {
        i=0;
        while (ReflectList[i][0] != UNICODE_NULL ) {
            ReflectListLen[i] = wcslen (ReflectList[i]);
            i++;
        }

    }

    i=0;
    while (ReflectList[i][0] != UNICODE_NULL ) {
        if ( _wcsnicmp (ReflectList[i], Path, ReflectListLen[i]) == 0)
            return TRUE;
        i++;
    }

    return FALSE;
}

BOOL
UpdateKeyTag (
    HKEY hBase,
    DWORD dwAttribute
    )
/*++

Routine Description:

    Update a particular Key tag, like written by 32bit apps or its a copy by reflector.

Arguments:

    hBase - handle to a key to operate.
    dwAttribute - tag value its can be
                   0x01 written by 32bit apps.
                   0x02 created by reflector.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.
--*/
{

    //
    // the flag can't be >0x0f i.e., last 4 bits
    //

    
    KEY_USER_FLAGS_INFORMATION sFlag;
    NTSTATUS st;

    sFlag.UserFlags = dwAttribute;
    


    st = NtSetInformationKey(
        hBase,
        KeyUserFlagsInformation,
        &sFlag,
        sizeof( KEY_USER_FLAGS_INFORMATION)
        );

    if (!NT_SUCCESS (st))
        return FALSE;
    return TRUE;

}

BOOL
QueryKeyTag (
    HKEY hBase,
    DWORD *dwAttribute
    )
/*++

Routine Description:

    Read Key tag, like written by 32bit apps or its a copy by reflector.

Arguments:

    hBase - handle to a key to operate.
    dwAttribute - receive the TAG
                   0x01 written by 32bit apps.
                   0x02 created by reflector.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.
--*/
{
    DWORD ResLen;
    KEY_USER_FLAGS_INFORMATION sFlag;
    NTSTATUS st;

    if ( dwAttribute == NULL )
        return FALSE;

    if ( hBase == NULL ) 
        return FALSE;

    *dwAttribute  =0;

    st = NtQueryKey(
        hBase,
        KeyFlagsInformation,
        (PVOID)&sFlag,
        sizeof(KEY_FLAGS_INFORMATION),
        &ResLen);

    if (!NT_SUCCESS (st))
        return FALSE;

    *dwAttribute = sFlag.UserFlags;
    return TRUE;

}

BOOL
SyncValue (
    HANDLE hBase, 
    HANDLE hRemap,
    DWORD  dwDirection,
    DWORD  dwFlag
    )
/*++

Routine Description:

    Synchronize a two node with value Key. Delete from the RemapKey, and copy from Base

Arguments:

    hBase - Handle to the src key.
    hRemap - Handle to the remap key.
    dwDirection - SyncDitection
            DIRECTION_32_TO_64 - 32bit is the source of information
            DIRECTION_64_TO_32 - 32bit is the source of information

    dwFlag - determine the behavior of the operation.
            DELETE_SRC_VALUEKEY delete source value key after coping on the dest.
            DONT_DELETE_DEST_VALUEKEY don't delete dest before copying from src.
            DEFAULT_FLAG - this means the default operation.
            SYNC_VALUE_IF_REFLECTED_KEYS - if either one is reflected key then sync.


Return Value:

    TRUE if the function succeed.
    FALSE otherwise.
--*/
{
    HANDLE hTimeStampKey;
    NTSTATUS st= STATUS_SUCCESS;
    DWORD Index=0;

    DWORD ResultLength;
    DWORD LastKnownSize = 0;
    UNICODE_STRING      UnicodeValueName;

    PKEY_VALUE_FULL_INFORMATION KeyValueInformation = NULL;
    BYTE Buff [sizeof(KEY_VALUE_FULL_INFORMATION) + 2048];
    WCHAR TmpChar;
    ULONG Length = sizeof(KEY_VALUE_FULL_INFORMATION) + 2048; 

    KeyValueInformation = (PKEY_VALUE_FULL_INFORMATION)Buff;
    

    if ( SYNC_VALUE_IF_REFLECTED_KEYS & dwFlag) {

        DWORD Attrib1 =0;
        DWORD Attrib2 =0;

        QueryKeyTag (hBase, &Attrib1);
        QueryKeyTag (hRemap, &Attrib2);

        //
        // if atleast one is a reflected Key then sync value
        //
        if (!( (Attrib1 & TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE) ||
            (Attrib2 & TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE) ) )   // reflector touched this Key
        return TRUE;
    }

    for (Index=0;;Index++) {

        st = NtEnumerateValueKey(
                                 hRemap,
                                 Index,
                                 KeyValueFullInformation,
                                 KeyValueInformation,
                                 Length,
                                 &ResultLength
                                 );

        if (!NT_SUCCESS(st))
            break;

        KeyValueInformation->Name[KeyValueInformation->NameLength/2] = UNICODE_NULL;
        RtlInitUnicodeString( &UnicodeValueName, KeyValueInformation->Name );

        if ( !(DONT_DELETE_DEST_VALUEKEY & dwFlag))
        if ( NtDeleteValueKey(
                        hRemap,
                        &UnicodeValueName
                        ) == STATUS_SUCCESS ) Index--;
    }

    //
    // Copy all key from the Base. For each copy patch value if applicable
    //

    for (Index=0, st= STATUS_SUCCESS;;Index++) {

        st = NtEnumerateValueKey(
                                 hBase,
                                 Index,
                                 KeyValueFullInformation,
                                 KeyValueInformation,
                                 Length,
                                 &ResultLength
                                 );

        if (st == STATUS_BUFFER_OVERFLOW ) {
            //Allocate more Buffer BUGBUG name shouldn't that big
            DbgPrint ("\nWow64: Will ignore any Key value larger than 2048 byte");
        }

        if (!NT_SUCCESS (st))
            break;

        TmpChar = KeyValueInformation->Name[KeyValueInformation->NameLength/2];
        KeyValueInformation->Name[KeyValueInformation->NameLength/2] = UNICODE_NULL;
        RtlInitUnicodeString( &UnicodeValueName, KeyValueInformation->Name );

        
        //
        // Check if you need to filter the Value DllSurrogate is such one.
        //
        if (dwFlag & DONT_SYNC_IF_DLL_SURROGATE) {
            if (_wcsnicmp (KeyValueInformation->Name, L"DllSurrogate",12 )==0 && KeyValueInformation->DataLength <=2) // size of UNICODE_NULL
            continue;
        }

        if ( (DELETE_SRC_VALUEKEY & dwFlag))  //delete from source in case of runonce
            if ( NtDeleteValueKey(
                    hBase,
                    &UnicodeValueName
                    ) == STATUS_SUCCESS ) Index--;

        if ( (PATCH_VALUE_KEY_NAME & dwFlag) && (DIRECTION_32_TO_64 == dwDirection)) {
            wcscat (KeyValueInformation->Name, L"_x86");
            RtlInitUnicodeString( &UnicodeValueName, KeyValueInformation->Name );
            
        }

        KeyValueInformation->Name[KeyValueInformation->NameLength/2] = TmpChar;

        NtSetValueKey(
                    hRemap,
                    &UnicodeValueName,
                    KeyValueInformation->TitleIndex,
                    KeyValueInformation->Type,
                    (PBYTE)(KeyValueInformation)+KeyValueInformation->DataOffset,
                    KeyValueInformation->DataLength
                    );

        

    }
   
    //
    // Now reflect the security attribute
    //
    Wow64ReflectSecurity (hBase, hRemap );
 
    return TRUE;
}

BOOL 
ReflectDllSurrogateKey (
    PWCHAR SrcNode
    )

    /*++

Routine Description:

    Determine if the DllSurrogateKey under AppID shoule be reflected.
    //By default this should always be reflected. Except when the key is empty.

Arguments:

    SrcNode - Name of the node to be synced.

Return Value:

    TRUE if the key Should be reflected.
    FALSE otherwise.
--*/
{

        

        
        BYTE KeyBuffer[512];
        DWORD KeyBufferSize = sizeof (KeyBuffer);
        DWORD ResultLength;
        UNICODE_STRING ValueName;
        NTSTATUS Status;
        PWCHAR pStr;
        HKEY hKey;

        PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation = NULL;
        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyBuffer;
        RtlInitUnicodeString (&ValueName, L"");
    
        //
        // Apply special rule of empty AppID key for dll surrogate.
        //
     
        if ( ( pStr = wcsistr (SrcNode, L"\\DllSurrogate") ) == NULL) 
            return TRUE;

        if ( *(pStr+13) != UNICODE_NULL) {
            return TRUE;
        }
        //
        // Consider only value in that key
        //

        

        //
        // if value key isn't empty reflect, i.e., return FALSE.
        //


        hKey = OpenNode (SrcNode);
        *(LONG *)KeyValueInformation->Data = 0;

        Status = NtQueryValueKey(
                        hKey,
                        &ValueName,
                        KeyValuePartialInformation,
                        KeyValueInformation,
                        KeyBufferSize,
                        &ResultLength);
        if (NULL != hKey)    
            NtClose (hKey);  // reflection should be disable because setup is on its way.

        if ( *(LONG *)KeyValueInformation->Data == 0)
            return FALSE;

        return TRUE;

}

BOOL 
ReflectInprocHandler32KeyByHandle (
    HKEY hKey
    )

    /*++

Routine Description:

    Determine if the ReflectInprocHandler32Key under CLSID shoule be reflected.
    //By default this should always be reflected. Except when the key is empty.

Arguments:

    SrcNode - Name of the node to be synced.

Return Value:

    TRUE if the key Should be reflected.
    FALSE otherwise.
--*/
{

        

        
        BYTE KeyBuffer[512];
        DWORD KeyBufferSize = sizeof (KeyBuffer);
        DWORD ResultLength;
        UNICODE_STRING ValueName;
        NTSTATUS Status;
        PWCHAR pStr;
        

        PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation = NULL;
        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyBuffer;
        RtlInitUnicodeString (&ValueName, L""); //default value Key
    
        
        //
        // if value key isn't empty reflect, i.e., return FALSE.
        //
        //return FALSE; //never reflect


        *(LONG *)KeyValueInformation->Data = 0;

        Status = NtQueryValueKey(
                        hKey,
                        &ValueName,
                        KeyValuePartialInformation,
                        KeyValueInformation,
                        KeyBufferSize,
                        &ResultLength
                        );
        

        pStr = (PWCHAR)KeyValueInformation->Data;

        if ( NT_SUCCESS(Status) && pStr != NULL) { //Need to check type

            if ( 0 == _wcsnicmp (pStr, L"ole32.dll", 9))
                return TRUE;

            if ( 0 == _wcsnicmp (pStr, L"oleaut32.dll", 12))
                return TRUE;
        }

        return FALSE;
}

BOOL 
ReflectInprocHandler32KeyByName (
    PWCHAR SrcNode
    )

    /*++

Routine Description:

    Determine if the ReflectInprocHandler32Key under CLSID shoule be reflected.
    //By default this should always be reflected. Except when the key is empty.

Arguments:

    SrcNode - Name of the node to be synced.

Return Value:

    TRUE if the key Should be reflected.
    FALSE otherwise.
--*/
{


        HKEY hKey;
        BOOL bRet = FALSE;

        hKey = OpenNode (SrcNode);

        if ( NULL != hKey ) {
            bRet = ReflectInprocHandler32KeyByHandle (hKey);
            NtClose (hKey);
        }

        return bRet;
}

BOOL
TaggedKeyForDelete (
    PWCHAR SrcNode
    )
/*++

Routine Description:

    Check if the Tagged deletion and noclobber rule should be applicable on this key.

Arguments:

    SrcNode - Name of the node to be checked.

Return Value:

    TRUE if the rule is applicable.
    FALSE otherwise.
--*/ 
{
        if ( wcsistr (SrcNode, L"Classes\\CLSID\\{") != NULL ) 
            return TRUE;

        if ( wcsistr (SrcNode, L"Classes\\Wow6432Node\\CLSID\\{") != NULL ) 
            return TRUE;

        if ( ( wcsistr (SrcNode, L"Classes\\AppID\\{") != NULL ) ||
            ( wcsistr (SrcNode, L"Classes\\Wow6432Node\\AppID\\{") != NULL ) ) 
            return TRUE;

    return FALSE;
}

BOOL
IsExemptReflection ( 
    PWCHAR SrcNode
    )
/*++

Routine Description:

    Check if the is is on the exempt list from reflection.

Arguments:

    SrcNode - Name of the node to be synced that need to be  checked.

Return Value:

    TRUE if the key is on the exempt list.
    FALSE otherwise.
--*/ 
{
    //
    // Use a static list. 
    //

        
        if ( wcsistr (SrcNode, L"Classes\\Installer") != NULL )
            return TRUE;

        if ( wcsistr (SrcNode, L"Classes\\Wow6432Node\\Installer") != NULL )
            return TRUE;

    return FALSE;
}

BOOL
IsSpecialNode ( 
    PWCHAR SrcNode,
    BOOL *Flag,
    DWORD dwDirection,
    DWORD *pdwKeyType
    )
/*++

Routine Description:

    Check if the node need different treatment.

Arguments:

    SrcNode - Name of the node to be synced.
    Flag - If this fall in the special node category this flag is set TRUE.
    dwDirection - SyncDitection
            DIRECTION_32_TO_64 - 32bit is the source of information
            DIRECTION_64_TO_32 - 32bit is the source of information

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.
--*/
{
        *Flag = FALSE;

        if ( wcsistr (SrcNode, L"Classes\\CLSID\\{") != NULL ) { //guid start with {
            *Flag = TRUE;
            ReflectClassGuid ( SrcNode, dwDirection);
        }

        if ( wcsistr (SrcNode, L"Classes\\Wow6432Node\\CLSID\\{") != NULL ) {
            *Flag = TRUE;
            ReflectClassGuid ( SrcNode, dwDirection);
        }

        //
        // Always merge file association BUGBUG: See how bad it is.
        // Must handle special case runonce
        // 

        if ( _wcsnicmp (SrcNode, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run",75 ) == 0 ) { //75 is the size of the string
            *Flag = TRUE;
        //
        // HandleRunOnce (SrcNode);
        //
        }

        if ( wcsistr (SrcNode, L"Classes\\Installer") != NULL )
            *Flag = TRUE;

        if ( wcsistr (SrcNode, L"Classes\\Wow6432Node\\Installer") != NULL )
            *Flag = TRUE;

        //if ( wcsistr (SrcNode, L"\\Classes\\Interface") != NULL )
          //  *Flag = TRUE;

        //if ( wcsistr (SrcNode, L"\\Classes\\Wow6432Node\\Interface") != NULL )
          //  *Flag = TRUE;

        //if (_wcsnicmp (SrcNode, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\TypeLib", sizeof (L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\TypeLib")/2 -1)==0)
          //  *Flag = TRUE;
    
        //if (_wcsnicmp (SrcNode, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Wow6432Node\\TypeLib", sizeof (L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Wow6432Node\\TypeLib")/2 -1)==0)
          //  *Flag = TRUE;

        if ( ( wcsistr (SrcNode, L"Classes\\AppID\\{") != NULL ) ||
            ( wcsistr (SrcNode, L"Classes\\Wow6432Node\\AppID\\{") != NULL ) ) {

            *pdwKeyType = DONT_SYNC_IF_DLL_SURROGATE;

        }
            
    return *Flag;
}

BOOL
NtSyncNode (
    HANDLE hBase,
    PWCHAR AbsPath,
    BOOL bFlag
    )
/*++

Routine Description:

    Synchronize a tree based while closing a Key that was dirty.

Arguments:

    hBase - Handle to the open Key.
    AbsPath - The original path application has created a key.
    bFlag - specify the sync property.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.
--*/
{
    WCHAR DestNode[WOW64_MAX_PATH];
    WCHAR SrcNode[WOW64_MAX_PATH];
    BOOL bSpecialNode = FALSE;

    DWORD dwLen = WOW64_MAX_PATH;
    HKEY hRemap;
    HKEY hBaseNew;
    BOOL bRet;
    DWORD dwDirection;
    DWORD dwKeyType =0;
    
    //
    // If handle is null try to open the key on the otherside of the registry and pull that in.
    //

    if ( hBase != NULL ) {
       if (!HandleToKeyName ( hBase, SrcNode, &dwLen ))
            return FALSE;
    } else wcscpy (SrcNode, AbsPath);


    if (wcsistr (SrcNode, L"Wow6432Node") != NULL ) {

        dwDirection = DIRECTION_32_TO_64;
        Map32bitTo64bitKeyName ( SrcNode, DestNode );

    } else {
        dwDirection = DIRECTION_64_TO_32;
        Map64bitTo32bitKeyName ( SrcNode, DestNode );
    }

    //
    // check if both are the same
    //
    if (_wcsicmp ( SrcNode, DestNode ) == 0)
        return TRUE; //source and destination is the same

    //DbgPrint ("\nSyncing Node %S", SrcNode );

    if (! (bFlag & SKIP_SPECIAL_CASE ))
    if (IsSpecialNode ( SrcNode, &bSpecialNode, dwDirection, &dwKeyType  )) //special rule is applicable here.
        return TRUE;

    hRemap = OpenNode (DestNode);
    hBaseNew = OpenNode (SrcNode); // Open source in case user didn't open it with query priviledge.

    if ( hRemap == NULL && (!( bFlag & DONT_CREATE_DEST_KEY)) ) { //check if you should create this node
        //
        // Always create unless GUID or .abc, then you need to do some additional check.
        //
        if ( CreateNode (DestNode)) {
            hRemap = OpenNode (DestNode);
            UpdateKeyTag ( hRemap, TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE);
        }
    }

    

    
    //
    // SyncValue only, delete all the value from destination and recopy.
    // Generated Key will be reflected by create key.
    //

    if ( hBaseNew!= NULL && hRemap != NULL ) 
        bRet = SyncValue (hBaseNew, hRemap, dwDirection, DEFAULT_FLAG | dwKeyType );

    MyNtClose (hRemap); // Close the handle
    MyNtClose (hBaseNew); // Close the NewHandle
    return bRet;
    //
    // Check for existamce?
    //
 
}

LONGLONG
CmpKeyTimeStamp (
    HKEY hSrc,
    HKEY hDest
    )
/*++

Routine Description:

    Compare Key time stamp.

Arguments:

    hSrc - handle to the src Key.
    hDest - Handle to the dest Key.

Return Value:

    0 - if timestamp of hSrc == timestamp of hDest
    >0 - if timestamp of hSrc > timestamp of hDest
    <0 - if timestamp of hSrc < timestamp of hDest
    FALSE otherwise.
--*/
{
    NTSTATUS st= STATUS_SUCCESS;
    DWORD Index=0, ResultLength;

    LONGLONG TimeSrc=0;
    LONGLONG TimeDest=0;

    PKEY_BASIC_INFORMATION KeyInformation = NULL;
    BYTE Buff [sizeof(KEY_BASIC_INFORMATION) + 256];

    ULONG Length = sizeof(KEY_BASIC_INFORMATION) + 256;
    KeyInformation = (PKEY_BASIC_INFORMATION)Buff;

    

     st = NtQueryKey(
                        hSrc,
                        KeyBasicInformation,
                        KeyInformation,
                        Length,
                        &ResultLength
                        );
     if(NT_SUCCESS (st))
         TimeSrc = *(LONGLONG *)&KeyInformation->LastWriteTime;

     st = NtQueryKey(
                        hDest,
                        KeyBasicInformation,
                        KeyInformation,
                        Length,
                        &ResultLength
                        );
     if(NT_SUCCESS (st))
         TimeDest = *(LONGLONG *)&KeyInformation->LastWriteTime;

     if ( TimeDest == 0 || TimeSrc == 0)    
         return 0;

     return TimeSrc - TimeDest;
}

BOOL
IsPresentLocalServerAppID (
    PWCHAR KeyName, 
    PWCHAR pCLSID,
    PWCHAR DestNode
    ) 
/*++

Routine Description:

    Check if a GUID has localserver32 or AppID than should have been 
    reflected on the other side.

Arguments:

    KeyName - Name of the key.
    pCLDID  - pointer to the end of CLSID
    DestNode - Destination CLSID
            


Return Value:

    TRUE if LocalSrever or AppID is there.
    FALSE otherwise.
--*/
{
    HKEY hKeyTemp = NULL;
    DWORD Len = wcslen (DestNode);
    PWCHAR pDest = DestNode+Len;
    DWORD AttribSrc = 0;
    DWORD AttribDest = TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE; //if key doesn't exist
    HKEY hDest = NULL;


    BYTE KeyBuffer[512];
    DWORD KeyBufferSize = sizeof (KeyBuffer);
    DWORD ResultLength;
    UNICODE_STRING ValueName;
    NTSTATUS Status;
    HKEY hKey;

    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation = NULL;
    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyBuffer;
    RtlInitUnicodeString (&ValueName, L"APPID");







    wcscpy (pCLSID-1, L"\\LocalServer32");

    hKeyTemp = OpenNode (KeyName);
    if (hKeyTemp == NULL ) {

        wcscpy (pCLSID-1, L"\\AppID");

        hKeyTemp = OpenNode (KeyName);
        if (hKeyTemp == NULL ) {
            //
            // Check APPID value key associated with the GUID.
            //
            *(pCLSID-1)= UNICODE_NULL;
            hKeyTemp = OpenNode (KeyName);
            if (hKeyTemp != NULL ) { // query for APPID

                Status = NtQueryValueKey(
                        hKeyTemp,
                        &ValueName,
                        KeyValuePartialInformation,
                        KeyValueInformation,
                        KeyBufferSize,
                        &ResultLength);

                if (!NT_SUCCESS (Status)) {
                    MyNtClose(hKeyTemp);
                    return FALSE;
                }
                *pDest = UNICODE_NULL;
                hDest = OpenNode (DestNode);
            }
        }

        wcscpy (pDest, L"\\AppID");
        hDest = OpenNode (DestNode);
        *pDest = UNICODE_NULL;
      

    }else  {
        wcscpy (pDest, L"\\LocalServer32");
        hDest = OpenNode (DestNode);
        *pDest = UNICODE_NULL;
        
    }

    

    QueryKeyTag (hKeyTemp, &AttribSrc);
    QueryKeyTag (hDest, &AttribDest);
    MyNtClose (hDest);
    MyNtClose (hKeyTemp);

    //
    // if atleast one is a reflected Key then sync value
    //
    if ( (AttribSrc & TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE) ||
        (AttribDest & TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE) )   // reflector touched this Key
        return TRUE;

    return FALSE;  //Yepp ID is present and the guid can be reflected

}

BOOL 
ReflectClassGuid (
    PWCHAR SrcName,
    DWORD dwDirection
    )
/*++

Routine Description:

    Synchronize a two node with value Key. Delete from the RemapKey, and copy from Base

Arguments:

    SrcName - Name of the key on CLSID path.
    dwDirection - SyncDitection
            DIRECTION_32_TO_64 - 32bit is the source of information
            DIRECTION_64_TO_32 - 32bit is the source of information


Return Value:

    TRUE if the function succeed.
    FALSE otherwise.
--*/

{
    PWCHAR pCLSID;
    DWORD  dwLen;
    WCHAR  KeyName[256];  //You don't need this big Key for CLSID
    WCHAR  DestNode[256];
    
    HANDLE hKeyTemp;
    HANDLE hSrc;
    HANDLE hDest;
    BOOL bNewlyCreated = FALSE;
    //
    // If Localserver is present for that key, sync from the CLSID.
    //


    pCLSID = wcsistr (SrcName, L"\\CLSID\\{");
    if ( pCLSID == NULL )
        return TRUE;
    wcscpy (KeyName, SrcName );
    pCLSID = &KeyName[(DWORD)(pCLSID - SrcName)];
    pCLSID +=7; // point start of guid {

    // Sanity Check and will be good enough????
    if ( pCLSID[9] != L'-' || pCLSID[14] != L'-' ||  pCLSID[19] != L'-' ||
          pCLSID[24] != L'-' || pCLSID[37] != L'}' )
        return FALSE;


    //DbgPrint ("\nTrying to sync GUID %S", SrcName);


    //
    // Initially sync the Key first in case time stamp is same because of resolution.
    // Cey Creation will be done while syncing Key from GUID
    //
    pCLSID +=39;
    if ( *(pCLSID-1) != UNICODE_NULL ) {  //check if following is applicable.

        if ( _wcsnicmp (pCLSID, L"InprocServer32", 14) == 0 ) //Skip Inproc server
                return TRUE;

        if ( _wcsnicmp (pCLSID, L"InprocHandler32", 15) == 0 ) {//Check  InprocHandler 
            if (!ReflectInprocHandler32KeyByName (KeyName))
                return TRUE;
        }
    }

    
    //
    // Get other path.
    //
    *(pCLSID-1)= UNICODE_NULL; // Make path only to the GUID
    if ( dwDirection == DIRECTION_32_TO_64 )
        Map32bitTo64bitKeyName ( KeyName, DestNode );  //get 64bit side //BUGBUG: you can optimize this
    else if ( dwDirection == DIRECTION_64_TO_32 )
        Map64bitTo32bitKeyName ( KeyName, DestNode );  //get 32bit side

    //
    // If the other hive has InProcHandler ignore this reflection rule
    // After Beta1 or apply by Tag
    //

    if ( !IsPresentLocalServerAppID (KeyName, pCLSID, DestNode) )
        return TRUE;

    //
    // Now time to reflect everything except InprocServer32
    //

    pCLSID--;
    pCLSID[0]= UNICODE_NULL; // Make path only to the GUID


    hSrc = OpenNode (KeyName);
    if (hSrc == NULL )
        return TRUE;

    hDest = OpenNode (DestNode);
    if ( hDest == NULL ) {

        CreateNode (DestNode);
        hDest = OpenNode (DestNode);
        if (hDest != NULL) {

            UpdateKeyTag ( hDest, TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE);
            bNewlyCreated = TRUE;
            SyncValue ( hSrc, hDest, dwDirection, 0);
        }
    } 
        

    if (hDest != NULL && hSrc != NULL) {
        //
        // Sync Value on current Node
        //
        //if ( !bNewlyCreated ) {
            //
            // if destination is a copy then update this.
            //
            DWORD Attrib1=0;
            DWORD Attrib2=0;
            HKEY hSrcKey1;
            HKEY hDestKey1;

            

            if ( dwDirection == DIRECTION_32_TO_64 )
                Map32bitTo64bitKeyName ( SrcName, DestNode );  //get 64bit side //BUGBUG: you can optimize this
            else if ( dwDirection == DIRECTION_64_TO_32 )
                Map64bitTo32bitKeyName ( SrcName, DestNode );  //get 32bit side

            hSrcKey1 = OpenNode (SrcName);
            hDestKey1 = OpenNode (DestNode);

            if ( hSrcKey1 != NULL && hDestKey1 != NULL )  //if dest isn't reflected key should you merge?
                //
                // 64bit Local Server might get priority
                //
                SyncValue ( hSrcKey1, hDestKey1, dwDirection, SYNC_VALUE_IF_REFLECTED_KEYS);

            MyNtClose ( hSrcKey1 );
            MyNtClose ( hDestKey1 );
        //}

        SyncGuidKey (hSrc, hDest, dwDirection, FALSE );
    }

    MyNtClose (hDest);
    MyNtClose (hSrc);
    return TRUE;

}

BOOL 
SyncGuidKey (
    HANDLE hSrc, 
    HANDLE hDest,
    DWORD dwDirection,
    DWORD __bNewlyCreated
    )
/*++

Routine Description:

    Synchronize a two CLSID Node.

Arguments:

    hSrc - Handle to Source Class GUID.
    hDest - Handle to dest Class GUID.
    dwDirection - SyncDitection
            DIRECTION_32_TO_64 - 32bit is the source of information
            DIRECTION_64_TO_32 - 32bit is the source of information
    __bNewlyCreated - if the destination is just created.


Return Value:

    TRUE if the function succeed.
    FALSE otherwise.
--*/
{
    //
    // Enumerate every key under src and recursively copy that except InProcServer32
    //

    HANDLE hSrcNew;
    HANDLE hDestNew;
    OBJECT_ATTRIBUTES Obja;

    NTSTATUS st= STATUS_SUCCESS;
    DWORD Index=0;

    LONGLONG TimeDiff;
    BOOL bNewlyCreated = FALSE;

    DWORD ResultLength;
    UNICODE_STRING      UnicodeKeyName;

    PKEY_NODE_INFORMATION KeyInformation = NULL;
    BYTE Buff [sizeof(KEY_NODE_INFORMATION) + 256];
    DWORD Length = sizeof (Buff);

    KeyInformation = (PKEY_NODE_INFORMATION)Buff;
    


    //
    // Sync Value first.
    //
    //TimeDiff = CmpKeyTimeStamp ( hSrc, hDest );
    //if (TimeDiff > 0 || __bNewlyCreated ) { //for newnly created key always merge. 
    if (__bNewlyCreated ) { //for newnly created key always merge. 
        SyncValue ( hSrc, hDest, dwDirection, DEFAULT_FLAG);
        //LogMsg (hSrc, L"Copy Guid Keys..");
    }

    //
    // Enumerate all key from the hRemap and delete.
    //
    for (Index=0;;Index++) {

        st = NtEnumerateKey(
                            hSrc,
                            Index,
                            KeyNodeInformation,
                            KeyInformation,
                            Length,
                            &ResultLength
                            );

        if (!NT_SUCCESS(st))
            break;

        KeyInformation->Name[KeyInformation->NameLength/2] = UNICODE_NULL;
        RtlInitUnicodeString( &UnicodeKeyName, KeyInformation->Name );

        if (_wcsnicmp (KeyInformation->Name, L"InprocServer32", 14) == 0 ) //Skip Inproc server
            continue;

        InitializeObjectAttributes (&Obja, &UnicodeKeyName, OBJ_CASE_INSENSITIVE, hSrc, NULL );

        //
        //  Open source key on the Source Side;
        //
        st = NtOpenKey (&hSrcNew, KEY_ALL_ACCESS, &Obja);
        if (!NT_SUCCESS(st))
            continue;

        if (_wcsnicmp (KeyInformation->Name, L"InprocHandler32", 15) == 0 ) {//Check  InprocHandler 
            if (!ReflectInprocHandler32KeyByHandle (hSrcNew)) {
                NtClose (hSrcNew);
                continue;
            }
        }
        
        //
        // Create or open the key on the dest side.
        //
        InitializeObjectAttributes (&Obja, &UnicodeKeyName, OBJ_CASE_INSENSITIVE, hDest, NULL );
        bNewlyCreated = FALSE;

        st = NtOpenKey (&hDestNew, KEY_ALL_ACCESS, &Obja);
        if (!NT_SUCCESS(st))  {

            //
            // Try to create the key here
            //
            st = NtCreateKey(
                        &hDestNew,
                        KEY_ALL_ACCESS,
                        &Obja,
                        0,
                        NULL ,
                        REG_OPTION_NON_VOLATILE,
                        NULL
                        );
            if (!NT_SUCCESS(st)) {
                NtClose (hSrcNew);
                continue;
            }
            bNewlyCreated = TRUE;
            UpdateKeyTag ( hDestNew, TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE );
        }
        //
        // Sync only when Key is created.
        //
        SyncGuidKey ( hSrcNew, hDestNew, dwDirection, bNewlyCreated );
        
        NtClose (hSrcNew);
        NtClose (hDestNew);
    }

    return TRUE;
}

BOOL 
SyncKeysOnBoot ( )
/*++

Routine Description:

  Sync Certain Keys on Boot.
  We don't have any particular list or way to figure it out what need to be synced but this 
  can be extended as request comes.

Arguments:

  None.

Return Value:

  TRUE on success.
  FALSE otherwise.
--*/

{
    //
    // Sync some setup information here. 
    //

    HKEY hSrc;
    HKEY hDest;
    BOOL bRet = FALSE;

    if ( (hSrc = OpenNode (L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion")) == NULL)
        return FALSE;

    if ( (hDest = OpenNode (L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows NT\\CurrentVersion")) == NULL) {
        NtClose (hSrc);
        return FALSE;
    }


    
    bRet = SyncValue ( hSrc, hDest, DIRECTION_64_TO_32, DONT_DELETE_DEST_VALUEKEY );
            
            

    NtClose (hSrc);
    NtClose (hDest);
    return bRet;

}


BOOL 
Wow64SyncCLSID ()
/*++

Routine Description:

    Synchronize CLSID on the machine hive.
    Algorithm:
        1. Enumerate all guid on 64bit side, if the guid has the local 
            server and the other side don't have the guid, sync this.
        2. Apply the same rule for 32bit side as well.
        3. This is only applicable for machine hives only.
        4. This function will run at the end of setup once to sync some guid.

Arguments:

    None.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.
--*/
{
    //
    // Enumerate every key under src and recursively copy that except InProcServer32
    //

    HANDLE hSrc;
    HANDLE hSrcTemp;

    HANDLE hSrcNew;
    HANDLE hDestNew;

    OBJECT_ATTRIBUTES Obja;
    WCHAR Path [256];

    NTSTATUS st= STATUS_SUCCESS;
    DWORD Index=0;

    DWORD ResultLength;
    UNICODE_STRING      UnicodeKeyName;

    PKEY_NODE_INFORMATION KeyInformation = NULL;
    BYTE Buff [sizeof(KEY_NODE_INFORMATION) + 256];
    DWORD Length = sizeof (Buff);

    DWORD dwDirection = DIRECTION_64_TO_32;

    KeyInformation = (PKEY_NODE_INFORMATION)Buff;

    for (;;) {

        if ( dwDirection == DIRECTION_64_TO_32 )
            hSrc = OpenNode (L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\CLSID");
        else hSrc = OpenNode (L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Wow6432Node\\CLSID");

        //
        // Enumerate all key from the hRemap and delete.
        //
        for (Index=0;;Index++) {

            st = NtEnumerateKey(
                                hSrc,
                                Index,
                                KeyNodeInformation,
                                KeyInformation,
                                Length,
                                &ResultLength
                                );

            if (!NT_SUCCESS(st))
                break;

            KeyInformation->Name[KeyInformation->NameLength/2] = UNICODE_NULL;
            wcscpy (Path, KeyInformation->Name);

            wcscat ( Path,L"\\LocalServer32");
            RtlInitUnicodeString( &UnicodeKeyName, Path );

            InitializeObjectAttributes (&Obja, &UnicodeKeyName, OBJ_CASE_INSENSITIVE, hSrc, NULL );

            //
            //  Open source key on the Source Side;
            //
            st = NtOpenKey (&hSrcTemp, KEY_READ, &Obja);
            if (!NT_SUCCESS(st)) { // Local Server Key doesn't exist

                wcscpy (Path, KeyInformation->Name);
                wcscat ( Path,L"\\AppID");

                RtlInitUnicodeString( &UnicodeKeyName, Path );
                InitializeObjectAttributes (&Obja, &UnicodeKeyName, OBJ_CASE_INSENSITIVE, hSrc, NULL );

                st = NtOpenKey (&hSrcTemp, KEY_READ, &Obja);
                if (!NT_SUCCESS(st)) // AppID Key doesn't exist
                    continue;  
                else NtClose (hSrcTemp);

            } else NtClose (hSrcTemp);

            //
            // Check if the guid exists on the other side, if so continue.
            //
            if ( dwDirection == DIRECTION_64_TO_32 )
                wcscpy (Path,L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Wow6432Node\\CLSID\\");
            else
                wcscpy (Path,L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\CLSID\\");

            wcscat (Path,KeyInformation->Name );
            hSrcTemp = OpenNode (Path);

            if (hSrcTemp != NULL ) {

                NtClose (hSrcTemp );
                continue;
            }

            //
            // Create or open the key on the dest side.
            //
            if ( !CreateNode (Path))
                continue;
        
            if ( (hDestNew = OpenNode (Path))==NULL)
                continue;

            UpdateKeyTag ( hDestNew, TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE ); //Mark the key as reflected.
        
            RtlInitUnicodeString( &UnicodeKeyName, KeyInformation->Name );
            InitializeObjectAttributes (&Obja, &UnicodeKeyName, OBJ_CASE_INSENSITIVE, hSrc, NULL );

            st = NtOpenKey (&hSrcNew, KEY_ALL_ACCESS, &Obja);
            if (!NT_SUCCESS(st)) {
                NtClose (hDestNew);
                continue;  
            }

            SyncGuidKey ( hSrcNew, hDestNew, dwDirection, 1);
            NtClose (hSrcNew);
            NtClose (hDestNew);
        } //for-loop enumeration all guids

        NtClose ( hSrc );
      
        if (DIRECTION_32_TO_64 == dwDirection)
            break;

        if (dwDirection == DIRECTION_64_TO_32 )
            dwDirection = DIRECTION_32_TO_64;
        
    } //for loop for direction

    SyncKeysOnBoot (); //sync some special value keys

    return TRUE;
}


VOID 
PatchPathOnValueKey (
    ULONG DataSize,
    ULONG Type,
    WCHAR *Data,
    WCHAR *RetDataBuff,
    ULONG *pCorrectDataSize
    )
/*++

Routine Description:

    Patch the value key while writing on the 32bit side.

Arguments:

    DataSize - Size of data in byte in the buffer.
    Type - registry value type.
    Data - data buffer.
    RetDataBuffer - will contain the patched value.
    pCorrectDataSide - Will have the updated size.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.
--*/
{
    WCHAR ThunkData[256];
    PWCHAR pCorrectData = (PWCHAR)Data;

    *pCorrectDataSize = DataSize;


    //
    // thunk  %ProgramFiles%  ==> %ProgramFiles(x86)% 
    //        %commonprogramfiles% ==> %commonprogramfiles(x86)%
    //

   

    if (DataSize < ( sizeof (ThunkData) - 10) && (Type == REG_SZ || Type == REG_EXPAND_SZ ) )  { //(x86)==>10 byte

        //
        // do the thunking here.
        //

        PWCHAR p;
        PWCHAR t;

        memcpy ( (PBYTE ) &ThunkData[0], (PBYTE)Data, DataSize);
        ThunkData [DataSize/sizeof (WCHAR) ] = UNICODE_NULL; // make sure NULL terminated
        
        if ( (p = wcsistr (ThunkData, L"%ProgramFiles%" )) != NULL ){

            p +=13; //skip at the end of %ProgramFiles
            

        } else if ( (p = wcsistr (ThunkData, L"%commonprogramfiles%")) != NULL ){

            p +=19; //skip at the end of %commonprogramfiles
            
        }

        if (p) {

            t = pCorrectData + (p - ThunkData);
            wcscpy(p, L"(x86)"); //(x86)
            wcscat(p, t);        //copy rest of the string

            pCorrectData = ThunkData;
            *pCorrectDataSize += sizeof (L"(x86)");
        }

    } //if if (DataSize < ( _MAX_PATH

    if ( pCorrectData == ThunkData )
        memcpy ( RetDataBuff, pCorrectData, *pCorrectDataSize );
}


BOOL
Wow64RegDeleteKey (
    HKEY hBase,
    WCHAR  *SubKey
    )
/*++

Routine Description:

    Delete mirror Key.

Arguments:

    hBase - handle to the base key.
    SubKey - Name of the subkey to be deleted.


Return Value:

    TRUE if the key is on the list of reflection.
    FALSE otherwise.
--*/
{
    //
    // 1. Get the complete path to base.
    // 2. Get Check if the key exist on the reflection list.
    // 3. Delete the mirror.
    //

    WCHAR SrcNode[WOW64_MAX_PATH];
    WCHAR KeyName[WOW64_MAX_PATH];
    PWCHAR pCLSID;
    
    BOOL bSpecialNode = FALSE;

    DWORD dwLen = WOW64_MAX_PATH;
    HKEY hRemap;
    DWORD dwDirection;
    NTSTATUS St;

    
    DWORD AttributeMirrorKey;

    
    if (!bReflectorStatusOn)
        return TRUE;  //reflector isn't enable yet.
    
    if ( hBase == NULL)
        wcscpy ( SrcNode, SubKey);

    else  if (!HandleToKeyName ( hBase, SrcNode, &dwLen ))
        return FALSE;

    if (SubKey != NULL && hBase != NULL) {   // wow64 will call with null subkey

        if (*SubKey != L'\\')
            wcscat (SrcNode, L"\\");
        wcscat (SrcNode, SubKey );
    }
    
    
    //
    // If it's guid then dest mustnot have InprocServer.
    //

    /*
    pCLSID = wcsistr (SrcNode, L"\\CLSID\\{");
    if ( pCLSID != NULL ) {

        HKEY hKeyTemp;
     
        wcscpy (KeyName, SrcNode );
        pCLSID = &KeyName[(DWORD)(pCLSID - SrcNode)];
        pCLSID +=7; // point start of guid {

        // Sanity Check and will be good enough????
        if (!( pCLSID[9] != L'-' || pCLSID[14] != L'-' ||  pCLSID[19] != L'-' ||
            pCLSID[24] != L'-' || pCLSID[37] != L'}' ) ) {
            

            //DbgPrint ("\nTrying to sync GUID %S", SrcName);

            pCLSID +=38;
            wcscpy (pCLSID, L"\\InprocServer32");

            hKeyTemp = OpenNode (KeyName);
            if (hKeyTemp != NULL ) {

                MyNtClose (hKeyTemp);
                return TRUE; // Shouldn't detele InprocSrver32
            }

            wcscpy (pCLSID, L"\\InprocHandler32");

            hKeyTemp = OpenNode (KeyName);
            if (hKeyTemp != NULL ) {  

                MyNtClose (hKeyTemp);
                return TRUE; // Shouldn't delete InprocHandler
            }
        } // if initial guid check succeed
    }  //  if \CLSID\{ is there
    */

    
    
    //
    // The other Key has already been deleted. You can delete this or wait.
    //

    if ( TaggedKeyForDelete (SrcNode) ) {

        DWORD Attrib1 = 0;
      
        QueryKeyTag (hBase, &Attrib1);
        

        //*** finetune the rule remove key only with reflected tag.
        //if (!( (Attrib1 & TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE) ||
        //    (AttributeMirrorKey & TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE) ))   // reflector touched this Key
        //        return TRUE; // One key must have reflected tag to be deleted.

        if (!(Attrib1 & TAG_KEY_ATTRIBUTE_REFLECTOR_WRITE))
            return TRUE; // the isn't tagged as reflected.

    }
    

    //
    //  Delete the key here
    //

    St = NtDeleteKey( hBase );

    return TRUE;
    //
    // Check for existamce?
    //
 
}

BOOL
Wow64ReflectSecurity (
    HKEY SrcKey,
    HKEY DestKey
    )
/*++

Routine Description:

  Copy security attribute from SrcKey to DestKey.

Arguments:

  SrcKey - Handle to a key..
  DestKey - handle to the destination key.

Return Value:

  TRUE if operation succeeded.
  FALSE otherwise. 

--*/
{

    NTSTATUS Status;
    PSECURITY_DESCRIPTOR SD;
    BYTE Buffer[2048]; // reflector only manages general purpose keys and will have smaller ACL
    

    LONG Ret, Len;
    LONG BufferLen = sizeof (Buffer);
    DWORD Count = 0;

    SD = (PSECURITY_DESCRIPTOR)Buffer;

    Len = BufferLen;

    Status = NtQuerySecurityObject(
                     SrcKey,
                     DACL_SECURITY_INFORMATION,
                     SD,
                     Len,
                     &Len
                     );

    if ( NT_SUCCESS (Status )) 
        Status = NtSetSecurityObject(
                        DestKey,
                        DACL_SECURITY_INFORMATION,
                        SD
                        );
    

    Len = BufferLen;

    Status = NtQuerySecurityObject(
                     SrcKey,
                     GROUP_SECURITY_INFORMATION,
                     SD,
                     Len,
                     &Len
                     );

    if ( NT_SUCCESS (Status )) 
        Status = NtSetSecurityObject(
                        DestKey,
                        GROUP_SECURITY_INFORMATION,
                        SD
                        );
    


    Len = BufferLen;
    Status = NtQuerySecurityObject(
                     SrcKey,
                     OWNER_SECURITY_INFORMATION,
                     SD,
                     Len,
                     &Len
                     );

    if ( NT_SUCCESS (Status )) 
        Status = NtSetSecurityObject(
                        DestKey,
                        OWNER_SECURITY_INFORMATION,
                        SD
                        );
    

    


    Len = BufferLen;
    Status = NtQuerySecurityObject(
                     SrcKey,
                     SACL_SECURITY_INFORMATION,
                     SD,
                     Len,
                     &Len
                     );

    if ( NT_SUCCESS (Status )) 
        Status = NtSetSecurityObject(
                        DestKey,
                        SACL_SECURITY_INFORMATION,
                        SD
                        );

    return TRUE;
}

BOOL
IsOnReflectionByHandle ( 
    HKEY KeyHandle 
    )
/*++

Routine Description:

  Check if the key specified by a handle sit on the list of keys of reflection.

Arguments:

  KeyHandle - Handle to a key..

Return Value:

  TRUE if the key sit on the the list of reflection.
  FALSE otherwise.

--*/
{
    WCHAR SrcNode[WOW64_MAX_PATH];
    DWORD dwLen = WOW64_MAX_PATH;
    

    if (!bReflectorStatusOn)
        return FALSE;  //reflector isn't enable yet.

    
    if ( KeyHandle == NULL)
        return FALSE;

    else  if (!HandleToKeyName ( KeyHandle, SrcNode, &dwLen ))
        return FALSE;

    return IsOnReflectionList (SrcNode);

}

HKEY
Wow64OpenRemappedKeyOnReflection (
    HKEY SrcKey
    )
/*++

Routine Description:

  Called from advapi to get an handle to remapped key that is on reflection list.

Arguments:

  SrcKey - Handle to a key..

Return Value:

  Valid handle to the reflected key.
  NULL if the function fails.

--*/
{
    PWCHAR DestNode;
    PWCHAR SrcNode;
    BOOL bSpecialNode = FALSE;

    DWORD dwLen = WOW64_MAX_PATH;
    HKEY hRemap;
    NTSTATUS St;

    DestNode = RegRemapAlloc (WOW64_MAX_PATH);
    SrcNode  = RegRemapAlloc (WOW64_MAX_PATH);

    if ( NULL == DestNode || NULL == SrcNode ) {

        RegRemapFree ( DestNode );
        RegRemapFree ( SrcNode );
        return NULL;
    }


    
    if (!bReflectorStatusOn) {

        RegRemapFree ( DestNode );
        RegRemapFree ( SrcNode );
        return NULL;  //reflector isn't enable yet.
    }
    

    
    if ( SrcKey == NULL) {

        RegRemapFree ( DestNode );
        RegRemapFree ( SrcNode );
        return NULL;
    }

    else  if (!HandleToKeyName ( SrcKey, SrcNode, &dwLen )) {

        RegRemapFree ( DestNode );
        RegRemapFree ( SrcNode );
        return NULL;
    }

    if ( !IsOnReflectionList (SrcNode)) {

        RegRemapFree ( DestNode );
        RegRemapFree ( SrcNode );
        return NULL;
    }

    if (wcsistr (SrcNode, L"Wow6432Node") != NULL ) {

        Map32bitTo64bitKeyName ( SrcNode, DestNode );

    } else {
        Map64bitTo32bitKeyName ( SrcNode, DestNode );
    }

    //
    // check if both are the same
    //
    if (_wcsicmp ( SrcNode, DestNode ) == 0) {

        RegRemapFree ( DestNode );
        RegRemapFree ( SrcNode );
        return NULL; //source and destination is the same
    }

    //
    // Must check the special case, Like Installer/file association....
    //

    if ( IsExemptReflection ( SrcNode )) {

        RegRemapFree ( DestNode );
        RegRemapFree ( SrcNode );
        return NULL;
    }



    if ( (hRemap = OpenNode (DestNode) ) == NULL ){

        RegRemapFree ( DestNode );
        RegRemapFree ( SrcNode );
        return NULL;
    }
    

    RegRemapFree ( DestNode );
    RegRemapFree ( SrcNode );

    return hRemap;
}

BOOL
Wow64InitRegistry(
    DWORD dwFlag
    )
/*++

Routine Description:

  Called from advapi initialization code [possibly from RegInitialize @base\screg\winreg\client\init.c].
  This initialize critical section for wow64 registry access.

Arguments:

  dwFlag - No uses at this time, might add functionality later, like who called, AdvAPi32.dll 
           or Wow64.dll so that different thing can be done if needed in the future.
    

Return Value:

  TRUE if wow64 section can be initialized properly.
  FALSE otherwise.

--*/
{
    return InitHandleTable (); //Initialize the handle table that also initialize critical section.

}


BOOL
Wow64CloseRegistry(
    DWORD dwFlag
    )
/*++

Routine Description:

  Called from advapi unload code [possibly from RegInitialize @base\screg\winreg\client\init.c].
  This cleanup some resources like critical section CleanUp.

Arguments:

  dwFlag - No uses at this time, might add functionality later, like who called, AdvAPi32.dll 
           or Wow64.dll so that different thing can be done if needed in the future.
    

Return Value:

  TRUE if wow64 section has been cleaned up properly properly.
  FALSE otherwise.

--*/
{
    //
    // If there is any key to close please do that.
    //

    WOW64_HANDLE *pList;
    DWORD i,k, OpenHandle=0;

    bReflectorStatusOn = FALSE;
    for (i=0;i<TABLE_SEGMENT_MAX, List[i] != NULL;i++) {

        pList = (WOW64_HANDLE *)List[i];
        for (k=0;k<SEGMENT_SIZE;k++)

            if (pList[k].hBase != NULL) {
                //
                // Need to reflect the Key.
                //
                if (pList[k].Status & WOW64_HANDLE_DIRTY) {  // if the handle is dirty sync the node
                    NtSyncNode ( pList[k].hBase, NULL, FALSE );
                    OpenHandle++;
                }
            }
    }

    if ( OpenHandle )
        DbgPrint ("Wow64: the process kept [%d] opened key handles\n", OpenHandle );

    if (bHandleTableInit)
        RtlDeleteCriticalSection (&HandleTable);
    bHandleTableInit=FALSE;

#ifdef _WOW64DLLAPI_ //only linked with wow64 not with advapi32
    CloseWow64Shim ();
#endif
    return TRUE;
}


void
InitializeWow64OnBoot(
    DWORD dwFlag
    )
/*++

Routine Description:

  Called from advapi to get an handle to remapped key that is on reflection list.

Arguments:

  dwFlag - define the point where this function were invoked.
    1- means were invoked from csr service
    2- means this were invoked by setup.

Return Value:

  None.
--*/
{
    DWORD Ret;
    HKEY Key;
    NTSTATUS st;
    
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING KeyName;

	RtlInitUnicodeString (&KeyName, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Classes");
    InitializeObjectAttributes (&Obja, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );
	
    st = NtOpenKey (&Key, KEY_ALL_ACCESS, &Obja);
	if (NT_SUCCESS(st)) {
		st = NtDeleteKey (Key);
		NtClose (Key);
	}

    RtlInitUnicodeString (&KeyName, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Classes");
    InitializeObjectAttributes (&Obja, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );

    st = NtCreateKey(
                    &Key,
                    KEY_ALL_ACCESS | KEY_CREATE_LINK,
                    &Obja,
                    0,
                    NULL ,
                    REG_OPTION_NON_VOLATILE | REG_OPTION_OPEN_LINK | REG_OPTION_CREATE_LINK,  // special options flag
                    NULL
                    );
    
    if (NT_SUCCESS(st)) {

        RtlInitUnicodeString (&KeyName, L"SymbolicLinkValue");
        st = NtSetValueKey(
                                Key,
                                &KeyName,
                                0  ,
                                REG_LINK,
                                (PBYTE)WOW64_32BIT_MACHINE_CLASSES_ROOT,
                                (DWORD ) (wcslen (WOW64_32BIT_MACHINE_CLASSES_ROOT) * sizeof (WCHAR))
                                );

        
        NtClose(Key);
        if ( !NT_SUCCESS(st) ) {
#if DBG
			DbgPrint ( "Wow64-InitializeWow64OnBoot: Couldn't create symbolic link%S\n", WOW64_32BIT_MACHINE_CLASSES_ROOT);
#endif
            return;
        }
    }
    return;
}

#ifdef _ADVAPI32_
WINADVAPI
LONG
APIENTRY
Wow64Win32ApiEntry (
    DWORD dwFuncNumber,
    DWORD dwFlag,
    DWORD dwRes
    )
/*++

Routine Description:

  This is a generic API exported through adavpi32.dll. Just changing the function number 
  More functionality can be added in the future if needed.

Arguments:

  dwFuncNumber - desired function number. 1 means enable/disable reflection.
  dwFlag - set properties of the function entry. if Function number is 1 flag might be one of them.
    WOW64_REFLECTOR_ENABLE - enable reflection.
    WOW64_REFLECTOR_ENABLE - Disable reflection.
  dwRes - for future uses. set to 0.

Return Value:

  None.
--*/
{
    if (dwFuncNumber == 1) {
        if (dwFlag & WOW64_REFLECTOR_ENABLE )
            bReflectorStatusOn = TRUE;
        else if (dwFlag & WOW64_REFLECTOR_DISABLE )
            bReflectorStatusOn = FALSE;

    }

    return 0;
}

#endif


BOOL 
Wow64RegIsPossibleShim (
    HANDLE KeyHandle
    )

/*++

Routine Description:

  Tag the key handle if that fall under some special category like Run RunOnce etc. 
  Those key are tagged so that no KernelCall is made just to inspect some operation.
  If the key is not dirty, it simply cleaned at close.

Arguments:

  KeyHandle - the handle of the key to be tagged.

Return Value:

  None.
--*/

{
    WCHAR SrcNode[WOW64_MAX_PATH];
    DWORD dwLen = WOW64_MAX_PATH;


    if (!HandleToKeyName ( KeyHandle, SrcNode, &dwLen ))
            return FALSE;

    if (( _wcsnicmp (SrcNode, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run",75 ) == 0 ) ||
    ( _wcsnicmp (SrcNode, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run",63 ) == 0 ) ){ //75 is the size of the string

        //
        // Get a handle block and update flag
        //
        //Wow64RegSetKeyPossibleShim (KeyHandle);
        return TRUE;
    }
    return FALSE;
}

#ifdef DBG
BOOL
Wow64RegSetValue (
    HKEY hKey,
    PWCHAR ValueName,
    PVOID  Value,
    DWORD  ValueType
    )
{

    UNICODE_STRING      UnicodeValueName;
    DWORD DataLength;
    NTSTATUS Nt;
    RtlInitUnicodeString( &UnicodeValueName, ValueName );
      
    if ( ValueType == REG_SZ )  {
        DataLength = 2 + sizeof (WCHAR) * wcslen (Value);
    }
    if ( ValueType == REG_DWORD)
        DataLength = 4;


    Nt = NtSetValueKey(
                    hKey,
                    &UnicodeValueName,
                    0,
                    ValueType,
                    (PBYTE)Value,
                    DataLength
                    );
    if (NT_SUCCESS (Nt))
        return TRUE;
    return FALSE;
}

VOID
DebugRegistryRedirectionOnClose (
    HANDLE KeyHandle,
    PWCHAR Message
    )

/*++

Routine Description:

  This function will be called on every single RegCloseKey in the debug mode 
  so that we can inspect whats going on.

  The main idea behind this function is to log registry information on a 
  different hive say HKLM\SW\Wow6432Node\Wow64 and then the whole path.
  Each operation can be tagged with OpenFlag and some attribute to inspect 
  at the end.

  Featutes to implement:
  Break on a particular Key access.
  Filter Key access.

Arguments:

  KeyHandle - the handle of the key to be inspected.
  Message - message from the caller, like this key should have been reflected.

Return Value:

  None.
--*/

{
    WCHAR SrcNode[WOW64_MAX_PATH];
    WCHAR NewNode[WOW64_MAX_PATH+100];
    DWORD dwLen = WOW64_MAX_PATH;
    HKEY  hDest;
    WCHAR Buff[20], *pTemp;

    if ( !HandleToKeyName ( KeyHandle, SrcNode, &dwLen))
        return;

    //
    //if (wcsistr (SrcNode, L"\\cpp") == NULL)
    //  return;

    wcscpy (NewNode, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node");
    wcscat ( NewNode, SrcNode);

    CreateNode (NewNode);
    hDest = OpenNode (NewNode);

    if (hDest == NULL)
        return;
    
    SyncValue (KeyHandle, hDest, 0, DONT_DELETE_DEST_VALUEKEY );
    
    LogID++;
    swprintf (Buff, L"Wow64%d:", LogID);
    Wow64RegSetValue ( hDest, Buff, (PVOID)Message, REG_SZ);
    MyNtClose(hDest);
}
#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\regremap\wow64reg\cleanup.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    cleanup.c

Abstract:

    This module will cleanup registry with copied entry.

Author:

    ATM Shafiqul Khalid (askhalid) 16-Feb-2000

Revision History:

--*/

#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#include "wow64reg.h"
#include <assert.h>
#include "reflectr.h"

DWORD
DeleteValueFromSrc (
    HKEY SrcKey
    )
/*++

Routine Description:

    Delete Wow6432Value key from the node.

Arguments:

    SrcKey - Handle to the src Key.

Return Value:

    TRUE if everything under the has been deleted.
    FALSE otherwise.

--*/

{

    DWORD dwIndex =0;
    DWORD Ret;

    HKEY hKey;


    WCHAR Node[_MAX_PATH];

    //Delete wow6432Value Key
    if (RegDeleteValue( SrcKey, (LPCWSTR )WOW6432_VALUE_KEY_NAME) != ERROR_SUCCESS) {
        //Wow64RegDbgPrint (("\nSorry! couldn't remove wow6432 value key or it doesn't exist"))
    }



    for (;;) {

        DWORD Len = sizeof (Node)/sizeof (WCHAR);
        Ret = RegEnumKey(
                          SrcKey,
                          dwIndex,
                          Node,
                          Len
                          );
        if (Ret != ERROR_SUCCESS)
            break;

        dwIndex++;

        Ret = RegOpenKeyEx(SrcKey, Node , 0, KEY_ALL_ACCESS, &hKey);
        if (Ret != ERROR_SUCCESS) {
            continue;
        }

        DeleteValueFromSrc (hKey);
        RegCloseKey (hKey);

    }
    return TRUE;
}

DWORD
DeleteKey (
    HKEY DestKey,
    WCHAR *pKeyName,
    DWORD mode
    )
/*++

Routine Description:

    Delete key from the destination node if that was a copy from src node.

Arguments:

    DestKey - Handle to the dest Key.
    pKeyName - Key to delete
    mode   -  deletion mode.
            ==> 0 default remove only copy key.
            ==> 1 remove all key disregarding copy attribute.

Return Value:

    TRUE if everything under the has been deleted.
    FALSE otherwise.

--*/

{

    DWORD dwIndex =0;
    DWORD Ret;

    HKEY hKey;


    WCHAR Node[_MAX_PATH];


    BOOL bDeleteNode = FALSE;
    BOOL bEmptyNode = TRUE; // hope that it can delete everything

    WOW6432_VALUEKEY ValueDest;

    Ret = RegOpenKeyEx(DestKey, pKeyName , 0, KEY_ALL_ACCESS, &hKey);
        if (Ret != ERROR_SUCCESS) {
            return Ret;
        }

    GetWow6432ValueKey ( hKey, &ValueDest);


    if ( ValueDest.ValueType == Copy || mode == 1 ) {
        //delete all the values
        bDeleteNode = TRUE; //don't delete this node
    }

    // delete all the subkeys enumerate and delete

    for (;;) {

        DWORD Len = sizeof (Node)/sizeof (Node[0]);
        Ret = RegEnumKey(
                          hKey,
                          dwIndex,
                          Node,
                          Len
                          );
        if (Ret != ERROR_SUCCESS)
            break;

        dwIndex++;
        if ( !wcscmp  (Node, (LPCWSTR )NODE_NAME_32BIT) )
            continue;

        if (!DeleteKey (hKey, Node, mode )) {
            bEmptyNode = FALSE; // sorry couldn't delete everything
            dwIndex--; //skip the node
        }

    }
    RegCloseKey (hKey);

    //now delete the dest key.
    if (bDeleteNode) {
        if ( RegDeleteKey ( DestKey, pKeyName) == ERROR_SUCCESS)
        return ERROR_SUCCESS;
    }

    return -1; //unpredictable error
}

BOOL
DeleteAll (
    PWCHAR Parent,
    PWCHAR SubNodeName,
    DWORD Mode,
    DWORD option //one means delete discarding wow6432valuekey
    )
/*++

Routine Description:

    Validate node. if node exist skip if doesn't then create the node and then return.

Arguments:

    Parent - Name of the parent.
    SubNodeName - Name of the node under parent that need to be deleted.

    Mode - 0 means Subnode is under the parent.
           1 means there were wild card and the subnode is under all key under parent.

    option - 0 means check wow6432valuekey for copy
           1 means delete discarding wow6432valuekey


Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/

{
    PWCHAR SplitLoc;
    DWORD Ret;
    WCHAR TempIsnNode1[_MAX_PATH];
    WCHAR TempIsnNode2[_MAX_PATH];

    if (SubNodeName == NULL) {

        WCHAR *p ;
        HKEY hKey;

        wcscpy (TempIsnNode1, Parent);

        p = &TempIsnNode1[wcslen(TempIsnNode1)];

        Wow64RegDbgPrint ( ("\nDeleting Key %S......", TempIsnNode1) );

        while ( p != TempIsnNode1 && *p !=L'\\') p--;

        if ( p != TempIsnNode1 ) {
            *p=UNICODE_NULL;

            hKey = OpenNode (TempIsnNode1);
                if ( hKey == NULL ){
                    Wow64RegDbgPrint ( ("\nSorry! Couldn't open the key [%S]",TempIsnNode1));
                    return FALSE;
                }

                DeleteKey (hKey, p+1, 1);
                DeleteValueFromSrc (hKey);
                RegCloseKey (hKey);

        }

        return TRUE; //empty node under parent
    }

    if (SubNodeName[0] == UNICODE_NULL)
        return TRUE;

    if ( Mode == 1) {

        HKEY Key = OpenNode (Parent);
        //
        //  loop through all the subkey under parent
        //

        DWORD dwIndex =0;
        for (;;) {

            DWORD Len = sizeof ( TempIsnNode1 )/sizeof (WCHAR);

            TempIsnNode1 [0]=UNICODE_NULL;
            Ret = RegEnumKey(
                              Key,
                              dwIndex,
                              TempIsnNode1,
                              Len
                              );
            if (Ret != ERROR_SUCCESS)
                break;

            if (Parent[0] != UNICODE_NULL) {

                wcscpy ( TempIsnNode2, Parent);
                wcscat (TempIsnNode2, (LPCWSTR )L"\\");
                wcscat (TempIsnNode2, TempIsnNode1);

            } else   wcscpy (TempIsnNode2, TempIsnNode1);

            DeleteAll  (TempIsnNode2, SubNodeName, 0, option);

            dwIndex++;
        }
        RegCloseKey (Key);
        return TRUE;
    }
    //
    // No wild card here
    //
    if ( ( SplitLoc = wcschr (SubNodeName, L'*') ) == NULL ) {
        if (Parent[0] != UNICODE_NULL) {

            wcscpy ( TempIsnNode2, Parent);
            wcscat (TempIsnNode2, (LPCWSTR )L"\\");
            wcscat (TempIsnNode2, SubNodeName);

        } else
            wcscpy (TempIsnNode2, SubNodeName);

        DeleteAll  (TempIsnNode2, NULL, 0, option);
        return TRUE;
    }

    assert ( *(SplitLoc-1) == L'\\');
    *(SplitLoc-1) = UNICODE_NULL;
    SplitLoc++;
    if (*SplitLoc == L'\\')
        SplitLoc++;

    if (Parent[0] != UNICODE_NULL) {
        wcscat (Parent, (LPCWSTR )L"\\");
        wcscat (Parent, SubNodeName);
    } else
        wcscpy (Parent, SubNodeName);

    DeleteAll  (Parent, SplitLoc, 1, option); //mode 1 means loop within all

    return TRUE;
    //for any wildcard split the string

}

//Cleanup program

BOOL
CleanupTable ()
/*++

Routine Description:

    Cleanup  main table containing ISN node list.

Arguments:

    None.

Return Value:

    TRUE if the table has been removed successfully.
    FALSE otherwise.

--*/
{
    HKEY hKey;
    DWORD Ret;

    //
    //  take action to remove registry entry
    //

    Ret = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        (LPCWSTR ) WOW64_REGISTRY_SETUP_KEY_NAME_REL_PARENT,
                        0,
                        KEY_ALL_ACCESS,
                        &hKey
                        );

    if (Ret == ERROR_SUCCESS ) {

        Ret = RegDeleteKey (hKey, (LPCWSTR)WOW64_REGISTRY_ISN_NODE_NAME );

        if ( Ret == ERROR_SUCCESS) {
            Wow64RegDbgPrint ( ("\nSuccessfully removed ISN Table entry "));
        }

        RegCloseKey (hKey);
    }

    return TRUE;

}



BOOL
CleanpRegistry ()
/*++

Routine Description:

    Cleanup Registry.

Arguments:

    None.

Return Value:

    TRUE if everything under the has been deleted.
    FALSE otherwise.

--*/
{



    extern ISN_NODE_TYPE *RedirectorTable;

    DWORD dwIndex;
    HKEY hKey;

    WCHAR TempIsnNode[256];
    WCHAR IsnNode[256];

    //
    // Initialize the table first then delete the table
    //

    InitializeIsnTable ();


    for ( dwIndex=0;dwIndex<wcslen (RedirectorTable[dwIndex].NodeValue);dwIndex++) {


            IsnNode[0] = UNICODE_NULL;
            wcscpy (TempIsnNode , RedirectorTable[dwIndex].NodeValue);
            wcscat (TempIsnNode , (LPCWSTR )L"\\");

            wcscat (TempIsnNode, (LPCWSTR )NODE_NAME_32BIT);
            Wow64RegDbgPrint ( ("\nDeleting Key %S==>%S", IsnNode, TempIsnNode));

            if (wcschr(TempIsnNode, L'*') != NULL ) { //wildcard exist
                DeleteAll ( IsnNode,
                            TempIsnNode,
                            0,
                            1
                            );
            } else {

                hKey = OpenNode (RedirectorTable[dwIndex].NodeValue);
                if ( hKey == NULL ){
                    Wow64RegDbgPrint ( ("\nSorry! Couldn't open the key [%S]",RedirectorTable[dwIndex].NodeValue));
                    continue;
                }

                DeleteKey (hKey, NODE_NAME_32BIT, 1);
                DeleteValueFromSrc (hKey);
                RegCloseKey (hKey);
            }
    }
    CleanupTable ();
    return TRUE;

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\regremap\wow64reg\reflectr.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    reflectr.c

Abstract:

    This module will register reflector thread and do necessary action while awake up.

Author:

    ATM Shafiqul Khalid (askhalid) 16-Feb-2000

Revision History:

--*/

#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include <string.h>
#include "wow64reg.h"
#include <assert.h>
#include <shlwapi.h>
#include "reflectr.h"


REFLECTOR_EVENT eReflector[ISN_NODE_MAX_NUM];

REFLECTR_STATUS ReflectrStatus = Stopped;
HANDLE hRegistryEvent[ISN_NODE_MAX_NUM];


HANDLE hReflector;
DWORD  TotalEventCount = 0;

VOID
DbgPrint(
    PCHAR FormatString,
    ...
    );

REFLECTR_STATUS
GetReflectorThreadStatus ()
/*++

Routine Description:

    Return current thread status;

Arguments:

    None.

Return Value:

    REFLECTR_STATUS

--*/

{
    return ReflectrStatus;

}

BOOL
NotifyKeyChange (
    HKEY hKey,
    HANDLE hEvent
    )
/*
Routine Description:

    Register an event to be fired when something get changed on a key.

Arguments:

    hKey - handle to a key that need to be watched.
    hEvent event that need to be triggered.

Return Value:

    TRUE if the event registration succeed,
    FALSE otherwise.

--*/
{
    DWORD Ret;
    ResetEvent (hEvent);
    Ret = RegNotifyChangeKeyValue(
                                hKey,      // need to change to the ISN node
                                TRUE,                   // Watch the whole sub-tree
                                REG_NOTIFY_CHANGE_NAME |
                                        REG_NOTIFY_CHANGE_LAST_SET, // Don't watch for anything
                                hEvent,         // Event Handle
                                TRUE                    // Async
                                );
    if ( ERROR_SUCCESS != Ret)
        DbgPrint ("\nWow64.exe:Error!! Couldn't register events:%x on handle %x",hEvent, hKey);  

    return Ret == ERROR_SUCCESS;
                               
}

VOID
RefreshWaitEventTable ()
/*++

Routine Description:

    Just copy all event object and we can wail for new event to trigger.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD k;
    for (k=0;k<TotalEventCount;k++)
        hRegistryEvent[k] = eReflector[k].hRegistryEvent;
}

BOOL
CreateInsertEvent (
    PWCHAR Name,
    DWORD dwIndex
    )
/*++

Routine Description:

    Create an event for the key.

Arguments:

    Name - Name of the key an event will be created to watch any changes.
    dwIndex - is the index to the reflector table. when event is fired up we need to tack the key.

Return Value:

    TRUE on success,
    FALSE Otherwise

--*/
{

    if ( Name == UNICODE_NULL)
        return FALSE;

    if (wcsstr( Name, (LPCWSTR)L"\\REGISTRY\\USER\\*\\")) {

                if (RegOpenKey ( HKEY_CURRENT_USER,
                      Name+sizeof ( L"\\REGISTRY\\USER\\*")/sizeof(WCHAR),
                      &eReflector[TotalEventCount].hKey) != ERROR_SUCCESS) {

                      Wow64RegDbgPrint (("\nSorry! couldn't open Key [%S]",
                          Name+sizeof ( L"\\REGISTRY\\USER\\*")/sizeof(WCHAR) ) );

                      return FALSE;
                }
    } else {

                eReflector[TotalEventCount].hKey = OpenNode (Name);

                if ( eReflector[TotalEventCount].hKey == NULL ) {

                    Wow64RegDbgPrint (("\nSorry! couldn't open Key [%S] Len%d %d %d", Name, wcslen (Name), Name[0], UNICODE_NULL ));
                    return FALSE;
                }
    }



    //
    // DO make sure that 32bit version exist on the hive...
    //

 
    {
        WCHAR TempName[256];

        GetMirrorName (Name, TempName);
        if ( wcscmp(Name,TempName ) )
             CreateNode ( TempName );
        
        // get all kind of name
    }

        eReflector[TotalEventCount].hRegistryEvent = CreateEvent(
                    NULL,   // Security Attributes
                    TRUE,  // Manual Reset
                    FALSE,  // Initial State
                    NULL    // Unnamed
                    ) ;

        if ( !eReflector[TotalEventCount].hRegistryEvent) {

            Wow64RegDbgPrint (("\nUnable to create event"));
            RegCloseKey (eReflector[TotalEventCount].hKey);
            return FALSE;
        }

        eReflector[TotalEventCount].dwIndex = dwIndex;
        ResetEvent (eReflector[TotalEventCount].hRegistryEvent);

        if (!NotifyKeyChange (eReflector[TotalEventCount].hKey,
            eReflector[TotalEventCount].hRegistryEvent
            )) {
                    Wow64RegDbgPrint ( ("\nSevere Error!!!! Couldn't hook to registry notify index:%d", TotalEventCount) );
                    RegCloseKey (eReflector[TotalEventCount].hKey);
                    CloseHandle (eReflector[TotalEventCount].hRegistryEvent);
                    return FALSE;  //set thread state
          }

        TotalEventCount++;

        return TRUE;
}


DWORD
TotalRelflectorKey()
/*++

Routine Description:

    Return the total number of the key in the reflector Table.

Arguments:

    None.

Return Value:

    Number of entry in the reflector table.

--*/
{
    extern ISN_NODE_TYPE *ReflectorTable;
    DWORD i;
    for (i=0;;i++)
        if ( ReflectorTable[i].NodeValue[0] == UNICODE_NULL )
            return i;
}

VOID
PrintTable ()
/*++

Routine Description:

    Dump the current content of the table, just for debugging purpose.

Arguments:

    None.

Return Value:

    None.

--*/
{
    extern ISN_NODE_TYPE *ReflectorTable;
    DWORD Size = TotalRelflectorKey();
    DWORD i;

    for ( i=0;i<Size;i++)
        Wow64RegDbgPrint ( ("\nTableElem [%d], %S", i, ReflectorTable[i].NodeValue));

}

BOOL
RemoveKeyToWatch (
    PWCHAR Name
    )
/*++

Routine Description:

    Remove an entry in from the table to reflector thread need to watch.

Arguments:

    Name - Name of the key to remove from the table.

Return Value:

    TRUE on success,
    FALSE Otherwise

--*/
{
    DWORD i;
    DWORD k;
    extern ISN_NODE_TYPE *ReflectorTable;
    DWORD Size;


    for (i=1; i<TotalEventCount;i++)
        if (!_wcsicmp (Name, ReflectorTable[eReflector[i].dwIndex].NodeValue)) {//found match

            // move reflector table entry
            // fixup pointer in the ereflectortable

            Size = TotalRelflectorKey ();
            wcscpy (  ReflectorTable[eReflector[i].dwIndex].NodeValue,
                      ReflectorTable[Size-1].NodeValue
                    );
            Size--;
            ReflectorTable[Size].NodeValue[0]=UNICODE_NULL; //invalidate the place
            for (k=1; k<TotalEventCount;k++)
                if ( eReflector[k].dwIndex == Size ) {
                    eReflector[k].dwIndex = eReflector[i].dwIndex; //new location
                        break;
                }


            // fixup the table with the new entry

            {
                REFLECTOR_EVENT Temp = eReflector[i];
                eReflector[i]        = eReflector[TotalEventCount-1];
                eReflector[TotalEventCount-1] = Temp;;
            }
            TotalEventCount--;
            CloseHandle (eReflector[TotalEventCount].hRegistryEvent );
            RegCloseKey ( eReflector[TotalEventCount].hKey);
            eReflector[TotalEventCount].dwIndex = -1;

            //Now remove from the original table

            PrintTable();
            return TRUE;
        }

    return FALSE;
}

BOOL
AddKeyToWatch (
    PWCHAR Name
    )
/*++

Routine Description:

    Add an entry in the table to reflector thread need to watch.

Arguments:
 
    Name - Name of the key to watch.

Return Value:

    TRUE on success,
    FALSE Otherwise

--*/
{

    //
    // Check for duplicate entry
    //


    DWORD i;
    DWORD k;
    extern ISN_NODE_TYPE *ReflectorTable;
    DWORD Size;


    for (i=1; i<TotalEventCount;i++)
        if (!_wcsicmp (Name, ReflectorTable[eReflector[i].dwIndex].NodeValue)) {//found match
            return FALSE; //already there
        }



    Size = TotalRelflectorKey ();
    wcscpy (  ReflectorTable[Size].NodeValue, Name );
    ReflectorTable[Size+1].NodeValue[0]=UNICODE_NULL; //invalidate the place

    if (!CreateInsertEvent ( Name, Size ))
        ReflectorTable[Size].NodeValue[0]=UNICODE_NULL; //no point of keeping the bad entry

    return TRUE;
}

BOOL
ValidateOpenHandleEventTable (
    DWORD dwIndex
    )
/*++

Routine Description:

    Validate a given node and if something wrong kick out the entry from the
    event table.

Arguments:

    dwIndex - entry that need to be checked

Return Value:

    TRUE if function succeed.
    FALSE otherwise.

--*/
{
    extern ISN_NODE_TYPE *ReflectorTable;

    //
    //  current implementation will just remove the entry from the table
    //

    return RemoveKeyToWatch (ReflectorTable[eReflector[dwIndex].dwIndex].NodeValue);
}

VOID
PeocessHiveLoadUnload ()
/*++

Routine Description:

    Take necessary action when a hive has been unloaded.

Arguments:

    None.

Return Value:

    None.

--*/
{

    DWORD i;

    WCHAR Name[257];
    WCHAR Type;

    for (;;) {
        if (!DeQueueObject ( Name, &Type ))
            break;

        if ( Type == HIVE_UNLOADING ) { //Closing hive

            RemoveKeyToWatch (Name);
        } else if ( Type == HIVE_LOADING) { //opening hive

            AddKeyToWatch (Name);
        }

        Wow64RegDbgPrint ( ("\nFired up from shared memory write.....Value..%S  [%C]", Name, Type) );
    }
}
 
ULONG
ReflectorFn (
    PVOID *pTemp
    )
/*++

Routine Description:

    Main reflector thread.

Arguments:

    pTemp -

Return Value:

    return exit code.

--*/
{
    DWORD Ret, k;
    DWORD LocalWaitTime;

    pTemp=NULL;

    for (k=0;k<TotalEventCount;k++)
          hRegistryEvent[k] = eReflector[k].hRegistryEvent;

    for (k=0;k<TotalEventCount;k++) {  //reset everything and wait for a fresh event
        if (eReflector[k].hRegistryEvent)
          NotifyKeyChange (  eReflector[k].hKey, eReflector[k].hRegistryEvent);
      }

    for (;;) {

        if ( ReflectrStatus == PrepareToStop ) {
            Wow64RegDbgPrint ( ("\nGoing to stop"));
            ReflectrStatus = Stopped;
            break;  // the thread should stop
        }

        Wow64RegDbgPrint ( ("\nReflector thread has been started and will wait for event\n.......") );

        Sleep (1000*10); //wait 10 sec before reregistering events

        LocalWaitTime = WAIT_INTERVAL; //wait infinite
        for (;;) {

            //DbgPrint ("\nwow64.exe Waiting to liten...");
            Ret = WaitForMultipleObjects(TotalEventCount, hRegistryEvent, FALSE, LocalWaitTime );

            if (ReflectrStatus == PrepareToStop) {

                ReflectrStatus = Stopped;
                Wow64RegDbgPrint ( ("\nGoing to stop"));
                break;  // the thread should stop
            }
         
            if ( Ret == WAIT_TIMEOUT )
                break; // break the loop and process all dirty hives.

            if ( ( Ret-WAIT_OBJECT_0) > TotalEventCount ) { //right index
                Wow64RegDbgPrint ( ("\nWaitMultiple object failed!!.. %d LastError:%d", Ret, GetLastError ()) );
                Sleep (1000*10); //wait 10 sec before reregistering events
                continue;
                //break;
            }

            //
            // Checkspecial case like shared memory write
            //
            if ( (Ret-WAIT_OBJECT_0) == 0){

                PeocessHiveLoadUnload ();
                ResetEvent (eReflector[0].hRegistryEvent);  // reset the  event that triggered this
                RefreshWaitEventTable ();

                continue;
            }

            //
            // set timeout to 10 second, Mark the hive dirty, reset event, and back to sleep
            //
            LocalWaitTime = 5*1000;  // poll the event every 5 second.
            Sleep (1000* 3);// Sleep 3 second to reregister the event.
            eReflector[Ret-WAIT_OBJECT_0].bDirty = TRUE;
            ResetEvent (eReflector[Ret-WAIT_OBJECT_0].hRegistryEvent);

            //
            // watch for the event again
            //

            if (!NotifyKeyChange (  eReflector[Ret-WAIT_OBJECT_0].hKey, 
                                    eReflector[Ret-WAIT_OBJECT_0].hRegistryEvent)){
                    //
                    // if the node get deleted you need to unload the events and everything
                    //
                    ValidateOpenHandleEventTable (Ret-WAIT_OBJECT_0);
                    RefreshWaitEventTable ();
                    //ReflectrStatus = Abnormal;
                    //break; //set thread state
            }
            
        }

        if (ReflectrStatus == PrepareToStop) 
            break;


        //
        // Now process all dirty hive.
        //

        for (k=0;k<TotalEventCount;k++)
            if ( eReflector[k].bDirty ) {

                CreateIsnNodeSingle( eReflector[k].dwIndex);  // reflect changes
                eReflector[k].bDirty = FALSE;
                //ResetEvent (eReflector[k].hRegistryEvent);
            }

    } //for loop

    Wow64RegDbgPrint ( ("\nReflector thread terminated...."));
    return TRUE;
}


BOOL
RegisterReflector()
/*++

Routine Description:

    Register the reflector thread after doing necessary initialization.

Arguments:

    None.

Return Value:

    TRUE if it can launch the reflector thread properly.
    FALSE otherwise.

--*/
{
    DWORD i;
    DWORD Size;


    extern ISN_NODE_TYPE *ReflectorTable;


    if ( ReflectrStatus == Running )
        return TRUE; // already running

    if ( ReflectrStatus != Dead )
        return FALSE; // last state was invalid I can do nothing

    InitializeIsnTableReflector (); //initialize the table with the more list in the registry.

    hReflector = NULL;

    if (!TotalEventCount)
        Wow64RegDbgPrint (("\nSorry! total event count for reflector is zero %d", TotalEventCount));

    //
    // Now time to create event and sync object for the shared resources
    //

    for (i=0;i<ISN_NODE_MAX_NUM;i++) {
        eReflector[i].hRegistryEvent = NULL;
        eReflector[i].hKey = NULL;
        eReflector[i].dwIndex = -1;
        eReflector[i].bDirty = FALSE; // not dirty so that we need to refresh.
    }

    if (!CreateSharedMemory ( 0 ))
        Wow64RegDbgPrint (("\nSorry Couldn't create/open shared memory Ret:%x", GetLastError ())); //default creation

    if (!Wow64CreateEvent ( 0, &eReflector[TotalEventCount].hRegistryEvent ))
        Wow64RegDbgPrint ( ("\nSorry Couldn't create events, reflector can listen to others"));
    else {
        eReflector[TotalEventCount].dwIndex = -1;
        TotalEventCount++;
    }

    Size = TotalRelflectorKey ();
    for ( i=0;i<Size;i++) {

            //
            // Open The Key
            //
            //
            // special case current user
            //

        CreateInsertEvent ( ReflectorTable[i].NodeValue, i );

    }


    //
    // Now Create a thread to watch the event.
    //

    hReflector = CreateThread(
                        NULL,           // pointer to security attributes
                        0,              // initial thread stack size
                        ReflectorFn,    // pointer to thread function
                        0,              // argument for new thread
                        0,              // creation flags
                        NULL            // pointer to receive thread ID

                        );
    if  ( !hReflector ) {

        Wow64RegDbgPrint ( ("\nCouldn't create reflector thread"));
        return FALSE;
    }

    ReflectrStatus = Running;
            return TRUE;
}

BOOL
UnRegisterReflector()
/*++

Routine Description:

    Unregister reflector thread and cleanup resources used by the reflector thread.

Arguments:

    None.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{

    DWORD i;
    DWORD k;

    ReflectrStatus = PrepareToStop;

    //
    //  try to signal event in case the thread is wating
    //
    for (k=0;k<TotalEventCount;k++) {  //reset everything and wait for a fresh event
        if (eReflector[k].hRegistryEvent)
          SetEvent (eReflector[k].hRegistryEvent);
      }


    //
    // Allow reflector thread little bit time to stop.
    //
    i=0;
    while ( ReflectrStatus != Stopped ) {

        Sleep(1000);
        if ( ReflectrStatus != Running )
            break; // why you should wait idle thread or that might be in a abnormal state.

        i++;
        if (i>60*5)
            break;  // 5min timeout going to stop anyway.
    }

    for (i=1;i<TotalEventCount;i++) {  // skip the initial event for shared memory

        CloseHandle (eReflector[i].hRegistryEvent);
        eReflector[i].hRegistryEvent = NULL;

        RegCloseKey ( eReflector[i].hKey );
        eReflector[i].hKey = NULL;
    }

    if ( hReflector ) {
        CloseHandle (hReflector);  //make sure abnormal thread termination doesn't cause any corruption
        hReflector = NULL;
    }

    ReflectrStatus = Dead;

    //
    // release shared resources
    //

    CloseSharedMemory ();
    Wow64CloseEvent ();

    return TRUE;
}

BOOL
InitReflector ()
/*++

Routine Description:

    Initialize resources associated with a reflector thread.

Arguments:

    None.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{
    DWORD k;

    ReflectrStatus = Dead;

    hReflector = NULL;

    for (k=0;k<ISN_NODE_MAX_NUM;k++) {  //reset everything and wait for a fresh event

        eReflector[k].hRegistryEvent = NULL;
        eReflector[k].hKey = NULL;
        eReflector[k].bDirty = FALSE; // not dirty so that we need to refresh.

      }

    return TRUE;

}

LONG
RegReflectKey (
  HKEY hKey,         // handle to open key
  LPCTSTR lpSubKey,   // subkey name
  DWORD   dwOption   // option flag
)
/*++

Routine Description:

    Synchronize registry hive from a given point.

Arguments:

    hKey - handle to an open key. Can be predefined handle or NULL to sync all.
    lpSubKey - Name of the subkey. This can be NULL.
    dwOption - set to zero. for future uses.

Return Value:

    ERROR_SUCCESS on success,
    WIN32 error otherwise.

--*/
{
    HKEY hDest;

    WCHAR Path[_MAX_PATH];
    DWORD Len  = _MAX_PATH;

    WCHAR DestNode[_MAX_PATH];
    BOOL b64bitSide=TRUE;
    BOOL Ret = TRUE;

    DestNode[0] = UNICODE_NULL;

    //
    // present implementation will start from the very top level
    //

    //
    // should interact with the running service, stop the thread, run the reflector and then try again.
    //

    if (hKey != NULL || dwOption!=0 ) {
        Wow64RegDbgPrint (("\nCurrent implementation only take all zero parameters. "));
    }

    if (!InitializeIsnTable ())
        return -1;

    if (!InitializeIsnTableReflector ())
        return -1;

    if (!HandleToKeyName ( hKey, Path, &Len ))
        return -1;

    //
    // Make the complete path
    //

    if ( lpSubKey != NULL )
        if (lpSubKey[0] != UNICODE_NULL ) {
            wcscat (Path, L"\\");
            wcscat (Path, lpSubKey );
        }

    //
    // MakeSure destination exists
    //
    //
    // must check the value if that exist
    //

    if ( Is64bitNode ( Path )) {

        Map64bitTo32bitKeyName ( Path, DestNode );
    } else {

        b64bitSide = FALSE;
        Map32bitTo64bitKeyName ( Path, DestNode );
    }

    hDest = OpenNode (DestNode);
    if (hDest != NULL)
        RegCloseKey ( hDest);
    else {
        if ( !CreateNode (DestNode))
            return -1;
    }

    SyncNode (Path);

    return ERROR_SUCCESS;
}

BOOL
SetWow64InitialRegistryLayout ()
/*++

Routine Description:

    This routine does some initial setup for the registry for wow64.

Arguments:

    None.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/

{
    DWORD Ret;
    HKEY Key;
    //HKEY Key1;
    //
    //  Create symbolic link {HKLM\software\Wow6432Node\Classes to HKLM\software\classes\wow6432Node}
    //

    InitializeWow64OnBoot (1);
    return TRUE;

    Ret = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,        // handle to an open key
                            L"SOFTWARE\\Classes\\Wow6432Node",  // address of subkey name
                            0,                        // reserved
                            NULL,                     // address of class string
                            REG_OPTION_NON_VOLATILE,  // special options flag
                            KEY_ALL_ACCESS,           // desired security access
                            NULL,                     // address of key security structure
                            &Key,                     // address of buffer for opened handle
                            NULL                     // address of disposition value buffer
                            );

    if ( Ret != ERROR_SUCCESS ) {
        Wow64RegDbgPrint ( ("\nSorry! I couldn't create the key SOFTWARE\\Classes\\Wow6432Node") );
        return FALSE;
    }
    RegCloseKey ( Key );

    Ret = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,        // handle to an open key
                            L"SOFTWARE\\Wow6432Node", // address of subkey name
                            0,                        // reserved
                            NULL,                     // address of class string
                            REG_OPTION_NON_VOLATILE ,  // special options flag
                            KEY_ALL_ACCESS,           // desired security access
                            NULL,                     // address of key security structure
                            &Key,                     // address of buffer for opened handle
                            NULL                     // address of disposition value buffer
                            );

    if  (Ret != ERROR_SUCCESS ) {
        Wow64RegDbgPrint ( ("\nSorry! couldn't create/open SOFTWARE\\Wow6432Node") );
        return FALSE;
    } else  {

        //
        // Delete the Key if exist
        //
        Ret = RegDeleteKey ( Key, L"Classes");
        RegCloseKey (Key);

    }
    if  (Ret == ERROR_SUCCESS )
    Ret = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,        // handle to an open key
                            L"SOFTWARE\\Wow6432Node\\Classes",  // address of subkey name
                            0,                        // reserved
                            NULL,                     // address of class string
                            REG_OPTION_NON_VOLATILE | REG_OPTION_OPEN_LINK | REG_OPTION_CREATE_LINK,  // special options flag
                            KEY_ALL_ACCESS | KEY_CREATE_LINK,           // desired security access
                            NULL,                     // address of key security structure
                            &Key,                     // address of buffer for opened handle
                            NULL                     // address of disposition value buffer
                            );

    if(Ret == ERROR_SUCCESS) {
        Ret = RegSetValueEx(
                            Key,
                            L"SymbolicLinkValue",
                            0,
                            REG_LINK,
                            (PBYTE)WOW64_32BIT_MACHINE_CLASSES_ROOT,
                            (DWORD ) (wcslen (WOW64_32BIT_MACHINE_CLASSES_ROOT) * sizeof (WCHAR))
                            );
        RegCloseKey(Key);
        if ( Ret != ERROR_SUCCESS ) {
            Wow64RegDbgPrint ( ("\nSorry! I couldn't create symbolic link to %S", WOW64_32BIT_MACHINE_CLASSES_ROOT));
            return FALSE;
        }
    }else {
        Wow64RegDbgPrint ( ("\nWarning!! SOFTWARE\\Wow6432Node\\Classes might be already there\n") );
        return FALSE;
    }

    return TRUE;
}


BOOL
PopulateReflectorTable ()
/*++

Routine Description:

    Populate the initial redirector table

Arguments:

    None.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/

{

    extern ISN_NODE_TYPE *ReflectorTable;
    extern ISN_NODE_TYPE *RedirectorTable;

    HKEY Key;
    LONG Ret;
    DWORD dwIndex=0;

    //
    // delete the entry first
    //

    SetWow64InitialRegistryLayout ();

    Ret = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,        // handle to an open key
                            (LPCWSTR ) WOW64_REGISTRY_SETUP_KEY_NAME_REL,  // address of subkey name
                            0,                        // reserved
                            NULL,                     // address of class string
                            REG_OPTION_NON_VOLATILE,  // special options flag
                            KEY_ALL_ACCESS,           // desired security access
                            NULL,                     // address of key security structure
                            &Key,                     // address of buffer for opened handle
                            NULL                     // address of disposition value buffer
                            );

    if (Ret != ERROR_SUCCESS ) {
        Wow64RegDbgPrint ( ("\nSorry!! couldn't open/create key list at %S", WOW64_REGISTRY_SETUP_REFLECTOR_KEY) );
        return FALSE;
    }


    //
    // Now Key point to the right location
    //

    for ( dwIndex=0;wcslen (RedirectorTable[dwIndex].NodeValue);dwIndex++) {
        if (RedirectorTable[dwIndex].Flag==0) { // write the node in the registry
             Ret = RegSetValueEx(
                            Key,
                            RedirectorTable[dwIndex].NodeName,
                            0,
                            REG_SZ,
                            (PBYTE)&RedirectorTable[dwIndex].NodeValue[0],
                            (ULONG)(wcslen (RedirectorTable[dwIndex].NodeValue)+1)*sizeof(WCHAR)
                            );
             if ( Ret != ERROR_SUCCESS ) {
                 Wow64RegDbgPrint ( ("\nSorry! couldn't write the key"));
                 RegCloseKey (Key);
                 return FALSE;
             }

        }
    }

    RegCloseKey (Key);



    //
    //  populate list for reflector
    //

    Ret = RegCreateKeyEx(
                            HKEY_LOCAL_MACHINE,        // handle to an open key
                            (LPCWSTR ) WOW64_REGISTRY_SETUP_REFLECTOR_KEY,  // address of subkey name
                            0,                        // reserved
                            NULL,                     // address of class string
                            REG_OPTION_NON_VOLATILE,  // special options flag
                            KEY_ALL_ACCESS,           // desired security access
                            NULL,                     // address of key security structure
                            &Key,                     // address of buffer for opened handle
                            NULL                     // address of disposition value buffer
                            );

    if (Ret != ERROR_SUCCESS ) {
        Wow64RegDbgPrint ( ("\nSorry!! couldn't open/create key list at %S", WOW64_REGISTRY_SETUP_REFLECTOR_KEY));
        return FALSE;
    }


    //
    // Now Key point to the right location
    //

    for ( dwIndex=0;wcslen (ReflectorTable[dwIndex].NodeValue);dwIndex++) {
        if (ReflectorTable[dwIndex].Flag==0) { // write the node in the registry
             Ret = RegSetValueEx(
                            Key,
                            ReflectorTable[dwIndex].NodeName,
                            0,
                            REG_SZ,
                            (PBYTE)&ReflectorTable[dwIndex].NodeValue[0],
                            (ULONG)((wcslen (ReflectorTable[dwIndex].NodeValue)*sizeof(WCHAR))+sizeof(UNICODE_NULL))
                            );
             if ( Ret != ERROR_SUCCESS ) {
                 Wow64RegDbgPrint ( ("\nSorry! couldn't write the key"));
                 RegCloseKey (Key);
                 return FALSE;
             }

        }
    }

    RegCloseKey (Key);

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\regremap\wow64reg\refhlpr.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    main.c

Abstract:

    This module will do the necessary things to setup initial registry for the redirection
    purpose.

//
//  Test case scenario
//      1. Open a ISN node and list content
//      2. Create a ISN node do 1.
//      3. Open a non ISN node and list
//      4. Create a non ISN node and list content
//

  Outstanding issue:
    reflector: If Key has been created on one side, we can reflect that on the other side.
               Deletion: Without any additional attribute it's impossible to track.

Author:

    ATM Shafiqul Khalid (askhalid) 18-Nov-1999

Revision History:

--*/


#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include <stdlib.h>
#include "wow64reg.h"
#include <assert.h>
#include "reflectr.h"

VOID
DbgPrint(
    PCHAR FormatString,
    ...
    );

#define REFLECTOR_ENABLE_KEY L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\WOW64\\Reflector Setup"

ISN_NODE_TYPE ReflectorTableStatic[ISN_NODE_MAX_NUM]={
    { { L"REFLECT1"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes"},0 },    // alias to the classes root on the user hives
    //{ { L"REFLECT2"}, {L"\\REGISTRY\\USER\\*\\Software\\Classes"},0 },    // the first '*' is the user's SID
    { { L"REFLECT3"}, {L"\\REGISTRY\\USER\\*_Classes"},0 },    // alias to the classes root on the user hives
    { { L"REFLECT4"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\Run"},0 },    // Runonce Key
    { { L"REFLECT5"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\RunOnce"},0 },    // Runonce Key
    { { L"REFLECT6"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\RunOnceEx"},0 },    // Runonce Key
    { { L"REFLECT7"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\COM3"},0 },    // COM+ Key
    { { L"REFLECT8"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\COM3"},0 },    // COM+ Key
    { { L"REFLECT9"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Ole"},0 },    // OLE Key
    { { L"REFLECT10"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Ole"},0 },    // OLE Key
    { { L"REFLECT11"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\EventSystem"},0 },    // EventSystem
    { { L"REFLECT12"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\EventSystem"},0 },    // EventSystem
    { { L"REFLECT13"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\RPC"},0 },    // RPC
    { { L"REFLECT14"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\RPC"},0 },    // RPC
    { { L"REFLECT15"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Wow6432Node\\Microsoft\\Windows\\CurrentVersion\\UnInstall"},0 },    // UnInstall Key
    { { L"REFLECT16"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\UnInstall"},0 },    // UnInstall Key
    //{ { L"REFLECT15"},  {L"\\REGISTRY\\MACHINE\\SYSTEM\\TEST"},0 },
    { {L""}, {L""} }
    };

ISN_NODE_TYPE RedirectorTableStatic[ISN_NODE_MAX_NUM]={
    //{ { L"REDIRECT1"},  {L"\\REGISTRY\\MACHINE\\SYSTEM\\TEST"},0 },
    { { L"REDIRECT2"}, {L"\\REGISTRY\\USER\\*\\Software\\Classes"},0 },    // the first '*' is the user's SID
    { { L"REDIRECT3"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes"},0 },    // CLS ROOT
    { { L"REDIRECT4"}, {L"\\REGISTRY\\MACHINE\\SOFTWARE"},0 },    // CLS ROOT
    { { L"REDIRECT5"}, {L"\\REGISTRY\\USER\\*_Classes"},0 },    // alias to the classes root on the user hives
    { {L""}, {L""} }
    };

ISN_NODE_TYPE *ReflectorTable = &ReflectorTableStatic[0]; // dynamically we can allocate later on.
ISN_NODE_TYPE *RedirectorTable = &RedirectorTableStatic[0];       // dynamically we can allocate later on.

ISN_NODE_TYPE TempIsnNode;

BOOL bInitialCopy  = FALSE;

VOID
SetInitialCopy ()
{
    bInitialCopy  = TRUE;
}

BOOL
ReflectSecurity (
    HKEY SrcKey,
    HKEY DestKey
    )
/*++

Routine Description:

  Copy security attribute from SrcKey to DestKey.

Arguments:

  SrcKey - Handle to a key..
  DestKey - handle to the destination key.

Return Value:

  TRUE if operation succeeded.
  FALSE otherwise. 

--*/
{

    PSECURITY_DESCRIPTOR SD;
    BYTE Buffer[2048]; // reflector only manages general purpose keys and will have smaller ACL
    

    LONG Ret, Len;
    LONG BufferLen = sizeof (Buffer);
    DWORD Count = 0;

    SD = (PSECURITY_DESCRIPTOR)Buffer;

    Len = BufferLen;
    Ret = RegGetKeySecurity( SrcKey, DACL_SECURITY_INFORMATION, SD, &Len);
    if (Ret == ERROR_INSUFFICIENT_BUFFER ) {

        SD = VirtualAlloc( NULL, Len, MEM_COMMIT, PAGE_READWRITE );
        if (SD != NULL) {

            BufferLen = Len;
            Ret = RegGetKeySecurity( SrcKey, DACL_SECURITY_INFORMATION, SD, &Len);
        } else SD = (PSECURITY_DESCRIPTOR)Buffer;
            
    }
    if (ERROR_SUCCESS == Ret )
        Ret = RegSetKeySecurity ( DestKey, DACL_SECURITY_INFORMATION, SD );
    Count +=Ret;
    

    Len = BufferLen;
    Ret = RegGetKeySecurity( SrcKey, GROUP_SECURITY_INFORMATION, SD, &Len);
    if (Ret == ERROR_INSUFFICIENT_BUFFER ) {

        if (SD != Buffer)
            VirtualFree (SD, 0,MEM_RELEASE);

        SD = VirtualAlloc( NULL, Len, MEM_COMMIT, PAGE_READWRITE );
        if (SD != NULL) {

            BufferLen = Len;
            Ret = RegGetKeySecurity( SrcKey, DACL_SECURITY_INFORMATION, SD, &Len);
        } else SD = (PSECURITY_DESCRIPTOR)Buffer;
            
    }
    if (ERROR_SUCCESS == Ret )
        Ret = RegSetKeySecurity ( DestKey, GROUP_SECURITY_INFORMATION, SD );
    Count +=Ret;
    


    Len = BufferLen;
    Ret = RegGetKeySecurity( SrcKey, OWNER_SECURITY_INFORMATION, SD, &Len);
    if (Ret == ERROR_INSUFFICIENT_BUFFER ) {

        if (SD != Buffer)
            VirtualFree (SD, 0,MEM_RELEASE);

        SD = VirtualAlloc( NULL, Len, MEM_COMMIT, PAGE_READWRITE );
        if (SD != NULL) {

            BufferLen = Len;
            Ret = RegGetKeySecurity( SrcKey, DACL_SECURITY_INFORMATION, SD, &Len);
        } else SD = (PSECURITY_DESCRIPTOR)Buffer;
            
    }
    if (ERROR_SUCCESS == Ret )
        Ret = RegSetKeySecurity ( DestKey, OWNER_SECURITY_INFORMATION, SD );
    Count +=Ret;
    

    Len = BufferLen;
    Ret = RegGetKeySecurity( SrcKey, SACL_SECURITY_INFORMATION, SD, &Len);
    if (Ret == ERROR_INSUFFICIENT_BUFFER ) {

        if (SD != Buffer)
            VirtualFree (SD, 0,MEM_RELEASE);

        SD = VirtualAlloc( NULL, Len, MEM_COMMIT, PAGE_READWRITE );
        if (SD != NULL) {

            BufferLen = Len;
            Ret = RegGetKeySecurity( SrcKey, DACL_SECURITY_INFORMATION, SD, &Len);
        } else SD = (PSECURITY_DESCRIPTOR)Buffer;
            
    }
    if (ERROR_SUCCESS == Ret )
        Ret = RegSetKeySecurity ( DestKey, SACL_SECURITY_INFORMATION, SD );
    Count +=Ret;
    
    if (SD != Buffer)
            VirtualFree (SD, 0,MEM_RELEASE);

    if (Count != 0) {
        return FALSE;
    }
    return TRUE;
}

BOOL
GetDefaultValue (
    HKEY  SrcKey,
    WCHAR *pBuff,
    DWORD *Len
    )
/*++

Routine Description:

  retrieve the default value.

Arguments:

  SrcKey - Handle to a key default value need to be retrieved.
  pBuff - receiving the default value.
  Len - size of the buffer.

Return Value:

  TRUE if it can retrieve the value, 
  FALSE otherwise.

--*/
{
    DWORD Ret;

    Ret = RegQueryValueEx(
                        SrcKey,            // handle to key to query
                        NULL,
                        NULL,
                        NULL,
                        (PBYTE) &pBuff[0],
                        Len);

    if (Ret != ERROR_SUCCESS )
        return FALSE;
    return TRUE;
}

BOOL
NonMergeableValueCLSID (
    HKEY SrcKey,
    HKEY DestKey
    )
/*++

Routine Description:

  determine if a key related to an association should be merged.
  Rule: if the association refer to a CLSID that has InprocServer don't merge that.
  .doc default attrib will have another key x, and x's default attribute might have 
  CLSID. Now that clsID need to have either LocalServer or need to be present on the 
  other side.

Arguments:

  SrcKey - Handle to a key that need to be checked.
  DestKey - handle to the destination key that will receive the update.

Return Value:

  TRUE if we shouldn't merge value.
  FALSE otherwise. //catter will merge value.

--*/
{
    WCHAR Name[_MAX_PATH];
    WCHAR Buff[_MAX_PATH];
    WCHAR *pStr;
    DWORD dwBuffLen = 256;

    HKEY hClsID;
    DWORD dwCount;
    DWORD Ret;
    DWORD dwFlag = 0;

    BOOL bCLSIDPresent = TRUE;

    //
    //  get name to the key.
    //  get default value
    //     open the key under SrcKey
    //     try CLSID if exist
    //                  open the CLSID and check for localserver
    //                  Merge the key
    //     try classid on dest.
    //


    dwBuffLen = sizeof (Name ) / sizeof (Name[0]);
    if (!HandleToKeyName ( SrcKey, Name, &dwBuffLen ))
        return TRUE;  // ignore merging at this point, fardown the association.

    pStr = wcsstr (Name, L"\\.");  // consider only association like .doc

    //
    //  don't fall in the association category
    //
    if (pStr == NULL)
        return FALSE;  // value key should be merged
    if (wcschr (pStr+1, L'\\') !=NULL )
        return FALSE;  // value key should be merged

    //
    //  get the default string
    //

    
    if ( !GetDefaultValue (SrcKey, Buff, &dwBuffLen) )
        return TRUE;  // failed don't merge, check for insufficient buffer.

    wcscat (Buff, L"\\CLSID");


    //
    // Check which side you are checking, if src is 32bit you need to pass 32bit flag
    //
    dwBuffLen = sizeof (Name ) / sizeof (Name[0]);
    if (!HandleToKeyName ( SrcKey, Name, &dwBuffLen )) //get the name
        return TRUE;

    if (!Is64bitNode (Name) )
        dwFlag = KEY_WOW64_32KEY;

    Ret = RegOpenKeyEx(
                        HKEY_CLASSES_ROOT,
                        Buff,
                        0,//OpenOption,
                        KEY_ALL_ACCESS | dwFlag,
                        &hClsID
                        );

    if ( Ret != ERROR_SUCCESS ) {
        if (Ret == ERROR_FILE_NOT_FOUND )
            return FALSE; // key doesn't exist 
        //
        // Try to find out if this assumption is true.
        // no CLSID you can merge because it doesn't associate any CLSID
        //
        return TRUE; //key might be bad or access denied.
    }

        dwBuffLen = sizeof (Buff ) / sizeof (Buff[0]);
        if ( !GetDefaultValue (hClsID, Buff, &dwBuffLen ) ) {

            RegCloseKey (hClsID);
            return TRUE;  // failed don't merge, couldn't get the CLSID
        }

        RegCloseKey (hClsID);
        //
        //  check if the CLSID has localserver
        //
        wcscpy (Name, L"CLSID\\");
        wcscat (Name, Buff );

        Ret = RegOpenKeyEx(
                        HKEY_CLASSES_ROOT,
                        Name,
                        0,//OpenOption,
                        KEY_ALL_ACCESS | dwFlag,
                        &hClsID
                        );

        if ( Ret != ERROR_SUCCESS )
            bCLSIDPresent = FALSE; //clsid on source doesn't exist and hence no local server, i.e., no handler
        else  {
            dwBuffLen = sizeof (Name ) / sizeof (Name[0]);
            if (!HandleToKeyName ( hClsID, Name, &dwBuffLen )) //get the name
               return TRUE;
        }

        if ( bCLSIDPresent ) {
            dwCount =0;
            MarkNonMergeableKey ( Buff, hClsID, &dwCount );
            RegCloseKey (hClsID);

            if (dwCount != 0)
                return FALSE;

            bCLSIDPresent = FALSE; // must be an InProc
        }

        //
        // Now chek of local server, there might be some case where 
        // on the source there is one local server that don't exist on the dest, 
        // but in the future, that will get copied over.
        // 
        //
        

        //
        // Get mirror Name
        //
        GetMirrorName (Name, Buff);

        if ( (hClsID = OpenNode (Buff)) != NULL ) {
            RegCloseKey (hClsID);
            return FALSE; // mirror side has the handler CLSID
        }

        return TRUE; // no don't merge value associated with the src key.

}

BOOL
GetKeyTime (
    HKEY SrcKey,
    ULONGLONG *Time
    )
/*++

Routine Description:

  Get last update time associated with a key.


Arguments:

  SrcKey - handle to the key.

Return Value:

  TRUE if function succeed, FALSE otherwise.

--*/
{

    DWORD Ret;
    FILETIME ftLastWriteTime;


    Ret  = RegQueryInfoKey(
                        SrcKey, // handle to key to query
                        NULL,   // address of buffer for class string
                        NULL,   // address of size of class string buffer
                        NULL,   // reserved
                        NULL,   // address of buffer for number of
                                // subkeys
                        NULL,   // address of buffer for longest subkey
                                                 // name length
                        NULL,   // address of buffer for longest class
                                // string length
                        NULL,   // address of buffer for number of value
                                // entries
                        NULL,   // address of buffer for longest
                                // value name length
                        NULL,   // address of buffer for longest value
                                // data length
                        NULL,
                                // address of buffer for security
                                // descriptor length
                        &ftLastWriteTime  // address of buffer for last write
                                // time
                        );

    if ( Ret == ERROR_SUCCESS ) {
        *Time = *(ULONGLONG *)&ftLastWriteTime;  //copy the value
        return TRUE;
    }

    return FALSE;
}



VOID
UpdateTable (
     ISN_NODE_TYPE *Table,
     ISN_NODE_TYPE *TempIsnNode
     )
{
    DWORD dwCount=0;
    BOOL Found = FALSE;

    if ( !wcslen (TempIsnNode->NodeName) || !wcslen (TempIsnNode->NodeValue) )
        return;

    for ( dwCount=0;wcslen (Table[dwCount].NodeValue);dwCount++) {
        if (wcscmp (Table[dwCount].NodeValue, TempIsnNode->NodeValue) == 0 ) {
            Table[dwCount].Flag=1;  //already in the registry
            Found = TRUE;
        }
    }

    if (!Found) {
            //update the table with the node
            if ( dwCount >= ISN_NODE_MAX_NUM ) {
                Wow64RegDbgPrint ( ("\nSorry! The table is full returning..............."));
                return;
            }

            Table[dwCount].Flag=1;
            wcscpy (Table[dwCount].NodeName, TempIsnNode->NodeName);
            wcscpy (Table[dwCount].NodeValue, TempIsnNode->NodeValue);

            Table[dwCount+1].NodeName[0] = UNICODE_NULL;
            Table[dwCount+1].NodeValue[0] = UNICODE_NULL;
    }
}

BOOL
IsGUIDStrUnderCLSID (
    LPCWSTR Key
    )
/*++

Routine Description:

  pIsGuid examines the string specified by Key and determines if it
  is the correct length and has dashes at the correct locations.

Arguments:

  Key - The string that may or may not be a GUID

Return Value:

  TRUE if Key is a GUID (and only a GUID), or FALSE if not.

--*/

{
    int i;
    PWCHAR p;

    if ( (wcslen (Key) != 38) || (*Key != L'{' )) {
        return FALSE;
    }

    for (i = 0, p = (PWCHAR)(Key+1) ; i<36 ; p++, i++) {
        if (*p == L'-') {
            if (i != 8 && i != 13 && i != 18 && i != 23) {
                return FALSE;
            }
        } else if (i == 8 || i == 13 || i == 18 || i == 23) {
            return FALSE;
        } else if (!iswxdigit( *p )) //ifnot alphaneumeric
            return FALSE;
    }

    if ( *p != L'}')
        return FALSE;

    return TRUE;
}

BOOL
CreateWow6432ValueKey (
    HKEY DestKey,
    WOW6432_VALUEKEY_TYPE ValueType
    )
/*++

Routine Description:

    Create a Wow6432ValueKey under the node.

Arguments:

    DestKey - Handle to the dest Key.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{
    WOW6432_VALUEKEY Value;
    ULONGLONG temp;
    SYSTEMTIME sSystemTime;
    FILETIME sFileTime;

    Value.ValueType = ValueType;
    Value.Reserve = 0;



    GetSystemTime (&sSystemTime);
    if ( SystemTimeToFileTime( &sSystemTime, &sFileTime) ==0 )
        return FALSE;

    Value.TimeStamp = *(ULONGLONG *)&sFileTime;
    Value.TimeStamp += (1000*10000*VALUE_KEY_UPDATE_TIME_DIFF); //100 nano sec interval


    if ( RegSetValueEx(
                            DestKey,
                            (LPCWSTR )WOW6432_VALUE_KEY_NAME,
                            0,
                            REG_BINARY,
                            (const PBYTE)&Value,
                            sizeof (WOW6432_VALUEKEY)
                            ) != ERROR_SUCCESS ) {

                            Wow64RegDbgPrint ( ("\nSorry! couldn't create wow6432valueKey "));
                            return FALSE;
    }

    if (! GetKeyTime (DestKey, &temp))
        return FALSE;

    if (Value.TimeStamp < temp || Value.TimeStamp > (temp+(1000*10000*VALUE_KEY_UPDATE_TIME_DIFF)) )
        Wow64RegDbgPrint ( ("\nError in the time Stamp!!!!"));

    return TRUE;

}

BOOL
GetWow6432ValueKey (
    HKEY hKey,
    WOW6432_VALUEKEY *pValue
    )
/*++

Routine Description:

    If the specified Key have the Wow6432Value key return the structure.

Arguments:

    hKey - Handle to the Key to search the value key.
    pValue - Receive the structure.

Return Value:

    TRUE if the value can be quaried and exist.
    FALSE otherwise.

--*/
{




    DWORD Type;
    DWORD Len = sizeof (WOW6432_VALUEKEY);
    DWORD Ret;

    memset ( pValue, 0, sizeof (WOW6432_VALUEKEY)); // zeroing buffer

    if ( (Ret=RegQueryValueEx(
                        hKey,                               // handle to key to query
                        (LPCWSTR )WOW6432_VALUE_KEY_NAME,   // address of name of value to query
                        0,                                  // reserved
                        &Type,                              // address of buffer for value type
                        (PBYTE)pValue,                             // address of data buffer
                        &Len                                // address of data buffer size
                        )) == ERROR_SUCCESS )
                        return TRUE;
    return FALSE;
}


BOOL
MarkSingleNonMergeableKey (
    HKEY hParent,
    LPCWSTR KeyName
    )
/*++

Routine Description:

    Mark a key non mergeable.

Arguments:

    KeyName -  Name of the key to mark.
    hParent -  Handle to the parent.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{
    HKEY hKey;
    DWORD Ret;

    WOW6432_VALUEKEY Value;

    if ( RegOpenKey (hParent, KeyName, &hKey ) != ERROR_SUCCESS )
        return FALSE;


    GetWow6432ValueKey ( hKey, &Value ); //todo check return value

    if ( Value.ValueType != None ) {

        RegCloseKey (hKey );
        return FALSE; // already marked with some other type
    }

    Ret = CreateWow6432ValueKey ( hKey, NonMergeable);
    RegCloseKey (hKey );
    return Ret;
}

BOOL
MarkNonMergeableKey (
    LPCWSTR KeyName,
    HKEY hKey,
    DWORD *pMergeableSubkey
    )
/*++

Routine Description:

    Check all the key under hKey if they qualify to be non mergeable. 
    If so mark them non mergeable.

Arguments:

    KeyName -  Name of the Key. Normally all following rules is for guid type parent.
                 If parent qualify, complete path name can be extracted to compare againest grammer.
    hKey       - Handle to a open Key.
    pMergeableSubkey - caller receive total number of mergeable subkey.


Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

    // pMergeableSubkey==0 and return TRUE means there is nothing to reflect.

--*/
{

    //
    // 1. Inproc server is always non mergeable
    // 2. If there is no local server everything is nonmergeable
    // 3. If there is both LocalServer32 and InprocServer32 skip Inprocserver
    // 4. InprocHandler32 ??
    // 5. Typelib  check if the GUID point to a right content that can be copied.
    //

    //
    // check if the name is guid
    //

    DWORD LocalServer = 0;
    DWORD InprocServer32 = 0;

    ISN_NODE_TYPE Node;
    DWORD dwIndex;
    DWORD Ret;
    WCHAR FullKeyName[_MAX_PATH];
    DWORD dwLen = _MAX_PATH;

    //
    // Check if the Key Fall under Classes\CLSID or \\Classes\\Wow6432Node\\CLSID
    //

    if ( !IsGUIDStrUnderCLSID ( KeyName ) )
        return TRUE; //No action is required

    if ( !HandleToKeyName ( hKey, FullKeyName, &dwLen )) {
        *pMergeableSubkey = 0;
        return TRUE; // FALSE
    }

    dwLen = wcslen (FullKeyName);
    if (dwLen <=39)
        return TRUE;
    dwLen-=39;  //skip the GUID because the handle point to guid

    if (!(_wcsnicmp ( FullKeyName+dwLen-14, L"\\Classes\\CLSID", 14) ==0 ||
        _wcsnicmp ( FullKeyName+dwLen-26, L"\\Classes\\Wow6432Node\\CLSID", 26) ==0 ||
        _wcsnicmp ( FullKeyName+dwLen-6, L"\\CLSID", 6) ==0)
        )
        return  TRUE;
    
    //don't reflect Key with name InProcServer32 or inprochandler
    if ( _wcsicmp (KeyName, (LPCWSTR)L"InprocServer32")==0 || _wcsicmp (KeyName, (LPCWSTR) L"InprocHandler32")==0) {

        *pMergeableSubkey = 0;
        return TRUE;
    }

    

    //Mark the inprocserver
    //Mark InprocHandler

    //if no localserver mark all

    //Enumerate all the Keys

    *pMergeableSubkey = 0;
    dwIndex = 0;
    LocalServer =0;

    for (;;) {

        DWORD Len = sizeof (Node.NodeValue)/sizeof (WCHAR);
        Ret = RegEnumKey(
                          hKey,
                          dwIndex,
                          Node.NodeValue,
                          Len
                          );
        if (Ret != ERROR_SUCCESS)
            break;

        dwIndex++;
        if ( !wcscmp  (Node.NodeValue, (LPCWSTR )NODE_NAME_32BIT) )
            continue;

        if ( !_wcsicmp (Node.NodeValue, (LPCWSTR)L"InprocServer32") || !_wcsicmp (Node.NodeValue, (LPCWSTR) L"InprocHandler32")) {
            MarkSingleNonMergeableKey ( hKey, Node.NodeValue );
            InprocServer32 = 1;
        } else if ( !_wcsicmp ((LPCWSTR)Node.NodeValue, (LPCWSTR)L"LocalServer32")) {
                    LocalServer=1;
                    (*pMergeableSubkey)++;
        }
        else (*pMergeableSubkey)++;

    }
    // if Ret != NomoreKey then you are in trouble

    //
    //  you might try 2nd pass to evaluate rest of the key
    //

    if ( LocalServer == 0 )
        *pMergeableSubkey = 0;  //there might be some copy key to merge

    return TRUE;
}

BOOL
ChangedInValueKey(
    HKEY DestKey,
    PWCHAR pValueName,
    PBYTE pBuff,
    DWORD BuffLen
    )
/*++

Routine Description:

    This routine check for a particular value key and return if that
    need to be copied into the destination key.

Arguments:

    DestKey - Handle to the dest Key.
    pValueName - Name of the value key need to be checked into DestKey
    pBuff - buffer that contain the value.
    BuffLen - length of the buffer

Return Value:

    TRUE if destination need to be updated.
    FALSE otherwise.

--*/
{
    BYTE TempBuff[256];
    DWORD Ret;
    DWORD Type;
    DWORD TempBuffLen = 256;

    Ret =RegQueryValueEx(
                        DestKey,
                        pValueName,
                        0,
                        &Type,
                        TempBuff,
                        &TempBuffLen
                        );
    if ( (Ret != ERROR_SUCCESS ) || (BuffLen != TempBuffLen ) )
        return TRUE;

    if (memcmp (TempBuff, pBuff, BuffLen) != 0)
        return TRUE;

    return FALSE;
}

BOOL
MergeK1K2Value (
    HKEY SrcKey,
    HKEY DestKey,
    DWORD dwFlag
    )
/*++

Routine Description:

    Copy value key from the node pointed by SrcKey to the DestKey skipping the special wow6432 node.

Arguments:

    SrcKey - Source Key Node.
    DestKey - Handle to the dest Key.
    dwFlag - option flag to merge value key.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{

    ISN_NODE_TYPE Node;
    DWORD dwIndex =0;
    DWORD Ret;

    WOW6432_VALUEKEY ValueSrc;
    WOW6432_VALUEKEY ValueDest;
    ULONGLONG TimeSrc;
    ULONGLONG TimeDest;

    DWORD CreateWowValueKey = FALSE;


    //
    // CopyValue
    //

    //
    // find the wow6432valuekey and interpret the case if value keys need to be copied.
    // Compare the same wow6432node from both Key.
    //

    GetWow6432ValueKey ( SrcKey, &ValueSrc);
    GetWow6432ValueKey ( DestKey, &ValueDest);


    if ( !GetKeyTime ( SrcKey, &TimeSrc)  || ! GetKeyTime ( DestKey, &TimeDest) ) {

        Wow64RegDbgPrint ( ("\nSorry! Couldn't get time stamp"));
        return FALSE;
    }


    if (!( dwFlag & DESTINATION_NEWLY_CREATED )) { //timestamp is always higher for newly created key by reflector

        //
        // check which one is new
        //
        if ( ValueDest.TimeStamp ==0 || ValueSrc.TimeStamp ==0 ) {

            //check only Key time stamp
            if ( TimeSrc < TimeDest ) return TRUE;

        } else if ( ValueSrc.TimeStamp > TimeSrc ||   //nothing has been changed on src
            ( TimeDest > TimeSrc ) //dest has newer valid stamp
            )
            return TRUE;  //nothing has been changed since last scan
    }

    if ( NonMergeableValueCLSID ( SrcKey, DestKey))
        return TRUE;

    //
    // Reflect security attributes
    //
    ReflectSecurity (SrcKey, DestKey);

    for (;;) {
        DWORD Type;
        DWORD Len1 =  sizeof(Node.NodeName);
        DWORD Len2 =  sizeof(Node.NodeValue);

                Ret = RegEnumValue(
                              SrcKey,
                              dwIndex,
                              Node.NodeName,
                              &Len1,
                              0,
                              &Type,
                              (PBYTE)&Node.NodeValue[0],
                              &Len2
                              );

                if ( Ret != ERROR_SUCCESS)
                    break;
                dwIndex++;

                //
                // skip the value if its wow6432 value key. Advapi will filter the key in the long run
                //

                if ( !wcscmp  (Node.NodeName, (LPCWSTR )WOW6432_VALUE_KEY_NAME) )
                    continue;
                //
                // check first if any changes in the value key
                //
                if (!ChangedInValueKey(
                            DestKey,
                            Node.NodeName,
                            (PBYTE)&Node.NodeValue[0],
                            Len2
                    ) )
                    continue;

                if  (dwFlag & PATCH_PATHNAME )
                    PatchPathName ( Node.NodeValue );

                Ret = RegSetValueEx(
                            DestKey,
                            Node.NodeName,
                            0,
                            Type,
                            (PBYTE)&Node.NodeValue[0],
                            Len2
                            );
             if ( Ret != ERROR_SUCCESS ) {

                 Wow64RegDbgPrint ( ("\nSorry! couldn't set Key value"));
             } else {

                 CreateWowValueKey = TRUE; //need to update the wow64keys.
                 if  (dwFlag & DELETE_VALUEKEY ) {

                     //delete the value key from the sources
                    RegDeleteValue (SrcKey, Node.NodeName);
                    dwIndex = 0; // start the loop again
                 }
             }
    }

    if ( dwIndex == 0 )   // for an empty key you need to write the value
        CreateWowValueKey = TRUE;

    if ( ( CreateWowValueKey) && (!(NOT_MARK_DESTINATION & dwFlag ) ) ) {

                    if ( !CreateWow6432ValueKey ( DestKey, Copy) )
                        Wow64RegDbgPrint ( ("\nSorry! Couldn't create wow6432ValueKey..."));
                }

    //
    // set attribute on the parent side that key has been reflected
    //
    if  ( CreateWowValueKey && !(NOT_MARK_SOURCE & dwFlag) )
    if ( !CreateWow6432ValueKey ( SrcKey, Reflected ) ) {
        Wow64RegDbgPrint ( ("\nSorry! couldn't create wow6432ValueKey on the source."));
        return FALSE;
    }

    return TRUE;
}


BOOL 
SpecialReflectableKey (
    HKEY SrcKey,
    HKEY DestKey
    ) 
/*++

Routine Description:

    This will determine if a certain key shouldn't be scanned for possible reflection.

Arguments:

    SrcKey - Source Key Node.
    DestKey - Handle to destination key.

Return Value:

    TRUE if the key shouldn't be scanned.
    FALSE otherwise.

--*/

{
    WCHAR Node[_MAX_PATH];
    DWORD dwLen = _MAX_PATH;
   

    if ( !HandleToKeyName ( SrcKey, Node, &dwLen ))
        return TRUE; // on error betrter skip the key

    //
    // Check if its a TypeLib
    //
    //
    // Hard coded no reflection for \Installer Key.
    //
    if (_wcsnicmp (Node, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Wow6432Node\\Installer", sizeof (L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Wow6432Node\\Installer")/sizeof (WCHAR) )==0)
        return TRUE;

    if (_wcsnicmp (Node, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Installer", sizeof (L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Wow6432Node\\Installer")/sizeof (WCHAR) )==0)
        return TRUE;


    if (_wcsicmp (Node, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\TypeLib")==0) {
        //ProcessTypeLib (SrcKey, DestKey, TRUE);
        return TRUE;
    }

    
    if (_wcsicmp (Node, L"\\REGISTRY\\MACHINE\\SOFTWARE\\Classes\\Wow6432Node\\TypeLib")==0) {
        //ProcessTypeLib (SrcKey, DestKey, FALSE);
        return TRUE;
    }


    

    return FALSE;
}

void
MergeK1K2 (
    HKEY SrcKey,
    HKEY DestKey,
    DWORD OptionFlag
    )
/*++

Routine Description:

    Copy contect from the node pointed by SrcKey to the DestKey skipping the special wow6432 node.

    Cases:
    1. Reflect everything from K1 to K2: done
    2. Reflect everything from K2 to K1: <TBD>
    3. Delete  everything from K1 which was a copy from K1 and doesn't exist over there <TBD>
    4. Delete  everything from K2 which was a copy from K2 and doesn't exist over there <TBD>

Arguments:

    SrcKey - Source Key Node.
    DestKey - Handle to the dest Key.
    OptionFlag - determine behavior of the reflection

Return Value:

    None.

--*/

{

    WCHAR Node[_MAX_PATH];
    DWORD dwIndex =0;
    DWORD Ret;
    DWORD dwNewOptionFlag = 0;

    HKEY Key11;
    HKEY Key21;


    //
    // Copy Values first
    //

    if ( SpecialReflectableKey (SrcKey, DestKey) )
        return;

    if ( GetReflectorThreadStatus () == PrepareToStop )
        return; // thread going to stop soon

    if  ( ! (OptionFlag & DELETE_FLAG ) )
        MergeK1K2Value ( SrcKey,DestKey, OptionFlag );

    //
    //  Copy subKeys
    //


    dwIndex = 0;
    for (;;) {

        DWORD ToMergeSubKey =1;
        BOOL MirrorKeyExist = FALSE;
        WOW6432_VALUEKEY ValueSrc;  

        DWORD Len = sizeof (Node)/sizeof (Node[0]);
        Ret = RegEnumKey(
                          SrcKey,
                          dwIndex,
                          Node,
                          Len
                          );
        if (Ret != ERROR_SUCCESS)
            break;

        dwIndex++;
        if ( !wcscmp  (Node, (LPCWSTR )NODE_NAME_32BIT) )
            continue;


        Ret = RegOpenKeyEx(SrcKey, Node, 0, KEY_ALL_ACCESS, &Key11);
        if (Ret != ERROR_SUCCESS) {
            continue;
        }

        if (!MarkNonMergeableKey (Node, Key11, &ToMergeSubKey ) ) {
            RegCloseKey (Key11);
            continue;
        }

        if ( ToMergeSubKey == 0 ){
            RegCloseKey (Key11);
            continue;
        } // no subkey to merge
       

        GetWow6432ValueKey ( Key11, &ValueSrc);
        if ( ValueSrc.ValueType == NonMergeable ) {
            RegCloseKey (Key11);
            continue;
        }

        //
        // Tryto open first if fail then create
        //
        if ((Ret = RegOpenKeyEx(DestKey, Node, 0, KEY_ALL_ACCESS, &Key21))
            == ERROR_SUCCESS)
            MirrorKeyExist = TRUE;

        //
        // Check if the mirror key is a original Key
        //
        if ( MirrorKeyExist )  {
            WOW6432_VALUEKEY ValueDest;
            GetWow6432ValueKey ( Key21, &ValueDest);
            if ( ( ValueDest.ValueType == None && ValueDest.TimeStamp!=0 ) ||
                ( ValueDest.ValueType == NonMergeable ) )
            {  //doesn't make any sense to merge down.
                printf ("\nClosing here...");
                RegCloseKey (Key11);
                RegCloseKey (Key21);
                continue;
            }

        }

        //
        // check the deletion case: if the dest isn't empty
        //

        if (!MirrorKeyExist) {  //The key doesn't exist on the other side

            //
            // See if the src key is a copy
            //
            

            //
            //  if its a copy you shouldn't try to create the key
            //  Rather you might delete the Key
            //
            if ( ValueSrc.ValueType == Copy || ValueSrc.ValueType == Reflected ) {

                RegCloseKey (Key11);
                //
                //  Delete the subKey
                //
                if ( DeleteKey( SrcKey, Node, 1) == ERROR_SUCCESS) {
                    dwIndex--; //you needn't to increase index otherwise skip
                    //Wow64RegDbgPrint ( ("\nDeleting copied Key: %S",Node.NodeValue));
                } else
                    Wow64RegDbgPrint ( ("\nCouldn't delete Key: %S, Error:%d",Node, Ret));

                continue;

            } else {

                //
                // if it has already been reflected do you need to create
                // Mark the Key as copied Key
                //
                if ( ValueSrc.ValueType == None ||  ValueSrc.ValueType == Reflected) {  //todo make sure reflected key should be there
                   if ( (Ret = RegCreateKey(DestKey, Node, &Key21) ) != ERROR_SUCCESS)
                       Wow64RegDbgPrint ( ("\nCouldn't create Key: %S, Error:%d",Node, Ret));
                   else {
                       MirrorKeyExist = TRUE; //just created the mirror key
                       dwNewOptionFlag = DESTINATION_NEWLY_CREATED;
                   }
                }
            }
        }

        if (!MirrorKeyExist) {
            RegCloseKey (Key11);
            continue;
        }

        MergeK1K2 ( Key11, Key21, OptionFlag |  dwNewOptionFlag );
        RegCloseKey (Key11);
        RegCloseKey (Key21);

    }
}

BOOL
MergeKeySrcDest(
    PWCHAR Src,
    PWCHAR Dest
    )
/*++

Routine Description:

    Copy contect from the src node to the dest  node.

Arguments:

    Src - Name of the src Node.
    Dest - Name of the dest Node.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{

    BOOL Ret = TRUE;
    HKEY Key1;
    HKEY Key2;

    Key1 = OpenNode (Src);
    if (Key1==NULL )
        return FALSE;

    Key2 = OpenNode (Dest );
    if (Key2==NULL ) {
        RegCloseKey (Key1);
        return FALSE;
    }

    MergeK1K2 (Key1, Key2, 0);  //you need to return right value

    RegCloseKey (Key1);
    RegCloseKey (Key2);

    //
    // if its a delete and Key2 is empty should you delete that?
    //

    return Ret;

}

BOOL
SyncNode (
    PWCHAR NodeName
    )
/*++

Routine Description:

    Sync registry from a given point.

Arguments:

    NodeName - Name of the registry from where the node need to be synced.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{

    WCHAR DestNode[_MAX_PATH];
    BOOL b64bitSide=TRUE;
    BOOL Ret = TRUE;

    DestNode[0] = UNICODE_NULL;

    //
    // must check the value if that exist
    //

    if ( Is64bitNode ( NodeName )) {

        Map64bitTo32bitKeyName ( NodeName, DestNode );
    } else {

        b64bitSide = FALSE;
        Map32bitTo64bitKeyName ( NodeName, DestNode );
    }

    //
    // if both name are same you can return immediately.
    //

    Wow64RegDbgPrint ( ("\nvalidating nodes in  SyncNode :%S==>\n\t\t\t%S", NodeName, DestNode));
    if (!wcscmp ( NodeName, DestNode ) )
        return TRUE; // nothing to do same thing

    Ret = MergeKeySrcDest( NodeName, DestNode );  //merge both way??
    return Ret & MergeKeySrcDest( DestNode, NodeName  );
    
}

BOOL
MergeContent (
    PWCHAR Chield,
    DWORD FlagDelete,
    DWORD dwMergeMode
    )
/*++

Routine Description:

    Copy contect from the parent node to chield node. Parent node would be just immediate
    parent. 

Arguments:

    Clield - Name of the chield with complete path to copy.
    FlagDelete - if this flag is set the its delete operation for all those reflected Keys.
    dwMergeMode - 0 means the destination node would be 32bit side
                  1 means the destination node would be 64bit side

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{

    ISN_NODE_TYPE Parent;
    PWCHAR p;

    HKEY Key1;
    HKEY Key2;

    p  = wcsstr (Chield, (LPCWSTR)NODE_NAME_32BIT);
    if ( p != NULL ) {
        wcsncpy (Parent.NodeValue, Chield, p-Chield-1);
        Parent.NodeValue[p-Chield-1] = UNICODE_NULL;

    } else return FALSE;



    Key1 = OpenNode (Parent.NodeValue);
    if (Key1==NULL )
        return FALSE;

    Key2 = OpenNode (Chield );
    if (Key2==NULL ) {
        RegCloseKey (Key1);
        return FALSE;
    }

    if ( dwMergeMode == 0 )      // 64bit side to 32bit side
        MergeK1K2 (Key1, Key2, 0 );
    else if ( dwMergeMode == 1)  // 32bit to 64bit side
        MergeK1K2 (Key2, Key1, 0 );

    RegCloseKey (Key1);
    RegCloseKey (Key2);

    return TRUE;

}

BOOL
ValidateNode (
    PWCHAR Parent,
    PWCHAR SubNodeName,
    DWORD Mode, //one means validate all node under parent and using subnode
    DWORD FlagDelete,
    DWORD dwMergeMode
    )
/*++

Routine Description:

    Validate node. if node exist skip if doesn't then create the node and then return.

Arguments:

    Parent - Name of the parent.
    SubNodeName - Name of the node under parent that need to be validated.
    Mode - 0 means Subnode is under the parent.
           1 means there were wild card and the subnode is under all key under parent.
    FlagDelete - if this flag is set then the content need to be deleted.
    dwMergeMode - 0 means the destination node would be 32bit side
                  1 means the destination node would be 64bit side


Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/

{
    PWCHAR SplitLoc;
    DWORD Ret;
    WCHAR  KeyName[256]; //this is just single node name
    WCHAR  TempIsnNode2[MAX_PATH];

    if (SubNodeName == NULL) {
        //then its only with the parent
        CheckAndCreateNode (Parent);

        //
        // you can try to copy here
        //

        return MergeContent ( Parent, FlagDelete, dwMergeMode);

    }

    if (SubNodeName[0] == UNICODE_NULL)
        return TRUE;

    if ( Mode == 1) {

        HKEY Key = OpenNode (Parent);
        //
        //  loop through all the subkey under parent
        //

        DWORD dwIndex =0;
        for (;;) {

            DWORD Len = sizeof ( KeyName)/sizeof (WCHAR);
            Ret = RegEnumKey(
                              Key,
                              dwIndex,
                              KeyName,
                              Len
                              );
            if (Ret != ERROR_SUCCESS)
                break;

            if (Parent[0] != UNICODE_NULL) {

                wcscpy ( TempIsnNode2, Parent);
                wcscat (TempIsnNode2, (LPCWSTR )L"\\");
                wcscat (TempIsnNode2, KeyName);

            } else   wcscpy (TempIsnNode2, KeyName);

            ValidateNode (TempIsnNode2, SubNodeName, 0, FlagDelete, dwMergeMode);

            dwIndex++;
        }
        
        if (ERROR_NO_MORE_ITEMS != Ret)
            return FALSE;

        RegCloseKey (Key);
        return TRUE;
    }
    //
    // No wild card here
    //
    if ( ( SplitLoc = wcschr (SubNodeName, L'*') ) == NULL ) {
        if (Parent[0] != UNICODE_NULL) {

            wcscpy ( TempIsnNode2, Parent);
            wcscat (TempIsnNode2, (LPCWSTR )L"\\");
            wcscat (TempIsnNode2, SubNodeName);

        } else
            wcscpy (TempIsnNode2, SubNodeName);

        return ValidateNode (TempIsnNode2, NULL, 0, FlagDelete, dwMergeMode);

    }

    assert ( *(SplitLoc-1) == L'\\');
    *(SplitLoc-1) = UNICODE_NULL;
    SplitLoc++;
    if (*SplitLoc == L'\\')
        SplitLoc++;

    if (Parent[0] != UNICODE_NULL) {
        wcscat (Parent, (LPCWSTR )L"\\");
        wcscat (Parent, SubNodeName);
    } else
        wcscpy (Parent, SubNodeName);

    return ValidateNode (Parent, SplitLoc, 1, FlagDelete, dwMergeMode); //mode 1 means loop within all

    //for any wildcard split the string

}

BOOL
Is64bitNode (
    WCHAR *pName
    )
/*++

Routine Description:

    Check if the given name is 64bit.

Arguments:

    pName - Name of the Key.


Return Value:

    TRUE if the name is 64bit.
    FALSE otherwise.

--*/
{
    PWCHAR pTemp;
    WCHAR  Buff[_MAX_PATH];
    WCHAR  WowNodeName[1+sizeof (NODE_NAME_32BIT)];

    wcscpy (WowNodeName, NODE_NAME_32BIT);
    _wcsupr (WowNodeName);
    wcscpy (Buff, pName );
    _wcsupr (Buff);


    if ( ( pTemp = wcsstr (Buff, WowNodeName) ) == NULL )
        return TRUE;

    if ( *(pTemp-1) != L'\\' ) // check that wow64 is not in the middle of name
        return TRUE;

    return FALSE;
}

BOOL
GetMirrorName (
    PWCHAR Name,
    PWCHAR MirrorName
    )
/*++

Routine Description:

    Return the Mirror name of the Key, ie., if the input is 64 bit it 
    will try to get 32bit name and vice versa.

Arguments:

    Name - name of the key.
    MirrorName - receive the mirror key name.


Return Value:

    TRUE if the function succeed.
    FALSE otherwise.  

--*/
{
     

    if ( Is64bitNode ( Name) )
        Map64bitTo32bitKeyName ( Name, MirrorName );
    else
        Map32bitTo64bitKeyName ( Name, MirrorName );
    return TRUE;
}

BOOL
CreateIsnNodeSingle(
    DWORD dwIndex
    )
/*++

Routine Description:

    This function basically start merging from the root of a given key.

Arguments:

    dwIndex - index to the reflector table.


Return Value:

    TRUE if the function succeed.
    FALSE otherwise.  

--*/
{
        ISN_NODE_TYPE IsnNode;
        BOOL b64bitSide=TRUE;

        Wow64RegDbgPrint ( ("\nvalidating nodes %S", ReflectorTable[dwIndex].NodeValue));
        //DbgPrint  ("\nvalidating nodes %S", ReflectorTable[dwIndex].NodeValue);

            if (_wcsnicmp (
                ReflectorTable[dwIndex].NodeValue,
                (LPCWSTR )WOW64_RUNONCE_SUBSTR,
                wcslen ((LPCWSTR )WOW64_RUNONCE_SUBSTR) ) == 0 ) {
                return HandleRunonce ( ReflectorTable[dwIndex].NodeValue );
            }


            if ( !wcschr (ReflectorTable[dwIndex].NodeValue, L'*') ) // no wildcard
                return SyncNode ( ReflectorTable[dwIndex].NodeValue );

            //
            // Check for runonce Key
            //

            wcscpy (TempIsnNode.NodeValue, ReflectorTable[dwIndex].NodeValue);
            wcscat (TempIsnNode.NodeValue, (LPCWSTR )L"\\");

            wcscat (TempIsnNode.NodeValue, (LPCWSTR )NODE_NAME_32BIT);

            Wow64RegDbgPrint ( ("\nCopying Key %S==>%S", IsnNode.NodeValue, TempIsnNode.NodeValue));
            ValidateNode (
                IsnNode.NodeValue,
                TempIsnNode.NodeValue,
                0,
                0, // last 0 means creation
                0  // Merge 64bit side to 32bit side
                );

            ValidateNode (
                IsnNode.NodeValue,
                TempIsnNode.NodeValue,
                0,
                0, // last 0 means creation
                1
                );
    return TRUE;

}

BOOL
CreateIsnNode()
/*++

Routine Description:

    This function basically start merging using all entry in the reflector table.

Arguments:

    None.


Return Value:

    TRUE if the function succeed.
    FALSE otherwise.  

--*/
{
    ISN_NODE_TYPE IsnNode;
    DWORD dwIndex;

    for ( dwIndex=0;wcslen (RedirectorTable[dwIndex].NodeValue);dwIndex++) {

            IsnNode.NodeValue[0] = UNICODE_NULL;
            wcscpy (TempIsnNode.NodeValue, RedirectorTable[dwIndex].NodeValue);
            wcscat (TempIsnNode.NodeValue, (LPCWSTR )L"\\");

            wcscat (TempIsnNode.NodeValue, (LPCWSTR )NODE_NAME_32BIT);
            Wow64RegDbgPrint ( ("\nCopying Key %S==>%S", IsnNode.NodeValue, TempIsnNode.NodeValue));
            ValidateNode (
                IsnNode.NodeValue,
                TempIsnNode.NodeValue,
                0,
                0, // last 0 means creation
                0  // Merge 64bit side to 32bit side
                );

            ValidateNode (
                IsnNode.NodeValue,
                TempIsnNode.NodeValue,
                0,
                0, // last 0 means creation
                1  // Merge 32bit side to 64bit side
                );
    }
    return TRUE;
}

BOOL
AllocateTable (
    HKEY Key,
    ISN_NODE_TYPE **Table
    )
/*++

Routine Description:

    This function will dynamically allocate memory for the reflector thread.
    Currently its implemented as a static table with around 30 entry.

Arguments:

    Key - entry in the registry that will have the initial table information.
    Table - Table that will point at the new location.


Return Value:

    TRUE if the function succeed.
    FALSE otherwise.  

--*/
{

    //
    // determine the number of subkey and that would determine the size
    //
    return TRUE;
}

BOOL
InitializeIsnTable ()
/*++

Routine Description:

    Initialize the NodeTable. It merge the value from the registry as well as
    hardcoded value

Arguments:

    None.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{
    HKEY Key;
    HKEY Key1;
    LONG Ret;
    DWORD dwIndex=0;

    Ret = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        (LPCWSTR ) WOW64_REGISTRY_SETUP_KEY_NAME_REL,
                        0,
                        KEY_ALL_ACCESS,
                        &Key
                        );

    if (Ret != ERROR_SUCCESS) {
        Ret = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        (LPCWSTR )L"SOFTWARE\\Microsoft",
                        0,
                        KEY_ALL_ACCESS,
                        &Key
                        );
        if (Ret != ERROR_SUCCESS )
            return FALSE;

        if ((Ret = RegOpenKeyEx (Key, (LPCWSTR )L"WOW64\\ISN Nodes", 0, KEY_ALL_ACCESS, &Key1)) != ERROR_SUCCESS )
            if ((Ret = RegCreateKey (Key, (LPCWSTR )L"WOW64\\ISN Nodes", &Key1)) != ERROR_SUCCESS) {
                RegCloseKey (Key);
                return FALSE;
            }

         RegCloseKey (Key);
         Key=Key1;
    }

    //if (!AllocateTable (Key, &RedirectorTable ) )
      //  return FALSE;

    //
    // Now Key point to the right location
    //

    RedirectorTable[0].NodeName[0]=UNICODE_NULL; //initialize the table with empty
    RedirectorTable[0].NodeValue[0]=UNICODE_NULL;

    for (;;) {
        DWORD Type, Len1 = sizeof ( TempIsnNode.NodeName );
        DWORD Len2 =  sizeof ( TempIsnNode.NodeValue );
                Ret = RegEnumValue(
                              Key,
                              dwIndex,
                              TempIsnNode.NodeName,
                              &Len1,
                              0,
                              &Type,
                              (PBYTE)&TempIsnNode.NodeValue[0],
                              &Len2
                              );
                //see if its in the table
                if ( Ret != ERROR_SUCCESS)
                    break;

                dwIndex++;
                if (Type != REG_SZ )
                    continue;

                UpdateTable (RedirectorTable, &TempIsnNode);
    }

    RegCloseKey (Key);
    return TRUE;
}


BOOL
InitializeIsnTableReflector ()
/*++

Routine Description:

    Initialize the NodeTable for the reflector. It merge the value from the registry as
    well as hardcoded value

Arguments:

    Mode - Operation mode
           0 - default, it update the table and rewrite the table in the registry.
           1 - means only update the table, don't overwrite in the registry.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{
    HKEY Key;
    HKEY Key1;
    LONG Ret;
    DWORD dwIndex=0;


    Ret = RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE,
                        (LPCWSTR ) WOW64_REGISTRY_SETUP_REFLECTOR_KEY,
                        0,
                        KEY_ALL_ACCESS,
                        &Key
                        );

    if (Ret != ERROR_SUCCESS ) {
        Wow64RegDbgPrint ( ("\nSorry!! couldn't open key list at %S", WOW64_REGISTRY_SETUP_REFLECTOR_KEY));
        return FALSE;
    }


    //
    // Now Key point to the right location
    //


    //if (!AllocateTable (Key, &ReflectorTable ) )
      //  return FALSE;

    ReflectorTable[0].NodeName[0]=UNICODE_NULL; //initialize the table with empty
    ReflectorTable[0].NodeValue[0]=UNICODE_NULL;

    for (;;) {
        DWORD Type, Len1 = sizeof ( TempIsnNode.NodeName );
        DWORD Len2 =  sizeof ( TempIsnNode.NodeValue );
                Ret = RegEnumValue(
                              Key,
                              dwIndex,
                              TempIsnNode.NodeName,
                              &Len1,
                              0,
                              &Type,
                              (PBYTE)&TempIsnNode.NodeValue[0],
                              &Len2
                              );
                //see if its in the table
                if ( Ret != ERROR_SUCCESS)
                    break;

                dwIndex++;
                if (Type != REG_SZ )
                    continue;

                UpdateTable (ReflectorTable, &TempIsnNode);

    }


    return TRUE;
}

BOOL
StartReflector ()
/*++

Routine Description:

    Start the reflector thread.

Arguments:

    None.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{
    HKEY hWowSetupKey;
    WCHAR RefEnableKey[256]; // only a defined key

    if ((hWowSetupKey = OpenNode (REFLECTOR_ENABLE_KEY))!=NULL) {
        RegCloseKey ( hWowSetupKey );
        return FALSE; //reflector couldn't be register because it's disabled now, because of reflection code in advapi.
    }

    //
    // Sync all CLDids
    //

    Wow64SyncCLSID();

    //
    // Now disable the reflector forcefully
    //
    wcscpy (RefEnableKey, REFLECTOR_ENABLE_KEY);
    if (CreateNode (RefEnableKey)) 
        return FALSE; //reflector couldn't be register because it's disabled now, because of reflection code in advapi.

    //
    // This will be called at the end of GUI mode setup and runonce key can be processed here.
    //

    //return FALSE; // eventully reflector service will go away.
    return RegisterReflector ();

}

BOOL
StopReflector ()
/*++

Routine Description:

    Stop the reflector thread.

Arguments:

    None.

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{
    return UnRegisterReflector ();

}

BOOL
PatchPathName (
    PWCHAR pName
    )
/*++

Routine Description:

    Patch pathname so that it point to the right location.
    The value might have multiple system32.

Arguments:

    pName - name to the path.

Return Value:

    TRUE if the function already patched the name.
    FALSE otherwise.

--*/

{
    WCHAR  pBuff[512+20];
    WCHAR  pBackup[512+20];
    PWCHAR pLoc;
    BOOL bRet = FALSE;

    DWORD Len;

    //if there is any system32 replace that with WOW64_SYSTEM_DIRECTORY_NAME
    PWCHAR pTemp;

    Len = wcslen ( pName );
    if (  Len > 512 || Len==0 )
        return FALSE; //too long or too small to patch

    wcscpy (pBackup, pName ); // backup the name to keep case as it was
    wcscpy (pBuff, pName );
    _wcsupr (pBuff);

    pLoc = pBuff;

    for (;;) {

        pTemp = wcsstr (pLoc, L"SYSTEM32");  //todo check if this should be case incensative
        if (pTemp == NULL )
            return bRet; //nothing to patch

        //
        // sanity check
        //
        Len = wcslen (L"SYSTEM32");
        if ( pTemp[Len] != UNICODE_NULL ) {
            if ( pTemp[Len] != L'\\' ) {
                pLoc++;
                continue; //only patch system32 or system32\?*
            }
        }

        wcscpy (pName + (pTemp-pBuff), WOW64_SYSTEM_DIRECTORY_NAME );
        wcscat (pName,  pBackup + (pTemp-pBuff)+wcslen (L"SYSTEM32")) ;
        pLoc++;
        bRet = TRUE;
    }

    return TRUE;
}

BOOL
HandleRunonce(
    PWCHAR pKeyName
    )
/*++

Routine Description:

    Its a special case handling runonce key in the registry. Like 32bit apps can register
    something that need to be reflected on the 64bit side so that right things happen.

Arguments:

    pKeyName - name of the key, there might be multiple one like run, runonce, runonceex

Return Value:

    TRUE if the function succeed.
    FALSE otherwise.

--*/
{

    WCHAR pName64[256];
    HKEY Key1;
    HKEY Key2;

    Map32bitTo64bitKeyName ( pKeyName, pName64 );

    if ( (Key1 = OpenNode ( pKeyName ) ) == NULL )
        return FALSE;

    if ( (Key2 = OpenNode ( pName64 ) ) == NULL ) {
        RegCloseKey (Key1);
        return FALSE;
    }

    Wow64RegDbgPrint ( ("\nCopying runonce Key %S", pKeyName));

    //
    // make source taking 64bit name
    // Read check the timestamp on the source and the dest.
    // If src is the newer copy content otherwise ignore it.
    // PatchContent
    //


    MergeK1K2Value ( Key1, Key2, PATCH_PATHNAME | DELETE_VALUEKEY | NOT_MARK_SOURCE | NOT_MARK_DESTINATION );
    

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\regremap\wow64reg\typelib.cpp ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    typelib.cpp

Abstract:

    This module will apply special rules reflecting typelib and other.

Author:

    ATM Shafiqul Khalid (askhalid) 16-Feb-2000

Revision History:

--*/

#include <windows.h>
#include <windef.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <shlwapi.h>
#include "wow64reg.h"
#include "reflectr.h"

BOOL 
ExistCLSID (
    PWCHAR Name,
    BOOL Mode
    )
/*++

Routine Description:

    This will do return if the given classID exist on 
    the destination, or even on the mirror side that can 
    happen after reflection

Arguments:

    Name - Name of the GUID including whole path.
    Mode - TURE check on the 64bit side
            FALSE check on the 32bit side.

Return Value:

    TRUE if the guid exist or might be copied after reflection.
    FALSE otherwise.

--*/
{
    WCHAR Buff[256];
    HKEY hClsID;

    DWORD dwBuffLen;
    DWORD dwCount =0;
    DWORD Ret;

        wcscpy (Buff, L"CLSID\\");
        wcscat (Buff, Name );
       
        Ret = RegOpenKeyEx(
                        HKEY_CLASSES_ROOT,
                        Buff,
                        0,//OpenOption,
                        KEY_ALL_ACCESS | ( (~Mode) & KEY_WOW64_32KEY),
                        &hClsID
                        );

        if ( Ret == ERROR_SUCCESS) {
            RegCloseKey (hClsID);
            return TRUE;  //ID is there
        }

        //open the other side of the registry
        Ret = RegOpenKeyEx(
                        HKEY_CLASSES_ROOT,
                        Buff,
                        0,//OpenOption,
                        KEY_ALL_ACCESS | ( (Mode) & KEY_WOW64_32KEY),
                        &hClsID
                        );
        

        if ( Ret != ERROR_SUCCESS) 
            return FALSE;
        
        dwBuffLen = sizeof (Buff ) / sizeof (Buff[0]);
        if (!HandleToKeyName ( hClsID, Buff, &dwBuffLen )) //get the name
            return FALSE;

        dwCount =0;
        MarkNonMergeableKey ( Buff, hClsID, &dwCount );
        RegCloseKey (hClsID);

        if (dwCount != 0)
            return TRUE;  //yepp you got it
        return FALSE;

        
}

BOOL
ReflectTypeLibVersion (
    HKEY KeyVersion,
    BOOL Mode
    )
/*++

Routine Description:

    This will do special treatment for typelib interfaces.

Arguments:

    KeyVersion - Source Key Node.
    Mode - TRUE - reflection from 64->32
           FALSE - reflection from 32->64
    

Return Value:

    TRUE if the typelib GUID version should be reflected.
    FALSE otherwise.

    Note: the inner loop executed 10,000 times on typical installation.

--*/
{
    WCHAR LocalID[256];
    WCHAR TypeLibPath [_MAX_PATH];
    DWORD dwLocalIdIndex=0;

    HKEY LocalIdKeyTemp;
    BOOL bReflectVersion = FALSE;
    DWORD Ret;

    for (;;) {

        DWORD Len = sizeof (LocalID)/sizeof (LocalID[0]);
        BOOL bReflectLocalId = FALSE;

        LocalID[0]=UNICODE_NULL;

        Ret = RegEnumKey(
                          KeyVersion,
                          dwLocalIdIndex,
                          LocalID,
                          Len
                          );
        if (Ret != ERROR_SUCCESS)
            break;

        dwLocalIdIndex++;
        //
        // Check if this ID has any special mark.
        //

        if (wcslen (LocalID) < (Len - 7) )
            wcscat ( LocalID, L"\\win32");
        else continue;

        Ret = RegOpenKeyEx(KeyVersion, LocalID, 0, KEY_ALL_ACCESS, &LocalIdKeyTemp);
        if (Ret != ERROR_SUCCESS) {
            continue;
        }

        {
             
            DWORD Type;
            HRESULT hr;
            ITypeLib *pTypeLib = NULL;

            Len = sizeof (TypeLibPath)/sizeof (TypeLibPath[0]);

            Ret =RegQueryValueEx(
                                LocalIdKeyTemp,
                                NULL,
                                0,
                                &Type,
                                (LPBYTE)&TypeLibPath[0],
                                &Len
                                );
            RegCloseKey (LocalIdKeyTemp);
            if ( Ret != ERROR_SUCCESS )
                break;
        //
        //  under the "win32" key you'll find a path name. Call oleaut32's LoadTypeLibEx() passing REGKIND_NONE, to get back an ITypeLib* corresponding to that file. 
        //

            
		    hr =  LoadTypeLibEx(TypeLibPath, REGKIND_NONE, &pTypeLib);	
		    
            if (SUCCEEDED(hr)) {

                DWORD Count, i;
                ITypeInfo *pTInfo = NULL;

                //
                //  call ITypeInfo::GetTypeInfoCount, and start calling ITypeLib::GetTypeInfo(), to enumerate all of the ITypeInfos inside the typelib 
                //
                Count = pTypeLib->GetTypeInfoCount ();

                //
                //  For each ITypeInfo, call ITypeInfo::GetTypeAttr() to get back a TYPEATTR struct. 
                //
                for (i=0; i<Count; i++ ) {
                    GUID guidClsid;
                    WCHAR buff[50];
                    //
                    //  In the TYPEATTR you'll find a GUID - that GUID is the one that oleaut32.dll will call OLE's CoCreateInstance on if an app loads the typelib and asks OLEAUT for an interface pointer based on a typeinfo. That GUID will be in HKLM\Software\Classes\CLSID, so we'll know if that interface is reflectable or not.
                    //
                    hr = pTypeLib->GetTypeInfo (i, &pTInfo);
                    if ( !(SUCCEEDED(hr)))
                        break;
                    else {

                        TYPEATTR *TypeAttr;

                        

                        hr = pTInfo->GetTypeAttr ( &TypeAttr);
                        if (SUCCEEDED ( hr )) {
                            guidClsid = TypeAttr->guid;

                            //if guid exis then reflect the whole guid

                             swprintf(buff,L"{%08X-%04X-%04X-%02X%02X-%02X%02X%02X%02X%02X%02X}",
                                    guidClsid.Data1, 
                                    guidClsid.Data2, 
                                    guidClsid.Data3,
                                   guidClsid.Data4[0], guidClsid.Data4[1],
                                   guidClsid.Data4[2], guidClsid.Data4[3],
                                   guidClsid.Data4[4], guidClsid.Data4[5],
                                   guidClsid.Data4[6], guidClsid.Data4[7]);
                             //printf ("\nCurrent string is ..%S [%d %d %d]", buff,dwIndex, dwVersionIndex,  dwLocalIdIndex);
                             

                             if (ExistCLSID ( buff, !Mode ))
                                 bReflectLocalId = TRUE;
                        }

                        pTInfo->Release();
                        pTInfo = NULL;
                    }

                    if ( bReflectLocalId )
                        break;
                } //for-enum all type info    
			    
		    }//if- loadTypeLib
		   
		    if(pTypeLib)
			    pTypeLib->Release();
            pTypeLib = NULL;
        } //block-

        //
        //Check if you need to reflect this Key;
        //
        if ( bReflectLocalId )
            bReflectVersion = TRUE;
        
    } //for enum ID

    return bReflectVersion;
}

BOOL 
ProcessTypeLib (
    HKEY SrcKey,
    HKEY DestKey,
    BOOL Mode
    )
/*++

Routine Description:

    This will do special treatment for typelib interfaces.

Arguments:

    SrcKey - Source Key Node.
    DestKey - Handle Destination  key
    Mode - TRUE - reflection from 64->32
           FALSE - reflection from 32->64

Return Value:

    TRUE if the key shouldn't be scanned.
    FALSE otherwise.

    Note: the inner loop executed 10,000 times on typical installation.

--*/

{
   

    
    WCHAR GuidName[256];  // This one going to be GUID so not _MAX_PATH
    WCHAR VersionName[256];

    DWORD dwIndex =0;
    DWORD dwVersionIndex=0;

    DWORD Ret;

    HKEY KeyGuidInterface;
    HKEY KeyVersion;

    

    //
    // enumeate all of the GUIDs under HKLM\Software\Classes\Typelib 
    //
    
    dwIndex = 0;
    for (;;) {

        DWORD Len = sizeof (GuidName)/sizeof (GuidName[0]);
        Ret = RegEnumKey(
                          SrcKey,
                          dwIndex,
                          GuidName,
                          Len
                          );
        if (Ret != ERROR_SUCCESS)
            break;

        dwIndex++;
        
        Ret = RegOpenKeyEx(SrcKey, GuidName, 0, KEY_ALL_ACCESS, &KeyGuidInterface);
        if (Ret != ERROR_SUCCESS) {
            continue;
        }
        //
        // if not GUID continue
        //
        //
        // Check if there is any special stamp on that key.
        //

        //
        //  enumerate all of the version numbers under each GUID 
        //
        dwVersionIndex = 0;
        for (;;) {

            DWORD Len = sizeof (VersionName)/sizeof (VersionName[0]);
            Ret = RegEnumKey(
                              KeyGuidInterface,
                              dwVersionIndex,
                              VersionName,
                              Len
                              );
            if (Ret != ERROR_SUCCESS)
                break;

            dwVersionIndex++;
        
            Ret = RegOpenKeyEx(KeyGuidInterface, VersionName, 0, KEY_ALL_ACCESS, &KeyVersion);
            if (Ret != ERROR_SUCCESS) {
                continue;
            }
            //
            //  under each version number, enumerate all of the locale IDs. In the case of Proj2000, it's version 4.3, locale id 0. 
            //
            //  Any optimization based on one way reflection?
            //

            if ( ReflectTypeLibVersion ( KeyVersion, Mode ) ){
                HKEY MirrorKeyVersion;
                //
                // Open or create destination
                // Call the API
                //
                
                wcscat (GuidName, L"\\");
                wcscat (GuidName, VersionName);
                
                Ret = RegCreateKeyEx(
                            DestKey,        // handle to an open key
                            GuidName,  // address of subkey name
                            0,                        // reserved
                            NULL,                     // address of class string
                            REG_OPTION_NON_VOLATILE,  // special options flag
                            KEY_ALL_ACCESS,           // desired security access
                            NULL,                     // address of key security structure
                            &MirrorKeyVersion,                     // address of buffer for opened handle
                            NULL                     // address of disposition value buffer
                            );
                if ( ERROR_SUCCESS == Ret ) {
                    MergeK1K2 (KeyVersion, MirrorKeyVersion, FALSE );
                    RegCloseKey (MirrorKeyVersion);
                    //printf ("\n #### key has been reflected ... %S",GuidName );
                }

            } else
                //printf ("\n %%%%%%%%%%%%%%%%%%%%%%%% not reflected %S", GuidName);
            RegCloseKey (KeyVersion);


        } //for enum version
        RegCloseKey (KeyGuidInterface);

    }//for - enum GUID

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\regremap\wow64reg\wow64ipc.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    wow64ipc.c

Abstract:

    This module will do the communication machanism among different processes that need
    to interact with the wow64 services, like winlogon will notify wow64svc.

Author:

    ATM Shafiqul Khalid (askhalid) 22-Mar-2000

Revision History:

--*/


#include <windows.h> 
#include <memory.h> 
#include <wow64reg.h>
#include <stdio.h>
#include "reflectr.h"
 
#define SHMEMSIZE 4096 
 
LPVOID lpvMem = NULL; // pointer to shared memory
HANDLE hMapObject = NULL;

HANDLE hWow64Event = NULL;
HANDLE hWow64Mutex = NULL;

LIST_OBJECT *pList = NULL;

//SECURITY_DESCRIPTOR sdWow64SharedMemory;
//SECURITY_ATTRIBUTES saWow64SharedMemory;

BOOL
Wow64CreateLock (
    DWORD dwOption
    )
/*++

Routine Description:

    Create or open Event wow64 service need to check.

Arguments:

    dwOption - 
        OPEN_EXISTING_SHARED_MEMORY  -- shouldn't be the first process to create this.

Return Value:

    TRUE if the function has successfully created/opened the memory.
    FALSE otherwise.

--*/

{
    hWow64Mutex =  CreateMutex(
                                NULL, // SD
                                FALSE,// initial owner
                                WOW64_SVC_REFLECTOR_MUTEX_NAME // object name
                                );
    if ( hWow64Mutex == NULL )
        return FALSE;

    if ( GetLastError() != ERROR_ALREADY_EXISTS && dwOption == OPEN_EXISTING_SHARED_RESOURCES) {

        Wow64CloseLock ();
        return FALSE;
    }

    return TRUE;

}

VOID
Wow64CloseLock ()

/*++

Routine Description:

    Close wow64 service event.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if ( NULL != hWow64Mutex )
        CloseHandle ( hWow64Mutex );
    hWow64Mutex = NULL;
}
 
Wow64CreateEvent (
    DWORD dwOption,
    HANDLE *hEvent
    )
/*++

Routine Description:

    Create or open Event wow64 service need to check.

Arguments:

    dwOption - 
        OPEN_EXISTING_SHARED_MEMORY  -- shouldn't be the first process to create this.

Return Value:

    TRUE if the function has successfully created/opened the memory.
    FALSE otherwise.

--*/

{
    *hEvent = NULL;

    hWow64Event =  CreateEvent(
                                NULL, // SD
                                TRUE, // reset type
                                FALSE,// initial state
                                WOW64_SVC_REFLECTOR_EVENT_NAME // object name
                                );
    if ( hWow64Event == NULL )
        return FALSE;

    if ( GetLastError() != ERROR_ALREADY_EXISTS && dwOption == OPEN_EXISTING_SHARED_RESOURCES) {

        Wow64CloseEvent ();
        return FALSE;
    }

    *hEvent = hWow64Event;
    return TRUE;

}

VOID
Wow64CloseEvent ()

/*++

Routine Description:

    Close wow64 service event.

Arguments:

    None.

Return Value:

    None.

--*/
{
    if ( NULL != hWow64Event )
        CloseHandle ( hWow64Event );
    hWow64Event = NULL;
}

BOOL
LockSharedMemory ()
{
    DWORD Ret;
    Ret = WaitForSingleObject( hWow64Mutex, 1000*5*60); // 5 min is good enough
    
    //
    //  now you can access shared memory
    //
    //Log information if error occur

    if ( Ret == WAIT_OBJECT_0 || Ret == WAIT_ABANDONED ) 
        return TRUE;

    //
    // check for abandaned case
    //

    return FALSE;

}

BOOL
UnLockSharedMemory ()
{
    if ( ReleaseMutex ( hWow64Mutex ) ) 
        return TRUE;

    return FALSE;
}

BOOL 
CreateSharedMemory (
    DWORD dwOption
    )
/*++

Routine Description:

    Create or open shared memory, used by different process.

Arguments:

    dwOption - 
        OPEN_EXISTING_SHARED_MEMORY  -- shouldn't be the first process to create this.

Return Value:

    TRUE if the function has successfully created/opened the memory.
    FALSE otherwise.

--*/

{ 
    BOOL fInit;

    
    //if (!InitializeSecurityDescriptor( &sdWow64SharedMemory, SECURITY_DESCRIPTOR_REVISION ))
      //  return FALSE;

    // saWow64SharedMemory.nLength = sizeof ( SECURITY_ATTRIBUTES );
    // saWow64SharedMemory.bInheritHandle =  TRUE; 
    // saWow64SharedMemory.lpSecurityDescriptor = &sdWow64SharedMemory; 
  





            // Create a named file mapping object.
 
            hMapObject = CreateFileMapping( 
                INVALID_HANDLE_VALUE, // use paging file
                NULL, //&saWow64SharedMemory,                 // no security attributes
                PAGE_READWRITE,       // read/write access
                0,                    // size: high 32-bits
                SHMEMSIZE,            // size: low 32-bits
                SHRED_MEMORY_NAME );     // name of map object

            if (hMapObject == NULL) 
                return FALSE; 
 
            // The first process to attach initializes memory.
 
            fInit = (GetLastError() != ERROR_ALREADY_EXISTS); 

            if (fInit && dwOption == OPEN_EXISTING_SHARED_RESOURCES ) {

                CloseSharedMemory ();
                return FALSE; // no shared memory exist
            }
 
            // Get a pointer to the file-mapped shared memory.
 
            pList = (LIST_OBJECT *) MapViewOfFile( 
                hMapObject,     // object to map view of
                FILE_MAP_WRITE, // read/write access
                0,              // high offset:  map from
                0,              // low offset:   beginning
                0);             // default: map entire file
            if (pList == NULL) 
                return FALSE; 
 
            // Initialize memory if this is the first process.
 
            if (fInit) {
                memset( ( PBYTE )pList, '\0', SHMEMSIZE); 
                pList->MaxCount = ( SHMEMSIZE - sizeof ( LIST_OBJECT ) ) / (LIST_NAME_LEN*sizeof (WCHAR)); 
            
            }

            //
            //  Also initialize all the locking and synchronization object
            //

            if ( !Wow64CreateLock ( dwOption ) ) {
                CloseSharedMemory ();
                return FALSE;
            }
 
            return TRUE;
}

VOID
CloseSharedMemory ()
{ 

            if (pList != NULL )
                UnmapViewOfFile(pList); 
            pList = NULL;
 
            // Close the process's handle to the file-mapping object.
 
            if ( hMapObject!= NULL ) 
                CloseHandle(hMapObject); 
            hMapObject = NULL;

            Wow64CloseLock ();
            
} 

// initially try to transfer only one object

BOOL
EnQueueObject (
    PWCHAR pObjName,
    WCHAR  Type
    )
/*++

Routine Description:

    Put an object name in the queue.

Arguments:

    pObjName - Name of the object to put in the quque.
    Type - L: Loading hive
           U: Unloading Hive

Return Value:

    TRUE if the function has successfully created/opened the memory.
    FALSE otherwise.

--*/
{
    // lpvMem check if this value is NULL
    // wait to get the lock on shared memory

    DWORD Len;
    DWORD i;

    if ( pList == NULL )
        return FALSE;

    Len = wcslen (pObjName);
    if (Len == 0 || Len > 256 )
        return FALSE;

    if (!LockSharedMemory ())
        return FALSE;

    if ( pList->Count == pList->MaxCount ) {
        UnLockSharedMemory ();
        return FALSE;
    }

    for ( i=0; i<pList->MaxCount; i++) {
        if (pList->Name[i][0] == UNICODE_NULL ) break;
    }

    if ( i == pList->MaxCount ) {
        UnLockSharedMemory ();
        return FALSE;
    }


    wcscpy ( pList->Name[i], pObjName);
    pList->Count++;
    pList->Name[i][LIST_NAME_LEN-1] = Type;

    UnLockSharedMemory ();
    SignalWow64Svc ();

    // write data

    // release data
    return TRUE;
}

BOOL
DeQueueObject (
    PWCHAR pObjName,
    PWCHAR  Type
    )
/*++

Routine Description:

    Get a name of object from the queue.

Arguments:

    pObjName - Name of the object that receive the name.
    Type - L: Loading hive
           U: Unloading Hive

Return Value:

    TRUE if the function has successfully created/opened the memory.
    FALSE otherwise.

--*/
{
    // lpvMem check if this value is NULL
    // wait to get the lock on shared memory

    DWORD Len;
    DWORD i;

    if ( pList == NULL )
        return FALSE;


    if (!LockSharedMemory ())
        return FALSE;

    if ( pList->Count == 0 ) {
        UnLockSharedMemory ();
        return FALSE;
    }

    for ( i=0; i < pList->MaxCount; i++) {
        if (pList->Name[i][0] != UNICODE_NULL ) break;
    }

    if ( i == pList->MaxCount ) {
        UnLockSharedMemory ();
        return FALSE;
    }

    wcscpy ( pObjName, pList->Name[i]);
    pList->Name[i][0] = UNICODE_NULL;

    pList->Count--;
    *Type = pList->Name[i][LIST_NAME_LEN-1];

    UnLockSharedMemory ();
    //SignalWow64Svc (); 

    // write data

    // release data
    return TRUE;
}
 
//signal wowservice to receive the data.

BOOL
SignalWow64Svc ()
{
   //this might be a simple event trigger or set event

    if ( SetEvent ( hWow64Event ) )
        return TRUE;

    return FALSE;

}

BOOL 
CheckAdminPriviledge ()
/*++

Routine Description:

    Check if the running thread has admin priviledge.

Arguments:

    None.

Return Value:

    TRUE if the calling thread has admin proviledge.
    FALSE otherwise.

--*/
{
 
    BOOL bRetCode = FALSE;
/*
    HANDLE TokenHandle;
    BOOL b;
    DWORD ReturnLength;

    PTOKEN_USER TokenInfo;

    //
    // If we're impersonating, use the thread token, otherwise
    // use the process token.
    //

    PTOKEN_USER Result = NULL;

    b = OpenThreadToken(
            GetCurrentThread(),
            TOKEN_QUERY,
            FALSE,
            &TokenHandle
            );

    if (!b) {

        if (GetLastError() == ERROR_NO_TOKEN) {

            //
            // We're not impersonating, try the process token
            //

            b = OpenProcessToken(
                    GetCurrentProcess(),
                    TOKEN_QUERY,
                    &TokenHandle
                    );

            if (!b) {

                return FALSE;
            }

        } else {

            //
            // We failed for some unexpected reason, return NULL and
            // let the caller figure it out if he so chooses.
            //

            return FALSE;
        }
    }

    ReturnLength = GetSidLengthRequired( SID_MAX_SUB_AUTHORITIES ) + sizeof( TOKEN_USER );

    TokenInfo = (PTOKEN_USER)malloc( ReturnLength );

    if (TokenInfo != NULL) {

        b = GetTokenInformation (
               TokenHandle,
               TokenGroups,
               TokenInfo,
               ReturnLength,
               &ReturnLength
               );

        if (b) {

            Result = TokenInfo;

        } else {

            if (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

                //
                // Reallocate TokenInfo
                //

                free( TokenInfo );

                TokenInfo = (PTOKEN_USER)malloc( ReturnLength );

                if (TokenInfo != NULL) {

                    b = GetTokenInformation (
                           TokenHandle,
                           TokenGroups,
                           TokenInfo,
                           ReturnLength,
                           &ReturnLength
                           );

                    if (b) {

                        Result = TokenInfo;
                    }

                } else {

                    SetLastError( ERROR_NOT_ENOUGH_MEMORY );
					return FALSE;
                }
            }
        }

    } else {

        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
		return FALSE;
    }


	DWORD dwSidSize = 0;
	SID_NAME_USE SidType;
	DWORD strSize = 80;
	WCHAR  str [80];
	SID_NAME_USE sidType;
	BOOL bProceede = TRUE;

	DWORD dwRet = LookupAccountName ( 
									NULL, 
									L"Administrators", 
									NULL, 
									&dwSidSize, 
									str, 
									&strSize, 
									&sidType );

	if ( dwSidSize == 0)
	if ( !dwRet  ) {
		cBase.PrintErrorWin32 ( GetLastError () );
		bProceede = FALSE;

	}

	PSID psid = NULL;

	if ( bProceede )
	if ( dwSidSize ) {
		psid = (PSID) GlobalAlloc ( GPTR, dwSidSize );

		if ( psid == NULL )
			bProceede = FALSE;
		else {
			strSize = 80;
			dwRet = LookupAccountName ( 
										NULL, 
										L"Administrators", 
										psid,                                                                                                                                                                                                                                                                                                  
										&dwSidSize, 
										str, 
										&strSize, 
										&sidType );
			if ( ! dwRet )
				bProceede = FALSE;
		}
	}

	//now check
	

	if ( Result == NULL ) 
		bProceede = FALSE;


	TOKEN_GROUPS *pGroups = ( TOKEN_GROUPS *)Result;
	
	
	if ( bProceede )
	for ( int i=0; i < pGroups->GroupCount; i++ ) {
		if ( EqualSid ( pGroups->Groups [i].Sid, psid ) ){
			bRetCode = TRUE;
			break;
		}
	};

	if ( psid != NULL )
		GlobalFree ( psid );

	if ( Result != NULL )
		free ( Result );

*/
    return bRetCode;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\regremap\wow64reg\wow64reg.c ===
/*++

Copyright (c) 1999  Microsoft Corporation

Module Name:

    wow64reg.c

Abstract:

    This module implement some APIs for client who need to access registry in a mix way. 
    The client need to link againest wow64reg.lib files. The available APIs has been defined
    in the wow64reg.h files.

    The possible scenario is

    1. 32 bit Apps need to access 64 bit registry key.
    2. 64 bit Apps need to access 32-bit registry key.
    3. The actual redirected path from a given path.

Author:

    ATM Shafiqul Khalid (askhalid) 10-Nov-1999

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>  
#include <nturtl.h>  
#include <windows.h>
#include <stdio.h>
#include <ntregapi.h>
#include <stdlib.h>

#include "regremap.h"
#include "wow64reg.h"
#include "reflectr.h"

#define WOW6432NODELEN 15
VOID
GetPatchedName (
    PWCHAR Dest,
    LPCTSTR Source,
    DWORD  Count
    )
/*++

Routine Description:

    This function patches 32bit equivalent name from a given name and location to patch from.
    XX\ ==>> XX\Wow6432Node count==3
    XX  ==>> XX\Wow6432Node count==2
    XX\PP ==>> XX\Wow6432Node count ==3


Arguments:

    Dest - receive the result.
    Source - Name to patch
    Count - where to patch the string.

Return Value:

    None.

--*/

{
    BOOL  PerfectIsnNode = FALSE;

    if (Count) {

        wcsncpy ( Dest, Source, Count );
        if (Dest[Count-1] != L'\\' ) {

            Dest[Count] = L'\\';   // at the end case
            Count++;
            PerfectIsnNode = TRUE;
        }
    }

    wcscpy ( Dest+Count, NODE_NAME_32BIT );

    if ( !PerfectIsnNode ) {

        wcscat ( Dest, L"\\");
        wcscat ( Dest, Source + Count );
    }
    //
    //  Make sure that the patched key are not on the exempt list.
    //
}



LONG 
Wow64RegOpenKeyEx(
  HKEY hKey,         
  LPCTSTR lpSubKey,  
  DWORD ulOptions,   
  REGSAM samDesired, 
  PHKEY phkResult    
)
/*++

Routine Description:

    This is the equivalent of RegOpenExW to access reggistry in the mix mode. This code will be 
    compiled only for 64bit environment. In the 32bit environment WOW64 will take care of everything.
    We are nor worried much about performance hit due to opening key twice or retranslating path.
    Because only few people will access the registry in the mix mode.


Arguments:

    hKey -  handle to open key
    lpSubKey - address of name of subkey to open
    ulOptions - typically 0.
    samDesired - security access mask might have WOW64_RES flag
        KEY_WOW64_32KEY - this will open 32bit equivalent key disregarding 
                                   the process.
        KEY_WOW64_64KEY - this will open 64bit equivalent key disregarding the process.

    phkResult -address of handle to open key

Return Value:

    WIN32 Error code.

--*/
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING Parent;

    WCHAR ParentName[WOW64_MAX_PATH+WOW6432NODELEN];
    WCHAR TempName[WOW64_MAX_PATH+WOW6432NODELEN];
    DWORD dwBuffLen = WOW64_MAX_PATH;
    DWORD dwSubKeyLen;
    DWORD dwParentKeyLen;

    WCHAR NullString;
    
    
    PWCHAR p32bitNode;
    PWCHAR pPatchLoc;
    PWCHAR pDivider;

    NTSTATUS st;
    BOOL bHandle64 = TRUE; // assume all the handle passed in is 64bit.


    if( lpSubKey == NULL ) {
        NullString = UNICODE_NULL;
        lpSubKey = &NullString;
    }

    //
    // check if the WOW64 reserve bit set. If none of them is set we can't proceede.
    //

    dwSubKeyLen = wcslen (lpSubKey); 

    if (dwSubKeyLen > WOW64_MAX_PATH)
        return ERROR_INVALID_PARAMETER;

    {
        BOOL
        AdvapiAccessDenied (
        HKEY hKey, 
        const WCHAR * lpSubKey, 
        PWCHAR ParentName, 
        DWORD dwLen,
        DWORD *pAccessMask,
        BOOL Flag
        );

        if ( samDesired & KEY_WOW64_32KEY){
            if (AdvapiAccessDenied (
                                    hKey, 
                                    lpSubKey, 
                                    ParentName, 
                                    WOW64_MAX_PATH,
                                    &samDesired,
                                    FALSE
                                    ))
                return ERROR_ACCESS_DENIED;
            }
    }


    if (!(samDesired & KEY_WOW64_RES) ) {
        //
        //  return ERROR_INVALID_PARAMETER; try to be optimistic
        //

        return    RegOpenKeyEx (
                                hKey,         
                                lpSubKey, 
                                ulOptions,  
                                samDesired,
                                phkResult   
                               );
    }
    
    if( hKey == NULL ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    //  makesure that subkey doesn't have the special wow string
    //
    
    if ( ( p32bitNode = wcsistr ((PWCHAR)lpSubKey, NODE_NAME_32BIT)) != NULL ) {
        //
        // if access 64bit hive compress the subkey, if 32bit hive just pass as it is.
        //
        if ( samDesired & KEY_WOW64_64KEY ) {
            wcscpy (ParentName, lpSubKey);
            p32bitNode = ParentName + ( p32bitNode- lpSubKey);
            wcscpy ( p32bitNode, p32bitNode + NODE_NAME_32BIT_LEN );
        }

        return    RegOpenKeyEx (
                                hKey,         
                                ParentName, 
                                ulOptions,  
                                samDesired & (~KEY_WOW64_RES),
                                phkResult   
                               );
    }

    //
    //  Check predefined handle like HKEY_CLASSES_ROOT if so you only need to patch subkey
    //
    //
    //  Client must pass meaningful handle to this function.
    //

    if ( hKey == HKEY_CLASSES_ROOT ) {
        wcscpy ( ParentName, MACHINE_CLASSES_ROOT);

    } else if ( !HandleToKeyName ( hKey, ParentName, &dwBuffLen ) ) { 
        //
        // should we recoved from buffer overflow. We are not going to support all possible combination.
        //
        return ERROR_INVALID_HANDLE;
    }
      
    //
    //  If parent has already been patched just call the RegOpenKeyEx for 32bit open
    //

    if ((p32bitNode = wcsistr (ParentName, NODE_NAME_32BIT)) != NULL ) {
        
        //
        //  [todo] do you need to make sure that the substring mustbe the subkey 
        //  for an ISN node on 64bit registry to satisfy this condition.
        //  if we assume that noy key will have this name then the checking is 
        //  good enough.
        //

        bHandle64 = FALSE;  // it's not handle to 64 bit Key        
    }

    //
    // Get complete qualified path to do sanity check.
    //

    dwParentKeyLen = wcslen(ParentName);
    if (( dwParentKeyLen + dwSubKeyLen ) > WOW64_MAX_PATH )
        return ERROR_INVALID_PARAMETER;

    
    pDivider = ParentName + dwParentKeyLen + 1; //point to the divider location
    *(pDivider-1)= L'\\';
    wcscpy (pDivider, (PWCHAR)lpSubKey);
    if (IsExemptRedirectedKey(ParentName, TempName)) {
        //
        // If the path is on the exempt list we access 64bit hive
        //
        samDesired = (samDesired & (~KEY_WOW64_RES)) | KEY_WOW64_64KEY; //make sure access 64bit hive
    }

    if ( ( bHandle64 && (samDesired  & KEY_WOW64_64KEY ) )    // if totally 64
        || ( !bHandle64 && (samDesired  & KEY_WOW64_32KEY ) ) // if totally 32 
        || !IsIsnNode (ParentName, &pPatchLoc) ) {            // if not a ISN node don't care

        return    RegOpenKeyEx (
                                hKey,        
                                lpSubKey, 
                                ulOptions,  
                                samDesired & (~KEY_WOW64_RES),
                                phkResult   
                               );
    }

    //
    //  Now it might be mix mode access
    //
    if ( pPatchLoc >= pDivider ) {

        //
        //  patching only the subkey will be good enough
        //

        if ( samDesired  & KEY_WOW64_64KEY ) {  // want to access 64bit just disregard

            wcscpy ( ParentName, lpSubKey );
        } else  {

             
            GetPatchedName (ParentName,lpSubKey, (DWORD)(pPatchLoc-pDivider) );
        }

        return   RegOpenKeyEx (
                                hKey,        
                                ParentName, 
                                ulOptions,  
                                samDesired & (~KEY_WOW64_RES),
                                phkResult   
                               );
    } else {

        if ( samDesired  & KEY_WOW64_64KEY ) {  // want to access 64bit just disregard

            if (p32bitNode != NULL)   //compress
                wcscpy ( p32bitNode, p32bitNode + NODE_NAME_32BIT_LEN );
            RtlInitUnicodeString (&Parent, ParentName );
        } else  {

            GetPatchedName (TempName,ParentName, (DWORD)(pPatchLoc-ParentName));
            RtlInitUnicodeString (&Parent, TempName );
        }

        
        InitializeObjectAttributes (&Obja, 
                                    &Parent, 
                                    OBJ_CASE_INSENSITIVE, 
                                    NULL, 
                                    NULL
                                    );

        samDesired &= (~KEY_WOW64_RES);
        st = NtOpenKey (phkResult, samDesired, &Obja);

        if ( !NT_SUCCESS(st))
                    return RtlNtStatusToDosError (st);
        return 0;
    }
    
}

LONG 
Wow64pRegCreateKeyEx(
  HKEY hKey,                // handle to an open key
  LPCWSTR lpSubKey,         // address of subkey name
  DWORD Reserved,           // reserved
  LPWSTR lpClass,           // address of class string
  DWORD dwOptions,          // special options flag
  REGSAM samDesired,        // desired security access
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                            // address of key security structure
  PHKEY phkResult,          // address of buffer for opened handle
  LPDWORD lpdwDisposition,   // address of disposition value buffer
  WCHAR *ParentName
)
 
/*++

Routine Description:

    An existing registry key may be opened, or a new one created,
    with NtCreateKey.

    If the specified key does not exist, an attempt is made to create it.
    For the create attempt to succeed, the new node must be a direct
    child of the node referred to by KeyHandle.  If the node exists,
    it is opened.  Its value is not affected in any way.

    Share access is computed from desired access.

    NOTE:

        If CreateOptions has REG_OPTION_BACKUP_RESTORE set, then
        DesiredAccess will be ignored.  If the caller has the
        privilege SeBackupPrivilege asserted, a handle with
        KEY_READ | ACCESS_SYSTEM_SECURITY will be returned.
        If SeRestorePrivilege, then same but KEY_WRITE rather
        than KEY_READ.  If both, then both access sets.  If neither
        privilege is asserted, then the call will fail.

Arguments:

    hKey - Handle to a currently open key or one of the following predefined reserved 
    handle values: 
                HKEY_CLASSES_ROOT
                HKEY_CURRENT_CONFIG
                HKEY_CURRENT_USER
                HKEY_LOCAL_MACHINE
                HKEY_USERS

    The key opened or created by the RegCreateKeyEx function is a subkey of the key 
    identified by the hKey parameter. 

    lpSubKey  - Pointer to a null-terminated string specifying the name of a subkey 
    that this function opens or creates. The subkey specified must be a subkey of the 
    key identified by the hKey parameter. This subkey must not begin with the backslash 
    character ('\'). This parameter cannot be NULL. 

    Reserved -Reserved; must be zero. 
    
    lpClass - Pointer to a null-terminated string that specifies the class (object type) 
    of this key. This parameter is ignored if the key already exists. No classes are 
    currently defined; applications should pass a null string. 

    dwOptions  - Specifies special options for the key. This parameter can be one of the 
    following values. 
        REG_OPTION_NON_VOLATILE This key is not volatile. This is the default. The 
            information is stored in a file and is preserved when the system is restarted. 
        REG_OPTION_VOLATILE     
        REG_OPTION_BACKUP_RESTORE  Windows NT/2000: If this flag is set, the function 
            ignores  the samDesired parameter and attempts to open the key with the access 
            required to backup or restore the key. If the calling thread has the 
            SE_BACKUP_NAME privilege enabled, the key is opened with 
            ACCESS_SYSTEM_SECURITY and KEY_READ access. If the calling thread 
            has the SE_RESTORE_NAME privilege enabled, the key is opened with 
            ACCESS_SYSTEM_SECURITY and KEY_WRITE access. 
            If both privileges are enabled, the key has the combined accesses 
            for both privileges.  

    samDesired  - Specifies an access mask that specifies the desired security access 
    for the new key. This parameter can be a combination of the following values:
        KEY_ALL_ACCESS      Combination of KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, 
                            KEY_NOTIFY, KEY_CREATE_SUB_KEY, KEY_CREATE_LINK, 
                            and KEY_SET_VALUE access. 
        KEY_CREATE_LINK     Permission to create a symbolic link. 
        KEY_CREATE_SUB_KEY  Permission to create subkeys. 
        KEY_ENUMERATE_SUB_KEYS Permission to enumerate subkeys. 
        KEY_EXECUTE         Permission for read access. 
        KEY_NOTIFY          Permission for change notification. 
        KEY_QUERY_VALUE     Permission to query subkey data. 
        KEY_READ            Combination of KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, and KEY_NOTIFY access. 
        KEY_SET_VALUE       Permission to set subkey data. 
        KEY_WRITE           Combination of KEY_SET_VALUE and KEY_CREATE_SUB_KEY access. 
                            
        Security access mask might also have WOW64_RES flag
        KEY_WOW64_32KEY     this will open 32bit equivalent key disregarding 
                                   the process.
        KEY_WOW64_64KEY     this will open 64bit equivalent key disregarding the process.


    lpSecurityAttributes  -  Pointer to a SECURITY_ATTRIBUTES structure that determines 
    whether the returned handle can be inherited by child processes. If 
    lpSecurityAttributes is NULL, the handle cannot be inherited. 


    phkResult  - Pointer to a variable that receives a handle to the opened or 
    created key. When you no longer need the returned handle, call the RegCloseKey 
    function to close it. 

    lpdwDisposition - Pointer to a variable that receives one of the following 
    disposition values: Value Meaning  REG_CREATED_NEW_KEY The key did not exist 
    and was created. REG_OPENED_EXISTING_KEY The key existed and was simply 
    opened without being changed. If lpdwDisposition is NULL, no disposition 
    information is returned. 

Return Values:
    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is a nonzero error code defined in WINERROR.H. 



--*/
{
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING Parent;

    WCHAR TempName[WOW64_MAX_PATH+WOW6432NODELEN];
    DWORD dwBuffLen = WOW64_MAX_PATH;
    DWORD dwSubKeyLen;
    DWORD dwParentKeyLen;

    
    
    PWCHAR p32bitNode;
    PWCHAR pPatchLoc;
    PWCHAR pDivider;

    NTSTATUS st;
    BOOL bHandle64 = TRUE; // assume all the handle passed in is 64bit.

    //
    // check if the WOW64 reserve bit set. If none of them is set we can't proceede.
    //

    dwSubKeyLen = wcslen (lpSubKey);

    if (dwSubKeyLen > WOW64_MAX_PATH)
        return ERROR_INVALID_PARAMETER;


    if (!(samDesired & KEY_WOW64_RES) ) {
        //
        //  return ERROR_INVALID_PARAMETER; try to be optimistic
        //

        return    RegCreateKeyEx (
                                  hKey,                // handle to an open key
                                  lpSubKey,            // address of subkey name
                                  Reserved,            // reserved
                                  lpClass,             // address of class string
                                  dwOptions,           // special options flag
                                  samDesired,          // desired security access
                                  lpSecurityAttributes,
                                                       // address of key security structure
                                  phkResult,           // address of buffer for opened handle
                                  lpdwDisposition      // address of disposition value buffer
                                );

    }
    
    if( hKey == NULL ) {
        return ERROR_INVALID_HANDLE;
    }

    //
    //  makesure that subkey doesn't have the special wow string
    //
    if ( ( p32bitNode = wcsistr ((PWCHAR)lpSubKey, NODE_NAME_32BIT)) != NULL ) {
        //
        // if access 64bit hive compress the subkey, if 32bit hive just pass as it is.
        //
        if ( samDesired & KEY_WOW64_64KEY ) {
            wcscpy (ParentName, lpSubKey);
            p32bitNode = ParentName + ( p32bitNode- lpSubKey);
            wcscpy ( p32bitNode, p32bitNode + NODE_NAME_32BIT_LEN );
        }

        return    RegCreateKeyEx (
                                  hKey,                // handle to an open key
                                  lpSubKey,            // address of subkey name
                                  Reserved,            // reserved
                                  lpClass,             // address of class string
                                  dwOptions,           // special options flag
                                  samDesired & (~KEY_WOW64_RES),          // desired security access
                                  lpSecurityAttributes,
                                                       // address of key security structure
                                  phkResult,           // address of buffer for opened handle
                                  lpdwDisposition      // address of disposition value buffer
                                );
    }

    //
    //  Check predefined handle like HKEY_CLASSES_ROOT if so you only need to patch subkey
    //
    //
    //  Client must pass meaningful handle to this function.
    //

    if ( hKey == HKEY_CLASSES_ROOT ) {
        wcscpy ( ParentName, MACHINE_CLASSES_ROOT);

    } else if ( !HandleToKeyName ( hKey, ParentName, &dwBuffLen ) ) { 
        //
        // should we recoved from buffer overflow. We are not going to support all possible combination.
        //
        return ERROR_INVALID_HANDLE;
    }
      
    //
    //  If parent has already been patched just call the RegOpenKeyEx for 32bit open
    //

    if ((p32bitNode = wcsistr (ParentName, NODE_NAME_32BIT)) != NULL ) {
        
        //
        //  [todo] do you need to make sure that the substring mustbe the subkey 
        //  for an ISN node on 64bit registry to satisfy this condition.
        //  if we assume that noy key will have this name then the checking is 
        //  good enough.
        //

        bHandle64 = FALSE;  // it's not handle to 64 bit Key        
    }

    //
    // Get complete qualified path to do sanity check.
    //

    dwParentKeyLen = wcslen(ParentName);
    if (( dwParentKeyLen + dwSubKeyLen ) > WOW64_MAX_PATH )
        return ERROR_INVALID_PARAMETER;

    pDivider = ParentName + dwParentKeyLen + 1; //point to the divider location
    *(pDivider-1)= L'\\';
    wcscpy (pDivider, (PWCHAR)lpSubKey);
    if (IsExemptRedirectedKey(ParentName, TempName)) {
        //
        // If the path is on the exempt list we access 64bit hive
        //
        samDesired = (samDesired & (~KEY_WOW64_RES)) | KEY_WOW64_64KEY; //make sure access 64bit hive
    }

    if ( ( bHandle64 && (samDesired  & KEY_WOW64_64KEY ) )    // if totally 64
        || ( !bHandle64 && (samDesired  & KEY_WOW64_32KEY ) ) // if totally 32 
        || !IsIsnNode (ParentName, &pPatchLoc) ) {            // if not a ISN node don't care

        return    RegCreateKeyExW (
                                  hKey,                // handle to an open key
                                  lpSubKey,            // address of subkey name
                                  Reserved,            // reserved
                                  lpClass,             // address of class string
                                  dwOptions,           // special options flag
                                  samDesired & (~KEY_WOW64_RES), // desired security access
                                  lpSecurityAttributes,
                                                       // address of key security structure
                                  phkResult,           // address of buffer for opened handle
                                  lpdwDisposition      // address of disposition value buffer
                                );
    }

    //
    //  Now it might be mix mode access
    //
    if ( pPatchLoc >= pDivider ) {

        //
        //  patching only the subkey will be good enough
        //

        if ( samDesired  & KEY_WOW64_64KEY ) {  // want to access 64bit just disregard

            wcscpy ( ParentName, lpSubKey );
        } else  {

             
            GetPatchedName (ParentName,lpSubKey, (DWORD)(pPatchLoc-pDivider) );
        }

        return RegCreateKeyExW (
                                  hKey,                // handle to an open key
                                  ParentName,            // address of subkey name
                                  Reserved,            // reserved
                                  lpClass,             // address of class string
                                  dwOptions,           // special options flag
                                  samDesired & (~KEY_WOW64_RES), // desired security access
                                  lpSecurityAttributes,
                                                       // address of key security structure
                                  phkResult,           // address of buffer for opened handle
                                  lpdwDisposition      // address of disposition value buffer
                                );

    } else {

        HKEY hNewParent = NULL; 
        LONG Ret;
        PWCHAR pSubKey;

        // 
        // get new handle on the parent and then create the child
        //


        if ( samDesired  & KEY_WOW64_64KEY ) {  // want to access 64bit just disregard

            if (p32bitNode != NULL)  {//compress 

                *(p32bitNode-1) = UNICODE_NULL;
                wcscpy ( p32bitNode, p32bitNode + NODE_NAME_32BIT_LEN + 
                    (p32bitNode[NODE_NAME_32BIT_LEN]==L'\\'? 1:0));
            }

            pSubKey = p32bitNode;
            RtlInitUnicodeString (&Parent, ParentName );

        } else  {

            
            pSubKey = pPatchLoc;     

            GetPatchedName (TempName,ParentName, (DWORD)(pPatchLoc-ParentName));
            TempName[pPatchLoc-ParentName+NODE_NAME_32BIT_LEN]=UNICODE_NULL; //repatch

            RtlInitUnicodeString (&Parent, TempName );
        }

        
        InitializeObjectAttributes (&Obja, 
                                    &Parent, 
                                    OBJ_CASE_INSENSITIVE, 
                                    NULL, 
                                    NULL
                                    );

        samDesired &= (~KEY_WOW64_RES);

        //
        //  if key doesn't exist try to create
        //  Try to avoid using NtOpenKey rather use RegOpenKey
        //

        st = NtOpenKey (&hNewParent, 
                        MAXIMUM_ALLOWED, 
                        &Obja); 

        if ( !NT_SUCCESS(st))
                    return RtlNtStatusToDosError (st); 

        return   RegCreateKeyExW (
                                  hNewParent,          // handle to an open key
                                  pSubKey,             // address of subkey name
                                  Reserved,            // reserved
                                  lpClass,             // address of class string
                                  dwOptions,           // special options flag
                                  samDesired & (~KEY_WOW64_RES), // desired security access
                                  lpSecurityAttributes,
                                                       // address of key security structure
                                  phkResult,           // address of buffer for opened handle
                                  lpdwDisposition      // address of disposition value buffer
                                );
        NtClose (hNewParent);
        return 0;
        
    }
    
}

DWORD 
GetExistingParentLevel (
    PWCHAR Path
    )
{
    NTSTATUS st;
    HANDLE  hKey;
    HANDLE  hKeyCreate;
    OBJECT_ATTRIBUTES Obja;
    UNICODE_STRING KeyName;
    PWCHAR pTrace;
    PWCHAR p;



    pTrace = Path+wcslen (Path); //pTrace point at the end of path
    p=pTrace;

    for (;;) {
        RtlInitUnicodeString (&KeyName, Path);
        InitializeObjectAttributes (&Obja, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL );

        st = NtOpenKey (&hKey, KEY_WRITE | KEY_READ, &Obja);

        if ( st == STATUS_OBJECT_NAME_NOT_FOUND ) {
            //backtrack until you hit the line
            while ( *p != L'\\' && p!= Path)
                p--;

            //LOGPRINT( (ERRORLOG, "\nTest Code[%S]",p ));
            if ( p == Path ) break;
            *p = UNICODE_NULL;
            continue;
        }
        break;
    }

    if (!NT_SUCCESS(st)) {
        return 0;
    }

    //
    //  Point to the code
    //
    return wcslen (Path);
}

BOOL
UpdateKeyTagWithLevel ( 
    HKEY hKey,
    DWORD Tag,
    DWORD dwLevel, 
    PWCHAR ParentName 
    )
{
    PWCHAR p;
    HKEY hKeyTemp;

    UpdateKeyTag(hKey, Tag);

    if ( dwLevel == 0) {
        return TRUE;
    }
    p = &ParentName [dwLevel];

    if (*p != L'\\')
        return FALSE;

    for (;;) {
        while (*(++p) != L'\\' && *p != UNICODE_NULL)
            ;
        if (*p == L'\\')
            *p = UNICODE_NULL;
        else 
            return TRUE;

        //DbgPrint ("Updating Key Tag [%S]", ParentName);
        hKeyTemp = OpenNode (ParentName);
        UpdateKeyTag(hKeyTemp, Tag);
        NtClose (hKeyTemp);
        *p = L'\\';
    }
}

LONG 
Wow64RegCreateKeyEx(
  HKEY hKey,                // handle to an open key
  LPCWSTR lpSubKey,         // address of subkey name
  DWORD Reserved,           // reserved
  LPWSTR lpClass,           // address of class string
  DWORD dwOptions,          // special options flag
  REGSAM samDesired,        // desired security access
  LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                            // address of key security structure
  PHKEY phkResult,          // address of buffer for opened handle
  LPDWORD lpdwDisposition   // address of disposition value buffer
)
 
/*++

Routine Description:

    An existing registry key may be opened, or a new one created,
    with NtCreateKey.

    If the specified key does not exist, an attempt is made to create it.
    For the create attempt to succeed, the new node must be a direct
    child of the node referred to by KeyHandle.  If the node exists,
    it is opened.  Its value is not affected in any way.

    Share access is computed from desired access.

    NOTE:

        If CreateOptions has REG_OPTION_BACKUP_RESTORE set, then
        DesiredAccess will be ignored.  If the caller has the
        privilege SeBackupPrivilege asserted, a handle with
        KEY_READ | ACCESS_SYSTEM_SECURITY will be returned.
        If SeRestorePrivilege, then same but KEY_WRITE rather
        than KEY_READ.  If both, then both access sets.  If neither
        privilege is asserted, then the call will fail.

Arguments:

    hKey - Handle to a currently open key or one of the following predefined reserved 
    handle values: 
                HKEY_CLASSES_ROOT
                HKEY_CURRENT_CONFIG
                HKEY_CURRENT_USER
                HKEY_LOCAL_MACHINE
                HKEY_USERS

    The key opened or created by the RegCreateKeyEx function is a subkey of the key 
    identified by the hKey parameter. 

    lpSubKey  - Pointer to a null-terminated string specifying the name of a subkey 
    that this function opens or creates. The subkey specified must be a subkey of the 
    key identified by the hKey parameter. This subkey must not begin with the backslash 
    character ('\'). This parameter cannot be NULL. 

    Reserved -Reserved; must be zero. 
    
    lpClass - Pointer to a null-terminated string that specifies the class (object type) 
    of this key. This parameter is ignored if the key already exists. No classes are 
    currently defined; applications should pass a null string. 

    dwOptions  - Specifies special options for the key. This parameter can be one of the 
    following values. 
        REG_OPTION_NON_VOLATILE This key is not volatile. This is the default. The 
            information is stored in a file and is preserved when the system is restarted. 
        REG_OPTION_VOLATILE     
        REG_OPTION_BACKUP_RESTORE  Windows NT/2000: If this flag is set, the function 
            ignores  the samDesired parameter and attempts to open the key with the access 
            required to backup or restore the key. If the calling thread has the 
            SE_BACKUP_NAME privilege enabled, the key is opened with 
            ACCESS_SYSTEM_SECURITY and KEY_READ access. If the calling thread 
            has the SE_RESTORE_NAME privilege enabled, the key is opened with 
            ACCESS_SYSTEM_SECURITY and KEY_WRITE access. 
            If both privileges are enabled, the key has the combined accesses 
            for both privileges.  

    samDesired  - Specifies an access mask that specifies the desired security access 
    for the new key. This parameter can be a combination of the following values:
        KEY_ALL_ACCESS      Combination of KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, 
                            KEY_NOTIFY, KEY_CREATE_SUB_KEY, KEY_CREATE_LINK, 
                            and KEY_SET_VALUE access. 
        KEY_CREATE_LINK     Permission to create a symbolic link. 
        KEY_CREATE_SUB_KEY  Permission to create subkeys. 
        KEY_ENUMERATE_SUB_KEYS Permission to enumerate subkeys. 
        KEY_EXECUTE         Permission for read access. 
        KEY_NOTIFY          Permission for change notification. 
        KEY_QUERY_VALUE     Permission to query subkey data. 
        KEY_READ            Combination of KEY_QUERY_VALUE, KEY_ENUMERATE_SUB_KEYS, and KEY_NOTIFY access. 
        KEY_SET_VALUE       Permission to set subkey data. 
        KEY_WRITE           Combination of KEY_SET_VALUE and KEY_CREATE_SUB_KEY access. 
                            
        Security access mask might also have WOW64_RES flag
        KEY_WOW64_32KEY     this will open 32bit equivalent key disregarding 
                                   the process.
        KEY_WOW64_64KEY     this will open 64bit equivalent key disregarding the process.


    lpSecurityAttributes  -  Pointer to a SECURITY_ATTRIBUTES structure that determines 
    whether the returned handle can be inherited by child processes. If 
    lpSecurityAttributes is NULL, the handle cannot be inherited. 


    phkResult  - Pointer to a variable that receives a handle to the opened or 
    created key. When you no longer need the returned handle, call the RegCloseKey 
    function to close it. 

    lpdwDisposition - Pointer to a variable that receives one of the following 
    disposition values: Value Meaning  REG_CREATED_NEW_KEY The key did not exist 
    and was created. REG_OPENED_EXISTING_KEY The key existed and was simply 
    opened without being changed. If lpdwDisposition is NULL, no disposition 
    information is returned. 

Return Values:
    If the function succeeds, the return value is ERROR_SUCCESS.

    If the function fails, the return value is a nonzero error code defined in WINERROR.H. 



--*/
{
    DWORD Ret;
    DWORD Temp = 0;
    DWORD dwLevel;
    DWORD dwLen;

    WCHAR ParentName[WOW64_MAX_PATH+WOW6432NODELEN];

    if (lpdwDisposition == NULL) {
        lpdwDisposition = &Temp;
    }


    if ( samDesired & KEY_WOW64_32KEY){
        
        dwLen = WOW64_MAX_PATH;
        ParentName[0]= UNICODE_NULL;
        HandleToKeyName ( hKey, ParentName, &dwLen);
        dwLen = wcslen (lpSubKey);
        if (dwLen>1) {
            wcscat (ParentName, L"\\");
            wcscat (ParentName, lpSubKey);
        }

        if (AdvapiAccessDenied (
                                hKey, 
                                lpSubKey, 
                                ParentName, 
                                WOW64_MAX_PATH,
                                &samDesired,
                                TRUE
                                ))
            return ERROR_ACCESS_DENIED;
        //
        // Check how many level parent keys exists so that KeyTag can be updated properly.
        //
        dwLevel = GetExistingParentLevel (ParentName);
    }

    Ret = Wow64pRegCreateKeyEx(
                                hKey,                // handle to an open key
                                lpSubKey,            // address of subkey name
                                Reserved,            // reserved
                                lpClass,             // address of class string
                                dwOptions,           // special options flag
                                samDesired,          // desired security access
                                lpSecurityAttributes,// address of key security structure
                                phkResult,           // address of buffer for opened handle
                                lpdwDisposition,      // address of disposition value buffer
                                ParentName
                                );

    //
    // If this is a newly created key and 32bit flag is passed in then you must set the owner
    //
    if ( (Ret == ERROR_SUCCESS) && (*lpdwDisposition == REG_CREATED_NEW_KEY) && ( samDesired & KEY_WOW64_32KEY )) {
        //
        // Sometimes caller create multiple Keys in a single call.
        // Need to determine what node has been created 
        //
        dwLen = WOW64_MAX_PATH;
        ParentName[0]= UNICODE_NULL;
        HandleToKeyName ( hKey, ParentName, &dwLen);
        dwLen = wcslen (lpSubKey);
        if (dwLen>1) {
            wcscat (ParentName, L"\\");
            wcscat (ParentName, lpSubKey);
        }

        //DbgPrint ("ADVAPI:Created a new key with tag: [%S]", lpSubKey);
        UpdateKeyTagWithLevel ( *phkResult,TAG_KEY_ATTRIBUTE_32BIT_WRITE,dwLevel, ParentName );
    }

    return Ret;
}

BOOL
Wow64RegNotifyLoadHive (
    PWCHAR Name
    )

/*++

Routine Description:

    This function will Notify running Wow64 Service that some hive has been loaded in the 
    system. Wow64 should respond if it care to handle this.

Arguments:

    Name - Absolute path of the registry that has been loaded.
    
Return Value:

    TRUE if everything under the has been deleted.
    FALSE otherwise.

  failure scenarion:
     Wow64 service isn't running.
     there is nothing the caller do, there for this will be a non blocking call.
     In the future caller should try to lunch the service...<TBD>

--*/

{
    DWORD Ret;
    HANDLE hEvent;

    if (!CreateSharedMemory ( OPEN_EXISTING_SHARED_RESOURCES )) {

        Wow64RegDbgPrint ( ("\nSorry! Couldn't open shared memory Ret:%d", GetLastError ()) );
        return FALSE;
    }


    if (!Wow64CreateEvent ( OPEN_EXISTING_SHARED_RESOURCES, &hEvent) ) {

      CloseSharedMemory ();
      Wow64RegDbgPrint ( ("\nSorry! couldn't open event to ping reflector..") );
      return FALSE;

    }

    Ret = EnQueueObject ( Name, HIVE_LOADING);
    
    CloseSharedMemory ();
    Wow64CloseEvent ();

    return Ret;

}

BOOL
Wow64RegNotifyUnloadHive (
    PWCHAR Name
    )

/*++

Routine Description:

    This function will Notify running Wow64 Service that some hive going to be unloaded 
    in the system. Wow64 should respond if it care to handle this. Normally Wow64 will 
    close any open handle to that hive.

Arguments:

    Name - Absolute path of the registry that going to unloaded.
    
Return Value:

    TRUE if everything under the has been deleted.
    FALSE otherwise.

  failure scenarion:
     Wow64 service isn't running.
     there is nothing the caller do, there for this will be a non blocking call.
     In the future caller should try to lunch the service...<TBD>

--*/

{
    DWORD Ret;
    HANDLE hEvent;

    if (!CreateSharedMemory ( OPEN_EXISTING_SHARED_RESOURCES )) {

        Wow64RegDbgPrint ( ("\nSorry! Couldn't open shared memory Ret:%d", GetLastError ()));
        return FALSE;
    }


    if (!Wow64CreateEvent ( OPEN_EXISTING_SHARED_RESOURCES, &hEvent) ) {

      CloseSharedMemory ();
      Wow64RegDbgPrint ( ("\nSorry! couldn't open event to ping reflector..") );
      return FALSE;

    }

    Ret = EnQueueObject ( Name, HIVE_UNLOADING);
    
    CloseSharedMemory ();
    Wow64CloseEvent ();

    return Ret;

}

BOOL
Wow64RegNotifyLoadHiveByHandle (
    HKEY hKey
    )

/*++

Routine Description:

    This function will Notify running Wow64 Service that some hive has been loaded in the 
    system. Wow64 should respond if it care to handle this.

Arguments:

    hKey - handle to the key that has been loaded.
    
Return Value:

    TRUE if everything under the has been deleted.
    FALSE otherwise.

  failure scenarion:
     Wow64 service isn't running.
     there is nothing the caller do, there for this will be a non blocking call.
     In the future caller should try to lunch the service...<TBD>

--*/

{
    WCHAR Name [256];
    DWORD Len = 256;

    if (!HandleToKeyName ( hKey, Name, &Len ))
        return FALSE;
    
    return  Wow64RegNotifyLoadHive( Name );

}

BOOL
Wow64RegNotifyUnloadHiveByHandle (
    HKEY hKey
    )

/*++

Routine Description:

    This function will Notify running Wow64 Service that some hive going to be unloaded 
    in the system. Wow64 should respond if it care to handle this. Normally Wow64 will 
    close any open handle to that hive.

Arguments:

    hKey - handle to the key that going to unloaded.
    
Return Value:

    TRUE if everything under the has been deleted.
    FALSE otherwise.

  failure scenarion:
     Wow64 service isn't running.
     there is nothing the caller do, there for this will be a non blocking call.
     In the future caller should try to lunch the service...<TBD>

--*/

{
    WCHAR Name [256];
    DWORD Len = 256;

    if (!HandleToKeyName ( hKey, Name, &Len ))
        return FALSE;
    
    return  Wow64RegNotifyUnloadHive( Name );

}

BOOL
Wow64RegNotifyLoadHiveUserSid (
    PWCHAR lpwUserSid
    )

/*++

Routine Description:

    This function will Notify running Wow64 Service that some hive has been loaded in the 
    system. Wow64 should respond if it care to handle this.

Arguments:

    hKey - handle to the key that has been loaded.
    
Return Value:

    TRUE if everything under the has been deleted.
    FALSE otherwise.

  failure scenarion:
     Wow64 service isn't running.
     there is nothing the caller do, there for this will be a non blocking call.
     In the future caller should try to lunch the service...<TBD>

--*/

{
    WCHAR Name [256];
    HKEY hUserRoot;
    
    wcscpy (Name, L"\\REGISTRY\\USER\\");
    wcscat (Name, lpwUserSid );

    if (wcsistr (Name, L"_Classes")) {
        wcscat (Name, L"\\Wow6432Node");

        hUserRoot = OpenNode (Name);

        //
        // DbgPrint ("\nWow64:Creating Hive %S",Name);
        //
        // Create the 32bit user hive if applicable
        //
        if ( hUserRoot == NULL ) {        
            CreateNode (Name);
        } else
            NtClose (hUserRoot);
    }

    return TRUE;

    
    //return  Wow64RegNotifyLoadHive( Name );

}

BOOL
Wow64RegNotifyUnloadHiveUserSid (
    PWCHAR lpwUserSid
    )

/*++

Routine Description:

    This function will Notify running Wow64 Service that some hive going to be unloaded 
    in the system. Wow64 should respond if it care to handle this. Normally Wow64 will 
    close any open handle to that hive.

Arguments:

    hKey - handle to the key that going to unloaded.
    
Return Value:

    TRUE if everything under the has been deleted.
    FALSE otherwise.

  failure scenarion:
     Wow64 service isn't running.
     there is nothing the caller do, there for this will be a non blocking call.
     In the future caller should try to lunch the service...<TBD>

--*/

{
    WCHAR Name [256];

    wcscpy (Name, L"\\REGISTRY\\USER\\");
    wcscat (Name, lpwUserSid );
    

    //
    //return  Wow64RegNotifyUnloadHive( Name );
    //
    return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\regremap\wow64reg\reflectr.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    reflectr.h

Abstract:

    This file define function used only in the setup/reflector thread

Author:

    ATM Shafiqul Khalid (askhalid) 16-Feb-2000

Revision History:

--*/

#ifndef __REFLECTR_H__
#define __REFLECTR_H__

//
// must not define this for the checin code its only for the debugging code
//
//#define ENABLE_REGISTRY_LOG
//#define WOW64_LOG_REGISTRY  // will log information 

#define WAIT_INTERVAL INFINITE  //Infinite

#define VALUE_KEY_UPDATE_TIME_DIFF 10  // minimum difference in sec to Keyupdate and reflector thread scan

#define WOW64_REGISTRY_SETUP_REFLECTOR_KEY L"SOFTWARE\\Microsoft\\WOW64\\Reflector Nodes"

//
//  following flag used in the merge value key & Keys
//
#define PATCH_PATHNAME              0x00000001 // patch pathname from value
#define DELETE_VALUEKEY             0x00000002 // delete the value after copy like runonce key
#define NOT_MARK_SOURCE             0x00000004 // don't mark source 
#define NOT_MARK_DESTINATION        0x00000008 // don't mark destination
#define DESTINATION_NEWLY_CREATED   0x00000010 // destination is newly created don't check timestamp

#define DELETE_FLAG                 0x10000000 // destination is newly created don't check timestamp


#define CONSOLE_OUTPUT printf

#ifndef THUNK
#ifdef ENABLE_REGISTRY_LOG
#define Wow64RegDbgPrint(x) RegLogPrint x
#else
#define Wow64RegDbgPrint(x)   //NULL Statement
#endif
#endif

//
// over write for thunk
//
#if defined THUNK
#undef CONSOLE_OUTPUT
#define CONSOLE_OUTPUT DbgPrint
#undef Wow64RegDbgPrint
#define Wow64RegDbgPrint(x) CONSOLE_OUTPUT x
#endif



typedef struct __REFLECTOR_EVENT {
    HANDLE  hRegistryEvent;
    HKEY  hKey;
    DWORD   dwIndex;  //index to the ISN node table
    BOOL  bDirty;
} REFLECTOR_EVENT;


typedef enum {
    Dead=0,             // no thread 
    Stopped,            // events has been initialised
    Running,            // running the thread
    PrepareToStop,      // going to stop soon
    Abnormal            // abnormal state need to clean up in some way
} REFLECTR_STATUS;

#define HIVE_LOADING L'L'
#define HIVE_UNLOADING L'U'
#define LIST_NAME_LEN 257    //256 +1 for the last entry

#define OPEN_EXISTING_SHARED_RESOURCES 0x12
#define CREATE_SHARED_MEMORY 0x13

typedef WCHAR LISTNAME[LIST_NAME_LEN];

#pragma warning( disable : 4200 )    //todisable zero length array which will be allocated later
typedef struct _LIST_OBJECT {
    DWORD Count;
    DWORD MaxCount;
    LISTNAME Name[]; //the 256th position will hold the value like loading/unloading
} LIST_OBJECT;
#pragma warning( default : 4200 )

#ifdef __cplusplus
extern "C" {
#endif


BOOL 
ExistCLSID (
    PWCHAR Name,
    BOOL Mode
    );

BOOL
MarkNonMergeableKey (
    LPCWSTR KeyName,
    HKEY hKey,
    DWORD *pMergeableSubkey
    );

BOOL
SyncNode (
    PWCHAR NodeName
    );

BOOL 
ProcessTypeLib (
    HKEY SrcKey,
    HKEY DestKey,
    BOOL Mode
    );

void
MergeK1K2 (
    HKEY SrcKey,
    HKEY DestKey,
    DWORD FlagDelete 
    );

BOOL
CreateIsnNode();

BOOL
CreateIsnNodeSingle(
    DWORD dwIndex
    );

BOOL 
GetWow6432ValueKey (
    HKEY hKey,
    WOW6432_VALUEKEY *pValue
    );

DWORD
DeleteKey (
    HKEY DestKey,
    WCHAR *pKeyName,
    DWORD mode
    );

BOOL
CleanpRegistry ( );

BOOL
InitializeIsnTable ();

BOOL
UnRegisterReflector();

BOOL
RegisterReflector();

ULONG
ReflectorFn (
    PVOID *pTemp
    );

BOOL
InitReflector ();

BOOL
InitializeIsnTableReflector ();

BOOL 
PopulateReflectorTable ();

BOOL 
Is64bitNode ( 
    WCHAR *pName
    );


BOOL 
HandleRunonce(
    PWCHAR pKeyName
    );

BOOL
PatchPathName (
    PWCHAR pName
    );

BOOL
GetMirrorName (
    PWCHAR Name, 
    PWCHAR TempName
    );

VOID SetInitialCopy ();

////////////////shared memory service/////////////////////////////

BOOL 
CreateSharedMemory (
    DWORD dwOption
    );

VOID
CloseSharedMemory ();

BOOL
Wow64CreateLock (
    DWORD dwOption
    );

VOID
Wow64CloseLock ();

BOOL
Wow64CreateEvent (
    DWORD dwOption,
    HANDLE *hEnent
    );

VOID
Wow64CloseEvent ();

BOOL
SignalWow64Svc ();

BOOL
EnQueueObject (
    PWCHAR pObjName,
    WCHAR  Type
    );
BOOL
DeQueueObject (
    PWCHAR pObjName,
    PWCHAR  Type
    );

REFLECTR_STATUS
GetReflectorThreadStatus ();

BOOL
GetMirrorName (
    PWCHAR Name,
    PWCHAR MirrorName
    );

BOOL
PopulateReflectorTable ();

BOOL
GetDefaultValue (
    HKEY  SrcKey,
    WCHAR *pBuff,
    DWORD *Len
    );

BOOL
WriteRegLog (
    PWCHAR Msg
    );

VOID 
CloseRegLog ();

BOOL
InitRegLog ();

BOOL
RegLogPrint ( 
    CHAR *p, 
    ... 
    );

#ifdef __cplusplus
    }
#endif
#endif //__REFLECTR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\setup\boot\driveex.h ===
/* Return values of GetDriveTypeEx(). */
#define EX_DRIVE_INVALID    0
#define EX_DRIVE_REMOVABLE  1
#define EX_DRIVE_FIXED      2
#define EX_DRIVE_REMOTE     3
#define EX_DRIVE_CDROM      4
#define EX_DRIVE_FLOPPY     5
#define EX_DRIVE_RAMDISK    6


UINT GetDriveTypeEx (int nDrive);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\setup\boot\dmnd2.c ===
/***************************************************************************
**
**	File:			dmnd2.c
**	Purpose:		CallBack functions to be passed to the Diamond
**					FDI (File Decompression Interface) module.
**	Notes:
**
****************************************************************************/

#define DMND2_C

#include <windows.h>
#include <stdlib.h>		/* malloc */
#include <malloc.h>		/* malloc, _halloc */
#include <stdio.h>		/* _tempnam */
#include <fcntl.h>
#include <io.h>			/* _open, _read, _write, _write, _lseek, _mktemp */
#include <sys\stat.h>	/* _S_IWRITE, _S_IREAD */

#include "stdtypes.h"
#include "setup.h"

#include <fdi.h>


typedef struct _fud		/* Fdi User Data block used in FDICopy */
	{
	char * szDstDir;
	char * szSrcs;
	char * szDsts;
	char * szSrcBuf;
	char * szDstBuf;
	BOOL * rgfSrcFilesCopied;
	int    cFilesCopied;
	int    cSrcFiles;
	int    cCabNum;		/* Current cabinet number (starts at 1) */
	HWND   hWnd;		/* Window handle used to display dialogs */
	HFDI   hfdi;
	ERF    erf;
	BRC    brc;
	char   rgchSpillFileName[cchFullPathMax];
	int    hfSpillFile;
	}  FUD;

typedef FUD *   PFUD;   /* Ptr to Fdi User Data block */

#define pfudNull	((PFUD)NULL)
#define hfdiNull	((HFDI)NULL)

#define szSpillFilePrefix		"sf"
#define szSpillFileTemplate		"sfXXXXXX"

/* FDI Callback Routines
*/
FNFDINOTIFY  ( FnFdiNotifyCB );
FNALLOC      ( FnFdiAllocCB );
FNFREE       ( FnFdiFreeCB );
INT_PTR  FAR DIAMONDAPI FnFdiOpenCB  ( char FAR *szFile, int oflag, int pmode );
UINT FAR DIAMONDAPI FnFdiReadCB  ( INT_PTR hf, void FAR *pv, UINT cb );
UINT FAR DIAMONDAPI FnFdiWriteCB ( INT_PTR hf, void FAR *pv, UINT cb );
int  FAR DIAMONDAPI FnFdiCloseCB ( INT_PTR hf );
long FAR DIAMONDAPI FnFdiSeekCB  ( INT_PTR hf, long dist, int seektype );


/* Private Functions
*/
static int  FhHandleCopyFileMsgInNotify ( PFUD pfud, char * szFName );
static BOOL FHandleCloseFileMsgInNotify ( PFUD pfud, INT_PTR hf );
static BOOL FHandleNextCabMsgInNotify ( PFUD pfud, char * szCabFName,
				char * szDiskLabel, char * szSrcDir, FDIERROR fdie );
static BOOL FModifyCabinetName(char * szSrcDir, int cCabNum);
static BOOL FEnsureCabinetFileIsPresent(HWND hWnd, char * szSrcDir,
											char * szCabinet, int cCabNum);
static int  HfOpenSpillFile ( PFDISPILLFILE pfdisf, int oflag, int pmode );
static VOID InitFud (PFUD pfud, char * szDstDir, char * szSrcs,
				char * szDsts, char * szSrcBuf, char * szDstBuf,
				BOOL * rgfSrcFilesCopied, int cSrcFiles, HWND hWnd );

/* KLUDGE - so pfud->brc can be found in callbacks */
static PFUD pfudG = pfudNull;


#ifndef DEBUG_TEST	/* Turn on for create/skip file messages. */
  #define DebugMsgSz(sz1, sz2)
#else  /* DEBUG */
static VOID DebugMsgSz ( char * szPattern, char * szArgument );

/*
************************************************************************/
static VOID DebugMsgSz ( char * szPattern, char * szArgument )
{
	char rgch[128];

	wsprintf(rgch, szPattern, szArgument);
	DebugMsg(rgch);
}
#endif /* DEBUG */


/*
**	Purpose:
**		This function is passed as a callback to the FDI library.
**	Arguments:
**		fdint - type of notification
**		pfdin - data for notification
**	Returns:
**		varies with fdint
**
*************************************************************************/
FNFDINOTIFY ( FnFdiNotifyCB )
{
	switch (fdint)
		{
	default:
		DebugMsg("Unexpected message passed to FnFdiNotifyCB().");
		((PFUD)(pfdin->pv))->brc = brcGen;
		return (0);

	case fdintCABINET_INFO:
		/* do nothing */
		return (0);

	case fdintCOPY_FILE:
		return (FhHandleCopyFileMsgInNotify(pfdin->pv, pfdin->psz1));

	case fdintCLOSE_FILE_INFO:
		return (FHandleCloseFileMsgInNotify(pfdin->pv, pfdin->hf) ? TRUE
					: -1);

	case fdintPARTIAL_FILE:
		/* do nothing */
		return (0);

	case fdintNEXT_CABINET:
		return (FHandleNextCabMsgInNotify(pfdin->pv, pfdin->psz1,
					pfdin->psz2, pfdin->psz3, pfdin->fdie) ? 0 : -1);
		}
}


/*
**	returns:
**		 0 == skip this file
**		-1 == abort FDICopy()
**		else a legitimate DOS file handle
*************************************************************************/
static int FhHandleCopyFileMsgInNotify ( PFUD pfud, char * szFName )
{
	SZ  szSrcs = pfud->szSrcs;
	SZ  szDsts = pfud->szDsts;
	int iFile;
	struct _stat stat;

	for (iFile = 0; *szSrcs; iFile++)
		{
		if (*szSrcs == '@' && !lstrcmpi(szSrcs+1, szFName))
			{
			int  hfRet;

			lstrcpy(pfud->szDstBuf, pfud->szDstDir);
			lstrcat(pfud->szDstBuf, "\\");
			lstrcat(pfud->szDstBuf, szDsts);
			DebugMsgSz("Creating Dest File: %s", pfud->szDstBuf);

			/* If file exists, try to remove it.
			*/
			if (_stat(pfud->szDstBuf, &stat) != -1)
				{
				/* NOTE: Ignore error return values here since
				*	 _open should catch any errors anyway.
				*/
				if (!(stat.st_mode & _S_IWRITE))
					_chmod(pfud->szDstBuf, _S_IREAD | _S_IWRITE);
				_unlink(pfudG->szDstBuf);
				}

			hfRet = _open(pfud->szDstBuf,
							_O_BINARY | _O_CREAT | _O_RDWR | _O_TRUNC,
							_S_IREAD | _S_IWRITE);
			if (hfRet == -1)
				pfud->brc = brcMemDS;

			if (iFile < pfud->cSrcFiles)
				(pfud->rgfSrcFilesCopied)[iFile] = TRUE;

			// We will have copied one more file
			pfud->cFilesCopied++;

			return (hfRet);
			}

		szSrcs += lstrlen(szSrcs) + 1;
		szDsts += lstrlen(szDsts) + 1;
		}

	DebugMsgSz("Skipping a cabinet file: %s", szFName);

	return (0);
}


/*
*************************************************************************/
static BOOL FHandleCloseFileMsgInNotify ( PFUD pfud, INT_PTR hf )
{
	if (FnFdiCloseCB(hf) != -1)
		{
		_chmod(pfud->szDstBuf, S_IREAD);
		return (TRUE);
		}

	return (FALSE);
}


/*
*************************************************************************/
static BOOL FHandleNextCabMsgInNotify ( PFUD pfud, char * szCabFName,
				char * szDiskLabel, char * szSrcDir, FDIERROR fdie )
{
	Unused(szDiskLabel);

	/* Check if diamond is calling us again because the cabinet
	*	we specified was bad.
	*/
	if (fdie == FDIERROR_WRONG_CABINET)
		{
		DebugMsg("Cabinet files are out of sequence or corrupted.");
		return FALSE;
		}

	lstrcpy(pfud->szSrcBuf, szSrcDir);
	lstrcat(pfud->szSrcBuf, szCabFName);

	if (!FEnsureCabinetFileIsPresent(pfud->hWnd, szSrcDir, szCabFName,
										pfud->cCabNum+1))
		{
		pfud->brc = brcFile;
		
		return FALSE;
		}
		
	return TRUE;
}


/*
*************************************************************************/
static int CFilesInSrcsInitRgf ( char * szSrcs, BOOL * rgfSrcFilesCopied )
{
	int iFile, cFiles;

	for (iFile = 0; iFile < 128; iFile++)
		rgfSrcFilesCopied[iFile] = TRUE;

	cFiles = 0;
	while (*szSrcs)
		{
		if (*szSrcs == '@')
			rgfSrcFilesCopied[cFiles] = FALSE;

		cFiles++;
		szSrcs += lstrlen(szSrcs) + 1;
		}

	if (cFiles > 128)
		{
		DebugMsg("More than 128 source files in .LST file "
						"- will not check that all exist.");
		cFiles = 128;
		}

	return (cFiles);
}


/*
**	Purpose:
**		Copies all cabinet files in the specified copy list, ignoring
**		any non-cabinet files in the list.
**	Arguments:
**		szCabinet:  cabinet filename (oem).
**		szSrcDir:   src path with trailing backslash (ANSI).
**		szDstDir:   dst path with trailing backslash (oem).
**		szSrcs:     NULL separated list of src filenames (oem).
**		szDsts:     NULL separated list of dst filenames (oem).
**		szSrcBuf:   buffer to hold src path for error msgs.
**		szDstBuf:   buffer to hold dst path for error msgs.
**	Returns:
**		brcOkay if completed without error, brcXX otherwise.
**
*************************************************************************/
extern  BRC  BrcHandleCabinetFiles ( HWND hWnd, char * szCabinet,
					int cFirstCabinetNum, int cLastCabinetNum, char *szSrcDir,
					char * szDstDir, char * szSrcs, char * szDsts,
					char * szSrcBuf, char * szDstBuf )
{
	FUD  fud;
	BRC  brcRet    = brcOkay;
	BOOL rgfSrcFilesCopied[128];
	int  cSrcFiles = CFilesInSrcsInitRgf(szSrcs, rgfSrcFilesCopied);
	int  cpuType   = cpuUNKNOWN;

	InitFud(&fud, szDstDir, szSrcs, szDsts, szSrcBuf, szDstBuf,
				rgfSrcFilesCopied, cSrcFiles, hWnd);
	pfudG = &fud;

#if 0
	/*	NOTE: Get CPU type ourselves, since FDI's CPU detection may
	*	not work correctly for 16-bit Windows applications.
	*/
	cpuType = (GetWinFlags() & WF_CPU286) ? cpu80286 : cpu80386;
#endif

    if ((fud.hfdi = FDICreate(FnFdiAllocCB, FnFdiFreeCB, FnFdiOpenCB,
								FnFdiReadCB, FnFdiWriteCB, FnFdiCloseCB,
								FnFdiSeekCB, cpuType,
								&(fud.erf) )) == hfdiNull)
		{
        return (brcMem);
        }

	/*
	 * Process cabinets as long as we have more files to copy.
	 * i is the current cabinet number (starting at 1).
	 */
	for (fud.cCabNum=cFirstCabinetNum;
			fud.cFilesCopied < fud.cSrcFiles && fud.cCabNum<=cLastCabinetNum;
			fud.cCabNum++)
		{
		/* Modify the cabinet name depending on the current cabinet number */
		if (!FModifyCabinetName(szCabinet, fud.cCabNum))
			{
			brcRet = brcFile;
			break;
			}

		lstrcpy(szSrcBuf, szSrcDir);
		lstrcat(szSrcBuf, szCabinet);

		if (!FEnsureCabinetFileIsPresent(fud.hWnd, szSrcDir, szCabinet,
											fud.cCabNum))
			{
			brcRet = brcFile;
			break;
			}

		if (!FDICopy(fud.hfdi, szCabinet, szSrcDir, 0, FnFdiNotifyCB, NULL,
				&fud))
			{
			brcRet = (fud.brc == brcOkay) ? brcGen : fud.brc;
			break;
			}
		}

	if (brcRet == brcOkay)
		{
		int iFile;

		/* Check if we got all the files we want */
		for (iFile = 0; iFile < cSrcFiles; iFile++)
			{
			if (!(rgfSrcFilesCopied[iFile]))
				{
				lstrcat(szSrcBuf, " : ");
				lstrcat(szSrcBuf, szSrcs + 1);
				brcRet = brcFile;
				}
			szSrcs += lstrlen(szSrcs) + 1;
			}
		}

	FDIDestroy(fud.hfdi);

	/* Ensure that the spill file is deleted.
	*/
	Assert(pfudG != pfudNull);
	if (pfudG->hfSpillFile != -1)
		FnFdiCloseCB(pfudG->hfSpillFile);

	return (brcRet);
}


/*
*************************************************************************/
static VOID InitFud (PFUD pfud, char * szDstDir, char * szSrcs,
				char * szDsts, char * szSrcBuf, char * szDstBuf,
				BOOL * rgfSrcFilesCopied, int cSrcFiles, HWND hWnd )
{
	pfud->erf.fError   = fFalse;
	pfud->szDstDir     = szDstDir;
	pfud->szSrcs       = szSrcs;
	pfud->szDsts       = szDsts;
	pfud->szSrcBuf     = szSrcBuf;
	pfud->szDstBuf     = szDstBuf;
	pfud->rgfSrcFilesCopied = rgfSrcFilesCopied;
	pfud->cSrcFiles    = cSrcFiles;
	pfud->cFilesCopied = 0;
	pfud->hWnd         = hWnd;
	pfud->brc          = brcOkay;
	*(pfud->rgchSpillFileName) = chEos;
	pfud->hfSpillFile  = -1;
}


static BOOL FModifyCabinetName(char * szSrcDir, int cCabNum)
{
	char *pch = szSrcDir + lstrlen(szSrcDir);
	
	if (cCabNum < 1 || cCabNum > 9)
		return FALSE;
	
	/* Leave the name unchabged for the first cabinet */
	if (cCabNum == 1)
		return TRUE;
	
	/* Look for the dot, starting backward */
	for (; *pch != '.'; pch--)
		{
		/* Error if we can't find a dot before we find a slash */
		if (pch<=szSrcDir+1 || *pch == '\\')
			return FALSE;
		}
	
	/* Point to the character before the dot */
	pch--;
	
	/* Replace the last character before the dot by the cabinet number */
	*pch = (char)(cCabNum + '0');
	
	return TRUE;
}

static BOOL FEnsureCabinetFileIsPresent(HWND hWnd, char * szSrcDir,
											char * szCabinet, int cCabNum)
{
	char rgchFileName[cchFullPathMax], rgchCabNum[32];
	OFSTRUCT ofs;
	HFILE hFile;
	BOOL fFirst = TRUE;

	Unused(hWnd);
	
	lstrcpy(rgchFileName, szSrcDir);
	lstrcat(rgchFileName, szCabinet);
	
	for (;;)
		{
		hFile = OpenFile(rgchFileName, &ofs, OF_EXIST);
		if (hFile != HFILE_ERROR)
			break;
		
		_itoa(cCabNum, rgchCabNum, 10);
		
		if (fFirst)
			{
			if (DispErrBrc(brcInsDisk, FALSE, MB_ICONEXCLAMATION|MB_OKCANCEL,
					rgchCabNum, NULL, NULL) != IDOK)
				{
				return FALSE;
				}
			fFirst = FALSE;
			}
		else
			{
			if (DispErrBrc(brcInsDisk2, FALSE, MB_ICONEXCLAMATION|MB_OKCANCEL,
					rgchFileName, rgchCabNum, NULL) != IDOK)
				{
				return FALSE;
				}
			}

		}
	
	return TRUE;
}


/*
**	Purpose:
**		Memory allocator for FDI.
**	Arguments:
**		cb - size of block to allocate
**	Returns:
**		Non-NULL pointer to block of size at least cb,
**		or NULL for failure.
**
*************************************************************************/
FNALLOC ( FnFdiAllocCB )
{
#ifdef _WIN32
	void HUGE * pvRet = malloc(cb);
#else
	void HUGE * pvRet = _halloc(cb,1);
#endif

	if (pvRet == NULL && pfudG->brc == brcOkay)
		pfudG->brc = brcMem;

	return (pvRet);
}


/*
**	Purpose:
**		Memory free function for FDI.
**	Arguments:
**		pv - memory allocated by FnFdiAllocCB to be freed
**	Returns:
**		None.
**
*************************************************************************/
FNFREE ( FnFdiFreeCB )
{
#ifdef _WIN32
    free(pv);
#else
    _hfree(pv);
#endif
}


/*
*************************************************************************/
INT_PTR FAR DIAMONDAPI FnFdiOpenCB ( char FAR *szFile, int oflag, int pmode )
{
	INT_PTR hfRet;
	
	if (*szFile == '*')
		return (HfOpenSpillFile((PFDISPILLFILE)szFile, oflag, pmode));
	
	hfRet = _open(szFile, oflag, pmode);

	if (hfRet == -1 && pfudG->brc == brcOkay)
		pfudG->brc = brcFile;

	return (hfRet);
}


/*
*************************************************************************/
static int HfOpenSpillFile ( PFDISPILLFILE pfdisf, int oflag, int pmode )
{
	SZ   szTmp;
	CHAR rgchSize[20];
	BOOL fTryAgain = fTrue;

	Assert(pfdisf != (PFDISPILLFILE)NULL);
	Assert(*(pfdisf->ach) == '*');
	Assert(pfudG != pfudNull);
	Assert(pfudG->hfSpillFile == -1);	/* Only one at a time */
	Assert(*(pfudG->rgchSpillFileName) == chEos);

	if ((szTmp = _tempnam("", szSpillFilePrefix)) == szNull)
		{
		DebugMsg("Unable to get spill file name.");
		goto LNoSpillFile;
		}
	Assert(lstrlen(szTmp) < sizeof(pfudG->rgchSpillFileName));
	lstrcpy(pfudG->rgchSpillFileName, szTmp);
	free(szTmp);

LOpenSpillFile:
	oflag = _O_CREAT | _O_BINARY | _O_RDWR;		/* Force open mode */
	if ((pfudG->hfSpillFile = _open(pfudG->rgchSpillFileName, oflag, pmode))
			== -1)
		{
		DebugMsg("Unable to open spill file.");
		goto LNoSpillFile;
		}

	if (pfdisf->cbFile > 0)
		{
		/* Size file by writing one byte at size - 1.
		*/
		if (FnFdiSeekCB(pfudG->hfSpillFile, pfdisf->cbFile - 1, SEEK_SET) == -1
				|| FnFdiWriteCB(pfudG->hfSpillFile, "b", 1) != 1)
			{
			DebugMsg("Unable to set spill file size.");
			goto LNoSpillFile;
			}
		}

	return (pfudG->hfSpillFile);

LNoSpillFile:
	if (pfudG->hfSpillFile != -1)
		FnFdiCloseCB(pfudG->hfSpillFile);

	if (fTryAgain)
		{
		/* Try again with bootstrap temp dir.
		*
		*	(REVIEW: We could do another search here, checking for size.)
		*/
		fTryAgain = fFalse;
		Assert(lstrlen(pfudG->szDstBuf) + lstrlen(szSpillFileTemplate) <
				sizeof(pfudG->rgchSpillFileName));
		lstrcpy(pfudG->rgchSpillFileName, pfudG->szDstDir);
		lstrcat(pfudG->rgchSpillFileName, szDirSep);
		lstrcat(pfudG->rgchSpillFileName, szSpillFileTemplate);
		if (_mktemp(pfudG->rgchSpillFileName) != NULL)
			goto LOpenSpillFile;
		}

	_ltoa((pfdisf->cbFile + 1023) / 1024, rgchSize, 10);
	DispErrBrc(brcNoSpill, fTrue, MB_OK | MB_ICONSTOP, rgchSize, szNull, szNull);

	*(pfudG->rgchSpillFileName) = chEos;
	pfudG->brc = brcNoSpill;

	return (-1);
}


/*
*************************************************************************/
UINT FAR DIAMONDAPI FnFdiReadCB ( INT_PTR hf, void FAR *pv, UINT cb )
{
	UINT cbRet = _read((int)hf, pv, cb);

	if (cbRet != cb && pfudG->brc == brcOkay)
		pfudG->brc = brcMemDS;

	return (cbRet);
}


/*
*************************************************************************/
UINT FAR DIAMONDAPI FnFdiWriteCB ( INT_PTR hf, void FAR *pv, UINT cb )
{
	UINT cbRet = _write((int)hf, pv, cb);

	FYield();

	if (cbRet != cb && pfudG->brc == brcOkay)
		pfudG->brc = brcDS;

	return (cbRet);
}


/*
*************************************************************************/
int FAR DIAMONDAPI FnFdiCloseCB ( INT_PTR hf )
{
	int iRet = _close((int)hf);

	if (iRet == -1 && pfudG->brc == brcOkay)
		pfudG->brc = brcDS;

	/* If we're closing the spill file, delete it.
	*/
	if (hf == pfudG->hfSpillFile)
		{
		_unlink(pfudG->rgchSpillFileName);		/* Delete spill file */
		*(pfudG->rgchSpillFileName) = chEos;	/* Empty path */
		pfudG->hfSpillFile = -1;				/* Mark as closed */
		}

	return (iRet);
}


/*
*************************************************************************/
long FAR DIAMONDAPI FnFdiSeekCB ( INT_PTR hf, long dist, int seektype )
{
	long lRet = _lseek((int)hf, dist, seektype);

	if (lRet == -1L && pfudG->brc == brcOkay)
		{
		DebugMsg("Seek Operation failed in Cabinet");
		pfudG->brc = brcGen;
		}

	return (lRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\setup\boot\setup.h ===
typedef USHORT         BRC;   /* Bootstrapper Return Code */

/* order is important:
*/
#define brcGen       0
#define brcVir       1
#define brcInst      2
#define brcFile      3
#define brcMemDS     4
#define brcLst       5
#define brcMem       6
#define brcDS        7
#define brcMemDSHlp  8	/* Note: second half of brcMemDS message. */
#define brcInsDisk	 9
#define brcInsDisk2	 10
#define brcNoCpuSect 11
#define brcNoSpill   12
#define brcRegDb     13
#define brcOkay      14
#define brcInsCDRom2 15
#define brcUserQuit  16
#define brcString	 17
#define brcConnectToSource	18
#define brcConnectHlp	19
#define brcNoStf     20
#define brcMax       21

#define IDS_InsufMem	(brcMax + 1)	/* NOTE: brc's are also string id's! */
#define IDS_InitErr		(brcMax + 2)
#define IDS_Setup		(brcMax + 3)


/* REVIEW: What is the "right" size for full path?
**	(GetWindowsDirectory() says it needs 144 bytes).
*/
#define cchFullPathMax  160

extern int DispErrBrc ( BRC brc, BOOL fError, UINT fuStyle,
					const char *sz1, const char *sz2,
					const char *sz3 );

extern  BRC  BrcHandleCabinetFiles ( HWND hWnd, char * szCabinet,
					int cFirstCabinetNum, int cNumOfCabinets, char * szSrcDir,
					char * szDstDir, char * szSrcs, char * szDsts,
					char * szSrcBuf, char * szDstBuf );

extern void FYield ( VOID );

extern HANDLE hinstBoot;

#ifdef DEBUG
  #define DebugMsg(sz)  MessageBox(NULL, (sz), "Bootstrapper Debug Msg", MB_OK)
#else
  #define DebugMsg(sz)
#endif

#ifdef DEBUG
#ifdef DMND2_C
/* For Assertion and Debug error message display */
char szDebugMsg[24] = "Debug Setup Message";
char szDebugBuf[512];
#else
extern char szDebugMsg[24];
extern char szDebugBuf[512];
#endif /* DMND2_C */
#define Assert(exp)\
		{\
		if (!(exp))\
			{\
			wsprintf(szDebugBuf, "File %s, Line %d",\
					(LPSTR)__FILE__, __LINE__);\
			MessageBox(NULL, szDebugBuf, "Assertion Error",\
					MB_OK | MB_ICONSTOP);\
			}\
		}
#else	/* !DEBUG */
#define Assert(exp)
#endif  /* !DEBUG */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\setup\boot\driveex.c ===
#include <windows.h>
#include <string.h>
#include "driveex.h"

#if 0
  /* // See the "MS-DOS Programmer's Reference" for further information
   // about this structure. */
typedef struct tagDEVICEPARAMS
   {
   BYTE  bSpecFunc;        /* Special functions */
   BYTE  bDevType;         /* Device type */
   WORD  wDevAttr;         /* Device attributes */
   WORD  wCylinders;       /* Number of cylinders */
   BYTE  bMediaType;       /* Media type */
                        /* Beginning of BIOS parameter block (BPB) */
   WORD  wBytesPerSec;     /* Bytes per sector */
   BYTE  bSecPerClust;     /* Sectors per cluster */
   WORD  wResSectors;      /* Number of reserved sectors */
   BYTE  bFATs;            /* Number of FATs */
   WORD  wRootDirEnts;     /* Number of root-directory entries */
   WORD  wSectors;         /* Total number of sectors */
   BYTE  bMedia;           /* Media descriptor */
   WORD  wFATsecs;         /* Number of sectors per FAT */
   WORD  wSecPerTrack;     /* Number of sectors per track */
   WORD  wHeads;           /* Number of heads */
   DWORD dwHiddenSecs;     /* Number of hidden sectors */
   DWORD dwHugeSectors;    /* Number of sectors if wSectors == 0 */
                        /* End of BIOS parameter block (BPB) */
   } DEVICEPARAMS, FAR * LPDEVICEPARAMS;
   /* Function prototypes */
BOOL GetDeviceParameters (int nDrive, LPDEVICEPARAMS dp);
BOOL IsCDRomDrive (int nDrive);
/*----------------------------------------------------------------- */
/* GetDeviceParameters() */
/* */
/* Fills a DEVICEPARAMS struct with info about the given drive. */
/* Calls DOS IOCTL Get Device Parameters (440Dh, 60h) function. */
/* */
/* Parameters */
/*   nDrive   Drive number  0 = A, 1 = B, 2 = C, and so on. */
/*   dp       Pointer to a structure that will contain the drive's */
/*            parameters. */
/* */
/* Returns TRUE if it succeeded, FALSE if it failed. */
/*----------------------------------------------------------------- */
#pragma warning(disable:4704)	/* in-line asm precludes global optimizations  */
BOOL GetDeviceParameters (int nDrive, LPDEVICEPARAMS dp)
   {
   BOOL bResult = TRUE;      /* Assume success */
   __asm {
         push ds
         mov  bx, nDrive
         inc  bx           /* Convert 0-based #'s to 1-based #s */
         mov  ch, 08h      /* Device category--must be 08h */
         mov  cl, 60h      /* MS-DOS IOCTL Get Device Parameters */
         lds  dx, dp
         mov  ax, 440Dh
         int  21h
         jnc  gdp_done     /* CF SET if error */
         mov  bResult, FALSE
      gdp_done:
         pop  ds
         }
   return (bResult);
   }
#pragma warning(default:4704)	/* in-line asm precludes global optimizations  */

/*----------------------------------------------------------------- */
/* IsCDRomDrive() */
/* */
/* Determines if a drive is a CD-ROM. Calls MSCDEX and checks */
/* that MSCDEX is loaded, and that MSCDEX reports the drive is a */
/* CD-ROM. */
/* */
/* Parameters */
/*    nDrive    Drive number  0 = A, 1 = B, 2 = C, and so forth. */
/* */
/* Returns TRUE if nDrive is a CD-ROM drive, FALSE if it isn't. */
/*----------------------------------------------------------------- */
#pragma warning(disable:4704)	/* in-line asm precludes global optimizations  */
BOOL IsCDRomDrive (int nDrive)
   {
   BOOL bResult = FALSE;      /* Assume not a CD-ROM drive */
   __asm {
         mov  ax, 150Bh       /* MSCDEX CD-ROM Drive Check */
         xor  bx, bx
         mov  cx, nDrive
         int  2Fh
         cmp  bx, 0ADADh      /* Check MSCDEX signature */
         jne  not_cd_drive
         or   ax, ax          /* Check the drive type */
         jz   not_cd_drive    /* 0 (zero) means not CD-ROM */
         mov  bResult, TRUE
      not_cd_drive:
         }
   return (bResult);
   }
#pragma warning(default:4704)	/* in-line asm precludes global optimizations  */
#endif

/*----------------------------------------------------------------- */
/* GetDriveTypeEx() */
/* */
/* Determines the type of a drive. Calls Windows's GetDriveType */
/* to determine if a drive is valid, fixed, remote, or removeable, */
/* then breaks down these categories further to specific device */
/* types. */
/* */
/* Parameters */
/*    nDrive    Drive number  0 = A, 1 = B, 2 = C, etc. */
/* */
/* Returns one of: */
/*    EX_DRIVE_INVALID         -- Drive not detected */
/*    EX_DRIVE_REMOVABLE       -- Unknown removable-media type drive */
/*    EX_DRIVE_FIXED           -- Hard disk drive */
/*    EX_DRIVE_REMOTE          -- Remote drive on a network */
/*    EX_DRIVE_CDROM           -- CD-ROM drive */
/*    EX_DRIVE_FLOPPY          -- Floppy disk drive */
/*    EX_DRIVE_RAMDISK         -- RAM disk */
/*----------------------------------------------------------------- */
UINT GetDriveTypeEx (int nDrive)
   {
#if 0
   DEVICEPARAMS dp;
   UINT uType;
   _fmemset (&dp, 0, sizeof(dp));    /* Init device params struct */
   uType = GetDriveType (nDrive);
   switch (uType)
      {
      case DRIVE_REMOTE:
            /* GetDriveType() reports CD-ROMs as Remote drives. Need */
            /* to see if the drive is a CD-ROM or a network drive. */
         if (IsCDRomDrive (nDrive))
            return (EX_DRIVE_CDROM);
         else
            return (EX_DRIVE_REMOTE);
         break;
      case DRIVE_REMOVABLE:
            /* Check for a floppy disk drive. If it isn't, then we */
            /* don't know what kind of removable media it is. */
            /* For example, could be a Bernoulli box or something new... */
         if (GetDeviceParameters (nDrive, &dp))
            switch (dp.bDevType)
               {
                  /* Floppy disk drive types */
               case 0x0: case 0x1: case 0x2: case 0x3:
               case 0x4: case 0x7: case 0x8:
                  return (EX_DRIVE_FLOPPY);
               }
         return (EX_DRIVE_REMOVABLE);  /* Unknown removable media type */
         break;
      case DRIVE_FIXED:
            /* GetDeviceParameters returns a device type of 0x05 for */
            /* hard disks. Because hard disks and RAM disks are the two */
            /* types of fixed-media drives, we assume that any fixed- */
            /* media drive that isn't a hard disk is a RAM disk. */
         if (GetDeviceParameters (nDrive, &dp) && dp.bDevType == 0x05)
            return (EX_DRIVE_FIXED);
         else
            return (EX_DRIVE_RAMDISK);
         break;
#endif
   UINT uType;
   CHAR achRoot[4];

   achRoot[0] = 'A'+nDrive;
   achRoot[1] = ':';
   achRoot[2] = '\\';
   achRoot[3] = 0;
   uType = GetDriveTypeA (achRoot);
   switch (uType)
      {
      case DRIVE_REMOVABLE:
         return (EX_DRIVE_REMOVABLE);  /* Unknown removable media type */
      case DRIVE_FIXED:
         return (EX_DRIVE_FIXED);
      case DRIVE_REMOTE:
         return (EX_DRIVE_REMOTE);
      case DRIVE_CDROM:
         return (EX_DRIVE_CDROM);
      case DRIVE_RAMDISK:
         return (EX_DRIVE_RAMDISK);
      }
   return (EX_DRIVE_INVALID);   /* Drive is invalid if we get here. */
   }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\setup\boot\genthk.h ===
/***************************************************************************
**
**	File:		genthk.h
**	Purpose:	Prototypes for Generic Thunk API's.
**	Notes:
**		These API's (exported from the NT Kernel) allow 16-bit
**		apps to call 32-bit DLL's when running under Windows NT WOW
**		(Windows on Windows).  This interface is called 'Generic
**		Thunking,' not to be confused with Win32s Universal Thunks,
**		which provides this functionality under Window 3.1.
**
****************************************************************************/

#ifndef GENTHK_H
#define GENTHK_H


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif


DWORD FAR PASCAL LoadLibraryEx32W ( LPCSTR, DWORD, DWORD );
DWORD FAR PASCAL GetProcAddress32W ( DWORD, LPCSTR );
DWORD FAR PASCAL GetVDMPointer32W ( LPVOID, UINT );
BOOL  FAR PASCAL FreeLibrary32W ( DWORD );

/* NOTE: CallProc32W can take a variable number of
*	parameters.  The prototype below is for calling
*	a Win32 API which takes no arguments.
*/
DWORD FAR PASCAL CallProc32W ( LPVOID, DWORD, DWORD );


typedef DWORD (FAR PASCAL * PFNGETVERSION32) ();
#define CallGetVersion32(hProc)	\
	((*((PFNGETVERSION32) hProc)) ())
	

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif

#endif  /* GENTHK_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\setup\boot\virwinn.c ===
#include <windows.h>
#include "stdtypes.h"
/*
**  VIRWINN.C
**
**  This is an attempt at virus detection.  The routine FVirCheck
**  should be called sometime during the boot process, and takes
**  one argument, a handle to the application instance.  The
**  ComplainAndQuit() call should be replaced with code appropriate
**  to your application.  It is recommended that this bring up
**  a dialog with an error message, and give the user the option of
**  continuing (defaults to terminating).  If the user chooses to
**  terminate (or if the option is not given), ComplainAndQuit()
**  should clean up anything that has been done so far, and exit.
*/
/*  WARNING!! Do not change WHashGood at all!!
**  WARNING!! WHashGood must be a near procedure, compiled native.
*/

/*
**  EXE header format definitions.  Lifted from linker.
*/

#define EMAGIC      0x5A4D  /* Old magic number */
#define ERES2WDS    0x000A  /* No. of reserved words in e_res2 */

struct exe_hdr  /* DOS 1, 2, 3 .EXE header */
    {
    unsigned short e_magic; /* Magic number */
    unsigned short e_cblp;  /* Bytes on last page of file */
    unsigned short e_cp;    /* Pages in file */
    unsigned short e_crlc;  /* Relocations */
    unsigned short e_cparhdr;   /* Size of header in paragraphs */
    unsigned short e_minalloc;  /* Minimum extra paragraphs needed */
    unsigned short e_maxalloc;  /* Maximum extra paragraphs needed */
    unsigned short e_ss;    /* Initial (relative) SS value */
    unsigned short e_sp;    /* Initial SP value */
    unsigned short e_csum;  /* Checksum */
    unsigned short e_ip;    /* Initial IP value */
    unsigned short e_cs;    /* Initial (relative) CS value */
    unsigned short e_lfarlc;    /* File address of relocation table */
    unsigned short e_ovno;  /* Overlay number */
    unsigned long e_sym_tab;    /* offset of symbol table file */
    unsigned short e_flags; /* old exe header flags  */
    unsigned short e_res;   /* Reserved words */
    unsigned short e_oemid; /* OEM identifier (for e_oeminfo) */
    unsigned short e_oeminfo;   /* OEM information; e_oemid specific */
    unsigned short e_res2[ERES2WDS];    /* Reserved words */
    long e_lfanew;  /* File address of new exe header */
    };

/*
** NEW EXE format definitions.  Lifted from linker
*/

#define NEMAGIC 0x454E  /* New magic number */
#define NERESBYTES  8   /* Eight bytes reserved (now) */
#define NECRC       8   /* Offset into new header of NE_CRC */

struct new_exe  /* New .EXE header */
    {
    unsigned short  ne_magic;   /* Magic number NE_MAGIC */
    unsigned char   ne_ver; /* Version number */
    unsigned char   ne_rev; /* Revision number */
    unsigned short  ne_enttab;  /* Offset of Entry Table */
    unsigned short  ne_cbenttab;    /* Number of bytes in Entry Table */
    long        ne_crc; /* Checksum of whole file */
    unsigned short  ne_flags;   /* Flag word */
    unsigned short  ne_autodata;    /* Automatic data segment number */
    unsigned short  ne_heap;    /* Initial heap allocation */
    unsigned short  ne_stack;   /* Initial stack allocation */
    long        ne_csip;    /* Initial CS:IP setting */
    long        ne_sssp;    /* Initial SS:SP setting */
    unsigned short  ne_cseg;    /* Count of file segments */
    unsigned short  ne_cmod;    /* Entries in Module Reference Table */
    unsigned short  ne_cbnrestab;   /* Size of non-resident name table */
    unsigned short  ne_segtab;  /* Offset of Segment Table */
    unsigned short  ne_rsrctab; /* Offset of Resource Table */
    unsigned short  ne_restab;  /* Offset of resident name table */
    unsigned short  ne_modtab;  /* Offset of Module Reference Table */
    unsigned short  ne_imptab;  /* Offset of Imported Names Table */
    long        ne_nrestab; /* Offset of Non-resident Names Table */
    unsigned short  ne_cmovent; /* Count of movable entries */
    unsigned short  ne_align;   /* Segment alignment shift count */
    unsigned short  ne_cres;    /* Count of resource entries */
    unsigned char   ne_exetyp;  /* Target operating system */
    unsigned char   ne_flagsothers; /* Other .EXE flags */
    char        ne_res[NERESBYTES];
    /* Pad structure to 64 bytes */
    };

/*
**  WHashGood()
**
**  This returns the correct hash value.
**
**  WARNING!! This routine must not be altered in ANY way.  It gets
**  patched and/or rewritten by VIRPATCH!!
*/

unsigned near WHashGood ( void );
unsigned near WHashGood ()
{
    return (0x1234);
}

/*
**  WHash(wHash, rgb, cb)
**
**  Update hash value to account for cb new bytes pointed to by rgb.
**  Old hash value is wHash; returns new hash value.
**
**  We do the hash on a word basis; the hash function is a simple
**  rotate and add.
*/

unsigned WHash ( unsigned wHash, BYTE rgb[], int cb );
unsigned WHash ( unsigned wHash, BYTE rgb[], int cb )
{
    while (cb > 1)
        {
#pragma warning(disable:4213)   /* nonstandard extension : cast on l-value */
        wHash = (wHash << 3) + (wHash >> 13) + *((int *)rgb)++;
#pragma warning(default:4213)
        cb -= 2;
        }
    if (cb != 0)
        wHash = (wHash << 3) + (wHash >> 13) + *rgb;
    return (wHash);
}

/*
**  FVirCheck(hinst)
**
**  This is the main virus detection routine.  It should be called
**  during boot, with a handle to the application instance.
**  The detection method used is to hash the EXE headers; this
**  hash value will change if the number or type of segments change,
**  or if their length changes.
*/

BOOL FVirCheck ( HANDLE hinst );
BOOL FVirCheck ( HANDLE hinst )
{
    int fh;
    unsigned wHash;
    unsigned cb, cbT;
    long lPos;
    char sz[256+1];
    BYTE rgb[512];
#define pehdr ((struct exe_hdr *)rgb)
#define pnex ((struct new_exe *)rgb)

    /* First we have to get a handle to the executable file.
       Unfortunately, although Windows already has this file open,
       there's no way to use its handle.  Instead we have to reopen
       the file. */

    if (GetModuleFileName(hinst, (char far *)sz, 256) == 0)
        return TRUE; //This shouldn't happen but still continue loading

    if ((fh = OpenFile((LPSTR)sz, (LPOFSTRUCT)rgb, OF_READ)) == -1)
        {
        /* We can't open the file.  This should never happen; if
           it does, it means we're in a weird state, and probably
           did something wrong in this code.  We'll just say
           everything is OK, and continue the boot. */
        return TRUE;
        }
    /* Read old header */
    if (_lread(fh, (LPSTR)rgb, sizeof (struct exe_hdr)) != sizeof (struct
        exe_hdr) ||
        pehdr->e_magic != EMAGIC)
        goto Corrupted;
    /* Hash old header */
    wHash = WHash(0, rgb, sizeof (struct exe_hdr));
    lPos = pehdr->e_lfanew;
    /* Read new header (and some more) */
    if (lPos == 0 || _llseek(fh, lPos, 0) != lPos ||
        _lread(fh, (LPSTR)rgb, 512) != 512 || pnex->ne_magic != NEMAGIC)
        goto Corrupted;
    /* Figure out size of total header; nonresident table is last part
       of header. */
    cb = (unsigned)(pnex->ne_nrestab - lPos) + pnex->ne_cbnrestab;
    /* Do hash on buffer basis */
    while (cb > 512)
        {
        /* Hash this buffer */
        wHash = WHash(wHash, rgb, 512);
        cb -= 512;
        cbT = (cb > 512 ? 512 : cb);
        /* and read in next */
        if (_lread(fh, (LPSTR)rgb, cbT) != cbT)
            goto Corrupted;
        }
    /* Update hash for final partial buffer, and compare with good value. */
    if (WHash(wHash, rgb, cb) != WHashGood())
        {
Corrupted:
        /* We've got an error reading the file or, more likely,
           a hash mismatch.  Close the file, give an error, and
           quit. */
        _lclose(fh);
        /* CHANGE THE FOLLOWING LINE TO CODE APPROPRIATE TO YOUR
        ** APPLICATION!!
        ** This should be replaced with code giving an error message (such as
        ** "Application file is corrupted").  It is recommended that this
        ** bring up
        ** a dialog with an error message, and give the user the option of
        ** continuing (defaults to terminating).  If the user chooses to
        ** terminate (or if the option is not given), ComplainAndQuit()
        ** should clean up anything that has been done so far, and exit.
        */

        /*  MessageBox(NULL, "Executable File Corrupted", 
        *                   "WARNING", MB_ICONSTOP | MB_OK);
        */

        /* ComplainAndQuit();
        */
        /* END OF CHANGE */
        return FALSE;
        }
    /* Everything's OK. Just close the file, and continue. */
    _lclose(fh);
    return TRUE;
#undef pehdr
#undef pnex
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\setup\inc\ctl3d.h ===
/*-----------------------------------------------------------------------
|	CTL3D.DLL
|	
|	Adds 3d effects to Windows controls
|
|	See ctl3d.doc for info
|		
-----------------------------------------------------------------------*/
#ifdef __cplusplus
extern "C" {
#endif


BOOL WINAPI Ctl3dSubclassDlg(HWND, WORD);
BOOL WINAPI Ctl3dSubclassDlgEx(HWND, DWORD);
WORD WINAPI Ctl3dGetVer(void);
BOOL WINAPI Ctl3dEnabled(void);
HBRUSH WINAPI Ctl3dCtlColor(HDC, LONG);	// ARCHAIC, use Ctl3dCtlColorEx
HBRUSH WINAPI Ctl3dCtlColorEx(UINT wm, WPARAM wParam, LPARAM lParam);
BOOL WINAPI Ctl3dColorChange(void);
BOOL WINAPI Ctl3dSubclassCtl(HWND);
LONG WINAPI Ctl3dDlgFramePaint(HWND, UINT, WPARAM, LPARAM);

BOOL WINAPI Ctl3dAutoSubclass(HANDLE);

BOOL WINAPI Ctl3dRegister(HANDLE);
BOOL WINAPI Ctl3dUnregister(HANDLE);

/* Ctl3dSubclassDlg3d flags */
#define CTL3D_BUTTONS		0x0001
#define CTL3D_LISTBOXES		0x0002		
#define CTL3D_EDITS			0x0004	
#define CTL3D_COMBOS			0x0008		
#define CTL3D_STATICTEXTS	0x0010		
#define CTL3D_STATICFRAMES	0x0020

#define CTL3D_NODLGWINDOW       0x00010000
#define CTL3D_ALL				0xffff

#define WM_DLGBORDER (WM_USER+3567)
/* WM_DLGBORDER *(int FAR *)lParam return codes */
#define CTL3D_NOBORDER		0
#define CTL3D_BORDER			1

#define WM_DLGSUBCLASS (WM_USER+3568)
/* WM_DLGSUBCLASS *(int FAR *)lParam return codes */
#define CTL3D_NOSUBCLASS	0
#define CTL3D_SUBCLASS		1

/* Resource ID for 3dcheck.bmp (for .lib version of ctl3d) */
#define CTL3D_3DCHECK 26567


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\setup\boot\setup.c ===
#include <windows.h>
#if 0
#include <stdtypes.h>
#endif
#include <stdio.h>
#include <stdlib.h>
#include <direct.h>
#include <dos.h>
#include <sys\types.h>
#include <sys\stat.h>
#include <ctype.h>      /* isspace */
#include <io.h>
#include <limits.h>     /* UINT_MAX */
#include <memory.h>     /* _fmemcpy, _fmemccpy */
#include <lzexpand.h>
#include <shellapi.h>   /* HKEY, HKEY_CLASSES_ROOT, ERROR_SUCCESS */
#include "setup.h"
#include "genthk.h"     /* thunks for calls to get 32-bit version */
#include "driveex.h"
#include <stdtypes.h>

/* Messages for optional background task.
*/
#define IDM_ACME_STARTING 261
#define IDM_ACME_COMPLETE 262
#define IDM_ACME_FAILURE  263

#ifdef APPCOMP
#include <decomp.h>
#endif /* APPCOMP */
#include <fdi.h>


/* List file extension */
char szLstExt[] = "LST";


/* List file section names */
char szDefaultParamsSect[] = "Params";
char szDefaultFilesSect[]  = "Files";

char szWin3xParamsSect[]   = "Win3.x Params";
char szWin3xFilesSect[]    = "Win3.x Files";

char szWin95ParamsSect[]   = "Windows 95 Params";
char szWin95FilesSect[]    = "Windows 95 Files";

char szNTIntelParamsSect[] = "NT Intel Params";
char szNTIntelFilesSect[]  = "NT Intel Files";

char szNTVerIntelParamsSect[] = "NT3.51 Intel Params";
char szNTVerIntelFilesSect[]  = "NT3.51 Intel Files";

char * szParamsSect = szNull;
char * szFilesSect  = szNull;

typedef struct _PLATFORM_SPEC
{
    BYTE minMajorVersion;
    BYTE minMinorVersion;
    char *szParamsSect;
    char *szFilesSect;
} PLATFORM_SPEC, *PPLATFORM_SPEC;

PLATFORM_SPEC aIntelSpec[] =
{
    {3, 51, szNTVerIntelParamsSect, szNTVerIntelFilesSect},
    {0,  0, szNTIntelParamsSect,    szNTIntelFilesSect},
    {0,  0, NULL,           NULL}
};

PLATFORM_SPEC aEmptySpec[] =
{
    {0,  0, NULL,           NULL}
};

// Note: this is indexed by PROCESSOR_ARCHITECTURE_xxx
//       definitions in ntexapi.h
//
PPLATFORM_SPEC aaPlatformSpecs[] =
{
    aIntelSpec,     // PROCESSOR_ARCHITECTURE_INTEL 0
    aEmptySpec,     // PROCESSOR_ARCHITECTURE_MIPS  1
    aEmptySpec,     // PROCESSOR_ARCHITECTURE_ALPHA 2
    aEmptySpec,     // PROCESSOR_ARCHITECTURE_PPC   3
    aEmptySpec,     // PROCESSOR_ARCHITECTURE_SHX   4
    aEmptySpec,     // PROCESSOR_ARCHITECTURE_ARM   5
    aIntelSpec,     // PROCESSOR_ARCHITECTURE_IA64  6
    aEmptySpec,     // PROCESSOR_ARCHITECTURE_ALPHA64 7
    aEmptySpec,     // PROCESSOR_ARCHITECTURE_MSIL  8
    aIntelSpec      // PROCESSOR_ARCHITECTURE_AMD64 9
};

/* Bootstrapper class name */
char szBootClass[]  = "STUFF-BOOT";

/* String buffer sizes */
#define cchLstLineMax       128
#define cchWinExecLineMax   (256 + cchFullPathMax)

/* No. of retries to attempt when removing files or dirs,
*   or when executing a chmod.
*/
#define cRetryMax   1200

/* SetErrorMode flags */
#define fNoErrMes 1
#define fErrMes   0

/* Quiet Mode -- Note: EEL must be kept in sync with acmsetup.h */
typedef UINT EEL;       /* Exit Error Level */
#define eelSuccess            ((EEL)0x0000)
#define eelBootstrapperFailed ((EEL)0x0009) /* Used only in Bootstrapper! */

EEL  eelExitErrorLevel = eelBootstrapperFailed;
BOOL fQuietMode        = fFalse;
BOOL fExeced           = fFalse;
BOOL fWin31            = fFalse;

/* Forward Declarations */
VOID    CleanUpTempDir ( char *, char * );
BRC     BrcInstallFiles ( char *, char *, char * );
BOOL    FCreateTempDir ( char *, char * );
BRC     BrcCopyFiles ( char *, char *, char * );
VOID    RemoveFiles ( char * );
BRC     BrcCopy ( char *, char * );
LONG    LcbFreeDrive ( int );
BOOL    FVirCheck ( HANDLE );
HWND    HwndInitBootWnd ( HANDLE );
LRESULT CALLBACK BootWndProc ( HWND, UINT, WPARAM, LPARAM );
BOOL    FGetFileSize ( char *, UINT * );
BRC     BrcBuildFileLists ( char *, UINT );
VOID    FreeFileLists ( VOID );
BOOL    FExecAndWait ( char *, HWND );
BOOL    FWriteBatFile ( OFSTRUCT, char *, char * );
BOOL    FLstSectionExists ( char * szLstFileName, char * szSect );
DWORD   GetCpuArchitecture();
BOOL    FNotifyAcme ( VOID );
BOOL    FGetAcmeErrorLevel ( EEL * peel );
BOOL    FCreateRegKey      ( CSZC cszcKey );
BOOL    FDoesRegKeyExist   ( CSZC cszcKey );
BOOL    FCreateRegKeyValue ( CSZC cszcKey, CSZC cszcValue );
BOOL    FGetRegKeyValue    ( CSZC cszcKey, SZ szBuf, CB cbBufMax );
VOID    DeleteRegKey       ( CSZC cszcKey );
BOOL    FFlushRegKey ( VOID );
BOOL    FWriteToRestartFile ( SZ szTmpDir );
BOOL    FCreateIniFileName ( SZ szIniFile, CB cbBufMax );
BOOL    FReadIniFile ( SZ szIniFile, HLOCAL * phlocal, PCB pcbBuf );
BOOL    FAllocNewBuf ( CB cbOld, SZ szTmpDir, SZ szSection, SZ szKey,
                        HLOCAL * phlocal, PCB pcbToBuf );
BOOL    FProcessFile ( HLOCAL hlocalFrom, HLOCAL hlocalTo, CB cbToBuf,
                        SZ szTmpDir, SZ szSection, SZ szKey );
VOID    CopyIniLine ( SZ szKey, SZ szTmpDir, SZ szFile, PSZ pszToBuf );
BOOL    FWriteIniFile ( SZ szIniFile, HLOCAL hlocalTo );
BRC     BrcInsertDisk(CHAR *pchStf, CHAR *pchSrcDrive);
BOOL    FRenameBadMaintStf ( SZ szStf );


/* Bootstrapper list file params */
char    rgchSetupDirName[cchLstLineMax];
#ifdef UNUSED   /* Replaced by DrvWinClass */
char    rgchDrvModName[cchLstLineMax];
#endif  /* UNUSED */
char    rgchDrvWinClass[cchLstLineMax];
char    rgchCmdLine[cchLstLineMax];
char    rgchBootTitle[cchLstLineMax];
char    rgchBootMess[cchLstLineMax];
char    rgchWin31Mess[cchLstLineMax];
char    rgchCabinetFName[cchLstLineMax];
char    rgchBackgroundFName[cchLstLineMax];
char    rgchBkgWinClass[cchLstLineMax];
char    rgchInsertCDMsg[cchLstLineMax];
char    rgchInsertDiskMsg[cchLstLineMax];
LONG    lcbDiskFreeMin;
int     cFirstCabinetNum;
int     cLastCabinetNum;
HANDLE  hSrcLst = NULL;
HANDLE  hDstLst = NULL;
char    rgchErrorFile[cchFullPathMax];
HANDLE  hinstBoot = NULL;
HWND    hwndBoot = NULL;


CHAR rgchInsufMem[cchSzMax] = "";
CHAR rgchInitErr[cchSzMax]  = "";
CHAR rgchSetup[cchSzMax]    = "";


/*
**  'Fixup' temp dir string by removing any subdirs and ensuring
**  extension is only one character.  (Note - Win3.0 has bug with
**  WinExec'ing some EXEs from a full 8.3 directory!)
**************************************************************************/
void FixupTempDirName( LPSTR szDir )
{
    LPSTR   szNext;
    int     cch = 0;

    if (*szDir == '\\'
        || *(AnsiNext(szDir)) == ':')
        {
        lstrcpy(szDir, "~msstfqf.t");
        return;
        }

    while (*szDir != '\\'
        && *szDir != '.'
        && *szDir != '\0'
        && *szDir != ':'
        && cch++ < 8)
        {
        szDir = AnsiNext(szDir);
        }

    szNext = AnsiNext(szDir);
    if (*szDir == '.'
        && *szNext != '.'
        && *szNext != '\\'
        && *szNext != '\0'
        && *szNext != ':')
        {
        *(AnsiNext(szNext)) = '\0';
        return;
        }

    *szDir = '\0';
    lstrcat(szDir, ".t");
}


/* Displays bootstrapper messages.
 * If fError is true, it's an error message, otherwise it's
 * just a message (e.g. insert disk 1).
**************************************************************************/
int DispErrBrc ( BRC brc, BOOL fError, UINT fuStyle,
                    const char *sz1, const char *sz2,
                    const char *sz3 )
{
    char rgchTitle[cchSzMax];
    char rgchMessage[256];
    char szBuf[256 + cchFullPathMax + 256];

#ifndef DEBUG
    if (fQuietMode)
        {
        return (IDCANCEL);
        }
#endif

    if (LoadString(hinstBoot, brcGen, rgchTitle, 256) == 0
        || LoadString(hinstBoot, brc, rgchMessage, 256) == 0)
        {
        MessageBox(hwndBoot, rgchInsufMem, rgchInitErr, MB_OK | MB_ICONSTOP);
        return 0;
        }
    
    if (!fError)
        lstrcpy(rgchTitle, rgchSetup);

    if (sz1 == NULL) sz1 = "";
    if (sz2 == NULL) sz2 = "";
    if (sz3 == NULL) sz3 = "";

    if (brc == brcFile)
        wsprintf(szBuf, rgchMessage, (LPSTR)AnsiUpper(rgchErrorFile));
    else if (brc == brcDS || brc == brcMemDS)
        wsprintf(szBuf, rgchMessage, lcbDiskFreeMin / 1024L);
    else
        wsprintf(szBuf, rgchMessage, sz1, sz2, sz3);

    if ((brc == brcMemDS || brc == brcNoSpill)
        && LoadString(hinstBoot, brcMemDSHlp, rgchMessage, 256))
        {
        lstrcat(szBuf, rgchMessage);
        }
    else if (brc == brcConnectToSource
        && LoadString(hinstBoot, brcConnectHlp, rgchMessage, 256))
        {
        lstrcat(szBuf, rgchMessage);
        }

    return (MessageBox(hwndBoot, szBuf, rgchTitle, fuStyle));
}


/*
**  Purpose:
**      Installs Setup executable in a temporary directory on an
**      available hardrive, and launches Setup.  After Setup
**      completes, removes the temporary files and directory.
**  Arguments:
**      Standard Windows WinMain args.
**  Returns:
**      Returns eelExitErrorLevel.  0 == Success.
**************************************************************************/
int WINAPI WinMain ( HINSTANCE hInstance, HINSTANCE hPrevInstance,
                     LPSTR lpszCmdParam, int nCmdShow )
{
    char    chDrive;
    char    rgchDstDir[cchFullPathMax] = " :\\";   // WARN: kept as OEM chars
    char    * szDstDirSlash = szNull;
    char    rgchModuleFileName[cchFullPathMax]; // WARN: kept as ANSI chars
    char    rgchLstFileName[cchFullPathMax];
    char    rgchTemp[cchFullPathMax];
    char    rgchSrcDir[cchFullPathMax];   
    UINT    cbLstSize;
    char    rgchWinExecLine[cchWinExecLineMax];
    UINT    uiRes;
    int     iModLen;
    BRC     brc;
    BOOL    fCleanupTemp = FALSE;
    LPSTR   sz;
    HWND    hWndBkg = 0;  /* window of background task */
    UINT    hMod;

    Unused(nCmdShow);
    hinstBoot = hInstance;

    rgchErrorFile[0] = '\0';
    
    if (LoadString(hinstBoot, IDS_InsufMem, rgchInsufMem,
            sizeof rgchInsufMem) == 0
        || LoadString(hinstBoot, IDS_InitErr, rgchInitErr,
            sizeof rgchInitErr) == 0
        || LoadString(hinstBoot, IDS_Setup, rgchSetup,
            sizeof rgchSetup) == 0)
        {
        /* REVIEW: If these LoadStrngs fail, the user will never know...
        *   But we can't hard-code strings in an .h file because INTL
        *   requires all localizable strings to be in resources!
        */
#ifdef DEBUG
        MessageBox(NULL, "Initial LoadString's failed; probably out of memory.",
                    szDebugMsg, MB_OK | MB_ICONEXCLAMATION);

#endif /* DEBUG */
        }
                                           
    for (sz = lpszCmdParam; *sz != '\0'; sz = AnsiNext(sz))
        {
        if ((*sz == '-' ||  *sz == '/')
                && toupper(*(sz+1)) == 'Q' && toupper(*(sz+2)) == 'T')
            {
            fQuietMode = fTrue;
            break;
            }
        }

/*
 * REVIEW: Check that this code is still functional before restoring it.
 */
#if VIRCHECK
    if (!FVirCheck(hInstance))
        {
        DispErrBrc(brcVir, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        goto LCleanupAndExit;
        }
#endif

    if (hPrevInstance || FindWindow(szBootClass, NULL) != NULL)
        {
        DispErrBrc(brcInst, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        goto LCleanupAndExit;
        }

    GetModuleFileName(hInstance, rgchModuleFileName, cchFullPathMax);

    /*
     * If the first switch on the command line is /M, then it specifies
     * the real module name to use.
     */
    if ((lpszCmdParam[0] == '-' || lpszCmdParam[0] == '/')
            && toupper(lpszCmdParam[1]) == 'M')
        {
        char *pCh, *pCh2;
        BOOL fQuotedFileName;
        
        /* Skip the spaces */
        for (pCh = lpszCmdParam+2; *pCh == ' '; pCh++);
        fQuotedFileName = (*pCh == '\"');
        if (fQuotedFileName)
            {
            pCh++;
            }
        
        /* Copy the file name, and add the EOS */
        lstrcpy(rgchModuleFileName, pCh);
        for (pCh2=rgchModuleFileName; 
            (*pCh2 != ' ' || fQuotedFileName) && 
            (*pCh2 != '\"' || !fQuotedFileName) && 
             *pCh2 != '\0'; 
            pCh2++);
        *pCh2 = '\0';
        
        /* Remove the /M param from the command line */
        lpszCmdParam = pCh + lstrlen(rgchModuleFileName);
        if (fQuotedFileName && *lpszCmdParam == '\"')
            {
            lpszCmdParam++;
            }

        /* Remove trailing whitespace from the command line */
        for (pCh = lpszCmdParam; *pCh == ' '; pCh++);
        lpszCmdParam = pCh;
        }


    OemToAnsiBuff(rgchModuleFileName, rgchModuleFileName, sizeof(rgchModuleFileName));

    // Windows 3.0 bug with UNC paths - prepends windows drive letter
    sz = (LPSTR)rgchModuleFileName;
    if (*sz != '\0'
        && *sz != '\\'
        && *(sz = AnsiNext(sz)) == ':'
        && *(sz = AnsiNext(sz)) == '\\'
        && *AnsiNext(sz) == '\\')
        {
        LPSTR szDst = (LPSTR)rgchModuleFileName;

        while ((*szDst++ = *sz++) != '\0')
            ;
        }

    iModLen = lstrlen(rgchModuleFileName);
    lstrcpy(rgchSrcDir, rgchModuleFileName);
    sz = (LPSTR)&rgchSrcDir[iModLen];
    while (sz > (LPSTR)rgchSrcDir && *sz != '\\')
        sz = AnsiPrev(rgchSrcDir, sz);
    Assert(sz > (LPSTR)rgchSrcDir);
    *(AnsiNext(sz)) = '\0';               

    /*
     * If the first switch on the command line is /L, then it specifies
     * the name of the .lst file to use.
     */
    rgchTemp[0] = '\0';
    if ((lpszCmdParam[0] == '-' || lpszCmdParam[0] == '/')
            && toupper(lpszCmdParam[1]) == 'L')
        {
        char *pCh, *pCh2;
        
        /* Skip the spaces */
        for (pCh = lpszCmdParam+2; *pCh == ' ' && *pCh != '\0'; pCh++);
        
        /* Copy the .lst file name, and add the newline */
        lstrcpy(rgchTemp, pCh);
        for (pCh2=rgchTemp; *pCh2 != ' ' && *pCh2!= '\0'; pCh2++);
        *pCh2 = '\0';
        
        /* Remove the /L param from the command line */
        lpszCmdParam = pCh + lstrlen(rgchTemp);
        for (pCh = lpszCmdParam; *pCh == ' ' && *pCh != '\0'; pCh++);
        lpszCmdParam = pCh;
        }


    /* If there is something on the command line, use it as the .lst file */
    if (*rgchTemp != '\0')
        {
        lstrcpy(rgchLstFileName, rgchSrcDir);
        lstrcat(rgchLstFileName, rgchTemp);
        }
    else
        {
        lstrcpy(rgchLstFileName, rgchModuleFileName);
        sz = (LPSTR)&rgchLstFileName[iModLen];
        while (sz > (LPSTR)rgchLstFileName && *sz != '.')
            sz = AnsiPrev(rgchLstFileName, sz);
        Assert(sz > (LPSTR)rgchLstFileName);
        *(AnsiNext(sz)) = '\0';
        lstrcat(rgchLstFileName, szLstExt);
        }

    if (!FGetFileSize(rgchLstFileName, &cbLstSize) || cbLstSize == 0)
        {
        lstrcpy(rgchErrorFile, rgchLstFileName);
        DispErrBrc(brcFile, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        goto LCleanupAndExit;
        }

#ifndef WF_WINNT
#define WF_WINNT 0x4000
#endif

    /* Attempt to use appropriate platform.
    */
    szParamsSect = szNull;
    szFilesSect  = szNull;

    if (1)
        {
        DWORD dwVers = 0;
        DWORD dwCpuArchitecture;
        DWORD dwMajorVersion;
        DWORD dwMinorVersion;
        PPLATFORM_SPEC pPlatformSpec;

        dwCpuArchitecture = GetCpuArchitecture();

        dwVers = GetVersion();
        dwMajorVersion = LOBYTE(LOWORD(dwVers));
        dwMinorVersion = HIBYTE(LOWORD(dwVers));

        if (dwCpuArchitecture < (sizeof (aaPlatformSpecs) / sizeof(aaPlatformSpecs[0])))
            {
            pPlatformSpec = aaPlatformSpecs[dwCpuArchitecture];
            } 
        else 
            {
            pPlatformSpec = aEmptySpec;
            }

        for (; pPlatformSpec->szParamsSect != NULL; pPlatformSpec++)
            {
            if (((pPlatformSpec->minMajorVersion < dwMajorVersion) || 
                 (pPlatformSpec->minMajorVersion == dwMajorVersion && pPlatformSpec->minMinorVersion <= dwMinorVersion)) &&
                FLstSectionExists(rgchLstFileName, pPlatformSpec->szParamsSect))
                {
                szParamsSect = pPlatformSpec->szParamsSect;
                szFilesSect  = pPlatformSpec->szFilesSect;
                break;
                }
            }
        }
    else    /* non-WinNT */
        {
        if (FLstSectionExists(rgchLstFileName, szWin95ParamsSect)
            && (LOBYTE(LOWORD(GetVersion())) > 3
                || HIBYTE(LOWORD(GetVersion())) >= 95))
            {
            szParamsSect = szWin95ParamsSect;
            szFilesSect  = szWin95FilesSect;
            }
        else
            {
            fWin31 = fTrue;
            if (FLstSectionExists(rgchLstFileName, szWin3xParamsSect))
                {
                szParamsSect = szWin3xParamsSect;
                szFilesSect  = szWin3xFilesSect;
                }
            }
        }

    if (szParamsSect == szNull)
        {
        if (FLstSectionExists(rgchLstFileName, szDefaultParamsSect))
            {
            szParamsSect = szDefaultParamsSect;
            szFilesSect  = szDefaultFilesSect;
            }
        else
            {
            DispErrBrc(brcNoCpuSect, TRUE, MB_OK | MB_ICONSTOP, NULL,
                    NULL, NULL);
            goto LCleanupAndExit;
            }
        }

    if (GetPrivateProfileString(szParamsSect, "TmpDirName", "",
                rgchSetupDirName, cchLstLineMax, rgchLstFileName) <= 0
        || (lcbDiskFreeMin = GetPrivateProfileInt(szParamsSect,
                "TmpDirSize", 0, rgchLstFileName) * 1024L) <= 0
        || (cFirstCabinetNum = GetPrivateProfileInt(szParamsSect,
                "FirstCabNum", 1, rgchLstFileName)) <= 0
        || (cLastCabinetNum = GetPrivateProfileInt(szParamsSect,
                "LastCabNum", 1, rgchLstFileName)) <= 0
#ifdef UNUSED
        || GetPrivateProfileString(szParamsSect, "DrvModName", "",
                rgchDrvModName, cchLstLineMax, rgchLstFileName) <= 0
#endif  /* UNUSED */
        || GetPrivateProfileString(szParamsSect, "DrvWinClass", "",
                rgchDrvWinClass, cchLstLineMax, rgchLstFileName) <= 0
        || GetPrivateProfileString(szParamsSect, "CmdLine", "", rgchCmdLine,
                cchLstLineMax, rgchLstFileName) <= 0
	//|| GetPrivateProfileString(szParamsSect, "Require31", "",
	//	rgchWin31Mess, cchLstLineMax, rgchLstFileName) <= 0
        || GetPrivateProfileString(szParamsSect, "WndTitle", "",
                rgchBootTitle, cchLstLineMax, rgchLstFileName) <= 0
        || GetPrivateProfileString(szParamsSect, "WndMess", "",
                rgchBootMess, cchLstLineMax, rgchLstFileName) <= 0)
        {
        DispErrBrc(brcLst, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        goto LCleanupAndExit;
        }

    if (FindWindow(rgchDrvWinClass, NULL) != NULL)
        {
        DispErrBrc(brcInst, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        goto LCleanupAndExit;
        }

    GetPrivateProfileString(szParamsSect, "CabinetFile", "",
            rgchCabinetFName, cchLstLineMax, rgchLstFileName);

    GetPrivateProfileString(szParamsSect, "InsertCDMsg", "",
            rgchInsertCDMsg, cchLstLineMax, rgchLstFileName);

    GetPrivateProfileString(szParamsSect, "InsertDiskMsg", "",
            rgchInsertDiskMsg, cchLstLineMax, rgchLstFileName);

    if (rgchWin31Mess[0] != '\0'
        && LOBYTE(LOWORD((DWORD)GetVersion())) == 3
        && HIBYTE(LOWORD((DWORD)GetVersion())) < 10)
        {
        if (!fQuietMode)
            {
            char rgchTitle[cchSzMax];
    
            if (LoadString(hinstBoot, brcGen, rgchTitle, 256) == 0)
                lstrcpy(rgchTitle, rgchSetup);
            MessageBox(hwndBoot, rgchWin31Mess, rgchTitle,
                        MB_OK | MB_ICONSTOP);
            }
        goto LCleanupAndExit;
        }

    FixupTempDirName(rgchSetupDirName);

    for (sz = rgchBootMess; *sz != '\0'; sz = AnsiNext(sz))
        if (*sz == '\\' && *(sz+1) == 'n')
            {
            *sz++ = '\r';
            *sz   = '\n';
            }

    /* If there is a /W then is specifies we are in add/remove mode with
       the setup app not installed. We need to read it off CD/Floppy/Network
      */
    if ((lpszCmdParam[0] == '-' || lpszCmdParam[0] == '/')
            && toupper(lpszCmdParam[1]) == 'W')
        {
        CHAR    rgchStf[_MAX_PATH];
        char *pCh, *pCh2, *pCh3;
        
        /* Skip the spaces */
        for (pCh = lpszCmdParam+2; *pCh == ' ' && *pCh != '\0'; pCh++);
        
        lstrcpy(rgchStf, rgchSrcDir);
        pCh3 = rgchStf + lstrlen(rgchStf);
        /* Copy the .stf file name, and add the newline */
        for (pCh2=pCh; *pCh2 != ' ' && *pCh2!= '\0'; pCh2++)
            *pCh3++ = *pCh2;
        *pCh3 = '\0';
    
        /* Remove the /W parameter */
        lpszCmdParam = pCh2;

        /* Get them to insert the correct disk */
        if ((brc = BrcInsertDisk(rgchStf, rgchSrcDir)) != brcOkay)
            {
            if (brc != brcMax)
                DispErrBrc(brc, TRUE, MB_OK | MB_ICONSTOP, rgchStf, NULL, NULL);
            goto LCleanupAndExit;
            }
        }

    GetPrivateProfileString(szParamsSect, "Background", "",
            rgchBackgroundFName, cchLstLineMax, rgchLstFileName);
    GetPrivateProfileString(szParamsSect, "BkgWinClass", "",
            rgchBkgWinClass, cchLstLineMax, rgchLstFileName);
    if (rgchBackgroundFName[0] != '\0')
        {
        lstrcpy(rgchTemp, rgchSrcDir);
        lstrcat(rgchTemp, rgchBackgroundFName);
        if (rgchBkgWinClass[0] != '\0')
            {
            lstrcat(rgchTemp, " /C");
            lstrcat(rgchTemp, rgchBkgWinClass);
            }
        lstrcat(rgchTemp, " /T");
        lstrcat(rgchTemp, rgchBootTitle);
        lstrcat(rgchTemp, " /M");
        lstrcat(rgchTemp, rgchBootMess);

        hMod = WinExec(rgchTemp, SW_SHOWNORMAL);  /* ignore if exec failed */
#ifdef DEBUG
        if (hMod < 32)
            {
            wsprintf(szDebugBuf, "%s: Background WinExec failed.",
                        rgchBackgroundFName);
            MessageBox(NULL, szDebugBuf, szDebugMsg, MB_OK | MB_ICONSTOP);
            }
#endif  /* DEBUG */

        hWndBkg = FindWindow(rgchBkgWinClass, rgchBootTitle);
        }
    if (!hWndBkg && (hwndBoot = HwndInitBootWnd(hInstance)) == NULL)
            {
            DispErrBrc(brcMem, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
            goto LCleanupAndExit;
            }

    if ((brc = BrcBuildFileLists(rgchLstFileName, cbLstSize)) != brcOkay)
        {
        DispErrBrc(brc, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        goto LCleanupAndExit;
        }
    
    lstrcat(rgchDstDir, "~MSSETUP.T");
    szDstDirSlash = rgchDstDir + lstrlen(rgchDstDir);
    lstrcat(rgchDstDir, "\\");

    lstrcat(rgchDstDir, rgchSetupDirName);
    AnsiToOem(rgchDstDir, rgchDstDir);
    for (chDrive = 'Z'; chDrive >= 'A'; --chDrive)
        {
        UINT fModeSav;
        BOOL fDriveFixed;

        fModeSav = SetErrorMode(fNoErrMes);
        fDriveFixed = (GetDriveTypeEx(chDrive - 'A') == EX_DRIVE_FIXED);
        SetErrorMode(fModeSav);
        if (fDriveFixed)
            {
            *rgchDstDir = chDrive;
            brc = BrcInstallFiles(rgchSrcDir, rgchDstDir, szDstDirSlash);
            if (brc == brcOkay)
                break;
            if (brc == brcFile)
                {
                DispErrBrc(brc, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
                goto LCleanupAndExit;
                }
            else if (brc == brcNoSpill)
                {
                /* Message already handled in HfOpenSpillFile */
                goto LCleanupAndExit;
                }
            }
        }

    if (chDrive < 'A')
        {
        uiRes = GetWindowsDirectory(rgchDstDir, cchFullPathMax);
        Assert(uiRes > 0);
#if DBCS    // [J1] Fixed DBCS raid #46.
        AnsiUpper(rgchDstDir);
#endif
        /* BLOCK */
            {
            LPSTR sz = (LPSTR)&rgchDstDir[uiRes];

            sz = AnsiPrev(rgchDstDir, sz);
            if (*sz != '\\')
                lstrcat(rgchDstDir, "\\");
            }

        lstrcat(rgchDstDir, "~MSSETUP.T");
        szDstDirSlash = rgchDstDir + lstrlen(rgchDstDir);
        lstrcat(rgchDstDir, "\\");

        Assert(lstrlen(rgchDstDir) + lstrlen(rgchSetupDirName)
                < cchFullPathMax);
        lstrcat(rgchDstDir, rgchSetupDirName);
        AnsiToOem(rgchDstDir, rgchDstDir);
        brc = BrcInstallFiles(rgchSrcDir, rgchDstDir, szDstDirSlash);
        if (brc != brcOkay)
            {
            /* NoSpill message already handled in HfOpenSpillFile */
            if (brc != brcNoSpill)
                {
                DispErrBrc(brc, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
                }
            goto LCleanupAndExit;
            }
        }

    hSrcLst = LocalFree(hSrcLst);   /* don't need src list anymore */
    Assert(hSrcLst == NULL);

    /* Use full path to .exe; don't rely on cwd (fails under Win95).
    */
    /* block */
        {
        char rgchTmp[cchWinExecLineMax];

        wsprintf(rgchTmp, rgchCmdLine, (LPSTR)rgchSrcDir,
                lpszCmdParam);

        Assert(lstrlen(rgchTmp) + lstrlen(rgchDstDir) + 1 < cchWinExecLineMax);

        lstrcpy(rgchWinExecLine, rgchDstDir);
        lstrcat(rgchWinExecLine, "\\");
        lstrcat(rgchWinExecLine, rgchTmp);
        }
    GlobalCompact((DWORD)(64L * 1024L));
    fCleanupTemp = TRUE;

    if (!fWin31 && !FNotifyAcme())
        {
#if DEBUG
        DispErrBrc(brcRegDb, TRUE, MB_OK | MB_ICONEXCLAMATION, NULL, NULL, NULL);
#endif /* DEBUG */
        /* Try running Acme anyway. */
        }
    if (!fWin31 && !FWriteToRestartFile(rgchDstDir))
        {
#ifdef DEBUG
        MessageBox(NULL, "Write to restart file failed. Setup can continue, "
                    "but some initialization files might not get removed "
                    "if Setup must restart Windows.",
                    szDebugMsg, MB_OK | MB_ICONEXCLAMATION);

#endif /* DEBUG */
        /*
         *  Any errors encountered will have been displayed where they occured.
         *  Try running Acme anyway.
         */
        }
    if (hWndBkg)
        SendMessage(hWndBkg, WM_COMMAND, IDM_ACME_STARTING, 0);

    if (!FExecAndWait(rgchWinExecLine, hwndBoot))
        {
        DispErrBrc(brcMem, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        goto LCleanupAndExit;
        }
    fExeced = fTrue;

LCleanupAndExit:
    if (fCleanupTemp && szDstDirSlash != szNull)
        CleanUpTempDir(rgchDstDir, szDstDirSlash);
    FreeFileLists();
    eelExitErrorLevel = eelBootstrapperFailed;
    if (fExeced && !FGetAcmeErrorLevel(&eelExitErrorLevel))
        {
#ifdef UNUSED
        /* NOTE: Removed to avoid the message on WinNT.  On NT, Acme can
        *   exit and the bootstrapper can kick in before the restart
        *   actually happens, causing this message (since Acme has already
        *   removed the reg key as part of its reboot cleanup).  We'll
        *   leave the eelFailed value, though, since no one should be
        *   relying on it at reboot anyway, and it may help catch other
        *   problems down the road.
        */
        DispErrBrc(brcRegDb, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
#endif /* UNUSED */
        Assert(eelExitErrorLevel == eelBootstrapperFailed);
        }
    if (hwndBoot != NULL)
        DestroyWindow(hwndBoot);
    if (hWndBkg && IsWindow(hWndBkg))
        {
        SendMessage(hWndBkg, WM_COMMAND, eelExitErrorLevel == eelSuccess ?
                    IDM_ACME_COMPLETE : IDM_ACME_FAILURE, 0);
        if (IsWindow(hWndBkg))
            PostMessage(hWndBkg, WM_QUIT, 0, 0);
        }
    return (eelExitErrorLevel);
}


/*
**  Purpose:
**      Creates and temporary subdirectory at the given path,
**      appends it to the given path, and copies the Setup files
**      into it.
**  Arguments:
**      szModule: Full path to bootstrapper's directory (ANSI chars).
**      rgchDstDir: Full path to destination directory (OEM chars).
**  Returns:
**      One of the following Bootstrapper return codes:
**          brcMem    out of memory
**          brcDS     out of disk space
**          brcMemDS  out of memory or disk space
**          brcFile   expected source file missing
**          brcOkay   completed without error
**************************************************************************/
BRC BrcInstallFiles ( char * szModule, char * rgchDstDir,
                    char * szDstDirSlash )
{
    BRC brc;

    if (LcbFreeDrive(*rgchDstDir - 'A' + 1) < lcbDiskFreeMin)
        return (brcDS);
    if (!FCreateTempDir(rgchDstDir, szDstDirSlash))
        return (brcMemDS);
    if ((brc = BrcCopyFiles(szModule, rgchDstDir, szDstDirSlash)) != brcOkay)
        {
        CleanUpTempDir(rgchDstDir, szDstDirSlash);
        return (brc);
        }

    SetFileAttributes(rgchDstDir, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY);

    Assert(szDstDirSlash);
    Assert(*szDstDirSlash == '\\');
    *szDstDirSlash = '\0';
    SetFileAttributes(rgchDstDir, FILE_ATTRIBUTE_HIDDEN | FILE_ATTRIBUTE_READONLY);
    *szDstDirSlash = '\\';

    return (brcOkay);
}


/*
**  Purpose:
**      Removes the temporary files and directory.
**  Arguments:
**      rgchDstDir: Full path to temp directory (OEM chars).
**  Returns:
**      None.
**************************************************************************/
VOID CleanUpTempDir ( char * rgchDstDir, char * szDstDirSlash )
{
    char rgchRoot[] = " :\\";
    int i;

    RemoveFiles(rgchDstDir);

    rgchRoot[0] = *rgchDstDir;
    _chdir(rgchRoot);

    SetFileAttributes(rgchDstDir, FILE_ATTRIBUTE_NORMAL);

    /* Try to remove the directory up to cRetryMax times.
    */
    for (i = 0; i < cRetryMax; i++)
        {
        if (_rmdir(rgchDstDir) == 0)
            break;
        }

    Assert(szDstDirSlash);
    Assert(*szDstDirSlash == '\\');
    *szDstDirSlash = '\0';
    SetFileAttributes(rgchDstDir, FILE_ATTRIBUTE_NORMAL);

    /* Try to remove the directory up to cRetryMax times.
    */
    for (i = 0; i < cRetryMax; i++)
        {
        if (_rmdir(rgchDstDir) == 0)
            break;
        }

    *szDstDirSlash = '\\';
}


/*
**  Purpose:
**      Creates a temporary subdirectory at the given path,
**      and appends it to the given path.
**  Arguments:
**      rgchDir: Full path to destination directory (OEM chars).
**  Returns:
**      TRUE if directory was successfully created,
**      FALSE if not.
**************************************************************************/
BOOL FCreateTempDir ( char * rgchDir, char * szDstDirSlash )
{
    char    rgchTmp[cchFullPathMax];
    FILE *  fp;
    char *  pch;
    int     fErr;
    int     i = 0;

    pch = (char *)(&rgchDir[lstrlen(rgchDir)]);
    Assert(*pch == '\0');
    _chdrive(*rgchDir - 'A' + 1);

    Assert(szDstDirSlash);
    Assert(*szDstDirSlash == '\\');
    *szDstDirSlash = '\0';
    _mkdir(rgchDir);
    *szDstDirSlash = '\\';

    while (!_access(rgchDir, 0))
        {
        if (!_chdir(rgchDir))
            {
            /* verify dir is write-able */
            lstrcpy(rgchTmp, rgchDir);
            lstrcat(rgchTmp, "\\tXXXXXX");
            Assert(lstrlen(rgchTmp) < cchFullPathMax);
            if (_mktemp(rgchTmp) != NULL
                && (fp = fopen(rgchTmp, "w")) != NULL)
                {
                fErr = fclose(fp);
                Assert(!fErr);

                fErr = remove(rgchTmp);
#ifdef DBCS     // [J2] Fixed DBCS raid #28.
                if (fErr)       // Keep the directory name
                    *pch = '\0';
#else
                *pch = '\0';
#endif
                return (!fErr);
                }
            }
        if (++i > 9)
            break;
        _itoa(i, pch, 10);
        Assert(lstrlen(rgchDir) < cchFullPathMax);
        }

    if (i <= 9 && !_mkdir(rgchDir))
        {
        fErr = _chdir(rgchDir);
        Assert(!fErr);
#ifdef DBCS     // [J2] Fixed DBCS raid #28.
//      Keep the directory name
#else
        *pch = '\0';
#endif
        return (TRUE);
        }

    *pch = '\0';

    return (FALSE);
}

/*
**  Purpose:
**      Reopens BAT file and writes DEL or RMDIR line.
**  Arguments:
**      of:    OFSTRUCT to REOPEN.
**      szCmd: Command (ANSI chars).  ["DEL" or "RMDIR"]
**      szArg: Fully qualified pathname for argument (OEM chars).
**  Returns:
**      TRUE or FALSE.
**************************************************************************/
BOOL FWriteBatFile ( OFSTRUCT of, char * szCmd, char * szArg )
{
    int     fhBat = -1;
    BOOL    fRet = TRUE;

    if ((fhBat = OpenFile("a", &of, OF_REOPEN | OF_WRITE)) == -1
        || _llseek(fhBat, 0L, 2) == -1L
        || _lwrite(fhBat, szCmd, lstrlen(szCmd)) != (UINT)lstrlen(szCmd)
        || _lwrite(fhBat, (LPSTR)" ", 1) != 1
        || _lwrite(fhBat, szArg, lstrlen(szArg)) != (UINT)lstrlen(szArg)
        || _lwrite(fhBat, (LPSTR)"\r\n", 2) != 2)
        {
        fRet = FALSE;
        }

    if (fhBat != -1)
        {
        int fErr = _lclose(fhBat);

        Assert(fErr != -1);
        }

    return (fRet);
}

#ifdef DEBUG
/*
**  Purpose:
**      Checks if destination filename is a valid 8.3 name with no path
*/
BOOL FValidFATFileName ( char* szName )
{
    int  iLen, ch;
    for (iLen = 0; (ch = *szName++) != '\0'; iLen++)
        {
        if (ch <= ' ' || ch == '\\' || ch == ':' || ch == ',')
            return fFalse;
        if (ch == '.')
            {
            if (iLen == 0 || iLen > 8)
                return fFalse;
            iLen = 9;
            }
        if (iLen == 8 || iLen == 13)
            return fFalse;
        }
    return (iLen > 0);
}
#endif  /* DEBUG */


/*
**  Purpose:
**      Copies the source files into the given destination dir.
**  Arguments:
**      szModule: Source path (ANSI chars).
**      szDstDir: Destination path (OEM chars).
**  Returns:
**      One of the following bootstrapper return codes:
**          brcMem    out of memory
**          brcDS     out of disk space
**          brcMemDS  out of memory or disk space
**          brcFile   expected source file missing
**          brcOkay   completed without error
**************************************************************************/
BRC BrcCopyFiles ( char * szModule, char * szDstDir, char * szDstDirSlash )
{
    char        rgchSrcFullPath[cchFullPathMax];
    char        rgchDstFullPath[cchFullPathMax];
    char        rgchTmpDirPath[cchFullPathMax];
    char *      szSrc;
    char *      szDst;
    int         cbSrc;
    BRC         brc = brcOkay;
    int         fhBat = -1;
    OFSTRUCT    ofBat;
    int         fErr;
    BOOL        fCabinetFiles = FALSE;

    lstrcpy(rgchDstFullPath, szDstDir);
    lstrcat(rgchDstFullPath, "\\_MSSETUP._Q_");
    Assert(lstrlen(rgchDstFullPath) < cchFullPathMax);
    _chmod(rgchDstFullPath, S_IREAD | S_IWRITE);
    remove(rgchDstFullPath);

    OemToAnsiBuff(rgchDstFullPath, rgchDstFullPath, sizeof(rgchDstFullPath));
    fhBat = OpenFile(rgchDstFullPath, &ofBat, OF_CREATE | OF_WRITE);
    AnsiToOem(rgchDstFullPath, rgchDstFullPath);
    if (fhBat == -1)
        return (brcMemDS);

    fErr = _lclose(fhBat);
    Assert(!fErr);

    szSrc = (char *)LocalLock(hSrcLst);
    if (szSrc == NULL)
         return (brcMem);

    szDst = (char *)LocalLock(hDstLst);
    
    if (szDst == NULL) {
        LocalUnlock (hSrcLst);
        return (brcMem);
    }

    for (;
        (cbSrc = lstrlen(szSrc)) != 0;
        szSrc += cbSrc + 1, szDst += lstrlen(szDst) + 1)
        {
        
        //
        //  This code has been added so that we can detect a path
        //  in setup.lst for the right hand side of the equals sign.  This
        //  allows us flexiblity in specifying where files like setup.inf
        //  should be pulled from, otherwise we always use the files from
        //  the original source location.  If we detect "<anything>:\" or
        //  "\\" then we assume it is a path.
        //
        if( ((':' == szSrc[1]) && ('\\' == szSrc[2])) ||
            (('\\' == szSrc[0]) && ('\\' == szSrc[1])) )
        {
            rgchSrcFullPath[0] = '\0';
        }
        else
        {
            lstrcpy(rgchSrcFullPath, szModule);
        }

        lstrcat(rgchSrcFullPath, szSrc);
        lstrcpy(rgchDstFullPath, szDstDir);
        lstrcat(rgchDstFullPath, "\\");
        lstrcat(rgchDstFullPath, szDst);
#ifdef DEBUG
        if (!FValidFATFileName(szDst))
            {
            wsprintf(szDebugBuf, "Invalid destination file, must be 8.3: %s",
                        szDst);
            MessageBox(NULL, szDebugBuf, szDebugMsg, MB_OK | MB_ICONSTOP);
            continue;
            }
#endif  /* DEBUG */
        Assert(lstrlen(rgchSrcFullPath) < cchFullPathMax);
        Assert(lstrlen(rgchDstFullPath) < cchFullPathMax);
        if (   !FWriteBatFile(ofBat, "ATTRIB -R", rgchDstFullPath)
            || !FWriteBatFile(ofBat, "DEL",       rgchDstFullPath))
            {
            brc = brcDS;
            break;
            }

        if (*szSrc == '@')  /* cabinet file */
            {
            if (*rgchCabinetFName == '\0')
                {
                brc = brcFile;
#ifdef DEBUG
                lstrcpy(rgchErrorFile, ". Missing CABINET= line");
#endif //DEBUG
                break;
                }
            fCabinetFiles = TRUE;
            continue;
            }

        if ((brc = BrcCopy(rgchSrcFullPath, rgchDstFullPath)) != brcOkay)
            break;
        _chmod(rgchDstFullPath, S_IREAD);
        }
    LocalUnlock(hSrcLst);
    LocalUnlock(hDstLst);

    lstrcpy(rgchDstFullPath, szDstDir);
    lstrcat(rgchDstFullPath, "\\_MSSETUP._Q_");
    Assert(lstrlen(rgchDstFullPath) < cchFullPathMax);

    Assert(szDstDirSlash != szNull);
    Assert(*szDstDirSlash == chDirSep);
    *szDstDirSlash = chEos;
    lstrcpy(rgchTmpDirPath, szDstDir);
    *szDstDirSlash = chDirSep;

    if (brc == brcOkay
        && (!FWriteBatFile(ofBat, "DEL", rgchDstFullPath)
        || !FWriteBatFile(ofBat, "RMDIR", szDstDir)
        || !FWriteBatFile(ofBat, "RMDIR", rgchTmpDirPath)))
        {
        return (brcDS);
        }

    if (fCabinetFiles && brc == brcOkay)
        {
        szSrc = (char *)LocalLock(hSrcLst);
        if(szSrc == NULL)
            return (brcMem);

        szDst = (char *)LocalLock(hDstLst);
        if( szDst == NULL) {
            LocalUnlock (hSrcLst);
            return (brcMem);
        }
#ifdef DEBUG
        if (!FValidFATFileName(rgchCabinetFName))
            {
            wsprintf(szDebugBuf, "Invalid cabinet file, must be 8.3: %s",
                            rgchCabinetFName);
            MessageBox(NULL, szDebugBuf, szDebugMsg, MB_OK | MB_ICONSTOP);
            }
        else            
#endif  /* DEBUG */

        brc = BrcHandleCabinetFiles(hwndBoot, rgchCabinetFName,
                    cFirstCabinetNum, cLastCabinetNum, szModule, szDstDir,
                    szSrc, szDst, rgchErrorFile, rgchDstFullPath);

        LocalUnlock(hSrcLst);
        LocalUnlock(hDstLst);
        }

    return (brc);
}


/*
**  Purpose:
**      Removes the files previously copied to the temp dest dir.
**  Arguments:
**      szDstDir: full path to destination directory (OEM chars).
**  Returns:
**      None.
**************************************************************************/
VOID RemoveFiles ( char * szDstDir )
{
    char    rgchDstFullPath[cchFullPathMax];
    char *  szDst;
    int     cbDst;
    int     i;
    OFSTRUCT ofs;
    UINT    fModeSav;

    fModeSav = SetErrorMode(fNoErrMes);
    szDst = (char *)LocalLock(hDstLst);
    
    if (szDst == NULL)
        return;

    for (; (cbDst = lstrlen(szDst)) != 0; szDst += cbDst + 1)
        {
        lstrcpy(rgchDstFullPath, szDstDir);
        lstrcat(rgchDstFullPath, "\\");
        lstrcat(rgchDstFullPath, szDst);
        Assert(lstrlen(rgchDstFullPath) < cchFullPathMax);
        
        /* Don't try to remove the file if it doesn't exist */
        if (OpenFile(rgchDstFullPath, &ofs, OF_EXIST) == HFILE_ERROR)
            continue;

        /* Try to _chmod the file up to cRetryMax times.
        */
        for (i = 0; i < cRetryMax; i++)
            {
            if (_chmod(rgchDstFullPath, S_IWRITE) == 0)
                break;
            FYield();
            }

        /* Try to remove the file up to cRetryMax times.
        */
        for (i = 0; i < cRetryMax; i++)
            {
            if (remove(rgchDstFullPath) == 0)
                break;
            FYield();
            }
        }

    LocalUnlock(hDstLst);
    SetErrorMode(fModeSav);

    lstrcpy(rgchDstFullPath, szDstDir);
    lstrcat(rgchDstFullPath, "\\_MSSETUP._Q_");
    Assert(lstrlen(rgchDstFullPath) < cchFullPathMax);
    _chmod(rgchDstFullPath, S_IWRITE);
    remove(rgchDstFullPath);
}


/*
**  Purpose:
**      Copies the given source file to the given destination.
**  Arguments:
**      szFullPathSrc: full path name of source file (ANSI chars).
**      szFullPathDst: full path name of destination file (OEM chars).
**  Returns:
**      One of the following bootstrapper return codes:
**          brcMem    out of memory
**          brcDS     out of disk space
**          brcMemDS  out of memory or disk space
**          brcFile   expected source file missing
**          brcOkay   completed without error
**************************************************************************/
BRC BrcCopy ( char * szFullPathSrc, char * szFullPathDst )
{
    int         fhSrc = -1;
    int         fhDst = -1;
    OFSTRUCT    ofSrc, ofDst;
    BRC         brc = brcMemDS;
    int         fErr;

#ifdef APPCOMP
    if ((fhSrc = OpenFile(szFullPathSrc, &ofSrc, OF_READ)) == -1)
        {
        brc = brcFile;
        lstrcpy(rgchErrorFile, szFullPathSrc);
        goto CopyFailed;
        }
#endif /* APPCOMP */

    /* REVIEW: BUG: if szFullPathDst is an existing subdirectory
    ** instead of a file, we'll fail trying to open it, think we're
    ** out of disk space, and go back up to try another disk.
    ** This is acceptable for now.
    */
    _chmod(szFullPathDst, S_IREAD | S_IWRITE);
    OemToAnsiBuff(szFullPathDst, szFullPathDst, cchFullPathMax);
    fhDst = OpenFile(szFullPathDst, &ofDst, OF_CREATE | OF_WRITE);
    AnsiToOem(szFullPathDst, szFullPathDst);
    if (fhDst == -1)
        goto CopyFailed;

#ifdef APPCOMP
    if (WReadHeaderInfo(fhSrc) > 0)
        {
        LONG lRet;

        lRet = LcbDecompFile(fhSrc, fhDst, -1, 0, TRUE, NULL, 0L, NULL, 0,
                NULL);
        if (lRet < 0L)
            {
            if (lRet == (LONG)rcOutOfMemory)
                brc = brcMem;
            if (lRet == (LONG)rcWriteError)
                brc = brcDS;
            goto CopyFailed;
            }
        FFreeHeaderInfo();
        }
    else    /* copy the file using LZExpand */
#endif /* APPCOMP */
        {
        HFILE   hSrcLZ;
        DWORD   dwRet;

#ifdef APPCOMP
        fErr = _lclose(fhSrc);
        Assert(!fErr);
        fhSrc = -1;
#endif /* APPCOMP */

        if ((hSrcLZ = LZOpenFile(szFullPathSrc, &ofSrc, OF_READ)) == -1)
            {
            brc = brcFile;
            lstrcpy(rgchErrorFile, szFullPathSrc);
            goto CopyFailed;
            }

        /* We would like to yield more often, but LZCopy has no callbacks */
        FYield();
        
        dwRet = LZCopy(hSrcLZ, fhDst);
        LZClose(hSrcLZ);

        if (dwRet >= LZERROR_UNKNOWNALG)
            {
            if (dwRet == LZERROR_GLOBALLOC)
                brc = brcMem;
            if (dwRet == LZERROR_WRITE)
                brc = brcDS;
            goto CopyFailed;
            }
        }

    brc = brcOkay;

CopyFailed:
#ifdef APPCOMP
    if (fhSrc != -1)
        {
        fErr = _lclose(fhSrc);
        Assert(!fErr);
        }
#endif /* APPCOMP */
    if (fhDst != -1)
        {
        fErr = _lclose(fhDst);
        Assert(!fErr);
        }

    return (brc);
}


/*
**  Purpose:
**      Determine the storage space remaining on disk.
**  Arguments:
**      nDrive: drive number (1='A', 2='B', etc.)
**  Returns:
**      Number of bytes free on disk,
**      or 0 if not a valid drive.
+++
**  Implementation:
**      Calls DOS interrupt 21h, funct 36h.
**************************************************************************/
LONG LcbFreeDrive ( int nDrive )
{
    LONG        lcbRet;
        CHAR            achRoot[4];
        ULARGE_INTEGER  freeBytes;

        achRoot[0] = 'A'+nDrive-1;
        achRoot[1] = ':';
        achRoot[2] = '\\';
        achRoot[3] = 0;
        memset(&freeBytes, 0, sizeof(freeBytes));
        
        GetDiskFreeSpaceEx(achRoot, &freeBytes, 0, 0);
        lcbRet = freeBytes.LowPart;

    /* KLUDGE: Drives bigger than 2 GB can return zero total space!
    */
    if (lcbRet < 0L || lcbRet > (999999L * 1024L))
        {
        return (999999L * 1024L);
        }

    return (lcbRet);
}


/*
**  Purpose:
**      Creates and displays bootstrapper window.
**  Arguments:
**      hInstance: process instance handle
**  Returns:
**      Window handle to bootstrapper window, or
**      NULL if the window could not be created.
**************************************************************************/
HWND HwndInitBootWnd ( HANDLE hInstance )
{
    WNDCLASS    wc;
    HWND        hwnd;
    int         cx, cy;

    wc.style = 0;
    wc.lpfnWndProc = BootWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = 0;
    wc.hInstance = hInstance;
    wc.hIcon = NULL;
    wc.hCursor = NULL;
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = szBootClass;
    if (!RegisterClass(&wc))
        return (NULL);

    cx = GetSystemMetrics(SM_CXSCREEN) / 2;
    cy = GetSystemMetrics(SM_CYSCREEN) / 3;

    hwnd = CreateWindow(szBootClass, rgchBootTitle,
            WS_DLGFRAME, cx / 2, cy, cx, cy, NULL, NULL, hInstance, NULL);

    if (hwnd == NULL)
        return (NULL);

    if (!fQuietMode)
        {
        ShowWindow(hwnd, SW_SHOWNORMAL);
        UpdateWindow(hwnd);
        }

    return (hwnd);
}

// ripped off from mvdm\wow32\wgtext.c
ULONG GetTextExtent(HDC hdc, LPSTR lpstr, int cbString)
{
    ULONG ul = 0;
    SIZE size4;

    if ((GetTextExtentPoint(
                    hdc,
                    lpstr,
                    cbString,
                    &size4
                   )))
    {
        // check if either cx or cy are bigger than SHRT_MAX == 7fff
        // but do it in ONE SINGLE check

        if ((size4.cx | size4.cy) & ~SHRT_MAX)
        {
            if (size4.cx > SHRT_MAX)
               ul = SHRT_MAX;
            else
               ul = (ULONG)size4.cx;

            if (size4.cy > SHRT_MAX)
               ul |= (SHRT_MAX << 16);
            else
               ul |= (ULONG)(size4.cy << 16);
        }
        else
        {
            ul = (ULONG)(size4.cx | (size4.cy << 16));
        }

    }
    return (ul);
}

/*
**  Purpose:
**      WndProc for bootstrapper window.
**  Arguments:
**      Standard Windows WndProc arguments.
**  Returns:
**      Result of call DefWindowProc, or zero if WM_PAINT message.
**************************************************************************/
LRESULT CALLBACK BootWndProc ( HWND hwnd, UINT wMsgID, WPARAM wParam,
                            LPARAM lParam )
{
    HDC         hdc;
    PAINTSTRUCT ps;
    RECT        rect;
    UINT        iMargin;

    switch (wMsgID)
        {
#ifdef DBCS     // [J3] Fixed KK raid #12.
        case WM_CREATE:
            {
            if (!fQuietMode)
                {
                int x, y, cx, cy;
                hdc = BeginPaint(hwnd, &ps);
                GetClientRect(hwnd, &rect);
                cx = (LOWORD(GetTextExtent(hdc, rgchBootMess, lstrlen(rgchBootMess))) + 13) / 14 * 16 + 2;
                if (cx > rect.right)
                    {
                    if (cx > GetSystemMetrics(SM_CXSCREEN))
                        cx = GetSystemMetrics(SM_CXSCREEN);
                    x = (GetSystemMetrics(SM_CXSCREEN) - cx) / 2;
                    y = cy = GetSystemMetrics(SM_CYSCREEN) / 3;
                    SetWindowPos(hwnd, NULL, x, y, cx, cy, SWP_NOZORDER);
                    }
                EndPaint(hwnd, &ps);
                }
            break;
            }
#endif
        case WM_PAINT:
            if (!fQuietMode)
                {
                hdc = BeginPaint(hwnd, &ps);
                GetClientRect(hwnd, &rect);
                iMargin = rect.right / 16;
                rect.top    = rect.bottom / 2 - GetSystemMetrics(SM_CYCAPTION);
                rect.left   = iMargin;
                rect.right -= iMargin;
                SetBkMode(hdc, TRANSPARENT);
                DrawText(hdc, rgchBootMess, -1, &rect,
                         DT_WORDBREAK | DT_CENTER | DT_NOPREFIX);
                EndPaint(hwnd, &ps);
                }
            break;
        default:
            return (DefWindowProc(hwnd, wMsgID, wParam, lParam));
        }

    return (0L);
}


/*
**  Purpose:
**      Get size of file.
**  Arguments:
**      szFile:  List file name (full path, ANSI).
**      pcbSize: Pointer to variable to receive file size.
**  Returns:
**      FALSE if file found and size >= 64K.
**      TRUE otherwise.
**************************************************************************/
BOOL FGetFileSize ( char * szFile, UINT * pcbSize )
{
    int     fh;
    int     fErr;
    LONG    lcb;

    *pcbSize = 0;
    if ((fh = _lopen(szFile, OF_READ)) == -1)
        {
        return (TRUE);
        }
    
    if ((lcb = _llseek(fh, 0L, 2)) > 65535)
        {
#pragma warning(disable:4127)   /* conditional expression is constant */
        Assert(FALSE);
#pragma warning(default:4127)
        _lclose(fh);
        return (FALSE);
        }
    *pcbSize = (UINT)lcb;
    fErr = _lclose(fh);
    Assert(!fErr);

    return (TRUE);
}


/*
**  Purpose:
**      Build file Src and Dst lists from LST file.
**  Arguments:
**      szFile: List file name (full path, ANSI).
**      cbFile: Size of list file
**  Note:
**      Sets globals: hSrcLst, hDstLst.
**  Returns:
**      One of the following Bootstrapper return codes:
**          brcMem    out of memory
**          brcLst    list file is corrupted
**          brcOkay   completed without error
**************************************************************************/
BRC BrcBuildFileLists ( char * szFile, UINT cbFile )
{
    char    rgchDst[cchLstLineMax];
    char *  szSrc;
    char *  szDst;
    char *  pchDstStart;
    int     cbSrc;
    UINT    i;
    HANDLE  hTemp;

    /* Build Src List */

    if ((hSrcLst = LocalAlloc(LMEM_MOVEABLE, cbFile)) == NULL)
        return (brcMem);
    szSrc = (char *)LocalLock(hSrcLst);
    if(szSrc == (char *)NULL)
        return (brcMem);

    i = GetPrivateProfileString(szFilesSect, NULL, "", szSrc, cbFile, szFile);
    if (i <= 0)
        {
        LocalUnlock(hSrcLst);
        hSrcLst = LocalFree(hSrcLst);
        Assert(hSrcLst == NULL);
        return (brcLst);
        }
    Assert(i+1 < cbFile);
    szSrc[i++] = '\0';  /* force double zero at end */
    szSrc[i++] = '\0';
    LocalUnlock(hSrcLst);
    hTemp = LocalReAlloc(hSrcLst, i, LMEM_MOVEABLE);
    if(hTemp == NULL)
        return (brcMem);
    hSrcLst = hTemp;

    /* Build Dst List */
    if ((hDstLst = LocalAlloc(LMEM_MOVEABLE, cbFile)) == NULL)
        {
        hSrcLst = LocalFree(hSrcLst);
        Assert(hSrcLst == NULL);
        return (brcMem);
        }

    szSrc = (char *)LocalLock(hSrcLst);
    if (szSrc == (char *)NULL)
        return (brcMem);

    szDst = pchDstStart = (char *)LocalLock(hDstLst);
    if (szDst == (char *)NULL) {
        LocalUnlock (hDstLst);
        return (brcMem);
    }

    for (;
        (cbSrc = lstrlen(szSrc)) != 0;
        szSrc += cbSrc + 1, szDst += lstrlen(szDst) + 1)
        {
        if (GetPrivateProfileString(szFilesSect, szSrc, "", rgchDst,
                cchLstLineMax, szFile) <= 0)
            {
            LocalUnlock(hSrcLst);
            LocalUnlock(hDstLst);
            FreeFileLists();
            return (brcLst);
            }
        AnsiToOem(rgchDst, rgchDst);
        lstrcpy(szDst, rgchDst);
        }
    *szDst = '\0';  /* force double zero at end */
    LocalUnlock(hSrcLst);
    LocalUnlock(hDstLst);
    hTemp = LocalReAlloc(hDstLst, (int)(szDst - pchDstStart) + 1,
            LMEM_MOVEABLE);
    if (hTemp == NULL)
        return (brcMem);
    hDstLst = hTemp;

    return (brcOkay);
}


/*
**  Purpose:
**      Frees file list buffers with non-NULL handles
**      and sets them to NULL.
**  Arguments:
**      none.
**  Returns:
**      none.
**************************************************************************/
VOID FreeFileLists ()
{
    if (hSrcLst != NULL)
        hSrcLst = LocalFree(hSrcLst);
    if (hDstLst != NULL)
        hDstLst = LocalFree(hDstLst);
    Assert(hSrcLst == NULL);
    Assert(hDstLst == NULL);
}



/*
**  Purpose:
**      Spawns off a process with WinExec and waits for it to complete.
**  Arguments:
**      szCmdLn: Line passed to WinExec (cannot have leading spaces).
**  Returns:
**      TRUE if successful, FALSE if not.
+++
**  Implementation:
**      GetModuleUsage will RIP under Win 3.0 Debug if module count is
**      zero (okay to ignore and continue), but the GetModuleHandle
**      check will catch all zero cases for single instances of the
**      driver, the usual case.  [Under Win 3.1 we will be able to
**      replace both checks with just an IsTask(hMod) check.]
**************************************************************************/
BOOL FExecAndWait ( char * szCmdLn, HWND hwndHide )
{
    UINT hMod;
    MSG msg;

    Assert(!isspace(*szCmdLn)); /* leading space kills WinExec */

    if ((hMod = WinExec(szCmdLn, SW_SHOWNORMAL)) > 32)
        {
        UINT i;
        UINT_PTR idTimer;
        
        /* KLUDGE: Give the app some time to create its main window.
        *
        *   On newer versions of NT, we were exiting the while loop
        *   (below) and cleaning up the temp dir before the app had
        *   even put up its window.
        *
        *   NOTE: In trials, we only had to retry once, so cRetryMax
        *   may be overkill, but it should be pretty rare that this
        *   would fail in shipping products anyway.
        */
        for (i = 0; i < cRetryMax; i++)
            {
            if(FindWindow(rgchDrvWinClass, NULL) != NULL)
                break;
            if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
                {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
                }
            }

        /* Set the timer to fire every 1/10 of a second. This is
            necessary because we might never return from GetMessage */
        idTimer = SetTimer(NULL, 0, 100, NULL);
        /*
        ** REVIEW - FindWindow() will wait until the LAST setup quits (not
        **  necessarily this setup.  If exec'ing a 16-bit app we could
        **  use the old code:
        **    while (GetModuleHandle(rgchDrvModName) && GetModuleUsage(hMod))
        **  but on NT this fails so for 32-bit apps we could attempt to
        **  remove one of the executable files (slow?).
        **
        ** REVIEW - This loop becomes a busy wait under NT, which is bad.
        **  However, it doesn't appear to affect ACME's performance
        **  noticeably.
        */
        while (FindWindow(rgchDrvWinClass, NULL) != NULL)
            {
            if (GetMessage(&msg, NULL, 0, 0))
                {
                TranslateMessage(&msg);
                DispatchMessage(&msg);
                }
            if (msg.message == WM_TIMER && hwndHide != (HWND)NULL)
                {
                ShowWindow(hwndHide, SW_HIDE);
                hwndHide = (HWND)NULL;
                }
            }
        if (idTimer != 0)
            KillTimer(0, idTimer);
        return (TRUE);
        }
#ifdef DEBUG
    wsprintf(szDebugBuf, "WinExec Error: %d", hMod);
    MessageBox(NULL, szDebugBuf, szDebugMsg, MB_OK | MB_ICONSTOP);
#endif  /* DEBUG */

    return (FALSE);
}


/*
**  Purpose: Processes messages that may be in the queue.
**  Arguments: none
**  Returns: none
**************************************************************************/
void PUBLIC FYield ( VOID )
{
    MSG  msg;

    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
        {
        TranslateMessage(&msg);
        DispatchMessage(&msg);
        }
}


/*
**************************************************************************/
BOOL FLstSectionExists ( char * szLstFileName, char * szSect )
{
    return (GetPrivateProfileString(szSect, "CmdLine", "", rgchCmdLine,
                cchLstLineMax, szLstFileName) > 0);
}



/*
**************************************************************************/
DWORD GetCpuArchitecture ()
{
    SYSTEM_INFO sysInfo;

    GetSystemInfo(&sysInfo);

    return sysInfo.wProcessorArchitecture;
}


static CSZC cszcBootstrapperKey = "MS Setup (ACME)\\Bootstrapper\\Exit Level";
static CSZC cszcEelRunning      = "Running";

/*
**  Purpose:
**      Lets Acme know the bootstrapper launched it.  So Acme will let
**      us know its exit error level.
**  Arguments:
**      none.
**  Returns:
**      fTrue if successful, fFalse otherwise.
**  Notes:
**      REVIEW: Probably should use DDE instead of the Registration
**      Database.
**************************************************************************/
BOOL FNotifyAcme ( VOID )
{
    if (!FCreateRegKey(cszcBootstrapperKey))
        {
        return (fFalse);
        }
    if (!FCreateRegKeyValue(cszcBootstrapperKey, cszcEelRunning))
        {
        return (fFalse);
        }
    if (!FFlushRegKey())
        {
        return (fFalse);
        }
    return (fTrue);
}


/*
**  Purpose:
**      Get the exit error level set by Acme and clean up the Registration
**      Database.
**  Arguments:
**      peel: Exit error level (to be set).
**  Returns:
**      fTrue if successful, fFalse otherwise.
**************************************************************************/
BOOL FGetAcmeErrorLevel ( EEL * peel )
{
    CHAR rgchValue[cchSzMax];

    if (FGetRegKeyValue(cszcBootstrapperKey, rgchValue, sizeof rgchValue))
        {
#ifdef DEBUG
        /*
         *  Assert(isdigit(rgchValue[0]));
         *  Assert(isdigit(rgchValue[1]) || rgchValue[1] == chEos);
         */
        UINT i;
        BOOL fValidValue = fFalse;

        /*  Assumes valid values are 1 or 2 digit numbers. */
        for (i = 0; rgchValue[i] != chEos; i++)
            {
            fValidValue = fTrue;
            if (!isdigit(rgchValue[i]) || i > 1)
                {
                fValidValue = fFalse;
                break;
                }
            }
        if (!fValidValue)
            {
            char szBuf[cchSzMax];
    
            wsprintf(szBuf, "RegKeyValue (%s)", rgchValue);
            MessageBox(NULL, szBuf, "Debug Assertion in FGetAcmeErrorLevel",
                        MB_OK | MB_ICONSTOP);
            }
#endif  /* DEBUG */

        *peel = atoi(rgchValue);
        DeleteRegKey(cszcBootstrapperKey);
        return (fTrue);
        }
    else
        {
        if (fWin31)
            {
            *peel = eelSuccess;
            return fTrue;
            }
        return (fFalse);
        }
}


/*
**  Purpose:
**      Creates a Registration Database key that is a subkey of
**      cszcBootstrapperKey.
****************************************************************************/
BOOL FCreateRegKey ( CSZC cszcKey )
{
    HKEY hkey;

    if (RegCreateKey(HKEY_CLASSES_ROOT, cszcKey, &hkey) != ERROR_SUCCESS)
        {
        DispErrBrc(brcRegDb, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        return (fFalse);
        }

    if (RegCloseKey(hkey) != ERROR_SUCCESS)
        {
        DispErrBrc(brcRegDb, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        return (fFalse);
        }

    return (fTrue);
}


/*
**  Purpose:
**      API to check for the existence of the specified key in
**      the Registration Database.
****************************************************************************/
BOOL FDoesRegKeyExist ( CSZC cszcKey )
{
    HKEY hkey;

    if (RegOpenKey(HKEY_CLASSES_ROOT, cszcKey, &hkey) != ERROR_SUCCESS)
        return (fFalse);

    RegCloseKey(hkey);

    return (fTrue);
}


/*
**  Purpose:
**      Creates a Registration Database key that is a subkey of
**      HKEY_CLASSES_ROOT and associates a value with the key.
****************************************************************************/
BOOL FCreateRegKeyValue ( CSZC cszcKey, CSZC cszcValue )
{
    if (RegSetValue(HKEY_CLASSES_ROOT, cszcKey, REG_SZ, cszcValue,
                    lstrlen(cszcKey)) != ERROR_SUCCESS)
        {
        DispErrBrc(brcRegDb, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        return (fFalse);
        }

    return (fTrue);
}


/*
**  Purpose:
**      Determines the value associated with the specified Registration
**      Database key.
****************************************************************************/
BOOL FGetRegKeyValue ( CSZC cszcKey, SZ szBuf, CB cbBufMax )
{
    LONG lcb = cbBufMax;

    if (szBuf != szNull && cbBufMax != 0)
        *szBuf = chEos;

    if (!FDoesRegKeyExist(cszcKey))
        return (fFalse);

    if (RegQueryValue(HKEY_CLASSES_ROOT, cszcKey, szBuf, &lcb)
            != ERROR_SUCCESS)
        {
        DispErrBrc(brcRegDb, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        return (fFalse);
        }

    Assert(lcb < cbMaxConst);

    return (fTrue);
}


/*
**  Purpose:
**      API to remove the specified Registration Database key,
**      its associated values, and subkeys.
****************************************************************************/
VOID DeleteRegKey ( CSZC cszcKey )
{
    char rgchKey[cchSzMax], rgchBuffer[cchSzMax];
    char *pch;
    HKEY hKeyT = NULL;
        
    lstrcpy(rgchKey, cszcKey);
    RegDeleteKey(HKEY_CLASSES_ROOT, rgchKey);
    pch = rgchKey + 1;

    while(pch > rgchKey)
        {
        pch = rgchKey + lstrlen(rgchKey);
        while (pch > rgchKey)
            {
            if (*pch == '\\')
                break;
            pch--;
            }
        if (*pch != '\\')
            break;
        *pch = '\0';
        if (RegOpenKey(HKEY_CLASSES_ROOT, rgchKey, &hKeyT) != ERROR_SUCCESS)
            break;
        if (RegEnumKey(hKeyT, 0, rgchBuffer, sizeof(rgchBuffer)) == ERROR_SUCCESS)
            {
            break;
            }

        RegCloseKey(hKeyT);
        hKeyT = NULL;
        RegDeleteKey(HKEY_CLASSES_ROOT, rgchKey);
        }

    if (hKeyT != NULL)
        RegCloseKey(hKeyT);
    
}


/*
**  Purpose:
**      API to flush the specified Registration Database key.
****************************************************************************/
BOOL FFlushRegKey ( VOID )
{
    /* REVIEW: Does 16 bit code need to flush the RegDb?  RegFlushKey is
        32 bit.
    if (RegFlushKey(HKEY_CLASSES_ROOT)) != ERROR_SUCCESS)
        {
        DispErrBrc(brcRegDb, TRUE, MB_OK | MB_ICONSTOP, NULL, NULL, NULL);
        return (fFalse);
        }
    */

    return (fTrue);
}


/*
**  Purpose:
**      Write temporary files to restart ini file.  So that if Acme reboots,
**      the files in the temporary directory will be removed.  Win95 only.
**  Arguments:
**      szTmpDir: Full path to destination directory (OEM chars).
**  Returns:
**      fTrue if successful, fFalse otherwise.
**
**  REVIEW: The files are removed, but not the temp directories.
**      There may be a way to do that via the wininit.ini file.
**      This should be looked into.
**************************************************************************/
BOOL FWriteToRestartFile ( SZ szTmpDir )
{
    char   rgchIniFile[_MAX_PATH];
    CB     cbFrom;
    CB     cbTo;
    HLOCAL hlocalFrom = (HLOCAL)NULL;
    HLOCAL hlocalTo   = (HLOCAL)NULL;
    BOOL   fRet = fFalse;

    SZ szSection = "rename";
    SZ szKey     = "NUL";

    /* This code is not used under NT. */
    if (1)
        {
        return (fTrue);
        }

    if (!FCreateIniFileName(rgchIniFile, sizeof rgchIniFile))
        {
        goto LCleanupAndReturn;
        }
    if (!FGetFileSize(rgchIniFile, &cbFrom))
        {
        goto LCleanupAndReturn;
        }
    if (!FReadIniFile(rgchIniFile, &hlocalFrom, &cbFrom))
        {
        goto LCleanupAndReturn;
        }
    if (!FAllocNewBuf(cbFrom, szTmpDir, szSection, szKey, &hlocalTo, &cbTo))
        {
        goto LCleanupAndReturn;
        }
    if (!FProcessFile(hlocalFrom, hlocalTo, cbTo, szTmpDir, szSection, szKey))
        {
        goto LCleanupAndReturn;
        }
    if (!FWriteIniFile(rgchIniFile, hlocalTo))
        {
        goto LCleanupAndReturn;
        }
    fRet = fTrue;

LCleanupAndReturn:
    if (hlocalFrom != (HLOCAL)NULL)
        {
        hlocalFrom = LocalFree(hlocalFrom);
        Assert(hlocalFrom == (HLOCAL)NULL);
        }
    if (hlocalTo != (HLOCAL)NULL)
        {
        hlocalTo = LocalFree(hlocalTo);
        Assert(hlocalTo == (HLOCAL)NULL);
        }

    return (fRet);
}


/*
**  Purpose:
**      Create the restart file name.
**  Arguments:
**      szIniFile: Buffer to hold file name.
**      cbBufMax:  Size of buffer.
**  Returns:
**      fTrue if successful, fFalse otherwise.
**************************************************************************/
BOOL FCreateIniFileName ( SZ szIniFile, CB cbBufMax )
{
    CB cbWinDir;

    cbWinDir = GetWindowsDirectory((LPSTR)szIniFile, cbBufMax);
    if (cbWinDir == 0)
        {
#pragma warning(disable:4127)   /* conditional expression is constant */
        Assert(fFalse); /*  Unusual if this happens. */
#pragma warning(default:4127)
        return (fFalse);
        }
    Assert(isalpha(*szIniFile));
    Assert(*(szIniFile + 1) == ':');

    if (*(AnsiPrev((LPSTR)szIniFile, (LPSTR)&szIniFile[cbWinDir])) != '\\')
        lstrcat((LPSTR)szIniFile, "\\");
    lstrcat((LPSTR)szIniFile, "wininit.ini");
    Assert((CB)lstrlen(szIniFile) < cbBufMax);

    return (fTrue);
}


/*
**  Purpose:
**      Read the data from the ini file
**  Arguments:
**      szIniFile: Ini file name
**      phlocal:   Pointer to memory handle.
**      pcbBuf:    Pointer to the number of bytes in the buffer.
**  Returns:
**      fTrue if successful, fFalse otherwise.
**************************************************************************/
BOOL FReadIniFile ( SZ szIniFile, HLOCAL * phlocal, PCB pcbBuf )
{
    UINT   fModeSav;
    HLOCAL hlocal;
    SZ     szBuf;
    CB     cbBuf;
    BOOL   fRet = fFalse;

    Assert(szIniFile != szNull);
    Assert(phlocal != (HLOCAL *)NULL);
    Assert(pcbBuf  != pcbNull);

    fModeSav = SetErrorMode(fNoErrMes);
    hlocal = *phlocal;
    cbBuf  = *pcbBuf;

    Assert(hlocal == (HLOCAL)NULL);

    if (cbBuf == 0) /* Ini file does not exist or is empty. */
        {
        /*  Alloc room for CR, LF, EOS. */
        hlocal = LocalAlloc(LMEM_MOVEABLE, 3);
        if (hlocal == NULL)
            {
#ifdef DEBUG
            MessageBox(NULL, "Out of memory in FReadIniFile.", szDebugMsg,
                MB_OK | MB_ICONEXCLAMATION);
#endif /* DEBUG */
            }
        else
            {
            szBuf = (SZ)LocalLock(hlocal);
            
            if(szBuf == szNull)
                return fFalse;

            *szBuf++ = chCR;
            *szBuf++ = chEol;
            *szBuf   = chEos;
            *pcbBuf = 2;
            fRet = fTrue;
            }
        }
    else
        {
        HFILE    hfile;
        OFSTRUCT ofs;
        CB       cbRead;

        /* Flush cache before calling OpenFile() */
        WritePrivateProfileString(szNull, szNull, szNull, szIniFile);
        hfile = OpenFile(szIniFile, &ofs, OF_READWRITE | OF_SHARE_EXCLUSIVE);
        if (hfile == HFILE_ERROR)
            {
#ifdef DEBUG
            wsprintf(szDebugBuf, "Can't open file: %s.", szIniFile);
            MessageBox(NULL, szDebugBuf, szDebugMsg,
                            MB_OK | MB_ICONEXCLAMATION);
#endif /* DEBUG */
            goto LCleanupAndReturn;
            }
        hlocal = LocalAlloc(LMEM_MOVEABLE, cbBuf + 1);
        if (hlocal == NULL)
            {
#ifdef DEBUG
        MessageBox(NULL, "Out of memory in FReadIniFile.", szDebugMsg,
            MB_OK | MB_ICONEXCLAMATION);
#endif /* DEBUG */
            }
        else
            {
            szBuf = (SZ)LocalLock(hlocal);
            if(szBuf == szNull)
                return fFalse;

            cbRead = (CB)_lread(hfile, szBuf, cbBuf + 1);
            if (cbRead == HFILE_ERROR)
                {
#ifdef DEBUG
                wsprintf(szDebugBuf, "Can't read file: %s.", szIniFile);
                MessageBox(NULL, szDebugBuf, szDebugMsg,
                                MB_OK | MB_ICONEXCLAMATION);
#endif /* DEBUG */
                }
            else
                {
                Assert(cbRead == cbBuf);
                *(szBuf + cbBuf) = chEos;
                fRet = fTrue;
                }
            }
        hfile = _lclose(hfile);
        Assert(hfile != HFILE_ERROR);
        }

LCleanupAndReturn:
    if (hlocal != NULL)
        {
        LocalUnlock(hlocal);
        }
    *phlocal = hlocal;
    SetErrorMode(fModeSav);

    return (fRet);
}


/*
**  Purpose:
**      Allocate buffer for new file.
**  Arguments:
**      cbOld:     Size of existing file
**      szTmpDir:  Full path to destination directory (OEM chars).
**      szSection: Ini section name
**      szKey:     Ini key name
**      phlocal:   Pointer to memory handle.
**      pcbToBuf:  Pointer to total size of new buffer.
**  Returns:
**      fTrue if successful, fFalse if LocalAlloc failed.
**************************************************************************/
BOOL FAllocNewBuf ( CB cbOld, SZ szTmpDir, SZ szSection, SZ szKey,
                    HLOCAL * phlocal, PCB pcbToBuf )
{
    UINT fModeSav;
    SZ   szDst;
    CB   cbDst;
    CB   cbOverhead;
    CB   cbNew;
    BOOL fRet = fFalse;

    fModeSav = SetErrorMode(fNoErrMes);
    szDst = (SZ)LocalLock(hDstLst);
    if(szDst == szNull)
        return fFalse;
    /*
     *  Added to the old file will be one line per temporary file
     *  and (possibly) a section line.  cbNew is initialized with
     *  the size of the section line, plus enough for the file
     *  (_MSSETUP._Q_) which is not in the DstLst.
     *
     *  Each line will look like:
     *      <szKey>=<szTmpDir>\<szFile><CR><LF>
     */
    cbOverhead = lstrlen(szKey) + 1 + lstrlen(szTmpDir) + 1 + 2;
    cbNew = lstrlen(szSection) + 5 + _MAX_PATH;
    for (; (cbDst = lstrlen(szDst)) != 0; szDst += cbDst + 1)
        {
        cbNew += cbOverhead + cbDst;
        }

    LocalUnlock(hDstLst);

    *pcbToBuf = cbOld + cbNew;
    *phlocal = LocalAlloc(LMEM_MOVEABLE, *pcbToBuf);
    if (*phlocal == NULL)
        {
#ifdef DEBUG
        MessageBox(NULL, "Out of memory in FAllocNewBuf.", szDebugMsg,
            MB_OK | MB_ICONEXCLAMATION);
#endif /* DEBUG */
        }
    else
        fRet = fTrue;
    SetErrorMode(fModeSav);

    return (fRet);
}


/*
**  Purpose:
**      Add the new lines to the ini file.
**  Arguments:
**      hlocalFrom: Handle to Src memory.
**      hlocalTo:   Handle to Dst memory.
**      cbToBuf:    Total size of Dst memory.
**      szTmpDir:   Full path to destination directory (OEM chars).
**      szSection:  Ini section name
**      szKey:      Ini key name
**  Returns:
**      fTrue if successful, fFalse otherwise.
**
**  REVIEW: DBCS writes out different order.  See DBCS J6 code and
**          comments in sysinicm.c.
**************************************************************************/
BOOL FProcessFile ( HLOCAL hlocalFrom, HLOCAL hlocalTo, CB cbToBuf,
                        SZ szTmpDir, SZ szSection, SZ szKey )
{
    UINT fModeSav;
    SZ   szFromBuf;
    SZ   szToBuf;
    SZ   szToStart;
    SZ   szCur;
    SZ   szDst;
    CB   cbSect;
    CB   cbDst;

    Unused(cbToBuf);    /* Used in debug only */

    fModeSav = SetErrorMode(fNoErrMes);

    szFromBuf = (SZ)LocalLock(hlocalFrom);
    if(szFromBuf == szNull)
        return fFalse;

    szToBuf = (SZ)LocalLock(hlocalTo);
    if(szToBuf != szNull) {
        LocalUnlock (hlocalFrom);
        return fFalse;
    }

    szToStart = szToBuf;

    cbSect = lstrlen(szSection);
    for (szCur = szFromBuf; *szCur != chEos; szCur = AnsiNext(szCur))
        {
        if (*szCur == '[' && *((szCur + cbSect + 1)) == ']'
                && _memicmp(szSection, AnsiNext(szCur), cbSect) == 0)
            {
            /*  Found section.  Copy up to section line. */
            CB cbCopy = (CB)(szCur - szFromBuf);

            memcpy(szToBuf, szFromBuf, cbCopy);
            szToBuf += cbCopy;
            break;
            }
        }

    /*  Copy section line. */
    *szToBuf++ = '[';
    memcpy(szToBuf, szSection, cbSect);
    szToBuf += cbSect;
    *szToBuf++ = ']';
    *szToBuf++ = chCR;
    *szToBuf++ = chEol;

    /*  Copy new lines. */
    szDst = (SZ)LocalLock(hDstLst);
    if (szDst == szNull) {

        LocalUnlock(hlocalFrom);
        LocalUnlock(hlocalTo);
        return fFalse;
    }

    for (; (cbDst = lstrlen(szDst)) != 0; szDst += cbDst + 1)
        {
        CopyIniLine(szKey, szTmpDir, szDst, &szToBuf);
        }
    LocalUnlock(hDstLst);
    CopyIniLine(szKey, szTmpDir, "_MSSETUP._Q_", &szToBuf);

    /*  Copy rest of file. */
    if (*szCur == '[')
        {
        /*
         *  Skip section line in From buffer.  Allow room for '[', section,
         *  ']', CR, LF.
         */
        szCur += cbSect + 4;
        }
    else
        {
        szCur = szFromBuf;
        }
    szToBuf = _memccpy(szToBuf, szCur, chEos, UINT_MAX);
    Assert(szToBuf != szNull);
    Assert((CB)lstrlen(szToStart) < cbToBuf);

    LocalUnlock(hlocalFrom);
    LocalUnlock(hlocalTo);
    SetErrorMode(fModeSav);

    return (fTrue);
}


/*
**  Purpose:
**      Constructs and copies an ini line to a buffer.
**  Arguments:
**      szKey:    Ini key name
**      szTmpDir: Full path to destination directory (OEM chars).
**      szFile:   Name of file in temporary directory.
**      pszToBuf: Pointer to new buffer.
**  Returns:
**      none
**************************************************************************/
VOID CopyIniLine ( SZ szKey, SZ szTmpDir, SZ szFile, PSZ pszToBuf )
{
    char rgchSysIniLine[256];
    CB   cbCopy;

    lstrcpy(rgchSysIniLine, szKey);
    lstrcat(rgchSysIniLine, "=");
    lstrcat(rgchSysIniLine, szTmpDir);
    lstrcat(rgchSysIniLine, "\\");
    lstrcat(rgchSysIniLine, szFile);
    Assert(lstrlen(rgchSysIniLine) < sizeof rgchSysIniLine);
    cbCopy = lstrlen(rgchSysIniLine);
    memcpy(*pszToBuf, rgchSysIniLine, cbCopy);
    (*pszToBuf) += cbCopy;
    *(*pszToBuf)++ = chCR;
    *(*pszToBuf)++ = chEol;
}


/*
**  Purpose:
**      Writes out the new ini file.
**  Arguments:
**      szIniFile: Buffer to hold file name.
**      hlocalTo:   Handle to Src memory.
**  Returns:
**      fTrue if successful, fFalse otherwise.
**************************************************************************/
BOOL FWriteIniFile ( SZ szIniFile, HLOCAL hlocalTo )
{
    UINT     fModeSav;
    SZ       szToBuf;
    HFILE    hfile;
    OFSTRUCT ofs;
    CB       cbWrite;
    BOOL     fRet = fFalse;

    fModeSav = SetErrorMode(fNoErrMes);
    szToBuf = (SZ)LocalLock(hlocalTo);
    if(szToBuf == szNull)
        return fFalse;

    hfile = OpenFile(szIniFile, &ofs, OF_CREATE | OF_WRITE);
    if (hfile == HFILE_ERROR)
        {
#ifdef DEBUG
        wsprintf(szDebugBuf, "Can't open file: %s.", szIniFile);
        MessageBox(NULL, szDebugBuf, szDebugMsg,
                        MB_OK | MB_ICONEXCLAMATION);
#endif /* DEBUG */
        goto LUnlockAndReturn;
        }

    cbWrite = _lwrite(hfile, szToBuf, lstrlen(szToBuf));
    if (cbWrite == HFILE_ERROR)
        {
#ifdef DEBUG
        wsprintf(szDebugBuf, "Can't write to file: %s.", szIniFile);
        MessageBox(NULL, szDebugBuf, szDebugMsg,
                        MB_OK | MB_ICONEXCLAMATION);
#endif /* DEBUG */
        }
    else
        {
        fRet = fTrue;
        }

    hfile = _lclose(hfile);
    Assert(hfile != HFILE_ERROR);

LUnlockAndReturn:
    LocalUnlock(hlocalTo);
    SetErrorMode(fModeSav);

    return (fRet);
}

CHAR szcStfSrcDir[] = "Source Directory\t";
#define cchStfSrcDir (sizeof(szcStfSrcDir)-1)

/* Finds the source directory for the installation, asks the user
   to insert the disk. And returns */

BRC BrcInsertDisk(CHAR *pchStf, CHAR *pchSrcDrive)
{
    CHAR  rgbBuf[_MAX_PATH];
    BYTE  rgbFileBuf[32];
    UINT  iFileBuf = sizeof(rgbFileBuf), cFileBuf = sizeof(rgbFileBuf);
    CHAR *pchBuf = rgbBuf;
    CHAR *pchMsg;
    int iStf = 0;
    HFILE hFile;
    BRC brc = brcLst;
    char chDrv;
    BOOL fQuote = FALSE;
    int drvType;
    BOOL fFirst = TRUE;
    BOOL fOpen = FALSE;
    HFILE hFileT;
    BOOL fRenameStf = fFalse;

    if ((hFile = _lopen(pchStf, OF_READ)) == HFILE_ERROR)
        return brcNoStf;

    /* Find the path to the original setup. This is stored in the .stf file on the
       Source Directory line */
    while (pchBuf < rgbBuf + sizeof(rgbBuf))
        {
        BYTE ch;

        if (iFileBuf == cFileBuf)
            {
            if ((cFileBuf = _lread(hFile, rgbFileBuf, sizeof(rgbFileBuf))) == 0)
                goto LDone;
            iFileBuf = 0;
            }
        ch = rgbFileBuf[iFileBuf++];
        if (iStf < cchStfSrcDir)
            {
            if (ch == szcStfSrcDir[iStf])
                iStf++;
            else
                iStf = 0;
            continue;
            }
        if(fQuote)
            fQuote = FALSE;
        else if (ch == '"')
            {
            fQuote = TRUE;
            continue;
            }
        else if (ch == '\x0d' || ch == '\t')
            break;
        *pchBuf++ = (CHAR)ch;
        /* Case of having the last character be a DBCS character */
        if (IsDBCSLeadByte(ch))
            {
            if (iFileBuf == cFileBuf)
                {
                _lread(hFile, &ch, 1);
                *pchBuf++ = (CHAR) ch;
                }
            else
                *pchBuf++ = rgbFileBuf[iFileBuf++];
            }
        }

LDone:
    *pchBuf = 0;
    if (rgbBuf[0] == 0)
        {
        fRenameStf = fTrue;
        goto LClose;
        }
    chDrv = (char)toupper(rgbBuf[0]);
    if (rgbBuf[1] != ':' || chDrv < 'A' || chDrv > 'Z')
        {
        /* We know this is a network drive - UNC Name */
        drvType = EX_DRIVE_REMOTE;
        Assert(rgbBuf[0] == '\\' && rgbBuf[1] == '\\');
        }
    else
        {
        drvType = GetDriveTypeEx(chDrv - 'A');
        }

    lstrcpy(pchSrcDrive, rgbBuf);
    if (*AnsiPrev(rgbBuf, pchBuf) != '\\')
        {
        *pchBuf++ = '\\';
        *pchBuf = 0;
        }

    lstrcat(rgbBuf, "Setup.ini");

    while (!fOpen)
        {
        switch (drvType)
            {
        case EX_DRIVE_FIXED:
        case EX_DRIVE_REMOTE:
        case EX_DRIVE_RAMDISK:
        case EX_DRIVE_INVALID:
        default:
            if (!fFirst)
                {
                /* We've been here before */
                DispErrBrc(brcConnectToSource, TRUE, MB_OK | MB_ICONSTOP, pchSrcDrive, NULL, NULL);
                brc = brcMax;
                goto LClose;
                }
            /* The setup stuff should be available, change directories and go for it */
            break;
        case EX_DRIVE_FLOPPY:
        case EX_DRIVE_REMOVABLE:
            /* Ask to insert disk */
            pchMsg = rgchInsertDiskMsg;
            goto LAskUser;
            break;
        case EX_DRIVE_CDROM:
            /* Ask to insert their CD */
            pchMsg = rgchInsertCDMsg;
LAskUser:
            if (fFirst)
                {
                if (DispErrBrc(brcString, FALSE, MB_ICONEXCLAMATION|MB_OKCANCEL,
                        pchMsg, NULL, NULL) != IDOK)
                    {
                    brc = brcUserQuit;
                    goto LClose;
                    }
                }
            else
                {
                if (DispErrBrc(brcInsCDRom2, FALSE, MB_ICONEXCLAMATION|MB_OKCANCEL,
                        rgbBuf, pchMsg, NULL) != IDOK)
                    {
                    brc = brcUserQuit;
                    goto LClose;
                    }
                }
            break;
            }

        if ((hFileT = _lopen(rgbBuf, OF_READ)) != HFILE_ERROR)
            {
            _lclose(hFileT);
            fOpen = fTrue;
            }

        fFirst = FALSE;

        }

    brc = brcOkay;

LClose:
    _lclose(hFile);

    /* If we can't find the source path in the maintenance mode .STF,
    *   assume it's corrupted and rename it, so when the user runs again
    *   from the source image, we will just run in 'floppy' mode,
    *   avoiding the bad .STF file.
    *   (NOTE: Assumes /W is only used in maint mode!!)
    */
    if (fRenameStf)
        {
        FRenameBadMaintStf(pchStf);
        brc = brcNoStf;
        }

    return brc;

}


/*
****************************************************************************/
BOOL FRenameBadMaintStf ( SZ szStf )
{
    CHAR rgch[_MAX_FNAME];

    _splitpath(szStf, szNull, szNull, rgch, szNull);
    if (*rgch == '\0')
        lstrcpy(rgch, "stf");

    Assert(lstrlen(rgch) + 4 < sizeof rgch);
    lstrcat(rgch, ".000");

    rename(szStf, rgch);

    /* Remove the original .STF in case the rename failed
    *   (probably due to a previously renamed .STF file).
    */
    remove(szStf);

    return (fTrue);     /* Always returns true */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\setup\inc\acmhook.h ===
#pragma warning(disable:4001)

////////////////////////////////////////////////////////////////////////////////
//	File:		ACMHOOK.H
//	Purpose:	Types, data structures, and function definitions for
//				hooking out the standard acme ui
//	Notes:		I - input
//				O - output
////////////////////////////////////////////////////////////////////////////////

#if defined(__cplusplus)
extern "C" {
#endif //__cplusplus

#define cbMaxSz 256						// maximum string buffer size
#define DECL __cdecl					// calling convention of hook procedures

typedef enum {							// Dialog Hook Return Code
	shrcOk,								// proceed with setup
	shrcCancel,							// cancel/quit button was pushed
	shrcIgnore,							// ignore button was pushed
	shrcOption,							// "change option" button was pushed
	shrcDirectory,						// "change directory" button was pushed
	shrcRefresh,						// activation change - refresh data
	shrcFail,							// error occurred - cancel setup
	shrcNone,							// don't remove any shared components
	shrcKeep,							// don't remove this shared component
	shrcRemoveAll,						// remove all app/shared components
	shrcRemove,							// remove this shared component
	shrcReinstall,						// re install components
	shrcFrameRegisterFail,				// error registering class
	shrcFrameCreateFail					// error creating frame window
	} SHRC;

typedef struct {						// Hook Data
	LONG cb;							// structure size (I)
	CHAR rgchHelpFile[cbMaxSz];			// help file (I)
	DWORD dwHelpContext;				// help context (I)
	} HD, *PHD;

typedef struct {						// Welcome Dialog Hook Data
	HD hd;								// common hook data
	BOOL fMaint;						// maintenace mode setup (I)
	} WDHD, *PWDHD;

typedef
	SHRC (DECL *LPFNSHRCWDH)(PWDHD);	// Welcome Dialog Hook

typedef struct {						// Modules in Use Dialog Hook Data
	HD hd;								// common hook data
	CHAR rgchModuleList[cbMaxSz];		// names of modules in use (I)
	} MUDHD, *PMUDHD;

typedef
	SHRC (DECL *LPFNSHRCMUDH)(PMUDHD);	// Modules in Use Dialog Hook

typedef enum {							// Copy Disincentive Dialog Hook Mode
	cddhmNameOrg,						// allow the name and org to be modified
	cddhmName,							// allow only the name to be modified
	cddhmOrg							// allow only the org to be modified
	} CDDHM;

typedef struct {						// Copy Disincentive Dialog Hook Data
	HD hd;								// common hook data
	CDDHM cddhm;						// CD mode (I)
	CHAR rgchName[cbMaxSz];				// name string (I/O)
	CHAR rgchOrg[cbMaxSz];				// organization string (I/O)
	} CDDHD, *PCDDHD;

typedef
	SHRC (DECL *LPFNSHRCCDDH)(PCDDHD);	// Copy Disincentive Dialog Hook

typedef enum {							// Serial Number Dialog Hook Mode
	sndhmNormal,						// the normal/default functionality
	sndhmCDKey,							// the cdkey functionality
	sndhmOEM							// the OEM functionality
	} SNDHM;

typedef struct {						// Serial Number Dialog Hook Data
	HD hd;								// common hook data
	CHAR rgchSerNum[cbMaxSz];			// serial number string (I/O)
	SNDHM sndhm;						// serial number dialog hook mode (I)
	} SNDHD, *PSNDHD;

typedef
	SHRC (DECL *LPFNSHRCSNDH)(PSNDHD);	// Serial Number Dialog Hook

typedef enum {							// Already Used Dialog Hook Mode
	audhmBad,							// setup.ini corrupted
	audhmOrg,							// organization used
	audhmName,							// name used
	audhmBoth							// both name and org used
	} AUDHM;

typedef struct {						// Already Used Dialog Hook Data
	HD hd;								// common hook data
	AUDHM audhm;						// mode (I)
	CHAR rgchName[cbMaxSz];				// name string (I)
	CHAR rgchOrg[cbMaxSz];				// organization string (I)
	} AUDHD, *PAUDHD;

typedef
	SHRC (DECL *LPFNSHRCAUDH)(PAUDHD);	// Already Used Dialog Hook

typedef struct {						// Disk Locked Dialog Hook Data
	HD hd;								// common hook data
	CHAR rgchDir[cbMaxSz];				// directory string (I)
	} DLDHD, *PDLDHD;

typedef
	SHRC (DECL *LPFNSHRCDLDH)(PDLDHD);	// Disk Locked Dialog Hook

typedef enum {							// Copy Disincentive Dialog Hook Mode
	cpdhmRemind,						// piracy reminder
	cpdhmWarn,							// piracy warning
	cpdhmWarn2							// nasty ;-) piracy warning
	} CPDHM;

typedef struct {						// CD Piracy Dialog Hook Data
	HD hd;								// common hook data
	CPDHM cpdhm;						// mode (I)
	} CPDHD, *PCPDHD;

typedef
	SHRC (DECL *LPFNSHRCCPDH)(PCPDHD);	// CD Piracy Dialog Hook

typedef enum {							// DiRectory Dialog Hook Mode
	drdhmNotExistDir,					// directory does not exist
	drdhmAppExistsOld,					// older version in directory
	drdhmAppExistsNew					// new version in directory
	} DRDHM;

typedef struct {						// DiRectory Dialog Hook Data
	HD hd;								// common hook data
	DRDHM drdhm;						// mode (I)
	CHAR rgchComponent[cbMaxSz];		// component name string (I)
	CHAR rgchPath[cbMaxSz];				// path (I)
	} DRDHD, *PDRDHD;

typedef
	SHRC (DECL *LPFNSHRCDRDH)(PDRDHD);	// DiRectory Dialog Hook

typedef struct {						// Get Path Dialog Hook Data
	HD hd;								// common hook data
	CHAR rgchFilename[cbMaxSz];			// filename string - may be "" (I)
	CHAR rgchVersion[cbMaxSz];			// version string - may be "" (I)
	CHAR rgchSrcDir[cbMaxSz];			// source distory string - may be "" (I)
	LONG cSubNodeMax;					// count of maximumum subnodes (I)
	BOOL fAllowExtendedChars;			// if extended characters allowed (I)
	CHAR rgchComponent[cbMaxSz];		// component name string - may be "" (I)
	BOOL fNeedNewEmptyDir;				// the directory should be empty (I)
	CHAR rgchPath[cbMaxSz];				// path to edit (I/O)
	} GPDHD, *PGPDHD;

typedef
	SHRC (DECL *LPFNSHRCGPDH)(PGPDHD);	// Get Path Dialog Hook

typedef struct {						// App Main BuTtoN
	CHAR rgchLabel[cbMaxSz];			// button label string (I)
	CHAR rgchText[cbMaxSz];				// description string (I)
	HBITMAP hbm;						// bitmap for button (I)
	} AMBTN, *PAMBTN;
	
typedef struct {						// App Main Dialog Hook Data
	HD hd;								// common hook data
	LONG iambtnSelected;				// which button selected (I/O)
	LONG cambtn;						// number of buttons (I)
	CHAR rgchPath[cbMaxSz];				// directory path (I)
	HGLOBAL hrgambtn;					// button data (I)
	} AMDHD, *PAMDHD;

typedef
	SHRC (DECL *LPFNSHRCAMDH)(PAMDHD);	// App Main Dialog Hook

typedef struct {						// ProgMan Dialog Hook Data
	HD hd;								// common hook data
	CHAR rgchGroup[cbMaxSz];			// suggested group name (I/O)
	LONG crgchExisting;					// number of existing groups (I)
	HGLOBAL hrgrgchExisting;			// existing group names (I)
										// [crgchExisting][cbMaxSz]
	} PMDHD, *PPMDHD;

typedef
	SHRC (DECL *LPFNSHRCPMDH)(PPMDHD);	// ProgMan Dialog Hook Data

typedef struct {						// ReBoot Dialog Hook Data
	HD hd;								// common hook data
	} RBDHD, *PRBDHD;

typedef
	SHRC (DECL *LPFNSHRCRBDH)(PRBDHD);	// ReBoot Dialog Hook

typedef struct {						// Reboot Failed Dialog Hook Data
	HD hd;								// common hook data
	} RFDHD, *PRFDHD;

typedef
	SHRC (DECL *LPFNSHRCRFDH)(PRFDHD);	// Reboot Failed Dialog Hook

typedef enum {							// eXiT Dialog Hook Mode
	xtdhmOk,							// installation was successful
	xtdhmError,							// installation failed
	xtdhmQuit							// installation was cancelled
	} XTDHM;

typedef struct {						// eXiT Dialog Hook  Data
	HD hd;								// common hook data
	XTDHM xtdhm;						// mode (I)
	} XTDHD, *PXTDHD;

typedef
	SHRC (DECL *LPFNSHRCXTDH)(PXTDHD);	// eXiT Dialog Hook 

typedef struct {						// Disk Space iTeMs
	CHAR rgchDesc[cbMaxSz];				// description string (I)
	CHAR rgchSize[cbMaxSz];				// size (I)
	} DSTM, *PDSTM;

typedef struct {						// Disk Space iTeMs
	LONG cbReq;							// bytes required on current drive (I)
	LONG cbNeed;						// bytes needed on current drive (I)
	} DSDRV, *PDSDRV;

typedef struct {						// Disk Space Dialog Hook Data
	HD hd;								// common hook data
	BOOL fAdmin;						// whether in admin mode or not (I)
	LONG idsdrvCur;						// the selected drive (I/O)
	LONG cdstm;							// number of items (I)
	HGLOBAL hrgdstm;					// the items
	LONG cdsdrv;						// number of drives (I)
	HGLOBAL hrgdsdrv;					// the drives
	} DSDHD, *PDSDHD;

typedef
	SHRC (DECL *LPFNSHRCDSDH)(PDSDHD);	// Disk Space Dialog Hook

typedef struct {						// OPtions Dialog iTeMs
	CHAR rgchTitle[cbMaxSz];			// title string (for listbox) (I)
	CHAR rgchDesc[cbMaxSz];				// description string (I)
	CHAR rgchDir[cbMaxSz];				// the directory string (I)
	LONG cb;							// number of bytes item requires (I)
	BOOL fChecked;						// if the item is chosen (I/O)
	BOOL fChangeOption;					// enable the "change option" button
	BOOL fChangeDirectory;				// enable the "change directory" button
	BOOL fVital;						// the item is vital
	} OPTM, *POPTM;

typedef struct {						// OPtions Dialog Hook Data
	HD hd;								// common hook data
	BOOL fMaint;						// maintenace mode setup (I)
	BOOL fTop;							// if top level dialog (I)
	LONG coptm;							// number of option items (I)
	LONG ioptmCur;						// currently selected item (I/O)
	CHAR rgchDrvCur[cbMaxSz];			// drive of currently selected item (I)
	LONG cbDrvCurReq;					// bytes needed on current drive (I)
	LONG cbDrvCurAvail;					// bytes available on current drive (I)
	LONG cToAdd;						// number of items to add (I)
	LONG cToRemove;						// number of items to remove (I)
	HGLOBAL hrgoptm;					// the option items (I)
	} OPDHD, *POPDHD;

typedef
	SHRC (DECL *LPFNSHRCOPDH)(POPDHD);	// OPtions Dialog Hook

typedef struct {						// Admin Warn Hook Data
	HD hd;								// common hook data
	} AWDHD, *PAWDHD;

typedef
	SHRC (DECL *LPFNSHRCAWDH)(PAWDHD);	// Admin Warn Hook

typedef struct {						// MsApps directory Hook Data
	HD hd;								// common hook data
	CHAR rgchPath[cbMaxSz];				// directory path (I)
	} MADHD, *PMADHD;

typedef
	SHRC (DECL *LPFNSHRCMADH)(PMADHD);	// MsApps directory Hook

typedef enum {							// Confirm Server Dialog Hook Mode'
	csdhmName,							// use server name
	csdhmLetter							// use drive letter
	} CSDHM;

typedef struct {						// Confirm Server Dialog Hook Data
	HD hd;								// common hook data
	CHAR rgchName[cbMaxSz];				// component name (I)
	CHAR rgchPath[cbMaxSz];				// directory path (I)
	CHAR rgchNetPath[cbMaxSz];			// network path (I/O)
	CHAR rgchServer[cbMaxSz];			// network server (I/O)
	CHAR chDrive;						// drive letter (I/O)
	CSDHM csdhm;						// use name or drive letter (O)
	} CSDHD, *PCSDHD;

typedef
	SHRC (DECL *LPFNSHRCCSDH)(PCSDHD);	// Confirm Server Dialog Hook

typedef enum {							// Shared Files Dialog Hook Mode
	sfdhmServer,						// put shared files on server;
	sfdhmLocal,							// put shared files on local hard drive
	sfdhmChoice							// user can choose in network mode
	} SFDHM;

typedef struct {						// Shared Files Dialog Hook Data
	HD hd;								// common hook data
	BOOL fAdmin;						// whether in admin mode or not (I)
	SFDHM sfdhm;						// shared files mode (O)
	} SFDHD, *PSFDHD;

typedef 
	SHRC (DECL *LPFNSHRCSFDH)(PSFDHD);	// Shared Files Dialog Hook

typedef struct {						// Remove Shared Dialog Hook Data
	HD hd;								// common hook data
	CHAR rgchComponent[cbMaxSz];		// component name (I)
	} RSDHD, *PRSDHD;

typedef
	SHRC (DECL *LPFNSHRCRSDH)(PRSDHD);	// Remove Shared Dialog Hook

typedef struct {						// Ask Quit Dialog Hook Data
	HD hd;								// common hook data
	} AQDHD, *PAQDHD;

typedef
	SHRC (DECL *LPFNSHRCAQDH)(PAQDHD);	// Ask Quit Dialog Hook

typedef struct {						// Invalid Net Path Dialog Hook Data
	HD hd;								// common hook data
	} INDHD, *PINDHD;

typedef
	SHRC (DECL *LPFNSHRCINDH)(PINDHD);	// Invalid Net Path Dialog Hook

typedef struct {						// No Connection Dialog Hook Data
	HD hd;								// common hook data
	} NCDHD, *PNCDHD;

typedef
	SHRC (DECL *LPFNSHRCNCDH)(PNCDHD);	// No Connection Dialog Hook

typedef enum {							// Start Modeless Dialog Hook Mode
	smdhmSearching,						// searching for components
	smdhmCheckingDisk,					// checking disk space
	smdhmModifyingSys					// modifying system
	} SMDHM;

typedef struct {						// Start Modeless Dialog Hook
	HD hd;								// common hook data
	SMDHM smdhm;						// modeless dialog type (I)
	HWND hwndParent;					// parent for modeless dialog (I)
	DWORD dwHook;						// value for End Modeless (O)
	} SMDHD, *PSMDHD;

typedef
	SHRC (DECL *LPFNSHRCSMDH)(PSMDHD);	// Start Modeless Dialog Hook

typedef struct {						// End Modeless Dialog Hook
	HD hd;								// common hook data
	DWORD dwHook;						// value from Start Modeless (I)
	} EMDHD, *PEMDHD;

typedef
	SHRC (DECL *LPFNSHRCEMDH)(PEMDHD);	// End Modeless Dialog Hook

typedef struct {						// Create Frame Hook Data
	LONG cbCFHD;						// structure size (I)
	WNDCLASS wc;						// default RegisterClass data (I)
	CREATESTRUCT cs;					// default CreateWindow data (I)
	HWND hwndFrame;						// new frame window handle (O)
	int nCmdShow;						// default parm for ShowWindow (I)
	} CFHD, *PCFHD;

typedef
	SHRC (DECL *LPFNSHRCCFH)(PCFHD);	// Create Frame Hook

typedef struct {						// Message Box Hook Data
	LONG cbMBHD;						// structure size (I)
	HWND hwndOwner;						// handle of owner window (I)
	LPCSTR lpszText;					// text in message box (I)
	LPCSTR lpszTitle;					// title of message box (I)
	UINT uStyle;						// style of message box (I)
	int idRet;							// return value of message box (O)
	} MBHD, *PMBHD;

typedef
	SHRC (DECL *LPFNSHRCMBH)(PMBHD);	// Message Box Hook

typedef struct {						// Gauge Init Hook Data
	LONG cbGIHD;						// structure size (I)
	} GIHD, *PGIHD;

typedef
	SHRC (DECL *LPFNSHRCGIH)(PGIHD);	// Gauge Init Hook

typedef struct {						// Gauge Open Hook Data
	LONG cbGOHD;						// structure size (I)
	HWND hwndParent;					// handle of parent (frame) window (I)
	BOOL *pfAbort;						// flag to set when cancel pushed
	} GOHD, *PGOHD;

typedef
	SHRC (DECL *LPFNSHRCGOH)(PGOHD);	// Gauge Open Hook

typedef struct {						// Gauge Close Hook Data
	LONG cbGCHD;						// structure size (I)
	} GCHD, *PGCHD;

typedef
	SHRC (DECL *LPFNSHRCGCH)(PGCHD);	// Gauge Close Hook

typedef struct {						// Gauge Title Hook Data
	LONG cbGTHD;						// structure size (I)
	CHAR rgchTitle[cbMaxSz];			// new title string (I)
	} GTHD, *PGTHD;

typedef
	SHRC (DECL *LPFNSHRCGTH)(PGTHD);	// Gauge Title Hook

typedef struct {						// Gauge teXt Hook Data
	LONG cbGXHD;						// structure size (I)
	CHAR rgchSrc[cbMaxSz];				// new source string (I)
	CHAR rgchDst[cbMaxSz];				// new destination string (I)
	} GXHD, *PGXHD;

typedef
	SHRC (DECL *LPFNSHRCGXH)(PGXHD);	// Gauge teXt Hook

typedef struct {						// Gauge Range Hook Data
	LONG cbGRHD;						// structure size (I)
	LONG iLim;							// new range limit (I)
	} GRHD, *PGRHD;

typedef
	SHRC (DECL *LPFNSHRCGRH)(PGRHD);	// Gauge Range Hook

typedef struct {						// Gauge Position Hook Data
	LONG cbGPHD;						// structure size (I)
	LONG iCur;							// new current position (I)
	} GPHD, *PGPHD;

typedef
	SHRC (DECL *LPFNSHRCGPH)(PGPHD);	// Gauge Position Hook

typedef struct {						// Gauge Delta Hook Data
	LONG cbGDHD;						// structure size (I)
	LONG dCur;							// delta to current position (I)
	} GDHD, *PGDHD;

typedef
	SHRC (DECL *LPFNSHRCGDH)(PGDHD);	// Gauge Delta Hook

typedef struct {						// Gauge Yield Hook Data
	LONG cbGYHD;						// structure size (I)
	} GYHD, *PGYHD;

typedef
	SHRC (DECL *LPFNSHRCGYH)(PGYHD);	// Gauge Yield Hook

typedef struct {						// Filecopy Warning Hook Data
	LONG cbFWHD;						// structure size (I)
	CHAR rgchPath[cbMaxSz];					// path to file being copied
	} FWHD, *PFWHD;

typedef
	SHRC (DECL *LPFNSHRCFWH)(PFWHD);	// Filecopy Warning Hook

#if defined(__cplusplus)
}
#endif //__cplusplus

#pragma warning(default:4001)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\setup\inc\debugids.h ===
/***************************************************************************
**
**	File:		debugids.h
**	Purpose:	Debug message IDs
**	Notes:	IDs must be assigned within the ranges indicated below
**
****************************************************************************/

typedef struct _DMS  /* internal debug message table structure */
{
	UINT        iMsg;
	const CHAR* szMsg;
} DMS;

#define MID_DUMP_MESSAGES (8<<16) /* special ID to dump all messages to log */

/* DEBUG ERROR MESSAGES FROM MSSETUP.DLL - MUST BE IN RANGE 256 - 511 */

#define IDS_UnknownFailure       256
#define IDS_DEF_SystemError	   257
#define IDS_DEF_OutOfMemory	   258
#define IDS_DEF_OutOfDiskSpace	259

#define IDS_INFBadSectionLabel  272
#define IDS_INFHasNulls         273
#define IDS_INFBadFDLine        275
#define IDS_INFBadRSLine        276
#define IDS_INFInvalidFirstChar 277
#define IDS_FDDid              	278
#define IDS_FDSrcFile          	279
#define IDS_FDAppend           	280
#define IDS_FDBackup           	281
#define IDS_FDCopy             	282
#define IDS_FDDate             	283
#define IDS_FDDecompress       	284
#define IDS_FDLang             	285
#define IDS_FDOverwrite        	286
#define IDS_FDReadOnly         	287
#define IDS_FDRemove           	288
#define IDS_FDRename           	289
#define IDS_FDRenameSymbol     	290
#define IDS_FDRoot             	291
#define IDS_FDSetTime          	292
#define IDS_FDShared           	293
#define IDS_FDSize             	294
#define IDS_FDSystem           	295
#define IDS_FDTime             	296
#define IDS_FDUndo             	297
#define IDS_FDVersion          	298
#define IDS_FDVital            	299
#define IDS_FDAppendRenameRoot 	300
#define IDS_FDAppendBackup     	301
#define IDS_FDCopyRemove       	302

/* DEBUG ERROR MESSAGES FROM ACMSETUP.EXE - MUST BE IN RANGE 768 - 1023 */

#define IDS_DestDirNotInTree	768
#define IDS_NoGetTargetFileName	769
#define IDS_FrameBitmapParse	770
#define	IDS_TopLevelPlor		771
#define	IDS_BadObjDestDir		772
#define	IDS_AppSearchTopOnly	773
#define	IDS_AppSearchSearchOnly	774
#define	IDS_SearchOnlyAppSearch	775
#define	IDS_RefProofLines		776
#define	IDS_RefLexLines			777
#define	IDS_CantSearch			778

#define	IDS_ConfigDirYes		784
#define	IDS_BadNumVisualObjs	785
#define	IDS_NoLoadBmp			786
#define	IDS_MissBmpField		787
#define	IDS_MustBeTrigger		788
#define	IDS_MissDlgTitle		789
#define	IDS_DataNotEmpty		790

#define	IDS_BadDataValue		795
#define	IDS_ExtraDataValue		796
#define	IDS_BadDllValue			797
#define	IDS_BadIdValue			798
#define	IDS_BadProcValue		799

#define	IDS_BadIni1File			807
#define	IDS_BadIni1Sect			808
#define	IDS_BadIni1Key			809
#define	IDS_BadIni2File			810
#define	IDS_BadIni2Sect			811
#define	IDS_BadIni2Key			812
#define	IDS_BadEmptyFileName	814
#define	IDS_BadFileName			816
#define	IDS_BadVersionField		817
#define	IDS_BadIniFile			819
#define	IDS_BadIniSect			820
#define	IDS_BadIniKey			821
#define	IDS_BadIniVal			822
#define	IDS_BadIniIndex			823
#define	IDS_BadInfSection		824
#define	IDS_BadInfKey			825
#define	IDS_BadObjectList		827
#define	IDS_BadObjectRef		828
#define	IDS_BadResourceType		829
#define	IDS_BadResourceId		830
#define	IDS_BadHexData			834

#define	IDS_NoDictObjList		857
#define	IDS_BadCountryCode		862
#define	IDS_BadLexType			863
#define	IDS_BadLanguage			864
#define	IDS_BadRegDataField		879
#define	IDS_BadTriggerObj		881
#define	IDS_NoThenOrElse	    882
#define	IDS_BadThen				883
#define	IDS_BadElse				884
#define	IDS_MissingData			885
#define	IDS_MissingVisualData	890
#define	IDS_BadVisualData		891
#define	IDS_BadHiddenData		892
#define	IDS_MaxObjTooHigh		901
#define	IDS_COMP_CHECK_NOLIB	904
#define	IDS_COMP_CHECK_NOPROC	905
#define	IDS_STR_BADCKDIR_VAL	906
#define	IDS_STR_BADDSTDIR		907
#define	IDS_STR_ERR_OBJID		908
#define IDS_STR_BADADMINDIR     909

#define	IDS_STR_DUPOBJID		913
#define	IDS_STR_BAD_FIELD		914
#define	IDS_BadDefaultPath		915
#define	IDS_BadSubdirValue		918
#define	IDS_BadExtendedChars	919
#define	IDS_BadDialogIfDefault	920
#define	IDS_BadEnvirName		924

#define	IDS_BadRegistryKey		932
#define	IDS_BadRegIndexValue	933

#define	IDS_BadAppName			936
#define	IDS_BadAppVersion		937
#define	IDS_BadAdminRoot		938
#define	IDS_BadFloppyRoot		939
#define	IDS_BadNetworkRoot		940
#define	IDS_BadMaintRoot		941
#define	IDS_BadBatchRoot		942
#define	IDS_NoMaintSrcDir		943
#define IDS_BadMSAPPSDrive		944
#define	IDS_BadStfVersion		945
#define	IDS_UnknownTopLevel		946
#define	IDS_BadNetLogPath		947

#define	IDS_BadProcDataValue	959
#define	IDS_BadCostDataValue	960

#define IDS_BadAdminSubDir		965

#define IDS_BadShortcutPath		990
#define IDS_BadRegValue			991
#define IDS_BadItemName			992
#define IDS_BadTargetFileSpec	993
#define IDS_BadIconFileSpec		994
#define IDS_BadWorkingDirSpec	995
#define IDS_BadShortcutName		996
#define IDS_BadProgramGroupName	997
#define IDS_BadCommandLineSpec	998
#define IDS_SelfRegDLLNotFound	999
#define IDS_SelfRegDLLNotLoaded	1000
#define IDS_SelfRegEntryPointMissing	1001
#define IDS_CompanionNotInMMode	1002
#define IDS_BadInfModeTrigger	1003
#define IDS_InfModeNoCompDll	1004
#define IDS_SharedFnameIncompat	1005
#define IDS_VerCheckIncompat	1006

/* DEBUG LOG MESSAGES FROM MSSETUP.DLL - MUST BE IN RANGE 1280 - 1535 */

#define	IDS_LF_IgnoreMissingSrcFile		1281


/* DEBUG LOG MESSAGES FROM ACMSETUP.EXE - MUST BE IN RANGE 1792 - 2047 */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\setup\inc\odbcexec.h ===
/***************************************************************************
**
**	File:			odbcexec.h
**	Purpose:		Contains defines used by both the 16 and 32 bit ends
**					of the ODBC communication channel.
**
**	Notes:			This header files contains code, so it cannot be
**					included in more than one compilation unit.  The
**					reason it contains code is that GetTransferFileName()
**					is used on both the 16 and 32 bit sides, and this is
**					simpler than creating a shared .cpp file just for it.
**
****************************************************************************/

#ifndef ODBCEXEC_H
#define ODBCEXEC_H

#include <string.h>

#define EXE_NAME "ODBCEXEC.EXE"
#define SZ_TRANSFER_FILE_NAME "SendODBC"

#define ODBC_BUFFER_SIZE 256

/*
 * Returns the name of the file used to pass information from the 32 bit
 * process to the 16 bit process.  This file is in the Windows dir,
 * and has name SZ_TRANSFER_FILE_NAME (defined in ODBCEXEC.H).
 */
char *GetTransferFileName()
{
	static char rgchImage[128];
	UINT cb=GetWindowsDirectory(rgchImage, sizeof rgchImage);

	// Add a slash unless it's the root
	if (cb > 3)
		{
		rgchImage[cb] = '\\';
		rgchImage[cb+1] = '\0';
		}

	strcat(rgchImage, SZ_TRANSFER_FILE_NAME);
	return rgchImage;
}

#endif /* ODBCEXEC_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\setup\inc\mxdi.h ===
// mxdi.h: Memory Decryption Interface 
// 
//        To be used in combination with diamond's fdi.h 
//
// Copyright (c) 1994 Microsoft Corporation.  All rights reserved.
// Microsoft Confidential.
//
//

// Include <fdi.h> before this file

#ifndef _MXDI_H_
#define _MXDI_H_

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus

typedef enum tagRCA
{
    rcaSuccess,
    rcaOOM,                         // Out of memory
    rcaNoKey,                       // No key for this product
    rcaBadKey,                      // Key does not match file being decrypted
    rcaWrongCd,                     // You bought this product from another CD
    rcaWrongBatch,                  // You bought this product from another 
                                    //     batch of the same CD
    rcaBadLkdbVersion,              //  
    rcaLkdbNotFound,                // Couldn't find lkdb or lkdb.dll
    rcaUnknownEncryptionMethod,     //
    rcaBadParam,                    // Invalid parameter given
    rcaLkdbFileError,               // Error reading, writing, or seeking 
                                    //     the LKDB
    rcaLkdbNotOnLocalDrive,         // LKDB data is on non-local drive
    // encryption only
    rcaReservedSpaceTooSmall = 100, //
} RCA;       // result code in Alakazam

///////////////////////////////////////////////////////////
// Backward compatibility bandaids. 
// These will be removed sooner than you'd hope.
///
typedef void FAR * HMDI;
#define FMDIAllocInit   FMXDIAllocInit
#define FMDIAssertInit  FMXDIAssertInit

#define MDICreate       MXDICreate
#define MDIDecrypt      MXDIDecrypt
#define MDIDestroy      MXDIDestroy
#define RcaFromHmdi     RcaFromHmxdi
///////////////////////////////////////////////////////////


typedef void FAR * HMXDI;

typedef void FAR * (*PFNCRYPTALLOC) (unsigned long); // memory allocation functions
typedef void       (*PFNCRYPTFREE)  (void FAR *);    // memory allocation functions
typedef void       (*PFNCRYPTASSERT) (LPCSTR szMsg, LPCSTR szFile, UINT iLine);


// These are the functions to be used in conjunction with Diamond
//
//      main (...)
//      {
//          if (!FMXDIAllocInit(...))
//              abort();
//          hmxdi = MXDICreate();
//          if (NULL == hmxdi)
//              abort();
//          hfdi = FDICreate(...);
//          For all cabinets
//              if (!FDICopy(..., MXDIDecrypt, &hmxdi))
//                  HandleErrors(..., RcaFromHmxdi(hmxdi));
//          FDIDestroy(hfdi);
//          MDIDestroy(hmxdi);
//      }    
//
//
//

BOOL FMXDIAllocInit(PFNCRYPTALLOC pfnAlloc, PFNCRYPTFREE pfnFree) ;
BOOL FMXDIAssertInit(PFNCRYPTASSERT pfnAssert);

HMXDI FAR CDECL MXDICreate(void);
int  FAR CDECL MXDIDecrypt(PFDIDECRYPT pfdid);
void FAR CDECL MXDIDestroy(HMXDI hmxdi);

RCA RcaFromHmxdi(HMXDI hmxdi);

#ifdef __cplusplus
}
#endif // __cplusplus

#endif // !_MXDI_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\setup\inc\setupkit.h ===
/***************************************************************************
**
**	File:			SetupKit.h
**	Purpose:		Toolkit types, defines, and prototypes.
**	Notes:
**
****************************************************************************/

#ifndef SETUPKIT_H
#define SETUPKIT_H

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif


/*
**	Purpose:
**		Calculates the number of bytes that a string occupies (not including
**		the terminating zero character).
**	Arguments:
**		sz: string whose length is to be calculated.
**	Returns:
**		0 if sz was NULL.
**		The number of bytes from the beginning of the string to its
**			terminating zero character.
*/
#define CbStrLen(sz)              ((CB)lstrlen(sz))


/*
**	Purpose:
**    Checks if the string is empty
**	Arguments:
**		sz:
**	Returns:
**		0 if sz was NULL.
**    1 otherwise
*/
#define FEmptySz(sz)              ((BOOL)((sz) == szNull || *(sz) == chEos))

#define FValidSz(sz)              (!FEmptySz(sz))


/*
 *	CHaracter Physical representation datatype
 */
typedef BYTE             CHP;		/* CHaracter Physical */
typedef CHP *            PCHP;		/* Ptr to CHaracter Physical */
typedef CB               CCHP;		/* Count of CHaracter Physical */
typedef CCHP *           PCCHP;		/* Ptr to Count of CHaracter Physical */

#define pchpNull         ((PCHP)NULL)
#define pcchpNull        ((PCCHP)NULL)
#define CbFromCchp(cchp) ((CB)(cchp))


/*
 *	CHaracter Logical representation datatype
 */
typedef CHP              CHL;		/* CHaracter Logical */
typedef CHL *            PCHL;		/* Ptr to CHaracter Logical */
typedef PCHL *           PPCHL;		/* Ptr to Ptr to CHaracter Logical */
typedef CB               CCHL;		/* Count of CHaracter Logical */

#define pchlNull         ((PCHL)NULL)
#define ppchlNull        ((PPCHL)NULL)

#define cchpFullPathMax  ((CCHP)(_MAX_PATH))

#define cchGrpNameMax  30  /* right for win31, WfW, WinNT */
#ifdef OLD
#define cchGrpNameMax  ((CB)(LOWORD(GetVersion()) == 0x0003 ? 24 : 29))
#endif /* OLD */

/*
 *	Maximum size block that can be allocated (bytes).
 */
#define cbAllocMax  ((CB)65520)


/*
 *	Path Verification Routines
 */

typedef UINT  FPV;		/* Flags for Path Validation */

#define fpvSub     0x0000  /* Must be subpath, cannot have Drive or UNC */
#define fpvUnc     0x0001  /* Validate UNC path, \\Node\share */
#define fpvDrive   0x0002  /* Validate Drive at start of path */
#define fpvFile    0x0004  /* Validate filename only, no subdirectories */
#define fpvDir     0x0010  /* Allow trailing directory separator */
#define fpvFat     0x0020  /* Restrict to only 8.3 FAT name, no LFNs */
#define fpvFull    (fpvDrive | fpvUnc) /* Full path, with Drive or UNC */
#define fpvModule  (fpvDrive | fpvUnc | fpvFile) /* Valid executable name */

/*
**	Purpose:
**		Checks the validity of a filepath or filename.
**		Allowable filepath components are controlled by bit flags.
**		Default behavior is to allow directories with filename.
**		Leading backslash is not permitted in directory name.
**	Arguments:
**		szcPath:      non-NULL string to validate
**		fpvFlags:     pathname options flags
**	Returns:
**		fTrue if szcPath is valid for requested type
**		fFalse if invalid path
***************************************************************************/

BOOL PUBLIC FValidFilePath ( SZC szcPath, FPV fpvFlags );

#define FValidDir(szcDir)          FValidFilePath(szcDir, fpvFull | fpvDir)
#define FValidPath(szcPath)        FValidFilePath(szcPath, fpvFull)
#define FValidSubDir(szc)          FValidFilePath(szc, fpvDir)
#define FValidSubPath(szc)         FValidFilePath(szc, fpvSub)
#define FValidFATSubPath(szc)      FValidFilePath(szc, fpvFat)
#define FValidFileName(szc)        FValidFilePath(szc, fpvFile)
#define FValidDllFileName(szc)     FValidFilePath(szc, fpvModule)
#define FValidDstDir(szcDir)       FValidFilePath(szcDir, fpvDrive | fpvDir)


#define FValidInfSect(cszcSect)												\
				(FValidSz(cszcSect) && !strchr(cszcSect, ']'))

#define FValidIniFile(szcFile)												\
				(FValidPath(szcFile)											\
				 || CrcStringCompareI(szcFile, "WIN.INI") == crcEqual)


/* String manipulation routines */

/*
**	Purpose:
**		Advances a string pointer to the beginning of the next valid
**		character.  This may include skipping a double-byte character.
**	Arguments:
**		sz: the string pointer to advance.  It can be NULL or empty, or else
**			it must point at the beginning of a valid character.
**	Returns:
**		NULL if sz was NULL.
**		sz unchanged if it was an empty string (*sz == '\0').
**		sz advanced past the current character and to the beginning of the
**			next valid character.
*/
#define SzNextChar(sz)            AnsiNext(sz)


/*
**	Purpose:
**		Retreats a string pointer to the beginning of the previous valid
**		character.  This may include skipping a double-byte character.
**	Arguments:
**		szStart: string pointer to the beginning of a valid character that
**			equals or preceeds the character szCur.
**		szCur:   string pointer to retreat.  It can be NULL or empty, or
**			can point to any byte in a valid character.
**	Returns:
**		NULL if szCur was NULL.
**		sz unchanged if szStart was NULL or if szCur equaled szStart.
**		sz retreated past the current character and to the beginning of the
**			previous valid character.
*/
#define SzPrevChar(szStart, szCur) AnsiPrev(szStart, szCur)


/*
**	Purpose:
**		Copies a string from one buffer to another.
**	Arguments:
**		szDst: string pointer to destination buffer.  This can be NULL or
**			else it must contain enough storage to copy szSrc with its
**			terminating zero character.
**		szSrc: string pointer to source buffer.  This can be NULL or else
**			must point to a zero terminated string (can be empty).
**	Returns:
**		NULL if either szDst or szSrc is NULL.
**		szDst signifying the operation succeeded.
*/
#define SzStrCopy(szDst, szSrc)   lstrcpy(szDst, szSrc)


/*
**	Purpose:
**		Appends a string from one buffer to another.
**	Arguments:
**		szDst: string pointer to destination buffer.  This can be NULL or
**			else it must contain a zero terminated string (can be empty)
**			and enough storage to append szSrc with its terminating zero
**			character.
**		szSrc: string pointer to source buffer.  This can be NULL or else
**			must point to a zero terminated string (can be empty).
**	Returns:
**		NULL if either szDst or szSrc is NULL.
**		szDst signifying the operation succeeded.
*/
#define SzStrCat(szDst, szSrc)    lstrcat(szDst, szSrc)


/*
**	Purpose:
**		Converts a zero-terminated string to upper case.
**	Arguments:
**		sz: the string to convert to upper case.  sz must be non-NULL though
**			it can be empty.
**	Returns:
**		A pointer to the converted string.
*/
/* REVIEW: define SzStrUpper(sz)            (sz) */


/*
**	Purpose:
**		Converts a zero-terminated string to lower case.
**	Arguments:
**		sz: the string to convert to lower case.  sz must be non-NULL though
**			it can be empty.
**	Returns:
**		A pointer to the converted string.
*/
#define SzStrLower(sz)            AnsiLower(sz)


/* Memory Handling routines */
extern PB    WINAPI PbAlloc ( CB cb );
extern BOOL  WINAPI FFree ( PB pb, CB cb );
extern PB    WINAPI PbRealloc ( PB pb, CB cbNew, CB cbOld );

#define FHandleOOM()              HandleOOM()

/*
**	Purpose:
**		Frees the memory used by an sz.  This assumes the terminating
**		zero occupies the final byte of the allocated buffer.
**	Arguments:
**		sz: the buffer to free.  this must be non-NULL though it can point
**			at an empty string.
**	Returns:
**		fTrue if the Free() operation succeeds.
**		fFalse if the Free() operation fails.
*/
#define FFreeSz(sz)               FFree((PB)(sz), CbStrLen(sz)+1)


/*
**	Purpose:
**		Shrinks a buffer to exactly fit a string.
**	Arguments:
**		sz: the string for which the buffer should shrink to.  sz must be
**			non-NULL though it can be empty.
**		cb: the size in bytes for the buffer that was originally allocated.
**			cb must be greater than or equal to CbStrLen(sz) + 1.
**	Returns:
**		A pointer to the original string if the Realloc() operation succeeds.
**		NULL if the Realloc() operation fails.
*/
#define SzReallocSz(sz, cb)   (SZ)(PbRealloc((PB)(sz), (CbStrLen(sz)+1), cb))


/*
 *	File Handle structure
 *	Fields:
 *		hFile:   Win32 file handle.
 *		iDosfh:  Only used to avoid changing old source code, same as hFile
 *		szPath:  Full path used when the file was opened.
 */
typedef union _fh		/* File Handle structure */
	{
	INT     iDosfh;  /* temp until code converted */
	HANDLE  hFile;
	} FH;

/*
 *	File Handle datatype
 */
typedef FH *    PFH;		/* Ptr to File Handle structure */
typedef PFH *   PPFH;		/* Ptr to Ptr to File Handle structure */

#define pfhNull   ((PFH)NULL)
#define ppfhNull  ((PPFH)NULL)


/*
 *	Open File Mode datatype
 */
typedef UINT  OFM;		/* Open File Mode */

#define ofmExist          ((OFM)OF_EXIST)
#define ofmRead           ((OFM)OF_READ      | OF_SHARE_DENY_WRITE)
#define ofmReadCompat     ((OFM)OF_READ      | OF_SHARE_COMPAT)
#define ofmWrite          ((OFM)OF_WRITE     | OF_SHARE_EXCLUSIVE)
#define ofmReadWrite      ((OFM)OF_READWRITE | OF_SHARE_EXCLUSIVE)
#define ofmCreate         ((OFM)OF_CREATE    | OF_SHARE_EXCLUSIVE)


/*
 *	Seek File Mode datatype
 */
typedef UINT  SFM;		/* Seek File Mode */

#define sfmSet   ((SFM)FILE_BEGIN)
#define sfmCur   ((SFM)FILE_CURRENT)
#define sfmEnd   ((SFM)FILE_END)


/*
 *	Long File Address datatype
 */
typedef unsigned long  LFA;		/* Long File Address */

#define lfaSeekError   ((LFA)HFILE_ERROR)


/*
 *	Expanded Error Return Code
 */
typedef unsigned int  EERC;		/* Expanded Error Return Code */

#define eercOkay    ((EERC)0)
#define eercAbort   ((EERC)1)
#define eercRetry   ((EERC)2)
#define eercIgnore  ((EERC)3)


/* File handling routines */
extern EERC  WINAPI EercOpenFile ( PPFH ppfh, CSZC cszcFile, OFM ofm,
								   BOOL fVital );
extern BOOL  WINAPI FFileExist ( CSZC cszcFile, OFM ofm );
extern BOOL  WINAPI FCloseFile ( PFH pfh );
extern CB    WINAPI CbReadFile ( PFH pfh, PB pbBuf, CB cbMax );
extern CB    WINAPI CbWriteFile ( PFH pfh, PB pbBuf, CB cbMax );
extern LFA   WINAPI LfaSeekFile ( PFH pfh, LONG l, SFM sfm );
extern BOOL  WINAPI FChmodFile ( CSZC cszcFileName, INT wFlags, BOOL fVital );
extern SZC WINAPI DriveNumToRootPath( INT iDrive );


typedef unsigned int IDDT;		/* Insert Disk Dialog Type */
#define iddtStandard	((IDDT)1)
#define iddtHddi		((IDDT)2)
#define iddtHddiMaint	((IDDT)3)


/* Media source file handling routines */
extern EERC WINAPI EercOpenSrcFile ( PPFH ppfh, UINT did, SZ szSrcDir,
									 SZ szFile, BOOL fWrite );
extern EERC WINAPI EercOpenSrcFileEx ( PPFH ppfh, UINT did, SZ szSrcDir,
							 SZ szFile, BOOL fWrite, BOOL fVital, IDDT iddt );
extern EERC WINAPI EercReadSrcFile ( PFH pfh, PB pbBuf, CB cbMax );

extern EERC WINAPI EercWriteSrcFile ( PFH pfh, PB pbBuf, CB cbMax );

extern BOOL WINAPI FCloseSrcFile( PFH pfh, BOOL fRdOnly );

extern EERC WINAPI EercFindHddiFloppy ( SZ szSrcDir, DWORD dwDrives,
										PCH pchDrive, BOOL fVital, IDDT iddt );

/*
 *	SetErrorMode type
 */
typedef unsigned int  SEM;		/* SetErrorMode type */


/*
 *	Comparison Return Code datatype
 */
typedef INT CRC;		/* Comparison Return Code */

#define crcError         ((CRC)(-2))
#define crcEqual         ((CRC)  0 )
#define crcFirstHigher   ((CRC)  1 )
#define crcSecondHigher  ((CRC)(-1))

extern SZ    PUBLIC SzDupl ( CSZC cszc );
extern CRC   WINAPI CrcStringCompare  ( CSZC cszc1, CSZC cszc2 );
extern CRC   WINAPI CrcStringCompareI ( CSZC cszc1, CSZC cszc2 );
extern SZ    WINAPI SzLastChar ( CSZC cszc );
extern CB    WINAPI CbStrCopyToBuffer ( PB pbBuf, CB cbMax, CSZC cszcSrc );


/*
 *	BindImage API, exported from MSSETUP.DLL, and/or IMAGEHLP.DLL
 */

#define IMAGEHELP_DLL  "imagehlp.dll"
#define BINDIMAGE_PROC "BindImage"
typedef BOOL (WINAPI *PFNBindImage)( SZ szImage, SZ szDllPath, SZ szSymPath);

extern BOOL WINAPI BindImage( SZ szImage, SZ szDllPath, SZ szSymPath);


/*
 *	API to set Admin mode in toolkit DLL
 */

VOID WINAPI SetAdminMode ( VOID );  /* called only by ACMSETUP.EXE */
BOOL WINAPI IsAdminMode ( VOID );


/* Like FStampResource, but only reads the data into the buffer.
*/
BOOL  WINAPI FReadResource ( SZ szFilePath, UINT uiResType, UINT uiResId,
												 SZ szData, CB cbData, BOOL fNotCopied );

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif

#endif  /* SETUPKIT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\setup\inc\version.h ===
#define rmj		3
#define rmm		1
#define rup		1918
#define szVerName	"3.01.0.1918"
#define szVerUser	"CONMAN"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\setup\inc\setupapi.h ===
/***************************************************************************
**
**      File:                   SETUPAPI.H
**      Purpose:                Prototypes for the Setup API.
**      Notes:
**
****************************************************************************/

#ifndef SETUPAPI_H
#define SETUPAPI_H

#define ACME_LOGFILE    1
/* Plenty of macros to make the port to Win32 easier.
 * e.g. #define _fmemcmp memcmp
 */
#include <windowsx.h>

/* Ignore the following declarators */
#define _based(seg)
#define _loadds
#define __loadds
#define __export

/* Undef CopyFile, which WIN32 defines as CopyFileA, an API */
#undef CopyFile

/*
 * In Win32, all the Api's work directly with ANSI buffers, so we no longer
 * want to use conversions.
 */
#undef OemToAnsi
#undef AnsiToOem
#define OemToAnsi(o,a) lstrcpy(a,o)
#define AnsiToOem(a,o) lstrcpy(o,a)

#ifdef _DEBUG
#define DEBUG
#endif


#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif

/* Private toolkit messages used by ACMSETUP and custom actions */

#define  STF_MESSAGE        (WM_USER + 0x8000)
#define  STF_REINITDIALOG   (STF_MESSAGE + 12)
#define  STF_ACTIVATEAPP    (STF_MESSAGE + 17)

/*
 *      Setup Error Codes.  These are the values passed to the user supplied
 *      error function.
 */
typedef unsigned int  SEC;              /* Setup Error Code */
typedef SEC *         PSEC;             /* Ptr to Setup Error Code */

#define secOk         ((SEC)   0)
#define secErr        ((SEC)1024)
#define secQuit       ((SEC)1025)
#define secRestart    ((SEC)1026)	/* Windows is being restarted */


/*
 *      Window Visibility Modes - InitSetupToolkit parameter
 */
typedef UINT WVM;       /* Window Visibility Mode */

#define wvmNormal     ((WVM)0)
#define wvmMaximized  ((WVM)1)
#define wvmMinimized  ((WVM)2)


/*
 *      CoMmand Option flags
 */
typedef UINT CMO;       /* CoMmand Option */

#define cmoVital      ((CMO)0x1)
#define cmoCopy       ((CMO)0x2)
#define cmoUndo       ((CMO)0x4)
#define cmoRoot       ((CMO)0x8)
#define cmoDecompress ((CMO)0x10)
#define cmoTimeStamp  ((CMO)0x20)
#define cmoReadOnly   ((CMO)0x40)
#define cmoBackup     ((CMO)0x80)
#define cmoForce      ((CMO)0x100)
#define cmoRemove     ((CMO)0x200)
#define cmoOverwrite  ((CMO)0x400)
#define cmoAppend     ((CMO)0x800)
#define cmoPrepend    ((CMO)0x1000)
#define cmoShared     ((CMO)0x2000)
#define cmoSystem     ((CMO)0x4000)
/* NOTE oefCabinet in COMSTF.H uses 0x8000 */
#define cmoNone       ((CMO)0x0)
#define cmoAll        ((CMO)0xffff)


/*
 *      File Exist Modes - DoesFileExist parameter
 *      (order is important)
 */
typedef UINT FEM;       /* File Exist Mode */

#define femExists     ((FEM)0)
#define femRead       ((FEM)1)
#define femWrite      ((FEM)2)
#define femReadWrite  ((FEM)3)
#define femMin        ((FEM)0)
#define femMax        ((FEM)4)


/*
 *      Size ChecK Modes - SetSizeCheckMode parameter
 */
typedef UINT SCKM;      /* Size ChecK Mode */

#define sckmOff       ((SCKM)0)
#define sckmOnIgnore  ((SCKM)1)
#define sckmOnFatal   ((SCKM)2)


/*
 *      Silent Mode - SetSilentMode parameter
 */
typedef UINT SM;        /* Silent Mode */

#define smNormal        ((SM)0x0000)
#define smNoDialogs     ((SM)0x0001)
#define smNoCopyGauge   ((SM)0x0002)
#define smTotallySilent ((SM) ~(0))


/*
 *      Current File Version - DoesSharedFileNeedCopying return type
 *
 *      NOTE - order is important - see FIBSECfv(cfv) macro below.
 */
typedef enum _CFV               /* Current File Version */
	{
	cfvNoFile,
	cfvLoVer,
	cfvDiffLang,
	cfvEqVer,
	cfvHiVer,
	cfvUnknown
	}  CFV;
typedef CFV * PCFV;             /* Ptr to Current File Version */
#define FIBSECfv(cfv)   (cfv > cfvEqVer)


typedef UINT WMD;               /* Windows MoDe */

#define wmdReal      0
#define wmdStandard  1
#define wmdEnhanced  2
#define wmdNT            3
#define wmdUnknown  10


typedef UINT CPU;               /* type of Central Processor Unit (or coprocessor) */

#define cpu8086          0
#define cpu80186         1
#define cpu80286         2
#define cpu80386         3
#define cpu80486         4
#define cpuR4000     5  /* for compatibility with CDrivers : Setup 2.0 */
						/* Ideally this should have been ifdef'd  to > 5 */
#define cpuMin           0
#define cpuMax           5
#define cpuUnknown  20


typedef VOID ( WINAPI *LPFNERROREXIT )( UINT );

#define SETUPAPI        WINAPI
#define SZ                      char *
#define CSZ                     char * const
#define SZC                     const char *
#define CSZC            const char * const

extern VOID SETUPAPI AddBlankToBillboardList ( LONG lTicks );
extern VOID SETUPAPI AddDos5Help ( SZ szProgName, SZ szProgHelp, CMO cmo );
extern VOID SETUPAPI AddLineToRestartFile ( SZ szLine );
extern VOID SETUPAPI AddListItem ( SZ szSymbol, SZ szItem );
extern VOID SETUPAPI AddSectionFilesToCopyList ( SZ szSect, SZ szSrcDir, SZ szDstDir );
extern VOID SETUPAPI AddSectionKeyFileToCopyList ( SZ szSect, SZ szKey, SZ szSrcDir, SZ szDstDir );
extern VOID SETUPAPI AddSpecialFileToCopyList ( SZ szSect, SZ szKey, SZ szSrcDir, SZ szDstPath );
extern VOID SETUPAPI AddSrcFileWithAttribsToCopyList ( SZ szSect, SZ szKey, SZ szSrcPath, SZ szDstPath );
extern VOID SETUPAPI AddShareToAutoexec ( SZ szSrc, SZ szDst, BOOL fConfig, BOOL fNeedsNewLine, SZ szDefPath, UINT wMinLock, UINT wMinBuf, UINT wMaxLock, UINT wMaxBuf, CMO cmo );
extern VOID SETUPAPI AddToBillboardList ( SZ szDll, UINT idDlg, SZ szProc, LONG lTicks );
extern VOID SETUPAPI BackupFile ( SZ szFullPath, SZ szBackup );
extern UINT SETUPAPI CbGetListItem ( SZ szSym, UINT uiItem, SZ szItem, UINT cbMax );
extern UINT SETUPAPI CbGetSymbolValue ( SZ szSymbol, SZ szValue, UINT cbMax );
extern VOID SETUPAPI ClearBillboardList ( VOID );
extern VOID SETUPAPI ClearCopyList ( VOID );
extern int  SETUPAPI CompareFileVersions ( SZ szVer1, SZ szVer2 );
extern VOID SETUPAPI CopyFile ( SZ szFullPathSrc, SZ szFullPathDst, CMO cmo, BOOL fAppend );
extern VOID SETUPAPI CopyFilesInCopyList ( BOOL fDeterrentEnabled );
extern VOID SETUPAPI CreateDir ( SZ szDir, CMO cmo );
extern VOID SETUPAPI CreateIniKeyValue ( CSZC cszcFile, CSZC cszcSect, CSZC cszcKey, CSZC cszcValue, CMO cmo );
extern VOID SETUPAPI CreateProgmanGroup ( SZ szGroup, SZ szPath, CMO cmo );
extern VOID SETUPAPI CreateProgmanItem ( SZ szGroup, SZ szItem, SZ szCmd, SZ szOther, CMO cmo );
extern VOID SETUPAPI CreateSysIniKeyValue ( SZ szFile, SZ szSect, SZ szKey, SZ szValue, CMO cmo );
extern VOID SETUPAPI DebugMessagesOn ( BOOL fMsgOn );
extern VOID SETUPAPI DeleteProgmanGroup ( SZ szGroup, CMO cmo );
extern VOID SETUPAPI DeleteProgmanItem ( SZ szGroup, SZ szItem, CMO cmo, BOOL fDelEmptyGroup );
extern BOOL SETUPAPI DeleteRegKeyValue32 ( HKEY hRootKey, CSZC cszcSubKey, CSZC cszcValueName );
extern int  SETUPAPI DoMsgBox ( CSZC cszcText, CSZC cszcCaption, UINT uiType );
extern int  SETUPAPI DoMsgBoxProc( CSZC cszcText, CSZC cszcCaption, UINT uiType );
extern BOOL SETUPAPI DoesDirExist ( SZ szDir );
extern BOOL SETUPAPI DoesFileExist ( SZ szFileName, FEM fem );
extern BOOL SETUPAPI DoesInfSectionExist ( SZ szSect );
extern BOOL SETUPAPI DoesInfSectionKeyExist ( SZ szSect, SZ szKey );
extern BOOL SETUPAPI DoesIniKeyExist ( SZ szFile, SZ szSect, SZ szKey );
extern BOOL SETUPAPI DoesIniSectionExist ( SZ szFile, SZ szSect );
extern CFV  SETUPAPI DoesSharedFileNeedCopying ( VOID );
extern BOOL SETUPAPI DoesSysIniKeyValueExist ( SZ szFile, SZ szSect, SZ szKey, SZ szValue );
extern VOID SETUPAPI DumpCopyList ( SZ szFile );
extern VOID SETUPAPI EndSetupToolkit ( VOID );
extern BOOL SETUPAPI ExitExecRestart ( VOID );
extern BOOL SETUPAPI FAddLineToRestartFile ( SZ szLine );
extern BOOL SETUPAPI FAddListItem ( SZ szSym, SZ szItem );
extern BOOL SETUPAPI FCloseHelp ( VOID );
extern BOOL SETUPAPI FGetShareParamsFromFile ( CSZC cszcFile, BOOL fConfig, UINT * puiLock, UINT * puiBuf, BOOL * pfAnyShare, SZ szPath, UINT cbBuf );
extern BOOL SETUPAPI FixupWinIniMsappsSection ( VOID );
extern BOOL SETUPAPI FLanguageMismatchInf ( SZ szSection, SZ szKey, SZ szDestPath );
extern BOOL SETUPAPI FLongFileNamesSuppressed ( VOID );
extern BOOL SETUPAPI FOpenLogFile ( CSZC cszcFile, BOOL fAppend );
extern BOOL SETUPAPI FRegCloseKey (HKEY hKey);
extern BOOL SETUPAPI FGetKeyInfo(HKEY hkey,LPDWORD lpcSubKeys,LPDWORD lpcValues);
extern BOOL SETUPAPI FRegCreateKey32(HKEY hRootKey, SZ szRegKey,HKEY* phKey);
extern BOOL SETUPAPI FWriteToLogFile ( CSZC cszc, BOOL fRequireLog );
extern BOOL SETUPAPI FCloseLogFile ( VOID );
extern BOOL SETUPAPI ForceNewDialog ( BOOL fForce );
extern BOOL SETUPAPI HandleOOM ( VOID );
extern UINT SETUPAPI HandleSharedFile ( SZ szInfSect, SZ szInfKey, CSZC cszcRegKey,
								CSZC cszcFullPath, HKEY hRegRootKey, SZ szRegDbKey,
								SZ szRegValueName, UINT uiRegDbField, SZ szWinIniSect,
								SZ szWinIniKey, UINT uiWinIniField, SZ szBuf, UINT cbBufMax);
extern BOOL SETUPAPI FRemoveSymbol ( SZ szSymbol );
extern BOOL SETUPAPI FReplaceListItem ( SZ szSym, UINT uiItem, SZ szItem );
extern BOOL SETUPAPI FSetSymbolValue ( SZ szSymbol, SZ szValue );
extern UINT SETUPAPI FindFileInTree ( SZ szFile, SZ szDir, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI FindFileUsingFileOpen ( SZ szFile, SZ szPath, UINT cbPathMax );
extern UINT SETUPAPI FindTargetOnEnvVar ( SZ szFile, SZ szEnvVar, SZ szBuf, UINT cbBufMax );
extern VOID SETUPAPI ForceRestartOn ( VOID );
extern VOID SETUPAPI ForceRestartOff ( VOID );
extern VOID SETUPAPI FreeMemInf ( VOID * pvMemInf );
extern char SETUPAPI GetConfigLastDrive ( VOID );
extern UINT SETUPAPI GetConfigNumBuffers ( VOID );
extern UINT SETUPAPI GetConfigNumFiles ( VOID );
extern UINT SETUPAPI GetConfigRamdriveSize ( VOID );
extern UINT SETUPAPI GetConfigSmartdrvSize ( VOID );
extern LONG SETUPAPI GetCopyListCost ( SZ szExtraList, SZ szCostList, SZ szNeedList );
extern UINT SETUPAPI GetDOSMajorVersion ( VOID );
extern UINT SETUPAPI GetDOSMinorVersion ( VOID );
extern UINT SETUPAPI GetDateOfFile ( SZ szFile, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI GetDayFromDate ( SZ szDate );
extern UINT SETUPAPI GetEnvVariableValue ( SZ szEnvVar, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI GetExistingFOTFileForTTF ( SZ szFile, SZ szBuf, UINT cbBufMax );
extern LONG SETUPAPI GetFreeSpaceForDrive ( SZ szDrive );
extern UINT SETUPAPI GetHourFromDate ( SZ szDate );
extern UINT SETUPAPI GetIniKeyString ( CSZC cszcFile, CSZC cszcSect, CSZC cszcKey, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI GetListItem ( SZ szListSymbol, UINT uiItem, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI GetListLength ( SZ szSymbol );
extern VOID SETUPAPI GetLocalHardDrivesList ( SZ szSymbol );
extern WORD SETUPAPI GetLocalLanguage ( VOID );
extern UINT SETUPAPI GetMinuteFromDate ( SZ szDate );
extern UINT SETUPAPI GetMonthFromDate ( SZ szDate );
extern VOID SETUPAPI GetNetworkDrivesList ( SZ szSymbol );
extern UINT SETUPAPI GetNthFieldFromIniString ( SZ szLine, UINT uiField, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI GetNumWinApps ( VOID );
extern VOID SETUPAPI GetParallelPortsList ( SZ szSymbol );
extern UINT SETUPAPI GetProcessorType ( VOID );
extern UINT SETUPAPI GetRegKeyValue32 ( HKEY hRootKey, CSZC cszcSubKey, CSZC cszcValueName, PDWORD pdwType, PBYTE pbData, UINT cbData );
extern VOID SETUPAPI GetRemovableDrivesList ( SZ szSymbol );
extern int  SETUPAPI GetScreenHeight ( VOID );
extern int  SETUPAPI GetScreenWidth ( VOID );
extern UINT SETUPAPI GetSecondFromDate ( SZ szDate );
extern UINT SETUPAPI GetSectionKeyDate ( SZ szSect, SZ szKey, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI GetSectionKeyFilename ( SZ szSect, SZ szKey, SZ szBuf, UINT cbBufMax );
extern LONG SETUPAPI GetSectionKeySize ( SZ szSect, SZ szKey );
extern UINT SETUPAPI GetSectionKeyVersion ( SZ szSect, SZ szKey, SZ szBuf, UINT cbBufMax );
extern VOID SETUPAPI GetSerialPortsList ( SZ szSymbol );
extern SM   SETUPAPI GetSilentMode ( VOID );
extern LONG SETUPAPI GetSizeOfFile ( SZ szFile );
extern UINT SETUPAPI GetSymbolValue ( SZ szSymbol, SZ szBuf, UINT cbBufMax );
extern LONG SETUPAPI GetTotalSpaceForDrive ( SZ szDrive );
extern UINT SETUPAPI GetTypeFaceNameFromTTF ( SZ szFile, SZ szBuf, UINT cbBufMax );
extern VOID SETUPAPI GetValidDrivesList ( SZ szSymbol );
extern LONG SETUPAPI GetVersionNthField ( SZ szVersion, UINT uiField );
extern UINT SETUPAPI GetVersionOfFile ( SZ szFile, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI GetWindowsDirPath ( SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI GetWindowsMajorVersion ( VOID );
extern UINT SETUPAPI GetWindowsMinorVersion ( VOID );
extern UINT SETUPAPI GetWindowsMode ( VOID );
extern UINT SETUPAPI GetWindowsSysDir ( SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI GetYearFromDate ( SZ szDate );
extern BOOL SETUPAPI Has87MathChip ( VOID );
extern BOOL SETUPAPI HasMonochromeDisplay ( VOID );
extern BOOL SETUPAPI HasMouseInstalled ( VOID );
extern HWND SETUPAPI HdlgShowHelp (UINT uiMsg, WPARAM wParam, LPARAM lParam);
extern HINSTANCE SETUPAPI HinstFrame ( VOID );
extern HWND SETUPAPI HwndFrame ( VOID );
extern VOID SETUPAPI InitLongFileNames ( VOID );
extern UINT SETUPAPI InitSetupToolkit ( SZ szCmdLine, WVM wvmVisibilityMode, BOOL fUseRegDb, LPFNERROREXIT lpfnErrorExit );
extern BOOL SETUPAPI IsCtl3dEnabled ( VOID );
extern BOOL SETUPAPI IsDirWritable ( SZ szDir );
extern BOOL SETUPAPI IsDriveLocalHard ( SZ szDrive );
extern BOOL SETUPAPI IsDriveNetwork ( SZ szDrive );
extern BOOL SETUPAPI IsDriveRemovable ( SZ szDrive );
extern BOOL SETUPAPI IsDriveValid ( SZ szDrive );
extern BOOL SETUPAPI IsDriverInConfig ( SZ szDrv );
extern BOOL SETUPAPI IsFileInUseBySystem ( SZ szFullPath );
extern BOOL SETUPAPI IsFileWritable ( SZ szFile );
extern BOOL SETUPAPI IsValidPath ( SZC szcPath );
extern BOOL SETUPAPI IsWindowsShared ( VOID );
extern VOID SETUPAPI MakeListFromProgmanGroups ( SZ szSymbol );
extern VOID SETUPAPI MakeListFromSectionDate ( SZ szSym, SZ szSect );
extern VOID SETUPAPI MakeListFromSectionFilename ( SZ szSym, SZ szSect );
extern VOID SETUPAPI MakeListFromSectionKeys ( SZ szSymbol, SZ szSect );
extern VOID SETUPAPI MakeListFromSectionSize ( SZ szSym, SZ szSect );
extern VOID SETUPAPI MakeListFromSectionVersion ( SZ szSym, SZ szSect );
extern VOID SETUPAPI PrependToPath ( SZ szSrc, SZ szDst, SZ szDir, CMO cmo );
extern VOID * SETUPAPI PVSaveMemInf ( VOID );
extern VOID SETUPAPI ReactivateSetupScript ( VOID );
extern VOID SETUPAPI ReadInfFile ( SZ szFile );
extern VOID SETUPAPI RemoveDir ( SZ szDir, CMO cmo );
extern VOID SETUPAPI RemoveFile ( SZ szFullPathSrc, CMO cmo );
extern VOID SETUPAPI RemoveIniKey ( CSZC cszcFile, CSZC cszcSect, CSZC cszcKey, CMO cmo );
extern VOID SETUPAPI RemoveIniSection ( CSZC cszcFile, CSZC cszcSect, CMO cmo );
extern VOID SETUPAPI RemoveSectionFilesToCopyList ( SZ szSect, SZ szDstDir );
extern VOID SETUPAPI RemoveSectionKeyFileToCopyList ( SZ szSect, SZ szKey, SZ szDstDir );
extern VOID SETUPAPI RemoveSpecialFileToCopyList ( SZ szSect, SZ szKey, SZ szDstPath );
extern VOID SETUPAPI RemoveSymbol ( SZ szSym );
extern VOID SETUPAPI RenameFile ( SZ szFullPath, SZ szBackup );
extern VOID SETUPAPI ReplaceListItem ( SZ szSymbol, UINT uiItem, SZ szItem );
extern BOOL SETUPAPI RestartListEmpty ( VOID );
extern VOID SETUPAPI RestoreCursor ( HCURSOR hcursorPrev );
extern VOID SETUPAPI RestoreMemInf ( VOID * pvMemInf );
extern VOID * SETUPAPI SaveMemInf ( VOID );
extern UINT SETUPAPI SearchForLocationForSharedFile ( HKEY hRegRootKey,
								SZ szRegDbKey, SZ szRegValueName, UINT uiRegDbField,
								SZ szWinIniSect, SZ szWinIniKey, UINT uiWinIniField,
								SZ szDefSharedPath, SZ szVersion, SZ szLangSrc,
								SZ szBuf, UINT cbBufMax );
extern VOID SETUPAPI SetAbout ( SZ szAbout1, SZ szAbout2 );
extern BOOL SETUPAPI SetBeepingMode ( BOOL fMode );
extern VOID SETUPAPI SetBitmap ( SZ szDll, UINT idBitmap );
extern VOID SETUPAPI SetCopyGaugePosition ( int x, int y );
extern BOOL SETUPAPI SetCopyMode ( BOOL fMode );
extern BOOL SETUPAPI SetDecompMode ( BOOL fMode );
extern BOOL SETUPAPI SetRegKeyValue32 ( HKEY hRootKey, CSZC cszcSubKey, CSZC cszcValueName, DWORD fdwType, CONST BYTE* lpbData, DWORD cbData );
extern BOOL SETUPAPI SetRegKeyValue32Ex (HKEY hKey,HKEY hRootKey, CSZC cszcRegKey, CSZC cszcValueName, DWORD fdwType,CONST BYTE* lpbData, DWORD cbData,BOOL fClose );
extern BOOL SETUPAPI GetRegKeyValue32Ex (HKEY hKey,CSZC cszcValueName, PDWORD pdwType,PBYTE pbData, UINT cbData, BOOL fClose );
extern VOID SETUPAPI SetRestartDir ( SZ szDir );
extern SM   SETUPAPI SetSilentMode ( SM smSilentMode );
extern UINT SETUPAPI SetSizeCheckMode ( SCKM sckmMode );
extern VOID SETUPAPI SetSymbolValue ( SZ szSymbol, SZ szValue );
extern BOOL SETUPAPI SetTimeValue ( UINT uiHours, UINT uiMinutes, UINT uiSeconds );
extern VOID SETUPAPI SetTitle ( SZ sz );
extern VOID SETUPAPI ShowProgmanGroup ( SZ szGroup, UINT Cmd, CMO cmo );
extern HCURSOR SETUPAPI ShowWaitCursor ( VOID );
extern VOID SETUPAPI StampResource ( SZ szFilePath, UINT uiResType, UINT uiResId, SZ szData, UINT cbData, BOOL fNotCopied );
extern VOID SETUPAPI SuppressLongFileNames ( VOID );
extern VOID SETUPAPI UIPop ( UINT cDlgs );
extern VOID SETUPAPI UIPopAll ( VOID );
extern UINT SETUPAPI UIStartDlg ( SZ szDll, UINT Dlg, SZ szDlgProc, UINT HelpDlg, SZ szHelpProc, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI UIStartExeDlg ( HINSTANCE hinstExe, UINT Dlg, FARPROC lpfnDlgProc, UINT HelpDlg, FARPROC lpfnHelpProc, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI UIStartExeDlgWinHelp ( HINSTANCE hinstExe, UINT Dlg, FARPROC lpfnDlgProc, SZ szFile, DWORD* rgdwHelpID, SZ szBuf, UINT cbBufMax );
extern UINT SETUPAPI UsGetListLength ( SZ szSym );
extern VOID SETUPAPI WriteLogDivider ( VOID );
extern UINT SETUPAPI EnsurePathExists( SZ szFullPathDst );
extern BOOL SETUPAPI FRemoveOurDir ( SZ szFullPath, BOOL fStrip );
#if defined(UI_HOOK)
extern HMODULE SETUPAPI HmodUIHookDll(VOID);
#endif /* UI_HOOK */

#undef  SZ
#undef  CSZ
#undef  SZC
#undef  CSZC

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif

#endif  /* SETUPAPI_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\setup\intl\usa\bldver.h ===
#include "version.h"


#ifdef RC_INVOKED

#include "verdef.h"

#define VER_FILEVERSION_STR      "3.01\0"
#define VER_FILEVERSION          rmj,rmm,0,rup

#define VER_LEGALCOPYRIGHT_STR   "Copyright \251 Microsoft Corp. 1991-1997\0"
#define VER_COMMENT_STR          "Windows Setup Toolkit (Throttle)\0"
#define VER_FILETYPE             VFT_DLL
#define VER_FILESUBTYPE          0

#endif  /* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\setup\intl\usa\verdef.h ===
/***************************************************************************
**
**	File:			verdef.h
**	Purpose:		Defines values used in the version data structure for
**					all files, and which do not change.
**	Notes:
**
****************************************************************************/

#ifndef VERSION_H
#define VERSION_H

#ifndef VS_FF_DEBUG
#ifdef _RC32
#include <winver.h>
#else
/* ver.h defines constants needed by the VS_VERSION_INFO structure */
#include <ver.h>
#endif /* _RC32 */
#endif 

/*--------------------------------------------------------------*/

/* default is official */
#ifdef PRIVATEBUILD
#define VER_PRIVATEBUILD            VS_FF_PRIVATEBUILD
#else
#define VER_PRIVATEBUILD            0
#endif

/* default is final */
#ifdef PRERELEASE
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK

#endif  /* VERSION_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\setup\inc\stdtypes.h ===
/****************************************************************************
**
**	File:			STDTYPES.H
**	Purpose:		Standard project wide include file.
**	Notes:
**
****************************************************************************/

#ifndef STDTYPES_H
#define STDTYPES_H

#ifdef _WIN32
/* The windows.h for win32 used _WINDOWS_ instead of _INC_WINDOWS */
#ifdef _INC_WINDOWS
#undef _INC_WINDOWS
#endif
#define _INC_WINDOWS	_WINDOWS_
#endif /* _WIN32 */

/* MAX_PATH is the Win32 define, _MAX_PATH is the MSVC define, equate them */
#ifdef MAX_PATH
#undef _MAX_PATH
#define _MAX_PATH MAX_PATH
#else
#define MAX_PATH _MAX_PATH
#endif

/* CDECL is already defined in WIN32.  Undef it */
/*#undef CDECL*/

/* Rename PSZ, since it is defined in WIN32 as char*, and we want char** */
#define PSZ _PSZ


#ifdef DEBUG
#define DEVELOPER		/* REVIEW: This is temporary */
#endif

/*
 *	Constants
 */
#define fFalse				((BOOL)0)
#define fTrue				((BOOL)1)

#define Nil					0

#define chNil				'\0'
#define chEos				'\0'
#define chTab				'\t'
#define chEol				'\n'
#define chCR				'\r'
#define chCtrlZ				'\x1A'

#define chSpace				' '
#define chBang				'!'
#define chDblQuote			'\"'
#define chDollar			'$'
#define chPercent			'%'
#define chSngQuote			'\''
#define chStar				'*'
#define chPlus				'+'
#define chComma				','
#define chMinus				'-'
#define chPeriod			'.'
#define chSlash				'/'
#define chColon				':'
#define chSemiColon			';'
#define chLftAngle			'<'
#define chEquals			'='
#define chRgtAngle			'>'
#define chQuestionMark		'?'
#define chAtSign			'@'
#define chLftSqBracket		'['
#define chBackSlash			'\\'
#define chRgtSqBracket		']'
#define chUnderscore		'_'
#define chLftBrace			'{'
#define chVertical			'|'
#define chRgtBrace			'}'

#define chDirSep			chBackSlash

#define szDirSep            "\\"
#define szTab               "\t"

#define cchIntMax			 17		/*  Maximum number of digits (_itoa) */
#define cchLongMax			 33		/*  Maximum number of digits (_ltoa) */
#define cchSzMax	     MAX_PATH	/*  Includes chEos */

/*
 *	In a windows program windows.h must be included before this file.
 *	If a DOS program includes ver.h, it must do so before including this
 *	file.
 */
#ifndef _INC_WINDOWS	/* Don't declare if already declared in windows.h */
#ifndef WINAPI			/* Don't declare if already declared in ver.h */

typedef int					BOOL;
typedef unsigned char		BYTE;
typedef unsigned int		UINT;

#ifdef STRICT
typedef signed long			LONG;
#else
#define LONG				long
#endif

#ifndef NULL
#define NULL				0
#endif

#endif  /* WINAPI */

#define VOID				void
#define CDECL				_cdecl
typedef void *				LPVOID;

#endif  /* _INC_WINDOWS */

/*
 *	Common definitions.  See windef.h and winnt.h for these defines:
 *
 *		VOID, NULL, CDECL, WINAPI, CALLBACK
 */
#define STATIC_FN			static
#define STATIC_VAR			static
#define PRIVATE				WINAPI
#define PUBLIC				WINAPI

#define HUGE

/*
 *	Standard types.  See windef.h and winnt.h for these types:
 *
 *		CHAR, UCHAR, BYTE, BOOL, USHORT, INT, UINT, WPARAM,
 *      LONG, ULONG, LPARAM, LRESULT
 *
 *	Types defined in _WIN32 windef.h and winnt.h, but not WIN16 windows.h.
 *
 *		CHAR, USHORT, ULONG
 */
#ifndef _WIN32
typedef char				CHAR;
typedef unsigned short		USHORT;
typedef unsigned long		ULONG;
#endif /* !_WIN32 */
typedef signed char			SBYTE;
typedef UINT			CB;
typedef unsigned long		LCB;

typedef UINT				IDT;	/* ID of dialog Template */
typedef UINT				IDC;	/* ID of dialog Control  */
typedef UINT				IDR;	/* ID of Resource        */

/*
 *	Standard pointer types.  See windef.h and winnt.h for these types:
 *
 *      PUSHORT, PINT, PUINT, PBOOL, PLONG, PULONG
 *
 *	Types defined in _WIN32 windef.h and winnt.h, but not WIN16 windows.h.
 *
 *		PBOOL, PUINT, PUSHORT, PULONG
*/
#ifndef _WIN32
typedef BOOL *				PBOOL;
typedef UINT *				PUINT;
typedef USHORT *			PUSHORT;
typedef ULONG *				PULONG;
#endif /* !_WIN32 */
typedef VOID *				PV;
typedef PV *				PPV;
typedef PPV *				PPPV;
typedef CHAR *				SZ;		/* ptr to char                   */
typedef CHAR * const		CSZ;	/* constant ptr to char          */
typedef const CHAR *		SZC;	/* ptr to constant char          */
typedef const CHAR * const	CSZC;	/* constant ptr to constant char */
typedef SZ *				RGSZ;
typedef SZ *				PSZ;
typedef PSZ *				PPSZ;
typedef BYTE *				PB;
typedef PB *				PPB;
typedef PPB *				PPPB;
typedef SBYTE *				PSB;
typedef PSB *				PPSB;
typedef PPSB *				PPPSB;
typedef PBOOL *				PPBOOL;
typedef PPBOOL *			PPPBOOL;
typedef BOOL *				RGBOOL;
typedef RGBOOL *			PRGBOOL;
typedef PRGBOOL *			PPRGBOOL;
typedef PINT *				PPINT;
typedef PPINT *				PPPINT;
typedef PUINT *				PPUINT;
typedef PPUINT *			PPPUINT;
typedef UINT *				RGUINT;
typedef RGUINT *			PRGUINT;
typedef PRGUINT *			PPRGUINT;
typedef PUSHORT *			PPUSHORT;
typedef PPUSHORT *			PPPUSHORT;
typedef PLONG * 	 	 	PPLONG;
typedef PPLONG *			PPPLONG;
typedef PULONG *			PPULONG;
typedef PPULONG *			PPPULONG;
typedef CB *				PCB;
typedef PCB *				PPCB;
typedef PPCB *				PPPCB;
typedef LCB *				PLCB;
typedef PLCB *				PPLCB;
typedef PPLCB *				PPPLCB;
typedef IDT *               PIDT;
typedef PIDT *              PPIDT;
typedef PPIDT *             PPPIDT;
typedef IDC *               PIDC;
typedef PIDC *              PPIDC;
typedef PPIDC *             PPPIDC;
typedef IDR *               PIDR;
typedef PIDR *              PPIDR;
typedef PPIDR *             PPPIDR;

#ifdef _INC_WINDOWS

/*
 *	Pointers to various Windows types.
 */
typedef FARPROC *			PLPFN;
typedef DLGPROC *			PDLGPROC;
typedef HACCEL *			PHACCEL;
typedef HBITMAP *			PHBM;
typedef HBRUSH *			PHBR;
typedef HCURSOR *			PHCURSOR;
typedef HDC *				PHDC;
typedef HDWP *				PHDWP;
typedef HFONT *				PHFONT;
typedef HGDIOBJ *			PHGDIOBJ;
typedef HGLOBAL *			PHGLOBAL;
typedef HHOOK *				PHHOOK;
typedef HICON *				PHICON;
typedef HINSTANCE *			PHINST;
typedef HMENU *				PHMENU;
typedef HMETAFILE *			PHMF;
typedef HMODULE *			PHMOD;
typedef HPALETTE *			PHPAL;
typedef HPEN *				PHPEN;
typedef HRSRC *				PHRSRC;
typedef HTASK *				PHTASK;

typedef HWND *				PHWND;
typedef HRGN *				PHRGN;
typedef PRECT *				PPRECT;

#endif  /* _INC_WINDOWS */

/*
 *	More constants
 */
#define szNil				( (SZ) Nil )
#define pszNil				( (PSZ)Nil )
#define pbNil				( (PB) Nil )
#define pvNil				( (PV) Nil )
#define cbNil				( (CB) Nil )
#define idtNil				( (IDT)Nil )
#define idcNil				( (IDC)Nil )
#define idrNil				( (IDR)Nil )

#define cbMaxConst			( (CB) 0xffff )
#define cbError				( (CB) HFILE_ERROR )

#ifdef __cplusplus
#define pvNull				0
#define lpvoidNull			0
#define szNull				0
#define pszNull				0
#define rgszNull			0
#define cszcNull			0
#define pbNull				0
#define pcbNull				0
#define puintNull			0
#define rguintNull          0
#define prguintNull         0
#define pulongNull			0
#define lpfnNull			0
#define pfNull              0
#define rgfNull             0
#define prgfNull            0
#define pidtNull            0
#define pidcNull            0
#define pidrNull            0
#else
#define pvNull				( (PV)     NULL )
#define lpvoidNull			( (LPVOID) NULL )
#define szNull				( (SZ)     NULL )
#define pszNull				( (PSZ)    NULL )
#define rgszNull			( (RGSZ)   NULL )
#define cszcNull			( (CSZC)   NULL )
#define pbNull				( (PB)     NULL )
#define pcbNull				( (PCB)    NULL )
#define puintNull			( (PUINT)  NULL )
#define rguintNull          ( (RGUINT) NULL )
#define prguintNull         ( (PRGUINT)NULL )
#define pulongNull			( (PULONG) NULL )
#define lpfnNull			(          NULL )
#define pfNull              ( (PBOOL)  NULL )
#define rgfNull             ( (RGBOOL) NULL )
#define prgfNull            ( (PRGBOOL)NULL )
#define pidtNull            ( (PIDT)   NULL )
#define pidcNull            ( (PIDC)   NULL )
#define pidrNull            ( (PIDR)   NULL )
#endif  /* __cplusplus */

#ifdef _INC_WINDOWS

/*
 *	Null constants for various Windows types.
 */
#ifdef __cplusplus
#define dlgprocNull			0
#define haccellNull			0
#define hbmNull				0
#define hbrNull				0
#define hcursorNull			0
#define hdcNull				0
#define hdrvrNull			0
#define hdwpNull			0
#define hfontNull			0
#define hgdiobjNull			0
#define hglobalNull			0
#define hhookNull			0
#define hiconNull			0
#define hinstNull			0
#define hmenuNull			0
#define hmfNull				0
#define hmodNull			0
#define hpalNull			0
#define hpenNull			0
#define hrsrcNull			0
#define htaskNull			0
#define hwndNull			0
#define rgnNull				0
#define prectNull			0

#define plpfnNull			0
#define pdlgprocNull		0
#define phaccellNull		0
#define phbmNull			0
#define phbrNull			0
#define phcursorNull		0
#define phdcNull			0
#define phdrvrNull			0
#define phdwpNull			0
#define phfontNull			0
#define phgdiobjNull		0
#define phglobalNull		0
#define phhookNull			0
#define phiconNull			0
#define phinstNull			0
#define phmenuNull			0
#define phmfNull			0
#define phmodNull			0
#define phpalNull			0
#define phpenNull			0
#define phrsrcNull			0
#define phtaskNull			0
#define phwndNull			0
#define prgnNull			0
#define pprectNull			0
#else
#define dlgprocNull			( (DLGPROC ) NULL )
#define haccellNull			( (HACCEL)   NULL )
#define hbmNull				( (HBITMAP)  NULL )
#define hbrNull				( (HBRUSH)   NULL )
#define hcursorNull			( (HCURSOR)  NULL )
#define hdcNull				( (HDC)      NULL )
#define hdrvrNull			( (HDRVR)    NULL )
#define hdwpNull			( (HDWP)     NULL )
#define hfontNull			( (HFONT)    NULL )
#define hgdiobjNull			( (HGDIOBJ)  NULL )
#define hglobalNull			( (HGLOBAL)  NULL )
#define hhookNull			( (HHOOK)    NULL )
#define hiconNull			( (HICON)    NULL )
#define hinstNull			( (HINSTANCE)NULL )
#define hmenuNull			( (HMENU)    NULL )
#define hmfNull				( (HMETAFILE)NULL )
#define hmodNull			( (HMODULE)  NULL )
#define hpalNull			( (HPALETTE) NULL )
#define hpenNull			( (HPEN)     NULL )
#define hrsrcNull			( (HRSRC)    NULL )
#define htaskNull			( (HTASK)    NULL )
#define hwndNull			( (HWND)     NULL )
#define rgnNull				( (HRGN)     NULL )
#define prectNull			( (PRECT)    NULL )

#define plpfnNull			( (PLPFN)    NULL )
#define pdlgprocNull		( (PDLGPROC) NULL )
#define phaccellNull		( (PHACCEL)  NULL )
#define phbmNull			( (PHBM)     NULL )
#define phbrNull			( (PHBR)     NULL )
#define phcursorNull		( (PHCURSOR) NULL )
#define phdcNull			( (PHDC)     NULL )
#define phdrvrNull			( (PHDRVR)   NULL )
#define phdwpNull			( (PHDWP)    NULL )
#define phfontNull			( (PHFONT)   NULL )
#define phgdiobjNull		( (PHGDIOBJ) NULL )
#define phglobalNull		( (PHGLOBAL) NULL )
#define phhookNull			( (PHHOOK)   NULL )
#define phiconNull			( (PHICON)   NULL )
#define phinstNull			( (PHINST)   NULL )
#define phmenuNull			( (PHMENU)   NULL )
#define phmfNull			( (PHMF)     NULL )
#define phmodNull			( (PHMOD)    NULL )
#define phpalNull			( (PHPAL)    NULL )
#define phpenNull			( (PHPEN)    NULL )
#define phrsrcNull			( (PHRSRC)   NULL )
#define phtaskNull			( (PHTASK)   NULL )
#define phwndNull			( (PHWND)    NULL )
#define prgnNull			( (PHRGN)    NULL )
#define pprectNull			( (PPRECT)   NULL )
#endif  /* __cplusplus */

#endif  /* _INC_WINDOWS */

#define cbSz				( (CB)sizeof( SZ    ) )
#define cbPsz				( (CB)sizeof( PSZ   ) )
#define cbByte				( (CB)sizeof( BYTE  ) )
#define cbPb				( (CB)sizeof( PB    ) )
#define cbBool				( (CB)sizeof( BOOL  ) )
#define cbPbool				( (CB)sizeof( PBOOL ) )
#define cbInt				( (CB)sizeof( INT   ) )
#define cbPint				( (CB)sizeof( PINT  ) )
#define cbLong				( (CB)sizeof( LONG  ) )
#define cbPlong				( (CB)sizeof( PLONG ) )
#define cbCb				( (CB)sizeof( CB    ) )
#define cbPcb				( (CB)sizeof( PCB   ) )
#define cbPv				( (CB)sizeof( PV    ) )

/*
 *	Useful self commenting constructs
 */
#define Unused(x)			(void)(x=x)

typedef enum _OFI			/* Okay/Fail/Ignore enum */
	{
	ofiOkay,
	ofiFail,
	ofiIgnore
	}  OFI;
typedef OFI *  POFI;  /* Ptr to Okay/Fail/Ignore enum */

#define cbMaxDriveSize	(999999L * 1024L)

#endif  /* STDTYPES_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\setup\user\user.c ===
#include <windows.h>
/*

   Stub for user.exe on Win64.

   Quicktime 4.0 install program requires a "user.exe" to install properly.

   It appears that all user.exe requires is a vlid "PE" or "NE" header and
   standard, localizable version resources.

   Quicktime assumes that user.exe is commnon to all MS OS platforms since
   it shipped on Win3.x  NT3.x, NT4x, Windows 9x, Win2K, and WinXP.  The only
   problem is tha user.exe has always been a 16-bit binary.


   See bugs #491368 and #653284.
   
*/

int __cdecl main(argc, argv)
{
     return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\setup\inc\stdassrt.h ===
/****************************************************************************
**
**	File:			STDASSRT.H
**	Purpose:		Standard Assert macros and common error handling defines.
**	Notes:
**
****************************************************************************/

#ifndef STDASSRT_H
#define STDASSRT_H

#ifdef __cplusplus
extern "C" {            /* Assume C declarations for C++ */
#endif

/* REVIEW: need to make this DEBUG only when RTChkArg is removed */
#define EnableAssertCode  static char THIS_FILE[] = __FILE__;


/*  Common Error Validation and Handling */

typedef enum {
	vrcFail  = 0,  /* if IDOK or IDIGNORE or IDNO or no message box */
	vrcValid = 1,  /* if no error condition */
	vrcRetry = 2,  /* if IDRETRY or IDYES */
	vrcQuit  = 3,  /* if IDABORT or IDCANCEL */
	vrcYes   = vrcRetry,
	vrcNo    = vrcFail,
	vrcIgnore= vrcFail,
	vrcCancel= vrcQuit,
	vrcAbort = vrcQuit,
	vrcOk    = vrcFail
} VRC;

#define ERROR_PARAM_MAX 4   /* parameters %1, %2, %3, %4 */

/* sets an error parameter from a temp string value, good until Validate() */
VOID PUBLIC SetErrorParam ( UINT iParam, SZC szValue );

/* sets an error parameter from a stable string value, can Validate() later */
VOID PUBLIC SetErrorParamConst ( UINT iParam, CSZC szValue );

/* sets an error message parameter from a string value, make a string copy */
VOID PUBLIC SetErrorParamCopy  ( UINT iParam, SZC  szValue );

/* sets an error message parameter from an integer value */
VOID PUBLIC SetErrorParamInt   ( UINT iParam, INT   iValue );

/* sets an error message parameter from an character value */
VOID PUBLIC SetErrorParamChar  ( UINT iParam, CHAR chValue );

/* tests a condition, handles error and clears error parameters if false */
VRC  PUBLIC Validate ( BOOL fCondition, UINT iStringId );

/* loads a string resource or debug string, calls ProcessMessage() */
VRC  PUBLIC ProcessMessageId ( UINT iStringId );

/* formats message template, optionally displays message box, write to log */
VRC  PUBLIC ProcessMessage ( SZC szMsg );

/* loads a debug or resource message and writes to the logfile if open */
VRC  PUBLIC LogMessageId ( UINT iResId );  /* return status of log write */

/* loads a message, sets status for %V & %v, writes to the logfile if open */
VRC  PUBLIC LogValidate ( BOOL fCondition, UINT iResId );/* return log status */

/* prototype for callback to obtain object or pass-specific information */
/* returns the number of characters copied to the buffer, or 0 if no info */
typedef INT (WINAPI *PFNErrorParam)( INT chParam, SZ rgchBuf );

/* entry for ACME only, to setup pass calback for error parameters */
VOID PUBLIC SetPassInfo(SZC szPassName, PFNErrorParam pfnCallback);

/* internal entry to process debug messages, called using DebugMessage(sz) */
VRC  PUBLIC ProcessDebugMessage ( SZC szMsg );

/* Sets and gets global last-error message */
VOID PUBLIC SetLastSetupErrMsg ( SZ szMsg );
SZ   PUBLIC SzGetLastSetupErrMsg ( VOID );

/* entry for ACME only, to setup pass calback for FED Font change - DBCS only*/
typedef BOOL (WINAPI *PFNFEFont)( HWND hdlg );

VOID PUBLIC SetFEFontProc(PFNFEFont pfnCallback);

/* Bit flag, combined with message IDS values to specify messages that
*	should be stored into the LastSetupErrMsg buffer in ProcessMessageId.
*	Also macros to test, clear and set the bit flag.
*
*	NOTE: 1 << 8 through 8 << 16 are reserved for ProcessMessageId
*	internal use.  (See setupdll\_assert.h)
*/
#define midErrMsg			(16 << 16)
#define	FIsErrMsg(id)		(id & midErrMsg)
#define IdClearErrMsg(id)	(id & (~midErrMsg))
#define IdErrMsg(id)		(id | midErrMsg)


#ifdef DEBUG
# define DebugErrorParam(p,v)	   SetErrorParam(p,v)
# define DebugErrorParamCopy(p,v)  SetErrorParamCopy(p,v)
# define DebugErrorParamConst(p,v) SetErrorParamConst(p,v)
# define DebugErrorParamInt(p,v)   SetErrorParamInt(p,v)
# define DebugErrorParamChar(p,v)  SetErrorParamChar(p,v)
# define DebugMessageId(i)         ProcessMessageId(i)
# define DebugMessage(s)           ProcessDebugMessage(s)
# define DebugLogMessageId(i)      LogMessageId(i)
#else
# define DebugErrorParam(p,v)
# define DebugErrorParamCopy(p,v)
# define DebugErrorParamConst(p,v)
# define DebugErrorParamInt(p,v)
# define DebugErrorParamChar(p,v)
# define DebugMessageId(i)
# define DebugMessage(s)
# define DebugLogMessageId(i)
#endif

#ifdef DEBUG
BOOL PUBLIC ResponseFile ( SZ szFile );
#endif

/* Must call as the first call (with hinstAcme) AND as the last
*	call (with hinstNull).
*/
BOOL PUBLIC SetAcmeInst(HINSTANCE hInst, LPSTR szCmdLine);

/*  RunTime Argument Checking  */
/*  REVIEW: this should be removed, all uses replaced by calls to Validate */
#define RTChkArg(f, retVal) \
	{ if (!(f)) { FailRTChkArg(THIS_FILE, __LINE__); return (retVal); } }

VRC  PUBLIC FailRTChkArg ( SZC szFile, UINT uiLine );

/*	Assert macros */

VOID PUBLIC FailAssert (SZC szFile, UINT uiLine );  /* also PreCond, BadParam */

#ifdef DEBUG

#define FailAssertObj(f, l, i) FailAssert(f, (UINT)(l + ((i)<<16)))
#define FailChkArg(f, l, i)    FailAssert(f, (UINT)(l + (1<<31) + ((i)<<16)))
#define FailPreCond(f, l)      FailAssert(f, (UINT)(l + (1<<31)))

#define Assert(f)      ((f) ? (VOID)0 : (VOID)FailAssert(THIS_FILE, __LINE__))
#define EvalAssert(f)  ((f) ? (VOID)0 : (VOID)FailAssert(THIS_FILE, __LINE__))

#define AssertRet(f, retVal) \
		{if (!(f)) {FailAssert( THIS_FILE, __LINE__); return (retVal);} }
#define EvalAssertRet(f, retVal) \
		{if (!(f)) {FailAssert( THIS_FILE, __LINE__); return (retVal);} }

#define PreCondition(f, retVal)	\
		{if (!(f)) {FailPreCond(THIS_FILE, __LINE__); return (retVal);} }
#define ChkArg(f, iArg, retVal)	\
		{if (!(f)) {FailChkArg(THIS_FILE, __LINE__, iArg); return (retVal);} }

#else

#define Assert(f)
#define EvalAssert(f)				((VOID)(f))
#define AssertRet(    f, retVal)
#define EvalAssertRet(f, retVal)	((VOID)(f))
#define PreCondition( f, retVal)	RTChkArg(f, retVal)
#define ChkArg( f, iArg, retVal)

#endif


/* REVIEW: These are obsolete, remove when files using them are updated */

#ifdef DEBUG
#define DisplayAssertMsg()    Assert(fFalse);
#define DebugLine(expr)       expr;
#define DisplayErrorMsg(sz)   ((VOID)FDisplaySystemMsg(sz))
#else
#define DisplayAssertMsg() /* in objodbc.cpp, copylist.c */
#define DebugLine(expr)    /* once in copylist.c */
#define DisplayErrorMsg(sz)
#endif
extern BOOL WINAPI FDisplaySystemMsg     ( SZ szErr );

#ifdef DEVELOPER
#define BadArgErr(nArg, szApi, szArgs) SetupApiErr(nArg+saeMax, szApi, szArgs)
#else
#define BadArgErr(nArg, szApi, szArgs)
#endif

/* REVIEW: end of obsolete */

#ifdef __cplusplus
}                       /* End of extern "C" { */
#endif

#endif  /* STDASSRT_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\tests\apc\apc.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

VOID TimerCallback(PVOID pv, BOOLEAN b)
{
    DbgPrint("TimerCallback called!\n");
}

int main(int argc, char *argv[])
{
    NTSTATUS st;
    HANDLE Q;
    HANDLE T;
    LARGE_INTEGER li;

    DbgPrint("Creating timer queue...\n");
    RtlCreateTimerQueue(&Q);

    DbgPrint("In main... setting a timer...\n");

    st = RtlSetTimer(Q,
                     &T,
                     TimerCallback,
                     NULL,
                     500,
                     500,
                     0);


    DbgPrint("In main... sleeping...\n");
    li.QuadPart = -500*20*5000;
    NtDelayExecution(FALSE, &li);

    DbgPrint("In main... cancelling timer...\n");
    RtlCancelTimer(Q, T);

    DbgPrint("In main... deleting timer...\n");
    RtlDeleteTimerQueue(Q);


    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\tests\crash\crash.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

long handler(PEXCEPTION_POINTERS p, BOOLEAN bThrow, BOOLEAN bContinueExecution)
{
    DbgPrint("In handler... record %x, context %x\n", p->ExceptionRecord, p->ContextRecord);  
    
    if(bThrow) {
       DbgPrint("In handler... throwing an exception...\n");
       try {
          RtlRaiseStatus(STATUS_INVALID_PARAMETER);
       }
       except(handler(GetExceptionInformation(), FALSE, FALSE)) {
          DbgPrint("In handler... executed handler\n");
       }
    }
  
    if (bContinueExecution) {
        DbgPrint("In handler... returning EXCEPTION_CONTINUE_EXECUTION...\n");
        return EXCEPTION_CONTINUE_EXECUTION;
    }

    DbgPrint("In handler... returning EXCEPTION_EXECUTE_HANDLER...\n");
    return EXCEPTION_EXECUTE_HANDLER;
}

int main(int argc, char *argv[])
{
    int *p;

    p = NULL;

    DbgPrint("In main... throwing an exception...\n");
    try {
         *p = 1;
    } except (handler(GetExceptionInformation(), FALSE, FALSE)) {
        DbgPrint("In main... executed handler\n");
    }
    DbgPrint("In main... back from exception...\n");

    DbgPrint("In main... throwing an exception with RtlRaiseStatus...\n");
    try {
         RtlRaiseStatus(STATUS_INVALID_PARAMETER);
    } except (handler(GetExceptionInformation(), FALSE, FALSE)) {
        DbgPrint("In main... executed handler\n");
    }
    DbgPrint("In main... back from exception...\n");
    
    DbgPrint("In main... throwing an exception with an exception in exception handler...\n");
    try {
         RtlRaiseStatus(STATUS_INVALID_PARAMETER);
    } except (handler(GetExceptionInformation(), TRUE, FALSE)) {
        DbgPrint("In main... executed handler\n");
    }
    DbgPrint("In main... back from exception...\n");

    DbgPrint("In main... trowing an exception structure that is continueable...\n");
    try {
         EXCEPTION_RECORD Record;
         RtlZeroMemory(&Record, sizeof(EXCEPTION_RECORD));
         Record.ExceptionCode = STATUS_INVALID_PARAMETER;
         Record.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
         Record.NumberParameters = 0;
         Record.ExceptionFlags = 0;
         RtlRaiseException(&Record);
         
         DbgPrint("In main... Execution was continued!\n");

    } except (handler(GetExceptionInformation(), FALSE, TRUE)) {
        DbgPrint("In main... executed handler\n");
    }
    DbgPrint("In main... back from exception...\n");

    return 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\tests\bvt\wow64bvt.c ===
// define COBJMACROS so the IUnknown_Release() gets defined
#define COBJMACROS

// disable ddraw COM declarations.  Otherwise ddrawint.h defineds _NO_COM
// and includes ddraw.h.  That causes ddraw.h to define IUnknown as 'void *'
// which obliterates the struct IUnknown in objbase.h.  This all happens
// inside winddi.h
#define _NO_DDRAWINT_NO_COM

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <time.h>
#include <objbase.h>    
#include <mshtml.h> 
#include <winddi.h>
#include <io.h>

#define PAGE_4K   0x1000

// Assume an error happened.  This variable controls whether a pass or fail
// is logged in the test results.
SYSTEM_INFO SysInfo;
BOOL g_bError = TRUE;

// Time the test started (only valid in the main process)
time_t TestStartTime;

FILE *fpLogFile;

void __cdecl PrintToLog(char *format, ...)
{
    va_list pArg;
    char buffer[4096];

    va_start(pArg, format);
    _vsnprintf(buffer, sizeof(buffer), format, pArg);
    buffer[sizeof(buffer)-1] = '\0';
    printf("%s", buffer);
    if (fpLogFile) {
        fprintf(fpLogFile, "%s", buffer);
    }
}

////////////  All this code runs in a worker thread in a child process //////
//// Prefix any output by "WOW64BVT1" so it can be identified as coming from
//// the child process.

// This routine is invoked when "childprocess" is passed on the command-line.
// The child runs synchronously with the parent to maximize the test coverage.
int BeAChildProcess(void)
{
    HRESULT hr;
    IUnknown *pUnk;
    CLSID clsid;
    HWND hwnd;

    PrintToLog("WOW64BVT1: Child process running\n");

    // Do some COM stuff here
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED|COINIT_DISABLE_OLE1DDE);
    if (FAILED(hr)) {
        PrintToLog("ERROR: WOW64BVT1: CoInitializeEx failed %x\n", hr);
        return 3;
    }

    // Load and call 32-bit mshtml inproc
    hr = CLSIDFromProgID(L"Shell.Explorer", &clsid);
    if (FAILED(hr)) {
        PrintToLog("ERROR: WOW64BVT1: CLSIDFromProgID for Shell.Explorer failed %x\n", hr);
        return 3;
    }
#if 0   // The cocreate fails on IA64 with 8007000e (E_OUTOFMEMORY)
    hr = CoCreateInstance(&clsid, NULL, CLSCTX_INPROC_SERVER, &IID_IUnknown, (PVOID *)&pUnk);
    if (FAILED(hr)) {
        PrintToLog("ERROR: WOW64BVT1: CoCreateInstance for Shell.Explorer failed %x\n", hr);
        return 3;
    }
    Sleep(1000);
    IUnknown_Release(pUnk);
    pUnk = NULL;
#endif

    // Load and call mplay32.exe out-of-proc
#if 0 // The clsidfromprogid fails on IA64 with 800401f3 (CO_E_CLASSSTRING)
    hr = CLSIDFromProgID(L"MediaPlayer.MediaPlayer.1", &clsid);
    if (FAILED(hr)) {
        PrintToLog("ERROR: WOW64BVT1: CLSIDFromProgID for MediaPlayer.MediaPlayer failed %x\n", hr);
        return 3;
    }
    hr = CoCreateInstance(&clsid, NULL, CLSCTX_LOCAL_SERVER, &IID_IUnknown, (PVOID *)&pUnk);
    if (FAILED(hr)) {
        PrintToLog("ERROR: WOW64BVT1: CoCreateInstance for MediaPlayer.MediaPlayer failed %x\n", hr);
        return 3;
    }
    Sleep(5000);
    IUnknown_Release(pUnk);
    pUnk = NULL;
#endif

    // Unfortunately, mplay32 has a refcounting problem and doesn't close
    // when we release it.  Post a quit message to make it close.
    hwnd = FindWindowW(NULL, L"Windows Media Player");
    if (hwnd) {
        PostMessage(hwnd, WM_QUIT, 0, 0);
    }

    // Wrap up COM now
    CoUninitialize();

    PrintToLog("WOW64BVT1: Child process done OK.\n");
    return 0;
}

////////////  All this code runs in a worker thread in the main process //////
//// Prefix any output by "WOW64BVT" so it can be identified as coming from
//// the parent process.

DWORD BeAThread(LPVOID lpParam)
{
    NTSTATUS st;
    LPWSTR lp;

    PrintToLog("WOW64BVT: Worker thread running\n");

    // Call an API close to the end of whnt32.c's dispatch table
    st = NtYieldExecution();
    if (FAILED(st)) {
        PrintToLog("ERROR: WOW64BVT: NtYieldExecution failed %x\n", st);
        exit(1);
    }

    // Call an API close to the end of whwin32.c's dispatch table.  Pass NULL,
    // so it is expected to fail.
    lp = EngGetPrinterDataFileName(NULL);    // calls NtGdiGetDhpdev()
    if (lp) {
        // It succeeded.... it shouldn't have since 
        PrintToLog("ERROR: WOW64BVT: EngGetPrinterDataFileName succeeeded when it should not have.\n");
        exit(1);
    }

    PrintToLog("WOW64BVT: Worker thread done OK.\n");
    return 0;
}

HANDLE CreateTheThread(void)
{
    HANDLE h;
    DWORD dwThreadId;

    PrintToLog("WOW64BVT: Creating child thread\n");
    h = CreateThread(NULL, 0, BeAThread, NULL, 0, &dwThreadId);
    if (h == INVALID_HANDLE_VALUE) {
        PrintToLog("ERROR: WOW64BVT: Error %d creating worker thread.\n", GetLastError());
        exit(2);
    }
    // Sleep a bit here, to try and let the child thread run a bit
    Sleep(10);
    return h;
}

BOOL AllocateStackAndTouch(
    INT Count)
{
    char temp[4096];

    memset(temp, 0, sizeof(temp));

    if (--Count) {
        AllocateStackAndTouch(Count);
    }

    return TRUE;
}

DWORD WINAPI TestGuardPagesThreadProc(
    PVOID lpParam)
{
    
    try {
        AllocateStackAndTouch(PtrToUlong(lpParam));
    } except(EXCEPTION_EXECUTE_HANDLER) {
        PrintToLog("ERROR: WOW64BVT: Error allocating stack. Exception Code = %lx\n",
               GetExceptionCode());
        exit(1);
    }

    return 0;
}

int TestGuardPages(
    VOID)
{
    HANDLE h;
    DWORD dwExitCode, dwThreadId;
    BOOL b;
    ULONG NestedStackCount = 100;
    DWORD StackSize = 4096;
    
    
    PrintToLog("WOW64BVT: Creating worker threads to test guard pages\n");

    while (StackSize < (32768+1))
    {
        h = CreateThread(NULL, 
                         StackSize, 
                         TestGuardPagesThreadProc, 
                         UlongToPtr(NestedStackCount), 
                         0, 
                         &dwThreadId);
        if (h == INVALID_HANDLE_VALUE) {
            PrintToLog("ERROR: WOW64BVT:  Error %d creating worker thread for guard page tests.\n", GetLastError());
            exit(2);
        }
        StackSize += 4096;
        WaitForSingleObject(h, INFINITE);

        b = GetExitCodeThread(h, &dwExitCode);
        if (b) {
             if (dwExitCode) {
                 return (int)dwExitCode;
             }
        } else {
            PrintToLog("ERROR: GetExitCodeThread failed with LastError = %d\n", GetLastError());
            return 1;
        }
    }

    PrintToLog("WOW64BVT: Test guard pages done OK.\n");

    return 0;
}


int TestMemoryMappedFiles(
    VOID)
{
    HANDLE Handle;
    PWCHAR pwc;
    MEMORY_BASIC_INFORMATION mbi;
    BOOL ExceptionHappened = FALSE;
  
    
    PrintToLog("WOW64BVT: Testing memory mapped files\n");

    Handle = CreateFileMappingW(INVALID_HANDLE_VALUE,
                                NULL,
                                SEC_RESERVE | PAGE_READWRITE,
                                0,
                                32 * 1024,
                                L"HelloWorld");

    if (Handle == INVALID_HANDLE_VALUE) {
        PrintToLog("ERROR: WOW64BVT : Error %d creating file mapping\n", GetLastError());
        return 1;
    }

    pwc = (PWCHAR)MapViewOfFile(Handle,
                                FILE_MAP_WRITE,
                                0,
                                0,
                                0);

    if (!pwc) {
        PrintToLog("ERROR: WOW64BVT : Error %d mapping section object\n", GetLastError());
        return 1;
    }

    if (!VirtualQuery(pwc,
                      &mbi,
                      sizeof(mbi))) {
        PrintToLog("ERROR: WOW64BVT : Virtual query failed with last error = %d\n", GetLastError());
        return 1;
    }

    if (mbi.State != MEM_RESERVE) {
        PrintToLog("ERROR: WOW64BVT : Memory attributes have changed since mapped %lx\n", mbi.State);
        return 1;
    }

    try {
        *pwc = *(pwc+1);
    } except(EXCEPTION_EXECUTE_HANDLER) {
        ExceptionHappened = TRUE;
    }

    if (ExceptionHappened == FALSE) {
        PrintToLog("ERROR: WOW64BVT : Memory has been committed while it should have ONLY been reserved.\n");
        return 1;
    }

    if (!VirtualQuery(pwc,
                      &mbi,
                      sizeof(mbi))) {
        PrintToLog("ERROR: WOW64BVT : Virtual query failed with last error = %d\n", GetLastError());
        return 1;
    }

    if (mbi.State != MEM_RESERVE) {
        PrintToLog("ERROR: WOW64BVT : Memory attributes have changed since mapped %lx\n", mbi.State);
        return 1;
    }

    UnmapViewOfFile(pwc);
    CloseHandle(Handle);

    PrintToLog("WOW64BVT: Testing memory mapped files done OK.\n");

    return 0;
}

BOOL ReleasePages(PVOID Address, 
                  DWORD DeAllocationType, 
                  SIZE_T ReleasedPages)
{

    PVOID p = Address;
    SIZE_T nPages = ReleasedPages;
    NTSTATUS NtStatus;

    NtStatus = NtFreeVirtualMemory(NtCurrentProcess(),
                                   &p,
                                   &nPages,
                                   DeAllocationType);

    return NT_SUCCESS(NtStatus);
}

BOOL VerifyPages(PVOID Address,
                 DWORD DeAllocationType,
                 SIZE_T ReleasedPages)
{
    DWORD PagesState;
    BOOL b;
    MEMORY_BASIC_INFORMATION mbi;

    if (DeAllocationType == MEM_DECOMMIT)
    {
        PagesState = MEM_RESERVE;
    }
    else if (DeAllocationType == MEM_RELEASE)
    {
        PagesState = MEM_FREE;
    }
    else
    {
        PagesState = DeAllocationType;
    }


    b = VirtualQuery(Address,
                     &mbi,
                     sizeof(mbi));

    if (b)
    {
        if (mbi.State != PagesState)
        {
            PrintToLog("ERROR: WOW64BVT: Incorrect page protection set at address %p. State = %lx - %lx, RegionSize = %lx - %lx\n",
                        Address, mbi.State, PagesState, mbi.RegionSize, ReleasedPages);
            b = FALSE;
        }
    }
    else
    {
        PrintToLog("ERROR: WOW64BVT: Failed to query virtual memory at address %p - %lx\n",
                    Address, GetLastError());
    }

    return b;
}


BOOL ReleaseVerifyPages(PVOID BaseAllocation,
                       PVOID *Address,
                       SIZE_T *AllocationSize,
                       DWORD AllocationType,
                       DWORD DeAllocationType,
                       DWORD ReleasedPages)
{
    BOOL b;

    if (ReleasedPages > *AllocationSize)
    {
        ReleasedPages = *AllocationSize;
    }
    
    b = ReleasePages(*Address, DeAllocationType, ReleasedPages);
    if (b == FALSE)
    {
        PrintToLog("ERROR: WOW64BVT: Failed to release a page - %lx\n", GetLastError());
        return b;
    }
    
    b = VerifyPages(*Address, 
                    DeAllocationType, 
                    ReleasedPages);

    *AllocationSize -= ReleasedPages;
    *Address  = (PVOID)((ULONG_PTR)*Address + ReleasedPages);

    if (b == FALSE)
    {
        PrintToLog("ERROR: WOW64BVT: Failed to verify pages at address %lx - %lx\n",
                    ((ULONG_PTR)Address + ReleasedPages), GetLastError());
    }

    return b;
}


BOOL TestVadSplitOnFreeHelper(DWORD AllocationType, 
                              DWORD DeAllocationType,
                              SIZE_T TotalAllocation)
{
    BOOL b;
    PVOID Address;
    PVOID BaseAllocation;
    SIZE_T BaseAllocationSize;
    INT n;

    Address = VirtualAlloc(NULL,
                           TotalAllocation,
                           AllocationType,
                           PAGE_READWRITE);

    if (Address == NULL)
    {
        PrintToLog("ERROR: WOW64BVT: Failed to allocate memory - %lx\n", GetLastError());
    }

    n = 1;
    BaseAllocation = Address;
    BaseAllocationSize = TotalAllocation;
    while (TotalAllocation != 0)
    {
        b = ReleaseVerifyPages(BaseAllocation,
                               &Address,
                               &TotalAllocation,
                               AllocationType,
                               DeAllocationType,
                               PAGE_4K * n);

        if (b == FALSE)
        {
            PrintToLog("ERROR: WOW64BVT: ReleaseVerifyPages failed - %lx. %lx-%lx-%lx", 
                        GetLastError(), BaseAllocation, Address, TotalAllocation);
            break;
        }
        b = VerifyPages(BaseAllocation,
                        DeAllocationType,
                        n * PAGE_4K);

        if (b == FALSE)
        {
            PrintToLog("ERROR: WOW64BVT: Verify released pages from address %p with length = %lx failed\n", BaseAllocation, (n * PAGE_4K));
            break;
        }

        if (TotalAllocation > 0)
        {
            b = VerifyPages(Address,
                            AllocationType,
                            TotalAllocation);

            if (b == FALSE)
            {
                PrintToLog("ERROR: WOW64BVT: Verify pages from address %p with length = %lx failed\n", BaseAllocation, TotalAllocation);
                break;
            }
        }

        n += 2;
    }

    return b;
}


int TestVadSplitOnFree()
{
    BOOL b;
    SIZE_T AllocationSize = (PAGE_4K * 10);


    PrintToLog("WOW64BVT: Testing VAD splitting...\n");

    b = TestVadSplitOnFreeHelper(MEM_COMMIT,
                                 MEM_DECOMMIT,
                                 AllocationSize);

    if (b)
    {
        b = TestVadSplitOnFreeHelper(MEM_COMMIT,
                                     MEM_RELEASE,
                                     AllocationSize);
    }

    if (b)
    {
        b = TestVadSplitOnFreeHelper(MEM_RESERVE,
                                     MEM_RELEASE,
                                     AllocationSize);
    }

    if (b != FALSE)
    {
        PrintToLog("WOW64BVT: Testing VAD splitting...OK\n");
    }
    else
    {
        PrintToLog("ERROR: WOW64BVT: Testing VAD splitting\n");
    }

    return (b == FALSE);
}


PVOID GetReadOnlyBuffer()
{
    PVOID pReadOnlyBuffer = NULL;

    if (!pReadOnlyBuffer)
    {
        SYSTEM_INFO SystemInfo;

        // Get system info so that we know the page size
        GetSystemInfo(&SystemInfo);

        // Allocate a whole page.  This is optimal.
        pReadOnlyBuffer = VirtualAlloc(NULL, SystemInfo.dwPageSize, MEM_COMMIT, PAGE_READWRITE);
        if (pReadOnlyBuffer)
        {
            // Fill it with know patern
            FillMemory(pReadOnlyBuffer, SystemInfo.dwPageSize, 0xA5);
            
            // Mark the page readonly
            pReadOnlyBuffer = VirtualAlloc(pReadOnlyBuffer, SystemInfo.dwPageSize, MEM_COMMIT, PAGE_READONLY);
        }
    }

    return pReadOnlyBuffer;
}

PVOID GetReadOnlyBuffer2()
{
    PVOID pReadOnlyBuffer = NULL;

    DWORD OldP;
    SYSTEM_INFO SystemInfo;

    // Get system info so that we know the page size
    GetSystemInfo(&SystemInfo);

    // Allocate a whole page.  This is optimal.
    pReadOnlyBuffer = VirtualAlloc(NULL, SystemInfo.dwPageSize, MEM_COMMIT, PAGE_READWRITE);

    if (pReadOnlyBuffer)
    {
        FillMemory(pReadOnlyBuffer, SystemInfo.dwPageSize, 0xA5);
        lstrcpy((PTSTR)pReadOnlyBuffer, TEXT("xxxxxxxxxxxxxxxxxxxx"));

        if (!VirtualProtect(pReadOnlyBuffer, SystemInfo.dwPageSize, PAGE_READONLY, &OldP))
        {
            PrintToLog("ERROR: WOW64BVT: VirtualProtect() failed inside GetReadOnlyBuffer2()\n");
            VirtualFree(pReadOnlyBuffer, 0, MEM_RELEASE);

            pReadOnlyBuffer = NULL;
        }

    }

    return pReadOnlyBuffer;

}

BOOL TestMmPageProtection()
{
    PTSTR String;
    BOOL AV = FALSE;


    PrintToLog("WOW64BVT: Testing MM Page Protection...\n");

    String = (PTSTR) GetReadOnlyBuffer();
    if (!String) {
        PrintToLog("ERROR: WOW64BVT: GetReadOnlyBuffer() failed\n");
        return TRUE;
    }

    try {
        *String = TEXT('S');
    } except(EXCEPTION_EXECUTE_HANDLER) {
        AV = TRUE;
    }

    VirtualFree(String, 0, MEM_RELEASE);

    if (AV == TRUE) {
        
        AV = FALSE;
        String = (PTSTR) GetReadOnlyBuffer2();

        if (!String) {
            PrintToLog("ERROR: WOW64BVT: GetReadOnlyBuffer2() failed\n");
            return TRUE;
        }

        try {
            *String = TEXT('A');
        } except(EXCEPTION_EXECUTE_HANDLER) {
            AV = TRUE;
        }

        VirtualFree(String, 0, MEM_RELEASE);
    } else {
        PrintToLog("ERROR: WOW64BVT: GetReadOnlyBuffer() failed to make 4K pages read only\n");
    }


    if (AV == TRUE) {
        PrintToLog("WOW64BVT: Testing MM Page Protection...OK\n");
    } else {
        PrintToLog("ERROR: WOW64BVT: Testing MM Page Protection\n");
    }

    return (AV == FALSE);
}

#define STACK_BUFFER  0x300
BOOL TestX86MisalignedLock()
{
    BOOL bError = FALSE;

    PrintToLog("WOW64BVT: Testing X86 Lock on misaligned addresses...\n");
    
    __try
    {
        __asm
        {
        pushad;
        pushfd;

        sub esp, STACK_BUFFER;

        ;;
        ;; make eax  unaliged with respect to an 8-byte cache line
        ;;

        mov eax, esp;
        add eax, 10h;
        mov ecx, 0xfffffff0;
        and eax, ecx;
        add eax, 7;
        mov ebx, eax;

        ;;
        ;; add
        ;;

        mov DWORD PTR [eax], 0x0300;
        lock add WORD PTR [eax], 0x0004;
        cmp DWORD PTR [eax], 0x0304;
        jnz $endwitherrornow;


        mov DWORD PTR [eax], 0x0300;
        lock add DWORD PTR [eax], 0x10000;
        cmp DWORD PTR [eax], 0x10300;
        jnz $endwitherrornow;

        mov ecx, DWORD PTR [eax+8];
        add ecx, 0x10;
        lock add DWORD PTR [eax+8], 0x10;
        cmp DWORD PTR [eax+8], ecx;
        jnz $endwitherrornow;
        
        mov ecx, DWORD PTR fs:[5];
        mov esi, 0x30000;
        lock add DWORD PTR fs:[5], esi;
        add esi, ecx;
        cmp DWORD PTR fs:[5], esi;
        mov DWORD PTR fs:[5], ecx;
        jnz $endwitherrornow;

        mov edi, 5;
        mov ecx, DWORD PTR fs:[edi];
        mov esi, 0x30000;
        lock add DWORD PTR fs:[edi], esi;
        add esi, ecx;
        cmp DWORD PTR fs:[edi], esi;
        mov DWORD PTR fs:[edi], ecx;
        jnz $endwitherrornow;

        mov esi, 0x40;
        mov WORD PTR [eax], 0x3000;
        lock add WORD PTR [eax], si;
        cmp WORD PTR [eax], 0x3040;
        jnz $endwitherrornow;

        mov edi, 0x40;
        mov DWORD PTR [eax], 0x3000;
        lock add DWORD PTR [eax], edi;
        cmp DWORD PTR [eax], 0x3040;
        jnz $endwitherrornow;

        ;;
        ;; adc
        ;;

        pushfd;
        pop ecx;
        or ecx, 1;
        push ecx;
        popfd;
        mov DWORD PTR [eax], 0x030000;
        lock adc DWORD PTR [eax], 0x40000;
        cmp DWORD PTR [eax], 0x70001;
        jnz $endwitherrornow;

        pushfd;
        pop ecx;
        and ecx, 0xfffffffe;
        push ecx;
        popfd;
        mov dx, 0x4000;
        mov WORD PTR [eax], 0x03000;
        lock adc WORD PTR [eax], dx;
        cmp WORD PTR [eax], 0x7000;
        jnz $endwitherrornow;

        pushfd;
        pop ecx;
        or ecx, 0x01;
        push ecx;
        popfd;
        mov WORD PTR [eax], 0x03000;
        lock adc WORD PTR [eax], 0x04000;
        cmp WORD PTR [eax], 0x7001;
        jnz $endwitherrornow;        


        ;;
        ;; and
        ;;

        mov DWORD PTR [eax], 0xffffffff;
        lock and DWORD PTR [eax], 0xffff;
        cmp DWORD PTR [eax], 0xffff;
        jnz $endwitherrornow;

        mov DWORD PTR [eax], 0xffffffff;
        lock and DWORD PTR [eax], 0xff00ff00;
        cmp DWORD PTR [eax], 0xff00ff00;
        jnz $endwitherrornow;

        mov DWORD PTR [eax], 0xffffffff;
        mov esi, 0x00ff00ff
        lock and DWORD PTR [eax], esi;
        cmp DWORD PTR [eax], esi;
        jnz $endwitherrornow;

        mov ecx, 4;
        mov DWORD PTR [eax+ecx*2], 0xffffffff;
        mov esi, 0xffff00ff
        lock and DWORD PTR [eax+ecx*2], esi;
        cmp DWORD PTR [eax+ecx*2], 0xffff00ff;
        jnz $endwitherrornow;

        mov WORD PTR [eax], 0xffff;
        mov si, 0xff
        lock and WORD PTR [eax], si;
        cmp WORD PTR [eax], si;
        jnz $endwitherrornow;

        mov edi, DWORD PTR fs:[5];
        mov DWORD PTR fs:[5], 0xffffffff;
        mov ebx, 5;
        lock and DWORD PTR fs:[ebx], 0xff00ff00;
        cmp DWORD PTR fs:[ebx], 0xff00ff00;
        mov DWORD PTR fs:[ebx], edi;
        jnz $endwitherrornow;

        ;;
        ;; or
        ;;

        mov DWORD PTR [eax], 0x00;
        lock or DWORD PTR [eax], 0xffff;
        cmp DWORD PTR [eax], 0xffff;
        jnz $endwitherrornow;

        mov DWORD PTR [eax], 0xff00ff00;
        lock or DWORD PTR [eax], 0xff00ff;
        cmp DWORD PTR [eax], 0xffffffff;
        jnz $endwitherrornow;

        mov DWORD PTR [eax], 0xff000000;
        mov esi, 0x00ff00ff
        lock or DWORD PTR [eax], esi;
        cmp DWORD PTR [eax], 0xffff00ff;
        jnz $endwitherrornow;

        mov ecx, 4;
        mov DWORD PTR [eax+ecx*2], 0xff000000;
        mov esi, 0x00ff00ff
        lock or DWORD PTR [eax+ecx*2], esi;
        cmp DWORD PTR [eax+ecx*2], 0xffff00ff;
        jnz $endwitherrornow;

        mov WORD PTR [eax], 0xf000;
        mov si, 0xff
        lock or WORD PTR [eax], si;
        cmp WORD PTR [eax], 0xf0ff;
        jnz $endwitherrornow;

        mov edi, DWORD PTR fs:[5];
        mov DWORD PTR fs:[5], 0x00;
        mov ebx, 5;
        lock or DWORD PTR fs:[ebx], 0xff00ff00;
        cmp DWORD PTR fs:[ebx], 0xff00ff00;
        mov DWORD PTR fs:[ebx], edi;
        jnz $endwitherrornow;

        ;;
        ;; xor
        ;;

        mov DWORD PTR [eax], 0x00ffffff;
        lock xor DWORD PTR [eax], 0xffff;
        cmp DWORD PTR [eax], 0x00ff0000;
        jnz $endwitherrornow;

        mov DWORD PTR [eax], 0xff00ff00;
        lock xor DWORD PTR [eax], 0xff00ff;
        cmp DWORD PTR [eax], 0xffffffff;
        jnz $endwitherrornow;

        mov DWORD PTR [eax], 0xff0000ff;
        mov esi, 0x00ff00ff
        lock xor DWORD PTR [eax], esi;
        cmp DWORD PTR [eax], 0xffff0000;
        jnz $endwitherrornow;

        mov ecx, 4;
        mov DWORD PTR [eax+ecx*2], 0xff000000;
        mov esi, 0xffff00ff
        lock xor DWORD PTR [eax+ecx*2], esi;
        cmp DWORD PTR [eax+ecx*2], 0x00ff00ff;
        jnz $endwitherrornow;

        mov WORD PTR [eax], 0xf000;
        mov si, 0xf0ff
        lock xor WORD PTR [eax], si;
        cmp WORD PTR [eax], 0x00ff;
        jnz $endwitherrornow;

        mov edi, DWORD PTR fs:[5];
        mov DWORD PTR fs:[5], 0x0f;
        mov ebx, 5;
        lock xor DWORD PTR fs:[ebx], 0xff00000f;
        cmp DWORD PTR fs:[ebx], 0xff000000;
        mov DWORD PTR fs:[ebx], edi;
        jnz $endwitherrornow;

        ;;
        ;; inc & dec
        ;;
        mov DWORD PTR [eax], 0xffff;
        lock inc DWORD PTR [eax];
        cmp DWORD PTR [eax], 0x10000;
        jnz $endwitherrornow;
        lock inc WORD PTR [eax];
        cmp WORD PTR [eax], 0x0001;
        lock dec WORD PTR [eax];
        jnz $endwitherrornow;
        cmp WORD PTR [eax], 0x00;
        jnz $endwitherrornow;
        mov DWORD PTR [eax], 0;
        lock dec DWORD PTR [eax];
        cmp DWORD PTR [eax], 0xffffffff;
        jnz $endwitherrornow;
        
        ;;
        ;; not
        ;;
        mov DWORD PTR [eax], 0x10101010;
        lock not DWORD PTR [eax];
        cmp DWORD PTR [eax], 0xefefefef;
        jnz $endwitherrornow;
        mov DWORD PTR [eax+8], 0xffff0000;
        lock not DWORD PTR [eax+8];
        cmp DWORD PTR [eax+8], 0x0000ffff;
        jnz $endwitherrornow;
        mov ecx, 2;
        mov DWORD PTR [eax+ecx*4], 0xffffffff;
        lock not DWORD PTR [eax+ecx*4];
        cmp DWORD PTR [eax+ecx*4], 0x00000000;
        jnz $endwitherrornow;

        ;;
        ;; neg
        ;;
        mov DWORD PTR [eax], 0;
        lock neg DWORD PTR [eax];
        jc $endwitherrornow;
        cmp DWORD PTR [eax], 0;
        jnz $endwitherrornow;
        mov DWORD PTR [eax], 0xffffffff;
        lock neg DWORD PTR [eax];
        jnc $endwitherrornow;
        cmp DWORD PTR [eax], 0x01;
        jnz $endwitherrornow;

        mov WORD PTR [eax], 0xff;
        lock neg WORD PTR [eax];
        jnc $endwitherrornow;
        cmp WORD PTR [eax], 0xff01;
        jnz $endwitherrornow;

        ;;
        ;; bts
        ;;

        mov DWORD PTR [eax], 0x7ffffffe;
        lock bts DWORD PTR [eax], 0;
        jc $endwitherrornow;
        cmp DWORD PTR [eax], 0x7fffffff;
        jnz $endwitherrornow;

        mov ecx, eax;
        sub ecx, 4;
        mov edx, 63;
        lock bts DWORD PTR [ecx], edx;
        jc $endwitherrornow;
        cmp DWORD PTR [eax], 0xffffffff
        jnz $endwitherrornow;

        ;;
        ;; xchg
        ;;
        
        mov DWORD PTR [eax], 0xf0f0f0f0;
        mov edx, 0x11112222;
        lock xchg DWORD PTR [eax], edx;
        cmp DWORD PTR [eax], 0x11112222;
        jnz $endwitherrornow;
        cmp edx, 0xf0f0f0f0;
        jnz $endwitherrornow;

        xchg WORD PTR [eax], dx;
        cmp WORD PTR [eax], 0xf0f0;
        jnz $endwitherrornow;
        cmp dx, 0x2222;
        jnz $endwitherrornow;

        ;;
        ;; cmpxchg
        ;;

        mov ebx, eax;
        mov DWORD PTR [ebx], 0xf0f0f0f0;
        mov eax, 0x10101010;
        mov edx, 0x22332233;
        lock cmpxchg DWORD PTR [ebx], edx;
        jz $endwitherrornow;
        cmp eax, 0xf0f0f0f0;
        jnz $endwitherrornow;

        mov DWORD PTR [ebx], 0xf0f0f0f0;
        mov eax, 0xf0f0f0f0;
        mov edx, 0x12341234;
        lock cmpxchg DWORD PTR [ebx], edx;
        jnz $endwitherrornow;
        cmp DWORD PTR [ebx], 0x12341234;
        jnz $endwitherrornow;

        ;;
        ;; cmpxchg8b
        ;;

        mov DWORD PTR [ebx], 0x11223344;
        mov DWORD PTR [ebx+4], 0x55667788;
        mov edx, 0x12341234;
        mov eax, 0xff00ff00;
        lock cmpxchg8b [ebx];
        jz $endwitherrornow;
        cmp edx, 0x55667788;
        jnz $endwitherrornow;
        cmp eax, 0x11223344;
        jnz $endwitherrornow;

        mov esi, ebx;
        mov DWORD PTR [esi], 0x11223344;
        mov DWORD PTR [esi+4], 0x55667788;
        mov edx, 0x55667788;
        mov eax, 0x11223344;
        mov ecx, 0x10101010;
        mov ebx, 0x20202020;
        lock cmpxchg8b [esi];
        jnz $endwitherrornow;
        cmp DWORD PTR [esi], 0x20202020;
        jnz $endwitherrornow;
        cmp DWORD PTR [esi+4], 0x10101010;
        jnz $endwitherrornow;
        
        mov eax, esi;
        mov ebx, eax;

        ;;
        ;; sub
        ;;

        mov DWORD PTR [eax], 0x0300;
        lock sub WORD PTR [eax], 0x0004;
        cmp DWORD PTR [eax], 0x2fc;
        jnz $endwitherrornow;

        mov DWORD PTR [eax], 0x10000;
        lock sub DWORD PTR [eax], 0x0300;
        cmp DWORD PTR [eax], 0xfd00;
        jnz $endwitherrornow;

        mov ecx, DWORD PTR [eax+8];
        sub ecx, 0x10;
        lock sub DWORD PTR [eax+8], 0x10;
        cmp DWORD PTR [eax+8], ecx;
        jnz $endwitherrornow;
        
        mov ecx, DWORD PTR fs:[5];
        mov esi, 0x3000;
        lock sub DWORD PTR fs:[5], esi;
        mov edi, ecx;
        sub ecx, esi;
        cmp DWORD PTR fs:[5], ecx;
        mov DWORD PTR fs:[5], edi;
        jnz $endwitherrornow;

        mov edi, 5;
        mov ecx, DWORD PTR fs:[edi];
        mov esi, 0x30000;
        lock sub DWORD PTR fs:[edi], esi;
        mov edx, ecx;
        sub ecx, esi;
        cmp DWORD PTR fs:[edi], ecx;
        mov DWORD PTR fs:[edi], edx;
        jnz $endwitherrornow;

        mov si, 0x40;
        mov WORD PTR [eax], 0x3000;
        lock sub WORD PTR [eax], si;
        cmp WORD PTR [eax], 0x2fc0;
        jnz $endwitherrornow;

        mov edi, 0x40;
        mov DWORD PTR [eax], 0x3000;
        lock sub DWORD PTR [eax], edi;
        cmp DWORD PTR [eax], 0x2fc0;
        jnz $endwitherrornow;

        ;;
        ;; sbb
        ;;

        pushfd;
        pop ecx;
        or ecx, 1;
        push ecx;
        popfd;
        mov DWORD PTR [eax], 0x030000;
        lock sbb DWORD PTR [eax], 0x40000;
        cmp DWORD PTR [eax], 0xfffeffff;
        jnz $endwitherrornow;

        pushfd;
        pop ecx;
        and ecx, 0xfffffffe;
        push ecx;
        popfd;
        mov dx, 0x4000;
        mov WORD PTR [eax], 0x03000;
        lock sbb WORD PTR [eax], dx;
        cmp WORD PTR [eax], 0xf000;
        jnz $endwitherrornow;

        pushfd;
        pop ecx;
        or ecx, 0x01;
        push ecx;
        popfd;
        mov WORD PTR [eax], 0x03000;
        lock sbb WORD PTR [eax], 0x04000;
        cmp WORD PTR [eax], 0xefff;
        jnz $endwitherrornow;        

        ;;
        ;; xadd
        ;;

        mov DWORD PTR [eax], 0x12345678;
        mov ecx, 0x1234;
        lock xadd DWORD PTR [eax], ecx;
        cmp ecx, 0x12345678;
        jnz $endwitherrornow;        
        mov edx, 0x1234;
        add edx, 0x12345678;
        cmp DWORD PTR [eax], edx;
        jnz $endwitherrornow;        

        mov WORD PTR [eax], 0x5678;
        mov cx, 0x1234;
        lock xadd WORD PTR [eax], cx;
        cmp cx, 0x5678;
        jnz $endwitherrornow;        
        mov dx, 0x5678;
        add dx, 0x1234;
        cmp WORD PTR [eax], dx;
        jnz $endwitherrornow;        

        ;;
        ;; Update caller with status
        ;;
        mov bError, 0
        jmp $endnow;

$endwitherrornow:

        mov bError, 1
$endnow:
        add esp, STACK_BUFFER;
        popfd;
        popad;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        bError = TRUE;
        printf("ERROR: WOW64BVT: Exception %lx\n", GetExceptionCode());
    }

    if (bError == FALSE) {
        PrintToLog("WOW64BVT: Testing X86 Lock on misaligned addresses...OK\n");
    } else {
        PrintToLog("ERROR: WOW64BVT: Testing X86 Lock on misaligned addresses\n");
    }

    return bError;
}


//
// this routine is used by the two FP tests below
//
int WINAPI FpExcpFilter(LPEXCEPTION_POINTERS lper, int contType)
{
  lper->ContextRecord->FloatSave.ControlWord = 0x33F;

  return contType;
}
BOOL TestFPContext()
{
    BOOL bError = FALSE;
    INT i;
    INT j;

    EXCEPTION_POINTERS *exceptPtrs;

    // 8 registers * 10 bytes per register 
    // Plus a 9th register to make sure we overflow when we should
    //
    char fpArray[90];           
    short controlWord = 0x0300;

    PrintToLog("WOW64BVT: Testing X86 FP Context...\n");

    __try
    {
        for (i = 0; i < 90; i++) {
            fpArray[i] = (char) i;
        }

        __try
        {
            _asm {
                fninit
                fldcw word ptr controlWord
                fld tbyte ptr fpArray
                fld tbyte ptr fpArray + 10
                fld tbyte ptr fpArray + 20
                fld tbyte ptr fpArray + 30
                fld tbyte ptr fpArray + 40
                fld tbyte ptr fpArray + 50
                fld tbyte ptr fpArray + 60
                fld tbyte ptr fpArray + 70
                fwait
    
                // This next push should cause an overflow exception
                fld tbyte ptr fpArray + 80
                fwait
            }

            bError = TRUE;
            printf("ERROR: WOW64BVT: Didn't see stack overflow\n");
        }
        __except(exceptPtrs = GetExceptionInformation(), EXCEPTION_EXECUTE_HANDLER)
        {
            EXCEPTION_RECORD *exceptionRecord;
            CONTEXT *context;
            char *tmpPtr;
        

            //
            // Execute the error handling in a known good fp state
            //
            _asm fninit

            exceptionRecord = exceptPtrs->ExceptionRecord;
            context = exceptPtrs->ContextRecord;

            // Now make sure the exception we saw was the one we expected
            if (exceptionRecord->ExceptionCode != STATUS_FLOAT_STACK_CHECK) {
                bError =  TRUE;
                printf("ERROR: WOW64BVT: Didn't see stack overflow STATUS. Saw 0x%08x\n", exceptionRecord->ExceptionCode);
                goto failFpContent;
            }

            if ((context->FloatSave.StatusWord & 0x77f) != 0x241) {
                bError = TRUE;
                printf("ERROR: WOW64BVT: Didn't see stack overflow status bits\n");
                goto failFpContent;
            }

            tmpPtr = &(context->FloatSave.RegisterArea[0]);

            // And verify the register contents
            for (i = 7; i >= 0; i--) {
                for (j = i * 10; j < ((i+1) * 10); j++) {
                    if (*tmpPtr++ != (char) j) {
                        bError = TRUE;
                        printf("ERROR: WOW64BVT: Didn't see correct fp context\n");
                        goto failFpContent;
                    }
                }
            }


            //
            // Unfortunately, for the Merced Processor, the IIP has the
            // address of the wait intstruction following the fld that
            // overflowed the stack. For an x86 processor, the EIP
            // has the address of the fld instruction. Both architectures
            // put the fld instruction in the fir register, so lets hope
            // people use that to look for FP error addresses...
            //
            // Thus, we cannot do the following style of test
            //
            // ASSERT(((ULONG) context->FloatSave.ErrorOffset) ==
            //        ((ULONG) exceptionRecord->ExceptionAddress));
            //

failFpContent:
            ;
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        bError = TRUE;
        printf("ERROR: WOW64BVT: Exception %lx\n", GetExceptionCode());
    }

    if (bError == FALSE) {
        PrintToLog("WOW64BVT: Testing X86 FP Context...OK\n");
    } else {
        PrintToLog("ERROR: WOW64BVT: Testing X86 FP Context\n");
    }

    return bError;
}


BOOL TestMMXException()
{
    LONG bError = TRUE;

    unsigned short op1[5] = {0x0000, 0x0000, 0x0000, 0x8000, 0x7ffe};
    unsigned short res[5];
    short controlWord = 0x0308;


    PrintToLog("WOW64BVT: Testing X86 MMX exception...\n");
    
    __try
    {
        _asm {
            fninit
            fld tbyte ptr op1
            fld tbyte ptr op1
            fldcw word ptr controlWord
        }

        __try
        {
            _asm faddp  ST(1),ST(0)
            _asm fstp tbyte ptr res

        }
        __except(FpExcpFilter(GetExceptionInformation(), EXCEPTION_CONTINUE_EXECUTION)) {
            // Do nothing
        }


        _asm {

            cmp     DWORD PTR [res + 6],0x7FFF8000
            jne             ADD_FAILED
            mov             bError,0
ADD_FAILED:
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        bError = TRUE;
        printf("ERROR: WOW64BVT: Exception %lx\n", GetExceptionCode());
    }

    if (bError == FALSE) {
        PrintToLog("WOW64BVT: Testing X86 MMX exception...OK\n");
    } else {
        PrintToLog("ERROR: WOW64BVT: Testing X86 MMX exception\n");
    }

    return (BOOL) bError;
}

BOOL TestX86SelectorLoad()
{

    BOOL bError = FALSE;

    PrintToLog("WOW64BVT: Testing X86 selector-load...\n");
    
    __try
    {
        __asm
        {
            mov ax, ss;
            mov ss, ax;

            mov ax, ds;
            mov ds, ax;

            mov ax, es;
            mov es, ax;

            mov ax, fs;
            mov fs, ax;
        }

    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        bError = TRUE;
        printf("ERROR: WOW64BVT: Exception %lx\n", GetExceptionCode());
    }

    if (bError == FALSE) {
        PrintToLog("WOW64BVT: Testing X86 selector-load...OK\n");
    } else {
        PrintToLog("ERROR: WOW64BVT: Testing X86 selector-load\n");
    }

    return bError;

}


////////////  All this code runs in the main test driver thread //////

HANDLE CreateTheChildProcess(char *ProcessName, char *LogFileName)
{
    char Buffer[512];
    HANDLE h;
    STARTUPINFOA si;
    PROCESS_INFORMATION pi;
    BOOL b;

    PrintToLog("WOW64BVT: Creating child process\n");

    strcpy(Buffer, ProcessName);
    strcat(Buffer, " childprocess");
    memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);
    if (fpLogFile) {
        // If we're logging, then change the child process' stdout/stderr
        // to be the log file handle, so their output is captured to the file.
        HANDLE hLog = (HANDLE)_get_osfhandle(_fileno(fpLogFile));

        si.dwFlags = STARTF_USESTDHANDLES;
        si.hStdInput = GetStdHandle(STD_INPUT_HANDLE);
        si.hStdOutput = hLog;
        si.hStdError = hLog;
    }
    b = CreateProcessA(NULL, Buffer, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi);
    if (!b) {
        PrintToLog("ERROR: WOW64BVT:  Error %d creating child process.\n", GetLastError());
        exit(1);
    }
    CloseHandle(pi.hThread);
    return pi.hProcess;
}

// This is called from within exit() in the main test driver process
void __cdecl AtExitHandler(void)
{
    time_t EndTime;
    struct tm *newtime;
    OSVERSIONINFOW vi;
    BOOL b;
    int year, hour;

    memset(&vi, 0, sizeof(vi));
    vi.dwOSVersionInfoSize = sizeof(vi);
    b = GetVersionExW(&vi);
    if (!b) {
        PrintToLog("\tWARNING: GetVersionExW failed, LastError = %d\n", GetLastError());
        vi.dwBuildNumber = 0;
    }

    // Close the logging bucket.
    PrintToLog(("[/TEST LOGGING OUTPUT]\n"));

    // Print the required data:
    PrintToLog("\tTEST:         wow64bvt\n");
    PrintToLog("\tBUILD:        %d\n", vi.dwBuildNumber);
    PrintToLog("\tMACHINE:      \\\\%s\n", getenv("COMPUTERNAME"));
    PrintToLog("\tRESULT:       %s\n", (g_bError) ? "FAIL" : "PASS");
    PrintToLog("\tCONTACT:      samera\n");
    PrintToLog("\tMGR CONTACT:  samera\n");
    PrintToLog("\tDEV PRIME:    samera\n");
    PrintToLog("\tDEV ALT:      askhalid\n");
    PrintToLog("\tTEST PRIME:   terryla\n");
    PrintToLog("\tTEST ALT:     terryla\n");
    newtime = localtime(&TestStartTime);
    year = (newtime->tm_year >= 100) ? newtime->tm_year-100 : newtime->tm_year;
    if (newtime->tm_hour == 0) {
        hour = 12;
    } else if (newtime->tm_hour > 12) {
        hour = newtime->tm_hour-12;
    } else {
        hour = newtime->tm_hour;
    }
    PrintToLog("\tSTART TIME:   %d/%d/%2.2d %d:%2.2d:%2.2d %s\n", newtime->tm_mon+1,
                                                     newtime->tm_mday,
                                                     year,
                                                     hour,
                                                     newtime->tm_min,
                                                     newtime->tm_sec,
                                                     (newtime->tm_hour < 12) ? "AM" : "PM");

    time(&EndTime);
    newtime = localtime(&EndTime);
    year = (newtime->tm_year >= 100) ? newtime->tm_year-100 : newtime->tm_year;
    if (newtime->tm_hour == 0) {
        hour = 12;
    } else if (newtime->tm_hour > 12) {
        hour = newtime->tm_hour-12;
    } else {
        hour = newtime->tm_hour;
    }
    PrintToLog("\tEND TIME:     %d/%d/%2.2d %d:%2.2d:%2.2d %s\n", newtime->tm_mon+1,
                                                     newtime->tm_mday,
                                                     year,
                                                     hour,
                                                     newtime->tm_min,
                                                     newtime->tm_sec,
                                                     (newtime->tm_hour < 12) ? "AM" : "PM");
    PrintToLog("[/TESTRESULT]\n");
}

//
// This is just used to print out failing exception cases
//
void __cdecl ExceptionWoops(HRESULT want, HRESULT got)
{
	if (got == 0) {
		PrintToLog("==> Exception Skipped. Wanted: 0x%08x, Got: 0x%08x\n", want, got);
	}
	else {
		PrintToLog("==> Unexpected Exception. Wanted: 0x%08x, Got: 0x%08x\n", want, got);
	}
}

#define EXCEPTION_LOOP      10000

// Among other things, this does some divife by zero's (as a test)
// so don't have the compiler stop things just because we're causing an error
#pragma warning(disable:4756)
#pragma warning(disable:4723)

//
// Do some exception checks
//
int __cdecl ExceptionCheck(void)
{
    int failThis;
	int sawException;
    int i;
    char *p = NULL;
	HRESULT code;


    PrintToLog("WOW64BVT: Testing Exception Handling...\n");

    // Assume success
    failThis = FALSE;

    // Test a privileged instruction
	sawException = FALSE;
	__try {
		__asm {
			hlt
		}
		code = 0;
	}
	__except((code = GetExceptionCode()), 1 ) {
        ULONG checkCode;

        if (SysInfo.dwProcessorType == PROCESSOR_AMD_X8664) {
            checkCode = STATUS_ACCESS_VIOLATION;
        } else {
            checkCode = STATUS_PRIVILEGED_INSTRUCTION;
        }
        
        if (code == checkCode) {
            // PrintToLog("Saw privileged instruction\n");
        }
        else {
                PrintToLog("ERROR: Cause a privileged instruction fault\n");
	        ExceptionWoops(STATUS_PRIVILEGED_INSTRUCTION, code);
            failThis = TRUE;
        }
		sawException = TRUE;
	}
	if (!sawException) {
            PrintToLog("ERROR: Cause a privileged instruction fault\n");
        ExceptionWoops(STATUS_PRIVILEGED_INSTRUCTION, code);
        failThis = TRUE;
    }

    // Test an illegal instruction
	sawException = FALSE;
	__try {
		__asm {
			__asm _emit 0xff
			__asm _emit 0xff
			__asm _emit 0xff
			__asm _emit 0xff
		}
		code = 0;
	}
	__except((code = GetExceptionCode()), 1 ) {
		if (code == STATUS_ILLEGAL_INSTRUCTION) {
			// PrintToLog("Saw illegal instruction\n");
        }
        else {
            PrintToLog("ERROR: Cause an illegal instruction fault\n");
	        ExceptionWoops(STATUS_ILLEGAL_INSTRUCTION, code);
            failThis = TRUE;
        }
		sawException = TRUE;
	}
	if (!sawException) {
        PrintToLog("ERROR: Cause an illegal instruction fault\n");
        ExceptionWoops(STATUS_ILLEGAL_INSTRUCTION, code);
        failThis = TRUE;
    }

//
// Testing for an int 3 can be a problem for systems that
// are running checked builds. So, don't bother with this
// test. Perhaps in the future, the code can test for a checked
// build and do appropriate.
//
#if 0
    // Test the result of an int 3
	sawException = FALSE;
	__try {
		_asm {
			int 3
		}
		code = 0;
	}
	__except((code = GetExceptionCode()), 1 ) {
        if (code == STATUS_BREAKPOINT) {
			// PrintToLog("Saw debugger breakpoint\n");
        }
        else {
            PrintToLog("ERROR: Cause an int 3 debugger breakpoint\n");
	        ExceptionWoops(STATUS_BREAKPOINT, code);
            failThis = TRUE;
        }
		sawException = TRUE;
	}
	if (!sawException) {
        PrintToLog("ERROR: Cause an int 3 debugger breakpoint\n");
        ExceptionWoops(STATUS_BREAKPOINT, code);
        failThis = TRUE;
    }
#endif

    // Test the result of an illegal int XX instruction
	sawException = FALSE;
	__try {
		_asm {
			int 66
		}
		code = 0;
	}
	__except((code = GetExceptionCode()), 1 ) {
        if (code == STATUS_ACCESS_VIOLATION) {
			// PrintToLog("Saw access violation\n");
        }
        else {
            PrintToLog("ERROR: Cause an int 66 unknown interrupt (Access violation)\n");
	        ExceptionWoops(STATUS_ACCESS_VIOLATION, code);
            failThis = TRUE;
        }
		sawException = TRUE;
	}
	if (!sawException) {
        PrintToLog("ERROR: Cause an int 66 unknown interrupt (Access violation)\n");
        ExceptionWoops(STATUS_ACCESS_VIOLATION, code);
        failThis = TRUE;
    }

    // Test the result of an int divide by zero
	sawException = FALSE;
	__try {
		int i, j, k;

		i = 0;
		j = 4;

		k = j / i;
		code = 0;
	}
	__except((code = GetExceptionCode()), 1 ) {
        if (code == STATUS_INTEGER_DIVIDE_BY_ZERO) {
			// PrintToLog("Saw int divide by zero\n");
        }
        else {
            PrintToLog("ERROR: Cause an integer divide by zero\n");
	        ExceptionWoops(STATUS_INTEGER_DIVIDE_BY_ZERO, code);
            failThis = TRUE;
        }
		sawException = TRUE;
	}
	if (!sawException) {
        PrintToLog("ERROR: Cause an integer divide by zero\n");
        ExceptionWoops(STATUS_INTEGER_DIVIDE_BY_ZERO, code);
        failThis = TRUE;
    }

    // Test the result of an fp divide by zero
	// PrintToLog("Before div0: Control is 0x%0.4x, Status is 0x%0.4x\n", _control87(0,0), _status87());
	sawException = FALSE;
	__try {
		double x, y;

		y = 0.0;

		x = 1.0 / y ;

		// PrintToLog("x is %lf\n", x);

		code = 0;
	}
	__except((code = GetExceptionCode()), 1 ) {
		// Don't actually get a divide by zero error, get
		// so we should never hit this exception!
        PrintToLog("Try a floating divide by zero\n");
		PrintToLog("Woops! Saw an exception when we shouldn't have!\n");
		sawException = TRUE;
            failThis = TRUE;
	}
	// So you would think you'd get a float divide by zero error... Nope,
	// you get X set to infinity...
	if (code != 0) {
        PrintToLog("ERROR: Try a floating divide by zero\n");
        ExceptionWoops(0, code);
        failThis = TRUE;
    }
	// PrintToLog("After div0: Control is 0x%0.4x, Status is 0x%0.4x\n", _control87(0,0), _status87());


    // Test an int overflow (which actually does not cause an exception)
	sawException = FALSE;
	__try {
		__asm {
			into
		}
		// PrintToLog("into doesn't fault\n");
		code = 0;
	}
	__except((code = GetExceptionCode()), 1 ) {
        if (code == STATUS_INTEGER_OVERFLOW) {
			// PrintToLog("Saw integer overflow\n");
        }
        else {
            PrintToLog("ERROR: Try an into overflow fault\n");
	        ExceptionWoops(STATUS_INTEGER_OVERFLOW, code);
            failThis = TRUE;
        }
		sawException = TRUE;
	}
	// Looks like integer overflow is ok... Is this a CRT thing?
	if (code != 0) {
        PrintToLog("ERROR: Try an into overflow fault\n");
        ExceptionWoops(0, code);
        failThis = TRUE;
    }

    // Test an illegal access
	sawException = FALSE;
	__try {

		*p = 1;
		code = 0;
	}
	__except((code = GetExceptionCode()), 1 ) {
        if (code == STATUS_ACCESS_VIOLATION) {
			// PrintToLog("Saw access violation\n");
        }
        else {
            PrintToLog("ERROR: Cause an access violation\n");
	        ExceptionWoops(STATUS_ACCESS_VIOLATION, code);
            failThis = TRUE;
        }
		sawException = TRUE;
	}
	if (!sawException) {
        PrintToLog("ERROR: Cause an access violation\n");
        ExceptionWoops(STATUS_ACCESS_VIOLATION, code);
        failThis = TRUE;
    }

    //
    // Finally, try a lot of exceptions (a loop) and verify we don't overflow
    // the stack
    //
    for (i = 0; i < EXCEPTION_LOOP; i++) {
        
        // Test an illegal access
        sawException = FALSE;
        __try {
            *p = 1;
            code = 0;
        }
        __except((code = GetExceptionCode()), 1 ) {
            if (code == STATUS_ACCESS_VIOLATION) {
                // PrintToLog("Saw access violation\n");
            }
            else {
                PrintToLog("ERROR: Cause an access violation\n");
                ExceptionWoops(STATUS_ACCESS_VIOLATION, code);
                failThis = TRUE;
                break;
            }
            sawException = TRUE;
        }
        if (!sawException) {
            PrintToLog("ERROR: Cause an access violation\n");
            ExceptionWoops(STATUS_ACCESS_VIOLATION, code);
            failThis = TRUE;
            break;
        }
    }

    if (failThis) {
        PrintToLog("ERROR: Testing Exception Handling\n");
    }
    else {
        PrintToLog("WOW64BVT: Testing Exception Handling... OK\n");
    }

	return failThis;
}

// Ok, go back to normal warnings...
#pragma warning(default:4756)
#pragma warning(default:4723)

#if defined(__BUILDMACHINE__)
#if defined(__BUILDDATE__)
#define B2(x, y) "" #x "." #y
#define B1(x, y) B2(x, y)
#define BUILD_MACHINE_TAG B1(__BUILDMACHINE__, __BUILDDATE__)
#else
#define B2(x) "" #x
#define B1(x) B2(x)
#define BUILD_MACHINE_TAG B1(__BUILDMACHINE__)
#endif
#else
#define BUILD_MACHINE_TAG ""
#endif

int __cdecl main(int argc, char *argv[])
{
    NTSTATUS st;
    HANDLE HandleList[2];
    BOOL b;
    DWORD dwExitCode;

    // get native system information
    GetNativeSystemInfo (&SysInfo);

    // Disable buffering of the standard output handle
    setvbuf(stdout, NULL, _IONBF, 0);

    // Do some minimal command-line checking
    if (argc < 2 || argc > 3) {
        PrintToLog("Usage:  wow64bvt log_file_name\n\n");
        return 1;
    } else if (strcmp(argv[1], "childprocess") == 0) {
        return BeAChildProcess();
    }
    // We're the main exe

    // Record the start time
    time(&TestStartTime);

    // Open the log file
    fpLogFile = fopen(argv[1], "w");
    if (!fpLogFile) {
        PrintToLog("wow64bvt: Error: unable to create the log file '%s'\n", argv[1]);
        return 1;
    }
    // Disable buffering of the log file handle
    setvbuf(fpLogFile, NULL, _IONBF, 0);

    // Print the initial banner
    PrintToLog("[TESTRESULT]\n");
    PrintToLog("[TEST LOGGING OUTPUT]\n");
    PrintToLog("%s built on %s at %s by %s\n", argv[0], __DATE__, __TIME__, BUILD_MACHINE_TAG);

    // Register the atexit handler - it closes the logging output section
    // and prints the success/fail information as the BVT test exits.
    atexit(AtExitHandler);

    ///////////////////////////// Test starts here //////////////////////////

    // 32-bit child process creation from 32-bit parent.  The parent instance
    // (running now) tested 32-bit child from 64-bit parent
    HandleList[0] = CreateTheChildProcess(argv[0], argv[1]);

    // Create a thread do so some more work
    HandleList[1] = CreateTheThread();

    // Wait for everything to finish
    WaitForMultipleObjects(sizeof(HandleList)/sizeof(HandleList[0]), HandleList, TRUE, INFINITE);

    // Get the return code from the child process
    b=GetExitCodeProcess(HandleList[0], &dwExitCode);
    if (b) {
        if (dwExitCode) {
            // The child failed.  We should fail too.
            return (int)dwExitCode;
        }
    } else {
        PrintToLog("ERROR: GetExitCodeProcess failed with LastError = %d\n", GetLastError());
        return 1;
    }

    // Get the return code from the thread
    b=GetExitCodeThread(HandleList[1], &dwExitCode);
    if (b) {
        if (dwExitCode) {
            // The child failed.  We should fail too.
            return (int)dwExitCode;
        }
    } else {
        PrintToLog("ERROR: GetExitCodeThread failed with LastError = %d\n", GetLastError());
        return 1;
    }


    b = ExceptionCheck();
    if (b) {
        PrintToLog("ERROR: Exception Handling test.\n");
        return 1;
    }

    b = TestGuardPages();
    if (b) {
        PrintToLog("ERROR: TestGuardPages().\n");
        return 1;
    }

    b = TestMemoryMappedFiles();
    if (b) {
        PrintToLog("ERROR: TestMemoryMappedFiles().\n");
        return 1;
    }

    b = TestVadSplitOnFree();
    if (b) {
        PrintToLog("ERROR: TestVadSplitOnFree()\n");
        return 1;
    }

    b = TestMmPageProtection();
    if (b) {
        PrintToLog("ERROR: TestMmPageProtection()\n");
        return 1;
    }

    b = TestX86MisalignedLock();
    if (b) {
        PrintToLog("ERROR: TestX86MisalignedLock()\n");
        return 1;
    }

    b = TestFPContext();
    if (b) {
        PrintToLog("ERROR: TestFPContext()\n");
        return 1;
    }

    b = TestMMXException();
    if (b) {
        PrintToLog("ERROR: TestMMXException()\n");
        return 1;
    }

    b = TestX86SelectorLoad();
    if (b) {
        PrintToLog("ERROR: TestX86SelectorLoad()\n");
        return 1;
    }


    // Everything finished OK.  Clear the error flag and exit.  The atexit
    // callback function will finish filling out the log if this is the
    // main thread.    
    RtlZeroMemory (&g_bError, sizeof (g_bError));

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\tools\genlib\redblack.c ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    redblack.c

Abstract:
    
    This module implements red/black trees.
    
Author:

    16-Jun-1995 t-orig

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include "gen.h"

PKNOWNTYPES NIL;

#define RIGHT(x)        x->RBRight
#define LEFT(x)         x->RBLeft
#define PARENT(x)       x->RBParent
#define COLOR(x)        x->RBColor
#define KEY(x)          x->TypeName

VOID
RBInitTree(
    PRBTREE ptree
    )
{
    ptree->pRoot = NIL;
    ptree->pLastNodeInserted = NULL;
}


PKNOWNTYPES
RBLeftRotate(
    PKNOWNTYPES root,
    PKNOWNTYPES x
    )
/*++

Routine Description:

    Rotates the tree to the left at node x.


         x                     y
        / \                   / \
       A   y       ==>>      x   C
          / \               / \
         B   C             A   B

Arguments:

    root - The root of the Red/Black tree
    x - The node at which to rotate

Return Value:

    return-value - The new root of the tree (which could be the same as 
                   the old root).

--*/
{
    PKNOWNTYPES y;

    y = RIGHT(x);
    RIGHT(x) = LEFT(y);
    if (LEFT(y) != NIL){
        PARENT(LEFT(y)) = x;
    }
    PARENT(y) = PARENT(x);
    if (PARENT(x) == NIL){
        root = y;
    } else if (x==LEFT(PARENT(x))) {
        LEFT(PARENT(x)) = y;
    } else {
        RIGHT(PARENT(x))= y;
    }
    LEFT(y) = x;
    PARENT(x) = y;
    return root;
}



PKNOWNTYPES
RBRightRotate(
    PKNOWNTYPES root,
    PKNOWNTYPES x
    )
/*++

Routine Description:

    Rotates the tree to the right at node x.


         x                     y
        / \                   / \
       y   C       ==>>      A   x
      / \                       / \
     A   B                     B   C

Arguments:

    root - The root of the Red/Black tree
    x - The node at which to rotate

Return Value:

    return-value - The new root of the tree (which could be the same as
                   the old root).

--*/
{
    PKNOWNTYPES y;

    y = LEFT(x);
    LEFT(x) = RIGHT(y);
    if (RIGHT(y) != NIL) {
        PARENT(RIGHT(y)) = x;
    }
    PARENT(y) = PARENT(x);
    if (PARENT(x) == NIL) {
        root = y;
    } else if (x==LEFT(PARENT(x))) {
        LEFT(PARENT(x)) = y;
    } else {
        RIGHT(PARENT(x))= y;
    }
    RIGHT(y) = x;
    PARENT(x) = y;
    return root;
}




PKNOWNTYPES
RBTreeInsert(
    PKNOWNTYPES root,
    PKNOWNTYPES z
    )
/*++

Routine Description:

    Inserts a new node into a tree without preserving the red/black properties.
    Should ONLY be called by RBInsert!  This is just a simple binary tree
    insertion routine.

Arguments:

    root -  The root of the red/black tree
    z - The new node to insert

Return Value:

    return-value - The new root of the tree (which could be the same as the
    old root).
    

--*/
{
    PKNOWNTYPES x,y;
    int i;

    y = NIL;
    x = root;

    LEFT(z) = RIGHT(z) = NIL;

    // Find a place to insert z by doing a simple binary search
    while (x!=NIL) {
        y = x;
        i = strcmp(KEY(z), KEY(x));
        if (i < 0){
            x = LEFT(x);
        } else {
            x = RIGHT(x);
        }
    }

    // Insert z into the tree
    PARENT(z)= y;

    if (y==NIL) {
        root = z;
    } else if (i<0) {
        LEFT(y) = z;
    } else {
        RIGHT(y) = z;
    }

    return root;
}


VOID
RBInsert(
    PRBTREE     ptree,
    PKNOWNTYPES x
    )
/*++

Routine Description:

    Inserts a node into a red/black tree while preserving the red/black
    properties.

Arguments:

    root -  The root of the red/black tree
    z - The new node to insert

Return Value:

    return-value - The new root of the tree (which could be the same as
                   the old root).

--*/
{
    PKNOWNTYPES root = ptree->pRoot;
    PKNOWNTYPES y;

    // Make a linked-list of nodes for easy deletion
    x->Next = ptree->pLastNodeInserted;
    ptree->pLastNodeInserted = x;
    
    // Insert x into the tree without preserving the red/black properties
    root = RBTreeInsert (root, x);
    COLOR(x) = RED;

    // We can stop fixing the tree when either:
    // 1) We got to the root 
    // 2) x has a BLACK parent (the tree obeys the red/black properties,
    //    because no RED parent has a RED child.
    while ((x != root) && (COLOR(PARENT(x)) == RED)) {
        if (PARENT(x) == LEFT(PARENT(PARENT(x)))) {
            // Parent of x is a left child with sibling y.
            y = RIGHT(PARENT(PARENT(x)));
            if (COLOR(y) == RED) {
                // Since y is red, just change everyone's color and try again
                // with x's grandfather
                COLOR (PARENT (x)) = BLACK;
                COLOR(y) = BLACK;
                COLOR(PARENT(PARENT(x))) = RED;
                x =  PARENT(PARENT(x));
            } else if (x == RIGHT (PARENT (x))) {
                // Here y is BLACK and x is a right child.  A left rotation
                // at x would prepare us for the next case
                x = PARENT(x);
                root = RBLeftRotate (root, x);
            } else {
                // Here y is BLACK and x is a left child.  We fix the tree by
                // switching the colors of x's parent and grandparent and
                // doing a right rotation at x's grandparent.
                COLOR (PARENT (x)) = BLACK;
                COLOR (PARENT (PARENT (x))) = RED;
                root = RBRightRotate (root, PARENT(PARENT(x)));
            }
        } else {
            // Parent of x is a right child with sibling y.
            y = LEFT(PARENT(PARENT(x)));
            if (COLOR(y) == RED) {
                // Since y is red, just change everyone's color and try again
                // with x's grandfather
                COLOR (PARENT (x)) = BLACK;
                COLOR(y) = BLACK;
                COLOR(PARENT(PARENT(x))) = RED;
                x =  PARENT(PARENT(x));
            } else if (x == LEFT (PARENT (x))) {
                // Here y is BLACK and x is a left child.  A right rotation
                // at x would prepare us for the next case
                x = PARENT(x);
                root = RBRightRotate (root, x);
            } else {
                // Here y is BLACK and x is a right child.  We fix the tree by
                // switching the colors of x's parent and grandparent and
                // doing a left rotation at x's grandparent.
                COLOR (PARENT (x)) = BLACK;
                COLOR (PARENT (PARENT (x))) = RED;
                root = RBLeftRotate (root, PARENT(PARENT(x)));
            }
        }
    } // end of while loop

    COLOR(root) = BLACK;
    ptree->pRoot= root;
}


PKNOWNTYPES
RBFind(
    PRBTREE ptree,
    char *Name
    )
/*++

Routine Description:

    Finds a node in the red black tree given a name

Arguments:

    root - The root of the red/black tree
    name - The name corresponding to the node to be searched for.

Return Value:

    return-value - The node in the tree (entry point of code containing name), or
        NULL if not found.


--*/
{
    int i;
    PKNOWNTYPES root = ptree->pRoot;

    while (root != NIL) {
        i = strcmp(Name, KEY(root));
        if (i < 0) {
            root = LEFT(root);
        } else if (i > 0) {
            root = RIGHT(root);
        } else {
            return root;
        }
    }
    return NULL;  // Range not found
}


PKNOWNTYPES
RBTreeSuccessor(
    PKNOWNTYPES x
    )
/*++

Routine Description:

    Returns the successor of a node in a binary tree (the successor of x 
    is defined to be the node which just follows x in an inorder
    traversal of the tree).

Arguments:

    x - The node whose successor is to be returned

Return Value:

    return-value - The successor of x

--*/

{
    PKNOWNTYPES y;

    // If x has a right child, the successor is the leftmost node to the
    // right of x.
    if (RIGHT(x) != NIL) {
        x = RIGHT(x);
        while (LEFT(x) != NIL) {
            x = LEFT(x);
        }
        return x;
    }
    
    // Else the successor is an ancestor with a left child on the path to x
    y = PARENT(x);
    while ((y != NIL) && (x == RIGHT(y))) {
        x = y;
        y = PARENT(y);
    }
    return y;
}



PKNOWNTYPES
RBDeleteFixup(
    PKNOWNTYPES root,
    PKNOWNTYPES x
    )
/*++

Routine Description:

    Fixes the red/black tree after a delete operation.  Should only be 
    called by RBDelete

Arguments:

    root - The root of the red/black tree
    x - Either a child of x, or or a child or x's successor

Return Value:

    return-value - The new root of the red/black tree

--*/
{
    PKNOWNTYPES w;

    // We stop when we either reached the root, or reached a red node (which
    // means that property 4 is no longer violated).
    while ((x!=root) && (COLOR(x)==BLACK)) {
        if (x == LEFT(PARENT(x))) {
            // x is a left child with sibling w      
            w = RIGHT(PARENT(x));
            if (COLOR(w) == RED) {
                // If w is red it must have black children.  We can switch
                // the colors of w and its parent and perform a left
                // rotation to bring w to the top.  This brings us to one
                // of the other cases.
                COLOR(w) = BLACK;
                COLOR(PARENT(x)) = RED;
                root = RBLeftRotate (root, PARENT(x));
                w = RIGHT(PARENT(x));
            }
            if ((COLOR(LEFT(w)) == BLACK) && (COLOR(RIGHT(w)) == BLACK)) {
                // Here w is black and has two black children.  We can thus
                // change w's color to red and continue.
                COLOR(w) = RED;
                x = PARENT(x);
            } else {
                if (COLOR(RIGHT(w)) == BLACK) {
                    // Here w is black, its left child is red, and its right child
                    // is black.  We switch the colors of w and its left child,
                    // and perform a left rotation at w which brings us to the next
                    // case.
                    COLOR(LEFT(w)) = BLACK;
                    COLOR(w) = RED;
                    root = RBRightRotate (root, w);
                    w = RIGHT(PARENT(x));
                } 
                // Here w is black and has a red right child.  We change w's
                // color to that of its parent, and make its parent and right
                // child black.  Then a left rotation brings w to the top.
                // Making x the root ensures that the while loop terminates.
                COLOR(w) = COLOR(PARENT(x));
                COLOR(PARENT(x)) = BLACK;
                COLOR(RIGHT(w)) = BLACK;
                root = RBLeftRotate (root, PARENT(x));
                x = root;
            }
        } else {
            // The symmetric case:  x is a right child with sibling w.
            w = LEFT(PARENT(x));
            if (COLOR(w) == RED) {
                COLOR(w) = BLACK;
                COLOR(PARENT(x)) = RED;
                root = RBRightRotate (root, PARENT(x));
                w = LEFT(PARENT(x));
            }
            if ((COLOR(LEFT(w)) == BLACK) && (COLOR(RIGHT(w)) == BLACK)) {
                COLOR(w) = RED;
                x = PARENT(x);
            } else {
                if (COLOR(LEFT(w)) == BLACK) {
                    COLOR(RIGHT(w)) = BLACK;
                    COLOR(w) = RED;
                    root = RBLeftRotate (root, w);
                    w = LEFT(PARENT(x));
                } 
                COLOR(w) = COLOR(PARENT(x));
                COLOR(PARENT(x)) = BLACK;
                COLOR(LEFT(w)) = BLACK;
                root = RBRightRotate (root, PARENT(x));
                x = root;
            }
        }
    } // end of while loop

    //printf ("Changing color at %i to BLACK\n", x->intelColor);
    COLOR(x) = BLACK;
    return root;
}




PKNOWNTYPES
RBDelete(
    PRBTREE ptree,
    PKNOWNTYPES z
    )
/*++

Routine Description:

    Deletes a node in a red/black tree while preserving the red/black 
    properties.

Arguments:

    root - The root of the red/black tree
    z - The node to be deleted

Return Value:

    return-value - The new root of the red/black tree

--*/
{
    PKNOWNTYPES x,y;
    PKNOWNTYPES root = ptree->pRoot;
    COL c;

    
    // It's easy to delete a node with at most one child:  we only need to
    // remove it and put the child in its place.  It z has at most one child,
    // we can just remove it.  Otherwise we'll replace it with its successor
    // (which is guaranteed to have at most one child, or else one of its
    // children would be the succecssor), and delete the successor.
    if ((LEFT(z) == NIL) || (RIGHT(z) == NIL)) {
        y = z;
    } else {
        y = RBTreeSuccessor(z);
    }

    // Recall that y has at most one child.  If y has one child, x is set to
    // it.  Else x will be set to NIL which is OK.  This way we don't have
    // to worry about this special case.
    if (LEFT(y) != NIL){
        x = LEFT(y);
    } else {
        x = RIGHT(y);
    }
    
    // Now we will remove y from the tree
    PARENT(x) = PARENT(y);
    
    if (PARENT(y) == NIL) {
        root = x;
    } else if (y == LEFT(PARENT(y))) {
        LEFT(PARENT(y)) = x;
    } else {
        RIGHT(PARENT(y)) = x;
    }

    if (PARENT(x) == z) {
        PARENT(x) = y;
    }

    c = COLOR(y);

    // Since each node has lots of fields (fields may also change during
    // the lifetime of this code), I found it safer to copy the
    // pointers as opposed to data.
    if (y!=z) { // Now swapping y and z, but remembering color of y
        PARENT(y) = PARENT(z);

        if (root == z) {
            root = y;
        } else if (z == RIGHT(PARENT(z))) {
            RIGHT(PARENT(z)) = y;
        } else {
            LEFT(PARENT(z)) = y;
        }

        LEFT(y) = LEFT(z);
        if (LEFT(y) != NIL) {
            PARENT(LEFT(y)) = y;
        }

        RIGHT(y) = RIGHT(z);
        if (RIGHT(y) != NIL) {
            PARENT(RIGHT(y)) = y;
        }

        COLOR(y) = COLOR(z);
    }


    // Need to fix the tree (fourth red/black property).
    if (c == BLACK) {
        root = RBDeleteFixup (root, x);
    }
    return root;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\tools\gennt32t\gennt32t.cpp ===
/*++
                                                                                
Copyright (c) 1998-1999 Microsoft Corporation

Module Name:

    gennt32t.cpp

Abstract:
    
    Generates NT32 headers for use in the NT64 build.
    
Author:

    mzoran  5-8-98

Revision History:

--*/

#pragma warning( disable : 4786) //disable identifier is too long for debugging error
#pragma warning( disable : 4503) //disable decorated name is too long
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <assert.h>

#include <iostream>
#include <fstream>
#include <iomanip>
#include <string>
#include <sstream>
#include <set>
#include <map>

extern "C" {

#include "gen.h"

// string to put in front of all error messages so that BUILD can find them.
const char *ErrMsgPrefix = "NMAKE :  U8603: 'GENNT32T' ";

#pragma warning(push)
#pragma warning(disable:4702)
void
HandlePreprocessorDirective(
   char *p
   )
{
   ExitErrMsg(FALSE, "Preprocessor directives not allowed by gennt32t.\n");
}
#pragma warning(pop)

}

using namespace std;
typedef string String;

PRBTREE pFunctions = NULL;
PRBTREE pStructures = NULL;
PRBTREE pTypedefs = NULL;
PKNOWNTYPES NIL = NULL;

void ExtractCVMHeader(PCVMHEAPHEADER pHeader) {
   pFunctions = &pHeader->FuncsList;
   pTypedefs =  &pHeader->TypeDefsList;
   pStructures =&pHeader->StructsList;
   NIL         =&pHeader->NIL; 
}

 
void GetType(PKNOWNTYPES pTypes, char *pPrepend, ostream & oType, ostream & oName, BOOL bAddTypeName) {
  
   while(1) {
      PKNOWNTYPES pBasicType = NULL;
      assert(pTypes->TypeName != NULL);
      
      oType << "/* " << pTypes->TypeName << " */";
                          
      if(pTypes->Flags & BTI_ISARRAY)
         oName << '[' << pTypes->dwArrayElements << ']';
      if (pTypes->IndLevel > 0) {
         oType << GetHostPointerName(pTypes->Flags & BTI_PTR64);
         return;
      }
      if(!(BTI_NOTDERIVED & pTypes->Flags)) {
         
         if (strcmp(pTypes->BaseName, "enum") == 0) {
            if (bAddTypeName)
               oType << "enum " << pPrepend << pTypes->TypeName << " {} \n";
            else
               oType << "_int32 \n";
            return;
         }

         else if (strcmp(pTypes->BaseName, "union") == 0 ||
             strcmp(pTypes->BaseName, "struct") == 0) {

            oType << "\n#pragma pack(" << pTypes->dwCurrentPacking 
                  << ")\n";
            if (bAddTypeName) 
              oType << pTypes->BaseName << " " << pPrepend << pTypes->TypeName;
            else
              oType << pTypes->BaseName << " ";

            if (NULL != pTypes->pmeminfo) {
               oType << "{\n";
               PMEMBERINFO pmeminfo = pTypes->pmeminfo;
               do {
                  ostringstream oMemberType("");
                  ostringstream oMemberName("");
                  PKNOWNTYPES pMemberType = pmeminfo->pkt;
                  if(pmeminfo->sName != NULL)
                     oMemberName << pmeminfo->sName;
                  if (pmeminfo->bIsArray) 
                     oMemberName << '[' << pmeminfo->ArrayElements << ']';
                  if (pmeminfo->IndLevel > 0) {
                     oMemberType << GetHostPointerName(pmeminfo->bIsPtr64);
                  }
                  else {
                     GetType(pMemberType, pPrepend, oMemberType, oMemberName, FALSE);
                     if (pmeminfo->bIsBitfield) 
                        oMemberName << " : " << pmeminfo->BitsRequired;
                  }
                  oType << oMemberType.str() << " " << oMemberName.str() << ";\n";
                  pmeminfo = pmeminfo->pmeminfoNext;
               } while(NULL != pmeminfo);
               oType << "}\n";
            }
            
            return;
         }
         else {
            pBasicType = pTypes->pTypedefBase;
            if (NULL == pBasicType) {
               oType << GetHostPointerName(pTypes->Flags & BTI_PTR64);
               return;
            }
            pTypes = pBasicType;
         }
      }
      else {
         char Buffer[MAX_PATH];
         oType << GetHostTypeName(pTypes, Buffer);
         return;
      }      
   }
}

void DumpTypesHeader(void) {
    PKNOWNTYPES pTypes; 

    cout << "///////////////////////////////////////////\n";
    cout << "// This file is autogenerated by gennt32t. \n";
    cout << "// Do not edit                             \n";
    cout << "///////////////////////////////////////////\n";
    cout << '\n' << '\n';

    cout << "#include <guiddef.h>\n\n";

    cout << "#pragma pack(push, gennt32t)\n\n";

    cout << "///////////////////////////////////////////\n";
    cout << "//  Structures                             \n";
    cout << "///////////////////////////////////////////\n";
    for(pTypes = pStructures->pLastNodeInserted; pTypes != NULL; pTypes = pTypes->Next) {
      if (pTypes->TypeName != NULL && !(pTypes->Flags & BTI_NOTDERIVED)) {
         ostringstream oType;
         ostringstream oName;
         GetType(pTypes, "NT32", oType, oName, TRUE);
         cout << "/* " << pTypes->TypeName << " */";
         cout << oType.str() << "\n";
         cout << oName.str() << ";" << "\n";
         cout << "/* End of definition for " << pTypes->TypeName << " */\n";
         cout << '\n';
      }    }
    cout << '\n' << '\n';

    cout << "///////////////////////////////////////////\n";
    cout << "//  TypeDefs                               \n";
    cout << "///////////////////////////////////////////\n";
    for(pTypes = pTypedefs->pLastNodeInserted; pTypes != NULL; pTypes = pTypes->Next) {
      if (pTypes->TypeName != NULL && !(pTypes->Flags & BTI_NOTDERIVED)) {
         ostringstream oType;
         ostringstream oName;
         oName << "NT32" << pTypes->TypeName << " ";
         GetType(pTypes, "NT32", oType, oName, FALSE);
         cout << "/* " << pTypes->TypeName << " */" << " typedef \n";
         cout << oType.str() << "\n";
         cout << oName.str() << "\n";
         cout << ";" << "\n";
         cout << "/* End of definition for " << pTypes->TypeName << " */\n";
         cout << '\n';
      }
    }
    cout << '\n' << '\n';

    cout << "#pragma pack(pop, gennt32t)\n\n";

}

int _cdecl main(int argc, char*argv[]) {
    ExtractCVMHeader(MapPpmFile(argv[1], TRUE));
    DumpTypesHeader();
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\tools\gen.h ===
/*++
                                                                                
Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    gen.h

Abstract:
    
    Types shared between the Wx86 tools
    
Author:

    ??-???-?? Unknown

Revision History:

--*/

// Increment this number whenever the format of winincs.ppm changes
#define VM_TOOL_VERSION_BASE     0x80000006

// Make the 64-bit PPM file format incompatible to prevent badness
#if _WIN64
    #define VM_TOOL_VERSION (VM_TOOL_VERSION_BASE | 0x01000000)
#else
    #define VM_TOOL_VERSION (VM_TOOL_VERSION_BASE)
#endif

// Make the compiler more struct.
#pragma warning(3:4033)   // function must return a value
//#pragma warning(3:4701)   // local may be used w/o init
#pragma warning(3:4702)   // Unreachable code
#pragma warning(3:4705)   // Statement has no effect

extern const char *ErrMsgPrefix;    // string to put in front of all error
                                    // messages so that BUILD can find them.
                                    // This is something like:
                                    // "NMAKE :  U8600: 'GENTHNK' "

struct _KnownTypesInfo;

typedef enum _TokenType {
    TK_NONE,            // 0
    TK_IDENTIFIER,      // 1
    TK_NUMBER,          // 2
    TK_PLUS,            // 3
    TK_MINUS,           // 4
    TK_STAR,            // 5
    TK_DIVIDE,          // 6
    TK_LSQUARE,         // 7
    TK_RSQUARE,         // 8
    TK_LBRACE,          // 9
    TK_RBRACE,          // a
    TK_LPAREN,          // b
    TK_RPAREN,          // c
    TK_VARGS,           // d
    TK_CONST,           // e
    TK_VOLATILE,        // f
    TK_REGISTER,        // 10
    TK_EXTERN,          // 11
    TK_CDECL,           // 12
    TK_STDCALL,         // 13
    TK_TYPEDEF,         // 14
    TK_STATIC,          // 15
    TK_COMMA,           // 16
    TK_SEMI,            // 17
    TK_STRUCT,          // 18
    TK_UNION,           // 19
    TK_ENUM,            // 1a
    TK_INLINE,          // 1b
    TK_COLON,           // 1c
    TK_ASSIGN,          // 1d
    TK_DOT,             // 1e
    TK_LSHIFT,          // 1f
    TK_RSHIFT,          // 20
    TK_LESS,            // 21
    TK_GREATER,         // 22
    TK_UNALIGNED,       // 23
    TK_DECLSPEC,        // 24
    TK_RESTRICT,        // 25
    TK_FASTCALL,        // 26
    TK_IN,              // 27
    TK_OUT,             // 28
    TK_INOUT,           // 29
    TK_BITWISE_AND,     // 30
    TK_BITWISE_OR,      // 31
    TK_LOGICAL_AND,     // 32
    TK_LOGICAL_OR,      // 33
    TK_MOD,             // 34
    TK_XOR,             // 35
    TK_NOT,             // 36
    TK_TILDE,           // 37
    TK_STRING,          // 38
    TK_SIZEOF,          // 39
    TK_TEMPLATE,        // 40
    TK___W64,           // 41
    TK_EOS              // end-of-statement
} TOKENTYPE, *PTOKENTYPE;

typedef struct _cvmheapinfo {
    ULONG_PTR uBaseAddress;
    ULONG_PTR uReserveSize;
    ULONG_PTR uRegionSize;
    ULONG_PTR uUncomitted;
    ULONG_PTR uUnReserved;
    ULONG_PTR uAvailable;
} CVMHEAPINFO;

typedef struct _memberinfo {
    struct _memberinfo *pmeminfoNext;   // ptr to next member
    DWORD dwOffset;                     // offset in structure of member
    char *sName;                        // member name
    char *sType;                        // type name
    struct _KnownTypesInfo *pkt;        // Info for this type 
    int IndLevel;                       // levels of indirection
    struct _KnownTypesInfo *pktCache;   // used by MemberTypes() in genthnk
    BOOL bIsBitfield;                   // Determines if this is a bitfield
    int BitsRequired;                   // Number of bits required for bitfield
    BOOL bIsPtr64;                      // Pointer is a 64 bit pointer
    BOOL bIsArray;                      // This member is an array
    int ArrayElements;                  // Number of elements in the array
} MEMBERINFO, *PMEMBERINFO;

typedef struct _funcinfo {
    struct _funcinfo *pfuncinfoNext;
    BOOL fIsPtr64;                  // TRUE if this is a __ptr64
    TOKENTYPE tkDirection;          // TK_IN, TK_OUT, TK_INOUT or TK_NONE
    TOKENTYPE tkPreMod;             // TK_CONST, TK_VOLATILE, or TK_NONE
    TOKENTYPE tkSUE;                // TK_STRUCT/UNION/ENUM, or TK_NONE
    char *sType;                    // name of the type
    struct _KnownTypesInfo *pkt;    // Info for this type
    TOKENTYPE tkPrePostMod;         // TK_CONST, TK_VOLATILE, or TK_NONE
    int IndLevel;                   // indirection level
    TOKENTYPE tkPostMod;            // TK_CONST, TK_VOLATILE, or TK_NONE
    char *sName;                    // name of the argment
} FUNCINFO, *PFUNCINFO;

#if _WIN64
  // The sizes must be bigger since the MEMBERINFO structs themselves are bigger
  #define FUNCMEMBERSIZE   (40*1024)  // storage for members or MEMINFO list
  #define MEMBERMETHODSSIZE  8192     // storage for names of methods
#else
  #define FUNCMEMBERSIZE   (20*1024)  // storage for members or MEMINFO list
  #define MEMBERMETHODSSIZE  4096     // storage for names of methods
#endif

typedef enum _TypeKind {
    TypeKindEmpty = 0,              // Members[] is unused
    TypeKindStruct,                 // TYPESINFO.Members is array of MEMBERINFO
    TypeKindFunc                    // TYPESINFO.Members is array of FUNCINFO
} TYPEKIND;

#define DIR_INOUT   0
#define DIR_IN      1
#define DIR_OUT     2

#define SIZEOFPOINTER   4   // standard size for 32 bit pointer
#define SIZEOFPOINTER64 8   // standard size for 64 bit pointer


// The colors
typedef enum {RED, BLACK} COL;

typedef struct _KnownTypesInfo {
     // elements used by the Red-Black tree code, along with TypeName
     struct _KnownTypesInfo *RBParent;
     struct _KnownTypesInfo *RBLeft;
     struct _KnownTypesInfo *RBRight;
     COL    RBColor;
     struct _KnownTypesInfo *Next;

     ULONG Flags;
     int   IndLevel;
     int   RetIndLevel;
     int   Size;
     int   iPackSize;
     char  *BasicType;
     char  *BaseName;
     char  *FuncRet;
     char  *FuncMod;
     char  *TypeName;
     char  *Methods;
     char  *IMethods;
     char  *BaseType;
     GUID  gGuid;
     DWORD dwVTBLSize;
     DWORD dwVTBLOffset;
     int   TypeId;    
     int   LineNumber;
     DWORD dwScopeLevel;
     struct _KnownTypesInfo *pktBase;   // a cache, used by genthnk
     struct _KnownTypesInfo *pktRet;    // a cache, used by genthnk
     int   SizeMembers; // size of Members[], in bytes
     char  *Members;
     char  *FileName;
     PMEMBERINFO pmeminfo;
     PFUNCINFO   pfuncinfo;
     DWORD dwArrayElements;
     DWORD dwBaseSize;
     struct _KnownTypesInfo *pTypedefBase;
     DWORD dwCurrentPacking;
     char  Names[1];
} KNOWNTYPES, *PKNOWNTYPES;

typedef struct _RBTree {
     PKNOWNTYPES pRoot;
     PKNOWNTYPES pLastNodeInserted;
} RBTREE, *PRBTREE;

typedef struct _DefaultBasicTypes {
     char *BasicType;
}DEFBASICTYPES, *PDEFBASICTYPES;

typedef struct _TypesInfo {
     ULONG Flags;
     int  IndLevel;                 // indirection level
     int  Size;                     // size of the type in bytes
     int  iPackSize;                // packing size
     char BasicType[MAX_PATH];
     char BaseName[MAX_PATH];
     char FuncRet[MAX_PATH];
     char FuncMod[MAX_PATH];
     char TypeName[MAX_PATH];       // typedef or struc name
     TYPEKIND TypeKind;             // how to interpret Members[] data
     PFUNCINFO pfuncinfo;           // if TypeKind==TypeKindFunc, ptr to first FUNCINFO
     int   RetIndLevel;             // if TypeKind==TypeKindFunc, indlevel of return type for function
     DWORD dwMemberSize;            // #bytes used in Members array
     char Members[FUNCMEMBERSIZE];  // stores either MEMBERINFOs or FUNCINFOs
//   Added to support automatic retrival of COM objects
//   If a class or struct is found with virtual methods, an extra VTLB member
//   is created at the top.
//   Note: a class has a VTLB if virtual methods are found or base class
//   has virtual methods
//   A type is a COM object if it is IUnknown or it derives from a COM object
     GUID gGuid;                        // Guid for this object if
     DWORD dwVTBLSize;                  // Total size of the VTBL
     DWORD dwVTBLOffset;                // Offset of VTLB from parent
     char Methods[MEMBERMETHODSSIZE];   // Names of methods
     char IMethods[MEMBERMETHODSSIZE];  // Names of methods not inherited 
     char BaseType[MAX_PATH];           // Name of the base class
//////////////////////////////////////////////////////////////////////
//   Added to support reordering of definations later
//////////////////////////////////////////////////////////////////////
     int TypeId;    //is actually a defination ID
     char FileName[MAX_PATH];
     int LineNumber;
     DWORD dwCurrentPacking;            // Packing level when structure defined
     DWORD dwScopeLevel;
     DWORD dwArrayElements;             // If this is an array, the number of elements
     DWORD dwBaseSize;                  // Base size before it is multiplied for the array
     PKNOWNTYPES pTypedefBase;
} TYPESINFO, *PTYPESINFO;

#define BTI_DLLEXPORT       1       // the function decl had __declspec(dllimport)
#define BTI_CONTAINSFUNCPTR 2       // the type contains a function pointer
#define BTI_PTR64           4       // the type is a __ptr64
#define BTI_HASGUID         8       // A guid has been found for this type
#define BTI_ISCOM           16      // This is a COM object 
#define BTI_DISCARDABLE     32      // Type is overwriteable
#define BTI_VIRTUALONLY     64      // Contains only virtual methods
#define BTI_ANONYMOUS       128     // Type is anonymous
#define BTI_POINTERDEP      256     // Type is dependent on the standard pointer size
#define BTI_NOTDERIVED      512     // Type is not derived, but a placeholder
#define BTI_ISARRAY        1024     // Element is an array
#define BTI_UNSIGNED     2048       // Used only on default derived types
                                    // Signals that the type is unsigned
#define BTI_INT64DEP     4096       // this is a 8byte integer value that 
                                    // might be union as well 

// contiguous allocation in a buffer
typedef struct _bufallocinfo {
    BYTE *pb;           // ptr to buffer pool
    DWORD dwSize;       // size of buffer pool
    DWORD dwLen;        // current length of buffer pool
} BUFALLOCINFO;

typedef struct _TokenMatch {
    TOKENTYPE Tk;
    char *MatchString;
} TOKENMATCH, *PTOKENMATCH;


extern char *TokenString[];
extern TOKENMATCH KeywordList[];

typedef struct _Token {
    TOKENTYPE TokenType;
    union _TokenName {
        char *Name;     // filled in only for TokenType==TK_IDENTIFIER or TK_STRING
        long Value;     // filled in only for TokenType==TK_NUMBER
    };
    DWORD dwValue; //unsigned version of Value
} TOKEN, *PTOKEN;

#define MAX_CHARS_IN_LINE           4096
#define MAX_TOKENS_IN_STATEMENT     4096
extern TOKEN Tokens[MAX_TOKENS_IN_STATEMENT];
extern int CurrentTokenIndex;

void
ResetLexer(
    void
    );

char *
LexOneLine(
    char *p,
    BOOL fStopAtStatement,
    BOOL *pfLexDone
    );

BOOL
UnlexToText(
    char *dest,
    int destlen,
    int StartToken,
    int EndToken
    );

void
DumpLexerOutput(
    int FirstToken
    );

void
HandlePreprocessorDirective(
    char *Line
    );

TOKENTYPE
ConsumeDirectionOpt(
    void
    );

TOKENTYPE
ConsumeConstVolatileOpt(
    void
    );

PMEMBERINFO
AllocMemInfoAndLink(
    BUFALLOCINFO *pbufallocinfo,
    PMEMBERINFO pmeminfo
    );

PFUNCINFO
AllocFuncInfoAndLink(
    BUFALLOCINFO *pbufallocinfo,
    PFUNCINFO pfuncinfo
    );

DWORD 
SizeOfMultiSz(
    char *c
    );

BOOL
CatMultiSz(
    char *dest,
    char *source,
    DWORD dwMaxSize
    );


BOOL
AppendToMultiSz(
    char *dest,
    char *source,
    DWORD dwMaxSize
    );

BOOL IsInMultiSz(
    const char *multisz,
    const char *element
    );

BOOL 
ConvertStringToGuid(
    const char *pString, 
    GUID *pGuid
    );

//
// Inline code

#define iswhitespace(c) ((c == ' ') || (c == '\t'))

//
// initialize BUFALLOCINFO structure
_inline void BufAllocInit(BUFALLOCINFO *pbufallocinfo, 
                  BYTE *pb, DWORD dwSize, DWORD dwLen)
{
    pbufallocinfo->pb = pb;
    pbufallocinfo->dwSize = dwSize;
    pbufallocinfo->dwLen = dwLen;
}

//
// allocate memory from buffer
_inline void *BufAllocate(BUFALLOCINFO *pbufallocinfo, DWORD dwLen)
{
    void *pv = NULL;        
    DWORD dwNewLen;

    // Pad to quadword alignment, like malloc does, so RISC builds don't
    // take alignment faults.
    dwLen = (dwLen+7) & ~7;

    dwNewLen = pbufallocinfo->dwLen + dwLen;
    
    if (dwNewLen < pbufallocinfo->dwSize)
    {
        pv = &pbufallocinfo->pb[pbufallocinfo->dwLen];
        pbufallocinfo->dwLen = dwNewLen;
    }
    
    return(pv);
}

//
// determine if we could allocate from buffer pool
_inline BOOL BufCanAllocate(BUFALLOCINFO *pbufallocinfo, DWORD dwLen)
{
    return( (pbufallocinfo->dwLen + dwLen) < pbufallocinfo->dwSize);
}

//
// get pointer to current free area
_inline void *BufPointer(BUFALLOCINFO *pbufallocinfo)
{
    return(&pbufallocinfo->pb[pbufallocinfo->dwLen]);
}

//
// get remaining space in buffer
_inline DWORD BufGetFreeSpace(BUFALLOCINFO *pbufallocinfo)
{
    return pbufallocinfo->dwSize - pbufallocinfo->dwLen;
}

_inline char *SkipWhiteSpace(char *s)
{
    while (iswhitespace(*s) && (*s != 0)) {
        s++;
        }
    return(s);
}

__inline void
ConsumeToken(
    void
    )
{
    if (Tokens[CurrentTokenIndex].TokenType != TK_EOS) {
        CurrentTokenIndex++;
    }
}

__inline PTOKEN
CurrentToken(
    void
    )
{
    return &Tokens[CurrentTokenIndex];
}


//
// function prototypes
char *SkipKeyWord(char *pSrc, char *pKeyWord);
BOOL IsSeparator(char ch);
BOOL IsTokenSeparator(void);
size_t  CopyToken(char *pDst, char *pSrc, size_t Size);
char *GetNextToken(char *pSrc);

void DumpKnownTypes(PKNOWNTYPES pKnownTypes, FILE *fp);
void DumpTypesInfo(PTYPESINFO pTypesInfo, FILE *fp);
void FreeTypesList(PRBTREE HeadList);

void __cdecl ErrMsg(char *pch, ...);
__declspec(noreturn)
void __cdecl ExitErrMsg(BOOL bSysError, char *pch, ...);

void __cdecl DbgPrintf(char *pch, ...);

char *ReadEntireFile(HANDLE hFile, DWORD *pBytesRead);
HANDLE CreateTempFile(VOID);

BOOL
ParseTypes(
    PRBTREE pTypesList,
    PTYPESINFO pTypesInfo,
    PKNOWNTYPES *ppKnownTypes
    );

PFUNCINFO
RelocateTypesInfo(
    char *dest,
    PTYPESINFO src
    );

void ParseIndirection(
    DWORD *pIndLevel,
    DWORD *pdwSize,
    DWORD *pFlags,
    PTOKENTYPE tkPrePostMod,
    PTOKENTYPE tkPostMod
);

PKNOWNTYPES
GetNameFromTypesList(
     PRBTREE pHeadList,
     char *pTypeName
     );

PDEFBASICTYPES
GetDefBasicType(
     char *pBasicType
     );

PKNOWNTYPES
AddToTypesList(
     PRBTREE pHeadList,
     PTYPESINFO pTypesInfo
     );

BOOL
AddOpenFile(
    char   *FileName,
    FILE   *fp,
    HANDLE hFile
    );

void
DelOpenFile(
    FILE   *fp,
    HANDLE hFile
    );

void
CloseOpenFileList(
    BOOL DeleteFiles
    );


BOOL
ConsoleControlHandler(
    DWORD dwCtrlType
    );




//
// global vars
extern char szVARGS[];
extern char szNULL[];
extern char szCONST[];
extern char szVOLATILE[];
extern char szREGISTER[];
extern char szEXTERN[];
extern char szCDECL[];
extern char sz_CDECL[];
extern char szSTDCALL[];
extern char sz__FASTCALL[];
extern char szUNALIGNED[];
extern char szTYPEDEF[];
extern char szCHAR[];
extern char szINT[];
extern char szLONG[];
extern char szSHORT[];
extern char szDOUBLE[];
extern char szENUM[];
extern char szFLOAT[];
extern char szSTRUCT[];
extern char szUNION[];
extern char szVOID[];
extern char szINT64[];
extern char sz_INT64[];
extern char szFUNC[];
extern char szSIGNED[];
extern char szUNSIGNED[];
extern char szFUNCTIONS[];
extern char szSTRUCTURES[];
extern char szTYPEDEFS[];
extern char szPragma[];
extern char szPack[];
extern char szPush[];
extern char szPop[];
extern char szSTATIC[];
extern char szUNSIGNEDCHAR[];
extern char szUNSIGNEDSHORT[];
extern char szUNSIGNEDLONG[];
extern CHAR szINOUT[];
extern CHAR szIN[];
extern CHAR szOUT[];
extern CHAR szVTBL[];
extern char szGUID[];


extern BOOLEAN bDebug;
extern BOOLEAN bExitClean;

extern PVOID (*fpTypesListMalloc)(ULONG Len);

PKNOWNTYPES GetBasicType(
            char *sTypeName,
            PRBTREE TypeDefsList,
            PRBTREE StructsList);
void ReplaceInTypesList(PKNOWNTYPES pKnownTypes, PTYPESINFO pTypesInfo);

HANDLE CreateAllocCvmHeap(ULONG_PTR uBaseAddress,
                          ULONG_PTR uReserveSize,
                          ULONG_PTR uRegionSize,
                          ULONG_PTR uUncomitted,
                          ULONG_PTR uUnReserved,
                          ULONG_PTR uAvailable);

PVOID GetCvmHeapBaseAddress(HANDLE hCvmHeap);
PVOID
AllocCvm(HANDLE hCvmHeap,
    ULONG_PTR Size
    );
void DeleteAllocCvmHeap(HANDLE hCvmHeap);

// This structure is the first thing allocated within the CvmHeap.  It contains
// the roots of all data stored within the heap.
typedef struct _CvmHeapHeader {
    ULONG Version;
    ULONG_PTR BaseAddress;
    RBTREE FuncsList;
    RBTREE StructsList;
    RBTREE TypeDefsList;
    KNOWNTYPES NIL;
} CVMHEAPHEADER, *PCVMHEAPHEADER;

PVOID GetCvmHeapAvailable(HANDLE hCvmHeap);

// from redblack.c:
VOID
RBInsert(
    PRBTREE proot,
    PKNOWNTYPES x
    );

PKNOWNTYPES
RBFind(
    PRBTREE proot,
    PVOID addr
    );

PKNOWNTYPES
RBDelete(
    PRBTREE proot,
    PKNOWNTYPES z
    );

VOID
RBInitTree(
    PRBTREE proot
    );

extern PKNOWNTYPES NIL;

//
// Use these allocators instead of malloc/free
//
PVOID GenHeapAlloc(INT_PTR Len);
void GenHeapFree(PVOID pv);

BOOL
IsDefinedPointerDependent(
    char *pName
    );

PCHAR
IsDefinedPtrToPtrDependent(
    IN char *pName
    );

BOOL
ClosePpmFile(
   BOOL bExitFailure
   );

PCVMHEAPHEADER 
MapPpmFile(
   char *sPpmfile,
   BOOL bExitFailure
   );

char *GetHostPointerName(BOOL bIsPtr64);
char *GetHostBasicTypeName(PKNOWNTYPES pkt);
char *GetHostTypeName(PKNOWNTYPES pkt, char *pBuffer);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\tools\genthnk\genthnk.c ===
/*++
                                                                                
Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    genthnk.c

Abstract:
    
    This program generates thunks.
    
Author:

    08-Jul-1995 JonLe

Revision History:

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "gen.h"

// bitfield values to indicate which platform an API should be switched in on.
#define API_NONE        0
#define API_WIN95       1
#define API_WIN98       2
#define API_NT4         4
#define API_NT5         8
#define API_WIN9x       (API_WIN95 | API_WIN98)
#define API_NTx         (API_NT4 | API_NT5)
#define API_ALL         (API_WIN9x | API_NTx)

#define API_SHIFT_WIN9x 0   // shift API bits right 0 to make Win9x leftmost
#define API_SHIFT_NTx   2   // shift API bits right 2 to make NTx leftmost

// This is the new VC6 import structure.  VC6 import lib spec is checked
// in as wx86\doc\vc6.doc.  Contact Dan Spalding or Kathleen Herold for
// more info.  Or look at sdktools\vctools\coff\deflib.h ImportHdr.
typedef struct ImgImportHdr {
    WORD    Sig1;       // always 0 (IMAGE_FILE_MACHINE_UNKNOWN)
    WORD    Sig2;       // always ffff (IMPORT_HDR_SIG2)
    WORD    Version;
    WORD    Machine;
    DWORD   TimeStamp;
    DWORD   SizeOfData; // count of bytes in strings that follow
    union {
        WORD Ordinal;
        WORD Hint;
    };

    WORD    Type : 2;   // IMPORT_TYPE
    WORD    NameType : 3; // IMPORT_NAME_TYPE
    WORD    Reserved : 11;// Reserved.  Must be 0.
} VC6_IMAGE_IMPORT_HEADER, *PVC6_IMAGE_IMPORT_HEADER; 

enum IMPORT_TYPE
{
    IMPORT_CODE = 0,
    IMPORT_DATA = 1,
    IMPORT_CONST = 2,
};

enum IMPORT_NAME_TYPE
{
    IMPORT_ORDINAL,
    IMPORT_NAME,
    IMPORT_NAME_NO_PREFIX,
    IMPORT_NAME_UNDECORATE
};
// end of VC6 import structure


// string to put in front of all error messages so that BUILD can find them.
const char *ErrMsgPrefix = "NMAKE :  U8600: 'GENTHNK' ";

// template sections types
char szIFUNC[]= "IFunc";
char szEFUNC[]= "EFunc";
char szEFAST[]= "EFast";
char szTYPES[]= "Types";
char szCODE[] = "Code";
char szFAILTYPES[] = "FailTypes";
char szMACROS[]="Macros";

// template properties
char szTEMPLENAME[]= "TemplateName";
char szMACRONAME[] = "MacroName";
char szTYPENAME[]  = "TypeName";
char szINDLEVEL[]  = "IndLevel";
char szDIRECTION[] = "Direction";
char szNUMARGS[]   = "NumArgs";
char szCGENBEG[]   = "Begin";       // default codeburst name
char szCGENEND[]   = "End";
char szUSE[]       = "Use";
char szALSO[]      = "Also";
char szNOTYPE[]    = "NoType";
char szCASE[]      = "Case";

// substitution macros
char szTEMPLATE[]="Template";
char szDLLNAME[]="DllName";
char szXPTNAME[]="XPTName";
char szDLLTARGET[]="DllTarget";
char szAPIFNRET[]="ApiFnRet";
char szAPIFNMOD[]="ApiFnMod";
char szAPINAME[]="ApiName";
char szAPINAMESKIP[]="ApiNameSkip";
char szAPIFORWARD[]="ApiForward";
char szAPINUM[]="ApiNum";
char szAPIUNKNOWN[]="ApiUnknown";
char szAPINODECL[]="ApiNoDecl";
char szFASTCALL[]="FastCall";
char szSLOWCALL[]="SlowCall";
char szFASTX2NMETH[]="FastX2NMethod";
char szSLOWX2NMETH[]="SlowX2NMethod";
char szFATX2NMETH[]="FatX2NMethod";
char szMETHODNUMBER[]="MethodNumber";
char szRETSIZE[]="RetSize";
char szUNALIGNEDTAG64[]="UnalignedTag64";
char szARGSIZE[]="ArgSize";
char szARGTYPE[]="ArgType";
char szARGHOSTTYPE[] = "ArgHostType";
char szARGTYPEIND[]="ArgTypeInd";
char szARGHOSTTYPEIND[]="ArgHostTypeInd";
char szARGNAME[]="ArgName";
char szARGNAMEHOSTCASTED[]="ArgHostName";
char szARGVAL[]="ArgVal";
char szFUNCARGNUM[]="FuncArgNum";
char szARGMOD[]="ArgMod";
char szARGPOSTMOD[]="ArgPostMod";
char szARGLIST[]="ArgList";
char szIFAPIRET[]="IfApiRet";
char szIFARGS[]="IfArgs";
char szARGMORE[]="ArgMore";
char szAPILIST[]="ApiList";
char szAPIMORE[]="ApiMore";
char szLISTCOL[]="ListCol";
char szARGLOCAL[]="ArgLocal";
char szARGOFF[]="ArgOff";
char szARGADDR[]="ArgAddr";
char szEXPORTLIST[]="ExportList";
char szEXPNAME[]= "ExpName";
char szIFEXPFORWARD[]= "IfExpForward";
char szADDRARGSLIST[]="AddrArgsList";
char szNARGTYPE[]="NArgType";
char szNARGNAME[]="NArgName";
char szIFRETTYPE[]="IfRetType";
char szIFORDINALS[]="IfOrdinals";
char szAPISTRINGS[]="ApiStrings";
char szDBGSINDEX[]="DbgsIndex";
char szDBGSLIST[]="DbgsList";
char szDBGSSTRINGS[]="DbgsStrings";
char szDBGSMORE[]="DbgsMore";
char szCPPEXPORT[]="CppExport";
char szCEXPORT[]="CExport";
char szCPPOUTPUT[]="CppOutput";
char szCOUTPUT[]="COutput";
char szAPIDECLSPEC[]="ApiDeclSpec";
char szIFAPICODE[]="IfApiCode";
char szRETTYPE[]="RetType";
char szMARG[]="MArg";
char szMEMBERTYPES[]="MemberTypes";
char szBTOTMEMBERTYPES[]="BtoTMemberTypes";
char szFORCETYPE[]="ForceType";
char szLOG[]="Log";
char szRTOLTYPES[]= "RtoLTypes";
char szIFNOTRETTYPE[]="IfNotRetType";
char szIFISMEMBER[]="IfIsMember";
char szIFNISMEMBER[]="IfNotIsMember";
char szIFISBITFIELD[]="IfIsBitfield";
char szIFNISBITFIELD[]="IfNotIsBitfield";
char szIFISARRAY[]="IfIsArray";
char szIFNISARRAY[]="IfNotIsArray";
char szARGARRAYELEMENTS[]="ArrayElements";
char szIFPOINTERTOPTRDEP[]="IfPointerToPtrDep";
char szIFNPOINTERTOPTRDEP[]="IfNotPointerToPtrDep";
char szISPOINTERTOPTRDEP[]="IsPointerToPtrDep";
char szIFPTRDEP[]="IfPtrDep";
char szIFNPTRDEP[]="IfNotPtrDep";
char szIFINT64DEPUNION[]="IfInt64DepUnion";
char szIFNINT64DEPUNION[]="IfNotInt64DepUnion";
char szNL[]="NL";
char szINDENT[]="Indent";
char szNOFORMAT[]="NoFormat";
char szALIGN[]="Align";
char szCOMMENT[]="Comment";

char szOFFSET[]="OffSet";

char szHOSTAPPEND[]="Host";

char szCARG[]="CArg";
char szCARGEXIST[]="CArgExist";
char szFORCASE[]="ForCase";
char szCNUMBER[]="CNumber";

// if support
char szIF[]="If";
char szELSE[]="Else";
char szOR[]="Or";
char szAND[]="And";
char szNOT[]="Not";

char szARGUNIONULARGEINTEGER[]="PULARGE_INTEGER";
char szARGUNIONLARGEINTEGER[]="PLARGE_INTEGER";



extern char sz__PTR64[];


#define MAX_ALSO        80
#define MAX_CODEBURST   20
#define MAX_NOTYPE      32

typedef struct tagCODEBURST {
    char *Name;
} CODEBURST;

CODEBURST CodeBursts[MAX_CODEBURST];

typedef struct _Templates{
   LIST_ENTRY   TempleEntry;
   char *Name;
   int  IndLevel;
   TOKENTYPE tkDirection;
   PKNOWNTYPES pktType;
   char *Comment;
   char *CodeBurst[MAX_CODEBURST];
   char *NoTypes[MAX_NOTYPE];
   PLIST_ENTRY pCaseList;
   char Buffer[1];
}TEMPLES, *PTEMPLES;

typedef struct _CGenerate {
   LIST_ENTRY CGenerateEntry;
   FILE *fp;
   
   FILE *fpC;
   char *FileNameC;
   char *FileBaseNameC;
   
   FILE *fpCpp;
   char *FileNameCpp;
   char *FileBaseNameCpp;
   
   char TempleName[1];
}CGENERATE, *PCGENERATE;

FILE *fpLog;    // file pointer to optional log file for @Log() calls


//
// handy macro to knock out the hi bit in implib style ordinals
//
#define IMPORDINAL(o) ((o) & ~0x80000000)

//
// Structure definining the list of arguments for a function
//
typedef struct _ArgumentsList {
   LIST_ENTRY   ArgumentsEntry;     // ptr to prev and next arg
   PKNOWNTYPES  pKnownTypes;        // type of this arg
   PKNOWNTYPES  pStructType;        // cache used by MemberTypes()
   DWORD        ArgSize;            // size of this arg
   BOOL         IsPtr64;            // TRUE if this arg is __ptr64
   int          OffSet;             // offset from stack for this arg
   int          IndLevel;           // indirection level
   TOKENTYPE    tkDirection;        // TK_NONE, TK_IN, TK_OUT, TK_INOUT
   TOKENTYPE    Mod;                // modifier (TK_CONST/VOLATILE/NONE)
   TOKENTYPE    SUEOpt;             // TK_STRUCT/ENUM/UNION/NONE
   char         *Type;              // typename for this arg
   TOKENTYPE    PostMod;            // modifier (TK_CONST/VOLATILE/NONE)
   TOKENTYPE    PrePostMod;         // modifier (TK_CONST/VOLATILE/NONE)
   char          *Name;              // argument name (may be a nonameX)
   char         *ArgLocal;          // name of local var containing copy of arg
   char         *HostCastedName;    // Contains full name of struct member with 
                                    // host casts or NULL
   BOOL         fRequiresThunk;     // TRUE if arg type contains a nested
                                    //  function pointer (and hence needs
                                    //  special thunking)
   BOOL         fNoType;            // TRUE if types templates should *not*
                                    //  be expanded for this param.
   BOOL         fIsMember;          // This arg is actually a member of an array
   BOOL         bIsBitfield;        // Determines if this is a bitfield
   int          BitsRequired;       // Number of bits required for bitfield
   BOOL         bIsArray;           // This member is an array
   int          ArrayElements;      // Number of elements in the array
} ARGSLIST, *PARGSLIST;

//
// Structure containing the list of macro arguments
//
typedef struct _MacroArgsList {
    int  NumArgs;
    LPSTR ArgText[1];
} MACROARGSLIST, *PMACROARGSLIST;

typedef struct _MLListEntry {
   LIST_ENTRY ListEntry;
   PMACROARGSLIST pMArgs;
} MLLISTENTRY, *PMLLISTENTRY;

#define MAX_MACRO_STACK     20
PMACROARGSLIST MacroStack[MAX_MACRO_STACK];
int MacroStackTop;


//
// This defines the first method number that would not be supported as a
// fast or slow method call. If this is to be changed then FastN2X and SlowN2X
// worker routines need to be addeed in whole32.dll
#define MAXFASTN2XMETHODNUMBER  16

//
// This defines the maximum number of parameters that are allowed to be in a
// FastX2N or SlowX2N method call. To change it new code would have to be
// added to FastX2N and SlowX2N in whole32\methods.c to deal with the 
// additional number of parameters.
#define MAXX2NPARAMETERS        10

typedef enum {
    UNKNOWNMETHOD = 0,
    FATX2NMETHOD = 1,
    FASTX2NMETHOD = 2,
    SLOWX2NMETHOD = 3
} METHODTYPE;

typedef struct _ExportDebugInfo {
   LIST_ENTRY  ExportsDbgEntry;
   LIST_ENTRY  ArgsListHead;
   struct _ExportDebugInfo  *IntForward;
   int         ArgsSize;
   ULONG       Function;
   char       *ExtForward;
   char       *ExportName;
   char       *CplusDecoration;
   ULONG       Ordinal;

   // 0 = known fn, -1 incomplete declaration, 1 no declaration
   char        UnKnownApi;
   BOOLEAN     Data;
   BOOLEAN     PrivateNamed;
   CHAR        FastCall;
   BYTE        ApiPlatform;     // the API_ bit collection
   METHODTYPE  X2NMethodType;
   ULONG       MethodNumber;
   char        Buffer[1];
}EXPORTSDEBUG, *PEXPORTSDEBUG;

typedef struct _DebugStringsList {
   LIST_ENTRY  DebugStringsEntry;
   char *Name;
   char *ArgFormat;
   char *RetFormat;
   char Buffer[1];
} DEBUGSTRINGS, *PDEBUGSTRINGS;

typedef struct _CGenerateState {
   PEXPORTSDEBUG  ExportsDbg;
   PDEBUGSTRINGS  DebugStrings;
   PCGENERATE     CGen;
   PTEMPLES       Temple;       // template for this func (may be IFunc or EFunc)
   PKNOWNTYPES    ApiTypes;
   int            ApiNum;
   PARGSLIST      pArgsList;
   int            ListCol;
   BOOLEAN        MoreApis;
   BOOLEAN        ExTemplate;   // true if Temp is an EFunc template with a 'Begin='
   PTEMPLES       TempleEx;     // EFunc for this API (if there is one)
   int            CodeBurstIndex;
   PTEMPLES       CurrentTemple; // This is the template that is currently being expanded.
   PMACROARGSLIST pMacroArgsList;
   PCHAR          *MemberNoType; // Additional set of notypes to applyPMACROARGSLIST pMacroArgsList;
   int            CaseNumber;  // Number of the current Case being expanded.
   PLIST_ENTRY    pCaseList;
   PMACROARGSLIST pCaseArgsList;
} CGENSTATE, *PCGENSTATE;

int BeginCBI;       // CodeBurstIndex for 'Begin='

PKNOWNTYPES NIL;    // for red-black trees
PRBTREE FuncsList;
PRBTREE TypeDefsList;
PRBTREE StructsList;

RBTREE FakeFuncsList;
LIST_ENTRY TypeTempleList;
LIST_ENTRY FailTempleList;
LIST_ENTRY IFuncTempleList;
LIST_ENTRY EFuncTempleList;
LIST_ENTRY EFastTempleList;
LIST_ENTRY CodeTempleList;
LIST_ENTRY CGenerateList;
LIST_ENTRY ExportsList;
LIST_ENTRY DebugStringsList;
LIST_ENTRY MacroList;
ULONG NumDebugStringsEntries;

BOOL MapViewDll(char *DllName);
char DllName[MAX_PATH+1]= "";
char ExplicitDllBaseName[MAX_PATH+1] = "UNSPECIFIED";
char *DllBaseName = ExplicitDllBaseName;
PVOID DllMappedBase = NULL;
ULONG_PTR DllRvaOffset;
PULONG DllFunctions = NULL;
PUSHORT DllNameOrdinals = NULL;
PULONG DllNameTable = NULL;
ULONG DllExportDirSize;
PIMAGE_EXPORT_DIRECTORY DllExportDir;

BOOL MapViewImplib(char *ImplibName);
char ImplibName[MAX_PATH+1]="";
char *ImplibBaseName = NULL;
PVOID ImplibMappedBase= NULL;
ULONG ImplibNumSymbols=0;
PULONG ImplibSymbolMembers=NULL;
PCHAR ImplibSymbolNames=NULL;
char szIMPPREFIX[]="__imp_";
char szIDATA5[]=".idata$5";
char szTEXT[]=".text";

char szINTFORWARD[]="_IntForward_";

char XptName[MAX_PATH+1]= "";
char *XptBaseName = NULL;

// these are used to report errors while parsing .tpl files
char *TemplateFileName;
int TemplateLine;

char iHandleCpp = 0; // if == 0, Don't use CPP macros,  and warn if CPP exports found
                     // if < 0, Don't use CPP macros, no warn if CPP exports found
                     // if > 0, Use CPP macros.

BOOL bNoFuzzyLogic;
BOOL bUseExpListAndImplib;
BOOL bWarnAboutNestedFuncPtrs;
BOOL bUseDirection = TRUE;
BOOL bStripNewline = TRUE;

int OutputColumn = 0;
int IndentLevel = 0;
BOOL bFirstCharHit = FALSE;
#define INDENTSIZE 4

void SetInternalForwards(void);
BOOL ExtractXpt(char *XptName, char *DllName);
BOOL ExtractExports(void);
BOOL ExtractPpm(char *FileName);
BOOL ExtractTemples(char *FileName);
BOOL ExtractCGenerate(char *pNames);
BOOL ExtractImplib(char *LibName);


char *CopyField(char *pDst, char *pSrc, int Len, char Sep);
void DumpTemplate(PTEMPLES ptpl, FILE *fp);
PTEMPLES GetTemplate(PLIST_ENTRY pHeadList, char *TempleName);
char *CGenerate(char *pSrc, PCGENSTATE pCGenState);
char *CGenerateEx(char *pSrc, PCGENSTATE pCGenState, char *OutBuffer, SIZE_T MaxLen, SIZE_T *BytesReturned);
char *ListApis(char *pSrc, PCGENSTATE pCGenState, BOOL bExports);
char *ListArgs(char *pSrc, PCGENSTATE pCGenState, BOOL Always);
void ProcessTemple(PCGENSTATE pCGenState);
char *IncludeTemplate(char *pSrc, PCGENSTATE pCGenState);
char *IncludeTypes(char *pSrc, PCGENSTATE pCGenState, BOOL bRtoL);
char *MemberTypes(char *pSrc, PCGENSTATE pCGenState, BOOL bBtoT);
char *IfNotRetType(char *pSrc, PCGENSTATE pCGenState);
char *IncludeRetType(char *pSrc, PCGENSTATE pCGenState);
char *WriteMore(char *pSrc, PCGENSTATE pCGenState, BOOL bMore);
BOOL AddToExportsList(PEXPORTSDEBUG pExportsDebug);
PEXPORTSDEBUG FindInExportsList(char *Name);
char *SkipSubExpression(char *pSrc, char **pSubExpression);
PKNOWNTYPES BuildFakeTypesInfo(PEXPORTSDEBUG pExportsDbg, PKNOWNTYPES pKnownTypes);
void WriteListColumn(PCGENSTATE pCGenState);
char *GetAltExportName(char *Buffer, PCGENSTATE pCGenState, int Len);
void BuildArgsList(PTEMPLES pTempleEx, PFUNCINFO funcinfo, PLIST_ENTRY pListHead);
char *IfApiRet(char *pSrc, PCGENSTATE pCGenState);
char *IfApiCode(char *pSrc, PCGENSTATE pCGenState);
char *IfRetType(char *pSrc, PCGENSTATE pCGenState);
char *IfArgs(char *pSrc, PCGENSTATE pCGenState);
void ApiStrings(PCGENSTATE pCGenState);
int GetFuncArgNum(PCGENSTATE pCGenState);
int GetFuncIndex(PCGENSTATE pCGenState, char *FuncTypeName);
char *ListDbgs(char *pSrc, PCGENSTATE pCGenState);
void WriteDbgsStrings(char *pSrc, PCGENSTATE pCGenState);
int GetRetSize(PCGENSTATE pCGenState);
int GetArgSize(PEXPORTSDEBUG ExportDebug);
char *GetOffSet(char *pSrc, char *Buffer);
char *LexMacroArgs(char *pch);
PLIST_ENTRY ListFromTempleType(char *TempleType);
void UseLogMacros(char *pLogName);
char *UpdateLog(char *pSrc, PCGENSTATE pCGenState);
BOOL IsPointerToPtrDep(PARGSLIST pArgsList);
char* ForceTypeExpand( char *pSrc, PCGENSTATE pCGenState);
VOID SetArgListToTypeForArg(PARGSLIST pArgsList, PARGSLIST pArgsListOld, char * pTypeName);

BOOLEAN
IsFastCall(
     PCGENSTATE pCGenState
     );

METHODTYPE
GetX2NMethodType(
     PCGENSTATE pCGenState
     );



char *
GetAddrFirstArg(
      PCGENSTATE pCGenState,
      char *Buffer,
      int BuffLen
      );

PKNOWNTYPES
IsSameType(
     PKNOWNTYPES pktArgs,
     int IndLevel,
     TOKENTYPE tkArgDirection,
     char *tplTypeName,
     int tplIndLevel,
     TOKENTYPE tkTypeDirection,
     BOOL bScanBaseTypes
     );

char *
WriteArgAddr(
      char *pSrc,
      PCGENSTATE pCGenState,
      char *Buffer,
      int BuffLen
      );

BOOL
WriteArgLocal(
       PCGENSTATE pCGenState,
       char *Buffer,
       int BuffLen
       );

BOOL
AddTemple(
    char *TempleType,
    char *TempleName,
    char *Comment,
    char *IndLevel,
    char *pCCode[MAX_CODEBURST],
    TOKENTYPE tkDirection,
    char *Also[MAX_ALSO],
    int AlsoCount,
    char *NoType[MAX_NOTYPE],
    int NoTypeCount,
    PLIST_ENTRY pCaseList
    );


int
GetCodeBurstIndex(
    char *BurstName
    );

int
GetExistingCodeBurstIndex(
    char *BurstName
    );

BOOLEAN
ExpandMacro(
    char *MacroName,
    PCGENSTATE pCGenState,
    char **ppIn,
    char *OutBuffer,
    SIZE_T MaxLen,
    SIZE_T *BytesReturned
    );

BOOLEAN
TempleHasNoCodeBursts(
    PTEMPLES pTemple
    );

void
PlatformSwitchStart(
    PCGENSTATE pCGenState,
    BYTE ApiPlatform
    );

void
PlatformSwitchEnd(
    PCGENSTATE pCGenState,
    BYTE ApiPlatform
    );

void
PlatformSwitchEndTable(
    PCGENSTATE pCGenState,
    BYTE ApiPlatform
    );

char *
ExtractBoolean1(
    char *pSrc, 
    PCGENSTATE pCGenState,
    BOOLEAN *result
    );

char *
ExtractBoolean2(
    char *pSrc, 
    PCGENSTATE pCGenState,
    BOOLEAN *result1,
    BOOLEAN *result2
    );

void
WriteBoolean (
    char *pSrc,
    BOOL Value  
    );


char *CPlatformSwitches[] = { "",
                              "(%s==0x0400)",
                              "(%s>0x0400)",
                              "(%s>=0x0400)" };
char *AsmPlatformSwitches[] = { "",
                                "(%s_ASM EQ 0400h)",
                                "(%s_ASM GT 0400h)",
                                "(%s_ASM GE 0400h)" };

BOOL
ExpandTemple(PTEMPLES ptpl,
             int CodeBurstIndex,
             PCGENSTATE pCGenState) 
{

   PLIST_ENTRY pOldCaseList;
   PTEMPLES    pOldCurrentTemple;
   char *pSrc = ptpl->CodeBurst[CodeBurstIndex];

   if (NULL == pSrc) {
      return FALSE;
   }  
 
   pSrc = ptpl->CodeBurst[CodeBurstIndex];
      
   while (*pSrc && !isgraph(*pSrc)) {
       pSrc++;
   }
   
   if ('\0' == *pSrc) {
       return FALSE;
   }
      
   //
   // Expand the type here

   pOldCurrentTemple = pCGenState->CurrentTemple;
   pOldCaseList = pCGenState->pCaseList;

   if(ptpl->pCaseList != NULL &&
      !IsListEmpty(ptpl->pCaseList)) {
           
       pCGenState->pCaseList = ptpl->pCaseList;
   }

   pCGenState->CurrentTemple = ptpl;
   CGenerate(pSrc, pCGenState);

   pCGenState->CurrentTemple = pOldCurrentTemple;
   pCGenState->pCaseList = pOldCaseList;

   return TRUE;

}

PVOID CheckHeapAlloc(SIZE_T Size) {
   PVOID pMem;

   pMem = GenHeapAlloc(Size);
   if(NULL == pMem) {
       DbgPrintf("Error: Out of Memory!\n");
       DebugBreak();
       ExitErrMsg(FALSE, "Error: Out of Memory!\n");
   }
   return pMem;
}

typedef struct _StringListEntry {
    LIST_ENTRY ListEntry;
    PSTR pStr;
} STRINGLISTENTRY, *PSTRINGLISTENTRY;

VOID
FreeMacroArgsList(PMACROARGSLIST pArgs) {
   SIZE_T c;
   for(c=0; c < (SIZE_T)pArgs->NumArgs; c++) {
      GenHeapFree(pArgs->ArgText[c]);
   }
   GenHeapFree(pArgs);
}

char *
CArg(
    char *pSrc,
    PCGENSTATE pCGenState,
    PSTR *pBuffer,
    BOOL TestExistOnly
    )
{
    int i;
    int ArgNum;
    CHAR s[MAX_PATH];
    PCHAR pResult;
    PMACROARGSLIST pList = pCGenState->pCaseArgsList;
    PCHAR pCommandName = TestExistOnly ? szCARGEXIST : szCARG;

    if (!pList) {
        ExitErrMsg(FALSE, "%s(%d) %s unexpected: no case is currently being applied\n", 
                   TemplateFileName, TemplateLine, pCommandName);
    }

    if (*pSrc != '(') {
        ExitErrMsg(FALSE, "%s(%d) %s Incorrect parameter %s\n", 
                   TemplateFileName, TemplateLine, pCommandName, pSrc);
    }

    pSrc++;
    i = 0;
    while ((*pSrc != ')') && (i < sizeof(s)-1)) {
        s[i++] = *pSrc++;
    }
    s[i] = 0;
    ArgNum = atoi(s);
    pSrc++;     // skip ')'

    if (ArgNum-- == 0) {
        ExitErrMsg(FALSE, "%s(%d) Invalid %s parameter %s\n", TemplateFileName, TemplateLine, 
                   pCommandName, s);
    }

    if (TestExistOnly) {
       pResult = (ArgNum >= pList->NumArgs) ? "0" : "1";  
    }
    else {
        if (ArgNum >= pList->NumArgs) { 
            ExitErrMsg(FALSE, "%s(%d) Case only has %d arguments\n", TemplateFileName, TemplateLine, pList->NumArgs);
        }
        pResult = pList->ArgText[ArgNum];
    }
    if (pBuffer != NULL) {
        *pBuffer = pResult;
    }
    else {
        CGenerate(pResult, pCGenState);
    }
    return pSrc;
}

char *ForCase(char *pSrc, PCGENSTATE pCGenState) {

   PMACROARGSLIST pCaseArgsListOld;
   PLIST_ENTRY pHead, pThis;
   char *pch;
   char *pExpression;
   int OldCaseNumber;

   // Are any cases available for application
   if (pCGenState->pCaseList == NULL ||
       (pCGenState->pCaseList != NULL && IsListEmpty(pCGenState->pCaseList))) {
      //Do nothing
      return SkipSubExpression(pSrc, NULL);
   }

   pch = SkipSubExpression(pSrc, &pExpression);
   if (pSrc == pch || !pExpression) {
      return pch;
   }
   pSrc = pch;
   
   pCaseArgsListOld = pCGenState->pCaseArgsList;
   pHead = pCGenState->pCaseList;
   pThis = pHead->Flink;
   OldCaseNumber = pCGenState->CaseNumber;
   pCGenState->CaseNumber = 0;
   do {
      pCGenState->pCaseArgsList = CONTAINING_RECORD(pThis,MLLISTENTRY,ListEntry)->pMArgs;
      CGenerate(pExpression, pCGenState);
      pThis = pThis->Flink;
      pCGenState->CaseNumber++;
   } while (pThis != pHead );
   pCGenState->CaseNumber = OldCaseNumber;
   pCGenState->pCaseArgsList = pCaseArgsListOld;

   return pSrc;
}

PCHAR 
ParseMacroArgs(IN PCHAR pch,
               IN SIZE_T maxlen,
               OUT PMACROARGSLIST *ppMArgsList
               )
{
   PMACROARGSLIST pMArgsList = NULL;
   LIST_ENTRY ArgsList;
   PCHAR pl;
   int ArgCount=0;
   int ParenDepth=0;
   SIZE_T len = 0;

   if (maxlen == 0) {
      len = MAXUINT_PTR;
   }

   InitializeListHead(&ArgsList);

   if (*pch != '(') {
      ExitErrMsg(FALSE, "ParseMacroArgs: Expected to find ( for args list\n");
   }

   pch++;
   ParenDepth++;
   len++;

   while(ParenDepth > 0) {
      
      pl = pch;

      while(1) {
         if('\0' == *pl || len > maxlen) {
            ExitErrMsg(FALSE, "ParseMacroArgs: Unmatched paren for args list\n");
         }

         if (*pl == '(') {
            ParenDepth++;
         }

         else if (*pl == ')') {
            ParenDepth--;
         }

         if (ParenDepth == 0 || 
             (ParenDepth == 1 && *pl == ',')) {
            PSTRINGLISTENTRY pSl;
            pSl = CheckHeapAlloc(sizeof(STRINGLISTENTRY));
            pSl->pStr = CheckHeapAlloc(pl - pch + 1);
            memcpy(pSl->pStr, pch, pl - pch);
            pSl->pStr[pl - pch] = '\0';
            InsertTailList(&ArgsList, &(pSl->ListEntry));

            ArgCount++;
            pch = pl + 1;
            if (ParenDepth == 0) {
               // No more arguments
               goto Exit;
            }
            else {
               // Do next argument
               break;
            }
         }

         pl++;

      }

   }
Exit:
   pMArgsList = CheckHeapAlloc(sizeof(MACROARGSLIST) + sizeof(LPSTR) * ArgCount);
   pMArgsList->NumArgs = ArgCount;
   for(ArgCount = 0; ArgCount < pMArgsList->NumArgs; ArgCount++) {
      PSTRINGLISTENTRY pSl;
     
      pSl = CONTAINING_RECORD(ArgsList.Flink,STRINGLISTENTRY,ListEntry);
      RemoveHeadList(&ArgsList);

      pMArgsList->ArgText[ArgCount] = pSl->pStr;
      GenHeapFree(pSl);
   }

   *ppMArgsList = pMArgsList;
   return pch;
}

void ExtractServicesTab(char *pch);
/* main
 *
 * standard win32 base windows entry point
 * returns 0 for clean exit, otherwise nonzero for error
 *
 *
 * ExitCode:
 *  0       - Clean exit with no Errors
 *  nonzero - error ocurred
 *
 */
int __cdecl main(int argc, char **argv)
{
   int   i;
   DWORD dw;
   char *pch;
   CGENSTATE CGenState;
   PLIST_ENTRY Next;
   BOOL bUseServicesTab = FALSE;

   // init the lists
   InitializeListHead(&TypeTempleList);
   InitializeListHead(&FailTempleList);
   InitializeListHead(&CodeTempleList);
   InitializeListHead(&IFuncTempleList);
   InitializeListHead(&EFuncTempleList);
   InitializeListHead(&EFastTempleList);
   InitializeListHead(&CGenerateList);
   InitializeListHead(&ExportsList);
   InitializeListHead(&DebugStringsList);
   InitializeListHead(&MacroList);
   NumDebugStringsEntries = 0;
   BeginCBI = GetCodeBurstIndex(szCGENBEG);    // Preload 'Begin=' as a valid codeburst


   SetConsoleCtrlHandler(ConsoleControlHandler, TRUE);


   /*try*/ {


       /*
        *  Get cmd line args.
        */
       i = 0;
       while (++i < argc)  {
            pch = argv[i];
            if (*pch == '-' || *pch == '/') {
                pch++;
                switch (toupper(*pch)) {
                   case 'D':
                      bDebug = TRUE;
                      setvbuf(stderr, NULL, _IONBF, 0);
                      break;

                   case 'F':
                      bExitClean = FALSE;
                      break;
                     
                   case 'T':  // template file name
                      if (!ExtractTemples(pch+1)) {
                          ExitErrMsg(FALSE, "ExtractTemples failed %s\n", pch);
                          }

                      break;

                   case 'C':  //cgenerate "-cOutputFileName[,CppOutputFileName]:TemplateName"
                      if (!ExtractCGenerate(pch+1)) {
                          ExitErrMsg(FALSE, "ExtractCGenerate failed %s\n", pch);
                          }

                      break;

                   case 'M':   // ppm file name (only 1 expected!)
                      if (FuncsList) {
                          ExitErrMsg(FALSE, "ExtractPpm only one Ppm file allowed %s\n", pch);
                          }

                      if (!ExtractPpm(pch+1)) {
                          ExitErrMsg(FALSE, "ExtractPpm failed %s\n", pch);
                          }

                      break;
                   case 'S':   //use a services.tab instead of an exports list
                      bUseServicesTab = TRUE;
                      ExtractServicesTab(pch+1);
                      break;
                   case 'E':   // xpt list for exports "-eExportListName"
                      dw = GetFullPathName(pch+1,
                                           sizeof(XptName) - 1,
                                           XptName,
                                           &XptBaseName
                                           );
                      if (!dw || dw >= sizeof(XptName) - 1) {
                          ExitErrMsg(FALSE, "Invalid XptName %s\n", pch);
                          }

                      break;

                   case 'X':  // Enable exports from implib, -eXptName assumed
                      bUseExpListAndImplib = TRUE;
                      break;

                   case 'I':   // implib file name "-iImplibName"
                      dw = GetFullPathName(pch+1,
                                           sizeof(ImplibName) - 1,
                                           ImplibName,
                                           &ImplibBaseName
                                           );
                      if (!dw || dw >= sizeof(ImplibName) - 1) {
                          ExitErrMsg(FALSE, "Invalid Import Library Name %s\n", pch);
                          }
                      break;

                   case 'L':   // Disable fuzzy logic symbol name matching
                      bNoFuzzyLogic = TRUE;
                      break;

                   case 'W':   // warn about unthunked structures containing function ptrs
                      bWarnAboutNestedFuncPtrs = TRUE;
                      break;

                   case 'U':   // [U]se direction information (__in, __out)
                      bUseDirection = FALSE;    // turn it off
                      break;

                   case 'K':    // generate chec[K] file from @Log() macros
                      UseLogMacros(pch+1);
                      break;

                   case 'N':    // specify explicit DLL base name
                      strncpy(DllBaseName, pch+1, MAX_PATH);
                      break;

                   default:
                      ExitErrMsg(FALSE, "Unrecognized option %s\n", pch);
                   }
                }
            else if (*pch) {

                dw = GetFullPathName(pch,
                                    sizeof(DllName) - 1,
                                    DllName,
                                    &DllBaseName
                                    );
                if (!dw || dw >= sizeof(DllName) - 1) {
                     ExitErrMsg(FALSE, "Invalid DllName %s\n", pch);
                     }

                }
            }

       if(!bUseServicesTab) {

         //
         // MapView of importlib and dll into memory and
         // set up global variables for easy access
         //

         if (ImplibName[0]) {
            if (!MapViewImplib(ImplibName)) {
                  ExitErrMsg(FALSE, "Couldn't open import lib '%s'\n", ImplibName);
            }
         }

         if (DllName[0]) {
            if (!MapViewDll(DllName)) {
               ExitErrMsg(FALSE, "Couldn't open DLL '%s'\n", DllName);
            }
         }



         //
         // Extract exports using dll and implib.
         //

         if (DllName[0] && (!XptName[0] || bUseExpListAndImplib)) {

           // Insist that we have both an implib and a dll.
           if ((DllName[0] && !ImplibName[0]) || (ImplibName[0] && !DllName[0])) {
                ExitErrMsg(FALSE, "DllName or ImplibName missing\n");
           }

           if (!ExtractExports()) {
               ExitErrMsg(FALSE, "Failed to get exports for <%s>\n", DllName);
           }

         }

         //
         // Extract exports from the api list
         //

         if (XptName[0]) {
            if (!ExtractXpt(XptName, DllName)) {
               ExitErrMsg(FALSE, "Failed to get exports for <%s>\n", XptName);
            }
         }
       }

       //
       // Set Internal forwards.
       //
       SetInternalForwards();


       Next = CGenerateList.Flink;
       while (Next != &CGenerateList) {

           memset(&CGenState, 0, sizeof(CGenState));

           CGenState.CGen = CONTAINING_RECORD(Next,CGENERATE,CGenerateEntry);

           ProcessTemple(&CGenState);

           DelOpenFile(CGenState.CGen->fp, NULL);
           fclose(CGenState.CGen->fp);

           Next= Next->Flink;
           }
       }
     /*except(EXCEPTION_EXECUTE_HANDLER) {
       ExitErrMsg(FALSE,
                  "ExceptionCode=%x\n",
                  GetExceptionCode()
                  );
       }*/

   CloseOpenFileList(FALSE);
   return 0;
}


int
GetCodeBurstIndex(
    char *BurstName
    )
/*++

Routine Description:

    Given a name of a 'foo='  (ie. "foo"), return its index in the array
    of codebursts.  If there is no 'foo=' on file, add it.

Arguments:

    BurstName   - name of codeburst to get/add.

Return Value:

    Index into template->CodeBursts[], or calls ExitErrMsg() on error.

--*/
{
    int i;
    int FirstFree = -1;

    if (strcmp(BurstName, "CGenBegin") == 0) {
        // Compatibility:  Accept 'CGenBegin' as 'Begin'
        return BeginCBI;
    }

    for (i=0; i<MAX_CODEBURST; ++i) {
        if (CodeBursts[i].Name) {
            if (strcmp(BurstName, CodeBursts[i].Name) == 0) {
                return i;
            }
        } else {
            if (FirstFree == -1) {
                FirstFree = i;
            }
        }
    }

    if (FirstFree == -1) {
        if (TemplateFileName) {
            ExitErrMsg(FALSE,
                   "%s(%d) Cannot specify more than %d unique codeburst names (%s)",
                   TemplateFileName, TemplateLine,
                   MAX_CODEBURST, BurstName
                  );
        } else {
            ExitErrMsg(FALSE,
                   "Cannot specify more than %d unique codeburst names (%s)",
                   MAX_CODEBURST, BurstName
                  );
        }
    }

    i = strlen(BurstName)+1;

    CodeBursts[FirstFree].Name = GenHeapAlloc(i);
    if (!CodeBursts[FirstFree].Name) {
        ExitErrMsg(TRUE, "Out of memory in GetCodeBurstIndex");
    }
    memcpy(CodeBursts[FirstFree].Name, BurstName, i);

    return FirstFree;
}


int
GetExistingCodeBurstIndex(
    char *BurstName
    )
/*++

Routine Description:

    Given a name of a 'foo='  (ie. "foo"), return its index in the array
    of codebursts.  If there is no 'foo=' on file, call ExitErrMsg().

Arguments:

    BurstName   - name of codeburst to get.

Return Value:

    Index into template->CodeBursts[], or -1 on error.

--*/
{
    int i;

    if (strcmp(BurstName, "CGenBegin") == 0) {
        // Compatibility:  Accept 'CGenBegin' as 'Begin'
        return BeginCBI;
    }

    for (i=0; i<MAX_CODEBURST; ++i) {
        if (CodeBursts[i].Name) {
            if (strcmp(BurstName, CodeBursts[i].Name) == 0) {
                return i;
            }
        }
    }

    return -1;
}


PKNOWNTYPES
GetApiTypes(
    PEXPORTSDEBUG ExportsDbg
    )
{
    PKNOWNTYPES ApiTypes;
    char *ExpName;
    char *pch;

    ExpName = ExportsDbg->IntForward ? ExportsDbg->IntForward->ExportName
                                     : ExportsDbg->ExportName;


    //
    // Look in the FakeFuncsLIst, and the FuncsList.
    //

    ApiTypes = GetNameFromTypesList(&FakeFuncsList, ExpName);
    if (!ApiTypes) {
        ApiTypes = GetNameFromTypesList(FuncsList, ExpName);
        }


    //
    // If export is a decorated name then lets see if we have
    // a func that matches the undecorated name
    //

    if (!ApiTypes) {
        pch = strchr(ExpName, '@');
        if (pch) {
            *pch = '\0';
            ApiTypes = GetNameFromTypesList(&FakeFuncsList, ExpName);
            if (!ApiTypes) {
                ApiTypes = GetNameFromTypesList(FuncsList, ExpName);
                }
            *pch = '@';
            }
        }

    if (!ApiTypes && ExportsDbg->Data) {
        ApiTypes = GetNameFromTypesList(TypeDefsList, "PVOID");
        }

    else
    {

        if (!ApiTypes || !ApiTypes->pfuncinfo) {
            ApiTypes = BuildFakeTypesInfo(ExportsDbg, ApiTypes);
            }

        if (!ApiTypes->pktRet) {
            // Get KnownTypes info for Return Type
            PKNOWNTYPES pkt;

            ResetLexer();
            LexMacroArgs(ApiTypes->FuncRet);
            ConsumeConstVolatileOpt();

            if (ParseTypes(TypeDefsList, NULL, &pkt) == FALSE) {
                CurrentTokenIndex = 0;
                if (ParseTypes(StructsList, NULL, &pkt) == FALSE ) {
                    ExitErrMsg(FALSE, "GetApiTypes: Undefined return type %s\n", ApiTypes->FuncRet);
                }
            }
            ApiTypes->pktRet = pkt;
        }
    }

    return ApiTypes;

}






/*
 * ProcessTemple
 */
void ProcessTemple(PCGENSTATE pCGenState)
{
    PLIST_ENTRY Next;
    PTEMPLES pTemple;
    PTEMPLES pTempleEx;
    int i;

    pTemple = GetTemplate(&CodeTempleList, pCGenState->CGen->TempleName);
    if (pTemple) {
        fprintf(pCGenState->CGen->fp,
                "%s CodeTemplate:%s\n",
                pTemple->Comment,
                pTemple->Name
                );
        pCGenState->Temple = pTemple;
        ExpandTemple(pCGenState->Temple, pCGenState->CodeBurstIndex, pCGenState); 
    } else if (pTemple = GetTemplate(&IFuncTempleList,
                                    pCGenState->CGen->TempleName
                                    )) {
        pCGenState->ApiNum = 0;
        Next = ExportsList.Flink;
        while (Next != &ExportsList) {
            BYTE ApiPlatform;

            pCGenState->ExportsDbg = CONTAINING_RECORD(Next,
                                                       EXPORTSDEBUG,
                                                       ExportsDbgEntry
                                                       );

            //
            // Switch this API in or out depending on the platform info
            //
            ApiPlatform = pCGenState->ExportsDbg->ApiPlatform;
            pCGenState->Temple = pTemple;
            PlatformSwitchStart(pCGenState, ApiPlatform);

            pCGenState->ApiTypes = GetApiTypes(pCGenState->ExportsDbg);

            //
            // Use exception template for this api if there is one
            //
            pTempleEx = GetTemplate(&EFuncTempleList,
                                    pCGenState->ExportsDbg->ExportName
                                    );
            pCGenState->TempleEx = pTempleEx;
            if (pTempleEx) {
                pCGenState->ExTemplate = TRUE;
            } else {
                pCGenState->ExTemplate = FALSE;
            }

            if (pTempleEx && (pTempleEx->CodeBurst[BeginCBI] || TempleHasNoCodeBursts(pTempleEx))) {

                pCGenState->Temple = pTempleEx;
                fprintf(pCGenState->CGen->fp,
                        "%s Func Template:%s\n",
                        pTempleEx->Comment,
                        pTempleEx->Name
                        );

                 if (TempleHasNoCodeBursts(pTempleEx)) {
                    // skip this API:  ex template, but not code at all
                    fprintf(pCGenState->CGen->fp,
                             "%s *** WARNING *** Excluded Api %s\n",
                            pCGenState->Temple->Comment,
                            pCGenState->ExportsDbg->ExportName
                            );
                    goto SkipGen;
                }
            } else {
                // no ex template

                pCGenState->Temple = pTemple;

                if (pCGenState->ExportsDbg->Data) {
                    // DATA export - skip the API
                    fprintf(pCGenState->CGen->fp,
                             "%s *** WARNING *** Excluded Data Export %s\n",
                            pCGenState->Temple->Comment,
                            pCGenState->ExportsDbg->ExportName
                            );
                    goto SkipGen;
                } else if (!pCGenState->ApiTypes->pfuncinfo) {
                    // members unknown - skip the API
                    ExitErrMsg(FALSE, 
                               "API %s has no function prototype - unable to generate code.", 
                               pCGenState->ExportsDbg->ExportName
                              );
                } else if (!iHandleCpp && pCGenState->ExportsDbg->CplusDecoration) {
                    // CPP export and we aren't set up for CPP exports
                    fprintf(pCGenState->CGen->fp,
                             "%s *** WARNING *** Excluding CPP Api: %s\n",
                            pCGenState->Temple->Comment,
                            pCGenState->ExportsDbg->ExportName
                            );
                    goto SkipGen;
                }
            }

               //
               // skip this api if:
               // - external forward reference
               // - internal forward which does not define the fn
               //
               //
            if ( (pCGenState->ExportsDbg->ExtForward ||
                      (pCGenState->ExportsDbg->IntForward &&
                       pCGenState->ExportsDbg->IntForward != pCGenState->ExportsDbg))) {
               fprintf(pCGenState->CGen->fp,
                        "%s %s forwarded to %s\n",
                       pCGenState->Temple->Comment,
                       pCGenState->ExportsDbg->ExportName,
                       pCGenState->ExportsDbg->ExtForward
                          ? pCGenState->ExportsDbg->ExtForward
                          : pCGenState->ExportsDbg->IntForward->ExportName
                       );

               if (pTempleEx) {
                  fprintf(pCGenState->CGen->fp,
                          "%s WARNING: forwarded function has an exception template\n",
                          pCGenState->Temple->Comment,
                          pTempleEx->Name
                         );
               }

            } else {    // gen code for this api
                PLIST_ENTRY NextArg;
                PARGSLIST   pArgsList;

                BuildArgsList(pTempleEx,
                              pCGenState->ApiTypes->pfuncinfo,
                              &pCGenState->ExportsDbg->ArgsListHead
                              );

                if (GetArgSize(pCGenState->ExportsDbg) < 0) {
                    ExitErrMsg(FALSE, 
                               "API %s has no function prototype - unable to generate code.", 
                               pCGenState->ExportsDbg->ExportName
                              );
                } else {

                    ExpandTemple(pCGenState->Temple, BeginCBI, pCGenState);

                    //
                    // Dump warnings about unthunked parameters which 
                    // contain nested function pointers.
                    //
                    if (bWarnAboutNestedFuncPtrs && !pTempleEx) {
                        int ArgNum = 1;
                        NextArg = pCGenState->ExportsDbg->ArgsListHead.Flink;

                        while (NextArg != &pCGenState->ExportsDbg->ArgsListHead) {
                           pArgsList = CONTAINING_RECORD(NextArg,
                                                         ARGSLIST,
                                                         ArgumentsEntry
                                                         );
                           if (pArgsList->fRequiresThunk) {
                                //
                                // The argument contained a nested function
                                // pointer, and nothing thunked that
                                // function pointer.  Warn about a potential
                                // bug.
                                //
                                fprintf(pCGenState->CGen->fp,
                                    "// *** WARNING: Arg %d: type '%s' contains an unthunked function pointer ***\n",
                                    ArgNum,
                                    pArgsList->Type
                                    );
                            }
                            NextArg = NextArg->Flink;
                            ArgNum++;
                        }
                    }

                    //
                    // clean up pArgsList->LocalVar and ArgHostName
                    //
                    NextArg = pCGenState->ExportsDbg->ArgsListHead.Flink;
                    while (NextArg != &pCGenState->ExportsDbg->ArgsListHead) {
                       pArgsList = CONTAINING_RECORD(NextArg,
                                                     ARGSLIST,
                                                     ArgumentsEntry
                                                     );
                       if (pArgsList->ArgLocal) {
                           GenHeapFree(pArgsList->ArgLocal);
                           pArgsList->ArgLocal = NULL;
                           }
                       if (pArgsList->HostCastedName) {
                          GenHeapFree(pArgsList->HostCastedName);
                          pArgsList->HostCastedName = NULL;
                       }

                       NextArg = NextArg->Flink;
                       }

                    pCGenState->ApiNum++;
                    }
                }

SkipGen:
            //
            // End switching this API in or out depending on the platform info
            //
            ApiPlatform = pCGenState->ExportsDbg->ApiPlatform;
            PlatformSwitchEnd(pCGenState, ApiPlatform);

            Next= Next->Flink;
        }
    } else {
        ExitErrMsg(FALSE,
                   "%s,%s:%s Template undefined\n",
                   pCGenState->CGen->FileNameC,
                   pCGenState->CGen->FileNameCpp ? pCGenState->CGen->FileNameCpp : "",
                   pCGenState->CGen->TempleName
                   );
    }
}


void
PlatformSwitchStart(
    PCGENSTATE pCGenState,
    BYTE ApiPlatform
    )
{
    BOOL fIsAsm;

    if (ApiPlatform == API_ALL) {
        return;
    }

    //
    // Switch this API in or out depending on the platform info
    //      00: don't emit anything
    //      01: emit "== 0x0400"
    //      10: emit "> 0x0400"
    //      11: emit ">= 0x0400"
    //
    if (!pCGenState->Temple || !pCGenState->Temple->Comment) {
        fIsAsm = FALSE;
    } else {
        if (strcmp(pCGenState->Temple->Comment, ";") == 0) {
            fIsAsm = TRUE;
        } else {
            fIsAsm = FALSE;
        }
    }

    if (fIsAsm) {
        fprintf(pCGenState->CGen->fp, "\nif ");
    } else {
        fprintf(pCGenState->CGen->fp, "\n#if ");
    }

    if (ApiPlatform & API_WIN9x) {
        BYTE Plat = (ApiPlatform & API_WIN9x) >> API_SHIFT_WIN9x;

        fprintf(pCGenState->CGen->fp,
                (fIsAsm) ? AsmPlatformSwitches[Plat] : CPlatformSwitches[Plat],
                "_WIN32_WINDOWS"
                );
    }

    if ((ApiPlatform & API_WIN9x) && (ApiPlatform & API_NTx)) {
        // API is on some flavor of Win9x and some NTx flavor
        fprintf(pCGenState->CGen->fp, (fIsAsm) ? " OR " : " || ");
    }

    if (ApiPlatform & API_NTx) {
        BYTE Plat = (ApiPlatform & API_NTx) >> API_SHIFT_NTx;

        fprintf(pCGenState->CGen->fp,
                (fIsAsm) ? AsmPlatformSwitches[Plat] : CPlatformSwitches[Plat],
                "_WIN32_WINNT"
                );
    }

    if (pCGenState->ListCol) {
        WriteListColumn(pCGenState);
    } else {
        fprintf(pCGenState->CGen->fp, "\n");
    }

}



void
PlatformSwitchEnd(
    PCGENSTATE pCGenState,
    BYTE ApiPlatform
    )
{
    if (ApiPlatform != API_ALL) {
        if (strcmp(pCGenState->Temple->Comment, ";") == 0) {
            fprintf(pCGenState->CGen->fp, "\nendif ; _WIN32_WIN...\n");
        } else {
            fprintf(pCGenState->CGen->fp, "\n#endif // _WIN32_WIN...\n");
        }
        if (pCGenState->ListCol) {
            WriteListColumn(pCGenState);
        } else {
            fprintf(pCGenState->CGen->fp, "\n");
        }
    }
}

void
PlatformSwitchEndTable(
    PCGENSTATE pCGenState,
    BYTE ApiPlatform
    )
{
    if (ApiPlatform != API_ALL) {
        if (strcmp(pCGenState->Temple->Comment, ";") == 0) {
            fprintf(pCGenState->CGen->fp, "\nendif ; _WIN32_WIN...\n");
        } else {
       fprintf(pCGenState->CGen->fp, "\n#else\n     {whInvalidCall, 0, 0},");
            fprintf(pCGenState->CGen->fp, "\n#endif // _WIN32_WIN...\n");
        }
        if (pCGenState->ListCol) {
            WriteListColumn(pCGenState);
        } else {
            fprintf(pCGenState->CGen->fp, "\n");
        }
    }
}

/*
 *  BuildArgsList
 *
 *
 */
void BuildArgsList(PTEMPLES pTempleEx, PFUNCINFO funcinfo, PLIST_ENTRY pListHead)
{
    int  i;
    ULONG Size;
    int OffSet=0;
    int ArgOffSet;
    PKNOWNTYPES pkt;
    PARGSLIST pArgsList;
    int NoTypeCount;
    char *HostCastedName;

    if (!IsListEmpty(pListHead)) {
        return;
    }

    if (!pTempleEx) {
        NoTypeCount = 0;
    } else {
        //
        // There is an [EFunc] for this API.  Get the count of
        // NoType= entries for the EFunc.
        //
        for (NoTypeCount=0; NoTypeCount<MAX_NOTYPE; ++NoTypeCount) {
            if (!pTempleEx->NoTypes[NoTypeCount]) {
                break;
            }
        }
    }

    while (funcinfo) {
        pkt = GetNameFromTypesList(TypeDefsList, funcinfo->sType);
        if (!pkt) {
            pkt = GetNameFromTypesList(StructsList, funcinfo->sType);
            if (!pkt) {
                ExitErrMsg(FALSE, "Unknown type %s\n", funcinfo->sType);
            }
        }

        //
        // Save the ArgOffSet, and add the args size to the cumulative
        // offset for the next argument.
        //
        // Round up the arg size to the next dword. Assumes intel stack
        // parameter passing conventions, and that all pointers are
        // sizeof(int *) except __ptr64 which are sizeof(PVOID64).
        //
        ArgOffSet = OffSet;

        Size = funcinfo->IndLevel ?
                 ( funcinfo->fIsPtr64 ? SIZEOFPOINTER64 : SIZEOFPOINTER ) :
                 pkt->Size;

        OffSet += ((Size + 3) & ~3) >> 2;

        //
        // Create ARGSLIST entry, and add it to the list
        //
        pArgsList = GenHeapAlloc(sizeof(ARGSLIST));
        if (!pArgsList) {
            ExitErrMsg(TRUE, "bal.\n");
        }
        memset(pArgsList, 0, sizeof(ARGSLIST));

        if(funcinfo->sName == NULL) {
           HostCastedName = GenHeapAlloc(sizeof(szHOSTAPPEND));
           if (NULL == HostCastedName)
              ExitErrMsg(FALSE, "Out of memory in BuildArgsList\n");
           strcpy(HostCastedName, szHOSTAPPEND);
        }
        else {
           HostCastedName = GenHeapAlloc(sizeof(szHOSTAPPEND) + strlen(funcinfo->sName));
           if (NULL == HostCastedName)
              ExitErrMsg(FALSE, "Out of memory in BuildArgsList\n");
           strcpy(HostCastedName, funcinfo->sName);
           strcat(HostCastedName, szHOSTAPPEND);
        }

        pArgsList->pKnownTypes = pkt;
        pArgsList->OffSet      = ArgOffSet;
        pArgsList->IndLevel    = funcinfo->IndLevel;
        pArgsList->ArgSize     = Size;
        pArgsList->IsPtr64     = funcinfo->fIsPtr64;  
        pArgsList->Mod         = funcinfo->tkPreMod;
        pArgsList->tkDirection = funcinfo->tkDirection;
        pArgsList->SUEOpt      = funcinfo->tkSUE;
        pArgsList->Type        = funcinfo->sType;
        pArgsList->PostMod     = funcinfo->tkPostMod;
        pArgsList->PrePostMod  = funcinfo->tkPrePostMod;
        pArgsList->Name        = funcinfo->sName;
        pArgsList->HostCastedName = HostCastedName;
        pArgsList->fIsMember   = FALSE;
        pArgsList->bIsBitfield = FALSE;        
        pArgsList->BitsRequired= 0;       
        pArgsList->bIsArray    = FALSE;           
        pArgsList->ArrayElements=0;

        if (pkt->Flags & BTI_CONTAINSFUNCPTR) {
            //
            // This parameter type is either a function pointer, or
            // a type which contains an embedded function pointer.
            // Something is going to have to thunk it.
            //
            pArgsList->fRequiresThunk = TRUE;
        }

        if (pTempleEx) {
            //
            // There is an [EFunc] for this API.  See if this param
            // should have [Types] templates expanded or not.
            //
            for (i=0; i<NoTypeCount; ++i) {
                if (pTempleEx->NoTypes[i] &&
                    strcmp(pArgsList->Name, pTempleEx->NoTypes[i]) == 0) {
                    //
                    // This param is not supposed to have [Types] expanded
                    //
                    pArgsList->fNoType = TRUE;
                    pTempleEx->NoTypes[i] = NULL;
                }
            }
        }


        InsertTailList(pListHead, &pArgsList->ArgumentsEntry);

        //
        // and on to the next argument .....
        //
        funcinfo = funcinfo->pfuncinfoNext;
    }

    if (pTempleEx) {
        //
        // For error reporting, indicate any NoTypes= that did not match
        // a param name
        //
        for (i=0; i<NoTypeCount; ++i) {
            if (pTempleEx->NoTypes[i]) {
                ExitErrMsg(FALSE, "[EFunc] %s(%x) has a 'NoType=%s' which does not correspond to an argument name\n", pTempleEx->Name, pTempleEx, pTempleEx->NoTypes[i]);
            }
        }
    }

    return;
}


//
// return pointer to type of first argument
char *NArgType(PCGENSTATE pCGenState, char *s, int iLen, char **ppSrc)
{
    PARGSLIST pArgsList;
    PLIST_ENTRY Next;
    char *pch = s;
    CGENSTATE CGenState;
    int Len, i;
    char *pSrc;

    pSrc = *ppSrc;
    if (*pSrc != '(') {
        ErrMsg("Incorrect NArgType parameter %s\n", pSrc);
        fprintf(pCGenState->CGen->fp, "** ERROR ** Incorrect NArgType parameter %s\n", pSrc);
        return NULL;
    }

    pSrc++;
    i = 0;
    while ((*pSrc != ')') && (i < iLen-1)) {
        s[i++] = *pSrc++;
    }
    s[i] = 0;
    *ppSrc = ++pSrc;
    Len = atoi(s);

    if (Len-- == 0) {
        ErrMsg("Invalid NArgType parameter %s\n", s);
        fprintf(pCGenState->CGen->fp, "** ERROR ** Invalid NArgType parameter %s\n", s);
        return NULL;
    }


    if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
        fprintf(pCGenState->CGen->fp,
                "\n\t*** ERROR ***\n*** NArgType Missing argument List: %s\n\n",
                pCGenState->ApiTypes->TypeName
                );

        return NULL;
    }

    Next = pCGenState->ExportsDbg->ArgsListHead.Flink;

    // check for void arg list
    pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);
    if (!pArgsList->Name && strcmp(pArgsList->Type, szVARGS)) {
        return NULL;
    }

    CGenState = *pCGenState;

    for (i = 0; (i < Len) && (Next != &CGenState.ExportsDbg->ArgsListHead); i++) {
        Next= Next->Flink;
    }
    if (Next == &CGenState.ExportsDbg->ArgsListHead) {
        ErrMsg("NArgType parameter out of range %d\n", Len);
        fprintf(pCGenState->CGen->fp, "** ERROR ** NArgType parameter out of range %d\n", Len);
        return NULL;
    }

    CGenState.pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);

    //
    // Copy in the explicit struct/union/enum keyword, if present
    //
    strcat(pch, TokenString[CGenState.pArgsList->SUEOpt]);

    //
    // Copy in the actual typename
    //
    strcpy(pch, CGenState.pArgsList->Type);

    if (CGenState.pArgsList->PrePostMod != TK_NONE) {
        strcat(pch, " ");
        strcat(pch,  TokenString[CGenState.pArgsList->PrePostMod]);
    }
    pch = pch  + strlen(pch);
    if (CGenState.pArgsList->IndLevel) {
        *pch++ = ' ';
        for (i=0; i<CGenState.pArgsList->IndLevel; ++i) {
            *pch++ = '*';
        }
    }
    *pch = '\0';
          
    return(s);
}

//
// return pointer to name of first argument
char *NArgName(PCGENSTATE pCGenState, char *s, int iLen, char **ppSrc)
{
   PARGSLIST pArgsList;
   PLIST_ENTRY Next;
   char *pch = s;
   CGENSTATE CGenState;
   int Len, i;
   char *pSrc;

   pSrc = *ppSrc;
   if (*pSrc != '(') {
       ErrMsg("Incorrect NArgType parameter %s\n", pSrc);
       fprintf(pCGenState->CGen->fp, "** ERROR ** Incorrect NArgType parameter %s\n", pSrc);
       return(NULL);
       }
       
   pSrc++;
   i = 0;
   while ((*pSrc != ')') && (i < iLen-1)) {
       s[i++] = *pSrc++;
       }
   s[i] = 0;
   *ppSrc = ++pSrc;
   Len = atoi(s);

   if (Len-- == 0) {
       ErrMsg("Invalid NArgType parameter %s\n", s);
       fprintf(pCGenState->CGen->fp, "** ERROR ** Invalid NArgType parameter %s\n", s);
       return(NULL);
       }

   if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n*** NArgType Missing argument List: %s\n\n",
               pCGenState->ApiTypes->TypeName
               );

       return(NULL);
       }

   Next = pCGenState->ExportsDbg->ArgsListHead.Flink;
   
   // check for void arg list
   pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);
   if (!pArgsList->Name && strcmp(pArgsList->Type, szVARGS)) {
       return(NULL);
       }

   CGenState = *pCGenState;
   
   for (i = 0; (i < Len) && (Next != &CGenState.ExportsDbg->ArgsListHead); i++) {
       Next= Next->Flink;       
       }
   if (Next == &CGenState.ExportsDbg->ArgsListHead) {
       ErrMsg("NArgName parameter out of range %d\n", Len);
       fprintf(pCGenState->CGen->fp, "** ERROR ** NArgName parameter out of range %d\n", Len);
       return(NULL);
       }       
              
   CGenState.pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);
   
   strcpy(pch, CGenState.pArgsList->Name);
          
   return(s);
}

char *
MArg(
    char *pSrc,
    PCGENSTATE pCGenState,
    PSTR *pBuffer
    )
/*++

Routine Description:

    Expand the n'th argument for the current macro

Arguments:

    pSrc        - pointer to character following 'MArg'
    pCGenState  - current code-gen state

Return Value:

    pointer to character following the end of the macro argument

--*/
{
    int i;
    int ArgNum;
    PMACROARGSLIST pList = pCGenState->pMacroArgsList;
    char s[MAX_PATH];
    PMACROARGSLIST OldList;

    if (!pList) {
        ExitErrMsg(FALSE, "%s(%d) MArg unexpected: no macro is currently being expanded\n", TemplateFileName, TemplateLine);
    }

    if (*pSrc != '(') {
        ExitErrMsg(FALSE, "%s(%d) Incorrect MArg parameter %s\n", TemplateFileName, TemplateLine, pSrc);
    }

    pSrc++;
    i = 0;
    while ((*pSrc != ')') && (i < sizeof(s)-1)) {
        s[i++] = *pSrc++;
    }
    s[i] = 0;
    ArgNum = atoi(s);
    pSrc++;     // skip ')'

    if (ArgNum-- == 0) {
        ExitErrMsg(FALSE, "%s(%d) Invalid MArg parameter %s\n", TemplateFileName, TemplateLine, s);
    }

    if (ArgNum >= pList->NumArgs) {
        ExitErrMsg(FALSE, "%s(%d) Macro only takes %d arguments\n", TemplateFileName, TemplateLine, pList->NumArgs);
    }

    if (pBuffer == NULL) {
       OldList = pCGenState->pMacroArgsList;
       pCGenState->pMacroArgsList = MacroStack[--MacroStackTop];
       CGenerate(pList->ArgText[ArgNum], pCGenState);
       MacroStack[MacroStackTop++] = pCGenState->pMacroArgsList;
       pCGenState->pMacroArgsList = OldList;    
    }
    else {
       *pBuffer = pList->ArgText[ArgNum];
    }
    return pSrc;
}

char *ArgType(char *Buffer, PCGENSTATE pCGenState) {
   char *pch;
   if (pCGenState->pArgsList) {
        int i;

        pch = Buffer;
        if (pCGenState->pArgsList->SUEOpt != TK_NONE) {
            strcpy(pch, TokenString[pCGenState->pArgsList->SUEOpt]);
            strcat(pch, " ");
            pch += strlen(pch);
        }
        strcpy(pch,  pCGenState->pArgsList->Type);
        if (pCGenState->pArgsList->PrePostMod != TK_NONE) {
            strcat(pch, " ");
            strcat(pch,  TokenString[pCGenState->pArgsList->PrePostMod]);
        }
        pch = pch+strlen(pch);
        if (pCGenState->pArgsList->IndLevel) {
            *pch++ = ' ';
            for (i=0; i<pCGenState->pArgsList->IndLevel; ++i) {
                *pch++ = '*';
            }
        }
        *pch = '\0';
        pch = Buffer;
        return pch;
   }
   else 
      return NULL;
}

char *UnalignedTag64(char *Buffer, PCGENSTATE pCGenState) {

    //
    // PUT UNALIGNED TAg for interested type like KLPWST KHBITMAP all kernel mode shareable struct
    //

    char CurrArgType[256];
    if ( NULL == ArgType ( CurrArgType, pCGenState))
        return NULL;
    
    //
    // Now chek the name 
    //

    if ( pCGenState->pArgsList->ArgSize == 8 ) {
        
         //
         // BUGBUG: check if you need special case for KLPWSTR and KHBITMAP
         //         if so put more generic form
         //(strncmp ( CurrAgrType, "KLPWSTR ",7) == 0) || 
         //(strncmp ( CurrAgrType, "KHBITMAP ",8) == 0)
         //

        strcpy (Buffer, "*(UNALIGNED ");
        strcat (Buffer, CurrArgType);
        if (strchr(CurrArgType, '*') == NULL )
            strcat ( Buffer, " ");
        strcat (Buffer, "*)&");
        return Buffer;
    }
    return NULL;

}


char *ArgHostType(char *Buffer, PCGENSTATE pCGenState) {
   char *pch;
   if (pCGenState->pArgsList) {
      int i;
      pch = Buffer;
      /*if (pCGenState->pArgsList->SUEOpt != TK_NONE) {
         strcpy(pch, TokenString[pCGenState->pArgsList->SUEOpt]);
         strcat(pch, " ");
         pch += strlen(pch);
      }*/
      if (pCGenState->pArgsList->IndLevel > 0) {
         strcpy(pch, GetHostPointerName(pCGenState->pArgsList->IsPtr64));
         pch += strlen(pch);
      }
      else {
         char Buffer[MAX_PATH];
         strcpy(pch, GetHostTypeName(pCGenState->pArgsList->pKnownTypes, Buffer));
         pch += strlen(pch);
      }
      *pch = '\0';
      pch = Buffer;
      return pch;
   }
   else 
      return NULL;
}

BOOL IsPointer(PCGENSTATE pCGenState) {
    return (pCGenState->pArgsList->IndLevel > 0) || (pCGenState->pArgsList->pKnownTypes->IndLevel > 0);
}

char *ArgTypeInd(char *Buffer, PCGENSTATE pCGenState, BOOL bHostName) {
   
   CGENSTATE GenStateOld;
   ARGSLIST ArgsListOld;
   KNOWNTYPES KnownTypes;
   PKNOWNTYPES pCurrent;
   int IndLevel;
   char *pch;

   //copy over the old structures before mangaling them
   GenStateOld = *pCGenState;
   ArgsListOld = *(pCGenState->pArgsList);
   KnownTypes = *(pCGenState->pArgsList->pKnownTypes);
   pCGenState->pArgsList->pKnownTypes = &KnownTypes;
   
   if (pCGenState->pArgsList->IndLevel > 0) {
      IndLevel = pCGenState->pArgsList->IndLevel - 1;
      goto success;
   }

   pCurrent = &KnownTypes;
   IndLevel = pCurrent->IndLevel;
   if (IndLevel == 0) {
      ErrMsg("ArgTypeInd: Tried to get name of type pointed to by %s\n",pCGenState->pArgsList->Name);
      ExitErrMsg(FALSE, "ArgTypeInd: %s is not a pointer!\n", pCGenState->pArgsList->Name);
   }

   while(1) {//chase all the way down to a struct/union/enum or a func_ptr
      PCHAR IndName; 
      ASSERT(pCurrent != NULL);
      if (pCurrent->IndLevel == 1 && !bHostName && ((IndName = IsDefinedPtrToPtrDependent(pCurrent->TypeName)) != NULL)) {
          PKNOWNTYPES pkt;
          IndLevel--;
          pkt = GetNameFromTypesList(TypeDefsList, IndName);
         
          ASSERT(pkt != NULL);
          KnownTypes = *pkt;
          goto success;
      }      
      else if (pCurrent->pTypedefBase != NULL) {
         pCurrent = pCurrent->pTypedefBase;
      }
      else {
         //hit a struct/union/enum or func_ptr
         KnownTypes = *pCurrent;
         pCGenState->pArgsList->pStructType = NULL;
         pCGenState->pArgsList->SUEOpt = TK_NONE;
         IndLevel--;

         if (pCurrent->Flags & BTI_NOTDERIVED) {
            pCGenState->pArgsList->SUEOpt = TK_NONE;
              goto success;
         }
         else if(strcmp("struct", KnownTypes.BaseName) == 0) { 
            pCGenState->pArgsList->SUEOpt = TK_STRUCT;
            goto success;
         }
         else if(strcmp("union", KnownTypes.BaseName) == 0) {
            pCGenState->pArgsList->SUEOpt = TK_UNION;
            goto success;
         }
         else if(strcmp("enum", KnownTypes.BaseName) == 0) {
            pCGenState->pArgsList->SUEOpt = TK_ENUM;
            goto success;
         }            
         else {
            ExitErrMsg(FALSE, "ArgTypeInd: Can't determine what %s is.\n", pCGenState->pArgsList->Name);
         }
      }      
   }

success:
   //fake out the typename and the indirection
   KnownTypes.IndLevel = 0;
   pCGenState->pArgsList->IndLevel = IndLevel;
   pCGenState->pArgsList->Type = KnownTypes.TypeName;
   //Print the mangled type, then restore the old type
   if (bHostName) 
      pch = ArgHostType(Buffer, pCGenState);
   else 
      pch = ArgType(Buffer, pCGenState);

   *pCGenState = GenStateOld;
   *(pCGenState->pArgsList) = ArgsListOld;

   return pch;
}

char *ApiName(char *pSrc, char**pch, char *Buffer, PCGENSTATE pCGenState) {
   char *pTemp;
   strcpy(Buffer, pCGenState->ExportsDbg->ExportName);

   // if ApiName has decoration then truncate it
   pTemp = strchr(Buffer, '@');
   if (pTemp) {
      *pTemp = '\0';
   }
   
   *pch = Buffer;
   return pSrc;
}

char *ApiNameSkip(char *pSrc, char**pch, char *Buffer, PCGENSTATE pCGenState) {
   char *pNewSrc, *pTemp, *pEnd;
   int CharsToSkip;
   
   pNewSrc = ApiName(pSrc, pch, Buffer, pCGenState);
   
   pEnd = SkipSubExpression(pNewSrc, NULL);
   if (pNewSrc == pEnd)
      return pNewSrc;

   pTemp = pNewSrc+1;
   CharsToSkip = atoi(pTemp);
   while(**pch != '\0' && CharsToSkip > 0) {
      (*pch)++;
      CharsToSkip--;
   }
   
   return pEnd;

}

BOOL IsPointerToPtrDep(PARGSLIST pArgsList) {
   PKNOWNTYPES pCurrent;

   pCurrent = pArgsList->pKnownTypes;

   if (pArgsList->IndLevel + pCurrent->IndLevel < 1)
      ExitErrMsg(FALSE, "IsPointerToPtrDep: %s is not a pointer\n", pArgsList->Name);
   
   if (pArgsList->IndLevel + pCurrent->IndLevel > 1) {

      // Since pCurrent->IndLevel is acumulative, this can happen if and 
      // only if this type or one of its base types is a pointer to 
      // another pointer.  This case is defined to be pointer dependent.

      return TRUE;
   }

   // At this point, either pArgsList->IndLevel == 1 and pCurrent->IndLevel == 0
   // or pArgsList->IndLevel == 0 and pCurrent->IndLevel = 1.
   // First check if this type is defined to be a pointer to a pointer dependent type.
   // If not, defererence the pointer by walking through typedefs until pCurrent->IndLevel = 0
   // Note that multiple levels of pointers are no longer possible.

   if(IsDefinedPtrToPtrDependent(pCurrent->TypeName)) {
       return TRUE;
   }

   while(pCurrent->IndLevel != 0) {
      
      // Check if this type is one of the special types used
      // between sortpp and genthnk.
  
      if (pCurrent->Flags & BTI_NOTDERIVED) 
     return FALSE;     

      // Assert that this type is not a struct, union, or enum.
      // This shouldn't happen because sortpp should store
      // these with an indlevel of 0.
 
      ASSERT(strcmp(pCurrent->BaseName, "struct") != 0);
      ASSERT(strcmp(pCurrent->BaseName, "union") != 0);
      ASSERT(strcmp(pCurrent->BaseName, "enum") != 0);

      // Check if this type is a function pointer.  If it is,
      // return FALSE since they are arbitrarly defined to not
      // be pointer dependent.  This may be changed check if any
      // of the arguments to the function pointer are pointer dependent.
   
      if (strcmp(pCurrent->BaseName, "()") == 0) 
     return FALSE;
  
      // Get the base typedef.
      pCurrent = pCurrent->pTypedefBase;  
   }
   
   // Now that the pointer has been dereferenced, test if 
   // this type is pointer dependent.

   return (pCurrent->Flags & BTI_POINTERDEP) != 0;
}

char *TestIfPointerToPtrDep(char *pSrc, PCGENSTATE pCGenState, PCHAR pch) {

    PCHAR pEnd;
    PMACROARGSLIST pMArgsList;
    ARGSLIST ArgsList;
    CHAR TypeName[MAX_PATH];
    SIZE_T BytesReturned;

    pEnd = SkipSubExpression(pSrc, NULL);
    if (pSrc == pEnd) {
       ExitErrMsg(FALSE, "TestIfPointerToPtrDep: exactly 1 argument is required.\n"); 
    }

    ParseMacroArgs(pSrc, pEnd - pSrc, &pMArgsList);

    if (pMArgsList->NumArgs != 1) {
       ExitErrMsg(FALSE, "IncludeRetTypes: exactly 1 argument is required.\n");
    }
    
    CGenerateEx(pMArgsList->ArgText[0], pCGenState, TypeName, MAX_PATH, &BytesReturned);
    SetArgListToTypeForArg(&ArgsList, &ArgsList, TypeName);
    
    if(IsPointerToPtrDep(&ArgsList)) {
        strcpy(pch, "1");
    }
    else {
        strcpy(pch, "0");
    }
    FreeMacroArgsList(pMArgsList); 
    return pEnd;   
}
 
BOOL IsPtrDep(PARGSLIST pArgsList) {
   //This is a pointer to something(ptr dep.)
   if (pArgsList->IndLevel > 0)
      return TRUE;
   return pArgsList->pKnownTypes->Flags & ( BTI_POINTERDEP | BTI_INT64DEP );
}
BOOL IsInt64DepUnion(PCGENSTATE pCGenState) {

   
   char Buff[256];

   Buff[0]=0;
   ArgTypeInd( Buff, pCGenState, FALSE);

   // make exception for union _ULARGE_INTEGER
   if (strncmp(Buff, "union _ULARGE_INTEGER", sizeof ("union _ULARGE_INTEGER")) == 0 )
        return TRUE; //IsPointerToPtrDep ( pArgsList );
   if (strncmp(Buff, "union _LARGE_INTEGER", sizeof ("union _LARGE_INTEGER")) == 0 )
        return TRUE; //IsPointerToPtrDep ( pArgsList );


   return FALSE; //pArgsList->pKnownTypes->Flags & BTI_INT64DEP;
}

void DoIndent(PCGENSTATE pCGenState) {
    int i;
    for(i=IndentLevel, OutputColumn = 1; i > 0; i--,OutputColumn++) {
        if (fputc(' ', pCGenState->CGen->fp) != ' ')
            ExitErrMsg(TRUE, "fputc %s\n", pCGenState->CGen->FileNameC);
        OutputColumn++;
    }
}

char * CGeneratePrintChar(char *pch, PCGENSTATE pCGenState) {
   if (!bStripNewline) {
      if('\n' == *pch)
         OutputColumn = 0; //will be incremented to 1
      goto PrintIt;
   }
   else {
      int i;
      if (*pch == '\n')
         goto SkipIt;
      if (!bFirstCharHit) {
         if(!isspace(*pch)) {
            DoIndent(pCGenState);
            bFirstCharHit = TRUE;
            goto PrintIt;
         }
         else
            goto SkipIt;
      }
      else
         goto PrintIt;
   }
PrintIt:
   if (fputc(*pch, pCGenState->CGen->fp) != *pch) 
      goto PrintError;
   OutputColumn++;
SkipIt:
   return pch + 1;
PrintError:
   ExitErrMsg(TRUE, "fputc %s\n", pCGenState->CGen->FileNameC);
}

char *CGenerate(char *pSrc, PCGENSTATE pCGenState) {
   return CGenerateEx(pSrc, pCGenState, NULL, 0, NULL);
}

/*
 *  CGenerate
 *
 */
char *CGenerateEx(char *pSrc, PCGENSTATE pCGenState, char *OutBuffer, SIZE_T MaxLen, SIZE_T *BytesReturned)
{
   FILE **pfp = &pCGenState->CGen->fp;
   char *pch;
   int  i;
   size_t Len;
   char Buffer[MAX_PATH*4];
   char *BufferPos = NULL;

   if (OutBuffer != NULL) {
      BufferPos = OutBuffer;
      *BytesReturned = 0;
   }

   while (*pSrc) {
  
       if (OutBuffer != NULL && MaxLen == 0) {
          ExitErrMsg(FALSE, "Out of buffer space!\n");
       }

       if (*pSrc != '@') {
          if (OutBuffer != NULL) {
             *BufferPos++ = *pSrc++;
             *BytesReturned += 1;
             MaxLen--;
          }
          else {
             pSrc = CGeneratePrintChar(pSrc, pCGenState);
          }      
       }
       else if (*(pSrc + 1) == '@') {
          pSrc++;
          if (OutBuffer != NULL) {
             *BufferPos++ = *pSrc++;
             *BytesReturned += 1;
             MaxLen--;
          }
          else {
             pSrc = CGeneratePrintChar(pSrc, pCGenState);
          }
       }
       else {
           pch = NULL;
           memset(Buffer, 0, sizeof(Buffer));
             pSrc++;    //skip the @ is the command name
           
             if(bStripNewline && !bFirstCharHit) {
                 OutputColumn = 1 + IndentLevel;
             }

           if (!strncmp(pSrc, szNL, sizeof(szNL) - 1)) {              
               pSrc += sizeof(szNL) - 1;
               if (fputc('\n', *pfp) != '\n')
                  ExitErrMsg(TRUE, "fputc %s\n", pCGenState->CGen->FileNameC);                 
               OutputColumn = 1;
               bFirstCharHit = FALSE;
           }
           else if (!strncmp(pSrc, szINDENT, sizeof(szINDENT) - 1)) {
               int OldIndent;
               pSrc += sizeof(szINDENT) - 1;
               OldIndent = IndentLevel;
               IndentLevel += INDENTSIZE;
               pSrc = WriteMore(pSrc, pCGenState, TRUE);
               IndentLevel = OldIndent;
           }
           else if (!strncmp(pSrc, szNOFORMAT, sizeof(szNOFORMAT) - 1)) {
              BOOL bOldStripNewline;
                 pSrc += sizeof(szNOFORMAT) - 1;
              bOldStripNewline = bStripNewline;
              bStripNewline = FALSE;
              pSrc = WriteMore(pSrc, pCGenState, TRUE);
              bStripNewline = bOldStripNewline;
           }
           else if (!strncmp(pSrc, szTEMPLATE, sizeof(szTEMPLATE) - 1)) {
               pSrc += sizeof(szTEMPLATE) - 1;
               pSrc = IncludeTemplate(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szAPILIST, sizeof(szAPILIST) - 1)) {
               pSrc += sizeof(szAPILIST) - 1;
               pSrc = ListApis(pSrc, pCGenState, FALSE);
               }
           else if (!strncmp(pSrc, szAPINAMESKIP, sizeof(szAPINAMESKIP) -1 )) {
               pSrc += sizeof(szAPINAMESKIP) - 1;
               pSrc = ApiNameSkip(pSrc, &pch, Buffer, pCGenState);
           }           
           else if (!strncmp(pSrc, szAPINAME, sizeof(szAPINAME) - 1)) {
               pSrc += sizeof(szAPINAME) - 1;
               pSrc = ApiName(pSrc, &pch, Buffer, pCGenState);
           }
           else if (!strncmp(pSrc, szAPIFORWARD, sizeof(szAPIFORWARD) - 1)) {
               pSrc += sizeof(szAPIFORWARD) - 1;

               if (pCGenState->ExportsDbg->IntForward) {
                   strcpy(Buffer, szINTFORWARD);
                   strcpy(Buffer + sizeof(szINTFORWARD) - 1,
                          pCGenState->ExportsDbg->IntForward->ExportName
                          );
                   }
               else {
                   strcpy(Buffer, pCGenState->ExportsDbg->ExportName);
                   }

               // if ApiName has decoration then truncate it
               pch = strchr(Buffer, '@');
               if (pch) {
                   *pch = '\0';
                   }

               pch = Buffer;

               }

           else if (!strncmp(pSrc, szAPINUM, sizeof(szAPINUM) - 1)) {
               _itoa(pCGenState->ApiNum, Buffer, 10);
               pch = Buffer;
               pSrc += sizeof(szAPINUM) - 1;
               }
           else if (!strncmp(pSrc, szAPIFNRET, sizeof(szAPIFNRET) - 1)) {
               if (pCGenState->ApiTypes) {
                   pch = pCGenState->ApiTypes->FuncRet;
                   }
               pSrc += sizeof(szAPIFNRET) - 1;
               }
           else if (!strncmp(pSrc, szAPIDECLSPEC, sizeof(szAPIDECLSPEC) - 1)) {
               BOOL b = pCGenState->ApiTypes && (pCGenState->ApiTypes->Flags & BTI_DLLEXPORT);

               pSrc += sizeof(szAPIDECLSPEC) - 1;
               pSrc = WriteMore(pSrc, pCGenState, b);
               }
           else if (!strncmp(pSrc, szAPIFNMOD, sizeof(szAPIFNMOD) - 1)) {
               if (pCGenState->ApiTypes) {
                   pch = pCGenState->ApiTypes->FuncMod;
                   }
               pSrc += sizeof(szAPIFNMOD) - 1;
               }
           else if (!strncmp(pSrc, szAPIMORE, sizeof(szAPIMORE) - 1)) {
               pSrc += sizeof(szAPIMORE) - 1;
               pSrc = WriteMore(pSrc, pCGenState, pCGenState->MoreApis);
               }
           else if (!strncmp(pSrc, szIFAPIRET, sizeof(szIFAPIRET) - 1)) {
               pSrc += sizeof(szIFAPIRET) - 1;
               pSrc = IfApiRet(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szIFISMEMBER, sizeof(szIFISMEMBER) - 1)) {
               pSrc += sizeof(szIFISMEMBER) - 1;
               pSrc = WriteMore(pSrc, pCGenState, pCGenState->pArgsList->fIsMember);
           }
           else if (!strncmp(pSrc, szIFNISMEMBER, sizeof(szIFNISMEMBER) - 1)) {
              pSrc += sizeof(szIFNISMEMBER) - 1;
              pSrc = WriteMore(pSrc, pCGenState, !(pCGenState->pArgsList->fIsMember));
           }
           else if (!strncmp(pSrc, szIFISBITFIELD, sizeof(szIFISBITFIELD) - 1)) {
               pSrc += sizeof(szIFISBITFIELD) - 1;
               pSrc = WriteMore(pSrc, pCGenState, pCGenState->pArgsList->bIsBitfield);
           }
           else if (!strncmp(pSrc, szIFNISBITFIELD, sizeof(szIFNISBITFIELD) - 1)) {
              pSrc += sizeof(szIFNISBITFIELD) - 1;
              pSrc = WriteMore(pSrc, pCGenState, !(pCGenState->pArgsList->bIsBitfield));
           }
           else if (!strncmp(pSrc, szIFISARRAY, sizeof(szIFISARRAY) - 1)) {
               pSrc += sizeof(szIFISARRAY) - 1;
               pSrc = WriteMore(pSrc, pCGenState, pCGenState->pArgsList->bIsArray);
           }
           else if (!strncmp(pSrc, szIFNISARRAY, sizeof(szIFNISARRAY) - 1)) {
              pSrc += sizeof(szIFNISARRAY) - 1;
              pSrc = WriteMore(pSrc, pCGenState, !(pCGenState->pArgsList->bIsArray));
           }
           else if (!strncmp(pSrc, szARGARRAYELEMENTS, sizeof(szARGARRAYELEMENTS) - 1)) {
              pSrc += sizeof(szARGARRAYELEMENTS) - 1;
              _itoa((int)(pCGenState->pArgsList->ArrayElements), Buffer, 10);
              pch = Buffer;
           }
           else if (!strncmp(pSrc, szIFPOINTERTOPTRDEP, sizeof(szIFPOINTERTOPTRDEP) -1 )) {
              pSrc += sizeof(szIFPOINTERTOPTRDEP) - 1;
              pSrc = WriteMore(pSrc, pCGenState, IsPointerToPtrDep(pCGenState->pArgsList));
           }
           else if (!strncmp(pSrc, szIFNPOINTERTOPTRDEP, sizeof(szIFNPOINTERTOPTRDEP) -1 )) {
              pSrc += sizeof(szIFNPOINTERTOPTRDEP) - 1;
              pSrc = WriteMore(pSrc, pCGenState, !IsPointerToPtrDep(pCGenState->pArgsList));
           }
           else if (!strncmp(pSrc, szISPOINTERTOPTRDEP, sizeof(szISPOINTERTOPTRDEP) -1 )) {
              pSrc += sizeof(szISPOINTERTOPTRDEP) - 1;
              pch = Buffer;
              pSrc = TestIfPointerToPtrDep(pSrc, pCGenState, pch);
           }
           else if (!strncmp(pSrc, szIFPTRDEP, sizeof(szIFPTRDEP) -1 )) {
              pSrc += sizeof(szIFPTRDEP) - 1;
              pSrc = WriteMore(pSrc, pCGenState, IsPtrDep(pCGenState->pArgsList));
           }
           else if (!strncmp(pSrc, szIFNPTRDEP, sizeof(szIFNPTRDEP) -1 )) {
              pSrc += sizeof(szIFNPTRDEP) - 1;
              pSrc = WriteMore(pSrc, pCGenState, !IsPtrDep(pCGenState->pArgsList));
           }
           else if (!strncmp(pSrc, szIFINT64DEPUNION, sizeof(szIFINT64DEPUNION) -1 )) {
              pSrc += sizeof(szIFINT64DEPUNION) - 1;
              pSrc = WriteMore(pSrc, pCGenState, IsInt64DepUnion(pCGenState));
           }
           else if (!strncmp(pSrc, szIFNINT64DEPUNION, sizeof(szIFNINT64DEPUNION) -1 )) {
              pSrc += sizeof(szIFNINT64DEPUNION) - 1;
              pSrc = WriteMore(pSrc, pCGenState, !IsInt64DepUnion(pCGenState));
           }           
           else if (!strncmp(pSrc, szIFAPICODE, sizeof(szIFAPICODE) -  1)) {
               pSrc += sizeof(szIFAPICODE) - 1;
               pSrc = IfApiCode(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szFASTCALL, sizeof(szFASTCALL) - 1)) {
               pSrc += sizeof(szFASTCALL) - 1;
               pSrc = WriteMore(pSrc, pCGenState, IsFastCall(pCGenState));
               }
           else if (!strncmp(pSrc, szSLOWCALL, sizeof(szSLOWCALL) - 1)) {
               pSrc += sizeof(szSLOWCALL) - 1;
               pSrc = WriteMore(pSrc, pCGenState, !IsFastCall(pCGenState));
               }
           else if (!strncmp(pSrc, szFASTX2NMETH, sizeof(szFASTX2NMETH) - 1)) {
               pSrc += sizeof(szFASTX2NMETH) - 1;
               pSrc = WriteMore(pSrc, pCGenState, GetX2NMethodType(pCGenState) == FASTX2NMETHOD);
               }
           else if (!strncmp(pSrc, szSLOWX2NMETH, sizeof(szSLOWX2NMETH) - 1)) {
               pSrc += sizeof(szSLOWX2NMETH) - 1;
               pSrc = WriteMore(pSrc, pCGenState, GetX2NMethodType(pCGenState) == SLOWX2NMETHOD);
               }
           else if (!strncmp(pSrc, szFATX2NMETH, sizeof(szFATX2NMETH) - 1)) {
               pSrc += sizeof(szFATX2NMETH) - 1;
               pSrc = WriteMore(pSrc, pCGenState, GetX2NMethodType(pCGenState) == FATX2NMETHOD);
               }
           else if (!strncmp(pSrc, szMETHODNUMBER, sizeof(szMETHODNUMBER) - 1)) {
               pSrc += sizeof(szMETHODNUMBER) - 1;
               _itoa(pCGenState->ExportsDbg->MethodNumber, Buffer, 10);
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szIFARGS, sizeof(szIFARGS) - 1)) {
               pSrc += sizeof(szIFARGS) - 1;
               pSrc = IfArgs(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szFUNCARGNUM, sizeof(szFUNCARGNUM) - 1)) {
               pSrc += sizeof(szFUNCARGNUM) - 1;
               _itoa(GetFuncArgNum(pCGenState), Buffer, 10);
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szRETSIZE, sizeof(szRETSIZE) - 1)) {
               pSrc += sizeof(szRETSIZE) - 1;
               _itoa(GetRetSize(pCGenState), Buffer, 10);
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szARGSIZE, sizeof(szARGSIZE) - 1)) {
               pSrc += sizeof(szARGSIZE) - 1;
               _itoa(GetArgSize(pCGenState->ExportsDbg), Buffer, 10);
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szFORCASE, sizeof(szFORCASE) - 1)) {
               pSrc += sizeof(szFORCASE) - 1;
               pSrc = ForCase(pSrc, pCGenState);
           }
           else if (!strncmp(pSrc, szCARGEXIST, sizeof(szCARGEXIST) - 1)) {
               pSrc += sizeof(szCARGEXIST) - 1;
               if (OutBuffer != NULL) {
                  pSrc = CArg(pSrc, pCGenState, &pch, TRUE);
               }
               else {
                  pSrc = CArg(pSrc, pCGenState, NULL, TRUE);
               }
           }
           else if (!strncmp(pSrc, szCARG, sizeof(szCARG) - 1)) {
               pSrc += sizeof(szCARG) - 1;
               if (OutBuffer != NULL) {
                  pSrc = CArg(pSrc, pCGenState, &pch, FALSE);
               }
               else {
                  pSrc = CArg(pSrc, pCGenState, NULL, FALSE);
               }
           }
           else if (!strncmp(pSrc, szCNUMBER, sizeof(szCNUMBER) - 1)) {
               pSrc += sizeof(szCNUMBER) - 1;
               _itoa(pCGenState->CaseNumber, Buffer, 10);
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szARGLIST, sizeof(szARGLIST) - 1)) {
               pSrc += sizeof(szARGLIST) - 1;
               if (pCGenState->ApiTypes) {
                   pSrc = ListArgs(pSrc, pCGenState, TRUE);
                   }
               }
           else if (!strncmp(pSrc, szNARGTYPE, sizeof(szNARGTYPE) - 1)) {
               pSrc += sizeof(szNARGTYPE) - 1;
               pch = NArgType(pCGenState, Buffer, sizeof(Buffer), &pSrc);
               }
           else if (!strncmp(pSrc, szNARGNAME, sizeof(szNARGNAME) - 1)) {
               pSrc += sizeof(szNARGNAME) - 1;
               pch = NArgName(pCGenState, Buffer, sizeof(Buffer), &pSrc);
               }
           else if (!strncmp(pSrc, szMARG, sizeof(szMARG) - 1)) {
               pSrc += sizeof(szMARG) - 1;
               if (OutBuffer != NULL) {
                  pSrc = MArg(pSrc, pCGenState, &pch);
               }
               else {
                  pSrc = MArg(pSrc, pCGenState, NULL);
               }
           }
           else if (!strncmp(pSrc, szFORCETYPE, sizeof(szFORCETYPE) - 1)) {
               pSrc += sizeof(szFORCETYPE) - 1;
               pSrc = ForceTypeExpand( pSrc, pCGenState);
           }
           else if (!strncmp(pSrc, szMEMBERTYPES, sizeof(szMEMBERTYPES) - 1)) {
               pSrc += sizeof(szMEMBERTYPES) - 1;
               pSrc = MemberTypes( pSrc, pCGenState, FALSE);
               }
           else if (!strncmp(pSrc, szBTOTMEMBERTYPES, sizeof(szBTOTMEMBERTYPES) - 1)) {
               pSrc += sizeof(szBTOTMEMBERTYPES) - 1;
               pSrc = MemberTypes( pSrc, pCGenState, TRUE);
               }
           else if (!strncmp(pSrc, szLOG, sizeof(szLOG) - 1)) {
               pSrc += sizeof(szLOG) - 1;
               pSrc = UpdateLog(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szIFRETTYPE, sizeof(szIFRETTYPE) - 1)) {
               pSrc += sizeof(szIFRETTYPE) - 1;
               pSrc = IfRetType(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szIFNOTRETTYPE, sizeof(szIFNOTRETTYPE) - 1)) {
               pSrc += sizeof(szIFNOTRETTYPE) - 1;
               pSrc = IfNotRetType(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szARGMOD, sizeof(szARGMOD) - 1)) {
               pSrc += sizeof(szARGMOD) - 1;
               if (pCGenState->pArgsList) {
                   pch = TokenString[pCGenState->pArgsList->Mod];
                   }
               }
           else if (!strncmp(pSrc, szARGPOSTMOD, sizeof(szARGPOSTMOD) - 1)) {
               pSrc += sizeof(szARGPOSTMOD) - 1;
               if (pCGenState->pArgsList) {
                   pch = TokenString[pCGenState->pArgsList->PostMod];
                   }
               }
           else if (!strncmp(pSrc, szARGTYPEIND, sizeof(szARGTYPEIND) - 1)) {
              pSrc += sizeof(szARGTYPEIND) - 1;
              pch = ArgTypeInd(Buffer, pCGenState, FALSE);    
           }
           else if (!strncmp(pSrc, szARGHOSTTYPEIND, sizeof(szARGHOSTTYPEIND) - 1)) {
              pSrc += sizeof(szARGHOSTTYPEIND) - 1;
              pch = ArgTypeInd(Buffer, pCGenState, TRUE);    
           }
           else if (!strncmp(pSrc, szARGHOSTTYPE, sizeof(szARGHOSTTYPE) -1 )) {
              pSrc += sizeof(szARGHOSTTYPE) - 1;
              pch = ArgHostType(Buffer, pCGenState);
           }
           else if (!strncmp(pSrc, szARGTYPE, sizeof(szARGTYPE) - 1)) {
              pSrc += sizeof(szARGTYPE) - 1;
              pch = ArgType(Buffer, pCGenState);
           }
           else if (!strncmp(pSrc, szUNALIGNEDTAG64, sizeof(szUNALIGNEDTAG64) - 1)) {
              pSrc += sizeof(szUNALIGNEDTAG64) - 1;
              pch = UnalignedTag64(Buffer, pCGenState);
           }
           else if (!strncmp(pSrc, szARGNAME, sizeof(szARGNAME) - 1)) {
               if (pCGenState->pArgsList) {
                   pch = pCGenState->pArgsList->Name;
                   if (!pch) {
                       pch = "";
                   }
               }
               pSrc += sizeof(szARGNAME) - 1;
           }
           else if (!strncmp(pSrc, szARGNAMEHOSTCASTED, sizeof(szARGNAMEHOSTCASTED) - 1)) {
               if (pCGenState->pArgsList) {
                  pch = pCGenState->pArgsList->HostCastedName;
                  if (!pch) {
                     if (pCGenState->pArgsList->Name == NULL)
                        pch = "";
                     else 
                        pch = pCGenState->pArgsList->Name;
                  }
               }
              pSrc += sizeof(szARGNAMEHOSTCASTED) - 1; 
           }
           else if (!strncmp(pSrc, szARGVAL, sizeof(szARGVAL) - 1)) {
               if (pCGenState->pArgsList) {
                   strcpy(Buffer, pCGenState->pArgsList->Name);

                   // replace all occurrences of '->' by '__'
                   // and '.', '*', ')', and '(' by '_'
                   pch = Buffer;
                   while (*pch) {
                       if (*pch == '.' || *pch == ')' || *pch == '(' || *pch == '*')
                          *pch = '_';
                       else if (*pch == '-' && *(pch+1) == '>') {
                           *pch = '_';
                           *(pch+1) = '_';
                           pch++;
                       }
                       pch++;
                   }
                   pch = Buffer;
               } else {
                   pch = "";
               }
               pSrc += sizeof(szARGVAL) - 1;
               }
           else if (!strncmp(pSrc, szARGOFF, sizeof(szARGOFF) - 1)) {
               pSrc += sizeof(szARGOFF) - 1;
               if (pCGenState->pArgsList) {
                   _itoa(pCGenState->pArgsList->OffSet, Buffer, 10);
                   pch = Buffer;
                   }
               }
           else if (!strncmp(pSrc, szARGADDR, sizeof(szARGADDR) - 1)) {
               pSrc += sizeof(szARGADDR) - 1;
               if (pCGenState->pArgsList) {
                   if (pCGenState->pArgsList->ArgLocal) {
                       pch = Buffer;
                       *pch = '&';
                       strcpy(pch+1, pCGenState->pArgsList->ArgLocal);
                       pSrc = SkipSubExpression(pSrc, NULL);                       }
                   else {
                       pch = Buffer;
                       pSrc = WriteArgAddr(pSrc,
                                           pCGenState,
                                           pch,
                                           sizeof(Buffer)-1
                                           );
                       }
                   }
               }
           else if (!strncmp(pSrc, szADDRARGSLIST, sizeof(szADDRARGSLIST) - 1)) {
               pSrc += sizeof(szADDRARGSLIST) - 1;
               pch = GetAddrFirstArg(pCGenState, Buffer, sizeof(Buffer) - 1);
               }
           else if (!strncmp(pSrc, szARGLOCAL, sizeof(szARGLOCAL) - 1)) {
               pSrc += sizeof(szARGLOCAL) - 1;
               if (pCGenState->pArgsList) {
                   pch = Buffer;
                   if (!WriteArgLocal(pCGenState, pch, sizeof(Buffer)-1)) {
                      ExitErrMsg(FALSE, "CGenerate failed\n");
                      }
                   }
               }
           else if (!strncmp(pSrc, szARGMORE, sizeof(szARGMORE) - 1)) {
               pSrc += sizeof(szARGMORE) - 1;
               pSrc = WriteMore(pSrc,
                                pCGenState,
                                pCGenState->pArgsList &&
                                pCGenState->pArgsList->ArgumentsEntry.Flink
                                  != &pCGenState->ExportsDbg->ArgsListHead
                                );
               }
           else if (!strncmp(pSrc, szTYPES, sizeof(szTYPES) - 1)) {
               pSrc += sizeof(szTYPES) - 1;
               pSrc = IncludeTypes(pSrc, pCGenState, FALSE);
               }
           else if (!strncmp(pSrc, szRTOLTYPES, sizeof(szRTOLTYPES) - 1)) {
               pSrc += sizeof(szRTOLTYPES) - 1;
               pSrc = IncludeTypes(pSrc, pCGenState, TRUE);
               }
           else if (!strncmp(pSrc, szRETTYPE, sizeof(szRETTYPE) - 1)) {
               pSrc += sizeof(szRETTYPE) - 1;
               pSrc = IncludeRetType(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szEXPORTLIST, sizeof(szEXPORTLIST) - 1)) {
               pSrc += sizeof(szEXPORTLIST) - 1;
               pSrc = ListApis(pSrc, pCGenState, TRUE);
               }
           else if (!strncmp(pSrc, szEXPNAME, sizeof(szEXPNAME) - 1)) {
               pSrc += sizeof(szEXPNAME) - 1;
               pch = pCGenState->ExportsDbg->ExportName;
               }
           else if (!strncmp(pSrc, szIFEXPFORWARD, sizeof(szIFEXPFORWARD) - 1)) {
               pSrc += sizeof(szIFEXPFORWARD) - 1;
               pch = GetAltExportName(Buffer,  pCGenState, sizeof(Buffer) - 1);
               }
           else if (!strncmp(pSrc, szIFORDINALS, sizeof(szIFORDINALS) - 1)) {
               pSrc += sizeof(szIFORDINALS) - 1;

               if (pCGenState->ExportsDbg &&
                   (pCGenState->ExportsDbg->Ordinal & 0x80000000))
                 {
                   pch = Buffer;
                   *pch = '@';
                   _itoa(IMPORDINAL(pCGenState->ExportsDbg->Ordinal),
                         pch + 1,
                         10
                         );
                   }
               }
           else if (!strncmp(pSrc, szLISTCOL, sizeof(szLISTCOL) - 1)) {
               pSrc += sizeof(szLISTCOL) - 1;
               pCGenState->ListCol = OutputColumn;
               }
           else if (!strncmp(pSrc, szDLLNAME, sizeof(szDLLNAME) - 1)) {
               Len = CopyToken(Buffer, DllBaseName, sizeof(Buffer) - 1);
               if (Len >= sizeof(Buffer) - 1) {
                   ExitErrMsg(FALSE, "OverFlow %s\n", pSrc);
                   }
               pch = Buffer;
               pSrc += sizeof(szDLLNAME) - 1;
               }
           else if (!strncmp(pSrc, szXPTNAME, sizeof(szXPTNAME) - 1)) {
               Len = CopyToken(Buffer, XptBaseName, sizeof(Buffer) - 1);
               if (Len >= sizeof(Buffer) - 1) {
                   ExitErrMsg(FALSE, "OverFlow %s\n", pSrc);
                   }
               pch = Buffer;
               pSrc += sizeof(szXPTNAME) - 1;
               }
           else if (!strncmp(pSrc, szDLLTARGET, sizeof(szDLLTARGET) - 1)) {
               Len = CopyToken(Buffer, pCGenState->CGen->FileBaseNameC, sizeof(Buffer) - 1);
               if (Len >= sizeof(Buffer) - 1) {
                   ExitErrMsg(FALSE, "Overflow %s\n", pSrc);
                   }
               pch = Buffer;
               pSrc += sizeof(szDLLTARGET) - 1;
               }
           else if (!strncmp(pSrc, szAPIUNKNOWN, sizeof(szAPIUNKNOWN) - 1)) {
               pSrc += sizeof(szAPIUNKNOWN) - 1;
               pSrc = WriteMore(pSrc,
                                pCGenState,
                                pCGenState->ExportsDbg->UnKnownApi
                                );
               }
           else if (!strncmp(pSrc, szAPINODECL, sizeof(szAPINODECL) - 1)) {
               pSrc += sizeof(szAPINODECL) - 1;
               pSrc = WriteMore(pSrc,
                                pCGenState,
                                pCGenState->ExportsDbg->UnKnownApi == 1
                                );
               }

           else if (!strncmp(pSrc, szAPISTRINGS, sizeof(szAPISTRINGS) - 1)) {
               pSrc += sizeof(szAPISTRINGS) - 1;
               if (pCGenState->ApiTypes) {
                   ApiStrings(pCGenState);
                   }
               }
           else if (!strncmp(pSrc, szDBGSINDEX, sizeof(szDBGSINDEX) - 1)) {
               char *pExpression, *pFree;
               int Index;

               pSrc += sizeof(szDBGSINDEX) - 1;
               pch = pSrc;
               pSrc = SkipSubExpression(pch, &pFree);

               if (pSrc != pch) {
                   if (!pFree && pCGenState->pArgsList ) {
                       pExpression = pCGenState->pArgsList->Type;
                       }
                   else {
                       pExpression = pFree;
                       }

                   Index = GetFuncIndex(pCGenState, pExpression);
                   if (Index == -1) {
                       ExitErrMsg(FALSE, "DebugsIndex unknown! %s\n", pch);
                       }

                   _itoa(Index, Buffer, 10);
                   pch = Buffer;
                   if (pFree) {
                       GenHeapFree(pFree);
                       }
                   }
               else {
                   pch = NULL;
                   }

               }

           else if (!strncmp(pSrc, szDBGSLIST, sizeof(szDBGSLIST) - 1)) {
               pSrc += sizeof(szDBGSLIST) - 1;
               pSrc = ListDbgs(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szDBGSSTRINGS, sizeof(szDBGSSTRINGS) - 1)) {
               pSrc += sizeof(szDBGSSTRINGS) - 1;
               WriteDbgsStrings(pSrc, pCGenState);
               }
           else if (!strncmp(pSrc, szDBGSMORE, sizeof(szDBGSMORE) - 1)) {
               pSrc += sizeof(szDBGSMORE) - 1;
               pSrc = WriteMore(pSrc, pCGenState, pCGenState->MoreApis);
               }
           else if (!strncmp(pSrc, szOFFSET, sizeof(szOFFSET) - 1)) {
               pSrc += sizeof(szOFFSET) - 1;
               pSrc = GetOffSet(pSrc, Buffer);
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szCPPEXPORT, sizeof(szCPPEXPORT) - 1)) {
               pSrc += sizeof(szCPPEXPORT) - 1;
               pSrc = WriteMore(pSrc,
                                pCGenState,
                                iHandleCpp > 0 && pCGenState->ExportsDbg->CplusDecoration
                                );
               }
           else if (!strncmp(pSrc, szCEXPORT, sizeof(szCEXPORT) - 1)) {
               pSrc += sizeof(szCEXPORT) - 1;
               pSrc = WriteMore(pSrc,
                                pCGenState,
                                !(iHandleCpp > 0 && pCGenState->ExportsDbg->CplusDecoration)
                                );
               }
           else if (!strncmp(pSrc, szCPPOUTPUT, sizeof(szCPPOUTPUT) - 1)) {
               pSrc += sizeof(szCPPOUTPUT) - 1;
               if (pCGenState->CGen->FileNameCpp != NULL) {
                   pCGenState->CGen->fp = pCGenState->CGen->fpCpp;
                   }
               }
           else if (!strncmp(pSrc, szCOUTPUT, sizeof(szCOUTPUT) - 1)) {
               pSrc += sizeof(szCOUTPUT) - 1;
               pCGenState->CGen->fp = pCGenState->CGen->fpC;
               }
           else if (!strncmp(pSrc, szIF, sizeof(szIF) - 1)) {
               BOOLEAN result;

               pSrc += sizeof(szIF) - 1;
               pSrc = ExtractBoolean1(pSrc, pCGenState, &result);
               pSrc = WriteMore(pSrc, pCGenState, result );

               if ( *pSrc == '@' &&
               !strncmp(pSrc+1, szELSE, sizeof(szELSE) - 1)) {
                    pSrc += sizeof(szELSE) - 1+1;               
                    pSrc = WriteMore(pSrc, pCGenState, !result);
                    }
               }
           else if (!strncmp(pSrc, szELSE, sizeof(szELSE) - 1)) {
               ExitErrMsg ( FALSE, "@Else not immediately following @If" );
               }
           else if (!strncmp(pSrc, szOR, sizeof(szOR) - 1)) {              
               BOOLEAN result1, result2;
               pSrc += sizeof(szOR) - 1;
               pSrc = ExtractBoolean2(pSrc, pCGenState, &result1, &result2);
               WriteBoolean ( Buffer, result1 || result2 );
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szAND, sizeof(szAND) - 1)) {            
               BOOLEAN result1, result2;
               pSrc += sizeof(szAND) - 1;
               pSrc = ExtractBoolean2(pSrc, pCGenState, &result1, &result2);
               WriteBoolean ( Buffer, result1 && result2 );
               pch = Buffer;
               }
           else if (!strncmp(pSrc, szNOT, sizeof(szNOT) - 1)) {            
               BOOLEAN result1;
               pSrc += sizeof(szNOT) - 1;
               pSrc = ExtractBoolean1(pSrc, pCGenState, &result1);
               WriteBoolean ( Buffer, !result1);
               pch = Buffer;
               }
           else {
                //
                // See if this is an '@macroname'
                //
                char MacroName[MAX_PATH];
                char *p = MacroName;
                char *pIn = pSrc;
                SIZE_T Bytes;

                while (isalnum(*pIn)) {
                    *p++ = *pIn++;
                }
                *p = '\0';
                if (ExpandMacro(MacroName, pCGenState, &pIn, BufferPos, MaxLen, &Bytes)) {
                   if (OutBuffer != NULL) {
                      Bytes--; // subtract off terminating zero.
                      BufferPos += Bytes;
                      MaxLen -= Bytes;
                      *BytesReturned += Bytes;                      
                   }
                   pSrc = pIn;
                } else {
                    ExitErrMsg(FALSE, "Unknown keyword '@%s'", MacroName);
                }
            }

           if (pch) {
               if (OutBuffer != NULL) {
                  SIZE_T Bytes;
                  CGenerateEx(pch, pCGenState, BufferPos, MaxLen, &Bytes);
                  Bytes--; // subtract off terminating zero.
                  BufferPos += Bytes;
                  MaxLen -= Bytes;
                  *BytesReturned += Bytes;
               }
               else {
                  while (*pch) 
                     pch = CGeneratePrintChar(pch, pCGenState);
               }
           }
      }
      
   }

   if (OutBuffer != NULL) {
      if(MaxLen == 0) {
         ExitErrMsg(FALSE, "Out of Buffer space!\n");
      }
      *BufferPos = '\0';
      *BytesReturned += 1;
   }

   return pSrc;
}


int GetMemberOffset(char *sTypeName, char *sMemberName)
{
    PKNOWNTYPES pkt = NULL;
    PMEMBERINFO pmi;
    int i;

    //
    // This is the same as running the lexer on a single identifier...
    //
    Tokens[0].TokenType = TK_IDENTIFIER;
    Tokens[0].Name = sTypeName;
    Tokens[1].TokenType = TK_EOS;

    CurrentTokenIndex = 0;
    if (ParseTypes(TypeDefsList, NULL, &pkt) && pkt != NULL) {
        pkt = GetBasicType(pkt->BaseName, TypeDefsList, StructsList);
    } else {
        CurrentTokenIndex = 0;
        ParseTypes(StructsList, NULL, &pkt);
    }

    if (pkt == NULL) {
        ExitErrMsg(FALSE,
               "GetOffSet: Unknown Type %s\n",
               sTypeName
               );
    }

    pmi = pkt->pmeminfo;
    while (pmi) {

        if (!pmi->sName) {
            //
            // Found a nameless member.  See if the member name we're
            // looking for is a member of this nameless member.
            //
            //  ie.  typedef struct { int bar; } FOO;
            //
            //       typedef struct TEST {
            //          union {
            //              int i;
            //              FOO;
            //          }
            //       } test;
            //
            // GetOffset(TEST, bar) will recurse when pmi points
            // at the memberinfo for the nameless member 'FOO'.
            //
            i = GetMemberOffset(pmi->sType, sMemberName);
            if (i != -1) {
                return i;
            }
        } else if (!strcmp(pmi->sName, sMemberName)) {
            return pmi->dwOffset;
        }
        pmi = pmi->pmeminfoNext;
    }
    return -1;
}


char *
GetOffSet(
    char *pSrc,
    char *Buffer
    )
{
    char *pOrg = pSrc;
    char *pch;
    int  Len;
    char TypeName[MAX_PATH];
    char MemberName[MAX_PATH];

    if (*pSrc != '(') {
        ExitErrMsg(TRUE, "GetOffset: Invalid %s\n", pSrc);
        }

    while (IsSeparator(*pSrc)) {
        pSrc = GetNextToken(pSrc);
        if (!*pSrc || *pSrc == ')') {
            ExitErrMsg(TRUE, "GetOffset: Invalid %s\n", pOrg);
            }
        }

    pch = TypeName;
    Len = sizeof(TypeName)-1;
    while ((*pSrc != ',') && (*pSrc != 0)) {
         if (!--Len) {
             *pch = '\0';
             ExitErrMsg(TRUE, "GetOffset: Overflow %s\n", TypeName);
             }
         *pch++ = *pSrc++;
         }
    *pch = '\0';


     while (IsSeparator(*pSrc)) {
         pSrc = GetNextToken(pSrc);
         if (!*pSrc || *pSrc == ')') {
             ExitErrMsg(TRUE, "GetOffset: Invalid %s\n", pOrg);
             }
         }

    pch = MemberName;
    Len = sizeof(MemberName)-1;
    while (!IsSeparator(*pSrc)) {
         if (!--Len) {
             *pch = '\0';
             ExitErrMsg(TRUE, "GetOffset: Overflow %s\n", MemberName);
             }
         *pch++ = *pSrc++;
         }
    *pch = '\0';

    while (*pSrc && *pSrc++ != ')') {
         ;
         }

    Len = GetMemberOffset(TypeName, MemberName);
    if (Len < 0) {
        ExitErrMsg(FALSE,
               "GetOffSet: Unknown Member %s.%s\n",
               TypeName,
               MemberName
               );

    } 
    
    _ltoa(Len, Buffer, 16);
    return(pSrc);
}






/*
 *  GetRetSize
 *
 */
int GetRetSize(PCGENSTATE pCGenState)
{
    FILE *fp = pCGenState->CGen->fp;
    PKNOWNTYPES pkt;
    int i, Len;
    int RetSize, RetIndLevel;

    if (!pCGenState->ApiTypes) {
        fprintf(pCGenState->CGen->fp,
                "\n\t*** ERROR ***\n*** GetRetSize: No Api defined\n\n"
                );
        return -1;
    }

    // Get KnownTypes info for Return Type.  Can't use the ApiTypes->pktRet
    // cache as ParseIndirection() needs the state of the parse.
    ResetLexer();
    LexMacroArgs(pCGenState->ApiTypes->FuncRet);
    ConsumeConstVolatileOpt();

    if (ParseTypes(TypeDefsList, NULL, &pkt) == FALSE) {
       CurrentTokenIndex = 0;
       if (ParseTypes(StructsList, NULL, &pkt) == FALSE ) {

           fprintf(pCGenState->CGen->fp,
                   "\n\t*** ERROR ***\n*** GetRetSize: Undefind Type %s\n\n",
                   pCGenState->ApiTypes->FuncRet
                   );

           return -1;
        }
    }

   if (pCGenState->ApiTypes->RetIndLevel) {
      RetSize = SIZEOFPOINTER;
   } else {
      RetSize = pkt->Size;
   }

   return RetSize;
}

/*
 *  GetArgSize
 *
 */
int GetArgSize(PEXPORTSDEBUG ExportDebug)
{
   PARGSLIST pArgsList;
   PLIST_ENTRY Next;
   int Total = 0;
   int ArgSize;           

   if (IsListEmpty(&ExportDebug->ArgsListHead)) {
       return -1;
       }

   if (ExportDebug->ArgsSize >= 0) {
       return ExportDebug->ArgsSize;
       }

   if (ExportDebug->IntForward && ExportDebug->IntForward->ArgsSize >= 0) {
       ExportDebug->ArgsSize = ExportDebug->IntForward->ArgsSize;
       return ExportDebug->ArgsSize;
       }

   Next = ExportDebug->ArgsListHead.Flink;

   // check for void arg list
   pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);
   if (!pArgsList->Name && strcmp(pArgsList->Type, szVARGS)) {
       return 0;
       }

   do {
       pArgsList = CONTAINING_RECORD(Next,ARGSLIST, ArgumentsEntry);

       ArgSize = (pArgsList->ArgSize + 3) & ~3;
       Total += ArgSize;

       Next= Next->Flink;

     } while (Next != &ExportDebug->ArgsListHead);

   ExportDebug->ArgsSize = Total;

   if (ExportDebug->IntForward) {
       ExportDebug->IntForward->ArgsSize = Total;
       }

   return Total;
}


/*
 *  ApiStrings
 *
 */
void ApiStrings(PCGENSTATE pCGenState)
{
    FILE *fp = pCGenState->CGen->fp;
    PLIST_ENTRY Next;
    PARGSLIST pArgsList;
    PKNOWNTYPES pkt;
    int ArgSize, IndLevel;
    char *pRet;
    char BaseName[MAX_PATH];
    char *c;

    // copy in the DLL name and whack off the extension
    strcpy(BaseName, DllBaseName);
    c = strchr(BaseName, '.');
    if (c) {
        *c = '\0';
    }

    //
    // Write the ApiName <"ApiName", ">
    //
    fprintf(fp, "\"%s!%s\", \"", BaseName, pCGenState->ExportsDbg->ExportName);

    //
    // Write out the Args <Arg1 %x, ArgN %x>
    //
    if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
        fprintf(fp,
                "\n\t*** ERROR ***\n*** ArgFormat Missing argument List: %s\n\n",
                pCGenState->ApiTypes->TypeName
                );
        return;
    }

    Next = pCGenState->ExportsDbg->ArgsListHead.Flink;

    do {
        pArgsList = CONTAINING_RECORD(Next,ARGSLIST, ArgumentsEntry);

        // check for void arg list
        if (!pArgsList->Name) {
            break;
        }

        fprintf(fp, "%s %s ",
                pArgsList->pKnownTypes->TypeName,
                pArgsList->Name
                );

        // check for vargs
        if (!strcmp(pArgsList->Name, szVARGS)) {
            break;
        }

        ArgSize = pArgsList->ArgSize;

        while (ArgSize > 0) {
           ArgSize -= sizeof(int);
           fprintf(fp,
                   "%s%s",
                   "%x",
                   ArgSize > 0 ? "." : ""
                   );
        }

        Next= Next->Flink;
        if (Next != &pCGenState->ExportsDbg->ArgsListHead) {
            fputc(',', fp);
        }

    } while (Next != &pCGenState->ExportsDbg->ArgsListHead);

    //
    // Write out Return Type <", "RetType %x">
    //
    pRet = pCGenState->ApiTypes->FuncRet;
    fprintf(fp, "\", \"%s ", pRet);

    ResetLexer();
    LexMacroArgs(pRet);
    ConsumeConstVolatileOpt();

       // Get Known Types for size of Return Type
    if (ParseTypes(TypeDefsList, NULL, &pkt) == FALSE) {
        CurrentTokenIndex = 0;
        if (ParseTypes(StructsList, NULL, &pkt) == FALSE) {

            fprintf(pCGenState->CGen->fp,
                    "\n\t*** ERROR ***\n*** GetRetSize: Undefind Type %s\n\n",
                    pCGenState->ApiTypes->FuncRet
                    );
            return;
        }
    }

    ArgSize = pkt->Size;
    ParseIndirection(NULL, &ArgSize, NULL, NULL, NULL);

    while (ArgSize > 0) {
        ArgSize -= sizeof(int);
        fprintf(fp,
                "%s%s",
                "%x",
                ArgSize > 0 ? "." : ""
                );
    }

    fprintf(fp, "\"");
}






char *
GetAddrFirstArg(
      PCGENSTATE pCGenState,
      char *Buffer,
      int BuffLen)
{

     PLIST_ENTRY pFirstEntry;
     PARGSLIST pArgsList;

     if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
         return "NULL";
         }

     pFirstEntry = pCGenState->ExportsDbg->ArgsListHead.Flink;
     pArgsList = CONTAINING_RECORD(pFirstEntry, ARGSLIST, ArgumentsEntry);
     if (!pArgsList->Name) {
         return "NULL";
         }

     Buffer[0] = '&';
     BuffLen--;

     if ((int)strlen(pArgsList->Name) > BuffLen) {
         ExitErrMsg(TRUE, "gafa: Overflow %s\n", pArgsList->Name);
         }

     strcpy(&Buffer[1], pArgsList->Name);

     return Buffer;
}



/*
 *  IfArgs
 *
 */
char *IfArgs(char *pSrc, PCGENSTATE pCGenState)
{
   BOOL bMore = TRUE;
   PARGSLIST pArgsList;
   PLIST_ENTRY pFirstEntry;
   PKNOWNTYPES pkt;


      // skip empty list,
   if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
       bMore = FALSE;
       }

      // check for void arg list
   else {
      pFirstEntry = pCGenState->ExportsDbg->ArgsListHead.Flink;
      pArgsList = CONTAINING_RECORD(pFirstEntry, ARGSLIST, ArgumentsEntry);
      if (!pArgsList->Name) {
          pkt = GetNameFromTypesList(TypeDefsList, pArgsList->Type);
          if (!pkt) {
              pkt = GetNameFromTypesList(StructsList, pArgsList->Type);
              }
          if (!pkt) {
              ExitErrMsg(FALSE,
                         "ifArgs: Unknown Type %s\n",
                         pArgsList->Type
                         );
              }

          if (!pkt->IndLevel && !strcmp(pkt->BasicType, szVOID)) {
              bMore = FALSE;
              }
          }
      }

   return WriteMore(pSrc,pCGenState, bMore);
}




/*
 *  IfApiRet
 *
 */
char *IfApiRet(char *pSrc, PCGENSTATE pCGenState)
{
    int i, Len;
    BOOL bMore = TRUE;
    PKNOWNTYPES pkt;

    ResetLexer();
    LexMacroArgs(pCGenState->ApiTypes->FuncRet);
    ConsumeConstVolatileOpt();

    if (ParseTypes(TypeDefsList,NULL, &pkt) == FALSE) {
        CurrentTokenIndex = 0;
        if (ParseTypes(StructsList, NULL, &pkt) == FALSE) {
            bMore = FALSE;
        }
    }

    if (bMore && CurrentToken()->TokenType != TK_STAR &&
        !pkt->IndLevel && !strcmp(pkt->BasicType, szVOID)) {
        bMore = FALSE;
    }

    return WriteMore(pSrc, pCGenState, bMore);
}


char *
IfApiCode(
    char *pSrc,
    PCGENSTATE pCGenState
    )
/*++

Routine Description:

    Expands an EFunc's codeburst, if it exists.  ie. @IfApiCode(foo) will
    expand to the 'foo=' section of the current EFunc, if the current EFunc
    has a 'foo='.  Otherwise, there is no expansion.

Arguments:

    pSrc        - pointer to character following '@IfApiCode'
    pCGenState  - current code-gen state

Return Value:

    pointer to character following the end of the ')'

--*/
{
    char *pch;
    char *pEnd;
    size_t  Len;
    int CodeBurstIndex;
    char CodeName[MAX_PATH];
    char *CodeBurst;

    pch = SkipSubExpression(pSrc, NULL);
    if (pSrc == pch) {
        return pSrc;
    }
    pEnd = pch;

    pch = pSrc+1;
    if (IsSeparator(*pch)) {
        return pSrc;
    }

    pSrc = pch;
    while (!IsSeparator(*pch)) {
        pch++;
    }
    Len = pch - pSrc;

    // Copy name to a buffer and null-terminate
    memcpy(CodeName, pSrc, Len);
    CodeName[Len] = '\0';

    CodeBurstIndex = GetExistingCodeBurstIndex(CodeName);
    if (CodeBurstIndex == -1) {
        ExitErrMsg(FALSE, "CodeBurst '%s' unknown.\n", CodeName);
    }

    if (pCGenState->ExTemplate) {
        CodeBurst = pCGenState->TempleEx->CodeBurst[CodeBurstIndex];
        if (CodeBurst) {
            //
            // There is an [Efunc] with a non-empty codeburst for this API.
            // Generate its codeburst.
            //
            CGenerate(CodeBurst, pCGenState);
        }
    }

    return pEnd;
}


/*
 *  CheckFastCallArgs
 *
 */
BOOLEAN
FastCallArgs(
    PLIST_ENTRY ArgsListHead,
    int ArgLimit,
    BOOL fCheckTypes,
    BOOL fCheckFirstArgType    
    )
{
   PARGSLIST pArgsList;
   PTEMPLES pTypeTemple;
   PKNOWNTYPES pktTemple;
   int tplIndLevel, NumArgs, ArgSize;
   PLIST_ENTRY Next, NextTemple;

   if (IsListEmpty(ArgsListHead)) {
       return FALSE;
       }


   Next = ArgsListHead->Flink;

   // check for void arg list, or vargs as first arg
   pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);
   if (!pArgsList->Name) {
       return strcmp(pArgsList->Type, szVARGS) ? TRUE : FALSE;
       }

   NumArgs = 0;
   while (Next != ArgsListHead) {
       pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);

       //
       // Cannot have more than 4 args
       //

       if (++NumArgs > ArgLimit) {
           return FALSE;
           }


       //
       // arg size must be dword or less
       //

       ArgSize = (pArgsList->ArgSize + 3) & ~3;

       if (ArgSize < 0 || ArgSize > 4) {
           return FALSE;
           }

       //
       // vargs of any indlevel aren't allowed
       //

       if (!strcmp(pArgsList->pKnownTypes->BaseName, szVARGS)) {
           return FALSE;
           }

       //
       // floats of Zero IndLevel aren't allowed
       //

       if (pArgsList->IndLevel == 0 &&
           !strcmp(pArgsList->pKnownTypes->BaseName, szFLOAT))
          {
           return FALSE;
           }


       //
       // type templates are not allowed except for the first arg in methods
       //

       if ((fCheckTypes) &&
           ((NumArgs != 1) ||
           ((NumArgs == 1) && fCheckFirstArgType))) {
           NextTemple = TypeTempleList.Flink;
           while (NextTemple != &TypeTempleList) {
               pTypeTemple = CONTAINING_RECORD(NextTemple, TEMPLES, TempleEntry);


               //
               // get the Known types info for each type template.
               //

               pktTemple = pTypeTemple->pktType;
               if (!pktTemple) {

                   //
                   // Don't have the Known types info yet, fetch it
                   // and save it in the TypeTemplate
                   //

                   pktTemple = GetNameFromTypesList(TypeDefsList,
                                                pTypeTemple->Name
                                                );
                   if (!pktTemple) {
                       pktTemple = GetNameFromTypesList(StructsList,
                                                        pTypeTemple->Name
                                                    );
                       }
    
                   pTypeTemple->pktType = pktTemple;
                   }

               if (!pktTemple) {
                   ExitErrMsg(FALSE,
                          "Temple: Type not found %s\n",
                          pTypeTemple->Name
                          );
                   }


               //
               // See if arg matches this type template
               //

               if (IsSameType(pArgsList->pKnownTypes,
                              pArgsList->IndLevel,
                              TK_NONE,
                              pTypeTemple->Name,
                              pTypeTemple->IndLevel + pktTemple->IndLevel,
                              TK_NONE,
                              TRUE
                              ))
                  {
                   return FALSE;
                  }

               NextTemple = NextTemple->Flink;
               }  
           }
           Next= Next->Flink;
       }


   return TRUE;
}


BOOLEAN
IsFastCall(
     PCGENSTATE pCGenState
)
{
     if (!pCGenState->ExportsDbg) { // can this occur ?
         return FALSE;
         }

     //
     // If first time, determine if Api can be a fastcall.
     // tri state flag, where:
     //    -1 == Cannot be a fastcall
     //    0  == undetermined
     //    1  == Can be a fastcall
     //

     if (!pCGenState->ExportsDbg->FastCall) {
         int Size;

         pCGenState->ExportsDbg->FastCall = -1; // assume not a fastcall

         //
         // Fast call criteria:
         // 1. NOT have an exception template.
         // 2. each param up to 4 bytes (exclude structures)
         // 3. 0 to 4 params
         // 4. return 0 or 1 dword.
         // 5. Not be a float or a VARGS
         // 6. Not have have a type template
         // 7. Must not be in the EFastTemplate list
         // 8. Must not have a C++ linkage
         //

         if (!pCGenState->ExTemplate && !pCGenState->ExportsDbg->CplusDecoration) {
             Size =  GetRetSize(pCGenState);
             if (Size >= 0 && Size <= 4 &&
                 !GetTemplate(&EFastTempleList, pCGenState->ExportsDbg->ExportName) &&
                 FastCallArgs(&pCGenState->ExportsDbg->ArgsListHead, 4, TRUE, TRUE))
                {
                 pCGenState->ExportsDbg->FastCall = 1;
                 }
             }
         }

     return pCGenState->ExportsDbg->FastCall == 1;
}

METHODTYPE
GetX2NMethodType(
     PCGENSTATE pCGenState
     )
{
    int RetSize;

         //
         // Fast X2N method criteria:
         // 1. NOT have an exception template.
         // 2. each param up to 4 bytes (exclude structures)
         // 3. Number of parameters between 1 and MAXX2NPARAMETERS 
         // 4. return 0 or 1 dword.
         // 5. Not be a float or a VARGS
         // 6. Not have have a type template, except for this pointer
         // 7. Must not be in the EFastTemplate list
         // 8. Must not have a C++ linkage
         //

         //
         // Slow X2N method criteria:
         // 1. NOT have an exception template.
         // 2. each param up to 4 bytes (exclude structures)
         // 3. Number of parameters between 1 and MAX2NPARAMETERS 
         // 4. return 0 or 1 dword.
         // 5. Not be a float or a VARGS
         // 6. Must not be in the EFastTemplate list
         // 7. Must not have a C++ linkage
         //

         // Fat X2N methods are neither Slow X2N methods or Fast X2N methods


    if (!pCGenState->ExportsDbg) { // can this occur ?
         return FALSE;
         }

    if (pCGenState->ExportsDbg->X2NMethodType == UNKNOWNMETHOD) {

        RetSize = GetRetSize(pCGenState);
        if (pCGenState->ExTemplate ||
            pCGenState->ExportsDbg->CplusDecoration ||
            GetTemplate(&EFastTempleList, pCGenState->ExportsDbg->ExportName) ||
            (RetSize > 4) || (RetSize < 0)) {
            pCGenState->ExportsDbg->X2NMethodType = FATX2NMETHOD;
            }
        else if (FastCallArgs(&pCGenState->ExportsDbg->ArgsListHead, MAXX2NPARAMETERS, TRUE, FALSE)) {
            pCGenState->ExportsDbg->X2NMethodType = FASTX2NMETHOD;
            }
        else if (FastCallArgs(&pCGenState->ExportsDbg->ArgsListHead, MAXX2NPARAMETERS, FALSE, FALSE)) {
            pCGenState->ExportsDbg->X2NMethodType = SLOWX2NMETHOD;
            }
        else {
            pCGenState->ExportsDbg->X2NMethodType = FATX2NMETHOD;
            }
        }

    return(pCGenState->ExportsDbg->X2NMethodType);
}

/*
 *  IfRetType
 *
 */
char *IfRetType(char *pSrc, PCGENSTATE pCGenState)
{
   char *pch;
   BOOL bMore = FALSE;
   char c;
   
   pch = GetNextToken(pSrc);
   if (pch != pSrc)
   {
       bMore = ( ! strncmp(pch, pCGenState->ApiTypes->FuncRet,
                                strlen( pCGenState->ApiTypes->FuncRet)));
   }
   pSrc = GetNextToken(pch);
   
   pch = WriteMore(pSrc ,pCGenState, bMore);   
   
   return(pch);
}

/*
 *  IfNotRetType
 *
 */
char *IfNotRetType(char *pSrc, PCGENSTATE pCGenState)
{
   char *pch;
   BOOL bMore = FALSE;
   char c;
   
   pch = GetNextToken(pSrc);
   if (pch != pSrc)
   {
       bMore = (strncmp( pch, pCGenState->ApiTypes->FuncRet, strlen( pCGenState->ApiTypes->FuncRet ) ) != 0);
   }
   pSrc = GetNextToken(pch);
   
   pch = WriteMore(pSrc ,pCGenState, bMore);   
   
   return(pch);
}

BOOL
ExpandType(
   PCGENSTATE pCGenState,
   PKNOWNTYPES pkt,
   PLIST_ENTRY pTempleList,
   int CodeBurstIndex
   )
{
   
   PARGSLIST pArgsList;
   PKNOWNTYPES pktTemple;
   int tplIndLevel;
   PLIST_ENTRY NextArg, NextTemple;
   PTEMPLES pTypeTemple;
   BOOL bMatchFound = FALSE;
   int i;

   pArgsList = pCGenState->pArgsList;

   i=2;
   while (i--) {
       NextTemple = pTempleList->Flink;
       while (NextTemple != pTempleList) {
           pTypeTemple = CONTAINING_RECORD(NextTemple, TEMPLES, TempleEntry);

           tplIndLevel = pTypeTemple->IndLevel;
           pktTemple = pTypeTemple->pktType;
           if (!pktTemple) {
               pktTemple = GetNameFromTypesList(TypeDefsList,
                                                pTypeTemple->Name
                                               );
               if (!pktTemple) {
                   pktTemple = GetNameFromTypesList(StructsList,
                                                    pTypeTemple->Name
                                                   );
               }
               pTypeTemple->pktType = pktTemple;
           }


           if (!pktTemple) {
               ExitErrMsg(FALSE,
                          "Temple: Type not found %s\n",
                          pTypeTemple->Name
                          );
           }

           tplIndLevel += pktTemple->IndLevel;

           if (IsSameType(pkt,
                          pArgsList->IndLevel,
                          pArgsList->tkDirection,
                          pTypeTemple->Name,
                          tplIndLevel,
                          pTypeTemple->tkDirection,
                          i == 0
                          )) {
                DbgPrintf("ttpl: MEMBER %s.%s Type=%s IndLevel=%d\n",
                          pCGenState->ApiTypes->FuncRet,
                          pTypeTemple->Name,
                          pTypeTemple->Name,
                          pTypeTemple->IndLevel
                         );

               if(ExpandTemple(pTypeTemple, CodeBurstIndex, pCGenState)){
                   return TRUE;
               }
           }

       NextTemple = NextTemple->Flink;
       }

   }

   return FALSE;

}

BOOL IsInNoType(PCHAR *NoTypes, PMEMBERINFO pmi) {
    SIZE_T NoTypeCount;
    if (NoTypes == NULL || pmi->sName == NULL) {
       return FALSE;
    }
    for (NoTypeCount=0; NoTypeCount<MAX_NOTYPE; ++NoTypeCount) {  
        if (!NoTypes[NoTypeCount]) {
            return FALSE;
        }
        else {
           if (strcmp(pmi->sName, NoTypes[NoTypeCount]) == 0) {
              return TRUE;
           }
        }
    }
    return FALSE;
}

SIZE_T CountNoTypes(PCHAR *NoTypes) {
   SIZE_T Count = 0;
   if (NoTypes == NULL) {
      return 0;
   }
   while(*NoTypes++ != NULL) {
      Count++;
   }
   return Count;
}

VOID pMemberTypes( PCGENSTATE pCGenState, int CodeBurstIndex, char *MemReference, BOOL bBtoT);

void ExpandMemberType( PMEMBERINFO pmi, CGENSTATE CGenState, int CodeBurstIndex,
    PKNOWNTYPES pktStruct, char* pszStructName, char *pszHostCastedStructName, PARGSLIST pArgsList, FILE* fpLog,
    PARGSLIST pArgsListOld, char *pMemReference, BOOL bBtoT)
{                      
    char *sName;
    char *sNameNew;
    char *sHostCastedName;
    int i, Len, HostCastedNameLen;
    int tplIndLevel;
    PLIST_ENTRY NextArg, NextTemple;
    PTEMPLES pTypeTemple;
    PKNOWNTYPES pktTemple;
    PKNOWNTYPES pkt;
    BOOL bAddCast = TRUE;
    SIZE_T NoTypeCount;
    char Type[MAX_PATH];
    PARGSLIST pArgsListTemp;

    // Determine if this member should be expanded by checking for a NoType entry.
    if (pmi->sName != NULL) {
       if(IsInNoType(CGenState.CurrentTemple->NoTypes, pmi) ||
          IsInNoType(CGenState.MemberNoType, pmi)) {
          goto NextMember;
       }
    }

    // Get the pkt for the member type
    if ( pmi->pktCache )
    {
        pkt = pmi->pktCache;
    }
    else
    {
        ResetLexer();
        LexMacroArgs(pmi->sType);
        ConsumeConstVolatileOpt();

        if (ParseTypes(TypeDefsList,NULL, &pkt) == FALSE)
        {
            CurrentTokenIndex = 0;
            if ( ParseTypes( StructsList, NULL, &pkt ) == FALSE )
            {
                fprintf( fpLog, "%s *** WARNING *** Member %s->%s skipped - unknown type\n", CGenState.Temple->Comment,
                    pszStructName, pmi->sType );

                goto NextMember;
            }
        }
        pmi->pktCache = pkt;
    }

    if ( pktStruct == pkt )
    {
        //
        // Rats!  The structure contains a member which is a pointer
        // with the same type as this structure.  ie.  this struct
        // is self-referential.  We can't expand it as the expansion
        // is recursive.
        //
        fprintf( fpLog, "%s *** WARNING *** Member %s->%s skipped - self-referencing structure\n", CGenState.Temple->Comment,
            pszStructName, pmi->sType );

        goto NextMember;
    }        
        
    // Build the new names.
    sName = pmi->sName;
    
    // This is a type without a name. No casting is needed.    
    if (pktStruct->Flags & BTI_ANONYMOUS) {

       if (sName == NULL) {
          sHostCastedName = CheckHeapAlloc(strlen(pszHostCastedStructName) + 1); 
          sNameNew = CheckHeapAlloc(strlen(pszStructName) + 1);
          strcpy(sHostCastedName, pszHostCastedStructName);
          strcpy(sNameNew, pszStructName);
       }

       else {
          sHostCastedName = CheckHeapAlloc(strlen(pszHostCastedStructName) + strlen(pMemReference) + strlen(sName) + 1);
          strcpy(sHostCastedName, pszHostCastedStructName);
          strcat(sHostCastedName, pMemReference);
          strcat(sHostCastedName, sName);
          sNameNew = CheckHeapAlloc(strlen(pszStructName) + strlen(pMemReference) + strlen(sName) + 1);
          strcpy(sNameNew, pszStructName);
          strcat(sNameNew, pMemReference);
          strcat(sNameNew, sName);
       }

    }
    else {
       
       pArgsListTemp = CGenState.pArgsList;
       CGenState.pArgsList = pArgsListOld;
       if (IsPointer(&CGenState)) {
           ArgTypeInd(Type, &CGenState, TRUE);
           strcat(Type, " *");
       }
       else {
           ArgHostType(Type, &CGenState);
       }
   
       if (CGenState.pArgsList->bIsBitfield ||
               (CGenState.pArgsList->IndLevel == 0 &&
                CGenState.pArgsList->pKnownTypes->IndLevel == 0 &&
                  (strcmp(CGenState.pArgsList->pKnownTypes->BasicType, "struct") == 0 ||
                   strcmp(CGenState.pArgsList->pKnownTypes->BasicType, "enum") == 0 ||
                   strcmp(CGenState.pArgsList->pKnownTypes->BasicType, "union") == 0)
                  )
                
           ) {
           bAddCast = FALSE;
       }
       else {
           bAddCast = TRUE;
       }
   
       CGenState.pArgsList = pArgsListTemp;
       
       HostCastedNameLen = strlen(pszHostCastedStructName) + strlen(Type) + 8; 
              
       Len = strlen(pszStructName) + 1;

       if (sName != NULL) {
          HostCastedNameLen += strlen(pMemReference) + strlen(sName);
          Len += strlen(pMemReference) + strlen(sName);
       
       }
   
       if (Len >= MAX_PATH || HostCastedNameLen >= MAX_PATH) {
           fprintf( fpLog,
                    "%s *** WARNING *** Member %s->%s skipped - name is too long\n",
                    CGenState.Temple->Comment,
                    pszStructName,
                    pmi->sType
                  );
           goto NextMember;
   
       }
   
       sHostCastedName = CheckHeapAlloc(HostCastedNameLen);
       sHostCastedName[0] = '\0';
   
       if (bAddCast) {
           strcpy(sHostCastedName, "((");
           strcat(sHostCastedName, Type);
           strcat(sHostCastedName, ")(");
           strcat(sHostCastedName, pszHostCastedStructName);
           strcat(sHostCastedName, "))");
       }
       else {
           strcat(sHostCastedName, pszHostCastedStructName);
       }
   
       if(sName != NULL) {
          strcat(sHostCastedName, pMemReference);
          strcat(sHostCastedName, sName);
       }
           
       sNameNew = CheckHeapAlloc(Len);        
       strcpy(sNameNew, pszStructName);
       
       if(sName != NULL) {
          strcat(sNameNew, pMemReference);
          strcat(sNameNew, sName);       
       }

    }
        
    pArgsList->pKnownTypes = pkt;
    pArgsList->ArgSize = pkt->Size;
    pArgsList->IsPtr64 = pmi->bIsPtr64;
    pArgsList->OffSet = -1;     // there is no stack offset for this member
    pArgsList->IndLevel = pmi->IndLevel;
    // pArgsList->tkDirection is same as the original arg
    pArgsList->Type = pmi->sType;
    pArgsList->pStructType = NULL;
    pArgsList->Mod = TK_NONE;
    pArgsList->SUEOpt = TK_NONE;
    pArgsList->PostMod = TK_NONE;
    pArgsList->PrePostMod = TK_NONE;
    pArgsList->Name = sNameNew;
    pArgsList->ArgLocal = sNameNew;
    pArgsList->HostCastedName = sHostCastedName;
    pArgsList->fIsMember      = TRUE;
    pArgsList->bIsBitfield = pmi->bIsBitfield;        
    pArgsList->BitsRequired= pmi->BitsRequired;       
    pArgsList->bIsArray    = pmi->bIsArray;           
    pArgsList->ArrayElements=pmi->ArrayElements;
    pArgsList->fRequiresThunk = ((pkt->Flags & BTI_CONTAINSFUNCPTR) != 0);

    if (sName != NULL) {
       CGenState.MemberNoType = NULL;
       ExpandType(&CGenState, pArgsList->pKnownTypes, &TypeTempleList, CodeBurstIndex);        
    }
    else {
       
       // This field is a nameless field in a structure or union.
       // Example:
       //     struct foobar {
       //         int x;
       //     };
       //     struct foobar2 {
       //         struct foobar;
       //         int y;
       //     };
       // foobar2 will import all the fields of foobar.
       //
       // When walking down the structure, we want to continue expanding foobar when we reach the nameless field.
       
       SIZE_T NumNoTypes1, NumNoTypes2;
       PCHAR *NewNoTypes;
       
       NumNoTypes1 = CountNoTypes(CGenState.MemberNoType); 
       NumNoTypes2 = CountNoTypes(CGenState.CurrentTemple->NoTypes);
       if (NumNoTypes1 + NumNoTypes2 + 1 > MAX_NOTYPE) {
          ExitErrMsg(FALSE, "ExpandMemberType: too many notypes.\n");
       }
       NewNoTypes = CheckHeapAlloc((NumNoTypes1 + NumNoTypes2 + 1)*sizeof(PCHAR));
       
       memcpy(NewNoTypes, CGenState.MemberNoType, NumNoTypes1 * sizeof(PCHAR));
       memcpy(NewNoTypes + NumNoTypes1, CGenState.CurrentTemple->NoTypes, NumNoTypes2 * sizeof(PCHAR));
       NewNoTypes[NumNoTypes1 + NumNoTypes2] = NULL;
       CGenState.MemberNoType = NewNoTypes;
       pMemberTypes( &CGenState, CodeBurstIndex, pMemReference, bBtoT);
       GenHeapFree(NewNoTypes);
    }

    GenHeapFree(sNameNew);
    GenHeapFree(sHostCastedName); 

NextMember:;
}

void ExpandMemberTypesBackwards( PMEMBERINFO pmi, CGENSTATE CGenState, int CodeBurstIndex,
    PKNOWNTYPES pktStruct, char* pszStructName, char *pszHostCastedStructName, PARGSLIST pArgsList, FILE* fpLog,
    PARGSLIST pArgsListOld, char *pMemReference, BOOL bBtoT)
{
    if ( pmi->pmeminfoNext != NULL )
    {
        ExpandMemberTypesBackwards( pmi->pmeminfoNext, CGenState, CodeBurstIndex, pktStruct,
            pszStructName, pszHostCastedStructName, pArgsList, fpLog,
            pArgsListOld, pMemReference, bBtoT);
    }

    ExpandMemberType( pmi, CGenState, CodeBurstIndex, pktStruct,
        pszStructName, pszHostCastedStructName, pArgsList, fpLog,
        pArgsListOld, pMemReference, bBtoT);
}

VOID pMemberTypes( PCGENSTATE pCGenState, int CodeBurstIndex, char *MemReference, BOOL bBtoT) {
    
    int Len;
    PCGENERATE pCGen;
    CGENSTATE CGenState;
    PKNOWNTYPES pkt;
    PKNOWNTYPES pktLast;
    ARGSLIST ArgsListOld;
    PMEMBERINFO pmi;

    pCGen = CheckHeapAlloc(sizeof(CGENERATE)+strlen(pCGenState->CGen->TempleName)+1);

    InitializeListHead(&pCGen->CGenerateEntry);
   
    pCGen->fp = pCGenState->CGen->fp;
    pCGen->FileNameC = pCGenState->CGen->FileNameC;
    pCGen->FileBaseNameC = pCGenState->CGen->FileBaseNameC;
    pCGen->fpCpp = pCGenState->CGen->fpCpp;
    pCGen->FileNameCpp = pCGenState->CGen->FileNameCpp;
    pCGen->FileBaseNameCpp = pCGenState->CGen->FileBaseNameCpp;
    strcpy(pCGen->TempleName, pCGenState->CGen->TempleName);
   
    CGenState = *pCGenState;
    CGenState.CGen = pCGen;

    pkt = pCGenState->pArgsList->pKnownTypes;
    while(pkt->pTypedefBase != NULL) {
       pkt = pkt->pTypedefBase;
    }
    pCGenState->pArgsList->pStructType = pkt;

    // Save the old ARGSLIST away
    ArgsListOld = *(pCGenState->pArgsList);

    // get a ptr to the member list for the struct
    pmi = pkt->pmeminfo;
    if ( !pmi )
    {
        ExitErrMsg(FALSE, "Type '%s' is not a struct", pCGenState->pArgsList->Type);
    }

    if(strcmp(pkt->BasicType, "union") == 0) {
        PMEMBERINFO pmiTemp;
        // check if any of the members of this union are in the notype list.
        for (pmiTemp = pkt->pmeminfo; pmiTemp != NULL; pmiTemp = pmiTemp->pmeminfoNext) {
           if (IsInNoType(pCGenState->MemberNoType, pmiTemp) || 
               IsInNoType(pCGenState->CurrentTemple->NoTypes, pmiTemp)) {
               //A member of the union is in the notype list, skip union.
               goto done;
           }
        }
    }

    // loop over each member variable within the type
    if ( bBtoT )
    {
        do
        {
            ExpandMemberType( pmi, CGenState, CodeBurstIndex, ArgsListOld.pKnownTypes, ArgsListOld.Name, 
                ArgsListOld.HostCastedName, pCGenState->pArgsList, pCGenState->CGen->fp,
                &ArgsListOld, MemReference, bBtoT);
            pmi = pmi->pmeminfoNext;
        }
        while ( pmi != NULL );
    }
    else
    {
        ExpandMemberTypesBackwards( pmi, CGenState, CodeBurstIndex, ArgsListOld.pKnownTypes, ArgsListOld.Name,
                ArgsListOld.HostCastedName, pCGenState->pArgsList, pCGenState->CGen->fp,
                &ArgsListOld, MemReference, bBtoT);
    }

done:
    // Restore the old ARGSLIST
    *pCGenState->pArgsList = ArgsListOld;
    GenHeapFree(pCGen);
}

char* MemberTypes( char *pSrc, PCGENSTATE pCGenState, BOOL bBtoT)
/*++

Routine Description:

    Expands [Type] templates for the return value of an API call.

Arguments:

    pSrc        - pointer to character following '@RetType'
    pCGenState  - current code-gen state

Return Value:

    pointer to character following the end of the ')'

--*/
{
    char *pEnd;
    char *pch;
    int Len;
    char BurstName[MAX_PATH];
    int CodeBurstIndex;
    PMACROARGSLIST pMArgsList = NULL;
    SIZE_T BytesReturned;

    char MemReference[MAX_PATH];

    pch = SkipSubExpression(pSrc, NULL);
    if (pSrc == pch) {
        return pSrc;
    }
    pEnd = pch;

    ParseMacroArgs(pSrc, pEnd - pSrc, &pMArgsList);

    if (pMArgsList->NumArgs < 1 || pMArgsList->NumArgs > 2) {
       ExitErrMsg(FALSE, "MemberTypes: 1 or 2 arguments are required.\n");
    }

    CGenerateEx(pMArgsList->ArgText[0], pCGenState, BurstName, MAX_PATH, &BytesReturned);    
    CodeBurstIndex = GetExistingCodeBurstIndex(BurstName);
    if (CodeBurstIndex == -1) {
        ExitErrMsg(FALSE, "CodeBurst '%s' unknown.\n", BurstName);
    }

    //handle optional member reference symbol
    if (pMArgsList->NumArgs == 2) {
       CGenerateEx(pMArgsList->ArgText[1], pCGenState, MemReference, MAX_PATH, &BytesReturned);
    }
    else {
       strcpy(MemReference, "->");
    }

    pMemberTypes(pCGenState, CodeBurstIndex, MemReference, bBtoT);  
    FreeMacroArgsList(pMArgsList);    
    return pEnd;
}

char* ForceTypeExpand( char *pSrc, PCGENSTATE pCGenState)
{
    char *pEnd;
    char *pch;
    int Len;
    PCGENERATE pCGen;
    CGENSTATE CGenState;
    char BurstName[MAX_PATH];
    char ArgName[MAX_PATH];
    char ArgHostName[MAX_PATH];
    char TypeName[MAX_PATH];
    char Direction[MAX_PATH];
    int CodeBurstIndex;
    PARGSLIST pArgsList;
    ARGSLIST ArgsListOld;
    ARGSLIST ArgsListNew;
    TOKENTYPE tkDirection;
    PMACROARGSLIST pMArgsList = NULL;
    SIZE_T BytesReturned;
    BOOL bHasArgsList=FALSE;

    pch = SkipSubExpression(pSrc, NULL);
    if (pSrc == pch) {
        return pSrc;
    }
    pEnd = pch;

    ParseMacroArgs(pSrc, pEnd - pSrc, &pMArgsList);    
    
    if (pMArgsList->NumArgs != 5) {
       ExitErrMsg(FALSE, "ForceTypeExpand: 5 arguments are required.\n");
    }

    CGenerateEx(pMArgsList->ArgText[0], pCGenState, BurstName, MAX_PATH, &BytesReturned);
    CodeBurstIndex = GetExistingCodeBurstIndex(BurstName);
    if (CodeBurstIndex == -1) {
        ExitErrMsg(FALSE, "CodeBurst '%s' unknown.\n", BurstName);
    }

    pCGen = GenHeapAlloc(sizeof(CGENERATE)+strlen(pCGenState->CGen->TempleName)+1);
    if (!pCGen) {
        ExitErrMsg(TRUE, "mt: %s\n", pSrc);
    }

    CGenerateEx(pMArgsList->ArgText[1], pCGenState, ArgName, MAX_PATH, &BytesReturned);
    CGenerateEx(pMArgsList->ArgText[2], pCGenState, ArgHostName, MAX_PATH, &BytesReturned);
    CGenerateEx(pMArgsList->ArgText[3], pCGenState, TypeName, MAX_PATH, &BytesReturned);
    CGenerateEx(pMArgsList->ArgText[4], pCGenState, Direction, MAX_PATH, &BytesReturned);

    // Parse the direction
    if(strcmp(Direction, "IN OUT") == 0) {
       tkDirection = TK_INOUT;
    }
    else if (strcmp(Direction, "IN") == 0) {
       tkDirection = TK_IN;
    }
    else if (strcmp(Direction, "OUT") == 0) {
       tkDirection = TK_OUT;
    }
    else if (strcmp(Direction, "none") == 0) {
       tkDirection = TK_NONE;
    }
    else {
       ExitErrMsg(FALSE, "FORCETYPE: Unknown direction %s\n", Direction);
    }
                
    InitializeListHead(&pCGen->CGenerateEntry);
       
    pCGen->fp = pCGenState->CGen->fp;
    pCGen->FileNameC = pCGenState->CGen->FileNameC;
    pCGen->FileBaseNameC = pCGenState->CGen->FileBaseNameC;
    pCGen->fpCpp = pCGenState->CGen->fpCpp;
    pCGen->FileNameCpp = pCGenState->CGen->FileNameCpp;
    pCGen->FileBaseNameCpp = pCGenState->CGen->FileBaseNameCpp;
    strcpy(pCGen->TempleName, pCGenState->CGen->TempleName);
   
    CGenState = *pCGenState;
    CGenState.CGen = pCGen;

    // Save the old ARGSLIST away
    pArgsList = pCGenState->pArgsList;
    if (pArgsList == NULL) {
       CGenState.pArgsList = &ArgsListNew;
       pArgsList = &ArgsListOld;
       *pArgsList = *(PARGSLIST)pCGenState->ExportsDbg->ArgsListHead.Flink;
    }
    else {
       ArgsListOld = *pArgsList;
       bHasArgsList = TRUE;
    }
    
    pArgsList->pKnownTypes = NULL;
    pArgsList->ArgSize = 0;
    pArgsList->IsPtr64 = FALSE;
    pArgsList->OffSet = -1;     // there is no stack offset for this member
    pArgsList->IndLevel = 0;
    pArgsList->tkDirection = tkDirection;
    pArgsList->Type = TypeName;
    pArgsList->pStructType = NULL;
    pArgsList->Mod = TK_NONE;
    pArgsList->SUEOpt = TK_NONE;
    pArgsList->PostMod = TK_NONE;
    pArgsList->PrePostMod = TK_NONE;
    pArgsList->Name = ArgName;
    pArgsList->ArgLocal = ArgName;
    pArgsList->HostCastedName = ArgHostName;
    pArgsList->fIsMember      = TRUE;
    pArgsList->bIsBitfield = FALSE;        
    pArgsList->BitsRequired= FALSE;       
    pArgsList->bIsArray    = FALSE;           
    pArgsList->ArrayElements=0;
    pArgsList->fRequiresThunk = FALSE;

    SetArgListToTypeForArg(CGenState.pArgsList, pArgsList, TypeName);
    ExpandType(&CGenState, CGenState.pArgsList->pKnownTypes, &TypeTempleList, CodeBurstIndex);

    // Restore the old ARGSLIST
    if (bHasArgsList) {
        *pCGenState->pArgsList = ArgsListOld;
    }
    else {
         pCGenState->pArgsList = NULL;
    }
    GenHeapFree(pCGen);
    FreeMacroArgsList(pMArgsList);
    return pEnd;
}

char *
IncludeRetType(
    char *pSrc,
    PCGENSTATE pCGenState
    )
/*++

Routine Description:

    Expands [Type] templates for the return value of an API call.

Arguments:

    pSrc        - pointer to character following '@RetType'
    pCGenState  - current code-gen state

Return Value:

    pointer to character following the end of the ')'

--*/
{
    char *pEnd;
    char *pch;
    PCGENERATE pCGen;
    CGENSTATE CGenState;
    PKNOWNTYPES pkt;
    int i, Len;
    int tplIndLevel;
    PTEMPLES pTypeTemple;
    PKNOWNTYPES pktTemple;
    PLIST_ENTRY NextArg, NextTemple;
    char BurstName[MAX_PATH];
    int CodeBurstIndex;
    char *CodeBurst;
    PMACROARGSLIST pMArgsList = NULL;
    SIZE_T BytesReturned;

    pch = SkipSubExpression(pSrc, NULL);
    if (pSrc == pch) {
        return pSrc;
    }
    pEnd = pch;

    ParseMacroArgs(pSrc, pEnd - pSrc, &pMArgsList);

    if (pMArgsList->NumArgs != 1) {
       ExitErrMsg(FALSE, "IncludeRetTypes: exactly 1 argument is required.\n");
    }
    
    CGenerateEx(pMArgsList->ArgText[0], pCGenState, BurstName, MAX_PATH, &BytesReturned);
    CodeBurstIndex = GetExistingCodeBurstIndex(BurstName);
    if (CodeBurstIndex == -1) {
        ExitErrMsg(FALSE, "CodeBurst '%s' unknown.\n", BurstName);
    }

    pCGen = GenHeapAlloc(sizeof(CGENERATE)+strlen(pCGenState->CGen->TempleName)+1);
    if (!pCGen) {
        ExitErrMsg(TRUE, "it: %s\n", pSrc);
    }

    InitializeListHead(&pCGen->CGenerateEntry);
   
    pCGen->fp = pCGenState->CGen->fp;
    pCGen->FileNameC = pCGenState->CGen->FileNameC;
    pCGen->FileBaseNameC = pCGenState->CGen->FileBaseNameC;
    pCGen->fpCpp = pCGenState->CGen->fpCpp;
    pCGen->FileNameCpp = pCGenState->CGen->FileNameCpp;
    pCGen->FileBaseNameCpp = pCGenState->CGen->FileBaseNameCpp;
    strcpy(pCGen->TempleName, pCGenState->CGen->TempleName);
   
    CGenState = *pCGenState;
    CGenState.CGen = pCGen;

    if (pCGenState->ExTemplate) {
        CodeBurst = pCGenState->TempleEx->CodeBurst[CodeBurstIndex];
        if (CodeBurst) {
            //
            // The [EFunc] template for this API has a return-type codeburst.
            // That is expanded in lieu of a [Types] template.
            //
            CGenerate(CodeBurst, &CGenState);
            return pEnd;
        }
    }

    pkt = pCGenState->ApiTypes->pktRet;
    pkt = pCGenState->ApiTypes->pktRet;
    i=2;
    while (i--) {
        NextTemple = TypeTempleList.Flink;
        while (NextTemple != &TypeTempleList) {
            pTypeTemple = CONTAINING_RECORD(NextTemple, TEMPLES, TempleEntry);

            tplIndLevel = pTypeTemple->IndLevel;
            pktTemple = pTypeTemple->pktType;
            if (!pktTemple) {
                pktTemple = GetNameFromTypesList(TypeDefsList,
                                                 pTypeTemple->Name
                                                );
                if (!pktTemple) {
                    pktTemple = GetNameFromTypesList(StructsList,
                                                     pTypeTemple->Name
                                                    );
                }
                pTypeTemple->pktType = pktTemple;
            }


            if (!pktTemple) {
                ExitErrMsg(FALSE,
                           "Temple: Type not found %s\n",
                           pTypeTemple->Name
                           );
            }

            tplIndLevel += pktTemple->IndLevel;

            if (IsSameType(pkt,
                           pCGenState->ApiTypes->RetIndLevel,
                           TK_NONE,
                           pTypeTemple->Name,
                           tplIndLevel,
                           TK_NONE,
                           i == 0
                           )) {
                 DbgPrintf("ttpl: RETURN %s.%s Type=%s IndLevel=%d\n",
                           CGenState.ApiTypes->FuncRet,
                           pTypeTemple->Name,
                           pTypeTemple->Name,
                           pTypeTemple->IndLevel
                          );

                if (pTypeTemple->CodeBurst[CodeBurstIndex]) {
                    pSrc = pTypeTemple->CodeBurst[CodeBurstIndex];
                    while (*pSrc && !isgraph(*pSrc)) {
                        pSrc++;
                    }
                    if (*pSrc) {
                        CGenerate(pSrc, &CGenState);
                    }
                }

                i = 0;
                break;  // break from while loop over all templates
            }

        NextTemple = NextTemple->Flink;
        }

    }
    
    GenHeapFree(pCGen);
    FreeMacroArgsList(pMArgsList);

    return pEnd;
}

VOID
SetArgListToTypeForArg(
    PARGSLIST pArgsList,
    PARGSLIST pArgsListOld,
    char * pTypeName
    )
{
   int IndLevel = 0;
   char TypeNameCopy[MAX_PATH];
   PKNOWNTYPES pkt;
   char *p;
   BOOL bIsTypedef = TRUE;

   *pArgsList = *pArgsListOld;
   p = pTypeName;
   strcpy(TypeNameCopy, p);
   p = TypeNameCopy;

   while(*p != '\0') {
      if (*p == '*') {
         IndLevel++;
         *p = ' ';
      }
      p++;
   }

   ResetLexer();
   LexMacroArgs(TypeNameCopy);
   ConsumeConstVolatileOpt();
   
   if (ParseTypes(TypeDefsList, NULL, &pkt) == FALSE) {
        CurrentTokenIndex = 0;
        bIsTypedef = FALSE;
        if (ParseTypes(StructsList, NULL, &pkt) == FALSE ) {
            ExitErrMsg(FALSE, "SetArgListToType: %s is not a valid type\n", TypeNameCopy);
        }
   }

   pArgsList->pKnownTypes = pkt;
   pArgsList->pStructType = NULL;   
   //DWORD        ArgSize;            // size of this arg (should be unchanged)
   pArgsList->IsPtr64 = (IndLevel == 0 && (pkt->Flags & BTI_PTR64));
   //BOOL         IsPtr64;            // TRUE if this arg is __ptr64 (should be unchanged)
   //int          OffSet;             // offset from stack for this arg(should be unchanged)
   pArgsList->IndLevel = IndLevel;
   //TOKENTYPE    tkDirection;        // TK_NONE, TK_IN, TK_OUT, TK_INOUT(should be unchanged)
   //TOKENTYPE    Mod;                // modifier (TK_CONST/VOLATILE/NONE)(should be unchanged)
   
   if (!bIsTypedef) {
      if (strcmp(pkt->BasicType, szSTRUCT) == 0) {
         pArgsList->SUEOpt = TK_STRUCT;
      } else if (strcmp(pkt->BasicType, szUNION) == 0) {
         pArgsList->SUEOpt = TK_UNION;
      } else if (strcmp(pkt->BasicType, szENUM) == 0) {
         pArgsList->SUEOpt = TK_ENUM;
      } else {
         pArgsList->SUEOpt = TK_NONE;
      }
   }

  pArgsList->Type = pkt->TypeName; 
   //TOKENTYPE    PostMod;            // modifier (TK_CONST/VOLATILE/NONE)
   //TOKENTYPE    PrePostMod;         // modifier (TK_CONST/VOLATILE/NONE)
   //char          *Name;              // argument name (may be a nonameX)
   //char         *ArgLocal;          // name of local var containing copy of arg
   //char         *HostCastedName;    // Contains full name of struct member with 
                                    // host casts or NULL
  pArgsList->fRequiresThunk = pkt->Flags & BTI_CONTAINSFUNCPTR;
  pArgsList->fNoType = FALSE;            // TRUE if types templates should *not*
                                    //  be expanded for this param.
   //BOOL         fIsMember;          // This arg is actually a member of an array
   //BOOL         bIsBitfield;        // Determines if this is a bitfield
   //int          BitsRequired;       // Number of bits required for bitfield
   //BOOL         bIsArray;           // This member is an array
   //int          ArrayElements;      // Number of elements in the array

}



BOOL
ExpandTypesForApi(
    PLIST_ENTRY ArgsListHead,
    PCGENSTATE CGenState,
    PLIST_ENTRY pTypesList,
    int CodeBurstIndex,
    BOOL bExpandAll,
    BOOL bRtoL
    )
{
   int  i, Len;
   int tplIndLevel;
   PCGENERATE pCGen;
   PARGSLIST pArgsList;
   PTEMPLES pTypeTemple;
   PKNOWNTYPES pktArgs, pktTemple;
   PLIST_ENTRY NextArg, NextTemple;
   BOOL fKeepGoing = TRUE;

   //
   // For each argument process a type template if any.
   //

   if ( bRtoL )
   {
      NextArg = &CGenState->ExportsDbg->ArgsListHead;
      NextArg = NextArg->Blink;
   }
   else
   {
      NextArg = ArgsListHead;
   }

   do
   {
       CGenState->pArgsList = CONTAINING_RECORD(NextArg,ARGSLIST,ArgumentsEntry);

        if (CGenState->pArgsList->fNoType) {
            //
            // This arg is listed in this API's [EFunc] NoTypes list.
            // Do not expand [Types] templates for it.
            //
            goto NextArg;
        }


       ResetLexer();
       LexMacroArgs(CGenState->pArgsList->Type);
       ConsumeConstVolatileOpt();

        // Get KnownTypes info for Argument
        if (ParseTypes(TypeDefsList, NULL, &pktArgs) == FALSE) {
            CurrentTokenIndex = 0;
            if (ParseTypes(StructsList, NULL, &pktArgs) == FALSE ) {
                ErrMsg(
                      "Args: Type not found %s %s\n",
                       CGenState->pArgsList->Type,
                       CGenState->ApiTypes->TypeName
                       );
               return fKeepGoing;
            }
        }

        fKeepGoing = !ExpandType(CGenState, CGenState->pArgsList->pKnownTypes, 
                                 pTypesList, CodeBurstIndex);
        fKeepGoing = fKeepGoing | bExpandAll;

NextArg:
      if ( bRtoL )
      {
         if ( NextArg == ArgsListHead )
         {
             break;
         }

         NextArg = NextArg->Blink;
      }
      else
      {
         NextArg = NextArg->Flink;

         if ( NextArg == &CGenState->ExportsDbg->ArgsListHead )
         {
            break;
         }
      }

   } while (fKeepGoing);

   return fKeepGoing;
}

/*
 *  IncludeTypes
 *
 */
char *IncludeTypes(char *pSrc, PCGENSTATE pCGenState, BOOL bRtoL)
{
   char *pEnd;
   char *pch;
   int  Len;
   PCGENERATE pCGen;
   CGENSTATE CGenState;
   PARGSLIST pArgsList;
   PLIST_ENTRY NextArg;
   char BurstName[MAX_PATH];
   PMACROARGSLIST pMArgsList = NULL;
   SIZE_T BytesReturned;
   int CodeBurstIndex;

   pch = SkipSubExpression(pSrc, NULL);
   if (pSrc == pch) {
       return pSrc;
       }
   pEnd = pch;

   //
   // Functions must have an argument list (at least void)
   //
   if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n IncludeTypes Missing argument List: %s\n",
               pCGenState->ApiTypes->TypeName
               );

       return pEnd;
       }


   //
   // If void arg list, nothing to do!
   //
   NextArg = pCGenState->ExportsDbg->ArgsListHead.Flink;
   pArgsList = CONTAINING_RECORD(NextArg, ARGSLIST, ArgumentsEntry);
   if (!pArgsList->Name && strcmp(pArgsList->Type, szVARGS)) {
       return pEnd;
       }

   ParseMacroArgs(pSrc, pEnd - pSrc, &pMArgsList);

   if (pMArgsList->NumArgs < 1) {
      ExitErrMsg(FALSE, "IncludeTypes: CodeBurst name required\n");
   }

   CGenerateEx(pMArgsList->ArgText[0], pCGenState, BurstName, MAX_PATH, &BytesReturned);
   CodeBurstIndex = GetExistingCodeBurstIndex(BurstName);
   if (CodeBurstIndex == -1) {
       ExitErrMsg(FALSE, "CodeBurst '%s' unknown.\n", BurstName);
   }

   pCGen = GenHeapAlloc(sizeof(CGENERATE)+strlen(pCGenState->CGen->TempleName)+1);
   if (!pCGen) {
       ExitErrMsg(TRUE, "it: %s\n", pSrc);
       }

   InitializeListHead(&pCGen->CGenerateEntry);
   
   pCGen->fp = pCGenState->CGen->fp;   
   pCGen->FileNameC = pCGenState->CGen->FileNameC;
   pCGen->FileBaseNameC = pCGenState->CGen->FileBaseNameC;
   pCGen->fpCpp = pCGenState->CGen->fpCpp;
   pCGen->FileNameCpp = pCGenState->CGen->FileNameCpp;
   pCGen->FileBaseNameCpp = pCGenState->CGen->FileBaseNameCpp;
   strcpy(pCGen->TempleName, pCGenState->CGen->TempleName);

   CGenState = *pCGenState;
   CGenState.CGen = pCGen;

   if (pMArgsList->NumArgs >= 2) {
      char ArgName[MAX_PATH];
      char TypeName[MAX_PATH];
      char CastedArgName[MAX_PATH];
      size_t ArgNameLen;
      size_t ArgTypeLen;
      char *p;
      BOOL bHasType = FALSE;

      //extract arg name to expand types for
      CGenerateEx(pMArgsList->ArgText[1], pCGenState, ArgName, MAX_PATH, &BytesReturned);
      if (BytesReturned == 0) {
         ExitErrMsg(FALSE, "IncludeTypes: Empty arg name is not allowed.\n");
      }
      ArgNameLen = BytesReturned - 1;

      if (pMArgsList->NumArgs == 3) {

         //extract the type name
         CGenerateEx(pMArgsList->ArgText[2], pCGenState, TypeName, MAX_PATH, &BytesReturned);
         if (BytesReturned == 0) {
            ExitErrMsg(FALSE, "IncludeTypes: Empty type name is not allowed.\n");
         }

         ArgTypeLen = BytesReturned - 1;
         bHasType = TRUE;

         if (ArgTypeLen + ArgNameLen + 4 >= MAX_PATH) {
            ExitErrMsg(FALSE, "ArgType + ArgName is too long\n");
         }

         memcpy(CastedArgName, "((", 2);
         p = CastedArgName + 2;
         memcpy(p, TypeName, ArgTypeLen);
         p += ArgTypeLen;         
         memcpy(p, ")", 1);
         p++;
         memcpy(p, ArgName, ArgNameLen);
         p += ArgNameLen;
         memcpy(p, ")", 2);

      }

      else {
         ExitErrMsg(FALSE, "IncludeTypes: Too many arguments\n");
      }

      //Find arg in the arglist.
      do {

        pArgsList = CONTAINING_RECORD(NextArg, ARGSLIST, ArgumentsEntry);
        if (pArgsList->Name != NULL) {
           if (strcmp(pArgsList->Name, ArgName) == 0) {
              //Expand this argument
              
              if (bHasType) {
                 CGenState.pArgsList = GenHeapAlloc(sizeof(ARGSLIST));
                 if(NULL == CGenState.pArgsList)
                    ExitErrMsg(FALSE, "IncludeTypes: out of memory.\n");
                 SetArgListToTypeForArg(CGenState.pArgsList, pArgsList, TypeName);
                 CGenState.pArgsList->Name = CastedArgName;
              }
              else {
                 CGenState.pArgsList = pArgsList;
              }

              if (!ExpandType(&CGenState, CGenState.pArgsList->pKnownTypes, &FailTempleList, CodeBurstIndex))
                 ExpandType(&CGenState, CGenState.pArgsList->pKnownTypes, &TypeTempleList, CodeBurstIndex);
              
              if (bHasType) {
                 GenHeapFree(CGenState.pArgsList);
              }
              
              GenHeapFree(pCGen);
              FreeMacroArgsList(pMArgsList);
              return pEnd;
           }
        }
              
        NextArg = NextArg->Flink;
      } while (NextArg != &CGenState.ExportsDbg->ArgsListHead);
      ExitErrMsg(FALSE, "IncludeTypes: %s is not a known argument for %s\n", ArgName, pCGenState->ExportsDbg->ExportName);

   }
   else {
      if (ExpandTypesForApi(NextArg,
                            &CGenState,
                            &FailTempleList,
                            CodeBurstIndex,
                            FALSE,
                            bRtoL)) {

         ExpandTypesForApi(NextArg,
                            &CGenState,
                            &TypeTempleList,
                            CodeBurstIndex,
                            TRUE,
                            bRtoL);
      }
   }

   GenHeapFree(pCGen);
   FreeMacroArgsList(pMArgsList);
   return pEnd;
}




/*
 *   IsSameType
 *
 */
PKNOWNTYPES
IsSameType(
    PKNOWNTYPES pktArgs,
    int IndLevel,
    TOKENTYPE tkArgDirection,
    char *tplTypeName,
    int tplIndLevel,
    TOKENTYPE tkTypeDirection,
    BOOL bScanBaseTypes
    )
{ 

    if (*tplTypeName != '*' && strcmp(tplTypeName, "default") != 0 &&
        IndLevel + pktArgs->IndLevel != tplIndLevel) {
        //
        // Not a generic '*' or 'default' types template, and levels of indirection
        // don't match
        //
        return NULL;
    }

    if (!bUseDirection) {
        tkArgDirection = TK_NONE;
    }
    if (tkTypeDirection != TK_EOS && tkArgDirection != tkTypeDirection) {
        //
        // Direction-sensitivity enabled, type template isn't generic to
        // all directions, and IN, OUT, IN/OUT don't match
        //
        return NULL;
    }

    if (!strcmp(pktArgs->TypeName, tplTypeName)) {
        //
        // type names match
        //
        return pktArgs;
    }

    if (bScanBaseTypes) {
        PKNOWNTYPES pkt;

        if (strcmp(tplTypeName, "struct") == 0 &&
            strcmp(pktArgs->BasicType, "struct") == 0) {
            //
            // This matches a generic 'struct' template.
            //
            return pktArgs;
        }

        if (strcmp(tplTypeName, "union") == 0 &&
            strcmp(pktArgs->BasicType, "union") == 0) {
            //
            // This matches a generic 'union' template.
            //
            return pktArgs;
        }

        if (*tplTypeName == '*' && IndLevel+pktArgs->IndLevel) {
            //
            // The template is a generic pointer template, and the arg type
            // is a pointer to something.  Match.
            //
            return pktArgs;
        }

        if (!strcmp(pktArgs->BaseName, pktArgs->TypeName)) {
           //
            // Base name of the arg type matches this arg type, no
            // possiblity of a match.
            //
            pkt = NULL; 
            goto try_default;
        }

        //
        // Get the knowntype for basetype of the arg
        //
        if (pktArgs->pktBase) {
            // the knowntype is already cached
            pkt = pktArgs->pktBase;
        } else {
            pkt = GetNameFromTypesList(TypeDefsList, pktArgs->BaseName);
            if (!pkt) {
                pkt = GetNameFromTypesList(StructsList, pktArgs->BaseName);
            }
            if (!pkt) {
                goto try_default;
            }
            pktArgs->pktBase = pkt;
        }

        IndLevel += pktArgs->IndLevel - pkt->IndLevel;

        pkt = IsSameType(pkt,
                         IndLevel,
                         tkArgDirection,
                         tplTypeName,
                         tplIndLevel,
                         tkTypeDirection,
                         TRUE
                         );

        if (NULL == pkt) {
try_default:
            // The default type template matches everything
            if (strcmp(tplTypeName, "default") == 0) {
               //printf("Applying default template to %s\n", pktArgs->TypeName);
               return pktArgs;
            }
        }

        return pkt;

    }

    return NULL;
}



/*
 * GetAltExportName
 *
 * Fetches the forward name if one exists, returns NULL if none.
 *
 */
char *GetAltExportName(char *Buffer, PCGENSTATE pCGenState, int Len)
{
   PKNOWNTYPES pkt;
   PEXPORTSDEBUG pExportDebug;

   PLIST_ENTRY Next;
   int i;

   pExportDebug = pCGenState->ExportsDbg;

   if (pExportDebug->ExtForward) {
       i = _snprintf(Buffer, Len, "=%s", pExportDebug->ExtForward);
       }
   else if (pExportDebug->IntForward) {
       if (bNoFuzzyLogic && !strchr(pExportDebug->IntForward->ExportName, '@')) {

           i = _snprintf(Buffer, Len, "=%s%s@%d",
                         szINTFORWARD,
                         pExportDebug->IntForward->ExportName,
                         GetArgSize(pExportDebug)
                         );
           }
       else {
           i = _snprintf(Buffer, Len, "=%s%s",
                         szINTFORWARD,
                         pExportDebug->IntForward->ExportName
                         );
           }
       }
   else if (bNoFuzzyLogic &&
            !strchr(pExportDebug->ExportName, '@') &&
            !strstr(pCGenState->ApiTypes->FuncMod, "cdecl"))
      {
       i = _snprintf(Buffer, Len, "=%s@%d",
                     pExportDebug->ExportName,
                     GetArgSize(pExportDebug)
                     );
       }
   else {
       return NULL;
       }


   if (i < 0) {
       ExitErrMsg(FALSE,
                  "GetAltExportName: Overflow %s\n",
                  pExportDebug->ExportName
                  );
       }

   return Buffer;

}



/*
 *  IncludeTemplate
 *
 */
char *IncludeTemplate(char *pSrc, PCGENSTATE pCGenState)
{
   char *pEnd;
   char *pch;
   size_t  Len;
   PCGENERATE pCGen;
   CGENSTATE CGenState;

   pch = SkipSubExpression(pSrc, NULL);
   if (pSrc == pch) {
       return pSrc;
       }
   pEnd = pch;

   pch = pSrc + 1;
   if (IsSeparator(*pch)) {
       return pSrc;
       }

   pSrc = pch;
   while (!IsSeparator(*pch)) {
      pch++;
      }
   Len = pch - pSrc;

   pCGen = GenHeapAlloc(Len + 1 + sizeof(CGENERATE));
   if (!pCGen) {
       ExitErrMsg(TRUE, "it: %s\n", pSrc);
       }

   InitializeListHead(&pCGen->CGenerateEntry);
   pCGen->fp = pCGenState->CGen->fp;
   pCGen->fpC = pCGenState->CGen->fpC;
   pCGen->FileNameC = pCGenState->CGen->FileNameC;
   pCGen->FileBaseNameC = pCGenState->CGen->FileBaseNameC;
   pCGen->fpCpp = pCGenState->CGen->fpCpp;
   pCGen->FileNameCpp = pCGenState->CGen->FileNameCpp;
   pCGen->FileBaseNameCpp = pCGenState->CGen->FileBaseNameCpp;
   memcpy(pCGen->TempleName, pSrc, Len);
   *(pCGen->TempleName + Len) = '\0';

   memset(&CGenState, 0, sizeof(CGENSTATE));
   CGenState.CGen = pCGen;

   CGenState.ExportsDbg = pCGenState->ExportsDbg;
   CGenState.DebugStrings = pCGenState->DebugStrings;
   CGenState.ApiTypes = pCGenState->ApiTypes;
   CGenState.ApiNum = pCGenState->ApiNum;
   CGenState.pArgsList = pCGenState->pArgsList;
   CGenState.ListCol = pCGenState->ListCol;
   CGenState.MoreApis = pCGenState->MoreApis;
   CGenState.CodeBurstIndex = pCGenState->CodeBurstIndex;

   ProcessTemple(&CGenState);

   GenHeapFree(pCGen);
   return pEnd;
}



/*
 *  WriteMore
 */
char *WriteMore(char *pSrc, PCGENSTATE pCGenState, BOOL bMore)
{
   char *pch;
   char *pExpression;
   CGENSTATE CGenState;

   pch = SkipSubExpression(pSrc, bMore ? &pExpression : NULL);
   if (pSrc == pch) {
       return pSrc;
       }
   pSrc = pch;

   if (!bMore || !pExpression) {
       return pSrc; 
       }

   CGenState = *pCGenState;
   CGenerate(pExpression, &CGenState);

   GenHeapFree(pExpression);
   return pSrc;
}




/*
 *  WriteArgLocal
 */
BOOL
WriteArgLocal(
       PCGENSTATE pCGenState,
       char *Buffer,
       int BuffLen)
{
   char *pExpression;
   char *pEnd;
   char *pch;
   int i, Len;

   if (pCGenState->pArgsList->ArgLocal) {
       ErrMsg("Type Template error multiple ArgLocals\n");
       return FALSE;
       }

   // format the local var name
   Len = _snprintf(Buffer, BuffLen, "%s", pCGenState->pArgsList->Name);
   if (Len <= 0) {
       ErrMsg(
              "WriteArgLocal buffer overflow %s\n",
              pCGenState->pArgsList->Name
              );
       return FALSE;
       }

   // alloc space for the local var name, and stash it away
   pCGenState->pArgsList->ArgLocal = GenHeapAlloc(Len + 1);
   if (!pCGenState->pArgsList->ArgLocal) {
        ErrMsg("GenHeapAlloc(ArgLocal) %s\n", pCGenState->pArgsList->Name);
        return FALSE;
        }
   strcpy(pCGenState->pArgsList->ArgLocal, Buffer);

   //
   // format the declarator statement: "ArgType IndLevel *ArgName"
   //

   pch = Buffer;
   i = strlen(pCGenState->pArgsList->Type) +
       strlen(TokenString[pCGenState->pArgsList->SUEOpt]) + 1;
   if (i >= BuffLen) {
       ErrMsg(
              "WriteArgLocal buffer overflow %s\n",
              pCGenState->pArgsList->Name
              );
       return FALSE;
       }

   if (pCGenState->pArgsList->SUEOpt != TK_NONE) {
       strcpy(pch, TokenString[pCGenState->pArgsList->SUEOpt]);
       strcat(pch, " ");
       strcat(pch, pCGenState->pArgsList->Type);
   } else {
       strcpy(pch, pCGenState->pArgsList->Type);
   }
   if (pCGenState->pArgsList->PrePostMod != TK_NONE) {
       strcat(pch, " ");
       strcat(pch,  TokenString[pCGenState->pArgsList->PrePostMod]);
   }
   i = strlen(pch);
   Len = BuffLen - i - 1;
   pch += i;
   
   i = pCGenState->pArgsList->IndLevel;
   if (!Len || i > Len) {
       ErrMsg(
              "WriteArgLocal buffer overflow %s\n",
              pCGenState->pArgsList->Name
              );
       return FALSE;
       }

    if (i) {
        *pch++ = ' ';
        while (i) {
            *pch++ = '*';
            i--;
        }
    }
   *pch++ = ' ';

   i = strlen(pCGenState->pArgsList->ArgLocal);
   if (!Len || i > Len) {
       ErrMsg(
              "WriteArgLocal buffer overflow %s\n",
              pCGenState->pArgsList->Name
              );
       return FALSE;
       }

   strcpy(pch, pCGenState->pArgsList->ArgLocal);

   //
   // Record that some kind of exception template has been used
   // during generation of this argument.
   //
   pCGenState->pArgsList->fRequiresThunk = FALSE;

   return TRUE;
}




/*
 *  WriteArgAddr
 */
char *
WriteArgAddr(
       char *pSrc,
       PCGENSTATE pCGenState,
       char *Buffer,
       int BuffLen)
{
   char *pEnd;
   char *pch;
   size_t Len;

   pch = SkipSubExpression(pSrc, NULL);
   if (pSrc == pch) {
       return pSrc;
       }
   pEnd = pch;

   Len = --pch - ++pSrc;

   if (Len + 32 >= (size_t)BuffLen) {
       ExitErrMsg(FALSE,
                  "WriteArgAddr buffer overflow %s\n",
                  pSrc
                  );
       }

   while (pSrc < pch) {
      *Buffer++ = *pSrc++;
      }

   *Buffer++ = ' ';
   *Buffer++ = '+';
   *Buffer++ = ' ';

   _itoa(pCGenState->pArgsList->OffSet, Buffer, 10);

   return pEnd;
}



BOOLEAN
TempleHasNoCodeBursts(
    PTEMPLES pTemple
    )
/*++

Routine Description:

    Determines if a template has no codebursts at all or not.

Arguments:

    pTemple     - template to examine

Return Value:

    TRUE if template has no codebursts, FALSE if there is at least one.

--*/
{
    int i;

    for (i=0; i<MAX_CODEBURST; ++i) {
        if (pTemple->CodeBurst[i]) {
            return FALSE;
        }
    }

    return TRUE;
}


/*
 *  ListApis
 */
char *ListApis(char *pSrc, PCGENSTATE pCGenState, BOOL bExports)
{

   char *pch;
   char *pExpression;
   PLIST_ENTRY Next;
   CGENSTATE CGenState;
   PTEMPLES pTemple;
   BOOL GenerateCode;
   BYTE ApiPlatform;
   BOOL ExcludedApi;

   pch = SkipSubExpression(pSrc, &pExpression);
   if (pSrc == pch || !pExpression) {
       return pch;
       }
   pSrc = pch;

   memset(&CGenState, 0, sizeof(CGenState));
   CGenState.CGen = pCGenState->CGen;
   CGenState.Temple = pCGenState->Temple;
   CGenState.MoreApis = TRUE;
   CGenState.ListCol = pCGenState->ListCol;
   CGenState.CodeBurstIndex = pCGenState->CodeBurstIndex;

   Next = ExportsList.Flink;
   while (Next != &ExportsList) {
       CGenState.ExportsDbg = CONTAINING_RECORD(Next,
                                                EXPORTSDEBUG,
                                                ExportsDbgEntry
                                                );

       Next= Next->Flink;
       if (Next == &ExportsList) {
           CGenState.MoreApis = FALSE;
           }

       //
       // Switch this API in or out depending on the platform info
       //
       ApiPlatform = CGenState.ExportsDbg->ApiPlatform;
       PlatformSwitchStart(&CGenState, ApiPlatform);

       CGenState.ApiTypes = GetApiTypes(CGenState.ExportsDbg);

       pTemple = GetTemplate(&EFuncTempleList,
                             CGenState.ExportsDbg->ExportName
                             );



       ExcludedApi = FALSE;

           // skip this api if ex template, but no code
       if (!bExports && pTemple && TempleHasNoCodeBursts(pTemple)) {
      ExcludedApi = TRUE;
           fprintf(pCGenState->CGen->fp,
                    "%s *** WARNING *** Excluded Api %s\n",
                   CGenState.Temple->Comment,
                   CGenState.ExportsDbg->ExportName
                   );
           }

          //
          // skip this api if:
          // - external forward reference
          // - internal forward which does not define the function.
          //   (exportname != forwardname)
          //
       else if (!bExports &&
                (CGenState.ExportsDbg->ExtForward ||
                 (CGenState.ExportsDbg->IntForward &&
                  CGenState.ExportsDbg->IntForward != CGenState.ExportsDbg)))
          {
            ExcludedApi = TRUE;
            fprintf(pCGenState->CGen->fp,
                     "%s %s forwarded to %s\n",
                    CGenState.Temple->Comment,
                    CGenState.ExportsDbg->ExportName,
                    CGenState.ExportsDbg->ExtForward
                       ? CGenState.ExportsDbg->ExtForward
                       : CGenState.ExportsDbg->IntForward->ExportName
                    );

            }


          // skip this api if DATA and no ex template
       else if (!pTemple && CGenState.ExportsDbg->Data) {
           ExcludedApi = TRUE;
           fprintf(pCGenState->CGen->fp,
                    "%s *** WARNING *** Excluded Data Export %s\n",
                   CGenState.Temple->Comment,
                   CGenState.ExportsDbg->ExportName
                   );
           }

          // skip this api if CPP export and we aren't setup for CPP exports,
       else if (!pTemple && !iHandleCpp && CGenState.ExportsDbg->CplusDecoration)
         {
           ExcludedApi = TRUE;
           fprintf(pCGenState->CGen->fp,
                    "%s *** WARNING *** Excluding CPP Api: %s\n",
                   CGenState.Temple->Comment,
                   CGenState.ExportsDbg->ExportName
                   );
           }

           // skip this api if members are unknown
       else if (!CGenState.ApiTypes->pfuncinfo) {
           ExcludedApi = TRUE;
           ExitErrMsg(FALSE, 
                      "API %s has no function prototype - unable to generate code.", 
                      CGenState.ExportsDbg->ExportName
                     );

           }

           // gen code for this api
       else {

           if (pTemple) {
               CGenState.ExTemplate= TRUE;
               }
           else {
               CGenState.ExTemplate= FALSE;
               }

           BuildArgsList(pTemple,
                         CGenState.ApiTypes->pfuncinfo,
                         &CGenState.ExportsDbg->ArgsListHead
                         );


           if (GetArgSize(CGenState.ExportsDbg) < 0) {
          ExcludedApi = TRUE;
               ExitErrMsg(FALSE, 
                          "API %s has no function prototype - unable to generate code.", 
                          CGenState.ExportsDbg->ExportName
                         );
               }
           else {
               CGenerate(pExpression, &CGenState);

               if (bExports) {
                    //
                    // we're generating the .DEF file.   Mark some APIs
                    // as private so the linker doesn't warn us.
                    //
                    if (strcmp(CGenState.ExportsDbg->ExportName,
                               "DllGetClassObject") == 0 ||
                        strcmp(CGenState.ExportsDbg->ExportName,
                               "DllCanUnloadNow") == 0 ||
                        strcmp(CGenState.ExportsDbg->ExportName,
                               "DllRegisterServer") == 0 ||
                        strcmp(CGenState.ExportsDbg->ExportName,
                               "DllRegisterServerEx") == 0 ||
                        strcmp(CGenState.ExportsDbg->ExportName,
                               "DllInstall") == 0 ||
                        strcmp(CGenState.ExportsDbg->ExportName,
                               "DllUnregisterServer") == 0) {

                        fprintf(pCGenState->CGen->fp, " PRIVATE");
                    }

               }
               CGenState.ApiNum++;
               }
           }

       if (bExports)
    PlatformSwitchEnd(&CGenState, ApiPlatform);
       else{
    if (ExcludedApi)
      PlatformSwitchEnd(&CGenState, ApiPlatform);
    else
      PlatformSwitchEndTable(&CGenState, ApiPlatform);
       }

       if (CGenState.ListCol) {
           WriteListColumn(&CGenState);
           }
       }

   GenHeapFree(pExpression);
   return pSrc;
}


PKNOWNTYPES
BuildFakeTypesInfo(
    PEXPORTSDEBUG pExportsDbg,
    PKNOWNTYPES pKnownTypes
    )
{
   TYPESINFO ti;
   int ArgsSize, i;
   size_t Len;
   PFUNCINFO funcinfo;
   char *pch;

   memset(&ti, 0, sizeof(TYPESINFO));
   strcpy(ti.TypeName, pExportsDbg->ExportName);

   if (pKnownTypes) {
       strcpy(ti.BasicType, pKnownTypes->BasicType);
       strcpy(ti.BaseName, pKnownTypes->BaseName);
       strcpy(ti.FuncRet, pKnownTypes->FuncRet);
       strcpy(ti.FuncMod, pKnownTypes->FuncMod);

       pExportsDbg->UnKnownApi = -1; // incomplete fn declaration

       /*
        *  WARNING:
        *  The type is added to the FakeFuncsList with args
        *  info from the dll symbols. The type is NOT removed
        *  from the FuncsList.
        */

       }
   else {
       strcpy(ti.BasicType, szFUNC);
       strcpy(ti.FuncRet, szINT);

       pExportsDbg->UnKnownApi = 1;  // missing fn declaration
       }

   ArgsSize = pExportsDbg->ArgsSize;

   if (!ArgsSize) {
       ti.TypeKind = TypeKindFunc;
       ti.dwMemberSize = sizeof(FUNCINFO) + strlen(szVOID) + 1;
       ti.pfuncinfo = (PFUNCINFO)ti.Members;
       pch = ti.Members + sizeof(FUNCINFO);
       strcpy(pch, szVOID);
       ti.pfuncinfo->sType = pch;
       }
   else if (ArgsSize < 0) {
       ;
       }
   else {
       ti.TypeKind = TypeKindFunc;
       pch = ti.Members + sizeof(FUNCINFO);
       Len = sizeof(ti.Members) - 1 - sizeof(FUNCINFO);
       funcinfo = (PFUNCINFO)ti.Members;
       ti.pfuncinfo = funcinfo;
       while (ArgsSize && Len) {
           ti.dwMemberSize+=sizeof(FUNCINFO);
           i = _snprintf(pch, Len, "Fake%x", ArgsSize);
           if (i < 0) {
               return NULL;
               }
           i++;
           Len -= i;
           funcinfo->sName = pch;
           pch += i;
           ti.dwMemberSize+=i;
           strcpy(pch, szINT);
           funcinfo->sType = pch;
           i = strlen(szINT) + 1;
           pch += i;
           ti.dwMemberSize+=i;
           ArgsSize -= sizeof(int);

           if (ArgsSize) {
               PFUNCINFO funcinfoNext;
               INT_PTR Realignment;

               //
               // Allocate space for another FUNCINFO, ensuring that
               // it is DWORD-aligned.
               //
               Len -= sizeof(FUNCINFO);
               Realignment = 4 - ((INT_PTR)pch & 3);
               Len -= Realignment;
               funcinfoNext = (PFUNCINFO)(pch + Realignment);
               pch += sizeof(FUNCINFO)+Realignment;
               ti.dwMemberSize += (DWORD)Realignment;
               if ((INT_PTR)Len < 0) {
                   return NULL;
                   }
               funcinfo->pfuncinfoNext = funcinfoNext;
               funcinfo = funcinfoNext;
               }
           }
       }

   return AddToTypesList(&FakeFuncsList, &ti);
}

/*
 *  GetFuncArgNum
 */
int GetFuncArgNum(PCGENSTATE pCGenState)
{
   PARGSLIST pArgsList;
   PKNOWNTYPES pkt;
   int NumArgs;
   PFUNCINFO funcinfo;

   pArgsList = pCGenState->pArgsList;

   if (!pArgsList) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n*** GetFuncArgNum Missing argument List\n\n"
               );

       return -1;
       }

   pkt = pArgsList->pKnownTypes;
   while (!pkt->Members || !pkt->pfuncinfo) {
       if (pkt->pktBase) {
           // the knowntype is already cached
           pkt = pkt->pktBase;
       } else {
           PKNOWNTYPES pktOrg = pkt;
           pkt = GetNameFromTypesList(TypeDefsList, pkt->BaseName);
           if (!pkt) {
               if (pArgsList->pKnownTypes) {
                   fprintf(pCGenState->CGen->fp,
                           "\n\t*** ERROR ***\n*** GetFuncArgNum BaseType Not found:<%s:%s>\n\n",
                           pArgsList->pKnownTypes->TypeName,
                           pArgsList->pKnownTypes->BasicType
                           );
               } else {
                   fprintf(pCGenState->CGen->fp,
                           "\n\t*** ERRR ***\n*** GetFuncArgNum BaseType Not found: no KnownTypes\n\n"
                          );
                   }
               return -1;
               }
            pktOrg->pktBase = pkt;
       }

       if (!strcmp(pkt->BasicType, pkt->TypeName)) {
           break;
           }
       }

   funcinfo = pkt->pfuncinfo;
   if (!pkt->Members || !funcinfo) {
       fprintf(pCGenState->CGen->fp,
               "/*** WARN gfan No Members:<%s:%s> ***/ ",
               pArgsList->pKnownTypes->TypeName,
               pkt->BasicType
               );

       return 0;
   }

   //
   //  "..." vargs is nonsense can't do it!
   //
   if (strcmp(funcinfo->sType, szVARGS) == 0) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n*** GetFuncArgNum variable Args:<%s:%s>\n\n",
               pArgsList->pKnownTypes->TypeName,
               pkt->BasicType
               );
       return -1;
   }

   //
   //  void arg list, Zero Args
   //
   if (strcmp(funcinfo->sType, szVOID) == 0) {
       return 0;
   }

   NumArgs = 0;
   do {
       NumArgs++;
       funcinfo = funcinfo->pfuncinfoNext;
   } while(funcinfo);

   return NumArgs;
}



/*
 *  GetFuncIndex
 */
int GetFuncIndex(PCGENSTATE pCGenState, char *FuncTypeName)
{
   PKNOWNTYPES pkt, pktFunc;
   int  Len, LenExpr, LenArgs, LenRet;
   char *pch;
   char Args[1024];
   PFUNCINFO funcinfo;
   PDEBUGSTRINGS DebugStrings;

   if (!FuncTypeName || !*FuncTypeName) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n*** GetFuncIndex TypeName Not specified\n\n"
               );
       return -1;
       }

   pkt = GetNameFromTypesList(TypeDefsList, FuncTypeName);
   if (!pkt) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n*** GetFuncIndex Type Not found:<%s>\n\n",
               FuncTypeName
               );
       return -1;
       }

   pktFunc = pkt;
   while (!pkt->Members || !pkt->pfuncinfo) {
       // NOTE: we cannot look at pkt->pktBase as it may point to a struct
       //       knowntype instead of a typedef
       pkt = GetNameFromTypesList(TypeDefsList, pkt->BaseName);
       if (!pkt) {
           fprintf(pCGenState->CGen->fp,
                   "\n\t*** ERROR ***\n*** GetFuncIndex BaseType Not found:<%s:%s>\n\n",
                   FuncTypeName,
                   pktFunc->BaseName
                   );
           return -1;
           }

       if (!strcmp(pkt->BasicType, pkt->TypeName)) {
           break;
           }
       }


   LenArgs = 1;
   Args[0] = '\0';

   funcinfo = pkt->pfuncinfo;
   if (pkt->Members && funcinfo) {

        //
        //  "..." vargs is nonsense can't do it!
        //
        if (strcmp(funcinfo->sType, szVARGS) == 0) {
            fprintf(pCGenState->CGen->fp,
                    "\n\t*** ERROR ***\n*** GetFuncIndex variable Args:<%s:%s>\n\n",
                    FuncTypeName,
                    pkt->BasicType
                    );
            return -1;
        }

        //
        //  void arg list means no args
        //
        if (strcmp(funcinfo->sType, szVOID) != 0) {
            pch = Args;
            do {
                //
                // Copy in the typename
                //
                Len = strlen(funcinfo->sType);
                LenArgs += Len;
                if (LenArgs >= sizeof(Args)-3) {
                    break;
                }
                strcpy(pch, funcinfo->sType);
                pch += Len;

                //
                // Copy in the levels of indirection
                //
                LenArgs += funcinfo->IndLevel;
                if (LenArgs >= sizeof(Args)-3) {
                    break;
                }
                for (Len = 0; Len<funcinfo->IndLevel; ++Len) {
                    *pch++ = '*';
                }

                //
                // Copy in the argument name, if present
                //
                if (funcinfo->sName) {
                    Len = strlen(funcinfo->sName) + 1;
                    LenArgs += Len;
                    if (LenArgs >= sizeof(Args)-3) {
                        break;
                    }
                    *pch = ' ';
                    strcpy(pch+1, funcinfo->sName);
                    pch += Len;
                }

                //
                // Copy in the printf-style formatting for this argument
                //
                LenArgs += 3;
                *pch++ = ' ';
                *pch++ = '%';
                *pch++ = 'x';
                funcinfo = funcinfo->pfuncinfoNext;
                if (funcinfo) {
                    LenArgs+=2;
                    *pch++ = ',';
                    *pch++ = ' ';
                }
            } while (funcinfo);

           if (LenArgs >= sizeof(Args)-5) {
               ExitErrMsg(FALSE,
                          "GetFuncIndex overflow %s.%s\n",
                          FuncTypeName,
                          pkt->Members
                          );
               }
           }

           //
           // Null-terminate the Args[] string.
           //
           Args[LenArgs-1] = '\0';
       }



   LenExpr = strlen(FuncTypeName) + 1;
   LenRet = strlen(pkt->FuncRet) + 4;

   DebugStrings = GenHeapAlloc(LenExpr + LenRet + LenArgs + sizeof(DEBUGSTRINGS));
   if (!DebugStrings) {
       ExitErrMsg(TRUE,
                  "GetFuncIndex: GenHeapAlloc(DebugStrings) %s.%s\n",
                  FuncTypeName,
                  pkt->Members
                  );
       }

   Len = 0;
   DebugStrings->Name = DebugStrings->Buffer;
   strcpy(DebugStrings->Name, FuncTypeName);
   Len += LenExpr;

   DebugStrings->ArgFormat = DebugStrings->Buffer + Len;
   strcpy(DebugStrings->ArgFormat, Args);
   Len += LenArgs;

   DebugStrings->RetFormat = DebugStrings->Buffer + Len;
   strcpy(DebugStrings->RetFormat, pkt->FuncRet);
   strcat(DebugStrings->RetFormat, " %x");
   Len += LenRet;

   InsertTailList(&DebugStringsList, &DebugStrings->DebugStringsEntry);

   return NumDebugStringsEntries++;
}




/*
 *  WriteDbgsStrings
 *
 */
void WriteDbgsStrings(char *pSrc, PCGENSTATE pCGenState)
{
    DEBUGSTRINGS DebugStrings;
    char BaseName[MAX_PATH];
    char *c;

    // copy in the DLL name and whack off the extension
    strcpy(BaseName, DllBaseName);
    c = strchr(BaseName, '.');
    if (c) {
        *c = '\0';
    }

    if (!pCGenState->DebugStrings) {
        pCGenState->DebugStrings = &DebugStrings;
        DebugStrings.Name =
        DebugStrings.ArgFormat =
        DebugStrings.RetFormat = "";
        }

    fprintf(pCGenState->CGen->fp,
            "\"%s!%s\",\"%s\",\"%s\"",
            BaseName,
            pCGenState->DebugStrings->Name,
            pCGenState->DebugStrings->ArgFormat,
            pCGenState->DebugStrings->RetFormat
            );
}


/*
 *  ListDbgs
 */
char *ListDbgs(char *pSrc, PCGENSTATE pCGenState)
{

   char *pch;
   char *pExpression;
   PLIST_ENTRY Next;
   CGENSTATE CGenState;
   PTEMPLES pTemple;

   pch = SkipSubExpression(pSrc, &pExpression);
   if (pSrc == pch || !pExpression) {
       return pch;
       }
   pSrc = pch;

   memset(&CGenState, 0, sizeof(CGenState));
   CGenState.CGen = pCGenState->CGen;
   CGenState.Temple = pCGenState->Temple;
   CGenState.ListCol = pCGenState->ListCol;

   if (!IsListEmpty(&DebugStringsList)) {
       Next = DebugStringsList.Flink;
       while (Next != &DebugStringsList) {
           CGenState.DebugStrings = CONTAINING_RECORD(Next,
                                                      DEBUGSTRINGS,
                                                      DebugStringsEntry
                                                      );

           Next= Next->Flink;
           CGenState.MoreApis = Next != &DebugStringsList;
           CGenerate(pExpression, &CGenState);
           if (CGenState.ListCol) {
               WriteListColumn(&CGenState);
               }
           }
       }
   else {
       CGenState.MoreApis = FALSE;
       CGenerate(pExpression, &CGenState);
       if (CGenState.ListCol) {
           WriteListColumn(&CGenState);
           }
       }

   GenHeapFree(pExpression);
   return pSrc;
}


/*
 *  ListArgs
 */
char *ListArgs(char *pSrc, PCGENSTATE pCGenState, BOOL Always)
{
   PARGSLIST pArgsList;
   PLIST_ENTRY Next;
   char *pch;
   char *pExpression;
   CGENSTATE CGenState;

   if (IsListEmpty(&pCGenState->ExportsDbg->ArgsListHead)) {
       fprintf(pCGenState->CGen->fp,
               "\n\t*** ERROR ***\n*** ListArgs Missing argument List: %s\n\n",
               pCGenState->ApiTypes->TypeName
               );

       return SkipSubExpression(pSrc, NULL);
       }

   Next = pCGenState->ExportsDbg->ArgsListHead.Flink;

   // check for void arg list
   if (!Always) {
       pArgsList = CONTAINING_RECORD(Next, ARGSLIST, ArgumentsEntry);
       if (!pArgsList->Name && strcmp(pArgsList->Type, szVARGS)) {
           return SkipSubExpression(pSrc, NULL);
           }
       }

   CGenState = *pCGenState;
   pch = SkipSubExpression(pSrc, &pExpression);
   if (pSrc == pch || !pExpression) {
       return pch;
       }
   pSrc = pch;

   do {
       CGenState.pArgsList = CONTAINING_RECORD(Next,ARGSLIST, ArgumentsEntry);

       CGenerate(pExpression, &CGenState); 

       if (CGenState.ListCol) {
          WriteListColumn(&CGenState);
          }

       Next= Next->Flink;

     } while (Next != &CGenState.ExportsDbg->ArgsListHead);


   GenHeapFree(pExpression);
   return pSrc;
}



/*
 *  WriteListColumn
 */
void WriteListColumn(PCGENSTATE pCGenState)
{
    int Len;
    FILE *fp = pCGenState->CGen->fp;

    OutputColumn = pCGenState->ListCol;
    Len =  OutputColumn - 1;

    if (fputc('\n', fp) != '\n') {
        ExitErrMsg(TRUE, "fputc %s\n", pCGenState->CGen->FileNameC); 
        }
    while (Len--) {
        if (fputc(' ', fp) != ' ') {
            ExitErrMsg(TRUE, "fputc %s\n", pCGenState->CGen->FileNameC);
            }
        }


}




/*
 *  SkipSubExpression
 *
 */
char *SkipSubExpression(char *pSrc, char **pSubExpression)
{
   char *pOrg = pSrc;
   char *pSave;
   int  Len = 0;
   int ParenLevel;

   if ((*pSrc != '(') && (*pSrc != ',')) {
       return pOrg;
       }

   pSrc++;

   pSave = pSrc;
   ParenLevel = 1;
   Len = 0;

   while (*pSrc) {
       if (*pSrc == '(') {
           ParenLevel++;
           }
       else if (*pSrc == ')') {
           ParenLevel--;
           }

       pSrc++;

       if (!ParenLevel) {
           break;
           }

       Len++;
       }


   if (pSubExpression) {
       if (Len) {
           *pSubExpression = GenHeapAlloc(Len + 1);
           if (!*pSubExpression) {
               ExitErrMsg(TRUE, "GenHeapAlloc(SubExpression) %s\n", pOrg);
               }
           if (Len) {
               memcpy(*pSubExpression, pSave, Len);
               }
           *(*pSubExpression + Len) = '\0';
           }
       else {
           *pSubExpression = NULL;
           }
       }

   return pSrc;
}






/*
 *  GetTemplate
 */
PTEMPLES GetTemplate(PLIST_ENTRY pHeadList, char *TempleName)
{
   PTEMPLES ptpl;
   PLIST_ENTRY Next;

   Next = pHeadList->Flink;
   while (Next != pHeadList) {
      ptpl = CONTAINING_RECORD(Next, TEMPLES, TempleEntry);
      if (!strcmp(ptpl->Name, TempleName)) {
          return ptpl;
          }
      Next= Next->Flink;
      }

   return NULL;
}


void
UseLogMacros(char *LogName)
{
    DWORD Len;
    char FullLogName[MAX_PATH+1];
    char *LogBaseName;

    Len = GetFullPathName(LogName,
                          sizeof(FullLogName) - 1,
                          FullLogName,
                          &LogBaseName
                          );
    if (Len == 0 || Len >= sizeof(FullLogName) - 1) {
        ExitErrMsg(TRUE, "Could not fully-qualify log filename '%s'\n", LogName);
    }

    fpLog = fopen(FullLogName, "w");
    if (!fpLog) {
        ExitErrMsg(TRUE, "fopen(%s) failed\n", FullLogName);
    }
    if (!AddOpenFile(FullLogName, fpLog, NULL)) {
        ExitErrMsg(FALSE, "AddOpenFile failed\n");
    }
}


char *
UpdateLog(
    char *pSrc,
    PCGENSTATE pCGenState
    )
{
    FILE *fpOld;
    BOOL bMore;

    if (fpLog) {
        fpOld = pCGenState->CGen->fp;
        pCGenState->CGen->fp = fpLog;
        bMore = TRUE;
    } else {
        fpOld = NULL;
        bMore = FALSE;
    }

    pSrc = WriteMore(pSrc,pCGenState,bMore);

    if (bMore) {
        pCGenState->CGen->fp = fpOld;
        fprintf(fpLog, "\n");
    }

    return pSrc;
}



/*
 *  ExtractCGenerate
 */
BOOL ExtractCGenerate(char *pNames)
{
   FILE *fp=NULL, *fpCpp=NULL;
   size_t Len;
   DWORD SizeFileName, SizeTempleName;
   DWORD SizeFileNameCpp = 0;
   char *pch;
   char *pchColon, *pchComma;
   PCGENERATE pCGen;
   char *OutputBaseNameCpp;
   char FullOutputNameCpp[MAX_PATH+1];
   char *OutputBaseName;
   char FullOutputName[MAX_PATH+1];
   char OutputName[MAX_PATH+1];
   char OutputNameCpp[MAX_PATH+1];
   char TempleName[MAX_PATH];



   DbgPrintf("CGenerate: %s\n", pNames);

   pchComma = strchr(pNames, ',');
   pchColon = strchr(pNames, ':');

   if (pchComma != NULL) {
       pch = pchComma;
       }
   else {
       pch = pchColon;
       }
   Len = pch - pNames;
   if (!pch || !Len || Len >= sizeof(OutputName) - 1) {
       return FALSE;
       }
   strncpy(OutputName, pNames, Len);
   *(OutputName + Len) = '\0';

   //
   // Extract the CPP filename, and initialize iHandleCPP
   //

   OutputNameCpp[0] = '\0';
   if (pchComma) {
       size_t LenCpp;

       LenCpp = pchColon - ++pchComma;
       if (LenCpp >= sizeof(OutputNameCpp) - 1) {
           return(FALSE);
           }

       if (LenCpp) {
           iHandleCpp = 1;      // use CPP macros
           strncpy(OutputNameCpp, pchComma, LenCpp);
           *(OutputNameCpp + LenCpp) = '\0';
           }
       else {
           iHandleCpp = -1;     // ignore CPP macros, and don't warn
           }

       Len += LenCpp + 1;

       }
      
   pNames += Len;
   if (*pNames != ':') {  // no template name!
       return FALSE;
       }

   Len = GetFullPathName(OutputName,
                         sizeof(FullOutputName) - 1,
                         FullOutputName,
                         &OutputBaseName
                         );
   if (Len >= sizeof(FullOutputName) - 1) {
       return FALSE;
       }

   SizeFileName = Len + 1;

   fp = fopen(FullOutputName, "w");
   if (!fp) {
       ExitErrMsg(TRUE, "fopen(%s) failed\n", FullOutputName);
       }
   if (!AddOpenFile(FullOutputName, fp, NULL)) {
       ExitErrMsg(FALSE, "AddOpenFile failed\n");
       }
   if (fseek(fp, 0, SEEK_SET)) {
       ExitErrMsg(TRUE, "ExtractCGenerate: fseek to 0 failed\n");
   }


   //
   // Open the CPP file name
   //

   //if (iHandleCpp > 0) {
   if (OutputNameCpp[0]) {

       Len = GetFullPathName(OutputNameCpp,
                             sizeof(FullOutputNameCpp) - 1,
                             FullOutputNameCpp,
                             &OutputBaseNameCpp
                             );
       if (!Len || (Len >= sizeof(FullOutputNameCpp) - 1)) {
           return FALSE;
           }

       SizeFileNameCpp = Len + 1;

       fpCpp = fopen(FullOutputNameCpp, "w");
       if (!fpCpp) {
           ExitErrMsg(TRUE, "fopen(%s) failed\n", FullOutputNameCpp);
           }
       if (!AddOpenFile(FullOutputNameCpp, fpCpp, NULL)) {
           ExitErrMsg(FALSE, "AddOpenFile failed\n");
           }

       if (fseek(fpCpp, 0, SEEK_SET)) {
           ExitErrMsg(TRUE, "ExtractCGenerate fseek #2 to 0 failed\n");
       }

       }
   
   pch = GetNextToken(pNames);
   if (pch == pNames || !*pch) {
       return FALSE;
       }

   Len = CopyToken(TempleName, pch, sizeof(TempleName) - 1);
   if (!Len || Len >= sizeof(TempleName) - 1) {
       return FALSE;
       }

   SizeTempleName = Len + 1;

   Len = sizeof(CGENERATE) + 1;
   Len += SizeFileName + SizeTempleName + SizeFileNameCpp;
   pCGen = GenHeapAlloc(Len);
   if (!pCGen) {
       ExitErrMsg(TRUE, "GenHeapAlloc(CGENERATE)");
       }
   memset(pCGen, 0, Len);

   if (bDebug) {
       setvbuf(fp, NULL, _IONBF, 0);
       }

   pCGen->fp = fp;
   pCGen->fpC = fp;
   strcpy(pCGen->TempleName, TempleName);
   pCGen->FileNameC = pCGen->TempleName + SizeTempleName;
   pCGen->FileBaseNameC = pCGen->FileNameC;
   pCGen->FileBaseNameC += OutputBaseName - FullOutputName;
   strcpy(pCGen->FileNameC, FullOutputName);


   //
   // Save the CPP filename, and file handle.
   //

   if (iHandleCpp > 0 && OutputNameCpp[0]) {
       if (bDebug) {
           setvbuf(fpCpp, NULL, _IONBF, 0);
           }
       pCGen->fpCpp = fpCpp;
       pCGen->FileNameCpp = pCGen->FileNameC + SizeFileName;
       pCGen->FileBaseNameCpp = pCGen->FileNameCpp;
       pCGen->FileBaseNameCpp += OutputBaseNameCpp - FullOutputNameCpp;
       strcpy(pCGen->FileNameCpp, FullOutputNameCpp);
       }
       
   InsertTailList(&CGenerateList, &pCGen->CGenerateEntry);

   return TRUE;
}



/*
 *  ExtractTemples
 *
 */
BOOL ExtractTemples(char *FileName)
{
    FILE *fp;
    int  FileSize;
    BOOL bRet = FALSE;
    char *pSrc;
    char *pch;
    size_t  Len;
    int  CGenLen;
    LPSTR pCCode[MAX_CODEBURST];
    char Comment[MAX_PATH];
    char IndLevel[MAX_PATH];
    char TempleType[MAX_PATH];
    char TempleName[MAX_PATH];
    char CodeBurstName[MAX_PATH];
    LPSTR Also[MAX_ALSO];
    int AlsoCount;
    LPSTR NoType[MAX_NOTYPE];
    int NoTypeCount;
    PLIST_ENTRY pCaseList;
    char Line[1024];
    int  CodeBurstIndex;
    TOKENTYPE tkDirection;
    PTEMPLES tpl;
    BOOL fFreeCCode = TRUE;
    int i;


    DbgPrintf("Template: %s\n", FileName);

    fp = fopen(FileName, "r");
    if (!fp) {
        ExitErrMsg(TRUE, "fopen(%s) failed\n", FileName);
    }
    if (fseek(fp, 0, SEEK_END)) {
        ExitErrMsg(TRUE, "fseek to EOF failed\n");
    }
    FileSize = ftell(fp);
    if (fseek(fp, 0, SEEK_SET)) {
        ExitErrMsg(TRUE, "fseek to 0 failed\n");
    }

    // Record the filename/line number information for error messages
    TemplateFileName = FileName;
    TemplateLine = 1;

    if (!fgets(Line, sizeof(Line) - 1, fp)) {
        if (ferror(fp)) {
            ExitErrMsg(TRUE, "Failed to get Types from %s\n", FileName);

        } else if (feof(fp)) {
            ExitErrMsg(TRUE, "Premature EOF %s\n", FileName);
        }
    }

    // reset the TempleType:  no [TempleType] is active
    *TempleType = '\0';

    // reset all variables used within a [TempleType]
    CGenLen = 0;
    *IndLevel = 0;
    *TempleName = '\0';
    strcpy(Comment, "//");
    memset(pCCode, 0, sizeof(LPSTR)*MAX_CODEBURST);
    tkDirection = TK_EOS;       // assume template handles all flavors of IN/OUT
    AlsoCount=0;
    NoTypeCount=0;
    pCaseList = NULL;

    // loop over all lines in the template file
    do {
        pSrc = Line;

        // skip whitespace at the start of the line
        while (*pSrc && isspace(*pSrc)) {
            pSrc++;
        }

        // if at end-of-line or encountered ';'  (comment-to-EOL), go to
        // next line.
        if (!*pSrc || *pSrc == ';') {
            goto GetNextLine;
        }

        if (*pSrc == '[') {
            // encountered new [TempleType].  If there was a previous template,
            // add it now.
            if (*TempleName &&
                !AddTemple(TempleType, TempleName, Comment, IndLevel, pCCode, tkDirection, Also, AlsoCount, NoType, NoTypeCount, pCaseList)) {
                ExitErrMsg(FALSE, "%s(%d) %s %s\n", TemplateFileName, TemplateLine, TempleType, pSrc);
            }

            // free the previous template's memory
            if (fFreeCCode) {
                for (i=0; i < MAX_CODEBURST; ++i) {
                    if (pCCode[i]) {
                        GenHeapFree(pCCode[i]);
                    }
                }
            }
            fFreeCCode = TRUE;

            // reset the vars used for each template
            CGenLen = 0;
            memset(pCCode, 0, sizeof(LPSTR)*MAX_CODEBURST);
            *IndLevel = 0;
            *TempleName = '\0';
            strcpy(Comment, "//");
            tkDirection = TK_EOS;       // assume template handles all flavors of IN/OUT
            pCaseList = NULL;

            for (i=0; i<AlsoCount; ++i) {
                GenHeapFree(Also[i]);
            }
            AlsoCount=0;
            for (i=0; i<NoTypeCount; ++i) {
                GenHeapFree(NoType[i]);
            }
            NoTypeCount=0;

            // set up the new TempleType
            pSrc++;
            Len = CopyToken(TempleType, pSrc, sizeof(TempleType) - 1);
            if (Len >= sizeof(TempleType) - 1) {
                goto ETPLExit;
            }
            pch = pSrc + Len;
            if (*pch != ']') {
                *TempleType = '\0';
            }
            goto GetNextLine;
        }

        // if no active [TempleType], ignore the line
        if (!*TempleType) {
            goto GetNextLine;
        }

        // a [TempleType] is active.  Scan for known property names
        if ( ((pch = SkipKeyWord(pSrc, szTEMPLENAME)) != pSrc ||
              (pch = SkipKeyWord(pSrc, szMACRONAME)) != pSrc ||
              (pch = SkipKeyWord(pSrc, szTYPENAME)) != pSrc)
             && *pch == '=') {

            // found:       TemplateName=
            //           or MacroName=
            //           or TypeName=
            // They all mean the same thing.

            // If a template is outstanding, add it now.
            if (*TempleName &&
                !AddTemple(TempleType, TempleName, Comment, IndLevel, pCCode, tkDirection, Also, AlsoCount, NoType, NoTypeCount, pCaseList)) {
                ExitErrMsg(FALSE, "%s(%d) %s %s\n", TemplateFileName, TemplateLine, TempleType, pSrc);
            }

            // free the previous template's memory
            if (fFreeCCode) {
                for (i=0; i < MAX_CODEBURST; ++i) {
                    if (pCCode[i]) {
                        GenHeapFree(pCCode[i]);
                    }
                }
            }
            fFreeCCode = TRUE;

            // reset the vars used for each template
            CGenLen = 0;
            memset(pCCode, 0, sizeof(LPSTR)*MAX_CODEBURST);
            *IndLevel = 0;
            *TempleName = '\0';
            tkDirection = TK_EOS;       // assume template handles all flavors of IN/OUT
            pCaseList = NULL;
            for (i=0; i<AlsoCount; ++i) {
                GenHeapFree(Also[i]);
            }
            AlsoCount=0;
            for (i=0; i<NoTypeCount; ++i) {
                GenHeapFree(NoType[i]);
            }
            NoTypeCount=0;

            // copy in the new TemplateName
            pch = GetNextToken(pch);
            Len = sizeof(TempleName) - 1;
            pSrc = TempleName;
            while (isgraph(*pch) && Len--) {
                *pSrc++ = *pch++;
            }
            if (Len == 0) {
                // name too long
                goto ETPLExit;
            }
            *pSrc = '\0';

        } else if ((pch = SkipKeyWord(pSrc, szCOMMENT)) != pSrc &&
                   *pch == '=') {

            // found:   Comment=
            pch = GetNextToken(pch);
            Len = sizeof(Comment) - 1;
            pSrc = Comment;
            while (isgraph(*pch) && Len--) {
                *pSrc++ = *pch++;
            }

            *pSrc = '\0';

        } else if ( ((pch = SkipKeyWord(pSrc, szINDLEVEL)) != pSrc ||
                     (pch = SkipKeyWord(pSrc, szNUMARGS)) != pSrc)
                    && *pch == '=') {

            // Found:       IndLevel=
            //           or NumArgs=
            // They mean the same thing
            pch = GetNextToken(pch);
            if (IsSeparator(*pch)) {
                goto ETPLExit;
            }
            pSrc = pch;
            Len = CopyToken(IndLevel, pSrc, sizeof(IndLevel) - 1);
            pch += Len;

        } else if ((pch = SkipKeyWord(pSrc, szDIRECTION)) != pSrc &&
                *pch == '=') {
            pch++;
            // Found:   Direction=
            if (strncmp(pch, "IN OUT", 6) == 0) {
                tkDirection = TK_INOUT;
                pch += 6;
            } else if (strncmp(pch, "IN", 2) == 0) {
                tkDirection = TK_IN;
                pch += 2;
            } else if (strncmp(pch, "OUT", 3) == 0) {
                tkDirection = TK_OUT;
                pch += 3;
            } else if (strncmp(pch, "none", 4) == 0) {
                // this allows a type template to explicitly catch
                // all pointer types which have no IN/OUT modifiers.
                tkDirection = TK_NONE;
                pch+=4;
            } else {
                goto ETPLExit;
            }

        } else if ((pch = SkipKeyWord(pSrc, szUSE)) != pSrc &&
                *pch == '=') {
            PLIST_ENTRY pHeadList;
            char buffer[MAX_PATH];

            // Found: Use=
            pch++;
            pHeadList = ListFromTempleType(TempleType);
            if (!pHeadList) {
                ExitErrMsg(FALSE, "%s(%d) Use= can only be used after a [Temple]\n", TemplateFileName, TemplateLine);
            }
            Len = CopyToken(buffer, pch, sizeof(buffer));
            tpl = GetTemplate(pHeadList, buffer);
            if (!tpl) {
                ExitErrMsg(FALSE, "%s(%d) Use=%s: Template not found\n", TemplateFileName, TemplateLine, pch);
            }

            // copy the template back to our locals
            strcpy(Comment, tpl->Comment);
            sprintf(IndLevel, "%d", tpl->IndLevel);
            tkDirection = tpl->tkDirection;
            memcpy(pCCode, tpl->CodeBurst, sizeof(LPSTR)*MAX_CODEBURST);
            fFreeCCode = FALSE; // Don't GenHeapFree() the pCCode array
                                // after adding this temple.
            pch += Len;

        } else if ((pch = SkipKeyWord(pSrc, szNOTYPE)) != pSrc &&
                *pch == '=') {
            char *t;

            if (AlsoCount) {
                ExitErrMsg(FALSE, "%s(%d) Cannot have both NoType= and Also= in the same template\n", TemplateFileName, TemplateLine);
            }

            // skip '=' and any leading spaces
            do {
                pch++;
                if (*pch == '\0') {
                    goto ETPLExit;
                }
            } while (isspace(*pch) && *pch != '\0');

            // get length of the NoType= name
            t = pch;
            while (isgraph(*t)) {
                t++;
            }
            Len= t-pch;

            // copy the name
            t = GenHeapAlloc(Len + 1);
            memcpy(t, pch, Len);
            t[Len] = '\0';

            if (NoTypeCount == MAX_NOTYPE) {
                ExitErrMsg(FALSE, "%s(%d) Max. of %d NoType= clauses allowed.  Also=%s\n", TemplateFileName, TemplateLine, MAX_ALSO, t);
            }

            NoType[NoTypeCount++] = t;

            pch += Len;
        
        } else if ((pch = SkipKeyWord(pSrc, szCASE)) != pSrc &&
                *pch == '=') {
            char *t;
            PMACROARGSLIST pMArgsList = NULL;
            PMLLISTENTRY pMLListEntry = NULL;

            // skip '=' and any leading spaces
            do {
                pch++;
                if (*pch == '\0') {
                    goto ETPLExit;
                }
            } while (isspace(*pch) && *pch != '\0');

            // get length of the Case=
            t = pch;
            while (isgraph(*t)) {
                t++;
            }
            Len= t-pch;

            if (pCaseList == NULL) {
               pCaseList = CheckHeapAlloc(sizeof(LIST_ENTRY));
               InitializeListHead(pCaseList);
            }

            ParseMacroArgs(pch, Len, &pMArgsList);
            pMLListEntry = CheckHeapAlloc(sizeof(MLLISTENTRY));
            if (NULL == pMLListEntry) {
               ExitErrMsg(FALSE, "Out of memory\n");
            }
            pMLListEntry->pMArgs = pMArgsList;
            InsertTailList(pCaseList, &(pMLListEntry->ListEntry));
            pch += Len;


        } else if ((pch = SkipKeyWord(pSrc, szALSO)) != pSrc &&
                *pch == '=') {
            char *t;

            if (NoTypeCount) {
                ExitErrMsg(FALSE, "%s(%d) Cannot have both Also= and NoType= in the same template\n", TemplateFileName, TemplateLine);
            }

            // skip '=' and any leading spaces
            do {
                pch++;
                if (*pch == '\0') {
                    goto ETPLExit;
                }
            } while (isspace(*pch) && *pch != '\0');

            // get length of the Also= name
            t = pch;
            while (isgraph(*t)) {
                t++;
            }
            Len= t-pch;

            // copy the name
            t = GenHeapAlloc(Len + 1);
            memcpy(t, pch, Len);
            t[Len] = '\0';

            if (AlsoCount == MAX_ALSO) {
                ExitErrMsg(FALSE, "%s(%d) Max. of %d Also= clauses allowed.  Also=%s\n", TemplateFileName, TemplateLine, MAX_ALSO, t);
            }

            Also[AlsoCount++] = t;

            pch += Len;

        } else {

GetNextCodeBurst:
            // grab the name, and if the next thing isn't '=', error out.
            pch = GetNextToken(pSrc);
            if (*pch != '=') {
                goto ETPLExit;
            }
            Len = CopyToken(CodeBurstName, pSrc, pch-pSrc);
            pch += Len;

            // convert the name into an index
            CodeBurstIndex = GetCodeBurstIndex(CodeBurstName);
            if (pCCode[CodeBurstIndex]) {
                // Two codebursts with the same name in this template
                goto ETPLExit;
            }

            pCCode[CodeBurstIndex] = GenHeapAlloc(FileSize*2 + 1);
            CGenLen = 0;

            pSrc = pCCode[CodeBurstIndex];
            while (fgets(pSrc, FileSize*2 - CGenLen, fp)) {
                char buffer[MAX_PATH];
                int len;

                TemplateLine++;

                len = CopyToken(buffer, pSrc, sizeof(buffer));
                pch = pSrc;
                if (len && pSrc[len] == '=') {
                    // The line starts with some keyword and is followed by
                    // an '=' sign.
                    if (strcmp(buffer, szCGENEND) == 0 ||
                        strcmp(buffer, "CGenEnd") == 0) {

                        // The string is 'End=' or 'CGenEnd='.  The CodeBurst
                        // is done.
                        *pSrc = '\0';
                        CGenLen++;
                        pch += len+1;
                        break;
                    }

                    // See if it is the start of a new CodeBurst:
                    CodeBurstIndex = GetExistingCodeBurstIndex(buffer);
                    if (CodeBurstIndex != -1) {
                        strcpy(Line, pSrc);
                        *pSrc = '\0';
                        CGenLen++;
                        pSrc = Line;
                        goto GetNextCodeBurst;
                    }
                }

                Len = strlen(pSrc);
                CGenLen += Len;
                pSrc += Len;

            }

            if (!CGenLen) {
                GenHeapFree(pCCode[CodeBurstIndex]);
                pCCode[CodeBurstIndex] = NULL;
            }
        }

        while (*pch && *pch != ';' && IsSeparator(*pch)) {
            pch++;
        }
        if (*pch) {
            if (*pch == ';') {
                // comment to end-of-line
                goto GetNextLine;
            }
            goto ETPLExit;
        }

GetNextLine:
        TemplateLine++;
    } while (fgets(Line, sizeof(Line) - 1, fp));

    // If there is an outstanding template when EOF is hit, add it now.
    if (*TempleName &&
        !AddTemple(TempleType, TempleName, Comment, IndLevel, pCCode, tkDirection, Also, AlsoCount, NoType, NoTypeCount, pCaseList)) {

        ExitErrMsg(FALSE, "%s(%d) %s %s\n", TemplateFileName, TemplateLine, TempleType, pSrc);
    }


    if (!feof(fp) && ferror(fp)) {
        ExitErrMsg(TRUE, "%s(%d) Read error: %s\n", TemplateFileName, TemplateLine, TempleName);
    }

    bRet = TRUE;

ETPLExit:
    if (!bRet) {
        ErrMsg("%s(%d) ETPL: Invalid Line <%s>\n%s\n", TemplateFileName, TemplateLine, pSrc, Line);
    }

    if (fFreeCCode) {
        for (i=0; i < MAX_CODEBURST; ++i) {
            if (pCCode[i]) {
                GenHeapFree(pCCode[i]);
            }
        }
    }
    for (i=0; i<AlsoCount; ++i) {
        GenHeapFree(Also[i]);
    }
    for (i=0; i<NoTypeCount; ++i) {
        GenHeapFree(NoType[i]);
    }

    fclose(fp);

    TemplateFileName = NULL;

    return bRet;
}



PEXPORTSDEBUG
FindInExportsList(char *Name)
{
    PLIST_ENTRY pNext;
    PEXPORTSDEBUG pexportsdbg;

    pNext = ExportsList.Flink;
    while (pNext != &ExportsList) {
        pexportsdbg = CONTAINING_RECORD(pNext, EXPORTSDEBUG, ExportsDbgEntry);
        if (!strcmp(Name, pexportsdbg->ExportName)) {
            return pexportsdbg;
        }
        pNext = pNext->Flink;
    }
    return NULL;
}




PLIST_ENTRY
ListFromTempleType(
    char *TempleType
    )
{
    if (!TempleType || !*TempleType) {
        return NULL;
    }

    if (!strcmp(TempleType, szIFUNC)) {
        return &IFuncTempleList;
    } else if (!strcmp(TempleType, szEFUNC)) {
        return &EFuncTempleList;
    } else if (!strcmp(TempleType, szTYPES)) {
        return &TypeTempleList;
    } else if (!strcmp(TempleType, szCODE)) {
        return &CodeTempleList;
    } else if (!strcmp(TempleType, szEFAST)) {
        return &EFastTempleList;
    } else if (!strcmp(TempleType, szMACROS)) {
        return &MacroList;
    } else if (!strcmp(TempleType, szFAILTYPES)) {
        return &FailTempleList;
    }
    return NULL;
}

/*
 *  AddTemple
 *
 *  worker function for ExtractTemple, to verify and store template.
 */

#pragma optimize("", off)
BOOL
AddTemple(
    char *TempleType,
    char *TempleName,
    char *Comment,
    char *IndLevel,
    char *pCCode[MAX_CODEBURST],
    TOKENTYPE tkDirection,
    char *Also[MAX_ALSO],
    int AlsoCount,
    char *NoType[MAX_NOTYPE],
    int NoTypeCount,
    PLIST_ENTRY pCaseList
    )
{
    PLIST_ENTRY pHeadList = NULL;
    PTEMPLES ptpl;
    char *pch;
    int SizeCGen, SizeTempleName, SizeComment, SizeNoType;
    int Len;
    int i;
    int AlsoIndex;

    if (!*TempleName) {
        return FALSE;
    }

    pHeadList = ListFromTempleType(TempleType);
    if (!pHeadList) {
        return FALSE;
    }

    SizeCGen = 0;
    for (i=0; i<MAX_CODEBURST; ++i) {
         SizeCGen++;
         if (pCCode[i]) {
            SizeCGen += strlen(pCCode[i]);
         }
    }

    AlsoIndex=0;

    for (;;) {
        if (pHeadList != &TypeTempleList && GetTemplate(pHeadList, TempleName)) {
            ExitErrMsg(FALSE, "Multiple templates are not allowed.  TemplateName=%s, Type=%s\n", TempleName, TempleType);
        }

        SizeTempleName = strlen(TempleName) + 1;
        SizeComment = strlen(Comment) + 1;
        SizeNoType = 0;
        for (i=0; i<NoTypeCount; ++i) {
            SizeNoType += strlen(NoType[i])+1;
        }


        Len = SizeCGen + SizeTempleName + SizeComment + SizeNoType;
        Len +=  sizeof(TEMPLES);

        ptpl = GenHeapAlloc(Len);
        if (!ptpl) {
            ExitErrMsg(TRUE, "GenHeapAlloc(TEMPLE)");
            }

        memset(ptpl, 0, Len);
        ptpl->IndLevel = strtoul(IndLevel, &pch, 10);
        ptpl->tkDirection = tkDirection;

        Len = 0;
        ptpl->Name = ptpl->Buffer;
        strcpy(ptpl->Name, TempleName);
        Len += SizeTempleName;

        ptpl->Comment = ptpl->Buffer + Len;
        strcpy(ptpl->Comment, Comment);
        Len += SizeComment;

        for (i=0; i<MAX_CODEBURST; ++i) {
            if (pCCode[i]) {
                //
                // Copy the code for this codeburst name
                //
                ptpl->CodeBurst[i] = ptpl->Buffer + Len;
                Len++;
                strcpy(ptpl->CodeBurst[i], pCCode[i]);
                Len += strlen(pCCode[i]);
            }
        }

        for (i=0; i<NoTypeCount; ++i) {
            ptpl->NoTypes[i] = ptpl->Buffer + Len;
            Len++;
            strcpy(ptpl->NoTypes[i], NoType[i]);
            Len += strlen(NoType[i]);
        }

        ptpl->pCaseList = pCaseList;

        InsertTailList(pHeadList, &ptpl->TempleEntry);

        if (bDebug && Len >= SizeCGen+SizeTempleName+SizeComment+SizeNoType) {
            ExitErrMsg(FALSE, "Buffer overrun in AddTemple!  Heap is trashed! ptpl=%x\n", ptpl);
        }

        if (bDebug) {
            DumpTemplate(ptpl, stdout);
            }

        if (AlsoIndex == AlsoCount) {
            break;
        }
        // there are Also= lines, add those template, too
        strcpy(TempleName, Also[AlsoIndex]);
        AlsoIndex++;
    }

   return TRUE;
}
#pragma optimize("", on)


/*
 *
 */
void DumpTemplate(PTEMPLES ptpl, FILE *fp)
{
     int i;

     fprintf(fp,"Temple: %d Name<%s>\n",
                 ptpl->IndLevel,
                 ptpl->Name
                 );

     for (i=0; i<MAX_CODEBURST; ++i) {
         if (CodeBursts[i].Name) {
             fprintf(fp,"%s(%d) Temple: %s<%s>\n", TemplateFileName, TemplateLine, CodeBursts[i].Name, ptpl->CodeBurst[i]);
         }
     }
}


ULONG
EndianSwitch(
    PULONG pul
    )
{
    ULONG NewValue;
    PBYTE pbValue = (PBYTE)pul;
    PBYTE pbNewValue = (PBYTE) &NewValue;

    *pbNewValue++ = *(pbValue + 3);
    *pbNewValue++ = *(pbValue + 2);
    *pbNewValue++ = *(pbValue + 1);
    *pbNewValue   = *pbValue;

    return NewValue;
}


/*  MapViewDll
 *
 *  Creates a Mapped view of a Dll and intializes
 *  Dll global variables for easy access to the Export Directory
 *
 *  DllMappedBase
 *  DllRvaOffset
 *  DllExportDir
 *  DllExportDirSize
 *  DllFunctions
 *  DllNameOrdinals
 *  DllNameTable
 *
 *
 */
BOOL MapViewDll(char *DllName)
{
    ULONG_PTR RvaOffset;
    HANDLE hFile;
    HANDLE hMapFile;
    PVOID  MappedBase;
    PIMAGE_EXPORT_DIRECTORY ExportDir;
    ULONG ExportDirSize;
    ULONG Forward;



    //
    // open and map the file to get the exports info
    //

    hFile = CreateFile(DllName,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL
                       );

    if (hFile == INVALID_HANDLE_VALUE) {
        ErrMsg("MapViewDll CreateFile(%s) gle %d\n", DllName, GetLastError());
        return FALSE;
        }

    hMapFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0,NULL);
    if (!hMapFile) {
        ErrMsg("MapViewDll CreateFileMapping(%s) gle %d\n", DllName, GetLastError());
        return FALSE;
        }

    MappedBase = MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);
    if (!MappedBase) {
        ErrMsg("MapViewDll MapViewOfFile(%s) gle %d\n", DllName, GetLastError());
        return FALSE;
        }

    ExportDir = ImageDirectoryEntryToData( MappedBase,
                                           TRUE,
                                           IMAGE_DIRECTORY_ENTRY_EXPORT,
                                           &ExportDirSize
                                           );
    if (!ExportDir) {
        ErrMsg("MapViewDll ImageDirectoryEntryToData=NULL\n");
        return FALSE;
        }

    //
    // Initialize the global variables.
    //

    RvaOffset = (ULONG_PTR)ExportDir - (ULONG_PTR)MappedBase;

    ExportDir = ImageDirectoryEntryToData( MappedBase,
                                           FALSE,
                                           IMAGE_DIRECTORY_ENTRY_EXPORT,
                                           &ExportDirSize
                                           );
    if (!ExportDir) {
        ErrMsg("MapViewDll ImageDirectoryEntryToData=NULL on the second call\n");
        return FALSE;
    }


    DllExportDirSize = ExportDirSize;
    DllMappedBase = MappedBase;
    DllRvaOffset = RvaOffset;
    DllExportDir = ExportDir;

    DllFunctions = (PULONG)((ULONG_PTR)ExportDir +
                            (ULONG_PTR)ExportDir->AddressOfFunctions - RvaOffset
                            );


    DllNameTable  = (PULONG)((ULONG_PTR)ExportDir +
                          (ULONG_PTR)ExportDir->AddressOfNames - RvaOffset
                          );

    DllNameOrdinals = (PUSHORT)((ULONG_PTR)ExportDir +
                             (ULONG_PTR)ExportDir->AddressOfNameOrdinals - RvaOffset
                             );

    fprintf(stdout,
            "Name %s Base %x Ver %x.%x NumberOfFunctions %x NumberOfNames %x\n",
            (PCHAR)((ULONG_PTR)ExportDir + (ULONG_PTR)ExportDir->Name - RvaOffset),
            ExportDir->Base,
            (ULONG)ExportDir->MajorVersion,
            (ULONG)ExportDir->MinorVersion,
            ExportDir->NumberOfFunctions,
            ExportDir->NumberOfNames
            );


    return TRUE;

}


ULONG
DllOrdinalByName(
    char *ExportName
    )
{
    PULONG pNames;
    ULONG NumNames;
    PUSHORT pNameOrdinals;
    char *Name;

    pNames  = DllNameTable;
    pNameOrdinals = DllNameOrdinals;

    NumNames = DllExportDir->NumberOfNames;
    while (NumNames--) {
        Name = (char *)((ULONG_PTR)DllExportDir + *pNames - DllRvaOffset);

        if (!strcmp(Name, ExportName)) {
            return *pNameOrdinals + DllExportDir->Base;
            }

        pNames++;
        pNameOrdinals++;
        }


   return 0;
}





/*  MapViewImplib
 *
 *  Creates a Mapped view of an import library and intializes
 *  ImpLib global variables for access to symbols in the first
 *  special linker member.
 *
 *  ImplibMappedBase
 *  ImplibNumSymbols
 *  ImplibSymbolMembers
 *  ImplibSymbolNames
 *
 */

BOOL MapViewImplib(char *LibName)
{
    HANDLE hFile;
    HANDLE hMapFile;
    PBYTE  MappedBase;
    PBYTE  VirtualOffset;
    ULONG  MemberSize;
    PIMAGE_ARCHIVE_MEMBER_HEADER ArchiveMemberHeader;


    //
    // open and map the file.
    //

    hFile = CreateFile(LibName,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL
                       );

    if (hFile == INVALID_HANDLE_VALUE) {
        ErrMsg("MapViewImplib CreateFile(%s) gle %d\n", LibName, GetLastError());
        return FALSE;
        }

    hMapFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0,NULL);
    if (!hMapFile) {
        ErrMsg("MapViewImplib CreateFileMapping(%s) gle %d\n", LibName, GetLastError());
        return FALSE;
        }

    MappedBase = (PBYTE)MapViewOfFile(hMapFile, FILE_MAP_READ, 0, 0, 0);
    if (!MappedBase) {
        ErrMsg("MapViewImplib MapViewOfFile(%s) gle %d\n", LibName, GetLastError());
        return FALSE;
        }


    //
    // Verify the file is an archive
    //

    if (memcmp(MappedBase, IMAGE_ARCHIVE_START, IMAGE_ARCHIVE_START_SIZE)) {
        ErrMsg("MapViewImplib IMAGE_ARCHIVE_START_SIZE invalid(%s)\n", LibName);
        return FALSE;
        }

    VirtualOffset = MappedBase + IMAGE_ARCHIVE_START_SIZE;

    ArchiveMemberHeader = (PIMAGE_ARCHIVE_MEMBER_HEADER) VirtualOffset;
    if (sscanf((char *) ArchiveMemberHeader->Size, "%ld", &MemberSize) != 1) {
        ErrMsg("MapViewImplib ArchiveMemberHeader->Size '%s' corrupt\n", (char *) ArchiveMemberHeader->Size);
        return FALSE;
    }


    //
    // Verify first special linker member exists (name == "\\")
    //

    if (memcmp(ArchiveMemberHeader->Name, IMAGE_ARCHIVE_LINKER_MEMBER, sizeof(ArchiveMemberHeader->Name))) {
        ErrMsg("MapViewImplib first special linker member missing (%s)\n", LibName);
        return FALSE;
        }

    //
    // First Linker Member format (Big endian!)
    //  NumberOfSymbols, 4 bytes
    //  Offsets,         4 bytes * NumSymbols
    //  StringTable      NumSymbols == NumStrings
    //

    VirtualOffset += sizeof(IMAGE_ARCHIVE_MEMBER_HEADER);
    ImplibNumSymbols = EndianSwitch((PULONG)VirtualOffset);


    VirtualOffset += 4;
    ImplibSymbolMembers = (PULONG)VirtualOffset;

    VirtualOffset +=  ImplibNumSymbols * sizeof(ULONG);
    ImplibSymbolNames = (PCHAR)VirtualOffset;

    ImplibMappedBase = MappedBase;

    fprintf(stdout, "Implib: %s Base %p\n", LibName, ImplibMappedBase);


    return TRUE;

}


BOOL
ExtractMember(
    ULONG MemberOffset,
    PULONG Ordinal,
    BOOLEAN *Data
    )
{
    PIMAGE_FILE_HEADER ImageFileHeader;
    PBYTE VirtualOffset;
    BOOL Idata5Found, TextFound;

    VirtualOffset = (PBYTE)ImplibMappedBase + MemberOffset;

    VirtualOffset += sizeof(IMAGE_ARCHIVE_MEMBER_HEADER);
    ImageFileHeader = (PIMAGE_FILE_HEADER) VirtualOffset;

    *Ordinal = 0;
    Idata5Found = FALSE;
    TextFound = FALSE;

    if (ImageFileHeader->Machine == 0 &&
        ImageFileHeader->NumberOfSections == 0xffff) {
        //
        // VC6 format import lib found.
        //
        PVC6_IMAGE_IMPORT_HEADER pHdr;

        pHdr = (PVC6_IMAGE_IMPORT_HEADER)ImageFileHeader;
        if (pHdr->NameType == IMPORT_ORDINAL) {
            //
            // pHdr->wOrdinal specifies the ordinal for this import.
            //
            *Ordinal = 0x80000000 | (ULONG)pHdr->Ordinal;
        }
        if (pHdr->Type == IMPORT_DATA) {
            //
            // This is a data import
            //
            *Data = TRUE;
        }
        Idata5Found = TRUE;
    } else {
        //
        // Pre-VC6 import lib.
        //
        ULONG NumSections;
        ULONG UNALIGNED *RawDataPointer;
        IMAGE_SECTION_HEADER UNALIGNED *ImageSectionHeader;

        NumSections = ImageFileHeader->NumberOfSections;

        //
        // Carefull, librarian doesn't align the Image section header according
        // to normal rules for images.
        //

        VirtualOffset += sizeof(IMAGE_FILE_HEADER) + ImageFileHeader->SizeOfOptionalHeader;
        ImageSectionHeader = (IMAGE_SECTION_HEADER UNALIGNED *)VirtualOffset;

        while (NumSections--) {

            //
            // Implib provides .idata5, and .idata4 (duplicate) which
            // contains the ordinal number with the hi bit set if it
            // was specified in the module definition file. Otherwise
            // the ordinal number is not specified in the implib.
            //

            if (!Idata5Found &&
                !strncmp(ImageSectionHeader->Name, szIDATA5, sizeof(szIDATA5)-1)) {

                //
                // Carefull, librarian doesn't align the begining of raw data
                // according to normal rules for images.
                //

                RawDataPointer = (ULONG UNALIGNED *)((PBYTE)ImageFileHeader + ImageSectionHeader->PointerToRawData);
                if (*RawDataPointer & 0x80000000) {
                    *Ordinal = *RawDataPointer;
                }
                Idata5Found = TRUE;

            } else if (!TextFound &&
                 !strncmp(ImageSectionHeader->Name, szTEXT, sizeof(szTEXT)-1)) {
                TextFound = TRUE;
            }

            ImageSectionHeader++;
        }

        *Data = !TextFound;  // if no text section, must be data export
    }
    return Idata5Found;
}






BOOL
InitExportDebug(
    PEXPORTSDEBUG ExportDebug,
    char *SymbolName,
    ULONG SymbolMember
    )
{
    ULONG_PTR Forward;
    ULONG OrdinalIndex;
    char *pch = SymbolName; // we assume __implib_ prefix not present

    //
    // C fn begins with "_"
    // C++ fn begins with "?"
    // Data export begins with  "??_C" in real symbols,
    // but in implib looks a C function
    //

    if (*pch == '?') {
        ExportDebug->CplusDecoration = pch;
        DbgPrintf("C++ export %s\n", SymbolName);
        }
    else {
        ExportDebug->CplusDecoration = NULL;
        }

    //
    //  Copy out the ExportName.
    //

    if (*pch == '_' || *pch == '?') {
        pch++;                          // skip lead char (underscor, qmark)
    }
    strcpy(ExportDebug->ExportName, pch);
    pch = strchr(ExportDebug->ExportName, '@');
    if (SymbolName[0] == '?' && SymbolName[1] == '?') {
        //
        // Found a "real" C++ name: a mangled version of
        // "classname::membername".  Use the fully-mangled function name,
        // instead of the name with the leading '?' stripped, and don't
        // truncate after the '@'.
        //
        strcpy(ExportDebug->ExportName, SymbolName);
        pch = NULL;
    }
    if (pch && ExportDebug->CplusDecoration && pch[1] != '@') {
        //
        // This export is '?membername@classname@@...'.  Don't truncate!
        //
        strcpy(ExportDebug->ExportName, SymbolName);
        pch = NULL;
    }

    if (pch && !bNoFuzzyLogic) {   // truncate the symbol from ExportName
        *pch = '\0';
        }

    //
    // Get the decoration, for synthetic args
    // cdecl has no decoration
    // stdcall has total arg size
    //

    if (pch && !ExportDebug->CplusDecoration) {
        ExportDebug->ArgsSize = strtol(pch + 1, NULL, 10);
        }
    else {
        ExportDebug->ArgsSize = -1;
        }


    //
    // Fetch the ordinal from the implib. In an Implib the ordinal
    // only appears if an ordinal is specifed in the def file.
    //

    if (!ExtractMember(SymbolMember, &ExportDebug->Ordinal, &ExportDebug->Data)) {
        ErrMsg("InitExportDebug: %s Member not found\n", SymbolName);
        return FALSE;
        }

    if (ExportDebug->Data) {
        DbgPrintf("DATA export %s\n", SymbolName);
        }

    //
    // If we don't yet have an ordinal, search the ExportNameTable
    // for the Ordinal number. Note that Ordinals which *must* appear
    // in generated def files have the hi-bit set!
    //

    if (!ExportDebug->Ordinal) {
        ExportDebug->Ordinal = DllOrdinalByName(ExportDebug->ExportName);
        if (!ExportDebug->Ordinal) {
            ErrMsg("InitExportDebug: %s Ordinal not found\n", SymbolName);
            return FALSE;
            }
        }


    //
    // Look up function using ordinal as index to function table.
    //

    OrdinalIndex = IMPORDINAL(ExportDebug->Ordinal) - DllExportDir->Base;
    ExportDebug->Function = *(DllFunctions + OrdinalIndex);


    //
    // Check for references forwarded externally, we only need
    // external forwards which are really internal forwards.
    //
    // e.g rpcrt4.dll has following def file entries:
    //
    // I_RpcBindingInqDynamicEndpoint=RPCRT4.I_RpcBindingInqDynamicEndpointW
    // I_RpcBindingInqDynamicEndpointW
    //
    // Our thunk dll will use the following:
    //
    // I_RpcBindingInqDynamicEndpoint=I_RpcBindingInqDynamicEndpointW
    // I_RpcBindingInqDynamicEndpointW
    //
    // It is important to strip the "rpcrt4." as this adds an extra
    // loader reference to rpcrt4.dll.
    //
    //
    ExportDebug->ExtForward = NULL;

    Forward = (ULONG_PTR)DllExportDir + ExportDebug->Function - DllRvaOffset;
    if (Forward > (ULONG_PTR)DllExportDir &&
        Forward < (ULONG_PTR)DllExportDir + DllExportDirSize)
       {
        char *pSrc;

        pSrc = (char *) Forward;
        pch = DllBaseName;

        while (*pSrc && *pSrc != '.' && toupper(*pSrc) == toupper(*pch)) {
            pSrc++;
            pch++;
            }

        if (*pSrc == *pch) {
            ExportDebug->ExtForward = pSrc + 1;
            }
        }



    DbgPrintf("%4.1d %8.1x(%4.1d) %8.1x %s(%s)\n",
              ExportDebug->ArgsSize,
              ExportDebug->Ordinal,
              IMPORDINAL(ExportDebug->Ordinal),
              ExportDebug->Function,
              ExportDebug->ExportName,
              ExportDebug->ExtForward ? ExportDebug->ExtForward : ""
              );

   return TRUE;
}




/*
 *  SetInternalForwards
 *
 *
 *
 */
void
SetInternalForwards(void)
{
   PLIST_ENTRY NextExport;
   PEXPORTSDEBUG ExportDebug;


   //
   // check each export in the list for multiple exports to same function.
   // For each set of internal forwards identify which export defines the api,
   // and save this in the IntForward field.
   //

   NextExport= ExportsList.Flink;
   while (NextExport != &ExportsList) {
        ExportDebug = CONTAINING_RECORD(NextExport,
                                       EXPORTSDEBUG,
                                       ExportsDbgEntry
                                       );

        if (ExportDebug->Function &&
           !ExportDebug->ExtForward &&
           !ExportDebug->IntForward)
         {
            PLIST_ENTRY Next;
            PEXPORTSDEBUG pexdbg;
            PEXPORTSDEBUG KnownApi =NULL;
            int ArgSize = ExportDebug->ArgsSize;

            //
            // Walk the rest of the list to find first duplicate function
            //

            Next = NextExport->Flink;
            while (Next != &ExportsList) {
                pexdbg = CONTAINING_RECORD(Next,
                                           EXPORTSDEBUG,
                                           ExportsDbgEntry
                                           );

                if (pexdbg->Function == ExportDebug->Function) {
                    if (pexdbg->ArgsSize >= 0) {
                        ArgSize = pexdbg->ArgsSize;
                        }
                    break;
                    }

                 Next = Next->Flink;

                }


            if (Next != &ExportsList) {

                //
                // We found one dup function. Temporarily link together this set
                // of dup functions using the IntForward field, and determine
                // the first KnownApi.
                //

                if (GetNameFromTypesList(FuncsList, ExportDebug->ExportName)) {
                    KnownApi = ExportDebug;
                    }


                do {

                    pexdbg = CONTAINING_RECORD(Next,
                                               EXPORTSDEBUG,
                                               ExportsDbgEntry
                                               );


                    if (pexdbg->Function == ExportDebug->Function) {
                        pexdbg->IntForward = ExportDebug->IntForward;
                        ExportDebug->IntForward = pexdbg;
                        if (pexdbg->ArgsSize >= 0) {
                            ArgSize = pexdbg->ArgsSize;
                            }

                        if (!KnownApi &&
                            GetNameFromTypesList(FuncsList, pexdbg->ExportName))
                          {
                            KnownApi = pexdbg;
                            }
                        }

                    Next = Next->Flink;

                } while (Next != &ExportsList);



                //
                // If we found multiple entries, walk the temp links, and insert
                // the KnownApi, which is used to define the api. If we didn't
                // find a known api, use ExportDebug, and hope for the best
                // (since its not known).
                //

                if (!KnownApi) {
                    KnownApi = ExportDebug;
                    }

                pexdbg = ExportDebug;

                while (pexdbg) {
                    PEXPORTSDEBUG NextForward;

                    NextForward = pexdbg->IntForward;
                    pexdbg->IntForward = KnownApi;
                    pexdbg->ArgsSize =  ArgSize;

                    DbgPrintf("IntForward: %s to %s\n",
                              pexdbg->ExportName,
                              KnownApi->ExportName
                              );

                    pexdbg = NextForward;

                    }
                }
            }

         NextExport = NextExport->Flink;

         }

}




/*
 *  ExtractExports -
 *
 *  reads the exports debug info from a dll,
 *  and builds the exports list.
 *
 */
BOOL ExtractExports(void)
{
    char *pch, pDst;

    ULONG  NumNames;
    PULONG pNames;
    PUSHORT pNameOrdinals;
    PULONG ImpSymbolMember;
    PCHAR  ImpSymbolName;
    EXPORTSDEBUG ExportDebug;
    PEXPORTSDEBUG pexdbgForward;
    char ExportName[MAX_PATH+1];

    //
    // For each "__imp_" in the implib, gather name, symbol and ordinal
    // and determine its forward status. This will pick up all exports
    // except those which are marked "PRIVATE".
    //

    NumNames   = ImplibNumSymbols;
    ImpSymbolMember = ImplibSymbolMembers;
    ImpSymbolName   = ImplibSymbolNames;

    while (NumNames--) {

         if (!strncmp(szIMPPREFIX, ImpSymbolName, sizeof(szIMPPREFIX) - 1)) {
             memset(&ExportDebug, 0, sizeof(ExportDebug));
             ExportDebug.ApiPlatform = API_ALL;
             ExportDebug.ExportName = ExportName;
             if (!InitExportDebug(&ExportDebug,
                                  ImpSymbolName + sizeof(szIMPPREFIX) - 1,
                                  EndianSwitch(ImpSymbolMember)
                                  ))
                {
                 return FALSE;
                 }

             if (!AddToExportsList(&ExportDebug)) {
                 return FALSE;
                 }

             }

         ImpSymbolMember++;
         ImpSymbolName += strlen(ImpSymbolName) + 1;
         }


    //
    // Search the Export name table for exports which haven't been added yet.
    // These are "PRIVATE" exports with names. We will still be missing
    // exports which are "PRIVATE NONAME", and we won't have symbolic info
    // for the private named exports.
    //

    NumNames = DllExportDir->NumberOfNames;
    pNames   = DllNameTable;
    pNameOrdinals = DllNameOrdinals;

    while (NumNames--) {

       memset(&ExportDebug, 0, sizeof(ExportDebug));

       ExportDebug.Ordinal = *pNameOrdinals + DllExportDir->Base;
       ExportDebug.Ordinal |= 0x80000000;
       ExportDebug.Function = *(DllFunctions + *pNameOrdinals);
       ExportDebug.ExportName = (char *)((ULONG_PTR)DllExportDir + *pNames - DllRvaOffset);
       ExportDebug.ApiPlatform = API_ALL;

       if (!FindInExportsList(ExportDebug.ExportName)) {
           ULONG_PTR Forward;
           char *pch;

           //
           // Check for references forwarded externally, we only need
           // external forwards which are really internal forwards.
           //

           ExportDebug.ExtForward = NULL;

           Forward = (ULONG_PTR)DllExportDir + ExportDebug.Function - DllRvaOffset;
           if (Forward > (ULONG_PTR)DllExportDir &&
               Forward < (ULONG_PTR)DllExportDir + DllExportDirSize)
              {
               char *pSrc;

               pSrc = (char *)Forward;
               pch = DllBaseName;

               while (*pSrc && *pSrc != '.' && *pSrc == *pch) {
                   pSrc++;
                   pch++;
                   }

               if (*pSrc == '.' && *pSrc == *pch) {
                   ExportDebug.ExtForward = pSrc + 1;
                   }
               }


           //
           // Check for decorations embedded in the exportname
           //

           pch = strchr(ExportDebug.ExportName, '@');
           if (pch++ && *pch != '@') {
               ExportDebug.ArgsSize = strtol(pch, NULL, 10);
               }
           else {
               ExportDebug.ArgsSize = -1;
               }

           ExportDebug.PrivateNamed = TRUE;

           DbgPrintf("Private Named Export: %4.1d %8.1x(%4.1d) %8.1x %s(%s)\n",
                     ExportDebug.ArgsSize,
                     ExportDebug.Ordinal,
                     IMPORDINAL(ExportDebug.Ordinal),
                     ExportDebug.Function,
                     ExportDebug.ExportName,
                     ExportDebug.ExtForward ? ExportDebug.ExtForward : ""
                     );

           if (!AddToExportsList(&ExportDebug)) {
               return FALSE;
               }
           }


       // advance to next name\ordinal
       pNames++;
       pNameOrdinals++;

       }





    return TRUE;
}

/*
    ExtractServicesTab-
    
    Used as a replacement to ExtractXpt.  Extracts file list from a services.tab
    file as used in the ntos project.
    
*/

void ExtractServicesTab(char *pch) {
   FILE *fp;
   char pTemp;

   EXPORTSDEBUG ExportDebug;
   char Line[MAX_PATH];
   char ExportName[MAX_PATH];
   char *ApiName;
   char TempBuffer[MAX_PATH];
   char *Prepend;   
   char *FileName;
   size_t len, PrependLen;

   //extract filename and optional prepend name
   FileName = pch;
   while(*pch != ':' && *pch != '\0') 
      pch++;

   pTemp = *pch;
   *pch = '\0';
   
   if (pTemp == ':') {
      pch++;
      Prepend = pch;
      while(*pch != '\0') {
         pch++;
      }
      PrependLen = pch-Prepend;
   }
   else {
      Prepend = pch;
      PrependLen = 0;
   }
   if (PrependLen > MAX_PATH - 1) {
      ExitErrMsg(FALSE, "ExSt: Text to prepend to functions names is too long\n");
   }
   memcpy(ExportName, Prepend, PrependLen);

   DbgPrintf("ExST: %s,%s\n", FileName, Prepend);

   fp = fopen(FileName, "r");
   if (!fp) {
       ExitErrMsg(TRUE, "ExST: fopen(%s) failed\n", FileName);
   }

   if (fseek(fp, 0, SEEK_SET)) {
       ExitErrMsg(TRUE, "ExST: fseek to 0 failed\n");
   }
   if (!fgets(Line, sizeof(Line) - 1, fp)) {
       if (ferror(fp)) {
           ExitErrMsg(FALSE, "ExST: Failed to get Defs from %s\n", FileName);
       } else if (feof(fp)) {
           ExitErrMsg(FALSE, "ExST: Premature EOF %s\n", FileName);
       }
   }

   do {
       // skip leading spaces
       pch = Line;
       while (*pch && isspace(*pch)) {
           pch++;
       }
       if (*pch == '\0')
          continue;

       // Grab the function name
       ApiName = pch;
       while(*pch != ',' && *pch != '\0')
          pch++;

       len = pch - ApiName;
       if (len + PrependLen + 1 > sizeof(ExportName)) {
           ErrMsg("ExST: ExportName Buffer overflow\n");
       }

       //Copy everything over
       memcpy(ExportName + PrependLen, ApiName, len);
       ExportName[PrependLen + len] = '\0';

       if (FindInExportsList(ExportName)) {
           //
           // Name is already in the Exports list.  Ignore the second
           // one.
           //
           DbgPrintf("Warning:  API %s was listed more than once in the services.tab.  Ignoring subsequent copies.\n", ExportName);
           continue;
       }

       memset(&ExportDebug, 0, sizeof(ExportDebug));
       ExportDebug.ExportName = ExportName;
       ExportDebug.MethodNumber = 3;
       ExportDebug.ApiPlatform = API_ALL;
       ExportDebug.Ordinal = 0;
       ExportDebug.ArgsSize = -1;

       if (!AddToExportsList(&ExportDebug)) {
           ExitErrMsg(FALSE, "ExST: Invalid Line %s\n", Line);
       }


   } while (fgets(Line, sizeof(Line) - 1, fp));


   if (!feof(fp) && ferror(fp)) {
       ExitErrMsg(FALSE, "ExST: File Read error: %s\n", FileName);   
   }

   fclose(fp);

   return;


}

/*
 *  ExtractXpt-
 *
 *  reads the exports from a ".xpt" file and builds the exports list.
 *  An ".xpt" file is simply a list of all of the exports.
 *
 */
BOOL ExtractXpt(char *XptListName, char *DllName)
{
    FILE *fp=NULL;
    BOOL bRet = FALSE;
    char *pch;
    char *pSrc=NULL;

    EXPORTSDEBUG ExportDebug;
    ULONG MethodNumber = 3;
    char Line[MAX_PATH];
    char ExportName[MAX_PATH];
    char ApiName[MAX_PATH];
    char Platform[MAX_PATH];
    BYTE ApiPlatform;
    size_t len;


    DbgPrintf("ExXpt: %s\n", XptListName);

    fp = fopen(XptListName, "r");
    if (!fp) {
        ErrMsg("ExXpt: fopen(%s) failed\n", XptListName);
        goto ExSrcExit;
    }

    if (fseek(fp, 0, SEEK_SET)) {
        ErrMsg("ExXpt: fseek failed.\n");
        goto ExSrcExit;
    }
    if (!fgets(Line, sizeof(Line) - 1, fp)) {
        if (ferror(fp)) {
            ErrMsg("ExXpt: Failed to get Defs from %s\n", XptListName);
            goto ExSrcExit;
        } else if (feof(fp)) {
            ErrMsg("ExXpt: Premature EOF %s\n", XptListName);
            goto ExSrcExit;
        }
    }

    do {
        // skip leading spaces
        pSrc = Line;
        while (*pSrc && isspace(*pSrc)) {
            pSrc++;
        }
        if (!*pSrc) {
            // line was blank.  Reset OLE method stuff for start of new
            // interface then get the next line.
            MethodNumber = 3;
            continue;
        }

        if (*pSrc == ';') {
            // line starts with comment.  If the comment indicates the
            // ole method number, grab that, then ignore the rest of the line.
            pSrc++;
            if (*pSrc++ == '*') {
                MethodNumber = atoi(pSrc);
            }
            continue;
        }

        // Grab the exported function name
        len = CopyToken(ApiName, pSrc, sizeof(ApiName)-1);
        if (len >= sizeof(ApiName) -1) {
            ErrMsg("ExXpt: ExportName Buffer overflow\n");
        }
        pSrc += len;

        if (FindInExportsList(ApiName)) {
            //
            // Name is already in the Exports list.  Ignore the second
            // one.
            //
            DbgPrintf("Warning:  API %s was listed more than once in the .xpt.  Ignoring subsequent copies.\n", ApiName);
            continue;
        }

        // skip over any whitespace after the export name
        while (*pSrc && isspace(*pSrc)) {
            pSrc++;
        }
        if (*pSrc == '\0' || *pSrc == ';') {
            // nothing else interresting on the line.  This API is supported
            // on all platoforms.
            ApiPlatform = API_ALL;
        } else {
            // next non-whitespace is not a comment.  This API has an explicit
            // list of supported platforms.
            ApiPlatform = API_NONE;

            do {
                len = CopyToken(Platform, pSrc, sizeof(Platform)-1);
                if (_stricmp(Platform, "win95") == 0) {
                    ApiPlatform |= API_WIN95;
                } else if (_stricmp(Platform, "win98") == 0) {
                    ApiPlatform |= API_WIN98;
                } else if (_stricmp(Platform, "nt4") == 0) {
                    ApiPlatform |= API_NT4;
                } else if (_stricmp(Platform, "nt5") == 0) {
                    ApiPlatform |= API_NT5;
                } else if (_stricmp(Platform, "ntx") == 0) {
                    ApiPlatform |= API_NTx;
                } else if (_stricmp(Platform, "win9x") == 0) {
                    ApiPlatform |= API_WIN9x;
                } else {
                    ExitErrMsg(FALSE, "Error: %s(%d) Unknown platform name '%s'.\n", TemplateFileName, TemplateLine, Platform);
                }
                pSrc += len;
                while (*pSrc && isspace(*pSrc)) {
                    pSrc++;
                }
            } while (*pSrc && *pSrc != ';');

            DbgPrintf("API %s has Platform %x\n", ExportName, ApiPlatform);
        }

        memset(&ExportDebug, 0, sizeof(ExportDebug));
        ExportDebug.ExportName = ExportName;
        ExportDebug.MethodNumber = MethodNumber++;
        ExportDebug.ApiPlatform = ApiPlatform;

        //
        // Look up the export in the implib
        //

        if (ImplibMappedBase) {
            int    Len;
            ULONG  SymbolMember=0;
            ULONG  ImpNumSymbols   = ImplibNumSymbols;
            PULONG ImpSymbolMember = ImplibSymbolMembers;
            PCHAR  ImpSymbolName   = ImplibSymbolNames;

            while (ImpNumSymbols--) {

                Len = strlen(ApiName);
                pch = ImpSymbolName + 1 + Len;
                if (!strncmp(ApiName, ImpSymbolName + 1, Len) &&
                    (!*pch  || *pch == '@')) {
                    SymbolMember = EndianSwitch(ImpSymbolMember);
                    break;
                }

                ImpSymbolMember++;
                ImpSymbolName += strlen(ImpSymbolName) + 1;
            }

            if (SymbolMember) {
                if (!InitExportDebug(&ExportDebug, ImpSymbolName, SymbolMember)) {
                    goto ExSrcExit;
                }
            } else {

                //
                // The export was not found in the implib, and for
                // flexibility we don't required it to be in implib.
                // fill up what we know.
                //

                ExportDebug.Ordinal = 0;
                ExportDebug.ArgsSize = -1;
                strcpy(ExportName, ApiName);
            }

        } else {

            // most info is unknown!

            ExportDebug.Ordinal = 0;
            ExportDebug.ArgsSize = -1;
            strcpy(ExportName, ApiName);
        }

        if (!AddToExportsList(&ExportDebug)) {
            goto ExSrcExit;
        }


    } while (fgets(Line, sizeof(Line) - 1, fp));


    if (!feof(fp) && ferror(fp)) {
        ErrMsg("ExXpt: File Read error: %s\n", XptListName);
        goto ExSrcExit;
    }

    bRet = TRUE;

ExSrcExit:
    if (!bRet) {
        ErrMsg("ExXpt: Invalid Line <%s>\n%s\n", pSrc, Line);
    }

    if (fp) {
        fclose(fp);
    }

    return bRet;
}



BOOL AddToExportsList(PEXPORTSDEBUG pExportsDebug)
{
   PEXPORTSDEBUG pexdbg;
   int Len;
   int SizeExportName;

   SizeExportName = strlen(pExportsDebug->ExportName) + 1;

   Len = sizeof(EXPORTSDEBUG) + SizeExportName + 1;

   pexdbg = GenHeapAlloc(Len);
   if (!pexdbg) {
       ExitErrMsg(TRUE, "GenHeapAlloc(EXPORTSDEBUG)");
   }
   memset(pexdbg, 0, Len);
   *pexdbg = *pExportsDebug;

   pexdbg->ExportName = pexdbg->Buffer;
   strcpy(pexdbg->ExportName, pExportsDebug->ExportName);

   InitializeListHead(&pexdbg->ArgsListHead);

   InsertTailList(&ExportsList, &pexdbg->ExportsDbgEntry);

   return TRUE;
}


/*
 *  ExtractPpm.  The on-disk .PPM file is opened as read-only, but
 *               the pages are copy-on-write to the pagefile, so genthnk
 *               can make changes to the in-memory version which go away
 *               when it exits.
 *
 */
BOOL ExtractPpm(char *PpmName)
{
   HANDLE hFile;
   HANDLE hMapFile = NULL;
   PVOID  pvBaseAddress;
   ULONG  Version;
   PVOID  MappedBase;
   ULONG  BytesRead;
   BOOL   bSuccess;
   NTSTATUS Status;
   PCVMHEAPHEADER pHeader;


   DbgPrintf("PpmName: %s\n", PpmName);

   hFile = CreateFile(PpmName,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      0,
                      NULL
                      );

   if (hFile == INVALID_HANDLE_VALUE) {
       hFile = NULL;
       ErrMsg("ExtractPpm CreateFile(%s) gle %d\n", PpmName, GetLastError());
       return FALSE;
       }


   bSuccess = ReadFile(hFile,
                       &Version,
                       sizeof(ULONG),
                       &BytesRead,
                       NULL
                       );
   if (!bSuccess || BytesRead != sizeof(ULONG)) {
       ErrMsg("ExtractPpm ReadFile(%s) gle %d\n", PpmName, GetLastError());
       return FALSE;
       }

   if (Version != VM_TOOL_VERSION) {
      ErrMsg("ExtractPpm: .PPM version %x does not match genthnk version %x\n",
             Version, VM_TOOL_VERSION);
      return FALSE;
      }

#if _WIN64
   // Read and ignore the 4-byte padding between the Version and the Base
   bSuccess = ReadFile(hFile,
                       &Version,
                       sizeof(ULONG),
                       &BytesRead,
                       NULL
                       );
   if (!bSuccess || BytesRead != sizeof(ULONG)) {
       ErrMsg("ExtractPpm ReadFile(%s) gle %d\n", PpmName, GetLastError());
       return FALSE;
       }
#endif

   bSuccess = ReadFile(hFile,
                       &pvBaseAddress,
               sizeof(ULONG_PTR),
                       &BytesRead,
                       NULL
                       );

   if (!bSuccess || BytesRead != sizeof(ULONG_PTR)) {
       ErrMsg("ExtractPpm ReadFile(%s) gle %d\n", PpmName, GetLastError());
       return FALSE;
       }


   hMapFile = CreateFileMapping(hFile, NULL, PAGE_WRITECOPY, 0, 0,NULL);
   if (!hMapFile) {
       ErrMsg("ExtractPpm CreateFileMapping(%s) gle %d\n", PpmName, GetLastError());
       return FALSE;
       }

   MappedBase = MapViewOfFileEx(hMapFile, FILE_MAP_COPY, 0, 0, 0, pvBaseAddress);
   if (!MappedBase || MappedBase != pvBaseAddress) {
       ErrMsg("ExtractPpm MapViewOfFile(%s) gle %d\n", PpmName, GetLastError());
       return FALSE;
       }

   pHeader = (PCVMHEAPHEADER)pvBaseAddress;

   FuncsList = &pHeader->FuncsList;
   StructsList = &pHeader->StructsList;
   TypeDefsList = &pHeader->TypeDefsList;
   NIL = &pHeader->NIL;

   // This must be done after NIL is initialized.
   RBInitTree(&FakeFuncsList);

   return TRUE;

}

#pragma warning(push)
#pragma warning(disable:4702)
void
HandlePreprocessorDirective(
    char *p
    )
{
    ExitErrMsg(FALSE, "Preprocessor directives not allowed: '%s'\n", p);
}
#pragma warning(pop)

char *
LexMacroArgs(
    char *pch
    )
{
    BOOL fLexDone;
    char *pchNew;

    ResetLexer();
    pchNew = LexOneLine(pch, FALSE, &fLexDone);
    CurrentTokenIndex = 0;

    if (fLexDone) {
        return pchNew;
    } else {
        return pch;
    }
}

BOOLEAN
ExpandMacro(
    char *MacroName,
    PCGENSTATE pCGenState,
    char **ppIn,
    char *OutBuffer,
    SIZE_T MaxLen,
    SIZE_T *BytesReturned
    )
/*++

Routine Description:

    Expands an @MacroName(arg1, arg2, ...).

Arguments:

    MacroName   - name of macro to expand
    pCGenState  - current code-gen state
    ppIn        - pointer to pointer to character following '@MacroName'

Return Value:

    TRUE if macro expanded OK, FALSE if not.  *ppIn will be updated to
    point to the character following the end of the macro.

--*/
{
    PTEMPLES pMacroTemple;
    PLIST_ENTRY NextMacro;
    char *pIn;
    char *pArg;
    PMACROARGSLIST NewMacroArgsList;
    int ArgCount;
    int ParenDepth;

    NextMacro = MacroList.Flink;
    while (NextMacro != &MacroList) {
        pMacroTemple = CONTAINING_RECORD(NextMacro, TEMPLES, TempleEntry);

        if (strcmp(MacroName, pMacroTemple->Name) == 0) {
            //
            // Found a macro by that name
            //
            break;
        }
        NextMacro = NextMacro->Flink;
    }

    if (NextMacro == &MacroList) {
        //
        // No macro by that name.
        //
        return FALSE;
    }

    pIn = *ppIn;

    ArgCount = pMacroTemple->IndLevel;
    NewMacroArgsList = GenHeapAlloc(sizeof(MACROARGSLIST) + sizeof(LPSTR) * ArgCount);
    if (!NewMacroArgsList) {
        ExitErrMsg(TRUE, "ExpandMacro out of memory");
    }
    NewMacroArgsList->NumArgs = ArgCount;

    if (!ArgCount) {
        //
        // This macro doesn't expect arguments
        //
    } else {
        //
        //
        // This macro expects arguments.  Parse the arguments.
        //

        pIn = ParseMacroArgs(pIn, 0, &NewMacroArgsList);

        if (NewMacroArgsList->NumArgs != ArgCount) {
            ExitErrMsg(FALSE, "Macro %s expects %d arguments\n", MacroName, ArgCount);
        }

    }

    // swap out the currently active macro (if any) and swap in the new macro
    MacroStack[MacroStackTop++] = pCGenState->pMacroArgsList;
    pCGenState->pMacroArgsList = NewMacroArgsList;

    // generate code for the Begin=/End= section of the macro
    if (!pMacroTemple->CodeBurst[BeginCBI]) {
        ExitErrMsg(FALSE, "%s(%d) Macro %s has no Begin= section: %s\n", TemplateFileName, TemplateLine, MacroName, *ppIn);
    }
    CGenerateEx(pMacroTemple->CodeBurst[BeginCBI], pCGenState, OutBuffer, MaxLen, BytesReturned);
   
    // swap the previously active macro back in
    pCGenState->pMacroArgsList = MacroStack[--MacroStackTop];
                                                            
    FreeMacroArgsList(NewMacroArgsList);

    *ppIn = pIn;

    return TRUE;
}


void
WriteBoolean (
    char *pSrc,
    BOOL Value  
    )
{
    if (pSrc){
        if ( Value ){
            *pSrc++ = '1';
        }
        else{
            *pSrc++ = '0';
        }
        *pSrc = '\0';
    }   
}

char *
ExtractBoolean (
    char *expression,
    BOOLEAN *result
    )
{   
    char thischar =*expression;

    *result = FALSE;


    if ( thischar != '\0') {
        char nextchar =*(expression+1);
        if ( nextchar != '\0' && nextchar != ')' && nextchar != ',' ) {
            ExitErrMsg(FALSE,"Invalid Expression");
        }
    }

    if (thischar == '0') {
        *result = FALSE;    
        return expression+1;
    }
    else if (thischar == '1') {
        *result = TRUE;
        return expression+1;
    }
    else{       
        ExitErrMsg(FALSE,"Invalid Expression");
    }
}

char *
ExtractBoolean1(
    char *pSrc, 
    PCGENSTATE pCGenState,
    BOOLEAN *result
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    BOOLEAN TempResult = FALSE; 
    char *pExpression;
    char *pch, *pch2;
    char Buffer[MAX_PATH];
    SIZE_T BytesReturned;

    *result = FALSE;

    pch = SkipSubExpression(pSrc, &pExpression);
    if (pSrc == pch) {
        return pSrc;
        }
    pSrc = pch;

    if (pExpression) {
        CGenerateEx(pExpression, pCGenState, Buffer, MAX_PATH, &BytesReturned);
        ExtractBoolean ( Buffer, result );      

        GenHeapFree(pExpression);
    }

    return pSrc;
}

char *
ExtractBoolean2(
    char *pSrc, 
    PCGENSTATE pCGenState,
    BOOLEAN *result1,
    BOOLEAN *result2
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    char *pExpression;
    char *pch, *pch2;
    char Buffer[MAX_PATH];
    SIZE_T BytesReturned;   

    *result1 = FALSE;
    *result2 = FALSE;

    pch = SkipSubExpression(pSrc, &pExpression);
    if (pSrc == pch) {
        return pSrc;
        }
    pSrc = pch;

    if (pExpression) {
        CGenerateEx(pExpression, pCGenState, Buffer, MAX_PATH, &BytesReturned);
        pch = Buffer;
        pch = ExtractBoolean ( Buffer, result1 );       
        if ( *pch == ',') {
            pch++;
        }
        else {
            ExitErrMsg(FALSE,"Invalid Expression");
        }
        ExtractBoolean ( pch, result2 );
                
        GenHeapFree(pExpression);        
    }
    return pSrc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\tools\genlib\genmisc.c ===
// Copyright (c) 1994-1999 Microsoft Corporation

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include "gen.h"

BOOLEAN bDebug = FALSE;
BOOLEAN bExitClean= TRUE;

char szNULL[]="";
char szVARGS[]="...";
char szCONST[] = "const";
char szVOLATILE[] = "volatile";
char szREGISTER[] = "register";
char szEXTERN[] = "extern";
char sz_CDECL[] = "__cdecl";
char szCDECL[] = "_cdecl";
char szSTDCALL[] = "__stdcall";
char sz__FASTCALL[] = "__fastcall";
char szUNALIGNED[] = "__unaligned";
char szTYPEDEF[] = "typedef";
char szCHAR[] = "char";
char szINT[] = "int";
char szLONG[] = "long";
char szSHORT[] = "short";
char szDOUBLE[] = "double";
char szENUM[] = "enum";
char szFLOAT[] = "float";
char szSTRUCT[] = "struct";
char szUNION[] = "union";
char szVOID[] = "void";
char szINT64[] = "_int64";
char sz_INT64[] = "__int64";
char sz__PTR64[] = "__ptr64";
char szFUNC[] = "()";
char szSIGNED[] = "signed";
char szUNSIGNED[] = "unsigned";
char szSTATIC[] = "static";
char szIN[] = "__in_wow64";
char szOUT[] = "__out_wow64";
char szINOUT[] = "__in_wow64 __out_wow64";
char szGUID[] = "GUID";
char sz__W64[] = "__w64";


char szPragma[] = "#pragma";
char szPack[] = "pack";
char szPush[] = "push";
char szPop[] = "pop";

char szFUNCTIONS[]  = "Functions";
char szSTRUCTURES[] = "Structures";
char szTYPEDEFS[]   = "TypeDefs";
char szUNSIGNEDCHAR[] = "unsigned char";
char szUNSIGNEDSHORT[] = "unsigned short";
char szUNSIGNEDLONG[] = "unsigned long";


DEFBASICTYPES DefaultBasicTypes[] = {
      { "unsigned int" },
      { "int" },
      { "short int" },
      { "unsigned short int" },
      { "long int" },
      { "unsigned long int" },
      { "char" },
      { "unsigned char" },
      { szINT64 },
      { sz_INT64 },
      { szGUID    },
      { szDOUBLE  },
      { szFLOAT   },
      { szENUM    },
      { szSTRUCT  },
      { szUNION   },
      { szVOID    },
      { szFUNC    }
     };

CHAR szVTBL[] = "VTBL";

#define NUMDEFBASICTYPES sizeof(DefaultBasicTypes)/sizeof(DEFBASICTYPES);

// List mapping TokenTypes to human-readable strings.  TK_NONE, TK_IDENTIFIER,
// TK_NUMBER, and TK_STRING must be special-cased.
char *TokenString[] = {
    "",             // TK_NONE
    "",             // TK_IDENTIFIER
    "",             // TK_NUMBER
    "+",            // TK_PLUS
    "-",            // TK_MINUS
    "*",            // TK_STAR
    "/",            // TK_DIVIDE
    "[",            // TK_LSQUARE
    "]",            // TK_RSQUARE
    "{",            // TK_LBRACE
    "}",            // TK_RBRACE
    "(",            // TK_LPAREN
    ")",            // TK_RPAREN
    "...",          // TK_VARGS
    "const",        // TK_CONST
    "volatile",     // TK_VOLATILE
    "register",     // TK_REGISTER
    "extern",       // TK_EXTERN
    "__cdecl",      // TK_CDECL
    "__stdcall",    // TK_STDCALL
    "typedef",      // TK_TYPEDEF
    "static",       // TK_STATIC
    ",",            // TK_COMMA
    ";",            // TK_SEMI
    "struct",       // TK_STRUCT
    "union",        // TK_UNION
    "enum",         // TK_ENUM
    "__inline",     // TK_INLINE
    ":",            // TK_COLON
    "=",            // TK_ASSIGN
    ".",            // TK_DOT
    "<<",           // TK_LSHIFT
    ">>",           // TK_RSHIFT
    "<",            // TK_LESS
    ">",            // TK_GREATER
    "__unaligned",  // TK_UNALIGNED
    "__declspec",   // TK_DECLSPEC
    "__restrict",   // TK_RESTRICT  (MIPS-only keyword - a pointer modifier)
    "__fastcall",   // TK_FASTCALL
    "__in_wow64",               // TK_IN
    "__out_wow64",              // TK_OUT
    "__in_wow64 __out_wow64",   // TK_INOUT
    "&",            // TK_BITWISE_AND
    "|",            // TK_BITWISE_OR
    "&&",           // TK_LOGICAL_AND
    "||",           // TK_LOGICAL_OR
    "%",            // TK_MOD
    "^",            // TK_XOR
    "!",            // TK_NOT
    "~",            // TK_TILDE
    "",             // TK_STRING
    "sizeof",       // TK_SIZEOF
    "template",     // TK_TEMPLATE
    "__w64",        // TK___W64
    ""              // TK_EOS
};


// List of keyword names.  When an identifier is recognized, it is
// compared against this list, and if it matches, TK_IDENTIFIER is
// replaced by the appropriate keyword token id.
//
// NOTE: This must remain in sorted order.
TOKENMATCH KeywordList[] = {
    { TK_CDECL,     "__cdecl"     },
    { TK_DECLSPEC,  "__declspec"  },
    { TK_FASTCALL,  "__fastcall"  },
    { TK_INLINE,    "__forceinline" },
    { TK_IN,        "__in_wow64"  },
    { TK_INLINE,    "__inline"    },
    { TK_OUT,       "__out_wow64" },
    { TK_RESTRICT,  "__restrict"  },
    { TK_STDCALL,   "__stdcall"   },
    { TK_UNALIGNED, "__unaligned" },
    { TK___W64,     "__w64"       },
    { TK_CDECL,     "_cdecl"      },
    { TK_FASTCALL,  "_fastcall"   },
    { TK_INLINE,    "_inline"     },
    { TK_STRUCT,    "class"       },
    { TK_CONST,     "const"       },
    { TK_ENUM,      "enum"        },
    { TK_EXTERN,    "extern"      },
    { TK_INLINE,    "inline"      },
    { TK_REGISTER,  "register"    },
    { TK_SIZEOF,    "sizeof"      },
    { TK_STATIC,    "static"      },
    { TK_STRUCT,    "struct"      },
    { TK_TEMPLATE,  "template"    },
    { TK_TYPEDEF,   "typedef"     },
    { TK_UNION,     "union"       },
    { TK_VOLATILE,  "volatile"    },
    { TK_NONE,      NULL          }
};


LIST_ENTRY OpenFileHead= {&OpenFileHead, &OpenFileHead};

typedef struct _OpenFileEntry {
    LIST_ENTRY FileEntry;
    HANDLE hFile;
    FILE *fp;
    char FileName[MAX_PATH+1];
} OPENFILEENTRY, *POPENFILEENTRY;

TOKEN Tokens[MAX_TOKENS_IN_STATEMENT];
int CurrentTokenIndex;

void
CheckForKeyword(
    PTOKEN Token
    );


BOOL
ConsoleControlHandler(
    DWORD dwCtrlType
    )
/*++

Routine Description:

    Called if user hits Ctrl+C or Ctrl+Break.  Closes all open files,
    allowing for a graceful exit.

Arguments:

    dwCtrlType -- ????

Return Value:

    ????

--*/
{
    CloseOpenFileList(TRUE);
    return FALSE;
}


BOOL
AddOpenFile(
    char   *FileName,
    FILE   *fp,
    HANDLE hFile
    )
/*++

Routine Description:

    Records that a file has been opened.  If an error occurs within
    the app, files in this list will be closed.

Arguments:

    FileName    -- name of open file
    fp          -- OPTIONAL file pointer
    hFile       -- OPTIONAL file handle

Return Value:

    TRUE if file added to the list, FALSE if failure (probably out of memory)

--*/
{
    POPENFILEENTRY pofe;

    pofe = GenHeapAlloc(sizeof(OPENFILEENTRY));
    if (!pofe) {
        ErrMsg("AddOpenWriteFile: insuf memory: %s\n", strerror(errno));
        return FALSE;
    }
    pofe->fp = fp;
    pofe->hFile = hFile;
    strcpy(pofe->FileName, FileName);

    InsertHeadList(&OpenFileHead, &pofe->FileEntry);
    return TRUE;
}


void
DelOpenFile(
    FILE   *fp,
    HANDLE hFile
    )
/*++

Routine Description:

    Deletes a file from the open file list.  Note that the file is not
    closed, the caller must do that.

Arguments:

    fp          -- OPTIONAL file pointer
    hFile       -- OPTIONAL file handle

Return Value:

    None.

--*/
{
    PLIST_ENTRY Next;
    POPENFILEENTRY pofe;

    Next = OpenFileHead.Flink;
    while (Next != &OpenFileHead) {
        pofe = CONTAINING_RECORD(Next, OPENFILEENTRY, FileEntry);
        if ((fp && pofe->fp == fp) || (hFile && pofe->hFile == hFile)) {
            RemoveEntryList(&pofe->FileEntry);
            GenHeapFree(pofe);
            return;
        }

        Next= Next->Flink;
    }
}



void
CloseOpenFileList(
    BOOL DeleteFiles
    )
/*++

Routine Description:

    Closes all open files and optionally deletes the files themselves.

Arguments:

    DeleteFiles -- TRUE if open files are to be deleted.

Return Value:

    None.

--*/
{
    PLIST_ENTRY Next;
    POPENFILEENTRY pofe;

    Next = OpenFileHead.Flink;
    while (Next != &OpenFileHead) {
        pofe = CONTAINING_RECORD(Next, OPENFILEENTRY, FileEntry);
        if (pofe->fp) {
            fclose(pofe->fp);
        } else if (pofe->hFile) {
            CloseHandle(pofe->hFile);
        }

        if (DeleteFiles && bExitClean) {
            DeleteFile(pofe->FileName);
        }

        // cheat, skip mem cleanup since we know we are exiting
        // GenHeapFree(pofe);

        Next= Next->Flink;
    }
}





void
DumpKnownTypes(
     PKNOWNTYPES pKnownTypes,
     FILE *fp
     )
/*++

Routine Description:

    Outputs the contents of a PKNOWNTYPES in a semi-readable format.

Arguments:

    pKnownTypes -- type to output
    fp          -- destination of the output

Return Value:

    None.

--*/
{
     fprintf(fp,"%2.1x|%2.1x|%2.1x|%2.1x|%s|%s|%s|%s|%s|\n",
                pKnownTypes->Flags,
                pKnownTypes->IndLevel,
                pKnownTypes->RetIndLevel,
                pKnownTypes->Size,
                pKnownTypes->BasicType,
                pKnownTypes->BaseName ? pKnownTypes->BaseName : szNULL,
                pKnownTypes->FuncRet ? pKnownTypes->FuncRet : szNULL,
                pKnownTypes->FuncMod ? pKnownTypes->FuncMod : szNULL,
                pKnownTypes->TypeName
                );

}


void
DumpTypesInfo(
    PTYPESINFO pTypesInfo,
    FILE *fp
    )
/*++

Routine Description:

    Outputs the contents of a PTYPESINFO in a semi-readable format.

Arguments:

    pTypesInfo  -- type to output
    fp          -- destination of the output

Return Value:

    None.

--*/
{
     fprintf(fp,"%2.1x|%2.1x|%2.1x|%2.1x|%s|%s|%s|%s|%s|\n",
                pTypesInfo->Flags,
                pTypesInfo->IndLevel,
                pTypesInfo->RetIndLevel,
                pTypesInfo->Size,
                pTypesInfo->BasicType,
                pTypesInfo->BaseName ? pTypesInfo->BaseName : szNULL,
                pTypesInfo->FuncRet  ? pTypesInfo->FuncRet : szNULL,
                pTypesInfo->FuncMod  ? pTypesInfo->FuncMod : szNULL,
                pTypesInfo->TypeName
                );
}




void
FreeTypesList(
    PRBTREE ptree
    )
/*++

Routine Description:

    Frees an entire red-black tree.

Arguments:

    ptree   -- tree to free.

Return Value:

    None.

--*/
{
    PKNOWNTYPES pNext, pNode;

    pNode = ptree->pLastNodeInserted;
    while (pNode) {
        pNext = pNode->Next;
        GenHeapFree(pNode);
        pNode = pNext;
    }
    RBInitTree(ptree);
}




PKNOWNTYPES
GetBasicType(
    char *sTypeName,
    PRBTREE TypeDefsList,
    PRBTREE StructsList
    )
/*++

Routine Description:

    Determines the basic type of a typedef.

Arguments:

    sTypeName       -- type name to look up
    TypeDefsList    -- list of typedefs
    StructsList     -- list of structs

Return Value:

    Ptr to the KNOWNTYPES for the basic type, or NULL if no basic type
    found.

--*/
{
    PKNOWNTYPES pkt, pktLast;

    //
    // go down the typedef list
    //
    pktLast = NULL;
    for (pkt = GetNameFromTypesList(TypeDefsList, sTypeName);
                                      (pkt != NULL) && (pkt != pktLast); ) {
        pktLast = pkt;
        pkt = GetNameFromTypesList(TypeDefsList, pktLast->BaseName);
    }

    //
    // see what the the final typedef stands for
    //
    if (pktLast == NULL) {
        pkt = GetNameFromTypesList(StructsList, sTypeName);
    } else {
        if (strcmp(pktLast->BasicType, szSTRUCT)) {
            pkt = pktLast;
        } else {
                                // if base type a struct get its definition
            pkt = GetNameFromTypesList(StructsList, pktLast->BaseName);
        }
    }

    return pkt;
}


PDEFBASICTYPES
GetDefBasicType(
    char *pBasicType
    )
/*++

Routine Description:

    Determines if a typename is a basic type, and if so, which one.

Arguments:

    pBasicType      -- typename to examine

Return Value:

    Ptr to the basic type info if pBasicType is a basic type.
    NULL if the type is not a default basic type (int, sort, struct, etc.)

--*/
{
    PDEFBASICTYPES pDefBasicTypes = DefaultBasicTypes;
    int i = NUMDEFBASICTYPES;

    do {
        if (!strcmp(pDefBasicTypes->BasicType, pBasicType)) {
            return pDefBasicTypes;
        }
        pDefBasicTypes++;
    } while (--i);

    return NULL;
}


PKNOWNTYPES
GetNameFromTypesList(
     PRBTREE pKnownTypes,
     char *pTypeName
     )
/*++

Routine Description:

    Searches a type list for a type name.

Arguments:

    pKnownType  -- type list to search
    pTypeName   -- type name to look for

Return Value:

    Ptr to the type info if pTypeName is in the list.
    NULL if the type was not found.

--*/
{
   //
   // Find the entry in the Red/Black tree
   //
   return RBFind(pKnownTypes, pTypeName);
}



PVOID
TypesListMalloc(
    ULONG Len
    )
/*++

Routine Description:

    Default memory allocator used to allocate a new KNOWNTYPES.
    It can be overridden by setting fpTypesListMalloc.

Arguments:

    Len     -- number of bytes of memory to allocate.

Return Value:

    Ptr to the memory or NULL of out-of-memory.

--*/
{
    return GenHeapAlloc(Len);
}

PVOID (*fpTypesListMalloc)(ULONG Len) = TypesListMalloc;

VOID
ReplaceInfoInKnownTypes(
    PKNOWNTYPES pKnownTypes,
    PTYPESINFO pTypesInfo
    )
{

    BYTE *pNames;
    int Len;
    int SizeBasicType, SizeBaseName, SizeMembers, SizeFuncMod, SizeFuncRet;
    int SizeTypeName, SizeBaseType, SizeMethods, SizeIMethods, SizeFileName;

    SizeBasicType = strlen(pTypesInfo->BasicType) + 1;
    SizeBaseName = strlen(pTypesInfo->BaseName) + 1;
    SizeFuncRet = strlen(pTypesInfo->FuncRet) + 1;
    SizeFuncMod = strlen(pTypesInfo->FuncMod) + 1;
    SizeTypeName = strlen(pTypesInfo->TypeName) + 1;
    SizeMembers = pTypesInfo->dwMemberSize;
    SizeBaseType = strlen(pTypesInfo->BaseType) + 1;
    SizeFileName = strlen(pTypesInfo->FileName) + 1;
    SizeMethods = SizeOfMultiSz(pTypesInfo->Methods);
    SizeIMethods = SizeOfMultiSz(pTypesInfo->IMethods);

    // The extra sizeof(DWORD) allows the Members[] array to be DWORD-aligned
    Len = SizeBasicType + SizeBaseName + SizeMembers + SizeFuncMod +
        SizeFuncRet + SizeTypeName + SizeBaseType + SizeFileName + SizeMethods + SizeIMethods + sizeof(DWORD_PTR);

    pNames = (*fpTypesListMalloc)(Len);
    if (!pNames) {
        fprintf(stderr, "%s pKnownTypes failed: ", ErrMsgPrefix, strerror(errno));
        DumpTypesInfo(pTypesInfo, stderr);
        ExitErrMsg(FALSE, "Out of memory!\n");
    }

    memset(pNames, 0, Len);

    pKnownTypes->Flags        = pTypesInfo->Flags;
    pKnownTypes->IndLevel     = pTypesInfo->IndLevel;
    pKnownTypes->RetIndLevel  = pTypesInfo->RetIndLevel;
    pKnownTypes->Size         = pTypesInfo->Size;
    pKnownTypes->iPackSize    = pTypesInfo->iPackSize;
    pKnownTypes->gGuid        = pTypesInfo->gGuid;
    pKnownTypes->dwVTBLSize   = pTypesInfo->dwVTBLSize;
    pKnownTypes->dwVTBLOffset = pTypesInfo->dwVTBLOffset;
    pKnownTypes->TypeId       = pTypesInfo->TypeId;
    pKnownTypes->LineNumber   = pTypesInfo->LineNumber;
    pKnownTypes->dwCurrentPacking = pTypesInfo->dwCurrentPacking;
    pKnownTypes->dwScopeLevel = pTypesInfo->dwScopeLevel;
    pKnownTypes->dwArrayElements = pTypesInfo->dwArrayElements;
    pKnownTypes->dwBaseSize   = pTypesInfo->dwBaseSize;
    pKnownTypes->pTypedefBase = pTypesInfo->pTypedefBase;
    Len = 0;

    pKnownTypes->BasicType = pNames + Len;
    strcpy(pKnownTypes->BasicType, pTypesInfo->BasicType);
    Len += SizeBasicType;

    pKnownTypes->BaseName = pNames + Len;
    strcpy(pKnownTypes->BaseName, pTypesInfo->BaseName);
    Len += SizeBaseName;

    pKnownTypes->FuncRet = pNames + Len;
    strcpy(pKnownTypes->FuncRet, pTypesInfo->FuncRet);
    Len += SizeFuncRet;

    pKnownTypes->FuncMod = pNames + Len;
    strcpy(pKnownTypes->FuncMod, pTypesInfo->FuncMod);
    Len += SizeFuncMod;

    if (SizeFileName > 0) {
        pKnownTypes->FileName = pNames + Len;
        strcpy(pKnownTypes->FileName, pTypesInfo->FileName);
        Len += SizeFileName;
    }
    else pKnownTypes->FileName = NULL;

    // Ensure that Members[] is DWORD-aligned, so the structures within the
    // Members[] are aligned.
    Len = (Len+sizeof(DWORD_PTR)) & ~(sizeof(DWORD_PTR)-1);

    if (SizeMembers == 0) {
        pKnownTypes->Members = NULL;
        pKnownTypes->pmeminfo = NULL;
        pKnownTypes->pfuncinfo = NULL;
    }
    else {
        pKnownTypes->Members = pNames + Len;
        memcpy(pKnownTypes->Members, pTypesInfo->Members, SizeMembers);

        //
        // Fix up pointers within the Members data, so they point into the
        // pKnownTypes data instead of the pTypesInfo.
        //
        pKnownTypes->pfuncinfo = RelocateTypesInfo(pKnownTypes->Members,
            pTypesInfo);

        if (pTypesInfo->TypeKind == TypeKindStruct) {
            pKnownTypes->pmeminfo = (PMEMBERINFO)pKnownTypes->Members;
        }
        Len += SizeMembers;
    }

    if (SizeMethods == 0) pKnownTypes->Methods = NULL;
    else {
        pKnownTypes->Methods = pNames + Len;
        memcpy(pKnownTypes->Methods, pTypesInfo->Methods, SizeMethods);
        Len += SizeMethods;
    }

    if (SizeIMethods == 0) pKnownTypes->IMethods = NULL;
    else {
        pKnownTypes->IMethods = pNames + Len;
        memcpy(pKnownTypes->IMethods, pTypesInfo->IMethods, SizeIMethods);
        Len += SizeIMethods;
    }

    pKnownTypes->BaseType = pNames + Len;
    strcpy(pKnownTypes->BaseType, pTypesInfo->BaseType);
    Len += SizeBaseType;

    pKnownTypes->TypeName = pNames + Len;
    strcpy(pKnownTypes->TypeName, pTypesInfo->TypeName);
    Len += SizeTypeName;

}

PKNOWNTYPES
AddToTypesList(
   PRBTREE pTree,
   PTYPESINFO pTypesInfo
   )
/*++

Routine Description:

    Adds a PTYPESINFO to the list of known types.

    This function makes the following ASSUMPTIONS:
       1. The MEMBERINFO buffer passed in the TYPESINFO structure is all
          allocated from one contiguous block of memory, ie completely
          contained within the Members[] buffer.

       2. The MEMBERINFO buffer built in the KNOWNTYPESINFO structure is
          also allocated from one contiguous block of memory.

       The code requires this since it will block copy the entire data
       structure and then "fixup" the pointers within the MEMBERINFO elements.

Arguments:

    pTree       -- types list to add the new type to
    pTypesInfo  -- the type to add.

Return Value:

    Ptr to the new PKNOWNTYPES, or NULL if out-of-memory.

--*/
{
    PKNOWNTYPES pKnownTypes;

    pKnownTypes = (*fpTypesListMalloc)(sizeof(KNOWNTYPES));
    if (!pKnownTypes) {
        fprintf(stderr, "%s pKnownTypes failed: ", ErrMsgPrefix, strerror(errno));
        DumpTypesInfo(pTypesInfo, stderr);
        return pKnownTypes;
    }

    memset(pKnownTypes, 0, sizeof(KNOWNTYPES));

    ReplaceInfoInKnownTypes(pKnownTypes, pTypesInfo);

    RBInsert(pTree, pKnownTypes);

    if (bDebug) {
        DumpKnownTypes(pKnownTypes, stdout);
    }

    return pKnownTypes;
}


void
ReplaceInTypesList(
    PKNOWNTYPES pKnownTypes,
    PTYPESINFO pTypesInfo
    )
/*++

Routine Description:

    Replaces an existing PKNOWNTYPES with a new PTYPESINFO.  The old data
    is overwritten with new data, so pointers to the old PKNOWNTYPES will
    still be valid.

    This function makes the following ASSUMPTIONS:
       1. The MEMBERINFO buffer passed in the TYPESINFO structure is all
          allocated from one contiguous block of memory, ie completely
          contained within the Members[] buffer.

       2. The MEMBERINFO buffer built in the KNOWNTYPESINFO structure is
          also allocated from one contiguous block of memory.

       The code requires this since it will block copy the entire data
       structure and then "fixup" the pointers within the MEMBERINFO elements.

Arguments:

    pKnownTypes -- type to overwrite
    pTypesInfo  -- the type to add.

Return Value:

    None.

--*/
{

    ReplaceInfoInKnownTypes(pKnownTypes, pTypesInfo);

    if (bDebug) {
        DumpKnownTypes(pKnownTypes, stdout);
    }
}


PFUNCINFO
RelocateTypesInfo(
    char *dest,
    PTYPESINFO src
    )
/*++

Routine Description:

    Adjusts pointers within the Members[] array which point back into
    the Members[].  After a TYPESINFO is copied, the destination TYPESINFO
    or KNOWNTYPES Members[] array must be relocated.

Arguments:

    dest        -- start of the destination Members[] data
    src         -- the source TYPESINFO from which the Members[] was copied

Return Value:

    Address for first pfuncinfo within dest, NULL if dest does not contain
    funcinfos.  Destination Members[] data is relocated no matter what.

--*/
{
    INT_PTR iPtrFix;
    PMEMBERINFO pmeminfo;
    PFUNCINFO pfuncinfo;
    PFUNCINFO pfuncinfoRet = NULL;

    iPtrFix = (INT_PTR)(dest - src->Members);
    if (src->TypeKind == TypeKindStruct) {

        pmeminfo = (PMEMBERINFO)dest;

        while (pmeminfo != NULL) {
            if (pmeminfo->pmeminfoNext != NULL) {
                pmeminfo->pmeminfoNext = (PMEMBERINFO)
                                    ((char *)pmeminfo->pmeminfoNext + iPtrFix);
            }
            if (pmeminfo->sName != NULL) {
                if (pmeminfo->sName < src->Members || pmeminfo->sName > &src->Members[FUNCMEMBERSIZE]) {
                    ExitErrMsg(FALSE, "RelocateTypesInfo: sName not within Members[]\n");
                }
                pmeminfo->sName += iPtrFix;
            }
            if (pmeminfo->sType != NULL) {
                if (pmeminfo->sType < src->Members || pmeminfo->sType > &src->Members[FUNCMEMBERSIZE]) {
                    ExitErrMsg(FALSE, "RelocateTypesInfo: sType not within Members[]\n");
                }
                pmeminfo->sType += iPtrFix;
            }
            pmeminfo = pmeminfo->pmeminfoNext;
        }
    } else if (src->TypeKind == TypeKindFunc) {

        //
        // Make pfuncinfo point into the 'dest' array by fixing up the
        // source pointer.
        //
        pfuncinfo = (PFUNCINFO)((INT_PTR)src->pfuncinfo + iPtrFix);
        if ((char *)pfuncinfo < dest || (char *)pfuncinfo > dest+FUNCMEMBERSIZE) {
            ExitErrMsg(FALSE, "RelocateTypesInfo: pfuncinfo bad\n");
        }
        pfuncinfoRet = pfuncinfo;

        while (pfuncinfo != NULL) {
            if (pfuncinfo->pfuncinfoNext) {
                pfuncinfo->pfuncinfoNext = (PFUNCINFO)
                                    ((char *)pfuncinfo->pfuncinfoNext + iPtrFix);
            }
            if (pfuncinfo->sName != NULL) {
                if (pfuncinfo->sName < src->Members || pfuncinfo->sName > &src->Members[FUNCMEMBERSIZE]) {
                    ExitErrMsg(FALSE, "RelocateTypesInfo: sName not within Members[]\n");
                }
                pfuncinfo->sName += iPtrFix;
            }
            if (pfuncinfo->sType != NULL) {
                if (pfuncinfo->sType < src->Members || pfuncinfo->sType > &src->Members[FUNCMEMBERSIZE]) {
                    ExitErrMsg(FALSE, "RelocateTypesInfo: sType not within Members[]\n");
                }
                pfuncinfo->sType += iPtrFix;
            }
            pfuncinfo = pfuncinfo->pfuncinfoNext;
        }
    }

    return pfuncinfoRet;
}


BOOL
ParseTypes(
    PRBTREE pTypesList,
    PTYPESINFO  pTypesInfo,
    PKNOWNTYPES *ppKnownTypes
    )
/*++

Routine Description:

    Parses the Tokens[] and recognizes the following syntaxes:
        BasicType
        DerivedType
        unsigned|signed <int type>
        unsigned|signed
        unsigned|signed short|long int
        short|long int

Arguments:

    pTypesList      -- list of known types
    pTypesInfo      -- [OPTIONAL OUT] info about the type that was recognized
    ppKnownTypes    -- [OPTIONAL OUT] KNOWNTYPES info about the type

Return Value:

    TRUE - type was recognized.  pTypeInfo and ppKnownTypes are set,
           CurrentToken() points to token following the type.
    FALSE - type not recognized.

--*/
{
    PKNOWNTYPES pkt;
    char TypeName[MAX_PATH];
    char *SizeMod = NULL;
    char *SignMod = NULL;
    BOOL fLoopMore;

    if (pTypesInfo) {
        memset(pTypesInfo, 0, sizeof(TYPESINFO));
    }

    switch (CurrentToken()->TokenType) {
    case TK_STRUCT:
    case TK_UNION:
    case TK_ENUM:
        ConsumeToken();
        break;

    case TK_VARGS:
        pkt = GetNameFromTypesList(pTypesList, szVARGS);
        ConsumeToken();
        goto PKTExit;

    default:
        break;
    }


    //
    // Process 'long', 'short', 'signed' and 'unsigned' modifiers
    //
    while (CurrentToken()->TokenType == TK_IDENTIFIER) {
        if (strcmp(CurrentToken()->Name, szLONG) == 0) {
            SizeMod = szLONG;
        } else if (strcmp(CurrentToken()->Name, szSHORT) == 0) {
            SizeMod = szSHORT;
        } else if (strcmp(CurrentToken()->Name, szUNSIGNED) == 0) {
            SignMod = szUNSIGNED;
        } else if (strcmp(CurrentToken()->Name, szSIGNED) == 0) {
            SignMod = NULL;
        } else {
            break;
        }
        ConsumeToken();
    }

    //
    // Convert the modifier list into a standardized type string and
    // look it up.
    //
    TypeName[0] = '\0';
    if (SignMod) {
        strcpy(TypeName, SignMod);
    }
    if (SizeMod) {
        if (TypeName[0]) {
            strcat(TypeName, " ");
        }
        strcat(TypeName, SizeMod);
    }

    //
    // Append the type name to the optional list of type modifiers
    //
    if (CurrentToken()->TokenType != TK_IDENTIFIER) {
        if (TypeName[0] == '\0') {
            return FALSE;   // no qualifiers, so not a type
        }
        //
        // Append the implict 'int' on the end of the type qualifiers
        //
        strcat(TypeName, " ");
        strcat(TypeName, szINT);
    } else {
        char *Name = CurrentToken()->Name;

        if (strcmp(Name, szVOID) == 0 ||
            strcmp(Name, szINT) == 0 ||
            strcmp(Name, szINT64) == 0 ||
            strcmp(Name, sz_INT64) == 0 ||
            strcmp(Name, szCHAR) == 0 ||
            strcmp(Name, szFLOAT) == 0 ||
            strcmp(Name, szDOUBLE) == 0) {

            // Append the intrinsic type to the list of type modifiers
            if (TypeName[0]) {
                strcat(TypeName, " ");
            }
            strcat(TypeName, Name);

            //
            // Don't worry about explicitly disallowing things like
            // 'unsigned double' or 'short char'.  They won't be
            // in the pTypesList, so the parse will fail.
            //

            ConsumeToken();

        } else if (TypeName[0]) {
            //
            // The identifier is not an intrinsic type, and type modifiers
            // were seen.  The identifier is a variable name, not part of the
            // type name.  The type name is implicitly 'int'.
            //
            strcat(TypeName, " ");
            strcat(TypeName, szINT);

        } else {
            //
            // The identifier is not an intrinsic type, and no type
            // modifiers have been seen.  It is probably a typedef name.
            //
            strcpy(TypeName, Name);
            ConsumeToken();
        }
    }

    //
    // Look up the type name with all of its glorious modifiers
    //
    pkt = GetNameFromTypesList(pTypesList, TypeName);
    if (!pkt) {
        //
        // Type not found
        //
        return FALSE;
    }

PKTExit:
    if (pTypesInfo && pkt) {
        BUFALLOCINFO bufallocinfo;
        char *ps;
        PFUNCINFO pfuncinfoSrc = pkt->pfuncinfo;
        PMEMBERINFO pmeminfoSrc = pkt->pmeminfo;

        BufAllocInit(&bufallocinfo, pTypesInfo->Members, sizeof(pTypesInfo->Members), 0);

        pTypesInfo->Flags = pkt->Flags;
        pTypesInfo->IndLevel = pkt->IndLevel;
        pTypesInfo->Size = pkt->Size;
        pTypesInfo->iPackSize = pkt->iPackSize;
        strcpy(pTypesInfo->BasicType,pkt->BasicType);
        if (pkt->BaseName) {
            strcpy(pTypesInfo->BaseName,pkt->BaseName);
        }
        strcpy(pTypesInfo->TypeName,pkt->TypeName);
        if (pfuncinfoSrc) {
            PFUNCINFO pfuncinfoDest = NULL;

            pTypesInfo->pfuncinfo = BufPointer(&bufallocinfo);
            pTypesInfo->TypeKind = TypeKindFunc;

            while (pfuncinfoSrc) {
                pfuncinfoDest = AllocFuncInfoAndLink(&bufallocinfo, pfuncinfoDest);
                if (!pfuncinfoDest) {
                    ExitErrMsg(FALSE, "ParseTypes - out of memory at line %d\n", __LINE__);
                }
                pfuncinfoDest->fIsPtr64 = pfuncinfoSrc->fIsPtr64;
                pfuncinfoDest->tkPreMod = pfuncinfoSrc->tkPreMod;
                pfuncinfoDest->tkSUE    = pfuncinfoSrc->tkSUE;
                pfuncinfoDest->tkPrePostMod = pfuncinfoSrc->tkPrePostMod;
                pfuncinfoDest->IndLevel = pfuncinfoSrc->IndLevel;
                pfuncinfoDest->tkPostMod = pfuncinfoSrc->tkPostMod;

                ps = BufPointer(&bufallocinfo);
                pfuncinfoDest->sType = ps;
                strcpy(ps, pfuncinfoSrc->sType);
                BufAllocate(&bufallocinfo, strlen(ps)+1);

                if (pfuncinfoSrc->sName) {
                    ps = BufPointer(&bufallocinfo);
                    pfuncinfoDest->sName = ps;
                    strcpy(ps, pfuncinfoSrc->sName);
                    BufAllocate(&bufallocinfo, strlen(ps)+1);
                }

                pfuncinfoSrc = pfuncinfoSrc->pfuncinfoNext;
            }
        } else if (pmeminfoSrc) {
            PMEMBERINFO pmeminfoDest = NULL;

            pTypesInfo->TypeKind = TypeKindStruct;

            while (pmeminfoSrc) {
                pmeminfoDest = AllocMemInfoAndLink(&bufallocinfo, pmeminfoDest);
                pmeminfoDest->dwOffset = pmeminfoSrc->dwOffset;

                if (pmeminfoSrc->sName) {
                    ps = BufPointer(&bufallocinfo);
                    pmeminfoDest->sName = ps;
                    strcpy(ps, pmeminfoSrc->sName);
                    BufAllocate(&bufallocinfo, strlen(ps)+1);
                }

                if (pmeminfoSrc->sType) {
                    ps = BufPointer(&bufallocinfo);
                    pmeminfoDest->sType = ps;
                    strcpy(ps, pmeminfoSrc->sType);
                    BufAllocate(&bufallocinfo, strlen(ps)+1);
                }

                pmeminfoSrc = pmeminfoSrc->pmeminfoNext;
            }
        }
        pTypesInfo->dwMemberSize = bufallocinfo.dwLen;
    }

    if (ppKnownTypes) {
        *ppKnownTypes = pkt;
    }

    return TRUE;
}



void
__cdecl ErrMsg(
    char *pch,
    ...
    )
/*++

Routine Description:

    Displays an error message to stderr in a format that BUILD can find.
    Use this instead of fprintf(stderr, ...).

Arguments:

    pch     -- printf-style format string
    ...     -- printf-style args

Return Value:

    None.  Message formatted and sent to stderr.

--*/
{
    va_list pArg;

    fputs(ErrMsgPrefix, stderr);
    va_start(pArg, pch);
    vfprintf(stderr, pch, pArg);
}


__declspec(noreturn)
void
__cdecl
ExitErrMsg(
    BOOL bSysError,
    char *pch,
    ...
    )
/*++

Routine Description:

    Displays an error message to stderr in a format that BUILD can find.
    Use this instead of fprintf(stderr, ...).

Arguments:

    bSysErr -- TRUE if the value of errno should be printed with the error
    pch     -- printf-style format string
    ...     -- printf-style args

Return Value:

    None.  Message formatted and sent to stderr, open files closed and
    deleted, process terminated.

--*/
{
    va_list pArg;
    if (bSysError) {
        fprintf(stderr, "%s System ERROR %s", ErrMsgPrefix, strerror(errno));
    } else {
        fprintf(stderr, "%s ERROR ", ErrMsgPrefix);
    }

    va_start(pArg, pch);
    vfprintf(stderr, pch, pArg);

    CloseOpenFileList(TRUE);

    //
    // Flush stdout and stderr buffers, so that the last few printfs
    // get sent back to BUILD before ExitProcess() destroys them.
    //
    fflush(stdout);
    fflush(stderr);

    ExitProcess(1);
}




void
__cdecl DbgPrintf(
    char *pch,
    ...
    )
/*++

Routine Description:

    Displays a message to stdout if bDebug is set.

Arguments:

    pch     -- printf-style format string
    ...     -- printf-style args

Return Value:

    None.  Message formatted and sent to stderr.

--*/
{
    va_list pArg;

    if (!bDebug) {
        return;
    }

    va_start(pArg, pch);
    vfprintf(stdout, pch, pArg);
}




char *
ReadEntireFile(
    HANDLE hFile,
    DWORD *pBytesRead
    )
/*++

Routine Description:

    Allocates memory on the local heap and reads an entire file into it.

Arguments:

    hFile       -- file to read in
    bBytesRead  -- [OUT] number of bytes read from the file

Return Value:

    pointer to the memory allocated for the file, or NULL on error.

--*/
{
    DWORD  Bytes;
    char *pch = NULL;

    if (SetFilePointer(hFile, 0, NULL, FILE_BEGIN) == 0xffffffff ||
        (Bytes = GetFileSize(hFile, NULL)) == 0xffffffff) {
        goto ErrorExit;
    }

    pch = GenHeapAlloc(Bytes);
    if (!pch) {
        return NULL;
    }

    if (!ReadFile(hFile, pch, Bytes, pBytesRead, NULL) ||
        *pBytesRead != Bytes) {
        DbgPrintf("BytesRead %d Bytes %d\n", *pBytesRead, Bytes);
        GenHeapFree(pch);
        pch = NULL;
    }

ErrorExit:
    if (!pch) {
        DbgPrintf("GetLastError %d\n", GetLastError());
    }

   return pch;
}


HANDLE
CreateTempFile(
    void
    )
/*++

Routine Description:

    Creates and opens a temporary file.  It will be deleted when it is
    closed.

Arguments:

    None.

Return Value:

    File handle, or INVALID_HANDLE_VALUE on error.

--*/
{
    DWORD dw;
    char PathName[MAX_PATH+1];
    char FileName[2*MAX_PATH];
    HANDLE hFile = INVALID_HANDLE_VALUE;

    dw = GetTempPath(MAX_PATH, PathName);
    if (!dw || dw > MAX_PATH) {
        strcpy(PathName, ".");
    }

    dw = GetTempFileName(PathName, "thk", 0, FileName);
    if (!dw) {
        strcpy(PathName, ".");
        dw = GetTempFileName(PathName, "thk", 0, FileName);
        if (!dw) {
            DbgPrintf("GetTempFileName %s GLE=%d\n", FileName, GetLastError());
        }
    }

    hFile = CreateFile(FileName,
                      GENERIC_READ | GENERIC_WRITE,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_ALWAYS,
                      FILE_ATTRIBUTE_TEMPORARY |
                      FILE_FLAG_DELETE_ON_CLOSE |
                      FILE_FLAG_SEQUENTIAL_SCAN,
                      0
                      );

    if (hFile == INVALID_HANDLE_VALUE) {
        DbgPrintf("Create %s GLE=%d\n", FileName, GetLastError());
    }

    return hFile;
}



size_t
CopyToken(
    char *pDst,
    char *pSrc,
    size_t Size
    )
/*++

Routine Description:

    Copies a token (a separator-delimited string) from pSrc to pDst.

Arguments:

    pDst    -- destination to write the token to
    pSrc    -- source to copy token from
    Size    -- number of bytes available at pDst.

Return Value:

    Number of bytes copied from pSrc to pDst.

--*/
{
    size_t i = 0;

    while (!IsSeparator(*pSrc) && i < Size) {
        i++;
        *pDst++ = *pSrc++;
    }

    *pDst = '\0';

    return i;
}



char *
SkipKeyWord(
    char *pSrc,
    char *pKeyWord
    )
/*++

Routine Description:

    If the first word at pSrc matches the specified keyword, then skip
    over that keyword.

Arguments:

    pSrc        -- source string to examine
    pKeyWord    -- keyword to try and match

Return Value:

    pSrc unchanged if keyword not matched.  If keyword matched, returns
    ptr to text following the keyword after pSrc.

--*/
{
    int  LenKeyWord;
    char *pch;

    LenKeyWord = strlen(pKeyWord);
    pch = pSrc + LenKeyWord;

    if (!strncmp(pSrc, pKeyWord, LenKeyWord) && IsSeparator(*pch)) {
        pSrc = GetNextToken(pch - 1);
    }

    return pSrc;
}


BOOL
IsSeparator(
    char ch
    )
/*++

Routine Description:

    Determines if a character is a separator or not.
    over that keyword.

Arguments:

    ch      -- character to examine.

Return Value:

    TRUE if the character is a separator, FALSE if not.

--*/
{
   switch (ch) {
      case ' ':
      case '|':
      case '(':
      case ')':
      case '*':
      case ',':
      case '{':
      case '}':
      case ';':
      case '[':
      case ']':
      case '=':
      case '\n':
      case '\r':
      case ':':
      case '.':
      case '\0':
          return TRUE;
      }

    return FALSE;
}



/*
 *  GetNextToken
 */
char *
GetNextToken(
    char *pSrc
    )
/*++

Routine Description:

    Scans the input string and returns the next separator-delimited string.

Arguments:

    pSrc    -- input string

Return Value:

    Ptr to start of the next separator char which isn't a space.

--*/
{
    if (!*pSrc) {
        return pSrc;
    }

    if (!IsSeparator(*pSrc++)) {
        while (*pSrc && !IsSeparator(*pSrc)) {
            pSrc++;
        }
    }

    while (*pSrc && *pSrc == ' ') {
        pSrc++;
    }

    return pSrc;
}


void
DeleteAllocCvmHeap(
    HANDLE hCvmHeap
    )
/*++

Routine Description:

    Cleans up the mapped shared memory.

Arguments:

    hCvmHeap    -- memory to clean up.

Return Value:

    None.

--*/
{
    NTSTATUS Status;
    CVMHEAPINFO *pcvmheap = (CVMHEAPINFO *)hCvmHeap;

    Status = NtFreeVirtualMemory(NtCurrentProcess(),
                        (PVOID *)&pcvmheap->uBaseAddress,
                        &pcvmheap->uRegionSize,
                        MEM_RELEASE);

    if (!NT_SUCCESS(Status)) {
        DbgPrintf("Error freeing CVM %x", Status);
    }
}


HANDLE
CreateAllocCvmHeap(
    ULONG_PTR uBaseAddress,
    ULONG_PTR uReserveSize,
    ULONG_PTR uRegionSize,
    ULONG_PTR uUncomitted,
    ULONG_PTR uUnReserved,
    ULONG_PTR uAvailable
    )
/*++

Routine Description:

    Allocates a region of memory and makes it into a heap.

Arguments:

    uBaseAddress    -- base address to allocate the heap at
    uReserveSize    -- number of bytes to reserve
    uRegionSize     -- size of the region
    uUncomitted     -- amount of uncommitted memory
    uUnReserved     -- amount of unreserved memory
    uAvailable      -- amount of available memory

Return Value:

    Handle to the heap, or NULL on error.

--*/
{
    CVMHEAPINFO *pcvmheap;
    NTSTATUS Status;
    PULONG_PTR pBaseAddress= NULL;

    pcvmheap = GenHeapAlloc(sizeof(CVMHEAPINFO));
    if (pcvmheap == NULL) {
        return NULL;
    }

    pcvmheap->uBaseAddress = uBaseAddress;
    pcvmheap->uReserveSize = uReserveSize;
    pcvmheap->uRegionSize = uRegionSize;
    pcvmheap->uUncomitted = uUncomitted;
    pcvmheap->uUnReserved = uUnReserved;
    pcvmheap->uAvailable = uAvailable;

    //
    // Reserve enuf contiguous address space, for expected needs
    //
    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                         (PVOID *)&pcvmheap->uBaseAddress,
                                         0,
                                         &pcvmheap->uReserveSize,
                                         MEM_RESERVE,
                                         PAGE_NOACCESS
                                         );

    if (!NT_SUCCESS(Status)) {
        //
        // May want to retry this, with a different base address
        //
        ErrMsg(
               "Unable to reserve vm %x %x %x\n",
               pcvmheap->uBaseAddress,
               pcvmheap->uReserveSize,
               Status
              );
        return NULL;
    }

    pcvmheap->uUnReserved = pcvmheap->uBaseAddress + pcvmheap->uReserveSize;


    //
    // Commit the first page, we will grow this a page at a time
    // as its needed.
    //
    pcvmheap->uAvailable = pcvmheap->uBaseAddress;
    Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                         (PVOID *)&pcvmheap->uAvailable,
                                         0,
                                         &pcvmheap->uRegionSize,
                                         MEM_COMMIT,
                                         PAGE_READWRITE
                                         );

    if (!NT_SUCCESS(Status)) {
        //
        // May want to retry this, with a different base address
        //
        ErrMsg(
               "Unable to commit vm %x %x %x\n",
               pcvmheap->uBaseAddress,
               pcvmheap->uReserveSize,
               Status
              );
        return NULL;
    }

    pcvmheap->uUncomitted = pcvmheap->uBaseAddress + pcvmheap->uRegionSize;


            // paranoia!
    if (pcvmheap->uAvailable != pcvmheap->uBaseAddress) {
        ErrMsg(
               "commit pvAvailable(%x) != gBaseAddress(%x)\n",
               pcvmheap->uAvailable,
               pcvmheap->uBaseAddress
              );
        return NULL;
    }

    DbgPrintf("Ppm: BaseAddress %x\n", pcvmheap->uBaseAddress);

    return pcvmheap;
}


PVOID
GetCvmHeapBaseAddress(
    HANDLE hCvmHeap
    )
/*++

Routine Description:

    Returns the base address of a heap.

Arguments:

    hCvmHeap        -- heap to examine

Return Value:

    Base address, or NULL.

--*/
{
    CVMHEAPINFO *pcvmheap = (CVMHEAPINFO *)hCvmHeap;
    return pcvmheap == NULL ? NULL : (PVOID)pcvmheap->uBaseAddress;
}


PVOID
GetCvmHeapAvailable(
    HANDLE hCvmHeap
    )
/*++

Routine Description:

    Returns the number of bytes available in a heap.

Arguments:

    hCvmHeap        -- heap to examine

Return Value:

    Bytes available, or NULL.

--*/
{
    CVMHEAPINFO *pcvmheap = (CVMHEAPINFO *)hCvmHeap;
    return pcvmheap == NULL ? NULL : (PVOID)pcvmheap->uAvailable;
}


PVOID
AllocCvm(
    HANDLE hCvmHeap,
    ULONG_PTR Size
    )
/*++

Routine Description:

    Allocate memory from a heap.

Arguments:

    hCvmHeam        -- heap to allocate from
    Size            -- number of bytes to allocate

Return Value:

    Ptr to allocated memory, or NULL of insufficient memory.

--*/
{
    CVMHEAPINFO *pcvmheapinfo = (CVMHEAPINFO *)hCvmHeap;
    NTSTATUS Status;
    ULONG_PTR Available;
    ULONG_PTR AlignedSize;

    if (pcvmheapinfo == NULL) {
        return NULL;
    }

    //
    // Round the allocation up to the next-highest multiple of 8, so that
    // allocations are correctly aligned.
    //
    AlignedSize = (Size + 7) & ~7;

    Available = pcvmheapinfo->uAvailable;
    pcvmheapinfo->uAvailable += AlignedSize;

    if (pcvmheapinfo->uAvailable >= pcvmheapinfo->uUnReserved) {
        ErrMsg("AllocCvm: Allocation Size exceeds reserved size\n");
        return NULL;
    }

    if (pcvmheapinfo->uAvailable >= pcvmheapinfo->uUncomitted) {
        //
        // Commit enuf pages to exceed the requested allocation size
        //
        Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                         (PVOID *)&pcvmheapinfo->uUncomitted,
                                         0,
                                         &Size,
                                         MEM_COMMIT,
                                         PAGE_READWRITE
                                         );

        if (!NT_SUCCESS(Status)) {
            ErrMsg(
                   "Unable to commit vm %x %x %x\n",
                   pcvmheapinfo->uBaseAddress,
                   Size,
                   Status
                   );
            return NULL;
        }

        pcvmheapinfo->uUncomitted += Size;
    }

    return (PVOID)Available;
}



void ParseIndirection(
    DWORD *pIndLevel,
    DWORD *pdwSize,
    DWORD *pFlags,
    PTOKENTYPE ptkPrePostMod,
    PTOKENTYPE ptkPostMod
    )
/*++

Routine Description:

    Parse any indirection level specificiations ('*') taking into
    account const, volatile, and __ptr64 modifiers.  For example:
    void * const __ptr64 ** const * __ptr64 would be valid.

    NOTE: the pointer is a 64-bit pointer only if the last pointer
          declared is modified by __ptr64.

Arguments:

    pIndlevel       -- [OUT] indirection level (number of '*'s)
    pdwSize         -- [OUT] size of the type (4 or 8)
    pFlags          -- [OUT] BTI_ flags
    ptkPrePostMod   -- [OUT] TK_CONST, TK_VOLATILE, or TK_NONE, depending
                             on modifiers seen before the first '*'
    ptkPostMod      -- [OUT] TK_CONST, TK_VOLATILE, or TK_NONE, depending
                             on modifiers seen after the first '*'

Return Value:

    None.  May not consume any tokens if there are no levels of indirection.

--*/
{
    int IndLevel = 0;
    DWORD dwSize = 0;
    DWORD Flags = 0;
    BOOL fStopScanning = FALSE;
    TOKENTYPE tkPrePostMod = TK_NONE;
    TOKENTYPE tkPostMod = TK_NONE;

    do {
        switch (CurrentToken()->TokenType) {
        case TK_BITWISE_AND:
            ////////////////////////////////////////////////////////////////////
            //The ref operator in C++ is equilivalent to * const in C
            //This implies that & should be treated as a * but add a postmod of const.
            /////////////////////////////////////////////////////////////////////
            tkPostMod = TK_CONST;
        case TK_STAR:
            IndLevel++;
            dwSize = SIZEOFPOINTER;
            Flags &= ~BTI_PTR64;
            ConsumeToken();
            break;

        case TK_CONST:
        case TK_VOLATILE:
            //
            // The caller may be interrested in whether the 'const' or
            // 'volatile' keywords are before or after the '*'
            //
            if (IndLevel) {
                tkPostMod = CurrentToken()->TokenType;
            } else {
                tkPrePostMod = CurrentToken()->TokenType;
            }
            ConsumeToken();
            break;

        case TK_IDENTIFIER:
            if (strcmp(CurrentToken()->Name, sz__PTR64) == 0) {
                dwSize = SIZEOFPOINTER64;
                Flags |= BTI_PTR64;
                ConsumeToken();
                break;
            }

        default:
            fStopScanning = TRUE;
            break;
        }
    } while (!fStopScanning);

    if (pIndLevel != NULL) {
        *pIndLevel += IndLevel;
    }
    if ((pdwSize != NULL) && (dwSize != 0)) {
        *pdwSize = dwSize;
    }
    if (pFlags != NULL) {
        *pFlags |= Flags;
    }
    if (ptkPostMod) {
        *ptkPostMod = tkPostMod;
    }
    if (ptkPrePostMod) {
        *ptkPrePostMod = tkPrePostMod;
    }
}



BOOL
IsTokenSeparator(
    void
    )
/*++

Routine Description:

    Determines if a token is a separator character or not.

Arguments:

    None.  Examines CurrentToken()->TokenType.

Return Value:

    TRUE if CurrentToken() is a separator, FALSE if not.

--*/
{
    switch (CurrentToken()->TokenType) {
    case TK_LPAREN:
    case TK_RPAREN:
    case TK_STAR:
    case TK_BITWISE_AND:
    case TK_COMMA:
    case TK_LBRACE:
    case TK_RBRACE:
    case TK_SEMI:
    case TK_LSQUARE:
    case TK_RSQUARE:
    case TK_COLON:
        return TRUE;

    default:
        return FALSE;
    }
}

VOID
ReleaseToken(
    PTOKEN Token
)
{

/*++

Routine Description:

        Releases any additional memory associated with a token.

Arguments:

        dest        - [IN] ptr to the token.

Return Value:

--*/

    if (Token->TokenType == TK_IDENTIFIER ||
        Token->TokenType == TK_STRING) {
        GenHeapFree(Token->Name);
    }
    Token->TokenType = TK_NONE;
    Token->Value = 0;
    Token->dwValue = 0;
}

void
ResetLexer(
    void
    )
/*++

Routine Description:

    Resets the lexer in preparation to analyze a new statement.

Arguments:

    None.

Return Value:

    None.  Lexer's state reset.

--*/
{
    int TokenCount;

    for (TokenCount = 0;
         TokenCount < MAX_TOKENS_IN_STATEMENT &&
         Tokens[TokenCount].TokenType != TK_EOS;
         ++TokenCount) {

         ReleaseToken(&Tokens[TokenCount]);
    }

    CurrentTokenIndex = 0;
}

__inline
VOID
InitializeToken(
    PTOKEN Token
    )
/*++

Routine Description:

    Initialize a token so the lexer can fill it in.

Arguments:

    Token       -- TOKEN to initialize

Return Value:

    None.

--*/
{
    // The number parser expects Value to be 0.
    Token->TokenType = TK_NONE;
    Token->Value = 0;
    Token->dwValue = 0;
}

void
ProcessEscapes(
    char *String
    )
/*++

Routine Description:

    Process escape characters, replacing them by the proper char.

Arguments:

    String  -- null-terminated string to process

Return Value:

    None.  Conversion is done in-place.

--*/
{
    char *pDest;
    char *pSrc;
    char c;
    int i;

    pSrc = pDest = String;
    while (*pSrc) {
        if (*pSrc != '\\') {
            *pDest = *pSrc;
            pSrc++;
            pDest++;
        } else {
            pSrc++;
            switch (*pSrc) {
            case 'n':
                c = '\n';
                break;

            case 't':
                c = '\t';
                break;

            case 'v':
                c = '\v';
                break;

            case 'b':
                c = '\b';
                break;

            case 'r':
                c = '\r';
                break;

            case 'f':
                c = '\f';
                break;

            case 'a':
                c = '\a';
                break;

            case '\\':
                c = '\\';
                break;

            case '?':
                c = '\?';
                break;

            case '\'':
                c = '\'';
                break;

            case '\"':
                c = '\"';
                break;

            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
                // Octal number
                c = 0;
                for (i=0; i<3;++i) {
                    c = (c * 8) + (*pSrc) - '0';
                    pSrc++;
                    if (*pSrc < '0' || *pSrc > '7') {
                        // hit end of number
                        break;
                    }
                }
                break;

            case 'x':
            case 'X':
                // Hex number
                pSrc++;
                c = 0;
                for (i=0; i<3;++i) {
                    char digit;

                    digit = *pSrc;
                    if (digit >= '0' && digit <= '9') {
                        digit -= '0';
                    } else if (digit >= 'a' && digit <= 'f') {
                        digit = digit - 'a' + 10;
                    } else if (digit >= 'A' && digit <= 'A') {
                        digit = digit - 'A' + 10;
                    } else {
                        // hit end of number
                        break;
                    }
                    c = (c * 16) + digit;
                    pSrc++;
                }
                break;

            default:
                // Parse error in the string literal.
                goto Exit;

            }
            *pDest = c;
            pDest++;
        }
    }
Exit:
    // Write the new null-terminator in
    *pDest = '\0';
}


// Disable 'unreachable code' warning: in some cases,
// HandlePreprocessorDirective does not return, leaving code following it
// unreachable.
#pragma warning(push)
#pragma warning(disable:4702)

char *
LexOneLine(
    char *p,
    BOOL fStopAtStatement,
    BOOL *pfLexDone
    )
/*++

Routine Description:

    Performs lexical analysis on a single line of input.  The lexer
    may stop before consuming an entire line of input, so the caller
    must closely examine the return code before grabbing the next line.

    __inline functions are deleted by the lexer.  The lexer consumes input
    until it encounters a '{' (assumed to be the start of the function
    body), then consumes input until the matching '}' is found (assumed to
    be the end of the function body).

    "template" is deleted by the lexer and treated as if it was
    an "__inline" keyword... it consumes everything upto '{' then
    keeps consuming until a matching '}' is found.  That makes unknwn.h
    work.

    Lexer unwraps extern "C" {} blocks.

    'static' and '__unaligned' keywords are deleted by the lexer.

    Preprocessor directives are handled via a callout to
    HandlePreprocessorDirective().

Arguments:

    p                   -- ptr into the line of input
    fStopAtStatement    -- TRUE if caller wants lexer to stop at ';' at
                           file-scope.  FALSE if caller wants lexer to stop
                           at ')' at file-scope.
    pfLexDone           -- [OUT] lexer sets this to TRUE if the analysis
                           is complete.  Lexer sets this to FALSE if
                           it needs another line of input from the caller.

Return Value:

    ptr into the line of input where lexing left off, or NULL if entire
    line was consumed.

    CurrentTokenIndex is the index of the next element of the Tokens[]
    array that the lexer will fill in.

    Tokens[] is the array of tokens the lexer has generated.

--*/
{
    static int NestingLevel=0;      // level of nesting of braces and parens
    static BOOL fInlineSeen=FALSE;  // TRUE while deleting __inline functions
    static int ExternCLevel=0;      // tracks the number of extern "C" blocks
    static int InlineLevel=0;       // NestingLevel for the outermost __inline
    int Digit;                      // a digit in a numeric constant
    int NumberBase = 10;            // assume numbers are base-10
    PTOKEN Token;                   // ptr to current token being lexed

    //
    // Assume the lexical analysis is not done
    //
    *pfLexDone = FALSE;

    //
    // Pick up analysis where we left off...
    //
    Token = &Tokens[CurrentTokenIndex];
    InitializeToken(Token);

    //
    // Loop over all characters in the line, or until a complete lexical
    // unit is done (depends on fStopAtStatement).
    //
    while (*p) {
        switch (*p) {
        case ' ':
        case '\t':
        case '\r':
        case '\n':
        case '\v':
        case '\f':
        case '\b':
        case '\a':
        case '\\':  // line-continuation characters are ignored
            p++;
            continue;

        case '#':
            //
            // HandlePreprocessorDirective() is implemented in the
            // app which links to genmisc.c.
            //
            HandlePreprocessorDirective(p);
            CurrentTokenIndex = (int)(Token - Tokens);
            return NULL;

        case '+':
            Token->TokenType = TK_PLUS;
            break;

        case '-':
            Token->TokenType = TK_MINUS;
            break;

        case ':':
            Token->TokenType = TK_COLON;
            break;

        case '=':
            Token->TokenType = TK_ASSIGN;
            break;

        case ';':
            if (NestingLevel == 0 && fStopAtStatement) {
                //
                // Found a ';' at file-scope.  This token marks the
                // end of the C-language statement.
                //
                p++;
                if (*p == '\n') {
                    //
                    // ';' is at EOL - consume it now.
                    //
                    p++;
                }
                Token->TokenType = TK_EOS;
                *pfLexDone = TRUE;
                CurrentTokenIndex = (int)(Token - Tokens + 1);
                return p;
            }
            Token->TokenType = TK_SEMI;
            break;

        case '*':
            Token->TokenType = TK_STAR;
            break;

        case '/':
            Token->TokenType = TK_DIVIDE;
            break;

        case ',':
            Token->TokenType = TK_COMMA;
            break;

        case '<':
            if (p[1] == '<') {
                Token->TokenType = TK_LSHIFT;
                p++;
            } else {
                Token->TokenType = TK_LESS;
            }
            break;

        case '>':
            if (p[1] == '>') {
                Token->TokenType = TK_RSHIFT;
                p++;
            } else {
                Token->TokenType = TK_GREATER;
            }
            break;

        case '&':
            if (p[1] == '&') {
                Token->TokenType = TK_LOGICAL_AND;
                p++;
            } else {
                Token->TokenType = TK_BITWISE_AND;
            }
            break;

        case '|':
            if (p[1] == '|') {
                Token->TokenType = TK_LOGICAL_OR;
                p++;
            } else {
                Token->TokenType = TK_BITWISE_OR;
            }
            break;

        case '%':
            Token->TokenType = TK_MOD;
            break;

        case '^':
            Token->TokenType = TK_XOR;
            break;

        case '!':
            Token->TokenType = TK_NOT;
            break;

        case '~':
            Token->TokenType = TK_TILDE;
            break;

        case '[':
            Token->TokenType = TK_LSQUARE;
            break;

        case ']':
            Token->TokenType = TK_RSQUARE;
            break;

        case '(':
            NestingLevel++;
            Token->TokenType = TK_LPAREN;
            break;

        case ')':
            NestingLevel--;
            if (NestingLevel == 0 && !fStopAtStatement) {
                //
                // Found a ')' at file-scope, and we're lexing
                // the contents of an @-command in genthnk.
                // Time to stop lexing.
                //
                p++;
                Token->TokenType = TK_EOS;
                *pfLexDone = TRUE;
                CurrentTokenIndex = (int)(Token - Tokens + 1);
                return p;
            } else if (NestingLevel < 0) {
                ExitErrMsg(FALSE, "Parse Error: mismatched nested '(' and ')'\n");
            }
            Token->TokenType = TK_RPAREN;
            break;

        case '{':
            //check for a 'extern "C" {}' or 'extern "C++" {}'
            if (Token - Tokens >= 2 &&
                Token[-2].TokenType == TK_EXTERN &&
                Token[-1].TokenType == TK_STRING &&
                (strcmp(Token[- 1].Name, "C") == 0 || strcmp(Token[-1].Name, "C++") == 0)) {

                    if (NestingLevel == 0 && fInlineSeen) {
                        ExitErrMsg(FALSE, "Extern \"C\" blocks only supported at file scope\n");
                    }
                    ExternCLevel++;


                    //remove the last 2 tokens and skip this token
                    ReleaseToken(Token - 2);
                    ReleaseToken(Token - 1);
                    Token -= 2;
                    p++;
                    continue;
            }

            NestingLevel++;
            Token->TokenType = TK_LBRACE;
            break;

        case '.':
            if (p[1] == '.' && p[2] == '.') {
                Token->TokenType = TK_VARGS;
                p+=2;
            } else {
                Token->TokenType = TK_DOT;
            }
            break;

        case '}':
            if (NestingLevel == 0 && ExternCLevel > 0) {
                //omit this token since it is the end of an extern "C" block
                ExternCLevel--;
                p++;
                continue;
            }
            NestingLevel--;
            if (NestingLevel < 0) {
                ExitErrMsg(FALSE, "Parse Error: mismatched nested '{' and '}'\n");
            }
            else if (NestingLevel == InlineLevel && fInlineSeen) {
                //
                // Found the closing '}' for the end of an inline
                // function.  Advance past the '}' and start lexing
                // again as if the __inline was never there.
                //
                fInlineSeen = FALSE;
                p++;
                continue;
            }
            else {
                Token->TokenType = TK_RBRACE;
            }
            break;

        case '0':
            if (p[1] == 'x' || p[1] == 'X') {
                //
                // Found '0x' prefix - the token is a hex constant
                //
                Token->TokenType = TK_NUMBER;

                for (p+=2; *p != '\0'; p++) {
                    if (isdigit(*p)) {
                        int i;
                        i = *p - '0';
                        Token->Value = Token->Value * 16 + i;
                        Token->dwValue = Token->dwValue * 16 + i;
                    } else {
                        char c = (char)toupper(*p);
                        if (c >= 'A' && c <= 'F') {
                            int i;
                            i = c - 'A' + 10;
                            Token->Value = Token->Value * 16 + i;
                            Token->dwValue = Token->dwValue * 16 + i;
                        } else if (c == 'L') {
                            //
                            // Numeric constant ending in 'L' is a long-integer
                            // type.
                            //
                            break;
                        } else if (isalpha(c)) {
                            DumpLexerOutput(0);
                            ExitErrMsg(FALSE, "Parse Error in hex constant.\n");
                        } else {
                            p--;
                            break;
                        }

                    }
                }
                break;
            } else if (isdigit(p[1])) {
                //
                // Found '0' followed by a valid number - the token is
                // an octal constant.
                //
                NumberBase = 8;

            }
            // fall into general number processing code

        case '1':
        case '2':
        case '3':
        case '4':
        case '5':
        case '6':
        case '7':
        case '8':
        case '9':
            Token->TokenType = TK_NUMBER;

            for (; *p != '\0'; p++) {
                Digit = *p - '0';
                if (*p == 'l' || *p == 'L') {
                    //
                    // Numeric constant ending in 'l' is a long-integer
                    //
                    break;
                } else if (Digit < 0 || Digit >= NumberBase) {
                    p--;
                    break;
                }
                Token->Value = Token->Value * NumberBase + Digit;
                Token->dwValue = Token->dwValue * NumberBase + Digit;
            }
            break;

        case '\'':
            Token->TokenType = TK_NUMBER;
            p++;  //skip past beginning '
            for(; *p != '\''; p++) {
                if (*p == '\0') {
                   ExitErrMsg(FALSE, "\' without ending \'\n");
                }
                Token->Value = Token->Value << 8 | (UCHAR)*p;
                Token->dwValue = Token->dwValue << 8 | (UCHAR)*p;
            }
            break;

        case '"':
            // A string literal. ie. char *p = "foo";
            {
                char *strStart;

                Token->TokenType = TK_STRING;
                strStart = ++p; //skip begining quote

                //get a count of the number of characters
                while (*p != '\0' && *p != '"') p++;

                if ('\0' == *p || '\0' == *(p+1)) {
                    ExitErrMsg(FALSE, "String without ending quote\n");
                }
                p++; //skip past the ending quote

                Token->Name = GenHeapAlloc(p - strStart); //1+strlen
                if (Token->Name == NULL) {
                    ExitErrMsg(FALSE, "Out of memory in lexer\n");
                }

                memcpy(Token->Name, strStart, p-strStart-1);
                Token->Name[p-strStart-1] = '\0';
                p--;
                ProcessEscapes(Token->Name);
            }
            break;

        default:
            if (*p == '_' || isalpha(*p)) {
                //
                // An identifier or keyword
                //
                char *IdStart = p;

                Token->TokenType = TK_IDENTIFIER;

                while (*p == '_' || isalpha(*p) || isdigit(*p)) {
                    p++;
                }
                Token->Name = GenHeapAlloc(p - IdStart + 1);
                if (Token->Name == NULL) {
                    ExitErrMsg(FALSE, "Out of memory in lexer\n");
                }
                memcpy(Token->Name, IdStart, p-IdStart);
                Token->Name[p-IdStart] = '\0';

                CheckForKeyword(Token);
                if (Token->TokenType == TK_TEMPLATE) {
                    fInlineSeen = TRUE;
                    InlineLevel = NestingLevel; // want to get back to the same scope
                } else if (Token->TokenType == TK_INLINE) {
                    if (NestingLevel) {
                        //
                        // __inline keyword embedded inside {}.  It's
                        // technically an error but we want to allow it
                        // during inclusion of ntcb.h.
                        //
                        continue;
                    }
                    fInlineSeen = TRUE;
                    InlineLevel = 0;    // want to get back to file scope
                } else if (Token->TokenType == TK_STATIC ||
                           Token->TokenType == TK_UNALIGNED ||
                           Token->TokenType == TK_RESTRICT ||
                           Token->TokenType == TK___W64) {
                    // filter out 'static', '__restrict', '__unaligned' and '__w64'
                    // keywords
                    continue;
                }
                p--;
            } else if (fInlineSeen) {
                //
                // While processing __inline functions, the lexer is
                // going to encounter all sorts of weird characters
                // in __asm blocks, etc.  Just ignore them and keep
                // consuming input.
                //
                p++;
                continue;
            } else {
                ExitErrMsg(FALSE, "Lexer: unexpected char '%c' (0x%x) found\n", *p, *p);
            }
        } // switch

        p++;
        if (!fInlineSeen) {
            Token++;
            if (Token == &Tokens[MAX_TOKENS_IN_STATEMENT]) {
                ExitErrMsg(FALSE, "Lexer internal error - too many tokens in this statement.");
            }
            InitializeToken(Token);
        }
    } // while (*p)

    //
    // Hit end-of-line.  Indicate this to the caller
    //
    Token->TokenType = TK_EOS;
    CurrentTokenIndex = (int)(Token - Tokens);
    return NULL;
}

#pragma warning(pop)


void
CheckForKeyword(
    PTOKEN Token
    )
/*++

Routine Description:

    Converts a TK_INDENTIFIER token into a C-language keyword token, if
    the identifier is in the KeywordList[].

Arguments:

    Token       -- Token to convert

Return Value:

    None.       Token->TokenType and Token->Name may be changed.

--*/
{
    int i;
    int r;

    for (i=0; KeywordList[i].MatchString; ++i) {
        r = strcmp(Token->Name, KeywordList[i].MatchString);
        if (r == 0) {
            GenHeapFree(Token->Name);
            Token->Name = NULL;
            Token->TokenType = KeywordList[i].Tk;
            return;
        } else if (r < 0) {
            return;
        }
    }
}

void
DumpLexerOutput(
    int FirstToken
    )
/*++

Routine Description:

    Debug routine to dump out the Token list as human-readable text.

Arguments:

    FirstToken      -- Index of the first token to list back.

Return Value:

    None.

--*/
{
    int i;

    for (i=0; i<FirstToken; ++i) {
        if (Tokens[i].TokenType == TK_EOS) {
            fprintf(stderr, "DumpLexerOutput: FirstToken %d is after EOS at %d\n", FirstToken, i);
            return;
        }
    }

    fprintf(stderr, "Lexer: ");
    for (i=FirstToken; Tokens[i].TokenType != TK_EOS; ++i) {
        switch (Tokens[i].TokenType) {
        case TK_NUMBER:
            fprintf(stderr, "0x%X ", Tokens[i].Value);
            break;

        case TK_IDENTIFIER:
        case TK_STRING:
            fprintf(stderr, "%s ", Tokens[i].Name);
            break;

        case TK_NONE:
            fprintf(stderr, "<TK_NONE> ");
            break;

        default:
            fprintf(stderr, "%s ", TokenString[(int)Tokens[i].TokenType]);
            break;
        }
    }
    fprintf(stderr, "<EOS>\n");
}


BOOL
UnlexToText(
    char *dest,
    int destlen,
    int StartToken,
    int EndToken
    )
/*++

Routine Description:

    Convert a sequence of Tokens back into human-readable text.

Arguments:

    dest        -- ptr to destination buffer
    destlen     -- length of destination buffer
    StartToken  -- index of first token to list back
    EndToken    -- index of last token (this token is *not* listed back)

Return Value:

    TRUE if Unlex successful.  FALSE if failure (ie. buffer overflow).

--*/
{
    int i;
    int len;
    char buffer[16];
    char *src;

    if (bDebug) {
        for (i=0; i<StartToken; ++i) {
            if (Tokens[i].TokenType == TK_EOS) {
                ErrMsg("UnlexToText: StartToken %d is after EOS %d\n", StartToken, i);
                return FALSE;
            }
        }
    }

    for (i=StartToken; i<EndToken; ++i) {
        switch (Tokens[i].TokenType) {
        case TK_EOS:
            return FALSE;

        case TK_NUMBER:
            sprintf(buffer, "%d", Tokens[i].Value);
            src = buffer;
            break;

        case TK_IDENTIFIER:
                case TK_STRING:
            src = Tokens[i].Name;
            break;

        case TK_NONE:
            src = "<TK_NONE>";
            break;

        default:
            src = TokenString[(int)Tokens[i].TokenType];
            break;
        }

        len = strlen(src);
        if (len+1 > destlen) {
            return FALSE;
        }
        strcpy(dest, src);
        dest += len;
        *dest = ' ';
        dest++;
        destlen -= len+1;
    }
    dest--;         // back up over the trailing ' '
    *dest = '\0';   // null-terminate

    return TRUE;
}


PVOID
GenHeapAlloc(
    INT_PTR Len
    )
{
    return RtlAllocateHeap(RtlProcessHeap(), 0, Len);
}

void
GenHeapFree(
    PVOID pv
    )
{
    RtlFreeHeap(RtlProcessHeap(), 0, pv);
}


TOKENTYPE
ConsumeDirectionOpt(
    void
    )
/*++

Routine Description:

    Comsumes a TK_IN or TK_OUT, if present in the lexer stream.  TK_IN
    followed by TK_OUT is converted to TK_INOUT.

Arguments:

    None.

Return Value:

    TK_IN, TK_OUT, TK_INOUT, or TK_NONE.

--*/
{
    TOKENTYPE t = CurrentToken()->TokenType;

    switch (t) {
    case TK_IN:
        ConsumeToken();
        if (CurrentToken()->TokenType == TK_OUT) {
            ConsumeToken();
            t = TK_INOUT;
        }
        break;

    case TK_OUT:
        ConsumeToken();
        if (CurrentToken()->TokenType == TK_IN) {
            ConsumeToken();
            t = TK_INOUT;
        }
        break;

    default:
        t = TK_NONE;
        break;
    }

    return t;
}


TOKENTYPE
ConsumeConstVolatileOpt(
    void
    )
/*++

Routine Description:

    Comsumes a TK_CONST or TK_VOLATILE, if present in the lexer stream.

Arguments:

    None.

Return Value:

    TK_CONST, TK_VOLATILE, or TK_NONE.

--*/
{
    TOKENTYPE t = CurrentToken()->TokenType;

    switch (t) {
    case TK_CONST:
    case TK_VOLATILE:
        ConsumeToken();
        break;

    default:
        t = TK_NONE;
        break;
    }

    return t;
}


PMEMBERINFO
AllocMemInfoAndLink(
    BUFALLOCINFO *pbufallocinfo,
    PMEMBERINFO pmeminfo
    )
/*++

Routine Description:

    Allocates a new MEMBERINFO struct from the buffer

Arguments:

    pbufallocinfo -- ptr to memory buffer to allocate from
    pmeminfo      -- ptr to list of MEMBERINFOs to link the new one into

Return Value:

    Newly-allocated, initialized, linked-in MEMBERINFO struct (or NULL)

--*/
{
    PMEMBERINFO pmeminfoNext;

    pmeminfoNext = BufAllocate(pbufallocinfo, sizeof(MEMBERINFO));
    if (pmeminfoNext) {
        if (pmeminfo) {
            pmeminfo->pmeminfoNext = pmeminfoNext;
        }
        memset(pmeminfoNext, 0, sizeof(MEMBERINFO));
    }   
    return pmeminfoNext;
}

PFUNCINFO
AllocFuncInfoAndLink(
    BUFALLOCINFO *bufallocinfo,
    PFUNCINFO pfuncinfo
    )
/*++

Routine Description:

    Allocates a new FUNCINFO struct from the buffer

Arguments:

    pbufallocinfo -- ptr to memory buffer to allocate from
    pmeminfo      -- ptr to list of FUNCINFOs to link the new one into

Return Value:

    Newly-allocated, initialized, linked-in FUNCINFO struct (or NULL)

--*/
{
    PFUNCINFO pfuncinfoNext;

    pfuncinfoNext = BufAllocate(bufallocinfo, sizeof(FUNCINFO));
    if ((pfuncinfoNext != NULL) && (pfuncinfo != NULL)) {
        pfuncinfo->pfuncinfoNext = pfuncinfoNext;
        pfuncinfoNext->sName = NULL;
        pfuncinfoNext->sType = NULL;
    }
    return pfuncinfoNext;
}

DWORD
SizeOfMultiSz(
    char *c
    )
{
/*++

Routine Description:

        Determines the number of bytes used by double '\0' terminated list.

Arguments:

        c           - [IN] ptr to the double '\0' termined list.

Return Value:

        Bytes used.
--*/
    DWORD dwSize = 1;
    char cPrevChar = '\0'+1;
    do {
        dwSize++;
        cPrevChar = *c;
    } while(*++c != '\0' || cPrevChar != '\0');
    return dwSize;
}

BOOL
CatMultiSz(
    char *dest,
    char *source,
    DWORD dwMaxSize
    )
{
/*++

Routine Description:

        Concatinates two double '\0' terminated lists.
        New list is stored at dest.

Arguments:

        dest        - [IN/OUT] ptr to the head double '\0' terminated list.
        element     - [IN] ptr to the head double '\0' terminated list.
        dwMaxSize   - [IN] max size of the new list in bytes.

Return Value:

        TRUE     - Success.
        FALSE    - Failure.
--*/
    //Find end of MultiSz
    DWORD dwLengthDest, dwLengthSource;
    dwLengthDest = SizeOfMultiSz(dest);
    if (2 == dwLengthDest) dwLengthDest = 0;
    else dwLengthDest--;
    dwLengthSource = SizeOfMultiSz(source);
    if (dwLengthDest + dwLengthSource > dwMaxSize) return FALSE;
    memcpy(dest + dwLengthDest, source, dwLengthSource);
    return TRUE;
}

BOOL
AppendToMultiSz(
    char *dest,
    char *source,
    DWORD dwMaxSize
    )
{
/*++

Routine Description:

        Adds a string to the end of a double '\0' terminated list.

Arguments:

        dest      - [IN/OUT] ptr to the double '\0' terminated list.
        source    - [IN] ptr to the string to add.
        dwMaxSize - [IN] max number of bytes that can be used by the list.

Return Value:

        TRUE     - Success.
        FALSE    - Failure.
--*/
    DWORD dwLengthDest, dwLengthSource;
    dwLengthDest = SizeOfMultiSz(dest);
    if (2 == dwLengthDest) dwLengthDest = 0;
    else dwLengthDest--;
    dwLengthSource = strlen(source) + 1;
    if (dwLengthDest + dwLengthSource + 1 > dwMaxSize) return FALSE;
    memcpy(dest + dwLengthDest, source, dwLengthSource);
    *(dest + dwLengthDest + dwLengthSource) = '\0';
    return TRUE;
}

BOOL IsInMultiSz(
    const char *multisz,
    const char *element
    )
{
/*++

Routine Description:

        Determines if a string exists in a double '\0' terminated list.

Arguments:

        ppHead  - [IN] ptr to the double '\0' terminated list.
        element - [IN] ptr to the element to find.
Return Value:

        TRUE     - element is in the list.
        FALSE    - element is not in the list.
--*/
    do {
        if (strcmp(multisz, element) == 0) return TRUE;
        //skip to end of string
        while(*multisz++ != '\0');
    } while(*multisz != '\0');
    return FALSE;
}

BOOL
ConvertGuidCharToInt(
    const char *pString,
    DWORD *n,
    unsigned short number
    )
{
/*++

Routine Description:

        Internal route to be called only from ConvertStringToGuid.
        Converts segements of the GUID to numbers.

Arguments:

        pString  - [IN] ptr to the string segment to process.
        n        - [OUT] ptr to number representation of string segment.
        number   - [IN] size of string segment in characters.

Return Value:

        TRUE  - Success.
--*/
    unsigned short base = 16; //guid numbers are in hex
    *n = 0;

    while(number-- > 0) {
        int t;

        if (*pString >= '0' && *pString <= '9') {
            t = *pString++ - '0';
        }
        else if (*pString >= 'A' && *pString <= 'F') {
            t = (*pString++ - 'A') + 10;
        }
        else if (*pString >= 'a' && *pString <= 'f') {
            t = (*pString++ - 'a') + 10;
        }
        else return FALSE;

        *n = (*n * base) + t;
    }

    return TRUE;
}

BOOL
ConvertStringToGuid(
    const char *pString,
    GUID *pGuid
    )
{

/*++

Routine Description:

        Converts a string in the form found in _declspec(uuid(GUID)) to a GUID.
        Braces around guid are acceptable and are striped before processing.

Arguments:

        pString - [IN] ptr to the string that represents the guid.
        pGuid   - [OUT] ptr to the new guid.

Return Value:

        TRUE    - Success.
--*/

    DWORD t;
    unsigned int c;
    unsigned int guidlength = 36;
    char tString[37]; //guidlength + 1

    t = strlen(pString);
    if (guidlength + 2 == t) {
        //string is surounded with braces
        //check for braces and chop
        if (pString[0] != '{' || pString[guidlength + 1] != '}') return FALSE;
        memcpy(tString, pString + 1, guidlength);
        tString[guidlength] = '\0';
        pString = tString;
    }

    else if (t != guidlength) return FALSE;

    if (!ConvertGuidCharToInt(pString, &t, 8)) return FALSE;
    pString += 8;
    pGuid->Data1 = t;
    if (*pString++ != '-') return FALSE;

    if (!ConvertGuidCharToInt(pString, &t, 4)) return FALSE;
    pString += 4;
    pGuid->Data2 = (unsigned short)t;
    if (*pString++ != '-') return FALSE;

    if (!ConvertGuidCharToInt(pString, &t, 4)) return FALSE;
    pString += 4;
    pGuid->Data3 = (unsigned short)t;
    if (*pString++ != '-') return FALSE;

    for(c = 0; c < 8; c++) {
        if (!ConvertGuidCharToInt(pString, &t, 2)) return FALSE;
        pString += 2;
        pGuid->Data4[c] = (unsigned char)t;
        if (c == 1)
            if (*pString++ != '-') return FALSE;
    }

    return TRUE;
}

BOOL
IsDefinedPointerDependent(
    char *pName
    )
{
/*++

Routine Description:

        Determines if a typename is inharenty pointer size dependent.
        The user is expected to check pointers and derived types.

Arguments:

        pName   - [IN] Type to check.

Return Value:

        TRUE    - Type is pointer size dependent.
--*/
    if (NULL == pName) return FALSE;
    if (strcmp(pName, "INT_PTR") == 0) return TRUE;
    if (strcmp(pName, "UINT_PTR") == 0) return TRUE;
    if (strcmp(pName, "HALF_PTR") == 0) return TRUE;
    if (strcmp(pName, "UHALF_PTR") == 0) return TRUE;
    if (strcmp(pName, "LONG_PTR") == 0) return TRUE;
    if (strcmp(pName, "ULONG_PTR") == 0) return TRUE;
    if (strcmp(pName, "__int64") == 0) return TRUE;
    if (strcmp(pName, "_int64") == 0) return TRUE;
    return FALSE;
}

PCHAR
IsDefinedPtrToPtrDependent(
    IN char *pName
    )
/*++

Routine Description:

        Determines if a typename is inharenty a pointer to a pointer
        dependent type. The user is expected to check pointers to pointers and derived types.
        All of these types have an indirection level of 1.

Arguments:

        pName   - [IN] Type to check.

Return Value:

        Pointer to the name of the indirection of this type.
--*/
{
   if (*pName != 'P') return NULL;
   if (strcmp(pName, "PINT_PTR") == 0) return "INT_PTR";
   if (strcmp(pName, "PUINT_PTR") == 0) return "UINT_PTR";
   if (strcmp(pName, "PHALF_PTR") == 0) return "HALF_PTR";
   if (strcmp(pName, "PUHALF_PTR") == 0) return "UHALF_PTR";
   if (strcmp(pName, "PLONG_PTR") == 0) return "LONG_PTR";
   if (strcmp(pName, "PULONG_PTR") == 0) return "ULONG_PTR";
   return NULL;
}

static HANDLE hFile = INVALID_HANDLE_VALUE;
static HANDLE hMapFile = NULL;
static void  *pvMappedBase = NULL;

BOOL
ClosePpmFile(
   BOOL bExitFailure
   )
{
/*++

Routine Description:

        Closes the opened ppm file.

Arguments:

        bExitFailure - [IN] Terminate program on error

Return Value:

        Error        - FALSE
        Success      - TRUE

--*/

   if (NULL != pvMappedBase) {
      if(!UnmapViewOfFile(pvMappedBase)) {
         if (bExitFailure) {
            ErrMsg("ClosePpmFile: Unable to unmap ppm file, error %u\n", GetLastError());
            ExitErrMsg(FALSE, _strerror(NULL));
         }
         return FALSE;
      }
      pvMappedBase = NULL;
   }
   if (NULL != hMapFile) {
      if(!CloseHandle(hMapFile)) {
         if (bExitFailure) {
            ErrMsg("ClosePpmFile: Unable to close ppm file, error %u\n", GetLastError());
            ExitErrMsg(FALSE, _strerror(NULL));
         }
         return FALSE;
      }
      hMapFile = NULL;
   }
   if (INVALID_HANDLE_VALUE != hFile) {
      if(!CloseHandle(hFile)) {
         if (bExitFailure) {
            ErrMsg("ClosePpmFile: Unable to close ppm file, error %u\n", GetLastError());
            ExitErrMsg(FALSE, _strerror(NULL));
         }
         return FALSE;
      }
      hFile = INVALID_HANDLE_VALUE;
   }
   return TRUE;
}

PCVMHEAPHEADER
MapPpmFile(
   char *sPpmfile,
   BOOL bExitFailure
   )
{

/*++

Routine Description:

       Opens a Ppm file and maps it.

Arguments:

        pName        - [IN] Name of the file to map.
        bExitFailure - [IN] Terminate program on error

Return Value:

        Error        - NULL
        Success      - Pointer to the VCVMHEAPHEADER

--*/
   void  *pvBaseAddress;
   DWORD  dwBytesRead;
   BOOL   fSuccess;
   ULONG Version;
   DWORD dwErrorNo;

   PCVMHEAPHEADER pHeader;

   hFile = CreateFile(sPpmfile,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      0,
                      NULL
                      );

   if (hFile == INVALID_HANDLE_VALUE) {
       if (!bExitFailure) goto fail;
       ErrMsg("MapPpmFile: Unable to open %s, error %u\n", sPpmfile, GetLastError());
       ExitErrMsg(FALSE, _strerror(NULL));
   }

   fSuccess = ReadFile(hFile,
                       &Version,
                       sizeof(ULONG),
                       &dwBytesRead,
                       NULL
                       );

   if (! fSuccess || dwBytesRead != sizeof(ULONG)) {
       if (!bExitFailure) goto fail;
       ErrMsg("MapPpmFile: Unable to read version for %s, error %u\n", sPpmfile, GetLastError());
       ExitErrMsg(FALSE, _strerror(NULL));
   }

   if (Version != VM_TOOL_VERSION) {
       //SetLastError(ERROR_BAD_DATABASE_VERSION);
       if (!bExitFailure) goto fail;
       ExitErrMsg(FALSE, "MapPpmFile: Ppm file file has version %x, expect %x\n", Version, VM_TOOL_VERSION);
   }

#if _WIN64
   // Read and skip the padding between the version and the base
   fSuccess = ReadFile(hFile,
                       &Version,
                       sizeof(ULONG),
                       &dwBytesRead,
                       NULL
                       );

   if (! fSuccess || dwBytesRead != sizeof(ULONG)) {
       if (!bExitFailure) goto fail;
       ErrMsg("MapPpmFile: Unable to read version for %s, error %u\n", sPpmfile, GetLastError());
       ExitErrMsg(FALSE, _strerror(NULL));
   }

#endif


   fSuccess = ReadFile(hFile,
                       &pvBaseAddress,
                       sizeof(pvBaseAddress),
                       &dwBytesRead,
                       NULL
                       );

   if (! fSuccess || dwBytesRead != sizeof(pvBaseAddress)) {
       if (!bExitFailure) goto fail;
       ExitErrMsg(FALSE, "MapPpmFile: Unable to read base address of ppm file %s, error %u\n", sPpmfile, GetLastError());
   }


   hMapFile = CreateFileMapping(hFile, NULL, PAGE_READONLY, 0, 0,NULL);
   if (!hMapFile) {
       if (!bExitFailure) goto fail;
       ExitErrMsg(FALSE, "MapPpmfile: Unable to map %s, error %u\n", sPpmfile, GetLastError());
   }

   pvMappedBase = MapViewOfFileEx(hMapFile, FILE_MAP_READ, 0, 0, 0, pvBaseAddress);
   if (! pvMappedBase || pvMappedBase != pvBaseAddress) {
       // If the file can't be mapped at the expected base, we must fail
       // since the memory is chock full o' pointers.
       if (!bExitFailure) goto fail;
       ExitErrMsg(FALSE, "MapPpmFile: Unable to map view of %s, error %u\n", sPpmfile, GetLastError());
   }

   NIL = &((PCVMHEAPHEADER)pvMappedBase)->NIL;
   return (PCVMHEAPHEADER)pvMappedBase;

fail:

   dwErrorNo = GetLastError();
   ClosePpmFile(FALSE);
   SetLastError(dwErrorNo);
   return NULL;

}

char szHOSTPTR32[] = "/* 64 bit ptr */ unsigned _int64";
char szHOSTPTR64[] = "/* 32 bit ptr */ unsigned _int32";

char *GetHostPointerName(BOOL bIsPtr64) {
   if (bIsPtr64)
      return szHOSTPTR32;
   else
      return szHOSTPTR64;
}

char szHOSTUSIZE8[] = "unsigned _int8";
char szHOSTUSIZE16[] = "unsigned _int16";
char szHOSTUSIZE32[] = "unsigned _int32";
char szHOSTUSIZE64[] = "unsigned _int64";
char szHOSTSIZE8[] = "_int8";
char szHOSTSIZE16[] = "_int16";
char szHOSTSIZE32[] = "_int32";
char szHOSTSIZE64[] = "_int64";
char szHOSTSIZEGUID[] = "struct _GUID";

char *GetHostBasicTypeName(PKNOWNTYPES pkt) {

   DWORD dwSize;

   if (pkt->Flags & BTI_ISARRAY)
      dwSize = pkt->dwBaseSize;
   else
      dwSize = pkt->Size;

   if (pkt->Flags & BTI_UNSIGNED) {
      switch(pkt->Size) {
         case 1:
             return szHOSTUSIZE8;
         case 2:
             return szHOSTUSIZE16;
         case 4:
             return szHOSTUSIZE32;
         case 8:
             return szHOSTUSIZE64;
         default:
             ExitErrMsg(FALSE, "Unknown type size of %d for type %s.\n", pkt->Size, pkt->TypeName);
      }
   }
   else {
      switch(pkt->Size) {
         case 0:
             return szVOID;
         case 1:
             return szHOSTSIZE8;
         case 2:
             return szHOSTSIZE16;
         case 4:
             return szHOSTSIZE32;
         case 8:
             return szHOSTSIZE64;
         case 16:
             return szHOSTSIZEGUID;
         default:
             ExitErrMsg(FALSE, "Unknown type size of %d for type %s.\n", pkt->Size, pkt->TypeName);
      }
   }
}

char *GetHostTypeName(PKNOWNTYPES pkt, char *pBuffer) {
   if (pkt->IndLevel > 0) {
      strcpy(pBuffer, GetHostPointerName(pkt->Flags & BTI_PTR64));
   }
   else if(!(BTI_NOTDERIVED & pkt->Flags)) {
      if (strcmp(pkt->BaseName, "enum") == 0) {
         strcpy(pBuffer, szHOSTSIZE32);
      }
      else if (strcmp(pkt->BaseName, "union") == 0 ||
               strcmp(pkt->BaseName, "struct") == 0) {
         strcpy(pBuffer, pkt->BaseName);
         strcat(pBuffer, " NT32");
         strcat(pBuffer, pkt->TypeName);
      }
      else {
         strcpy(pBuffer, "NT32");
         strcat(pBuffer, pkt->TypeName);
      }
   }
   else {
      strcpy(pBuffer, GetHostBasicTypeName(pkt));
   }
   return pBuffer;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\tools\sortpp\sortpp.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    sortpp.c

Abstract:

    This program parses the file winincs.pp and generates a .PPM file
    compatible with GENTHNK.

Author:

    08-Jul-1995 JonLe

Revision History:

    27-Nov-1996 BarryBo -- code cleanup and documentation
    20-Mar-1998 mzoran  -- Added support for finding COM interfaces

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <assert.h>
#include "gen.h"

// string to put in front of all error messages so that BUILD can find them.
const char *ErrMsgPrefix = "NMAKE :  U8604: 'SORTPP' ";

FILE *fpHeaders;
int StatementLineNumber;
char SourceFileName[MAX_PATH+1];
int  SourceLineNumber;
int TypeId = 0;

void DumpLexerOutput(int FirstToken);

//
// packing size as specified by /Zp option to the CL command
//
#define DEFAULTPACKINGSIZE 8

DWORD dwPackingCurrent = DEFAULTPACKINGSIZE;

typedef struct _packholder {
    struct _packholder *ppackholderNext;
    DWORD dwPacking;
    char sIdentifier[1];
    } PACKHOLDER;

PACKHOLDER *ppackholderHead = NULL;

struct TypeInfoListElement {
    struct TypeInfoListElement *pNext;
    TYPESINFO *pTypeInfo;
};

typedef struct TypeInfoListElement *PTYPEINFOELEMENT;

PKNOWNTYPES NIL;    // for red-black trees
PRBTREE FuncsList;
PRBTREE StructsList;
PRBTREE TypeDefsList;
RBTREE _VarsList;
PRBTREE VarsList = &_VarsList; // Used to track global variable declarations.
                               // Should not appear in the PPM file

char Headers[MAX_PATH+1];
char ppmName[MAX_PATH+1];

HANDLE hCvmHeap;
ULONG uBaseAddress = 0x30000000;
ULONG uReserveSize = 0x01800000;

BOOL bLine = FALSE;
char szThis[] = "This";

DWORD dwScopeLevel = 0;

void ExtractDerivedTypes(void);
BOOL LexNextStatement(void);
BOOL ParseFuncTypes(PTYPESINFO pTypesInfo, BOOL fDllImport);
BOOL ParseStructTypes(PTYPESINFO pTypesInfo);
BOOL ParseTypeDefs(PTYPESINFO pTypesInfo);
BOOL ParseVariables(VOID);
BOOL ParseGuid(GUID *pGuid);
BOOL AddDefaultDerivedTypes(void);
PKNOWNTYPES AddNewType(PTYPESINFO pTypesInfo, PRBTREE pTypesList);
BOOL CopyStructMembers(PTYPESINFO pTypesInfo, BOOL bUnion, PKNOWNTYPES pBaseType);
BOOL CopyEnumMembers(PTYPESINFO);
int CreatePseudoName(char *pDst, char *pSrc);
BOOL GetArrayIndex(DWORD *pdw);
LONGLONG expr(void);
LONGLONG expr_a1(void);
LONGLONG expr_a(void);
LONGLONG expr_b(void);
LONGLONG expr_c(void);
void CheckUpdateTypedefSizes(PTYPESINFO ptypesinfo);
PVOID SortppAllocCvm(ULONG Size);
BOOL WritePpmFile(char *PpmName);
void BumpStructUnionSize(DWORD *pdwSize, DWORD dwElemSize, BOOL bUnion);
BOOL GetExistingType(PTYPESINFO pTypesInfo, PBOOL pbFnPtr, PKNOWNTYPES *ppKnownTypes);
BOOL PrepareMappedMemory(void);
DWORD PackPaddingSize(DWORD dwCurrentSize, DWORD dwBase);
void PackPush(char *sIdentifier);
DWORD PackPop(char *sIdentifier);
BOOL ConsumeDeclSpecOpt(BOOL IsFunc, BOOL bInitReturns, BOOL *pIsDllImport, BOOL *pIsGuidDefined, GUID *pGuid);
TOKENTYPE ConsumeDirectionOpt(void);
TOKENTYPE ConsumeConstVolatileOpt(void);
PTYPEINFOELEMENT TypeInfoElementAllocateLink(PTYPEINFOELEMENT *ppHead, PTYPEINFOELEMENT pThis, TYPESINFO *pType);
VOID UpdateGuids(VOID);
BOOL AddVariable(char *Name, GUID * pGuid);
VOID GenerateProxy(char *pName, PTYPESINFO pTypesInfo);
VOID FreeTypeInfoList(PTYPEINFOELEMENT pThis);
PMEMBERINFO CatMeminfo(BUFALLOCINFO *pBufallocinfo, PMEMBERINFO pHead, PMEMBERINFO pTail, DWORD dwOffset, BOOL bStatus);
BOOL ConsumeExternC(void);

//
// PPC compiler is screwing up the Initializa list head macro !
//
#if defined (_PPC_)
#undef InitializeListHead
#define InitializeListHead(ListHead) ( (ListHead)->Flink = (ListHead), \
                                       (ListHead)->Blink = (ListHead) \
                                      )
#endif


_inline void
PackModify(
    DWORD dw
)
{
    dwPackingCurrent = dw;
    DbgPrintf("new packing is %x\n", dw);
}

_inline DWORD
PackCurrentPacking(
    void
)
{
    return dwPackingCurrent;
}

DWORD PackPaddingSize(DWORD dwCurrentSize, DWORD dwBase)
{
    DWORD dw;

    if (dwCurrentSize == 0) {
        return 0;                   // no padding for first member
    }

    if (dwBase == 0) {
        dwBase = SIZEOFPOINTER;
    }                               // if no base size yet then must be a ptr

                                    // base is min(size, packing)
    if (dwBase > PackCurrentPacking()) {
        dwBase = PackCurrentPacking();
    }

                                    // figure out padding
    return (dwBase - (dwCurrentSize % dwBase)) % dwBase;
}

_inline DWORD PackPackingSize(DWORD dwCurrentSize, DWORD dwSize,
                              DWORD dwBase)
{
                                    // round up to nearest dwBase
    return PackPaddingSize(dwCurrentSize, dwBase) + dwSize;
}



/* main
 *
 * standard win32 base windows entry point
 * returns 0 for clean exit, otherwise nonzero for error
 *
 *
 * ExitCode:
 *  0       - Clean exit with no Errors
 *  nonzero - error ocurred
 *
 */
int __cdecl main(int argc, char **argv)
{
    int      i;
    char *pHeaders = NULL;
    char *pch;
    DWORD LenHeaders=0;

    SetConsoleCtrlHandler(ConsoleControlHandler, TRUE);

    try {

        /*
         *  Get cmd line args.
         */
        i = 0;
        while (++i < argc)  {
            pch = argv[i];
            if (*pch == '-' || *pch == '/') {
                pch++;
                switch (toupper(*pch)) {
                case 'D':     // debug forces extra check
                    bDebug = TRUE;
                    setvbuf(stderr, NULL, _IONBF, 0);
                    break;

                case 'L':
                    bLine = TRUE;
                    break;

                case 'M':    // ppm output filename
                    strcpy(ppmName, ++pch);
                    DeleteFile(ppmName);
                    break;

                 case 'B':   // gBaseAddress
                     pch++;
                     uBaseAddress = atoi(pch);
                     break;

                 case 'R':   // Reserve size
                     pch++;
                     uReserveSize = atoi(pch);
                     break;

                 case '?':   // usage
                     ExitErrMsg(FALSE,
                     "sortpp -d -l -w -m<ppm file> -b<Base addr> -r<reserved> <pp file>\n");

                 default:
                     ExitErrMsg(FALSE, "Unrecognized option %s\n", pch);
                 }
            } else if (*pch) {
               strcpy(Headers, pch);
            }
        }

        if (!*Headers) {
            ExitErrMsg(FALSE, "no Headers file name\n");
        }

        if (!*ppmName) {
          ExitErrMsg(FALSE, "no -m<PPM filename>\n");
        }


        DbgPrintf("%s -> %s\n", Headers, ppmName);


        if (!PrepareMappedMemory()) {
            ExitErrMsg(FALSE, "Problem in PrepareMappedMemory %s, gle = %d\n",
                                                  Headers, GetLastError());
        }

        RBInitTree(FuncsList);
        RBInitTree(StructsList);
        RBInitTree(TypeDefsList);
        RBInitTree(VarsList);  //not in the PPM file

        fpHeaders = fopen(Headers, "r");

        if (fpHeaders == NULL) {
            ExitErrMsg(FALSE, "Headers open '%s' errno=%d\n", Headers, errno);
        }

        if (!AddDefaultDerivedTypes()) {
            ExitErrMsg(TRUE, "AddDefaultDerivedTypes failed\n");
        }

        // pull out the different types: structs, typedefs function prototypes
        ExtractDerivedTypes();

        // Attempt to update guids for structs that don't have them
        UpdateGuids();

        if (!WritePpmFile(ppmName)) {
            ExitErrMsg(FALSE, "Problem in WritePpmFile gle = %d\n", GetLastError());
        }

    } except(EXCEPTION_EXECUTE_HANDLER) {
        ExitErrMsg(FALSE,
                   "sortpp: ExceptionCode=%x\n",
                   GetExceptionCode()
                   );
    }

    DeleteAllocCvmHeap(hCvmHeap);

    return 0;
}



BOOL
AddDefaultDerivedTypes(
    void
    )
/*++

Routine Description:

    Add signed, unsigned to TypeDefsList.  Treated as derived types
    based on int.

Arguments:

    None.

Return Value:

    TRUE on success, FALSE on failure (probably out-of-memory)

--*/
{
    TYPESINFO TypesInfo;
    PFUNCINFO funcinfo;

    memset(&TypesInfo, 0, sizeof(TYPESINFO));

    strcpy(TypesInfo.BasicType,szINT);
    strcpy(TypesInfo.BaseName,szINT);
    strcpy(TypesInfo.TypeName,szINT);
    TypesInfo.Size = sizeof(int);
    TypesInfo.iPackSize = sizeof(int);
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"unsigned int");
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"short int");
    TypesInfo.Size = sizeof(short int);
    TypesInfo.iPackSize = sizeof(short int);
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"unsigned short int");
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"long int");
    TypesInfo.Size = sizeof(long int);
    TypesInfo.iPackSize = sizeof(long int);
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"unsigned long int");
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szCHAR);
    strcpy(TypesInfo.BaseName,szCHAR);
    strcpy(TypesInfo.TypeName,szCHAR);
    TypesInfo.Size = sizeof(char);
    TypesInfo.iPackSize = sizeof(char);
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,szUNSIGNEDCHAR);
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szINT64);
    strcpy(TypesInfo.BaseName,szINT64);
    strcpy(TypesInfo.TypeName,szINT64);
    TypesInfo.Size = sizeof(__int64);
    TypesInfo.iPackSize = sizeof(__int64);
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_INT64DEP | BTI_POINTERDEP;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"unsigned _int64");
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED | BTI_INT64DEP | BTI_POINTERDEP;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,sz_INT64);
    strcpy(TypesInfo.BaseName,sz_INT64);
    strcpy(TypesInfo.TypeName,sz_INT64);
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_INT64DEP | BTI_POINTERDEP;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.TypeName,"unsigned __int64");
    TypesInfo.Flags = BTI_NOTDERIVED | BTI_UNSIGNED | BTI_INT64DEP | BTI_POINTERDEP;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szDOUBLE);
    strcpy(TypesInfo.BaseName,szDOUBLE);
    strcpy(TypesInfo.TypeName,szDOUBLE);
    TypesInfo.Size = sizeof(double);
    TypesInfo.iPackSize = sizeof(double);
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szFLOAT);
    strcpy(TypesInfo.BaseName,szFLOAT);
    strcpy(TypesInfo.TypeName,szFLOAT);
    TypesInfo.Size = sizeof(float);
    TypesInfo.iPackSize = sizeof(float);
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szVOID);
    strcpy(TypesInfo.BaseName,szVOID);
    strcpy(TypesInfo.TypeName,szVOID);
    TypesInfo.Size = 0;
    TypesInfo.iPackSize = 0;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szGUID);
    strcpy(TypesInfo.BaseName,szGUID);
    strcpy(TypesInfo.TypeName,szGUID);
    TypesInfo.Size = 16;
    TypesInfo.iPackSize = 16;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    strcpy(TypesInfo.BasicType,szFUNC);
    strcpy(TypesInfo.BaseName,szFUNC);
    strcpy(TypesInfo.TypeName,szFUNC);
    TypesInfo.Flags = BTI_CONTAINSFUNCPTR | BTI_NOTDERIVED;
    TypesInfo.Size = 4;
    TypesInfo.iPackSize = 4;
    TypesInfo.dwMemberSize = sizeof(FUNCINFO)+strlen(szVOID)+1;
    TypesInfo.TypeKind = TypeKindFunc;
    funcinfo = (PFUNCINFO)TypesInfo.Members;
    TypesInfo.pfuncinfo = funcinfo;
    funcinfo->sType = TypesInfo.Members + sizeof(FUNCINFO);
    strcpy(funcinfo->sType, szVOID);
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    TypesInfo.dwMemberSize = 0;
    TypesInfo.Flags = BTI_NOTDERIVED;
    TypesInfo.TypeKind = TypeKindEmpty;
    TypesInfo.pfuncinfo = NULL;
    memset(TypesInfo.Members, 0, sizeof(TypesInfo.Members));

    strcpy(TypesInfo.BasicType,szVARGS);
    strcpy(TypesInfo.BaseName,szVARGS);
    strcpy(TypesInfo.TypeName,szVARGS);
    TypesInfo.Size = 0;               // varargs has size of 0
    TypesInfo.iPackSize = 0;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    // Generic pointer type.  Not generated by sortpp, but used by genthnk
    strcpy(TypesInfo.BasicType, "*");
    strcpy(TypesInfo.BaseName, "*");
    strcpy(TypesInfo.TypeName, "*");
    TypesInfo.IndLevel = 1;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    // Generic struct type.  Not generated by sortpp, but used by genthnk
    strcpy(TypesInfo.BasicType, "struct");
    strcpy(TypesInfo.BaseName, "struct");
    strcpy(TypesInfo.TypeName, "struct");
    TypesInfo.IndLevel = 0;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    // Generic union type.  Not generated by sortpp, but used by genthnk
    strcpy(TypesInfo.BasicType, "union");
    strcpy(TypesInfo.BaseName, "union");
    strcpy(TypesInfo.TypeName, "union");
    TypesInfo.IndLevel = 0;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    // Default type that matches all types.  Not generated by sortpp, but used by genthnk
    strcpy(TypesInfo.BasicType, "default");
    strcpy(TypesInfo.BaseName, "default");
    strcpy(TypesInfo.TypeName, "default");
    TypesInfo.IndLevel = 0;
    TypesInfo.Flags = BTI_NOTDERIVED;
    if (!AddToTypesList(TypeDefsList, &TypesInfo)) {
        return FALSE;
    }

    return TRUE;
}

BOOL
ConsumeExternC(
    void
    )
{

/*++

Routine Description:

    Consumes an extern or an extern "C".

Arguments:

    None.

Return Value:

    TRUE - extern or extern "C" was consumed.

--*/

    PTOKEN Token;
    Token = CurrentToken();
    if (Token->TokenType == TK_EXTERN) {
        ConsumeToken();
        Token = CurrentToken();
        if (Token->TokenType == TK_STRING &&
            strcmp(Token->Name, "C") == 0)
            ConsumeToken();
        return TRUE;
    }
    return FALSE;
}

void
ExtractDerivedTypes(
    void
    )

/*++

Routine Description:

    Removes derived type definitions from headers, building the
    TypesDef, Structs, and Funcs lists.

Arguments:

    None.

Return Value:

    None.

--*/
{
    TYPESINFO TypesInfo;
    PRBTREE pListHead;
    BOOL fDllImport;

    //
    // Lex in entire C-language statements, then parse them.  Stops at EOF.
    //
    while (LexNextStatement()) {

        int OldTokenIndex;
        int c;

        if (bDebug) {
            DumpLexerOutput(0);
        }

        if (bLine) {
            for(c=80; c > 0; c--)
                fputc('\b', stderr);
            c = fprintf(stderr, "Status: %s(%d)", SourceFileName, StatementLineNumber);
            for(; c < 78; c++)
                fputc(' ', stderr);
            fflush(stderr);
        }

        pListHead = NULL;
        assert(dwScopeLevel == 0);

        if (CurrentToken()->TokenType == TK_EOS) {

            //ddraw.h has an extra ; at the end of an extern "C" block
            continue;

        }

        ConsumeExternC();

        ConsumeDeclSpecOpt(TRUE, TRUE, &fDllImport, NULL, NULL);

        ConsumeExternC();

        OldTokenIndex = CurrentTokenIndex;
        //
        // Try to parse as a TypeDef.
        //
        if (ParseTypeDefs(&TypesInfo)) {
            //
            // Got a typedef
            //
            if (CurrentToken()->TokenType == TK_EOS) {
                pListHead = TypeDefsList;
                goto DoAddNewType;
            }
        }

        //
        // Failed to parse as TypeDef.  Try to parse as a struct/union/enum
        //
        CurrentTokenIndex = OldTokenIndex;
        if (ParseStructTypes(&TypesInfo)) {
            //
            // got a struct definition
            //
            if (CurrentToken()->TokenType == TK_EOS) {
                pListHead = StructsList;
                goto DoAddNewType;
            }
        }

        //
        // Failed to parse as struct/union/enum.  Try to parse as function
        //
        CurrentTokenIndex = OldTokenIndex;
        if (ParseFuncTypes(&TypesInfo, fDllImport)) {
            //
            // got a function prototype
            //
            if (CurrentToken()->TokenType == TK_EOS && !TypesInfo.IndLevel) {
                pListHead = FuncsList;
                goto DoAddNewType;
            }
        }

        CurrentTokenIndex = OldTokenIndex;
        if (ParseVariables()) continue;

        CurrentTokenIndex = OldTokenIndex;

DoAddNewType:
        if (pListHead && !AddNewType(&TypesInfo, pListHead)) {
            ErrMsg("AddNewType fail\n");
        }

        if (CurrentToken()->TokenType != TK_EOS && bDebug) {

            fprintf(stderr, "Warning: Rejected %s(%d)\n", SourceFileName, StatementLineNumber);
            //
            // Use the 8k buffer in TypesInfo.Members to unlex the source stmt
            //
            UnlexToText(TypesInfo.Members,
                        sizeof(TypesInfo.Members),
                        0,
                        MAX_TOKENS_IN_STATEMENT);
            fprintf(stderr, "\t%s;\n", TypesInfo.Members);
        }
    }
}



PKNOWNTYPES
AddNewType(
    PTYPESINFO pTypesInfo,
    PRBTREE pTypesList
    )
/*++

Routine Description:

    Adds a new type to a types list.

Arguments:

    pTypesInfo  -- type to add
    pTypesList  -- list to add the type to

Return Value:

    Returns a pointer to the KNOWNTYPES for the new type on success,
    NULL for error.

--*/
{
    PKNOWNTYPES pkt;
    PKNOWNTYPES pKnownTypes = NULL;
    PDEFBASICTYPES pdbt;
    ULONG Flags = 0;
    BOOL bRet = FALSE;

    if (((pTypesList == TypeDefsList) || (pTypesList == StructsList)) &&
        (((pTypesInfo->Size == 0) || (pTypesInfo->iPackSize == 0)) &&
        (*pTypesInfo->Members != 0))) {
        DbgPrintf("Added type with invalid size %s %s %s %d %d\n",
                     pTypesInfo->BasicType,
                     pTypesInfo->BaseName,
                     pTypesInfo->TypeName,
                     pTypesInfo->Size,
                     pTypesInfo->iPackSize);
    }

    pTypesInfo->TypeId = TypeId++;
    pTypesInfo->LineNumber = SourceLineNumber;
    pTypesInfo->dwScopeLevel = dwScopeLevel;
    pTypesInfo->dwCurrentPacking = PackCurrentPacking();
    if (strlen(SourceFileName) > sizeof(pTypesInfo->FileName) - 1)
        ExitErrMsg(FALSE, "Source file name is too large.\n");
    strcpy(pTypesInfo->FileName, SourceFileName);
    if (IsDefinedPointerDependent(pTypesInfo->TypeName))
       pTypesInfo->Flags |= BTI_POINTERDEP;

    //
    // Loop up the type and see if it is already in the list
    //
    pkt = GetNameFromTypesList(pTypesList, pTypesInfo->TypeName);
    if (pkt) {
//
// Uncomment the next line and comment the following line to change the
// behavior of this function. By doing this you will allow functions to be
// redefined in the following case: First a function that has no arguments
// is encountered and entered in the list. Later the same function is
// encountered with arguments and the new definition for it would override
// the old.
//      if ((pTypesList == StructsList) || (pTypesList == FuncsList)) {
        if (pTypesList == StructsList) {

            if (pTypesInfo->dwMemberSize == 0) {
                //
                // Since the struct has already been defined lets grab its
                // relevant size information.
                //
                pTypesInfo->IndLevel = pkt->IndLevel;
                pTypesInfo->Size = pkt->Size;
                pTypesInfo->iPackSize = pkt->iPackSize;
                pTypesInfo->TypeId = pkt->TypeId;
                return pkt;
            }

            if (! pkt->pmeminfo) {
                //
                // Find any previously defined typedefs that are based upon this
                // struct and fix their size.

                CheckUpdateTypedefSizes(pTypesInfo);
                ReplaceInTypesList(pkt, pTypesInfo);
                return pkt;
            }
        }
        else if (pkt->Flags & BTI_DISCARDABLE) {
            ReplaceInTypesList(pkt, pTypesInfo);
            return pkt;
        }
        //
        // else if it already exists, assume is the same
        //
        DbgPrintf("typedef: %s previously defined\n", pTypesInfo->TypeName);
        return pkt;
    }

    //
    // Type is not already listed.  Look up its basic type
    //
    pdbt = GetDefBasicType(pTypesInfo->BasicType);
    if (pdbt) {
       Flags = 0;
    } else {
        pkt = GetNameFromTypesList(pTypesList, pTypesInfo->BasicType);
        if (pkt) {
            Flags = pkt->Flags;
            pdbt = GetDefBasicType(pkt->BasicType);
            if (!pdbt) {
                ErrMsg("types Table corrupt %s\n", pkt->TypeName);
            }
        } else {
            ErrMsg("ant: unknown Basic Type %s\n", pTypesInfo->BasicType);
            goto ErrorExit;
        }
    }

    pTypesInfo->Flags |= Flags;
    strcpy(pTypesInfo->BasicType, pdbt->BasicType);
    pKnownTypes = AddToTypesList(pTypesList, pTypesInfo);
    if (pKnownTypes == NULL)
       goto ErrorExit;

    if (bDebug)
       DumpTypesInfo(pTypesInfo, stdout);

    return pKnownTypes;

ErrorExit:
    if (bDebug) {
        DumpTypesInfo(pTypesInfo, stdout);
    }


    DumpTypesInfo(pTypesInfo, stderr);
    return NULL;

}


void
CheckUpdateTypedefSizes(
    PTYPESINFO ptypesinfo
    )
/*++

Routine Description:

    We are about to replace an empty struct definition with one that has
    members and thus a size. We need to look through the typedefs list and
    see if any that have a size of 0 are defined from this new struct and if
    so then fix its size and packing size.

Arguments:

    ptypesinfo  -- struc definition with members

Return Value:

    None.

--*/
{
    PKNOWNTYPES pknwntyp, pkt;

    pknwntyp = TypeDefsList->pLastNodeInserted;

    while (pknwntyp) {
        if (pknwntyp->Size == 0) {
            pkt = GetBasicType(pknwntyp->TypeName, TypeDefsList, StructsList);
            if (pkt && ( ! strcmp(pkt->BasicType, szSTRUCT)) &&
                       ( ! strcmp(pkt->TypeName, ptypesinfo->TypeName))) {
                pknwntyp->Size = ptypesinfo->Size;
                pknwntyp->iPackSize = ptypesinfo->iPackSize;
                pknwntyp->Flags |= (ptypesinfo->Flags & BTI_CONTAINSFUNCPTR);
            }
        }
        pknwntyp = pknwntyp->Next;
    }
}


BOOL
GetExistingType(
    PTYPESINFO pTypesInfo,
    PBOOL pbFnPtr,
    PKNOWNTYPES *ppKnownTypes
    )
/*++

Routine Description:

    Gets an existing type from the lexer stream and returns the type
    information for it.

Arguments:

    pSrc        -- IN ptr to start of typename to look up
    pTypesInfo  -- Information of
    pbFnPtr     -- [OPTIONAL] OUT TRUE if the type is a pointer to a function
    ppKnownTypes-- [OPTIONAL] OUT KnownType infomation for this type if not a function pointer.

Return Value:

    FALSE if the name is not an existing type, or TRUE if the name is an
    existing type (CurrentToken ends up pointing at the token following the
    type).

--*/
{
    PKNOWNTYPES pKnownType;
    int OldCurrentTokenIndex = CurrentTokenIndex;

    if (bDebug) {
        fputs("GetExisting type called with the following lexer state:\n", stderr);
        DumpLexerOutput(CurrentTokenIndex);
    }
    memset(pTypesInfo, 0, sizeof(TYPESINFO));
    if (pbFnPtr) {
        *pbFnPtr = FALSE;
    }

    if (ParseStructTypes(pTypesInfo)) {
        if ((pKnownType = AddNewType(pTypesInfo, StructsList)) != NULL) {
            if (ppKnownTypes != NULL) *ppKnownTypes = pKnownType;
            return TRUE;
        } else {
            if (ppKnownTypes != NULL) *ppKnownTypes = NULL;
            return FALSE;
        }
    }

    CurrentTokenIndex = OldCurrentTokenIndex;
    if (pbFnPtr && ParseFuncTypes(pTypesInfo, FALSE)) {
        if (ppKnownTypes != NULL) *ppKnownTypes = NULL;
        *pbFnPtr = TRUE;
        return TRUE;
    }

    CurrentTokenIndex = OldCurrentTokenIndex;
    if (ParseTypes(TypeDefsList, pTypesInfo, &pKnownType)) {
        if (ppKnownTypes != NULL) *ppKnownTypes = pKnownType;
        return TRUE;
    }

    CurrentTokenIndex = OldCurrentTokenIndex;
    if (ParseTypes(StructsList, pTypesInfo, &pKnownType)) {
        if (ppKnownTypes != NULL) *ppKnownTypes = pKnownType;
        return TRUE;
    }

    return FALSE;
}


BOOL
ParseTypeDefs(
    PTYPESINFO pTypesInfo
    )
/*++

Routine Description:

    Parses a C-language statement if it is a 'typedef'.  Accepted syntaxes are:

    typedef <mod> type <indir> NewName<[]> <, <indir> NewName<[]>>
    typedef <mod> struct|enum|union <name> <indir> NewName <, <indir> NewName>
    typedef <mod> rtype <indir>(<modifiers * NewName ) ( <arg List>)

    (Note that we don't deal with extraneous parens very well)

Arguments:

    pTypesInfo  -- OUT ptr to info about the type

Return Value:

    TRUE if the statement is a typedef
    FALSE if the statement is not a typedef or some kind of error

--*/
{
    int IndLevel;
    BOOL bFnPtr = FALSE;
    TYPESINFO TypesInfo;
    DWORD dwSize;
    PKNOWNTYPES pKnownTypes = NULL;
    int i;
    int Flags;

    memset(pTypesInfo, 0, sizeof(TYPESINFO));

    if (CurrentToken()->TokenType == TK_DECLSPEC) {
        ConsumeDeclSpecOpt(FALSE, FALSE, NULL, NULL, NULL);
    }

    if (CurrentToken()->TokenType != TK_TYPEDEF) {
        //
        // Line doesn't start with 'typedef'
        //
        return FALSE;
    }
    ConsumeToken();

    if (CurrentToken()->TokenType == TK_STAR ||
        CurrentToken()->TokenType == TK_BITWISE_AND) {
        //
        // We have something like: 'typedef *foo;'.  This happens if a
        // .IDL file has a bogus typedef.  MIDL just omits the typename
        // if it isn't recognized.  Fake up a TypesInfo for 'int'.
        //
        ConsumeToken();
        bFnPtr = FALSE;
        memset(&TypesInfo, 0, sizeof(TypesInfo));
        strcpy(TypesInfo.BasicType,szINT);
        strcpy(TypesInfo.BaseName,szINT);
        strcpy(TypesInfo.TypeName,szINT);
        TypesInfo.Size = sizeof(int);
        TypesInfo.iPackSize = sizeof(int);
    } else {
        if (IsTokenSeparator() && CurrentToken()->TokenType != TK_LPAREN) {
            //
            // Text after 'typedef' doesn't start with anything plausible.
            //
            return FALSE;
        }

        ConsumeDeclSpecOpt(FALSE, FALSE, NULL, NULL, NULL);
        ConsumeConstVolatileOpt();
        if (!GetExistingType(&TypesInfo, &bFnPtr, &pKnownTypes)) {
            return FALSE;
        }
    }

    //
    // We now know the type.  Parse new type names derived from that type.
    //
    pTypesInfo->IndLevel = TypesInfo.IndLevel;
    pTypesInfo->Flags |= (TypesInfo.Flags & BTI_CONTAINSFUNCPTR);
    pTypesInfo->Flags |= (TypesInfo.Flags & BTI_POINTERDEP);
    pTypesInfo->Flags |= (TypesInfo.Flags & BTI_UNSIGNED);
    pTypesInfo->pTypedefBase = pKnownTypes;
    strcpy(pTypesInfo->BasicType, TypesInfo.BasicType);
    strcpy(pTypesInfo->TypeName, TypesInfo.TypeName);

    if (bFnPtr) {
        //
        // The type is a pointer to a function
        //
        pTypesInfo->Flags |= BTI_CONTAINSFUNCPTR;
        strcpy(pTypesInfo->BaseName, TypesInfo.BaseName);
        strcpy(pTypesInfo->FuncRet, TypesInfo.FuncRet);
        strcpy(pTypesInfo->FuncMod, TypesInfo.FuncMod);
        pTypesInfo->Size = SIZEOFPOINTER;
        pTypesInfo->iPackSize = SIZEOFPOINTER;
        pTypesInfo->dwMemberSize = TypesInfo.dwMemberSize;
        pTypesInfo->TypeKind = TypesInfo.TypeKind;
        memcpy(pTypesInfo->Members, TypesInfo.Members, sizeof(TypesInfo.Members));
        pTypesInfo->pfuncinfo = RelocateTypesInfo(pTypesInfo->Members,
                                                  &TypesInfo);
        return TRUE;
    }

    if (CurrentToken()->TokenType == TK_EOS) {
        return FALSE;
    }

    strcpy(pTypesInfo->BaseName, TypesInfo.TypeName);
    *pTypesInfo->TypeName = '\0';

    // don't handle extraneous parens.
    i = CurrentTokenIndex;
    while (CurrentToken()->TokenType != TK_EOS) {
        if (CurrentToken()->TokenType == TK_LPAREN) {
            return FALSE;
        }
        ConsumeToken();
    }
    CurrentTokenIndex = i;

    IndLevel = pTypesInfo->IndLevel;
    Flags = pTypesInfo->Flags;

    for (;;) {
        pTypesInfo->IndLevel = IndLevel;
        pTypesInfo->iPackSize = TypesInfo.iPackSize;
        pTypesInfo->Flags = Flags;
        dwSize = TypesInfo.Size;

        //
        // Skip 'const' keyword, if present.
        //
        if (CurrentToken()->TokenType == TK_CONST) {
            ConsumeToken();
        }

        //
        // Handle pointers to the base type
        //
        if (IsTokenSeparator() &&
            CurrentToken()->TokenType != TK_STAR &&
            CurrentToken()->TokenType != TK_BITWISE_AND) {
            return FALSE;
        }
        ParseIndirection(&pTypesInfo->IndLevel,
                         &dwSize,
                         &pTypesInfo->Flags,
                         NULL,
                         NULL);

        // This is a hack for the busted way that sortpp parses
        // data.   New types do not inherit the pointer size
        // properly.   We also can't inherit it at the top
        // since this might be a pointer to a pointer.  So what
        // we do is try to parse this as a pointer, and if the IndLevel
        // increases we know this is a pointer so do nothing.  If the IndLevel
        // doesn't increase, this is not a pointer so inherite the pointer attributes
        // from the parent.

        ASSERT(pTypesInfo->IndLevel >= IndLevel);
        if (pTypesInfo->IndLevel == IndLevel) {
            // inherite is ptr64 attribute from the base type.
            pTypesInfo->Flags |= (TypesInfo.Flags & BTI_PTR64);
        }

        if (CurrentToken()->TokenType != TK_IDENTIFIER) {
            return FALSE;
        }

        //
        // Get the name of the new typedef
        //
        if (CopyToken(pTypesInfo->TypeName,
                      CurrentToken()->Name,
                      sizeof(pTypesInfo->TypeName)-1
                      )
               >= sizeof(pTypesInfo->TypeName)) {
            return FALSE;
        }
        ConsumeToken();

        //
        // Handle an array of the type
        //
        while (CurrentToken()->TokenType == TK_LSQUARE) {
            DWORD dwIndex;

            if (!GetArrayIndex(&dwIndex)) {
                return FALSE;
            }

            if (dwIndex == 0) {          // a[] is really *a
                pTypesInfo->IndLevel++;
            } else {
                pTypesInfo->Flags |= BTI_ISARRAY;
                pTypesInfo->dwArrayElements = dwIndex;
                pTypesInfo->dwBaseSize = dwSize;
                dwSize = dwSize * dwIndex;
            }
        }

        if (pTypesInfo->IndLevel) {
            if (pTypesInfo->Flags & BTI_PTR64) {
                pTypesInfo->Size = SIZEOFPOINTER64;
                pTypesInfo->iPackSize = SIZEOFPOINTER64;
            } else {
                pTypesInfo->Size = SIZEOFPOINTER;
                pTypesInfo->iPackSize = SIZEOFPOINTER;
            }
            pTypesInfo->Flags |= BTI_POINTERDEP;
        } else {
            pTypesInfo->Size = dwSize;
        }

        switch (CurrentToken()->TokenType) {
        case TK_EOS:
            return TRUE;

        case TK_COMMA:
            //
            // There is a list of types derived from the base type
            // Add the current type in and loop to parse the next
            // type.
            //
            if (!AddNewType(pTypesInfo, TypeDefsList)) {
                return FALSE;
            }

            ConsumeToken(); // consume the ','
            break;

        default:
            return FALSE;
        }

    }

}



BOOL
ParseFuncTypes(
    PTYPESINFO pTypesInfo,
    BOOL fDllImport
    )
/*++

Routine Description:

    Parses a C-language statement if it is a function declaration:

    <mod> type <*> <mod> Name ( type <arg1>, type <arg2>, type <argn> )
    <mod> type <*> (<mod> * Name ) ( type <arg1>, type <arg2>, type <argn> )
    (Note that we don't deal with extraneous parens very well, and don't
     handle function pointers as return types.
     e.g. "void (*(*foo)(void))(void);" ).

Arguments:

    pTypesInfo  -- OUT ptr to info about the type
    fDllImport  -- TRUE if __declspec(dllimport) already consumed

Return Value:

    TRUE if the statement is a function declaration
    FALSE if the statement is not a function declaration or some kind of error

--*/
{
    char *pName;
    char *ps;
    char *pArgName;
    BOOL bFnPtr = FALSE;
    ULONG ArgNum = 0;
    int  IndLevel = 0;
    int  ArgIndLevel;
    int  Len;
    TYPESINFO ti;
    PFUNCINFO pfuncinfo;
    BUFALLOCINFO bufallocinfo;
    int  OldTokenIndex;
    char NoNameArg[32];
    PKNOWNTYPES pkt;

    memset(pTypesInfo, 0, sizeof(TYPESINFO));
    BufAllocInit(&bufallocinfo, pTypesInfo->Members, sizeof(pTypesInfo->Members), 0);
    pfuncinfo = NULL;


    if (fDllImport) {
        //
        // Declaration has __declspec(dllimport).  Genthnk should emit
        // __declspec(dllexport) in the function definition.
        //
        pTypesInfo->Flags |= BTI_DLLEXPORT;
    }

    // for functions, the first token is ret type
    if (IsTokenSeparator() && CurrentToken()->TokenType != TK_LPAREN) {
        //
        // First token isn't even an identifier - bail out.
        //
        return FALSE;
    }

    // There can be multiple __declspec's here - run through them all
    do {
        ConsumeDeclSpecOpt(TRUE, FALSE, &fDllImport, NULL, NULL);
    } while (CurrentToken()->TokenType == TK_DECLSPEC);

    //
    // Remember the index of the first token which describes the return type.
    //
    OldTokenIndex = CurrentTokenIndex;

    if (CurrentToken()->TokenType == TK_LPAREN) {
        // This is this start of a typedef (pfn)()
        //  where the pfn has an implecit return type of
        // int.
        strcpy(pTypesInfo->FuncRet, "int");
        goto ImplicitReturnType;
    }

    if (ConsumeDirectionOpt() != TK_NONE && bDebug) {
         // A struct element had a direction on it.  Ignore it and
         // warn the user.
         fprintf(stderr, "Warning: IN and OUT are ignored on function return types. %s line %d\n", SourceFileName, StatementLineNumber);
    }
    ConsumeConstVolatileOpt();
    if (!GetExistingType(&ti, NULL, NULL)) {
        ErrMsg("pft.rtype: unknown return type\n");
        DumpLexerOutput(OldTokenIndex);
        return FALSE;
    }

    // get indir for ret type
    ParseIndirection(&pTypesInfo->RetIndLevel, NULL, NULL, NULL, NULL);

    // Copy out ret type to FuncRet
    if (!UnlexToText(pTypesInfo->FuncRet, sizeof(pTypesInfo->FuncRet),
                     OldTokenIndex, CurrentTokenIndex)) {
        return FALSE;
    }

    ConsumeDeclSpecOpt(TRUE, FALSE, &fDllImport, NULL, NULL);

    if (fDllImport) {
        // Declaration has __declspec(dllimport).  Genthnk should emit
        // __declspec(dllexport) in the function definition.
        //
        pTypesInfo->Flags |= BTI_DLLEXPORT;
    }


    // if open paren, assume a fn pointer
ImplicitReturnType:
    if (CurrentToken()->TokenType == TK_LPAREN) {
        bFnPtr = TRUE;
        ConsumeToken();
    }

    // include cdecl, stdcall, save as FuncMod
    switch (CurrentToken()->TokenType) {
    case TK_CDECL:
        Len = CopyToken(pTypesInfo->FuncMod, szCDECL, sizeof(pTypesInfo->FuncMod) - 1);
        if (Len >= sizeof(pTypesInfo->FuncMod) - 1) {
            return FALSE;
        }
        ConsumeToken();
        break;

    case TK_FASTCALL:
        Len = CopyToken(pTypesInfo->FuncMod, sz__FASTCALL, sizeof(pTypesInfo->FuncMod) - 1);
        if (Len >= sizeof(pTypesInfo->FuncMod) - 1) {
            return FALSE;
        }
        ConsumeToken();
        break;

    case TK_STDCALL:
        Len = CopyToken(pTypesInfo->FuncMod, szSTDCALL, sizeof(pTypesInfo->FuncMod) - 1);
        if (Len >= sizeof(pTypesInfo->FuncMod) - 1) {
            return FALSE;
        }
        ConsumeToken();
        //
        // some funky ole include has:
        // "BOOL (__stdcall __stdcall *pfnContinue)(DWORD)"
        //
        if (CurrentToken()->TokenType == TK_STDCALL) {
            ConsumeToken();
        }
        break;

    default:
        break;
    }

    pTypesInfo->TypeKind = TypeKindFunc;
    pTypesInfo->dwMemberSize = 0;

    //
    // count indir on function
    //
    if (bFnPtr) {
        while (CurrentToken()->TokenType == TK_STAR ||
               CurrentToken()->TokenType == TK_BITWISE_AND) {
           IndLevel++;
           ConsumeToken();
        }
    }

    //
    // We expect the next token to be the func name.
    //
    if (CurrentToken()->TokenType != TK_RPAREN &&
        CurrentToken()->TokenType != TK_IDENTIFIER) {
        return FALSE;
    }

    pName = (bFnPtr && CurrentToken()->TokenType == TK_RPAREN) ? "" : CurrentToken()->Name;
    strcpy(pTypesInfo->BaseName, szFUNC);

    // look for beg of ArgList
    ConsumeToken();
    if (bFnPtr && CurrentToken()->TokenType == TK_RPAREN) {
        ConsumeToken();
    }

    if (CurrentToken()->TokenType != TK_LPAREN) {
        return FALSE;
    }
    ConsumeToken();     // consume the '('

    //
    // copy out the ArgList
    //
    while (CurrentToken()->TokenType != TK_EOS) {
        if (CurrentToken()->TokenType == TK_RPAREN) {
            break;
        }

        ArgIndLevel = 0;

        // ([mod] type [mod] [*] [mod] [ArgName] , ...)
        bFnPtr = FALSE;

        // skip register keywords all together
        if (CurrentToken()->TokenType == TK_REGISTER) {
            ConsumeToken();
        }

        //
        // Remember where we are in the parse
        //
        OldTokenIndex = CurrentTokenIndex;

        //
        // Allocate a new FUNCINFO struct for this parameter
        //
        pfuncinfo = AllocFuncInfoAndLink(&bufallocinfo, pfuncinfo);
        if (!pTypesInfo->pfuncinfo) {
            pTypesInfo->pfuncinfo = pfuncinfo;
        }

        if (CurrentToken()->TokenType == TK_VARGS) {
            ps = BufPointer(&bufallocinfo);
            pfuncinfo->sType = ps;
            strcpy(ps, szVARGS);
            BufAllocate(&bufallocinfo, strlen(szVARGS)+1);
            ConsumeToken();
            break;
        }

        // grab the IN, OUT, or 'IN OUT', if present
        pfuncinfo->tkDirection = ConsumeDirectionOpt();

        pfuncinfo->tkPreMod = ConsumeConstVolatileOpt();

        if (!GetExistingType(&ti, &bFnPtr, &pkt)) {
            ErrMsg("pft.args: unknown argument type at %d\n", OldTokenIndex);
            return FALSE;
        }
        pfuncinfo->pkt = pkt;

        // enter fp member as a typedef to store args and rettype
        if (bFnPtr) {
            TYPESINFO tiTmp;

            tiTmp = ti;
            tiTmp.pfuncinfo = RelocateTypesInfo(tiTmp.Members, &ti);
            tiTmp.Flags |= BTI_CONTAINSFUNCPTR;

            Len = CreatePseudoName(tiTmp.TypeName, ti.TypeName);
            if (!Len) {
                return FALSE;
            }

            pkt = AddNewType(&tiTmp, TypeDefsList);
            if (NULL == pkt) {
                return FALSE;
            }

            ps = BufPointer(&bufallocinfo);
            pfuncinfo->sType = ps;
            strcpy(ps, tiTmp.TypeName);
            BufAllocate(&bufallocinfo, strlen(ps)+1);

            pArgName = ti.TypeName;
            goto aftername;
        } else {

            DWORD Flags = 0;

            // skip indirection
            ParseIndirection(&pfuncinfo->IndLevel,
                             NULL,
                             &Flags,
                             &pfuncinfo->tkPrePostMod,
                             &pfuncinfo->tkPostMod
                             );

            if (Flags & BTI_PTR64) {
                pfuncinfo->fIsPtr64 = TRUE;
            }

            ps = BufPointer(&bufallocinfo);
            pfuncinfo->sType = ps;
            strcpy(ps, ti.TypeName);
            BufAllocate(&bufallocinfo, strlen(ps)+1);

            //
            // If the type of the parameter has an explicit
            // struct/union/enum keyword, pass that info on to
            // genthnk.  ie. if the parameter type is like
            // 'struct typename argname', set tkSUE to TK_STRUCT.
            //
            if (strcmp(ti.BaseName, szSTRUCT) == 0) {
                pfuncinfo->tkSUE = TK_STRUCT;
            } else if (strcmp(ti.BaseName, szUNION) == 0) {
                pfuncinfo->tkSUE = TK_UNION;
            } else if (strcmp(ti.BaseName, szENUM) == 0) {
                pfuncinfo->tkSUE = TK_ENUM;
            } else {
                pfuncinfo->tkSUE = TK_NONE;
            }
        }

        // if no argument name present, create one
        switch (CurrentToken()->TokenType) {
        case TK_RPAREN:
        case TK_LSQUARE:
        case TK_COMMA:
            // but null arg list doesn't have any name
            if (CurrentToken()->TokenType == TK_COMMA ||
                ArgNum      ||
                ti.IndLevel ||
                pfuncinfo->IndLevel ||
                strcmp(ti.BasicType, szVOID) ) {

                pArgName = NoNameArg;
                sprintf(NoNameArg, "_noname%x", ArgNum++);
            } else {
                pArgName = NULL;
            }
            break;

        case TK_IDENTIFIER:
            pArgName = CurrentToken()->Name;
            if (ArgNum == 0 &&
                pfuncinfo->IndLevel == 1 &&
                strcmp(pArgName, "This") == 0) {
                //
                // This is the first arg and it is a pointer with name 'This'.
                // Assume it is a MIDL-generated proxy prototype.
                //
                pfuncinfo->tkDirection = TK_IN;
            }
            ConsumeToken();
            break;

        default:
            return FALSE;
        }

aftername:
        if (pArgName) {
            //
            // Copy the argument name from pArgName into pfuncinfo->sName.
            //
            ps = BufPointer(&bufallocinfo);
            pfuncinfo->sName = ps;
            strcpy(ps, pArgName);
        }

        //
        // Handle parameter which is a single-dimension array by copying the
        // entire string from '[' to ']' (inclusive)
        // ie.  int foo(int i[3])
        //
        if (CurrentToken()->TokenType == TK_LSQUARE) {
            int OldCurrentTokenIndex = CurrentTokenIndex;
            int ArgNameLen = strlen(ps);

            do {
                ConsumeToken();
            } while (CurrentToken()->TokenType != TK_RSQUARE &&
                     CurrentToken()->TokenType != TK_EOS);

            if (CurrentToken()->TokenType == TK_EOS) {
                // Reject - unmatched '[' and ']'
                return FALSE;
            }
//            if (CurrentTokenIndex - OldCurrentTokenIndex == 1) {
                //
                // Found: empty array bounds '[]'.  Bump IndLevel and
                // don't append the '[]' to the parameter name.
                //
                pfuncinfo->IndLevel++;
//            } else if (!UnlexToText(ps + ArgNameLen,
//                                    BufGetFreeSpace(&bufallocinfo) - ArgNameLen,
//                                    OldCurrentTokenIndex,
//                                    CurrentTokenIndex+1)) {
//                ErrMsg("pft: args list too long\n");
//                return FALSE;
//            }
            ConsumeToken();
        }
        BufAllocate(&bufallocinfo, strlen(ps)+1);

        //bug bug , hack hack, danger danger
        if (CurrentToken()->TokenType == TK_ASSIGN) {
            //Header is using the C++ syntax of assigning
            //a default value to a argument.
            //This will be skipped.  Skip until a TK_COMMA, TK_EOS, TK_RPAREN
            ConsumeToken();

            while(CurrentToken()->TokenType != TK_COMMA &&
                  CurrentToken()->TokenType != TK_EOS &&
                  CurrentToken()->TokenType != TK_RPAREN) {
                    ConsumeToken();
            }
        }

        if (CurrentToken()->TokenType == TK_RPAREN) {
            break;
        } else {  // more args to go, add comma delimiter
            ConsumeToken();
        }
    }

    if (CurrentToken()->TokenType != TK_RPAREN) {
        ErrMsg("pft: unknown syntax for fn args\n");
        return FALSE;
    }

    ConsumeToken(); // consume the ')'

    pTypesInfo->IndLevel = IndLevel;
    pTypesInfo->Size = 4;
    pTypesInfo->iPackSize = 4;
    strcpy(pTypesInfo->BasicType, szFUNC);
    if (CopyToken(pTypesInfo->TypeName,
                  pName,
                  sizeof(pTypesInfo->TypeName)-1
                  )
           >= sizeof(pTypesInfo->TypeName) ) {
       return FALSE;
    }
    if (pfuncinfo == NULL) {
        //
        // No args encountered - create VOID args now
        //
        pfuncinfo = AllocFuncInfoAndLink(&bufallocinfo, pfuncinfo);
        ps = BufPointer(&bufallocinfo);
        strcpy(ps, szVOID);
        pfuncinfo->sType = ps;
        BufAllocate(&bufallocinfo, strlen(ps)+1);
        pTypesInfo->pfuncinfo = pfuncinfo;
    }
    pTypesInfo->dwMemberSize = bufallocinfo.dwLen;

    return TRUE;
}

BOOL
ParseStructTypes(
    PTYPESINFO pTypesInfo
    )
/*++

Routine Description:

    Parses a C-language statement if it is struct/union/enum declaration.

    struct|union|enum NewName <{}>
    struct NewName : <permission> BaseName <{}>
 (Note that we don't deal with extraneous parens very well)


Arguments:

    pTypesInfo  -- OUT ptr to info about the type

Return Value:

    TRUE if the statement is a struct/union/enum
    FALSE if the statement is not a s/u/e, or some other error

--*/
{
    TOKENTYPE FirstToken;
    BOOL bEnum = FALSE;
    BOOL bUnion = FALSE;
    DWORD dwOldScopeLevel = dwScopeLevel;
    BOOL IsGuidDefined = FALSE;

    memset(pTypesInfo, 0, sizeof(TYPESINFO));

    //
    // Match one of: STRUCT, UNION, or ENUM
    //
    FirstToken = CurrentToken()->TokenType;
    switch (FirstToken) {
    case TK_STRUCT:
        break;

    case TK_UNION:
        bUnion = TRUE;
        break;

    case TK_ENUM:
        bEnum = TRUE;
        break;

    default:
        goto retfail;   // no match
    }
    ConsumeToken();

    // BasicType is "struct", "union", or "enum"
    if (CopyToken(pTypesInfo->BasicType,
                  TokenString[FirstToken],
                  sizeof(pTypesInfo->BasicType)-1
                  )
            >= sizeof(pTypesInfo->BasicType) ) {
        goto retfail;
    }
    strcpy(pTypesInfo->BaseName, pTypesInfo->BasicType);

    //handle declspecs
    if (!bUnion && !bEnum) {
        while(ConsumeDeclSpecOpt(FALSE, FALSE, NULL, &IsGuidDefined, &(pTypesInfo->gGuid)));
        if (IsGuidDefined) pTypesInfo->Flags |= BTI_HASGUID;
    }

    switch (CurrentToken()->TokenType) {
    case TK_IDENTIFIER:
        {
            if (CopyToken(pTypesInfo->TypeName,
                CurrentToken()->Name,
                sizeof(pTypesInfo->BasicType)-1
                )
                >= sizeof(pTypesInfo->BasicType) ) {
                goto retfail;
            }
            ConsumeToken();
            break;
        }

    case TK_LBRACE:         // anonymous struct/union/enum
        if (!CreatePseudoName(pTypesInfo->TypeName, TokenString[FirstToken])) {
            //
            // call failed - probably buffer overflow
            //
            goto retfail;
        }
        pTypesInfo->Flags |= BTI_ANONYMOUS;
        break;

    default:
        //
        // STRUCT/UNION/ENUM followed by something other than an identifier
        // or a '{'.
        //
        goto retfail;
    }

    //
    // Process the contents of the curly braces, if present.
    //
    switch (CurrentToken()->TokenType) {
    case TK_EOS:
        goto retsuccess;

    case TK_LBRACE:
        {
            if (bEnum) {
                if(CopyEnumMembers(pTypesInfo)) goto retsuccess;
                else goto retfail;
            }
            if(CopyStructMembers(pTypesInfo, bUnion, NULL)) goto retsuccess;
            else goto retfail;

        }
    case TK_COLON: //entering a derived struct
        if (bEnum || bUnion) goto retfail;
        ConsumeToken();
        //look for base skipping public, private, and protected
        {
            PTOKEN pToken;
            BOOL bRetVal;
            PTYPEINFOELEMENT pMemFuncs;
            PKNOWNTYPES BaseType;

            pToken = CurrentToken();

            if (pToken->TokenType != TK_IDENTIFIER) goto retfail;
            if (strcmp(pToken->Name, "public") == 0 ||
                strcmp(pToken->Name, "private") == 0 ||
                strcmp(pToken->Name, "protected") == 0) {
                ConsumeToken();
            }
            //look for base
            if (CopyToken(pTypesInfo->BaseType,
                CurrentToken()->Name,
                sizeof(pTypesInfo->BasicType)-1
                )
                >= sizeof(pTypesInfo->BasicType) ) {
                goto retfail;
            }

            //lookup the base in structures
            BaseType = GetNameFromTypesList(StructsList,pTypesInfo->BaseType);
            if (NULL == BaseType) {
                //ErrMsg("Base type is unknown or not a structure\n");
                goto retfail;
            }

            //look for opening brace or EOS
            ConsumeToken();
            if (CurrentToken()->TokenType == TK_EOS) goto retsuccess;
            if (CurrentToken()->TokenType != TK_LBRACE) goto retfail;
            if (CopyStructMembers(pTypesInfo, FALSE, BaseType)) goto retsuccess;
            else goto retfail;
        }

    default:
        break;
    }

    goto retsuccess;
retfail:
    dwScopeLevel = dwOldScopeLevel;
    return FALSE;
retsuccess:
    dwScopeLevel = dwOldScopeLevel;
    return TRUE;
}

BOOL
CopyEnumMembers(
    PTYPESINFO pTypesInfo
    )
/*++

Routine Description:

    Scans over members of an enumeration declaration.  Nobody cares
    about the actual names and values, so they are simply skipped over
    until the matching '}' is found.

Arguments:

    pTypesInfo  -- OUT ptr to info about the type

Return Value:

    TRUE if the declaration is parsed OK
    FALSE if the statement is mis-parsed, or some other error

--*/
{
    DWORD *pdwSize = &(pTypesInfo->Size);
    DWORD *pdwPackSize = &(pTypesInfo->iPackSize);
    dwScopeLevel++;

    if (CurrentToken()->TokenType != TK_LBRACE) {
        return FALSE;
    } else {
        ConsumeToken();
    }

    //
    // Find the '}' which ends the enumeration declaration
    //
    while (CurrentToken()->TokenType != TK_RBRACE) {
        ConsumeToken();
    }
    ConsumeToken(); // consume the '}', too

    *pdwSize = sizeof(int);     // enum
    *pdwPackSize = sizeof(int); // enum

    return TRUE;
}


// How sortpp computes packing sizes:
//
// * Each member has a packing size which is
//    - size of a appropriate pointer if member is a pointer
//    - packing size of its base type
// * The packing size of struc or union is min(packing_size_of_largest_member,
//   current_packing_size_when_struct_defined)
// * Each member in a struct is aligned according to min(current_packing_size,
//   member_packing_size).
// * All pointers have size sizeof(void *) except __ptr64 pointers which
//   have a size sizeof(PVOID64)
// * bit fields are coallessed until
//   - the end of the struct
//   - a non bit field member
//   - a bit field member, but of different base type size
// * char s[] as the last member of a struct adds nothing to the size of the
//   struct and should not be aligned.
// * each member of a union is packed at offset 0.


BOOL
pCopyStructMembers(
    PTYPESINFO pTypesInfo,
    BOOL bUnion,
    PTYPEINFOELEMENT * ppMemberFuncs,
    DWORD Size,
    DWORD iPackSize
    )
/*++

Routine Description:

    Copies out struct members, verifying type of each member.

    { [mod] type [*] varname; [mod] type [*] varname; ...}
    { {varname, varname, ...}

    Assumes CurrentToken points at the '{' for the member list.
    Also determines the size of the struct/union.

Arguments:

    pTypesInfo  -- OUT ptr to info about the type
    bUnion      -- TRUE if parsing union, FALSE if parsing STRUCT.
    ppMemberFuncs -- OUT returns a list of virtual member functions or NULL.

Return Value:

    TRUE if the declaration is parsed OK
    FALSE if the statement is mis-parsed, or some other error

--*/
{
    char *psMemBuf = pTypesInfo->Members;
    DWORD *pdwSize = &(pTypesInfo->Size);
    DWORD *pdwPackSize = &(pTypesInfo->iPackSize);
    int Len;
    BOOL bFnPtr;
    TYPESINFO ti;
    DWORD dw;
    DWORD dwBase;                   // running size of struct element
    DWORD dwElemSize;               // size of a particular element
    DWORD dwBaseTypeSize;           // size of basic type of element
    DWORD dwBits;                   // # bits in a bitfield element
    DWORD dwBitsTotal;              // running # bits for string of elemnts
    DWORD dwBitsTypeSize;           // bit fields base type size
    BOOL bForceOutBits = FALSE;
    BOOL bTailPointer = FALSE;
    DWORD dwLastPackSize = 0;
    DWORD dwLastSize = 0;
    PMEMBERINFO pmeminfo;
    BUFALLOCINFO bufallocinfo;
    char *ps;
    DWORD Flags;
    DWORD dwIndex;
    int ParenDepth = 0;

    PTYPEINFOELEMENT pMethods = NULL;
    DWORD dwMethodNumber = 0;

    PKNOWNTYPES pkt;

    if (ppMemberFuncs != NULL) *ppMemberFuncs = NULL;

    *pdwSize = Size;                  // initialize size of structure
    *pdwPackSize = iPackSize;              // initialize packing alignment
    dwLastSize = Size;
    dwLastPackSize = iPackSize;

    BufAllocInit(&bufallocinfo, psMemBuf, sizeof(pTypesInfo->Members), 0);
    pmeminfo = NULL;

    pTypesInfo->TypeKind = TypeKindStruct;
    pTypesInfo->dwMemberSize = 0;
    bFnPtr = FALSE;

    // loop over members of the structure or union

    dwBitsTotal = 0;
    dwBitsTypeSize = 0;

    if (CurrentToken()->TokenType != TK_LBRACE) {
        return FALSE;
    }
    ConsumeToken();

    while (CurrentToken()->TokenType != TK_RBRACE) {
        int OldCurrentTokenIndex = CurrentTokenIndex;

        if (bDebug)
            DumpLexerOutput(CurrentTokenIndex);

        //strip off permission attributes
        //{public private protected} :
        while(CurrentToken()->TokenType == TK_IDENTIFIER &&
                (strcmp(CurrentToken()->Name, "public") == 0 ||
                 strcmp(CurrentToken()->Name, "private") == 0 ||
                 strcmp(CurrentToken()->Name, "protected") == 0
                 ))
        {
            ConsumeToken();
            if (CurrentToken()->TokenType != TK_COLON) return FALSE;
            ConsumeToken();

            if (CurrentToken()->TokenType == TK_RBRACE) goto done;
        }

        if (!bUnion &&
            ppMemberFuncs != NULL &&
            CurrentToken()->TokenType == TK_IDENTIFIER &&
            strcmp(CurrentToken()->Name, "virtual") == 0) {

            PTYPESINFO pFuncInfo;
            int TokenNumber = CurrentTokenIndex;
            ConsumeConstVolatileOpt();

            pFuncInfo = GenHeapAlloc(sizeof(TYPESINFO));
            if (pFuncInfo == NULL) ExitErrMsg(FALSE, "Out of memory!\n");
            ConsumeToken();

            //virtual method
            if (!ParseFuncTypes(pFuncInfo, FALSE)) {
                ErrMsg("Unable to parse method %u of %s\n", dwMethodNumber, pTypesInfo->TypeName);
                DumpLexerOutput(TokenNumber);
                return FALSE;
            }

            pMethods = TypeInfoElementAllocateLink(ppMemberFuncs, pMethods, pFuncInfo);

            //remove extra ;
            if (CurrentToken()->TokenType == TK_SEMI)
                ConsumeToken();
            //remove extra = 0;
            else if (CurrentToken()->TokenType == TK_ASSIGN) {
                ConsumeToken();
                //parsing 0;
                if (!(CurrentToken()->TokenType == TK_NUMBER &&
                    CurrentToken()->Value == 0)) return FALSE;
                ConsumeToken();
                //parsing ;
                if (CurrentToken()->TokenType != TK_SEMI) return FALSE;
                ConsumeToken();
            }
            else return FALSE; //fail

            dwMethodNumber++;
            continue;
        }


        if (ConsumeDirectionOpt() != TK_NONE && bDebug) {
            // A struct element had a direction on it.  Ignore it and
            // warn the user.
            fprintf(stderr, "Warning: IN and OUT are ignored on struct members. %s line %d\n", SourceFileName, StatementLineNumber);
        }

        ConsumeConstVolatileOpt();

        pmeminfo = AllocMemInfoAndLink(&bufallocinfo, pmeminfo);
        if (pmeminfo == NULL) {
            ErrMsg("CopyStructMembers: No memberinfo\n");
            return FALSE;
        }

        if (!GetExistingType(&ti, &bFnPtr, &pkt)) {
            ErrMsg("csm: unknown Type %d\n", OldCurrentTokenIndex);
            return FALSE;
        }
        pmeminfo->pkt = pkt;

        // enter function pointer member as a typedef to store args, rettype
        if (bFnPtr) {
            TYPESINFO tiTmp;

            ti.Flags |= BTI_CONTAINSFUNCPTR;
            tiTmp = ti;
            tiTmp.pfuncinfo = RelocateTypesInfo(tiTmp.Members, &ti);

            Len = CreatePseudoName(tiTmp.TypeName, ti.TypeName);
            if (!Len) {
                return FALSE;
            }
            tiTmp.Size = ti.Size;
            tiTmp.iPackSize = ti.iPackSize;

            pkt = AddNewType(&tiTmp, TypeDefsList);
            if (NULL == pkt) {
                return FALSE;
            }
            ps = BufPointer(&bufallocinfo);
            pmeminfo->sName = ps;
            strcpy(ps, ti.TypeName);
            BufAllocate(&bufallocinfo, strlen(ps)+1);
            pmeminfo->pkt = pkt;
        }
        /*else {
            ////////////////////////////////////////////////////////////////
            //This type has no members for it, do no process further.
            /////////////////////////////////////////////////////////////////
            if (CurrentToken()->TokenType == TK_SEMI) {
                ConsumeToken();
                continue;
            }
        }*/
        //
        // If the member contains a function pointer, then mark
        // this struct has containing a function pointer
        // Also mark if member is pointer dependent.

        pTypesInfo->Flags |= ((ti.Flags & BTI_CONTAINSFUNCPTR) | (ti.Flags & BTI_POINTERDEP));

        //
        // Union arm initialization
        dwBaseTypeSize = ti.iPackSize;

        if ((dwBitsTotal > 0) && (dwBaseTypeSize != dwBitsTypeSize)) {
            //
            // Determine size of bitfields
            //
            dw = (dwBitsTotal + ((dwBitsTypeSize*8)-1)) / (dwBitsTypeSize*8);
            *pdwSize = *pdwSize + PackPackingSize(bUnion ? 0 : *pdwSize,
                                                  dw*dwBitsTypeSize,
                                                  dwBitsTypeSize);
            dwBitsTotal = 0;
        }
        dwBitsTypeSize = dwBaseTypeSize;

        // element initialization
        dwBase = ti.Size;
        dwBits = 0;

        bTailPointer = FALSE;

        pmeminfo->dwOffset = bUnion ? 0 : *pdwSize +
                                                  PackPaddingSize(*pdwSize,
                                                              dwBaseTypeSize);

        //
        // Copy in the typename
        //
        ps = BufPointer(&bufallocinfo);
        pmeminfo->sType = ps;
        strcpy(ps, ti.TypeName);
        BufAllocate(&bufallocinfo, strlen(ps)+1);

        //
        // Skip just past the terminating ';' for this member and
        // figure out any size modifers to size of the base type.
        //
        while (CurrentToken()->TokenType != TK_SEMI) {

            PMEMBERINFO pmeminfoNew;

            switch (CurrentToken()->TokenType) {
            case TK_CONST:
            case TK_VOLATILE:
                ConsumeToken();
                break;

            case TK_COMMA:  // comma-separated list

                // update structure packing value
                if (dwBaseTypeSize > *pdwPackSize) {
                    *pdwPackSize = dwBaseTypeSize;
                }

                // flush out any bit fields not accounted for
                if ((dwBitsTotal > 0) && (dwBits == 0)) {
                    dw = (dwBitsTotal + ((dwBitsTypeSize*8)-1)) /
                                                        (dwBitsTypeSize*8);
                    dwElemSize = PackPackingSize(bUnion ? 0 : *pdwSize,
                                    dw*dwBitsTypeSize, dwBitsTypeSize);
                    BumpStructUnionSize(pdwSize, dwElemSize, bUnion);
                    dwBitsTotal = 0;
                    // recompute offset
                    pmeminfo->dwOffset = bUnion ? 0 : *pdwSize +
                                                  PackPaddingSize(*pdwSize,
                                                              dwBaseTypeSize);
                }

                // account for member just completed
                if (dwBits == 0) {
                    dwElemSize = PackPackingSize(bUnion ? 0 : *pdwSize,
                                                             dwBase,
                                                             dwBaseTypeSize);
                    BumpStructUnionSize(pdwSize, dwElemSize, bUnion);
                    dwBase = dwBaseTypeSize;
                }

                // update bit field count
                dwBitsTotal = dwBitsTotal + dwBits;
                dwBits = 0;

                // reset tail pointer flag
                bTailPointer = FALSE;

                // allocate space for new structure member and init it
                pmeminfoNew = AllocMemInfoAndLink(&bufallocinfo, pmeminfo);
                if (pmeminfoNew == NULL) {
                    ErrMsg("CopyStructMembers: No memberinfo\n");
                    return FALSE;
                    }

                // Copy over type information from previous meminfo.
                pmeminfoNew->sType = pmeminfo->sType;
                pmeminfoNew->pkt = pmeminfo->pkt;
                pmeminfo = pmeminfoNew;

                pmeminfo->dwOffset = bUnion ? 0 : *pdwSize +
                                                  PackPaddingSize(*pdwSize,
                                                              dwBaseTypeSize);
                ConsumeToken();
                break;

            case TK_STAR:
            case TK_BITWISE_AND:
                Flags = 0;
                ParseIndirection(&pmeminfo->IndLevel, NULL, &Flags, NULL, NULL);
                if (Flags & BTI_PTR64) {
                    pmeminfo->bIsPtr64 = TRUE;
                    dwBase = SIZEOFPOINTER64;
                } else {
                    dwBase = SIZEOFPOINTER;
                }
                //  If a pointer is present, mark as being pointer dependent.
                if (pmeminfo->IndLevel > 0) pTypesInfo->Flags |= BTI_POINTERDEP;
                dwBaseTypeSize = dwBase;
                if (*pdwPackSize < dwBase) {
                    *pdwPackSize = dwBase;
                }
                pmeminfo->dwOffset = bUnion ? 0 : *pdwSize +
                                                  PackPaddingSize(*pdwSize,
                                                              dwBaseTypeSize);
                break;

            case TK_LSQUARE:    // array declaration

                if (!GetArrayIndex(&dwIndex)) {
                    return FALSE;
                }
                if (dwIndex == 0) {          // a[] is really *a
                    bTailPointer = TRUE;
                    dwLastPackSize = *pdwPackSize;
                    dwLastSize = *pdwSize;
                    dwBase = SIZEOFPOINTER;
                    dwBaseTypeSize = SIZEOFPOINTER;
                    pmeminfo->dwOffset = bUnion ? 0 : *pdwSize +
                                                  PackPaddingSize(*pdwSize,
                                                              dwBaseTypeSize);
                } else {
                    pmeminfo->bIsArray = TRUE;
                    pmeminfo->ArrayElements = dwIndex;
                    dwBase = dwBase * dwIndex;
                }
                break;

            case TK_COLON:          // bit field
                ConsumeToken();     // consume the ':'

                if (CurrentToken()->TokenType != TK_NUMBER) {
                    return FALSE;
                }

                dwBits = (DWORD)CurrentToken()->Value;
                ConsumeToken(); // consume the TK_NUMBER
                pmeminfo->bIsBitfield = TRUE;
                pmeminfo->BitsRequired = (int)dwBits;
                break;

            case TK_IDENTIFIER:
                ps = BufPointer(&bufallocinfo);
                pmeminfo->sName = ps;
                CopyToken(ps, CurrentToken()->Name, MAX_PATH);

                if (!BufAllocate(&bufallocinfo, strlen(ps)+1)) {
                    ErrMsg("csm.members: BufAllocate failed\n");
                    return FALSE;
                }
                ConsumeToken();
                break;

            case TK_LPAREN:
                //
                // windows\inc\wingdip.h has a type named GDICALL, which
                // has a member in it with the following declaration:
                //      WCHAR (*pDest)[MAX_PATH];
                // We are just going to skip the parens and assume all is OK.
                //
                ParenDepth++;
                ConsumeToken();
                break;

            case TK_RPAREN:
                ParenDepth--;
                ConsumeToken();
                break;

            default:
                ErrMsg("csm.members: unknown type (%d)\n", (int)CurrentToken()->TokenType);
                return FALSE;
            }

        }

        // hit ; at end of a members list
        if (ParenDepth) {
            ErrMsg("csm.members: mismatched parentheses at index %d\n", CurrentTokenIndex);
            return FALSE;
        }

        // update struct packing size to that of largest member
        if (dwBaseTypeSize > *pdwPackSize) {
            *pdwPackSize = dwBaseTypeSize;
        }

        ConsumeToken(); // consume the ';'

        if ((bUnion) || (CurrentToken()->TokenType == TK_SEMI)) {
            dwBitsTotal = dwBitsTotal + dwBits;
            bForceOutBits = TRUE;
                                       // always force out bits in union arm
        }                              // or at end of structure

        // flush out any bit fields not accounted for
        if ( (dwBitsTotal > 0) && ( (dwBits == 0) || bForceOutBits) ) {
            dw = (dwBitsTotal + ((dwBitsTypeSize*8)-1)) / (dwBitsTypeSize*8);
            dwElemSize = PackPackingSize(bUnion ? 0 : *pdwSize,
                                          dw*dwBitsTypeSize, dwBitsTypeSize);
            BumpStructUnionSize(pdwSize, dwElemSize, bUnion);
            dwBitsTotal = 0;
            // recompute offset
            pmeminfo->dwOffset = bUnion ? 0 : *pdwSize +
                                                  PackPaddingSize(*pdwSize,
                                                              dwBaseTypeSize);
            }

        // account for member just completed
        if (dwBits == 0) {                    // add in last non bit fields
            dwElemSize = PackPackingSize(bUnion ? 0 : *pdwSize,
                                          dwBase, dwBaseTypeSize);
            BumpStructUnionSize(pdwSize, dwElemSize, bUnion);
        }

        // update bit field counter
        dwBitsTotal = dwBitsTotal + dwBits;
        dwBits = 0;

    }

done:
    // Advance past the '}'
    if ((CurrentToken()->TokenType == TK_RBRACE)) {
        ConsumeToken();
    }

    // if last member was something like foo[] then we roll back the size
    if ((bTailPointer) && (*pdwSize != 4)) {
        *pdwSize = dwLastSize;
        *pdwPackSize = dwLastPackSize;
        pmeminfo->dwOffset = dwLastSize;
    }

    // pack overall structure on it packing size
    dwBaseTypeSize = PackCurrentPacking() < *pdwPackSize ?
                                  PackCurrentPacking() : *pdwPackSize;
    if (*pdwSize != 0) {         // round up to min(packing level,4)
        dwBase = *pdwSize % dwBaseTypeSize;
        if (dwBase != 0) {
            *pdwSize = *pdwSize + (dwBaseTypeSize - dwBase);
        }
    }

    *pdwPackSize = dwBaseTypeSize;
    pTypesInfo->dwMemberSize = bufallocinfo.dwLen;

    return TRUE;
}

PMEMBERINFO
CatMeminfo(
    BUFALLOCINFO *pBufallocinfo,
    PMEMBERINFO pHead,
    PMEMBERINFO pTail,
    DWORD dwOffset,
    BOOL bStatus
    )
{

/*++

Routine Description:

    Concatinates the member info lists pointed to by pHead and pTail and
    copies them to the memory controled by the BUFALLOCINFO.  dwOffset is
    added to the offset for each of the members of the tail list.

Arguments:

    pBufallocinfo    -- [IN] ptr to buffer that represents the destination.
    pHead            -- [IN] ptr to the head list.
    pTail            -- [IN] ptr to the tail list.
    dwOffset         -- [IN] amount to add to the offset of elements in the tail.
    bStatus          -- [IN] Should be FALSE on initial call.

Return Value:

    Head of the new list.

--*/

    PMEMBERINFO pThis;
    char *pName, *pType;

    if (!bStatus && NULL == pHead) {
        pHead = pTail;
        bStatus = TRUE;
    }

    if (NULL == pHead) return NULL;

    pThis = (PMEMBERINFO)BufAllocate(pBufallocinfo, sizeof(MEMBERINFO));
    if (NULL == pThis) ExitErrMsg(FALSE, "Out of buffer memory! %d", __LINE__);
    *pThis = *pHead;

    if (pHead->sName != NULL) {
        pName = (char *)BufAllocate(pBufallocinfo, strlen(pHead->sName) + 1);
        if (NULL == pName) ExitErrMsg(FALSE, "Out of buffer memory! %d %s", __LINE__, pHead->sName);
        pThis->sName = strcpy(pName, pHead->sName);
    }

    if (pHead->sType != NULL) {
        pType = (char *)BufAllocate(pBufallocinfo, strlen(pHead->sType) + 1);
        if (NULL == pType) ExitErrMsg(FALSE, "Out of buffer memory! %d %s", __LINE__, pHead->sType);
        pThis->sType = strcpy(pType, pHead->sType);
    }

    if (bStatus) pThis->dwOffset += dwOffset;
    pThis->pmeminfoNext = CatMeminfo(pBufallocinfo, pHead->pmeminfoNext, pTail, dwOffset, bStatus);

    return pThis;
}

VOID
FreeTypeInfoList(
    PTYPEINFOELEMENT pThis
    )
{
/*++

Routine Description:

    Frees the memory associated with a TYPEINFOELEMENT.

Arguments:

    pThis        -- [IN] ptr to the list to free.

Return Value:

    None.

--*/

    PTYPEINFOELEMENT pNext;

    while(NULL != pThis) {
        pNext = pThis->pNext;
        if (pThis->pTypeInfo != NULL) GenHeapFree(pThis->pTypeInfo);
        GenHeapFree(pThis);
        pThis = pNext;
    }
}

VOID
GenerateProxy(
    char *pName,
    PTYPESINFO pTypesInfo
    )
{

/*++

Routine Description:

    Generates proxy infomation for functions in a struct with virtual methods.
    The infomation is of the form structname_functionname_Proxy.
    The function is added to the functions list if not already in the list.
    The discardable flag is set so that this type will be redefined in refound in the code.

Arguments:

    pName        -- [IN] ptr to the name of the struct that the method is in.
    pTypesInfo   -- [IN] Information for the function.

Return Value:

    None.

--*/

    TYPESINFO NewTypesInfo;
    PFUNCINFO pFuncInfo;
    PFUNCINFO *ppFuncInfo;
    PFUNCINFO pCurrent;
    BUFALLOCINFO bufallocinfo;
    char *pChar;
    DWORD dwSizeArgName, dwSizeTypeName;

    // Bail out if not func, no struct name, or no class name
    if (pName == NULL || pTypesInfo->TypeName == NULL) return;
    if (pTypesInfo->TypeKind != TypeKindFunc ||
        strlen(pName) == 0 ||
        strlen(pTypesInfo->TypeName) == 0) return;

    NewTypesInfo = *pTypesInfo;
    strcpy(NewTypesInfo.TypeName, pName);
    strcat(NewTypesInfo.TypeName, "_");
    strcat(NewTypesInfo.TypeName, pTypesInfo->TypeName);
    strcat(NewTypesInfo.TypeName, "_Proxy");

    /////////////////////////////////////////////////////////////////
    //Check if the function has already been added.
    //If it has, no more work is needed.
    /////////////////////////////////////////////////////////////////
    if (GetNameFromTypesList(FuncsList, NewTypesInfo.TypeName) != NULL)
        return;

    ////////////////////////////////////////////////////////////////////
    //Copy function members adding a this pointer at head
    //and skipping void arguments.
    ////////////////////////////////////////////////////////////////////
    BufAllocInit(&bufallocinfo, NewTypesInfo.Members, FUNCMEMBERSIZE, 0);
    dwSizeTypeName = strlen(pName) + 1;
    dwSizeArgName = strlen(szThis) + 1;
    pFuncInfo = (PFUNCINFO)BufAllocate(&bufallocinfo, sizeof(FUNCINFO) + dwSizeArgName + dwSizeTypeName);
    if (NULL == pFuncInfo) ExitErrMsg(FALSE, "Out of buffer memory! %d", __LINE__);

    pFuncInfo->fIsPtr64 = FALSE;
    pFuncInfo->tkDirection = TK_IN;
    pFuncInfo->tkPreMod = TK_NONE;
    pFuncInfo->tkSUE = TK_NONE;
    pFuncInfo->tkPrePostMod = TK_NONE;
    pFuncInfo->IndLevel = 1;
    pFuncInfo->tkPostMod = TK_NONE;
    pChar = ((char *)pFuncInfo) + sizeof(FUNCINFO);
    strcpy(pChar, pName);
    pFuncInfo->sType = pChar;
    pChar += dwSizeTypeName;
    strcpy(pChar, szThis);
    pFuncInfo->sName = pChar;
    pFuncInfo->pfuncinfoNext = NULL;
    NewTypesInfo.pfuncinfo = pFuncInfo;
    ppFuncInfo = &(pFuncInfo->pfuncinfoNext);

    //skip an argument of type void if it is at the begining.
    //This is needed since ParseFuncTypes puts a void arg if the
    //func does not have any arguments
    pCurrent = pTypesInfo->pfuncinfo;
    if (pCurrent != NULL &&
        strcmp(szVOID, pCurrent->sType) == 0
        && pCurrent->IndLevel == 0) {
        pCurrent = pCurrent->pfuncinfoNext;
    }

    for(; pCurrent != NULL; pCurrent=pCurrent->pfuncinfoNext) {

        dwSizeTypeName = strlen(pCurrent->sType) + 1;
        dwSizeArgName = strlen(pCurrent->sName) + 1;
        pFuncInfo = (PFUNCINFO)BufAllocate(&bufallocinfo, sizeof(FUNCINFO) + dwSizeArgName + dwSizeTypeName);
        if (NULL == pFuncInfo) ExitErrMsg(FALSE, "Out of buffer memory! %d", __LINE__);

        *pFuncInfo = *pCurrent;
        pChar = ((char *)pFuncInfo) + sizeof(FUNCINFO);
        strcpy(pChar, pCurrent->sType);
        pFuncInfo->sType = pChar;
        pChar += dwSizeTypeName;
        strcpy(pChar, pCurrent->sName);
        pFuncInfo->sName = pChar;
        pFuncInfo->pfuncinfoNext = NULL;
        *ppFuncInfo = pFuncInfo;
        ppFuncInfo = &(pFuncInfo->pfuncinfoNext);

    }

    NewTypesInfo.Flags |= BTI_DISCARDABLE;
    NewTypesInfo.dwMemberSize = bufallocinfo.dwLen;
    if (!AddNewType(&NewTypesInfo, FuncsList))
        ExitErrMsg(FALSE, "Unable to add proxy information.(Type was not in list)\n");

}

BOOL
CopyStructMembers(
    PTYPESINFO pTypesInfo,
    BOOL bUnion,
    PKNOWNTYPES pBaseType
    )
{

/*++

Routine Description:

    Parses the members of the structure and adds them to the pTypesInfo.
    Handles merging of members and methods when the structure is derived
    from another structure.  Delegates actual parsing to pCopyStructMembers.

Arguments:

    pTypesInfo   -- [IN OUT] ptr to infomation for the type being processed.
    dwElemSize   -- [IN] TRUE if processing a union, FALSE if a struct.
    bUnion       -- [IN] ptr to KNOWNTYPE of base structure or NULL.

Return Value:

    TRUE - If success.

--*/

    PTYPEINFOELEMENT pMemberFuncs = NULL;
    char *VTBLFakeMember;
    PMEMBERINFO pHead = NULL; //Head in final merge
    PMEMBERINFO pTail = NULL; //Tail in final merge
    DWORD dwiPackSize; //For tail
    DWORD dwSize; //For tail
    DWORD dwOffset; //For tail
    BUFALLOCINFO bufallocinfo;


    dwScopeLevel++;

    /////////////////////////////////////////////////////////////////
    //Add a discardable version of this struct if one doesn't exist
    /////////////////////////////////////////////////////////////////
    if (GetNameFromTypesList(StructsList, pTypesInfo->TypeName) == NULL) {
        TYPESINFO TTypesInfo;
        TTypesInfo = *pTypesInfo;
        TTypesInfo.Flags |= BTI_DISCARDABLE;
        AddNewType(&TTypesInfo, StructsList); //intentionally do not check
    }

    if(bUnion) return pCopyStructMembers(pTypesInfo, bUnion, NULL, 0, 0);

    if (pBaseType == NULL) {
        if (!pCopyStructMembers(pTypesInfo, FALSE, &pMemberFuncs, 0, 0)) {
            FreeTypeInfoList(pMemberFuncs);
            return FALSE;
        }
        if (pMemberFuncs!=NULL && pTypesInfo->Size > 0) {
            ErrMsg("Error: struct %s mixes data members and virtual functions(sortpp limitation).\n", pTypesInfo->TypeName);
            FreeTypeInfoList(pMemberFuncs);
            return FALSE;
        }

        pTypesInfo->dwVTBLSize = 0;
        pTypesInfo->dwVTBLOffset = 0;

        if (pMemberFuncs != NULL) {


            PTYPEINFOELEMENT pThisElement;
            DWORD dwElements = 0;
            DWORD dwLength, dwVoidLen, dwVTBLLen;
            PMEMBERINFO pMemberInfo;
            char *pName;

            ///////////////////////////////////////////////////////////////////////////
            //Build the fake VTBL pointer
            /////////////////////////////////////////////////////////////////////////////

            //Add the VTBL member
            dwVoidLen = strlen(szVOID) + 1;
            dwVTBLLen = strlen(szVTBL) + 1;

            memset(pTypesInfo->Members, 0, FUNCMEMBERSIZE);
            BufAllocInit(&bufallocinfo, pTypesInfo->Members, FUNCMEMBERSIZE, 0);
            pMemberInfo = (PMEMBERINFO)BufAllocate(&bufallocinfo, sizeof(MEMBERINFO) + dwVoidLen + dwVTBLLen);
            if (NULL == pMemberInfo) ExitErrMsg(FALSE, "Out of buffer memory! %d", __LINE__);

            pName = ((char *)pMemberInfo) + sizeof(MEMBERINFO);
            strcpy(pName, szVTBL);
            pMemberInfo->sName = pName;

            pName += dwVTBLLen;
            strcpy(pName, szVOID);
            pMemberInfo->sType = pName;

            pMemberInfo->pmeminfoNext = NULL;
            pMemberInfo->dwOffset = 0;
            pMemberInfo->IndLevel = 1;
            pMemberInfo->pktCache = 0;

            pTypesInfo->iPackSize = PackCurrentPacking() < SIZEOFPOINTER ?
                                      PackCurrentPacking() : SIZEOFPOINTER;
            pTypesInfo->Size = SIZEOFPOINTER;
            pTypesInfo->dwMemberSize = bufallocinfo.dwLen;
            pTypesInfo->Flags |= BTI_VIRTUALONLY;

            ///////////////////////////////////////////////////////////////////////////////
            //Build the list of functions in the VTBL
            ///////////////////////////////////////////////////////////////////////////////

            //copy methods over to Methods and IMethods
            for(pThisElement = pMemberFuncs; pThisElement != NULL; pThisElement = pThisElement->pNext) {
                if(pThisElement->pTypeInfo != NULL) {
                    if(!AppendToMultiSz(pTypesInfo->Methods, pThisElement->pTypeInfo->TypeName, MEMBERMETHODSSIZE) ||
                        !AppendToMultiSz(pTypesInfo->IMethods, pThisElement->pTypeInfo->TypeName, MEMBERMETHODSSIZE)) {
                        ExitErrMsg(FALSE,"Too many methods in %s\n", pTypesInfo->TypeName);
                    }
                    GenerateProxy(pTypesInfo->TypeName, pThisElement->pTypeInfo);
                    dwElements++;
                }
            }

            pTypesInfo->dwVTBLSize = dwElements;
            pTypesInfo->dwVTBLOffset = 0;

            //If this is IUnknown, it is a COM object
            if (strcmp("IUnknown", pTypesInfo->TypeName) == 0)
                pTypesInfo->Flags |= BTI_ISCOM;

        }

    }

    else {

        if(!pCopyStructMembers(pTypesInfo, FALSE, &pMemberFuncs, pBaseType->Size, pBaseType->iPackSize)) {
            FreeTypeInfoList(pMemberFuncs);
            return FALSE;
        }
        // This checks that structures with data member are not mixed with structures with virtual methods.
        // This is a sortpp limitation that makes computing the packing size during inheritance easier.
        // The if statement say that a valid inheritance is either.
        // 1. The derived class does not add new virtual methods or data members.
        // 2. The derived class does not add new virtual methods, adds no new data members, and it inherites from a class with no virtual functions.
        // 3. The derived class adds virtual functions, adds no new data members, and the base class has no data members.
        if (!((pMemberFuncs == NULL && pTypesInfo->dwMemberSize == 0) ||
              (pMemberFuncs == NULL && pTypesInfo->dwMemberSize > 0 && pBaseType->dwVTBLSize == 0) ||
              (pMemberFuncs != NULL && pTypesInfo->dwMemberSize == 0 && pBaseType->SizeMembers == 0)
             )) {
            ErrMsg("Error: struct %s mixes data members and virtual functions(sortpp limitation).\n", pTypesInfo->TypeName);
            ErrMsg("pMemberFuncs %p\n pTypesInfo->dwMemberSize %x\n pBaseType->Flags %x\n pBaseType->pmeminfo %p\n",
                    pMemberFuncs,
                    pTypesInfo->dwMemberSize,
                    pBaseType->Flags,
                    pBaseType->pmeminfo);
            FreeTypeInfoList(pMemberFuncs);
            return FALSE;
        }

        pTypesInfo->dwVTBLSize = pTypesInfo->dwVTBLOffset = pBaseType->dwVTBLSize;
        pTypesInfo->Flags |= (pBaseType->Flags & ~BTI_HASGUID);
        if(pMemberFuncs == NULL) {

            char *Members;
            PMEMBERINFO pHead, pTail, pTemp;

            if (pBaseType->pmeminfo != NULL)
                pHead = (PMEMBERINFO)pBaseType->pmeminfo;
            else
                pHead = NULL;

            if (pTypesInfo->dwMemberSize > 0)
                pTail = (PMEMBERINFO)pTypesInfo->Members;
            else
                pTail = NULL;

            /////////////////////////////////////////////////////////////////////////////
            //Allocate memory for the temp array
            /////////////////////////////////////////////////////////////////////////////
            Members = GenHeapAlloc(FUNCMEMBERSIZE);

            if (Members == NULL)
                ExitErrMsg(FALSE, "Out of memory!\n");

            /////////////////////////////////////////////////////////////////////////////
            //merge members lists with basetype
            /////////////////////////////////////////////////////////////////////////////

            //copy the concatination of the two to the temp buffer
            BufAllocInit(&bufallocinfo, Members, FUNCMEMBERSIZE, 0);
            pTemp = CatMeminfo(&bufallocinfo, pHead, pTail, 0, FALSE);

            ////////////////////////////////////////////////////////////////////////
            //copy members from temp buffers back to pTypesInfo
            ////////////////////////////////////////////////////////////////////////
            memset( pTypesInfo->Members, 0, FUNCMEMBERSIZE );
            BufAllocInit(&bufallocinfo, pTypesInfo->Members, FUNCMEMBERSIZE, 0);
            if (pTemp) {
                // Only call this one if the first one did anyting.  Otherwise
                // This one reads from uninitialized heap.
                CatMeminfo(&bufallocinfo, (PMEMBERINFO)Members, NULL, 0, FALSE);
            }
            pTypesInfo->dwMemberSize = bufallocinfo.dwLen;

            GlobalFree(Members);
        }

        else {

            PTYPEINFOELEMENT pThisElement;
            DWORD dwElements = 0;

            // This struct is virtual only since methods are being added.  We already checked that no
            // data members will be in the structure.
            pTypesInfo->Flags |= BTI_VIRTUALONLY;

            ////////////////////////////////////////////////////////
            //Copy base members over
            ////////////////////////////////////////////////////////

            memset( pTypesInfo->Members, 0, FUNCMEMBERSIZE );
            BufAllocInit(&bufallocinfo, pTypesInfo->Members, FUNCMEMBERSIZE, 0);
            CatMeminfo(&bufallocinfo, pBaseType->pmeminfo, NULL, 0, FALSE);
            pTypesInfo->dwMemberSize = bufallocinfo.dwLen;

            ///////////////////////////////////////////////////////////////////////////////
            //Build the list of functions in the VTBL
            ///////////////////////////////////////////////////////////////////////////////

            //copy unique methods over to IMethods
            for(pThisElement = pMemberFuncs; pThisElement != NULL; pThisElement = pThisElement->pNext) {
                if(pThisElement->pTypeInfo != NULL) {
                    if (!IsInMultiSz(pBaseType->Methods, pThisElement->pTypeInfo->TypeName)) {
                        if(!AppendToMultiSz(pTypesInfo->IMethods, pThisElement->pTypeInfo->TypeName,
                            MEMBERMETHODSSIZE)) {
                            ExitErrMsg(FALSE,"Too many methods in %s\n", pTypesInfo->TypeName);
                        }
                        GenerateProxy(pTypesInfo->TypeName, pThisElement->pTypeInfo);
                        dwElements++;
                    }
                }
            }

            memcpy(pTypesInfo->Methods, pBaseType->Methods, SizeOfMultiSz(pBaseType->Methods));
            if (!CatMultiSz(pTypesInfo->Methods, pTypesInfo->IMethods, MEMBERMETHODSSIZE))
                ExitErrMsg(FALSE, "Too many methods in %s\n", pTypesInfo->TypeName);

            pTypesInfo->dwVTBLSize = dwElements + pBaseType->dwVTBLSize;
            pTypesInfo->dwVTBLOffset = pBaseType->dwVTBLSize;

        }

    }

    FreeTypeInfoList(pMemberFuncs);
    return TRUE;
}

void
BumpStructUnionSize(
    DWORD *pdwSize,
    DWORD dwElemSize,
    BOOL bUnion
    )
/*++

Routine Description:

    Updates overall size of a struct/union

Arguments:

    pdwSize      -- [IN OUT] overall size of struct/union
    dwElemSize   -- size of new element to add into the struct/union
    bUnion       -- TRUE if a union, FALSE if a struct

Return Value:

    None.

--*/
{
    if (bUnion) {
        //
        // Size of a union is max(dwSize, dwElementSize)
        //
        if (dwElemSize > *pdwSize) {
            *pdwSize = dwElemSize;
        }
    } else {
        //
        // Size of a struct is current size of struct plus element size
        //
        *pdwSize = *pdwSize + dwElemSize;
    }
}

BOOL
ParseGuid(
    GUID *pGuid
    )
{
/*++

Routine Description:

    Parses a guid of the type found in a variable declaration.

Arguments:

    pGuid    -  [OUT] ptr to the guid.

Return Value:

    TRUE    - Guid parsed.
    FALSE   - Parse failed.

--*/
    unsigned int c;
    LONGLONG value;

    if (CurrentToken()->TokenType != TK_LBRACE) return FALSE;
    ConsumeToken();

    if (CurrentToken()->TokenType != TK_NUMBER) return FALSE;
    value = expr();
    if (value < 0 || value > 0xFFFFFFFF) return FALSE;
    pGuid->Data1 = (unsigned long)value;

    if (CurrentToken()->TokenType != TK_COMMA) return FALSE;
    ConsumeToken();

    if (CurrentToken()->TokenType != TK_NUMBER) return FALSE;
    value = expr();
    if (value < 0 || value > 0xFFFF) return FALSE;
    pGuid->Data2 = (unsigned short)value;

    if (CurrentToken()->TokenType != TK_COMMA) return FALSE;
    ConsumeToken();

    if (CurrentToken()->TokenType != TK_NUMBER) return FALSE;
    value = expr();
    if (value < 0 || value > 0xFFFF) return FALSE;
    pGuid->Data2 = (unsigned short)value;


    if (CurrentToken()->TokenType != TK_COMMA) return FALSE;
    ConsumeToken();

    if (CurrentToken()->TokenType != TK_LBRACE) return FALSE;
    ConsumeToken();

    c = 0;
    while(TRUE) {

        if (CurrentToken()->TokenType != TK_NUMBER) return FALSE;
        value = expr();
        if(value < 0 || value > 0xFF) return FALSE;
        pGuid->Data4[c] = (unsigned char)value;

        if (7 == c) break;

        if (CurrentToken()->TokenType != TK_COMMA) return FALSE;
        ConsumeToken();

        c++;

    }

    for(c=0; c<2; c++) {
        if (CurrentToken()->TokenType != TK_RBRACE) return FALSE;
        ConsumeToken();
    }

    return TRUE;

}

BOOL
ParseVariables(
    VOID
    )
{

/*++

Routine Description:

    Attempts to parse a variable declaration. If successful, the variable
    is added to the variable list.

Arguments:

    none

Return Value:

    TRUE - If success.

--*/


    TYPESINFO TypesInfo;
    GUID Guid;
    char *Name;

    ConsumeConstVolatileOpt();
    if (!GetExistingType(&TypesInfo, NULL, NULL)) return FALSE;
    while(CurrentToken()->TokenType == TK_STAR) ConsumeToken();

    if (CurrentToken()->TokenType == TK_DECLSPEC) {
        ConsumeDeclSpecOpt(FALSE, FALSE, NULL, NULL, NULL);
    }

    //next token should be the variable name
    if (CurrentToken()->TokenType != TK_IDENTIFIER) return FALSE;
    Name = CurrentToken()->Name;
    ConsumeToken();

    if (CurrentToken()->TokenType == TK_EOS) return AddVariable(Name, NULL);
    if (CurrentToken()->TokenType != TK_ASSIGN) return FALSE;
    ConsumeToken();

    if (CurrentToken()->TokenType == TK_NUMBER || CurrentToken()->TokenType == TK_STRING) {
        ConsumeToken();
        if (CurrentToken()->TokenType == TK_EOS) return AddVariable(Name, NULL);
        return FALSE;
    }
    else if (CurrentToken()->TokenType == TK_LBRACE) {
        //attempt to parse a guid definition
        if (ParseGuid(&Guid) &&
            CurrentToken()->TokenType == TK_EOS) return AddVariable(Name, &Guid);
        else return FALSE;
    }
    else return FALSE;

}

BOOL
GetArrayIndex(
    DWORD *pdw
    )
/*++

Routine Description:

    Parses the size of an array index by evaluating a C-language constant
    expression.

Arguments:

    pdw     -- [OUT] ptr to size of the array index.

Return Value:

    TRUE if array index parsed (CurrentToken points after the ']')
    FALSE if parse failed.

--*/
{
    LONGLONG value;

    *pdw = 0;       // assume no size

    if (CurrentToken()->TokenType != TK_LSQUARE) {
        return FALSE;
    }
    ConsumeToken();

    value = expr();
    if (value < 0 || value > 0xFFFFFFFF) return FALSE;

    *pdw = (DWORD)value;

    if (CurrentToken()->TokenType != TK_RSQUARE) {
        return FALSE;
    }
    ConsumeToken();

    return TRUE;
}

LONGLONG
expr(
    void
    )

{
    LONGLONG val = expr_a1();

    while(1) {
        switch (CurrentToken()->TokenType) {
        case TK_BITWISE_AND:
            ConsumeToken();
            val &= expr_a1();
            break;

        case TK_BITWISE_OR:
            ConsumeToken();
            val |= expr_a1();
            break;

        default:
            return val;
        }
    } while (1);

}

LONGLONG
expr_a1(
    void
    )
{
    LONGLONG val = expr_a();

    while(1) {
        switch (CurrentToken()->TokenType) {
        case TK_LSHIFT:
            ConsumeToken();
            val <<= expr_a();
            break;

        case TK_RSHIFT:
            ConsumeToken();
            val >>= expr_a();
            break;

        default:
            return val;
        }
    }

}

LONGLONG
expr_a(
    void
    )
/*++

Routine Description:

    Parses a C-language constant expression and returns the value - handles
    the operators 'plus' and 'minus'.

Arguments:

    None.

Return Value:

    Value of the expression.

--*/
{
    LONGLONG val = expr_b();

    do
    {
        switch (CurrentToken()->TokenType) {
        case TK_PLUS:
            ConsumeToken();
            val += expr_b();
            break;

        case TK_MINUS:
            ConsumeToken();
            val -= expr_b();
            break;

        default:
            return val;
        }
    } while (1);
}

LONGLONG
expr_b(
    void
    )
/*++

Routine Description:

    Part of expression evaluator - handles the highest-precedence operators
    'multiply' and 'divide'.

Arguments:

    None.

Return Value:

    Value of the expression.

--*/
{
    LONGLONG val = expr_c();

    do
    {
        switch (CurrentToken()->TokenType) {
        case TK_STAR:
            ConsumeToken();
            val *= expr_c();
            break;

        case TK_DIVIDE:
            ConsumeToken();
            val /= expr_c();
            break;

        case TK_MOD:
            ConsumeToken();
            val %= expr_c();
            break;

        default:
            // done
            return val;
        }
    } while (1);

}

LONGLONG
expr_c(
    void
    )
/*++

Routine Description:

    Part of expression evaluator - handles unary parts of the expression, like
    numbers, unary minus, and parentheses.

Arguments:

    None.

Return Value:

    Value of the expression.

--*/
{
    LONGLONG val;
    PKNOWNTYPES pkt;

    switch (CurrentToken()->TokenType) {
    case TK_NUMBER:
        val = CurrentToken()->dwValue;
        ConsumeToken();
        break;

    case TK_MINUS:  // unary minus
        ConsumeToken();
        val = -expr_c();
        break;

    case TK_TILDE:  // unary not
        ConsumeToken();
        val = ~expr_c();
        break;

    case TK_LPAREN:
        ConsumeToken();
        val = expr();
        if (CurrentToken()->TokenType != TK_RPAREN) {
            ErrMsg("Syntax error:  expected ')'");
        }
        ConsumeToken();
        break;

    case TK_RSQUARE:
        val = 0;
        break;

    case TK_SIZEOF:
        ConsumeToken(); // eat the sizeof keyword
        if (CurrentToken()->TokenType != TK_LPAREN) {
            ErrMsg("Expected '(' after 'sizeof\n");
            val = 0;
            break;
        }
        ConsumeToken(); // eat the '('
        if (CurrentToken()->TokenType == TK_STRING) {
            // sizeof(string literal)
            val = strlen(CurrentToken()->Name) + 1;
            ConsumeToken();
        } else {
            // sizeof(some type)
            TYPESINFO TypesInfo;
            DWORD dwIndLevel;
            DWORD dwSize;

            if (!GetExistingType(&TypesInfo, NULL, NULL)) {
                ExitErrMsg(FALSE, "Parse error in sizeof(typename)\n");
            }
            dwIndLevel = 0;
            ParseIndirection(&dwIndLevel, &dwSize, NULL, NULL, NULL);
            if (dwIndLevel) {
                val = (int)dwSize;
            } else {
                val = TypesInfo.Size;
            }
        }
        if (CurrentToken()->TokenType != TK_RPAREN) {
            ErrMsg("Expected ')' after 'sizeof(expr)\n");
        val = 0;
            break;
        }
        ConsumeToken(); // eat the ')'
        break;

    default:
        ErrMsg("Syntax error parsing expression\n");
        val = 0;
        break;
    }

    return val;
}


int
CreatePseudoName(
    char *pDst,
    char *pSrc
    )
/*++

Routine Description:

    Prefixes a given name with an index number and copies it into a buffer.

Arguments:

    pDst        -- [OUT] destination for the new name
    pSrc        -- [IN]  source for the base name (may be same as pDst)

Return Value:

    Chars copied, 0 for failure.

--*/
{
   static PseudoNameIndex = 0;
   int Len;
   char Buffer[MAX_PATH];

   Len = _snprintf(Buffer,
                   sizeof(Buffer) - 1,
                   "__wx86%2.2d%s",
                   PseudoNameIndex++,
                   pSrc
                   );

   if (Len <= 0) {
       ErrMsg("cpn: buffer overflow <%s>\n", pSrc);
       return 0;
       }

   strcpy(pDst, Buffer);

   return Len;

}




void
PackPush(
    char *sIdentifier
    )
/*++

Routine Description:

    Handles '#pragma pack (push...)'

Arguments:

    sIdentifier     -- [OPTIONAL] name to associate with the current pack level

Return Value:

    None.  Pack-stack updated.

--*/
{
    PACKHOLDER *ppackholder;

    if (!sIdentifier) {
        sIdentifier = "";
    }

    DbgPrintf("push (%d)\n", PackCurrentPacking());

    ppackholder = GenHeapAlloc(sizeof(PACKHOLDER) + strlen(sIdentifier));
    if (ppackholder == NULL) {
        ExitErrMsg(FALSE, "Out of memory for packing stack");
    }

    ppackholder->dwPacking = PackCurrentPacking();
    ppackholder->ppackholderNext = ppackholderHead;
    strcpy(ppackholder->sIdentifier, sIdentifier);
    ppackholderHead = ppackholder;
}


DWORD
PackPop(
    char *sIdentifier
    )
/*++

Routine Description:

    Handles '#pragma pack (pop...)'

Arguments:

    sIdentifier -- [OPTIONAL] name to pop to

Return Value:

    Returns new packing value.  Pack-stack updated.

--*/
{
    PACKHOLDER *ppackholder;
    PACKHOLDER *ppackholderPop;
    PACKHOLDER *ppackholderNext;
    DWORD dw = DEFAULTPACKINGSIZE;

    if (ppackholderHead == NULL) {
        ExitErrMsg(FALSE, "Error:  '#pragma pack' stack underflow.");
    }

    if (sIdentifier == NULL) {
        ppackholder = ppackholderHead;
        ppackholderHead = ppackholder->ppackholderNext;
        dw = ppackholder->dwPacking;
        GenHeapFree(ppackholder);
    } else {
        ppackholderPop = ppackholderHead;
        do {
            DbgPrintf("Poping for %s [%s]\n", sIdentifier, ppackholderPop ? ppackholderPop->sIdentifier : "-");
            ppackholderNext = ppackholderPop->ppackholderNext;
            if (strcmp(sIdentifier, ppackholderPop->sIdentifier) == 0) {
                dw = ppackholderPop->dwPacking;
                break;
            }
            ppackholderPop = ppackholderNext;
        } while (ppackholderPop != NULL);

        DbgPrintf("Found %s\n", ppackholderPop ? ppackholderPop->sIdentifier : "-");
        if (ppackholderPop != NULL) {
            ppackholderNext = ppackholderHead;
            do {
                ppackholder = ppackholderNext;
                ppackholderNext = ppackholder->ppackholderNext;
                ppackholderHead = ppackholderNext;
                GenHeapFree(ppackholder);
            } while (ppackholder != ppackholderPop);
        }
    }

    DbgPrintf("pop (%d)\n", dw);
    return(dw);
}

BOOL
PrepareMappedMemory(
    void
    )
/*++

Routine Description:

    Creates the memory for the .PPM file.

Arguments:

    None.

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    PCVMHEAPHEADER pHeader;
    hCvmHeap = CreateAllocCvmHeap(uBaseAddress,     // uBaseAddress
                       uReserveSize,   // uReservedSize
                       0x00010000,     // uRegionSize
                       0,              // uUncommited
                       0,              // uUnReserved
                       0);             // uAvailable

    if (hCvmHeap != NULL) {

        // create the heap header
        pHeader = SortppAllocCvm(sizeof(CVMHEAPHEADER));
        if (!pHeader) {
            return FALSE;
        }
        pHeader->Version = VM_TOOL_VERSION;
        pHeader->BaseAddress = (ULONG_PTR)GetCvmHeapBaseAddress(hCvmHeap);

        fpTypesListMalloc = SortppAllocCvm;

        FuncsList = &pHeader->FuncsList;
        StructsList = &pHeader->StructsList;
        TypeDefsList = &pHeader->TypeDefsList;
        NIL = &pHeader->NIL;
    }

    return(hCvmHeap != NULL);
}


PVOID
SortppAllocCvm(
    ULONG Size
    )
/*++

Routine Description:

    Allocates memory from the .PPM file mapping.

Arguments:

    None.

Return Value:

    ptr to new memory, or NULL on failure.

--*/
{
    return AllocCvm(hCvmHeap, Size);
}


BOOL
WritePpmFile(
    char *PpmName
    )
/*++

Routine Description:

    Write the .PPM file out to disk.

Arguments:

    Ppmname     -- [IN] name for .PPM file

Return Value:

    TRUE on success, FALSE on failure.

--*/
{
    NTSTATUS Status;
    BOOL bSuccess;
    HANDLE hPpmFile;
    DWORD BytesWritten;
    ULONG_PTR uBaseAddress = (ULONG_PTR)GetCvmHeapBaseAddress(hCvmHeap);
    ULONG_PTR uAvailable = (ULONG_PTR)GetCvmHeapAvailable(hCvmHeap);

    hPpmFile = CreateFile(PpmName,
                          GENERIC_WRITE,
                          0,
                          NULL,
                          CREATE_ALWAYS,
                          FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                          NULL
                          );

    if (hPpmFile == INVALID_HANDLE_VALUE) {
        ExitErrMsg(FALSE,
                   "CreateFile(%s) failed %x\n",
                   PpmName,
                   GetLastError()
                   );
    }

    if (!AddOpenFile(PpmName, 0, hPpmFile)) {
        ExitErrMsg(FALSE, "AddOpenFile failed\n");
    }

#if _WIN64
    if ((uAvailable - uBaseAddress) > MAXHALF_PTR) {
        ExitErrMsg(FALSE, "Attempt to write more than 0x%x bytes not allowed\n", MAXHALF_PTR);
    }
#endif

    bSuccess = WriteFile(hPpmFile,
                         (PVOID)uBaseAddress,
                         (DWORD)(uAvailable - uBaseAddress),
                         &BytesWritten,
                         NULL
                         );

    if (!bSuccess || BytesWritten != uAvailable - uBaseAddress) {
        ExitErrMsg(FALSE,
                   "WriteFile(%s) failed %x\n",
                   PpmName,
                   GetLastError()
                   );
    }

    DelOpenFile(0, hPpmFile);
    CloseHandle(hPpmFile);
    return TRUE;
}

void
HandlePreprocessorDirective(
    char *Line
    )
/*++

Routine Description:

    Scan and process a '#' preprocessor directive.
    Accepts:
        #pragma line LINENUM SOURCEFILE
        #pragma pack( [ [ { push | pop}, ] [  identifier,  ] ] [ n ] )

Arguments:

    Line    -- ptr to the source line (points at the '#' character)

Return Value:

    None.

--*/
{
    char *p;

    // skip over '#' character
    Line++;

    // skip over any spaces between '#' and the next token
    while (*Line == ' ' || *Line == '\t') {
        Line++;
    }

    // find the first token
    for (p = Line; isalpha(*p); ++p)
        ;

    *p = '\0';

    if (strcmp(Line, "pragma") == 0) {
        //
        // found: #pragma
        //
        char c;
        p++;

        while (*p == ' ' || *p == '\t') {
            p++;
        }

        //
        // Set 'Line' to the start of the word following '#pragma' and
        // move 'p' to the character following that word.
        //
        for (Line = p; isalpha(*p); ++p)
            ;

        //
        // Null-terminate the keyword, but save the overwritten character
        // for later.
        //
        c = *p;
        *p = '\0';

        if (strcmp(Line, "pack") != 0) {
            //
            // Might be "warning", "function" or "once".  Ignore these.
            //
            return;
        }

        //
        // Remove the null-terminator from the pragma and move 'p' to the
        // first character after "#pragma pack"
        //
        *p = c;
        while (*p == ' ' || *p == '\t') {
            p++;
        }

        if (*p == '\0') {
            //
            // Found: "#pragma pack" all by itself.  Reset packing to the
            // default value.
            //
            PackModify(DEFAULTPACKINGSIZE);
            return;
        } else if (*p != '(') {
            ExitErrMsg(FALSE, "Unknown '#pragma pack' syntax '%s'.\n", Line);
        }

        //
        // skip over the '(' character and any whitespace
        //
        do {
            p++;
        } while (*p == ' ' || *p == '\t');

        if (isdigit(*p)) {
            //
            // Found: '#pragma pack(NUMBER)'
            //
            PackModify(atol(p));
            //
            // Don't worry about the closing ')' - assume things are alright.
            //
            return;
        } else if (*p == ')') {
            //
            // Found: '#pragma pack()'
            //
            PackModify(DEFAULTPACKINGSIZE);
            return;
        } else if (!isalpha(*p)) {
            ExitErrMsg(FALSE, "Bad '#pragma pack' syntax '%s'.\n", Line);
            return;
        }

        //
        // Grab the next keyword following '#pragma pack('
        //
        for (Line = p; isalpha(*p); ++p)
            ;
        c = *p;
        *p = '\0';

        if (strcmp(Line, "push") == 0) {
            //
            // Restore the old character and skip over any whitespace
            //
            *p = c;
            while (*p == ' ' || *p == '\t') {
                p++;
            }

            if (*p == ',') {
                //
                // Skip the ',' and any whitespace
                //
                do {
                    p++;
                } while (*p == ' ' || *p == '\t');

                if (isdigit(*p)) {
                    //
                    // Found: "#pragma pack(push, n)"
                    //
                    PackPush(NULL);
                    PackModify(atoi(p));
                } else if (isalpha(*p) || *p == '_') {
                    //
                    // Found an identifier after "#pragma pack(push, ".
                    // Scan ahead to end of identifier.
                    //
                    Line = p;
                    do {
                        p++;
                    } while (isalnum(*p) || *p == '_');

                    //
                    // null-terminate the identifier, in 'Line'
                    //
                    c = *p;
                    *p = '\0';

                    //
                    // Skip past whitespace
                    //
                    while (c == ' ' || c == '\t') {
                        p++;
                        c = *p;
                    }
                    // 'c' is the first non-white char after identifier


                    if (c == ')') {
                        //
                        // Found: "#pragma pack(push, identifier)"
                        //
                        PackPush(Line);
                    } else if (c == ',') {
                        //
                        // Expect a number as the last thing on the line
                        //
                        PackPush(Line);
                        PackModify(atoi(p+1));
                    } else {
                        ExitErrMsg(FALSE, "Unknown #pragma pack syntax '%s' at %s(%d)\n", p, SourceFileName, StatementLineNumber );
                    }
                } else {
                    ExitErrMsg(FALSE, "Unknown #pragma pack syntax '%s'\n", p);
                }
            } else if (*p == ')') {
                //
                // Found: "#pragma pack(push)"
                //
                PackPush(NULL);

            } else {
                ExitErrMsg(FALSE, "Bad '#pragma pack(push)' syntax '%s' at %s(%d).\n", Line, SourceFileName, StatementLineNumber);
            }

        } else if (strcmp(Line, "pop") == 0) {
            //
            // Restore the old character and skip over any whitespace
            //
            *p = c;
            while (*p == ' ' || *p == '\t') {
                p++;
            }

            if (*p == ')') {
                //
                // Found: "#pragma pack(pop)"
                //
                PackModify(PackPop(NULL));
            } else if (*p == ',') {
                //
                // Found: "#pragma pack(pop, identifier)"
                //
                p++;
                while (*p == ' ' || *p == '\t') p++;

                if (!(isalpha(*p) || *p == '_'))
                    ExitErrMsg(FALSE, "Bad '#pragma pack(pop)' syntax '%s' at %s(%d).\n", p, SourceFileName, StatementLineNumber);

                Line = p;
                do {
                    p++;
                } while (isalnum(*p) || *p == '_');
                *p = '\0';
                PackModify(PackPop(Line));
            } else {
                ExitErrMsg(FALSE, "Bad '#pragma pack(pop)' syntax '%s' at %s(%d).\n", p, SourceFileName, StatementLineNumber);
            }
        } else {
            ExitErrMsg(FALSE, "Bad '#pragma pack' syntax '%s' at %s(%d).\n", Line, SourceFileName, StatementLineNumber);
        }

    } else if (strcmp(Line, "line") == 0) {
        //
        // found: #line LINE_NUMBER "FILENAME"
        //
        int i;

        //
        // skip over any spaces between '#line' and the line number
        //
        p++;
        while (*p == ' ' || *p == '\t') {
            p++;
        }

        //
        // copy in the new line number
        //
        SourceLineNumber = 0;
        while (isdigit(*p)) {
            SourceLineNumber = SourceLineNumber * 10 + *p - '0';
            p++;
        }
        SourceLineNumber--;

        //
        // Skip over any spaces between line number and the filename
        //
        while (*p == ' ' || *p == '\t') {
          p++;
        }

        //
        // Skip over the opening quote
        //
        if (*p == '\"') {
            p++;
        } else {
            ExitErrMsg(FALSE, "Badly-formed #line directive - filename missing");
        }

        //
        // Copy in the filename, converting "\\" sequences to single '\'
        //
        for (i=0; *p && *p != '\"' && i<sizeof(SourceFileName)-1; ++i, ++p) {
            if (*p == '\\' && p[1] == '\\') {
                p++;
            }
            SourceFileName[i] = *p;
        }
        SourceFileName[i] = '\0';
        StatementLineNumber = SourceLineNumber;
    } else {
        ExitErrMsg(FALSE, "Unknown '#' directive (%s).\n", Line);
    }

}


BOOL
LexNextStatement(
    void
    )
/*++

Routine Description:

    Read from the input file and perform lexical analysis.  On return, an
    entire C-language statement has been tokenized.  Use CurrentToken(),
    ConsumeToken(), and CurrentTokenIndex to access the tokenized statement.

    The preprocessor recognizes #pragma and #line directives, ignoring all
    other directives.

Arguments:

    None.

Return Value:

    TRUE if analysis successful.
        - Tokens[] is filled in with the tokenized statement
        - CurrentTokenIndex is set to 0
        - StatmentLineNumber is the line number in the original header file
          corresponding to the first token in the statement
        - SourceFileName[] is the name of the current header file
        - SourceFileLineNumber is the current line number in the header file
    FALSE if end-of-file encountered.

--*/
{
    static char Line[MAX_CHARS_IN_LINE+2];  // a line from the .pp file
    static char *p;                         // ptr into Line[]
    BOOL fParseDone;

    //
    // Clean up after the previous statment and prep for the next statement
    //
    ResetLexer();
    StatementLineNumber = SourceLineNumber;

    //
    // Lex source lines until a complete statement is recognized.  That
    // occurs when a ';' character is found at file-scope.
    //
    do {

        if (p == NULL || *p == '\0') {
            do {
                //
                // Get an entire source line from the file, and set p to
                // point to the first non-space character
                //
                if (feof(fpHeaders)) {
                    return FALSE;
                }

                SourceLineNumber++;
                if (!fgets(Line, MAX_CHARS_IN_LINE, fpHeaders)) {
                    return FALSE;
                }
                for (p = Line; isspace(*p); ++p)
                    ;
            } while (*p == '\0');
        }

        StatementLineNumber = SourceLineNumber;
        p = LexOneLine(p, TRUE, &fParseDone);

    } while (!fParseDone);

    CurrentTokenIndex = 0;
    return TRUE;
}


BOOL
ConsumeDeclSpecOpt(
    BOOL IsFunc,
    BOOL bInitReturns,
    BOOL *pIsDllImport,
    BOOL *pIsGuidDefined,
    GUID *pGuid
    )
/*++

Routine Description:

    Comsumes a __declspec modifier. Returns are unaffected if the corresponding
    __declspec is not found.


    Accepts:
        <not a __declspec keyword>
        __declspec()
        __declspec(naked)           (only if parsing functions)
        __declspec(thread)          (only if parsing data)
        __declspec(novtable)        (only if parsing data)
        __declspec(uuid(GUID))      (only if parsing data)
        __declspec(dllimport)       (both functions and data)
        __declspec(dllexport)       (both functions and data)
        __declspec(align(x))        (only if parsing data)

Arguments:

    IsFunc  -- TRUE if parsing a function declaration, FALSE if parsing
               a data/object declaration.  Affects which keywords are
               allowed within the __declspec.
    bInitReturns -- TRUE if returns should be initialized to FALSE.
    pIsDllImport -- [OPTIONAL OUT] set to TRUE if __declspec(dllimport) found
    pIsGuidDefined -- [OPTIONAL OUT] set to TRUE if __declspec(uuid(GUID)) found
    pGuid -- [OPTIONAL OUT] set to guid of __declspec(uuid(GUID)) if found.

Return Value:

    TRUE if __declspec consumed OK, FALSE if __declspec parse error.

--*/
{

    int OldTokenIndex;
    OldTokenIndex = CurrentTokenIndex;

    if (bInitReturns) {
        if (pIsDllImport != NULL) *pIsDllImport = FALSE;
        if (pIsGuidDefined != NULL) *pIsGuidDefined = FALSE;
    }

    if (CurrentToken()->TokenType != TK_DECLSPEC) {
        // Reject: no __declspec found
        goto dofail;
    }
    ConsumeToken();

    if (CurrentToken()->TokenType != TK_LPAREN) {
        // Reject: __declspec found without '(' following
        goto dofail;
    }
    ConsumeToken();

    if (CurrentToken()->TokenType == TK_RPAREN) {
        // Accept:  "__declspec ()"
        ConsumeToken();
        return TRUE;
    }
    else if (CurrentToken()->TokenType != TK_IDENTIFIER) {
        goto dofail;
    }

    //handle cases for both data and functions
    if (strcmp(CurrentToken()->Name, "dllimport") == 0) {
        //Parsing: __declspec(dllimport
        if (NULL != pIsDllImport) *pIsDllImport = TRUE;
        ConsumeToken();
    }
    else if (strcmp(CurrentToken()->Name, "dllexport") == 0) {
        //Parsing: __declspec(dllexport
        ConsumeToken();
    }
    else if (IsFunc) {
        if (strcmp(CurrentToken()->Name, "naked") == 0) {
            //Parsing: __declspec(naked
            ConsumeToken();
        } else if (strcmp(CurrentToken()->Name, "noreturn") == 0) {
            //Parsing: __declspec(noreturn
            ConsumeToken();
        } else if (strcmp(CurrentToken()->Name, "address_safe") == 0) {
            //Parsing: __declspec(address_safe
            ConsumeToken();
        } else if (strcmp(CurrentToken()->Name, "noalias") == 0) {
            //Parsing: __declspec(address_safe
            ConsumeToken();
        } else if (strcmp(CurrentToken()->Name, "restrict") == 0) {
            //Parsing: __declspec(address_safe
            ConsumeToken();
        }
        else goto dofail; //reject
    }
    else { //data
        if (strcmp(CurrentToken()->Name, "thread") == 0) {
            //Parsing: __declspec(thread
            ConsumeToken();
        }
        else if (strcmp(CurrentToken()->Name, "novtable") == 0) {
            //Parsing: __declspec(novtable
            ConsumeToken();
        }
        else if (strcmp(CurrentToken()->Name, "uuid") == 0) {
            GUID gTemp;
            //Parsing: __declspec(uuid
            ConsumeToken();
            if (CurrentToken()->TokenType != TK_LPAREN) goto dofail;
            //Parsing: __declspec(uuid(
            ConsumeToken();
            if (CurrentToken()->TokenType != TK_STRING) goto dofail;
            //Parsing: __declspec(uuid(guid
            if(!ConvertStringToGuid(CurrentToken()->Name, &gTemp)) goto dofail;
            ConsumeToken();
            if (CurrentToken()->TokenType != TK_RPAREN) goto dofail;
            //Parsing: __declspec(uuid(guid)
            ConsumeToken();
            if (pIsGuidDefined != NULL) *pIsGuidDefined = TRUE;
            if (pGuid != NULL) *pGuid = gTemp;
        }
        else if (strcmp(CurrentToken()->Name, "align") == 0) {
            ConsumeToken();
            if (CurrentToken()->TokenType != TK_LPAREN) goto dofail;
            ConsumeToken();
            expr();
            if (CurrentToken()->TokenType != TK_RPAREN) goto dofail;
            ConsumeToken();
        }
        else goto dofail; //reject
    }

    if (CurrentToken()->TokenType != TK_RPAREN) {
        // Reject: expect ')' after __declspec(extended-decl-modifier)
        goto dofail;
    }
    ConsumeToken();

    // Accept: __declspec(extended-decl-modifier)
    return TRUE;

dofail:
    CurrentTokenIndex = OldTokenIndex;
    return FALSE;
}

PTYPEINFOELEMENT
TypeInfoElementAllocateLink(
    PTYPEINFOELEMENT *ppHead,
    PTYPEINFOELEMENT pThis,
    TYPESINFO *pType
    )
{

/*++

Routine Description:

        Allocates a TYPEINFOELEMENT and linked it to the end of the list.

Arguments:

        ppHead  - [IN/OUT] ptr ptr to the head of the list.
        pThis   - [IN] ptr to the tail of the list.
        pType   - [IN] ptr to the typeinfo to add to the list.

Return Value:

        NON-NULL - New tail.
        NULL     - Failure.
--*/

    PTYPEINFOELEMENT pNew= GenHeapAlloc(sizeof(struct TypeInfoListElement));
    if (NULL == pNew) ExitErrMsg(FALSE, "Out of memory!");
    pNew->pNext = NULL;
    pNew->pTypeInfo = pType;
    if (NULL == pThis) *ppHead = pNew;
    else pThis->pNext = pNew;
    return pNew;
}

BOOL
AddVariable(
    char *Name,
    GUID * pGuid
    )
{
/*++

Routine Description:

        Adds a variable to the list of declared global variabled.

Arguments:

        Name -      [IN] ptr to name of variable to add.
        pGuid -     [OPTIONAL IN] ptr to guid for this variable.

Return Value:

        TRUE - if success.
--*/
    PKNOWNTYPES pKnownTypes;
    int Len;

    if(NULL == Name) return FALSE;

    //Already in the tree
    pKnownTypes = RBFind(VarsList, Name);
    if (NULL != pKnownTypes) {
        //replace guid in list if pGuid != NULL and ignore the duplication
        if (NULL != pGuid) {
            pKnownTypes->Flags |= BTI_HASGUID;
            pKnownTypes->gGuid = *pGuid;
        }
        return TRUE;
    }

    //Create a KNOWNTYPES structure for variable
    Len = sizeof(KNOWNTYPES) + strlen(Name) + 1;
    pKnownTypes = GenHeapAlloc(Len);
    if(NULL == pKnownTypes) return FALSE;

    memset(pKnownTypes, 0, Len);
    pKnownTypes->TypeName = pKnownTypes->Names;
    strcpy(pKnownTypes->Names, Name);
    if(NULL != pGuid) {
        pKnownTypes->Flags |= BTI_HASGUID;
        pKnownTypes->gGuid = *pGuid;
    }

    RBInsert(VarsList, pKnownTypes);
    return TRUE;
}



VOID
UpdateGuids(
    VOID
    )
{
/*++

Routine Description:

        Looks for variables of whose name starts with IID_ and assigned a guid structure.
        The IID_ is striped and the guid of the corresponding struct is updated

Arguments:

        None.

Return Value:

        None.
--*/
    PKNOWNTYPES pThis;
    PKNOWNTYPES pLookup;
    char *LookupName;

    for(pThis = VarsList->pLastNodeInserted; pThis != NULL; pThis = pThis->Next) {

        //test if name has guid associated with it and that it begins with IID_
        if ((pThis->Flags & BTI_HASGUID) &&
            pThis->TypeName[0] == 'I' &&
            pThis->TypeName[1] == 'I' &&
            pThis->TypeName[2] == 'D' &&
            pThis->TypeName[3] == '_' )
        {
            //Attempt to find a structure with the name except the IID_
            LookupName = pThis->TypeName + 4; //skip the IID_
            pLookup = RBFind(StructsList, LookupName);

            if(NULL != pLookup) {

                //if types does not have a GUID defined already, copy guid from here
                if (!(pLookup->Flags & BTI_HASGUID)) {
                    pLookup->Flags |= BTI_HASGUID;
                    pLookup->gGuid = pThis->gGuid;
                }

            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\tools\ppm2pps\ppm2pps.c ===
//////////////////////////////////////////////////////////////////////////////
// ppm2pps
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
//     Dump contents of ppm file
//
//////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <imagehlp.h>
#include <ctype.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>
#include "gen.h"

// string to put in front of all error messages so that BUILD can find them.
const char *ErrMsgPrefix = "NMAKE :  U8603: 'PPM2PPS' ";

//
// global variables
BOOL fDebug;            // global debug flag
BOOL fDumpCCheck;       // when set build ppswind.h for checking sizes/offsets
HANDLE hFile;
HANDLE hMapFile = NULL;

PRBTREE pFunctions = NULL;
PRBTREE pStructures = NULL;
PRBTREE pTypedefs = NULL;
PKNOWNTYPES NIL = NULL;

// function prototypes
void __cdecl ErrMsg(char *pch, ...);
void __cdecl ExitErrMsg(BOOL bSysError, char *pch, ...);
BOOL DumpTypedefs(FILE *filePpsfile,            // file to write output
                   BOOL fDumpNamedOnly,         // when set don't do unnamed 
                   PRBTREE pHead);              // known types function list
BOOL DumpStructures(FILE *filePpsfile,          // file to write output
                   BOOL fDumpNamedOnly,         // when set don't do unnamed 
                   PRBTREE pHead);              // known types function list
BOOL DumpFunctions(FILE *filePpsfile,           // file to write output
                   BOOL fDumpNamedOnly,         // when set don't do unnamed
                   PRBTREE pHead);              // known types function list
void Usage(char *s);
BOOL ParseArguments(int argc, char *argv[], char *sPpmfile, char *sPpsfile,
                    BOOL *pfDumpNamedOnly, BOOL *pfDebug, 
                    BOOL *pfDumpCCheck);
BOOL DumpCCheckHeader(PRBTREE pTypedefs,   // typedef lsit
                      PRBTREE pStructs);   // structs sit

                        
int __cdecl main(int argc, char *argv[])
{
    void *pvPpmData = NULL;
    BOOL fDumpNamedOnly;
    char sPpmfile[MAX_PATH];
    char sPpsfile[MAX_PATH];
    FILE *pfilePpsfile;

    try {

    if (! ParseArguments(argc, argv, sPpmfile, sPpsfile, 
                                    &fDumpNamedOnly, &fDebug, &fDumpCCheck))
    {
        Usage(argv[0]);
        return(-1);
    }
    
    if (*sPpmfile)
    {
        PCVMHEAPHEADER pHeader;

        pvPpmData = MapPpmFile(sPpmfile, TRUE);

        pHeader = (PCVMHEAPHEADER)pvPpmData;

        pFunctions = &pHeader->FuncsList;
        pTypedefs =  &pHeader->TypeDefsList;
        pStructures =&pHeader->StructsList;
        NIL         =&pHeader->NIL;
    
        pfilePpsfile = fopen(sPpsfile, "w");
        if (pfilePpsfile == 0)
        {
            ErrMsg("ERROR - Could not open output file %s\n", sPpsfile);
            CloseHandle(hFile);
            CloseHandle(hMapFile);
            return(-1);
        }
    
        if (DumpFunctions(pfilePpsfile, fDumpNamedOnly, 
                                                    pFunctions))
        {
            if (DumpStructures(pfilePpsfile, fDumpNamedOnly, 
                                                    pStructures))
            {
                DumpTypedefs(pfilePpsfile,fDumpNamedOnly, pTypedefs);
            }
        }
        fclose(pfilePpsfile);
    }
    
    if (fDumpCCheck && pTypedefs && pStructures)
    {
        DumpCCheckHeader(pTypedefs, pStructures);
    }
        
    CloseHandle(hFile);
    CloseHandle(hMapFile);

   } except(EXCEPTION_EXECUTE_HANDLER) {
       ExitErrMsg(FALSE,
                  "ExceptionCode=%x\n",
                  GetExceptionCode()
                  );
       }

    return(0);
}

void
DumpFuncinfo(FILE *pfilePpsfile, PFUNCINFO pf)
{
    while (pf) {
        int i;

        fprintf(pfilePpsfile,
                "%s %s%s %s %s %s",
                TokenString[pf->tkDirection],
                (pf->fIsPtr64) ? "__ptr64 " : "",
                TokenString[pf->tkPreMod],
                TokenString[pf->tkSUE],
                pf->sType,
                TokenString[pf->tkPrePostMod]
                );
        i = pf->IndLevel;
        while (i--) {
            fprintf(pfilePpsfile, "*");
        }
        fprintf(pfilePpsfile,
                "%s %s",
                TokenString[pf->tkPostMod],
                (pf->sName) ? pf->sName : ""
                );

        pf = pf->pfuncinfoNext;
        if (pf) {
            fprintf(pfilePpsfile, ", ");
        }
    }
}


/////////////////////////////////////////////////////////////////////////////
//
//  DumpCCheckHeader
//
//      dump header file that can be used to check sizes in ppm file against
//      those that are generated by C
//
//      returns TRUE on success
//
/////////////////////////////////////////////////////////////////////////////
BOOL DumpCCheckHeader(PRBTREE pTypedefs,   // typedef lsit
                      PRBTREE pStructs)    // structs lsit

{
    PKNOWNTYPES pknwntyp, pknwntypBasic;
    FILE *pfile;
    
    pfile = fopen("ppswind.h", "w");
    if (pfile == NULL) 
    {
        ErrMsg("Error opening ppwind.h for output\n");
        return(FALSE);
    }
    
    fprintf(pfile, "CCHECKSIZE cchecksize[] = {\n");

//
// typedefs
    pknwntyp = pTypedefs->pLastNodeInserted;

    while (pknwntyp) {
        if ((! isdigit(*pknwntyp->TypeName)) &&
            (strcmp(pknwntyp->TypeName,"...")) &&
            (strcmp(pknwntyp->TypeName,"()")) && 
            (strcmp(pknwntyp->BasicType, szFUNC)) &&
            (pknwntyp->Size > 0) &&
            (pknwntyp->dwScopeLevel == 0)) {

            pknwntypBasic = GetBasicType(pknwntyp->TypeName, 
                                     pTypedefs, pStructs);

            if (! ( (pknwntypBasic == NULL) || 
                    ( (! strcmp(pknwntypBasic->BaseName, szVOID)) &&
                      (pknwntypBasic->pmeminfo == NULL)))) {
 
                fprintf(pfile, " { %4d, sizeof(%s), \"%s\"}, \n",
                    pknwntyp->Size,
                    pknwntyp->TypeName,
                    pknwntyp->TypeName);        
            }
        }
        pknwntyp = pknwntyp->Next;
    }
    
    
//
// structs
    pknwntyp = pStructs->pLastNodeInserted;

    while (pknwntyp) {
        if ((! isdigit(*pknwntyp->TypeName) &&
            (pknwntyp->pmeminfo)))
        {
            if (!(pknwntyp->Flags & BTI_ANONYMOUS) && (pknwntyp->Size > 0) && (pknwntyp->dwScopeLevel == 0)) {
                fprintf(pfile, " { %4d, sizeof(%s %s), \"%s %s\" }, \n",
                    pknwntyp->Size,
                    pknwntyp->BaseName,
                    pknwntyp->TypeName,
                    pknwntyp->BaseName,
                    pknwntyp->TypeName);
            }
        }
        pknwntyp = pknwntyp->Next;
    }

    fprintf(pfile, " {0xffffffff, 0xffffffff,  \"\"}\n");
    fprintf(pfile,"\n};\n");
    
//
// structs fields
    fprintf(pfile, "CCHECKOFFSET ccheckoffset[] = {\n");

    pknwntyp = pStructs->pLastNodeInserted;

    while (pknwntyp) {
        if (! isdigit(*pknwntyp->TypeName)) 
        {
            if (!(pknwntyp->Flags & BTI_ANONYMOUS) && !(pknwntyp->Flags & BTI_VIRTUALONLY) && (pknwntyp->Size > 0) && (pknwntyp->dwScopeLevel == 0)) {
                PMEMBERINFO pmeminfo = pknwntyp->pmeminfo;
                while (pmeminfo != NULL) {
                    if ((pmeminfo->sName != NULL) && (*pmeminfo->sName != 0) && !(pmeminfo->bIsBitfield))
                    { 
                        fprintf(pfile, " { %4d, (long) (& (((%s %s *)0)->%s)), \"%s\", \"%s\" },\n",
                            pmeminfo->dwOffset,
                            pknwntyp->BaseName,
                            pknwntyp->TypeName,
                            pmeminfo->sName,
                            pknwntyp->TypeName,                   
                            pmeminfo->sName);
                    }
                    pmeminfo = pmeminfo->pmeminfoNext;
                }
                
            }
        }
        pknwntyp = pknwntyp->Next;
    }
    
    fprintf(pfile, " {0xffffffff, 0xffffffff, \"\", \"\"}\n");
    fprintf(pfile,"\n};\n");
    fclose(pfile);
    return(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
//
//  DumpTypedefs
//
//      dump structures from ppm file to output file
//
//      returns TRUE on success
//
/////////////////////////////////////////////////////////////////////////////
BOOL DumpTypedefs(FILE *pfilePpsfile,            // file to write output
                   BOOL fDumpNamedOnly,          // when set don't do unnamed 
                   PRBTREE pHead)                // known types function list
{
    KNOWNTYPES *pknwntyp;

    pknwntyp = pHead->pLastNodeInserted;

    fprintf(pfilePpsfile,"[Typedefs]\n\n");
    while (pknwntyp) {
        fprintf(pfilePpsfile,
                   "%2.1x|%2.1x|%2.1x|%s|%s|%s|%s|%s|",
                   pknwntyp->Flags,
                   pknwntyp->IndLevel,
                   pknwntyp->Size,
                   pknwntyp->BasicType,
                   pknwntyp->BaseName ? pknwntyp->BaseName : szNULL,
                   pknwntyp->FuncRet ? pknwntyp->FuncRet : szNULL,
                   pknwntyp->FuncMod ? pknwntyp->FuncMod : szNULL,
                   pknwntyp->TypeName
                   );
        DumpFuncinfo(pfilePpsfile, pknwntyp->pfuncinfo);
        fprintf(pfilePpsfile, "|\n");

        pknwntyp = pknwntyp->Next;
    }
    return(TRUE);
}


/////////////////////////////////////////////////////////////////////////////
//
//  DumpStructures
//
//      dump structures from ppm file to output file
//
//      returns TRUE on success
//
/////////////////////////////////////////////////////////////////////////////
BOOL DumpStructures(FILE *pfilePpsfile,          // file to write output
                   BOOL fDumpNamedOnly,          // when set don't do unnamed 
                   PRBTREE pHead)                // known types function list
{
    KNOWNTYPES *pknwntyp;
    DWORD dw;
    PMEMBERINFO pmeminfo;

    pknwntyp = pHead->pLastNodeInserted;

    fprintf(pfilePpsfile,"[Structures]\n\n");
    while (pknwntyp) {
        if (! fDumpNamedOnly || ! isdigit(*pknwntyp->TypeName)) {
            fprintf(pfilePpsfile,
                   "%2.1x|%2.1x|%2.1x|%s|%s|%s|%s|%s|",
                   pknwntyp->Flags,
                   pknwntyp->IndLevel,
                   pknwntyp->Size,                
                   pknwntyp->BasicType,
                   pknwntyp->BaseName ? pknwntyp->BaseName : szNULL,
                   pknwntyp->FuncRet ? pknwntyp->FuncRet : szNULL,
                   pknwntyp->FuncMod ? pknwntyp->FuncMod : szNULL,
                   pknwntyp->TypeName);

            // dump out the structure member info, if present
            pmeminfo = pknwntyp->pmeminfo;
            while (pmeminfo) {
                int i;

                fprintf(pfilePpsfile, "%s", pmeminfo->sType);
                i = pmeminfo->IndLevel;
                if (i) {
                    fprintf(pfilePpsfile, " ");
                    while (i--) {
                        fprintf(pfilePpsfile, "*");
                    }
                }
                if (pmeminfo->sName) {
                    fprintf(pfilePpsfile, " %s", pmeminfo->sName);
                }
                fprintf(pfilePpsfile, " @ %d|", pmeminfo->dwOffset);
                pmeminfo = pmeminfo->pmeminfoNext;
            }

            // dump out the function info, if present
            DumpFuncinfo(pfilePpsfile, pknwntyp->pfuncinfo);

            fprintf(pfilePpsfile, "\n");
        }

        pknwntyp = pknwntyp->Next;
    }
    return(TRUE);
}


/////////////////////////////////////////////////////////////////////////////
//
//  DumpFunctions
//
//      dump fucntion prototypes from ppm file to output file
//
//      returns TRUE on success
//
/////////////////////////////////////////////////////////////////////////////
BOOL DumpFunctions(FILE *pfilePpsfile,            // file to write output
                   BOOL fDumpNamedOnly,           // when set don't do unnamed
                   PRBTREE pHead)                 // known types function list
{
    KNOWNTYPES *pknwntyp;
    PFUNCINFO pf;

    pknwntyp = pHead->pLastNodeInserted;

    fprintf(pfilePpsfile,"[Functions]\n\n");
    while (pknwntyp) {
        fprintf(pfilePpsfile,
                   "%s|%s|%s|%s|",
                   (pknwntyp->Flags & BTI_DLLEXPORT) ? "dllexport" : "",
                   pknwntyp->FuncRet,
                   pknwntyp->FuncMod ? pknwntyp->FuncMod : szNULL,
                   pknwntyp->TypeName
                   );
        DumpFuncinfo(pfilePpsfile, pknwntyp->pfuncinfo);
        fprintf(pfilePpsfile, "|\n");
        pknwntyp = pknwntyp->Next;
    }
    return(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
//
//  Usgae
//
//      tells how to use
//
//
/////////////////////////////////////////////////////////////////////////////
void Usage(char *s)        // name of command invoked
{
    printf("Usage:\n");
    printf("    %s -d -n -x <ppm file> <pps output file>\n", s);
    printf("        -d set debug flag\n");
    printf("        -n dumps only named structs/enums/unions\n");
    printf("        -x creates ppswind.h for size/offset checking\n");
}

/////////////////////////////////////////////////////////////////////////////
//
//  ParseArgumaners
//
//      parse arguments
//
//      returnms FALSE on syntax error
//
/////////////////////////////////////////////////////////////////////////////

BOOL ParseArguments(int argc, char *argv[], char *sPpmfile, char *sPpsfile,
                    BOOL *pfDumpNamedOnly, BOOL *pfDebug, 
                    BOOL *pfDumpCCheck)
{
    int i;
    
    *sPpmfile = 0;
    *sPpsfile = 0;
    *pfDumpNamedOnly = FALSE;
    *pfDebug = FALSE;
    *pfDumpCCheck = FALSE;
    
    for (i = 1; i < argc; i++)
    {
        if (*argv[i] == '-')
        {
            switch(tolower(argv[i][1]))
            {
                case 'd':
                {
                    *pfDebug = TRUE;
                    break;
                }
                
                case 'n':
                {
                    *pfDumpNamedOnly = TRUE;
                    break;
                }
                
                case 'x':
                {
                    *pfDumpCCheck = TRUE;
                    break;
                }
                
                default:
                {
                    return(FALSE);
                }
            }
        } else {
            if (lstrlenA(argv[i]) >= MAX_PATH)
            {
                return(FALSE);
            }
            if (*sPpmfile == 0)
            {
                strcpy(sPpmfile, argv[i]);
            } else if (*sPpsfile == 0)
            {
                strcpy(sPpsfile, argv[i]);
            } else {
                return(FALSE);
            }
        }        
    }
    return( *pfDumpCCheck || ((*sPpmfile != 0) && (*sPpsfile != 0)));
}

#pragma warning(push)
#pragma warning(disable:4702)
void
HandlePreprocessorDirective(
    char *p
    )
{
    ExitErrMsg(FALSE, "Preprocessor directives not allowed by ppm2pps\n");
}
#pragma warning(pop)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\whbase\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

!if "$(WOW64_DEBUG_THUNKGEN)" == "1"
GENTHNK_FLAGS=-d -w
!else
GENTHNK_FLAGS=-w
!endif

PPMFILE=..\cgen\$(O)\winincs.ppm
NT32HDR=..\cgen\$(O)\nt32.h

WHLOGGENDIR=..\wow64log\$(O)

WHBASETAB=..\..\win32\client\wow6432\services.tab
WHBASEC=$(O)\whbase.c
WHBASELOGC=$(WHLOGGENDIR)\whbase.c
WHBASEERRC=$(O)\whbaseerr.c

$(WHBASEC): $(PPMFILE) \
           $(BASE_INC_PATH)\apithunk.tpl \
           $(BASE_INC_PATH)\genmacro.tpl \
           $(BASE_INC_PATH)\gentypes.tpl \
           whbase.tpl \
           $(WHBASETAB)
    genthnk.exe $(GENTHNK_FLAGS) \
                -m$(PPMFILE) \
                -t$(BASE_INC_PATH)\apithunk.tpl \
                -t$(BASE_INC_PATH)\genmacro.tpl \
                -t$(BASE_INC_PATH)\gentypes.tpl \
                -twhbase.tpl \
                -c$(WHBASEC):whbase \
                -s$(WHBASETAB)

$(WHBASEERRC): $(PPMFILE) \
               whbaseerr.tpl \
               $(WHBASETAB)
    genthnk.exe $(GENTHNK_FLAGS) \
                -m$(PPMFILE) \
                -twhbaseerr.tpl \
                -c$(WHBASEERRC):whbase \
                -s$(WHBASETAB)

$(WHBASELOGC): $(PPMFILE) \
              $(BASE_INC_PATH)\apithunk.tpl \
              $(BASE_INC_PATH)\genmacro.tpl \
              $(BASE_INC_PATH)\thunklog.tpl \
              $(WHBASETAB)
    -mkdir $(WHLOGGENDIR)
    genthnk.exe $(GENTHNK_FLAGS) \
                -m$(PPMFILE) \
                -t$(BASE_INC_PATH)\apithunk.tpl \
                -t$(BASE_INC_PATH)\genmacro.tpl \
                -t$(BASE_INC_PATH)\thunklog.tpl \
                -c$(WHBASELOGC):whbaselog \
                -s$(WHBASETAB)

thunks: $(WHBASEC) $(WHBASEERRC) $(WHBASELOGC)

cleanfiles:
    -del $(WHBASEC)
    -del $(WHBASEERRC)
    -del $(WHBASELOGC)

clean: cleanfiles thunks
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\whnt32\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

!if "$(WOW64_DEBUG_THUNKGEN)" == "1"
GENTHNK_FLAGS=-d -w
!else
GENTHNK_FLAGS=-w
!endif

PPMFILE=..\cgen\$(O)\winincs.ppm
NT32HDR=..\cgen\$(O)\nt32.h

WHLOGGENDIR=..\wow64log\$(O)

WHNT32TAB=$(O)\whnt32.tab
WHNT32C=$(O)\whnt32.c
WHNT32LOGC=$(WHLOGGENDIR)\whnt32.c

$(WHNT32C): $(PPMFILE) \
           $(BASE_INC_PATH)\apithunk.tpl \
           $(BASE_INC_PATH)\genmacro.tpl \
           $(BASE_INC_PATH)\gentypes.tpl \
           whnt32.tpl \
           whnt32t.tpl \
           $(WHNT32TAB)
    genthnk.exe $(GENTHNK_FLAGS) \
                -m$(PPMFILE) \
                -t$(BASE_INC_PATH)\apithunk.tpl \
                -t$(BASE_INC_PATH)\genmacro.tpl \
                -t$(BASE_INC_PATH)\gentypes.tpl \
                -twhnt32.tpl \
                -twhnt32t.tpl \
                -c$(WHNT32C):whnt32 \
                -s$(WHNT32TAB):Nt

$(WHNT32LOGC): $(PPMFILE) \
              $(BASE_INC_PATH)\apithunk.tpl \
              $(BASE_INC_PATH)\genmacro.tpl \
              $(BASE_INC_PATH)\thunklog.tpl \
              $(WHNT32TAB)
    -mkdir $(WHLOGGENDIR)
    genthnk.exe $(GENTHNK_FLAGS) \
                -m$(PPMFILE) \
                -t$(BASE_INC_PATH)\apithunk.tpl \
                -t$(BASE_INC_PATH)\genmacro.tpl \
                -t$(BASE_INC_PATH)\thunklog.tpl \
                -c$(WHNT32LOGC):whnt32log \
                -s$(WHNT32TAB):Nt

thunks: $(WHNT32NC) $(WHNT32LOGC)

cleanfiles:
    -del $(WHNT32C)
    -del $(WHNT32LOGC)

clean: cleanfiles thunks
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64\callback.c ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    callback.c

Abstract:

    Provides generic 64-to-32 transfer routines.

Author:

    20-May-1998 BarryBo

Revision History:

    2-Sept-1999 [askhalid] Removing some 32bit alpha specific code and using right context.

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "wow64p.h"
#include "wow64cpu.h"

ASSERTNAME;

VOID
WOW64DLLAPI
Wow64ApcRoutine(
    ULONG_PTR ApcContext,
    ULONG_PTR Arg2,
    ULONG_PTR Arg3
    )
/*++

Routine Description:

    Call a 32-bit APC function.

Arguments:

    ApcContext  - wow64 APC context data
    Arg2        - second arg to APC routine
    Arg3        - third arg to APC routine

Return Value:

    None.  Returns contrl back to NTDLL's APC handler, which will
    call native NtContinue to resume execution.

--*/
{
    CONTEXT32 NewContext32;
    ULONG SP;
    PULONG Ptr;
    USER_APC_ENTRY UserApcEntry;

    //
    // Grab the current 32-bit context
    //
    NewContext32.ContextFlags = CONTEXT32_INTEGER|CONTEXT32_CONTROL;
    CpuGetContext(NtCurrentThread(),
                  NtCurrentProcess(),
                  NtCurrentTeb(),
                  &NewContext32);

    

    //
    // Build up the APC callback state in NewContext32
    //
    SP = CpuGetStackPointer() & (~3);
    SP -= 4*sizeof(ULONG)+sizeof(CONTEXT32);
    Ptr = (PULONG)SP;
    Ptr[0] = (ULONG)(ApcContext >> 32);            // NormalRoutine
    Ptr[1] = (ULONG)ApcContext;                    // NormalContext
    Ptr[2] = (ULONG)Arg2;                          // SystemArgument1
    Ptr[3] = (ULONG)Arg3;                          // SystemArgument2
    ((PCONTEXT32)(&Ptr[4]))->ContextFlags = CONTEXT32_FULL;
    CpuGetContext(NtCurrentThread(),
                  NtCurrentProcess(),
                  NtCurrentTeb(),
                  (PCONTEXT32)&Ptr[4]); // ContinueContext (BYVAL!)
    CpuSetStackPointer(SP);
    CpuSetInstructionPointer(Ntdll32KiUserApcDispatcher);

    //
    // Link this APC into the list of outstanding APCs
    //
    UserApcEntry.Next = (PUSER_APC_ENTRY)Wow64TlsGetValue(WOW64_TLS_APCLIST);
    UserApcEntry.pContext32 = (PCONTEXT32)&Ptr[4];
    Wow64TlsSetValue(WOW64_TLS_APCLIST, &UserApcEntry);

    //
    // Call the 32-bit APC function.  32-bit NtContinue will longjmp
    // back when the APC function is done.
    //
    if (setjmp(UserApcEntry.JumpBuffer) == 0) {
        RunCpuSimulation();
    }
    //
    // If we get here, Wow64NtContinue has done a longjmp back, so
    // return back to the caller (in ntdll.dll), which will do a
    // native NtContinue and restore the native stack pointer and
    // context back.
    //
    // This is critical to do.  The x86 CONTEXT above has an out-of-date
    // value for EAX.  It still contains the system-service number for
    // whatever kernel call was made that allowed the APC to run.  On
    // an x86 machine, the x86 CONTEXT above would have had STATUS_USER_APC
    // or some other code like it, but on WOW64 we don't know what value
    // to use.  The correct value is sitting in the 64-bit CONTEXT up
    // the stack from where we are.  So... by returning here via longjmp,
    // native ntdll.dll will do an NtContinue to resume execution in the
    // native Nt* API that allowed the native APC to fire.  It will load
    // the return register with the right NTSTATUS code, so the whNt*
    // thunk will see the correct code, and reflect it into EAX.
    //
}


NTSTATUS
WOW64DLLAPI
Wow64WrapApcProc(
    PVOID *pApcRoutine,
    PVOID *pApcContext
    )
/*++

Routine Description:

    Thunk a 32-bit ApcRoutine/ApcContext pair to 64-bit

Arguments:

    pApcRoutine - pointer to pointer to APC routine.  IN is the 32-bit
                  routine.  OUT is the 64-bit wow64 thunk
    pApcContext - pointer to pointer to APC context.  IN is the 32-bit
                  context.  OUT is the 64-bit wow64 thunk

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    if (*pApcRoutine) {

        //
        // Dispatch the call to the jacket routine inside Wow64
        //
        
        *pApcContext = (PVOID)((ULONG_PTR)*pApcContext | ((ULONG_PTR)*pApcRoutine << 32));
        *pApcRoutine = Wow64ApcRoutine;

    } else {

        NtStatus = STATUS_INVALID_PARAMETER;
    }

    return NtStatus;
}

ULONG
Wow64KiUserCallbackDispatcher(
    PUSERCALLBACKDATA pUserCallbackData,
    ULONG ApiNumber,
    ULONG ApiArgument,
    ULONG ApiSize
    )
/*++

Routine Description:

    Make a call from a 64-to-32 user callback thunk into 32-bit code.
    This function calls ntdll32's KiUserCallbackDispatcher, and returns
    when 32-bit code calls NtCallbackReturn/ZwCallbackReturn.

Arguments:

    pUserCallbackData - OUT struct to use for tracking this callback
    ApiNumber       - index of API to call
    ApiArgument     - 32-bit pointer to 32-bit argument to the API
    ApiSize         - size of *ApiArgument

Return Value:

    Return value from the API call

--*/
{
    CONTEXT32 OldContext;
    ULONG ExceptionList;
    PTEB32 Teb32;
    ULONG NewStack;

    //
    // Handle nested callbacks
    //
    pUserCallbackData->PreviousUserCallbackData = Wow64TlsGetValue(WOW64_TLS_USERCALLBACKDATA);

    //
    // Store the callback data in the TEB.  whNtCallbackReturn will
    // use this pointer to pass information back here via a longjmp.
    //
    Wow64TlsSetValue(WOW64_TLS_USERCALLBACKDATA, pUserCallbackData);

    if (!setjmp(pUserCallbackData->JumpBuffer)) {
        //
        // Make the call to ntdll32.  whNtCallbackReturn will
        // longjmp back to this routine when it is called.
        //
        OldContext.ContextFlags = CONTEXT32_FULL;
        CpuGetContext(NtCurrentThread(),
                      NtCurrentProcess(),
                      NtCurrentTeb(),
                      &OldContext);
        NewStack = OldContext.Esp - ApiSize;

        RtlCopyMemory((PVOID)NewStack, (PVOID)ApiArgument, ApiSize);

        *(PULONG)(NewStack - 4) = 0;  // InputLength
        *(PULONG)(NewStack - 8) = NewStack;
        *(PULONG)(NewStack - 12) = ApiNumber;
        *(PULONG)(NewStack - 16) = 0;
        NewStack -= 16;
        CpuSetStackPointer(NewStack);
        CpuSetInstructionPointer(Ntdll32KiUserCallbackDispatcher);

        //
        // Save the exception list in case another handler is defined during
        // the callout.
        //
        Teb32 = NtCurrentTeb32();
        ExceptionList = Teb32->NtTib.ExceptionList;

        //
        // Execte the callback
        //
        RunCpuSimulation();
        //
        // This never returns.  When 32-bit code is done, it calls
        // NtCallbackReturn.  The thunk does a longjmp back to this
        // routine and lands in the 'else' clause below:
        //

    } else {
        //
        // Made it back from the NtCallbackReturn thunk.  Restore the
        // 32-bit context as it was before the callback, and return
        // back to our caller.  Our caller will call 64-bit
        // NtCallbackReturn to finish blowing off the 64-bit stack.
        //
        CpuSetContext(NtCurrentThread(),
                      NtCurrentProcess(),
                      NtCurrentTeb(),
                      &OldContext);
        //
        // Restore exception list.
        //

        NtCurrentTeb32()->NtTib.ExceptionList = ExceptionList;
        return pUserCallbackData->Status;
    }

    //
    // Should never get here.
    //
    WOWASSERT(FALSE);
    return STATUS_UNSUCCESSFUL;
}


NTSTATUS
Wow64NtCallbackReturn(
    PVOID OutputBuffer,
    ULONG OutputLength,
    NTSTATUS Status
    )
{
    PUSERCALLBACKDATA pUserCallbackData; 

    //
    // Find the callback data stuffed in TLS by Wow64KiUserCallbackDispatcher
    //
    pUserCallbackData = (PUSERCALLBACKDATA)Wow64TlsGetValue(WOW64_TLS_USERCALLBACKDATA);
    if (pUserCallbackData) {
        //
        // Restore previous User Callback context
        //
        Wow64TlsSetValue(WOW64_TLS_USERCALLBACKDATA, pUserCallbackData->PreviousUserCallbackData);

        //
        // Jump back to Wow64KiUserCallbackDispatcher
        //
        pUserCallbackData->UserBuffer = NULL;
        pUserCallbackData->OutputBuffer = OutputBuffer;

        //
        // Realign the buffer
        //
        if (((SIZE_T)OutputBuffer & (sizeof(ULONGLONG)-1)) != 0) {
            
            pUserCallbackData->OutputBuffer = Wow64AllocateHeap ( OutputLength );
            
            if (pUserCallbackData->OutputBuffer == NULL) {

                pUserCallbackData->OutputBuffer = OutputBuffer;
                pUserCallbackData->Status = STATUS_NO_MEMORY;
            } else {
                
                RtlCopyMemory (pUserCallbackData->OutputBuffer, OutputBuffer, OutputLength );
                pUserCallbackData->UserBuffer = OutputBuffer;  // works as a flag
            }
        }

        pUserCallbackData->OutputLength = OutputLength;
        pUserCallbackData->Status = Status;
        longjmp(pUserCallbackData->JumpBuffer, 1);
        
        //
        // We would never come here
        //
    }
    //
    // No callback data.  Probably a non-nested NtCallbackReturn call.
    // The kernel fails these with this return value.
    //
    return STATUS_NO_CALLBACK_ACTIVE;

}

WOW64DLLAPI
NTSTATUS
Wow64NtContinue(
    IN PCONTEXT ContextRecord, // really a PCONTEXT32
    IN BOOLEAN TestAlert
    )
/*++

Routine Description:

    32-bit wrapper for NtContinue.  Loads the new CONTEXT32 into the CPU
    and optionally allows usermode APCs to run.

Arguments:

    ContextRecord   - new 32-bit CONTEXT to use
    TestAlert       - TRUE if usermode APCs may be fired

Return Value:

    NTSTATUS.

--*/
{
    PCONTEXT32 Context32 = (PCONTEXT32)ContextRecord;
    PUSER_APC_ENTRY pApcEntry;
    PUSER_APC_ENTRY pApcEntryPrev;

    CpuSetContext(NtCurrentThread(),
                  NtCurrentProcess(),
                  NtCurrentTeb(),
                  Context32);

    pApcEntryPrev = NULL;
    pApcEntry = (PUSER_APC_ENTRY)Wow64TlsGetValue(WOW64_TLS_APCLIST);
    while (pApcEntry) {
        if (pApcEntry->pContext32 == Context32) {
            //
            // Found an outstanding usermode APC on this thread, and this
            // NtContinue call matches it.  Unwind back to the right place
            // on the native stack and have it do an NtContinue too.
            //
            if (pApcEntryPrev) {
                pApcEntryPrev->Next = pApcEntry->Next;
            } else {
                Wow64TlsSetValue(WOW64_TLS_APCLIST, pApcEntry->Next);
            }
            longjmp(pApcEntry->JumpBuffer, 1);
        }
        pApcEntryPrev = pApcEntry;
        pApcEntry = pApcEntry->Next;
    }
    //
    // No usermode APC is outstanding for this context record.  Don't
    // unwind the native stack because there is no place to go... just
    // continue the simulation.
    //
    if (TestAlert) {
        NtTestAlert();
    }
    return Context32->Eax;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\tools\idlclean\idlclean.c ===
//////////////////////////////////////////////////////////////////////////////
// idlclean
//
// Copyright (c) 1996-1999 Microsoft Corporation
//
//      Takes a MIDL-generated .H file and converts the commented-out
//      [in] and [out] keywords into IN and OUT so sortpp/genthnk can
//      find them.
//
//////////////////////////////////////////////////////////////////////////////

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdlib.h>
#include <stdio.h>
#include <string.h>

// string to put in front of all error messages so that BUILD can find them.
const char *ErrMsgPrefix = "NMAKE :  U8603: 'IDLCLEAN' ";

#define BUFLEN 8192
char buffer[BUFLEN];

const char szLinePrefix[]="/* ";
const char szIn[] = "[in]";
const char szOut[] = "[out]";

                        
int __cdecl main(int argc, char *argv[])
{
    FILE *fpIn, *fpOut;
    char *p;
    char *pchLineStart;
    BOOL fInPrinted;
    BOOL fOutPrinted;

    if (argc != 3) {
        fprintf(stderr, "%sUsage: IDLCLEAN infile outfile\n", ErrMsgPrefix);
        return 1;
    }
    fpIn = fopen(argv[1], "r");
    if (!fpIn) {
        fprintf(stderr, "%sCould not open input file '%s'\n", ErrMsgPrefix, argv[1]);
        return 1;
    }
    fpOut = fopen(argv[2], "w");
    if (!fpOut) {
        fprintf(stderr, "%sCould not open output file '%s\n", ErrMsgPrefix, argv[2]);
        return 1;
    }

    while (!feof(fpIn)) {
        //
        // Read a line from the input file
        //
        if (!fgets(buffer, BUFLEN, fpIn)) {
            break;
        }
        if (feof(fpIn)) {
            break;
        }
        pchLineStart = buffer;

        //
        // Skip leading spaces
        //
        while (*pchLineStart == ' ') {
            fprintf(fpOut, " ");
            pchLineStart++;
        }

        if (strncmp(pchLineStart, szLinePrefix, sizeof(szLinePrefix)-1) != 0) {
            //
            // Line doesn't start with the character sequence which prefixes
            // in/out decorators on arguments.
            //
            goto PrintLine;
        }

        //
        // Don't generate 'IN IN', etc. caused by MIDL output like
        // '[in][size_is][in]'
        //
        fInPrinted = FALSE;
        fOutPrinted = FALSE;

        //
        // Set a pointer to the first '['
        //
        p = pchLineStart + sizeof(szLinePrefix)-1;
        if (*p != '[') {
            //
            // The first char inside the comment isn't a '['.  Just print
            // the line as-is.
            //
            goto PrintLine;
        }

        //
        // The line needs modification.  Do it now.
        //
        fprintf(fpOut, "    ");
        while (*p == '[') {
            if (strncmp(p, szIn, sizeof(szIn)-1) == 0) {
                if (!fInPrinted) {
                    fprintf(fpOut, "IN ");
                    fInPrinted = TRUE;
                }
                p += sizeof(szIn)-1;
            } else if (strncmp(p, szOut, sizeof(szOut)-1) == 0) {
                if (!fOutPrinted) {
                    fprintf(fpOut, "OUT ");
                    fOutPrinted = TRUE;
                }
                p += sizeof(szOut)-1;
            } else {
                //
                // Uninterresting [keyword].  Skip it.
                //
                while (*p != ']') {
                    p++;
                }
                p++;
            }
        }

        //
        // pchLineStart points at the first non-space in the line, so the
        // whole line will be printed.
        //
PrintLine:
        fprintf(fpOut, "%s", pchLineStart);
    }
    fclose(fpOut);
    fclose(fpIn);
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64\config.c ===
/*++                 

Copyright (c) 2002 Microsoft Corporation

Module Name:

    config.c

Abstract:
    
    Configuration management routines for Wow64.

Author:

    17-Jun-2002  Samer Arafeh (samera)

Revision History:

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <minmax.h>
#include "nt32.h"
#include "wow64p.h"
#include "wow64cpu.h"

ASSERTNAME;


VOID
Wow64pGetStackDataExecuteOptions (
    OUT PULONG ExecuteOptions
    )
/*++

Routine Description:
  
    This routine retrieves the execution for the current wow64 process.
    Execute options are for stack and runtime data.
    
    32-bit stacks get execute option for free.
    
    This routine reads the global execute options, and sees if this specific app
    has overriden its execute options explicitly.
        
Arguments:

    ExecuteOptions - Pointer to receive the process execute options.

Return:

    None.

--*/

{
    NTSTATUS NtStatus;
    HANDLE Key;
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    CHAR Buffer [FIELD_OFFSET (KEY_VALUE_PARTIAL_INFORMATION, Data) + sizeof(ULONG)];
    ULONG ResultLength;
    ULONG Data;
    
    const static UNICODE_STRING KeyName = RTL_CONSTANT_STRING (WOW64_REGISTRY_CONFIG_ROOT);
    const static OBJECT_ATTRIBUTES ObjectAttributes = 
        RTL_CONSTANT_OBJECT_ATTRIBUTES (&KeyName, OBJ_CASE_INSENSITIVE);
    const static UNICODE_STRING ValueName = RTL_CONSTANT_STRING (WOW64_REGISTRY_CONFIG_EXECUTE_OPTIONS);

    
    //
    // Read in the initial execute options value
    //

    Data = *ExecuteOptions;

    //
    // Read in the global execute options
    //

    NtStatus = NtOpenKey (&Key,
                          KEY_QUERY_VALUE,
                          RTL_CONST_CAST(POBJECT_ATTRIBUTES)(&ObjectAttributes));

    if (NT_SUCCESS (NtStatus)) {

            
        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION) Buffer;
        NtStatus = NtQueryValueKey (Key,
                                    RTL_CONST_CAST(PUNICODE_STRING)(&ValueName),
                                    KeyValuePartialInformation,
                                    KeyValueInformation,
                                    sizeof (Buffer),
                                    &ResultLength);

        if (NT_SUCCESS (NtStatus)) {
            
            if ((KeyValueInformation->Type == REG_DWORD) &&
                (KeyValueInformation->DataLength == sizeof (DWORD))) {

                PRTL_USER_PROCESS_PARAMETERS ProcessParameters;

                Data = *(ULONG *)KeyValueInformation->Data;

                ASSERT ((Data & ~(MEM_EXECUTE_OPTION_STACK | MEM_EXECUTE_OPTION_DATA)) == 0);
                    
                Data &= (MEM_EXECUTE_OPTION_STACK | MEM_EXECUTE_OPTION_DATA);

                //
                // Lets see if the global execute options has been overriden
                //
                ProcessParameters = NtCurrentPeb()->ProcessParameters;
                if (ProcessParameters != NULL) {

                    ASSERT (ProcessParameters->ImagePathName.Buffer != NULL);
                
                    NtStatus = LdrQueryImageFileExecutionOptionsEx (
                        &ProcessParameters->ImagePathName,
                        WOW64_REGISTRY_CONFIG_EXECUTE_OPTIONS,
                        REG_DWORD,
                        &Data,
                        sizeof (Data),
                        NULL,
                        TRUE);
                }

                //
                // Reset the execute options value
                //

                *ExecuteOptions = Data;

            }
        }

        NtClose (Key);
    }

    return;
}


VOID
Wow64pSetProcessExecuteOptions (
    VOID
    )

/*++

Routine Description:
  
    This routine sets the execute options for the Wow64 process based on the values
    set in the registry. 
        
Arguments:

    ExecuteOptions - Pointer to receive the process execute options.

Return:

    None.

--*/

{
    ULONG ExecuteOptions;


    //
    // Default value
    //

#if defined(_AMD64_)
    ExecuteOptions = MEM_EXECUTE_OPTION_STACK | MEM_EXECUTE_OPTION_DATA;
#elif defined(_IA64_)
    ExecuteOptions = 0;
#else
#error "No Target Architecture"
#endif

    //
    // Retreive the execute options for this process
    //

    Wow64pGetStackDataExecuteOptions (&ExecuteOptions);

    //
    // Let's set the execute option value inside the 32-bit PEB 
    //

    NtCurrentPeb32()->ExecuteOptions = ExecuteOptions;

    return;
}



VOID
Wow64pSetExecuteProtection (
    IN OUT PULONG Protect)
/*++

Routine Description:
  
    This routine creates a page protection value according to the process
    execution options setting.
        
Arguments:

    Protect - Pointer to receive the new execute options.

Return:

    None.

--*/

{
    ULONG ExecuteOptions;
    ULONG NewProtect;


    //
    // Get the execute options
    //

    ExecuteOptions = NtCurrentPeb32()->ExecuteOptions;
    ExecuteOptions &= MEM_EXECUTE_OPTION_DATA;

    if (ExecuteOptions != 0) {

        NewProtect = *Protect;

        switch (NewProtect & 0x0F) {
        
        case PAGE_READONLY:
            NewProtect &= ~PAGE_READONLY;
            NewProtect |= PAGE_EXECUTE_READ;
            break;

        case PAGE_READWRITE:
            NewProtect &= ~PAGE_READWRITE;
            NewProtect |= PAGE_EXECUTE_READWRITE;
            break;

        case PAGE_WRITECOPY:
            NewProtect &= ~PAGE_WRITECOPY;
            NewProtect |= PAGE_EXECUTE_WRITECOPY;
            break;

        default:
            break;
        }

        *Protect = NewProtect;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64\raiseex.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    raiseex.c

Abstract:

    This module contains the routines necesary to allow a software CPU
    to simulate software interrupts, and raise exceptions.

Author:

    22-Jan-2000    SamerA

Revision History:

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include "wow64p.h"
#include "wow64cpu.h"

ASSERTNAME;



#define NUM_IDTSTATUS (sizeof(InterruptToNtStatus)/sizeof(NTSTATUS))

const NTSTATUS InterruptToNtStatus[] = 
{
   {STATUS_INTEGER_DIVIDE_BY_ZERO},   // 0
   {STATUS_WX86_SINGLE_STEP},         // 1 trace
   {STATUS_ACCESS_VIOLATION},         // 2 EXCEPTION_NMI BugCheck
   {STATUS_WX86_BREAKPOINT},          // 3 p1 BREAKPOINT_BREAK,
   {STATUS_INTEGER_OVERFLOW},         // 4
   {STATUS_ARRAY_BOUNDS_EXCEEDED},    // 5
   {STATUS_ILLEGAL_INSTRUCTION},      // 6 ? STATUS_INVALID_LOCK_SEQUENCE
   {STATUS_ACCESS_VIOLATION},         // 7 EXCEPTION_NPX_NOT_AVAILABLE ??
   {STATUS_ACCESS_VIOLATION},         // 8 EXCEPTION_DOUBLE_FAULT BugCheck
   {STATUS_ACCESS_VIOLATION},         // 9 EXCEPTION_NPX_OVERRUN BugCheck
   {STATUS_ACCESS_VIOLATION},         // a EXCEPTION_INVALID_TSS BugCheck
   {STATUS_ACCESS_VIOLATION},         // b Segment Not Present
   {STATUS_ACCESS_VIOLATION},         // c Stack Segment fault
   {STATUS_ACCESS_VIOLATION},         // d GP fault,
   {STATUS_ACCESS_VIOLATION},         // e Page Fault
   {STATUS_ACCESS_VIOLATION},         // f EXCEPTION_RESERVED BugCheck
   {STATUS_ACCESS_VIOLATION},         // 10 Coprocessor Error -> delayed via Trap07
   {STATUS_DATATYPE_MISALIGNMENT}     // 11 Alignment Fault
                                      //    p1= EXCEPT_LIMIT_ACCESS, p2 = Esp

   // 12 EXCEPTION_RESERVED_TRAP
   // 13 EXCEPTION_RESERVED_TRAP
   // 14 EXCEPTION_RESERVED_TRAP
   // 15 EXCEPTION_RESERVED_TRAP
   // 16 EXCEPTION_RESERVED_TRAP
   // 17 EXCEPTION_RESERVED_TRAP
   // 18 EXCEPTION_RESERVED_TRAP
   // 19 EXCEPTION_RESERVED_TRAP
   // 1A EXCEPTION_RESERVED_TRAP
   // 1B EXCEPTION_RESERVED_TRAP
   // 1C EXCEPTION_RESERVED_TRAP
   // 1D EXCEPTION_RESERVED_TRAP
   // 1E EXCEPTION_RESERVED_TRAP
   // 1F EXCEPTION_RESERVED_TRAP (APIC)

   // 21 reserved for WOW - Dos

   // 2A _KiGetTickCount
   // 2B _KiSetHighWaitLowThread
   // 2C _KiSetLowWaitHighThread
   // 2D _KiDebugService
   // 2E _KiSystemService
   // 2F _KiTrap0F
};


WOW64DLLAPI
NTSTATUS
Wow64RaiseException(
    IN DWORD InterruptNumber,
    IN OUT PEXCEPTION_RECORD ExceptionRecord)
/*++

Routine Description:

    This routine either simulates an x86 software interrupt, or generates a
    software exception. It's meant for CPU implementations to call this routine
    to raise an exception.
    
    NOTE : If this routine is called to raise a software exception (i.e.
           InterruptNumber is -1) and ExceptionRecord->ExceptionAddress is
           equal to NULL, then the return address of Wow64NotifyDebuggerHelper
           is used for that, otherwise the specified value is used.

Arguments:

    InterruptNumber   - If this parameter is -1, then the caller has supplied
                        an exception record to raise the exception for. If it
                        isn't -1, then a software exception is generated to simulate
                        the passed interrupt number
    ExceptionRecord   - Exception record to use if the InterruptNumber is -1                   
    
Return Value:

    The function returns to the caller if the exception has been handled.

--*/
{
    NTSTATUS NtStatus;
    CONTEXT32 Context32;
    EXCEPTION_RECORD ExceptionRecordLocal;
    PVOID CpuSimulationFlag;
    NTSTATUS ReturnStatus = STATUS_SUCCESS;
    PBYTE Fir = NULL;

    if (InterruptNumber != -1)
    {
        RtlZeroMemory(&ExceptionRecordLocal, sizeof(ExceptionRecordLocal));
        ExceptionRecord = &ExceptionRecordLocal;

        if (InterruptNumber < NUM_IDTSTATUS)
        {
            NtStatus = InterruptToNtStatus[InterruptNumber];
        }
        else 
        {
            NtStatus = STATUS_ACCESS_VIOLATION;
        }

        ExceptionRecord->ExceptionCode = NtStatus;

        Context32.ContextFlags = (CONTEXT32_CONTROL | CONTEXT32_INTEGER);
        
        if (NT_SUCCESS(CpuGetContext(NtCurrentThread(),
                                     NtCurrentProcess(),
                                     NtCurrentTeb(),
                                     &Context32)))
        {
            Fir = (PBYTE)Context32.Eip;
        }

        switch (NtStatus)
        {
        case STATUS_ACCESS_VIOLATION:
        case STATUS_DATATYPE_MISALIGNMENT:
            ExceptionRecord->NumberParameters        = 2;
            ExceptionRecord->ExceptionInformation[0] = 0;
            ExceptionRecord->ExceptionInformation[1] = (ULONG_PTR)Fir;
            break;

        case STATUS_WX86_BREAKPOINT:
            ExceptionRecord->ExceptionAddress        = (Fir-1);
            ExceptionRecord->NumberParameters        = 3;
            ExceptionRecord->ExceptionInformation[0] = 0;
            ExceptionRecord->ExceptionInformation[1] = Context32.Ecx;
            ExceptionRecord->ExceptionInformation[2] = Context32.Edx;
            break;

        default:
            ExceptionRecord->NumberParameters = 0;
            break;
        }
    }
    else
    {
        if (!ARGUMENT_PRESENT(ExceptionRecord))
        {
            ReturnStatus = STATUS_INVALID_PARAMETER;
        }
    }

    //
    // Raise the exception
    //
    if (NT_SUCCESS(ReturnStatus))
    {
        //
        // The CPU has definitely left code simulation
        //
        CpuSimulationFlag = Wow64TlsGetValue(WOW64_TLS_INCPUSIMULATION);
        Wow64TlsSetValue(WOW64_TLS_INCPUSIMULATION, FALSE);

        Wow64NotifyDebuggerHelper(ExceptionRecord,
                            TRUE);
        
        Wow64TlsSetValue(WOW64_TLS_INCPUSIMULATION, CpuSimulationFlag);
    }
    
    return ReturnStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64\init.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    init.c

Abstract:

    Process and thread init code for wow64.dll

Author:

    12-May-1998 BarryBo

Revision History:

    08-Mar-2001 Samer Arafeh (samera)  Initialize the SystemEmulation environment using
                                       the system serivces.

    02-Jan-2002 Samer Arafeh (samera)  Wow64-AMD64 support.

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbasep.h>
#include "wow64p.h"
#include "wow64cpu.h"
#include "nt32.h"
#include "thnkhlpr.h"
#include "wow64reg.h"

ASSERTNAME;


extern                       WOW64SERVICE_TABLE_DESCRIPTOR sdwhnt32;
extern __declspec(dllimport) WOW64SERVICE_TABLE_DESCRIPTOR sdwhwin32;
extern __declspec(dllimport) WOW64SERVICE_TABLE_DESCRIPTOR sdwhcon;
extern                       WOW64SERVICE_TABLE_DESCRIPTOR sdwhbase;
extern __declspec(dllimport) const PVOID Win32kCallbackTable[];   // in wow64win's ntcbc.c


ULONG Ntdll32LoaderInitRoutine;
ULONG Ntdll32KiUserExceptionDispatcher;
ULONG Ntdll32KiUserApcDispatcher;
ULONG Ntdll32KiUserCallbackDispatcher;
ULONG Ntdll32KiRaiseUserExceptionDispatcher;

PPEB32 Peb32;       // Pointer to 32-bit PEB for this process
ULONG NtDll32Base;  // Base address for 32-bit ntdll.dll

WOW64_SYSTEM_INFORMATION RealSysInfo;
WOW64_SYSTEM_INFORMATION EmulatedSysInfo;

WCHAR NtSystem32PathBuffer[264];
WCHAR NtSystem32LastGoodPathBuffer[264];
WCHAR NtWindowsImePathBuffer[264];
UNICODE_STRING NtSystem32Path;
UNICODE_STRING NtSystem32LastGoodPath;
UNICODE_STRING NtWindowsImePath;
WCHAR RegeditPathBuffer[264];
UNICODE_STRING RegeditPath;




NTSTATUS
Map64BitDlls(
    VOID
    );

NTSTATUS
LookupEntryPoint(
    IN ULONG DllBase,
    IN  PSZ NameOfEntryPoint,
    OUT ULONG *AddressOfEntryPoint,
    IN BOOLEAN DllIs64bit
    );

USHORT
NameToOrdinal (
    IN  PSZ NameOfEntryPoint,
    IN ULONG DllBase,
    IN ULONG NumberOfNames,
    IN PULONG NameTableBase,
    IN PUSHORT NameOrdinalTableBase
    );

NTSTATUS
MapNtdll32(
    OUT ULONG *pNtDllBase
    );

PWSTR
GetImageName (
    IN PWSTR DefaultImageName
    );

typedef DWORD (WINAPI *PPROCESS_START_ROUTINE)(
    VOID
    );

NTSTATUS
Wow64InitializeEmulatedSystemInformation(
    VOID
    )

/*++

Routine Description:
  
    This function initializes the global variable EmulatedSysInfo with the 
    system information for the emulated system.
  
Arguments:

    None.

--*/

{
    NTSTATUS NtStatus;

    NtStatus = NtQuerySystemInformation (SystemEmulationBasicInformation,
                                         &EmulatedSysInfo.BasicInfo,
                                         sizeof (EmulatedSysInfo.BasicInfo),
                                         NULL);

    if (NT_SUCCESS (NtStatus)) {

        NtStatus = NtQuerySystemInformation (SystemEmulationProcessorInformation,
                                             &EmulatedSysInfo.ProcessorInfo,
                                             sizeof (EmulatedSysInfo.ProcessorInfo),
                                             NULL);

        if (NT_SUCCESS (NtStatus)) {
            EmulatedSysInfo.RangeInfo =  0x80000000;
        }
    }

    return NtStatus;
}


NTSTATUS
Wow64InitializeSystemInformation(
    VOID
    )
/*++

Routine Description:

    This function retrieves the status system information from
    the system and initializes the global variable RealSysInfo.

Arguments:

    None.

Return Value:

    Status.

--*/
{
    NTSTATUS Status;

    Status = NtQuerySystemInformation(SystemBasicInformation,
                                      &RealSysInfo.BasicInfo,
                                      sizeof(SYSTEM_BASIC_INFORMATION),
                                      NULL);

    if (NT_SUCCESS(Status)) {

        Status = NtQuerySystemInformation(SystemProcessorInformation,
                                          &RealSysInfo.ProcessorInfo,
                                          sizeof(SYSTEM_PROCESSOR_INFORMATION),
                                          NULL);

        if (NT_SUCCESS(Status)) {
         
            Status = NtQuerySystemInformation(SystemRangeStartInformation,
                                              &RealSysInfo.RangeInfo,
                                              sizeof(ULONG_PTR),
                                              NULL);
        }
    }

    return Status;
}

VOID
Wow64pCopyString(
    PCHAR *p,
    PUNICODE_STRING32 str32,
    PUNICODE_STRING str64
    )
{
    *p = (PCHAR)ROUND_UP((SIZE_T)*p, sizeof(ULONG));

    str32->Length = str64->Length;
    str32->MaximumLength = str64->MaximumLength;
    RtlCopyMemory(*p, str64->Buffer, str64->MaximumLength);
    str32->Buffer = PtrToUlong(*p);

    *p += str64->MaximumLength;
}


ENVIRONMENT_THUNK_TABLE EnvironmentVariableTable[] = 
{
    { 
        L"ProgramFiles",            // Native environment variable to thunk
        L"ProgramFiles(x86)",       // Value for the thunked environment variable
        L"ProgramW6432",            // New environment variable to hold the original value being thunked
        TRUE                        // Treat the first value as an environment variable
    },
    { 
        L"CommonProgramFiles", 
        L"CommonProgramFiles(x86)", 
        L"CommonProgramW6432", 
        TRUE 
    },

    { 
        L"PROCESSOR_ARCHITECTURE",
        L"x86", 
        L"PROCESSOR_ARCHITEW6432",
        FALSE 
    },
};


NTSTATUS
Wow64pThunkEnvironmentVariables(
    VOID
    )

/*++

Routine Description:

    This function will thunk the environment variables pointed out by the EnvironmentVariableTable
    to the ones used on an x86 system, and will save the original values. The original
    values are restored when the 

Arguments:

    None.

Return Value:

    NTSTATUS.

--*/

{
    UNICODE_STRING Name;
    UNICODE_STRING Value, Value2;
    WCHAR Buffer [ 128 ];
    WCHAR Buffer2 [ 128 ];
    NTSTATUS NtStatus;
    ULONG i;

    
    i = 0;

    while (i < (sizeof(EnvironmentVariableTable) / sizeof(EnvironmentVariableTable[0])))
    {

        //
        // If a fake name already exists, then skip this one.
        //

        RtlInitUnicodeString (&Name, EnvironmentVariableTable[i].FakeName);

        Value.Length = 0;
        Value.MaximumLength = sizeof (Buffer);
        Value.Buffer = Buffer;

        NtStatus = RtlQueryEnvironmentVariable_U (NULL,
                                                  &Name,
                                                  &Value
                                                  );

        if (!NT_SUCCESS (NtStatus)) {

            //
            // Retreive the name of the ProgramFiles(x86) environment variable
            //

            if (EnvironmentVariableTable[i].IsX86EnvironmentVar == TRUE) {

                RtlInitUnicodeString (&Name, EnvironmentVariableTable[i].X86);

                Value.Length = 0;
                Value.MaximumLength = sizeof (Buffer);
                Value.Buffer = Buffer;


                NtStatus = RtlQueryEnvironmentVariable_U (NULL,
                                                          &Name,
                                                          &Value
                                                          );
            } else {

                RtlInitUnicodeString(&Value, EnvironmentVariableTable[i].X86);

                NtStatus = STATUS_SUCCESS;
            }

            if (NT_SUCCESS (NtStatus))
            {

                //
                // Save the original ProgramFiles environment variable
                //
            
                RtlInitUnicodeString (&Name, EnvironmentVariableTable[i].Native);

                Value2.Length = 0;
                Value2.MaximumLength = sizeof (Buffer2);
                Value2.Buffer = Buffer2;

                NtStatus = RtlQueryEnvironmentVariable_U (NULL,
                                                          &Name,
                                                          &Value2                                                  
                                                          );

                if (NT_SUCCESS (NtStatus))
                {
                    //
                    // Set the ProgramFiles environment variable to the x86 one
                    //

                    NtStatus = RtlSetEnvironmentVariable (NULL,
                                                          &Name,
                                                          &Value
                                                          );

                    if (NT_SUCCESS (NtStatus))
                    {

                        RtlInitUnicodeString (&Name, EnvironmentVariableTable[i].FakeName);

                        NtStatus = RtlSetEnvironmentVariable (NULL,
                                                              &Name,
                                                              &Value2
                                                              );
                    }
                }
            }
        }
        
        i++;
    }

    LOGPRINT((TRACELOG, "Result of thunking programfiles environment variables - %lx\n", NtStatus));

    return NtStatus;
}


NTSTATUS
Wow64pThunkProcessParameters(
    PPEB32 Peb32,
    PPEB Peb
    )
/*++

Routine Description:

    This function copies the process parameters from the 64bit peb to the 32bit peb.

Arguments:

    Peb32  - Supplies the pointer to the 32bit peb that will recieve the process parameters.
    Peb    - Supplies the pointer to the 64bit peb that will supply the process parameters.

Return Value:

    Status.

--*/
{

    SIZE_T AllocSize;
    PRTL_USER_PROCESS_PARAMETERS Params64;
    PRTL_USER_PROCESS_PARAMETERS32 Params32;
    SIZE_T Index;
    PCHAR p;
    PVOID Base;
    SIZE_T RegionSize;
    NTSTATUS st;


    //
    // Thunk the environment variables now.
    //

    Wow64pThunkEnvironmentVariables();

    // Process Parameters should have been normalized by ntdll.

    Params64 = Peb->ProcessParameters;
    if(NULL == Params64) {
        Peb32->ProcessParameters = (TYPE32(PRTL_USER_PROCESS_PARAMETERS))0;
        return STATUS_SUCCESS;
    }

    //
    //  Compute the required space for the continous memory region.

    AllocSize = sizeof(RTL_USER_PROCESS_PARAMETERS32);
    AllocSize += ROUND_UP(Params64->CurrentDirectory.DosPath.MaximumLength, sizeof(ULONG));
    AllocSize += ROUND_UP(Params64->DllPath.MaximumLength, sizeof(ULONG));
    AllocSize += ROUND_UP(Params64->ImagePathName.MaximumLength, sizeof(ULONG));
    AllocSize += ROUND_UP(Params64->CommandLine.MaximumLength, sizeof(ULONG));
    AllocSize += ROUND_UP(Params64->WindowTitle.MaximumLength, sizeof(ULONG));
    AllocSize += ROUND_UP(Params64->DesktopInfo.MaximumLength, sizeof(ULONG));
    AllocSize += ROUND_UP(Params64->ShellInfo.MaximumLength, sizeof(ULONG));
    AllocSize += ROUND_UP(Params64->RuntimeData.MaximumLength, sizeof(ULONG));

    for(Index=0; Index < RTL_MAX_DRIVE_LETTERS; Index++) {
        AllocSize += ROUND_UP(Params64->CurrentDirectores[Index].DosPath.MaximumLength, sizeof(ULONG));
    }

    Base = NULL;
    RegionSize = AllocSize;
    st = NtAllocateVirtualMemory(NtCurrentProcess(),
                                 &Base,
                                 0,
                                 &RegionSize,
                                 MEM_COMMIT|MEM_RESERVE,
                                 PAGE_READWRITE);

    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "ThunkProcessParameters: NtAllocateVirtualMemory failed allocating process paramaters, error %x.\n", st));
        return st;
    }

    Params32 = (PRTL_USER_PROCESS_PARAMETERS32)Base;
    Peb32->ProcessParameters = (TYPE32(PRTL_USER_PROCESS_PARAMETERS))PtrToUlong(Params32);
    p = (PCHAR)Params32 + sizeof(RTL_USER_PROCESS_PARAMETERS32);

    Params32->MaximumLength = Params32->Length = (ULONG)AllocSize;
    Params32->Flags = Params64->Flags;
    Params32->DebugFlags = Params64->DebugFlags;
    Params32->ConsoleHandle = (TYPE32(HANDLE))PtrToUlong(Params64->ConsoleHandle);
    Params32->ConsoleFlags = (ULONG)Params64->ConsoleFlags;
    Params32->StandardInput = (TYPE32(HANDLE)) PtrToUlong(Params64->StandardInput);
    Params32->StandardOutput = (TYPE32(HANDLE)) PtrToUlong(Params64->StandardOutput);
    Params32->StandardError = (TYPE32(HANDLE)) PtrToUlong(Params64->StandardError);

    Params32->CurrentDirectory.Handle = (TYPE32(HANDLE)) PtrToUlong(Params64->CurrentDirectory.Handle);
    Wow64pCopyString(&p, &Params32->CurrentDirectory.DosPath, &Params64->CurrentDirectory.DosPath);

    Wow64pCopyString(&p, &Params32->DllPath, &Params64->DllPath);
    Wow64pCopyString(&p, &Params32->ImagePathName, &Params64->ImagePathName);
    Wow64pCopyString(&p, &Params32->CommandLine, &Params64->CommandLine);
    Params32->Environment = PtrToUlong(Params64->Environment);

    Params32->StartingX = Params64->StartingX;
    Params32->StartingY = Params64->StartingY;
    Params32->CountX = Params64->CountX;
    Params32->CountY = Params64->CountY;
    Params32->CountCharsX = Params64->CountCharsX;
    Params32->CountCharsY = Params64->CountCharsY;
    Params32->FillAttribute = Params64->FillAttribute;

    Params32->WindowFlags = Params64->WindowFlags;
    Params32->ShowWindowFlags = Params64->ShowWindowFlags;
    Wow64pCopyString(&p, &Params32->WindowTitle, &Params64->WindowTitle);
    Wow64pCopyString(&p, &Params32->DesktopInfo, &Params64->DesktopInfo);
    Wow64pCopyString(&p, &Params32->ShellInfo, &Params64->ShellInfo);

    // RuntimeData is mis-prototyped as a UNICODE_STRING.  However,
    // it is really used by the C runtime as a mechanism to pass file
    // handles around.  Thunk it as such.  See sdktools\vctools\crtw32
    // \exec\dospawn.c and lowio\ioinit.c for the gory details.
    if (Params64->RuntimeData.Length && Params64->RuntimeData.Buffer) {
        int cfi_len;
        char *posfile64;
        UINT_PTR UNALIGNED *posfhnd64;
        char *posfile32;
        UINT UNALIGNED *posfhnd32;
        int i;

        cfi_len = *(int UNALIGNED *)Params64->RuntimeData.Buffer;

        Params32->RuntimeData.Length = Params64->RuntimeData.Length - cfi_len * sizeof(ULONG);
        Params32->RuntimeData.MaximumLength = Params32->RuntimeData.Length;
        Params32->RuntimeData.Buffer = PtrToUlong(p);
        p += Params32->RuntimeData.Length;

        posfile64 = (char *)((UINT_PTR)Params64->RuntimeData.Buffer+sizeof(int));
        posfhnd64 = (UINT_PTR UNALIGNED *)(posfile64 + cfi_len);
        posfile32 = (char *)((ULONG_PTR)Params32->RuntimeData.Buffer+sizeof(int));
        posfhnd32 = (UINT UNALIGNED *)(posfile32 + cfi_len);

        *(int *)Params32->RuntimeData.Buffer = cfi_len;
        for (i=0; i<cfi_len; ++i) {
            *posfile32 = *posfile64;
            *posfhnd32 = (ULONG)*posfhnd64;
            posfile32++;
            posfile64++;
            posfhnd32++;
            posfhnd64++;
        }

        // Any bytes past the end of 4+(cfi_len*(sizeof(UINT_PTR)+sizeof(UINT))
        // must be copied verbatim.  They are probably from a non-MS C runtime.
        memcpy(posfhnd32, posfhnd64, (Params64->RuntimeData.Length - ((ULONG_PTR)posfhnd64 - (ULONG_PTR)Params64->RuntimeData.Buffer)));
    }

    for(Index = 0; Index < RTL_MAX_DRIVE_LETTERS; Index++) {
        Params32->CurrentDirectores[Index].Flags = Params64->CurrentDirectores[Index].Flags;
        Params32->CurrentDirectores[Index].Length = sizeof(RTL_DRIVE_LETTER_CURDIR);
        Params32->CurrentDirectores[Index].TimeStamp = Params64->CurrentDirectores[Index].TimeStamp;
        Wow64pCopyString(&p, (PUNICODE_STRING32)&Params32->CurrentDirectores[Index].DosPath, (PUNICODE_STRING)&Params64->CurrentDirectores[Index].DosPath);
    }

    return STATUS_SUCCESS;
}

//
// This compile-time assert ensures that the PEB64 and PEB32 structures are in
// alignment on an IA64 build.  If this fails, someone added, deleted, or changed
// the type of a field in PEB32/PEB64 depending on the compile destination.  Check
// %ntdir%\base\published\wow64t.w for alignment errors.
//
// If you hit hit this, you'll see messages something like:
//
// error C2118: negative subscript or subscript is too large
//
#ifdef _WIN64
#define PEB_ALIGN_TARGET PEB64
#define PEB_ALIGN_SOURCE PEB
#else
#define PEB_ALIGN_TARGET PEB32
#define PEB_ALIGN_SOURCE PEB
#endif
#define CHECK_PEB_ALIGNMENT( f ) C_ASSERT( FIELD_OFFSET( PEB_ALIGN_SOURCE, f ) == FIELD_OFFSET( PEB_ALIGN_TARGET, f ) )

CHECK_PEB_ALIGNMENT( ActivationContextData );
CHECK_PEB_ALIGNMENT( ProcessAssemblyStorageMap );
CHECK_PEB_ALIGNMENT( SystemDefaultActivationContextData );
CHECK_PEB_ALIGNMENT( SystemAssemblyStorageMap );
CHECK_PEB_ALIGNMENT( pShimData );

#undef CHECK_PEB_ALIGNMENT
#undef PEB_ALIGN_TARGET
#undef PEB_ALIGN_SOURCE


NTSTATUS
ProcessInit(
    PSIZE_T pCpuThreadSize
    )
/*++

Routine Description:

    Perform per-process initialization for wow64.dll.  That includes
    creating the 32-bit PEB and mapping in 32-bit ntdll.dll.

Arguments:

    pCpuThreadSize  - OUT PTR to store the CPU's per-thread data requirements
                      in.

Return Value:

    Status.  If this fails, it doesn't clean up, assuming that the
    process is going to fail to run and exit right away, so nothing really
    gets leaked.

--*/
{
    NTSTATUS st;
    PVOID Base;
    SIZE_T RegionSize;
    PPEB Peb64 = NtCurrentPeb();  // get 64-bit PEB pointer
    ULONG ul;
    BOOLEAN b;
    HANDLE hKey;
    UNICODE_STRING KeyName;
    OBJECT_ATTRIBUTES ObjA;
    PWSTR defaultName;
    PWSTR imageName;

    InitializeDebug();

    //
    // Initialize Wow64Info
    //
    st = Wow64pInitializeWow64Info();
    if (!NT_SUCCESS (st)) {
    }

    st = InitializeContextMapper();
    if (!NT_SUCCESS (st)) {
       return st;
    }

    st = Wow64InitializeSystemInformation();
    if (!NT_SUCCESS (st)) {
       return st;
    }

    st = Wow64InitializeEmulatedSystemInformation();
    if (!NT_SUCCESS (st)) {
       return st;
    }

    //
    // Initialize all critical sections
    //
    st = RtlInitializeCriticalSection(&HandleDataCriticalSection);
    if (!NT_SUCCESS (st)) {
       return st;
    }

    //
    // Map in 32-bit ntdll32.dll and fill in the Ntdll32* global vars
    // with the system exports from ntdll.
    //
    st = MapNtdll32(&NtDll32Base);
    if (!NT_SUCCESS (st)) {
        LOGPRINT((ERRORLOG, "ProcessInit: MapNtdll32 failed, error %x \n", st));
        return st;
    }

    //Map in the 64bit DLLs.
    st = Map64BitDlls();
    if (!NT_SUCCESS (st)) {
        return st;
    }

    // Create the SuspendThread mutant to serialize access to the API
    st = Wow64pInitializeSuspendMutant();
    if (!NT_SUCCESS (st)) {
        return st;
    }

    // Get the full Nt Pathname to the %windir%\system32 directory, 
    // %windir% and %windir%\regedit.exe
    NtSystem32PathBuffer[0] = L'\\';
    NtSystem32PathBuffer[1] = L'?';
    NtSystem32PathBuffer[2] = L'?';
    NtSystem32PathBuffer[3] = L'\\';
    wcscpy(&NtSystem32PathBuffer[4], USER_SHARED_DATA->NtSystemRoot);
    wcscpy(RegeditPathBuffer, NtSystem32PathBuffer);
    wcscpy(NtWindowsImePathBuffer, NtSystem32PathBuffer);
    wcscpy(NtSystem32LastGoodPathBuffer, NtSystem32PathBuffer);
    NtSystem32Path.Buffer = NtSystem32PathBuffer;
    NtSystem32Path.MaximumLength = sizeof(NtSystem32PathBuffer);
    NtSystem32Path.Length = wcslen(NtSystem32PathBuffer) * sizeof(WCHAR);
    st = RtlAppendUnicodeToString(&NtSystem32Path, L"\\system32");
    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "ProcessInit: RtlAppendUnicodeToString failed, error %x \n", st));
        return st;
    }
    //
    // Last Good
    //
    NtSystem32LastGoodPath.Buffer = NtSystem32LastGoodPathBuffer;
    NtSystem32LastGoodPath.MaximumLength = sizeof (NtSystem32LastGoodPathBuffer);
    NtSystem32LastGoodPath.Length = wcslen (NtSystem32LastGoodPathBuffer)*sizeof (WCHAR);
    st = RtlAppendUnicodeToString(&NtSystem32LastGoodPath, L"\\LastGood\\System32");
    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "ProcessInit: RtlAppendUnicodeToString failed, error %x \n", st));
        return st;
    }


    NtWindowsImePath.Buffer = NtWindowsImePathBuffer;
    NtWindowsImePath.MaximumLength = sizeof(NtWindowsImePathBuffer);
    NtWindowsImePath.Length = wcslen(NtWindowsImePathBuffer) * sizeof(WCHAR);
    st = RtlAppendUnicodeToString(&NtWindowsImePath, L"\\ime");
    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "ProcessInit: RtlAppendUnicodeToString failed, error %x \n", st));
        return st;
    }

    RegeditPath.Buffer = RegeditPathBuffer;
    RegeditPath.MaximumLength = sizeof(RegeditPathBuffer);
    RegeditPath.Length = wcslen(RegeditPathBuffer) * sizeof(WCHAR);
    st = RtlAppendUnicodeToString(&RegeditPath, L"\\regedit.exe");
    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "ProcessInit: RtlAppendUnicodeToString failed, error %x \n", st));
        return st;
    }

    //
    // Initialize the system service tables
    //
    ServiceTables[WHNT32_INDEX] = sdwhnt32;
    ServiceTables[WHCON_INDEX] = sdwhcon;
    ServiceTables[WHWIN32_INDEX] = sdwhwin32;
    ServiceTables[WHBASE_INDEX] = sdwhbase;

    NtCurrentPeb()->KernelCallbackTable = Win32kCallbackTable;

    //
    // Get the address of the PEB32 from the process information
    //
    st = NtQueryInformationProcess(NtCurrentProcess(),
                                   ProcessWow64Information,
                                   &Peb32,
                                   sizeof(Peb32),
                                   NULL);
    if (!NT_SUCCESS (st)) {
        return st;
    }

    st = Wow64pThunkProcessParameters(Peb32, Peb64);
    if (!NT_SUCCESS (st)) {
       LOGPRINT((ERRORLOG, "ProcessInit: ThunkProcessParameters failed, error %x\n", st));
       return st;
    }

    //
    // Copy this one field down to the PEB32 from the native PEB.  It
    // is written into the 64-bit PEB by Fusion in csrss.exe after
    // NtCreateProcess has been called by the parent process.
    //

    Peb32->ActivationContextData = PtrToUlong(Peb64->ActivationContextData);
    Peb32->SystemDefaultActivationContextData = PtrToUlong(Peb64->SystemDefaultActivationContextData);

    //
    // Copy the pShimData if it exists on the 64-bit side and doesn't 
    // exist on the 32-bit side of the peb
    //

    if (Peb32->pShimData == 0L) {
        Peb32->pShimData = PtrToUlong (Peb64->pShimData);
    }

    //
    // If wow64 is running in guimode setup, then make sure the 32-bit Peb
    // BeingDebugged flag is FALSE.  Otherwise, if we are being debugged
    // by a 64-bit debugger with no WOW64 debugger extensions then it will
    // hit the STATUS_WX86_BREAKPOINT exception and halt.
    //
    RtlInitUnicodeString(&KeyName, L"\\Registry\\Machine\\System\\Setup");
    InitializeObjectAttributes(&ObjA, &KeyName, OBJ_CASE_INSENSITIVE, NULL, NULL);
    st = NtOpenKey(&hKey, KEY_READ, &ObjA);
    if (NT_SUCCESS(st)) {
        PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
        WCHAR Buffer[400];
        ULONG ResultLength;

        RtlInitUnicodeString(&KeyName, L"SystemSetupInProgress");
        KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)Buffer;
        st = NtQueryValueKey(hKey,
                             &KeyName,
                             KeyValuePartialInformation,
                             KeyValueInformation,
                             sizeof(Buffer),
                             &ResultLength);
        if (NT_SUCCESS(st) &&
            KeyValueInformation->Type == REG_DWORD &&
            *(DWORD *)(KeyValueInformation->Data)) {

            Peb32->BeingDebugged = FALSE;

        }
        NtClose(hKey);
    }

    //
    // Initialize the CPU
    //
    defaultName = L"Unknown Image";
    imageName = GetImageName(defaultName);

    st = CpuProcessInit(imageName, pCpuThreadSize);

    //
    // Success or failure, we are done with the image name
    //
    if (imageName != defaultName) {
        Wow64FreeHeap(imageName);
    }

    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "ProcessInit: CpuProcessInit failed, error %x.\n", st));
        return st;
    }

	
    if (!Wow64InitRegistry(0)) {
        LOGPRINT((ERRORLOG, "Couldn't Initialize Wow64 section of the registry"));
        return STATUS_UNSUCCESSFUL;
    }

    return st;
}


VOID
Wow64Shutdown(
    HANDLE ProcessHandle
    )
{
    CpuProcessTerm(ProcessHandle);
    Wow64CloseRegistry (0);
    ShutdownDebug();
}


VOID
ThunkPeb64ToPeb32(
    IN PPEB Peb64,
    OUT PPEB32 Peb32
    )
{
    RtlZeroMemory(Peb32, sizeof(PEB32));
    Peb32->Mutant = 0xffffffff;

    //
    // Initialize the Peb32 (copied from ntos\mm\procsup.c's MmCreatePeb)
    //
    Peb32->ImageBaseAddress = PtrToUlong(Peb64->ImageBaseAddress);
    Peb32->AnsiCodePageData = PtrToUlong(Peb64->AnsiCodePageData);
    Peb32->OemCodePageData =  PtrToUlong(Peb64->OemCodePageData);
    Peb32->UnicodeCaseTableData = PtrToUlong(Peb64->UnicodeCaseTableData);
    Peb32->NumberOfProcessors = Peb64->NumberOfProcessors;
    Peb32->BeingDebugged = Peb64->BeingDebugged;
    Peb32->NtGlobalFlag = Peb64->NtGlobalFlag;
    Peb32->CriticalSectionTimeout = Peb64->CriticalSectionTimeout;
    if (Peb64->HeapSegmentReserve > 1024*1024*1024) {   // 1gig
        Peb32->HeapSegmentReserve = 1024*1024;          // 1meg
    } else {
        Peb32->HeapSegmentReserve = (ULONG)Peb64->HeapSegmentReserve;
    }
    if (Peb64->HeapSegmentCommit > Peb32->HeapSegmentReserve) {
        Peb32->HeapSegmentCommit = 2*PAGE_SIZE;
    } else {
        Peb32->HeapSegmentCommit = (ULONG)Peb64->HeapSegmentCommit;
    }
    Peb32->HeapDeCommitTotalFreeThreshold = (ULONG)Peb64->HeapDeCommitTotalFreeThreshold;
    Peb32->HeapDeCommitFreeBlockThreshold = (ULONG)Peb64->HeapDeCommitFreeBlockThreshold;
    Peb32->MaximumNumberOfHeaps = (PAGE_SIZE - sizeof(PEB32))/sizeof(ULONG);
    Peb32->ProcessHeaps = PtrToUlong(Peb32+1);
    Peb32->OSMajorVersion = Peb64->OSMajorVersion;
    Peb32->OSMinorVersion = Peb64->OSMinorVersion;
    Peb32->OSBuildNumber = Peb64->OSBuildNumber;
    Peb32->OSPlatformId = Peb64->OSPlatformId;
    Peb32->OSCSDVersion = Peb64->OSCSDVersion;
    Peb32->ImageSubsystem = Peb64->ImageSubsystem;
    Peb32->ImageSubsystemMajorVersion = Peb64->ImageSubsystemMajorVersion;
    Peb32->ImageSubsystemMinorVersion = Peb64->ImageSubsystemMinorVersion;
    Peb32->ImageProcessAffinityMask = PtrToUlong((PVOID)Peb64->ImageProcessAffinityMask);
    Peb32->SessionId = Peb64->SessionId;
}


NTSTATUS
ThreadInit(
    PVOID pCpuThreadData
    )
/*++

Routine Description:

    Perform per-thread initialization for wow64.dll.

Arguments:

    pCpuThreadData  - pointer to private per-thread data for the CPU to use.

Return Value:

    Status.

--*/
{
    NTSTATUS st;
    PVOID Base;
    SIZE_T RegionSize;
    PTEB32 Teb32;
    PCH Stack;
    BOOLEAN GuardPage;
    ULONG OldProtect;
    SIZE_T ImageStackSize, ImageStackCommit, MaximumStackSize, StackSize;
    PIMAGE_NT_HEADERS32 NtHeaders;
    PPEB Peb64;
    PTEB Teb64;

    

    Peb64 = NtCurrentPeb();
    Teb64 = NtCurrentTeb();
    Teb32 = NtCurrentTeb32();

    if (Teb32->DeallocationStack == PtrToUlong( NULL ))
    {
        //
        // Allocate the 32-bit stack.  Cloned from windows\base\client\support.c
        // If the stack size was not supplied, then use the sizes from the
        // image header.
        //

        NtHeaders = (PIMAGE_NT_HEADERS32)RtlImageNtHeader(Peb64->ImageBaseAddress);
        ImageStackSize = NtHeaders->OptionalHeader.SizeOfStackReserve;
        ImageStackCommit = NtHeaders->OptionalHeader.SizeOfStackCommit;

        //
        // Maximum stack size shouldn't be less than 256K (per \base\client\process.c)
        //

        if (ImageStackSize < WOW64_MINIMUM_STACK_RESERVE_X86) {
            MaximumStackSize = WOW64_MINIMUM_STACK_RESERVE_X86;
        } else {
            MaximumStackSize = ImageStackSize;
        }
        StackSize = ImageStackCommit;

        //
        // Align the stack size to a page boundry and the reserved size
        // to an allocation granularity boundry.
        //

        StackSize = ROUND_UP ( StackSize, PAGE_SIZE );
        MaximumStackSize = ROUND_UP ( MaximumStackSize, 65536 );
        
        //
        // Reserve address space for the stack
        //

        Stack = NULL;
        st = NtAllocateVirtualMemory(
                 NtCurrentProcess(),
                 (PVOID *)&Stack,
                 0,
                 &MaximumStackSize,
                 MEM_RESERVE,
                 PAGE_READWRITE 
                 );

        if (!NT_SUCCESS( st )) 
        {
            LOGPRINT((ERRORLOG, "ThreadInit: NtAllocateVirtualMemory failed, error %x\n", st));
            goto ReturnError;
        }

        LOGPRINT((TRACELOG, "ThreadInit: 32 bit stack allocated at %I64x \n", (ULONGLONG)Stack));

        Teb32->DeallocationStack = PtrToUlong(Stack);
        Teb32->NtTib.StackBase = PtrToUlong(Stack + MaximumStackSize);

        Stack += MaximumStackSize - StackSize;
        if (MaximumStackSize > StackSize) 
        {
            Stack -= PAGE_SIZE;
            StackSize += PAGE_SIZE;
            GuardPage = TRUE;
        } 
        else 
        {
            GuardPage = FALSE;
        }

        //
        // Commit the initially valid portion of the stack
        //
        st = NtAllocateVirtualMemory(
                 NtCurrentProcess(),
                 (PVOID *)&Stack,
                 0,
                 &StackSize,
                 MEM_COMMIT,
                 PAGE_READWRITE
                 );

        if (!NT_SUCCESS( st ))
        {
            //
            // commit failed
            //

            LOGPRINT((ERRORLOG, "ThreadInit: NtAllocateVirtualMemory commit failed, error %x\n", st));
            goto ErrorFreeStack;
        }

        Teb32->NtTib.StackLimit = PtrToUlong(Stack);

        //
        // if we have space, create a guard page.
        //   
        if (GuardPage) 
        {
            RegionSize = PAGE_SIZE;
            st = NtProtectVirtualMemory(
                     NtCurrentProcess(),
                     (PVOID *)&Stack,
                     &RegionSize,
                     PAGE_GUARD | PAGE_READWRITE,
                     &OldProtect
                     );
        
            if (!NT_SUCCESS( st )) 
            {
                LOGPRINT((ERRORLOG, "ThreadInit: NtAllocateVirtualMemory for guard-page failed, error %x\n", st));
                goto ErrorFreeStack;
            }
            Teb32->NtTib.StackLimit = PtrToUlong ((PUCHAR)Teb32->NtTib.StackLimit + RegionSize);
        }
    }

    //
    // Migrate the Teb->IdealProcessor & Teb->CurrentLocale from the 64-bit TEB.
    // The kernel does exactly the same thing before starting the usermode thread by 
    // migrating these values from the TCB.
    //
    Teb32->CurrentLocale = Teb64->CurrentLocale;
    Teb32->IdealProcessor = Teb64->IdealProcessor;

    //
    // Now that everything else is initialized, run the CPU's per-thread
    // initialization code.
    //
    
    st = CpuThreadInit (pCpuThreadData);
    
    if (NT_SUCCESS( st )) 
    {
        return st;
    }

    LOGPRINT((ERRORLOG, "ThreadInit: CpuThreadInit failed, error %x\n", st));

ErrorFreeStack:
    
    Base = (PVOID) Teb32->DeallocationStack;
    RegionSize = 0;
    NtFreeVirtualMemory(NtCurrentProcess(), &Base, &RegionSize, MEM_RELEASE);

ReturnError:

    return st;
}

NTSTATUS
MapNtdll32(
    OUT ULONG *pNtDll32Base
    )
/*++

Routine Description:

    Map 32-bit ntdll32.dll into memory and look up all of the important
    entrypoints.

Arguments:

    pNtDll32Base    - OUT base address of the DLL.

Return Value:

    Status.  On success, Ntdll32* globals are set.

--*/
{
    UNICODE_STRING SystemDllPath;
    WCHAR SystemDllPathBuffer[DOS_MAX_PATH_LENGTH];
    NTSTATUS st;
    UNICODE_STRING FullDllName;
    WCHAR FullDllNameBuffer[DOS_MAX_PATH_LENGTH];
    UNICODE_STRING NtFileName;
    OBJECT_ATTRIBUTES ObjectAttributes;
    IO_STATUS_BLOCK IoStatus;
    HANDLE File;
    HANDLE Section;
    PVOID ViewBase;
    SIZE_T ViewSize;
    PVOID pv;
    PTEB Teb;
    PVOID ArbitraryUserPointer;


    //
    // Build up the name of the 32-bit system directory
    //
    SystemDllPath.Buffer = SystemDllPathBuffer;
    SystemDllPath.Length = 0;
    SystemDllPath.MaximumLength = sizeof(SystemDllPathBuffer);
    st = RtlAppendUnicodeToString(&SystemDllPath, USER_SHARED_DATA->NtSystemRoot);
    if(!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "MapNtDll32, RtlAppendUnicodeToString failed, error %x\n", st));
        return st;
    }
    st = RtlAppendUnicodeToString(&SystemDllPath, L"\\" WOW64_SYSTEM_DIRECTORY_U);
    if(!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "MapNtDll32, RtlAppendUnicodeToString failed, error %x\n", st));
        return st;
    }
    
    //
    // Build up the full pathname to %SystemRoot%\syswow64\ntdll32.dll
    //
    FullDllName.Buffer = FullDllNameBuffer;
    FullDllName.Length = 0;
    FullDllName.MaximumLength = sizeof(FullDllNameBuffer);
    RtlCopyUnicodeString(&FullDllName, &SystemDllPath);
    st = RtlAppendUnicodeToString(&FullDllName, L"\\ntdll.dll");
    if(!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "MapNtDll32, RtlAppendUnicodeToString failed, error %x\n", st));
        return st;
    }

    //
    // Convert the Win32 pathname to an NT pathname
    //
    if (!RtlDosPathNameToNtPathName_U(FullDllName.Buffer,
                                      &NtFileName,
                                      NULL,
                                      NULL)) {
        // probably out-of-memory
        return STATUS_UNSUCCESSFUL;
    }


    //
    // Open the file
    //
    InitializeObjectAttributes(&ObjectAttributes,
                               &NtFileName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    st = NtOpenFile(&File,
                    SYNCHRONIZE | FILE_EXECUTE,
                    &ObjectAttributes,
                    &IoStatus,
                    FILE_SHARE_READ | FILE_SHARE_DELETE,
                    FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
    RtlFreeHeap(RtlProcessHeap(), 0, NtFileName.Buffer);
    if (!NT_SUCCESS(st)) {
        return st;
    }

    //
    // Create the section
    //
    st = NtCreateSection(&Section,
                         SECTION_MAP_READ | SECTION_MAP_EXECUTE | SECTION_MAP_WRITE,
                         NULL,
                         NULL,
                         PAGE_EXECUTE,
                         SEC_IMAGE,
                         File);
    NtClose(File);
    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "MapNtDll32: NtCreateSection failed, error %x\n", st));
        return st;
    }

    //
    // Map the section in and let the debugger know the name of the image.
    // We lie to NTSD about the image name, calling it ntdll32.dll so
    // it can disambiguate between the two when doing name resolution.
    // Put 64-bit symbols first on sympath, then 32-bit, and NTSD will find
    // the 32-bit ntdll.pdb and use it for ntdll32.dll.
    //
    *pNtDll32Base = 0;
    pv = NULL;
    ViewSize = 0;
    Teb = NtCurrentTeb();
    ArbitraryUserPointer = Teb->NtTib.ArbitraryUserPointer;
    FullDllName.Buffer = FullDllNameBuffer;
    FullDllName.Length = 0;
    FullDllName.MaximumLength = sizeof(FullDllNameBuffer);
    RtlCopyUnicodeString(&FullDllName, &SystemDllPath);
    st = RtlAppendUnicodeToString(&FullDllName, L"\\ntdll32.dll");
    if(!NT_SUCCESS(st)) {
        NtClose(Section);
        LOGPRINT((ERRORLOG, "MapNtDll32, RtlAppendUnicodeToString failed, error %x\n", st));
        return st;
    }
    Teb->NtTib.ArbitraryUserPointer = (PVOID)FullDllName.Buffer;
    st = NtMapViewOfSection(Section,
                            NtCurrentProcess(),
                            &pv,
                            0,
                            0,
                            NULL,
                            &ViewSize,
                            ViewShare,
                            0,
                            PAGE_EXECUTE);
    Teb->NtTib.ArbitraryUserPointer = ArbitraryUserPointer;
    NtClose(Section);
    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "MapNtDll32, NtMapViewOfSection failed, error %x\n", st));
        return st;
    } else if (st == STATUS_IMAGE_NOT_AT_BASE) {
        LOGPRINT((ERRORLOG, "ntdll32.dll not at base.\n"));
        return STATUS_UNSUCCESSFUL;
    }
    *pNtDll32Base = PtrToUlong(pv);

    //
    // Look up the required exports from the Dll.
    //
    // main entrypoint
    st = LookupEntryPoint(*pNtDll32Base,
                          "LdrInitializeThunk",
                          &Ntdll32LoaderInitRoutine,
                          FALSE);
    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "MapNtDll32: LookupEntryPoint LdrInitializeThunk failed, error %x\n", st));
        return st;
    }

    //
    // exception dispatching
    //
    st = LookupEntryPoint(*pNtDll32Base,
                          "KiUserExceptionDispatcher",
                          &Ntdll32KiUserExceptionDispatcher,
                          FALSE);
    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "MapNtDll32: LookupEntryPoint KiUserExceptionDispatcher failed, error %x\n", st));
        WOWASSERT(FALSE);
        return st;
    }

    //
    // usermode APC dispatching
    //
    st = LookupEntryPoint(*pNtDll32Base,
                          "KiUserApcDispatcher",
                          &Ntdll32KiUserApcDispatcher,
                          FALSE);
    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "MapNtDll32: LookupEntryPoint KiUserApcDispatcher failed, error %x\n", st));
        WOWASSERT(FALSE);
        return st;
    }

    //
    // callback dispatching
    //
    st = LookupEntryPoint(*pNtDll32Base,
                          "KiUserCallbackDispatcher",
                          &Ntdll32KiUserCallbackDispatcher,
                          FALSE);
    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "MapNtDll32: LookupEntryPoint KiUserCallbackDispatcher failed, error %x\n", st));
        WOWASSERT(FALSE);
        return st;
    }

    //
    // raise a usermode exception
    //
    st = LookupEntryPoint(*pNtDll32Base,
                          "KiRaiseUserExceptionDispatcher",
                          &Ntdll32KiRaiseUserExceptionDispatcher,
                          FALSE);
    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "MapNtDll32: LookupEntryPoint KiRaiseUserExceptionDispatcher failed, error %x\n", st));
        WOWASSERT(FALSE);
        return st;
    }

    return st;
}


NTSTATUS
LookupEntryPoint(
    IN ULONG DllBase,
    IN  PSZ NameOfEntryPoint,
    OUT ULONG *AddressOfEntryPoint,
    BOOLEAN DllIs64bit
    )
/*++

Routine Description:

    Cloned from ntos\init\init.c LookupEntryPoint().  Tiny version of
    GetProcAddress.

Arguments:

    DllBase             - Dll to look export up in
    NameOfEntryPoint    - Name of export to look up
    AddressOfEntryPoint - OUT ptr to location to write the proc address
    DllIs64bit          - TRUE if DLL is 64bit
Return Value:

    Status.

--*/
{
    PIMAGE_EXPORT_DIRECTORY ExportDirectory;
    ULONG ExportSize;
    USHORT Ordinal;
    PULONG Addr;
    CHAR NameBuffer[64];


    ExportDirectory = (PIMAGE_EXPORT_DIRECTORY) RtlImageDirectoryEntryToData(
        (PVOID)DllBase,
        TRUE,
        IMAGE_DIRECTORY_ENTRY_EXPORT,
        &ExportSize);

    if ( strlen(NameOfEntryPoint) > (sizeof(NameBuffer)-2) ) {
        return STATUS_INVALID_PARAMETER;
    }

    strcpy(NameBuffer,NameOfEntryPoint);

    Ordinal = NameToOrdinal(
                NameBuffer,
                DllBase,
                ExportDirectory->NumberOfNames,
                (PULONG)((UINT_PTR)DllBase + ExportDirectory->AddressOfNames),
                (PUSHORT)((UINT_PTR)DllBase + ExportDirectory->AddressOfNameOrdinals)
                );

    //
    // If Ordinal is not within the Export Address Table,
    // then DLL does not implement function.
    //

    if ( (ULONG)Ordinal >= ExportDirectory->NumberOfFunctions ) {
        return STATUS_PROCEDURE_NOT_FOUND;
    }

    Addr = (PULONG)(DllBase + ExportDirectory->AddressOfFunctions);
    *AddressOfEntryPoint = (DllBase + Addr[Ordinal]);
    return STATUS_SUCCESS;
}


USHORT
NameToOrdinal (
    IN  PSZ NameOfEntryPoint,
    IN ULONG DllBase,
    IN ULONG NumberOfNames,
    IN PULONG NameTableBase,
    IN PUSHORT NameOrdinalTableBase
    )
/*++

Routine Description:

    Cloned from ntos\init\init.c NameToOrdinal().

Arguments:

    NameOfEntryPoint        - entrypoint name
    DllBase                 - base address of dll
    NumberOfNames           - # names in the dll export table
    NameTableBase           - address of the dll name table
    NameOrdinalTableBase    - address of the dll ordinal table

Return Value:

    Ordinal of the export.  -1 for failure.

--*/
{

    ULONG SplitIndex;
    LONG CompareResult;

    SplitIndex = NumberOfNames >> 1;

    CompareResult = strcmp(NameOfEntryPoint, (PSZ)(DllBase + NameTableBase[SplitIndex]));

    if ( CompareResult == 0 ) {
        return NameOrdinalTableBase[SplitIndex];
    }

    if ( NumberOfNames <= 1 ) {
        return (USHORT)-1;
    }

    if ( CompareResult < 0 ) {
        NumberOfNames = SplitIndex;
    } else {
        NameTableBase = &NameTableBase[SplitIndex+1];
        NameOrdinalTableBase = &NameOrdinalTableBase[SplitIndex+1];
        NumberOfNames = NumberOfNames - SplitIndex - 1;
    }

    return NameToOrdinal(NameOfEntryPoint,DllBase,NumberOfNames,NameTableBase,NameOrdinalTableBase);

}

CONST PCHAR  Kernel32ExportNames32[] = {
                              "BaseProcessStartThunk",
                              "BaseThreadStartThunk",
                              "CtrlRoutine",
                              "ConsoleIMERoutine",
                              "DebugBreak"
                             };

CONST PCHAR  Kernel32ExportNames64[] = {
#if defined(_IA64_)
                              "BaseProcessStartThunk",
                              "BaseThreadStartThunk",
#else
                              "BaseProcessStart",
                              "BaseThreadStart",
#endif
                              "CtrlRoutine",
                              "ConsoleIMERoutine",
                              "DebugBreak"
                             };

UINT NumberKernel32Exports = sizeof(Kernel32ExportNames32) / sizeof(PCHAR);
ULONG Kernel32Exports64[sizeof(Kernel32ExportNames64) / sizeof(PCHAR)];
ULONG Kernel32Exports32[sizeof(Kernel32ExportNames32) / sizeof(PCHAR)];

CONST WCHAR * Kernel32DllNames[] = {
                                L"\\System32\\Kernel32.dll",
                                L"\\" WOW64_SYSTEM_DIRECTORY_U L"\\kernel32.dll",
                              };
PULONG  Kernel32DllPtrTables[] = {Kernel32Exports64, Kernel32Exports32};
CONST PCHAR *Kernel32ExportNames[] = {Kernel32ExportNames64, Kernel32ExportNames32};

CONST BOOLEAN Kernel32Is64bit[] = {TRUE, FALSE};
#define NumberKernel32Dlls 2

#define BASE_PROCESS_START32         (Kernel32Exports32[0])
#define BASE_PROCESS_START64         (Kernel32Exports64[0])
#define BASE_THREAD_START32          (Kernel32Exports32[1])
#define BASE_THREAD_START64          (Kernel32Exports64[1])
#define BASE_ATTACH_COMPLETE_THUNK64 (Kernel32Exports64[2])

NTSTATUS
InitializeContextMapper(
   VOID
   )
/*++

Routine Description:

    Builds a mapping table that is used by ThunkInitialContext to map from addresses
    in 64bit kernel32 to address in 32bit kernel32.

Arguments:

   None.

Return Value:

   NT Error code.

--*/
{
   UINT DllNumber;
   UINT ExportNumber;
   PTEB Teb;

   LOGPRINT((TRACELOG, "Initializing context mapper\n"));

   Teb = NtCurrentTeb();

   for(DllNumber = 0; DllNumber < NumberKernel32Dlls; DllNumber++) {

       WCHAR FullDllNameBuffer[DOS_MAX_PATH_LENGTH];
       UNICODE_STRING DllName;
       BOOLEAN DllNameAllocated;
       HANDLE File, Section;
       OBJECT_ATTRIBUTES ObjectAttributes;
       IO_STATUS_BLOCK IoStatus;
       PVOID ViewBase;
       SIZE_T ViewSize;
       NTSTATUS st;
       PVOID ArbitraryUserPointer;

       File = Section = INVALID_HANDLE_VALUE;
       ViewBase = NULL;
       ViewSize = 0;
       DllNameAllocated = FALSE;

       try {

           LOGPRINT((TRACELOG, "InitializeContextMapper: Mapping in %S\n", Kernel32DllNames[DllNumber]));

           //Build up the file name
           if( wcslen(USER_SHARED_DATA->NtSystemRoot) + wcslen(Kernel32DllNames[DllNumber])
               >= DOS_MAX_PATH_LENGTH )
           {
               LOGPRINT((ERRORLOG, "InitializeContextMapper: failed due to filename length exceeding DOS_MAX_PATH_LENGTH\n"));
               return STATUS_INFO_LENGTH_MISMATCH;
           }
           wcscpy(FullDllNameBuffer, USER_SHARED_DATA->NtSystemRoot);
           wcscat(FullDllNameBuffer, Kernel32DllNames[DllNumber]);

           //
           // Convert the Win32 pathname to an NT pathname
           //
           if (!RtlDosPathNameToNtPathName_U(FullDllNameBuffer,
                                             &DllName,
                                             NULL,
                                             NULL)) {
                // probably out-of-memory
                return STATUS_UNSUCCESSFUL;
           }
           DllNameAllocated = TRUE;
           LOGPRINT((TRACELOG, "InitializeContextMapper: Opening %wZ\n", &DllName));

           //
           // Open the file
           //
           InitializeObjectAttributes(&ObjectAttributes,
                                      &DllName,
                                      OBJ_CASE_INSENSITIVE,
                                      NULL,
                                      NULL);

           st = NtOpenFile(&File,
                           SYNCHRONIZE | FILE_EXECUTE,
                           &ObjectAttributes,
                           &IoStatus,
                           FILE_SHARE_READ | FILE_SHARE_DELETE,
                           FILE_NON_DIRECTORY_FILE | FILE_SYNCHRONOUS_IO_NONALERT);
           if (!NT_SUCCESS(st)) {
               LOGPRINT((TRACELOG, "InitializeContextMapper: Unable to open file, status %x\n", st));
               return st;
           }

           //
           // Create the section
           //
           st = NtCreateSection(&Section,
                                SECTION_MAP_READ | SECTION_MAP_EXECUTE | SECTION_MAP_WRITE,
                                NULL,
                                NULL,
                                PAGE_EXECUTE,
                                SEC_IMAGE,
                                File);

           if (!NT_SUCCESS(st)) {
               LOGPRINT((TRACELOG, "InitializeContextMapper: Unable to create section, status %x\n", st));
               return st;
           }

           ArbitraryUserPointer = Teb->NtTib.ArbitraryUserPointer;
           Teb->NtTib.ArbitraryUserPointer = L"NOT_AN_IMAGE";
           st = NtMapViewOfSection(Section,
                                   NtCurrentProcess(),
                                   &ViewBase,
                                   0,
                                   0,
                                   NULL,
                                   &ViewSize,
                                   ViewUnmap,
                                   0,
                                   PAGE_EXECUTE);
           Teb->NtTib.ArbitraryUserPointer = ArbitraryUserPointer;

           if (!NT_SUCCESS(st) || STATUS_IMAGE_NOT_AT_BASE == st) {
               LOGPRINT((TRACELOG, "InitializeContextMapper: Unable to map view of section, status %x\n", st));
               if (st == STATUS_IMAGE_NOT_AT_BASE) {
                   st = STATUS_UNSUCCESSFUL;
               }
               return st;
           }

           for(ExportNumber = 0; ExportNumber < NumberKernel32Exports; ExportNumber++) {

               st = LookupEntryPoint((ULONG)(ULONG_PTR)ViewBase,
                     Kernel32ExportNames[DllNumber][ExportNumber],
                                     &(Kernel32DllPtrTables[DllNumber][ExportNumber]),
                                     Kernel32Is64bit[DllNumber]);
               if (!NT_SUCCESS(st)) {
                   LOGPRINT((TRACELOG, "InitializeContextMapper: Unable to lookup entrypoint %s, status %x\n", Kernel32ExportNames[DllNumber][ExportNumber], st));
                   return st;
               }

               LOGPRINT((TRACELOG, "InitializeContextMapper: Found entrypoint %s at %x\n", Kernel32ExportNames[DllNumber][ExportNumber], Kernel32DllPtrTables[DllNumber][ExportNumber]));

           }

       }

       finally {

          //Deallocate all the allocated resources
          if (ViewBase) {
              NtUnmapViewOfSection(NtCurrentProcess(),
                                   ViewBase);
          }
          if (INVALID_HANDLE_VALUE != Section) {
              NtClose(Section);
          }
          if (INVALID_HANDLE_VALUE != File) {
              NtClose(File);
          }
          if (DllNameAllocated) {
              RtlFreeHeap(RtlProcessHeap(), 0, DllName.Buffer);
          }

       }

   }

   return STATUS_SUCCESS;

}

ULONG
MapContextAddress64TO32(
  IN ULONG Address
  )
{

   UINT i;

   for(i=0; i<NumberKernel32Exports; i++) {

      if (Address == Kernel32Exports64[i]) {
          return Kernel32Exports32[i];
      }

   }

   return Address;

}

VOID
ThunkStartupContext64TO32(
   IN OUT PCONTEXT32 Context32,
   IN PCONTEXT Context64
   )
/*++

Routine Description:

    Munges the InitialPC and arguments registers to compensate for the fact that
    32bit kernel32 has different entry points then 64bit kernel32.  The 32bit context must
    have had the context flags set to full and the stack pointer initialized.

Arguments:

   Context32 - Receives a munged 32bit context.
   Context64 - Supplies the initial 64bit context.

Return Value:

   NT Error code.

--*/
{
    //
    // Thunk the 64-bit CONTEXT down to 32-bit.
    //
    ULONG InitialPC, StartupAddress, Arg1;

#if defined(_AMD64_)
    InitialPC = (ULONG)Context64->Rip;

    //
    // If this is a context created by 64-bit RtlCreateUserThread...
    //

    if (Context64->R9 == 0xf0e0d0c0a0908070UI64) {

        StartupAddress = InitialPC;
        Arg1 = (ULONG)Context64->Rcx;
    } else {
        
        StartupAddress = (ULONG)Context64->Rcx;
        Arg1 = (ULONG)Context64->Rdx;
    }
    if (Context64->R8 != 0) {
        Context32->Esp = (ULONG)Context64->R8;
    }
#elif defined(_IA64_)
    InitialPC = (ULONG)Context64->StIIP;
    StartupAddress = (ULONG)Context64->IntS1;
    Arg1 = (ULONG)Context64->IntS2;
    if (Context64->IntS3 != 0) {
        Context32->Esp = (ULONG)Context64->IntS3;
    }
#else
#error "No Target Architecture"
#endif

    LOGPRINT((TRACELOG, "ThunkStartupContent64TO32: Original InitialPC %x, StartupAddress %x, Arg1 %x\n", InitialPC, StartupAddress, Arg1));

    if (InitialPC == BASE_PROCESS_START64) {
        LOGPRINT((TRACELOG, "ThunkStartupContext64TO32: Thunking kernel32 process start\n"));
        InitialPC = BASE_PROCESS_START32;
        StartupAddress = MapContextAddress64TO32(StartupAddress);
    }
    else if (InitialPC == BASE_THREAD_START64) {
        LOGPRINT((TRACELOG, "ThunkStartupContext64TO32: Thunking kernel32 thread start\n"));
        InitialPC = BASE_THREAD_START32;
        StartupAddress = MapContextAddress64TO32(StartupAddress);
    }
    else {
        LOGPRINT((TRACELOG, "ThunkStartupContext64TO32: thunking generic context\n"));
        InitialPC = MapContextAddress64TO32(InitialPC);
    }

    LOGPRINT((TRACELOG, "ThunkStartupContent64TO32: New InitialPC %x, StartupAddress %x, Arg1 %x\n", InitialPC, StartupAddress, Arg1));

    Context32->Eip = InitialPC;
    Context32->Eax = StartupAddress;
    Context32->Ebx = Arg1;
}

VOID
SetProcessStartupContext64(
    OUT PCONTEXT Context64,
    IN HANDLE ProcessHandle,
    IN PCONTEXT32 Context32,
    IN ULONGLONG InitialSP64,
    IN ULONGLONG TransferAddress64
    )
/*++

Routine Description:

   Initializes a 64bit context for startup of a 64bit process.

Arguments:

   Context32 - Receives a initial 64bit context.
   ProcessHandle - Handle to the process the context is being created for.
   Context32 - Supplies the initial 32bit context as passed to NtCreateThread.
   InitialSP64 - Supplies the Initial 64bit stack pointer.
   TransferAddress64 - Supplies the address of the app startup code.

Return Value:

   None.

--*/
{

    //
    // Do what BaseInitializeContext(&Context64) would have done
    //

#if defined(_AMD64_)

    RtlZeroMemory(Context64, sizeof(CONTEXT));
    Context64->Rsp = InitialSP64;
    Context64->ContextFlags = CONTEXT_FULL;
    if (Context32->Eip == BASE_PROCESS_START32) {

        //
        // This is a call from CreateProcess.
        //
        // RIP should be kernel32.dll's process startup routine and rcx should
        // contain the exe's startup address.
        //

        Context64->Rip = BASE_PROCESS_START64;
        Context64->Rcx = TransferAddress64;

    } else if (Context32->Eip == BASE_THREAD_START32) {

        //
        // This is a call from CreateThread.
        //
        // RIP should be kernel32.dll's process startup routine and rcx should
        // contain the exe's startup address.
        //

        Context64->Rip = BASE_THREAD_START64;
        Context64->Rcx = TransferAddress64;

    } else {

        //
        // This is a call from ntdll.
        //
        // RIP should point to the exe startup address and rcx is the parameter.
        //

        ULONGLONG Argument;
        NTSTATUS Status;

        Context64->Rip = TransferAddress64;
        Argument = 0;
        Status = NtReadVirtualMemory(ProcessHandle,
                                     (PVOID)(Context32->Esp + sizeof(ULONG)),
                                     &Argument,
                                     sizeof(ULONG),
                                     NULL);

        if (NT_SUCCESS(Status)) {
            Context64->Rcx = Argument;
        }
    }

#elif defined(_IA64_)

    RtlZeroMemory(Context64, sizeof(CONTEXT));

    //
    // Everyone is assumed to have this...
    //
    Context64->SegCSD = USER_CODE_DESCRIPTOR;
    Context64->SegSSD = USER_DATA_DESCRIPTOR;
    Context64->Cflag = (ULONGLONG)((CR4_VME << 32) | CR0_PE | CFLG_II);
    Context64->Eflag = 0x00003000ULL;

    //
    // from ...\win\base\client\ia64\context.c
    //
    // Context64->RsPFS = 0;     // Done by the RtlZeroMemory() above
    //
    Context64->StIPSR = USER_PSR_INITIAL;
    Context64->StFPSR = USER_FPSR_INITIAL;
    Context64->RsBSP = Context64->RsBSPSTORE = Context64->IntSp = InitialSP64;
    Context64->IntSp -= STACK_SCRATCH_AREA; // scratch area as per convention
    Context64->IntS1 = TransferAddress64;
    Context64->IntS0 = Context64->StIIP = BASE_PROCESS_START64;

    //
    // Enable RSE engine
    //
    Context64->RsRSC = (RSC_MODE_EA<<RSC_MODE)
                   | (RSC_BE_LITTLE<<RSC_BE)
                   | (0x3<<RSC_PL);

    //
    // Note that we purposely set IntGp = 0ULL, to indicate special protocol
    // (see ps\ia64\psctxia64.c) - specifically, the StIIP address is really
    // a pointer to a plabel instead of the usual (a valid executable
    // address)
    //
    // Context64->IntGp = 0ULL;     // Done by the RtlZeroMemory() above
    //
    //
    // set nat bits for every thing except ap, gp, sp, also  T0 and T1
    //
    Context64->ApUNAT = 0xFFFFFFFFFFFFEDF1ULL;

    Context64->ContextFlags = CONTEXT_CONTROL| CONTEXT_INTEGER;

    if (Context32->Eip == BASE_PROCESS_START32) {
        //
        // This is a call from CreateProcess.  The IIP should be
        // kernel32.dll's process startup routine, and IntS0 should contain
        // the exe's startup address
        //
        Context64->IntS0 = Context64->StIIP = BASE_PROCESS_START64;
        Context64->IntS1 = TransferAddress64;

    } else if (Context32->Eip == BASE_THREAD_START32) {
        //
        // This is a call from CreateThread.  The IIP should be
        // kernel32.dll's process startup routine, and IntS0 should contain
        // the exe's startup address
        //
        Context64->IntS0 = Context64->StIIP = BASE_THREAD_START64;
        Context64->IntS1 = TransferAddress64;

    } else {
        //
        // This is a call from ntdll.  The IIP should point to the
        // exe startup address, and IntA0 is the parameter.
        //
        ULONGLONG Argument;
        NTSTATUS Status;

        Context64->IntS0 = Context64->StIIP = TransferAddress64;
        Argument = 0;
        Status = NtReadVirtualMemory(ProcessHandle,
                                     (PVOID)(Context32->Esp + sizeof(ULONG)),
                                     &Argument,
                                     sizeof(ULONG),
                                     NULL);
        if (NT_SUCCESS(Status)) {
             //
             // Note:  IA64 RtlInitializeContext does this write and ignores
             //        the return value, so we'll do the same.
             //
             NtWriteVirtualMemory(ProcessHandle,
                                  (PVOID)((ULONG_PTR)Context64->RsBSPSTORE),
                                  (PVOID)&Argument,
                                  sizeof(Argument),
                                  NULL);
        }
    }
#else
#error "No Target Architecture"
#endif
}

//
// names are in the NT name space.
//
CONST WCHAR *DllsToMapList[] = {L"\\KnownDlls\\kernel32.dll",
                                L"\\KnownDlls\\user32.dll"};
struct {
    PVOID DllBase;
    SIZE_T Length;
} DllsToMap[sizeof(DllsToMapList) / sizeof(sizeof(DllsToMapList[0]))];

NTSTATUS
Map64BitDlls(
    VOID
    )
/*++

Routine Description:

    Reserve ONLY the dlls address space without committing.  This is to prevent 32bit versions
    of these DLLs appearing at the same address and to catch unthunked callbacks.

Arguments:

   None.

Return Value:

   NT Error code.

--*/
{

   NTSTATUS Status;
   UINT c;
   PTEB Teb;
   PVOID BaseAddress;
   SIZE_T RegionSize;
   HANDLE SectionHandle;

   Teb=NtCurrentTeb();

   for(c=0;c<sizeof(DllsToMapList)/sizeof(DllsToMapList[0]);c++) {

      OBJECT_ATTRIBUTES ObjectAttributes;
      UNICODE_STRING SectionName;
      SIZE_T ViewSize;
      PVOID ArbitraryUserPointer;

      LOGPRINT((TRACELOG, "Map64BitDlls: Mapping 64bit section for %S\n", DllsToMapList[c]));

      RegionSize = 0;
      BaseAddress = NULL;
      SectionHandle = INVALID_HANDLE_VALUE;

      RtlInitUnicodeString(&SectionName, DllsToMapList[c]);

      InitializeObjectAttributes(&ObjectAttributes,
                                 &SectionName,
                                 OBJ_CASE_INSENSITIVE,
                                 NULL,
                                 NULL);

      Status = NtOpenSection(&SectionHandle,
                             SECTION_MAP_READ | SECTION_MAP_EXECUTE | SECTION_MAP_WRITE | SECTION_QUERY,
                             &ObjectAttributes);

      if (!NT_SUCCESS(Status)) {
          LOGPRINT((ERRORLOG, "Map64BitDlls: Unable to open section for %S, error %x\n", DllsToMapList[c], Status));
          SectionHandle = INVALID_HANDLE_VALUE;
          goto cleanup;
      }

      // get the image base and size
      ArbitraryUserPointer = Teb->NtTib.ArbitraryUserPointer;
      Teb->NtTib.ArbitraryUserPointer = L"NOT_AN_IMAGE";
      Status = NtMapViewOfSection(SectionHandle,
                                  NtCurrentProcess(),
                                  &BaseAddress,
                                  0,
                                  0,
                                  NULL,
                                  &RegionSize,
                                  ViewUnmap,
                                  0,
                                  PAGE_NOACCESS);
      Teb->NtTib.ArbitraryUserPointer = ArbitraryUserPointer;

      if (!NT_SUCCESS(Status) || STATUS_IMAGE_NOT_AT_BASE == Status) {
          LOGPRINT((ERRORLOG, "Map64BitDlls: Unable to map view for %S, error %x\n", DllsToMapList[c], Status));
          BaseAddress = NULL;
          
          if (Status == STATUS_IMAGE_NOT_AT_BASE) {
              Status = STATUS_UNSUCCESSFUL;
          }
          goto cleanup;
      }
      
      NtUnmapViewOfSection(NtCurrentProcess(), BaseAddress);
      NtClose(SectionHandle);

      // just reserve address space
      DllsToMap[c].DllBase = BaseAddress;

      Status = NtAllocateVirtualMemory(NtCurrentProcess(),
                                       &DllsToMap[c].DllBase,
                                       0,
                                       &RegionSize,
                                       MEM_RESERVE,
                                       PAGE_EXECUTE_READWRITE);

      if (!NT_SUCCESS(Status)) {
          LOGPRINT((ERRORLOG, "Map64BitDlls: Couldn't reserve memory Base=%lx, Size=%lx - Status = %lx\n",
                    DllsToMap[c].DllBase, RegionSize, Status));
                    DllsToMap[c].DllBase = NULL;
          goto CleanupLoop;
      }
      DllsToMap[c].Length = RegionSize;

      LOGPRINT((TRACELOG, "Map64BitDlls: %S mapped in at %p, size %p\n", DllsToMapList[c], DllsToMap[c].DllBase, DllsToMap[c].Length));
   }
   return STATUS_SUCCESS;

cleanup:
   
   if (NULL != BaseAddress) {
       NtUnmapViewOfSection(NtCurrentProcess(),
                            BaseAddress);
   }

   if (INVALID_HANDLE_VALUE != SectionHandle) {
       NtClose(SectionHandle);
   }

CleanupLoop:
   for(c=0;c<sizeof(DllsToMapList)/sizeof(DllsToMapList[0]);c++) {
       if (NULL != DllsToMap[c].DllBase) {
           RegionSize = 0;
           NtFreeVirtualMemory(NtCurrentProcess(),
                               &DllsToMap[c].DllBase,
                               &RegionSize,
                               MEM_RELEASE);
           DllsToMap[c].DllBase = NULL;
       }
   }

   return Status;
}

VOID
Wow64pBreakPoint(
    VOID
    )
/*++

Routine Description:

    This function is remote called to after a successful debug attach. Its
    purpose is to issue a breakpoint and then simulate 64-bit
    kernel32!ExitThread.
    
Arguments:

    None.

Return Value:

    None.

--*/

{
    HANDLE DebugPort;
    NTSTATUS Status;

    DebugPort = (HANDLE)NULL;

    Status = NtQueryInformationProcess(
                NtCurrentProcess(),
                ProcessDebugPort,
                (PVOID)&DebugPort,
                sizeof(DebugPort),
                NULL
                );

    if (NT_SUCCESS(Status) && DebugPort)
    {
        DbgBreakPoint();
    }
    
    NtCurrentTeb()->FreeStackOnTermination = TRUE;
    NtTerminateThread (NtCurrentThread(), 0);
}

VOID
Run64IfContextIs64(
    IN PCONTEXT Context,
    IN BOOLEAN IsFirstThread
    )
/*++

Routine Description:

    Called early in Wow64LdrpInitialize.  This routine checks the initial
    64-bit CONTEXT record, and if it looks like the new thread should be run
    as 64-bit (ie. without emulation), then this routine runs the 64-bit
    CONTEXT and terminates the thread/process.  If the initial CONTEXT
    appears to be one that should be run as 32-bit, then it returns back to
    its caller, and the caller must convert the CONTEXT to 32-bit and
    simulate it.

Arguments:

    Context                 - 64bit initial context for this thread.
    IsFirstThread           - TRUE for the initial thread in the process, FALSE
                              for all other threads.

Return Value:

    None - Runs context if context is 64bit.  Otherwise, return.
    
--*/
{    
    PLDR_DATA_TABLE_ENTRY Entry;
    PLDR_DATA_TABLE_ENTRY32 Entry32;
    PPEB_LDR_DATA32 Data32;
    ULONG64 InitialPC;
    NTSTATUS Status;
    LIST_ENTRY *NtDllEntry;
    int i;

#if defined(_AMD64_)
    //
    // If this is a context created by 64-bit RtlCreateUserThread...
    //

    if (Context->R9 == 0xf0e0d0c0a0908070UI64) {
        InitialPC = Context->Rip;
    } else {
        InitialPC = Context->Rcx;
    }
#elif defined(_IA64_)
    InitialPC = Context->IntS1;
#else
#error "No Target Architeture"
#endif   

    // Try to match the InitialPC with 64-bit ntdll.dll.  64-bit ntdll.dll
    // is the second entry in the InLoadOrderModuleList.
    NtDllEntry = NtCurrentPeb()->Ldr->InLoadOrderModuleList.Flink->Flink;
    Entry = CONTAINING_RECORD(NtDllEntry, 
                              LDR_DATA_TABLE_ENTRY, 
                              InLoadOrderLinks);
    // Just put this statement in the code so this structure is loaded
    // in the .pdb file for debugging.
    Entry32 =  CONTAINING_RECORD(NtDllEntry,
                                 LDR_DATA_TABLE_ENTRY32,
                                 InLoadOrderLinks);
    Data32 = (PPEB_LDR_DATA32) NtCurrentPeb()->Ldr;
    
    if (InitialPC >= (ULONG64)Entry->DllBase &&
        InitialPC < (ULONG64)((PCHAR)Entry->DllBase + Entry->SizeOfImage))  {

        //
        // The address is within 64-bit ntdll.dll.  Run the 64-bit function directly
        //

#if defined(_IA64_)
        
        Context->IntGp = ((PPLABEL_DESCRIPTOR)Context->IntS0)->GlobalPointer;
        Context->StIIP = ((PPLABEL_DESCRIPTOR)Context->IntS0)->EntryPoint;
        if (Context->StIPSR & IPSR_RI_MASK) { 
            LOGPRINT((ERRORLOG, "Warning!  IPSR has nonzero slot #.  Slot# is %d\n",(Context->StIPSR >> PSR_RI) & 3));
            Context->StIPSR &= ~IPSR_RI_MASK;
        }
#elif defined(_AMD64_)
        ;
#else
#error "No Target Architeture"
#endif
        LOGPRINT((TRACELOG, "InitialPC %p is within 64-bit ntdll.dll.  Running 64-bit context unchanged.\n", InitialPC));
        goto runcontext64;
    }

    //
    // Check if the address is within one of the address-space holes reserved
    // for 64-bit kernel32 and user32.
    //
    for (i=0; i<sizeof(DllsToMapList)/sizeof(DllsToMapList[0]); ++i) {
        if (InitialPC >= (ULONG64)DllsToMap[i].DllBase && 
            InitialPC < (ULONG64)DllsToMap[i].DllBase+DllsToMap[i].Length) {
            
            //
            // The InitialPC is inside one of the reserved holes
            //
            if (MapContextAddress64TO32((ULONG)InitialPC) == InitialPC) {
                
                //
                // The InitialPC is not one that we special-case by converting
                // into a call to the 32-bit DLL.  It may be kernel32!DebugBreak
                // or some other routine.
                //

                LOGPRINT((TRACELOG, "InitialPC %p found in the space reserved for 64-bit %wZ.", InitialPC, DllsToMapList[i]));
#if defined(_AMD64_)

                //
                // Map it to a 64-bit break point since we couldn't find a replacement startup address
                //
                Context->Rip = (ULONG64)Wow64pBreakPoint;

#elif defined(_IA64_)
                
                //
                // Map it to a 64-bit break point since we couldn't find a replacement startup address
                //
                Context->IntGp = ((PPLABEL_DESCRIPTOR)Wow64pBreakPoint)->GlobalPointer;
                Context->StIIP = ((PPLABEL_DESCRIPTOR)Wow64pBreakPoint)->EntryPoint;
                if (Context->StIPSR & IPSR_RI_MASK) { 
                    LOGPRINT((ERRORLOG, "Warning!  IPSR has nonzero slot #.  Slot# is %d\n",(Context->StIPSR >> PSR_RI) & 3));
                    Context->StIPSR &= ~IPSR_RI_MASK;
                }
#else
#error "No Target Architecture"
#endif                
                goto runcontext64;
            }
        }
    }

    // The initial context should be run as 32-bit
    return;

runcontext64:
    Status = NtContinue(Context, TRUE);
    WOWASSERT(!NT_SUCCESS(Status));
    if (IsFirstThread) {
       NtTerminateProcess(NtCurrentProcess(), Status);
    } else {
       NtTerminateThread(NtCurrentThread(), Status);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64\debug.c ===
/*++                 

Copyright (c) 1998 Microsoft Corporation

Module Name:

    debug.c

Abstract:
    
    Debugging/Logging helpers

Author:

    11-May-1998 BarryBo    

Revision History:

    05-Oct-1999 SamerA     Samer Arafeh
        Move logging code to wow64ext.dll
        
    05-Dec-2001 SamerA    Samer Arafeh
        Code cleanup. Remove profiling code.

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntverp.h>
#include <stdio.h>
#include <stdlib.h>
#include "wow64p.h"
#include "wow64log.h"

ASSERTNAME;

//
// Wow64log functions
//

PFNWOW64LOGINITIALIZE pfnWow64LogInitialize;
PFNWOW64LOGSYSTEMSERVICE pfnWow64LogSystemService;
PFNWOW64LOGMESSAGEARGLIST pfnWow64LogMessageArgList;
PFNWOW64LOGTERMINATE pfnWow64LogTerminate;




///////////////////////////////////////////////////////////////////////////////////////
//
//                        Generic utility routines.
//
///////////////////////////////////////////////////////////////////////////////////////


PWSTR
GetImageName(
    IN PWSTR DefaultImageName
    )
/*++

Routine Description:

    Gets the name of this image.

Arguments:

    DefaultImageName - Supplies the name to return on error.

Return Value:

    Success - The image name allocated with Wow64AllocateHeap.
    Failure - DefaultImageName 

--*/

{
   
   // Get the image name
   PPEB Peb;
   PWSTR Temp = NULL;
   PUNICODE_STRING ImagePathName;
   PWSTR ReturnValue;
   NTSTATUS Status;
   PVOID LockCookie = NULL;

   Peb = NtCurrentPeb();
   LdrLockLoaderLock(LDR_LOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, NULL, &LockCookie);
   
   try {
            
      PWCHAR Index;
      ULONG NewLength;

      if (!Peb->ProcessParameters) {
          Temp = DefaultImageName;
          leave;
      }
      ImagePathName = &(Peb->ProcessParameters->ImagePathName);

      if (!ImagePathName->Buffer || !ImagePathName->Length) {   
          Temp = DefaultImageName;
          leave;
      }

      //Strip off the path from the image name.
      //Start just after the last character
      Index = (PWCHAR)((PCHAR)ImagePathName->Buffer + ImagePathName->Length);
      while(Index-- != ImagePathName->Buffer && *Index != '\\');
      Index++;
      NewLength = (ULONG)((ULONG_PTR)((PCHAR)ImagePathName->Buffer + ImagePathName->Length) - (ULONG_PTR)(Index));

      Temp = Wow64AllocateHeap(NewLength+sizeof(UNICODE_NULL));
      if (!Temp) {
          Temp = DefaultImageName;
          __leave;
      }

      RtlCopyMemory(Temp, Index, NewLength);
      Temp[(NewLength / sizeof(WCHAR))] = L'\0';
   } __finally {
       LdrUnlockLoaderLock(LDR_UNLOCK_LOADER_LOCK_FLAG_RAISE_ON_ERRORS, LockCookie);
   }

   return Temp;

}


///////////////////////////////////////////////////////////////////////////////////////
//
//                        Generic IO utility routines.
//
///////////////////////////////////////////////////////////////////////////////////////

VOID
FPrintf(
   IN HANDLE Handle,
   IN CHAR *Format,
   ...
   )
/*++

Routine Description:

   The same as the C library function fprintf, except errors are ignored and output is to a 
   NT executive file handle. 

Arguments:

    Handle - Supplies a NT executive file handle to write to.
    Format - Supplies the format specifier.

Return Value:

    None. All errors are ignored.
--*/    
{
   va_list pArg;                                                 
   CHAR Buffer[1024];
   int c;
   IO_STATUS_BLOCK IoStatus;

   va_start(pArg, Format);                                       
   if (-1 == (c = _vsnprintf(Buffer, sizeof (Buffer), Format, pArg))) {
      return;
   }

   NtWriteFile(Handle,                                                
               NULL,                                                  
               NULL,                                                  
               NULL,                                                  
               &IoStatus,                                             
               Buffer,                                                
               c,                     
               NULL,                                                  
               NULL);
}


///////////////////////////////////////////////////////////////////////////////////////
//
//                        Logging and assert routines.
//
///////////////////////////////////////////////////////////////////////////////////////

void
LogOut(
   IN UCHAR LogLevel,
   IN char *pLogOut
   )
/*++

Routine Description:

    Generic helper routine which outputs the string to the appropriate
    destination(s).

Arguments:

    pLogOut - string to output

Return Value:

    None.

--*/
{
    //
    // Send the output to the debugger, if log flag is ERRORLOG.
    //

    if (LogLevel == ERRORLOG)
    {
       DbgPrint(pLogOut);
    }
}

WOW64DLLAPI
VOID
Wow64Assert(
    IN CONST PSZ exp,
    OPTIONAL IN CONST PSZ msg,
    IN CONST PSZ mod,
    IN LONG line
    )
/*++

Routine Description:

    Function called in the event that an assertion failed.  This is always
    exported from wow64.dll, so a checked thunk DLL can coexist with a retail
    wow64.dll.

Arguments:

    exp     - text representation of the expression from the assert
    msg     - OPTIONAL message to display
    mod     - text of the source filename
    line    - line number within 'mod'

Return Value:

    None.

--*/
{
#if DBG
    if (msg) {
        LOGPRINT((ERRORLOG, "WOW64 ASSERTION FAILED:\r\n  %s\r\n%s\r\nFile: %s Line %d\r\n", msg, exp, mod, line));
    } else {
        LOGPRINT((ERRORLOG, "WOW64 ASSERTION FAILED:\r\n  %s\r\nFile: %s Line %d\r\n", exp, mod, line));
    }

    if (NtCurrentPeb()->BeingDebugged) {
        DbgBreakPoint();
    }
#endif
}


void
WOW64DLLAPI
Wow64LogPrint(
   UCHAR LogLevel,
   char *format,
   ...
   )
/*++

Routine Description:

    WOW64 logging mechanism.  If LogLevel > ModuleLogLevel then print the
    message, else do nothing.

Arguments:

    LogLevel    - requested verbosity level
    format      - printf-style format string
    ...         - printf-style args

Return Value:

    None.

--*/
{
    int i, Len;
    va_list pArg;
    char *pch;
    char Buffer[1024];

    //
    // Call wow64log DLL if loaded
    //
    if (pfnWow64LogMessageArgList) 
    {
        va_start(pArg, format);
        (*pfnWow64LogMessageArgList)(LogLevel, format, pArg);
        va_end(pArg);
        return;
    }

    pch = Buffer;
    Len = sizeof(Buffer) - 1;
    i = _snprintf(pch, Len, "%8.8X:%8.8X ",
                  PtrToUlong(NtCurrentTeb()->ClientId.UniqueProcess), 
                  PtrToUlong(NtCurrentTeb()->ClientId.UniqueThread));
   
    ASSERT((PVOID)PtrToUlong(NtCurrentTeb()->ClientId.UniqueProcess) == NtCurrentTeb()->ClientId.UniqueProcess);
    ASSERT((PVOID)PtrToUlong(NtCurrentTeb()->ClientId.UniqueThread) == NtCurrentTeb()->ClientId.UniqueThread);

    if (i == -1) {
        i = sizeof(Buffer) - 1;
        Buffer[i] = '\0';
    } else if (i < 0) {
        return;
    }

    Len -= i;
    pch += i;

    va_start(pArg, format);
    i = _vsnprintf(pch, Len, format, pArg);
    // Force null termination in case the call fails.  It may return
    // sizeof(buffer) and not null-terminate!
    Buffer[sizeof(Buffer)-1] = '\0';
    LogOut(LogLevel, Buffer);
}


///////////////////////////////////////////////////////////////////////////////////////
//
//                        Startup and shutdown routines.
//
///////////////////////////////////////////////////////////////////////////////////////


NTSTATUS
Wow64pLoadLogDll(
    VOID)
{
    NTSTATUS NtStatus;
    UNICODE_STRING Wow64LogDllName;
    ANSI_STRING ProcName;
    PVOID Wow64LogDllBase = NULL;


    RtlInitUnicodeString(&Wow64LogDllName, L"wow64log.dll");
    NtStatus = LdrLoadDll(NULL, NULL, &Wow64LogDllName, &Wow64LogDllBase);
    if (NT_SUCCESS(NtStatus)) 
    {

        //
        // Get the entry points
        //
        RtlInitAnsiString(&ProcName, "Wow64LogInitialize");
        NtStatus = LdrGetProcedureAddress(Wow64LogDllBase,
                                          &ProcName,
                                          0,
                                          (PVOID *) &pfnWow64LogInitialize);

        if (NT_SUCCESS(NtStatus)) 
        {
            RtlInitAnsiString(&ProcName, "Wow64LogSystemService");
            NtStatus = LdrGetProcedureAddress(Wow64LogDllBase,
                                              &ProcName,
                                              0,
                                              (PVOID *) &pfnWow64LogSystemService);
            if (!NT_SUCCESS(NtStatus)) 
            {
                goto RetStatus;
            }

            RtlInitAnsiString(&ProcName, "Wow64LogMessageArgList");
            NtStatus = LdrGetProcedureAddress(Wow64LogDllBase,
                                              &ProcName,
                                              0,
                                              (PVOID *) &pfnWow64LogMessageArgList);
            if (!NT_SUCCESS(NtStatus)) 
            {
                goto RetStatus;
            }

            RtlInitAnsiString(&ProcName, "Wow64LogTerminate");
            NtStatus = LdrGetProcedureAddress(Wow64LogDllBase,
                                              &ProcName,
                                              0,
                                              (PVOID *) &pfnWow64LogTerminate);

            //
            // If all is well, then let's initialize
            //
            if (NT_SUCCESS(NtStatus)) 
            {
                NtStatus = (*pfnWow64LogInitialize)();
            }
        }
    }

RetStatus:
    
    if (!NT_SUCCESS(NtStatus))
    {
        pfnWow64LogInitialize =  NULL;
        pfnWow64LogSystemService = NULL;
        pfnWow64LogMessageArgList = NULL;
        pfnWow64LogTerminate = NULL;

        if (Wow64LogDllBase) 
        {
            LdrUnloadDll(Wow64LogDllBase);
        }
    }

    return NtStatus;
}


VOID
InitializeDebug(
    VOID
    )

/*++

Routine Description:

    Initializes the debug system of wow64.

Arguments:

    None.
    
Return Value:

    None.

--*/

{
   Wow64pLoadLogDll();
}

VOID ShutdownDebug(
     VOID
     )
/*++

Routine Description:

    Shutdown the debug system of wow64.

Arguments:

    None.
    
Return Value:

    None.

--*/
{
    if (pfnWow64LogTerminate)
    {
        (*pfnWow64LogTerminate)();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64\thread.c ===
/*++                 

Copyright (c) 1998 Microsoft Corporation

Module Name:

    thread.c

Abstract:
    
    Infrastructure for 32-bit code creating and manipulating threads

Author:

    17-Aug-1998 BarryBo - split out from wow64.c

Revision History:

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <winbasep.h>
#include "wow64p.h"
#include "wow64cpu.h"
#include "nt32.h"
#include "thnkhlpr.h"
#include "stdio.h"

ASSERTNAME;

SIZE_T Wow64MaximumStackSize = 384 * 1024;  // 384K is wow stack requirement
SIZE_T Wow64CommittedStackSize = 1024 * 32; // 32k

HANDLE SuspendThreadMutant;



NTSTATUS
Wow64pReadVirtualMemory (
     IN HANDLE ProcessHandle,
     IN PVOID BaseAddress,
     OUT PVOID Buffer,
     IN SIZE_T BufferSize,
     OUT PSIZE_T NumberOfBytesRead OPTIONAL
     )

/*++

Routine Description:

    This function copies the specified address range from the specified
    process into the specified address range of the current process.
    
    This function optmizes the code path if the ProcessHandle is the current
    process.

Arguments:

     ProcessHandle - Supplies an open handle to a process object.

     BaseAddress - Supplies the base address in the specified process
                   to be read.

     Buffer - Supplies the address of a buffer which receives the
              contents from the specified process address space.

     BufferSize - Supplies the requested number of bytes to read from
                  the specified process.

     NumberOfBytesRead - Receives the actual number of bytes
                         transferred into the specified buffer.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS NtStatus;

    if (ProcessHandle == NtCurrentProcess ()) {

        try {
            
            NtStatus = STATUS_SUCCESS;

            RtlCopyMemory (Buffer,
                           BaseAddress,
                           BufferSize);
        
            if (ARGUMENT_PRESENT (NumberOfBytesRead) != 0) {
                *NumberOfBytesRead = BufferSize;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {

              NtStatus = GetExceptionCode ();
        }
    } else {

        NtStatus = NtReadVirtualMemory (ProcessHandle,
                                        BaseAddress,
                                        Buffer,
                                        BufferSize,
                                        NumberOfBytesRead);
    }

    return NtStatus;
}

NTSTATUS
Wow64pWriteVirtualMemory(
     IN HANDLE ProcessHandle,
     OUT PVOID BaseAddress,
     IN CONST VOID *Buffer,
     IN SIZE_T BufferSize,
     OUT PSIZE_T NumberOfBytesWritten OPTIONAL
     )

/*++

Routine Description:

    This function copies the specified address range from the current
    process into the specified address range of the specified process.
    
    This function optmizes the code path if the ProcessHandle is the current
    process.
    
Arguments:

     ProcessHandle - Supplies an open handle to a process object.

     BaseAddress - Supplies the base address to be written to in the
                   specified process.

     Buffer - Supplies the address of a buffer which contains the
              contents to be written into the specified process
              address space.

     BufferSize - Supplies the requested number of bytes to write
                  into the specified process.

     NumberOfBytesWritten - Receives the actual number of bytes
                            transferred into the specified address space.

Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS NtStatus;

    if (ProcessHandle == NtCurrentProcess ()) {

        try {
            
            NtStatus = STATUS_SUCCESS;

            RtlCopyMemory (BaseAddress,
                           Buffer,
                           BufferSize);
        
            if (ARGUMENT_PRESENT (NumberOfBytesWritten) != 0) {
                *NumberOfBytesWritten = BufferSize;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {

              NtStatus = GetExceptionCode ();
        }
    } else {

        NtStatus = NtWriteVirtualMemory (ProcessHandle,
                                         BaseAddress,
                                         Buffer,
                                         BufferSize,
                                         NumberOfBytesWritten);
    }

    return NtStatus;
}

NTSTATUS
Wow64CreateStack64(
    IN HANDLE Process,
    IN SIZE_T MaximumStackSize,
    IN SIZE_T CommittedStackSize,
    OUT PINITIAL_TEB InitialTeb
    )
/*++

Routine Description:

    Create a 64-bit stack for a new thread created from 32-bit code.

Arguments:

    Process             - process to create the Teb in
    MaximumStackSize    - size of memory to reserve for the stack
    CommittedStackSize  - size to commit for the stack
    InitialTeb          - OUT 64-bit initial Teb values

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS Status;
    PCH Stack;
    SYSTEM_BASIC_INFORMATION SysInfo;
    BOOLEAN GuardPage;
    SIZE_T RegionSize;
    ULONG OldProtect;
#if defined(_IA64_)
    PCH Bstore;
    SIZE_T CommittedBstoreSize;
    SIZE_T MaximumBstoreSize;
    SIZE_T MstackPlusBstoreSize;
#endif

    Status = NtQuerySystemInformation( SystemBasicInformation,
                                       (PVOID)&SysInfo,
                                       sizeof( SysInfo ),
                                       NULL
                                     );
    if ( !NT_SUCCESS( Status ) ) {
        return( Status );
        }

    //
    // For WOW64, make sure the 64-bit stack is at least as big as
    // what is needed to run the wow64 code
    //
    if (MaximumStackSize < Wow64MaximumStackSize) {
        MaximumStackSize = Wow64MaximumStackSize;
    }

    if (CommittedStackSize < Wow64CommittedStackSize) {
        CommittedStackSize = Wow64CommittedStackSize;
    }

    if ( CommittedStackSize >= MaximumStackSize ) {
        MaximumStackSize = ROUND_UP(CommittedStackSize, (1024*1024));
        }


    CommittedStackSize = ROUND_UP( CommittedStackSize, SysInfo.PageSize );
    MaximumStackSize = ROUND_UP( MaximumStackSize,
                                 SysInfo.AllocationGranularity
                               );

    Stack = NULL,

#if defined(_IA64_)

    //
    // Piggyback the backing store with the memory stack
    //

    CommittedBstoreSize = CommittedStackSize;
    MaximumBstoreSize = MaximumStackSize;
    MstackPlusBstoreSize = MaximumBstoreSize + MaximumStackSize;

    Status = NtAllocateVirtualMemory( Process,
                                      (PVOID *)&Stack,
                                      0,
                                      &MstackPlusBstoreSize,
                                      MEM_RESERVE,
                                      PAGE_READWRITE
                                    );
#else

    Status = NtAllocateVirtualMemory( Process,
                                      (PVOID *)&Stack,
                                      0,
                                      &MaximumStackSize,
                                      MEM_RESERVE,
                                      PAGE_READWRITE
                                    );
#endif // defined(_IA64_)

    if ( !NT_SUCCESS( Status ) ) {
        LOGPRINT((ERRORLOG, "Wow64CreateStack64( %lx ) failed.  Stack Reservation Status == %X\n",
                  Process,
                  Status
                ));
        return( Status );
        }

#if defined(_IA64_)
    InitialTeb->OldInitialTeb.OldBStoreLimit = NULL;
#endif // defined(_IA64_)

    InitialTeb->OldInitialTeb.OldStackBase = NULL;
    InitialTeb->OldInitialTeb.OldStackLimit = NULL;
    InitialTeb->StackAllocationBase = Stack;
    InitialTeb->StackBase = Stack + MaximumStackSize;

    Stack += MaximumStackSize - CommittedStackSize;
    if (MaximumStackSize > CommittedStackSize) {
        Stack -= SysInfo.PageSize;
        CommittedStackSize += SysInfo.PageSize;
        GuardPage = TRUE;
        }
    else {
        GuardPage = FALSE;
        }
    Status = NtAllocateVirtualMemory( Process,
                                      (PVOID *)&Stack,
                                      0,
                                      &CommittedStackSize,
                                      MEM_COMMIT,
                                      PAGE_READWRITE
                                    );
    InitialTeb->StackLimit = Stack;

    if ( !NT_SUCCESS( Status ) ) {
        LOGPRINT((ERRORLOG, "Wow64CreateStack64( %lx ) failed.  Stack Commit Status == %X\n",
                  Process,
                  Status
                ));
        return( Status );
        }

    //
    // if we have space, create a guard page.
    //

    if (GuardPage) {
        RegionSize =  SysInfo.PageSize;
        Status = NtProtectVirtualMemory( Process,
                                         (PVOID *)&Stack,
                                         &RegionSize,
                                         PAGE_GUARD | PAGE_READWRITE,
                                         &OldProtect);


        if ( !NT_SUCCESS( Status ) ) {
            LOGPRINT(( ERRORLOG, "Wow64CreateStack( %lx ) failed.  Guard Page Creation Status == %X\n",
                      Process,
                      Status
                    ));
            return( Status );
            }
#if defined(_IA64_)
        InitialTeb->StackLimit = (PVOID)((PUCHAR)InitialTeb->StackLimit + RegionSize);
#else
        InitialTeb->StackLimit = (PVOID)((PUCHAR)InitialTeb->StackLimit - RegionSize);
#endif // defined(_IA64_)
        }

#if defined(_IA64_)

    //
    // Commit backing store pages and create guard pages if there is space
    //

    Bstore = InitialTeb->StackBase;
    if (MaximumBstoreSize > CommittedBstoreSize) {
        CommittedBstoreSize += SysInfo.PageSize;
        GuardPage = TRUE;
    } else {
        GuardPage = FALSE;
    }

    Status = NtAllocateVirtualMemory( Process,
                                      (PVOID *)&Bstore,
                                      0,
                                      &CommittedBstoreSize,
                                      MEM_COMMIT,
                                      PAGE_READWRITE
                                    );

    InitialTeb->BStoreLimit = Bstore + CommittedBstoreSize;

    if ( !NT_SUCCESS(Status) ) {
        LOGPRINT((ERRORLOG, "Wow64CreateStack64( %lx ) failed. Backing Store Commit Status == %X\n",
                 Process,
                 Status
                ));
        return (Status);
    }

    if (GuardPage) {
        Bstore = (PCH)InitialTeb->BStoreLimit - SysInfo.PageSize;
        RegionSize = SysInfo.PageSize;
        Status = NtProtectVirtualMemory(Process,
                                        (PVOID *)&Bstore,
                                        &RegionSize,
                                        PAGE_GUARD | PAGE_READWRITE,
                                        &OldProtect
                                       );
        if ( !NT_SUCCESS(Status) ) {
            LOGPRINT((ERRORLOG, "Wow64CreateStack64.  Backing Store Guard Page Creation Status == %X\n",
                     Process,
                     Status
                    ));
            return (Status);
        }
        InitialTeb->BStoreLimit = (PVOID)((PUCHAR)InitialTeb->BStoreLimit - RegionSize);
    }

#endif // defined(_IA64_)

    return( STATUS_SUCCESS );
}


NTSTATUS
Wow64FreeStack64(
    IN HANDLE Process,
    IN PINITIAL_TEB InitialTeb
    )
/*++

Routine Description:

    Free a 64-bit stack

Arguments:

    Process             - process to create the Teb in
    InitialTeb          - OUT 64-bit initial Teb values

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS Status;
    SIZE_T Zero;

    Zero = 0;
    Status = NtFreeVirtualMemory( Process,
                                  &InitialTeb->StackAllocationBase,
                                  &Zero,
                                  MEM_RELEASE
                                );
    if ( !NT_SUCCESS( Status ) ) {
        LOGPRINT((ERRORLOG, "Wow64FreeStack64( %lx ) failed: Stack DeCommit Status == %X\n", 
                  Process, Status));
        return( Status );
    }

    RtlZeroMemory( InitialTeb, sizeof( *InitialTeb ) );
    return( STATUS_SUCCESS );
}



NTSTATUS
ReadProcessParameters32(
    HANDLE ProcessHandle,
    ULONG ProcessParams32Address,
    struct NT32_RTL_USER_PROCESS_PARAMETERS **pProcessParameters32
    )
{
    NTSTATUS Status;
    ULONG Length;
    struct NT32_RTL_USER_PROCESS_PARAMETERS *ProcessParameters32;
    PVOID Base;

    // Get the length of the struct
    Status = Wow64pReadVirtualMemory (ProcessHandle,
                                      (PVOID)(ProcessParams32Address + sizeof(ULONG)),
                                      &Length,
                                      sizeof(Length),
                                      NULL);

    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    ProcessParameters32 = Wow64AllocateHeap(Length);
    if (!ProcessParameters32) {
        return STATUS_NO_MEMORY;
    }

    Base = (PVOID)ProcessParams32Address;
    Status = Wow64pReadVirtualMemory (ProcessHandle,
                                      Base,
                                      ProcessParameters32,
                                      Length,
                                      NULL);

    if (!NT_SUCCESS(Status)) {
        Wow64FreeHeap(ProcessParameters32);
        return Status;
    }

    *pProcessParameters32 = ProcessParameters32;
    return STATUS_SUCCESS;
}


NTSTATUS
ThunkProcessParameters32To64(
    IN HANDLE ProcessHandle,
    IN struct NT32_RTL_USER_PROCESS_PARAMETERS *ProcessParameters32
    )
/*++

Routine Description:

    Given a denormalized 32-bit PRTL_USER_PROCESS_PARAMETERS, allocate
    a 64-bit version and thunk the 32-bit values over.

Arguments:

    ProcessHandle       - IN target process handle
    ProcessParameters32 - IN 32-bit parameters

Return Value:

    NTSTATUS.

--*/
{
    PRTL_USER_PROCESS_PARAMETERS ProcessParameters;
    PRTL_USER_PROCESS_PARAMETERS ParametersInNewProcess=NULL;
    NTSTATUS Status;
    UNICODE_STRING ImagePathName;
    UNICODE_STRING DllPath;
    UNICODE_STRING CurrentDirectory;
    UNICODE_STRING CommandLine;
    UNICODE_STRING WindowTitle;
    UNICODE_STRING DesktopInfo;
    UNICODE_STRING ShellInfo;
    UNICODE_STRING RuntimeData;
    SIZE_T RegionSize;
    PROCESS_BASIC_INFORMATION pbi;
    PPEB pPeb64;

    //
    // The ProcessParameters struct is denormalized, so the
    // UNICODE_STRING Buffers are really just offsets in the
    // struct.  Normalize them to be pointers in our process.
    //

#define NormalizeString32(s, Base)              \
    if (s) {                                    \
        s = ((ULONG)(s) + PtrToUlong(Base));    \
    }

    NormalizeString32(ProcessParameters32->ImagePathName.Buffer,
                      ProcessParameters32);
    NormalizeString32(ProcessParameters32->DllPath.Buffer,
                      ProcessParameters32);
    NormalizeString32(ProcessParameters32->CommandLine.Buffer,
                      ProcessParameters32);
    NormalizeString32(ProcessParameters32->WindowTitle.Buffer,
                      ProcessParameters32);
    NormalizeString32(ProcessParameters32->DesktopInfo.Buffer,
                      ProcessParameters32);
    NormalizeString32(ProcessParameters32->ShellInfo.Buffer,
                      ProcessParameters32);
    NormalizeString32(ProcessParameters32->RuntimeData.Buffer,
                      ProcessParameters32);
    NormalizeString32(ProcessParameters32->CurrentDirectory.DosPath.Buffer,
                      ProcessParameters32);

    //
    // Thunk the bits and bobs back to 64-bit
    //
    Wow64ShallowThunkUnicodeString32TO64(&ImagePathName,
                                         &ProcessParameters32->ImagePathName);
    Wow64ShallowThunkUnicodeString32TO64(&DllPath,
                                         &ProcessParameters32->DllPath);
    Wow64ShallowThunkUnicodeString32TO64(&CommandLine,
                                         &ProcessParameters32->CommandLine);
    Wow64ShallowThunkUnicodeString32TO64(&WindowTitle,
                                         &ProcessParameters32->WindowTitle);
    Wow64ShallowThunkUnicodeString32TO64(&DesktopInfo,
                                         &ProcessParameters32->DesktopInfo);
    Wow64ShallowThunkUnicodeString32TO64(&ShellInfo,
                                         &ProcessParameters32->ShellInfo);
    Wow64ShallowThunkUnicodeString32TO64(&CurrentDirectory,
                                         &ProcessParameters32->CurrentDirectory.DosPath);

    if (ProcessParameters32->RuntimeData.Length &&
        ProcessParameters32->RuntimeData.Buffer) {
        //
        // See wow64\init.c's Wow64pThunkProcessParameters for details...
        //
        int cfi_len = *(UNALIGNED int *)ProcessParameters32->RuntimeData.Buffer;
        char *posfile32 = (char *)((UINT_PTR)ProcessParameters32->RuntimeData.Buffer+sizeof(int));
        UINT UNALIGNED *posfhnd32 = (UINT UNALIGNED *)(posfile32 + cfi_len);
        char *posfile64;
        UINT_PTR UNALIGNED *posfhnd64;
        int i;

        RuntimeData.Length = ProcessParameters32->RuntimeData.Length + sizeof(ULONG)*cfi_len;
        RuntimeData.MaximumLength = RuntimeData.Length;
        RuntimeData.Buffer = (LPWSTR)_alloca(RuntimeData.Length);

        posfile64 = (char *)( (ULONG_PTR)RuntimeData.Buffer + sizeof(int));
        posfhnd64 = (UINT_PTR UNALIGNED *)(posfile64 + cfi_len);

        *(int *)RuntimeData.Buffer = cfi_len;
        for (i=0; i<cfi_len; ++i) {
            // Use LongToPtr in order to sign-extend INVALID_FILE_HANDLE if
            // needed, from 32-bit to 64.
            *posfile64 = *posfile32;
            *posfhnd64 = (UINT_PTR)LongToPtr(*posfhnd32);
            posfile32++;
            posfile64++;
            posfhnd32++;
            posfhnd64++;
        }

        // Any bytes past the end of 4+(cfi_len*(sizeof(UINT_PTR)+sizeof(UINT))
        // must be copied verbatim.  They are probably from a non-MS C runtime.
        memcpy(posfhnd64, posfhnd32, (ProcessParameters32->RuntimeData.Length - ((ULONG_PTR)posfhnd32 - (ULONG_PTR)ProcessParameters32->RuntimeData.Buffer)));

    } else {
        RuntimeData.Length = RuntimeData.MaximumLength = 0;
        RuntimeData.Buffer = NULL;
    }

    //
    // Create a new 64-bit process parameters in denormalized form
    //
    Status = RtlCreateProcessParameters(&ProcessParameters,
                                        &ImagePathName,
                                        &DllPath,
                                        &CurrentDirectory,
                                        &CommandLine,
                                        NULL,   // no environment yet
                                        &WindowTitle,
                                        &DesktopInfo,
                                        &ShellInfo,
                                        &RuntimeData);
    if (!NT_SUCCESS(Status)) {
        return Status;
    }

    //
    // Thunk the rest of the fields.
    //

    ProcessParameters->DebugFlags =
        ProcessParameters32->DebugFlags;
    ProcessParameters->ConsoleHandle =
        (HANDLE)ProcessParameters32->ConsoleHandle;
    ProcessParameters->ConsoleFlags =
        ProcessParameters32->ConsoleFlags;
    ProcessParameters->StandardInput =
        (HANDLE)ProcessParameters32->StandardInput;
    ProcessParameters->StandardOutput =
        (HANDLE)ProcessParameters32->StandardOutput;
    ProcessParameters->StandardError =
        (HANDLE)ProcessParameters32->StandardError;
    ProcessParameters->Environment =
        (PVOID)ProcessParameters32->Environment;
    ProcessParameters->StartingX =
        ProcessParameters32->StartingX;
    ProcessParameters->StartingY =
        ProcessParameters32->StartingY;
    ProcessParameters->CountX =
        ProcessParameters32->CountX;
    ProcessParameters->CountY =
        ProcessParameters32->CountY;
    ProcessParameters->CountCharsX =
        ProcessParameters32->CountCharsX;
    ProcessParameters->CountCharsY =
        ProcessParameters32->CountCharsY;
    ProcessParameters->FillAttribute =
        ProcessParameters32->FillAttribute;
    ProcessParameters->WindowFlags =
        ProcessParameters32->WindowFlags;
    ProcessParameters->ShowWindowFlags =
        ProcessParameters32->ShowWindowFlags;

    //
    // Propagate the flags. We need to OR in the extra bits.
    //

    ProcessParameters->Flags |= ProcessParameters32->Flags;

    //
    // RtlCreateProcessParameters fills this in, but not correctly
    // if the process is being created without bInheritHandles.
    // Clean up now by grabbing the 32-bit directory handle.
    //
    ProcessParameters->CurrentDirectory.Handle =
        (HANDLE)ProcessParameters32->CurrentDirectory.Handle;

    //
    // Allocate space in the new process and copy the params in
    //
    RegionSize = ProcessParameters->Length;
    Status = NtAllocateVirtualMemory(ProcessHandle,
                                     &ParametersInNewProcess,
                                     0,
                                     &RegionSize,
                                     MEM_COMMIT,
                                     PAGE_READWRITE
                                    );
    if (!NT_SUCCESS(Status)) {
        goto DoFail;
    }
    ProcessParameters->MaximumLength = (ULONG)RegionSize;

    Status = Wow64pWriteVirtualMemory (ProcessHandle,
                                       ParametersInNewProcess,
                                       ProcessParameters,
                                       ProcessParameters->Length,
                                       NULL
                                       );
    if (!NT_SUCCESS(Status)) {
        goto DoFail;
    }

    //
    // Update the peb64->processParameters
    //
    Status = NtQueryInformationProcess(ProcessHandle,
                                       ProcessBasicInformation,
                                       &pbi,
                                       sizeof(pbi),
                                       NULL);
    if (!NT_SUCCESS(Status)) {
        goto DoFail;
    }

    pPeb64 = (PPEB)pbi.PebBaseAddress;
    Status = Wow64pWriteVirtualMemory (ProcessHandle,
                                       &pPeb64->ProcessParameters,
                                       &ParametersInNewProcess,
                                       sizeof(ParametersInNewProcess),
                                       NULL
                                       );
    if (!NT_SUCCESS(Status)) {
        goto DoFail;
    }

DoFail:
    //
    // On error, there's no need to free the processparameters from the
    // target process.  The 32-bit code which calls this via
    // NtCreateThread() will terminate the process for us.
    //
    RtlDestroyProcessParameters(ProcessParameters);
    return Status;
}


WOW64DLLAPI
NTSTATUS
Wow64NtCreateThread(
   OUT PHANDLE ThreadHandle, 
   IN ACCESS_MASK DesiredAccess,
   IN POBJECT_ATTRIBUTES ObjectAttributes OPTIONAL,
   IN HANDLE ProcessHandle,
   OUT PCLIENT_ID ClientId,
   IN PCONTEXT ThreadContext,   // this is really a PCONTEXT32
   IN PINITIAL_TEB InitialTeb,
   IN BOOLEAN CreateSuspended
   )
/*++

Routine Description:

    Create a 32-bit thread.  The 32-bit caller has already created
    the 32-bit stack, so this function needs to create a 64-bit stack
    and the 64-bit context required for starting up a thread.

Arguments:

    << same as NtCreateThread >>

Return Value:

    NTSTATUS.

--*/
{

    NTSTATUS Status;
    INITIAL_TEB InitialTeb64;
    BOOLEAN StackCreated = FALSE;
    BOOLEAN ThreadCreated = FALSE;
    PCONTEXT32 pContext32 = (PCONTEXT32)ThreadContext;
    CONTEXT Context64;
    ULONG_PTR Wow64Info;
    struct NT32_RTL_USER_PROCESS_PARAMETERS *ProcessParameters32 = NULL;
    PEB32 Peb32;
    PVOID Base;
    CHILD_PROCESS_INFO ChildInfo;
    PVOID Ldr;

    if (NULL == ThreadHandle || NULL == InitialTeb ||
        NULL == ThreadContext) {
        return STATUS_INVALID_PARAMETER;
    }

    Status = NtQueryInformationProcess(ProcessHandle,
                                       ProcessWow64Information,
                                       &Wow64Info,
                                       sizeof(Wow64Info),
                                       NULL
                                      );
    if (!NT_SUCCESS(Status)) {
        return Status;
    }
    if (Wow64Info) {
        //
        // Process is 32-bit.
        //
        ChildInfo.pPeb32 = (PPEB32)Wow64Info;

    } else {
        // process is 64-bit.  
        PROCESS_BASIC_INFORMATION pbi;

        // get the process basic information on the process
        Status = NtQueryInformationProcess(
           ProcessHandle,
           ProcessBasicInformation,
           &pbi,
           sizeof(pbi),
           NULL);

        if (!NT_SUCCESS(Status)) 
        {
           return STATUS_ACCESS_DENIED;
        }
         
        // read the child info struct, it contains a pointer to the PEB32
        Status = NtReadVirtualMemory(ProcessHandle,
                                     ((BYTE*)pbi.PebBaseAddress) + PAGE_SIZE - sizeof(ChildInfo),
                                     &ChildInfo,
                                     sizeof(ChildInfo),
                                     NULL);

        if (!NT_SUCCESS(Status)) {
            return Status;
        }
        
        if ((ChildInfo.Signature != CHILD_PROCESS_SIGNATURE) ||
            (ChildInfo.TailSignature != CHILD_PROCESS_SIGNATURE)) {
            return STATUS_ACCESS_DENIED;
        }
    }

    //
    // Read the PEB32 from the process
    //

    Status = Wow64pReadVirtualMemory (ProcessHandle,
                                      ChildInfo.pPeb32,
                                      &Peb32,
                                      sizeof(PEB32),
                                      NULL);
    
    if (!NT_SUCCESS(Status)) {
        return Status;
    }


    if (!Wow64Info) {
        //
        // The target process is 64-bit but was created by a 32-bit app
        //
        SIZE_T RegionSize;

        //
        // Read in the 32-bit ProcessParameters then free them
        //
        if (Peb32.ProcessParameters) {
            Status = ReadProcessParameters32(ProcessHandle,
                                             Peb32.ProcessParameters,
                                             &ProcessParameters32);
            if (!NT_SUCCESS(Status)) {
                goto DoFail;
            }

            RegionSize = 0;
            Base = (PVOID)Peb32.ProcessParameters;
            Status = NtFreeVirtualMemory(ProcessHandle,
                                         &Base,
                                         &RegionSize,
                                         MEM_RELEASE
                                        );
            WOWASSERT(NT_SUCCESS(Status));
        }

        //
        // Create a 64-bit stack with the size info from the image section
        //
        Status = Wow64CreateStack64(ProcessHandle,
                                    ChildInfo.ImageInformation.MaximumStackSize,
                                    ChildInfo.ImageInformation.CommittedStackSize,
                                    &InitialTeb64
                                   );
        if (!NT_SUCCESS(Status)) {
            goto DoFail;
        }
        StackCreated = TRUE;


        SetProcessStartupContext64(&Context64,
                                   ProcessHandle,
                                   pContext32, 
                                   (ULONGLONG)InitialTeb64.StackBase, 
                                   (ULONGLONG)ChildInfo.ImageInformation.TransferAddress);

        //
        // Thunk the processparameters up to 64-bit
        //
        if (ProcessParameters32) {
            Status = ThunkProcessParameters32To64(ProcessHandle,
                                                  ProcessParameters32);
            if (!NT_SUCCESS(Status)) {
                goto DoFail;
            }
        }

        Status = NtCreateThread(ThreadHandle,
                                DesiredAccess,
                                ObjectAttributes,
                                ProcessHandle,
                                ClientId,
                                &Context64,
                                &InitialTeb64,
                                CreateSuspended
                               );
        if (!NT_SUCCESS(Status)) {
            goto DoFail;
        }

        return STATUS_SUCCESS;
    } else {
        //
        // The target process is 32-bit.  Create a 64-bit stack for
        // wow64 to use.  The reserve/commit sizes come from globals
        // in wow64 instead of the image because we won't want to inherit
        // some tiny values from a highly-tuned app.
        //
        Status = Wow64CreateStack64(ProcessHandle,
                                    Wow64MaximumStackSize,
                                    Wow64CommittedStackSize,
                                    &InitialTeb64
                                   );

        if(!NT_SUCCESS(Status)) {
            LOGPRINT((ERRORLOG, "Wow64NtCreateThread: Couldn't create 64bit stack, Status %x\n", Status));
            return Status;
        }
        StackCreated = TRUE;

        if (Peb32.ProcessParameters) {
            PROCESS_BASIC_INFORMATION pbi;
            PPEB pPeb64;
            ULONG_PTR ParametersInNewProcess;

            //
            // If the process has no 64-bit parameters, then this is
            // the first 32-bit thread in a 64-bit process and needs
            // the parameters thunked up to 64-bit.
            //
            Status = NtQueryInformationProcess(ProcessHandle,
                                               ProcessBasicInformation,
                                               &pbi,
                                               sizeof(pbi),
                                               NULL);
            if (!NT_SUCCESS(Status)) {
               goto DoFail;
            }

            pPeb64 = (PPEB)pbi.PebBaseAddress;
            Status = Wow64pReadVirtualMemory (ProcessHandle,
                                              &pPeb64->ProcessParameters,
                                              &ParametersInNewProcess,
                                              sizeof(ParametersInNewProcess),
                                              NULL
                                              );
            if (!NT_SUCCESS(Status)) {
                goto DoFail;
            }

            if (!ParametersInNewProcess) {
                Status = ReadProcessParameters32(ProcessHandle,
                                                 Peb32.ProcessParameters,
                                                 &ProcessParameters32);
                if (!NT_SUCCESS(Status)) {
                    goto DoFail;
                }

                Status = ThunkProcessParameters32To64(ProcessHandle,
                                                  ProcessParameters32);
                if (!NT_SUCCESS(Status)) {
                    goto DoFail;
                }
            }
        }

        ThunkContext32TO64(pContext32,
                           &Context64,
                           (ULONGLONG)InitialTeb64.StackBase);

        //
        // Let MM grab the 32-bit InitialTeb as well
        //

        Wow64TlsSetValue (WOW64_TLS_INITIAL_TEB32, InitialTeb);

        Status = NtCreateThread(ThreadHandle,
                                DesiredAccess,
                                ObjectAttributes,
                                ProcessHandle,
                                ClientId,
                                &Context64,
                                &InitialTeb64,
                                TRUE
                               );
  
        Wow64TlsSetValue (WOW64_TLS_INITIAL_TEB32, NULL);

        if (NT_SUCCESS(Status)) {
   
            ThreadCreated = TRUE;

            if (!CreateSuspended) {
                Status = NtResumeThread(*ThreadHandle,
                                        NULL
                                       );

                if (!NT_SUCCESS(Status)) {
                    goto DoFail;
                }
            }
            
            return STATUS_SUCCESS;
        }
    }

DoFail:
    if (StackCreated) {
           Wow64FreeStack64(ProcessHandle,
                            &InitialTeb64
                            );
    }

    if (ThreadCreated) {
        NtTerminateThread(*ThreadHandle, 0);
    }

    if (ProcessParameters32) {
        Wow64FreeHeap(ProcessParameters32);
    }

    return Status;
}


NTSTATUS
WOW64DLLAPI
Wow64NtTerminateThread(
    HANDLE ThreadHandle,
    NTSTATUS ExitStatus
    )
/*++

Routine Description:

    Teminate a thread. If we were called from Kernel32!ExitThread
    then the 32-bit stack should already be gone. In this case we'll
    free the 64-bit stack as well.

Arguments:

    same as NtTerminateThread

--*/
{
    PTEB32 Teb32;
    SIZE_T Zero;
    PVOID StackBase;

    //
    // Check if we need to free the 32-bit stack
    //
    if (ThreadHandle == NULL) {
        
        CpuThreadTerm();

        Teb32 = NtCurrentTeb32();
        if (Teb32->FreeStackOnTermination) {
            
            Zero = 0;
            StackBase = UlongToPtr (Teb32->DeallocationStack);
            NtFreeVirtualMemory(NtCurrentProcess(),
                                &StackBase,
                                &Zero,
                                MEM_RELEASE);

            NtCurrentTeb()->FreeStackOnTermination = Teb32->FreeStackOnTermination;
        }
    }

    return NtTerminateThread (ThreadHandle, ExitStatus);
}

NTSTATUS
WOW64DLLAPI
Wow64QueryBasicInformationThread(
    IN HANDLE Thread,
    OUT PTHREAD_BASIC_INFORMATION ThreadInfo
    )
/*++

Routine Description:

    whNtQueryInformationFromThread calls this for ThreadBasicInformation.
    The TEB pointer in the basic information needs to be the TEB32 pointer.

Arguments:

    Thread      - thread to query
    ThreadInfo  - OUT pointer to 64-bit THREAD_BASIC_INFORMATION struct

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS Status, QIStatus; 
    HANDLE Process;
    PTEB32 Teb32;
    OBJECT_ATTRIBUTES ObjectAttributes;
    BOOLEAN GotProcessHandle = FALSE;
    PVOID Wow64Info;

    QIStatus = NtQueryInformationThread(Thread,
                                        ThreadBasicInformation,
                                        (PVOID)ThreadInfo,
                                        sizeof(THREAD_BASIC_INFORMATION),
                                        NULL
                                        );

    if (!NT_SUCCESS(QIStatus)) {
       return QIStatus;
    }

    //Thunk the 64bit AffinityMask to the 32bit AffinityMask
    ThreadInfo->AffinityMask = Wow64ThunkAffinityMask64TO32(ThreadInfo->AffinityMask);

    //
    // if the thread is executing inside this process, then let's read the TEB right away
    //
    if ((ThreadInfo->ClientId.UniqueProcess == NtCurrentTeb()->ClientId.UniqueProcess) && 
        (ThreadInfo->TebBaseAddress != NULL)) {

        ThreadInfo->TebBaseAddress = (PTEB) WOW64_GET_TEB32_SAFE (ThreadInfo->TebBaseAddress);

        goto exit;
    }

    // At this point, the TebAddress is for the 64bit TEB.   We need to get the 
    // address of the 32bit TEB.  If this is not a 32bit process, or some other error
    // occures, return a bogus value for the TEB and let the app fail on the 
    // ReadVirtualMemory call.   Do not fail the api after this point.     
   
    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0,
                               NULL,
                               NULL
                               );

    Status = NtOpenProcess(&Process,
                           PROCESS_VM_READ | PROCESS_QUERY_INFORMATION,
                           &ObjectAttributes, //ObjectAttributes
                           &(ThreadInfo->ClientId)
                           );
 
    if (!NT_SUCCESS(Status)) {
        LOGPRINT((TRACELOG, "Wow64QueryInformationThread: NtOpenProcess failed, status %x\n",Status));
        ThreadInfo->TebBaseAddress = NULL;
        goto exit;
    }
  
    GotProcessHandle = TRUE; //Process handle is valid
    
    // Check if this is a 32bit process.

    Status = NtQueryInformationProcess(Process,
                                       ProcessWow64Information,
                                       &Wow64Info,
                                       sizeof(Wow64Info),
                                       NULL);
   
    if (!NT_SUCCESS(Status)) {
        LOGPRINT((TRACELOG, "Wow64QueryInformationThread: NtQueryProcessInformation failed, status %x\n",Status));
        ThreadInfo->TebBaseAddress = NULL;
        goto exit;
    }
    
    if (!Wow64Info) {
        LOGPRINT((TRACELOG, "Wow64QueryInformationThread: The queryied thread is not in a process marked 32bit, returning bogus TEB\n"));
        ThreadInfo->TebBaseAddress = NULL;
        goto exit;        
    }
    
    Status = NtReadVirtualMemory(Process,
                                 WOW64_TEB32_POINTER_ADDRESS(ThreadInfo->TebBaseAddress),
                                 &Teb32,
                                 sizeof(PTEB32),
                                 NULL
                                 );

     if (!NT_SUCCESS(Status)) {
        LOGPRINT((TRACELOG, "Wow64QueryInformationThread: NtReadVirtualMemory failed, status %x\n",Status));
        ThreadInfo->TebBaseAddress = NULL;
        goto exit;
     }
  
     // If the TEB32 hasn't been created yet, the TEB32 address will be a bogus value such
     // as NULL or -1.
     LOGPRINT((TRACELOG, "Wow64QueryInformationThread: TEB32 address %X\n", PtrToUlong(Teb32)));
     ThreadInfo->TebBaseAddress = (PTEB)Teb32;
     
exit:
    if (GotProcessHandle) {
        Status = NtClose(Process);
        WOWASSERT(NT_SUCCESS(Status));
    }

    return QIStatus;

}


NTSTATUS
Wow64pOpenThreadProcess(
    IN HANDLE ThreadHandle,
    IN ULONG DesiredAccess,
    OUT PTEB *Teb OPTIONAL,
    OUT PCLIENT_ID ClientId OPTIONAL,
    OUT PHANDLE ProcessHandle)
/*++

Routine Description:

    Opens the process handle, with the specified attributes, of the specified 
    target thread.

Arguments:

    ThreadHandle   - Handle of target thread
    DesiredAccess  - Supplies the desired types of access for the process to open
    Teb            - Optional pointer to receive the adress of the target thread's TEB
    ClientId       - Pointer to receive the clietn id structure of the target thread
    ProcessHandle  - Pointer to receive process handle 

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    OBJECT_ATTRIBUTES ObjectAttributes;
    THREAD_BASIC_INFORMATION ThreadInformation;

    NtStatus = NtQueryInformationThread(ThreadHandle,
                                        ThreadBasicInformation,
                                        &ThreadInformation,
                                        sizeof( ThreadInformation ),
                                        NULL);

    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "Wow64pOpenThreadProcess : failed to query threadinfo %lx-%lx\n",
                  ThreadHandle, NtStatus));
        return NtStatus;
    }

    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0,
                               NULL,
                               NULL);

    NtStatus = NtOpenProcess(ProcessHandle,
                             DesiredAccess,
                             &ObjectAttributes,
                             &ThreadInformation.ClientId);

    if (NT_SUCCESS(NtStatus))
    {
        if (ARGUMENT_PRESENT(ClientId))
        {
            *ClientId = ThreadInformation.ClientId;
        }

        if (ARGUMENT_PRESENT(Teb))
        {
            *Teb = ThreadInformation.TebBaseAddress;
        }
    }
    else
    {
        LOGPRINT((ERRORLOG, "Wow64pOpenThreadProcess : failed to open thread (%lx) process -%lx\n",
                  ThreadHandle, NtStatus));

    }

    return NtStatus;
}


NTSTATUS
Wow64pSuspendThread(
    IN HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount OPTIONAL,
    OUT BOOLEAN *ReleaseSuspendMutant)
/*++

Routine Description:

    Suspend the target 32-bit thread, and optionally returns 
    the previous suspend count.

Arguments:

    ThreadHandle           - Handle of target thread to suspend
    PreviousSuspendCount   - Optional pointer to a value that, if specified, received 
                             the previous suspend count.
    ReleaseSuspendMutant   - Out value to indicate whether the release suspend mutant has
                             already been called.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN CurrentThread;
    PPEB32 Peb32;
    PTEB Teb;
    HANDLE ProcessHandle;
    CLIENT_ID ThreadClientId;
    ULONG LocalSuspendCount;

    
    *ReleaseSuspendMutant = TRUE;
    if (ThreadHandle == NtCurrentThread())
    {
        *ReleaseSuspendMutant = FALSE;
        NtReleaseMutant(SuspendThreadMutant, NULL);
        return NtSuspendThread(ThreadHandle, PreviousSuspendCount);
    }

    NtStatus = Wow64pOpenThreadProcess(ThreadHandle,
                                       (PROCESS_VM_OPERATION | 
                                        PROCESS_VM_READ | 
                                        PROCESS_VM_WRITE | 
                                        PROCESS_QUERY_INFORMATION |
                                        PROCESS_DUP_HANDLE),
                                       &Teb,
                                       &ThreadClientId,
                                       &ProcessHandle);

    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    NtStatus = NtQueryInformationProcess(ProcessHandle,
                                         ProcessWow64Information,
                                         &Peb32,
                                         sizeof(Peb32),
                                         NULL);
    if (NT_SUCCESS(NtStatus))
    {
        if (Peb32)
        {
            CurrentThread = (ThreadClientId.UniqueThread == 
                             NtCurrentTeb()->ClientId.UniqueThread);

            if (!ARGUMENT_PRESENT(PreviousSuspendCount))
            {
                PreviousSuspendCount = &LocalSuspendCount;
            }
            else
            {
                try
                {
                    *PreviousSuspendCount = *PreviousSuspendCount;
                }
                except(EXCEPTION_EXECUTE_HANDLER)
                {
                    PreviousSuspendCount = &LocalSuspendCount;
                }
            }

            if (CurrentThread)
            {
                *ReleaseSuspendMutant = FALSE;
                NtReleaseMutant(SuspendThreadMutant, NULL);
            }

            NtStatus = NtSuspendThread(ThreadHandle,
                                       PreviousSuspendCount);

            if (NT_SUCCESS(NtStatus))
            {
                if ((CurrentThread == FALSE) &&
                    (*PreviousSuspendCount == 0))
                {
                    NtStatus = CpuSuspendThread(ThreadHandle,
                                                ProcessHandle,
                                                Teb,
                                                PreviousSuspendCount);
                    if (!NT_SUCCESS(NtStatus))
                    {
                        LOGPRINT((ERRORLOG, "Wow64SuspendThread : CPU couldn't suspend thread (%lx) -%lx\n",
                                  ThreadHandle, NtStatus));

                        NtResumeThread(ThreadHandle, NULL);
                    }
                }
            }
        }
        else
        {
            NtStatus = STATUS_UNSUCCESSFUL;
        }
    }
    else
    {
        LOGPRINT((ERRORLOG, "Wow64SuspendThread : failed to query processinfo %lx-%lx\n",
                  ProcessHandle, NtStatus));
    }

    NtClose(ProcessHandle);

    return NtStatus;
}


NTSTATUS
Wow64SuspendThread(
    IN HANDLE ThreadHandle,
    OUT PULONG PreviousSuspendCount OPTIONAL
    )
/*++

Routine Description:

    Suspend the target 32-bit thread, and optionally returns 
    the previous suspend count. This routine is access-serialized through
    the SuspendThreadMutant.

Arguments:

    ThreadHandle           - Handle of target thread to suspend
    PreviousSuspendCount   - Optional pointer to a value that, if specified, received 
                             the previous suspend count.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus;
    BOOLEAN ReleaseSuspendMutant;

    NtStatus = NtWaitForSingleObject(SuspendThreadMutant,
                                     FALSE,
                                     NULL);

    if (NT_SUCCESS(NtStatus))
    {
        NtStatus = Wow64pSuspendThread(ThreadHandle,
                                       PreviousSuspendCount,
                                       &ReleaseSuspendMutant);

        if (ReleaseSuspendMutant)
        {
            NtReleaseMutant(SuspendThreadMutant, NULL);
        }
    }

    return NtStatus;
}


NTSTATUS
Wow64pContextThreadInformation(
     IN HANDLE ThreadHandle, 
     IN OUT PCONTEXT ThreadContext, // really a PCONTEXT32
     IN BOOLEAN SetContextThread
     )
/*++

Routine Description:

    Get/Set the 32-bit thread context.

Arguments:

    ThreadHandle     - thread to query
    ThreadContext    - OUT ptr to 32-bit context
    SetContextThread - TRUE if to set the thread context, otherwise FALSE.

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    BOOLEAN CurrentThread;
    PPEB32 Peb32;
    PTEB Teb;
    CLIENT_ID ThreadClientId;
    HANDLE ProcessHandle;
    ULONG PreviousSuspendCount;


    if (NtCurrentThread() == ThreadHandle)
    {
        if (SetContextThread)
        {
            return CpuSetContext(ThreadHandle,
                                 NtCurrentProcess(),
                                 NtCurrentTeb(),
                                 (PCONTEXT32)ThreadContext);
        }
        else
        {
            return CpuGetContext(ThreadHandle,
                                 NtCurrentProcess(),
                                 NtCurrentTeb(),
                                 (PCONTEXT32)ThreadContext);
        }
    }

    NtStatus = Wow64pOpenThreadProcess(ThreadHandle,
                                       (PROCESS_VM_OPERATION | 
                                        PROCESS_VM_READ | 
                                        PROCESS_VM_WRITE | 
                                        PROCESS_QUERY_INFORMATION |
                                        PROCESS_DUP_HANDLE),
                                       &Teb,
                                       &ThreadClientId,
                                       &ProcessHandle);

    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    NtStatus = NtQueryInformationProcess(ProcessHandle,
                                         ProcessWow64Information,
                                         &Peb32,
                                         sizeof(Peb32),
                                         NULL);
    if (NT_SUCCESS(NtStatus))
    {
        if (Peb32)
        {
            CurrentThread = (ThreadClientId.UniqueThread == 
                             NtCurrentTeb()->ClientId.UniqueThread);

            if (CurrentThread)
            {
                ThreadHandle = NtCurrentThread();
            }

            if (NT_SUCCESS(NtStatus))
            {
                if (SetContextThread)
                {
                    if (CurrentThread)
                    {
                        LOGPRINT((ERRORLOG, "Thread %lx is trying to change context of itself\n",
                                  ThreadHandle));
                    }
                    else
                    {
                        NtStatus = CpuSetContext(ThreadHandle,
                                                 ProcessHandle,
                                                 Teb,
                                                 (PCONTEXT32)ThreadContext);
                    }
                }
                else
                {
                    NtStatus = CpuGetContext(ThreadHandle,
                                             ProcessHandle,
                                             Teb,
                                             (PCONTEXT32)ThreadContext);

                    //
                    // VC6 debuggers calls GetContext at startup before the 32-bit context had
                    // been built. It doesn't check the return value.
                    //
                    if (!NT_SUCCESS(NtStatus)) 
                    {
                        //
                        // Probably just creating 32-bit thread, so "fake" the 
                        // context segment selectors specifically for Visual Studio 6
                        //

                        PCONTEXT32 FakeContext = (PCONTEXT32)ThreadContext;

#if defined(_IA64_)
                        FakeContext->SegGs = KGDT_R3_DATA|RPL_MASK;
                        FakeContext->SegEs = KGDT_R3_DATA|RPL_MASK;
                        FakeContext->SegDs = KGDT_R3_DATA|RPL_MASK;
                        FakeContext->SegSs = KGDT_R3_DATA|RPL_MASK;
                        FakeContext->SegFs = KGDT_R3_TEB|RPL_MASK;
                        FakeContext->SegCs = KGDT_R3_CODE|RPL_MASK;
#elif defined(_AMD64_)
                        FakeContext->SegGs = KGDT64_R3_DATA|RPL_MASK;
                        FakeContext->SegEs = KGDT64_R3_DATA|RPL_MASK;
                        FakeContext->SegDs = KGDT64_R3_DATA|RPL_MASK;
                        FakeContext->SegSs = KGDT64_R3_DATA|RPL_MASK;
                        FakeContext->SegFs = KGDT64_R3_CMTEB|RPL_MASK;
                        FakeContext->SegCs = KGDT64_R3_CMCODE|RPL_MASK;
#else
#error "No Target Architecture"
#endif
                    }
                }
            }
        }
        else
        {
            NtStatus = STATUS_NOT_IMPLEMENTED;
            
            LOGPRINT((TRACELOG, "Wow64pContextThreadInformation : Calling %wsContextThread on a 64-bit Thread from a 32-bit context failed -%lx\n",
                      (SetContextThread) ? L"NtSet" : L"NtGet", NtStatus));
        }
    }
    else
    {
        LOGPRINT((ERRORLOG, "Wow64pContextThreadInformation : failed to query processinfo %lx-%lx\n",
                  ProcessHandle, NtStatus));
    }

    NtClose(ProcessHandle);

    return STATUS_SUCCESS; 
}


NTSTATUS
Wow64GetContextThread(
     IN HANDLE ThreadHandle, 
     IN OUT PCONTEXT ThreadContext // really a PCONTEXT32
     )
/*++

Routine Description:

    Get the 32-bit thread context.

Arguments:

    ThreadHandle    - thread to query
    ThreadContext   - OUT ptr to 32-bit context

Return Value:

    NTSTATUS.

--*/
{
    return Wow64pContextThreadInformation(ThreadHandle,
                                          ThreadContext,
                                          FALSE);
}


NTSTATUS
Wow64SetContextThread(
     IN HANDLE ThreadHandle,
     IN PCONTEXT ThreadContext  // really a PCONTEXT32
     )
/*++

Routine Description:

    Set the 32-bit thread context.

Arguments:

    ThreadHandle    - thread to query
    ThreadContext   - OUT ptr to 32-bit context

Return Value:

    NTSTATUS.

--*/
{
    return Wow64pContextThreadInformation(ThreadHandle,
                                          ThreadContext,
                                          TRUE);
}



NTSTATUS 
Wow64pCreateSecurityDescriptor(
    OUT PSECURITY_DESCRIPTOR *ObjectSD,
    OUT PSID *WorldSidToFree,
    IN ACCESS_MASK AccessMask)
/*++

Routine Description:

    Creates a security descriptor representing EVERYONE to append for a kernel object.

Arguments:

    SecurityDescriptor      - Buffer to receive security descriptor information
    WorldSidToFree          - Address of World SID to free after the kernel object is initialized
    SecurityDescriptorLengh - Security descriptor buffer length
    AccessMask              - Access-allowed rights for the security descriptor

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus;
    PACL AclBuffer;
    ULONG SidLength;
    ULONG SecurityDescriptorLength;
    PSID WorldSid = NULL;
    PSECURITY_DESCRIPTOR SecurityDescriptor = NULL;
    SID_IDENTIFIER_AUTHORITY SidAuth = SECURITY_WORLD_SID_AUTHORITY;

    
    //
    //  Create the World (everyone) SID
    //
    SidLength = RtlLengthRequiredSid(1);

    WorldSid = Wow64AllocateHeap(SidLength);

    if (WorldSid == NULL)
    {
        LOGPRINT((ERRORLOG, "Wow64pCreateSecurityDescriptor - Could NOT Allocate SID Buffer.\n"));
        NtStatus = STATUS_NO_MEMORY;
        goto cleanup;
    }
    
    RtlZeroMemory(WorldSid, SidLength);
    RtlInitializeSid(WorldSid, &SidAuth, 1);

    *(RtlSubAuthoritySid(WorldSid, 0)) = SECURITY_WORLD_RID;
    

    SecurityDescriptorLength = SECURITY_DESCRIPTOR_MIN_LENGTH +
                               (ULONG)sizeof(ACL) +
                               (ULONG)sizeof(ACCESS_ALLOWED_ACE) +
                               RtlLengthSid( WorldSid );

    SecurityDescriptor = Wow64AllocateHeap(SecurityDescriptorLength);

    if (SecurityDescriptor == NULL)
    {
      NtStatus = STATUS_NO_MEMORY;
      goto cleanup;
    }

    //
    //  Initialize Security Descriptor
    //
    NtStatus = RtlCreateSecurityDescriptor(SecurityDescriptor,
                                           SECURITY_DESCRIPTOR_REVISION);
    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "Wow64pCreateSecurityDescriptor - Failed to create security desc - %lx\n",
                  NtStatus));
        goto cleanup;
    }

    //
    //  Initialize ACL
    //
    AclBuffer = (PACL)((PBYTE)SecurityDescriptor + SECURITY_DESCRIPTOR_MIN_LENGTH);
    NtStatus = RtlCreateAcl(AclBuffer,
                            (SecurityDescriptorLength - SECURITY_DESCRIPTOR_MIN_LENGTH),
                            ACL_REVISION2);
    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "Wow64pCreateSecurityDescriptor - Failed to create security desc ACL - %lx\n",
                  NtStatus));
        goto cleanup;
    }

    //
    //  Add an ACE to the ACL that allows World AccessMask to the
    //  object
    //
    NtStatus = RtlAddAccessAllowedAce(AclBuffer,
                                      ACL_REVISION2,
                                      AccessMask,
                                      WorldSid);
    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "Wow64pCreateSecurityDescriptor - Failed to add access-allowed ACE  - %lx\n",
                  NtStatus));
        goto cleanup;
    }

    //
    //  Assign the DACL to the security descriptor
    //
    NtStatus = RtlSetDaclSecurityDescriptor((PSECURITY_DESCRIPTOR)SecurityDescriptor,
                                            TRUE,
                                            AclBuffer,
                                            FALSE );
    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "Wow64pCreateSecurityDescriptor- Could NOT Set DACL Security Descriptor - %lx.\n",
                 NtStatus));
        goto cleanup;
    }

cleanup:
    if (NT_SUCCESS(NtStatus))
    {
        *WorldSidToFree = WorldSid;
        *ObjectSD = SecurityDescriptor;
    }
    else
    {
        *WorldSidToFree = NULL;
        *ObjectSD = NULL;
        if (WorldSid)
        {
            Wow64FreeHeap(WorldSid);
        }

        if (SecurityDescriptor)
        {
            Wow64FreeHeap(SecurityDescriptor);
        }
    }

    return NtStatus;
}


NTSTATUS
Wow64pInitializeSuspendMutant(
    VOID)
/*++

Routine Description:

    Creates the mutant to for execlusive access to Wow64SuspendThread API.

Arguments:

    None

Return Value:

    NTSTATUS.

--*/
{
    NTSTATUS NtStatus;
    OBJECT_ATTRIBUTES MutantObjectAttributes;
    UNICODE_STRING MutantUnicodeString;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    PSID WorldSid;
    WCHAR SuspendMutantFullName[ 64 ];


    //
    // Construct the cache mutant in the correct session space, in case
    // we are running on Hydra
    //
    SuspendMutantFullName[ 0 ] = UNICODE_NULL;
    if (NtCurrentPeb()->SessionId != 0)
    {
        swprintf(SuspendMutantFullName, L"\\sessions\\%ld", NtCurrentPeb()->SessionId);
    }

    swprintf(SuspendMutantFullName, L"%ws\\BaseNamedObjects\\%ws", SuspendMutantFullName, WOW64_SUSPEND_MUTANT_NAME);
    RtlInitUnicodeString(&MutantUnicodeString, SuspendMutantFullName);

    NtStatus = Wow64pCreateSecurityDescriptor(&SecurityDescriptor,
                                              &WorldSid,
                                              MUTANT_ALL_ACCESS);

    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "Wow64pInitializeSuspendMutant - Failed to create security descriptor - %lx",
                  NtStatus));
        return NtStatus;
    }


    InitializeObjectAttributes(&MutantObjectAttributes,
                               &MutantUnicodeString,
                               (OBJ_OPENIF | OBJ_CASE_INSENSITIVE),
                               NULL,
                               SecurityDescriptor);

    //
    // Let's create suspend thread mutant to serialize access
    // to Wow64SuspendThread
    //
    NtStatus = NtCreateMutant(&SuspendThreadMutant,
                              MUTANT_ALL_ACCESS,
                              &MutantObjectAttributes,
                              FALSE);

    Wow64FreeHeap(WorldSid);
    Wow64FreeHeap(SecurityDescriptor);

    if (!NT_SUCCESS(NtStatus))
    {
        LOGPRINT((ERRORLOG, "Wow64pInitializeSuspendMutant : Couldn't create/open SuspendThread mutant - %lx\n",
                  NtStatus));
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64\wow64lpc.c ===
/*++                 

Copyright (c) 2002 Microsoft Corporation

Module Name:

    wow64lpc.c

Abstract:
    
    This module implement the routines necessary to thunk legacy LPC messages
    that sent from code thats not wow64 aware.
    
    SQL client/server communication communicate over LPC when both sides are on the same 
    machine (we found this case during SQL setup).
       
    
Author:

    12-Jul-2002  Samer Arafeh (samera)

Revision History:

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <minmax.h>
#include "nt32.h"
#include "wow64p.h"
#include "wow64cpu.h"

#include <stdio.h>

//
// Buffer to hold the legacy LPC port name
//

WCHAR wszLegacyLpcPortName [MAX_PATH + 1];
INT LpcPortNameLength;

ASSERTNAME;



NTSTATUS
Wow64pGetLegacyLpcPortName(
    VOID
    )
/*++

Routine Description:

    This routine is called on process startup to cache the Legacy LPC port name
    used by MS SQL.

Arguments:

    None.
    
Return Value:

    NTSTATUS.

--*/
{
    const static UNICODE_STRING ComputerName_String = RTL_CONSTANT_STRING(L"COMPUTERNAME");
    NTSTATUS NtStatus;
    WCHAR wszComputerName [64];
    UNICODE_STRING ValueName;
    INT i;

    
    ValueName.Length = 0;
    ValueName.MaximumLength = sizeof (wszComputerName);
    ValueName.Buffer = wszComputerName;

    NtStatus = RtlQueryEnvironmentVariable_U (NULL, &ComputerName_String, &ValueName);

    if (NT_SUCCESS (NtStatus)) {
        
        LpcPortNameLength = _snwprintf (wszLegacyLpcPortName, 
                                        (sizeof (wszLegacyLpcPortName) / sizeof (wszLegacyLpcPortName [0])) - 1,
                                        L"\\BaseNamedObjects\\Global\\%ws",
                                        ValueName.Buffer);

        if (LpcPortNameLength < 0) {
            wszLegacyLpcPortName [0] = UNICODE_NULL;
            NtStatus = STATUS_BUFFER_TOO_SMALL;
        }
    }

    LOGPRINT((TRACELOG, "Wow64pGetLegacyLpcPortName: LegacyPortname = %ws,%lx - %lx\n", wszLegacyLpcPortName, LpcPortNameLength, NtStatus));

    return NtStatus;
}


BOOLEAN
Wow64pIsLegacyLpcPort (
    IN PUNICODE_STRING PortName
    )
/*++

Routine Description:
  
    This routine checks if the port name passed in a legacy one.
        
Arguments:

    PortName - Port name
    
Return:

    BOOLEAN.

--*/

{
    BOOLEAN LegacyPort = FALSE;

    try {

        if ((LpcPortNameLength > 0) && 
            (_wcsnicmp (PortName->Buffer, wszLegacyLpcPortName, LpcPortNameLength)) == 0) {
            LegacyPort = TRUE;
            LOGPRINT((TRACELOG, "Wow64pIsLegacyLpcPort: The following LPC port is Legacy: \n"));
        }
        
        LOGPRINT((TRACELOG, "Wow64pIsLegacyLpcPort: Incoming port = %ws\n", PortName->Buffer));

    } except (EXCEPTION_EXECUTE_HANDLER) {
        ;
    }

    return LegacyPort;
}


NTSTATUS
Wow64pThunkLegacyLpcMsgIn (
    IN BOOLEAN RequestWaitCall,
    IN PPORT_MESSAGE32 PortMessage32,
    IN OUT PPORT_MESSAGE *PortMessageOut
    )
/*++

Routine Description:
  
    This routine check the received PortMessage structure, and if it is a legacy one, 
    then it will thunk it.
        
Arguments:

    RequestWaitCall - Boolean to tell whether this is an NtRequestWaitReplyCall or not.
    
    PortMessage32 - Received 32-bit port message.
    
    PortMessageOut - Thunked port message. This is set to the Received port message if this
                     is not a legacy message.
    
Return:

    NTSTATUS.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PPORT_MESSAGE Message;
    CSHORT PortMessageTotalLength;
    PPORT_DATA_INFORMATION32 DataInfo32;
    PPORT_DATA_ENTRY32 DataEntry32;
    PPORT_DATA_INFORMATION DataInfo;
    PPORT_DATA_ENTRY DataEntry;
    ULONG CountDataBuffer;
    ULONG Ctr;



    //
    // Initialize the thunked port message to point to the caller's one
    //

    *PortMessageOut = (PPORT_MESSAGE) PortMessage32;

    if (ARGUMENT_PRESENT (PortMessage32)) {
        
        try {

            //
            // Initialize data length field
            //
            
            CountDataBuffer = 0;

            //
            // Calculate the exact space you need
            //

            if (PortMessage32->u2.s2.DataInfoOffset != 0) {

                DataInfo32 = (PPORT_DATA_INFORMATION32)((PCHAR)PortMessage32 + PortMessage32->u2.s2.DataInfoOffset);
                CountDataBuffer = DataInfo32->CountDataEntries * (sizeof (PORT_DATA_ENTRY) - sizeof (PORT_DATA_ENTRY32));
                CountDataBuffer += (sizeof (PORT_DATA_INFORMATION) - sizeof (PORT_DATA_INFORMATION32));

            } else {
                DataInfo32 = NULL;
            }

            CountDataBuffer += PortMessage32->u1.s1.DataLength;

            PortMessageTotalLength = sizeof (PORT_MESSAGE) + CountDataBuffer;

            Message = Wow64AllocateTemp (PortMessageTotalLength);
                
            if (Message != NULL) {
                
                //
                // Start copying information over
                //

                Message->u1.s1.DataLength = (CSHORT)CountDataBuffer;
                Message->u1.s1.TotalLength = PortMessageTotalLength;

                Message->u2.s2.Type = PortMessage32->u2.s2.Type;
                if (PortMessage32->u2.s2.DataInfoOffset != 0) {
                    Message->u2.s2.DataInfoOffset = PortMessage32->u2.s2.DataInfoOffset + (sizeof (PORT_MESSAGE) - sizeof (PORT_MESSAGE32));
                } else {
                    Message->u2.s2.DataInfoOffset = 0;
                }

                Message->ClientId.UniqueProcess = LongToPtr (PortMessage32->ClientId.UniqueProcess);
                Message->ClientId.UniqueThread = LongToPtr (PortMessage32->ClientId.UniqueThread);

                Message->MessageId = PortMessage32->MessageId;

                Message->ClientViewSize = PortMessage32->ClientViewSize;
                Message->CallbackId = PortMessage32->CallbackId;

                if (DataInfo32 != NULL) {
                        
                    Ctr = PortMessage32->u2.s2.DataInfoOffset - sizeof (*PortMessage32);
                    if (Ctr) {
                        RtlCopyMemory ((Message + 1),
                                       (PortMessage32 + 1),
                                       Ctr);
                    }

                    DataInfo = (PPORT_DATA_INFORMATION)((PCHAR)(Message + 1) + (Ctr));
                    DataInfo->CountDataEntries = DataInfo32->CountDataEntries;
                    DataEntry = &DataInfo->DataEntries [0];
                    DataEntry32 = &DataInfo32->DataEntries [0];
                        
                    for (Ctr = 0 ; Ctr < DataInfo32->CountDataEntries ; Ctr++) {
                        DataEntry [Ctr].Base = UlongToPtr (DataEntry32 [Ctr].Base);
                        DataEntry [Ctr].Size = DataEntry32 [Ctr].Size;
                    }
                } else {

                    if (PortMessage32->u1.s1.DataLength) {
                        RtlCopyMemory ((Message + 1),
                                       (PortMessage32 + 1),
                                       PortMessage32->u1.s1.DataLength);
                    }
                }
                    
                //
                // Use the new message pointer
                //

                *PortMessageOut = Message;

            } else {
                NtStatus = STATUS_NO_MEMORY;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
        
            NtStatus = GetExceptionCode ();
        }
    }

    return NtStatus;
}


NTSTATUS
Wow64pThunkLegacyLpcMsgOut (
    IN BOOLEAN RequestWaitCall,
    IN PPORT_MESSAGE PortMessage,
    IN OUT PPORT_MESSAGE32 PortMessage32
    )
/*++

Routine Description:
  
    This routine thunks the 64-bit port message into a legacy 32-bit LPC message.
        
Arguments:

    RequestWaitCall - Boolean to tell whether this is an NtRequestWaitReplyCall or not.
    
    PortMessage - 64-bit LPC port message to be thunked.
                     
    PortMessage32 - 32-bit legacy LPC port message to fill.
    
    
Return:

    NTSTATUS.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;
    CSHORT DataLength;

    if (ARGUMENT_PRESENT (PortMessage32)) {
        
        try {

            ASSERT (PortMessage != NULL);
            
            DataLength = PortMessage->u1.s1.DataLength;
            PortMessage32->u1.s1.TotalLength = sizeof (*PortMessage32) + DataLength;
            PortMessage32->u1.s1.DataLength = DataLength;

            PortMessage32->u2.s2.Type = PortMessage->u2.s2.Type;
            PortMessage32->u2.s2.DataInfoOffset = PortMessage->u2.s2.DataInfoOffset;

            PortMessage32->ClientId.UniqueProcess = PtrToLong (PortMessage->ClientId.UniqueProcess);
            PortMessage32->ClientId.UniqueThread = PtrToLong (PortMessage->ClientId.UniqueThread);

            PortMessage32->MessageId = PortMessage->MessageId;

            PortMessage32->ClientViewSize = (ULONG)PortMessage->ClientViewSize;
            PortMessage32->CallbackId = PortMessage->CallbackId;

            if (PortMessage32->u2.s2.DataInfoOffset == 0) {

                if (DataLength) {
                    RtlCopyMemory ((PortMessage32 + 1),
                                   (PortMessage + 1),
                                   DataLength);
                }
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
        
            NtStatus = GetExceptionCode ();
        }
    }

    return NtStatus;
}


NTSTATUS
Wow64pThunkLegacyPortViewIn (
    IN PPORT_VIEW32 PortView32,
    OUT PPORT_VIEW *PortView,
    OUT PBOOLEAN LegacyLpcPort
    )
/*++

Routine Description:
  
    This routine thunks incoming PortView structure for legacy Lpc messages.
        
Arguments:

    PortView32 - Incoming 32-bit PORT_VIEW structure
    
    PortView - Port view structure based on the caller type
    
    LegacyLpcPort - Flag set to TRUE if this is a legacy Lpc port
    
Return:

    NTSTATUS

--*/

{
    PPORT_VIEW PortViewCopy;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    //
    // Indicate this is not a legacy lpc port
    //

    *PortView = (PPORT_VIEW)PortView32;

    if (ARGUMENT_PRESENT (PortView32)) {
        
        try {

            if (PortView32->Length == sizeof (*PortView32)) {

                //
                // Allocate a Port view
                //

                PortViewCopy = Wow64AllocateTemp (sizeof (*PortViewCopy));
                if (PortViewCopy == NULL) {
                    return STATUS_NO_MEMORY;
                }

                //
                // Handle legacy port view
                //

                PortViewCopy->Length = sizeof (*PortViewCopy);
                PortViewCopy->SectionHandle = LongToPtr (PortView32->SectionHandle);
                PortViewCopy->SectionOffset = PortView32->SectionOffset;
                PortViewCopy->ViewSize = PortView32->ViewSize;
                PortViewCopy->ViewBase = UlongToPtr (PortView32->ViewBase);
                PortViewCopy->ViewRemoteBase = ULongToPtr (PortView32->ViewRemoteBase);

                *PortView = PortViewCopy;
                *LegacyLpcPort = TRUE;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            NtStatus = GetExceptionCode ();
        }
    }

    return NtStatus;
}

NTSTATUS
Wow64pThunkLegacyPortViewOut (
    IN PPORT_VIEW PortView,
    IN OUT PPORT_VIEW32 PortView32
    )
/*++

Routine Description:
  
    This routine thunks back a 64-bit PortView structure.
        
Arguments:

    PortView - 64-bit PortView structure
    
    PortView32 - 32-bit PortView structure to thunk to.    
    
Return:

    NTSTATUS

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    if (ARGUMENT_PRESENT (PortView32)) {
        
        try {

            ASSERT (PortView != NULL);

            if (PortView32->Length == sizeof (*PortView32)) {

                //
                // Handle legacy port view
                //

                PortView32->Length = sizeof (*PortView32);
                PortView32->SectionHandle = PtrToLong (PortView->SectionHandle);
                PortView32->SectionOffset = PortView->SectionOffset;
                PortView32->ViewSize = (ULONG)PortView->ViewSize;
                PortView32->ViewBase = PtrToUlong (PortView->ViewBase);
                PortView32->ViewRemoteBase = PtrToUlong (PortView->ViewRemoteBase);
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            NtStatus = GetExceptionCode ();
        }
    }

    return NtStatus;
}


NTSTATUS
Wow64pThunkLegacyRemoteViewIn (
    IN PREMOTE_PORT_VIEW32 RemotePortView32,
    IN OUT PREMOTE_PORT_VIEW *RemotePortView,
    OUT PBOOLEAN LegacyLpcPort
    )
/*++

Routine Description:
  
    This routine thunks incoming RemotePortView structure for legacy Lpc messages.
        
Arguments:

    RemotePortView32 - Incoming 32-bit REMOTE_PORT_VIEW structure
    
    RemotePortView - Remote port view structure based on the caller type
    
    LegacyLpcPort - Flag set to TRUE if this is a legacy Lpc port
    
Return:

    NTSTATUS

--*/

{
    PREMOTE_PORT_VIEW RemotePortViewCopy;
    NTSTATUS NtStatus = STATUS_SUCCESS;

    
    //
    // Indicate this is not a legacy lpc port
    //

    *RemotePortView = (PREMOTE_PORT_VIEW)RemotePortView32;

    if (ARGUMENT_PRESENT (RemotePortView32)) {

        try {

            if (RemotePortView32->Length == sizeof (*RemotePortView32)) {
                
                RemotePortViewCopy = Wow64AllocateTemp (sizeof (*RemotePortViewCopy));
                if (RemotePortViewCopy == NULL) {
                    return STATUS_NO_MEMORY;
                }

                RemotePortViewCopy->Length = sizeof (*RemotePortViewCopy);
                RemotePortViewCopy->ViewBase = UlongToPtr (RemotePortView32->ViewBase);
                RemotePortViewCopy->ViewSize = RemotePortView32->ViewSize;

                *LegacyLpcPort = TRUE;
                *RemotePortView = RemotePortViewCopy;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            NtStatus = GetExceptionCode ();
        }
    }

    return NtStatus;
}


NTSTATUS
Wow64pThunkLegacyRemoteViewOut (
    IN PREMOTE_PORT_VIEW RemotePortView,
    IN OUT PREMOTE_PORT_VIEW32 RemotePortView32
    )
/*++

Routine Description:
  
    This routine thunks back a 64-bit RemotePortView structure.
        
Arguments:

    RemotePortView - 64-bit RemotePortView structure
    
    RemotePortView32 - 32-bit RemotePortView structure to thunk to.    
    
Return:

    NTSTATUS

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    if (ARGUMENT_PRESENT (RemotePortView32)) {

        try {
            
            ASSERT (RemotePortView != NULL);

            RemotePortView32->Length = sizeof (*RemotePortView32);
            RemotePortView32->ViewBase = PtrToUlong (RemotePortView->ViewBase);
            RemotePortView32->ViewSize = (ULONG)RemotePortView->ViewSize;

        } except (EXCEPTION_EXECUTE_HANDLER) {
            NtStatus = GetExceptionCode ();
        }
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64\wow64.c ===
/*++                 

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    wow64.c

Abstract:
    
    Main entrypoints for wow64.dll

Author:

    11-May-1998 BarryBo

Revision History:
    
    9-Aug-1999  ATM Shafiqul Khalid (khalid)  Added WOW64IsCurrentProcess()
    
    2-Jan-2002  Samer Arafeh (samera)         Wow64-AMD64 support.
    

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#define NOEXTAPI
#include <wdbgexts.h>
#include <ntdbg.h>
#include "wow64p.h"
#include "wow64cpu.h"

ASSERTNAME;

//
// import from ntdll.dll to unlock the loader lock
//

extern VOID LdrProcessInitializationComplete (VOID);


//
// This structure, Wow64Info, allows 32-bit code running inside a Wow64 process
// to access information regarding the native system which Wow64 is running on.
//

WOW64INFO Wow64SharedInfo;


//
// This array mirror's the kernel's array of data used to decode
// system service call parameters and dispatch.
//

WOW64SERVICE_TABLE_DESCRIPTOR ServiceTables[NUMBER_SERVICE_TABLES];

//
// Wow64 Feature Bits
//

ULONG Wow64pFeatureBits;


NTSTATUS
Wow64pInitializeWow64Info(
    VOID
    )

/*++

Routine Description:

    This function initializes Wow64Info, which is accessed from 32-bit modules
    running inside Wow64 to retreive information about the native system.

Arguments:

    None.

Return Value:

    Status.

--*/
{

    Wow64SharedInfo.NativeSystemPageSize = PAGE_SIZE;

    return STATUS_SUCCESS;
}

/*++

Routine Description:

    This function initialize the supported features by Wow64.

Arguments:

    None.
    
Return Value:

    None.

--*/

VOID
Wow64pInitializeFeatureBits (
    VOID)

{

    Wow64pFeatureBits  = WOW64_LARGE_PAGES_SUPPORTED;
    Wow64pFeatureBits |= WOW64_AWE_SUPPORTED;
    Wow64pFeatureBits |= WOW64_RDWR_SCATTER_GATHER;
    Wow64pFeatureBits |= WOW64_WRITE_WATCH_SUPPORTED;

    return;
}


//
// Number of bytes of memory the CPU wants allocated per-thread
//
SIZE_T CpuThreadSize;

WOW64DLLAPI
VOID
Wow64LdrpInitialize (
    IN PCONTEXT Context
    )
/*++

Routine Description:

    This function is called by the 64-bit loader when the exe is 32-bit.

Arguments:

    Context - Supplies an optional context buffer that will be restore
              after all DLL initialization has been completed.  If this
              parameter is NULL then this is a dynamic snap of this module.
              Otherwise this is a static snap prior to the user process
              gaining control.

              NOTE:  This Context is 64-bit

Return Value:

    None.  Never returns:  the process is destroyed when this function
    completes.

--*/
{
    NTSTATUS st;
    PVOID pCpuThreadData;
    ULONG InitialIP;
    CONTEXT32 Context32;
    static BOOLEAN InitializationComplete;
    PWSTR ImagePath;
    PIMAGE_NT_HEADERS NtHeaders;
    PPEB Peb64;
    BOOLEAN FirstRun;


    //
    // Let the 32-bit thread points to wow64info.
    //
 
    Wow64TlsSetValue(WOW64_TLS_WOW64INFO, &Wow64SharedInfo);

    FirstRun = !InitializationComplete;
    
    if (FirstRun) {

        WCHAR ImagePathBuffer [ 264 ];

        //
        // First-time call - this is process init.
        //
        
        st = ProcessInit(&CpuThreadSize);

        //
        // Set process execute options
        //

        Wow64pSetProcessExecuteOptions ();

        //
        // Unlock the loader lock
        //

        LdrProcessInitializationComplete ();

        if (!NT_SUCCESS(st)) { 
            LOGPRINT((ERRORLOG, "Wow64LdrpInitialize: ProcessInit failed, error %x\n", st));
            LOGPRINT((ERRORLOG, "Wow64LdrpInitialize: Calling NtTerminateProcess.\n"));
            NtTerminateProcess(NtCurrentProcess(), st);
        }

        InitializationComplete = TRUE;

        //
        // Notify the CPU that the image has been loaded.
        //

        ImagePath = L"image";
        Peb64 = NtCurrentPeb();
        if ((ImagePath != NULL) && (Peb64->ProcessParameters->ImagePathName.Length != 0)) {

            ImagePath = Peb64->ProcessParameters->ImagePathName.Buffer;
        }

        NtHeaders = RtlImageNtHeader (Peb64->ImageBaseAddress);
        CpuNotifyDllLoad(ImagePath,
                         Peb64->ImageBaseAddress,
                         NtHeaders->OptionalHeader.SizeOfImage);

        //
        // Notify the CPU that 32-bit ntdll.dll has been loaded.
        //

        ImagePath = ImagePathBuffer;
    
        wcscpy (ImagePath, USER_SHARED_DATA->NtSystemRoot);
        wcsncat (ImagePath, L"\\syswow64\\ntdll.dll",
                 (sizeof(ImagePathBuffer)/sizeof(WCHAR))-wcslen(USER_SHARED_DATA->NtSystemRoot)-1);

        NtHeaders = RtlImageNtHeader (UlongToPtr (NtDll32Base));
        CpuNotifyDllLoad (ImagePath,
                          UlongToPtr (NtDll32Base),
                          NtHeaders->OptionalHeader.SizeOfImage);

        //
        // Initialize Wow64 feature bits
        //

        Wow64pInitializeFeatureBits ();

        //
        // Initialize Legacy Lpc port name
        //

        Wow64pGetLegacyLpcPortName ();
    }

        
    // Determine if the initial context for this process is in 32bit code or 64bit code.
    // If it is in 64bit, jump to it and stay in 64bit land forever.   If the initial
    // context is in 32bit land, finish the cpu initialization.
    // This feature is ment for supporting the breakin feature of debuggers which create a thread 
    // in the debuggeee 
    Run64IfContextIs64(Context, FirstRun);

    //
    // Allocate the CPU's per-thread memory from the 64-bit stack.  This
    // memory will be freed when the stack is freed.  It is passed into the
    // CPU as zero-filled.
    //
    pCpuThreadData = _alloca(CpuThreadSize);
    RtlZeroMemory (pCpuThreadData, CpuThreadSize);
    Wow64TlsSetValue (WOW64_TLS_CPURESERVED, pCpuThreadData);

    LOGPRINT((TRACELOG, "Wow64LdrpInitialize: cpu per thread data allocated at %I64x \n", (ULONGLONG)pCpuThreadData));
    WOWASSERT_PTR32(pCpuThreadData);   
 
    //
    // Perform per-thread init
    //
    st = ThreadInit (pCpuThreadData);
    
    if (!NT_SUCCESS(st)) {
        LOGPRINT((ERRORLOG, "Wow64LdrpInitialize: ThreadInit failed, error %x\n", st));
        LOGPRINT((ERRORLOG, "Wow64LdrpInitialize: Calling RtlRaiseStatus().\n"));
        WOWASSERT (FALSE);
        RtlRaiseStatus (st);
    }

    //
    // Call 32-bit ntdll.dll LdrInitializeThunk.  This never returns.
    //

    //
    // Fetch the initial 32-bit CONTEXT
    //

    Context32.ContextFlags = CONTEXT32_FULLFLOAT;
#if defined(_AMD64_)
    CpuSetInstructionPointer((ULONG)Context->Rip);
#elif defined(_IA64_)
    CpuSetInstructionPointer((ULONG)Context->StIIP);
#else
#error "No Target Architecture"
#endif

    CpuGetContext (NtCurrentThread (),
                   NtCurrentProcess (),
                   NtCurrentTeb (),
                   &Context32);
    
    ThunkStartupContext64TO32 (&Context32,
                               Context);

    InitialIP = Wow64SetupApcCall (Ntdll32LoaderInitRoutine,
                                   &Context32,
                                   NtDll32Base,
                                   0
                                  );

    //
    // Start simulation
    //

    RunCpuSimulation ();
}


VOID
Wow64SetupExceptionDispatch(
    IN PEXCEPTION_RECORD32 pRecord32,
    IN PCONTEXT32 pContext32
    )
/*++

Routine Description:
  
    Copy the 32bit exception record and 32bit continuation context to the 32bit stack
    and sets the 32bit context to run the exception dispatcher in NTDLL32.
    
    pRecord32  - Supplies the 32bit exception record to be raised.
    pContext32 - Supplies the 32bit continuation context. 

Arguments:

    None - If failure occures an exception will be thrown.

--*/
{
    ULONG SP;
    PULONG PtrExcpt;
    PULONG PtrCxt;
    EXCEPTION_RECORD32 ExrCopy32; 
    EXCEPTION_RECORD ExrCopy;
    PEXCEPTION_RECORD32 TmpExcpt;
    PCONTEXT32 TmpCxt;

retry:
    try {    

        SP = CpuGetStackPointer() & (~3);
        SP -= (2*sizeof(ULONG))+sizeof(EXCEPTION_RECORD32)+sizeof(CONTEXT32);

        PtrExcpt = (PULONG) SP;
        PtrCxt = (PULONG) (((UINT_PTR) PtrExcpt) + sizeof(ULONG));
        TmpExcpt = (PEXCEPTION_RECORD32) (((UINT_PTR) PtrCxt) + sizeof(ULONG));
        TmpCxt = (PCONTEXT32) (((UINT_PTR) TmpExcpt) + sizeof(EXCEPTION_RECORD32));


        //
        // Copy on the 32-bit EXCEPTION_RECORD
        //
        *TmpExcpt = *pRecord32;

        //
        // Copy the 32-bit CONTEXT on the stack, too
        //
        *TmpCxt = *pContext32;

        //
        // Change the cpu's Context to point at
        // ntdll32!KiUserExceptionDispatcher and set up the parameters
        // for the call.
        //
        *PtrExcpt = PtrToUlong(TmpExcpt);
        *PtrCxt = PtrToUlong(TmpCxt);
    }

    except((ExrCopy = *(((struct _EXCEPTION_POINTERS *)GetExceptionInformation())->ExceptionRecord)), EXCEPTION_EXECUTE_HANDLER) {
        if(GetExceptionCode() == STATUS_STACK_OVERFLOW) {
            ThunkExceptionRecord64To32(&ExrCopy, &ExrCopy32);
            ExrCopy32.ExceptionAddress = pRecord32->ExceptionAddress;
            pRecord32 = &ExrCopy32;
            goto retry;
        }
        else {
           // Send this exception to the debugger.
           ExrCopy.ExceptionAddress = (PVOID)pRecord32->ExceptionAddress; 
           Wow64NotifyDebugger(&ExrCopy, FALSE);
        }
    }

    //
    // Ok, we have made a copy of the ia32 context on the ia32 stack,
    // now need to set up for the running of the ia32 exception handler
    // so we need to reset the ia32 state to something good... 
    //
    
    CpuSetStackPointer(SP);
    CpuSetInstructionPointer(Ntdll32KiUserExceptionDispatcher);

    //
    // If the exception was floating point related, we need to reset
    // the floating point hardware to make sure we don't take another
    // exceptions from the current status bits
    //
    switch(pRecord32->ExceptionCode) {
        case STATUS_FLOAT_INEXACT_RESULT:
        case STATUS_FLOAT_UNDERFLOW:
        case STATUS_FLOAT_OVERFLOW:
        case STATUS_FLOAT_DIVIDE_BY_ZERO:
        case STATUS_FLOAT_DENORMAL_OPERAND:
        case STATUS_FLOAT_INVALID_OPERATION:
        case STATUS_FLOAT_STACK_CHECK:
            CpuResetFloatingPoint();

        default:
            // Nothing to do
            ;
    }
}


VOID
ThunkExceptionRecord64To32(
    IN  PEXCEPTION_RECORD   pRecord64,
    OUT PEXCEPTION_RECORD32 pRecord32
    )
/*++

Routine Description:

    Thunks an exception record from 64-bit to 32-bit.

Arguments:

    pRecord64   - 64-bit exception record
    pRecord32   - destination 32-bit exception record

Return Value:

    None.

--*/
{
    int i;

    switch (pRecord64->ExceptionCode) {
    case STATUS_WX86_BREAKPOINT:
        pRecord32->ExceptionCode = STATUS_BREAKPOINT;
        break;

    case STATUS_WX86_SINGLE_STEP:
        pRecord32->ExceptionCode = STATUS_SINGLE_STEP;
        break;

    default:
        pRecord32->ExceptionCode = pRecord64->ExceptionCode;
        break;
    }
    pRecord32->ExceptionFlags = pRecord64->ExceptionFlags;
    pRecord32->ExceptionRecord = PtrToUlong(pRecord64->ExceptionRecord);
    pRecord32->ExceptionAddress = PtrToUlong(pRecord64->ExceptionAddress);
    pRecord32->NumberParameters = pRecord64->NumberParameters;

    for (i=0; i<EXCEPTION_MAXIMUM_PARAMETERS; ++i) {
        pRecord32->ExceptionInformation[i] =
            (ULONG)pRecord64->ExceptionInformation[i];
    }

    ThunkpExceptionRecord64To32 (pRecord64, pRecord32);
}

PEXCEPTION_RECORD 
Wow64AllocThunkExceptionRecordChain32TO64(
    IN PEXCEPTION_RECORD32 Exr32
    )
/*++

Routine Description:

    Copy a 32bit chain of EXCEPTION_RECORD to a new 64bit chain.  Memory is 
    allocated on the temporary thunk memory list.

Arguments:

    Exr32 - supplies a pointer to the 32bit chain to copy.

Return Value:

    A newly created 64bit version of the 32bit list passed in Exr32.

--*/
{

    PEXCEPTION_RECORD Exr64;
    int i;

    if (NULL == Exr32) {
        return NULL;
    }

    Exr64 = Wow64AllocateTemp(sizeof(EXCEPTION_RECORD) );

    // Thunk the 32-bit exception record to 64-bit
    switch (Exr32->ExceptionCode) {
    case STATUS_BREAKPOINT:
        Exr64->ExceptionCode = STATUS_WX86_BREAKPOINT;
        break;

    case STATUS_SINGLE_STEP:
        Exr64->ExceptionCode = STATUS_WX86_SINGLE_STEP;
        break;

    default:
        Exr64->ExceptionCode = Exr32->ExceptionCode;
    }
    Exr64->ExceptionFlags = Exr32->ExceptionFlags;
    Exr64->ExceptionRecord = Wow64AllocThunkExceptionRecordChain32TO64((PEXCEPTION_RECORD32)Exr32->ExceptionRecord);
    Exr64->ExceptionAddress = (PVOID)Exr32->ExceptionAddress;
    Exr64->NumberParameters = Exr32->NumberParameters;
    for (i=0; i<EXCEPTION_MAXIMUM_PARAMETERS; ++i) {
        Exr64->ExceptionInformation[i] = Exr32->ExceptionInformation[i];
    }      

    return Exr64;

}

LONG
Wow64DispatchExceptionTo32(
    IN struct _EXCEPTION_POINTERS *ExInfo
    )
/*++

Routine Description:

    64-bit exception filter which is responsible for dispatching the
    exception down to 32-bit code.

Arguments:

    ExInfo  - 64-bit exception pointers

Return Value:

    None.  Never returns.

--*/
{
    EXCEPTION_RECORD32 Record32;
    CONTEXT32 Context32;
    

    LOGPRINT((TRACELOG, "Wow64DispatchExceptionTo32(%p) called.\n"
                        "Exception Code: 0x%x, Exception Address: 0x%p, TLS exceptionaddr:0x%p\n",
                         ExInfo,
                         ExInfo->ExceptionRecord->ExceptionCode,
                         ExInfo->ExceptionRecord->ExceptionAddress,
                         Wow64TlsGetValue(WOW64_TLS_EXCEPTIONADDR)));

    if (Wow64TlsGetValue(WOW64_TLS_INCPUSIMULATION)) {
        //
        // INCPUSIMULATION is still set, so the CPU emulator is not using
        // native SP as an alias for simulated ESP.  Therefore,
        // Wow64PrepareForException was a no-op and we need to reset the
        // CPU now.
        //
        CpuResetToConsistentState(ExInfo);
        Wow64TlsSetValue(WOW64_TLS_INCPUSIMULATION, FALSE);
    }
    
    Context32.ContextFlags = CONTEXT32_FULLFLOAT;
    CpuGetContext(NtCurrentThread(),
                  NtCurrentProcess(),
                  NtCurrentTeb(),
                  &Context32);
    ThunkExceptionRecord64To32(ExInfo->ExceptionRecord, &Record32);

    //
    // Do what the kernel does, when it's about to 
    // dispatch excpetions to user mode. Basically TrapFrame->Eip
    // will be pointing at the instruction following int 3, while
    // Context.Eip that will be dispatched to user mode, will be pointing
    // at the faulting instruction. See (ke\i386\exceptn.c)
    //
    switch (Record32.ExceptionCode)
    {
    case STATUS_BREAKPOINT:
        Context32.Eip--;
        break;
    }

    //
    // Patch in the original 32-bit exception address.  It was patched-out
    // by Wow64PrepareForException since that value is used to seed the
    // stack unwind.
    //
    Record32.ExceptionAddress =
        PtrToUlong(Wow64TlsGetValue(WOW64_TLS_EXCEPTIONADDR));
    WOWASSERT(!ARGUMENT_PRESENT(Record32.ExceptionRecord));

    //
    // Setup architecture dependent call to ntdll32's exception handler.
    Wow64SetupExceptionDispatch(&Record32, &Context32);

    //
    // At this point, the exception is now ready to be handled by the ia32
    // exception handler, so let the ia32 code run...
    //

    return EXCEPTION_EXECUTE_HANDLER;
}

BOOLEAN
Wow64NotifyDebugger(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN BOOLEAN FirstChance
    )
/*++

Routine Description:

   Notifies the debugger when a 32bit software exception occures.

Arguments:

    ExceptionRecord - supplies a pointer to the 64bit exception record chain to report 
                      to the debugger.

Return Value:

    TRUE - The debugger handled the exception.
    FALSE - The debugger did not handle the exception.

--*/
{
    try {
       Wow64NotifyDebuggerHelper(ExceptionRecord, FirstChance);
       return TRUE;  
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
       return FALSE;
    }
    
}

NTSTATUS
Wow64KiRaiseException(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN PCONTEXT ContextRecord,
    IN BOOLEAN FirstChance
    )
/*++

Routine Description:

   Called to raise a 32bit software exception.   This function notifies the debugger
   and then sets the 32bit instruction pointer to point to the exception dispatcher
   in NTDLL32.

Arguments:

    ExceptionRecord - supplies a pointer to the 32bit exception record chain to report 
                      to the debugger.

    ContextRecord - supplies a pointer to the 32bit continuation context record.

    FirstChange - TRUE if this is a first chance exception.

Return Value:

    An NTSTATUS code reporting success or failure.

--*/
{

    NTSTATUS st;
    EXCEPTION_RECORD32 Exr32;
    PEXCEPTION_RECORD Exr64;
    CONTEXT32 Cxt32;    
    BOOLEAN DebuggerHandled;

    // Kernel copies these, lets do what the kernel does.
    try {
       Exr32 = *(PEXCEPTION_RECORD32)ExceptionRecord;
       Exr32.ExceptionCode &= 0xefffffff;
       Cxt32 = *(PCONTEXT32)ContextRecord;
    }
    except(EXCEPTION_EXECUTE_HANDLER) {
       return GetExceptionCode();
    }  
    
    //
    // Update the CPU's context. This is similiar to what the kernel
    // does : at the start of ke!KiRaiseException, it does
    // ke!KeContextToKframes
    //
    CpuSetContext(NtCurrentThread(),
                  NtCurrentProcess(),
                  NtCurrentTeb(),
                  &Cxt32);

    // Send the exception to the debugger.
    Exr64 = Wow64AllocThunkExceptionRecordChain32TO64(&Exr32);
    LOGPRINT((TRACELOG, "Wow64KiRaiseException: Notifying debugger, FirstChance %X\n", (ULONG)FirstChance));
    DebuggerHandled = Wow64NotifyDebugger(Exr64, FirstChance);

    if (!DebuggerHandled) {  

#if defined(_AMD64_)
        //
        // Restore the 32-bit exception address
        //

        Exr32.ExceptionAddress = PtrToUlong (Wow64TlsGetValue (WOW64_TLS_EXCEPTIONADDR));
#endif

        // Debugger did not handle the exception.  Pass it back to the app.
        LOGPRINT((TRACELOG, "Wow64KiRaiseException: Debugger did not handle exception\n"));
        LOGPRINT((TRACELOG, "Wow64KiRaiseException: Dispatching exception to user mode.\n")); 
        WOWASSERT(FirstChance);  // Should not get back here if second chance.
        Wow64SetupExceptionDispatch(&Exr32, &Cxt32);
        return STATUS_SUCCESS; // Context will be set on the return from system service.

    }

    // Debugger did handle the exception.   Set the context to the restoration context.
    // This is effectivly the same as returning EXCEPTION_CONTINUE_EXECUTION from the
    // except block.  The debugger could have set the context, but that would be the 64
    // bit context and the code would probably not execute here.   This will need to
    // be revisited once (Get/Set)ThreadContext and debugging from a 32bit debugger is 
    // working.
    
    LOGPRINT((TRACELOG, "Wow64KiRaiseException: Debugger did handle exception(set context to restoration context)\n"));

    return STATUS_SUCCESS;

}


WOW64DLLAPI
PVOID
Wow64AllocateHeap(
    SIZE_T Size
    )
/*++

Routine Description:

    Wrapper for RtlAllocateHeap.

Arguments:

    Size        - number of bytes to allocate

Return Value:

    Pointer, or NULL if no memory.  Memory is not zero-filled.

--*/
{
    return RtlAllocateHeap(RtlProcessHeap(),
                           0,
                           Size);
}


WOW64DLLAPI
VOID
Wow64FreeHeap(
    PVOID BaseAddress
    )
/*++

Routine Description:

    Wrapper for RtlFreeHeap.

Arguments:

    BaseAddress     - Address to free.

Return Value:

    None.

--*/
{
    BOOLEAN b;

    b = RtlFreeHeap(RtlProcessHeap(),
                    0,
                    BaseAddress);
    WOWASSERT(b);
}

#pragma pack(push,8)
typedef struct _TempHeader {
   struct _TempHeader *Next;
} TEMP_HEADER, *PTEMP_HEADER;
#pragma pack(pop)

PVOID
WOW64DLLAPI
Wow64AllocateTemp(
    SIZE_T Size
    )
/*++

Routine Description:

    This function is called from a thunk to allocate temp memory which is
    freed once the thunk exits.

Arguments:

    Size - Supplies the amount of memory to allocate.

Return Value:

    Returns a pointer to the newly allocated memory.
    This function throws an exception if no memory is available.

--*/

{
    PTEMP_HEADER Header;

    if (!Size) {
        return NULL;
    }

    Header = RtlAllocateHeap(RtlProcessHeap(),
                             0,
                             sizeof(TEMP_HEADER) + Size
                             );
    if (!Header) {
        //
        // Throw an out-of-memory exception.  The thunk dispatcher will
        // catch this and clean up for us.  Normally you'd think we
        // could pass HEAP_GENERATE_EXCEPTIONS to RtlAllocateHeap and
        // the right thing would happen, but it doesn't.  NTRAID 413890.
        //
        EXCEPTION_RECORD ExceptionRecord;

        ExceptionRecord.ExceptionCode = STATUS_NO_MEMORY;
        ExceptionRecord.ExceptionRecord = (PEXCEPTION_RECORD)NULL;
        ExceptionRecord.NumberParameters = 1;
        ExceptionRecord.ExceptionFlags = 0;
        ExceptionRecord.ExceptionInformation[ 0 ] = sizeof(TEMP_HEADER) + Size;

        RtlRaiseException( &ExceptionRecord );
    }

    Header->Next = Wow64TlsGetValue(WOW64_TLS_TEMPLIST);
    Wow64TlsSetValue(WOW64_TLS_TEMPLIST, Header);

    return (PUCHAR)Header + sizeof(TEMP_HEADER);
}

VOID
Wow64FreeTempList(
    VOID
    )
/*++

Routine Description:

    This function is called to free all memory that was allocated in the thunk.

Arguments:

    None.

Return Value:

    None.

--*/
{
    PTEMP_HEADER Header,temp;
    BOOLEAN b;

    Header = Wow64TlsGetValue(WOW64_TLS_TEMPLIST);
    
    while(Header != NULL) {
       temp = Header->Next;
       b = RtlFreeHeap(RtlProcessHeap(),
                       0,
                       Header
                       );
       WOWASSERT(b);
       Header = temp;
    }

}

LONG
Wow64ServiceExceptionFilter(
    IN struct _EXCEPTION_POINTERS *ExInfo
    )
/*++

Routine Description:

    This function is called to determine if an exception should be handled
    by returning an error code to the application of the exception should
    be propaged up to the debugger.

    The purpose of this function is to make debugging thunks easier if ACCESS VIOLATIONS
    occure in the thunks.

Arguments:

    ExInfo - Supplies the exception information.

Return Value:

    EXCEPTION_CONTINUE_SEARCH - The exception should be passed to the debugger.
    EXCEPTION_EXECUTE_HANDLER - An error code should be passed to the application.

--*/
{
   
    LOGPRINT((TRACELOG, "Wow64ServiceExceptionFilter: Handling exception %x\n", ExInfo->ExceptionRecord->ExceptionCode));
  
    switch(ExInfo->ExceptionRecord->ExceptionCode) {
       case STATUS_ACCESS_VIOLATION:
       case STATUS_BREAKPOINT:
           return EXCEPTION_CONTINUE_SEARCH;
       default:
           return EXCEPTION_EXECUTE_HANDLER;
    }
}

LONG
Wow64HandleSystemServiceError(
    IN NTSTATUS Status,
    IN ULONG TableNumber,
    IN ULONG ApiNumber
    )
/*++

Routine Description:

    This function is called to determine the correct error number to return to
    the application based on the api called and the exception code.
   
    This function will set any values in the 64bit teb is necessary.

Arguments:

    Status - Supplies the exception code.
    TableNumber - Supplies the table number of the api called.
    ApiNumber - Supplies the number of the api called.

Return Value:

    return value.

--*/
{
   
   //
   // In the future, in may be a good idea to have a data structure to hold the exception cases.
   
   WOW64_API_ERROR_ACTION Action;
   LONG ActionParam;

   if (NULL == ServiceTables[TableNumber].ErrorCases) {
       Action = ServiceTables[TableNumber].DefaultErrorAction;
       ActionParam = ServiceTables[TableNumber].DefaultErrorActionParam;
   }
   else {
       Action = ServiceTables[TableNumber].ErrorCases[ApiNumber].ErrorAction;
       ActionParam = ServiceTables[TableNumber].ErrorCases[ApiNumber].ErrorActionParam;
   }

   switch(Action) {
      case ApiErrorNTSTATUS:
          return Status;
      case ApiErrorNTSTATUSTebCode:
          NtCurrentTeb32()->LastErrorValue = NtCurrentTeb()->LastErrorValue = RtlNtStatusToDosError(Status);
          return Status;
      case ApiErrorRetval:
          return ActionParam;
      case ApiErrorRetvalTebCode:
          NtCurrentTeb32()->LastErrorValue = NtCurrentTeb()->LastErrorValue = RtlNtStatusToDosError(Status);
          return ActionParam; 
      default:
          WOWASSERT(FALSE);
          return STATUS_INVALID_PARAMETER;         
   }

}


BOOL
WOW64DLLAPI
WOW64IsCurrentProcess (
    HANDLE hProcess
    )

/*++

Routine Description:

    Determines if hProcess corresponds to the current process.  

Arguments:

    hProcess    - handle to process to compare with the current one.

Return Value:

    If it does return TRUE, FALSE otherwise.
    
--*/
{
   NTSTATUS Status;
   PROCESS_BASIC_INFORMATION pbiProcess;
   PROCESS_BASIC_INFORMATION pbiCurrent;

   if (hProcess == NtCurrentProcess()) {
      return TRUE;
   }

   //
   // The process handle isn't obviously for the current procees - see if it
   // is an alias for the current process
   //
   Status = NtQueryInformationProcess(hProcess,
                                      ProcessBasicInformation,
                                      &pbiProcess,
                                      sizeof(pbiProcess),
                                      NULL
                                     );
   if (!NT_SUCCESS(Status)) {
      // Call failed for some reason - be pessimistic and flush the
      // current process's cache
      return TRUE;
   }

   Status = NtQueryInformationProcess(NtCurrentProcess(),
                                      ProcessBasicInformation,
                                      &pbiCurrent,
                                      sizeof(pbiCurrent),
                                      NULL
                                     );
   if (!NT_SUCCESS(Status)) {
      // Call failed for some reason - be pessimistic and flush the
      // current process's cache
      return TRUE;
   }

   if (pbiProcess.UniqueProcessId == pbiCurrent.UniqueProcessId) {
      return TRUE;
   }

   //
   // The hProcess specified is not the current process.  There
   // is no mechanism for cross-process Translation Cache flushes
   // yet.
   //
   return FALSE;
}

LONG
WOW64DLLAPI
Wow64SystemService(
    IN ULONG ServiceNumber,
    IN PCONTEXT32 Context32 //This is read only!
    )
/*++

Routine Description:

    This function is called by the CPU to dispatch a system call.

Arguments:

    ServiceNumber - Supplies the undecoded service number to call.
    Context32 - Supplies the readonly context used to call this service.

Return Value:

    None.

--*/
{
    ULONG Result;
    PVOID OldTempList;
    ULONG TableNumber, ApiNumber;
    THUNK_LOG_CONTEXT ThunkLogContext;

    // Indicate we're not in the CPU any more
    Wow64TlsSetValue(WOW64_TLS_INCPUSIMULATION, FALSE);

    // Backup the old temp list.  
    // This is so that recurion into the thunks(APC calls) are handled properly.

    OldTempList = Wow64TlsGetValue(WOW64_TLS_TEMPLIST);
    Wow64TlsSetValue(WOW64_TLS_TEMPLIST, NULL);
   
    TableNumber = (ServiceNumber >> 12) & 0xFF;
    ApiNumber = ServiceNumber & 0xFFF;

    if (TableNumber > NUMBER_SERVICE_TABLES) {
        return STATUS_INVALID_SYSTEM_SERVICE;
    }

    if (ApiNumber > ServiceTables[TableNumber].Limit) {
        return STATUS_INVALID_SYSTEM_SERVICE;
    }
    
    try {

        try {
            pfnWow64SystemService Service;

            // Synchronize the 64bit TEB with the 32bit TEB

            NtCurrentTeb()->LastErrorValue = NtCurrentTeb32()->LastErrorValue;
            Service = (pfnWow64SystemService)ServiceTables[TableNumber].Base[ApiNumber];

            if (pfnWow64LogSystemService)
            {
                ThunkLogContext.Stack32 = (PULONG)Context32->Edx;
                ThunkLogContext.TableNumber = TableNumber;
                ThunkLogContext.ServiceNumber = ApiNumber;
                ThunkLogContext.ServiceReturn = FALSE;

                (*pfnWow64LogSystemService)(&ThunkLogContext);

            }

            Result = (*Service)((PULONG)Context32->Edx);

            if (pfnWow64LogSystemService)
            {
                ThunkLogContext.ServiceReturn = TRUE;
                ThunkLogContext.ReturnResult = Result;
                (*pfnWow64LogSystemService)(&ThunkLogContext);
            }


        } except(Wow64ServiceExceptionFilter(GetExceptionInformation())) {
        
            // Return a predefined error to the application.
            Result = Wow64HandleSystemServiceError(GetExceptionCode(), TableNumber, ApiNumber);

        }
     
    } finally {

        // Synchronize the 32bit TEB with the 64bit TEB
        NtCurrentTeb32()->LastErrorValue  = NtCurrentTeb()->LastErrorValue;

        Wow64FreeTempList();

        // Restore the old templist
        Wow64TlsSetValue(WOW64_TLS_TEMPLIST, OldTempList);
     
    }

    // Indicate we're going back into the CPU now
    Wow64TlsSetValue(WOW64_TLS_INCPUSIMULATION, (PVOID)TRUE);

    return Result;
}

VOID
RunCpuSimulation(
    VOID
    )
/*++

Routine Description:

    Call the CPU to simulate 32-bit code and handle exeptions if they
    occur.

Arguments:

    None.

Return Value:

    None.  Never returns.

--*/
{
    while (1) {
        try {
            //
            // Indicate we're in the CPU now.  This controls !first in
            // the debugger.
            //
            Wow64TlsSetValue(WOW64_TLS_INCPUSIMULATION, (PVOID)TRUE);

            //
            // Go run the code.
            // Only way out of CpuSimulate() is an exception...
            //
            CpuSimulate();

        } except (Wow64DispatchExceptionTo32(GetExceptionInformation())) {
            //
            // The exception handler sets things up so we can run the
            // ia32 exception code. Thus, when it returns, we just
            // loop back and start simulating the ia32 cpu...
            //

            // Do nothing...
        }
    }

    //
    // Hey, how did that happen?
    //
    WOWASSERT(FALSE);
}

PWOW64_SYSTEM_INFORMATION
Wow64GetEmulatedSystemInformation(
     VOID
     )
{
    return &EmulatedSysInfo;
}

PWOW64_SYSTEM_INFORMATION
Wow64GetRealSystemInformation(
     VOID
     )
{
    return &RealSysInfo;
}


ULONG 
Wow64SetupApcCall(
    IN ULONG NormalRoutine,
    IN PCONTEXT32 NormalContext,
    IN ULONG Arg1,
    IN ULONG Arg2
    )
/*++

Routine Description:

    This functions initializes a APC call on the 32bit stack and sets the appropriate
    32bit context.

Arguments:

    NormalRoutine - Supplies the 32bit routine that the APC should call.

    NormalContext - Supplies a context that will be restored after
                    the APC is completed. 

    Arg1          - System argument 1.

    Arg2          - System argument 2.

Return Value:

    The address in 32bit code that execution will continue at.

--*/


{
    ULONG SP;
    PULONG Ptr;

    //
    // Build the stack frame for the Apc call.

    SP = CpuGetStackPointer();
    SP = (SP - sizeof(CONTEXT32)) & ~7; // make space for CONTEXT32 and qword-align it
    Ptr = (PULONG)SP;
    RtlCopyMemory(Ptr, NormalContext, sizeof(CONTEXT32));
    Ptr -= 4;
    Ptr[0] = NormalRoutine;              // NormalRoutine
    Ptr[1] = SP;                         // NormalContext
    Ptr[2] = Arg1;                       // SystemArgument1
    Ptr[3] = Arg2;                       // SystemArgument2
    SP = PtrToUlong(Ptr);
    CpuSetStackPointer(SP);
    CpuSetInstructionPointer(Ntdll32KiUserApcDispatcher);

    return Ntdll32KiUserApcDispatcher;    
      
}


NTSTATUS
Wow64SkipOverBreakPoint(
    IN PCLIENT_ID ClientId,
    IN PEXCEPTION_RECORD ExceptionRecord)
/*++

Routine Description:

    Changes a thread's Fir (IP) to point to the next instruction following
    the hard-coded breakpoint. Caller should guarantee that Context.Fir is
    pointing at the hardcoded breakpoint instruction.

Arguments:

    ClientId        - Client Id of the faulting thread by the bp
    ExceptionRedord - Exception record at the time of hitting the breakpoint.

Return Value:

    NTSTATUS

--*/
{
    NTSTATUS NtStatus;
    HANDLE ThreadHandle;
    OBJECT_ATTRIBUTES ObjectAttributes;
    CONTEXT Context;

    
    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0,
                               NULL,
                               NULL);

    NtStatus = NtOpenThread(&ThreadHandle,
                            (THREAD_GET_CONTEXT | THREAD_SET_CONTEXT),
                            &ObjectAttributes,
                            ClientId);

    if (NT_SUCCESS(NtStatus))
    {
        Context.ContextFlags = CONTEXT_CONTROL;
        NtStatus = NtGetContextThread(ThreadHandle,
                                      &Context);

        if (NT_SUCCESS(NtStatus))
        {
            NtStatus = Wow64pSkipContextBreakPoint(ExceptionRecord,
                                                   &Context);

            if (NT_SUCCESS(NtStatus))
            {
                NtStatus = NtSetContextThread(ThreadHandle,
                                              &Context);
            }
        }

        NtClose(ThreadHandle);
    }

    return NtStatus;
}


NTSTATUS
Wow64GetThreadSelectorEntry(
    IN HANDLE ThreadHandle,
    IN OUT PVOID DescriptorTableEntry,
    IN ULONG Length,
    OUT PULONG ReturnLength OPTIONAL)
/*++

Routine Description:

    Retreives the descriptor entry for the specified selector.

Arguments:

    ThreadHandle            - Thread handle to retreive the descriptor for
    DescriptorTableEntry    - Address of X86_DESCRIPTOR_TABLE_ENTRY
    Length                  - Specified the length of DescriptorTableEntry structure
    ReturnLength (OPTIONAL) - Returns the number of bytes returned

Return Value:

    NTSTATUS

--*/
{
    PTEB32 Teb32;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    PX86_DESCRIPTOR_TABLE_ENTRY X86DescriptorEntry = DescriptorTableEntry;

    try 
    {
        if (Length != sizeof(*X86DescriptorEntry))
        {
            return STATUS_INFO_LENGTH_MISMATCH;
        }

        switch (X86DescriptorEntry->Selector & (~(WORD)RPL_MASK))
        {
        case KGDT_NULL:
            RtlZeroMemory(&X86DescriptorEntry->Descriptor,
                          sizeof(X86DescriptorEntry->Descriptor));
            break;

#if defined(_AMD64_)
        case KGDT64_R3_CMCODE:
#elif defined(_IA64_)
        case KGDT_R3_CODE:
#else
#error "No Target Architecture"
#endif
            X86DescriptorEntry->Descriptor.LimitLow                  = 0xffff;
            X86DescriptorEntry->Descriptor.BaseLow                   = 0x0000;
            X86DescriptorEntry->Descriptor.HighWord.Bytes.BaseHi     = 0x0000;
            X86DescriptorEntry->Descriptor.HighWord.Bytes.BaseMid    = 0x00;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Type        = 0x1b;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Dpl         = 0x03;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Pres        = 0x01;
            X86DescriptorEntry->Descriptor.HighWord.Bits.LimitHi     = 0x0f;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Sys         = 0x00;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Reserved_0  = 0x00;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Default_Big = 0x01;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Granularity = 0x01;
            break;

#if defined(_AMD64_)
        case KGDT64_R3_DATA:
#elif defined(_IA64_)
        case KGDT_R3_DATA:
#else
#error "No Target Architecture"
#endif
            X86DescriptorEntry->Descriptor.LimitLow                  = 0xffff;
            X86DescriptorEntry->Descriptor.BaseLow                   = 0x0000;
            X86DescriptorEntry->Descriptor.HighWord.Bytes.BaseHi     = 0x0000;
            X86DescriptorEntry->Descriptor.HighWord.Bytes.BaseMid    = 0x00;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Type        = 0x13;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Dpl         = 0x03;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Pres        = 0x01;
            X86DescriptorEntry->Descriptor.HighWord.Bits.LimitHi     = 0x0f;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Sys         = 0x00;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Reserved_0  = 0x00;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Default_Big = 0x01;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Granularity = 0x01;
            break;

#if defined(_AMD64_)
        case KGDT64_R3_CMTEB:
#elif defined(_IA64_)
        case KGDT_R3_TEB:
#else
#error "No Target Architecture"
#endif
            Teb32 = NtCurrentTeb32();
            X86DescriptorEntry->Descriptor.LimitLow                  = 0x0fff;
            X86DescriptorEntry->Descriptor.BaseLow                   = (WORD)(PtrToUlong(Teb32) & 0xffff);
            X86DescriptorEntry->Descriptor.HighWord.Bytes.BaseHi     = (BYTE)((PtrToUlong(Teb32) >> 24) & 0xff);
            X86DescriptorEntry->Descriptor.HighWord.Bytes.BaseMid    = (BYTE)((PtrToUlong(Teb32) >> 16) & 0xff);
            X86DescriptorEntry->Descriptor.HighWord.Bits.Type        = 0x13;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Dpl         = 0x03;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Pres        = 0x01;
            X86DescriptorEntry->Descriptor.HighWord.Bits.LimitHi     = 0x00;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Sys         = 0x00;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Reserved_0  = 0x00;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Default_Big = 0x01;
            X86DescriptorEntry->Descriptor.HighWord.Bits.Granularity = 0x00;
            break;

        default:
            NtStatus = STATUS_UNSUCCESSFUL;
            break;
        }

        if (NT_SUCCESS(NtStatus))
        {
            if (ARGUMENT_PRESENT(ReturnLength))
            {
                *ReturnLength = sizeof(X86_LDT_ENTRY);
            }        
        }
    } 
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        NtStatus = GetExceptionCode();
    }

    return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64\thnkhlpr.c ===
/*++                 

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    thnkhlpr.c

Abstract:
    
    Thunk helper functions called by all thunks.

Author:

    19-Jul-1998 mzoran

Revision History:

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>                                         
#include <stdlib.h>
                                       
#include "nt32.h"
#include "wow64p.h"
#include "thnkhlpr.h"
ASSERTNAME;  

const UNICODE_STRING KnownDlls64 = {20, 20, L"\\KnownDlls"};
const UNICODE_STRING KnownDlls32 = {24, 24, L"\\KnownDlls32"};


//
// Array of directories to disable redirection for. The directory path is relative 
// to %windir%\system32
//

const PATH_REDIRECT_EXEMPT PathRediectExempt[] =
{
    // %windir%\system32\drivers\etc
    {L"\\drivers\\etc", ((sizeof(L"\\drivers\\etc")/sizeof(WCHAR)) - 1), FALSE} ,

    // %windir%\system32\spool
    {L"\\spool", ((sizeof(L"\\spool")/sizeof(WCHAR)) - 1), FALSE} ,

    // %windir%\system32\catroot
    {L"\\catroot", ((sizeof(L"\\catroot")/sizeof(WCHAR)) - 1), FALSE} ,

    // %windir%\system32\catroot2
    {L"\\catroot2", ((sizeof(L"\\catroot2")/sizeof(WCHAR)) - 1), FALSE} ,

};


VOID
RedirectObjectName(
    POBJECT_ATTRIBUTES Obj
    )
/*++

Routine Description:

    This function is called from any thunk with an IN POBJECT_ATTRIBUTES.
    The ObjectName field is redirected if it appears to point into the
    native system directory.

    The new name is allocated with Wow64AllocateTemp.
    
    An exception is thrown if an error occures.

Arguments:

    Obj - already-thunked 64-bit POBJECT_PARAMETERS.

Return Value:

    None

--*/
{
    PUNICODE_STRING Name;
    PUNICODE_STRING NewName;
    NTSTATUS st;
    PFILE_NAME_INFORMATION NameInformation;
    LONG Result;
    USHORT OriginalLength;
    PWCHAR RelativePath;
    ULONG Index;
    INT CompareResult;
    LPWSTR RedirDisableFilename, Temp;
    USHORT NewNameLength;
    BOOLEAN CaseInsensitive;
    BOOLEAN RedirectFile;
    UNICODE_STRING DisableFilename;
    PEB32 *pPeb32;
    NT32RTL_USER_PROCESS_PARAMETERS *pParams32;
    NT32CURDIR *pCurDir32;


    if (!Obj || !Obj->ObjectName) {
        
        //
        // No object, no name, or length is too short to hold Unicode "system32"
        //
        return;
    }

    Name = Obj->ObjectName;
    if (RtlEqualUnicodeString(Name, 
                              &KnownDlls64,
                              (Obj->Attributes & OBJ_CASE_INSENSITIVE) ? TRUE : FALSE)) {
        // Map KnownDlls to KnownDlls32
        Obj->ObjectName = (PUNICODE_STRING)&KnownDlls32;
        LOGPRINT((TRACELOG, "Redirected object name is now %wZ.\n", Obj->ObjectName));
        return;
    }

    if (Obj->RootDirectory) {
        
        //
        // Need to fully qualify the object name, since part is a handle and
        // part is a path string.
        //

        pPeb32 = NtCurrentPeb32();
        pParams32=(NT32RTL_USER_PROCESS_PARAMETERS*)pPeb32->ProcessParameters;
        pCurDir32 = (NT32CURDIR*)&pParams32->CurrentDirectory;

        if (pCurDir32->Handle == HandleToLong(Obj->RootDirectory)) {
            //
            // The object is relative to the process current directory
            //
            ULONG Length;
            UNICODE_STRING CurDirDosPath;

            Wow64ShallowThunkUnicodeString32TO64(&CurDirDosPath, &pCurDir32->DosPath);
            // Allocate space for the name, plus space for "\\??\\"
            Length = 8+CurDirDosPath.Length+Obj->ObjectName->Length;
            Name = Wow64AllocateTemp(sizeof(UNICODE_STRING)+Length);
            Name->Buffer = (LPWSTR)(Name+1);
            Name->MaximumLength = (USHORT)Length;
            Name->Length = 8;
            wcscpy(Name->Buffer, L"\\??\\");
            st = RtlAppendUnicodeStringToString(Name, &CurDirDosPath);
            if(!NT_SUCCESS(st)) {
                LOGPRINT((ERRORLOG, "RedirectObjectName: RtlAppendUnicodeToString failed, error %x\n", st));
                return;
            }
            st = RtlAppendUnicodeStringToString(Name, Obj->ObjectName);
            if(!NT_SUCCESS(st)) {
                LOGPRINT((ERRORLOG, "RedirectObjectName: RtlAppendUnicodeToString failed, error %x\n", st));
                return;
            }
        } else {
            //
            // Not the process current directory handle, so work it out the
            // hard way.
            //
            ULONG Length;
            IO_STATUS_BLOCK iosb;

            //
            // Allocate a buffer big enough for the biggest filename plus a null
            // terminator for the end (which we add later, if the API call
            // succeeds).
            //
            Length = sizeof(FILE_NAME_INFORMATION)+(MAXIMUM_FILENAME_LENGTH+1)*sizeof(WCHAR);

            NameInformation = Wow64AllocateTemp(Length);
            st = NtQueryInformationFile(Obj->RootDirectory,
                                        &iosb,
                                        NameInformation,
                                        Length,
                                        FileNameInformation);
            if (!NT_SUCCESS(st)) {
                // The handle is bad - don't try to redirect the filename part.
                return;
            }

            // null-terminate the filename
            NameInformation->FileName[NameInformation->FileNameLength / sizeof(WCHAR)] = L'\0';

            if (wcsncmp(NameInformation->FileName, L"\\??\\", 4) != 0) {
                // The name doesn't point to a file/directory, so no need
                // to redirect.
                return;
            }

            Name = Wow64AllocateTemp(sizeof(UNICODE_STRING));
            Name->Buffer = NameInformation->FileName;
            Name->Length = (USHORT)NameInformation->FileNameLength;
            Name->MaximumLength = MAXIMUM_FILENAME_LENGTH*sizeof(WCHAR);
            st = RtlAppendUnicodeStringToString(Name, Obj->ObjectName);
            if(!NT_SUCCESS(st)) {
                LOGPRINT((ERRORLOG, "RedirectObjectName: RtlAppendUnicodeToString failed, error %x\n", st));
                return;
            }
        }
    }


    CaseInsensitive = (Obj->Attributes & OBJ_CASE_INSENSITIVE) ? TRUE : FALSE;

    RedirDisableFilename = (LPWSTR)Wow64TlsGetValue(WOW64_TLS_FILESYSREDIR);

    if (RedirDisableFilename) {
        
        //
        // If this a redirect all setting, then this is not a file name all redirection should
        // be disabled at this point.
        //

        if (RedirDisableFilename == WOW64_FILE_SYSTEM_DISABLE_REDIRECT) {
            return;
        }

        if (wcscmp (RedirDisableFilename, WOW64_FILE_SYSTEM_DISABLE_REDIRECT_LEGACY) == 0) {
            return;
        }
        
        //
        // The caller has asked that the filesystem redirector be disabled
        // for a particular filename.
        //        

        if (RtlDosPathNameToNtPathName_U(RedirDisableFilename, &DisableFilename, NULL, NULL)) {
            // If the call fails, then don't try to disable redirection for it.
            // The failure may be out-of-memory, or it may be an invalid filename.
            Result = RtlCompareUnicodeString(Name, &DisableFilename, CaseInsensitive);
            LOGPRINT((TRACELOG, "Filesystem redirection disabled for %wZ : ", &DisableFilename));
            RtlFreeHeap (RtlProcessHeap (), 0, DisableFilename.Buffer);
            if (Result == 0) {
                LOGPRINT((TRACELOG, "Operation succeeded\n"));
                return;
            }
            LOGPRINT((TRACELOG, "Operation failed\n"));
        }
    }

    if (Name->Length >= NtSystem32Path.Length) {
        
        // Compare the strings, but force the lengths to be equal,
        // as RtlCompareUnicodeString returns the difference in length
        // if the strings are otherwise identical.
        OriginalLength = Name->Length;
        Name->Length = NtSystem32Path.Length;
        Result = RtlCompareUnicodeString(Name, &NtSystem32Path, CaseInsensitive);
        Name->Length = OriginalLength;
        if (Result == 0) {
        
            //
            // Make sure that the directory isn't part of our exception-list
            //
            RelativePath = (PWCHAR)((PCHAR)Name->Buffer + NtSystem32Path.Length);
            if (RelativePath[0] != UNICODE_NULL) {
                for (Index=0 ; Index < (sizeof(PathRediectExempt)/sizeof(PathRediectExempt[0])) ; Index++) {
                    CompareResult = _wcsnicmp(RelativePath, 
                                              PathRediectExempt[Index].Path, 
                                              PathRediectExempt[Index].CharCount);
                    if (CompareResult == 0) {
                        if ((PathRediectExempt[Index].ThisDirOnly == FALSE) ||
                            (wcschr(RelativePath+(PathRediectExempt[Index].CharCount+1), L'\\') == NULL)) {
                            return;
                        }
                    }
                }
            }

            //
            // Map system32 to syswow64
            //

            // Make a copy of the original string
            NewName = Wow64AllocateTemp(sizeof(UNICODE_STRING)+Name->MaximumLength);
            NewName->Length = Name->Length;
            NewName->MaximumLength = Name->MaximumLength;
            NewName->Buffer = (PWSTR)(NewName+1);
            RtlCopyMemory(NewName->Buffer, Name->Buffer, Name->MaximumLength);

            // Replace System32 by SysWow64
            RtlCopyMemory(&NewName->Buffer[(NtSystem32Path.Length - WOW64_SYSTEM_DIRECTORY_U_SIZE) / 2],
                          WOW64_SYSTEM_DIRECTORY_U,
                          WOW64_SYSTEM_DIRECTORY_U_SIZE);

            // Update the OBJECT_ATTRIBUTES.  Clear the RootDirectory handle
            // as the pathname is now fully-qualified.
            Obj->ObjectName = NewName;
            Obj->RootDirectory = NULL;
            LOGPRINT((TRACELOG, "Redirected object name is now %wZ.\n", Obj->ObjectName));
            return;
        }
    }

    //
    // Remap LastGood path
    //
    if (Name->Length >= NtSystem32LastGoodPath.Length) {
        
        // Compare the strings, but force the lengths to be equal,
        // as RtlCompareUnicodeString returns the difference in length
        // if the strings are otherwise identical.
        OriginalLength = Name->Length;
        Name->Length = NtSystem32LastGoodPath.Length;
        Result = RtlCompareUnicodeString(Name, &NtSystem32LastGoodPath, CaseInsensitive);
        Name->Length = OriginalLength;
        if (Result == 0) {
        
            //
            // Map system32 to syswow64
            //

            // Make a copy of the original string
            NewName = Wow64AllocateTemp(sizeof(UNICODE_STRING)+Name->MaximumLength);
            NewName->Length = Name->Length;
            NewName->MaximumLength = Name->MaximumLength;
            NewName->Buffer = (PWSTR)(NewName+1);
            RtlCopyMemory(NewName->Buffer, Name->Buffer, Name->MaximumLength);

            // Replace System32 by SysWow64
            RtlCopyMemory(&NewName->Buffer[(NtSystem32LastGoodPath.Length - WOW64_SYSTEM_DIRECTORY_U_SIZE) / 2],
                          WOW64_SYSTEM_DIRECTORY_U,
                          WOW64_SYSTEM_DIRECTORY_U_SIZE);

            // Update the OBJECT_ATTRIBUTES.  Clear the RootDirectory handle
            // as the pathname is now fully-qualified.
            Obj->ObjectName = NewName;
            Obj->RootDirectory = NULL;
            LOGPRINT((TRACELOG, "Redirected object name is now %wZ.\n", Obj->ObjectName));
            return;
        }
    }


    if (Name->Length >= NtWindowsImePath.Length) {
        
        // Check if the name is %systemroot%\ime
        OriginalLength = Name->Length;
        Name->Length = NtWindowsImePath.Length;
        Result = RtlCompareUnicodeString(Name,
                                         &NtWindowsImePath,
                                         CaseInsensitive);
        Name->Length = OriginalLength;

        if (Result == 0) {
            
            // Map to %windir%\ime to %windir%\ime (x86).
        
            RedirectFile = TRUE;
            if (Name->Length > NtWindowsImePath.Length) {
                if ((*(PWCHAR)((PCHAR)Name->Buffer + NtWindowsImePath.Length)) != L'\\') {
                    RedirectFile = FALSE;
                } else {
                    
                    if ((Name->Length >= (NtWindowsImePath.Length + sizeof (WOW64_X86_TAG_U) - sizeof (UNICODE_NULL))) &&
                        (_wcsnicmp((PWCHAR)((PCHAR)Name->Buffer + NtWindowsImePath.Length), WOW64_X86_TAG_U, (sizeof(WOW64_X86_TAG_U) - sizeof(UNICODE_NULL))/sizeof(WCHAR)) != 0)) {
                        RedirectFile = FALSE;
                    }
                }
            }

            if (RedirectFile == TRUE) {

                NewNameLength = Name->Length+sizeof(WOW64_X86_TAG_U);
                NewName = Wow64AllocateTemp(sizeof(UNICODE_STRING)+NewNameLength);
                NewName->Length = (USHORT)NewNameLength-sizeof(UNICODE_NULL);
                NewName->MaximumLength = NewNameLength;
                NewName->Buffer = (PWSTR)(NewName+1);

                Temp = NewName->Buffer;
                RtlCopyMemory(Temp, Name->Buffer, NtWindowsImePath.Length);
                Temp = (PWCHAR)((PCHAR)Temp + NtWindowsImePath.Length);
        
                RtlCopyMemory(Temp, WOW64_X86_TAG_U, sizeof(WOW64_X86_TAG_U) - sizeof(UNICODE_NULL));
                Temp = (PWCHAR)((PCHAR)Temp + (sizeof(WOW64_X86_TAG_U) - sizeof(UNICODE_NULL)));

                RtlCopyMemory(Temp, ((PCHAR)Name->Buffer + NtWindowsImePath.Length) , Name->Length - NtWindowsImePath.Length);
    
                Obj->ObjectName = NewName;
                Obj->RootDirectory = NULL;
        
                LOGPRINT((TRACELOG, "Redirected object name is now %wZ.\n", Obj->ObjectName));
            }
            return;
        }
    }

    if (Name->Length >= RegeditPath.Length) {
        
        //
        // Check if the name is %systemroot%\regedit.exe
        //

        Result = RtlCompareUnicodeString(Name,
                                         &RegeditPath, 
                                         (Obj->Attributes & OBJ_CASE_INSENSITIVE) ? TRUE : FALSE);
        if (Result == 0) {
            
            // Map to %windir%\syswow64\regedit.exe.  Allocate enough space
            // for the UNICODE_STRING plus "\??\%systemroot%\syswow64\regedit.exe"
            // The memory allocation contains a terminating NULL character, but the
            // Unicode string's Length does not.
            SIZE_T SystemRootLength = wcslen(USER_SHARED_DATA->NtSystemRoot);
            SIZE_T NameLength = sizeof(L"\\??\\")-sizeof(WCHAR) +
                                SystemRootLength*sizeof(WCHAR) +
                                sizeof(L'\\') +
                                sizeof(WOW64_SYSTEM_DIRECTORY_U)-sizeof(WCHAR) +
                                sizeof(L"\\regedit.exe");
            NewName = Wow64AllocateTemp(sizeof(UNICODE_STRING)+NameLength);
            NewName->Length = (USHORT)NameLength-sizeof(WCHAR);
            NewName->MaximumLength = NewName->Length;
            NewName->Buffer = (PWSTR)(NewName+1);
            wcscpy(NewName->Buffer, L"\\??\\");
            wcscpy(&NewName->Buffer[4], USER_SHARED_DATA->NtSystemRoot);
            NewName->Buffer[4+SystemRootLength] = '\\';
            wcscpy(&NewName->Buffer[4+SystemRootLength+1], WOW64_SYSTEM_DIRECTORY_U);
            wcscpy(&NewName->Buffer[4+SystemRootLength+1+(sizeof(WOW64_SYSTEM_DIRECTORY_U)-sizeof (UNICODE_NULL))/sizeof(WCHAR)], L"\\regedit.exe");
            Obj->ObjectName = NewName;
            Obj->RootDirectory = NULL;
            LOGPRINT((TRACELOG, "Redirected object name is now %wZ.\n", Obj->ObjectName));
            return;
        }
    }
}

VOID
Wow64RedirectFileName(
    IN OUT WCHAR *Name,
    IN OUT ULONG *Length
    )
/*++

Routine Description:

    This function is called to thunk a filename/length pair.
    
    An exception is thrown if an error occures.

Arguments:

    Name    - IN OUT UNICODE filename to thunk
    Length  - IN OUT pointer to filename length.
    

Return Value:

    None.  Contents of the Name and Length may be updated

--*/
{
    OBJECT_ATTRIBUTES Obj;
    UNICODE_STRING Ustr;

    if (*Length >= 0xffff) {
        RtlRaiseStatus(STATUS_INVALID_PARAMETER);
    }
    Ustr.Length = Ustr.MaximumLength = (USHORT)*Length;
    Ustr.Buffer = Name;

    InitializeObjectAttributes(&Obj,
                               &Ustr,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    RedirectObjectName(&Obj);
    if (Obj.ObjectName != &Ustr) {
        // RedirectObjectName actually changed the name.  Copy it back
        *Length = Obj.ObjectName->Length;
        RtlCopyMemory(Name, Obj.ObjectName->Buffer, Obj.ObjectName->Length);
    }
}

PUNICODE_STRING
Wow64ShallowThunkAllocUnicodeString32TO64_FNC(
    IN NT32UNICODE_STRING *src
    )

/*++

Routine Description:

    This function allocates a new UNICODE_STRING by calling Wow64AllocateTemp 
    and thunks the source to the new string.
    
    The mimimum amount of data is copied.
    
    An exception is thrown on a error.
    
Arguments:

    src - Ptr to the 32 bit string to be thunked.
    
Return Value:

    Ptr to the newly allocated 64 bit string.

--*/


{
   PUNICODE_STRING dst;

   if (src == NULL) {
      return NULL;
   }

   dst = Wow64AllocateTemp(sizeof(UNICODE_STRING));

   dst->Length = src->Length;
   dst->MaximumLength = src->MaximumLength;
   dst->Buffer = UlongToPtr (src->Buffer);

   return dst;
}

PSECURITY_DESCRIPTOR
Wow64ShallowThunkAllocSecurityDescriptor32TO64_FNC(
    IN NT32SECURITY_DESCRIPTOR *src
    )

/*++
                                     
Routine Description:

    This function allocates a new SECURITY_DESCRIPTOR by calling Wow64AllocateTemp and 
    thunks the source to the new structure.
    
    The minimum amount of data is copied.
    
    An exception is thrown on a error.
    
Arguments:

    src - Ptr to the 32 bit SECURITY_DESCRIPTOR to be thunked.
    
Return Value:

    Ptr to the newly allocated 64 bit SECURITY_DESCRIPTOR.
--*/


{

   SECURITY_DESCRIPTOR *dst;

   if (src == NULL) {
      return NULL;
   }

   if (src->Control & SE_SELF_RELATIVE) {
      // The security descriptor is self relative(no pointers).
      return (PSECURITY_DESCRIPTOR)src;
   }

   dst = Wow64AllocateTemp(sizeof(SECURITY_DESCRIPTOR));

   dst->Revision = src->Revision;
   dst->Sbz1 = src->Sbz1;
   dst->Control = (SECURITY_DESCRIPTOR_CONTROL)src->Control;
   dst->Owner = (PSID)src->Owner;
   dst->Group = (PSID)src->Group;
   dst->Sacl = (PACL)src->Sacl;
   dst->Dacl = (PACL)src->Dacl;

   return (PSECURITY_DESCRIPTOR)dst;
}
    
PSECURITY_TOKEN_PROXY_DATA
Wow64ShallowThunkAllocSecurityTokenProxyData32TO64_FNC(
    IN NT32SECURITY_TOKEN_PROXY_DATA *src
    )
/*++

Routine Description:

    This function allocates a new SECURITY_TOKEN_PRXY_DATA by calling Wow64AllocateTemp and 
    thunks the source to the new structure.
    
    The minimum amount of data is copied.
    
    An exception is thrown on a error.
    
Arguments:

    src - Ptr to the 32 bit SECURITY_TOKEN_PROXY_DATA to be thunked.
    
Return Value:

    Ptr to the newly allocated 64 bit SECURITY_TOKEN_PROXY_DATA.

--*/
{
   SECURITY_TOKEN_PROXY_DATA *dst;

   if (NULL == src) {
      return NULL;
   }

   if (src->Length != sizeof(NT32SECURITY_TOKEN_PROXY_DATA)) {
      RtlRaiseStatus(STATUS_INVALID_PARAMETER);
   }

   dst = Wow64AllocateTemp(sizeof(SECURITY_TOKEN_PROXY_DATA));

   dst->Length = sizeof(SECURITY_TOKEN_PROXY_DATA);
   dst->ProxyClass = src->ProxyClass;
   Wow64ShallowThunkUnicodeString32TO64(&(dst->PathInfo), &(src->PathInfo));
   dst->ContainerMask = src->ContainerMask;
   dst->ObjectMask = src->ObjectMask;

   return (PSECURITY_TOKEN_PROXY_DATA)dst;
}


NTSTATUS
Wow64ShallowThunkAllocSecurityQualityOfService32TO64_FNC(
    IN NT32SECURITY_QUALITY_OF_SERVICE *src,
    IN OUT PSECURITY_QUALITY_OF_SERVICE *dst
    )
/*++

Routine Description:

    This function allocates a new SECURITY_QUALITY_OF_SERVICE by calling Wow64AllocateTemp and 
    thunks the source to the new structure.
    
    The minimum amount of data is copied.
    
    An exception is thrown on a error.
    
Arguments:

    src - Ptr to the 32 bit SECURITY_TOKEN_PROXY_DATA to be thunked.
    
    dst - Ptr to ptr to the 64-bit (thunked) QoS.
    
Return Value:

    NTSTATUS.

--*/

{

    NTSTATUS NtStatus = STATUS_SUCCESS;
    ULONG QoSLength;


    if (src != NULL) {
        
        try {
            if (src->Length == sizeof (SECURITY_ADVANCED_QUALITY_OF_SERVICE)) {            
                *dst = Wow64AllocateTemp (sizeof(SECURITY_ADVANCED_QUALITY_OF_SERVICE));
                QoSLength = sizeof (SECURITY_ADVANCED_QUALITY_OF_SERVICE);
            } else {
            
                // if the size isn't right for an advanced QOS struct, assume it's
                // a regular QOS struct.  Many callers don't set the Length field
                // like LsaConnectUntrusted in lsa\security\client\austub.c
       
                *dst = Wow64AllocateTemp (sizeof(SECURITY_QUALITY_OF_SERVICE));
                QoSLength = sizeof (SECURITY_QUALITY_OF_SERVICE);
            }
        
            if (*dst != NULL) {
                
                (*dst)->Length = QoSLength;
                (*dst)->ImpersonationLevel = (SECURITY_IMPERSONATION_LEVEL)src->ImpersonationLevel;
                (*dst)->ContextTrackingMode = (SECURITY_CONTEXT_TRACKING_MODE)src->ContextTrackingMode;
                (*dst)->EffectiveOnly = src->EffectiveOnly;

                if (src->Length == sizeof (NT32SECURITY_ADVANCED_QUALITY_OF_SERVICE)) {
            
                    SECURITY_ADVANCED_QUALITY_OF_SERVICE *altdst = (SECURITY_ADVANCED_QUALITY_OF_SERVICE *)*dst;
                    NT32SECURITY_ADVANCED_QUALITY_OF_SERVICE *altsrc = (NT32SECURITY_ADVANCED_QUALITY_OF_SERVICE *)src;

                    altdst->ProxyData = Wow64ShallowThunkAllocSecurityTokenProxyData32TO64(altsrc->ProxyData);
                    altdst->AuditData = (PSECURITY_TOKEN_AUDIT_DATA)altsrc->AuditData;
                }
            } else {
                NtStatus = STATUS_NO_MEMORY;
            }

        } except (EXCEPTION_EXECUTE_HANDLER) {
            NtStatus = GetExceptionCode ();
        }
    } else {
        *dst = NULL;
    }

    return NtStatus;
    
}

NTSTATUS
Wow64ShallowThunkAllocObjectAttributes32TO64_FNC(
    IN NT32OBJECT_ATTRIBUTES *src,
    IN OUT POBJECT_ATTRIBUTES *dst
    )

/*++

Routine Description:

    This function allocates a new OBJECT_ATTRIBUTES by calling Wow64AllocateTemp and 
    thunks the source to the new structure.
    
    The minimum amount of data is copied.
    
    An exception is thrown on a error.
    
Arguments:

    src - Ptr to the 32 bit OBJECT_ATTRIBUTES to be thunked.
    
    dst - Ptr to ptr to the 64-bit (thunked) object attributes.
    
Return Value:

    NTSTATUS.

--*/

{
    NTSTATUS NtStatus = STATUS_SUCCESS;

    *dst = NULL;

    if (NULL != src) {

        //
        // Validate the object attribute as readable.
        //
        try {

            if(src->Length == sizeof(NT32OBJECT_ATTRIBUTES)) {
               
                *dst = Wow64AllocateTemp(sizeof(OBJECT_ATTRIBUTES));

                (*dst)->Length = sizeof(OBJECT_ATTRIBUTES);
                (*dst)->RootDirectory = (HANDLE)src->RootDirectory;
                (*dst)->ObjectName = Wow64ShallowThunkAllocUnicodeString32TO64(src->ObjectName);
                (*dst)->Attributes = src->Attributes;
                (*dst)->SecurityDescriptor = Wow64ShallowThunkAllocSecurityDescriptor32TO64(src->SecurityDescriptor);
                
                NtStatus = Wow64ShallowThunkAllocSecurityQualityOfService32TO64(src->SecurityQualityOfService, (PSECURITY_QUALITY_OF_SERVICE *)&(*dst)->SecurityQualityOfService);
   
                if (NT_SUCCESS (NtStatus)) {
                    RedirectObjectName(*dst);
                }

            } else {
               
                NtStatus = STATUS_INVALID_PARAMETER;
            }
        } except (EXCEPTION_EXECUTE_HANDLER) {
            
            NtStatus = GetExceptionCode ();
        }
    }

    return NtStatus;

}

NT32SIZE_T*
Wow64ShallowThunkSIZE_T64TO32(
    OUT NT32SIZE_T* dst,
    IN PSIZE_T src OPTIONAL
    )
/*++

Routine Description:

    This function converts a 64bit SIZE_T to a 32bit SIZE_T. 
    The result is saturated to 0xFFFFFFFF instead of truncating.
    
Arguments:

    src - Supplies the 64 bit SIZE_T to be thunked.
    dst - Receives the 32 bi SIZE_T.
    
Return Value:

    The value of dst.

--*/
{
    if (!src) {
       return (NT32SIZE_T*)src;
    }
    *dst = (NT32SIZE_T)min(*src,0xFFFFFFFF);  //saturate
    return dst;
}

PSIZE_T
Wow64ShallowThunkSIZE_T32TO64(
    OUT PSIZE_T dst,
    IN NT32SIZE_T *src OPTIONAL
    )
/*++

Routine Description:

    This function converts a 32bit SIZE_T to a 64bit SIZE_T. 
    The 64bit value is a zero extension of the 32bit value.
    
Arguments:

    src - Supplies the 64 bit SIZE_T to be thunked.
    dst - Receives the 32 bit SIZE_T.
    
Return Value:

    The value of dst.

--*/
{
   if (!src) {
      return (PSIZE_T)src;
   }

   try {
       *dst = (SIZE_T)*src; //zero extend
   } except (EXCEPTION_EXECUTE_HANDLER) {
       dst = NULL;
   }
   return dst;
}

ULONG 
Wow64ThunkAffinityMask64TO32(
    IN ULONG_PTR Affinity64
    )
/*++

Routine Description:

    This function converts a 64bit AffinityMask into a 32bit mask. 
    
Arguments:

    Affinity64 - Supplies the 64bit affinity mask.
    
Return Value:

    The converted 32bit affinity mask.

--*/
{

    // Create a 32bit affinity mask by ORing the top 32bits with the bottom 32bits.
    // Some care needs to be taken since the following is not always true:
    // Affinity32 == Wow64ThunkAffinityMask32TO64(Wow64ThunkAffinityMask64To32(Affinity32))

    return (ULONG)( (Affinity64 & 0xFFFFFFFF) | ( (Affinity64 & (0xFFFFFFFF << 32) ) >> 32) );
}

ULONG_PTR
Wow64ThunkAffinityMask32TO64(
    IN ULONG Affinity32
    )
/*++

Routine Description:

    This function converts a 32bit AffinityMask into a 64bit mask. 
    
Arguments:

    Affinity32 - Supplies the 32bit affinity mask.
    
Return Value:

    The converted 64bit affinity mask.

--*/
{
    return (ULONG_PTR)Affinity32;
}

VOID
WriteReturnLengthSilent(
    PULONG ReturnLength,
    ULONG Length
    )
/*++

Routine Description:

    Helper that writes back to a 32-bit ReturnLength parameter
    and silently ignores any faults that may occur.
    
Arguments:

    ReturnLength    - pointer to write the 32-bit return length to
    Length          - value to write
    
Return Value:

    None.  ReturnLength may not be updated if an exception occurs.

--*/
{
    if (!ReturnLength) {
        return;
    }
    try {
        *ReturnLength = Length;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        // do nothing
    }
}


VOID
WriteReturnLengthStatus(
    PULONG ReturnLength,
    NTSTATUS *pStatus,
    ULONG Length
    )
/*++

Routine Description:

    Helper that writes back to a 32-bit ReturnLength parameter
    and ignores any faults that may occur.  If a fault occurs,
    the write may not happen, but *pStatus will be updated.
    
Arguments:

    ReturnLength    - pointer to write the 32-bit return length to
    pStatus         - IN OUT pointer to the NTSTATUS
    Length          - value to write
    
Return Value:

    None.  ReturnLength may not be updated if an exception occurs.

--*/
{
    if (!ReturnLength) {
        return;
    }
    try {
        *ReturnLength = Length;
    } except (EXCEPTION_EXECUTE_HANDLER) {
        *pStatus = GetExceptionCode();
    }
}


BOOLEAN
Wow64IsModule32bitHelper(
    HANDLE ProcessHandle,
    IN ULONG64 DllBase)
/*++

Routine Description:
    This is a helper routine to be called from Wow64IsModule32bit
    
Arguments:

    ProcessHandle   - The handle of the process within which the module is in
    DllBase         - Base Address of the Dll being loaded

Return Value:

    BOOLEAN         - TRUE if Module at Dllbase is 32bit, FALSE otherwise

--*/

{

    PIMAGE_NT_HEADERS NtHeaders;
    PIMAGE_DOS_HEADER DosHeader;
    BYTE Temp [PAGE_SIZE_X86NT];
    SIZE_T Size;    
    NTSTATUS NtStatus;
    BOOLEAN Module32Bit;


    //
    // Default answer is 32-bit
    //

    Module32Bit = TRUE;
    NtHeaders = NULL;

    //
    // read in the first 8k of the image
    //

    NtStatus = NtReadVirtualMemory (ProcessHandle,
                                    (PVOID)DllBase,
                                    Temp,
                                    sizeof (Temp),
                                    &Size);
    
    if (NT_SUCCESS (NtStatus)) {
		
        DosHeader = (PIMAGE_DOS_HEADER)Temp;
        
        if (((ULONG)DosHeader->e_lfanew + sizeof(IMAGE_NT_HEADERS)) <=sizeof (Temp)) {
            NtHeaders = (PIMAGE_NT_HEADERS)((PUCHAR)Temp + (ULONG)DosHeader->e_lfanew);

        } else if (DosHeader->e_magic == IMAGE_DOS_SIGNATURE) {
		    
            //
            // the image header is outside the 1st 4K. Lets read in the next 4K.
            // Read the IMAGE_NT_HEADERS from whereever it is within the image
            //
   
                NtStatus = NtReadVirtualMemory(
                    ProcessHandle,
                    (PVOID)(DllBase + (ULONG)DosHeader->e_lfanew),
                    Temp,
                    sizeof (IMAGE_NT_HEADERS),
                    &Size);

                //
                // Verify signature on the image. 
                //

                if (NT_SUCCESS(NtStatus) && Size == sizeof (IMAGE_NT_HEADERS)) {		       
                    NtHeaders = (IMAGE_NT_HEADERS *)Temp;
                }
        } 
    }

    //
    // Check if the image is 32-bit or 64-bit
    //

    if (NtHeaders != NULL) {
        Module32Bit = (NtHeaders->FileHeader.Machine == IMAGE_FILE_MACHINE_I386 
            && NtHeaders->Signature == IMAGE_NT_SIGNATURE );  //askhalid: need to check Header signature as well
    }

    return Module32Bit;
}


    
BOOLEAN
Wow64IsModule32bit(
    IN PCLIENT_ID ClientId,
    IN ULONG64 DllBase)
/*++

Routine Description:
    This function looks at the Image header of the module at 
    DllBase and returns TRUE if the module is 32-bit
    
Arguments:

    ClientId        - Client Id of the faulting thread by the bp
    DllBase         - Base Address of the Dll being loaded

Return Value:

    BOOLEAN         - TRUE if Module at Dllbase is 32bit, FALSE otherwise

--*/
{
    NTSTATUS NtStatus;
    HANDLE ProcessHandle;
    BOOLEAN RetVal;
    OBJECT_ATTRIBUTES ObjectAttributes;
    
    
    InitializeObjectAttributes(&ObjectAttributes,
                               NULL,
                               0,
                               NULL,
                               NULL);

    NtStatus = NtOpenProcess(&ProcessHandle,
                             PROCESS_VM_READ,
                             &ObjectAttributes,
                             ClientId);

    RetVal = TRUE;
    if (NT_SUCCESS (NtStatus)) {
        
        RetVal = Wow64IsModule32bitHelper(ProcessHandle, DllBase);
        NtClose(ProcessHandle);
    }

    return RetVal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64\ia64\call32.s ===
//
//
// Copyright (c) 1998-2000  Microsoft Corporation
//
// Module Name:
//
//    call32.s
//
// Abstract:
//
//    This module implements calls from 64-bit code to 32-bit.
//
// Author:
//
//    01-June-1998 Barrybo, Created
//
// Revision History:
//
//--
#include "ksia64.h"

.file   "call32.s"

// This is the offset of the cDispatch field in a CALLBACKFRAGMENT
#define cDispatch       16

//
// Globals imported
//
        .global __imp_CpuResetToConsistentState
        .global __imp_RtlCopyMemory

        NESTED_ENTRY(Wow64PrepareForException)
// called with:
//
//  s0 = ptr to IA64 exception record
//  s1 = ptr to IA64 context record
//
// returns with:
//  none.  stack pointer will be switched to 64-bit stack
//
// This routine needs to make sure all the excpetion stuff is properly
// located on the ia64 stack so the ia64 excpetion handling code
// can do the right thing. Since an exception can happen while running ia32
// code, the excpetion information may be on the ia32 stack instead. Since
// the OS has gone through a lot of work to put it there, we just want to
// copy it (in its entirety) onto the ia64 stack and then update the ia64
// stack pointers appropriately
//
        NESTED_SETUP(0, 5, 3, 0)        // 5 locals, 3 out arg,
                                        // pfs saved in loc0, brp in loc1
        mov loc2 = gp                   // save gp
        PROLOGUE_END

        //
        // Did the exception happen on the ia32 or ia64 stack?
        // The answer is based on the value in TLS (WOW64_TLS_STACKPTR64).
        //
        add     t2 = TeDeallocationStack+8, teb     // Get the TLS address
        ;;

        ld8     t3 = [t2]               // Get WOW64_TLS_STACKPTR64 value
        ;;

        cmp.eq  pt0 = t3, r0            // Was WOW64_TLS_STACKPTR64 zero?
        ;;
        
  (pt0) br.cond.dpnt.few OnIa64Stk      // zero means already on ia64 stack

        //
        // Woops, on the ia32 stack 
        // So, the kernel did a lot of work to put everything it needs on
        // the ia32 stack. So let's copy everything it has done
        // onto the ia64 stack...

        mov     loc4 = sp               // Save the current ia32 sp
        adds    t4 = CxIntSp, s1        // Offset into cntx record for sp
        ;;

        ld8     t2 = [t4]               // Get the ia32 ptr before exception       
        ;;

        sub     t5 = t2, loc4           // Size of exception on ia32 stack
                                        // Remember stack grows down...
        ;;

        sub     loc3 = t3, t5           // Create the same space on ia64 stack
        mov     t6 = 0xf
    
        ;;
        andcm   loc3 = loc3, t6           // start on 16 byte boundaries

        ;;
        add     sp = -10, loc3          // Make ia64 calls on ia64 stack

        mov     out0 = loc3             // Copy to ia64 stack area
        mov     out1 = loc4             // Copy from ia32 stack area
        mov     out2 = t5               // Copy size of exception area

        //
        // call RtlMoveMemory
        //
        add     t1 = @gprel(__imp_RtlCopyMemory), gp
        ;;
        ld8     t1 = [t1]                   // Become a pointer to the plabel
        ;;
        ld8     t2 = [t1], PlGlobalPointer - PlEntryPoint   // Get entry point
        ;;
        ld8     gp = [t1]                   // Get the GP
        mov     bt0 = t2
        ;;
        br.call.sptk.many brp = bt0

        mov     gp = loc2

        //
        // Ok, everything has been copied over... Now update s0 and s1 with
        // the new values on the ia64 stack
        //
        sub     t3 = s0, loc4           // find exceptn frame in ia32 stack
        sub     t4 = s1, loc4           // find context frame in ia32 stack
        ;;

        add     s0 = t3, loc3           // Set exception frame in ia64 stack
        add     s1 = t4, loc3           // Set context frame in ia64 stack
        mov     sp = loc3               // and reset ia64 SP
        ;;

OnIa64Stk:
        //
        // Now, we know sp is an ia64 stack, so put the exception pointers
        // on the stack so we can make a call
        //
        add     t0 = -0x10, sp          // allocate some space from the stack
        add     t3 = -0x10, sp          // keep a copy
        ;;
        add     sp = -0x20, sp          // Calling convention says leave room...
        st8     [t0] = s0,8             // pExceptionRecord (ExceptionPointer[0])
        ;;
        st8     [t0] = s1               // store pContext (ExceptionPointer[1])
        mov     out0 = t3               // argument = PEXCEPTION_POINTERS

        //
        // Now send the exception to CpuResetToConsistantState()
        //
        // CpuResetToConsistantState() needs to:
        // 1) Zero out WOW64_TLS_STACKPTR64
        // 2) Check if the exception was from ia32 or ia64
        //     If exception was ia64, do nothing and return
        //     If exception was ia32, needs to:
        // 3) Needs to copy CONTEXT eip to the TLS (WOW64_TLS_EXCEPTIONADDR)
        // 4) reset CONTEXT ip to a valid ia64 ip (usually
        //      the destination of the jmpe)
        // 5) reset CONTEXT sp to a valid ia64 sp (TLS
        //      entry WOW64_TLS_STACKPTR64)
        
        //
        // call CpuResetToConsistentState(PEXCEPTION_POINTERS)
        //
        add     t1 = @gprel(__imp_CpuResetToConsistentState), gp
        ;;
        ld8     t1 = [t1]                   // Become a pointer to the plabel
        ;;
        ld8     t2 = [t1], PlGlobalPointer - PlEntryPoint   // Get entry point
        ;;
        ld8     gp = [t1]                   // Get the GP
        mov     bt0 = t2
        ;;
        br.call.sptk.many brp = bt0


        add     t2 = TeDeallocationStack+8+2*8, teb // Get the TLS address
        ;;

        st8     [t2] = zero    // WOW64_TLS_INCPUSIMULATION = FALSE


        //
        // Now cleanup and return (leaving ourselves on the ia64
        // stack if we weren't already on it)
        //
        mov     gp = loc2
        add     sp = 0x20, sp

        NESTED_RETURN
        NESTED_EXIT(Wow64PrepareForException)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64log\cathelper.c ===
/*++                 

Copyright (c) 2001 Microsoft Corporation

Module Name:

    cathelper.c

Abstract:
    
    Helper routines for categorizing APIs for logging.

Author:

    03-May-2001    KenCoope

Revision History:

--*/

#include "w64logp.h"
#include <cathelper.h>

#include <apimap.c>




ULONG
GetApiCategoryTableSize(
    void )
/*++

Routine Description:

    This routine retreives the number of APICATEGORY entries
    in the passed table.

Arguments:

    ApiCatTable - Pointer to API Category table

Return Value:

    Number of entries
--*/
{
    ULONG Count = 0;
    PAPI_CATEGORY ApiCatTable = Wow64ApiCategories;

    while (ApiCatTable && ApiCatTable->CategoryName) 
    {
        Count++;
        ApiCatTable++;
    }

    return Count;
}


PAPI_CATEGORY_MAPPING
FindApiInMappingTable(
    IN PTHUNK_DEBUG_INFO DebugInfoEntry,
    IN ULONG TableNumber)
/*++

Routine Description:

    This routine searches the API mapping table to determing the API
    category of the input DebugInfoEntry.

Arguments:

    DebugInfoEntry - A pointer to the THUNK_DEBUG_INFO entry
    TableNumber - The table number for the DebugInfoEntry

Return Value:

    The api category
--*/
{
    ULONG MapCount = 0;
    PAPI_CATEGORY_MAPPING ApiCatMapTable = Wow64ApiCategoryMappings;

    if( !DebugInfoEntry )
        return NULL;

    // search mapping array for a matching entry
    while( ApiCatMapTable && ApiCatMapTable->ApiName )
    {
        if( 0 == strcmp(DebugInfoEntry->ApiName, ApiCatMapTable->ApiName) )
        {
            ApiCatMapTable->ApiFlags = 0;
            return ApiCatMapTable;
        }

        ApiCatMapTable++;
        MapCount++;
    }

    // initialize pointer to next free mapping entry if needed
    if( ApiCategoryMappingNextFree == (ULONG)(-1) )
    {
        ApiCategoryMappingNextFree = MapCount;
    }

    // add new entry to the mapping table
    if( (ApiCategoryMappingNextFree+1) < MAX_API_MAPPINGS )
    {
        PAPI_CATEGORY_MAPPING NextMapping = ApiCatMapTable + 1;

        switch(TableNumber)
        {
            case WHNT32_INDEX:
                ApiCatMapTable->ApiCategoryIndex = APICAT_UNCLASS_WHNT32;
                break;

            case WHCON_INDEX:
                ApiCatMapTable->ApiCategoryIndex = APICAT_UNCLASS_WHCON;
                break;

            case WHWIN32_INDEX:
                ApiCatMapTable->ApiCategoryIndex = APICAT_UNCLASS_WHWIN32;
                break;

            case WHBASE_INDEX:
                ApiCatMapTable->ApiCategoryIndex = APICAT_UNCLASS_WHBASE;
                break;

            default:
                return NULL;
                break;
        }

        NextMapping->ApiName = NULL;
        NextMapping->ApiFlags = 0;
        NextMapping->ApiCategoryIndex = 0;
        ApiCatMapTable->ApiName = DebugInfoEntry->ApiName;
        ApiCatMapTable->ApiFlags = 0;
        ApiCategoryMappingNextFree++;

        return ApiCatMapTable;
    }
    
    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64log\logutil.c ===
/*++                 

Copyright (c) 1999 Microsoft Corporation

Module Name:

    logutil.c

Abstract:
    
    Helper routines for logging data.

Author:

    03-Oct-1999    SamerA

Revision History:

--*/

#include "w64logp.h"




WOW64LOGAPI
NTSTATUS
Wow64LogMessageArgList(
    IN UINT_PTR Flags,
    IN PSZ Format,
    IN va_list ArgList)
/*++

Routine Description:

    Logs a message.
    
Arguments:

    Flags  - Determine the output log type
    Format - Formatting string
    ...    - Variable argument

Return Value:

    NTSTATUS
--*/
{
    int BytesWritten;
    CHAR Buffer[ MAX_LOG_BUFFER ];

    //
    // Check trace gate flag
    //
    if (!((Wow64LogFlags & ~(UINT_PTR)LF_CONSOLE) & Flags)) 
    {
        return STATUS_SUCCESS;
    }

    BytesWritten = _vsnprintf(Buffer, 
                              sizeof(Buffer) - 1, 
                              Format, 
                              ArgList);

    if (BytesWritten < 0) 
    {
        return STATUS_BUFFER_TOO_SMALL;
    }

    //
    // Log the results
    //
    LogOut(Buffer, Wow64LogFlags);

    return STATUS_SUCCESS;
}



WOW64LOGAPI
NTSTATUS
Wow64LogMessage(
    IN UINT_PTR Flags,
    IN PSZ Format,
    IN ...)
/*++

Routine Description:

    Helper around logs a message that accepts a variable argument list
    
Arguments:

    Flags  - Determine the output log type
    Format - Formatting string
    ...    - Variable argument

Return Value:

    NTSTATUS
--*/
{
    NTSTATUS NtStatus;
    va_list ArgList;
    
    va_start(ArgList, Format);
    NtStatus = Wow64LogMessageArgList(Flags, Format, ArgList);
    va_end(ArgList);

    return NtStatus;
}




NTSTATUS
LogFormat(
    IN OUT PLOGINFO LogInfo,
    IN PSZ Format,
    ...)
/*++

Routine Description:

    Formats a message

Arguments:

    LogInfo    - Logging Information (buffer + available bytes)
    pszFormat  - Format string
    ...        - Optional arguments
    

Return Value:

    NTSTATUS - BufferSize is increment with the amount of bytes
    written if successful.
--*/
{
    va_list ArgList;
    NTSTATUS NtStatus = STATUS_SUCCESS;
    int BytesWritten;

    va_start(ArgList, Format);

    BytesWritten = _vsnprintf(LogInfo->OutputBuffer, LogInfo->BufferSize, Format, ArgList);

    va_end(ArgList);

    if (BytesWritten < 0)
    {
        NtStatus = STATUS_BUFFER_TOO_SMALL;
    }
    else
    {
        LogInfo->BufferSize -= BytesWritten;
        LogInfo->OutputBuffer += BytesWritten;
    }
    return NtStatus;
}


VOID
LogOut(
    IN PSZ Text,
    UINT_PTR Flags
    )
/*++

Routine Description:

    Logs -outputs- a message
       

Arguments:

    Text  - Formatted string to log
    
    Flags - Control flags

Return Value:

    None
--*/
{
    if ((Flags & LF_CONSOLE) != 0)
    {
        DbgPrint(Text);
    }

    //
    // Check if we need to send the output to a file
    //
    if (Wow64LogFileHandle != INVALID_HANDLE_VALUE)
    {
        LogWriteFile(Wow64LogFileHandle, Text);
    }
}




NTSTATUS
LogWriteFile(
   IN HANDLE FileHandle,
   IN PSZ LogText)
/*++

Routine Description:

   Writes text to a file handle

Arguments:

    FileHandle - Handle to a file object
    LogText    - Text to log to file

Return Value:

    NTSTATUS

--*/
{
   IO_STATUS_BLOCK IoStatus;
   NTSTATUS NtStatus;

   NtStatus = NtWriteFile(FileHandle,
                          NULL,       // event
                          NULL,       // apcroutine
                          NULL,       // apccontext
                          &IoStatus,
                          LogText,
                          strlen(LogText),
                          NULL,       // ByteOffset
                          NULL);      // key

   return NtStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64\wow64p.h ===
/*++

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    wow64p.h

Abstract:

    Private header for wow64.dll

Author:

    11-May-1998 BarryBo

Revision History:

--*/

#ifndef _WOW64P_INCLUDE
#define _WOW64P_INCLUDE

//
// All of this is so ke.h can be included from ntos\inc, to define
// KSERVICE_TABLE_DESCRIPTOR.
//
#include <ntosdef.h>
#include <procpowr.h>
#ifdef _AMD64_
#include <amd64.h>
#endif
#ifdef _IA64_
#include <v86emul.h>
#include <ia64.h>
#endif
#include <arc.h>
#include <ke.h>

#include "wow64.h"
#include "wow64log.h"
#include "wow64warn.h"


//
// X86-processor supported features
//
// The following features are considered:
// - Address Windowing Extension (AWE)
// - LARGE_PAGE Allocations
// - WriteWatch pages
// - Read/Write Scatter/Gather IO
//

extern ULONG Wow64pFeatureBits;

#if defined(_AMD64_)
#if PAGE_SIZE != PAGE_SIZE_X86NT
#error "Expecting AMD64 to have a PAGE_SIZE of 4K"
#else
#define WOW64_LARGE_PAGES_SUPPORTED     0x01
#define WOW64_AWE_SUPPORTED             0x02
#define WOW64_RDWR_SCATTER_GATHER       0x04
#define WOW64_WRITE_WATCH_SUPPORTED     0x08
#endif
#elif defined(_IA64_)
#if PAGE_SIZE != PAGE_SIZE_X86NT
#define WOW64_LARGE_PAGES_SUPPORTED     0x00
#define WOW64_AWE_SUPPORTED             0x00
#define WOW64_RDWR_SCATTER_GATHER       0x00
#define WOW64_WRITE_WATCH_SUPPORTED     0x00
#else
#error "Expecting IA64 to have a PAGE_SIZE of 8K"
#endif
#else
#error "No Target Architecture"
#endif

#define WOW64_IS_LARGE_PAGES_SUPPORTED() (Wow64pFeatureBits & WOW64_LARGE_PAGES_SUPPORTED)
#define WOW64_IS_AWE_SUPPORTED() (Wow64pFeatureBits & WOW64_AWE_SUPPORTED)
#define WOW64_IS_RDWR_SCATTER_GATHER_SUPPORTED() (Wow64pFeatureBits & WOW64_RDWR_SCATTER_GATHER)
#define WOW64_IS_WRITE_WATCH_SUPPORTED() (Wow64pFeatureBits & WOW64_WRITE_WATCH_SUPPORTED)


#define ROUND_UP(n,size)        (((ULONG)(n) + (size - 1)) & ~(size - 1))
#define WX86_MAX_ALLOCATION_RETRIES 3

#define WOW64_SUSPEND_MUTANT_NAME    L"SuspendThreadMutant"

#define WOW64_MINIMUM_STACK_RESERVE_X86  (256 * 1024)

//
// Data structure to represent relative paths inside system32 that
// shouldn't be redirected by our Object name redirector. Only used
// inside RedirectObjectName(...)
//
typedef struct _PATH_REDIRECT_EXEMPT
{
    WCHAR *Path;
    ULONG CharCount;
    BOOLEAN ThisDirOnly;
} PATH_REDIRECT_EXEMPT ;


//
// Builds a table to thunk environment variables at startup.
//

typedef struct _ENVIRONMENT_THUNK_TABLE
{
    WCHAR *Native;

    WCHAR *X86;

    WCHAR *FakeName;

    ULONG IsX86EnvironmentVar;

} ENVIRONMENT_THUNK_TABLE, *PENVIRONMENT_THUNK_TABLE;


//
// The following defintions are to support legacy LPC code (not wow64 aware)
//


#pragma pack(4)
typedef struct _PORT_MESSAGE32 {
    union {
        struct {
            CSHORT DataLength;
            CSHORT TotalLength;
        } s1;
        ULONG Length;
    } u1;
    union {
        struct {
            CSHORT Type;
            CSHORT DataInfoOffset;
        } s2;
        ULONG ZeroInit;
    } u2;
    union {
        struct {
            int UniqueProcess;
            int UniqueThread;
        } ClientId;
        double DoNotUseThisField;           // Force quadword alignment
    };
    ULONG MessageId;
    union {
        ULONG ClientViewSize;               // Only valid on LPC_CONNECTION_REQUEST message
        ULONG CallbackId;                   // Only valid on LPC_REQUEST message
    };
//  UCHAR Data[];
} PORT_MESSAGE32, *PPORT_MESSAGE32;

typedef struct _PORT_DATA_ENTRY32 {
    ULONG Base;
    ULONG Size;
} PORT_DATA_ENTRY32, *PPORT_DATA_ENTRY32;

typedef struct _PORT_DATA_INFORMATION32 {
    ULONG CountDataEntries;
    PORT_DATA_ENTRY32 DataEntries[1];
} PORT_DATA_INFORMATION32, *PPORT_DATA_INFORMATION32;

typedef struct _PORT_VIEW32 {
    ULONG Length;
    int SectionHandle;
    ULONG SectionOffset;
    ULONG ViewSize;
    ULONG ViewBase;
    ULONG ViewRemoteBase;
} PORT_VIEW32, *PPORT_VIEW32;

typedef struct _REMOTE_PORT_VIEW32 {
    ULONG Length;
    ULONG ViewSize;
    ULONG ViewBase;
} REMOTE_PORT_VIEW32, *PREMOTE_PORT_VIEW32;
#pragma pack()



//
// Code, Data and Teb default GDT entries (descriptor offsets)
// extracted from public\sdk\inc\nti386.h
//
#define KGDT_NULL       0
#define KGDT_R3_CODE    24
#define KGDT_R3_DATA    32
#define KGDT_R3_TEB     56
#define RPL_MASK        3

//
// LPC legacy support
//

#define WOW64_MARK_LEGACY_PORT_HANDLE(phandle) (*(PLONG)phandle = (*(PLONG)phandle | 0x01))
#define WOW64_IS_LEGACY_PORT_HANDLE(handle) (PtrToLong (handle) & 0x01)
#define WOW64_REMOVE_LEGACY_PORT_HANDLE_MARK(handle) handle = ((HANDLE)((ULONG_PTR)handle & ~0x01UI64))


// from wow64.c
extern WOW64SERVICE_TABLE_DESCRIPTOR ServiceTables[MAX_TABLE_INDEX];

LONG
Wow64DispatchExceptionTo32(
    IN struct _EXCEPTION_POINTERS *ExInfo
    );

VOID
RunCpuSimulation(
    VOID
    );


// from init.c
extern ULONG Ntdll32LoaderInitRoutine;
extern ULONG Ntdll32KiUserExceptionDispatcher;
extern ULONG Ntdll32KiUserApcDispatcher;
extern ULONG Ntdll32KiUserCallbackDispatcher;
extern ULONG Ntdll32KiRaiseUserExceptionDispatcher;
extern ULONG NtDll32Base;
extern WOW64_SYSTEM_INFORMATION RealSysInfo;
extern WOW64_SYSTEM_INFORMATION EmulatedSysInfo;
extern UNICODE_STRING NtSystem32Path;
extern UNICODE_STRING NtSystem32LastGoodPath;
extern UNICODE_STRING NtWindowsImePath;
extern UNICODE_STRING RegeditPath;

//
// Wow64 Maximum User Virtual Address
//

#define MAX_WOW64_ADDRESS()     (EmulatedSysInfo.BasicInfo.MaximumUserModeAddress)


NTSTATUS
ProcessInit(
    PSIZE_T pCpuThreadSize
    );

NTSTATUS
ThreadInit(
    PVOID pCpuThreadData
    );

NTSTATUS
InitializeContextMapper(
   VOID
   );

NTSTATUS
Wow64pInitializeWow64Info(
    VOID
    );

VOID
ThunkStartupContext64TO32(
   IN OUT PCONTEXT32 Context32,
   IN PCONTEXT Context64
   );

VOID
SetProcessStartupContext64(
    OUT PCONTEXT Context64,
    IN HANDLE ProcessHandle,
    IN PCONTEXT32 Context32,
    IN ULONGLONG InitialSP64,
    IN ULONGLONG TransferAddress64
    );

VOID
Run64IfContextIs64(
    IN PCONTEXT Context,
    IN BOOLEAN IsFirstThread
    );

VOID
ThunkpExceptionRecord64To32(
    IN  PEXCEPTION_RECORD   pRecord64,
    OUT PEXCEPTION_RECORD32 pRecord32
    );


// from thread.c
NTSTATUS
Wow64pInitializeSuspendMutant(
    VOID);


//////////////////////////////////
// Debug log startup and shutdown.
//////////////////////////////////

extern PFNWOW64LOGSYSTEMSERVICE pfnWow64LogSystemService;


VOID
InitializeDebug(
    VOID
    );

VOID ShutdownDebug(
     VOID
     );

// from *\call32.asm

// from debug.c
extern UCHAR Wow64LogLevel;

// from *\call64.asm
extern VOID ApiThunkDispatcher(VOID);

typedef LONG (*pfnWow64SystemService)(PULONG pBaseArgs);


// from *\systable.asm
extern ULONG KiServiceLimit;
extern CHAR KiArgumentTable[];
extern UINT_PTR KiServiceTable[];

//
// from misc.c
//

NTSTATUS
Wow64InitializeEmulatedSystemInformation(
    VOID
    );

VOID
ThunkContext32TO64(
    IN PCONTEXT32 Context32,
    OUT PCONTEXT Context64,
    IN ULONGLONG StackBase
    );

NTSTATUS
Wow64pSkipContextBreakPoint(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT Context
    );

//
// from config.c
//

VOID
Wow64pSetProcessExecuteOptions (
    VOID
    );

VOID
Wow64pSetExecuteProtection (
    IN OUT PULONG Protect);


//
// from wow64lpc.h
//

NTSTATUS
Wow64pGetLegacyLpcPortName(
    VOID
    );

BOOLEAN
Wow64pIsLegacyLpcPort (
    IN PUNICODE_STRING PortName
    );

NTSTATUS
Wow64pThunkLegacyLpcMsgIn (
    IN BOOLEAN RequestWaitCall,
    IN PPORT_MESSAGE32 PortMessage32,
    IN OUT PPORT_MESSAGE *PortMessageOut
    );

NTSTATUS
Wow64pThunkLegacyLpcMsgOut (
    IN BOOLEAN RequestWaitCall,
    IN PPORT_MESSAGE PortMessage,
    IN OUT PPORT_MESSAGE32 PortMessage32
    );

NTSTATUS
Wow64pThunkLegacyPortViewIn (
    IN PPORT_VIEW32 PortView32,
    OUT PPORT_VIEW *PortView,
    OUT PBOOLEAN LegacyLpcPort
    );

NTSTATUS
Wow64pThunkLegacyPortViewOut (
    IN PPORT_VIEW PortView,
    IN OUT PPORT_VIEW32 PortView32
    );

NTSTATUS
Wow64pThunkLegacyRemoteViewIn (
    IN PREMOTE_PORT_VIEW32 RemotePortView32,
    IN OUT PREMOTE_PORT_VIEW *RemotePortView,
    OUT PBOOLEAN LegacyLpcPort
    );

NTSTATUS
Wow64pThunkLegacyRemoteViewOut (
    IN PREMOTE_PORT_VIEW RemotePortView,
    IN OUT PREMOTE_PORT_VIEW32 RemotePortView32
    );


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64\amd64\except.asm ===
TITLE   "WOW64 Prepare For Exception"
;++
;
; Copyright (c) 2001  Microsoft Corporation
;
; Module Name:
;
;   except.asm
;
; Abstract:
;
;   This module implements the platform specific code to switch from the
;   32-bit stack to the 64-bit stack when an exception occurs.
;
; Author:
;
;   Samer Arafeh (samera) 11-Dec-2001
;
; Envirnoment:
;
;   User mode.
;
;--

include ksamd64.inc

        extern  RtlCopyMemory:proc
        extern  CpuResetToConsistentState:proc

        subttl "Wow64PrepareForException"
;++
;
; VOID
; Wow64PrepareForException (
;     IN PEXCEPTION_RECORD ExceptionRecord,
;     IN PCONTEXT ContextRecord
;     )
;
; Routine Description:
;
;    This function is called from the 64-bit exception dispatcher just before
;    it dispatches an exception when the current running program is a 32-bit
;    legacy application.
;
;    N.B. This function uses a nonstandard calling sequence.
;
; Arguments:
;
;    ExceptionRecord (rsi) - Supplies a pointer to an exception record.
;
;    ContextRecord (rdi) - Supplies a pointer to a context record.
;
;    N.B. The argument value are passed in non-standard registers and must
;         be relocated if a switch from the 32-bit to the 64-bit stack
;         occurs.
;
; Return Value:
;
;    None.
;
;--

ExFrame struct
        P1Home  dq ?                    ; parameter home addresses
        P2Home  dq ?                    ;
        P3Home  dq ?                    ;
        ExRecord dq ?                   ; exception record address
        CxRecord dq ?                   ; context record address
        Fill    dq ?                    ; fill to 0 mod 16
ExFrame ends

        NESTED_ENTRY Wow64PrepareForException, _TEXT$00

        push_reg rbx                    ; save nonvolatile register

        alloc_stack sizeof (ExFrame)    ; allocate stack frame

        END_PROLOGUE

;
; Check to determine if the exception happened on the 32-bit x86 stack. If
; the exception happened on the 32-bit stack, then the exception record,
; context record, and machine frame must be copied from the 32-bit stack to
; the 64-bit stack.
;

        mov     r11, QWORD PTR gs:[TeSelf] ; get the 64-bit Teb address
        mov     rbx, (TeDeallocationStack + 8)[r11] ; get to WOW64_TLS_STACKPTR64
        test    rbx, rbx                ; test if on 64-bit stack
        jz      short OnAmd64Stack      ; if z, on 64-bit stack
        
;
; Exception happened on the 32-bit stack.
;

        mov     r8d, CxRsp[rdi]         ; compute size of information to copy
        sub     r8d, esp                ; 
        mov     edx, esp                ; set source address
        sub     rbx, r8                 ; allocate space on 64-bit stack
        and     rbx, not 15             ; align 64-bit stack to 0 mod 16 boundary
        mov     rcx, rbx                ; set destination address
        call    RtlCopyMemory           ; copy exception information

;
; Relocate address of exception record and context record to the 64-bit stack.
;

        sub     esi, esp                ; relocate exception record address
        add     rsi, rbx                ;      
        sub     edi, esp                ; relocate context record address
        add     rdi, rbx                ; 
        mov     rsp, rbx                ; set 64-bit stack pointer

;
; Exception happened on the 32-bit stack or the 64-bit stack.
;
; Construct an exception pointers structure on the stack and call routine
; to reset consistent state.
;

OnAmd64Stack:                           ;
        mov     ExFrame.ExRecord[rsp], rsi ; save exception record addrss
        mov     ExFrame.CxRecord[rsp], rdi ; save context record addrss
        lea     rcx, ExFrame.ExRecord[rsp] ; set adddress of exception pointers
        call    CpuResetToConsistentState ; compute consistent state
        mov     r11, QWORD PTR gs:[TeSelf] ; get the 64-bit Teb address
        and     qword ptr (TeDeallocationStack + 8 + 16)[r11], 0 ; reset WOW64_TLS_INCPUSIMULATION flag
        add     rsp, sizeof (ExFrame)   ; deallocate stack frame
        pop     rbx                     ; restore nonvolatile register
        ret                             ;

        NESTED_END Wow64PrepareForException, _TEXT$00

        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64\amd64\misc.c ===
/*++                 

Copyright (c) 2002 Microsoft Corporation

Module Name:

    misc.c

Abstract:
    
    Processor-architecture routines for Wow64 context setup/conversion.

Author:

    28-Dec-2001  Samer Arafeh (samera)

Revision History:

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <minmax.h>
#include "nt32.h"
#include "wow64p.h"
#include "wow64cpu.h"

ASSERTNAME;


VOID
Wow64NotifyDebuggerHelper(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN BOOLEAN FirstChance
    )
/*++

Routine Description:
  
    This is a copy of RtlRaiseException, except it accepts the FirstChance parameter 
    specifing if this is a first chance exception.

    ExceptionRecord - Supplies the 64bit exception record to be raised.
    FirstChance - TRUE is this is a first chance exception.  

Arguments:

    None - Doesn't return through the normal path.

--*/

{

    CONTEXT ContextRecord;
    ULONG64 ControlPc;
    ULONG64 EstablisherFrame;
    PRUNTIME_FUNCTION FunctionEntry;
    PVOID HandlerData;
    ULONG64 ImageBase;
    NTSTATUS Status = STATUS_INVALID_DISPOSITION;

    //
    // Capture the current context, unwind to the caller of this routine, set
    // the exception address, and call the appropriate exception dispatcher.
    //

    RtlCaptureContext (&ContextRecord);
    ControlPc = ContextRecord.Rip;
    FunctionEntry = RtlLookupFunctionEntry (ControlPc, &ImageBase, NULL);
    if (FunctionEntry != NULL) 
    {
        RtlVirtualUnwind (UNW_FLAG_NHANDLER,
                          ImageBase,
                          ControlPc,
                          FunctionEntry,
                          &ContextRecord,
                          &HandlerData,
                          &EstablisherFrame,
                          NULL);

        if (ExceptionRecord->ExceptionAddress == NULL)
        {
            ExceptionRecord->ExceptionAddress = (PVOID)ContextRecord.Rip;
        }
    }

    Status = NtRaiseException (ExceptionRecord, &ContextRecord, FirstChance);

    //
    // There should never be a return from either exception dispatch or the
    // system service unless there is a problem with the argument list itself.
    // Raise another exception specifying the status value returned.
    //


    WOWASSERT (FALSE);
}


VOID
ThunkContext32TO64(
    IN PCONTEXT32 Context32,
    OUT PCONTEXT Context64,
    IN ULONGLONG StackBase
    )
/*++

Routine Description:
  
    Thunk a 32-bit CONTEXT record to 64-bit.  This isn't a general-purpose
    routine... it only does the minimum required to support calls to
    NtCreateThread from 32-bit code.  The resulting 64-bit CONTEXT is
    passed to 64-bit NtCreateThread only.

Arguments:

    Context32   - IN 32-bit CONTEXT
    Context64   - OUT 64-bit CONTEXT
    StackBase   - IN 64-bit stack base for the new thread

Return:

    None.  Context64 is initialized.

--*/

{

    RtlZeroMemory((PVOID)Context64, sizeof(CONTEXT));

    //
    // Setup the 64-bit Context
    //

    Context64->Rip = (ULONG_PTR) Context32->Eip;
    Context64->Rcx = (ULONG_PTR) Context32->Eax;
    Context64->Rdx = (ULONG_PTR) Context32->Ebx;

    //
    // Setup Rsp and initial Esp. Allocate a dummy call frame as well.
    //

    Context64->Rsp = (StackBase - 1);
    Context64->R8  = Context32->Esp;

    Context64->ContextFlags = CONTEXT_CONTROL | CONTEXT_INTEGER;
}

NTSTATUS
Wow64pSkipContextBreakPoint(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT Context)
/*++

Routine Description:

    Context->Rip is already past the INT 3 instruction, so nothing
    needs to be done here.

Arguments:

    ExceptionRecord  - Exception record at the time of hitting the bp
    Context          - Context to change

Return:

    NTSTATUS

--*/

{
    return STATUS_SUCCESS;
}


VOID
ThunkpExceptionRecord64To32(
    IN  PEXCEPTION_RECORD   ExceptionRecord64,
    OUT PEXCEPTION_RECORD32 ExceptionRecord32
    )

/*++

Routine Description:

    Thunks native architecture exception record.
    
    Note: This function is called after the generic exception record 
    fields (like exception code for example) have been thunked.

Arguments:

    ExceptionRecord64  - Pointer to the native architecture exception record.
    
    ExceptionRecord32  - Pointer to receive the thunked exception record.

Return:

    None.
--*/
{
    switch (ExceptionRecord64->ExceptionCode)
    {
    case STATUS_ACCESS_VIOLATION:
        {
            ASSERT (ExceptionRecord64->NumberParameters == 2);
            ExceptionRecord32->ExceptionInformation [0] &= 0x00000001;
        }
        break;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64\ia64\misc.c ===
/*++                 

Copyright (c) 1998-2000 Microsoft Corporation

Module Name:

    misc.c

Abstract:
    
    Random architecture dependent function for wow64.dll

Author:

    13-Aug-1998 mzoran

Revision History:

--*/

#define _WOW64DLLAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <minmax.h>
#include "nt32.h"
#include "wow64p.h"
#include "wow64cpu.h"

ASSERTNAME;


#define GET_IMM7B(x)     (x & 0x7fUI64)
#define GET_IMM9D(x)     ((x >> 7) & 0x1ffUI64)
#define GET_IMM5C(x)     ((x >> 16) & 0x1fUI64)
#define GET_IMMIC(x)     ((x >> 21) & 0x1UI64)
#define GET_IMM41(x)     ((x >> 22) & 0x1fffffUI64)
#define GET_IMMI(x)      ((x >> 63) & 0x1UI64)


VOID
Wow64NotifyDebuggerHelper(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN BOOLEAN FirstChance
    )
/*++

Routine Description:
  
    This is a copy of RtlRaiseException, except it accepts the FirstChance parameter 
    specifing if this is a first chance exception.

    ExceptionRecord - Supplies the 64bit exception record to be raised.
    FirstChance - TRUE is this is a first chance exception.  

Arguments:

    None - Doesn't return through the normal path.

--*/
{

    ULONGLONG ImageBase;
    ULONGLONG TargetGp;
    ULONGLONG ControlPc;
    CONTEXT ContextRecord;
    FRAME_POINTERS EstablisherFrame;
    PRUNTIME_FUNCTION FunctionEntry;
    BOOLEAN InFunction;
    ULONGLONG NextPc;

    //
    // Capture the current context, virtually unwind to the caller of this
    // routine, set the fault instruction address to that of the caller, and
    // call the raise exception system service.
    //

    RtlCaptureContext(&ContextRecord);
    ControlPc = RtlIa64InsertIPSlotNumber((ContextRecord.BrRp-16), 2);
    FunctionEntry = RtlLookupFunctionEntry(ControlPc, &ImageBase, &TargetGp);
    NextPc = RtlVirtualUnwind(ImageBase,
                              ControlPc,
                              FunctionEntry,
                              &ContextRecord,
                              &InFunction,
                              &EstablisherFrame,
                              NULL);

    ContextRecord.StIIP = NextPc + 8;
    ContextRecord.StIPSR &= ~((ULONGLONG) 3 << PSR_RI);
    if (ExceptionRecord->ExceptionAddress == NULL)
    {
        ExceptionRecord->ExceptionAddress = (PVOID)ContextRecord.StIIP;
    }
    NtRaiseException(ExceptionRecord, &ContextRecord, FirstChance);

    WOWASSERT(FALSE);
}


VOID
ThunkContext32TO64(
    IN PCONTEXT32 Context32,
    OUT PCONTEXT Context64,
    IN ULONGLONG StackBase
    )
/*++

Routine Description:
  
    Thunk a 32-bit CONTEXT record to 64-bit.  This isn't a general-purpose
    routine... it only does the minimum required to support calls to
    NtCreateThread from 32-bit code.  The resulting 64-bit CONTEXT is
    passed to 64-bit NtCreateThread only.

Arguments:

    Context32   - IN 32-bit CONTEXT
    Context64   - OUT 64-bit CONTEXT
    StackBase   - IN 64-bit stack base for the new thread

Return:

    None.  Context64 is initialized.

--*/
{
    RtlZeroMemory((PVOID)Context64, sizeof(CONTEXT));

    //
    // Setup the stuff that doesn't usually change
    // Need to worry about psr/fpsr or other ia64 control or will
    // default values be used when the kernel SANITIZEs these values?
    // When the kernel thread init code is working again, these 3 constants
    // won't need to be set here.
    //
    Context64->SegCSD = USER_CODE_DESCRIPTOR;
    Context64->SegSSD = USER_DATA_DESCRIPTOR;
    Context64->Cflag = (ULONGLONG)((CR4_VME << 32) | CR0_PE | CFLG_II);

    Context64->StIPSR = USER_PSR_INITIAL;
    Context64->RsPFS = 0;
    Context64->RsBSP = Context64->RsBSPSTORE = Context64->IntSp = StackBase;
    Context64->IntSp -= STACK_SCRATCH_AREA; // scratch area as per convention
    Context64->IntS1 = (ULONG_PTR)Context32->Eax;     // InitialPc
    Context64->IntS2 = (ULONG_PTR)Context32->Ebx;     // Parameter
    Context64->RsRSC = (RSC_MODE_EA<<RSC_MODE)
                   | (RSC_BE_LITTLE<<RSC_BE)
                   | (0x3<<RSC_PL);

    Context64->IntS0 = Context64->StIIP = (ULONG_PTR)Context32->Eip;
    Context64->IntS3 = Context32->Esp;
    // Set the initial GP to non-zero.  If it is zero, ntos\ps\ia64\psctxi64.c
    // will treat initial IIP as a PLABEL_DESCRIPTOR pointer and dereference it.
    // That's bad if we are using IIP to point to an IA32 address.
    Context64->IntGp = ~0i64;
    Context64->ContextFlags = CONTEXT_CONTROL| CONTEXT_INTEGER;
    Context64->ApUNAT = 0xFFFFFFFFFFFFEDF1ULL;
    Context64->Eflag = 0x00003002ULL;
}



NTSTATUS
Wow64pSkipContextBreakPoint(
    IN PEXCEPTION_RECORD ExceptionRecord,
    IN OUT PCONTEXT Context)
/*++

Routine Description:

    Advances Context->StIIP to the instruction following the hard coded bp.

Arguments:

    ExceptionRecord  - Exception record at the time of hitting the bp
    Context          - Context to change

Return:

    NTSTATUS
--*/
{
    PPSR IntPSR;
    ULONGLONG IntIP;

    IntIP  = (ULONGLONG)ExceptionRecord->ExceptionAddress;
    IntPSR = (PPSR)&Context->StIPSR;
    
    if ((IntIP & 0x000000000000000fUI64) != 0x0000000000000008UI64)
    {
        IntPSR->sb.psr_ri = (IntPSR->sb.psr_ri + 1);
    }
    else
    {
        IntPSR->sb.psr_ri = 0x00;
        Context->StIIP = (Context->StIIP + 0x10);
    }

    return STATUS_SUCCESS;
}


VOID
ThunkpExceptionRecord64To32(
    IN  PEXCEPTION_RECORD   ExceptionRecord64,
    OUT PEXCEPTION_RECORD32 ExceptionRecord32
    )

/*++

Routine Description:

    Thunks native architecture exception record.
    
    Note: This function is called after the generic exception record 
    fields (like exception code for example) have been thunked.

Arguments:

    ExceptionRecord64  - Pointer to the native architecture exception record.
    
    ExceptionRecord32  - Pointer to receive the thunked exception record.

Return:

    None.
--*/
{
    switch (ExceptionRecord64->ExceptionCode)
    {
    case STATUS_ACCESS_VIOLATION:
        {
            ASSERT (ExceptionRecord64->NumberParameters == 5);

            ExceptionRecord32->NumberParameters = 2;
            if ((ExceptionRecord64->ExceptionInformation [4] & (1i64 << ISR_W)) != 0) {
                ExceptionRecord32->ExceptionInformation [0] = 1;
            } else {
                ExceptionRecord32->ExceptionInformation [0] = 0;
            }
        }
        break;
    }

    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64svc\server\server.c ===
/*++

Copyright (c) 1996  Microsoft Corporation

Module Name:

    server.c

Abstract:

    This module contains the code to provide the RPC server.

Author:

    Wesley Witt (wesw) 16-Jan-1996


Revision History:

--*/

#include "wow64svc.h"
#pragma hdrstop


GUID Wow64SvcGuid = { 0xc3a9d640, 0xffff, 0x11d0, { 0x92, 0xbf, 0x0, 0xa0, 0x24, 0xaa, 0x1c, 0x1 } };

CRITICAL_SECTION CsPerfCounters;
DWORD OutboundSeconds;
DWORD InboundSeconds;
DWORD TotalSeconds;

CHAR Buffer[4096];

HANDLE hServiceEndEvent; // signalled by tapiworkerthread after letting clients know fax service is ending
#ifdef DBG
HANDLE hLogFile = INVALID_HANDLE_VALUE;
LIST_ENTRY CritSecListHead;
#endif





DWORD
ServiceStart(
    VOID
    )

/*++

Routine Description:

    Starts the RPC server.  This implementation listens on
    a list of protocols.  Hopefully this list is inclusive
    enough to handle RPC requests from most clients.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    if (StartReflector ())
        return 0;
    return 1;
}

void EndWow64Svc(
    BOOL bEndProcess,
    DWORD SeverityLevel
    )
/*++

Routine Description:

    End the fax service.

Arguments:

    None.

Return Value:

    None.

--*/
{
    ServiceStop();
}



DWORD
ServiceStop(
    void
    )

/*++

Routine Description:

    Stops the RPC server.

Arguments:

    None.

Return Value:

    None.

--*/

{
    if (StopReflector ())
        return 0;
    return 1;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64log\wow64log.c ===
/*++                 

Copyright (c) 1999 Microsoft Corporation

Module Name:

    wow64log.c

Abstract:
    
    Main entrypoints for wow64log.dll. To add a data type handler :
    1- Define a LOGDATATYPE for the data to log in w64logp.h
    2- Implement the data type handler using the standard interface
       NTSTATUS
       LogDataType(IN OUT PLOGINFO LogInfo,
                   IN ULONG_PTR Data,
                   IN PSZ FieldName,
                   IN BOOLEAN ServiceReturn);
    3- Insert the handler into LogDataType[] below.               
                   

Author:

    03-Oct-1999   SamerA

Revision History:

--*/

#include "w64logp.h"
#include <cathelper.h>

extern API_CATEGORY Wow64ApiCategories[];
extern API_CATEGORY_MAPPING Wow64ApiCategoryMappings[];

extern
ULONG
GetApiCategoryTableSize(
    void );

extern
PAPI_CATEGORY_MAPPING
FindApiInMappingTable(
    IN PTHUNK_DEBUG_INFO DebugInfoEntry,
    IN ULONG TableNumber);




/// Public

//
// Control logging flags 
//
UINT_PTR Wow64LogFlags;
HANDLE Wow64LogFileHandle;



/// Private

//
// Hold an array of pointers to each system service DebugThunkInfo
//
PULONG_PTR *LogNtBase;
PULONG_PTR *LogWin32;
PULONG_PTR *LogConsole;
PULONG_PTR *LogBase;

//
// Hold an array of pointers to each system service api/category info
//
PULONG_PTR *ApiInfoNtBase;
PULONG_PTR *ApiInfoWin32;
PULONG_PTR *ApiInfoConsole;
PULONG_PTR *ApiInfoBase;

//
// NOTE : The order entries in this table should match the LOGTYPE enum in
// w64logp.h.
//
LOGDATATYPE LogDataType[] =
{
    {LogTypeValue},            // TypeHex
    {LogTypePULongInOut},      // TypePULongPtrInOut
    {LogTypePULongOut},        // TypePULONGOut
    {LogTypePULongOut},        // TypePHandleOut
    {LogTypeUnicodeString},    // TypeUnicodeStringIn
    {LogTypeObjectAttrbiutes}, // TypeObjectAttributesIn
    {LogTypeIoStatusBlock},    // TypeIoStatusBlockOut
    {LogTypePWStr},            // TypePwstrIn
    {LogTypePRectIn},          // TypePRectIn
    {LogTypePLargeIntegerIn},  // TypePLargeIntegerIn
};






WOW64LOGAPI
NTSTATUS
Wow64LogInitialize(
    VOID)
/*++

Routine Description:

    This function is called by wow64.dll to initialize wow64 logging
    subsystem.

Arguments:

    None

Return Value:

    NTSTATUS
--*/
{
    ULONG NtBaseTableSize, Win32TableSize, ConsoleTableSize, BaseTableSize;
    PULONG_PTR *Win32ThunkDebugInfo;
    PULONG_PTR *ConsoleThunkDebugInfo;
    UNICODE_STRING Log2Name;
    PVOID Log2Handle = NULL;
    NTSTATUS st;

    //
    // Initialize the logging file handle
    //
    Wow64LogFileHandle = INVALID_HANDLE_VALUE;

    //
    // Initialize the logging flags
    //
    LogInitializeFlags(&Wow64LogFlags);
    WOW64LOGOUTPUT((LF_TRACE, "Wow64LogInitialize - Wow64LogFlags = %I64x\n", Wow64LogFlags));

    //
    // Load the Win32 logging DLL if available.
    //
    RtlInitUnicodeString(&Log2Name, L"wow64lg2.dll");
    st = LdrLoadDll(NULL, NULL, &Log2Name, &Log2Handle);
    if (NT_SUCCESS(st)) {
        ANSI_STRING ExportName;

        RtlInitAnsiString(&ExportName, "Win32ThunkDebugInfo");
        st = LdrGetProcedureAddress(Log2Handle, &ExportName, 0, &(PVOID)Win32ThunkDebugInfo);
        if (NT_SUCCESS(st)) {
            RtlInitAnsiString(&ExportName, "ConsoleThunkDebugInfo");
            st = LdrGetProcedureAddress(Log2Handle, &ExportName, 0, &(PVOID)ConsoleThunkDebugInfo);
        }
    }
    if (!NT_SUCCESS(st)) {
        Log2Handle = NULL;
        Win32ThunkDebugInfo = NULL;
        ConsoleThunkDebugInfo = NULL;
    }

    //
    // Build pointers to the debug thunk info for each
    // system service
    //
    
    NtBaseTableSize = GetThunkDebugTableSize(
                          (PTHUNK_DEBUG_INFO)NtThunkDebugInfo);
    BaseTableSize = GetThunkDebugTableSize(
                          (PTHUNK_DEBUG_INFO)BaseThunkDebugInfo);
    if (Log2Handle != NULL) {
        Win32TableSize = GetThunkDebugTableSize(
                              (PTHUNK_DEBUG_INFO)Win32ThunkDebugInfo);
        ConsoleTableSize = GetThunkDebugTableSize(
                              (PTHUNK_DEBUG_INFO)ConsoleThunkDebugInfo);
    } else {
        Win32TableSize = 0;
        ConsoleTableSize = 0;
    }
    
    LogNtBase = (PULONG_PTR *)Wow64AllocateHeap((NtBaseTableSize + Win32TableSize + ConsoleTableSize + BaseTableSize) *
                                                sizeof(PULONG_PTR) * 2 );

    if (!LogNtBase) 
    {
        WOW64LOGOUTPUT((LF_ERROR, "Wow64LogInitialize - Wow64AllocateHeap failed\n"));
        return STATUS_UNSUCCESSFUL;
    }
    
    LogWin32 = LogNtBase + NtBaseTableSize;
    LogConsole = LogWin32 + Win32TableSize;
    LogBase = LogConsole + ConsoleTableSize;

    ApiInfoNtBase = LogBase + BaseTableSize;
    ApiInfoWin32 = ApiInfoNtBase + NtBaseTableSize;
    ApiInfoConsole = ApiInfoWin32 + Win32TableSize;
    ApiInfoBase = ApiInfoConsole + ConsoleTableSize;

    BuildDebugThunkInfo(WHNT32_INDEX,(PTHUNK_DEBUG_INFO)NtThunkDebugInfo,LogNtBase,ApiInfoNtBase);
    BuildDebugThunkInfo(WHBASE_INDEX,(PTHUNK_DEBUG_INFO)BaseThunkDebugInfo,LogBase,ApiInfoBase);
    if (Log2Handle) {
        BuildDebugThunkInfo(WHWIN32_INDEX,(PTHUNK_DEBUG_INFO)Win32ThunkDebugInfo,LogWin32,ApiInfoWin32);
        BuildDebugThunkInfo(WHCON_INDEX,(PTHUNK_DEBUG_INFO)ConsoleThunkDebugInfo,LogConsole,ApiInfoConsole);
    } else
    {
        LogConsole = NULL;
        LogWin32 = NULL;
    }

    return STATUS_SUCCESS;
}



WOW64LOGAPI
NTSTATUS
Wow64LogTerminate(
    VOID)
/*++

Routine Description:

    This function is called by wow64.dll when the process is exiting.

Arguments:

    None

Return Value:

    NTSTATUS
--*/
{
    IO_STATUS_BLOCK IoStatusBlock;
    
    if (Wow64LogFileHandle != INVALID_HANDLE_VALUE) 
    {
        NtFlushBuffersFile(Wow64LogFileHandle, &IoStatusBlock);
        NtClose(Wow64LogFileHandle);
    }

    return STATUS_SUCCESS;
}



NTSTATUS
LogInitializeFlags(
    IN OUT PUINT_PTR Flags)
/*++

Routine Description:

    Reads the logging flags from the registry

Arguments:

    Flags - Pointer to receive logging flags

Return Value:

    NTSTATUS
--*/
{
    HANDLE Key;
    UNICODE_STRING KeyName, ValueName, ResultValue;
    OBJECT_ATTRIBUTES ObjectAttributes;
    WCHAR KeyValueBuffer[ 128 ];
    PKEY_VALUE_PARTIAL_INFORMATION KeyValueInformation;
    ULONG ResultLength, RegFlags;
    NTSTATUS NtStatus;


    //
    // Punch in the default
    //
    *Flags = LF_DEFAULT;

    KeyValueInformation = (PKEY_VALUE_PARTIAL_INFORMATION)KeyValueBuffer;

    RtlInitUnicodeString(&KeyName,
                         L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Session Manager");

    InitializeObjectAttributes(&ObjectAttributes,
                               &KeyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               NULL);

    NtStatus = NtOpenKey(&Key, KEY_READ, &ObjectAttributes);

    if (NT_SUCCESS(NtStatus)) 
    {
        RtlInitUnicodeString(&ValueName, L"WOW64LOGFLAGS");
        NtStatus = NtQueryValueKey(Key,
                                   &ValueName,
                                   KeyValuePartialInformation,
                                   KeyValueInformation,
                                   sizeof(KeyValueBuffer),
                                   &ResultLength);

        if (NT_SUCCESS(NtStatus)) 
        {
            if ((KeyValueInformation->Type == REG_DWORD) && 
                (KeyValueInformation->DataLength == sizeof(DWORD)))
            {
                *Flags = *((PULONG)KeyValueInformation->Data);
            }
        }
    }

    return NtStatus;
}


ULONG
GetThunkDebugTableSize(
    IN PTHUNK_DEBUG_INFO DebugInfoTable)
/*++

Routine Description:

    This routine retreives the number of DebugThunkInfo entries
    in the passed table.

Arguments:

    DebugInfoTable - Pointer to services debug info

Return Value:

    Number of entries
--*/
{
    BOOLEAN InvalidArgumentPresent;
    ULONG ArgIndex;
    ULONG Count = 0;

    while (DebugInfoTable && DebugInfoTable->ApiName) 
    {
        //
        // Walk the argument list to make sure there aren't any NULLs in them, which would
        // terminate the table.
        //

        ArgIndex = 0;
        InvalidArgumentPresent = FALSE;
        while (ArgIndex < DebugInfoTable->NumberOfArg)
        {
            if (!ARGUMENT_PRESENT (DebugInfoTable->Arg[ArgIndex++].Name))
            {
                InvalidArgumentPresent = TRUE;
                break;
            }
        }

        if (InvalidArgumentPresent == TRUE)
        {
            break;
        }
        
        Count++;
        DebugInfoTable = (PTHUNK_DEBUG_INFO)
                         &DebugInfoTable->Arg[DebugInfoTable->NumberOfArg];
    }

    return Count;
}



NTSTATUS
BuildDebugThunkInfo(
    IN ULONG TableNumber,
    IN PTHUNK_DEBUG_INFO DebugInfoTable,
    OUT PULONG_PTR *LogTable,
    OUT PULONG_PTR *ApiInfoTable)
/*++

Routine Description:

    This routine fills a service-table-indexed with pointers
    to the corresponding DebugThunkInfo

Arguments:

    DebugInfoTable - Services debug info
    LogTable       - Table of pointers to fill
    ApiInfoTable   - Table of pointers to fill
    

Return Value:

    NTSTATUS
--*/
{
    BOOLEAN InvalidArgumentPresent;
    ULONG ArgIndex;
    ULONG i=0;

    while (DebugInfoTable && DebugInfoTable->ApiName)
    {
        
        LogTable[i] = (PULONG_PTR) DebugInfoTable;

        ApiInfoTable[i++] = (PULONG_PTR) FindApiInMappingTable(DebugInfoTable,TableNumber);

        
        //
        // Walk the argument list to make sure there aren't any NULLs in them, which would
        // terminate the table.
        //

        ArgIndex = 0;
        InvalidArgumentPresent = FALSE;
        while (ArgIndex < DebugInfoTable->NumberOfArg)
        {
            if (!ARGUMENT_PRESENT (DebugInfoTable->Arg[ArgIndex++].Name))
            {
                InvalidArgumentPresent = TRUE;
                break;
            }
        }

        if (InvalidArgumentPresent == TRUE)
        {
            break;
        }

        DebugInfoTable = (PTHUNK_DEBUG_INFO)
                         &DebugInfoTable->Arg[DebugInfoTable->NumberOfArg];
    }

    return STATUS_SUCCESS;
}




NTSTATUS
LogApiHeader(
    PTHUNK_DEBUG_INFO ThunkDebugInfo, 
    PLOGINFO LogInfo,
    BOOLEAN ServiceReturn,
    ULONG_PTR ReturnResult,
    ULONG_PTR ReturnAddress)
/*++

Routine Description:

    Log the Thunked API header

Arguments:

    ThunkDebugInfo - Pointer to service log info
    LogInfo        - Logging Info
    ServiceReturn  - TRUE if called after the thunk API has executed
    ReturnResult   - Result code returned from the API
    ReturnAddress  - Return address of for this thunked call

Return Value:

    NTSTATUS
--*/
{
    if (ServiceReturn) 
    {
        return LogFormat(LogInfo,
                         "wh%s: Ret=%lx-%lx: ",
                         ThunkDebugInfo->ApiName,
                         ReturnResult,
                         ReturnAddress);
    }

    return LogFormat(LogInfo,
                     "%8.8X-wh%s: ",
                     PtrToUlong(NtCurrentTeb()->ClientId.UniqueThread),
                     ThunkDebugInfo->ApiName);
}



NTSTATUS
LogApiParameters(
    IN OUT PLOGINFO LogInfo, 
    IN PULONG Stack32, 
    IN PTHUNK_DEBUG_INFO ThunkDebugInfo, 
    IN BOOLEAN ServiceReturn)
/*++

Routine Description:

    Log the Thunked API Parameters

Arguments:

    LogInfo        - Output log buffer
    Stack32        - Pointer to 32-bit arg stack
    ThunkDebugInfo - Pointer to service log info for the API
    ServiceReturn  - TRUE if called after the Thunk API has executed

Return Value:

    NTSTATUS
--*/
{
    UINT_PTR i=0;

    //
    // Loops thru the parameters
    //
    while (i < ThunkDebugInfo->NumberOfArg) 
    {
        _try 
        {
            LogDataType[ThunkDebugInfo->Arg[i].Type].Handler(
                LogInfo,
                Stack32[i],
                ThunkDebugInfo->Arg[i].Name,
                ServiceReturn);
        }
        _except(EXCEPTION_EXECUTE_HANDLER)
        {
            //
            // Log the bad parameters
            //
            LogFormat(LogInfo,
                      "%s=%lx-%ws ",
                      ThunkDebugInfo->Arg[i].Name,
                      Stack32[i],
                      L"(BAD)");
        }
        i++;
    }

    return STATUS_SUCCESS;
}




NTSTATUS
LogThunkApi(
    IN PTHUNK_LOG_CONTEXT ThunkLogContext,
    IN PTHUNK_DEBUG_INFO ThunkDebugInfo,
    IN UINT_PTR LogFullInfo)
/*++

Routine Description:

    Log the Thunked API

Arguments:

    ThunkLogContext - Thunk API log context
    ThunkDebugInfo  - Pointer to service log info for the API
    LogFullInfo     - Flag whther to log all the API info or just the name

Return Value:

    NTSTATUS
--*/
{
    NTSTATUS NtStatus;
    CHAR szBuf[ MAX_LOG_BUFFER ];
    LOGINFO LogInfo;
    PULONG Stack32 = ThunkLogContext->Stack32;
    BOOLEAN ServiceReturn = ThunkLogContext->ServiceReturn;
    
    //
    // Initialize the log buffer
    //
    LogInfo.OutputBuffer = szBuf;
    LogInfo.BufferSize = MAX_LOG_BUFFER - 1;
    
    //
    // Log API header
    //
    NtStatus = LogApiHeader(ThunkDebugInfo, 
                            &LogInfo, 
                            ServiceReturn, 
                            ThunkLogContext->ReturnResult,
                            *(Stack32-1));

    if (!NT_SUCCESS(NtStatus))
    {
        return NtStatus;
    }

    // Log Parameters
    if (LogFullInfo) 
    {
        NtStatus = LogApiParameters(&LogInfo,
                                    Stack32, 
                                    ThunkDebugInfo, 
                                    ServiceReturn);
        if (!NT_SUCCESS(NtStatus)) 
        {
            return NtStatus;
        }
    }

    //
    // Do actual output
    //
    LogInfo.OutputBuffer[0] = '\0';
    LogOut(szBuf, Wow64LogFlags);
    LogOut("\r\n", Wow64LogFlags);

    return NtStatus;
}




WOW64LOGAPI
NTSTATUS
Wow64LogSystemService(
    IN PTHUNK_LOG_CONTEXT ThunkLogContext)
/*++

Routine Description:

    Logs information for the specified system service.

Arguments:

    LogContext - Thunk API log context

Return Value:

    NTSTATUS
--*/
{
    NTSTATUS NtStatus;
    PTHUNK_DEBUG_INFO ThunkDebugInfo;
    ULONG_PTR TableNumber = ThunkLogContext->TableNumber;
    ULONG_PTR ServiceNumber = ThunkLogContext->ServiceNumber;
    UINT_PTR LogFullInfo;
    PAPI_CATEGORY_MAPPING ApiCategoryMapping;

    //
    // Use try except !!
    //

    _try
    {
        switch(TableNumber)
        {
        case WHNT32_INDEX:
            if (!LF_NTBASE_ENABLED(Wow64LogFlags)) 
            {
                return STATUS_SUCCESS;
            }
            LogFullInfo = (Wow64LogFlags & LF_NTBASE_FULL);
            ThunkDebugInfo = (PTHUNK_DEBUG_INFO)LogNtBase[ServiceNumber];
            ApiCategoryMapping = (PAPI_CATEGORY_MAPPING)(ApiInfoNtBase[ServiceNumber]);

            if( LF_CATLOG_ENABLED(Wow64LogFlags) )
            {
                if(NULL == ApiCategoryMapping)
                {
                    return STATUS_SUCCESS;
                } else
                {
                    // api enabled check
                    if( 0 == (ApiCategoryMapping->ApiFlags & APIFLAG_ENABLED) )
                    {
                        return STATUS_SUCCESS;
                    }

                    // category enabled check
                    if( 0 == (Wow64ApiCategories[ApiCategoryMapping->ApiCategoryIndex].CategoryFlags & CATFLAG_ENABLED) )
                    {
                        return STATUS_SUCCESS;
                    }

                    // log on fail check
                    if( APIFLAG_LOGONFAIL == (ApiCategoryMapping->ApiFlags & APIFLAG_LOGONFAIL) )
                    {
                        if( FALSE == ThunkLogContext->ServiceReturn )
                        {
                            return STATUS_SUCCESS;
                        }

                        if( NT_SUCCESS(ThunkLogContext->ReturnResult) )
                        {
                            return STATUS_SUCCESS;
                        }
                    }
                }
            }
            break;

        case WHCON_INDEX:
            if (!LF_NTCON_ENABLED(Wow64LogFlags) || LogConsole == NULL)
            {
                return STATUS_SUCCESS;
            }
            LogFullInfo = (Wow64LogFlags & LF_NTCON_FULL);
            ThunkDebugInfo = (PTHUNK_DEBUG_INFO)LogConsole[ServiceNumber];
            ApiCategoryMapping = (PAPI_CATEGORY_MAPPING)(ApiInfoConsole[ServiceNumber]);
            
            if( LF_CATLOG_ENABLED(Wow64LogFlags) )
            {
                if(NULL == ApiCategoryMapping)
                {
                    return STATUS_SUCCESS;
                } else
                {
                    // api enabled check
                    if( 0 == (ApiCategoryMapping->ApiFlags & APIFLAG_ENABLED) )
                    {
                        return STATUS_SUCCESS;
                    }

                    // category enabled check
                    if( 0 == (Wow64ApiCategories[ApiCategoryMapping->ApiCategoryIndex].CategoryFlags & CATFLAG_ENABLED) )
                    {
                        return STATUS_SUCCESS;
                    }

                    // log on fail check
                    if( APIFLAG_LOGONFAIL == (ApiCategoryMapping->ApiFlags & APIFLAG_LOGONFAIL) )
                    {
                        if( FALSE == ThunkLogContext->ServiceReturn )
                        {
                            return STATUS_SUCCESS;
                        }

                        if( NT_SUCCESS(ThunkLogContext->ReturnResult) )
                        {
                            return STATUS_SUCCESS;
                        }
                    }
                }
            }
            break;

        case WHWIN32_INDEX:
            if (!LF_WIN32_ENABLED(Wow64LogFlags) || LogWin32 == NULL)
            {
                return STATUS_SUCCESS;
            }
            LogFullInfo = (Wow64LogFlags & LF_WIN32_FULL);
            ThunkDebugInfo = (PTHUNK_DEBUG_INFO)LogWin32[ServiceNumber];
            ApiCategoryMapping = (PAPI_CATEGORY_MAPPING)(ApiInfoWin32[ServiceNumber]);
            
            if( LF_CATLOG_ENABLED(Wow64LogFlags) )
            {
                if(NULL == ApiCategoryMapping)
                {
                    return STATUS_SUCCESS;
                } else
                {
                    // api enabled check
                    if( 0 == (ApiCategoryMapping->ApiFlags & APIFLAG_ENABLED) )
                    {
                        return STATUS_SUCCESS;
                    }

                    // category enabled check
                    if( 0 == (Wow64ApiCategories[ApiCategoryMapping->ApiCategoryIndex].CategoryFlags & CATFLAG_ENABLED) )
                    {
                        return STATUS_SUCCESS;
                    }

                    // log on fail check
                    if( APIFLAG_LOGONFAIL == (ApiCategoryMapping->ApiFlags & APIFLAG_LOGONFAIL) )
                    {
                        if( FALSE == ThunkLogContext->ServiceReturn )
                        {
                            return STATUS_SUCCESS;
                        }

                        if( NT_SUCCESS(ThunkLogContext->ReturnResult) )
                        {
                            return STATUS_SUCCESS;
                        }
                    }
                }
            }
            break;

        case WHBASE_INDEX:
            if (!LF_BASE_ENABLED(Wow64LogFlags))
            {
                return STATUS_SUCCESS;
            }
            LogFullInfo = (Wow64LogFlags & LF_BASE_FULL);
            ThunkDebugInfo = (PTHUNK_DEBUG_INFO)LogBase[ServiceNumber];
            ApiCategoryMapping = (PAPI_CATEGORY_MAPPING)(ApiInfoBase[ServiceNumber]);
            
            if( LF_CATLOG_ENABLED(Wow64LogFlags) )
            {
                if(NULL == ApiCategoryMapping)
                {
                    return STATUS_SUCCESS;
                } else
                {
                    // api enabled check
                    if( 0 == (ApiCategoryMapping->ApiFlags & APIFLAG_ENABLED) )
                    {
                        return STATUS_SUCCESS;
                    }

                    // category enabled check
                    if( 0 == (Wow64ApiCategories[ApiCategoryMapping->ApiCategoryIndex].CategoryFlags & CATFLAG_ENABLED) )
                    {
                        return STATUS_SUCCESS;
                    }

                    // log on fail check
                    if( APIFLAG_LOGONFAIL == (ApiCategoryMapping->ApiFlags & APIFLAG_LOGONFAIL) )
                    {
                        if( FALSE == ThunkLogContext->ServiceReturn )
                        {
                            return STATUS_SUCCESS;
                        }

                        if( NT_SUCCESS(ThunkLogContext->ReturnResult) )
                        {
                            return STATUS_SUCCESS;
                        }
                    }
                }
            }
            break;

        default: // invalid service table
            WOW64LOGOUTPUT((LF_ERROR, "Wow64LogSystemService: Not supported table number - %lx\n", TableNumber));
            return STATUS_UNSUCCESSFUL;
            break;
        }

        NtStatus = LogThunkApi(ThunkLogContext,
                               ThunkDebugInfo,
                               LogFullInfo);
    }
    _except(EXCEPTION_EXECUTE_HANDLER)
    {
        WOW64LOGOUTPUT((LF_EXCEPTION, "Wow64LogSystemService : Invalid Service ServiceTable = %lx, ServiceNumber = %lx. Status=%lx\n", 
                        TableNumber, ServiceNumber, GetExceptionCode()));
        NtStatus = GetExceptionCode();
    }

    return NtStatus;
}




//////////////////////////////////////////////////////////////////////////
//
//                   DATA TYPE LOGGING ROUTINES
//
///////////////////////////////////////////////////////////////////////////

NTSTATUS
LogTypeValue(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn)
/*++

Routine Description:

    Log Data as ULONG

Arguments:

    
    LogInfo       - Output log buffer
    Data          - Value to log
    FieldName     - Descriptive name of value to log
    ServiceReturn - TRUE if called after the thunk API has executed

Return Value:

    NTSTATUS
--*/
{
    if (ServiceReturn)
    {
        return STATUS_SUCCESS;
    }

    return LogFormat(LogInfo,
                     "%s=%lx ",
                     FieldName,
                     (ULONG)Data);
}



NTSTATUS
LogTypeUnicodeString(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn)
/*++

Routine Description:

    Log Data as UNICODE_STRING32

Arguments:

    
    LogInfo       - Output log buffer
    Data          - Value to log
    FieldName     - Descriptive name of value to log
    ServiceReturn - TRUE if called after the thunk API has executed

Return Value:

    NTSTATUS
--*/
{
    UNICODE_STRING32 *Name32;
    PWCHAR Buffer = L" ";

    if (ServiceReturn)
    {
        return STATUS_SUCCESS;
    }

    Name32 = (UNICODE_STRING32 *)Data;
    if (Data > 0xffff)
    {
        if (Name32->Buffer)
        {
            Buffer = (PWCHAR)Name32->Buffer;
        }
        if (Name32->Length && Name32->Buffer > 0xffff) {
            return LogFormat(LogInfo,
                             "%s=%ws ",
                             FieldName,
                             Buffer);
        } else {
            return LogFormat(LogInfo,
                             "%s={L=%x,M=%x,B=%x}",
                             FieldName,
                             Name32->Length,
                             Name32->MaximumLength,
                             Name32->Buffer);
        }
    }

    return LogFormat(LogInfo,
                     "%s=%x",
                     FieldName,
                     Name32);
}


NTSTATUS
LogTypePULongInOut(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn)
/*++

Routine Description:

    Log Data as PULONG

Arguments:

    
    LogInfo       - Output log buffer
    Data          - Value to log
    FieldName     - Descriptive name of value to log
    ServiceReturn - TRUE if called after the thunk API has executed

Return Value:

    NTSTATUS
--*/
{
    return LogFormat(LogInfo,
                     "[%s-%lx]=%lx ",
                     FieldName,
                     (ULONG)Data,
                     ((PULONG)Data ? *((PULONG)Data) : 0));
}



NTSTATUS
LogTypePULongOut(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn)
/*++

Routine Description:

    Log Data as PULONG (Out field)

Arguments:

    
    LogInfo       - Output log buffer
    Data          - Value to log
    FieldName     - Descriptive name of value to log
    ServiceReturn - TRUE if called after the thunk API has executed

Return Value:

    NTSTATUS
--*/
{
    if (ServiceReturn) 
    {
        return LogFormat(LogInfo,
                         "[%s-%lx]=%lx ",
                         FieldName,
                         (PULONG)Data,
                         ((PULONG)Data ? *(PULONG)Data : 0));
    }

    return LogFormat(LogInfo,
                     "%s=%lx ",
                     FieldName,
                     (PULONG)Data);
}


NTSTATUS
LogTypeObjectAttrbiutes(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn)
/*++

Routine Description:

    Log Data as POBJECT_ATTRIBUTES

Arguments:

    
    LogInfo       - Output log buffer
    Data          - Value to log
    FieldName     - Descriptive name of value to log
    ServiceReturn - TRUE if called after the thunk API has executed

Return Value:

    NTSTATUS
--*/
{
    NT32OBJECT_ATTRIBUTES *ObjA32;
    UNICODE_STRING32 *ObjectName = NULL;
    PWCHAR Buffer = L"";

    if (ServiceReturn) 
    {
        return STATUS_SUCCESS;
    }

    ObjA32 = (NT32OBJECT_ATTRIBUTES *)Data;
    if (ObjA32) 
    {
        ObjectName = (UNICODE_STRING32 *)ObjA32->ObjectName;
        if (ObjectName) 
        {
            if (ObjectName->Buffer) 
            {
                Buffer = (PWCHAR)ObjectName->Buffer;
            }
        }
    }


    return LogFormat(LogInfo,
                     "%s=%lx {N=%ws,A=%lx} ",
                     FieldName,
                     (PULONG)Data,
                     Buffer,
                     (ObjA32 ? ObjA32->Attributes : 0));
}


NTSTATUS
LogTypeIoStatusBlock(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn)
/*++

Routine Description:

    Log Data as IO_STATUS_BLOCK

Arguments:

    
    LogInfo       - Output log buffer
    Data          - Value to log
    FieldName     - Descriptive name of value to log
    ServiceReturn - TRUE if called after the thunk API has executed

Return Value:

    NTSTATUS
--*/
{
    if (ServiceReturn) 
    {
        PIO_STATUS_BLOCK32 StatusBlock32 = (PIO_STATUS_BLOCK32)Data;
        
        return LogFormat(LogInfo,
                         "%s={S=%lx,I=%lx} ",
                         FieldName,
                         (PULONG)Data,
                         (StatusBlock32 ? StatusBlock32->Status : 0),
                         (StatusBlock32 ? StatusBlock32->Information : 0));
    }

    return LogFormat(LogInfo,
                     "%s=%lx ",
                     FieldName,
                     (PULONG)Data);
}

NTSTATUS
LogTypePWStr(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn)
/*++

Routine Description:

    Log Data as PWSTR

Arguments:

    
    LogInfo       - Output log buffer
    Data          - Value to log
    FieldName     - Descriptive name of value to log
    ServiceReturn - TRUE if called after the thunk API has executed

Return Value:

    NTSTATUS
--*/
{
    ULONG_PTR i;
    WCHAR Buffer[ 14 ];
    PWSTR String = (PWSTR) Data;

    if (ServiceReturn) 
    {
        return STATUS_SUCCESS;
    }

    //
    // Sometime this type is treated as a pointer
    // to WCHARs without NULL terminating it, like 
    // how it's used in NtGdiExtTextOutW, so let's dump
    // a minimal string
    //
    if (Data) 
    {        
        i = 0;        
        while((i < ((sizeof(Buffer) / sizeof(WCHAR)) - 4)) && (String[i]))
        {
            Buffer[i] = String[i];
            i++;
        }

        if (i == ((sizeof(Buffer) / sizeof(WCHAR)) - 4))
        {
            Buffer[i++] = L'.';
            Buffer[i++] = L'.';
            Buffer[i++] = L'.';
        }
        Buffer[i++] = UNICODE_NULL;
    }


    return LogFormat(LogInfo,
                     "%s=%ws ",
                     FieldName,
                     (Data > 0xffff) ? Buffer : L"");
}



NTSTATUS
LogTypePRectIn(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn)
/*++

Routine Description:

    Log Data as PWSTR

Arguments:

    
    LogInfo       - Output log buffer
    Data          - Value to log
    FieldName     - Descriptive name of value to log
    ServiceReturn - TRUE if called after the thunk API has executed

Return Value:

    NTSTATUS
--*/
{
    if (ServiceReturn) 
    {
        return STATUS_SUCCESS;
    }

    if (Data) 
    {
        PRECT Rect = (PRECT)Data;
        return LogFormat(LogInfo,
                         "%s={%lx,%lx,%lx,%lx} ",
                         FieldName,
                         Rect->left, Rect->top, Rect->right, Rect->bottom);

    }
    
    return LogTypeValue(LogInfo,
                        Data,
                        FieldName,
                        ServiceReturn);
}



NTSTATUS
LogTypePLargeIntegerIn(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn)
/*++

Routine Description:

    Log Data as PLARGE_INTEGER

Arguments:

    
    LogInfo       - Output log buffer
    Data          - Value to log
    FieldName     - Descriptive name of value to log
    ServiceReturn - TRUE if called after the thunk API has executed

Return Value:

    NTSTATUS
--*/
{
    if (ServiceReturn) 
    {
        return STATUS_SUCCESS;
    }

    if (Data) 
    {
        NT32ULARGE_INTEGER *ULargeInt = (NT32ULARGE_INTEGER *)Data;
        return LogFormat(LogInfo,
                         "%s={H=%lx,L=%lx} ",
                         FieldName,
                         ULargeInt->HighPart, ULargeInt->LowPart);

    }
    
    return LogTypeValue(LogInfo,
                        Data,
                        FieldName,
                        ServiceReturn);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64log\w64logp.h ===
/*++
                                                                                
Copyright (c) 1999 Microsoft Corporation

Module Name:

    w64logp.h

Abstract:
    
    Private header for wow64log.dll
    
Author:

    03-OCt-1999   SamerA

Revision History:

--*/

#ifndef _W64LOGP_INCLUDE
#define _W64LOGP_INCLUDE

#define _WOW64LOGAPI_
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <stdio.h>
#include <stdarg.h>
#include "nt32.h"
#include "wow64.h"
#include "wow64log.h"

//
// bring in INVALID_HANDLE_VALUE
//
#include "winbase.h"  


//
// Max buffer size for output logging
//
#define MAX_LOG_BUFFER  1024

//
// Default logging flags if no reg value is found
//
#define LF_DEFAULT      (LF_ERROR)


//
// Prototype for data type handler log function
//
typedef NTSTATUS (*PFNLOGDATATYPEHANDLER)(PLOGINFO, 
                                          ULONG_PTR, 
                                          PSZ,
                                          BOOLEAN);

typedef struct _LOGDATATYPE
{
    PFNLOGDATATYPEHANDLER Handler;
} LOGDATATYPE, *PLOGDATATYPE;

//
// The layout of each entry in thunk debug info should be as follow :
//
// "ServiceName1", ServiceNumber, NumerOfArgument,
// "ArgName1", ArgType1, ...., ArgNameN, ArgTypeN
// "ServiceName2", ...and so on
//

typedef struct _ArgTypes
{
    char *Name;
    ULONG_PTR Type;
} ArgType, *PArgType;

//
// helper structures to help parsing the thunk debugging info
//
typedef struct _ThunkDebugInfo
{
    char *ApiName;
    UINT_PTR ServiceNumber;
    UINT_PTR NumberOfArg;
    ArgType Arg[0];
} THUNK_DEBUG_INFO, *PTHUNK_DEBUG_INFO;

typedef struct _LOGINFO
{
    PSZ OutputBuffer;
    ULONG_PTR BufferSize;
} LOGINFO, *PLOGINFO;


// from whnt32.c
extern PULONG_PTR NtThunkDebugInfo[];

// from whwin32.c
extern PULONG_PTR Win32ThunkDebugInfo[];

// from whcon.c
extern PULONG_PTR ConsoleThunkDebugInfo[];

// from whbase.c
extern PULONG_PTR BaseThunkDebugInfo[];

// from wow64log.c
extern UINT_PTR Wow64LogFlags;
extern HANDLE Wow64LogFileHandle;


NTSTATUS
LogInitializeFlags(
    IN OUT PUINT_PTR Flags);

ULONG
GetThunkDebugTableSize(
    IN PTHUNK_DEBUG_INFO DebugInfoTable);

NTSTATUS
BuildDebugThunkInfo(
    IN ULONG TableNumber,
    IN PTHUNK_DEBUG_INFO DebugInfoTable,
    OUT PULONG_PTR *LogTable,
    OUT PULONG_PTR *ApiInfoTable);

NTSTATUS
LogTypeValue(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn);

NTSTATUS
LogTypeUnicodeString(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn);

NTSTATUS
LogTypePULongInOut(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn);

NTSTATUS
LogTypePULongOut(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn);

NTSTATUS
LogTypeObjectAttrbiutes(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn);

NTSTATUS
LogTypeIoStatusBlock(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn);

NTSTATUS
LogTypePWStr(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn);

NTSTATUS
LogTypePRectIn(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn);

NTSTATUS
LogTypePLargeIntegerIn(
    IN OUT PLOGINFO LogInfo,
    IN ULONG_PTR Data,
    IN PSZ FieldName,
    IN BOOLEAN ServiceReturn);



// from logutil.c
NTSTATUS
LogFormat(
    IN OUT PLOGINFO LogInfo,
    IN PSZ Format,
    ...);

VOID
LogOut(
    IN PSZ Text,
    UINT_PTR Flags
    );

NTSTATUS
LogWriteFile(
   IN HANDLE FileHandle,
   IN PSZ LogText);

NTSTATUS
Wow64LogMessageInternal(
    IN UINT_PTR Flags,
    IN PSZ Format,
    IN ...);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\xip\xipdisk\xipdisk.c ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    XIPDisk.c

Abstract:

    This is the XIP Disk driver for Whistler NT/Embedded.

Author:

    DavePr 18-Sep-2000 -- base one NT4 DDK ramdisk by RobertN 10-Mar-1993.

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/


//
// Include files.
//

#include <ntddk.h>
#include "initguid.h"
#include "mountdev.h"

#include <ntdddisk.h>       // Disk device IOCTLs, DiskClassGuid

#include "fat.h"
#include "xip.h"
#include "XIPDisk.h"


//
// ISSUE-2000/10/11-DavePr -- haven't decided how to define DO_XIP appropriately.
//
#ifndef DO_XIP
#define DO_XIP 0x00020000
#endif

#include <string.h>


NTSTATUS
XIPDiskCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O system when the XIPDisk is opened or
    closed.

    No action is performed other than completing the request successfully.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    STATUS_INVALID_PARAMETER if parameters are invalid,
    STATUS_SUCCESS otherwise.

--*/

{
    PXIPDISK_EXTENSION    diskExtension = NULL;   // ptr to device extension
    PBIOS_PARAMETER_BLOCK bios;
    NTSTATUS              status;

    diskExtension = DeviceObject->DeviceExtension;
    status = XIPDispatch(XIPCMD_NOOP, NULL, 0);

    if (!NT_SUCCESS(status) || !diskExtension->BootParameters.BasePage) {
        status = STATUS_DEVICE_NOT_READY;
    } else {
        status = STATUS_SUCCESS;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
}


NTSTATUS
XIPDiskReadWrite(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O system to read or write to a
    device that we control.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    STATUS_INVALID_PARAMETER if parameters are invalid,
    STATUS_SUCCESS otherwise.

--*/

{
    PXIPDISK_EXTENSION     diskExtension;
    PIO_STACK_LOCATION     irpSp;
    PUCHAR                 bufferAddress, diskByteAddress;
    PUCHAR                 romPageAddress = NULL;
    ULONG_PTR              ioOffset;
    ULONG                  ioLength;
    NTSTATUS               status;

    PHYSICAL_ADDRESS       physicalAddress;
    ULONG                  mappingSize;

    //
    // Set up necessary object and extension pointers.
    //
    diskExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation(Irp);

    //
    // Check for invalid parameters.  It is an error for the starting offset
    // + length to go past the end of the buffer, or for the offset or length
    // not to be a proper multiple of the sector size.
    //
    // Others are possible, but we don't check them since we trust the
    // file system and they aren't deadly.
    //

    if (irpSp->Parameters.Read.ByteOffset.HighPart) {
        status = STATUS_INVALID_PARAMETER;
        goto done;
    }

    ioOffset = irpSp->Parameters.Read.ByteOffset.LowPart;
    ioLength = irpSp->Parameters.Read.Length;

    if (ioLength == 0) {
        status = STATUS_SUCCESS;
        goto done;
    }

    if (ioOffset + ioLength < ioOffset) {
        status = STATUS_INVALID_PARAMETER;
        goto done;
    }

    if ((ioOffset | ioLength) & (diskExtension->BiosParameters.BytesPerSector - 1)) {
        status = STATUS_INVALID_PARAMETER;
        goto done;

    }

    if ((ioOffset + ioLength) > (diskExtension->BootParameters.PageCount * PAGE_SIZE)) {
        status = STATUS_NONEXISTENT_SECTOR;
        goto done;
    }

    if (irpSp->MajorFunction == IRP_MJ_WRITE && diskExtension->BootParameters.ReadOnly) {
        status = STATUS_MEDIA_WRITE_PROTECTED;
        goto done;
    }

    //
    // Map the pages in the ROM into system space
    //
    mappingSize = ADDRESS_AND_SIZE_TO_SPAN_PAGES (ioOffset, ioLength) * PAGE_SIZE;

    //
    // Get a system-space pointer to the disk region.
    //
    physicalAddress.QuadPart = (diskExtension->BootParameters.BasePage + (ioOffset/PAGE_SIZE)) * PAGE_SIZE;

    romPageAddress = MmMapIoSpace(physicalAddress, mappingSize, MmCached);
    if (! romPageAddress) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    } 

    diskByteAddress = romPageAddress + (ioOffset & (PAGE_SIZE-1));

    //
    // Get a system-space pointer to the user's buffer.  A system
    // address must be used because we may already have left the
    // original caller's address space.
    //

    Irp->IoStatus.Information = irpSp->Parameters.Read.Length;

    ASSERT (Irp->MdlAddress != NULL);

    bufferAddress = MmGetSystemAddressForMdlSafe( Irp->MdlAddress, NormalPagePriority );

    if (! bufferAddress) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto done;
    }

    status = STATUS_SUCCESS;

    switch (irpSp->MajorFunction) {
    case IRP_MJ_READ:
        RtlCopyMemory( bufferAddress, diskByteAddress, ioLength );
        break;

    case IRP_MJ_WRITE:
        RtlCopyMemory( diskByteAddress, bufferAddress, ioLength );
        break;

    default:
        ASSERT(FALSE);
        status = STATUS_INVALID_PARAMETER;
    }

done:
    if (romPageAddress) {
        MmUnmapIoSpace (romPageAddress, mappingSize);
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
}


NTSTATUS
XIPDiskDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to perform a device I/O
    control function.

Arguments:

    DeviceObject - a pointer to the object that represents the device
        that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    STATUS_SUCCESS if recognized I/O control code,
    STATUS_INVALID_DEVICE_REQUEST otherwise.

--*/

{
    PBIOS_PARAMETER_BLOCK bios;
    PXIPDISK_EXTENSION   diskExtension;
    PIO_STACK_LOCATION   irpSp;
    NTSTATUS             status;
    ULONG                info;

    //
    // Set up necessary object and extension pointers.
    //

    diskExtension = DeviceObject->DeviceExtension;
    bios = &diskExtension->BiosParameters;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // Assume failure.
    //
    status = STATUS_INVALID_DEVICE_REQUEST;
    info = 0;

    //
    // Determine which I/O control code was specified.
    //
    switch (irpSp->Parameters.DeviceIoControl.IoControlCode) {
    
    case IOCTL_DISK_GET_MEDIA_TYPES:
    case IOCTL_STORAGE_GET_MEDIA_TYPES:
    case IOCTL_DISK_GET_DRIVE_GEOMETRY:
        //
        // Return the drive geometry for the virtual disk.  Note that
        // we return values which were made up to suit the disk size.
        //

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(DISK_GEOMETRY)) {

            status = STATUS_INVALID_PARAMETER;
            
        } else {

            PDISK_GEOMETRY outputBuffer;

            outputBuffer = (PDISK_GEOMETRY) Irp->AssociatedIrp.SystemBuffer;

            outputBuffer->MediaType          = FixedMedia;
            outputBuffer->Cylinders.QuadPart = diskExtension->NumberOfCylinders;
            outputBuffer->TracksPerCylinder  = diskExtension->TracksPerCylinder;
            outputBuffer->SectorsPerTrack    = bios->SectorsPerTrack;
            outputBuffer->BytesPerSector     = bios->BytesPerSector;

            status = STATUS_SUCCESS;
            info = sizeof( DISK_GEOMETRY );
        }
        break;

#if 0
    //
    // Ignore these IOCTLs for now.
    //
    case IOCTL_DISK_SET_PARTITION_INFO: 
    case IOCTL_DISK_SET_DRIVE_LAYOUT: 
        status = STATUS_SUCCESS;
        break;
#endif

    case IOCTL_DISK_GET_PARTITION_INFO: 
        //
        // Return the information about the partition.
        //

        if (irpSp->Parameters.DeviceIoControl.OutputBufferLength < sizeof(PARTITION_INFORMATION)) {

            status = STATUS_INVALID_PARAMETER;

        } else {

            PPARTITION_INFORMATION outputBuffer;
        
            outputBuffer = (PPARTITION_INFORMATION) Irp->AssociatedIrp.SystemBuffer;
        
            //
            // Fat hardwired here...
            //
            outputBuffer->PartitionType =  PARTITION_FAT_16;
            outputBuffer->BootIndicator = diskExtension->BootParameters.SystemDrive;
            outputBuffer->RecognizedPartition = TRUE;
            outputBuffer->RewritePartition = FALSE;
            outputBuffer->StartingOffset.QuadPart = 0;
            outputBuffer->PartitionLength.QuadPart = diskExtension->BootParameters.PageCount * PAGE_SIZE;
            outputBuffer->HiddenSectors =  diskExtension->BiosParameters.HiddenSectors;
        
            status = STATUS_SUCCESS;
            info = sizeof(PARTITION_INFORMATION);
        }
        break;


    case IOCTL_DISK_VERIFY:
        {
            PVERIFY_INFORMATION	verifyInformation;
            ULONG               buflen;
            ULONG_PTR           ioOffset;
            ULONG               ioLength;

            buflen = irpSp->Parameters.DeviceIoControl.InputBufferLength;

            if ( buflen < sizeof(VERIFY_INFORMATION) ) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            verifyInformation = Irp->AssociatedIrp.SystemBuffer;

            if (verifyInformation->StartingOffset.HighPart) {
                status = STATUS_DISK_CORRUPT_ERROR;
                break;
            }

            ioOffset = verifyInformation->StartingOffset.LowPart;
            ioLength = verifyInformation->Length;

            if (ioLength == 0) {
                status = STATUS_SUCCESS;

            } else if ((ioOffset | ioLength) & (diskExtension->BiosParameters.BytesPerSector - 1)) {
                status = STATUS_INVALID_PARAMETER;

            } else if ((ioOffset + ioLength) > (diskExtension->BootParameters.PageCount * PAGE_SIZE)) {
                status = STATUS_NONEXISTENT_SECTOR;

            } else {
                status = STATUS_SUCCESS;
            }
            break;
        }

    case IOCTL_DISK_IS_WRITABLE:
        status = diskExtension->BootParameters.ReadOnly? STATUS_MEDIA_WRITE_PROTECTED : STATUS_SUCCESS;
        break;

    case IOCTL_DISK_CHECK_VERIFY:
    case IOCTL_STORAGE_CHECK_VERIFY:
    case IOCTL_STORAGE_CHECK_VERIFY2:
        status = STATUS_SUCCESS;
        break;

    default:
        //
        // The specified I/O control code is unrecognized by this driver.
        // The I/O status field in the IRP has already been set so just
        // terminate the switch.
        //

#if DBG
        DbgPrint("XIPDisk:  ERROR:  unrecognized IOCTL %x\n",
                    irpSp->Parameters.DeviceIoControl.IoControlCode);
#endif
        break;

    case IOCTL_MOUNTDEV_QUERY_DEVICE_NAME:
        {
            PMOUNTDEV_NAME mountName;
            ULONG outlen;

            outlen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

            if ( outlen < sizeof(MOUNTDEV_NAME) ) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            mountName = Irp->AssociatedIrp.SystemBuffer;
            mountName->NameLength = diskExtension->DeviceName.Length;

            if ( outlen < mountName->NameLength + sizeof(WCHAR)) {
                status = STATUS_BUFFER_OVERFLOW;
                info = sizeof(MOUNTDEV_NAME);
                break;
            }

            RtlCopyMemory( mountName->Name, diskExtension->DeviceName.Buffer, mountName->NameLength);

            status = STATUS_SUCCESS;
            info = mountName->NameLength + sizeof(WCHAR);
            break;
        }

    case IOCTL_MOUNTDEV_QUERY_UNIQUE_ID:
        {
            PMOUNTDEV_UNIQUE_ID uniqueId;
            ULONG outlen;

            outlen = irpSp->Parameters.DeviceIoControl.OutputBufferLength;

            if (outlen < sizeof(MOUNTDEV_UNIQUE_ID)) {
                status = STATUS_INVALID_PARAMETER;
                break;
            }

            uniqueId = Irp->AssociatedIrp.SystemBuffer;
            uniqueId->UniqueIdLength = sizeof(XIPDISK_DEVICENAME);

            if (outlen < uniqueId->UniqueIdLength) {
                status = STATUS_BUFFER_OVERFLOW;
                info = sizeof(MOUNTDEV_UNIQUE_ID);
                break;
            }

            RtlCopyMemory( uniqueId->UniqueId, XIPDISK_DEVICENAME, uniqueId->UniqueIdLength );

            status = STATUS_SUCCESS;
            info = uniqueId->UniqueIdLength;
            break;
        }

        case IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME:
        {
            status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }
    }

    //
    // Finish the I/O operation by simply completing the packet and returning
    // the same status as in the packet itself.
    // Note that IoCompleteRequest may deallocate Irp before returning.
    //
    Irp->IoStatus.Information = info;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
}

VOID
XIPDiskUnloadDriver(
    IN PDRIVER_OBJECT DriverObject
    )
/*++

Routine Description:

    This routine is called by the I/O system to unload the driver.

    Any resources previously allocated must be freed.

Arguments:

    DriverObject - a pointer to the object that represents our driver.

Return Value:

    None
--*/

{
    PDEVICE_OBJECT      deviceObject = DriverObject->DeviceObject;
    PXIPDISK_EXTENSION  diskExtension = deviceObject->DeviceExtension;

    RtlFreeUnicodeString(&diskExtension->InterfaceString);
    diskExtension->InterfaceString.Buffer = NULL;

    if (deviceObject != NULL) {
        IoDeleteDevice( deviceObject );
    }
}

NTSTATUS
DriverEntry(
    IN OUT PDRIVER_OBJECT   DriverObject,
    IN     PUNICODE_STRING  RegistryPath
    )
/*++

Routine Description:
    This routine is called by the Operating System to initialize the driver.

Arguments:
    DriverObject - a pointer to a device extension object for the XIPDisk driver.

    RegistryPath - a pointer to our Services key in the registry.

Return Value:
    STATUS_SUCCESS if this disk is initialized; an error otherwise.

--*/

{
    XIP_BOOT_PARAMETERS   xipbootparameters;
    PBIOS_PARAMETER_BLOCK bios;
    NTSTATUS              status;

//  UNICODE_STRING        deviceName;
    UNICODE_STRING        realDeviceName;
    UNICODE_STRING        dosSymlink;
    UNICODE_STRING        driveLetter;

    PDEVICE_OBJECT        pdo = NULL;
    PDEVICE_OBJECT        deviceObject;

    PXIPDISK_EXTENSION    ext = NULL;   // ptr to device extension

    //
    // Read the parameters from the registry
    //
    status = XIPDispatch(XIPCMD_GETBOOTPARAMETERS, &xipbootparameters, sizeof(xipbootparameters));
    if (!NT_SUCCESS(status)) {
        return status;
    }

    if (xipbootparameters.BasePage == 0) {
        return STATUS_NO_SUCH_DEVICE;
    }

    // Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] = XIPDiskCreateClose;
    DriverObject->MajorFunction[IRP_MJ_CLOSE] = XIPDiskCreateClose;
    DriverObject->MajorFunction[IRP_MJ_READ] = XIPDiskReadWrite;
    DriverObject->MajorFunction[IRP_MJ_WRITE] = XIPDiskReadWrite;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = XIPDiskDeviceControl;

    //
    // Create and initialize a device object for the disk.
    //
    ObReferenceObject(DriverObject);

    status = IoReportDetectedDevice(
                 DriverObject,
                 InterfaceTypeUndefined,
                 -1,
                 -1,
                 NULL,
                 NULL,
                 TRUE,
                 &pdo
             );
    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Create the XIP root device.
    //

    RtlInitUnicodeString(&realDeviceName,  XIPDISK_DEVICENAME);

    status = IoCreateDevice( DriverObject,
                               sizeof( XIPDISK_EXTENSION ),
                               &realDeviceName,
                               FILE_DEVICE_VIRTUAL_DISK,
                               0,
                               FALSE,
                               &deviceObject );

    if (!NT_SUCCESS(status)) {
        return status;
    }

    // ISSUE-2000/10/14-DavePr -- Hardwiring the driveLetter because I haven't
    // figured out how to get the mountmgr to give out a drive letter. Naming
    // it as a form of floppy (deviceName) was one suggestion that failed (so far).
    // The dosSymlink isn't really necessary, but is another

    //
    // Create symbolic links.  Ignore failures
    //
//  RtlInitUnicodeString(&deviceName,  XIPDISK_FLOPPYNAME);
    RtlInitUnicodeString(&dosSymlink,  XIPDISK_DOSNAME);
    RtlInitUnicodeString(&driveLetter, XIPDISK_DRIVELETTER);

//  (void) IoCreateSymbolicLink(&deviceName,  &realDeviceName);
    (void) IoCreateSymbolicLink(&dosSymlink,  &realDeviceName);
    (void) IoCreateSymbolicLink(&driveLetter, &realDeviceName);

    //
    // Initialize device object and extension.
    //
    deviceObject->Flags |= DO_DIRECT_IO | DO_XIP;
    deviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;

    ext = deviceObject->DeviceExtension;

    bios = &ext->BiosParameters;

    //
    // Initialize the newly allocated disk extension from our temporary
    // Get the bios boot parameters from the kernel
    //
    ext->BootParameters = xipbootparameters;
    status = XIPDispatch(XIPCMD_GETBIOSPARAMETERS, bios, sizeof(*bios));

    //
    // Fill in the device objects
    //
    ext->DeviceObject = deviceObject;
//  ext->DeviceName = deviceName;
    ext->DeviceName = realDeviceName;

    ext->TracksPerCylinder = 1;
    ext->BytesPerCylinder  = bios->BytesPerSector * bios->SectorsPerTrack * ext->TracksPerCylinder;
    ext->NumberOfCylinders = (ULONG)(ext->BootParameters.PageCount * PAGE_SIZE / ext->BytesPerCylinder);

  
    //
    // Attach the root device
    //
    ext->TargetObject = IoAttachDeviceToDeviceStack(deviceObject, pdo);

    if (!ext->TargetObject) {
//      IoDeleteSymbolicLink(&deviceName);
        IoDeleteSymbolicLink(&dosSymlink);
        IoDeleteSymbolicLink(&driveLetter);
        IoDeleteSymbolicLink(&realDeviceName);
        IoDeleteDevice(deviceObject);
        return STATUS_NO_SUCH_DEVICE;
    }

    ext->UnderlyingPDO = pdo;

    status = IoRegisterDeviceInterface(pdo,
                                       (LPGUID)&DiskClassGuid,
                                       NULL,
                                       &ext->InterfaceString );
    if (NT_SUCCESS(status)) {
        status = IoSetDeviceInterfaceState( &ext->InterfaceString, TRUE );
        if (!NT_SUCCESS(status)) {
            DbgPrint("XIP: Warning: ignored failure %x retruned by IoSetDeviceInterface\n", status);
        }
    } else {
        DbgPrint("XIP: Warning: ignored failure %x retruned by IoRegisterDeviceInterface\n", status);
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64svc\server\wow64svc.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sources

Abstract:

    main file for the wow64svc 

Author:

    ATM Shafiqul Khalid (askhalid) 3-March-2000

Revision History:

--*/

#ifndef __WOW64_SVC_H__
#define __WOW64_SVC_H__

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <tchar.h>
#include <time.h>
#include "wow64reg.h"



#define WOW64_SERVICE_NAME            TEXT("Wow64")
#define WOW64_DISPLAY_NAME            TEXT("Wow64 Service ")
#define WOW64_DRIVER_NAME             TEXT("Windows NT Wow64 Driver")
#define WOW64_MONITOR_NAME            TEXT("Windows NT Wow64 Monitor")
#define WOW64_IMAGE_NAME              TEXT("%systemroot%\\system32\\Wow64.exe")
#define WOW64_FILE_PREFIX             TEXT("Wow64")
#define WOW64_EXTENSION_NAME          TEXT("Microsoft Routing Extension")



//
// We need to move messages to log file.
//

#if DBG
#define SvcDebugPrint(x) printf x
#else
#define SvcDebugPrint(x) ;
#endif


VOID
Wow64ServiceMain(
    DWORD argc,
    LPTSTR *argv
    );

DWORD
InstallService(
    LPTSTR  Username,
    LPTSTR  Password
    );

DWORD
RemoveService(
    void
    );

VOID
Wow64ServiceCtrlHandler(
    DWORD Opcode
    );

DWORD
ReportServiceStatus(
    DWORD CurrentState,
    DWORD Win32ExitCode,
    DWORD WaitHint
    );
 
DWORD
ServiceStart(
    VOID
    );

void 
EndWow64Svc(
    BOOL bEndProcess,
    DWORD SeverityLevel
    );

DWORD
ServiceStop(
    void
    );

DWORD
StartWow64Service ();

DWORD
StopWow64Service ();

DWORD
QueryWow64Service ();

//should goto wow64reg.h
BOOL
PopulateReflectorTable ();

//_________________________________________

#endif //__WOW64_SVC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\wow64\wow64svc\server\wow64svc.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    sources

Abstract:

    main file for the wow64svc 

Author:

    ATM Shafiqul Khalid (askhalid) 3-March-2000

Revision History:

--*/



#include "Wow64svc.h"

BOOL
SetWow64InitialRegistryLayout ();

SERVICE_STATUS          Wow64ServiceStatus;
SERVICE_STATUS_HANDLE   Wow64ServiceStatusHandle;
BOOL                    ServiceDebug;
HANDLE                  Wow64SvcHeapHandle;

SERVICE_TABLE_ENTRY   ServiceDispatchTable[] = {
    { WOW64_SERVICE_NAME,   Wow64ServiceMain    },
    { NULL,               NULL              }
};

LPTSTR NextParam ( 
    LPTSTR lpStr
    )
/*++

Routine Description

    Point to the next parameter in the commandline.

Arguments:

    lpStr - pointer to the current command line


Return Value:

    TRUE if the function succeed, FALSE otherwise.

--*/
{
	WCHAR ch = L' ';
		

    if (lpStr == NULL ) 
        return NULL;

    if ( *lpStr == 0 ) 
        return lpStr;

    while (  ( *lpStr != 0 ) && ( lpStr[0] != ch )) {

		if ( ( lpStr [0] == L'\"')  || ( lpStr [0] == L'\'') ) 
			ch = lpStr [0];

        lpStr++;
	}

	if ( ch !=L' ' ) lpStr++;

    while ( ( *lpStr != 0 ) && (lpStr[0] == L' ') )
        lpStr++;

    return lpStr;
}

DWORD CopyParam ( 
    LPTSTR lpDestParam, 
    LPTSTR lpCommandParam
    )
/*++

Routine Description

    Copy the current parameter to lpDestParam.

Arguments:

    lpDestParam - that receive current parameter
    lpCommandParam - pointer to the current command line


Return Value:

    TRUE if the function succeed, FALSE otherwise.

--*/

{
	DWORD dwLen = 0;
	WCHAR ch = L' ';

	*lpDestParam = 0;
	
	if ( ( lpCommandParam [0] == L'\"')  || ( lpCommandParam [0] == L'\'') ) {
		ch = lpCommandParam [0];
		lpCommandParam++;
	};


    while ( ( lpCommandParam [0] ) != ch && ( lpCommandParam [0] !=0 ) ) {
        *lpDestParam++ = *lpCommandParam++;
		dwLen++;

		if ( dwLen>255 ) return FALSE;
	}

	if ( ch != L' ' && ch != lpCommandParam [0] )
		return FALSE;
	else lpCommandParam++;

    *lpDestParam = 0;

	return TRUE;

}


int __cdecl 
main()

/*++

Routine Description:

    Main entry point for the TIFF image viewer.


Arguments:

    None.

Return Value:

    Return code, zero for success.

--*/

{
    int     rVal;
    HKEY hKey;
    DWORD Ret;

    LPTSTR  p;
    DWORD   Action = 0;
    LPTSTR  Username;
    LPTSTR  Password;

    PWCHAR lptCmdLine = GetCommandLine ();

    SvcDebugPrint(("\nWow64svc module......%S", lptCmdLine));
 
    lptCmdLine = NextParam ( lptCmdLine );

    while (  ( lptCmdLine != NULL ) && ( lptCmdLine[0] != 0 )  ) {

        if ( lptCmdLine[0] != L'-' && lptCmdLine[0] != L'/')  {
            SvcDebugPrint ( ("\nSorry! incorrect parameter....."));
            SvcDebugPrint ( ("\n Uses: wow64svc -[i/r/d]"));
            return FALSE;
        }

        switch ( lptCmdLine[1] ) {

            case L'i':
            case L'I': 
                
                //
                // Temporary heck ignore installing this service
                // You can delete the registry key as well for the initial sync
                //
                      InitializeWow64OnBoot (2);
                      //
                      // write sync value Key.....
                      //
                      hKey = OpenNode (L"\\REGISTRY\\MACHINE\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\RunOnce");
                      if (hKey != NULL)
                      {
                          Ret = RegSetValueEx(
                                hKey,
                                L"WOW64_SYNC",
                                0,
                                REG_SZ,
                                (PBYTE)L"wow64.exe -y",
                                sizeof (L"wow64.exe -y")
                                );
                          RegCloseKey (hKey);
                      }

                      return 0;
                      

            case L'r':
            case L'R':Action = 2;
                      break;

            case L'd':
            case L'D':
                Action = 3;
                break;

            case L's':
            case L'S':
                StartWow64Service ();
                return 0;
                break;

            case L'x':
            case L'X':
                StopWow64Service ();
                return 0;
                break;

            case L'q':
            case L'Q':
                QueryWow64Service ();
                return 0;
                break;

            case L'y':
            case L'Y':
                //
                // Initial Sync registry
                //
                Wow64SyncCLSID ();
                return 0;
            
            default:
                SvcDebugPrint ( ("\nSorry! incorrect parameter.....pass2"));
                SvcDebugPrint ( ("\n Uses: wow64svc -[i/r/d]"));
                return FALSE;
        }

        lptCmdLine = NextParam ( lptCmdLine );
    }

    switch( Action ) {
        case 1:
            rVal = InstallService( NULL, NULL );
            if (rVal == 0) {
                //LogMessage( MSG_INSTALL_SUCCESS );
            } else {
                //LogMessage( MSG_INSTALL_FAIL, GetLastErrorText( rVal ) );
            }
            return rVal;

        case 2:
            rVal = RemoveService();
            if (rVal == 0) {
                //LogMessage( MSG_REMOVE_SUCCESS );
            } else {
                //LogMessage( MSG_REMOVE_FAIL, GetLastErrorText( rVal ) );
            }
            return rVal;

        case 3:
            ServiceDebug = TRUE;
            //ConsoleDebugOutput = TRUE;
            return ServiceStart();
    }


    SvcDebugPrint ( ("\nAttempt to run as a survice ......."));

    if (!InitReflector ())
        SvcDebugPrint ( ("\nSorry! couldn't initialize reflector thread, exiting"));

    if (!StartServiceCtrlDispatcher( ServiceDispatchTable)) {

        rVal = GetLastError();
        SvcDebugPrint(( "StartServiceCtrlDispatcher error =%d", rVal ));
        return rVal;
    }
    
    return 0;
}

DWORD
InstallService(
    LPTSTR  Username,
    LPTSTR  Password
    )

/*++

Routine Description:

    Service installation function.  This function just
    calls the service controller to install the Wow64 service.
    It is required that the Wow64 service run in the context
    of a user so that the service can access MAPI, files on
    disk, the network, etc.

Arguments:

    Username    - User name where the service runs.
    Password    - Password for the user name.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    DWORD       rVal = 0;
    SC_HANDLE   hSvcMgr;
    SC_HANDLE   hService;

    //
    // do the registration for the reflector thread in the registry.
    //
    PopulateReflectorTable ();

    SvcDebugPrint ( ("\nInstalling service........"));
    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        rVal = GetLastError();
        SvcDebugPrint(( "\ncould not open service manager: error code = %u", rVal ));
        return rVal;
    }

    hService = CreateService(
            hSvcMgr,
            WOW64_SERVICE_NAME,
            WOW64_DISPLAY_NAME,
            SERVICE_ALL_ACCESS,
            SERVICE_WIN32_OWN_PROCESS,
            SERVICE_AUTO_START, //SERVICE_DEMAND_START, //SERVICE_AUTO_START,
            SERVICE_ERROR_NORMAL,
            WOW64_IMAGE_NAME,
            NULL,
            NULL,
            NULL,
            Username,
            Password
            );
    if (!hService) {
        rVal = GetLastError();
        SvcDebugPrint(( "\ncould not create Wow64 service: error code = %u", rVal ));
        return rVal;
    }

    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    SvcDebugPrint ( ("\nInstalled services with ret code: %d", rVal));
    return rVal;
}


DWORD
RemoveService(
    void
    )

/*++

Routine Description:

    Service removal function.  This function just
    calls the service controller to remove the Wow64 service.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    DWORD       rVal = 0;
    SC_HANDLE   hSvcMgr;
    SC_HANDLE   hService;


    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        rVal = GetLastError();
        SvcDebugPrint(( "could not open service manager: error code = %u", rVal ));
        return rVal;
    }

    hService = OpenService(
        hSvcMgr,
        WOW64_SERVICE_NAME,
        SERVICE_ALL_ACCESS
        );
    if (!hService) {
        rVal = GetLastError();
        SvcDebugPrint(( "could not open the Wow64 service: error code = %u", rVal ));
        return rVal;
    }

    if (ControlService( hService, SERVICE_CONTROL_STOP, &Wow64ServiceStatus )) {
        //
        // wait for 1 second
        //
        Sleep( 1000 );

        while( QueryServiceStatus( hService, &Wow64ServiceStatus ) ) {
            if ( Wow64ServiceStatus.dwCurrentState == SERVICE_STOP_PENDING ) {
                Sleep( 1000 );
            } else {
                break;
            }
        }

        if (Wow64ServiceStatus.dwCurrentState != SERVICE_STOPPED) {
            rVal = GetLastError();
            SvcDebugPrint(("could not stop the Wow64 service: error code = %u", rVal ));
            return rVal;
        }
    }

    if (!DeleteService( hService )) {
        rVal = GetLastError();
        SvcDebugPrint(( "could not delete the Wow64 service: error code = %u", rVal ));
        return rVal;
    }

    CloseServiceHandle( hService );
    CloseServiceHandle( hSvcMgr );

    return rVal;
}


VOID
Wow64ServiceMain(
    DWORD argc,
    LPTSTR *argv
    )

/*++

Routine Description:

    This is the service main that is called by the
    service controller.

Arguments:

    argc        - argument count
    argv        - argument array

Return Value:

    None.

--*/

{
    DWORD Rval;

    //
    // Setup initial registry link and layout for wow64 after boot.
    //
    SetWow64InitialRegistryLayout ();

    Wow64ServiceStatus.dwServiceType        = SERVICE_WIN32;
    Wow64ServiceStatus.dwCurrentState       = SERVICE_START_PENDING;
    Wow64ServiceStatus.dwControlsAccepted   = SERVICE_ACCEPT_STOP | SERVICE_ACCEPT_PAUSE_CONTINUE;
    Wow64ServiceStatus.dwWin32ExitCode      = 0;
    Wow64ServiceStatus.dwServiceSpecificExitCode = 0;
    Wow64ServiceStatus.dwCheckPoint         = 0;
    Wow64ServiceStatus.dwWaitHint           = 0;

    Wow64ServiceStatusHandle = RegisterServiceCtrlHandler(
        WOW64_SERVICE_NAME,
        Wow64ServiceCtrlHandler
        );

    if (!Wow64ServiceStatusHandle) {
        SvcDebugPrint(( "RegisterServiceCtrlHandler failed %d", GetLastError() ));
        return;
    }

    
    Rval = ServiceStart();
    if (Rval) {
        //
        // the service failed to start correctly
        //
        ReportServiceStatus( SERVICE_RUNNING, 0, 0);
        return;

    }

    ReportServiceStatus( SERVICE_RUNNING, 0, 0);
    return;
}


VOID
Wow64ServiceCtrlHandler(
    DWORD Opcode
    )

/*++

Routine Description:

    This is the Wow64 service control dispatch function.

Arguments:

    Opcode      - requested control code

Return Value:

    None.

--*/

{
    switch(Opcode) {
        case SERVICE_CONTROL_PAUSE:
            ReportServiceStatus( SERVICE_PAUSED, 0, 0 );
            break;

        case SERVICE_CONTROL_CONTINUE:
            ReportServiceStatus( SERVICE_RUNNING, 0, 0 );
            break;

        case SERVICE_CONTROL_STOP:
            if (ServiceStop () == 0)
                ReportServiceStatus( SERVICE_STOPPED, 0, 0 );
            return;

        case SERVICE_CONTROL_INTERROGATE:
            // fall through to send current status
            break;

        default:
            SvcDebugPrint(( "Unrecognized opcode %ld", Opcode ));
            break;
    }

    ReportServiceStatus( 0, 0, 0 );

    return;
}


DWORD
ReportServiceStatus(
    DWORD CurrentState,
    DWORD Win32ExitCode,
    DWORD WaitHint
    )

/*++

Routine Description:

    This function updates the service control manager's status information for the Wow64 service.

Arguments:

    CurrentState    - Indicates the current state of the service
    Win32ExitCode   - Specifies a Win32 error code that the service uses to
                      report an error that occurs when it is starting or stopping.
    WaitHint        - Specifies an estimate of the amount of time, in milliseconds,
                      that the service expects a pending start, stop, or continue
                      operation to take before the service makes its next call to the
                      SetServiceStatus function with either an incremented dwCheckPoint
                      value or a change in dwCurrentState.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    static DWORD CheckPoint = 1;
    BOOL rVal;

    Wow64ServiceStatus.dwCurrentState = CurrentState;

/*
    if (CurrentState == SERVICE_START_PENDING) {
        Wow64ServiceStatus.dwControlsAccepted = 0;
    } else {
        Wow64ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    }

    if (CurrentState) {
        Wow64ServiceStatus.dwCurrentState = CurrentState;
    }
    Wow64ServiceStatus.dwWin32ExitCode = Win32ExitCode;
    Wow64ServiceStatus.dwWaitHint = WaitHint;

    if ((Wow64ServiceStatus.dwCurrentState == SERVICE_RUNNING) ||
        (Wow64ServiceStatus.dwCurrentState == SERVICE_STOPPED ) ) {
        Wow64ServiceStatus.dwCheckPoint = 0;
    } else {
        Wow64ServiceStatus.dwCheckPoint = CheckPoint++;
    }
    */

    //
    // Report the status of the service to the service control manager.
    //
    rVal = SetServiceStatus( Wow64ServiceStatusHandle, &Wow64ServiceStatus );
    if (!rVal) {
        SvcDebugPrint(( "SetServiceStatus() failed: ec=%d", GetLastError() ));
    }

    return rVal;
}

DWORD
StartWow64Service ()
/*++

Routine Description:

    This function Start wow64 service.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/

{
    DWORD rVal=0;
    SC_HANDLE   hSvcMgr;
    SC_HANDLE   hService;

    SvcDebugPrint ( ("\ntrying to start  service......"));

    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        rVal = GetLastError();
        SvcDebugPrint(( "\ncould not open service manager: error code = %u", rVal ));
        return rVal;
    }

     hService = OpenService( hSvcMgr, WOW64_SERVICE_NAME, SERVICE_ALL_ACCESS );

     if ( !hService ) {

         rVal = GetLastError();
         SvcDebugPrint(( "\ncould not open service:%s error code = %u", WOW64_SERVICE_NAME, rVal ));
         return rVal;
     }

     if (! StartService( hService, 0, NULL) ) {

         rVal = GetLastError();
         SvcDebugPrint(( "\ncould not start service:%s error code = %u", WOW64_SERVICE_NAME, rVal ));
         return rVal;
     }

     SvcDebugPrint(( "\nservice:%s started successfully error code = %u", WOW64_SERVICE_NAME, rVal ));
     return 0;

}

DWORD
StopWow64Service ()
/*++

Routine Description:

    This function Stop wow64 service.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/
{
    DWORD rVal=0;
    SC_HANDLE   hSvcMgr;
    SC_HANDLE   hService;

    SvcDebugPrint ( ("\ntrying to start  service......"));
    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        rVal = GetLastError();
        SvcDebugPrint(( "\ncould not open service manager: error code = %u", rVal ));
        return rVal;
    }

     hService = OpenService( hSvcMgr, WOW64_SERVICE_NAME, SERVICE_ALL_ACCESS );

     if ( !hService ) {

         rVal = GetLastError();
         SvcDebugPrint(( "\ncould not open service:%S error code = %u", WOW64_SERVICE_NAME, rVal ));
         return rVal;
     }

     if (!ControlService( hService, SERVICE_CONTROL_PAUSE, &Wow64ServiceStatus )) {

         rVal = GetLastError();
         SvcDebugPrint(( "\nSorry! couldn't stop the service:%S error code = %u", WOW64_SERVICE_NAME, rVal ));
         return rVal;
     }
  

     SvcDebugPrint(( "\nservice:%S stopped successfully error code = %u", WOW64_SERVICE_NAME, rVal ));
     return 0;

}

DWORD
QueryWow64Service ()
/*++

Routine Description:

    This function log the current status of wow64 service.

Arguments:

    None.

Return Value:

    Return code.  Return zero for success, all other
    values indicate errors.

--*/
{
    DWORD rVal=0;
    SC_HANDLE   hSvcMgr;
    SC_HANDLE   hService;

    SvcDebugPrint ( ("\ntrying to start  service......"));
    hSvcMgr = OpenSCManager(
        NULL,
        NULL,
        SC_MANAGER_ALL_ACCESS
        );
    if (!hSvcMgr) {
        rVal = GetLastError();
        SvcDebugPrint(( "\ncould not open service manager: error code = %u", rVal ));
        return rVal;
    }

     hService = OpenService( hSvcMgr, WOW64_SERVICE_NAME, SERVICE_ALL_ACCESS );

     if ( !hService ) {

         rVal = GetLastError();
         SvcDebugPrint(( "\ncould not open service:%S error code = %u", WOW64_SERVICE_NAME, rVal ));
         return rVal;
     }
  
     QueryServiceStatus( hService, &Wow64ServiceStatus );
     {
         SvcDebugPrint ( ("\nStatus: %d, [pending %d] [running %d]",Wow64ServiceStatus.dwCurrentState, SERVICE_STOP_PENDING, SERVICE_RUNNING));
     }

     SvcDebugPrint(( "\nservice:%S started successfully error code = %u", WOW64_SERVICE_NAME, rVal ));
     return 0;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\xip\xipdisk\xipdisk.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    XIPDisk.h

Abstract:

    This file includes extension declaration for
    the XIP Disk driver for Whistler NT/Embedded.

Author:

    DavePr 18-Sep-2000 -- base one NT4 DDK ramdisk by RobertN 10-Mar-1993.

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

typedef struct  _XIPDISK_EXTENSION {
    PDEVICE_OBJECT        DeviceObject;
    PDEVICE_OBJECT        UnderlyingPDO;
    PDEVICE_OBJECT        TargetObject;

    XIP_BOOT_PARAMETERS   BootParameters;
    BIOS_PARAMETER_BLOCK  BiosParameters;

    ULONG                 NumberOfCylinders;
    ULONG                 TracksPerCylinder;    // hardwired at 1
    ULONG                 BytesPerCylinder;

    UNICODE_STRING        InterfaceString;
    UNICODE_STRING        DeviceName;
}   XIPDISK_EXTENSION, *PXIPDISK_EXTENSION;

#define XIPDISK_DEVICENAME  L"\\Device\\XIPDisk"
#define XIPDISK_FLOPPYNAME  L"\\Device\\Floppy9"
#define XIPDISK_DOSNAME     L"\\DosDevices\\XIPDisk"
#define XIPDISK_DRIVELETTER L"\\DosDevices\\X:"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\adler32.c ===
/* adler32.c -- compute the Adler-32 checksum of a data stream
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zlib.h"

#define BASE 65521L /* largest prime smaller than 65536 */
#define NMAX 5552
/* NMAX is the largest n such that 255n(n+1)/2 + (n+1)(BASE-1) <= 2^32-1 */

#define DO1(buf,i)  {s1 += buf[i]; s2 += s1;}
#define DO2(buf,i)  DO1(buf,i); DO1(buf,i+1);
#define DO4(buf,i)  DO2(buf,i); DO2(buf,i+2);
#define DO8(buf,i)  DO4(buf,i); DO4(buf,i+4);
#define DO16(buf)   DO8(buf,0); DO8(buf,8);

/* ========================================================================= */
uLong ZEXPORT adler32(adler, buf, len)
    uLong adler;
    const Bytef *buf;
    uInt len;
{
    unsigned long s1 = adler & 0xffff;
    unsigned long s2 = (adler >> 16) & 0xffff;
    int k;

    if (buf == Z_NULL) return 1L;

    while (len > 0) {
        k = len < NMAX ? len : NMAX;
        len -= k;
        while (k >= 16) {
            DO16(buf);
	    buf += 16;
            k -= 16;
        }
        if (k != 0) do {
            s1 += *buf++;
	    s2 += s1;
        } while (--k);
        s1 %= BASE;
        s2 %= BASE;
    }
    return (s2 << 16) | s1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\default_allocator.c ===
#include <windows.h>

void * zcalloc (void *opaque, unsigned items, unsigned size)
{
    return HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, size*items);
}

void  zcfree (void *opaque, void *ptr)
{
    HeapFree(GetProcessHeap(), 0, ptr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\compress.c ===
/* compress.c -- compress a memory buffer
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zlib.h"

/* ===========================================================================
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/
int ZEXPORT compress2 (dest, destLen, source, sourceLen, level)
    Bytef *dest;
    uLongf *destLen;
    const Bytef *source;
    uLong sourceLen;
    int level;
{
    z_stream stream;
    int err;

    stream.next_in = (Bytef*)source;
    stream.avail_in = (uInt)sourceLen;
#ifdef MAXSEG_64K
    /* Check for source > 64K on 16-bit machine: */
    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
#endif
    stream.next_out = dest;
    stream.avail_out = (uInt)*destLen;
    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;

    stream.zalloc = (alloc_func)0;
    stream.zfree = (free_func)0;
    stream.opaque = (voidpf)0;

    err = deflateInit(&stream, level);
    if (err != Z_OK) return err;

    err = deflate(&stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        deflateEnd(&stream);
        return err == Z_OK ? Z_BUF_ERROR : err;
    }
    *destLen = stream.total_out;

    err = deflateEnd(&stream);
    return err;
}

/* ===========================================================================
 */
int ZEXPORT compress (dest, destLen, source, sourceLen)
    Bytef *dest;
    uLongf *destLen;
    const Bytef *source;
    uLong sourceLen;
{
    return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\crc32.c ===
/* crc32.c -- compute the CRC-32 of a data stream
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zlib.h"

#define local static

#ifdef DYNAMIC_CRC_TABLE

local int crc_table_empty = 1;
local uLongf crc_table[256];
local void make_crc_table OF((void));

/*
  Generate a table for a byte-wise 32-bit CRC calculation on the polynomial:
  x^32+x^26+x^23+x^22+x^16+x^12+x^11+x^10+x^8+x^7+x^5+x^4+x^2+x+1.

  Polynomials over GF(2) are represented in binary, one bit per coefficient,
  with the lowest powers in the most significant bit.  Then adding polynomials
  is just exclusive-or, and multiplying a polynomial by x is a right shift by
  one.  If we call the above polynomial p, and represent a byte as the
  polynomial q, also with the lowest power in the most significant bit (so the
  byte 0xb1 is the polynomial x^7+x^3+x+1), then the CRC is (q*x^32) mod p,
  where a mod b means the remainder after dividing a by b.

  This calculation is done using the shift-register method of multiplying and
  taking the remainder.  The register is initialized to zero, and for each
  incoming bit, x^32 is added mod p to the register if the bit is a one (where
  x^32 mod p is p+x^32 = x^26+...+1), and the register is multiplied mod p by
  x (which is shifting right by one and adding x^32 mod p if the bit shifted
  out is a one).  We start with the highest power (least significant bit) of
  q and repeat for all eight bits of q.

  The table is simply the CRC of all possible eight bit values.  This is all
  the information needed to generate CRC's on data a byte at a time for all
  combinations of CRC register values and incoming bytes.
*/
local void make_crc_table()
{
  uLong c;
  int n, k;
  uLong poly;            /* polynomial exclusive-or pattern */
  /* terms of polynomial defining this crc (except x^32): */
  static const Byte p[] = {0,1,2,4,5,7,8,10,11,12,16,22,23,26};

  /* make exclusive-or pattern from polynomial (0xedb88320L) */
  poly = 0L;
  for (n = 0; n < sizeof(p)/sizeof(Byte); n++)
    poly |= 1L << (31 - p[n]);
 
  for (n = 0; n < 256; n++)
  {
    c = (uLong)n;
    for (k = 0; k < 8; k++)
      c = c & 1 ? poly ^ (c >> 1) : c >> 1;
    crc_table[n] = c;
  }
  crc_table_empty = 0;
}
#else
/* ========================================================================
 * Table of CRC-32's of all single-byte values (made by make_crc_table)
 */
local const uLongf crc_table[256] = {
  0x00000000L, 0x77073096L, 0xee0e612cL, 0x990951baL, 0x076dc419L,
  0x706af48fL, 0xe963a535L, 0x9e6495a3L, 0x0edb8832L, 0x79dcb8a4L,
  0xe0d5e91eL, 0x97d2d988L, 0x09b64c2bL, 0x7eb17cbdL, 0xe7b82d07L,
  0x90bf1d91L, 0x1db71064L, 0x6ab020f2L, 0xf3b97148L, 0x84be41deL,
  0x1adad47dL, 0x6ddde4ebL, 0xf4d4b551L, 0x83d385c7L, 0x136c9856L,
  0x646ba8c0L, 0xfd62f97aL, 0x8a65c9ecL, 0x14015c4fL, 0x63066cd9L,
  0xfa0f3d63L, 0x8d080df5L, 0x3b6e20c8L, 0x4c69105eL, 0xd56041e4L,
  0xa2677172L, 0x3c03e4d1L, 0x4b04d447L, 0xd20d85fdL, 0xa50ab56bL,
  0x35b5a8faL, 0x42b2986cL, 0xdbbbc9d6L, 0xacbcf940L, 0x32d86ce3L,
  0x45df5c75L, 0xdcd60dcfL, 0xabd13d59L, 0x26d930acL, 0x51de003aL,
  0xc8d75180L, 0xbfd06116L, 0x21b4f4b5L, 0x56b3c423L, 0xcfba9599L,
  0xb8bda50fL, 0x2802b89eL, 0x5f058808L, 0xc60cd9b2L, 0xb10be924L,
  0x2f6f7c87L, 0x58684c11L, 0xc1611dabL, 0xb6662d3dL, 0x76dc4190L,
  0x01db7106L, 0x98d220bcL, 0xefd5102aL, 0x71b18589L, 0x06b6b51fL,
  0x9fbfe4a5L, 0xe8b8d433L, 0x7807c9a2L, 0x0f00f934L, 0x9609a88eL,
  0xe10e9818L, 0x7f6a0dbbL, 0x086d3d2dL, 0x91646c97L, 0xe6635c01L,
  0x6b6b51f4L, 0x1c6c6162L, 0x856530d8L, 0xf262004eL, 0x6c0695edL,
  0x1b01a57bL, 0x8208f4c1L, 0xf50fc457L, 0x65b0d9c6L, 0x12b7e950L,
  0x8bbeb8eaL, 0xfcb9887cL, 0x62dd1ddfL, 0x15da2d49L, 0x8cd37cf3L,
  0xfbd44c65L, 0x4db26158L, 0x3ab551ceL, 0xa3bc0074L, 0xd4bb30e2L,
  0x4adfa541L, 0x3dd895d7L, 0xa4d1c46dL, 0xd3d6f4fbL, 0x4369e96aL,
  0x346ed9fcL, 0xad678846L, 0xda60b8d0L, 0x44042d73L, 0x33031de5L,
  0xaa0a4c5fL, 0xdd0d7cc9L, 0x5005713cL, 0x270241aaL, 0xbe0b1010L,
  0xc90c2086L, 0x5768b525L, 0x206f85b3L, 0xb966d409L, 0xce61e49fL,
  0x5edef90eL, 0x29d9c998L, 0xb0d09822L, 0xc7d7a8b4L, 0x59b33d17L,
  0x2eb40d81L, 0xb7bd5c3bL, 0xc0ba6cadL, 0xedb88320L, 0x9abfb3b6L,
  0x03b6e20cL, 0x74b1d29aL, 0xead54739L, 0x9dd277afL, 0x04db2615L,
  0x73dc1683L, 0xe3630b12L, 0x94643b84L, 0x0d6d6a3eL, 0x7a6a5aa8L,
  0xe40ecf0bL, 0x9309ff9dL, 0x0a00ae27L, 0x7d079eb1L, 0xf00f9344L,
  0x8708a3d2L, 0x1e01f268L, 0x6906c2feL, 0xf762575dL, 0x806567cbL,
  0x196c3671L, 0x6e6b06e7L, 0xfed41b76L, 0x89d32be0L, 0x10da7a5aL,
  0x67dd4accL, 0xf9b9df6fL, 0x8ebeeff9L, 0x17b7be43L, 0x60b08ed5L,
  0xd6d6a3e8L, 0xa1d1937eL, 0x38d8c2c4L, 0x4fdff252L, 0xd1bb67f1L,
  0xa6bc5767L, 0x3fb506ddL, 0x48b2364bL, 0xd80d2bdaL, 0xaf0a1b4cL,
  0x36034af6L, 0x41047a60L, 0xdf60efc3L, 0xa867df55L, 0x316e8eefL,
  0x4669be79L, 0xcb61b38cL, 0xbc66831aL, 0x256fd2a0L, 0x5268e236L,
  0xcc0c7795L, 0xbb0b4703L, 0x220216b9L, 0x5505262fL, 0xc5ba3bbeL,
  0xb2bd0b28L, 0x2bb45a92L, 0x5cb36a04L, 0xc2d7ffa7L, 0xb5d0cf31L,
  0x2cd99e8bL, 0x5bdeae1dL, 0x9b64c2b0L, 0xec63f226L, 0x756aa39cL,
  0x026d930aL, 0x9c0906a9L, 0xeb0e363fL, 0x72076785L, 0x05005713L,
  0x95bf4a82L, 0xe2b87a14L, 0x7bb12baeL, 0x0cb61b38L, 0x92d28e9bL,
  0xe5d5be0dL, 0x7cdcefb7L, 0x0bdbdf21L, 0x86d3d2d4L, 0xf1d4e242L,
  0x68ddb3f8L, 0x1fda836eL, 0x81be16cdL, 0xf6b9265bL, 0x6fb077e1L,
  0x18b74777L, 0x88085ae6L, 0xff0f6a70L, 0x66063bcaL, 0x11010b5cL,
  0x8f659effL, 0xf862ae69L, 0x616bffd3L, 0x166ccf45L, 0xa00ae278L,
  0xd70dd2eeL, 0x4e048354L, 0x3903b3c2L, 0xa7672661L, 0xd06016f7L,
  0x4969474dL, 0x3e6e77dbL, 0xaed16a4aL, 0xd9d65adcL, 0x40df0b66L,
  0x37d83bf0L, 0xa9bcae53L, 0xdebb9ec5L, 0x47b2cf7fL, 0x30b5ffe9L,
  0xbdbdf21cL, 0xcabac28aL, 0x53b39330L, 0x24b4a3a6L, 0xbad03605L,
  0xcdd70693L, 0x54de5729L, 0x23d967bfL, 0xb3667a2eL, 0xc4614ab8L,
  0x5d681b02L, 0x2a6f2b94L, 0xb40bbe37L, 0xc30c8ea1L, 0x5a05df1bL,
  0x2d02ef8dL
};
#endif

/* =========================================================================
 * This function can be used by asm versions of crc32()
 */
const uLongf * ZEXPORT get_crc_table()
{
#ifdef DYNAMIC_CRC_TABLE
  if (crc_table_empty) make_crc_table();
#endif
  return (const uLongf *)crc_table;
}

/* ========================================================================= */
#define DO1(buf) crc = crc_table[((int)crc ^ (*buf++)) & 0xff] ^ (crc >> 8);
#define DO2(buf)  DO1(buf); DO1(buf);
#define DO4(buf)  DO2(buf); DO2(buf);
#define DO8(buf)  DO4(buf); DO4(buf);

/* ========================================================================= */
uLong ZEXPORT crc32(crc, buf, len)
    uLong crc;
    const Bytef *buf;
    uInt len;
{
    if (buf == Z_NULL) return 0L;
#ifdef DYNAMIC_CRC_TABLE
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = crc ^ 0xffffffffL;
    while (len >= 8)
    {
      DO8(buf);
      len -= 8;
    }
    if (len) do {
      DO1(buf);
    } while (--len);
    return crc ^ 0xffffffffL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\deflate.c ===
/* deflate.c -- compress data using the deflation algorithm
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/*
 *  ALGORITHM
 *
 *      The "deflation" process depends on being able to identify portions
 *      of the input text which are identical to earlier input (within a
 *      sliding window trailing behind the input currently being processed).
 *
 *      The most straightforward technique turns out to be the fastest for
 *      most input files: try all possible matches and select the longest.
 *      The key feature of this algorithm is that insertions into the string
 *      dictionary are very simple and thus fast, and deletions are avoided
 *      completely. Insertions are performed at each input character, whereas
 *      string matches are performed only when the previous match ends. So it
 *      is preferable to spend more time in matches to allow very fast string
 *      insertions and avoid deletions. The matching algorithm for small
 *      strings is inspired from that of Rabin & Karp. A brute force approach
 *      is used to find longer strings when a small match has been found.
 *      A similar algorithm is used in comic (by Jan-Mark Wams) and freeze
 *      (by Leonid Broukhis).
 *         A previous version of this file used a more sophisticated algorithm
 *      (by Fiala and Greene) which is guaranteed to run in linear amortized
 *      time, but has a larger average cost, uses more memory and is patented.
 *      However the F&G algorithm may be faster for some highly redundant
 *      files if the parameter max_chain_length (described below) is too large.
 *
 *  ACKNOWLEDGEMENTS
 *
 *      The idea of lazy evaluation of matches is due to Jan-Mark Wams, and
 *      I found it in 'freeze' written by Leonid Broukhis.
 *      Thanks to many people for bug reports and testing.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"DEFLATE Compressed Data Format Specification".
 *      Available in ftp://ds.internic.net/rfc/rfc1951.txt
 *
 *      A description of the Rabin and Karp algorithm is given in the book
 *         "Algorithms" by R. Sedgewick, Addison-Wesley, p252.
 *
 *      Fiala,E.R., and Greene,D.H.
 *         Data Compression with Finite Windows, Comm.ACM, 32,4 (1989) 490-595
 *
 */

/* @(#) $Id$ */

#include "deflate.h"

const char deflate_copyright[] =
   " deflate 1.1.4 Copyright 1995-2002 Jean-loup Gailly ";
/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */

/* ===========================================================================
 *  Function prototypes.
 */
typedef enum {
    need_more,      /* block not completed, need more input or more output */
    block_done,     /* block flush performed */
    finish_started, /* finish started, need only more output at next deflate */
    finish_done     /* finish done, accept no more input or output */
} block_state;

typedef block_state (*compress_func) OF((deflate_state *s, int flush));
/* Compression function. Returns the block state after the call. */

local void fill_window    OF((deflate_state *s));
local block_state deflate_stored OF((deflate_state *s, int flush));
local block_state deflate_fast   OF((deflate_state *s, int flush));
local block_state deflate_slow   OF((deflate_state *s, int flush));
local void lm_init        OF((deflate_state *s));
local void putShortMSB    OF((deflate_state *s, uInt b));
local void flush_pending  OF((z_streamp strm));
local int read_buf        OF((z_streamp strm, Bytef *buf, unsigned size));
#ifdef ASMV
      void match_init OF((void)); /* asm code initialization */
      uInt longest_match  OF((deflate_state *s, IPos cur_match));
#else
local uInt longest_match  OF((deflate_state *s, IPos cur_match));
#endif

#ifdef DEBUG
local  void check_match OF((deflate_state *s, IPos start, IPos match,
                            int length));
#endif

/* ===========================================================================
 * Local data
 */

#define NIL 0
/* Tail of hash chains */

#ifndef TOO_FAR
#  define TOO_FAR 4096
#endif
/* Matches of length 3 are discarded if their distance exceeds TOO_FAR */

#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */

/* Values for max_lazy_match, good_match and max_chain_length, depending on
 * the desired pack level (0..9). The values given below have been tuned to
 * exclude worst case performance for pathological files. Better values may be
 * found for specific files.
 */
typedef struct config_s {
   ush good_length; /* reduce lazy search above this match length */
   ush max_lazy;    /* do not perform lazy search above this match length */
   ush nice_length; /* quit search above this match length */
   ush max_chain;
   compress_func func;
} config;

local const config configuration_table[10] = {
/*      good lazy nice chain */
/* 0 */ {0,    0,  0,    0, deflate_stored},  /* store only */
/* 1 */ {4,    4,  8,    4, deflate_fast}, /* maximum speed, no lazy matches */
/* 2 */ {4,    5, 16,    8, deflate_fast},
/* 3 */ {4,    6, 32,   32, deflate_fast},

/* 4 */ {4,    4, 16,   16, deflate_slow},  /* lazy matches */
/* 5 */ {8,   16, 32,   32, deflate_slow},
/* 6 */ {8,   16, 128, 128, deflate_slow},
/* 7 */ {8,   32, 128, 256, deflate_slow},
/* 8 */ {32, 128, 258, 1024, deflate_slow},
/* 9 */ {32, 258, 258, 4096, deflate_slow}}; /* maximum compression */

/* Note: the deflate() code requires max_lazy >= MIN_MATCH and max_chain >= 4
 * For deflate_fast() (levels <= 3) good is ignored and lazy has a different
 * meaning.
 */

#define EQUAL 0
/* result of memcmp for equal strings */

struct static_tree_desc_s {int dummy;}; /* for buggy compilers */

/* ===========================================================================
 * Update a hash value with the given input byte
 * IN  assertion: all calls to to UPDATE_HASH are made with consecutive
 *    input characters, so that a running hash key can be computed from the
 *    previous key instead of complete recalculation each time.
 */
#define UPDATE_HASH(s,h,c) (h = (((h)<<s->hash_shift) ^ (c)) & s->hash_mask)


/* ===========================================================================
 * Insert string str in the dictionary and set match_head to the previous head
 * of the hash chain (the most recent string with same hash key). Return
 * the previous length of the hash chain.
 * If this file is compiled with -DFASTEST, the compression level is forced
 * to 1, and no hash chains are maintained.
 * IN  assertion: all calls to to INSERT_STRING are made with consecutive
 *    input characters and the first MIN_MATCH bytes of str are valid
 *    (except for the last MIN_MATCH-1 bytes of the input file).
 */
#ifdef FASTEST
#define INSERT_STRING(s, str, match_head) \
   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
    match_head = s->head[s->ins_h], \
    s->head[s->ins_h] = (Pos)(str))
#else
#define INSERT_STRING(s, str, match_head) \
   (UPDATE_HASH(s, s->ins_h, s->window[(str) + (MIN_MATCH-1)]), \
    s->prev[(str) & s->w_mask] = match_head = s->head[s->ins_h], \
    s->head[s->ins_h] = (Pos)(str))
#endif

/* ===========================================================================
 * Initialize the hash table (avoiding 64K overflow for 16 bit systems).
 * prev[] will be initialized on the fly.
 */
#define CLEAR_HASH(s) \
    s->head[s->hash_size-1] = NIL; \
    zmemzero((Bytef *)s->head, (unsigned)(s->hash_size-1)*sizeof(*s->head));

/* ========================================================================= */
int ZEXPORT deflateInit_(strm, level, version, stream_size)
    z_streamp strm;
    int level;
    const char *version;
    int stream_size;
{
    return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
			 Z_DEFAULT_STRATEGY, version, stream_size);
    /* To do: ignore strm->next_in if we use it as window */
}

/* ========================================================================= */
int ZEXPORT deflateInit2_(strm, level, method, windowBits, memLevel, strategy,
		  version, stream_size)
    z_streamp strm;
    int  level;
    int  method;
    int  windowBits;
    int  memLevel;
    int  strategy;
    const char *version;
    int stream_size;
{
    deflate_state *s;
    int noheader = 0;
    static const char my_version[] = ZLIB_VERSION;

    ushf *overlay;
    /* We overlay pending_buf and d_buf+l_buf. This works since the average
     * output size for (length,distance) codes is <= 24 bits.
     */

    if (version == Z_NULL || version[0] != my_version[0] ||
        stream_size != sizeof(z_stream)) {
	return Z_VERSION_ERROR;
    }
    if (strm == Z_NULL) return Z_STREAM_ERROR;

    strm->msg = Z_NULL;
    if (strm->zalloc == Z_NULL) {
	strm->zalloc = zcalloc;
	strm->opaque = (voidpf)0;
    }
    if (strm->zfree == Z_NULL) strm->zfree = zcfree;

    if (level == Z_DEFAULT_COMPRESSION) level = 6;
#ifdef FASTEST
    level = 1;
#endif

    if (windowBits < 0) { /* undocumented feature: suppress zlib header */
        noheader = 1;
        windowBits = -windowBits;
    }
    if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
        windowBits < 9 || windowBits > 15 || level < 0 || level > 9 ||
	strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
        return Z_STREAM_ERROR;
    }
    s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));
    if (s == Z_NULL) return Z_MEM_ERROR;
    strm->state = (struct internal_state FAR *)s;
    s->strm = strm;

    s->noheader = noheader;
    s->w_bits = windowBits;
    s->w_size = 1 << s->w_bits;
    s->w_mask = s->w_size - 1;

    s->hash_bits = memLevel + 7;
    s->hash_size = 1 << s->hash_bits;
    s->hash_mask = s->hash_size - 1;
    s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);

    s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));
    s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));
    s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

    s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

    overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);
    s->pending_buf = (uchf *) overlay;
    s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);

    if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
        s->pending_buf == Z_NULL) {
        strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);
        deflateEnd (strm);
        return Z_MEM_ERROR;
    }
    s->d_buf = overlay + s->lit_bufsize/sizeof(ush);
    s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

    s->level = level;
    s->strategy = strategy;
    s->method = (Byte)method;

    return deflateReset(strm);
}

/* ========================================================================= */
int ZEXPORT deflateSetDictionary (strm, dictionary, dictLength)
    z_streamp strm;
    const Bytef *dictionary;
    uInt  dictLength;
{
    deflate_state *s;
    uInt length = dictLength;
    uInt n;
    IPos hash_head = 0;

    if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
        strm->state->status != INIT_STATE) return Z_STREAM_ERROR;

    s = strm->state;
    strm->adler = adler32(strm->adler, dictionary, dictLength);

    if (length < MIN_MATCH) return Z_OK;
    if (length > MAX_DIST(s)) {
	length = MAX_DIST(s);
#ifndef USE_DICT_HEAD
	dictionary += dictLength - length; /* use the tail of the dictionary */
#endif
    }
    zmemcpy(s->window, dictionary, length);
    s->strstart = length;
    s->block_start = (long)length;

    /* Insert all strings in the hash table (except for the last two bytes).
     * s->lookahead stays null, so s->ins_h will be recomputed at the next
     * call of fill_window.
     */
    s->ins_h = s->window[0];
    UPDATE_HASH(s, s->ins_h, s->window[1]);
    for (n = 0; n <= length - MIN_MATCH; n++) {
	INSERT_STRING(s, n, hash_head);
    }
    if (hash_head) hash_head = 0;  /* to make compiler happy */
    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateReset (strm)
    z_streamp strm;
{
    deflate_state *s;
    
    if (strm == Z_NULL || strm->state == Z_NULL ||
        strm->zalloc == Z_NULL || strm->zfree == Z_NULL) return Z_STREAM_ERROR;

    strm->total_in = strm->total_out = 0;
    strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */
    strm->data_type = Z_UNKNOWN;

    s = (deflate_state *)strm->state;
    s->pending = 0;
    s->pending_out = s->pending_buf;

    if (s->noheader < 0) {
        s->noheader = 0; /* was set to -1 by deflate(..., Z_FINISH); */
    }
    s->status = s->noheader ? BUSY_STATE : INIT_STATE;
    strm->adler = 1;
    s->last_flush = Z_NO_FLUSH;

    _tr_init(s);
    lm_init(s);

    return Z_OK;
}

/* ========================================================================= */
int ZEXPORT deflateParams(strm, level, strategy)
    z_streamp strm;
    int level;
    int strategy;
{
    deflate_state *s;
    compress_func func;
    int err = Z_OK;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    s = strm->state;

    if (level == Z_DEFAULT_COMPRESSION) {
	level = 6;
    }
    if (level < 0 || level > 9 || strategy < 0 || strategy > Z_HUFFMAN_ONLY) {
	return Z_STREAM_ERROR;
    }
    func = configuration_table[s->level].func;

    if (func != configuration_table[level].func && strm->total_in != 0) {
	/* Flush the last buffer: */
	err = deflate(strm, Z_PARTIAL_FLUSH);
    }
    if (s->level != level) {
	s->level = level;
	s->max_lazy_match   = configuration_table[level].max_lazy;
	s->good_match       = configuration_table[level].good_length;
	s->nice_match       = configuration_table[level].nice_length;
	s->max_chain_length = configuration_table[level].max_chain;
    }
    s->strategy = strategy;
    return err;
}

/* =========================================================================
 * Put a short in the pending buffer. The 16-bit value is put in MSB order.
 * IN assertion: the stream state is correct and there is enough room in
 * pending_buf.
 */
local void putShortMSB (s, b)
    deflate_state *s;
    uInt b;
{
    put_byte(s, (Byte)(b >> 8));
    put_byte(s, (Byte)(b & 0xff));
}   

/* =========================================================================
 * Flush as much pending output as possible. All deflate() output goes
 * through this function so some applications may wish to modify it
 * to avoid allocating a large strm->next_out buffer and copying into it.
 * (See also read_buf()).
 */
local void flush_pending(strm)
    z_streamp strm;
{
    unsigned len = strm->state->pending;

    if (len > strm->avail_out) len = strm->avail_out;
    if (len == 0) return;

    zmemcpy(strm->next_out, strm->state->pending_out, len);
    strm->next_out  += len;
    strm->state->pending_out  += len;
    strm->total_out += len;
    strm->avail_out  -= len;
    strm->state->pending -= len;
    if (strm->state->pending == 0) {
        strm->state->pending_out = strm->state->pending_buf;
    }
}

/* ========================================================================= */
int ZEXPORT deflate (strm, flush)
    z_streamp strm;
    int flush;
{
    int old_flush; /* value of flush param for previous deflate call */
    deflate_state *s;

    if (strm == Z_NULL || strm->state == Z_NULL ||
	flush > Z_FINISH || flush < 0) {
        return Z_STREAM_ERROR;
    }
    s = strm->state;

    if (strm->next_out == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0) ||
	(s->status == FINISH_STATE && flush != Z_FINISH)) {
        ERR_RETURN(strm, Z_STREAM_ERROR);
    }
    if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

    s->strm = strm; /* just in case */
    old_flush = s->last_flush;
    s->last_flush = flush;

    /* Write the zlib header */
    if (s->status == INIT_STATE) {

        uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;
        uInt level_flags = (s->level-1) >> 1;

        if (level_flags > 3) level_flags = 3;
        header |= (level_flags << 6);
	if (s->strstart != 0) header |= PRESET_DICT;
        header += 31 - (header % 31);

        s->status = BUSY_STATE;
        putShortMSB(s, header);

	/* Save the adler32 of the preset dictionary: */
	if (s->strstart != 0) {
	    putShortMSB(s, (uInt)(strm->adler >> 16));
	    putShortMSB(s, (uInt)(strm->adler & 0xffff));
	}
	strm->adler = 1L;
    }

    /* Flush as much pending output as possible */
    if (s->pending != 0) {
        flush_pending(strm);
        if (strm->avail_out == 0) {
	    /* Since avail_out is 0, deflate will be called again with
	     * more output space, but possibly with both pending and
	     * avail_in equal to zero. There won't be anything to do,
	     * but this is not an error situation so make sure we
	     * return OK instead of BUF_ERROR at next call of deflate:
             */
	    s->last_flush = -1;
	    return Z_OK;
	}

    /* Make sure there is something to do and avoid duplicate consecutive
     * flushes. For repeated and useless calls with Z_FINISH, we keep
     * returning Z_STREAM_END instead of Z_BUFF_ERROR.
     */
    } else if (strm->avail_in == 0 && flush <= old_flush &&
	       flush != Z_FINISH) {
        ERR_RETURN(strm, Z_BUF_ERROR);
    }

    /* User must not provide more input after the first FINISH: */
    if (s->status == FINISH_STATE && strm->avail_in != 0) {
        ERR_RETURN(strm, Z_BUF_ERROR);
    }

    /* Start a new block or continue the current one.
     */
    if (strm->avail_in != 0 || s->lookahead != 0 ||
        (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {
        block_state bstate;

	bstate = (*(configuration_table[s->level].func))(s, flush);

        if (bstate == finish_started || bstate == finish_done) {
            s->status = FINISH_STATE;
        }
        if (bstate == need_more || bstate == finish_started) {
	    if (strm->avail_out == 0) {
	        s->last_flush = -1; /* avoid BUF_ERROR next call, see above */
	    }
	    return Z_OK;
	    /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
	     * of deflate should use the same flush parameter to make sure
	     * that the flush is complete. So we don't have to output an
	     * empty block here, this will be done at next call. This also
	     * ensures that for a very small output buffer, we emit at most
	     * one empty block.
	     */
	}
        if (bstate == block_done) {
            if (flush == Z_PARTIAL_FLUSH) {
                _tr_align(s);
            } else { /* FULL_FLUSH or SYNC_FLUSH */
                _tr_stored_block(s, (char*)0, 0L, 0);
                /* For a full flush, this empty block will be recognized
                 * as a special marker by inflate_sync().
                 */
                if (flush == Z_FULL_FLUSH) {
                    CLEAR_HASH(s);             /* forget history */
                }
            }
            flush_pending(strm);
	    if (strm->avail_out == 0) {
	      s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */
	      return Z_OK;
	    }
        }
    }
    Assert(strm->avail_out > 0, "bug2");

    if (flush != Z_FINISH) return Z_OK;
    if (s->noheader) return Z_STREAM_END;

    /* Write the zlib trailer (adler32) */
    putShortMSB(s, (uInt)(strm->adler >> 16));
    putShortMSB(s, (uInt)(strm->adler & 0xffff));
    flush_pending(strm);
    /* If avail_out is zero, the application will call deflate again
     * to flush the rest.
     */
    s->noheader = -1; /* write the trailer only once! */
    return s->pending != 0 ? Z_OK : Z_STREAM_END;
}

/* ========================================================================= */
int ZEXPORT deflateEnd (strm)
    z_streamp strm;
{
    int status;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

    status = strm->state->status;
    if (status != INIT_STATE && status != BUSY_STATE &&
	status != FINISH_STATE) {
      return Z_STREAM_ERROR;
    }

    /* Deallocate in reverse order of allocations: */
    TRY_FREE(strm, strm->state->pending_buf);
    TRY_FREE(strm, strm->state->head);
    TRY_FREE(strm, strm->state->prev);
    TRY_FREE(strm, strm->state->window);

    ZFREE(strm, strm->state);
    strm->state = Z_NULL;

    return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;
}

/* =========================================================================
 * Copy the source state to the destination state.
 * To simplify the source, this is not supported for 16-bit MSDOS (which
 * doesn't have enough memory anyway to duplicate compression states).
 */
int ZEXPORT deflateCopy (dest, source)
    z_streamp dest;
    z_streamp source;
{
#ifdef MAXSEG_64K
    return Z_STREAM_ERROR;
#else
    deflate_state *ds;
    deflate_state *ss;
    ushf *overlay;


    if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {
        return Z_STREAM_ERROR;
    }

    ss = source->state;

    *dest = *source;

    ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));
    if (ds == Z_NULL) return Z_MEM_ERROR;
    dest->state = (struct internal_state FAR *) ds;
    *ds = *ss;
    ds->strm = dest;

    ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));
    ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));
    ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));
    overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);
    ds->pending_buf = (uchf *) overlay;

    if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
        ds->pending_buf == Z_NULL) {
        deflateEnd (dest);
        return Z_MEM_ERROR;
    }
    /* following zmemcpy do not work for 16-bit MSDOS */
    zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));
    zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));
    zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));
    zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);

    ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);
    ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);
    ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;

    ds->l_desc.dyn_tree = ds->dyn_ltree;
    ds->d_desc.dyn_tree = ds->dyn_dtree;
    ds->bl_desc.dyn_tree = ds->bl_tree;

    return Z_OK;
#endif
}

/* ===========================================================================
 * Read a new buffer from the current input stream, update the adler32
 * and total number of bytes read.  All deflate() input goes through
 * this function so some applications may wish to modify it to avoid
 * allocating a large strm->next_in buffer and copying from it.
 * (See also flush_pending()).
 */
local int read_buf(strm, buf, size)
    z_streamp strm;
    Bytef *buf;
    unsigned size;
{
    unsigned len = strm->avail_in;

    if (len > size) len = size;
    if (len == 0) return 0;

    strm->avail_in  -= len;

    if (!strm->state->noheader) {
        strm->adler = adler32(strm->adler, strm->next_in, len);
    }
    zmemcpy(buf, strm->next_in, len);
    strm->next_in  += len;
    strm->total_in += len;

    return (int)len;
}

/* ===========================================================================
 * Initialize the "longest match" routines for a new zlib stream
 */
local void lm_init (s)
    deflate_state *s;
{
    s->window_size = (ulg)2L*s->w_size;

    CLEAR_HASH(s);

    /* Set the default configuration parameters:
     */
    s->max_lazy_match   = configuration_table[s->level].max_lazy;
    s->good_match       = configuration_table[s->level].good_length;
    s->nice_match       = configuration_table[s->level].nice_length;
    s->max_chain_length = configuration_table[s->level].max_chain;

    s->strstart = 0;
    s->block_start = 0L;
    s->lookahead = 0;
    s->match_length = s->prev_length = MIN_MATCH-1;
    s->match_available = 0;
    s->ins_h = 0;
#ifdef ASMV
    match_init(); /* initialize the asm code */
#endif
}

/* ===========================================================================
 * Set match_start to the longest match starting at the given string and
 * return its length. Matches shorter or equal to prev_length are discarded,
 * in which case the result is equal to prev_length and match_start is
 * garbage.
 * IN assertions: cur_match is the head of the hash chain for the current
 *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1
 * OUT assertion: the match length is not greater than s->lookahead.
 */
#ifndef ASMV
/* For 80x86 and 680x0, an optimized version will be provided in match.asm or
 * match.S. The code will be functionally equivalent.
 */
#ifndef FASTEST
local uInt longest_match(s, cur_match)
    deflate_state *s;
    IPos cur_match;                             /* current match */
{
    unsigned chain_length = s->max_chain_length;/* max hash chain length */
    register Bytef *scan = s->window + s->strstart; /* current string */
    register Bytef *match;                       /* matched string */
    register int len;                           /* length of current match */
    int best_len = s->prev_length;              /* best match length so far */
    int nice_match = s->nice_match;             /* stop if match long enough */
    IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
        s->strstart - (IPos)MAX_DIST(s) : NIL;
    /* Stop when cur_match becomes <= limit. To simplify the code,
     * we prevent matches with the string of window index 0.
     */
    Posf *prev = s->prev;
    uInt wmask = s->w_mask;

#ifdef UNALIGNED_OK
    /* Compare two bytes at a time. Note: this is not always beneficial.
     * Try with and without -DUNALIGNED_OK to check.
     */
    register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
    register ush scan_start = *(ushf*)scan;
    register ush scan_end   = *(ushf*)(scan+best_len-1);
#else
    register Bytef *strend = s->window + s->strstart + MAX_MATCH;
    register Byte scan_end1  = scan[best_len-1];
    register Byte scan_end   = scan[best_len];
#endif

    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */
    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

    /* Do not waste too much time if we already have a good match: */
    if (s->prev_length >= s->good_match) {
        chain_length >>= 2;
    }
    /* Do not look for matches beyond the end of the input. This is necessary
     * to make deflate deterministic.
     */
    if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;

    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

    do {
        Assert(cur_match < s->strstart, "no future");
        match = s->window + cur_match;

        /* Skip to next match if the match length cannot increase
         * or if the match length is less than 2:
         */
#if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
        /* This code assumes sizeof(unsigned short) == 2. Do not use
         * UNALIGNED_OK if your compiler uses a different size.
         */
        if (*(ushf*)(match+best_len-1) != scan_end ||
            *(ushf*)match != scan_start) continue;

        /* It is not necessary to compare scan[2] and match[2] since they are
         * always equal when the other bytes match, given that the hash keys
         * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
         * strstart+3, +5, ... up to strstart+257. We check for insufficient
         * lookahead only every 4th comparison; the 128th check will be made
         * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
         * necessary to put more guard bytes at the end of the window, or
         * to check more often for insufficient lookahead.
         */
        Assert(scan[2] == match[2], "scan[2]?");
        scan++, match++;
        do {
        } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
                 scan < strend);
        /* The funny "do {}" generates better code on most compilers */

        /* Here, scan <= window+strstart+257 */
        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
        if (*scan == *match) scan++;

        len = (MAX_MATCH - 1) - (int)(strend-scan);
        scan = strend - (MAX_MATCH-1);

#else /* UNALIGNED_OK */

        if (match[best_len]   != scan_end  ||
            match[best_len-1] != scan_end1 ||
            *match            != *scan     ||
            *++match          != scan[1])      continue;

        /* The check at best_len-1 can be removed because it will be made
         * again later. (This heuristic is not always a win.)
         * It is not necessary to compare scan[2] and match[2] since they
         * are always equal when the other bytes match, given that
         * the hash keys are equal and that HASH_BITS >= 8.
         */
        scan += 2, match++;
        Assert(*scan == *match, "match[2]?");

        /* We check for insufficient lookahead only every 8th comparison;
         * the 256th check will be made at strstart+258.
         */
        do {
        } while (*++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 *++scan == *++match && *++scan == *++match &&
                 scan < strend);

        Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

        len = MAX_MATCH - (int)(strend - scan);
        scan = strend - MAX_MATCH;

#endif /* UNALIGNED_OK */

        if (len > best_len) {
            s->match_start = cur_match;
            best_len = len;
            if (len >= nice_match) break;
#ifdef UNALIGNED_OK
            scan_end = *(ushf*)(scan+best_len-1);
#else
            scan_end1  = scan[best_len-1];
            scan_end   = scan[best_len];
#endif
        }
    } while ((cur_match = prev[cur_match & wmask]) > limit
             && --chain_length != 0);

    if ((uInt)best_len <= s->lookahead) return (uInt)best_len;
    return s->lookahead;
}

#else /* FASTEST */
/* ---------------------------------------------------------------------------
 * Optimized version for level == 1 only
 */
local uInt longest_match(s, cur_match)
    deflate_state *s;
    IPos cur_match;                             /* current match */
{
    register Bytef *scan = s->window + s->strstart; /* current string */
    register Bytef *match;                       /* matched string */
    register int len;                           /* length of current match */
    register Bytef *strend = s->window + s->strstart + MAX_MATCH;

    /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
     * It is easy to get rid of this optimization if necessary.
     */
    Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");

    Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");

    Assert(cur_match < s->strstart, "no future");

    match = s->window + cur_match;

    /* Return failure if the match length is less than 2:
     */
    if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;

    /* The check at best_len-1 can be removed because it will be made
     * again later. (This heuristic is not always a win.)
     * It is not necessary to compare scan[2] and match[2] since they
     * are always equal when the other bytes match, given that
     * the hash keys are equal and that HASH_BITS >= 8.
     */
    scan += 2, match += 2;
    Assert(*scan == *match, "match[2]?");

    /* We check for insufficient lookahead only every 8th comparison;
     * the 256th check will be made at strstart+258.
     */
    do {
    } while (*++scan == *++match && *++scan == *++match &&
	     *++scan == *++match && *++scan == *++match &&
	     *++scan == *++match && *++scan == *++match &&
	     *++scan == *++match && *++scan == *++match &&
	     scan < strend);

    Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");

    len = MAX_MATCH - (int)(strend - scan);

    if (len < MIN_MATCH) return MIN_MATCH - 1;

    s->match_start = cur_match;
    return len <= s->lookahead ? len : s->lookahead;
}
#endif /* FASTEST */
#endif /* ASMV */

#ifdef DEBUG
/* ===========================================================================
 * Check that the match at match_start is indeed a match.
 */
local void check_match(s, start, match, length)
    deflate_state *s;
    IPos start, match;
    int length;
{
    /* check that the match is indeed a match */
    if (zmemcmp(s->window + match,
                s->window + start, length) != EQUAL) {
        fprintf(stderr, " start %u, match %u, length %d\n",
		start, match, length);
        do {
	    fprintf(stderr, "%c%c", s->window[match++], s->window[start++]);
	} while (--length != 0);
        z_error("invalid match");
    }
    if (z_verbose > 1) {
        fprintf(stderr,"\\[%d,%d]", start-match, length);
        do { putc(s->window[start++], stderr); } while (--length != 0);
    }
}
#else
#  define check_match(s, start, match, length)
#endif

/* ===========================================================================
 * Fill the window when the lookahead becomes insufficient.
 * Updates strstart and lookahead.
 *
 * IN assertion: lookahead < MIN_LOOKAHEAD
 * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD
 *    At least one byte has been read, or avail_in == 0; reads are
 *    performed for at least two bytes (required for the zip translate_eol
 *    option -- not supported here).
 */
local void fill_window(s)
    deflate_state *s;
{
    register unsigned n, m;
    register Posf *p;
    unsigned more;    /* Amount of free space at the end of the window. */
    uInt wsize = s->w_size;

    do {
        more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);

        /* Deal with !@#$% 64K limit: */
        if (more == 0 && s->strstart == 0 && s->lookahead == 0) {
            more = wsize;

        } else if (more == (unsigned)(-1)) {
            /* Very unlikely, but possible on 16 bit machine if strstart == 0
             * and lookahead == 1 (input done one byte at time)
             */
            more--;

        /* If the window is almost full and there is insufficient lookahead,
         * move the upper half to the lower one to make room in the upper half.
         */
        } else if (s->strstart >= wsize+MAX_DIST(s)) {

            zmemcpy(s->window, s->window+wsize, (unsigned)wsize);
            s->match_start -= wsize;
            s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */
            s->block_start -= (long) wsize;

            /* Slide the hash table (could be avoided with 32 bit values
               at the expense of memory usage). We slide even when level == 0
               to keep the hash table consistent if we switch back to level > 0
               later. (Using level 0 permanently is not an optimal usage of
               zlib, so we don't care about this pathological case.)
             */
	    n = s->hash_size;
	    p = &s->head[n];
	    do {
		m = *--p;
		*p = (Pos)(m >= wsize ? m-wsize : NIL);
	    } while (--n);

	    n = wsize;
#ifndef FASTEST
	    p = &s->prev[n];
	    do {
		m = *--p;
		*p = (Pos)(m >= wsize ? m-wsize : NIL);
		/* If n is not on any hash chain, prev[n] is garbage but
		 * its value will never be used.
		 */
	    } while (--n);
#endif
            more += wsize;
        }
        if (s->strm->avail_in == 0) return;

        /* If there was no sliding:
         *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
         *    more == window_size - lookahead - strstart
         * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
         * => more >= window_size - 2*WSIZE + 2
         * In the BIG_MEM or MMAP case (not yet supported),
         *   window_size == input_size + MIN_LOOKAHEAD  &&
         *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
         * Otherwise, window_size == 2*WSIZE so more >= 2.
         * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
         */
        Assert(more >= 2, "more < 2");

        n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);
        s->lookahead += n;

        /* Initialize the hash value now that we have some input: */
        if (s->lookahead >= MIN_MATCH) {
            s->ins_h = s->window[s->strstart];
            UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
#if MIN_MATCH != 3
            Call UPDATE_HASH() MIN_MATCH-3 more times
#endif
        }
        /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
         * but this is not important since only literal bytes will be emitted.
         */

    } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);
}

/* ===========================================================================
 * Flush the current block, with given end-of-file flag.
 * IN assertion: strstart is set to the end of the current match.
 */
#define FLUSH_BLOCK_ONLY(s, eof) { \
   _tr_flush_block(s, (s->block_start >= 0L ? \
                   (charf *)&s->window[(unsigned)s->block_start] : \
                   (charf *)Z_NULL), \
		(ulg)((long)s->strstart - s->block_start), \
		(eof)); \
   s->block_start = s->strstart; \
   flush_pending(s->strm); \
   Tracev((stderr,"[FLUSH]")); \
}

/* Same but force premature exit if necessary. */
#define FLUSH_BLOCK(s, eof) { \
   FLUSH_BLOCK_ONLY(s, eof); \
   if (s->strm->avail_out == 0) return (eof) ? finish_started : need_more; \
}

/* ===========================================================================
 * Copy without compression as much as possible from the input stream, return
 * the current block state.
 * This function does not insert new strings in the dictionary since
 * uncompressible data is probably not useful. This function is used
 * only for the level=0 compression option.
 * NOTE: this function should be optimized to avoid extra copying from
 * window to pending_buf.
 */
local block_state deflate_stored(s, flush)
    deflate_state *s;
    int flush;
{
    /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
     * to pending_buf_size, and each stored block has a 5 byte header:
     */
    ulg max_block_size = 0xffff;
    ulg max_start;

    if (max_block_size > s->pending_buf_size - 5) {
        max_block_size = s->pending_buf_size - 5;
    }

    /* Copy as much as possible from input to output: */
    for (;;) {
        /* Fill the window as much as possible: */
        if (s->lookahead <= 1) {

            Assert(s->strstart < s->w_size+MAX_DIST(s) ||
		   s->block_start >= (long)s->w_size, "slide too late");

            fill_window(s);
            if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

            if (s->lookahead == 0) break; /* flush the current block */
        }
	Assert(s->block_start >= 0L, "block gone");

	s->strstart += s->lookahead;
	s->lookahead = 0;

	/* Emit a stored block if pending_buf will be full: */
 	max_start = s->block_start + max_block_size;
        if (s->strstart == 0 || (ulg)s->strstart >= max_start) {
	    /* strstart == 0 is possible when wraparound on 16-bit machine */
	    s->lookahead = (uInt)(s->strstart - max_start);
	    s->strstart = (uInt)max_start;
            FLUSH_BLOCK(s, 0);
	}
	/* Flush if we may have to slide, otherwise block_start may become
         * negative and the data will be gone:
         */
        if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {
            FLUSH_BLOCK(s, 0);
	}
    }
    FLUSH_BLOCK(s, flush == Z_FINISH);
    return flush == Z_FINISH ? finish_done : block_done;
}

/* ===========================================================================
 * Compress as much as possible from the input stream, return the current
 * block state.
 * This function does not perform lazy evaluation of matches and inserts
 * new strings in the dictionary only for unmatched strings or for short
 * matches. It is used only for the fast compression options.
 */
local block_state deflate_fast(s, flush)
    deflate_state *s;
    int flush;
{
    IPos hash_head = NIL; /* head of the hash chain */
    int bflush;           /* set if current block must be flushed */

    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s->lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
	        return need_more;
	    }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        if (s->lookahead >= MIN_MATCH) {
            INSERT_STRING(s, s->strstart, hash_head);
        }

        /* Find the longest match, discarding those <= prev_length.
         * At this point we have always match_length < MIN_MATCH
         */
        if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            if (s->strategy != Z_HUFFMAN_ONLY) {
                s->match_length = longest_match (s, hash_head);
            }
            /* longest_match() sets match_start */
        }
        if (s->match_length >= MIN_MATCH) {
            check_match(s, s->strstart, s->match_start, s->match_length);

            _tr_tally_dist(s, s->strstart - s->match_start,
                           s->match_length - MIN_MATCH, bflush);

            s->lookahead -= s->match_length;

            /* Insert new strings in the hash table only if the match length
             * is not too large. This saves time but degrades compression.
             */
#ifndef FASTEST
            if (s->match_length <= s->max_insert_length &&
                s->lookahead >= MIN_MATCH) {
                s->match_length--; /* string at strstart already in hash table */
                do {
                    s->strstart++;
                    INSERT_STRING(s, s->strstart, hash_head);
                    /* strstart never exceeds WSIZE-MAX_MATCH, so there are
                     * always MIN_MATCH bytes ahead.
                     */
                } while (--s->match_length != 0);
                s->strstart++; 
            } else
#endif
	    {
                s->strstart += s->match_length;
                s->match_length = 0;
                s->ins_h = s->window[s->strstart];
                UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);
#if MIN_MATCH != 3
                Call UPDATE_HASH() MIN_MATCH-3 more times
#endif
                /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
                 * matter since it will be recomputed at next deflate call.
                 */
            }
        } else {
            /* No match, output a literal byte */
            Tracevv((stderr,"%c", s->window[s->strstart]));
            _tr_tally_lit (s, s->window[s->strstart], bflush);
            s->lookahead--;
            s->strstart++; 
        }
        if (bflush) FLUSH_BLOCK(s, 0);
    }
    FLUSH_BLOCK(s, flush == Z_FINISH);
    return flush == Z_FINISH ? finish_done : block_done;
}

/* ===========================================================================
 * Same as above, but achieves better compression. We use a lazy
 * evaluation for matches: a match is finally adopted only if there is
 * no better match at the next window position.
 */
local block_state deflate_slow(s, flush)
    deflate_state *s;
    int flush;
{
    IPos hash_head = NIL;    /* head of hash chain */
    int bflush;              /* set if current block must be flushed */

    /* Process the input block. */
    for (;;) {
        /* Make sure that we always have enough lookahead, except
         * at the end of the input file. We need MAX_MATCH bytes
         * for the next match, plus MIN_MATCH bytes to insert the
         * string following the next match.
         */
        if (s->lookahead < MIN_LOOKAHEAD) {
            fill_window(s);
            if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {
	        return need_more;
	    }
            if (s->lookahead == 0) break; /* flush the current block */
        }

        /* Insert the string window[strstart .. strstart+2] in the
         * dictionary, and set hash_head to the head of the hash chain:
         */
        if (s->lookahead >= MIN_MATCH) {
            INSERT_STRING(s, s->strstart, hash_head);
        }

        /* Find the longest match, discarding those <= prev_length.
         */
        s->prev_length = s->match_length, s->prev_match = s->match_start;
        s->match_length = MIN_MATCH-1;

        if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
            s->strstart - hash_head <= MAX_DIST(s)) {
            /* To simplify the code, we prevent matches with the string
             * of window index 0 (in particular we have to avoid a match
             * of the string with itself at the start of the input file).
             */
            if (s->strategy != Z_HUFFMAN_ONLY) {
                s->match_length = longest_match (s, hash_head);
            }
            /* longest_match() sets match_start */

            if (s->match_length <= 5 && (s->strategy == Z_FILTERED ||
                 (s->match_length == MIN_MATCH &&
                  s->strstart - s->match_start > TOO_FAR))) {

                /* If prev_match is also MIN_MATCH, match_start is garbage
                 * but we will ignore the current match anyway.
                 */
                s->match_length = MIN_MATCH-1;
            }
        }
        /* If there was a match at the previous step and the current
         * match is not better, output the previous match:
         */
        if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {
            uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;
            /* Do not insert strings in hash table beyond this. */

            check_match(s, s->strstart-1, s->prev_match, s->prev_length);

            _tr_tally_dist(s, s->strstart -1 - s->prev_match,
			   s->prev_length - MIN_MATCH, bflush);

            /* Insert in hash table all strings up to the end of the match.
             * strstart-1 and strstart are already inserted. If there is not
             * enough lookahead, the last two strings are not inserted in
             * the hash table.
             */
            s->lookahead -= s->prev_length-1;
            s->prev_length -= 2;
            do {
                if (++s->strstart <= max_insert) {
                    INSERT_STRING(s, s->strstart, hash_head);
                }
            } while (--s->prev_length != 0);
            s->match_available = 0;
            s->match_length = MIN_MATCH-1;
            s->strstart++;

            if (bflush) FLUSH_BLOCK(s, 0);

        } else if (s->match_available) {
            /* If there was no match at the previous position, output a
             * single literal. If there was a match but the current match
             * is longer, truncate the previous match to a single literal.
             */
            Tracevv((stderr,"%c", s->window[s->strstart-1]));
	    _tr_tally_lit(s, s->window[s->strstart-1], bflush);
	    if (bflush) {
                FLUSH_BLOCK_ONLY(s, 0);
            }
            s->strstart++;
            s->lookahead--;
            if (s->strm->avail_out == 0) return need_more;
        } else {
            /* There is no previous match to compare with, wait for
             * the next step to decide.
             */
            s->match_available = 1;
            s->strstart++;
            s->lookahead--;
        }
    }
    Assert (flush != Z_NO_FLUSH, "no flush?");
    if (s->match_available) {
        Tracevv((stderr,"%c", s->window[s->strstart-1]));
        _tr_tally_lit(s, s->window[s->strstart-1], bflush);
        s->match_available = 0;
    }
    FLUSH_BLOCK(s, flush == Z_FINISH);
    return flush == Z_FINISH ? finish_done : block_done;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\example.c ===
/* example.c -- usage example of the zlib compression library
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include <stdio.h>
#include "zlib.h"

#ifdef STDC
#  include <string.h>
#  include <stdlib.h>
#else
   extern void exit  OF((int));
#endif

#if defined(VMS) || defined(RISCOS)
#  define TESTFILE "foo-gz"
#else
#  define TESTFILE "foo.gz"
#endif

#define CHECK_ERR(err, msg) { \
    if (err != Z_OK) { \
        fprintf(stderr, "%s error: %d\n", msg, err); \
        exit(1); \
    } \
}

const char hello[] = "hello, hello!";
/* "hello world" would be more standard, but the repeated "hello"
 * stresses the compression code better, sorry...
 */

const char dictionary[] = "hello";
uLong dictId; /* Adler32 value of the dictionary */

void test_compress      OF((Byte *compr, uLong comprLen,
		            Byte *uncompr, uLong uncomprLen));
void test_gzio          OF((const char *out, const char *in, 
		            Byte *uncompr, int uncomprLen));
void test_deflate       OF((Byte *compr, uLong comprLen));
void test_inflate       OF((Byte *compr, uLong comprLen,
		            Byte *uncompr, uLong uncomprLen));
void test_large_deflate OF((Byte *compr, uLong comprLen,
		            Byte *uncompr, uLong uncomprLen));
void test_large_inflate OF((Byte *compr, uLong comprLen,
		            Byte *uncompr, uLong uncomprLen));
void test_flush         OF((Byte *compr, uLong *comprLen));
void test_sync          OF((Byte *compr, uLong comprLen,
		            Byte *uncompr, uLong uncomprLen));
void test_dict_deflate  OF((Byte *compr, uLong comprLen));
void test_dict_inflate  OF((Byte *compr, uLong comprLen,
		            Byte *uncompr, uLong uncomprLen));
int  main               OF((int argc, char *argv[]));

/* ===========================================================================
 * Test compress() and uncompress()
 */
void test_compress(compr, comprLen, uncompr, uncomprLen)
    Byte *compr, *uncompr;
    uLong comprLen, uncomprLen;
{
    int err;
    uLong len = strlen(hello)+1;

    err = compress(compr, &comprLen, (const Bytef*)hello, len);
    CHECK_ERR(err, "compress");

    strcpy((char*)uncompr, "garbage");

    err = uncompress(uncompr, &uncomprLen, compr, comprLen);
    CHECK_ERR(err, "uncompress");

    if (strcmp((char*)uncompr, hello)) {
        fprintf(stderr, "bad uncompress\n");
	exit(1);
    } else {
        printf("uncompress(): %s\n", (char *)uncompr);
    }
}

/* ===========================================================================
 * Test read/write of .gz files
 */
void test_gzio(out, in, uncompr, uncomprLen)
    const char *out; /* compressed output file */
    const char *in;  /* compressed input file */
    Byte *uncompr;
    int  uncomprLen;
{
    int err;
    int len = strlen(hello)+1;
    gzFile file;
    z_off_t pos;

    file = gzopen(out, "wb");
    if (file == NULL) {
        fprintf(stderr, "gzopen error\n");
        exit(1);
    }
    gzputc(file, 'h');
    if (gzputs(file, "ello") != 4) {
        fprintf(stderr, "gzputs err: %s\n", gzerror(file, &err));
	exit(1);
    }
    if (gzprintf(file, ", %s!", "hello") != 8) {
        fprintf(stderr, "gzprintf err: %s\n", gzerror(file, &err));
	exit(1);
    }
    gzseek(file, 1L, SEEK_CUR); /* add one zero byte */
    gzclose(file);

    file = gzopen(in, "rb");
    if (file == NULL) {
        fprintf(stderr, "gzopen error\n");
    }
    strcpy((char*)uncompr, "garbage");

    uncomprLen = gzread(file, uncompr, (unsigned)uncomprLen);
    if (uncomprLen != len) {
        fprintf(stderr, "gzread err: %s\n", gzerror(file, &err));
	exit(1);
    }
    if (strcmp((char*)uncompr, hello)) {
        fprintf(stderr, "bad gzread: %s\n", (char*)uncompr);
	exit(1);
    } else {
        printf("gzread(): %s\n", (char *)uncompr);
    }

    pos = gzseek(file, -8L, SEEK_CUR);
    if (pos != 6 || gztell(file) != pos) {
	fprintf(stderr, "gzseek error, pos=%ld, gztell=%ld\n",
		(long)pos, (long)gztell(file));
	exit(1);
    }

    if (gzgetc(file) != ' ') {
	fprintf(stderr, "gzgetc error\n");
	exit(1);
    }

    gzgets(file, (char*)uncompr, uncomprLen);
    uncomprLen = strlen((char*)uncompr);
    if (uncomprLen != 6) { /* "hello!" */
        fprintf(stderr, "gzgets err after gzseek: %s\n", gzerror(file, &err));
	exit(1);
    }
    if (strcmp((char*)uncompr, hello+7)) {
        fprintf(stderr, "bad gzgets after gzseek\n");
	exit(1);
    } else {
        printf("gzgets() after gzseek: %s\n", (char *)uncompr);
    }

    gzclose(file);
}

/* ===========================================================================
 * Test deflate() with small buffers
 */
void test_deflate(compr, comprLen)
    Byte *compr;
    uLong comprLen;
{
    z_stream c_stream; /* compression stream */
    int err;
    int len = strlen(hello)+1;

    c_stream.zalloc = (alloc_func)0;
    c_stream.zfree = (free_func)0;
    c_stream.opaque = (voidpf)0;

    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);
    CHECK_ERR(err, "deflateInit");

    c_stream.next_in  = (Bytef*)hello;
    c_stream.next_out = compr;

    while (c_stream.total_in != (uLong)len && c_stream.total_out < comprLen) {
        c_stream.avail_in = c_stream.avail_out = 1; /* force small buffers */
        err = deflate(&c_stream, Z_NO_FLUSH);
        CHECK_ERR(err, "deflate");
    }
    /* Finish the stream, still forcing small buffers: */
    for (;;) {
        c_stream.avail_out = 1;
        err = deflate(&c_stream, Z_FINISH);
        if (err == Z_STREAM_END) break;
        CHECK_ERR(err, "deflate");
    }

    err = deflateEnd(&c_stream);
    CHECK_ERR(err, "deflateEnd");
}

/* ===========================================================================
 * Test inflate() with small buffers
 */
void test_inflate(compr, comprLen, uncompr, uncomprLen)
    Byte *compr, *uncompr;
    uLong comprLen, uncomprLen;
{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, "garbage");

    d_stream.zalloc = (alloc_func)0;
    d_stream.zfree = (free_func)0;
    d_stream.opaque = (voidpf)0;

    d_stream.next_in  = compr;
    d_stream.avail_in = 0;
    d_stream.next_out = uncompr;

    err = inflateInit(&d_stream);
    CHECK_ERR(err, "inflateInit");

    while (d_stream.total_out < uncomprLen && d_stream.total_in < comprLen) {
        d_stream.avail_in = d_stream.avail_out = 1; /* force small buffers */
        err = inflate(&d_stream, Z_NO_FLUSH);
        if (err == Z_STREAM_END) break;
        CHECK_ERR(err, "inflate");
    }

    err = inflateEnd(&d_stream);
    CHECK_ERR(err, "inflateEnd");

    if (strcmp((char*)uncompr, hello)) {
        fprintf(stderr, "bad inflate\n");
	exit(1);
    } else {
        printf("inflate(): %s\n", (char *)uncompr);
    }
}

/* ===========================================================================
 * Test deflate() with large buffers and dynamic change of compression level
 */
void test_large_deflate(compr, comprLen, uncompr, uncomprLen)
    Byte *compr, *uncompr;
    uLong comprLen, uncomprLen;
{
    z_stream c_stream; /* compression stream */
    int err;

    c_stream.zalloc = (alloc_func)0;
    c_stream.zfree = (free_func)0;
    c_stream.opaque = (voidpf)0;

    err = deflateInit(&c_stream, Z_BEST_SPEED);
    CHECK_ERR(err, "deflateInit");

    c_stream.next_out = compr;
    c_stream.avail_out = (uInt)comprLen;

    /* At this point, uncompr is still mostly zeroes, so it should compress
     * very well:
     */
    c_stream.next_in = uncompr;
    c_stream.avail_in = (uInt)uncomprLen;
    err = deflate(&c_stream, Z_NO_FLUSH);
    CHECK_ERR(err, "deflate");
    if (c_stream.avail_in != 0) {
        fprintf(stderr, "deflate not greedy\n");
	exit(1);
    }

    /* Feed in already compressed data and switch to no compression: */
    deflateParams(&c_stream, Z_NO_COMPRESSION, Z_DEFAULT_STRATEGY);
    c_stream.next_in = compr;
    c_stream.avail_in = (uInt)comprLen/2;
    err = deflate(&c_stream, Z_NO_FLUSH);
    CHECK_ERR(err, "deflate");

    /* Switch back to compressing mode: */
    deflateParams(&c_stream, Z_BEST_COMPRESSION, Z_FILTERED);
    c_stream.next_in = uncompr;
    c_stream.avail_in = (uInt)uncomprLen;
    err = deflate(&c_stream, Z_NO_FLUSH);
    CHECK_ERR(err, "deflate");

    err = deflate(&c_stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        fprintf(stderr, "deflate should report Z_STREAM_END\n");
	exit(1);
    }
    err = deflateEnd(&c_stream);
    CHECK_ERR(err, "deflateEnd");
}

/* ===========================================================================
 * Test inflate() with large buffers
 */
void test_large_inflate(compr, comprLen, uncompr, uncomprLen)
    Byte *compr, *uncompr;
    uLong comprLen, uncomprLen;
{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, "garbage");

    d_stream.zalloc = (alloc_func)0;
    d_stream.zfree = (free_func)0;
    d_stream.opaque = (voidpf)0;

    d_stream.next_in  = compr;
    d_stream.avail_in = (uInt)comprLen;

    err = inflateInit(&d_stream);
    CHECK_ERR(err, "inflateInit");

    for (;;) {
        d_stream.next_out = uncompr;            /* discard the output */
	d_stream.avail_out = (uInt)uncomprLen;
        err = inflate(&d_stream, Z_NO_FLUSH);
        if (err == Z_STREAM_END) break;
        CHECK_ERR(err, "large inflate");
    }

    err = inflateEnd(&d_stream);
    CHECK_ERR(err, "inflateEnd");

    if (d_stream.total_out != 2*uncomprLen + comprLen/2) {
        fprintf(stderr, "bad large inflate: %ld\n", d_stream.total_out);
	exit(1);
    } else {
        printf("large_inflate(): OK\n");
    }
}

/* ===========================================================================
 * Test deflate() with full flush
 */
void test_flush(compr, comprLen)
    Byte *compr;
    uLong *comprLen;
{
    z_stream c_stream; /* compression stream */
    int err;
    int len = strlen(hello)+1;

    c_stream.zalloc = (alloc_func)0;
    c_stream.zfree = (free_func)0;
    c_stream.opaque = (voidpf)0;

    err = deflateInit(&c_stream, Z_DEFAULT_COMPRESSION);
    CHECK_ERR(err, "deflateInit");

    c_stream.next_in  = (Bytef*)hello;
    c_stream.next_out = compr;
    c_stream.avail_in = 3;
    c_stream.avail_out = (uInt)*comprLen;
    err = deflate(&c_stream, Z_FULL_FLUSH);
    CHECK_ERR(err, "deflate");

    compr[3]++; /* force an error in first compressed block */
    c_stream.avail_in = len - 3;

    err = deflate(&c_stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        CHECK_ERR(err, "deflate");
    }
    err = deflateEnd(&c_stream);
    CHECK_ERR(err, "deflateEnd");

    *comprLen = c_stream.total_out;
}

/* ===========================================================================
 * Test inflateSync()
 */
void test_sync(compr, comprLen, uncompr, uncomprLen)
    Byte *compr, *uncompr;
    uLong comprLen, uncomprLen;
{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, "garbage");

    d_stream.zalloc = (alloc_func)0;
    d_stream.zfree = (free_func)0;
    d_stream.opaque = (voidpf)0;

    d_stream.next_in  = compr;
    d_stream.avail_in = 2; /* just read the zlib header */

    err = inflateInit(&d_stream);
    CHECK_ERR(err, "inflateInit");

    d_stream.next_out = uncompr;
    d_stream.avail_out = (uInt)uncomprLen;

    inflate(&d_stream, Z_NO_FLUSH);
    CHECK_ERR(err, "inflate");

    d_stream.avail_in = (uInt)comprLen-2;   /* read all compressed data */
    err = inflateSync(&d_stream);           /* but skip the damaged part */
    CHECK_ERR(err, "inflateSync");

    err = inflate(&d_stream, Z_FINISH);
    if (err != Z_DATA_ERROR) {
        fprintf(stderr, "inflate should report DATA_ERROR\n");
        /* Because of incorrect adler32 */
	exit(1);
    }
    err = inflateEnd(&d_stream);
    CHECK_ERR(err, "inflateEnd");

    printf("after inflateSync(): hel%s\n", (char *)uncompr);
}

/* ===========================================================================
 * Test deflate() with preset dictionary
 */
void test_dict_deflate(compr, comprLen)
    Byte *compr;
    uLong comprLen;
{
    z_stream c_stream; /* compression stream */
    int err;

    c_stream.zalloc = (alloc_func)0;
    c_stream.zfree = (free_func)0;
    c_stream.opaque = (voidpf)0;

    err = deflateInit(&c_stream, Z_BEST_COMPRESSION);
    CHECK_ERR(err, "deflateInit");

    err = deflateSetDictionary(&c_stream,
			       (const Bytef*)dictionary, sizeof(dictionary));
    CHECK_ERR(err, "deflateSetDictionary");

    dictId = c_stream.adler;
    c_stream.next_out = compr;
    c_stream.avail_out = (uInt)comprLen;

    c_stream.next_in = (Bytef*)hello;
    c_stream.avail_in = (uInt)strlen(hello)+1;

    err = deflate(&c_stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        fprintf(stderr, "deflate should report Z_STREAM_END\n");
	exit(1);
    }
    err = deflateEnd(&c_stream);
    CHECK_ERR(err, "deflateEnd");
}

/* ===========================================================================
 * Test inflate() with a preset dictionary
 */
void test_dict_inflate(compr, comprLen, uncompr, uncomprLen)
    Byte *compr, *uncompr;
    uLong comprLen, uncomprLen;
{
    int err;
    z_stream d_stream; /* decompression stream */

    strcpy((char*)uncompr, "garbage");

    d_stream.zalloc = (alloc_func)0;
    d_stream.zfree = (free_func)0;
    d_stream.opaque = (voidpf)0;

    d_stream.next_in  = compr;
    d_stream.avail_in = (uInt)comprLen;

    err = inflateInit(&d_stream);
    CHECK_ERR(err, "inflateInit");

    d_stream.next_out = uncompr;
    d_stream.avail_out = (uInt)uncomprLen;

    for (;;) {
        err = inflate(&d_stream, Z_NO_FLUSH);
        if (err == Z_STREAM_END) break;
	if (err == Z_NEED_DICT) {
	    if (d_stream.adler != dictId) {
		fprintf(stderr, "unexpected dictionary");
		exit(1);
	    }
	    err = inflateSetDictionary(&d_stream, (const Bytef*)dictionary,
				       sizeof(dictionary));
	}
        CHECK_ERR(err, "inflate with dict");
    }

    err = inflateEnd(&d_stream);
    CHECK_ERR(err, "inflateEnd");

    if (strcmp((char*)uncompr, hello)) {
        fprintf(stderr, "bad inflate with dict\n");
	exit(1);
    } else {
        printf("inflate with dictionary: %s\n", (char *)uncompr);
    }
}

/* ===========================================================================
 * Usage:  example [output.gz  [input.gz]]
 */

int main(argc, argv)
    int argc;
    char *argv[];
{
    Byte *compr, *uncompr;
    uLong comprLen = 10000*sizeof(int); /* don't overflow on MSDOS */
    uLong uncomprLen = comprLen;
    static const char* myVersion = ZLIB_VERSION;

    if (zlibVersion()[0] != myVersion[0]) {
        fprintf(stderr, "incompatible zlib version\n");
        exit(1);

    } else if (strcmp(zlibVersion(), ZLIB_VERSION) != 0) {
        fprintf(stderr, "warning: different zlib version\n");
    }

    compr    = (Byte*)calloc((uInt)comprLen, 1);
    uncompr  = (Byte*)calloc((uInt)uncomprLen, 1);
    /* compr and uncompr are cleared to avoid reading uninitialized
     * data and to ensure that uncompr compresses well.
     */
    if (compr == Z_NULL || uncompr == Z_NULL) {
        printf("out of memory\n");
	exit(1);
    }
    test_compress(compr, comprLen, uncompr, uncomprLen);

    test_gzio((argc > 1 ? argv[1] : TESTFILE),
              (argc > 2 ? argv[2] : TESTFILE),
	      uncompr, (int)uncomprLen);

    test_deflate(compr, comprLen);
    test_inflate(compr, comprLen, uncompr, uncomprLen);

    test_large_deflate(compr, comprLen, uncompr, uncomprLen);
    test_large_inflate(compr, comprLen, uncompr, uncomprLen);

    test_flush(compr, &comprLen);
    test_sync(compr, comprLen, uncompr, uncomprLen);
    comprLen = uncomprLen;

    test_dict_deflate(compr, comprLen);
    test_dict_inflate(compr, comprLen, uncompr, uncomprLen);

    exit(0);
    return 0; /* to avoid warning */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\deflate.h ===
/* deflate.h -- internal compression state
 * Copyright (C) 1995-2002 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* @(#) $Id$ */

#ifndef _DEFLATE_H
#define _DEFLATE_H

#include "zutil.h"

/* ===========================================================================
 * Internal compression state.
 */

#define LENGTH_CODES 29
/* number of length codes, not counting the special END_BLOCK code */

#define LITERALS  256
/* number of literal bytes 0..255 */

#define L_CODES (LITERALS+1+LENGTH_CODES)
/* number of Literal or Length codes, including the END_BLOCK code */

#define D_CODES   30
/* number of distance codes */

#define BL_CODES  19
/* number of codes used to transfer the bit lengths */

#define HEAP_SIZE (2*L_CODES+1)
/* maximum heap size */

#define MAX_BITS 15
/* All codes must not exceed MAX_BITS bits */

#define INIT_STATE    42
#define BUSY_STATE   113
#define FINISH_STATE 666
/* Stream status */


/* Data structure describing a single value and its code string. */
typedef struct ct_data_s {
    union {
        ush  freq;       /* frequency count */
        ush  code;       /* bit string */
    } fc;
    union {
        ush  dad;        /* father node in Huffman tree */
        ush  len;        /* length of bit string */
    } dl;
} FAR ct_data;

#define Freq fc.freq
#define Code fc.code
#define Dad  dl.dad
#define Len  dl.len

typedef struct static_tree_desc_s  static_tree_desc;

typedef struct tree_desc_s {
    ct_data *dyn_tree;           /* the dynamic tree */
    int     max_code;            /* largest code with non zero frequency */
    const static_tree_desc *stat_desc; /* the corresponding static tree */
} FAR tree_desc;

typedef ush Pos;
typedef Pos FAR Posf;
typedef unsigned IPos;

/* A Pos is an index in the character window. We use short instead of int to
 * save space in the various tables. IPos is used only for parameter passing.
 */

typedef struct internal_state {
    z_streamp strm;      /* pointer back to this zlib stream */
    int   status;        /* as the name implies */
    Bytef *pending_buf;  /* output still pending */
    ulg   pending_buf_size; /* size of pending_buf */
    Bytef *pending_out;  /* next pending byte to output to the stream */
    int   pending;       /* nb of bytes in the pending buffer */
    int   noheader;      /* suppress zlib header and adler32 */
    Byte  data_type;     /* UNKNOWN, BINARY or ASCII */
    Byte  method;        /* STORED (for zip only) or DEFLATED */
    int   last_flush;    /* value of flush param for previous deflate call */

                /* used by deflate.c: */

    uInt  w_size;        /* LZ77 window size (32K by default) */
    uInt  w_bits;        /* log2(w_size)  (8..16) */
    uInt  w_mask;        /* w_size - 1 */

    Bytef *window;
    /* Sliding window. Input bytes are read into the second half of the window,
     * and move to the first half later to keep a dictionary of at least wSize
     * bytes. With this organization, matches are limited to a distance of
     * wSize-MAX_MATCH bytes, but this ensures that IO is always
     * performed with a length multiple of the block size. Also, it limits
     * the window size to 64K, which is quite useful on MSDOS.
     * To do: use the user input buffer as sliding window.
     */

    ulg window_size;
    /* Actual size of window: 2*wSize, except when the user input buffer
     * is directly used as sliding window.
     */

    Posf *prev;
    /* Link to older string with same hash index. To limit the size of this
     * array to 64K, this link is maintained only for the last 32K strings.
     * An index in this array is thus a window index modulo 32K.
     */

    Posf *head; /* Heads of the hash chains or NIL. */

    uInt  ins_h;          /* hash index of string to be inserted */
    uInt  hash_size;      /* number of elements in hash table */
    uInt  hash_bits;      /* log2(hash_size) */
    uInt  hash_mask;      /* hash_size-1 */

    uInt  hash_shift;
    /* Number of bits by which ins_h must be shifted at each input
     * step. It must be such that after MIN_MATCH steps, the oldest
     * byte no longer takes part in the hash key, that is:
     *   hash_shift * MIN_MATCH >= hash_bits
     */

    long block_start;
    /* Window position at the beginning of the current output block. Gets
     * negative when the window is moved backwards.
     */

    uInt match_length;           /* length of best match */
    IPos prev_match;             /* previous match */
    int match_available;         /* set if previous match exists */
    uInt strstart;               /* start of string to insert */
    uInt match_start;            /* start of matching string */
    uInt lookahead;              /* number of valid bytes ahead in window */

    uInt prev_length;
    /* Length of the best match at previous step. Matches not greater than this
     * are discarded. This is used in the lazy match evaluation.
     */

    uInt max_chain_length;
    /* To speed up deflation, hash chains are never searched beyond this
     * length.  A higher limit improves compression ratio but degrades the
     * speed.
     */

    uInt max_lazy_match;
    /* Attempt to find a better match only when the current match is strictly
     * smaller than this value. This mechanism is used only for compression
     * levels >= 4.
     */
#   define max_insert_length  max_lazy_match
    /* Insert new strings in the hash table only if the match length is not
     * greater than this length. This saves time but degrades compression.
     * max_insert_length is used only for compression levels <= 3.
     */

    int level;    /* compression level (1..9) */
    int strategy; /* favor or force Huffman coding*/

    uInt good_match;
    /* Use a faster search when the previous match is longer than this */

    int nice_match; /* Stop searching when current match exceeds this */

                /* used by trees.c: */
    /* Didn't use ct_data typedef below to supress compiler warning */
    struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */
    struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */
    struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */

    struct tree_desc_s l_desc;               /* desc. for literal tree */
    struct tree_desc_s d_desc;               /* desc. for distance tree */
    struct tree_desc_s bl_desc;              /* desc. for bit length tree */

    ush bl_count[MAX_BITS+1];
    /* number of codes at each bit length for an optimal tree */

    int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */
    int heap_len;               /* number of elements in the heap */
    int heap_max;               /* element of largest frequency */
    /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.
     * The same heap array is used to build all trees.
     */

    uch depth[2*L_CODES+1];
    /* Depth of each subtree used as tie breaker for trees of equal frequency
     */

    uchf *l_buf;          /* buffer for literals or lengths */

    uInt  lit_bufsize;
    /* Size of match buffer for literals/lengths.  There are 4 reasons for
     * limiting lit_bufsize to 64K:
     *   - frequencies can be kept in 16 bit counters
     *   - if compression is not successful for the first block, all input
     *     data is still in the window so we can still emit a stored block even
     *     when input comes from standard input.  (This can also be done for
     *     all blocks if lit_bufsize is not greater than 32K.)
     *   - if compression is not successful for a file smaller than 64K, we can
     *     even emit a stored file instead of a stored block (saving 5 bytes).
     *     This is applicable only for zip (not gzip or zlib).
     *   - creating new Huffman trees less frequently may not provide fast
     *     adaptation to changes in the input data statistics. (Take for
     *     example a binary file with poorly compressible code followed by
     *     a highly compressible string table.) Smaller buffer sizes give
     *     fast adaptation but have of course the overhead of transmitting
     *     trees more frequently.
     *   - I can't count above 4
     */

    uInt last_lit;      /* running index in l_buf */

    ushf *d_buf;
    /* Buffer for distances. To simplify the code, d_buf and l_buf have
     * the same number of elements. To use different lengths, an extra flag
     * array would be necessary.
     */

    ulg opt_len;        /* bit length of current block with optimal trees */
    ulg static_len;     /* bit length of current block with static trees */
    uInt matches;       /* number of string matches in current block */
    int last_eob_len;   /* bit length of EOB code for last block */

#ifdef DEBUG
    ulg compressed_len; /* total bit length of compressed file mod 2^32 */
    ulg bits_sent;      /* bit length of compressed data sent mod 2^32 */
#endif

    ush bi_buf;
    /* Output buffer. bits are inserted starting at the bottom (least
     * significant bits).
     */
    int bi_valid;
    /* Number of valid bits in bi_buf.  All bits above the last valid bit
     * are always zero.
     */

} FAR deflate_state;

/* Output a byte on the stream.
 * IN assertion: there is enough room in pending_buf.
 */
#define put_byte(s, c) {s->pending_buf[s->pending++] = (c);}


#define MIN_LOOKAHEAD (MAX_MATCH+MIN_MATCH+1)
/* Minimum amount of lookahead, except at the end of the input file.
 * See deflate.c for comments about the MIN_MATCH+1.
 */

#define MAX_DIST(s)  ((s)->w_size-MIN_LOOKAHEAD)
/* In order to simplify the code, particularly on 16 bit machines, match
 * distances are limited to MAX_DIST instead of WSIZE.
 */

        /* in trees.c */
void _tr_init         OF((deflate_state *s));
int  _tr_tally        OF((deflate_state *s, unsigned dist, unsigned lc));
void _tr_flush_block  OF((deflate_state *s, charf *buf, ulg stored_len,
			  int eof));
void _tr_align        OF((deflate_state *s));
void _tr_stored_block OF((deflate_state *s, charf *buf, ulg stored_len,
                          int eof));

#define d_code(dist) \
   ((dist) < 256 ? _dist_code[dist] : _dist_code[256+((dist)>>7)])
/* Mapping from a distance to a distance code. dist is the distance - 1 and
 * must not have side effects. _dist_code[256] and _dist_code[257] are never
 * used.
 */

#ifndef DEBUG
/* Inline versions of _tr_tally for speed: */

#if defined(GEN_TREES_H) || !defined(STDC)
  extern uch _length_code[];
  extern uch _dist_code[];
#else
  extern const uch _length_code[];
  extern const uch _dist_code[];
#endif

# define _tr_tally_lit(s, c, flush) \
  { uch cc = (c); \
    s->d_buf[s->last_lit] = 0; \
    s->l_buf[s->last_lit++] = cc; \
    s->dyn_ltree[cc].Freq++; \
    flush = (s->last_lit == s->lit_bufsize-1); \
   }
# define _tr_tally_dist(s, distance, length, flush) \
  { uch len = (length); \
    ush dist = (distance); \
    s->d_buf[s->last_lit] = dist; \
    s->l_buf[s->last_lit++] = len; \
    dist--; \
    s->dyn_ltree[_length_code[len]+LITERALS+1].Freq++; \
    s->dyn_dtree[d_code(dist)].Freq++; \
    flush = (s->last_lit == s->lit_bufsize-1); \
  }
#else
# define _tr_tally_lit(s, c, flush) flush = _tr_tally(s, 0, c)
# define _tr_tally_dist(s, distance, length, flush) \
              flush = _tr_tally(s, distance, length) 
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\infblock.h ===
/* infblock.h -- header to use infblock.c
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

struct inflate_blocks_state;
typedef struct inflate_blocks_state FAR inflate_blocks_statef;

extern inflate_blocks_statef * inflate_blocks_new OF((
    z_streamp z,
    check_func c,               /* check function */
    uInt w));                   /* window size */

extern int inflate_blocks OF((
    inflate_blocks_statef *,
    z_streamp ,
    int));                      /* initial return code */

extern void inflate_blocks_reset OF((
    inflate_blocks_statef *,
    z_streamp ,
    uLongf *));                  /* check value on output */

extern int inflate_blocks_free OF((
    inflate_blocks_statef *,
    z_streamp));

extern void inflate_set_dictionary OF((
    inflate_blocks_statef *s,
    const Bytef *d,  /* dictionary */
    uInt  n));       /* dictionary length */

extern int inflate_blocks_sync_point OF((
    inflate_blocks_statef *s));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\infblock.c ===
/* infblock.c -- interpret and process block types to last block
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "infblock.h"
#include "inftrees.h"
#include "infcodes.h"
#include "infutil.h"

struct inflate_codes_state {int dummy;}; /* for buggy compilers */

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits

/* Table for deflate from PKZIP's appnote.txt. */
local const uInt border[] = { /* Order of the bit length code lengths */
        16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

/*
   Notes beyond the 1.93a appnote.txt:

   1. Distance pointers never point before the beginning of the output
      stream.
   2. Distance pointers can point back across blocks, up to 32k away.
   3. There is an implied maximum of 7 bits for the bit length table and
      15 bits for the actual data.
   4. If only one code exists, then it is encoded using one bit.  (Zero
      would be more efficient, but perhaps a little confusing.)  If two
      codes exist, they are coded using one bit each (0 and 1).
   5. There is no way of sending zero distance codes--a dummy must be
      sent if there are none.  (History: a pre 2.0 version of PKZIP would
      store blocks with no distance codes, but this was discovered to be
      too harsh a criterion.)  Valid only for 1.93a.  2.04c does allow
      zero distance codes, which is sent as one code of zero bits in
      length.
   6. There are up to 286 literal/length codes.  Code 256 represents the
      end-of-block.  Note however that the static length tree defines
      288 codes just to fill out the Huffman codes.  Codes 286 and 287
      cannot be used though, since there is no length base or extra bits
      defined for them.  Similarily, there are up to 30 distance codes.
      However, static trees define 32 codes (all 5 bits) to fill out the
      Huffman codes, but the last two had better not show up in the data.
   7. Unzip can check dynamic Huffman blocks for complete code sets.
      The exception is that a single code would not be complete (see #4).
   8. The five bits following the block type is really the number of
      literal codes sent minus 257.
   9. Length codes 8,16,16 are interpreted as 13 length codes of 8 bits
      (1+6+6).  Therefore, to output three times the length, you output
      three codes (1+1+1), whereas to output four times the same length,
      you only need two codes (1+3).  Hmm.
  10. In the tree reconstruction algorithm, Code = Code + Increment
      only if BitLength(i) is not zero.  (Pretty obvious.)
  11. Correction: 4 Bits: # of Bit Length codes - 4     (4 - 19)
  12. Note: length code 284 can represent 227-258, but length code 285
      really is 258.  The last length deserves its own, short code
      since it gets used a lot in very redundant files.  The length
      258 is special since 258 - 3 (the min match length) is 255.
  13. The literal/length and distance code bit lengths are read as a
      single stream of lengths.  It is possible (and advantageous) for
      a repeat code (16, 17, or 18) to go across the boundary between
      the two sets of lengths.
 */


void inflate_blocks_reset(s, z, c)
inflate_blocks_statef *s;
z_streamp z;
uLongf *c;
{
  if (c != Z_NULL)
    *c = s->check;
  if (s->mode == BTREE || s->mode == DTREE)
    ZFREE(z, s->sub.trees.blens);
  if (s->mode == CODES)
    inflate_codes_free(s->sub.decode.codes, z);
  s->mode = TYPE;
  s->bitk = 0;
  s->bitb = 0;
  s->read = s->write = s->window;
  if (s->checkfn != Z_NULL)
    z->adler = s->check = (*s->checkfn)(0L, (const Bytef *)Z_NULL, 0);
  Tracev((stderr, "inflate:   blocks reset\n"));
}


inflate_blocks_statef *inflate_blocks_new(z, c, w)
z_streamp z;
check_func c;
uInt w;
{
  inflate_blocks_statef *s;

  if ((s = (inflate_blocks_statef *)ZALLOC
       (z,1,sizeof(struct inflate_blocks_state))) == Z_NULL)
    return s;
  if ((s->hufts =
       (inflate_huft *)ZALLOC(z, sizeof(inflate_huft), MANY)) == Z_NULL)
  {
    ZFREE(z, s);
    return Z_NULL;
  }
  if ((s->window = (Bytef *)ZALLOC(z, 1, w)) == Z_NULL)
  {
    ZFREE(z, s->hufts);
    ZFREE(z, s);
    return Z_NULL;
  }
  s->end = s->window + w;
  s->checkfn = c;
  s->mode = TYPE;
  Tracev((stderr, "inflate:   blocks allocated\n"));
  inflate_blocks_reset(s, z, Z_NULL);
  return s;
}


int inflate_blocks(s, z, r)
inflate_blocks_statef *s;
z_streamp z;
int r;
{
  uInt t;               /* temporary storage */
  uLong b;              /* bit buffer */
  uInt k;               /* bits in bit buffer */
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */

  /* copy input/output information to locals (UPDATE macro restores) */
  LOAD

  /* process input based on current state */
  while (1) switch (s->mode)
  {
    case TYPE:
      NEEDBITS(3)
      t = (uInt)b & 7;
      s->last = t & 1;
      switch (t >> 1)
      {
        case 0:                         /* stored */
          Tracev((stderr, "inflate:     stored block%s\n",
                 s->last ? " (last)" : ""));
          DUMPBITS(3)
          t = k & 7;                    /* go to byte boundary */
          DUMPBITS(t)
          s->mode = LENS;               /* get length of stored block */
          break;
        case 1:                         /* fixed */
          Tracev((stderr, "inflate:     fixed codes block%s\n",
                 s->last ? " (last)" : ""));
          {
            uInt bl, bd;
            inflate_huft *tl, *td;

            inflate_trees_fixed(&bl, &bd, &tl, &td, z);
            s->sub.decode.codes = inflate_codes_new(bl, bd, tl, td, z);
            if (s->sub.decode.codes == Z_NULL)
            {
              r = Z_MEM_ERROR;
              LEAVE
            }
          }
          DUMPBITS(3)
          s->mode = CODES;
          break;
        case 2:                         /* dynamic */
          Tracev((stderr, "inflate:     dynamic codes block%s\n",
                 s->last ? " (last)" : ""));
          DUMPBITS(3)
          s->mode = TABLE;
          break;
        case 3:                         /* illegal */
          DUMPBITS(3)
          s->mode = BAD;
          z->msg = (char*)"invalid block type";
          r = Z_DATA_ERROR;
          LEAVE
      }
      break;
    case LENS:
      NEEDBITS(32)
      if ((((~b) >> 16) & 0xffff) != (b & 0xffff))
      {
        s->mode = BAD;
        z->msg = (char*)"invalid stored block lengths";
        r = Z_DATA_ERROR;
        LEAVE
      }
      s->sub.left = (uInt)b & 0xffff;
      b = k = 0;                      /* dump bits */
      Tracev((stderr, "inflate:       stored length %u\n", s->sub.left));
      s->mode = s->sub.left ? STORED : (s->last ? DRY : TYPE);
      break;
    case STORED:
      if (n == 0)
        LEAVE
      NEEDOUT
      t = s->sub.left;
      if (t > n) t = n;
      if (t > m) t = m;
      zmemcpy(q, p, t);
      p += t;  n -= t;
      q += t;  m -= t;
      if ((s->sub.left -= t) != 0)
        break;
      Tracev((stderr, "inflate:       stored end, %lu total out\n",
              z->total_out + (q >= s->read ? q - s->read :
              (s->end - s->read) + (q - s->window))));
      s->mode = s->last ? DRY : TYPE;
      break;
    case TABLE:
      NEEDBITS(14)
      s->sub.trees.table = t = (uInt)b & 0x3fff;
#ifndef PKZIP_BUG_WORKAROUND
      if ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29)
      {
        s->mode = BAD;
        z->msg = (char*)"too many length or distance symbols";
        r = Z_DATA_ERROR;
        LEAVE
      }
#endif
      t = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);
      if ((s->sub.trees.blens = (uIntf*)ZALLOC(z, t, sizeof(uInt))) == Z_NULL)
      {
        r = Z_MEM_ERROR;
        LEAVE
      }
      DUMPBITS(14)
      s->sub.trees.index = 0;
      Tracev((stderr, "inflate:       table sizes ok\n"));
      s->mode = BTREE;
    case BTREE:
      while (s->sub.trees.index < 4 + (s->sub.trees.table >> 10))
      {
        NEEDBITS(3)
        s->sub.trees.blens[border[s->sub.trees.index++]] = (uInt)b & 7;
        DUMPBITS(3)
      }
      while (s->sub.trees.index < 19)
        s->sub.trees.blens[border[s->sub.trees.index++]] = 0;
      s->sub.trees.bb = 7;
      t = inflate_trees_bits(s->sub.trees.blens, &s->sub.trees.bb,
                             &s->sub.trees.tb, s->hufts, z);
      if (t != Z_OK)
      {
        r = t;
        if (r == Z_DATA_ERROR)
        {
          ZFREE(z, s->sub.trees.blens);
          s->mode = BAD;
        }
        LEAVE
      }
      s->sub.trees.index = 0;
      Tracev((stderr, "inflate:       bits tree ok\n"));
      s->mode = DTREE;
    case DTREE:
      while (t = s->sub.trees.table,
             s->sub.trees.index < 258 + (t & 0x1f) + ((t >> 5) & 0x1f))
      {
        inflate_huft *h;
        uInt i, j, c;

        t = s->sub.trees.bb;
        NEEDBITS(t)
        h = s->sub.trees.tb + ((uInt)b & inflate_mask[t]);
        t = h->bits;
        c = h->base;
        if (c < 16)
        {
          DUMPBITS(t)
          s->sub.trees.blens[s->sub.trees.index++] = c;
        }
        else /* c == 16..18 */
        {
          i = c == 18 ? 7 : c - 14;
          j = c == 18 ? 11 : 3;
          NEEDBITS(t + i)
          DUMPBITS(t)
          j += (uInt)b & inflate_mask[i];
          DUMPBITS(i)
          i = s->sub.trees.index;
          t = s->sub.trees.table;
          if (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) ||
              (c == 16 && i < 1))
          {
            ZFREE(z, s->sub.trees.blens);
            s->mode = BAD;
            z->msg = (char*)"invalid bit length repeat";
            r = Z_DATA_ERROR;
            LEAVE
          }
          c = c == 16 ? s->sub.trees.blens[i - 1] : 0;
          do {
            s->sub.trees.blens[i++] = c;
          } while (--j);
          s->sub.trees.index = i;
        }
      }
      s->sub.trees.tb = Z_NULL;
      {
        uInt bl, bd;
        inflate_huft *tl, *td;
        inflate_codes_statef *c;

        bl = 9;         /* must be <= 9 for lookahead assumptions */
        bd = 6;         /* must be <= 9 for lookahead assumptions */
        t = s->sub.trees.table;
        t = inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f),
                                  s->sub.trees.blens, &bl, &bd, &tl, &td,
                                  s->hufts, z);
        if (t != Z_OK)
        {
          if (t == (uInt)Z_DATA_ERROR)
          {
            ZFREE(z, s->sub.trees.blens);
            s->mode = BAD;
          }
          r = t;
          LEAVE
        }
        Tracev((stderr, "inflate:       trees ok\n"));
        if ((c = inflate_codes_new(bl, bd, tl, td, z)) == Z_NULL)
        {
          r = Z_MEM_ERROR;
          LEAVE
        }
        s->sub.decode.codes = c;
      }
      ZFREE(z, s->sub.trees.blens);
      s->mode = CODES;
    case CODES:
      UPDATE
      if ((r = inflate_codes(s, z, r)) != Z_STREAM_END)
        return inflate_flush(s, z, r);
      r = Z_OK;
      inflate_codes_free(s->sub.decode.codes, z);
      LOAD
      Tracev((stderr, "inflate:       codes end, %lu total out\n",
              z->total_out + (q >= s->read ? q - s->read :
              (s->end - s->read) + (q - s->window))));
      if (!s->last)
      {
        s->mode = TYPE;
        break;
      }
      s->mode = DRY;
    case DRY:
      FLUSH
      if (s->read != s->write)
        LEAVE
      s->mode = DONE;
    case DONE:
      r = Z_STREAM_END;
      LEAVE
    case BAD:
      r = Z_DATA_ERROR;
      LEAVE
    default:
      r = Z_STREAM_ERROR;
      LEAVE
  }
}


int inflate_blocks_free(s, z)
inflate_blocks_statef *s;
z_streamp z;
{
  inflate_blocks_reset(s, z, Z_NULL);
  ZFREE(z, s->window);
  ZFREE(z, s->hufts);
  ZFREE(z, s);
  Tracev((stderr, "inflate:   blocks freed\n"));
  return Z_OK;
}


void inflate_set_dictionary(s, d, n)
inflate_blocks_statef *s;
const Bytef *d;
uInt  n;
{
  zmemcpy(s->window, d, n);
  s->read = s->write = s->window + n;
}


/* Returns true if inflate is currently at the end of a block generated
 * by Z_SYNC_FLUSH or Z_FULL_FLUSH. 
 * IN assertion: s != Z_NULL
 */
int inflate_blocks_sync_point(s)
inflate_blocks_statef *s;
{
  return s->mode == LENS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\infcodes.h ===
/* infcodes.h -- header to use infcodes.c
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

struct inflate_codes_state;
typedef struct inflate_codes_state FAR inflate_codes_statef;

extern inflate_codes_statef *inflate_codes_new OF((
    uInt, uInt,
    inflate_huft *, inflate_huft *,
    z_streamp ));

extern int inflate_codes OF((
    inflate_blocks_statef *,
    z_streamp ,
    int));

extern void inflate_codes_free OF((
    inflate_codes_statef *,
    z_streamp ));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\gzio.c ===
/* gzio.c -- IO on .gz files
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 *
 * Compile this file with -DNO_DEFLATE to avoid the compression code.
 */

/* @(#) $Id$ */

#include <stdio.h>

#include "zutil.h"

struct internal_state {int dummy;}; /* for buggy compilers */

#ifndef Z_BUFSIZE
#  ifdef MAXSEG_64K
#    define Z_BUFSIZE 4096 /* minimize memory usage for 16-bit DOS */
#  else
#    define Z_BUFSIZE 16384
#  endif
#endif
#ifndef Z_PRINTF_BUFSIZE
#  define Z_PRINTF_BUFSIZE 4096
#endif

#define ALLOC(size) malloc(size)
#define TRYFREE(p) {if (p) free(p);}

static const int gz_magic[2] = {0x1f, 0x8b}; /* gzip magic header */

/* gzip flag byte */
#define ASCII_FLAG   0x01 /* bit 0 set: file probably ascii text */
#define HEAD_CRC     0x02 /* bit 1 set: header CRC present */
#define EXTRA_FIELD  0x04 /* bit 2 set: extra field present */
#define ORIG_NAME    0x08 /* bit 3 set: original file name present */
#define COMMENT      0x10 /* bit 4 set: file comment present */
#define RESERVED     0xE0 /* bits 5..7: reserved */

typedef struct gz_stream {
    z_stream stream;
    int      z_err;   /* error code for last stream operation */
    int      z_eof;   /* set if end of input file */
    FILE     *file;   /* .gz file */
    Byte     *inbuf;  /* input buffer */
    Byte     *outbuf; /* output buffer */
    uLong    crc;     /* crc32 of uncompressed data */
    char     *msg;    /* error message */
    char     *path;   /* path name for debugging only */
    int      transparent; /* 1 if input file is not a .gz file */
    char     mode;    /* 'w' or 'r' */
    long     startpos; /* start of compressed data in file (header skipped) */
} gz_stream;


local gzFile gz_open      OF((const char *path, const char *mode, int  fd));
local int do_flush        OF((gzFile file, int flush));
local int    get_byte     OF((gz_stream *s));
local void   check_header OF((gz_stream *s));
local int    destroy      OF((gz_stream *s));
local void   putLong      OF((FILE *file, uLong x));
local uLong  getLong      OF((gz_stream *s));

/* ===========================================================================
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb"). The file is given either by file descriptor
   or path name (if fd == -1).
     gz_open return NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).
*/
local gzFile gz_open (path, mode, fd)
    const char *path;
    const char *mode;
    int  fd;
{
    int err;
    int level = Z_DEFAULT_COMPRESSION; /* compression level */
    int strategy = Z_DEFAULT_STRATEGY; /* compression strategy */
    char *p = (char*)mode;
    gz_stream *s;
    char fmode[80]; /* copy of mode, without the compression level */
    char *m = fmode;

    if (!path || !mode) return Z_NULL;

    s = (gz_stream *)ALLOC(sizeof(gz_stream));
    if (!s) return Z_NULL;

    s->stream.zalloc = (alloc_func)0;
    s->stream.zfree = (free_func)0;
    s->stream.opaque = (voidpf)0;
    s->stream.next_in = s->inbuf = Z_NULL;
    s->stream.next_out = s->outbuf = Z_NULL;
    s->stream.avail_in = s->stream.avail_out = 0;
    s->file = NULL;
    s->z_err = Z_OK;
    s->z_eof = 0;
    s->crc = crc32(0L, Z_NULL, 0);
    s->msg = NULL;
    s->transparent = 0;

    s->path = (char*)ALLOC(strlen(path)+1);
    if (s->path == NULL) {
        return destroy(s), (gzFile)Z_NULL;
    }
    strcpy(s->path, path); /* do this early for debugging */

    s->mode = '\0';
    do {
        if (*p == 'r') s->mode = 'r';
        if (*p == 'w' || *p == 'a') s->mode = 'w';
        if (*p >= '0' && *p <= '9') {
	    level = *p - '0';
	} else if (*p == 'f') {
	  strategy = Z_FILTERED;
	} else if (*p == 'h') {
	  strategy = Z_HUFFMAN_ONLY;
	} else {
	    *m++ = *p; /* copy the mode */
	}
    } while (*p++ && m != fmode + sizeof(fmode));
    if (s->mode == '\0') return destroy(s), (gzFile)Z_NULL;
    
    if (s->mode == 'w') {
#ifdef NO_DEFLATE
        err = Z_STREAM_ERROR;
#else
        err = deflateInit2(&(s->stream), level,
                           Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, strategy);
        /* windowBits is passed < 0 to suppress zlib header */

        s->stream.next_out = s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
#endif
        if (err != Z_OK || s->outbuf == Z_NULL) {
            return destroy(s), (gzFile)Z_NULL;
        }
    } else {
        s->stream.next_in  = s->inbuf = (Byte*)ALLOC(Z_BUFSIZE);

        err = inflateInit2(&(s->stream), -MAX_WBITS);
        /* windowBits is passed < 0 to tell that there is no zlib header.
         * Note that in this case inflate *requires* an extra "dummy" byte
         * after the compressed stream in order to complete decompression and
         * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are
         * present after the compressed stream.
         */
        if (err != Z_OK || s->inbuf == Z_NULL) {
            return destroy(s), (gzFile)Z_NULL;
        }
    }
    s->stream.avail_out = Z_BUFSIZE;

    errno = 0;
    s->file = fd < 0 ? F_OPEN(path, fmode) : (FILE*)fdopen(fd, fmode);

    if (s->file == NULL) {
        return destroy(s), (gzFile)Z_NULL;
    }
    if (s->mode == 'w') {
        /* Write a very simple .gz header:
         */
        fprintf(s->file, "%c%c%c%c%c%c%c%c%c%c", gz_magic[0], gz_magic[1],
             Z_DEFLATED, 0 /*flags*/, 0,0,0,0 /*time*/, 0 /*xflags*/, OS_CODE);
	s->startpos = 10L;
	/* We use 10L instead of ftell(s->file) to because ftell causes an
         * fflush on some systems. This version of the library doesn't use
         * startpos anyway in write mode, so this initialization is not
         * necessary.
         */
    } else {
	check_header(s); /* skip the .gz header */
	s->startpos = (ftell(s->file) - s->stream.avail_in);
    }
    
    return (gzFile)s;
}

/* ===========================================================================
     Opens a gzip (.gz) file for reading or writing.
*/
gzFile ZEXPORT gzopen (path, mode)
    const char *path;
    const char *mode;
{
    return gz_open (path, mode, -1);
}

/* ===========================================================================
     Associate a gzFile with the file descriptor fd. fd is not dup'ed here
   to mimic the behavio(u)r of fdopen.
*/
gzFile ZEXPORT gzdopen (fd, mode)
    int fd;
    const char *mode;
{
    char name[20];

    if (fd < 0) return (gzFile)Z_NULL;
    sprintf(name, "<fd:%d>", fd); /* for debugging */

    return gz_open (name, mode, fd);
}

/* ===========================================================================
 * Update the compression level and strategy
 */
int ZEXPORT gzsetparams (file, level, strategy)
    gzFile file;
    int level;
    int strategy;
{
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

    /* Make room to allow flushing */
    if (s->stream.avail_out == 0) {

	s->stream.next_out = s->outbuf;
	if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {
	    s->z_err = Z_ERRNO;
	}
	s->stream.avail_out = Z_BUFSIZE;
    }

    return deflateParams (&(s->stream), level, strategy);
}

/* ===========================================================================
     Read a byte from a gz_stream; update next_in and avail_in. Return EOF
   for end of file.
   IN assertion: the stream s has been sucessfully opened for reading.
*/
local int get_byte(s)
    gz_stream *s;
{
    if (s->z_eof) return EOF;
    if (s->stream.avail_in == 0) {
	errno = 0;
	s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);
	if (s->stream.avail_in == 0) {
	    s->z_eof = 1;
	    if (ferror(s->file)) s->z_err = Z_ERRNO;
	    return EOF;
	}
	s->stream.next_in = s->inbuf;
    }
    s->stream.avail_in--;
    return *(s->stream.next_in)++;
}

/* ===========================================================================
      Check the gzip header of a gz_stream opened for reading. Set the stream
    mode to transparent if the gzip magic header is not present; set s->err
    to Z_DATA_ERROR if the magic header is present but the rest of the header
    is incorrect.
    IN assertion: the stream s has already been created sucessfully;
       s->stream.avail_in is zero for the first time, but may be non-zero
       for concatenated .gz files.
*/
local void check_header(s)
    gz_stream *s;
{
    int method; /* method byte */
    int flags;  /* flags byte */
    uInt len;
    int c;

    /* Check the gzip magic header */
    for (len = 0; len < 2; len++) {
	c = get_byte(s);
	if (c != gz_magic[len]) {
	    if (len != 0) s->stream.avail_in++, s->stream.next_in--;
	    if (c != EOF) {
		s->stream.avail_in++, s->stream.next_in--;
		s->transparent = 1;
	    }
	    s->z_err = s->stream.avail_in != 0 ? Z_OK : Z_STREAM_END;
	    return;
	}
    }
    method = get_byte(s);
    flags = get_byte(s);
    if (method != Z_DEFLATED || (flags & RESERVED) != 0) {
	s->z_err = Z_DATA_ERROR;
	return;
    }

    /* Discard time, xflags and OS code: */
    for (len = 0; len < 6; len++) (void)get_byte(s);

    if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */
	len  =  (uInt)get_byte(s);
	len += ((uInt)get_byte(s))<<8;
	/* len is garbage if EOF but the loop below will quit anyway */
	while (len-- != 0 && get_byte(s) != EOF) ;
    }
    if ((flags & ORIG_NAME) != 0) { /* skip the original file name */
	while ((c = get_byte(s)) != 0 && c != EOF) ;
    }
    if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */
	while ((c = get_byte(s)) != 0 && c != EOF) ;
    }
    if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */
	for (len = 0; len < 2; len++) (void)get_byte(s);
    }
    s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;
}

 /* ===========================================================================
 * Cleanup then free the given gz_stream. Return a zlib error code.
   Try freeing in the reverse order of allocations.
 */
local int destroy (s)
    gz_stream *s;
{
    int err = Z_OK;

    if (!s) return Z_STREAM_ERROR;

    TRYFREE(s->msg);

    if (s->stream.state != NULL) {
	if (s->mode == 'w') {
#ifdef NO_DEFLATE
	    err = Z_STREAM_ERROR;
#else
	    err = deflateEnd(&(s->stream));
#endif
	} else if (s->mode == 'r') {
	    err = inflateEnd(&(s->stream));
	}
    }
    if (s->file != NULL && fclose(s->file)) {
#ifdef ESPIPE
	if (errno != ESPIPE) /* fclose is broken for pipes in HP/UX */
#endif
	    err = Z_ERRNO;
    }
    if (s->z_err < 0) err = s->z_err;

    TRYFREE(s->inbuf);
    TRYFREE(s->outbuf);
    TRYFREE(s->path);
    TRYFREE(s);
    return err;
}

/* ===========================================================================
     Reads the given number of uncompressed bytes from the compressed file.
   gzread returns the number of bytes actually read (0 for end of file).
*/
int ZEXPORT gzread (file, buf, len)
    gzFile file;
    voidp buf;
    unsigned len;
{
    gz_stream *s = (gz_stream*)file;
    Bytef *start = (Bytef*)buf; /* starting point for crc computation */
    Byte  *next_out; /* == stream.next_out but not forced far (for MSDOS) */

    if (s == NULL || s->mode != 'r') return Z_STREAM_ERROR;

    if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO) return -1;
    if (s->z_err == Z_STREAM_END) return 0;  /* EOF */

    next_out = (Byte*)buf;
    s->stream.next_out = (Bytef*)buf;
    s->stream.avail_out = len;

    while (s->stream.avail_out != 0) {

	if (s->transparent) {
	    /* Copy first the lookahead bytes: */
	    uInt n = s->stream.avail_in;
	    if (n > s->stream.avail_out) n = s->stream.avail_out;
	    if (n > 0) {
		zmemcpy(s->stream.next_out, s->stream.next_in, n);
		next_out += n;
		s->stream.next_out = next_out;
		s->stream.next_in   += n;
		s->stream.avail_out -= n;
		s->stream.avail_in  -= n;
	    }
	    if (s->stream.avail_out > 0) {
		s->stream.avail_out -= fread(next_out, 1, s->stream.avail_out,
					     s->file);
	    }
	    len -= s->stream.avail_out;
	    s->stream.total_in  += (uLong)len;
	    s->stream.total_out += (uLong)len;
            if (len == 0) s->z_eof = 1;
	    return (int)len;
	}
        if (s->stream.avail_in == 0 && !s->z_eof) {

            errno = 0;
            s->stream.avail_in = fread(s->inbuf, 1, Z_BUFSIZE, s->file);
            if (s->stream.avail_in == 0) {
                s->z_eof = 1;
		if (ferror(s->file)) {
		    s->z_err = Z_ERRNO;
		    break;
		}
            }
            s->stream.next_in = s->inbuf;
        }
        s->z_err = inflate(&(s->stream), Z_NO_FLUSH);

	if (s->z_err == Z_STREAM_END) {
	    /* Check CRC and original size */
	    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));
	    start = s->stream.next_out;

	    if (getLong(s) != s->crc) {
		s->z_err = Z_DATA_ERROR;
	    } else {
	        (void)getLong(s);
                /* The uncompressed length returned by above getlong() may
                 * be different from s->stream.total_out) in case of
		 * concatenated .gz files. Check for such files:
		 */
		check_header(s);
		if (s->z_err == Z_OK) {
		    uLong total_in = s->stream.total_in;
		    uLong total_out = s->stream.total_out;

		    inflateReset(&(s->stream));
		    s->stream.total_in = total_in;
		    s->stream.total_out = total_out;
		    s->crc = crc32(0L, Z_NULL, 0);
		}
	    }
	}
	if (s->z_err != Z_OK || s->z_eof) break;
    }
    s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));

    return (int)(len - s->stream.avail_out);
}


/* ===========================================================================
      Reads one byte from the compressed file. gzgetc returns this byte
   or -1 in case of end of file or error.
*/
int ZEXPORT gzgetc(file)
    gzFile file;
{
    unsigned char c;

    return gzread(file, &c, 1) == 1 ? c : -1;
}


/* ===========================================================================
      Reads bytes from the compressed file until len-1 characters are
   read, or a newline character is read and transferred to buf, or an
   end-of-file condition is encountered.  The string is then terminated
   with a null character.
      gzgets returns buf, or Z_NULL in case of error.

      The current implementation is not optimized at all.
*/
char * ZEXPORT gzgets(file, buf, len)
    gzFile file;
    char *buf;
    int len;
{
    char *b = buf;
    if (buf == Z_NULL || len <= 0) return Z_NULL;

    while (--len > 0 && gzread(file, buf, 1) == 1 && *buf++ != '\n') ;
    *buf = '\0';
    return b == buf && len > 0 ? Z_NULL : b;
}


#ifndef NO_DEFLATE
/* ===========================================================================
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of bytes actually written (0 in case of error).
*/
int ZEXPORT gzwrite (file, buf, len)
    gzFile file;
    const voidp buf;
    unsigned len;
{
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

    s->stream.next_in = (Bytef*)buf;
    s->stream.avail_in = len;

    while (s->stream.avail_in != 0) {

        if (s->stream.avail_out == 0) {

            s->stream.next_out = s->outbuf;
            if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {
                s->z_err = Z_ERRNO;
                break;
            }
            s->stream.avail_out = Z_BUFSIZE;
        }
        s->z_err = deflate(&(s->stream), Z_NO_FLUSH);
        if (s->z_err != Z_OK) break;
    }
    s->crc = crc32(s->crc, (const Bytef *)buf, len);

    return (int)(len - s->stream.avail_in);
}

/* ===========================================================================
     Converts, formats, and writes the args to the compressed file under
   control of the format string, as in fprintf. gzprintf returns the number of
   uncompressed bytes actually written (0 in case of error).
*/
#ifdef STDC
#include <stdarg.h>

int ZEXPORTVA gzprintf (gzFile file, const char *format, /* args */ ...)
{
    char buf[Z_PRINTF_BUFSIZE];
    va_list va;
    int len;

    va_start(va, format);
#ifdef HAS_vsnprintf
    (void)vsnprintf(buf, sizeof(buf), format, va);
#else
    (void)vsprintf(buf, format, va);
#endif
    va_end(va);
    len = strlen(buf); /* some *sprintf don't return the nb of bytes written */
    if (len <= 0) return 0;

    return gzwrite(file, buf, (unsigned)len);
}
#else /* not ANSI C */

int ZEXPORTVA gzprintf (file, format, a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
	               a11, a12, a13, a14, a15, a16, a17, a18, a19, a20)
    gzFile file;
    const char *format;
    int a1, a2, a3, a4, a5, a6, a7, a8, a9, a10,
	a11, a12, a13, a14, a15, a16, a17, a18, a19, a20;
{
    char buf[Z_PRINTF_BUFSIZE];
    int len;

#ifdef HAS_snprintf
    snprintf(buf, sizeof(buf), format, a1, a2, a3, a4, a5, a6, a7, a8,
	     a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
#else
    sprintf(buf, format, a1, a2, a3, a4, a5, a6, a7, a8,
	    a9, a10, a11, a12, a13, a14, a15, a16, a17, a18, a19, a20);
#endif
    len = strlen(buf); /* old sprintf doesn't return the nb of bytes written */
    if (len <= 0) return 0;

    return gzwrite(file, buf, len);
}
#endif

/* ===========================================================================
      Writes c, converted to an unsigned char, into the compressed file.
   gzputc returns the value that was written, or -1 in case of error.
*/
int ZEXPORT gzputc(file, c)
    gzFile file;
    int c;
{
    unsigned char cc = (unsigned char) c; /* required for big endian systems */

    return gzwrite(file, &cc, 1) == 1 ? (int)cc : -1;
}


/* ===========================================================================
      Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.
      gzputs returns the number of characters written, or -1 in case of error.
*/
int ZEXPORT gzputs(file, s)
    gzFile file;
    const char *s;
{
    return gzwrite(file, (char*)s, (unsigned)strlen(s));
}


/* ===========================================================================
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function.
*/
local int do_flush (file, flush)
    gzFile file;
    int flush;
{
    uInt len;
    int done = 0;
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

    s->stream.avail_in = 0; /* should be zero already anyway */

    for (;;) {
        len = Z_BUFSIZE - s->stream.avail_out;

        if (len != 0) {
            if ((uInt)fwrite(s->outbuf, 1, len, s->file) != len) {
                s->z_err = Z_ERRNO;
                return Z_ERRNO;
            }
            s->stream.next_out = s->outbuf;
            s->stream.avail_out = Z_BUFSIZE;
        }
        if (done) break;
        s->z_err = deflate(&(s->stream), flush);

	/* Ignore the second of two consecutive flushes: */
	if (len == 0 && s->z_err == Z_BUF_ERROR) s->z_err = Z_OK;

        /* deflate has finished flushing only when it hasn't used up
         * all the available space in the output buffer: 
         */
        done = (s->stream.avail_out != 0 || s->z_err == Z_STREAM_END);
 
        if (s->z_err != Z_OK && s->z_err != Z_STREAM_END) break;
    }
    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
}

int ZEXPORT gzflush (file, flush)
     gzFile file;
     int flush;
{
    gz_stream *s = (gz_stream*)file;
    int err = do_flush (file, flush);

    if (err) return err;
    fflush(s->file);
    return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;
}
#endif /* NO_DEFLATE */

/* ===========================================================================
      Sets the starting position for the next gzread or gzwrite on the given
   compressed file. The offset represents a number of bytes in the
      gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error.
      SEEK_END is not implemented, returns error.
      In this version of the library, gzseek can be extremely slow.
*/
z_off_t ZEXPORT gzseek (file, offset, whence)
    gzFile file;
    z_off_t offset;
    int whence;
{
    gz_stream *s = (gz_stream*)file;

    if (s == NULL || whence == SEEK_END ||
	s->z_err == Z_ERRNO || s->z_err == Z_DATA_ERROR) {
	return -1L;
    }
    
    if (s->mode == 'w') {
#ifdef NO_DEFLATE
	return -1L;
#else
	if (whence == SEEK_SET) {
	    offset -= s->stream.total_in;
	}
	if (offset < 0) return -1L;

	/* At this point, offset is the number of zero bytes to write. */
	if (s->inbuf == Z_NULL) {
	    s->inbuf = (Byte*)ALLOC(Z_BUFSIZE); /* for seeking */
	    zmemzero(s->inbuf, Z_BUFSIZE);
	}
	while (offset > 0)  {
	    uInt size = Z_BUFSIZE;
	    if (offset < Z_BUFSIZE) size = (uInt)offset;

	    size = gzwrite(file, s->inbuf, size);
	    if (size == 0) return -1L;

	    offset -= size;
	}
	return (z_off_t)s->stream.total_in;
#endif
    }
    /* Rest of function is for reading only */

    /* compute absolute position */
    if (whence == SEEK_CUR) {
	offset += s->stream.total_out;
    }
    if (offset < 0) return -1L;

    if (s->transparent) {
	/* map to fseek */
	s->stream.avail_in = 0;
	s->stream.next_in = s->inbuf;
        if (fseek(s->file, offset, SEEK_SET) < 0) return -1L;

	s->stream.total_in = s->stream.total_out = (uLong)offset;
	return offset;
    }

    /* For a negative seek, rewind and use positive seek */
    if ((uLong)offset >= s->stream.total_out) {
	offset -= s->stream.total_out;
    } else if (gzrewind(file) < 0) {
	return -1L;
    }
    /* offset is now the number of bytes to skip. */

    if (offset != 0 && s->outbuf == Z_NULL) {
	s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);
    }
    while (offset > 0)  {
	int size = Z_BUFSIZE;
	if (offset < Z_BUFSIZE) size = (int)offset;

	size = gzread(file, s->outbuf, (uInt)size);
	if (size <= 0) return -1L;
	offset -= size;
    }
    return (z_off_t)s->stream.total_out;
}

/* ===========================================================================
     Rewinds input file. 
*/
int ZEXPORT gzrewind (file)
    gzFile file;
{
    gz_stream *s = (gz_stream*)file;
    
    if (s == NULL || s->mode != 'r') return -1;

    s->z_err = Z_OK;
    s->z_eof = 0;
    s->stream.avail_in = 0;
    s->stream.next_in = s->inbuf;
    s->crc = crc32(0L, Z_NULL, 0);
	
    if (s->startpos == 0) { /* not a compressed file */
	rewind(s->file);
	return 0;
    }

    (void) inflateReset(&s->stream);
    return fseek(s->file, s->startpos, SEEK_SET);
}

/* ===========================================================================
     Returns the starting position for the next gzread or gzwrite on the
   given compressed file. This position represents a number of bytes in the
   uncompressed data stream.
*/
z_off_t ZEXPORT gztell (file)
    gzFile file;
{
    return gzseek(file, 0L, SEEK_CUR);
}

/* ===========================================================================
     Returns 1 when EOF has previously been detected reading the given
   input stream, otherwise zero.
*/
int ZEXPORT gzeof (file)
    gzFile file;
{
    gz_stream *s = (gz_stream*)file;
    
    return (s == NULL || s->mode != 'r') ? 0 : s->z_eof;
}

/* ===========================================================================
   Outputs a long in LSB order to the given file
*/
local void putLong (file, x)
    FILE *file;
    uLong x;
{
    int n;
    for (n = 0; n < 4; n++) {
        fputc((int)(x & 0xff), file);
        x >>= 8;
    }
}

/* ===========================================================================
   Reads a long in LSB order from the given gz_stream. Sets z_err in case
   of error.
*/
local uLong getLong (s)
    gz_stream *s;
{
    uLong x = (uLong)get_byte(s);
    int c;

    x += ((uLong)get_byte(s))<<8;
    x += ((uLong)get_byte(s))<<16;
    c = get_byte(s);
    if (c == EOF) s->z_err = Z_DATA_ERROR;
    x += ((uLong)c)<<24;
    return x;
}

/* ===========================================================================
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state.
*/
int ZEXPORT gzclose (file)
    gzFile file;
{
    int err;
    gz_stream *s = (gz_stream*)file;

    if (s == NULL) return Z_STREAM_ERROR;

    if (s->mode == 'w') {
#ifdef NO_DEFLATE
	return Z_STREAM_ERROR;
#else
        err = do_flush (file, Z_FINISH);
        if (err != Z_OK) return destroy((gz_stream*)file);

        putLong (s->file, s->crc);
        putLong (s->file, s->stream.total_in);
#endif
    }
    return destroy((gz_stream*)file);
}

/* ===========================================================================
     Returns the error message for the last error which occured on the
   given compressed file. errnum is set to zlib error number. If an
   error occured in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/
const char*  ZEXPORT gzerror (file, errnum)
    gzFile file;
    int *errnum;
{
    char *m;
    gz_stream *s = (gz_stream*)file;

    if (s == NULL) {
        *errnum = Z_STREAM_ERROR;
        return (const char*)ERR_MSG(Z_STREAM_ERROR);
    }
    *errnum = s->z_err;
    if (*errnum == Z_OK) return (const char*)"";

    m =  (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);

    if (m == NULL || *m == '\0') m = (char*)ERR_MSG(s->z_err);

    TRYFREE(s->msg);
    s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3);
    strcpy(s->msg, s->path);
    strcat(s->msg, ": ");
    strcat(s->msg, m);
    return (const char*)s->msg;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\infcodes.c ===
/* infcodes.c -- process literals and length/distance pairs
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "inftrees.h"
#include "infblock.h"
#include "infcodes.h"
#include "infutil.h"
#include "inffast.h"

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits

typedef enum {        /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
      START,    /* x: set up for LEN */
      LEN,      /* i: get length/literal/eob next */
      LENEXT,   /* i: getting length extra (have base) */
      DIST,     /* i: get distance next */
      DISTEXT,  /* i: getting distance extra */
      COPY,     /* o: copying bytes in window, waiting for space */
      LIT,      /* o: got literal, waiting for output space */
      WASH,     /* o: got eob, possibly still output waiting */
      END,      /* x: got eob and all data flushed */
      BADCODE}  /* x: got error */
inflate_codes_mode;

/* inflate codes private state */
struct inflate_codes_state {

  /* mode */
  inflate_codes_mode mode;      /* current inflate_codes mode */

  /* mode dependent information */
  uInt len;
  union {
    struct {
      inflate_huft *tree;       /* pointer into tree */
      uInt need;                /* bits needed */
    } code;             /* if LEN or DIST, where in tree */
    uInt lit;           /* if LIT, literal */
    struct {
      uInt get;                 /* bits to get for extra */
      uInt dist;                /* distance back to copy from */
    } copy;             /* if EXT or COPY, where and how much */
  } sub;                /* submode */

  /* mode independent information */
  Byte lbits;           /* ltree bits decoded per branch */
  Byte dbits;           /* dtree bits decoder per branch */
  inflate_huft *ltree;          /* literal/length/eob tree */
  inflate_huft *dtree;          /* distance tree */

};


inflate_codes_statef *inflate_codes_new(bl, bd, tl, td, z)
uInt bl, bd;
inflate_huft *tl;
inflate_huft *td; /* need separate declaration for Borland C++ */
z_streamp z;
{
  inflate_codes_statef *c;

  if ((c = (inflate_codes_statef *)
       ZALLOC(z,1,sizeof(struct inflate_codes_state))) != Z_NULL)
  {
    c->mode = START;
    c->lbits = (Byte)bl;
    c->dbits = (Byte)bd;
    c->ltree = tl;
    c->dtree = td;
    Tracev((stderr, "inflate:       codes new\n"));
  }
  return c;
}


int inflate_codes(s, z, r)
inflate_blocks_statef *s;
z_streamp z;
int r;
{
  uInt j;               /* temporary storage */
  inflate_huft *t;      /* temporary pointer */
  uInt e;               /* extra bits or operation */
  uLong b;              /* bit buffer */
  uInt k;               /* bits in bit buffer */
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */
  Bytef *f;             /* pointer to copy strings from */
  inflate_codes_statef *c = s->sub.decode.codes;  /* codes state */

  /* copy input/output information to locals (UPDATE macro restores) */
  LOAD

  /* process input and output based on current state */
  while (1) switch (c->mode)
  {             /* waiting for "i:"=input, "o:"=output, "x:"=nothing */
    case START:         /* x: set up for LEN */
#ifndef SLOW
      if (m >= 258 && n >= 10)
      {
        UPDATE
        r = inflate_fast(c->lbits, c->dbits, c->ltree, c->dtree, s, z);
        LOAD
        if (r != Z_OK)
        {
          c->mode = r == Z_STREAM_END ? WASH : BADCODE;
          break;
        }
      }
#endif /* !SLOW */
      c->sub.code.need = c->lbits;
      c->sub.code.tree = c->ltree;
      c->mode = LEN;
    case LEN:           /* i: get length/literal/eob next */
      j = c->sub.code.need;
      NEEDBITS(j)
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
      DUMPBITS(t->bits)
      e = (uInt)(t->exop);
      if (e == 0)               /* literal */
      {
        c->sub.lit = t->base;
        Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
                 "inflate:         literal '%c'\n" :
                 "inflate:         literal 0x%02x\n", t->base));
        c->mode = LIT;
        break;
      }
      if (e & 16)               /* length */
      {
        c->sub.copy.get = e & 15;
        c->len = t->base;
        c->mode = LENEXT;
        break;
      }
      if ((e & 64) == 0)        /* next table */
      {
        c->sub.code.need = e;
        c->sub.code.tree = t + t->base;
        break;
      }
      if (e & 32)               /* end of block */
      {
        Tracevv((stderr, "inflate:         end of block\n"));
        c->mode = WASH;
        break;
      }
      c->mode = BADCODE;        /* invalid code */
      z->msg = (char*)"invalid literal/length code";
      r = Z_DATA_ERROR;
      LEAVE
    case LENEXT:        /* i: getting length extra (have base) */
      j = c->sub.copy.get;
      NEEDBITS(j)
      c->len += (uInt)b & inflate_mask[j];
      DUMPBITS(j)
      c->sub.code.need = c->dbits;
      c->sub.code.tree = c->dtree;
      Tracevv((stderr, "inflate:         length %u\n", c->len));
      c->mode = DIST;
    case DIST:          /* i: get distance next */
      j = c->sub.code.need;
      NEEDBITS(j)
      t = c->sub.code.tree + ((uInt)b & inflate_mask[j]);
      DUMPBITS(t->bits)
      e = (uInt)(t->exop);
      if (e & 16)               /* distance */
      {
        c->sub.copy.get = e & 15;
        c->sub.copy.dist = t->base;
        c->mode = DISTEXT;
        break;
      }
      if ((e & 64) == 0)        /* next table */
      {
        c->sub.code.need = e;
        c->sub.code.tree = t + t->base;
        break;
      }
      c->mode = BADCODE;        /* invalid code */
      z->msg = (char*)"invalid distance code";
      r = Z_DATA_ERROR;
      LEAVE
    case DISTEXT:       /* i: getting distance extra */
      j = c->sub.copy.get;
      NEEDBITS(j)
      c->sub.copy.dist += (uInt)b & inflate_mask[j];
      DUMPBITS(j)
      Tracevv((stderr, "inflate:         distance %u\n", c->sub.copy.dist));
      c->mode = COPY;
    case COPY:          /* o: copying bytes in window, waiting for space */
      f = q - c->sub.copy.dist;
      while (f < s->window)             /* modulo window size-"while" instead */
        f += s->end - s->window;        /* of "if" handles invalid distances */
      while (c->len)
      {
        NEEDOUT
        OUTBYTE(*f++)
        if (f == s->end)
          f = s->window;
        c->len--;
      }
      c->mode = START;
      break;
    case LIT:           /* o: got literal, waiting for output space */
      NEEDOUT
      OUTBYTE(c->sub.lit)
      c->mode = START;
      break;
    case WASH:          /* o: got eob, possibly more output */
      if (k > 7)        /* return unused byte, if any */
      {
        Assert(k < 16, "inflate_codes grabbed too many bytes")
        k -= 8;
        n++;
        p--;            /* can always return one */
      }
      FLUSH
      if (s->read != s->write)
        LEAVE
      c->mode = END;
    case END:
      r = Z_STREAM_END;
      LEAVE
    case BADCODE:       /* x: got error */
      r = Z_DATA_ERROR;
      LEAVE
    default:
      r = Z_STREAM_ERROR;
      LEAVE
  }
#ifdef NEED_DUMMY_RETURN
  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
#endif
}


void inflate_codes_free(c, z)
inflate_codes_statef *c;
z_streamp z;
{
  ZFREE(z, c);
  Tracev((stderr, "inflate:       codes free\n"));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\inffast.h ===
/* inffast.h -- header to use inffast.c
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

extern int inflate_fast OF((
    uInt,
    uInt,
    inflate_huft *,
    inflate_huft *,
    inflate_blocks_statef *,
    z_streamp ));
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\inffast.c ===
/* inffast.c -- process literals and length/distance pairs fast
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "inftrees.h"
#include "infblock.h"
#include "infcodes.h"
#include "infutil.h"
#include "inffast.h"

struct inflate_codes_state {int dummy;}; /* for buggy compilers */

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits

/* macros for bit input with no checking and for returning unused bytes */
#define GRABBITS(j) {while(k<(j)){b|=((uLong)NEXTBYTE)<<k;k+=8;}}
#define UNGRAB {c=z->avail_in-n;c=(k>>3)<c?k>>3:c;n+=c;p-=c;k-=c<<3;}

/* Called with number of bytes left to write in window at least 258
   (the maximum string length) and number of input bytes available
   at least ten.  The ten bytes are six bytes for the longest length/
   distance pair plus four bytes for overloading the bit buffer. */

int inflate_fast(bl, bd, tl, td, s, z)
uInt bl, bd;
inflate_huft *tl;
inflate_huft *td; /* need separate declaration for Borland C++ */
inflate_blocks_statef *s;
z_streamp z;
{
  inflate_huft *t;      /* temporary pointer */
  uInt e;               /* extra bits or operation */
  uLong b;              /* bit buffer */
  uInt k;               /* bits in bit buffer */
  Bytef *p;             /* input data pointer */
  uInt n;               /* bytes available there */
  Bytef *q;             /* output window write pointer */
  uInt m;               /* bytes to end of window or read pointer */
  uInt ml;              /* mask for literal/length tree */
  uInt md;              /* mask for distance tree */
  uInt c;               /* bytes to copy */
  uInt d;               /* distance back to copy from */
  Bytef *r;             /* copy source pointer */

  /* load input, output, bit values */
  LOAD

  /* initialize masks */
  ml = inflate_mask[bl];
  md = inflate_mask[bd];

  /* do until not enough input or output space for fast loop */
  do {                          /* assume called with m >= 258 && n >= 10 */
    /* get literal/length code */
    GRABBITS(20)                /* max bits for literal/length code */
    if ((e = (t = tl + ((uInt)b & ml))->exop) == 0)
    {
      DUMPBITS(t->bits)
      Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
                "inflate:         * literal '%c'\n" :
                "inflate:         * literal 0x%02x\n", t->base));
      *q++ = (Byte)t->base;
      m--;
      continue;
    }
    do {
      DUMPBITS(t->bits)
      if (e & 16)
      {
        /* get extra bits for length */
        e &= 15;
        c = t->base + ((uInt)b & inflate_mask[e]);
        DUMPBITS(e)
        Tracevv((stderr, "inflate:         * length %u\n", c));

        /* decode distance base of block to copy */
        GRABBITS(15);           /* max bits for distance code */
        e = (t = td + ((uInt)b & md))->exop;
        do {
          DUMPBITS(t->bits)
          if (e & 16)
          {
            /* get extra bits to add to distance base */
            e &= 15;
            GRABBITS(e)         /* get extra bits (up to 13) */
            d = t->base + ((uInt)b & inflate_mask[e]);
            DUMPBITS(e)
            Tracevv((stderr, "inflate:         * distance %u\n", d));

            /* do the copy */
            m -= c;
            r = q - d;
            if (r < s->window)                  /* wrap if needed */
            {
              do {
                r += s->end - s->window;        /* force pointer in window */
              } while (r < s->window);          /* covers invalid distances */
              e = (uInt)(s->end - r);
              if (c > e)
              {
                c -= e;                         /* wrapped copy */
                do {
                    *q++ = *r++;
                } while (--e);
                r = s->window;
                do {
                    *q++ = *r++;
                } while (--c);
              }
              else                              /* normal copy */
              {
                *q++ = *r++;  c--;
                *q++ = *r++;  c--;
                do {
                    *q++ = *r++;
                } while (--c);
              }
            }
            else                                /* normal copy */
            {
              *q++ = *r++;  c--;
              *q++ = *r++;  c--;
              do {
                *q++ = *r++;
              } while (--c);
            }
            break;
          }
          else if ((e & 64) == 0)
          {
            t += t->base;
            e = (t += ((uInt)b & inflate_mask[e]))->exop;
          }
          else
          {
            z->msg = (char*)"invalid distance code";
            UNGRAB
            UPDATE
            return Z_DATA_ERROR;
          }
        } while (1);
        break;
      }
      if ((e & 64) == 0)
      {
        t += t->base;
        if ((e = (t += ((uInt)b & inflate_mask[e]))->exop) == 0)
        {
          DUMPBITS(t->bits)
          Tracevv((stderr, t->base >= 0x20 && t->base < 0x7f ?
                    "inflate:         * literal '%c'\n" :
                    "inflate:         * literal 0x%02x\n", t->base));
          *q++ = (Byte)t->base;
          m--;
          break;
        }
      }
      else if (e & 32)
      {
        Tracevv((stderr, "inflate:         * end of block\n"));
        UNGRAB
        UPDATE
        return Z_STREAM_END;
      }
      else
      {
        z->msg = (char*)"invalid literal/length code";
        UNGRAB
        UPDATE
        return Z_DATA_ERROR;
      }
    } while (1);
  } while (m >= 258 && n >= 10);

  /* not enough input or output--restore pointers and return */
  UNGRAB
  UPDATE
  return Z_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\infutil.c ===
/* inflate_util.c -- data and routines common to blocks and codes
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "infblock.h"
#include "inftrees.h"
#include "infcodes.h"
#include "infutil.h"

struct inflate_codes_state {int dummy;}; /* for buggy compilers */

/* And'ing with mask[n] masks the lower n bits */
uInt const inflate_mask[17] = {
    0x0000,
    0x0001, 0x0003, 0x0007, 0x000f, 0x001f, 0x003f, 0x007f, 0x00ff,
    0x01ff, 0x03ff, 0x07ff, 0x0fff, 0x1fff, 0x3fff, 0x7fff, 0xffff
};


/* copy as much as possible from the sliding window to the output area */
int inflate_flush(s, z, r)
inflate_blocks_statef *s;
z_streamp z;
int r;
{
  uInt n;
  Bytef *p;
  Bytef *q;

  /* local copies of source and destination pointers */
  p = z->next_out;
  q = s->read;

  /* compute number of bytes to copy as far as end of window */
  n = (uInt)((q <= s->write ? s->write : s->end) - q);
  if (n > z->avail_out) n = z->avail_out;
  if (n && r == Z_BUF_ERROR) r = Z_OK;

  /* update counters */
  z->avail_out -= n;
  z->total_out += n;

  /* update check information */
  if (s->checkfn != Z_NULL)
    z->adler = s->check = (*s->checkfn)(s->check, q, n);

  /* copy as far as end of window */
  zmemcpy(p, q, n);
  p += n;
  q += n;

  /* see if more to copy at beginning of window */
  if (q == s->end)
  {
    /* wrap pointers */
    q = s->window;
    if (s->write == s->end)
      s->write = s->window;

    /* compute bytes to copy */
    n = (uInt)(s->write - q);
    if (n > z->avail_out) n = z->avail_out;
    if (n && r == Z_BUF_ERROR) r = Z_OK;

    /* update counters */
    z->avail_out -= n;
    z->total_out += n;

    /* update check information */
    if (s->checkfn != Z_NULL)
      z->adler = s->check = (*s->checkfn)(s->check, q, n);

    /* copy */
    zmemcpy(p, q, n);
    p += n;
    q += n;
  }

  /* update pointers */
  z->next_out = p;
  s->read = q;

  /* done */
  return r;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\inftrees.h ===
/* inftrees.h -- header to use inftrees.c
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* Huffman code lookup table entry--this entry is four bytes for machines
   that have 16-bit pointers (e.g. PC's in the small or medium model). */

typedef struct inflate_huft_s FAR inflate_huft;

struct inflate_huft_s {
  union {
    struct {
      Byte Exop;        /* number of extra bits or operation */
      Byte Bits;        /* number of bits in this code or subcode */
    } what;
    uInt pad;           /* pad structure to a power of 2 (4 bytes for */
  } word;               /*  16-bit, 8 bytes for 32-bit int's) */
  uInt base;            /* literal, length base, distance base,
                           or table offset */
};

/* Maximum size of dynamic tree.  The maximum found in a long but non-
   exhaustive search was 1004 huft structures (850 for length/literals
   and 154 for distances, the latter actually the result of an
   exhaustive search).  The actual maximum is not known, but the
   value below is more than safe. */
#define MANY 1440

extern int inflate_trees_bits OF((
    uIntf *,                    /* 19 code lengths */
    uIntf *,                    /* bits tree desired/actual depth */
    inflate_huft * FAR *,       /* bits tree result */
    inflate_huft *,             /* space for trees */
    z_streamp));                /* for messages */

extern int inflate_trees_dynamic OF((
    uInt,                       /* number of literal/length codes */
    uInt,                       /* number of distance codes */
    uIntf *,                    /* that many (total) code lengths */
    uIntf *,                    /* literal desired/actual bit depth */
    uIntf *,                    /* distance desired/actual bit depth */
    inflate_huft * FAR *,       /* literal/length tree result */
    inflate_huft * FAR *,       /* distance tree result */
    inflate_huft *,             /* space for trees */
    z_streamp));                /* for messages */

extern int inflate_trees_fixed OF((
    uIntf *,                    /* literal desired/actual bit depth */
    uIntf *,                    /* distance desired/actual bit depth */
    const inflate_huft * FAR *,       /* literal/length tree result */
    const inflate_huft * FAR *,       /* distance tree result */
    z_streamp));                /* for memory allocation */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\inflate.c ===
/* inflate.c -- zlib interface to inflate modules
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "infblock.h"

struct inflate_blocks_state {int dummy;}; /* for buggy compilers */

typedef enum {
      METHOD,   /* waiting for method byte */
      FLAG,     /* waiting for flag byte */
      DICT4,    /* four dictionary check bytes to go */
      DICT3,    /* three dictionary check bytes to go */
      DICT2,    /* two dictionary check bytes to go */
      DICT1,    /* one dictionary check byte to go */
      DICT0,    /* waiting for inflateSetDictionary */
      BLOCKS,   /* decompressing blocks */
      CHECK4,   /* four check bytes to go */
      CHECK3,   /* three check bytes to go */
      CHECK2,   /* two check bytes to go */
      CHECK1,   /* one check byte to go */
      DONE,     /* finished check, done */
      BAD}      /* got an error--stay here */
inflate_mode;

/* inflate private state */
struct internal_state {

  /* mode */
  inflate_mode  mode;   /* current inflate mode */

  /* mode dependent information */
  union {
    uInt method;        /* if FLAGS, method byte */
    struct {
      uLong was;                /* computed check value */
      uLong need;               /* stream check value */
    } check;            /* if CHECK, check values to compare */
    uInt marker;        /* if BAD, inflateSync's marker bytes count */
  } sub;        /* submode */

  /* mode independent information */
  int  nowrap;          /* flag for no wrapper */
  uInt wbits;           /* log2(window size)  (8..15, defaults to 15) */
  inflate_blocks_statef 
    *blocks;            /* current inflate_blocks state */

};


int ZEXPORT inflateReset(z)
z_streamp z;
{
  if (z == Z_NULL || z->state == Z_NULL)
    return Z_STREAM_ERROR;
  z->total_in = z->total_out = 0;
  z->msg = Z_NULL;
  z->state->mode = z->state->nowrap ? BLOCKS : METHOD;
  inflate_blocks_reset(z->state->blocks, z, Z_NULL);
  Tracev((stderr, "inflate: reset\n"));
  return Z_OK;
}


int ZEXPORT inflateEnd(z)
z_streamp z;
{
  if (z == Z_NULL || z->state == Z_NULL || z->zfree == Z_NULL)
    return Z_STREAM_ERROR;
  if (z->state->blocks != Z_NULL)
    inflate_blocks_free(z->state->blocks, z);
  ZFREE(z, z->state);
  z->state = Z_NULL;
  Tracev((stderr, "inflate: end\n"));
  return Z_OK;
}


int ZEXPORT inflateInit2_(z, w, version, stream_size)
z_streamp z;
int w;
const char *version;
int stream_size;
{
  if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
      stream_size != sizeof(z_stream))
      return Z_VERSION_ERROR;

  /* initialize state */
  if (z == Z_NULL)
    return Z_STREAM_ERROR;
  z->msg = Z_NULL;
  if (z->zalloc == Z_NULL)
  {
    z->zalloc = zcalloc;
    z->opaque = (voidpf)0;
  }
  if (z->zfree == Z_NULL) z->zfree = zcfree;
  if ((z->state = (struct internal_state FAR *)
       ZALLOC(z,1,sizeof(struct internal_state))) == Z_NULL)
    return Z_MEM_ERROR;
  z->state->blocks = Z_NULL;

  /* handle undocumented nowrap option (no zlib header or check) */
  z->state->nowrap = 0;
  if (w < 0)
  {
    w = - w;
    z->state->nowrap = 1;
  }

  /* set window size */
  if (w < 8 || w > 15)
  {
    inflateEnd(z);
    return Z_STREAM_ERROR;
  }
  z->state->wbits = (uInt)w;

  /* create inflate_blocks state */
  if ((z->state->blocks =
      inflate_blocks_new(z, z->state->nowrap ? Z_NULL : adler32, (uInt)1 << w))
      == Z_NULL)
  {
    inflateEnd(z);
    return Z_MEM_ERROR;
  }
  Tracev((stderr, "inflate: allocated\n"));

  /* reset state */
  inflateReset(z);
  return Z_OK;
}


int ZEXPORT inflateInit_(z, version, stream_size)
z_streamp z;
const char *version;
int stream_size;
{
  return inflateInit2_(z, DEF_WBITS, version, stream_size);
}


#define NEEDBYTE {if(z->avail_in==0)return r;r=f;}
#define NEXTBYTE (z->avail_in--,z->total_in++,*z->next_in++)

int ZEXPORT inflate(z, f)
z_streamp z;
int f;
{
  int r;
  uInt b;

  if (z == Z_NULL || z->state == Z_NULL || z->next_in == Z_NULL)
    return Z_STREAM_ERROR;
  f = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;
  r = Z_BUF_ERROR;
  while (1) switch (z->state->mode)
  {
    case METHOD:
      NEEDBYTE
      if (((z->state->sub.method = NEXTBYTE) & 0xf) != Z_DEFLATED)
      {
        z->state->mode = BAD;
        z->msg = (char*)"unknown compression method";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      if ((z->state->sub.method >> 4) + 8 > z->state->wbits)
      {
        z->state->mode = BAD;
        z->msg = (char*)"invalid window size";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      z->state->mode = FLAG;
    case FLAG:
      NEEDBYTE
      b = NEXTBYTE;
      if (((z->state->sub.method << 8) + b) % 31)
      {
        z->state->mode = BAD;
        z->msg = (char*)"incorrect header check";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      Tracev((stderr, "inflate: zlib header ok\n"));
      if (!(b & PRESET_DICT))
      {
        z->state->mode = BLOCKS;
        break;
      }
      z->state->mode = DICT4;
    case DICT4:
      NEEDBYTE
      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
      z->state->mode = DICT3;
    case DICT3:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
      z->state->mode = DICT2;
    case DICT2:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
      z->state->mode = DICT1;
    case DICT1:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE;
      z->adler = z->state->sub.check.need;
      z->state->mode = DICT0;
      return Z_NEED_DICT;
    case DICT0:
      z->state->mode = BAD;
      z->msg = (char*)"need dictionary";
      z->state->sub.marker = 0;       /* can try inflateSync */
      return Z_STREAM_ERROR;
    case BLOCKS:
      r = inflate_blocks(z->state->blocks, z, r);
      if (r == Z_DATA_ERROR)
      {
        z->state->mode = BAD;
        z->state->sub.marker = 0;       /* can try inflateSync */
        break;
      }
      if (r == Z_OK)
        r = f;
      if (r != Z_STREAM_END)
        return r;
      r = f;
      inflate_blocks_reset(z->state->blocks, z, &z->state->sub.check.was);
      if (z->state->nowrap)
      {
        z->state->mode = DONE;
        break;
      }
      z->state->mode = CHECK4;
    case CHECK4:
      NEEDBYTE
      z->state->sub.check.need = (uLong)NEXTBYTE << 24;
      z->state->mode = CHECK3;
    case CHECK3:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 16;
      z->state->mode = CHECK2;
    case CHECK2:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE << 8;
      z->state->mode = CHECK1;
    case CHECK1:
      NEEDBYTE
      z->state->sub.check.need += (uLong)NEXTBYTE;

      if (z->state->sub.check.was != z->state->sub.check.need)
      {
        z->state->mode = BAD;
        z->msg = (char*)"incorrect data check";
        z->state->sub.marker = 5;       /* can't try inflateSync */
        break;
      }
      Tracev((stderr, "inflate: zlib check ok\n"));
      z->state->mode = DONE;
    case DONE:
      return Z_STREAM_END;
    case BAD:
      return Z_DATA_ERROR;
    default:
      return Z_STREAM_ERROR;
  }
#ifdef NEED_DUMMY_RETURN
  return Z_STREAM_ERROR;  /* Some dumb compilers complain without this */
#endif
}


int ZEXPORT inflateSetDictionary(z, dictionary, dictLength)
z_streamp z;
const Bytef *dictionary;
uInt  dictLength;
{
  uInt length = dictLength;

  if (z == Z_NULL || z->state == Z_NULL || z->state->mode != DICT0)
    return Z_STREAM_ERROR;

  if (adler32(1L, dictionary, dictLength) != z->adler) return Z_DATA_ERROR;
  z->adler = 1L;

  if (length >= ((uInt)1<<z->state->wbits))
  {
    length = (1<<z->state->wbits)-1;
    dictionary += dictLength - length;
  }
  inflate_set_dictionary(z->state->blocks, dictionary, length);
  z->state->mode = BLOCKS;
  return Z_OK;
}


int ZEXPORT inflateSync(z)
z_streamp z;
{
  uInt n;       /* number of bytes to look at */
  Bytef *p;     /* pointer to bytes */
  uInt m;       /* number of marker bytes found in a row */
  uLong r, w;   /* temporaries to save total_in and total_out */

  /* set up */
  if (z == Z_NULL || z->state == Z_NULL)
    return Z_STREAM_ERROR;
  if (z->state->mode != BAD)
  {
    z->state->mode = BAD;
    z->state->sub.marker = 0;
  }
  if ((n = z->avail_in) == 0)
    return Z_BUF_ERROR;
  p = z->next_in;
  m = z->state->sub.marker;

  /* search */
  while (n && m < 4)
  {
    static const Byte mark[4] = {0, 0, 0xff, 0xff};
    if (*p == mark[m])
      m++;
    else if (*p)
      m = 0;
    else
      m = 4 - m;
    p++, n--;
  }

  /* restore */
  z->total_in += (uLong)(p - z->next_in);
  z->next_in = p;
  z->avail_in = n;
  z->state->sub.marker = m;

  /* return no joy or set up to restart on a new block */
  if (m != 4)
    return Z_DATA_ERROR;
  r = z->total_in;  w = z->total_out;
  inflateReset(z);
  z->total_in = r;  z->total_out = w;
  z->state->mode = BLOCKS;
  return Z_OK;
}


/* Returns true if inflate is currently at the end of a block generated
 * by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP
 * implementation to provide an additional safety check. PPP uses Z_SYNC_FLUSH
 * but removes the length bytes of the resulting empty stored block. When
 * decompressing, PPP checks that at the end of input packet, inflate is
 * waiting for these length bytes.
 */
int ZEXPORT inflateSyncPoint(z)
z_streamp z;
{
  if (z == Z_NULL || z->state == Z_NULL || z->state->blocks == Z_NULL)
    return Z_STREAM_ERROR;
  return inflate_blocks_sync_point(z->state->blocks);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\inftrees.c ===
/* inftrees.c -- generate Huffman trees for efficient decoding
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

#include "zutil.h"
#include "inftrees.h"

#if !defined(BUILDFIXED) && !defined(STDC)
#  define BUILDFIXED   /* non ANSI compilers may not accept inffixed.h */
#endif

const char inflate_copyright[] =
   " inflate 1.1.4 Copyright 1995-2002 Mark Adler ";
/*
  If you use the zlib library in a product, an acknowledgment is welcome
  in the documentation of your product. If for some reason you cannot
  include such an acknowledgment, I would appreciate that you keep this
  copyright string in the executable of your product.
 */
struct internal_state  {int dummy;}; /* for buggy compilers */

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits


local int huft_build OF((
    uIntf *,            /* code lengths in bits */
    uInt,               /* number of codes */
    uInt,               /* number of "simple" codes */
    const uIntf *,      /* list of base values for non-simple codes */
    const uIntf *,      /* list of extra bits for non-simple codes */
    inflate_huft * FAR*,/* result: starting table */
    uIntf *,            /* maximum lookup bits (returns actual) */
    inflate_huft *,     /* space for trees */
    uInt *,             /* hufts used in space */
    uIntf * ));         /* space for values */

/* Tables for deflate from PKZIP's appnote.txt. */
local const uInt cplens[31] = { /* Copy lengths for literal codes 257..285 */
        3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
        35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
        /* see note #13 above about 258 */
local const uInt cplext[31] = { /* Extra bits for literal codes 257..285 */
        0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2,
        3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112}; /* 112==invalid */
local const uInt cpdist[30] = { /* Copy offsets for distance codes 0..29 */
        1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
        257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
        8193, 12289, 16385, 24577};
local const uInt cpdext[30] = { /* Extra bits for distance codes */
        0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6,
        7, 7, 8, 8, 9, 9, 10, 10, 11, 11,
        12, 12, 13, 13};

/*
   Huffman code decoding is performed using a multi-level table lookup.
   The fastest way to decode is to simply build a lookup table whose
   size is determined by the longest code.  However, the time it takes
   to build this table can also be a factor if the data being decoded
   is not very long.  The most common codes are necessarily the
   shortest codes, so those codes dominate the decoding time, and hence
   the speed.  The idea is you can have a shorter table that decodes the
   shorter, more probable codes, and then point to subsidiary tables for
   the longer codes.  The time it costs to decode the longer codes is
   then traded against the time it takes to make longer tables.

   This results of this trade are in the variables lbits and dbits
   below.  lbits is the number of bits the first level table for literal/
   length codes can decode in one step, and dbits is the same thing for
   the distance codes.  Subsequent tables are also less than or equal to
   those sizes.  These values may be adjusted either when all of the
   codes are shorter than that, in which case the longest code length in
   bits is used, or when the shortest code is *longer* than the requested
   table size, in which case the length of the shortest code in bits is
   used.

   There are two different values for the two tables, since they code a
   different number of possibilities each.  The literal/length table
   codes 286 possible values, or in a flat code, a little over eight
   bits.  The distance table codes 30 possible values, or a little less
   than five bits, flat.  The optimum values for speed end up being
   about one bit more than those, so lbits is 8+1 and dbits is 5+1.
   The optimum values may differ though from machine to machine, and
   possibly even between compilers.  Your mileage may vary.
 */


/* If BMAX needs to be larger than 16, then h and x[] should be uLong. */
#define BMAX 15         /* maximum bit length of any code */

local int huft_build(b, n, s, d, e, t, m, hp, hn, v)
uIntf *b;               /* code lengths in bits (all assumed <= BMAX) */
uInt n;                 /* number of codes (assumed <= 288) */
uInt s;                 /* number of simple-valued codes (0..s-1) */
const uIntf *d;         /* list of base values for non-simple codes */
const uIntf *e;         /* list of extra bits for non-simple codes */
inflate_huft * FAR *t;  /* result: starting table */
uIntf *m;               /* maximum lookup bits, returns actual */
inflate_huft *hp;       /* space for trees */
uInt *hn;               /* hufts used in space */
uIntf *v;               /* working area: values in order of bit length */
/* Given a list of code lengths and a maximum table size, make a set of
   tables to decode that set of codes.  Return Z_OK on success, Z_BUF_ERROR
   if the given code set is incomplete (the tables are still built in this
   case), or Z_DATA_ERROR if the input is invalid. */
{

  uInt a;                       /* counter for codes of length k */
  uInt c[BMAX+1];               /* bit length count table */
  uInt f;                       /* i repeats in table every f entries */
  int g;                        /* maximum code length */
  int h;                        /* table level */
  register uInt i;              /* counter, current code */
  register uInt j;              /* counter */
  register int k;               /* number of bits in current code */
  int l;                        /* bits per table (returned in m) */
  uInt mask;                    /* (1 << w) - 1, to avoid cc -O bug on HP */
  register uIntf *p;            /* pointer into c[], b[], or v[] */
  inflate_huft *q;              /* points to current table */
  struct inflate_huft_s r;      /* table entry for structure assignment */
  inflate_huft *u[BMAX];        /* table stack */
  register int w;               /* bits before this table == (l * h) */
  uInt x[BMAX+1];               /* bit offsets, then code stack */
  uIntf *xp;                    /* pointer into x */
  int y;                        /* number of dummy codes added */
  uInt z;                       /* number of entries in current table */


  /* Generate counts for each bit length */
  p = c;
#define C0 *p++ = 0;
#define C2 C0 C0 C0 C0
#define C4 C2 C2 C2 C2
  C4                            /* clear c[]--assume BMAX+1 is 16 */
  p = b;  i = n;
  do {
    c[*p++]++;                  /* assume all entries <= BMAX */
  } while (--i);
  if (c[0] == n)                /* null input--all zero length codes */
  {
    *t = (inflate_huft *)Z_NULL;
    *m = 0;
    return Z_OK;
  }


  /* Find minimum and maximum length, bound *m by those */
  l = *m;
  for (j = 1; j <= BMAX; j++)
    if (c[j])
      break;
  k = j;                        /* minimum code length */
  if ((uInt)l < j)
    l = j;
  for (i = BMAX; i; i--)
    if (c[i])
      break;
  g = i;                        /* maximum code length */
  if ((uInt)l > i)
    l = i;
  *m = l;


  /* Adjust last length count to fill out codes, if needed */
  for (y = 1 << j; j < i; j++, y <<= 1)
    if ((y -= c[j]) < 0)
      return Z_DATA_ERROR;
  if ((y -= c[i]) < 0)
    return Z_DATA_ERROR;
  c[i] += y;


  /* Generate starting offsets into the value table for each length */
  x[1] = j = 0;
  p = c + 1;  xp = x + 2;
  while (--i) {                 /* note that i == g from above */
    *xp++ = (j += *p++);
  }


  /* Make a table of values in order of bit lengths */
  p = b;  i = 0;
  do {
    if ((j = *p++) != 0)
      v[x[j]++] = i;
  } while (++i < n);
  n = x[g];                     /* set n to length of v */


  /* Generate the Huffman codes and for each, make the table entries */
  x[0] = i = 0;                 /* first Huffman code is zero */
  p = v;                        /* grab values in bit order */
  h = -1;                       /* no tables yet--level -1 */
  w = -l;                       /* bits decoded == (l * h) */
  u[0] = (inflate_huft *)Z_NULL;        /* just to keep compilers happy */
  q = (inflate_huft *)Z_NULL;   /* ditto */
  z = 0;                        /* ditto */

  /* go through the bit lengths (k already is bits in shortest code) */
  for (; k <= g; k++)
  {
    a = c[k];
    while (a--)
    {
      /* here i is the Huffman code of length k bits for value *p */
      /* make tables up to required level */
      while (k > w + l)
      {
        h++;
        w += l;                 /* previous table always l bits */

        /* compute minimum size table less than or equal to l bits */
        z = g - w;
        z = z > (uInt)l ? l : z;        /* table size upper limit */
        if ((f = 1 << (j = k - w)) > a + 1)     /* try a k-w bit table */
        {                       /* too few codes for k-w bit table */
          f -= a + 1;           /* deduct codes from patterns left */
          xp = c + k;
          if (j < z)
            while (++j < z)     /* try smaller tables up to z bits */
            {
              if ((f <<= 1) <= *++xp)
                break;          /* enough codes to use up j bits */
              f -= *xp;         /* else deduct codes from patterns */
            }
        }
        z = 1 << j;             /* table entries for j-bit table */

        /* allocate new table */
        if (*hn + z > MANY)     /* (note: doesn't matter for fixed) */
          return Z_DATA_ERROR;  /* overflow of MANY */
        u[h] = q = hp + *hn;
        *hn += z;

        /* connect to last table, if there is one */
        if (h)
        {
          x[h] = i;             /* save pattern for backing up */
          r.bits = (Byte)l;     /* bits to dump before this table */
          r.exop = (Byte)j;     /* bits in this table */
          j = i >> (w - l);
          r.base = (uInt)(q - u[h-1] - j);   /* offset to this table */
          u[h-1][j] = r;        /* connect to last table */
        }
        else
          *t = q;               /* first table is returned result */
      }

      /* set up table entry in r */
      r.bits = (Byte)(k - w);
      if (p >= v + n)
        r.exop = 128 + 64;      /* out of values--invalid code */
      else if (*p < s)
      {
        r.exop = (Byte)(*p < 256 ? 0 : 32 + 64);     /* 256 is end-of-block */
        r.base = *p++;          /* simple code is just the value */
      }
      else
      {
        r.exop = (Byte)(e[*p - s] + 16 + 64);/* non-simple--look up in lists */
        r.base = d[*p++ - s];
      }

      /* fill code-like entries with r */
      f = 1 << (k - w);
      for (j = i >> w; j < z; j += f)
        q[j] = r;

      /* backwards increment the k-bit code i */
      for (j = 1 << (k - 1); i & j; j >>= 1)
        i ^= j;
      i ^= j;

      /* backup over finished tables */
      mask = (1 << w) - 1;      /* needed on HP, cc -O bug */
      while ((i & mask) != x[h])
      {
        h--;                    /* don't need to update q */
        w -= l;
        mask = (1 << w) - 1;
      }
    }
  }


  /* Return Z_BUF_ERROR if we were given an incomplete table */
  return y != 0 && g != 1 ? Z_BUF_ERROR : Z_OK;
}


int inflate_trees_bits(c, bb, tb, hp, z)
uIntf *c;               /* 19 code lengths */
uIntf *bb;              /* bits tree desired/actual depth */
inflate_huft * FAR *tb; /* bits tree result */
inflate_huft *hp;       /* space for trees */
z_streamp z;            /* for messages */
{
  int r;
  uInt hn = 0;          /* hufts used in space */
  uIntf *v;             /* work area for huft_build */

  if ((v = (uIntf*)ZALLOC(z, 19, sizeof(uInt))) == Z_NULL)
    return Z_MEM_ERROR;
  r = huft_build(c, 19, 19, (uIntf*)Z_NULL, (uIntf*)Z_NULL,
                 tb, bb, hp, &hn, v);
  if (r == Z_DATA_ERROR)
    z->msg = (char*)"oversubscribed dynamic bit lengths tree";
  else if (r == Z_BUF_ERROR || *bb == 0)
  {
    z->msg = (char*)"incomplete dynamic bit lengths tree";
    r = Z_DATA_ERROR;
  }
  ZFREE(z, v);
  return r;
}


int inflate_trees_dynamic(nl, nd, c, bl, bd, tl, td, hp, z)
uInt nl;                /* number of literal/length codes */
uInt nd;                /* number of distance codes */
uIntf *c;               /* that many (total) code lengths */
uIntf *bl;              /* literal desired/actual bit depth */
uIntf *bd;              /* distance desired/actual bit depth */
inflate_huft * FAR *tl; /* literal/length tree result */
inflate_huft * FAR *td; /* distance tree result */
inflate_huft *hp;       /* space for trees */
z_streamp z;            /* for messages */
{
  int r;
  uInt hn = 0;          /* hufts used in space */
  uIntf *v;             /* work area for huft_build */

  /* allocate work area */
  if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
    return Z_MEM_ERROR;

  /* build literal/length tree */
  r = huft_build(c, nl, 257, cplens, cplext, tl, bl, hp, &hn, v);
  if (r != Z_OK || *bl == 0)
  {
    if (r == Z_DATA_ERROR)
      z->msg = (char*)"oversubscribed literal/length tree";
    else if (r != Z_MEM_ERROR)
    {
      z->msg = (char*)"incomplete literal/length tree";
      r = Z_DATA_ERROR;
    }
    ZFREE(z, v);
    return r;
  }

  /* build distance tree */
  r = huft_build(c + nl, nd, 0, cpdist, cpdext, td, bd, hp, &hn, v);
  if (r != Z_OK || (*bd == 0 && nl > 257))
  {
    if (r == Z_DATA_ERROR)
      z->msg = (char*)"oversubscribed distance tree";
    else if (r == Z_BUF_ERROR) {
#ifdef PKZIP_BUG_WORKAROUND
      r = Z_OK;
    }
#else
      z->msg = (char*)"incomplete distance tree";
      r = Z_DATA_ERROR;
    }
    else if (r != Z_MEM_ERROR)
    {
      z->msg = (char*)"empty distance tree with lengths";
      r = Z_DATA_ERROR;
    }
    ZFREE(z, v);
    return r;
#endif
  }

  /* done */
  ZFREE(z, v);
  return Z_OK;
}


/* build fixed tables only once--keep them here */
#ifdef BUILDFIXED
local int fixed_built = 0;
#define FIXEDH 544      /* number of hufts used by fixed tables */
local inflate_huft fixed_mem[FIXEDH];
local uInt fixed_bl;
local uInt fixed_bd;
local inflate_huft *fixed_tl;
local inflate_huft *fixed_td;
#else
#include "inffixed.h"
#endif


int inflate_trees_fixed(bl, bd, tl, td, z)
uIntf *bl;               /* literal desired/actual bit depth */
uIntf *bd;               /* distance desired/actual bit depth */
const inflate_huft * FAR *tl;  /* literal/length tree result */
const inflate_huft * FAR *td;  /* distance tree result */
z_streamp z;             /* for memory allocation */
{
#ifdef BUILDFIXED
  /* build fixed tables if not already */
  if (!fixed_built)
  {
    int k;              /* temporary variable */
    uInt f = 0;         /* number of hufts used in fixed_mem */
    uIntf *c;           /* length list for huft_build */
    uIntf *v;           /* work area for huft_build */

    /* allocate memory */
    if ((c = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
      return Z_MEM_ERROR;
    if ((v = (uIntf*)ZALLOC(z, 288, sizeof(uInt))) == Z_NULL)
    {
      ZFREE(z, c);
      return Z_MEM_ERROR;
    }

    /* literal table */
    for (k = 0; k < 144; k++)
      c[k] = 8;
    for (; k < 256; k++)
      c[k] = 9;
    for (; k < 280; k++)
      c[k] = 7;
    for (; k < 288; k++)
      c[k] = 8;
    fixed_bl = 9;
    huft_build(c, 288, 257, cplens, cplext, &fixed_tl, &fixed_bl,
               fixed_mem, &f, v);

    /* distance table */
    for (k = 0; k < 30; k++)
      c[k] = 5;
    fixed_bd = 5;
    huft_build(c, 30, 0, cpdist, cpdext, &fixed_td, &fixed_bd,
               fixed_mem, &f, v);

    /* done */
    ZFREE(z, v);
    ZFREE(z, c);
    fixed_built = 1;
  }
#endif
  *bl = fixed_bl;
  *bd = fixed_bd;
  *tl = fixed_tl;
  *td = fixed_td;
  return Z_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\infutil.h ===
/* infutil.h -- types and macros common to blocks and codes
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

#ifndef _INFUTIL_H
#define _INFUTIL_H

typedef enum {
      TYPE,     /* get type bits (3, including end bit) */
      LENS,     /* get lengths for stored */
      STORED,   /* processing stored block */
      TABLE,    /* get table lengths */
      BTREE,    /* get bit lengths tree for a dynamic block */
      DTREE,    /* get length, distance trees for a dynamic block */
      CODES,    /* processing fixed or dynamic block */
      DRY,      /* output remaining window bytes */
      DONE,     /* finished last block, done */
      BAD}      /* got a data error--stuck here */
inflate_block_mode;

/* inflate blocks semi-private state */
struct inflate_blocks_state {

  /* mode */
  inflate_block_mode  mode;     /* current inflate_block mode */

  /* mode dependent information */
  union {
    uInt left;          /* if STORED, bytes left to copy */
    struct {
      uInt table;               /* table lengths (14 bits) */
      uInt index;               /* index into blens (or border) */
      uIntf *blens;             /* bit lengths of codes */
      uInt bb;                  /* bit length tree depth */
      inflate_huft *tb;         /* bit length decoding tree */
    } trees;            /* if DTREE, decoding info for trees */
    struct {
      inflate_codes_statef 
         *codes;
    } decode;           /* if CODES, current state */
  } sub;                /* submode */
  uInt last;            /* true if this block is the last block */

  /* mode independent information */
  uInt bitk;            /* bits in bit buffer */
  uLong bitb;           /* bit buffer */
  inflate_huft *hufts;  /* single malloc for tree space */
  Bytef *window;        /* sliding window */
  Bytef *end;           /* one byte after sliding window */
  Bytef *read;          /* window read pointer */
  Bytef *write;         /* window write pointer */
  check_func checkfn;   /* check function */
  uLong check;          /* check on output */

};


/* defines for inflate input/output */
/*   update pointers and return */
#define UPDBITS {s->bitb=b;s->bitk=k;}
#define UPDIN {z->avail_in=n;z->total_in+=(uLong)(p-z->next_in);z->next_in=p;}
#define UPDOUT {s->write=q;}
#define UPDATE {UPDBITS UPDIN UPDOUT}
#define LEAVE {UPDATE return inflate_flush(s,z,r);}
/*   get bytes and bits */
#define LOADIN {p=z->next_in;n=z->avail_in;b=s->bitb;k=s->bitk;}
#define NEEDBYTE {if(n)r=Z_OK;else LEAVE}
#define NEXTBYTE (n--,*p++)
#define NEEDBITS(j) {while(k<(j)){NEEDBYTE;b|=((uLong)NEXTBYTE)<<k;k+=8;}}
#define DUMPBITS(j) {b>>=(j);k-=(j);}
/*   output bytes */
#define WAVAIL (uInt)(q<s->read?s->read-q-1:s->end-q)
#define LOADOUT {q=s->write;m=(uInt)WAVAIL;}
#define WRAP {if(q==s->end&&s->read!=s->window){q=s->window;m=(uInt)WAVAIL;}}
#define FLUSH {UPDOUT r=inflate_flush(s,z,r); LOADOUT}
#define NEEDOUT {if(m==0){WRAP if(m==0){FLUSH WRAP if(m==0) LEAVE}}r=Z_OK;}
#define OUTBYTE(a) {*q++=(Byte)(a);m--;}
/*   load local pointers */
#define LOAD {LOADIN LOADOUT}

/* masks for lower bits (size given to avoid silly warnings with Visual C++) */
extern const uInt inflate_mask[17];

/* copy as much as possible from the sliding window to the output area */
extern int inflate_flush OF((
    inflate_blocks_statef *,
    z_streamp ,
    int));

struct internal_state      {int dummy;}; /* for buggy compilers */

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\maketree.c ===
/* maketree.c -- make inffixed.h table for decoding fixed codes
 * Copyright (C) 1995-2002 Mark Adler
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* This program is included in the distribution for completeness.
   You do not need to compile or run this program since inffixed.h
   is already included in the distribution.  To use this program
   you need to compile zlib with BUILDFIXED defined and then compile
   and link this program with the zlib library.  Then the output of
   this program can be piped to inffixed.h. */

#include <stdio.h>
#include <stdlib.h>
#include "zutil.h"
#include "inftrees.h"

/* simplify the use of the inflate_huft type with some defines */
#define exop word.what.Exop
#define bits word.what.Bits

/* generate initialization table for an inflate_huft structure array */
void maketree(uInt b, inflate_huft *t)
{
  int i, e;

  i = 0;
  while (1)
  {
    e = t[i].exop;
    if (e && (e & (16+64)) == 0)        /* table pointer */
    {
      fprintf(stderr, "maketree: cannot initialize sub-tables!\n");
      exit(1);
    }
    if (i % 4 == 0)
      printf("\n   ");
    printf(" {{{%u,%u}},%u}", t[i].exop, t[i].bits, t[i].base);
    if (++i == (1<<b))
      break;
    putchar(',');
  }
  puts("");
}

/* create the fixed tables in C initialization syntax */
void main(void)
{
  int r;
  uInt bl, bd;
  inflate_huft *tl, *td;
  z_stream z;

  z.zalloc = zcalloc;
  z.opaque = (voidpf)0;
  z.zfree = zcfree;
  r = inflate_trees_fixed(&bl, &bd, &tl, &td, &z);
  if (r)
  {
    fprintf(stderr, "inflate_trees_fixed error %d\n", r);
    return;
  }
  puts("/* inffixed.h -- table for decoding fixed codes");
  puts(" * Generated automatically by the maketree.c program");
  puts(" */");
  puts("");
  puts("/* WARNING: this file should *not* be used by applications. It is");
  puts("   part of the implementation of the compression library and is");
  puts("   subject to change. Applications should only use zlib.h.");
  puts(" */");
  puts("");
  printf("local uInt fixed_bl = %d;\n", bl);
  printf("local uInt fixed_bd = %d;\n", bd);
  printf("local inflate_huft fixed_tl[] = {");
  maketree(bl, tl);
  puts("  };");
  printf("local inflate_huft fixed_td[] = {");
  maketree(bd, td);
  puts("  };");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\inffixed.h ===
/* inffixed.h -- table for decoding fixed codes
 * Generated automatically by the maketree.c program
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

local const uInt fixed_bl = 9;
local const uInt fixed_bd = 5;
local const inflate_huft fixed_tl[] = {
    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},192},
    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},160},
    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},224},
    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},144},
    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},208},
    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},176},
    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},240},
    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},200},
    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},168},
    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},232},
    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},152},
    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},216},
    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},184},
    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},248},
    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},196},
    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},164},
    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},228},
    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},148},
    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},212},
    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},180},
    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},244},
    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},204},
    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},172},
    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},236},
    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},156},
    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},220},
    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},188},
    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},252},
    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},194},
    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},162},
    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},226},
    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},146},
    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},210},
    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},178},
    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},242},
    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},202},
    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},170},
    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},234},
    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},154},
    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},218},
    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},186},
    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},250},
    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},198},
    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},166},
    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},230},
    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},150},
    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},214},
    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},182},
    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},246},
    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},206},
    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},174},
    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},238},
    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},158},
    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},222},
    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},190},
    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},254},
    {{{96,7}},256}, {{{0,8}},80}, {{{0,8}},16}, {{{84,8}},115},
    {{{82,7}},31}, {{{0,8}},112}, {{{0,8}},48}, {{{0,9}},193},
    {{{80,7}},10}, {{{0,8}},96}, {{{0,8}},32}, {{{0,9}},161},
    {{{0,8}},0}, {{{0,8}},128}, {{{0,8}},64}, {{{0,9}},225},
    {{{80,7}},6}, {{{0,8}},88}, {{{0,8}},24}, {{{0,9}},145},
    {{{83,7}},59}, {{{0,8}},120}, {{{0,8}},56}, {{{0,9}},209},
    {{{81,7}},17}, {{{0,8}},104}, {{{0,8}},40}, {{{0,9}},177},
    {{{0,8}},8}, {{{0,8}},136}, {{{0,8}},72}, {{{0,9}},241},
    {{{80,7}},4}, {{{0,8}},84}, {{{0,8}},20}, {{{85,8}},227},
    {{{83,7}},43}, {{{0,8}},116}, {{{0,8}},52}, {{{0,9}},201},
    {{{81,7}},13}, {{{0,8}},100}, {{{0,8}},36}, {{{0,9}},169},
    {{{0,8}},4}, {{{0,8}},132}, {{{0,8}},68}, {{{0,9}},233},
    {{{80,7}},8}, {{{0,8}},92}, {{{0,8}},28}, {{{0,9}},153},
    {{{84,7}},83}, {{{0,8}},124}, {{{0,8}},60}, {{{0,9}},217},
    {{{82,7}},23}, {{{0,8}},108}, {{{0,8}},44}, {{{0,9}},185},
    {{{0,8}},12}, {{{0,8}},140}, {{{0,8}},76}, {{{0,9}},249},
    {{{80,7}},3}, {{{0,8}},82}, {{{0,8}},18}, {{{85,8}},163},
    {{{83,7}},35}, {{{0,8}},114}, {{{0,8}},50}, {{{0,9}},197},
    {{{81,7}},11}, {{{0,8}},98}, {{{0,8}},34}, {{{0,9}},165},
    {{{0,8}},2}, {{{0,8}},130}, {{{0,8}},66}, {{{0,9}},229},
    {{{80,7}},7}, {{{0,8}},90}, {{{0,8}},26}, {{{0,9}},149},
    {{{84,7}},67}, {{{0,8}},122}, {{{0,8}},58}, {{{0,9}},213},
    {{{82,7}},19}, {{{0,8}},106}, {{{0,8}},42}, {{{0,9}},181},
    {{{0,8}},10}, {{{0,8}},138}, {{{0,8}},74}, {{{0,9}},245},
    {{{80,7}},5}, {{{0,8}},86}, {{{0,8}},22}, {{{192,8}},0},
    {{{83,7}},51}, {{{0,8}},118}, {{{0,8}},54}, {{{0,9}},205},
    {{{81,7}},15}, {{{0,8}},102}, {{{0,8}},38}, {{{0,9}},173},
    {{{0,8}},6}, {{{0,8}},134}, {{{0,8}},70}, {{{0,9}},237},
    {{{80,7}},9}, {{{0,8}},94}, {{{0,8}},30}, {{{0,9}},157},
    {{{84,7}},99}, {{{0,8}},126}, {{{0,8}},62}, {{{0,9}},221},
    {{{82,7}},27}, {{{0,8}},110}, {{{0,8}},46}, {{{0,9}},189},
    {{{0,8}},14}, {{{0,8}},142}, {{{0,8}},78}, {{{0,9}},253},
    {{{96,7}},256}, {{{0,8}},81}, {{{0,8}},17}, {{{85,8}},131},
    {{{82,7}},31}, {{{0,8}},113}, {{{0,8}},49}, {{{0,9}},195},
    {{{80,7}},10}, {{{0,8}},97}, {{{0,8}},33}, {{{0,9}},163},
    {{{0,8}},1}, {{{0,8}},129}, {{{0,8}},65}, {{{0,9}},227},
    {{{80,7}},6}, {{{0,8}},89}, {{{0,8}},25}, {{{0,9}},147},
    {{{83,7}},59}, {{{0,8}},121}, {{{0,8}},57}, {{{0,9}},211},
    {{{81,7}},17}, {{{0,8}},105}, {{{0,8}},41}, {{{0,9}},179},
    {{{0,8}},9}, {{{0,8}},137}, {{{0,8}},73}, {{{0,9}},243},
    {{{80,7}},4}, {{{0,8}},85}, {{{0,8}},21}, {{{80,8}},258},
    {{{83,7}},43}, {{{0,8}},117}, {{{0,8}},53}, {{{0,9}},203},
    {{{81,7}},13}, {{{0,8}},101}, {{{0,8}},37}, {{{0,9}},171},
    {{{0,8}},5}, {{{0,8}},133}, {{{0,8}},69}, {{{0,9}},235},
    {{{80,7}},8}, {{{0,8}},93}, {{{0,8}},29}, {{{0,9}},155},
    {{{84,7}},83}, {{{0,8}},125}, {{{0,8}},61}, {{{0,9}},219},
    {{{82,7}},23}, {{{0,8}},109}, {{{0,8}},45}, {{{0,9}},187},
    {{{0,8}},13}, {{{0,8}},141}, {{{0,8}},77}, {{{0,9}},251},
    {{{80,7}},3}, {{{0,8}},83}, {{{0,8}},19}, {{{85,8}},195},
    {{{83,7}},35}, {{{0,8}},115}, {{{0,8}},51}, {{{0,9}},199},
    {{{81,7}},11}, {{{0,8}},99}, {{{0,8}},35}, {{{0,9}},167},
    {{{0,8}},3}, {{{0,8}},131}, {{{0,8}},67}, {{{0,9}},231},
    {{{80,7}},7}, {{{0,8}},91}, {{{0,8}},27}, {{{0,9}},151},
    {{{84,7}},67}, {{{0,8}},123}, {{{0,8}},59}, {{{0,9}},215},
    {{{82,7}},19}, {{{0,8}},107}, {{{0,8}},43}, {{{0,9}},183},
    {{{0,8}},11}, {{{0,8}},139}, {{{0,8}},75}, {{{0,9}},247},
    {{{80,7}},5}, {{{0,8}},87}, {{{0,8}},23}, {{{192,8}},0},
    {{{83,7}},51}, {{{0,8}},119}, {{{0,8}},55}, {{{0,9}},207},
    {{{81,7}},15}, {{{0,8}},103}, {{{0,8}},39}, {{{0,9}},175},
    {{{0,8}},7}, {{{0,8}},135}, {{{0,8}},71}, {{{0,9}},239},
    {{{80,7}},9}, {{{0,8}},95}, {{{0,8}},31}, {{{0,9}},159},
    {{{84,7}},99}, {{{0,8}},127}, {{{0,8}},63}, {{{0,9}},223},
    {{{82,7}},27}, {{{0,8}},111}, {{{0,8}},47}, {{{0,9}},191},
    {{{0,8}},15}, {{{0,8}},143}, {{{0,8}},79}, {{{0,9}},255}
  };
local const inflate_huft fixed_td[] = {
    {{{80,5}},1}, {{{87,5}},257}, {{{83,5}},17}, {{{91,5}},4097},
    {{{81,5}},5}, {{{89,5}},1025}, {{{85,5}},65}, {{{93,5}},16385},
    {{{80,5}},3}, {{{88,5}},513}, {{{84,5}},33}, {{{92,5}},8193},
    {{{82,5}},9}, {{{90,5}},2049}, {{{86,5}},129}, {{{192,5}},24577},
    {{{80,5}},2}, {{{87,5}},385}, {{{83,5}},25}, {{{91,5}},6145},
    {{{81,5}},7}, {{{89,5}},1537}, {{{85,5}},97}, {{{93,5}},24577},
    {{{80,5}},4}, {{{88,5}},769}, {{{84,5}},49}, {{{92,5}},12289},
    {{{82,5}},13}, {{{90,5}},3073}, {{{86,5}},193}, {{{192,5}},24577}
  };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\minigzip.c ===
/* minigzip.c -- simulate gzip using the zlib compression library
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/*
 * minigzip is a minimal implementation of the gzip utility. This is
 * only an example of using zlib and isn't meant to replace the
 * full-featured gzip. No attempt is made to deal with file systems
 * limiting names to 14 or 8+3 characters, etc... Error checking is
 * very limited. So use minigzip only for testing; use gzip for the
 * real thing. On MSDOS, use only on file names without extension
 * or in pipe mode.
 */

/* @(#) $Id$ */

#include <stdio.h>
#include "zlib.h"

#ifdef STDC
#  include <string.h>
#  include <stdlib.h>
#else
   extern void exit  OF((int));
#endif

#ifdef USE_MMAP
#  include <sys/types.h>
#  include <sys/mman.h>
#  include <sys/stat.h>
#endif

#if defined(MSDOS) || defined(OS2) || defined(WIN32)
#  include <fcntl.h>
#  include <io.h>
#  define SET_BINARY_MODE(file) setmode(fileno(file), O_BINARY)
#else
#  define SET_BINARY_MODE(file)
#endif

#ifdef VMS
#  define unlink delete
#  define GZ_SUFFIX "-gz"
#endif
#ifdef RISCOS
#  define unlink remove
#  define GZ_SUFFIX "-gz"
#  define fileno(file) file->__file
#endif
#if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
#  include <unix.h> /* for fileno */
#endif

#ifndef WIN32 /* unlink already in stdio.h for WIN32 */
  extern int unlink OF((const char *));
#endif

#ifndef GZ_SUFFIX
#  define GZ_SUFFIX ".gz"
#endif
#define SUFFIX_LEN (sizeof(GZ_SUFFIX)-1)

#define BUFLEN      16384
#define MAX_NAME_LEN 1024

#ifdef MAXSEG_64K
#  define local static
   /* Needed for systems with limitation on stack size. */
#else
#  define local
#endif

char *prog;

void error            OF((const char *msg));
void gz_compress      OF((FILE   *in, gzFile out));
#ifdef USE_MMAP
int  gz_compress_mmap OF((FILE   *in, gzFile out));
#endif
void gz_uncompress    OF((gzFile in, FILE   *out));
void file_compress    OF((char  *file, char *mode));
void file_uncompress  OF((char  *file));
int  main             OF((int argc, char *argv[]));

/* ===========================================================================
 * Display error message and exit
 */
void error(msg)
    const char *msg;
{
    fprintf(stderr, "%s: %s\n", prog, msg);
    exit(1);
}

/* ===========================================================================
 * Compress input to output then close both files.
 */

void gz_compress(in, out)
    FILE   *in;
    gzFile out;
{
    local char buf[BUFLEN];
    int len;
    int err;

#ifdef USE_MMAP
    /* Try first compressing with mmap. If mmap fails (minigzip used in a
     * pipe), use the normal fread loop.
     */
    if (gz_compress_mmap(in, out) == Z_OK) return;
#endif
    for (;;) {
        len = fread(buf, 1, sizeof(buf), in);
        if (ferror(in)) {
            perror("fread");
            exit(1);
        }
        if (len == 0) break;

        if (gzwrite(out, buf, (unsigned)len) != len) error(gzerror(out, &err));
    }
    fclose(in);
    if (gzclose(out) != Z_OK) error("failed gzclose");
}

#ifdef USE_MMAP /* MMAP version, Miguel Albrecht <malbrech@eso.org> */

/* Try compressing the input file at once using mmap. Return Z_OK if
 * if success, Z_ERRNO otherwise.
 */
int gz_compress_mmap(in, out)
    FILE   *in;
    gzFile out;
{
    int len;
    int err;
    int ifd = fileno(in);
    caddr_t buf;    /* mmap'ed buffer for the entire input file */
    off_t buf_len;  /* length of the input file */
    struct stat sb;

    /* Determine the size of the file, needed for mmap: */
    if (fstat(ifd, &sb) < 0) return Z_ERRNO;
    buf_len = sb.st_size;
    if (buf_len <= 0) return Z_ERRNO;

    /* Now do the actual mmap: */
    buf = mmap((caddr_t) 0, buf_len, PROT_READ, MAP_SHARED, ifd, (off_t)0); 
    if (buf == (caddr_t)(-1)) return Z_ERRNO;

    /* Compress the whole file at once: */
    len = gzwrite(out, (char *)buf, (unsigned)buf_len);

    if (len != (int)buf_len) error(gzerror(out, &err));

    munmap(buf, buf_len);
    fclose(in);
    if (gzclose(out) != Z_OK) error("failed gzclose");
    return Z_OK;
}
#endif /* USE_MMAP */

/* ===========================================================================
 * Uncompress input to output then close both files.
 */
void gz_uncompress(in, out)
    gzFile in;
    FILE   *out;
{
    local char buf[BUFLEN];
    int len;
    int err;

    for (;;) {
        len = gzread(in, buf, sizeof(buf));
        if (len < 0) error (gzerror(in, &err));
        if (len == 0) break;

        if ((int)fwrite(buf, 1, (unsigned)len, out) != len) {
	    error("failed fwrite");
	}
    }
    if (fclose(out)) error("failed fclose");

    if (gzclose(in) != Z_OK) error("failed gzclose");
}


/* ===========================================================================
 * Compress the given file: create a corresponding .gz file and remove the
 * original.
 */
void file_compress(file, mode)
    char  *file;
    char  *mode;
{
    local char outfile[MAX_NAME_LEN];
    FILE  *in;
    gzFile out;

    strcpy(outfile, file);
    strcat(outfile, GZ_SUFFIX);

    in = fopen(file, "rb");
    if (in == NULL) {
        perror(file);
        exit(1);
    }
    out = gzopen(outfile, mode);
    if (out == NULL) {
        fprintf(stderr, "%s: can't gzopen %s\n", prog, outfile);
        exit(1);
    }
    gz_compress(in, out);

    unlink(file);
}


/* ===========================================================================
 * Uncompress the given file and remove the original.
 */
void file_uncompress(file)
    char  *file;
{
    local char buf[MAX_NAME_LEN];
    char *infile, *outfile;
    FILE  *out;
    gzFile in;
    int len = strlen(file);

    strcpy(buf, file);

    if (len > SUFFIX_LEN && strcmp(file+len-SUFFIX_LEN, GZ_SUFFIX) == 0) {
        infile = file;
        outfile = buf;
        outfile[len-3] = '\0';
    } else {
        outfile = file;
        infile = buf;
        strcat(infile, GZ_SUFFIX);
    }
    in = gzopen(infile, "rb");
    if (in == NULL) {
        fprintf(stderr, "%s: can't gzopen %s\n", prog, infile);
        exit(1);
    }
    out = fopen(outfile, "wb");
    if (out == NULL) {
        perror(file);
        exit(1);
    }

    gz_uncompress(in, out);

    unlink(infile);
}


/* ===========================================================================
 * Usage:  minigzip [-d] [-f] [-h] [-1 to -9] [files...]
 *   -d : decompress
 *   -f : compress with Z_FILTERED
 *   -h : compress with Z_HUFFMAN_ONLY
 *   -1 to -9 : compression level
 */

int main(argc, argv)
    int argc;
    char *argv[];
{
    int uncompr = 0;
    gzFile file;
    char outmode[20];

    strcpy(outmode, "wb6 ");

    prog = argv[0];
    argc--, argv++;

    while (argc > 0) {
      if (strcmp(*argv, "-d") == 0)
	uncompr = 1;
      else if (strcmp(*argv, "-f") == 0)
	outmode[3] = 'f';
      else if (strcmp(*argv, "-h") == 0)
	outmode[3] = 'h';
      else if ((*argv)[0] == '-' && (*argv)[1] >= '1' && (*argv)[1] <= '9' &&
	       (*argv)[2] == 0)
	outmode[2] = (*argv)[1];
      else
	break;
      argc--, argv++;
    }
    if (argc == 0) {
        SET_BINARY_MODE(stdin);
        SET_BINARY_MODE(stdout);
        if (uncompr) {
            file = gzdopen(fileno(stdin), "rb");
            if (file == NULL) error("can't gzdopen stdin");
            gz_uncompress(file, stdout);
        } else {
            file = gzdopen(fileno(stdout), outmode);
            if (file == NULL) error("can't gzdopen stdout");
            gz_compress(stdin, file);
        }
    } else {
        do {
            if (uncompr) {
                file_uncompress(*argv);
            } else {
                file_compress(*argv, outmode);
            }
        } while (argv++, --argc);
    }
    exit(0);
    return 0; /* to avoid warning */
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\sources.inc ===
TARGETPATH=obj
TARGETTYPE=LIBRARY

USE_MSVCRT=1

C_DEFINES=/DMY_ZCALLOC

SOURCES= \
    ..\adler32.c \
    ..\compress.c \
    ..\crc32.c \
    ..\deflate.c \
    ..\gzio.c \
    ..\infblock.c \
    ..\infcodes.c \
    ..\inffast.c \
    ..\inflate.c \
    ..\inftrees.c \
    ..\infutil.c \
    ..\trees.c \
    ..\uncompr.c \
    ..\zutil.c \
    ..\default_allocator.c
    
PASS1_PUBLISH= \
    {$(O)\$(TARGETNAME).lib=$(PROJECT_LIB_PATH)\$(TARGETNAME).lib}

!if $(IA64)
# Emit LTCG codegen
LTCG_WKS=1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\trees.h ===
/* header created automatically with -DGEN_TREES_H */

local const ct_data static_ltree[L_CODES+2] = {
{{ 12},{  8}}, {{140},{  8}}, {{ 76},{  8}}, {{204},{  8}}, {{ 44},{  8}},
{{172},{  8}}, {{108},{  8}}, {{236},{  8}}, {{ 28},{  8}}, {{156},{  8}},
{{ 92},{  8}}, {{220},{  8}}, {{ 60},{  8}}, {{188},{  8}}, {{124},{  8}},
{{252},{  8}}, {{  2},{  8}}, {{130},{  8}}, {{ 66},{  8}}, {{194},{  8}},
{{ 34},{  8}}, {{162},{  8}}, {{ 98},{  8}}, {{226},{  8}}, {{ 18},{  8}},
{{146},{  8}}, {{ 82},{  8}}, {{210},{  8}}, {{ 50},{  8}}, {{178},{  8}},
{{114},{  8}}, {{242},{  8}}, {{ 10},{  8}}, {{138},{  8}}, {{ 74},{  8}},
{{202},{  8}}, {{ 42},{  8}}, {{170},{  8}}, {{106},{  8}}, {{234},{  8}},
{{ 26},{  8}}, {{154},{  8}}, {{ 90},{  8}}, {{218},{  8}}, {{ 58},{  8}},
{{186},{  8}}, {{122},{  8}}, {{250},{  8}}, {{  6},{  8}}, {{134},{  8}},
{{ 70},{  8}}, {{198},{  8}}, {{ 38},{  8}}, {{166},{  8}}, {{102},{  8}},
{{230},{  8}}, {{ 22},{  8}}, {{150},{  8}}, {{ 86},{  8}}, {{214},{  8}},
{{ 54},{  8}}, {{182},{  8}}, {{118},{  8}}, {{246},{  8}}, {{ 14},{  8}},
{{142},{  8}}, {{ 78},{  8}}, {{206},{  8}}, {{ 46},{  8}}, {{174},{  8}},
{{110},{  8}}, {{238},{  8}}, {{ 30},{  8}}, {{158},{  8}}, {{ 94},{  8}},
{{222},{  8}}, {{ 62},{  8}}, {{190},{  8}}, {{126},{  8}}, {{254},{  8}},
{{  1},{  8}}, {{129},{  8}}, {{ 65},{  8}}, {{193},{  8}}, {{ 33},{  8}},
{{161},{  8}}, {{ 97},{  8}}, {{225},{  8}}, {{ 17},{  8}}, {{145},{  8}},
{{ 81},{  8}}, {{209},{  8}}, {{ 49},{  8}}, {{177},{  8}}, {{113},{  8}},
{{241},{  8}}, {{  9},{  8}}, {{137},{  8}}, {{ 73},{  8}}, {{201},{  8}},
{{ 41},{  8}}, {{169},{  8}}, {{105},{  8}}, {{233},{  8}}, {{ 25},{  8}},
{{153},{  8}}, {{ 89},{  8}}, {{217},{  8}}, {{ 57},{  8}}, {{185},{  8}},
{{121},{  8}}, {{249},{  8}}, {{  5},{  8}}, {{133},{  8}}, {{ 69},{  8}},
{{197},{  8}}, {{ 37},{  8}}, {{165},{  8}}, {{101},{  8}}, {{229},{  8}},
{{ 21},{  8}}, {{149},{  8}}, {{ 85},{  8}}, {{213},{  8}}, {{ 53},{  8}},
{{181},{  8}}, {{117},{  8}}, {{245},{  8}}, {{ 13},{  8}}, {{141},{  8}},
{{ 77},{  8}}, {{205},{  8}}, {{ 45},{  8}}, {{173},{  8}}, {{109},{  8}},
{{237},{  8}}, {{ 29},{  8}}, {{157},{  8}}, {{ 93},{  8}}, {{221},{  8}},
{{ 61},{  8}}, {{189},{  8}}, {{125},{  8}}, {{253},{  8}}, {{ 19},{  9}},
{{275},{  9}}, {{147},{  9}}, {{403},{  9}}, {{ 83},{  9}}, {{339},{  9}},
{{211},{  9}}, {{467},{  9}}, {{ 51},{  9}}, {{307},{  9}}, {{179},{  9}},
{{435},{  9}}, {{115},{  9}}, {{371},{  9}}, {{243},{  9}}, {{499},{  9}},
{{ 11},{  9}}, {{267},{  9}}, {{139},{  9}}, {{395},{  9}}, {{ 75},{  9}},
{{331},{  9}}, {{203},{  9}}, {{459},{  9}}, {{ 43},{  9}}, {{299},{  9}},
{{171},{  9}}, {{427},{  9}}, {{107},{  9}}, {{363},{  9}}, {{235},{  9}},
{{491},{  9}}, {{ 27},{  9}}, {{283},{  9}}, {{155},{  9}}, {{411},{  9}},
{{ 91},{  9}}, {{347},{  9}}, {{219},{  9}}, {{475},{  9}}, {{ 59},{  9}},
{{315},{  9}}, {{187},{  9}}, {{443},{  9}}, {{123},{  9}}, {{379},{  9}},
{{251},{  9}}, {{507},{  9}}, {{  7},{  9}}, {{263},{  9}}, {{135},{  9}},
{{391},{  9}}, {{ 71},{  9}}, {{327},{  9}}, {{199},{  9}}, {{455},{  9}},
{{ 39},{  9}}, {{295},{  9}}, {{167},{  9}}, {{423},{  9}}, {{103},{  9}},
{{359},{  9}}, {{231},{  9}}, {{487},{  9}}, {{ 23},{  9}}, {{279},{  9}},
{{151},{  9}}, {{407},{  9}}, {{ 87},{  9}}, {{343},{  9}}, {{215},{  9}},
{{471},{  9}}, {{ 55},{  9}}, {{311},{  9}}, {{183},{  9}}, {{439},{  9}},
{{119},{  9}}, {{375},{  9}}, {{247},{  9}}, {{503},{  9}}, {{ 15},{  9}},
{{271},{  9}}, {{143},{  9}}, {{399},{  9}}, {{ 79},{  9}}, {{335},{  9}},
{{207},{  9}}, {{463},{  9}}, {{ 47},{  9}}, {{303},{  9}}, {{175},{  9}},
{{431},{  9}}, {{111},{  9}}, {{367},{  9}}, {{239},{  9}}, {{495},{  9}},
{{ 31},{  9}}, {{287},{  9}}, {{159},{  9}}, {{415},{  9}}, {{ 95},{  9}},
{{351},{  9}}, {{223},{  9}}, {{479},{  9}}, {{ 63},{  9}}, {{319},{  9}},
{{191},{  9}}, {{447},{  9}}, {{127},{  9}}, {{383},{  9}}, {{255},{  9}},
{{511},{  9}}, {{  0},{  7}}, {{ 64},{  7}}, {{ 32},{  7}}, {{ 96},{  7}},
{{ 16},{  7}}, {{ 80},{  7}}, {{ 48},{  7}}, {{112},{  7}}, {{  8},{  7}},
{{ 72},{  7}}, {{ 40},{  7}}, {{104},{  7}}, {{ 24},{  7}}, {{ 88},{  7}},
{{ 56},{  7}}, {{120},{  7}}, {{  4},{  7}}, {{ 68},{  7}}, {{ 36},{  7}},
{{100},{  7}}, {{ 20},{  7}}, {{ 84},{  7}}, {{ 52},{  7}}, {{116},{  7}},
{{  3},{  8}}, {{131},{  8}}, {{ 67},{  8}}, {{195},{  8}}, {{ 35},{  8}},
{{163},{  8}}, {{ 99},{  8}}, {{227},{  8}}
};

local const ct_data static_dtree[D_CODES] = {
{{ 0},{ 5}}, {{16},{ 5}}, {{ 8},{ 5}}, {{24},{ 5}}, {{ 4},{ 5}},
{{20},{ 5}}, {{12},{ 5}}, {{28},{ 5}}, {{ 2},{ 5}}, {{18},{ 5}},
{{10},{ 5}}, {{26},{ 5}}, {{ 6},{ 5}}, {{22},{ 5}}, {{14},{ 5}},
{{30},{ 5}}, {{ 1},{ 5}}, {{17},{ 5}}, {{ 9},{ 5}}, {{25},{ 5}},
{{ 5},{ 5}}, {{21},{ 5}}, {{13},{ 5}}, {{29},{ 5}}, {{ 3},{ 5}},
{{19},{ 5}}, {{11},{ 5}}, {{27},{ 5}}, {{ 7},{ 5}}, {{23},{ 5}}
};

const uch _dist_code[DIST_CODE_LEN] = {
 0,  1,  2,  3,  4,  4,  5,  5,  6,  6,  6,  6,  7,  7,  7,  7,  8,  8,  8,  8,
 8,  8,  8,  8,  9,  9,  9,  9,  9,  9,  9,  9, 10, 10, 10, 10, 10, 10, 10, 10,
10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11,
11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12,
12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13,
13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13,
13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14,
14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,
15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15,  0,  0, 16, 17,
18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22,
23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28,
28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29,
29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29
};

const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {
 0,  1,  2,  3,  4,  5,  6,  7,  8,  8,  9,  9, 10, 10, 11, 11, 12, 12, 12, 12,
13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16,
17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19,
19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20,
21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22,
22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23,
23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24,
25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25,
25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26,
26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27,
27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28
};

local const int base_length[LENGTH_CODES] = {
0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56,
64, 80, 96, 112, 128, 160, 192, 224, 0
};

local const int base_dist[D_CODES] = {
    0,     1,     2,     3,     4,     6,     8,    12,    16,    24,
   32,    48,    64,    96,   128,   192,   256,   384,   512,   768,
 1024,  1536,  2048,  3072,  4096,  6144,  8192, 12288, 16384, 24576
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\uncompr.c ===
/* uncompr.c -- decompress a memory buffer
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zlib.h"

/* ===========================================================================
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/
int ZEXPORT uncompress (dest, destLen, source, sourceLen)
    Bytef *dest;
    uLongf *destLen;
    const Bytef *source;
    uLong sourceLen;
{
    z_stream stream;
    int err;

    stream.next_in = (Bytef*)source;
    stream.avail_in = (uInt)sourceLen;
    /* Check for source > 64K on 16-bit machine: */
    if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;

    stream.next_out = dest;
    stream.avail_out = (uInt)*destLen;
    if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;

    stream.zalloc = (alloc_func)0;
    stream.zfree = (free_func)0;

    err = inflateInit(&stream);
    if (err != Z_OK) return err;

    err = inflate(&stream, Z_FINISH);
    if (err != Z_STREAM_END) {
        inflateEnd(&stream);
        return err == Z_OK ? Z_BUF_ERROR : err;
    }
    *destLen = stream.total_out;

    err = inflateEnd(&stream);
    return err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\zlib.h ===
/* zlib.h -- interface of the 'zlib' general purpose compression library
  version 1.1.4, March 11th, 2002

  Copyright (C) 1995-2002 Jean-loup Gailly and Mark Adler

  This software is provided 'as-is', without any express or implied
  warranty.  In no event will the authors be held liable for any damages
  arising from the use of this software.

  Permission is granted to anyone to use this software for any purpose,
  including commercial applications, and to alter it and redistribute it
  freely, subject to the following restrictions:

  1. The origin of this software must not be misrepresented; you must not
     claim that you wrote the original software. If you use this software
     in a product, an acknowledgment in the product documentation would be
     appreciated but is not required.
  2. Altered source versions must be plainly marked as such, and must not be
     misrepresented as being the original software.
  3. This notice may not be removed or altered from any source distribution.

  Jean-loup Gailly        Mark Adler
  jloup@gzip.org          madler@alumni.caltech.edu


  The data format used by the zlib library is described by RFCs (Request for
  Comments) 1950 to 1952 in the files ftp://ds.internic.net/rfc/rfc1950.txt
  (zlib format), rfc1951.txt (deflate format) and rfc1952.txt (gzip format).
*/

#ifndef _ZLIB_H
#define _ZLIB_H

#include "zconf.h"

#ifdef __cplusplus
extern "C" {
#endif

#define ZLIB_VERSION "1.1.4"

/* 
     The 'zlib' compression library provides in-memory compression and
  decompression functions, including integrity checks of the uncompressed
  data.  This version of the library supports only one compression method
  (deflation) but other algorithms will be added later and will have the same
  stream interface.

     Compression can be done in a single step if the buffers are large
  enough (for example if an input file is mmap'ed), or can be done by
  repeated calls of the compression function.  In the latter case, the
  application must provide more input and/or consume the output
  (providing more output space) before each call.

     The library also supports reading and writing files in gzip (.gz) format
  with an interface similar to that of stdio.

     The library does not install any signal handler. The decoder checks
  the consistency of the compressed data, so the library should never
  crash even in case of corrupted input.
*/

typedef voidpf (*alloc_func) OF((voidpf opaque, uInt items, uInt size));
typedef void   (*free_func)  OF((voidpf opaque, voidpf address));

struct internal_state;

typedef struct z_stream_s {
    Bytef    *next_in;  /* next input byte */
    uInt     avail_in;  /* number of bytes available at next_in */
    uLong    total_in;  /* total nb of input bytes read so far */

    Bytef    *next_out; /* next output byte should be put there */
    uInt     avail_out; /* remaining free space at next_out */
    uLong    total_out; /* total nb of bytes output so far */

    char     *msg;      /* last error message, NULL if no error */
    struct internal_state FAR *state; /* not visible by applications */

    alloc_func zalloc;  /* used to allocate the internal state */
    free_func  zfree;   /* used to free the internal state */
    voidpf     opaque;  /* private data object passed to zalloc and zfree */

    int     data_type;  /* best guess about the data type: ascii or binary */
    uLong   adler;      /* adler32 value of the uncompressed data */
    uLong   reserved;   /* reserved for future use */
} z_stream;

typedef z_stream FAR *z_streamp;

/*
   The application must update next_in and avail_in when avail_in has
   dropped to zero. It must update next_out and avail_out when avail_out
   has dropped to zero. The application must initialize zalloc, zfree and
   opaque before calling the init function. All other fields are set by the
   compression library and must not be updated by the application.

   The opaque value provided by the application will be passed as the first
   parameter for calls of zalloc and zfree. This can be useful for custom
   memory management. The compression library attaches no meaning to the
   opaque value.

   zalloc must return Z_NULL if there is not enough memory for the object.
   If zlib is used in a multi-threaded application, zalloc and zfree must be
   thread safe.

   On 16-bit systems, the functions zalloc and zfree must be able to allocate
   exactly 65536 bytes, but will not be required to allocate more than this
   if the symbol MAXSEG_64K is defined (see zconf.h). WARNING: On MSDOS,
   pointers returned by zalloc for objects of exactly 65536 bytes *must*
   have their offset normalized to zero. The default allocation function
   provided by this library ensures this (see zutil.c). To reduce memory
   requirements and avoid any allocation of 64K objects, at the expense of
   compression ratio, compile the library with -DMAX_WBITS=14 (see zconf.h).

   The fields total_in and total_out can be used for statistics or
   progress reports. After compression, total_in holds the total size of
   the uncompressed data and may be saved for use in the decompressor
   (particularly if the decompressor wants to decompress everything in
   a single step).
*/

                        /* constants */

#define Z_NO_FLUSH      0
#define Z_PARTIAL_FLUSH 1 /* will be removed, use Z_SYNC_FLUSH instead */
#define Z_SYNC_FLUSH    2
#define Z_FULL_FLUSH    3
#define Z_FINISH        4
/* Allowed flush values; see deflate() below for details */

#define Z_OK            0
#define Z_STREAM_END    1
#define Z_NEED_DICT     2
#define Z_ERRNO        (-1)
#define Z_STREAM_ERROR (-2)
#define Z_DATA_ERROR   (-3)
#define Z_MEM_ERROR    (-4)
#define Z_BUF_ERROR    (-5)
#define Z_VERSION_ERROR (-6)
/* Return codes for the compression/decompression functions. Negative
 * values are errors, positive values are used for special but normal events.
 */

#define Z_NO_COMPRESSION         0
#define Z_BEST_SPEED             1
#define Z_BEST_COMPRESSION       9
#define Z_DEFAULT_COMPRESSION  (-1)
/* compression levels */

#define Z_FILTERED            1
#define Z_HUFFMAN_ONLY        2
#define Z_DEFAULT_STRATEGY    0
/* compression strategy; see deflateInit2() below for details */

#define Z_BINARY   0
#define Z_ASCII    1
#define Z_UNKNOWN  2
/* Possible values of the data_type field */

#define Z_DEFLATED   8
/* The deflate compression method (the only one supported in this version) */

#define Z_NULL  0  /* for initializing zalloc, zfree, opaque */

#define zlib_version zlibVersion()
/* for compatibility with versions < 1.0.2 */

                        /* basic functions */

ZEXTERN const char * ZEXPORT zlibVersion OF((void));
/* The application can compare zlibVersion and ZLIB_VERSION for consistency.
   If the first character differs, the library code actually used is
   not compatible with the zlib.h header file used by the application.
   This check is automatically made by deflateInit and inflateInit.
 */

/* 
ZEXTERN int ZEXPORT deflateInit OF((z_streamp strm, int level));

     Initializes the internal stream state for compression. The fields
   zalloc, zfree and opaque must be initialized before by the caller.
   If zalloc and zfree are set to Z_NULL, deflateInit updates them to
   use default allocation functions.

     The compression level must be Z_DEFAULT_COMPRESSION, or between 0 and 9:
   1 gives best speed, 9 gives best compression, 0 gives no compression at
   all (the input data is simply copied a block at a time).
   Z_DEFAULT_COMPRESSION requests a default compromise between speed and
   compression (currently equivalent to level 6).

     deflateInit returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if level is not a valid compression level,
   Z_VERSION_ERROR if the zlib library version (zlib_version) is incompatible
   with the version assumed by the caller (ZLIB_VERSION).
   msg is set to null if there is no error message.  deflateInit does not
   perform any compression: this will be done by deflate().
*/


ZEXTERN int ZEXPORT deflate OF((z_streamp strm, int flush));
/*
    deflate compresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may introduce some
  output latency (reading input without producing any output) except when
  forced to flush.

    The detailed semantics are as follows. deflate performs one or both of the
  following actions:

  - Compress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in and avail_in are updated and
    processing will resume at this point for the next call of deflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly. This action is forced if the parameter flush is non zero.
    Forcing flush frequently degrades the compression ratio, so this parameter
    should be set only when necessary (in interactive applications).
    Some output may be provided even if flush is not set.

  Before the call of deflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating avail_in or avail_out accordingly; avail_out
  should never be zero before the call. The application can consume the
  compressed output when it wants, for example when the output buffer is full
  (avail_out == 0), or after each call of deflate(). If deflate returns Z_OK
  and with zero avail_out, it must be called again after making room in the
  output buffer because there might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, all pending output is
  flushed to the output buffer and the output is aligned on a byte boundary, so
  that the decompressor can get all input data available so far. (In particular
  avail_in is zero after the call if enough output space has been provided
  before the call.)  Flushing may degrade compression for some compression
  algorithms and so it should be used only when necessary.

    If flush is set to Z_FULL_FLUSH, all output is flushed as with
  Z_SYNC_FLUSH, and the compression state is reset so that decompression can
  restart from this point if previous compressed data has been damaged or if
  random access is desired. Using Z_FULL_FLUSH too often can seriously degrade
  the compression.

    If deflate returns with avail_out == 0, this function must be called again
  with the same value of the flush parameter and more output space (updated
  avail_out), until the flush is complete (deflate returns with non-zero
  avail_out).

    If the parameter flush is set to Z_FINISH, pending input is processed,
  pending output is flushed and deflate returns with Z_STREAM_END if there
  was enough output space; if deflate returns with Z_OK, this function must be
  called again with Z_FINISH and more output space (updated avail_out) but no
  more input data, until it returns with Z_STREAM_END or an error. After
  deflate has returned Z_STREAM_END, the only possible operations on the
  stream are deflateReset or deflateEnd.
  
    Z_FINISH can be used immediately after deflateInit if all the compression
  is to be done in a single step. In this case, avail_out must be at least
  0.1% larger than avail_in plus 12 bytes.  If deflate does not return
  Z_STREAM_END, then it must be called again as described above.

    deflate() sets strm->adler to the adler32 checksum of all input read
  so far (that is, total_in bytes).

    deflate() may update data_type if it can make a good guess about
  the input data type (Z_ASCII or Z_BINARY). In doubt, the data is considered
  binary. This field is only for information purposes and does not affect
  the compression algorithm in any manner.

    deflate() returns Z_OK if some progress has been made (more input
  processed or more output produced), Z_STREAM_END if all input has been
  consumed and all output has been produced (only when flush is set to
  Z_FINISH), Z_STREAM_ERROR if the stream state was inconsistent (for example
  if next_in or next_out was NULL), Z_BUF_ERROR if no progress is possible
  (for example avail_in or avail_out was zero).
*/


ZEXTERN int ZEXPORT deflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     deflateEnd returns Z_OK if success, Z_STREAM_ERROR if the
   stream state was inconsistent, Z_DATA_ERROR if the stream was freed
   prematurely (some input or output was discarded). In the error case,
   msg may be set but then points to a static string (which must not be
   deallocated).
*/


/* 
ZEXTERN int ZEXPORT inflateInit OF((z_streamp strm));

     Initializes the internal stream state for decompression. The fields
   next_in, avail_in, zalloc, zfree and opaque must be initialized before by
   the caller. If next_in is not Z_NULL and avail_in is large enough (the exact
   value depends on the compression method), inflateInit determines the
   compression method from the zlib header and allocates all data structures
   accordingly; otherwise the allocation will be deferred to the first call of
   inflate.  If zalloc and zfree are set to Z_NULL, inflateInit updates them to
   use default allocation functions.

     inflateInit returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_VERSION_ERROR if the zlib library version is incompatible with the
   version assumed by the caller.  msg is set to null if there is no error
   message. inflateInit does not perform any decompression apart from reading
   the zlib header if present: this will be done by inflate().  (So next_in and
   avail_in may be modified, but next_out and avail_out are unchanged.)
*/


ZEXTERN int ZEXPORT inflate OF((z_streamp strm, int flush));
/*
    inflate decompresses as much data as possible, and stops when the input
  buffer becomes empty or the output buffer becomes full. It may some
  introduce some output latency (reading input without producing any output)
  except when forced to flush.

  The detailed semantics are as follows. inflate performs one or both of the
  following actions:

  - Decompress more input starting at next_in and update next_in and avail_in
    accordingly. If not all input can be processed (because there is not
    enough room in the output buffer), next_in is updated and processing
    will resume at this point for the next call of inflate().

  - Provide more output starting at next_out and update next_out and avail_out
    accordingly.  inflate() provides as much output as possible, until there
    is no more input data or no more space in the output buffer (see below
    about the flush parameter).

  Before the call of inflate(), the application should ensure that at least
  one of the actions is possible, by providing more input and/or consuming
  more output, and updating the next_* and avail_* values accordingly.
  The application can consume the uncompressed output when it wants, for
  example when the output buffer is full (avail_out == 0), or after each
  call of inflate(). If inflate returns Z_OK and with zero avail_out, it
  must be called again after making room in the output buffer because there
  might be more output pending.

    If the parameter flush is set to Z_SYNC_FLUSH, inflate flushes as much
  output as possible to the output buffer. The flushing behavior of inflate is
  not specified for values of the flush parameter other than Z_SYNC_FLUSH
  and Z_FINISH, but the current implementation actually flushes as much output
  as possible anyway.

    inflate() should normally be called until it returns Z_STREAM_END or an
  error. However if all decompression is to be performed in a single step
  (a single call of inflate), the parameter flush should be set to
  Z_FINISH. In this case all pending input is processed and all pending
  output is flushed; avail_out must be large enough to hold all the
  uncompressed data. (The size of the uncompressed data may have been saved
  by the compressor for this purpose.) The next operation on this stream must
  be inflateEnd to deallocate the decompression state. The use of Z_FINISH
  is never required, but can be used to inform inflate that a faster routine
  may be used for the single inflate() call.

     If a preset dictionary is needed at this point (see inflateSetDictionary
  below), inflate sets strm-adler to the adler32 checksum of the
  dictionary chosen by the compressor and returns Z_NEED_DICT; otherwise 
  it sets strm->adler to the adler32 checksum of all output produced
  so far (that is, total_out bytes) and returns Z_OK, Z_STREAM_END or
  an error code as described below. At the end of the stream, inflate()
  checks that its computed adler32 checksum is equal to that saved by the
  compressor and returns Z_STREAM_END only if the checksum is correct.

    inflate() returns Z_OK if some progress has been made (more input processed
  or more output produced), Z_STREAM_END if the end of the compressed data has
  been reached and all uncompressed output has been produced, Z_NEED_DICT if a
  preset dictionary is needed at this point, Z_DATA_ERROR if the input data was
  corrupted (input stream not conforming to the zlib format or incorrect
  adler32 checksum), Z_STREAM_ERROR if the stream structure was inconsistent
  (for example if next_in or next_out was NULL), Z_MEM_ERROR if there was not
  enough memory, Z_BUF_ERROR if no progress is possible or if there was not
  enough room in the output buffer when Z_FINISH is used. In the Z_DATA_ERROR
  case, the application may then call inflateSync to look for a good
  compression block.
*/


ZEXTERN int ZEXPORT inflateEnd OF((z_streamp strm));
/*
     All dynamically allocated data structures for this stream are freed.
   This function discards any unprocessed input and does not flush any
   pending output.

     inflateEnd returns Z_OK if success, Z_STREAM_ERROR if the stream state
   was inconsistent. In the error case, msg may be set but then points to a
   static string (which must not be deallocated).
*/

                        /* Advanced functions */

/*
    The following functions are needed only in some special applications.
*/

/*   
ZEXTERN int ZEXPORT deflateInit2 OF((z_streamp strm,
                                     int  level,
                                     int  method,
                                     int  windowBits,
                                     int  memLevel,
                                     int  strategy));

     This is another version of deflateInit with more compression options. The
   fields next_in, zalloc, zfree and opaque must be initialized before by
   the caller.

     The method parameter is the compression method. It must be Z_DEFLATED in
   this version of the library.

     The windowBits parameter is the base two logarithm of the window size
   (the size of the history buffer).  It should be in the range 8..15 for this
   version of the library. Larger values of this parameter result in better
   compression at the expense of memory usage. The default value is 15 if
   deflateInit is used instead.

     The memLevel parameter specifies how much memory should be allocated
   for the internal compression state. memLevel=1 uses minimum memory but
   is slow and reduces compression ratio; memLevel=9 uses maximum memory
   for optimal speed. The default value is 8. See zconf.h for total memory
   usage as a function of windowBits and memLevel.

     The strategy parameter is used to tune the compression algorithm. Use the
   value Z_DEFAULT_STRATEGY for normal data, Z_FILTERED for data produced by a
   filter (or predictor), or Z_HUFFMAN_ONLY to force Huffman encoding only (no
   string match).  Filtered data consists mostly of small values with a
   somewhat random distribution. In this case, the compression algorithm is
   tuned to compress them better. The effect of Z_FILTERED is to force more
   Huffman coding and less string matching; it is somewhat intermediate
   between Z_DEFAULT and Z_HUFFMAN_ONLY. The strategy parameter only affects
   the compression ratio but not the correctness of the compressed output even
   if it is not set appropriately.

      deflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as an invalid
   method). msg is set to null if there is no error message.  deflateInit2 does
   not perform any compression: this will be done by deflate().
*/
                            
ZEXTERN int ZEXPORT deflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the compression dictionary from the given byte sequence
   without producing any compressed output. This function must be called
   immediately after deflateInit, deflateInit2 or deflateReset, before any
   call of deflate. The compressor and decompressor must use exactly the same
   dictionary (see inflateSetDictionary).

     The dictionary should consist of strings (byte sequences) that are likely
   to be encountered later in the data to be compressed, with the most commonly
   used strings preferably put towards the end of the dictionary. Using a
   dictionary is most useful when the data to be compressed is short and can be
   predicted with good accuracy; the data can then be compressed better than
   with the default empty dictionary.

     Depending on the size of the compression data structures selected by
   deflateInit or deflateInit2, a part of the dictionary may in effect be
   discarded, for example if the dictionary is larger than the window size in
   deflate or deflate2. Thus the strings most likely to be useful should be
   put at the end of the dictionary, not at the front.

     Upon return of this function, strm->adler is set to the Adler32 value
   of the dictionary; the decompressor may later use this value to determine
   which dictionary has been used by the compressor. (The Adler32 value
   applies to the whole dictionary even if only a subset of the dictionary is
   actually used by the compressor.)

     deflateSetDictionary returns Z_OK if success, or Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent (for example if deflate has already been called for this stream
   or if the compression method is bsort). deflateSetDictionary does not
   perform any compression: this will be done by deflate().
*/

ZEXTERN int ZEXPORT deflateCopy OF((z_streamp dest,
                                    z_streamp source));
/*
     Sets the destination stream as a complete copy of the source stream.

     This function can be useful when several compression strategies will be
   tried, for example when there are several ways of pre-processing the input
   data with a filter. The streams that will be discarded should then be freed
   by calling deflateEnd.  Note that deflateCopy duplicates the internal
   compression state which can be quite large, so this strategy is slow and
   can consume lots of memory.

     deflateCopy returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_STREAM_ERROR if the source stream state was inconsistent
   (such as zalloc being NULL). msg is left unchanged in both source and
   destination.
*/

ZEXTERN int ZEXPORT deflateReset OF((z_streamp strm));
/*
     This function is equivalent to deflateEnd followed by deflateInit,
   but does not free and reallocate all the internal compression state.
   The stream will keep the same compression level and any other attributes
   that may have been set by deflateInit2.

      deflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/

ZEXTERN int ZEXPORT deflateParams OF((z_streamp strm,
				      int level,
				      int strategy));
/*
     Dynamically update the compression level and compression strategy.  The
   interpretation of level and strategy is as in deflateInit2.  This can be
   used to switch between compression and straight copy of the input data, or
   to switch to a different kind of input data requiring a different
   strategy. If the compression level is changed, the input available so far
   is compressed with the old level (and may be flushed); the new level will
   take effect only at the next call of deflate().

     Before the call of deflateParams, the stream state must be set as for
   a call of deflate(), since the currently available input may have to
   be compressed and flushed. In particular, strm->avail_out must be non-zero.

     deflateParams returns Z_OK if success, Z_STREAM_ERROR if the source
   stream state was inconsistent or if a parameter was invalid, Z_BUF_ERROR
   if strm->avail_out was zero.
*/

/*   
ZEXTERN int ZEXPORT inflateInit2 OF((z_streamp strm,
                                     int  windowBits));

     This is another version of inflateInit with an extra parameter. The
   fields next_in, avail_in, zalloc, zfree and opaque must be initialized
   before by the caller.

     The windowBits parameter is the base two logarithm of the maximum window
   size (the size of the history buffer).  It should be in the range 8..15 for
   this version of the library. The default value is 15 if inflateInit is used
   instead. If a compressed stream with a larger window size is given as
   input, inflate() will return with the error code Z_DATA_ERROR instead of
   trying to allocate a larger window.

      inflateInit2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_STREAM_ERROR if a parameter is invalid (such as a negative
   memLevel). msg is set to null if there is no error message.  inflateInit2
   does not perform any decompression apart from reading the zlib header if
   present: this will be done by inflate(). (So next_in and avail_in may be
   modified, but next_out and avail_out are unchanged.)
*/

ZEXTERN int ZEXPORT inflateSetDictionary OF((z_streamp strm,
                                             const Bytef *dictionary,
                                             uInt  dictLength));
/*
     Initializes the decompression dictionary from the given uncompressed byte
   sequence. This function must be called immediately after a call of inflate
   if this call returned Z_NEED_DICT. The dictionary chosen by the compressor
   can be determined from the Adler32 value returned by this call of
   inflate. The compressor and decompressor must use exactly the same
   dictionary (see deflateSetDictionary).

     inflateSetDictionary returns Z_OK if success, Z_STREAM_ERROR if a
   parameter is invalid (such as NULL dictionary) or the stream state is
   inconsistent, Z_DATA_ERROR if the given dictionary doesn't match the
   expected one (incorrect Adler32 value). inflateSetDictionary does not
   perform any decompression: this will be done by subsequent calls of
   inflate().
*/

ZEXTERN int ZEXPORT inflateSync OF((z_streamp strm));
/* 
    Skips invalid compressed data until a full flush point (see above the
  description of deflate with Z_FULL_FLUSH) can be found, or until all
  available input is skipped. No output is provided.

    inflateSync returns Z_OK if a full flush point has been found, Z_BUF_ERROR
  if no more input was provided, Z_DATA_ERROR if no flush point has been found,
  or Z_STREAM_ERROR if the stream structure was inconsistent. In the success
  case, the application may save the current current value of total_in which
  indicates where valid compressed data was found. In the error case, the
  application may repeatedly call inflateSync, providing more input each time,
  until success or end of the input data.
*/

ZEXTERN int ZEXPORT inflateReset OF((z_streamp strm));
/*
     This function is equivalent to inflateEnd followed by inflateInit,
   but does not free and reallocate all the internal decompression state.
   The stream will keep attributes that may have been set by inflateInit2.

      inflateReset returns Z_OK if success, or Z_STREAM_ERROR if the source
   stream state was inconsistent (such as zalloc or state being NULL).
*/


                        /* utility functions */

/*
     The following utility functions are implemented on top of the
   basic stream-oriented functions. To simplify the interface, some
   default options are assumed (compression level and memory usage,
   standard memory allocation functions). The source code of these
   utility functions can easily be modified if you need special options.
*/

ZEXTERN int ZEXPORT compress OF((Bytef *dest,   uLongf *destLen,
                                 const Bytef *source, uLong sourceLen));
/*
     Compresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be at least 0.1% larger than
   sourceLen plus 12 bytes. Upon exit, destLen is the actual size of the
   compressed buffer.
     This function can be used to compress a whole file at once if the
   input file is mmap'ed.
     compress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer.
*/

ZEXTERN int ZEXPORT compress2 OF((Bytef *dest,   uLongf *destLen,
                                  const Bytef *source, uLong sourceLen,
                                  int level));
/*
     Compresses the source buffer into the destination buffer. The level
   parameter has the same meaning as in deflateInit.  sourceLen is the byte
   length of the source buffer. Upon entry, destLen is the total size of the
   destination buffer, which must be at least 0.1% larger than sourceLen plus
   12 bytes. Upon exit, destLen is the actual size of the compressed buffer.

     compress2 returns Z_OK if success, Z_MEM_ERROR if there was not enough
   memory, Z_BUF_ERROR if there was not enough room in the output buffer,
   Z_STREAM_ERROR if the level parameter is invalid.
*/

ZEXTERN int ZEXPORT uncompress OF((Bytef *dest,   uLongf *destLen,
                                   const Bytef *source, uLong sourceLen));
/*
     Decompresses the source buffer into the destination buffer.  sourceLen is
   the byte length of the source buffer. Upon entry, destLen is the total
   size of the destination buffer, which must be large enough to hold the
   entire uncompressed data. (The size of the uncompressed data must have
   been saved previously by the compressor and transmitted to the decompressor
   by some mechanism outside the scope of this compression library.)
   Upon exit, destLen is the actual size of the compressed buffer.
     This function can be used to decompress a whole file at once if the
   input file is mmap'ed.

     uncompress returns Z_OK if success, Z_MEM_ERROR if there was not
   enough memory, Z_BUF_ERROR if there was not enough room in the output
   buffer, or Z_DATA_ERROR if the input data was corrupted.
*/


typedef voidp gzFile;

ZEXTERN gzFile ZEXPORT gzopen  OF((const char *path, const char *mode));
/*
     Opens a gzip (.gz) file for reading or writing. The mode parameter
   is as in fopen ("rb" or "wb") but can also include a compression level
   ("wb9") or a strategy: 'f' for filtered data as in "wb6f", 'h' for
   Huffman only compression as in "wb1h". (See the description
   of deflateInit2 for more information about the strategy parameter.)

     gzopen can be used to read a file which is not in gzip format; in this
   case gzread will directly read from the file without decompression.

     gzopen returns NULL if the file could not be opened or if there was
   insufficient memory to allocate the (de)compression state; errno
   can be checked to distinguish the two cases (if errno is zero, the
   zlib error is Z_MEM_ERROR).  */

ZEXTERN gzFile ZEXPORT gzdopen  OF((int fd, const char *mode));
/*
     gzdopen() associates a gzFile with the file descriptor fd.  File
   descriptors are obtained from calls like open, dup, creat, pipe or
   fileno (in the file has been previously opened with fopen).
   The mode parameter is as in gzopen.
     The next call of gzclose on the returned gzFile will also close the
   file descriptor fd, just like fclose(fdopen(fd), mode) closes the file
   descriptor fd. If you want to keep fd open, use gzdopen(dup(fd), mode).
     gzdopen returns NULL if there was insufficient memory to allocate
   the (de)compression state.
*/

ZEXTERN int ZEXPORT gzsetparams OF((gzFile file, int level, int strategy));
/*
     Dynamically update the compression level or strategy. See the description
   of deflateInit2 for the meaning of these parameters.
     gzsetparams returns Z_OK if success, or Z_STREAM_ERROR if the file was not
   opened for writing.
*/

ZEXTERN int ZEXPORT    gzread  OF((gzFile file, voidp buf, unsigned len));
/*
     Reads the given number of uncompressed bytes from the compressed file.
   If the input file was not in gzip format, gzread copies the given number
   of bytes into the buffer.
     gzread returns the number of uncompressed bytes actually read (0 for
   end of file, -1 for error). */

ZEXTERN int ZEXPORT    gzwrite OF((gzFile file, 
				   const voidp buf, unsigned len));
/*
     Writes the given number of uncompressed bytes into the compressed file.
   gzwrite returns the number of uncompressed bytes actually written
   (0 in case of error).
*/

ZEXTERN int ZEXPORTVA   gzprintf OF((gzFile file, const char *format, ...));
/*
     Converts, formats, and writes the args to the compressed file under
   control of the format string, as in fprintf. gzprintf returns the number of
   uncompressed bytes actually written (0 in case of error).
*/

ZEXTERN int ZEXPORT gzputs OF((gzFile file, const char *s));
/*
      Writes the given null-terminated string to the compressed file, excluding
   the terminating null character.
      gzputs returns the number of characters written, or -1 in case of error.
*/

ZEXTERN char * ZEXPORT gzgets OF((gzFile file, char *buf, int len));
/*
      Reads bytes from the compressed file until len-1 characters are read, or
   a newline character is read and transferred to buf, or an end-of-file
   condition is encountered.  The string is then terminated with a null
   character.
      gzgets returns buf, or Z_NULL in case of error.
*/

ZEXTERN int ZEXPORT    gzputc OF((gzFile file, int c));
/*
      Writes c, converted to an unsigned char, into the compressed file.
   gzputc returns the value that was written, or -1 in case of error.
*/

ZEXTERN int ZEXPORT    gzgetc OF((gzFile file));
/*
      Reads one byte from the compressed file. gzgetc returns this byte
   or -1 in case of end of file or error.
*/

ZEXTERN int ZEXPORT    gzflush OF((gzFile file, int flush));
/*
     Flushes all pending output into the compressed file. The parameter
   flush is as in the deflate() function. The return value is the zlib
   error number (see function gzerror below). gzflush returns Z_OK if
   the flush parameter is Z_FINISH and all output could be flushed.
     gzflush should be called only when strictly necessary because it can
   degrade compression.
*/

ZEXTERN z_off_t ZEXPORT    gzseek OF((gzFile file,
				      z_off_t offset, int whence));
/* 
      Sets the starting position for the next gzread or gzwrite on the
   given compressed file. The offset represents a number of bytes in the
   uncompressed data stream. The whence parameter is defined as in lseek(2);
   the value SEEK_END is not supported.
     If the file is opened for reading, this function is emulated but can be
   extremely slow. If the file is opened for writing, only forward seeks are
   supported; gzseek then compresses a sequence of zeroes up to the new
   starting position.

      gzseek returns the resulting offset location as measured in bytes from
   the beginning of the uncompressed stream, or -1 in case of error, in
   particular if the file is opened for writing and the new starting position
   would be before the current position.
*/

ZEXTERN int ZEXPORT    gzrewind OF((gzFile file));
/*
     Rewinds the given file. This function is supported only for reading.

   gzrewind(file) is equivalent to (int)gzseek(file, 0L, SEEK_SET)
*/

ZEXTERN z_off_t ZEXPORT    gztell OF((gzFile file));
/*
     Returns the starting position for the next gzread or gzwrite on the
   given compressed file. This position represents a number of bytes in the
   uncompressed data stream.

   gztell(file) is equivalent to gzseek(file, 0L, SEEK_CUR)
*/

ZEXTERN int ZEXPORT gzeof OF((gzFile file));
/*
     Returns 1 when EOF has previously been detected reading the given
   input stream, otherwise zero.
*/

ZEXTERN int ZEXPORT    gzclose OF((gzFile file));
/*
     Flushes all pending output if necessary, closes the compressed file
   and deallocates all the (de)compression state. The return value is the zlib
   error number (see function gzerror below).
*/

ZEXTERN const char * ZEXPORT gzerror OF((gzFile file, int *errnum));
/*
     Returns the error message for the last error which occurred on the
   given compressed file. errnum is set to zlib error number. If an
   error occurred in the file system and not in the compression library,
   errnum is set to Z_ERRNO and the application may consult errno
   to get the exact error code.
*/

                        /* checksum functions */

/*
     These functions are not related to compression but are exported
   anyway because they might be useful in applications using the
   compression library.
*/

ZEXTERN uLong ZEXPORT adler32 OF((uLong adler, const Bytef *buf, uInt len));

/*
     Update a running Adler-32 checksum with the bytes buf[0..len-1] and
   return the updated checksum. If buf is NULL, this function returns
   the required initial value for the checksum.
   An Adler-32 checksum is almost as reliable as a CRC32 but can be computed
   much faster. Usage example:

     uLong adler = adler32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       adler = adler32(adler, buffer, length);
     }
     if (adler != original_adler) error();
*/

ZEXTERN uLong ZEXPORT crc32   OF((uLong crc, const Bytef *buf, uInt len));
/*
     Update a running crc with the bytes buf[0..len-1] and return the updated
   crc. If buf is NULL, this function returns the required initial value
   for the crc. Pre- and post-conditioning (one's complement) is performed
   within this function so it shouldn't be done by the application.
   Usage example:

     uLong crc = crc32(0L, Z_NULL, 0);

     while (read_buffer(buffer, length) != EOF) {
       crc = crc32(crc, buffer, length);
     }
     if (crc != original_crc) error();
*/


                        /* various hacks, don't look :) */

/* deflateInit and inflateInit are macros to allow checking the zlib version
 * and the compiler's view of z_stream:
 */
ZEXTERN int ZEXPORT deflateInit_ OF((z_streamp strm, int level,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT inflateInit_ OF((z_streamp strm,
                                     const char *version, int stream_size));
ZEXTERN int ZEXPORT deflateInit2_ OF((z_streamp strm, int  level, int  method,
                                      int windowBits, int memLevel,
                                      int strategy, const char *version,
                                      int stream_size));
ZEXTERN int ZEXPORT inflateInit2_ OF((z_streamp strm, int  windowBits,
                                      const char *version, int stream_size));
#define deflateInit(strm, level) \
        deflateInit_((strm), (level),       ZLIB_VERSION, sizeof(z_stream))
#define inflateInit(strm) \
        inflateInit_((strm),                ZLIB_VERSION, sizeof(z_stream))
#define deflateInit2(strm, level, method, windowBits, memLevel, strategy) \
        deflateInit2_((strm),(level),(method),(windowBits),(memLevel),\
                      (strategy),           ZLIB_VERSION, sizeof(z_stream))
#define inflateInit2(strm, windowBits) \
        inflateInit2_((strm), (windowBits), ZLIB_VERSION, sizeof(z_stream))


#if !defined(_Z_UTIL_H) && !defined(NO_DUMMY_DECL)
    struct internal_state {int dummy;}; /* hack for buggy compilers */
#endif

ZEXTERN const char   * ZEXPORT zError           OF((int err));
ZEXTERN int            ZEXPORT inflateSyncPoint OF((z_streamp z));
ZEXTERN const uLongf * ZEXPORT get_crc_table    OF((void));

#ifdef __cplusplus
}
#endif

#endif /* _ZLIB_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\zutil.h ===
/* zutil.h -- internal interface and configuration of the compression library
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h
 */

/* WARNING: this file should *not* be used by applications. It is
   part of the implementation of the compression library and is
   subject to change. Applications should only use zlib.h.
 */

/* @(#) $Id$ */

#ifndef _Z_UTIL_H
#define _Z_UTIL_H

#include "zlib.h"

#ifdef STDC
#  include <stddef.h>
#  include <string.h>
#  include <stdlib.h>
#endif
#ifdef NO_ERRNO_H
    extern int errno;
#else
#   include <errno.h>
#endif

#ifndef local
#  define local static
#endif
/* compile with -Dlocal if your debugger can't find static symbols */

typedef unsigned char  uch;
typedef uch FAR uchf;
typedef unsigned short ush;
typedef ush FAR ushf;
typedef unsigned long  ulg;

extern const char * const z_errmsg[10]; /* indexed by 2-zlib_error */
/* (size given to avoid silly warnings with Visual C++) */

#define ERR_MSG(err) z_errmsg[Z_NEED_DICT-(err)]

#define ERR_RETURN(strm,err) \
  return (strm->msg = (char*)ERR_MSG(err), (err))
/* To be used only when the state is known to be valid */

        /* common constants */

#ifndef DEF_WBITS
#  define DEF_WBITS MAX_WBITS
#endif
/* default windowBits for decompression. MAX_WBITS is for compression only */

#if MAX_MEM_LEVEL >= 8
#  define DEF_MEM_LEVEL 8
#else
#  define DEF_MEM_LEVEL  MAX_MEM_LEVEL
#endif
/* default memLevel */

#define STORED_BLOCK 0
#define STATIC_TREES 1
#define DYN_TREES    2
/* The three kinds of block type */

#define MIN_MATCH  3
#define MAX_MATCH  258
/* The minimum and maximum match lengths */

#define PRESET_DICT 0x20 /* preset dictionary flag in zlib header */

        /* target dependencies */

#ifdef MSDOS
#  define OS_CODE  0x00
#  if defined(__TURBOC__) || defined(__BORLANDC__)
#    if(__STDC__ == 1) && (defined(__LARGE__) || defined(__COMPACT__))
       /* Allow compilation with ANSI keywords only enabled */
       void _Cdecl farfree( void *block );
       void *_Cdecl farmalloc( unsigned long nbytes );
#    else
#     include <alloc.h>
#    endif
#  else /* MSC or DJGPP */
#    include <malloc.h>
#  endif
#endif

#ifdef OS2
#  define OS_CODE  0x06
#endif

#ifdef WIN32 /* Window 95 & Windows NT */
#  define OS_CODE  0x0b
#endif

#if defined(VAXC) || defined(VMS)
#  define OS_CODE  0x02
#  define F_OPEN(name, mode) \
     fopen((name), (mode), "mbc=60", "ctx=stm", "rfm=fix", "mrs=512")
#endif

#ifdef AMIGA
#  define OS_CODE  0x01
#endif

#if defined(ATARI) || defined(atarist)
#  define OS_CODE  0x05
#endif

#if defined(MACOS) || defined(TARGET_OS_MAC)
#  define OS_CODE  0x07
#  if defined(__MWERKS__) && __dest_os != __be_os && __dest_os != __win32_os
#    include <unix.h> /* for fdopen */
#  else
#    ifndef fdopen
#      define fdopen(fd,mode) NULL /* No fdopen() */
#    endif
#  endif
#endif

#ifdef __50SERIES /* Prime/PRIMOS */
#  define OS_CODE  0x0F
#endif

#ifdef TOPS20
#  define OS_CODE  0x0a
#endif

#if defined(_BEOS_) || defined(RISCOS)
#  define fdopen(fd,mode) NULL /* No fdopen() */
#endif

#if (defined(_MSC_VER) && (_MSC_VER > 600))
#  define fdopen(fd,type)  _fdopen(fd,type)
#endif


        /* Common defaults */

#ifndef OS_CODE
#  define OS_CODE  0x03  /* assume Unix */
#endif

#ifndef F_OPEN
#  define F_OPEN(name, mode) fopen((name), (mode))
#endif

         /* functions */

#ifdef HAVE_STRERROR
   extern char *strerror OF((int));
#  define zstrerror(errnum) strerror(errnum)
#else
#  define zstrerror(errnum) ""
#endif

#if defined(pyr)
#  define NO_MEMCPY
#endif
#if defined(SMALL_MEDIUM) && !defined(_MSC_VER) && !defined(__SC__)
 /* Use our own functions for small and medium model with MSC <= 5.0.
  * You may have to use the same strategy for Borland C (untested).
  * The __SC__ check is for Symantec.
  */
#  define NO_MEMCPY
#endif
#if defined(STDC) && !defined(HAVE_MEMCPY) && !defined(NO_MEMCPY)
#  define HAVE_MEMCPY
#endif
#ifdef HAVE_MEMCPY
#  ifdef SMALL_MEDIUM /* MSDOS small or medium model */
#    define zmemcpy _fmemcpy
#    define zmemcmp _fmemcmp
#    define zmemzero(dest, len) _fmemset(dest, 0, len)
#  else
#    define zmemcpy memcpy
#    define zmemcmp memcmp
#    define zmemzero(dest, len) memset(dest, 0, len)
#  endif
#else
   extern void zmemcpy  OF((Bytef* dest, const Bytef* source, uInt len));
   extern int  zmemcmp  OF((const Bytef* s1, const Bytef* s2, uInt len));
   extern void zmemzero OF((Bytef* dest, uInt len));
#endif

/* Diagnostic functions */
#ifdef DEBUG
#  include <stdio.h>
   extern int z_verbose;
   extern void z_error    OF((char *m));
#  define Assert(cond,msg) {if(!(cond)) z_error(msg);}
#  define Trace(x) {if (z_verbose>=0) fprintf x ;}
#  define Tracev(x) {if (z_verbose>0) fprintf x ;}
#  define Tracevv(x) {if (z_verbose>1) fprintf x ;}
#  define Tracec(c,x) {if (z_verbose>0 && (c)) fprintf x ;}
#  define Tracecv(c,x) {if (z_verbose>1 && (c)) fprintf x ;}
#else
#  define Assert(cond,msg)
#  define Trace(x)
#  define Tracev(x)
#  define Tracevv(x)
#  define Tracec(c,x)
#  define Tracecv(c,x)
#endif


typedef uLong (ZEXPORT *check_func) OF((uLong check, const Bytef *buf,
				       uInt len));
voidpf zcalloc OF((voidpf opaque, unsigned items, unsigned size));
void   zcfree  OF((voidpf opaque, voidpf ptr));

#define ZALLOC(strm, items, size) \
           (*((strm)->zalloc))((strm)->opaque, (items), (size))
#define ZFREE(strm, addr)  (*((strm)->zfree))((strm)->opaque, (voidpf)(addr))
#define TRY_FREE(s, p) {if (p) ZFREE(s, p);}

#endif /* _Z_UTIL_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\trees.c ===
/* trees.c -- output deflated data using Huffman coding
 * Copyright (C) 1995-2002 Jean-loup Gailly
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/*
 *  ALGORITHM
 *
 *      The "deflation" process uses several Huffman trees. The more
 *      common source values are represented by shorter bit sequences.
 *
 *      Each code tree is stored in a compressed form which is itself
 * a Huffman encoding of the lengths of all the code strings (in
 * ascending order by source values).  The actual code strings are
 * reconstructed from the lengths in the inflate process, as described
 * in the deflate specification.
 *
 *  REFERENCES
 *
 *      Deutsch, L.P.,"'Deflate' Compressed Data Format Specification".
 *      Available in ftp.uu.net:/pub/archiving/zip/doc/deflate-1.1.doc
 *
 *      Storer, James A.
 *          Data Compression:  Methods and Theory, pp. 49-50.
 *          Computer Science Press, 1988.  ISBN 0-7167-8156-5.
 *
 *      Sedgewick, R.
 *          Algorithms, p290.
 *          Addison-Wesley, 1983. ISBN 0-201-06672-6.
 */

/* @(#) $Id$ */

/* #define GEN_TREES_H */

#include "deflate.h"

#ifdef DEBUG
#  include <ctype.h>
#endif

/* ===========================================================================
 * Constants
 */

#define MAX_BL_BITS 7
/* Bit length codes must not exceed MAX_BL_BITS bits */

#define END_BLOCK 256
/* end of block literal code */

#define REP_3_6      16
/* repeat previous bit length 3-6 times (2 bits of repeat count) */

#define REPZ_3_10    17
/* repeat a zero length 3-10 times  (3 bits of repeat count) */

#define REPZ_11_138  18
/* repeat a zero length 11-138 times  (7 bits of repeat count) */

local const int extra_lbits[LENGTH_CODES] /* extra bits for each length code */
   = {0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0};

local const int extra_dbits[D_CODES] /* extra bits for each distance code */
   = {0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13};

local const int extra_blbits[BL_CODES]/* extra bits for each bit length code */
   = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7};

local const uch bl_order[BL_CODES]
   = {16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15};
/* The lengths of the bit length codes are sent in order of decreasing
 * probability, to avoid transmitting the lengths for unused bit length codes.
 */

#define Buf_size (8 * 2*sizeof(char))
/* Number of bits used within bi_buf. (bi_buf might be implemented on
 * more than 16 bits on some systems.)
 */

/* ===========================================================================
 * Local data. These are initialized only once.
 */

#define DIST_CODE_LEN  512 /* see definition of array dist_code below */

#if defined(GEN_TREES_H) || !defined(STDC)
/* non ANSI compilers may not accept trees.h */

local ct_data static_ltree[L_CODES+2];
/* The static literal tree. Since the bit lengths are imposed, there is no
 * need for the L_CODES extra codes used during heap construction. However
 * The codes 286 and 287 are needed to build a canonical tree (see _tr_init
 * below).
 */

local ct_data static_dtree[D_CODES];
/* The static distance tree. (Actually a trivial tree since all codes use
 * 5 bits.)
 */

uch _dist_code[DIST_CODE_LEN];
/* Distance codes. The first 256 values correspond to the distances
 * 3 .. 258, the last 256 values correspond to the top 8 bits of
 * the 15 bit distances.
 */

uch _length_code[MAX_MATCH-MIN_MATCH+1];
/* length code for each normalized match length (0 == MIN_MATCH) */

local int base_length[LENGTH_CODES];
/* First normalized length for each code (0 = MIN_MATCH) */

local int base_dist[D_CODES];
/* First normalized distance for each code (0 = distance of 1) */

#else
#  include "trees.h"
#endif /* GEN_TREES_H */

struct static_tree_desc_s {
    const ct_data *static_tree;  /* static tree or NULL */
    const intf *extra_bits;      /* extra bits for each code or NULL */
    int     extra_base;          /* base index for extra_bits */
    int     elems;               /* max number of elements in the tree */
    int     max_length;          /* max bit length for the codes */
};

local static_tree_desc  const static_l_desc =
{static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS};

local static_tree_desc  const static_d_desc =
{static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS};

local static_tree_desc  const static_bl_desc =
{(const ct_data *)0, extra_blbits, 0,   BL_CODES, MAX_BL_BITS};

/* ===========================================================================
 * Local (static) routines in this file.
 */

local void tr_static_init OF((void));
local void init_block     OF((deflate_state *s));
local void pqdownheap     OF((deflate_state *s, ct_data *tree, int k));
local void gen_bitlen     OF((deflate_state *s, tree_desc *desc));
local void gen_codes      OF((ct_data *tree, int max_code, ushf *bl_count));
local void build_tree     OF((deflate_state *s, tree_desc *desc));
local void scan_tree      OF((deflate_state *s, ct_data *tree, int max_code));
local void send_tree      OF((deflate_state *s, ct_data *tree, int max_code));
local int  build_bl_tree  OF((deflate_state *s));
local void send_all_trees OF((deflate_state *s, int lcodes, int dcodes,
                              int blcodes));
local void compress_block OF((deflate_state *s, ct_data *ltree,
                              ct_data *dtree));
local void set_data_type  OF((deflate_state *s));
local unsigned bi_reverse OF((unsigned value, int length));
local void bi_windup      OF((deflate_state *s));
local void bi_flush       OF((deflate_state *s));
local void copy_block     OF((deflate_state *s, charf *buf, unsigned len,
                              int header));

#ifdef GEN_TREES_H
local void gen_trees_header OF((void));
#endif

#ifndef DEBUG
#  define send_code(s, c, tree) send_bits(s, tree[c].Code, tree[c].Len)
   /* Send a code of the given tree. c and tree must not have side effects */

#else /* DEBUG */
#  define send_code(s, c, tree) \
     { if (z_verbose>2) fprintf(stderr,"\ncd %3d ",(c)); \
       send_bits(s, tree[c].Code, tree[c].Len); }
#endif

/* ===========================================================================
 * Output a short LSB first on the stream.
 * IN assertion: there is enough room in pendingBuf.
 */
#define put_short(s, w) { \
    put_byte(s, (uch)((w) & 0xff)); \
    put_byte(s, (uch)((ush)(w) >> 8)); \
}

/* ===========================================================================
 * Send a value on a given number of bits.
 * IN assertion: length <= 16 and value fits in length bits.
 */
#ifdef DEBUG
local void send_bits      OF((deflate_state *s, int value, int length));

local void send_bits(s, value, length)
    deflate_state *s;
    int value;  /* value to send */
    int length; /* number of bits */
{
    Tracevv((stderr," l %2d v %4x ", length, value));
    Assert(length > 0 && length <= 15, "invalid length");
    s->bits_sent += (ulg)length;

    /* If not enough room in bi_buf, use (valid) bits from bi_buf and
     * (16 - bi_valid) bits from value, leaving (width - (16-bi_valid))
     * unused bits in value.
     */
    if (s->bi_valid > (int)Buf_size - length) {
        s->bi_buf |= (value << s->bi_valid);
        put_short(s, s->bi_buf);
        s->bi_buf = (ush)value >> (Buf_size - s->bi_valid);
        s->bi_valid += length - Buf_size;
    } else {
        s->bi_buf |= value << s->bi_valid;
        s->bi_valid += length;
    }
}
#else /* !DEBUG */

#define send_bits(s, value, length) \
{ int len = length;\
  if (s->bi_valid > (int)Buf_size - len) {\
    int val = value;\
    s->bi_buf |= (val << s->bi_valid);\
    put_short(s, s->bi_buf);\
    s->bi_buf = (ush)val >> (Buf_size - s->bi_valid);\
    s->bi_valid += len - Buf_size;\
  } else {\
    s->bi_buf |= (value) << s->bi_valid;\
    s->bi_valid += len;\
  }\
}
#endif /* DEBUG */


#define MAX(a,b) (a >= b ? a : b)
/* the arguments must not have side effects */

/* ===========================================================================
 * Initialize the various 'constant' tables.
 */
local void tr_static_init()
{
#if defined(GEN_TREES_H) || !defined(STDC)
    static int static_init_done = 0;
    int n;        /* iterates over tree elements */
    int bits;     /* bit counter */
    int length;   /* length value */
    int code;     /* code value */
    int dist;     /* distance index */
    ush bl_count[MAX_BITS+1];
    /* number of codes at each bit length for an optimal tree */

    if (static_init_done) return;

    /* For some embedded targets, global variables are not initialized: */
    static_l_desc.static_tree = static_ltree;
    static_l_desc.extra_bits = extra_lbits;
    static_d_desc.static_tree = static_dtree;
    static_d_desc.extra_bits = extra_dbits;
    static_bl_desc.extra_bits = extra_blbits;

    /* Initialize the mapping length (0..255) -> length code (0..28) */
    length = 0;
    for (code = 0; code < LENGTH_CODES-1; code++) {
        base_length[code] = length;
        for (n = 0; n < (1<<extra_lbits[code]); n++) {
            _length_code[length++] = (uch)code;
        }
    }
    Assert (length == 256, "tr_static_init: length != 256");
    /* Note that the length 255 (match length 258) can be represented
     * in two different ways: code 284 + 5 bits or code 285, so we
     * overwrite length_code[255] to use the best encoding:
     */
    _length_code[length-1] = (uch)code;

    /* Initialize the mapping dist (0..32K) -> dist code (0..29) */
    dist = 0;
    for (code = 0 ; code < 16; code++) {
        base_dist[code] = dist;
        for (n = 0; n < (1<<extra_dbits[code]); n++) {
            _dist_code[dist++] = (uch)code;
        }
    }
    Assert (dist == 256, "tr_static_init: dist != 256");
    dist >>= 7; /* from now on, all distances are divided by 128 */
    for ( ; code < D_CODES; code++) {
        base_dist[code] = dist << 7;
        for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {
            _dist_code[256 + dist++] = (uch)code;
        }
    }
    Assert (dist == 256, "tr_static_init: 256+dist != 512");

    /* Construct the codes of the static literal tree */
    for (bits = 0; bits <= MAX_BITS; bits++) bl_count[bits] = 0;
    n = 0;
    while (n <= 143) static_ltree[n++].Len = 8, bl_count[8]++;
    while (n <= 255) static_ltree[n++].Len = 9, bl_count[9]++;
    while (n <= 279) static_ltree[n++].Len = 7, bl_count[7]++;
    while (n <= 287) static_ltree[n++].Len = 8, bl_count[8]++;
    /* Codes 286 and 287 do not exist, but we must include them in the
     * tree construction to get a canonical Huffman tree (longest code
     * all ones)
     */
    gen_codes((ct_data *)static_ltree, L_CODES+1, bl_count);

    /* The static distance tree is trivial: */
    for (n = 0; n < D_CODES; n++) {
        static_dtree[n].Len = 5;
        static_dtree[n].Code = bi_reverse((unsigned)n, 5);
    }
    static_init_done = 1;

#  ifdef GEN_TREES_H
    gen_trees_header();
#  endif
#endif /* defined(GEN_TREES_H) || !defined(STDC) */
}

/* ===========================================================================
 * Genererate the file trees.h describing the static trees.
 */
#ifdef GEN_TREES_H
#  ifndef DEBUG
#    include <stdio.h>
#  endif

#  define SEPARATOR(i, last, width) \
      ((i) == (last)? "\n};\n\n" :    \
       ((i) % (width) == (width)-1 ? ",\n" : ", "))

void gen_trees_header()
{
    FILE *header = fopen("trees.h", "w");
    int i;

    Assert (header != NULL, "Can't open trees.h");
    fprintf(header,
	    "/* header created automatically with -DGEN_TREES_H */\n\n");

    fprintf(header, "local const ct_data static_ltree[L_CODES+2] = {\n");
    for (i = 0; i < L_CODES+2; i++) {
	fprintf(header, "{{%3u},{%3u}}%s", static_ltree[i].Code,
		static_ltree[i].Len, SEPARATOR(i, L_CODES+1, 5));
    }

    fprintf(header, "local const ct_data static_dtree[D_CODES] = {\n");
    for (i = 0; i < D_CODES; i++) {
	fprintf(header, "{{%2u},{%2u}}%s", static_dtree[i].Code,
		static_dtree[i].Len, SEPARATOR(i, D_CODES-1, 5));
    }

    fprintf(header, "const uch _dist_code[DIST_CODE_LEN] = {\n");
    for (i = 0; i < DIST_CODE_LEN; i++) {
	fprintf(header, "%2u%s", _dist_code[i],
		SEPARATOR(i, DIST_CODE_LEN-1, 20));
    }

    fprintf(header, "const uch _length_code[MAX_MATCH-MIN_MATCH+1]= {\n");
    for (i = 0; i < MAX_MATCH-MIN_MATCH+1; i++) {
	fprintf(header, "%2u%s", _length_code[i],
		SEPARATOR(i, MAX_MATCH-MIN_MATCH, 20));
    }

    fprintf(header, "local const int base_length[LENGTH_CODES] = {\n");
    for (i = 0; i < LENGTH_CODES; i++) {
	fprintf(header, "%1u%s", base_length[i],
		SEPARATOR(i, LENGTH_CODES-1, 20));
    }

    fprintf(header, "local const int base_dist[D_CODES] = {\n");
    for (i = 0; i < D_CODES; i++) {
	fprintf(header, "%5u%s", base_dist[i],
		SEPARATOR(i, D_CODES-1, 10));
    }

    fclose(header);
}
#endif /* GEN_TREES_H */

/* ===========================================================================
 * Initialize the tree data structures for a new zlib stream.
 */
void _tr_init(s)
    deflate_state *s;
{
    tr_static_init();

    s->l_desc.dyn_tree = s->dyn_ltree;
    s->l_desc.stat_desc = &static_l_desc;

    s->d_desc.dyn_tree = s->dyn_dtree;
    s->d_desc.stat_desc = &static_d_desc;

    s->bl_desc.dyn_tree = s->bl_tree;
    s->bl_desc.stat_desc = &static_bl_desc;

    s->bi_buf = 0;
    s->bi_valid = 0;
    s->last_eob_len = 8; /* enough lookahead for inflate */
#ifdef DEBUG
    s->compressed_len = 0L;
    s->bits_sent = 0L;
#endif

    /* Initialize the first block of the first file: */
    init_block(s);
}

/* ===========================================================================
 * Initialize a new block.
 */
local void init_block(s)
    deflate_state *s;
{
    int n; /* iterates over tree elements */

    /* Initialize the trees. */
    for (n = 0; n < L_CODES;  n++) s->dyn_ltree[n].Freq = 0;
    for (n = 0; n < D_CODES;  n++) s->dyn_dtree[n].Freq = 0;
    for (n = 0; n < BL_CODES; n++) s->bl_tree[n].Freq = 0;

    s->dyn_ltree[END_BLOCK].Freq = 1;
    s->opt_len = s->static_len = 0L;
    s->last_lit = s->matches = 0;
}

#define SMALLEST 1
/* Index within the heap array of least frequent node in the Huffman tree */


/* ===========================================================================
 * Remove the smallest element from the heap and recreate the heap with
 * one less element. Updates heap and heap_len.
 */
#define pqremove(s, tree, top) \
{\
    top = s->heap[SMALLEST]; \
    s->heap[SMALLEST] = s->heap[s->heap_len--]; \
    pqdownheap(s, tree, SMALLEST); \
}

/* ===========================================================================
 * Compares to subtrees, using the tree depth as tie breaker when
 * the subtrees have equal frequency. This minimizes the worst case length.
 */
#define smaller(tree, n, m, depth) \
   (tree[n].Freq < tree[m].Freq || \
   (tree[n].Freq == tree[m].Freq && depth[n] <= depth[m]))

/* ===========================================================================
 * Restore the heap property by moving down the tree starting at node k,
 * exchanging a node with the smallest of its two sons if necessary, stopping
 * when the heap property is re-established (each father smaller than its
 * two sons).
 */
local void pqdownheap(s, tree, k)
    deflate_state *s;
    ct_data *tree;  /* the tree to restore */
    int k;               /* node to move down */
{
    int v = s->heap[k];
    int j = k << 1;  /* left son of k */
    while (j <= s->heap_len) {
        /* Set j to the smallest of the two sons: */
        if (j < s->heap_len &&
            smaller(tree, s->heap[j+1], s->heap[j], s->depth)) {
            j++;
        }
        /* Exit if v is smaller than both sons */
        if (smaller(tree, v, s->heap[j], s->depth)) break;

        /* Exchange v with the smallest son */
        s->heap[k] = s->heap[j];  k = j;

        /* And continue down the tree, setting j to the left son of k */
        j <<= 1;
    }
    s->heap[k] = v;
}

/* ===========================================================================
 * Compute the optimal bit lengths for a tree and update the total bit length
 * for the current block.
 * IN assertion: the fields freq and dad are set, heap[heap_max] and
 *    above are the tree nodes sorted by increasing frequency.
 * OUT assertions: the field len is set to the optimal bit length, the
 *     array bl_count contains the frequencies for each bit length.
 *     The length opt_len is updated; static_len is also updated if stree is
 *     not null.
 */
local void gen_bitlen(s, desc)
    deflate_state *s;
    tree_desc *desc;    /* the tree descriptor */
{
    ct_data *tree        = desc->dyn_tree;
    int max_code         = desc->max_code;
    const ct_data *stree = desc->stat_desc->static_tree;
    const intf *extra    = desc->stat_desc->extra_bits;
    int base             = desc->stat_desc->extra_base;
    int max_length       = desc->stat_desc->max_length;
    int h;              /* heap index */
    int n, m;           /* iterate over the tree elements */
    int bits;           /* bit length */
    int xbits;          /* extra bits */
    ush f;              /* frequency */
    int overflow = 0;   /* number of elements with bit length too large */

    for (bits = 0; bits <= MAX_BITS; bits++) s->bl_count[bits] = 0;

    /* In a first pass, compute the optimal bit lengths (which may
     * overflow in the case of the bit length tree).
     */
    tree[s->heap[s->heap_max]].Len = 0; /* root of the heap */

    for (h = s->heap_max+1; h < HEAP_SIZE; h++) {
        n = s->heap[h];
        bits = tree[tree[n].Dad].Len + 1;
        if (bits > max_length) bits = max_length, overflow++;
        tree[n].Len = (ush)bits;
        /* We overwrite tree[n].Dad which is no longer needed */

        if (n > max_code) continue; /* not a leaf node */

        s->bl_count[bits]++;
        xbits = 0;
        if (n >= base) xbits = extra[n-base];
        f = tree[n].Freq;
        s->opt_len += (ulg)f * (bits + xbits);
        if (stree) s->static_len += (ulg)f * (stree[n].Len + xbits);
    }
    if (overflow == 0) return;

    Trace((stderr,"\nbit length overflow\n"));
    /* This happens for example on obj2 and pic of the Calgary corpus */

    /* Find the first bit length which could increase: */
    do {
        bits = max_length-1;
        while (s->bl_count[bits] == 0) bits--;
        s->bl_count[bits]--;      /* move one leaf down the tree */
        s->bl_count[bits+1] += 2; /* move one overflow item as its brother */
        s->bl_count[max_length]--;
        /* The brother of the overflow item also moves one step up,
         * but this does not affect bl_count[max_length]
         */
        overflow -= 2;
    } while (overflow > 0);

    /* Now recompute all bit lengths, scanning in increasing frequency.
     * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all
     * lengths instead of fixing only the wrong ones. This idea is taken
     * from 'ar' written by Haruhiko Okumura.)
     */
    for (bits = max_length; bits != 0; bits--) {
        n = s->bl_count[bits];
        while (n != 0) {
            m = s->heap[--h];
            if (m > max_code) continue;
            if (tree[m].Len != (unsigned) bits) {
                Trace((stderr,"code %d bits %d->%d\n", m, tree[m].Len, bits));
                s->opt_len += ((long)bits - (long)tree[m].Len)
                              *(long)tree[m].Freq;
                tree[m].Len = (ush)bits;
            }
            n--;
        }
    }
}

/* ===========================================================================
 * Generate the codes for a given tree and bit counts (which need not be
 * optimal).
 * IN assertion: the array bl_count contains the bit length statistics for
 * the given tree and the field len is set for all tree elements.
 * OUT assertion: the field code is set for all tree elements of non
 *     zero code length.
 */
local void gen_codes (tree, max_code, bl_count)
    ct_data *tree;             /* the tree to decorate */
    int max_code;              /* largest code with non zero frequency */
    ushf *bl_count;            /* number of codes at each bit length */
{
    ush next_code[MAX_BITS+1]; /* next code value for each bit length */
    ush code = 0;              /* running code value */
    int bits;                  /* bit index */
    int n;                     /* code index */

    /* The distribution counts are first used to generate the code values
     * without bit reversal.
     */
    for (bits = 1; bits <= MAX_BITS; bits++) {
        next_code[bits] = code = (code + bl_count[bits-1]) << 1;
    }
    /* Check that the bit counts in bl_count are consistent. The last code
     * must be all ones.
     */
    Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,
            "inconsistent bit counts");
    Tracev((stderr,"\ngen_codes: max_code %d ", max_code));

    for (n = 0;  n <= max_code; n++) {
        int len = tree[n].Len;
        if (len == 0) continue;
        /* Now reverse the bits */
        tree[n].Code = (ush)bi_reverse(next_code[len]++, len);

        Tracecv(tree != static_ltree, (stderr,"\nn %3d %c l %2d c %4x (%x) ",
             n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));
    }
}

/* ===========================================================================
 * Construct one Huffman tree and assigns the code bit strings and lengths.
 * Update the total bit length for the current block.
 * IN assertion: the field freq is set for all tree elements.
 * OUT assertions: the fields len and code are set to the optimal bit length
 *     and corresponding code. The length opt_len is updated; static_len is
 *     also updated if stree is not null. The field max_code is set.
 */
local void build_tree(s, desc)
    deflate_state *s;
    tree_desc *desc; /* the tree descriptor */
{
    ct_data *tree         = desc->dyn_tree;
    const ct_data *stree  = desc->stat_desc->static_tree;
    int elems             = desc->stat_desc->elems;
    int n, m;          /* iterate over heap elements */
    int max_code = -1; /* largest code with non zero frequency */
    int node;          /* new node being created */

    /* Construct the initial heap, with least frequent element in
     * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].
     * heap[0] is not used.
     */
    s->heap_len = 0, s->heap_max = HEAP_SIZE;

    for (n = 0; n < elems; n++) {
        if (tree[n].Freq != 0) {
            s->heap[++(s->heap_len)] = max_code = n;
            s->depth[n] = 0;
        } else {
            tree[n].Len = 0;
        }
    }

    /* The pkzip format requires that at least one distance code exists,
     * and that at least one bit should be sent even if there is only one
     * possible code. So to avoid special checks later on we force at least
     * two codes of non zero frequency.
     */
    while (s->heap_len < 2) {
        node = s->heap[++(s->heap_len)] = (max_code < 2 ? ++max_code : 0);
        tree[node].Freq = 1;
        s->depth[node] = 0;
        s->opt_len--; if (stree) s->static_len -= stree[node].Len;
        /* node is 0 or 1 so it does not have extra bits */
    }
    desc->max_code = max_code;

    /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,
     * establish sub-heaps of increasing lengths:
     */
    for (n = s->heap_len/2; n >= 1; n--) pqdownheap(s, tree, n);

    /* Construct the Huffman tree by repeatedly combining the least two
     * frequent nodes.
     */
    node = elems;              /* next internal node of the tree */
    do {
        pqremove(s, tree, n);  /* n = node of least frequency */
        m = s->heap[SMALLEST]; /* m = node of next least frequency */

        s->heap[--(s->heap_max)] = n; /* keep the nodes sorted by frequency */
        s->heap[--(s->heap_max)] = m;

        /* Create a new node father of n and m */
        tree[node].Freq = tree[n].Freq + tree[m].Freq;
        s->depth[node] = (uch) (MAX(s->depth[n], s->depth[m]) + 1);
        tree[n].Dad = tree[m].Dad = (ush)node;
#ifdef DUMP_BL_TREE
        if (tree == s->bl_tree) {
            fprintf(stderr,"\nnode %d(%d), sons %d(%d) %d(%d)",
                    node, tree[node].Freq, n, tree[n].Freq, m, tree[m].Freq);
        }
#endif
        /* and insert the new node in the heap */
        s->heap[SMALLEST] = node++;
        pqdownheap(s, tree, SMALLEST);

    } while (s->heap_len >= 2);

    s->heap[--(s->heap_max)] = s->heap[SMALLEST];

    /* At this point, the fields freq and dad are set. We can now
     * generate the bit lengths.
     */
    gen_bitlen(s, (tree_desc *)desc);

    /* The field len is now set, we can generate the bit codes */
    gen_codes ((ct_data *)tree, max_code, s->bl_count);
}

/* ===========================================================================
 * Scan a literal or distance tree to determine the frequencies of the codes
 * in the bit length tree.
 */
local void scan_tree (s, tree, max_code)
    deflate_state *s;
    ct_data *tree;   /* the tree to be scanned */
    int max_code;    /* and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    if (nextlen == 0) max_count = 138, min_count = 3;
    tree[max_code+1].Len = (ush)0xffff; /* guard */

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            s->bl_tree[curlen].Freq += (ush) count;
        } else if (curlen != 0) {
            if (curlen != prevlen) s->bl_tree[curlen].Freq++;
            s->bl_tree[REP_3_6].Freq++;
        } else if (count <= 10) {
            s->bl_tree[REPZ_3_10].Freq++;
        } else {
            s->bl_tree[REPZ_11_138].Freq++;
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Send a literal or distance tree in compressed form, using the codes in
 * bl_tree.
 */
local void send_tree (s, tree, max_code)
    deflate_state *s;
    ct_data *tree; /* the tree to be scanned */
    int max_code;       /* and its largest code of non zero frequency */
{
    int n;                     /* iterates over all tree elements */
    int prevlen = -1;          /* last emitted length */
    int curlen;                /* length of current code */
    int nextlen = tree[0].Len; /* length of next code */
    int count = 0;             /* repeat count of the current code */
    int max_count = 7;         /* max repeat count */
    int min_count = 4;         /* min repeat count */

    /* tree[max_code+1].Len = -1; */  /* guard already set */
    if (nextlen == 0) max_count = 138, min_count = 3;

    for (n = 0; n <= max_code; n++) {
        curlen = nextlen; nextlen = tree[n+1].Len;
        if (++count < max_count && curlen == nextlen) {
            continue;
        } else if (count < min_count) {
            do { send_code(s, curlen, s->bl_tree); } while (--count != 0);

        } else if (curlen != 0) {
            if (curlen != prevlen) {
                send_code(s, curlen, s->bl_tree); count--;
            }
            Assert(count >= 3 && count <= 6, " 3_6?");
            send_code(s, REP_3_6, s->bl_tree); send_bits(s, count-3, 2);

        } else if (count <= 10) {
            send_code(s, REPZ_3_10, s->bl_tree); send_bits(s, count-3, 3);

        } else {
            send_code(s, REPZ_11_138, s->bl_tree); send_bits(s, count-11, 7);
        }
        count = 0; prevlen = curlen;
        if (nextlen == 0) {
            max_count = 138, min_count = 3;
        } else if (curlen == nextlen) {
            max_count = 6, min_count = 3;
        } else {
            max_count = 7, min_count = 4;
        }
    }
}

/* ===========================================================================
 * Construct the Huffman tree for the bit lengths and return the index in
 * bl_order of the last bit length code to send.
 */
local int build_bl_tree(s)
    deflate_state *s;
{
    int max_blindex;  /* index of last bit length code of non zero freq */

    /* Determine the bit length frequencies for literal and distance trees */
    scan_tree(s, (ct_data *)s->dyn_ltree, s->l_desc.max_code);
    scan_tree(s, (ct_data *)s->dyn_dtree, s->d_desc.max_code);

    /* Build the bit length tree: */
    build_tree(s, (tree_desc *)(&(s->bl_desc)));
    /* opt_len now includes the length of the tree representations, except
     * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.
     */

    /* Determine the number of bit length codes to send. The pkzip format
     * requires that at least 4 bit length codes be sent. (appnote.txt says
     * 3 but the actual value used is 4.)
     */
    for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {
        if (s->bl_tree[bl_order[max_blindex]].Len != 0) break;
    }
    /* Update opt_len to include the bit length tree and counts */
    s->opt_len += 3*(max_blindex+1) + 5+5+4;
    Tracev((stderr, "\ndyn trees: dyn %ld, stat %ld",
            s->opt_len, s->static_len));

    return max_blindex;
}

/* ===========================================================================
 * Send the header for a block using dynamic Huffman trees: the counts, the
 * lengths of the bit length codes, the literal tree and the distance tree.
 * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.
 */
local void send_all_trees(s, lcodes, dcodes, blcodes)
    deflate_state *s;
    int lcodes, dcodes, blcodes; /* number of codes for each tree */
{
    int rank;                    /* index in bl_order */

    Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");
    Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,
            "too many codes");
    Tracev((stderr, "\nbl counts: "));
    send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */
    send_bits(s, dcodes-1,   5);
    send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */
    for (rank = 0; rank < blcodes; rank++) {
        Tracev((stderr, "\nbl code %2d ", bl_order[rank]));
        send_bits(s, s->bl_tree[bl_order[rank]].Len, 3);
    }
    Tracev((stderr, "\nbl tree: sent %ld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_ltree, lcodes-1); /* literal tree */
    Tracev((stderr, "\nlit tree: sent %ld", s->bits_sent));

    send_tree(s, (ct_data *)s->dyn_dtree, dcodes-1); /* distance tree */
    Tracev((stderr, "\ndist tree: sent %ld", s->bits_sent));
}

/* ===========================================================================
 * Send a stored block
 */
void _tr_stored_block(s, buf, stored_len, eof)
    deflate_state *s;
    charf *buf;       /* input block */
    ulg stored_len;   /* length of input block */
    int eof;          /* true if this is the last block for a file */
{
    send_bits(s, (STORED_BLOCK<<1)+eof, 3);  /* send block type */
#ifdef DEBUG
    s->compressed_len = (s->compressed_len + 3 + 7) & (ulg)~7L;
    s->compressed_len += (stored_len + 4) << 3;
#endif
    copy_block(s, buf, (unsigned)stored_len, 1); /* with header */
}

/* ===========================================================================
 * Send one empty static block to give enough lookahead for inflate.
 * This takes 10 bits, of which 7 may remain in the bit buffer.
 * The current inflate code requires 9 bits of lookahead. If the
 * last two codes for the previous block (real code plus EOB) were coded
 * on 5 bits or less, inflate may have only 5+3 bits of lookahead to decode
 * the last real code. In this case we send two empty static blocks instead
 * of one. (There are no problems if the previous block is stored or fixed.)
 * To simplify the code, we assume the worst case of last real code encoded
 * on one bit only.
 */
void _tr_align(s)
    deflate_state *s;
{
    send_bits(s, STATIC_TREES<<1, 3);
    send_code(s, END_BLOCK, static_ltree);
#ifdef DEBUG
    s->compressed_len += 10L; /* 3 for block type, 7 for EOB */
#endif
    bi_flush(s);
    /* Of the 10 bits for the empty block, we have already sent
     * (10 - bi_valid) bits. The lookahead for the last real code (before
     * the EOB of the previous block) was thus at least one plus the length
     * of the EOB plus what we have just sent of the empty static block.
     */
    if (1 + s->last_eob_len + 10 - s->bi_valid < 9) {
        send_bits(s, STATIC_TREES<<1, 3);
        send_code(s, END_BLOCK, static_ltree);
#ifdef DEBUG
        s->compressed_len += 10L;
#endif
        bi_flush(s);
    }
    s->last_eob_len = 7;
}

/* ===========================================================================
 * Determine the best encoding for the current block: dynamic trees, static
 * trees or store, and output the encoded block to the zip file.
 */
void _tr_flush_block(s, buf, stored_len, eof)
    deflate_state *s;
    charf *buf;       /* input block, or NULL if too old */
    ulg stored_len;   /* length of input block */
    int eof;          /* true if this is the last block for a file */
{
    ulg opt_lenb, static_lenb; /* opt_len and static_len in bytes */
    int max_blindex = 0;  /* index of last bit length code of non zero freq */

    /* Build the Huffman trees unless a stored block is forced */
    if (s->level > 0) {

	 /* Check if the file is ascii or binary */
	if (s->data_type == Z_UNKNOWN) set_data_type(s);

	/* Construct the literal and distance trees */
	build_tree(s, (tree_desc *)(&(s->l_desc)));
	Tracev((stderr, "\nlit data: dyn %ld, stat %ld", s->opt_len,
		s->static_len));

	build_tree(s, (tree_desc *)(&(s->d_desc)));
	Tracev((stderr, "\ndist data: dyn %ld, stat %ld", s->opt_len,
		s->static_len));
	/* At this point, opt_len and static_len are the total bit lengths of
	 * the compressed block data, excluding the tree representations.
	 */

	/* Build the bit length tree for the above two trees, and get the index
	 * in bl_order of the last bit length code to send.
	 */
	max_blindex = build_bl_tree(s);

	/* Determine the best encoding. Compute first the block length in bytes*/
	opt_lenb = (s->opt_len+3+7)>>3;
	static_lenb = (s->static_len+3+7)>>3;

	Tracev((stderr, "\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",
		opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,
		s->last_lit));

	if (static_lenb <= opt_lenb) opt_lenb = static_lenb;

    } else {
        Assert(buf != (char*)0, "lost buf");
	opt_lenb = static_lenb = stored_len + 5; /* force a stored block */
    }

#ifdef FORCE_STORED
    if (buf != (char*)0) { /* force stored block */
#else
    if (stored_len+4 <= opt_lenb && buf != (char*)0) {
                       /* 4: two words for the lengths */
#endif
        /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.
         * Otherwise we can't have processed more than WSIZE input bytes since
         * the last block flush, because compression would have been
         * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to
         * transform a block into a stored block.
         */
        _tr_stored_block(s, buf, stored_len, eof);

#ifdef FORCE_STATIC
    } else if (static_lenb >= 0) { /* force static trees */
#else
    } else if (static_lenb == opt_lenb) {
#endif
        send_bits(s, (STATIC_TREES<<1)+eof, 3);
        compress_block(s, (ct_data *)static_ltree, (ct_data *)static_dtree);
#ifdef DEBUG
        s->compressed_len += 3 + s->static_len;
#endif
    } else {
        send_bits(s, (DYN_TREES<<1)+eof, 3);
        send_all_trees(s, s->l_desc.max_code+1, s->d_desc.max_code+1,
                       max_blindex+1);
        compress_block(s, (ct_data *)s->dyn_ltree, (ct_data *)s->dyn_dtree);
#ifdef DEBUG
        s->compressed_len += 3 + s->opt_len;
#endif
    }
    Assert (s->compressed_len == s->bits_sent, "bad compressed size");
    /* The above check is made mod 2^32, for files larger than 512 MB
     * and uLong implemented on 32 bits.
     */
    init_block(s);

    if (eof) {
        bi_windup(s);
#ifdef DEBUG
        s->compressed_len += 7;  /* align on byte boundary */
#endif
    }
    Tracev((stderr,"\ncomprlen %lu(%lu) ", s->compressed_len>>3,
           s->compressed_len-7*eof));
}

/* ===========================================================================
 * Save the match info and tally the frequency counts. Return true if
 * the current block must be flushed.
 */
int _tr_tally (s, dist, lc)
    deflate_state *s;
    unsigned dist;  /* distance of matched string */
    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */
{
    s->d_buf[s->last_lit] = (ush)dist;
    s->l_buf[s->last_lit++] = (uch)lc;
    if (dist == 0) {
        /* lc is the unmatched char */
        s->dyn_ltree[lc].Freq++;
    } else {
        s->matches++;
        /* Here, lc is the match length - MIN_MATCH */
        dist--;             /* dist = match distance - 1 */
        Assert((ush)dist < (ush)MAX_DIST(s) &&
               (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&
               (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");

        s->dyn_ltree[_length_code[lc]+LITERALS+1].Freq++;
        s->dyn_dtree[d_code(dist)].Freq++;
    }

#ifdef TRUNCATE_BLOCK
    /* Try to guess if it is profitable to stop the current block here */
    if ((s->last_lit & 0x1fff) == 0 && s->level > 2) {
        /* Compute an upper bound for the compressed length */
        ulg out_length = (ulg)s->last_lit*8L;
        ulg in_length = (ulg)((long)s->strstart - s->block_start);
        int dcode;
        for (dcode = 0; dcode < D_CODES; dcode++) {
            out_length += (ulg)s->dyn_dtree[dcode].Freq *
                (5L+extra_dbits[dcode]);
        }
        out_length >>= 3;
        Tracev((stderr,"\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",
               s->last_lit, in_length, out_length,
               100L - out_length*100L/in_length));
        if (s->matches < s->last_lit/2 && out_length < in_length/2) return 1;
    }
#endif
    return (s->last_lit == s->lit_bufsize-1);
    /* We avoid equality with lit_bufsize because of wraparound at 64K
     * on 16 bit machines and because stored blocks are restricted to
     * 64K-1 bytes.
     */
}

/* ===========================================================================
 * Send the block data compressed using the given Huffman trees
 */
local void compress_block(s, ltree, dtree)
    deflate_state *s;
    ct_data *ltree; /* literal tree */
    ct_data *dtree; /* distance tree */
{
    unsigned dist;      /* distance of matched string */
    int lc;             /* match length or unmatched char (if dist == 0) */
    unsigned lx = 0;    /* running index in l_buf */
    unsigned code;      /* the code to send */
    int extra;          /* number of extra bits to send */

    if (s->last_lit != 0) do {
        dist = s->d_buf[lx];
        lc = s->l_buf[lx++];
        if (dist == 0) {
            send_code(s, lc, ltree); /* send a literal byte */
            Tracecv(isgraph(lc), (stderr," '%c' ", lc));
        } else {
            /* Here, lc is the match length - MIN_MATCH */
            code = _length_code[lc];
            send_code(s, code+LITERALS+1, ltree); /* send the length code */
            extra = extra_lbits[code];
            if (extra != 0) {
                lc -= base_length[code];
                send_bits(s, lc, extra);       /* send the extra length bits */
            }
            dist--; /* dist is now the match distance - 1 */
            code = d_code(dist);
            Assert (code < D_CODES, "bad d_code");

            send_code(s, code, dtree);       /* send the distance code */
            extra = extra_dbits[code];
            if (extra != 0) {
                dist -= base_dist[code];
                send_bits(s, dist, extra);   /* send the extra distance bits */
            }
        } /* literal or match pair ? */

        /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */
        Assert(s->pending < s->lit_bufsize + 2*lx, "pendingBuf overflow");

    } while (lx < s->last_lit);

    send_code(s, END_BLOCK, ltree);
    s->last_eob_len = ltree[END_BLOCK].Len;
}

/* ===========================================================================
 * Set the data type to ASCII or BINARY, using a crude approximation:
 * binary if more than 20% of the bytes are <= 6 or >= 128, ascii otherwise.
 * IN assertion: the fields freq of dyn_ltree are set and the total of all
 * frequencies does not exceed 64K (to fit in an int on 16 bit machines).
 */
local void set_data_type(s)
    deflate_state *s;
{
    int n = 0;
    unsigned ascii_freq = 0;
    unsigned bin_freq = 0;
    while (n < 7)        bin_freq += s->dyn_ltree[n++].Freq;
    while (n < 128)    ascii_freq += s->dyn_ltree[n++].Freq;
    while (n < LITERALS) bin_freq += s->dyn_ltree[n++].Freq;
    s->data_type = (Byte)(bin_freq > (ascii_freq >> 2) ? Z_BINARY : Z_ASCII);
}

/* ===========================================================================
 * Reverse the first len bits of a code, using straightforward code (a faster
 * method would use a table)
 * IN assertion: 1 <= len <= 15
 */
local unsigned bi_reverse(code, len)
    unsigned code; /* the value to invert */
    int len;       /* its bit length */
{
    register unsigned res = 0;
    do {
        res |= code & 1;
        code >>= 1, res <<= 1;
    } while (--len > 0);
    return res >> 1;
}

/* ===========================================================================
 * Flush the bit buffer, keeping at most 7 bits in it.
 */
local void bi_flush(s)
    deflate_state *s;
{
    if (s->bi_valid == 16) {
        put_short(s, s->bi_buf);
        s->bi_buf = 0;
        s->bi_valid = 0;
    } else if (s->bi_valid >= 8) {
        put_byte(s, (Byte)s->bi_buf);
        s->bi_buf >>= 8;
        s->bi_valid -= 8;
    }
}

/* ===========================================================================
 * Flush the bit buffer and align the output on a byte boundary
 */
local void bi_windup(s)
    deflate_state *s;
{
    if (s->bi_valid > 8) {
        put_short(s, s->bi_buf);
    } else if (s->bi_valid > 0) {
        put_byte(s, (Byte)s->bi_buf);
    }
    s->bi_buf = 0;
    s->bi_valid = 0;
#ifdef DEBUG
    s->bits_sent = (s->bits_sent+7) & ~7;
#endif
}

/* ===========================================================================
 * Copy a stored block, storing first the length and its
 * one's complement if requested.
 */
local void copy_block(s, buf, len, header)
    deflate_state *s;
    charf    *buf;    /* the input data */
    unsigned len;     /* its length */
    int      header;  /* true if block header must be written */
{
    bi_windup(s);        /* align on byte boundary */
    s->last_eob_len = 8; /* enough lookahead for inflate */

    if (header) {
        put_short(s, (ush)len);   
        put_short(s, (ush)~len);
#ifdef DEBUG
        s->bits_sent += 2*16;
#endif
    }
#ifdef DEBUG
    s->bits_sent += (ulg)len<<3;
#endif
    while (len--) {
        put_byte(s, *buf++);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\zconf.h ===
/* zconf.h -- configuration of the zlib compression library
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#ifndef _ZCONF_H
#define _ZCONF_H

/*
 * If you *really* need a unique prefix for all types and library functions,
 * compile with -DZ_PREFIX. The "standard" zlib should be compiled without it.
 */
#ifdef Z_PREFIX
#  define deflateInit_	z_deflateInit_
#  define deflate	z_deflate
#  define deflateEnd	z_deflateEnd
#  define inflateInit_ 	z_inflateInit_
#  define inflate	z_inflate
#  define inflateEnd	z_inflateEnd
#  define deflateInit2_	z_deflateInit2_
#  define deflateSetDictionary z_deflateSetDictionary
#  define deflateCopy	z_deflateCopy
#  define deflateReset	z_deflateReset
#  define deflateParams	z_deflateParams
#  define inflateInit2_	z_inflateInit2_
#  define inflateSetDictionary z_inflateSetDictionary
#  define inflateSync	z_inflateSync
#  define inflateSyncPoint z_inflateSyncPoint
#  define inflateReset	z_inflateReset
#  define compress	z_compress
#  define compress2	z_compress2
#  define uncompress	z_uncompress
#  define adler32	z_adler32
#  define crc32		z_crc32
#  define get_crc_table z_get_crc_table

#  define Byte		z_Byte
#  define uInt		z_uInt
#  define uLong		z_uLong
#  define Bytef	        z_Bytef
#  define charf		z_charf
#  define intf		z_intf
#  define uIntf		z_uIntf
#  define uLongf	z_uLongf
#  define voidpf	z_voidpf
#  define voidp		z_voidp
#endif

#if (defined(_WIN32) || defined(__WIN32__)) && !defined(WIN32)
#  define WIN32
#endif
#if defined(__GNUC__) || defined(WIN32) || defined(__386__) || defined(i386)
#  ifndef __32BIT__
#    define __32BIT__
#  endif
#endif
#if defined(__MSDOS__) && !defined(MSDOS)
#  define MSDOS
#endif

/*
 * Compile with -DMAXSEG_64K if the alloc function cannot allocate more
 * than 64k bytes at a time (needed on systems with 16-bit int).
 */
#if defined(MSDOS) && !defined(__32BIT__)
#  define MAXSEG_64K
#endif
#ifdef MSDOS
#  define UNALIGNED_OK
#endif

#if (defined(MSDOS) || defined(_WINDOWS) || defined(WIN32))  && !defined(STDC)
#  define STDC
#endif
#if defined(__STDC__) || defined(__cplusplus) || defined(__OS2__)
#  ifndef STDC
#    define STDC
#  endif
#endif

#ifndef STDC
#  ifndef const /* cannot use !defined(STDC) && !defined(const) on Mac */
#    define const
#  endif
#endif

/* Some Mac compilers merge all .h files incorrectly: */
#if defined(__MWERKS__) || defined(applec) ||defined(THINK_C) ||defined(__SC__)
#  define NO_DUMMY_DECL
#endif

/* Old Borland C incorrectly complains about missing returns: */
#if defined(__BORLANDC__) && (__BORLANDC__ < 0x500)
#  define NEED_DUMMY_RETURN
#endif


/* Maximum value for memLevel in deflateInit2 */
#ifndef MAX_MEM_LEVEL
#  ifdef MAXSEG_64K
#    define MAX_MEM_LEVEL 8
#  else
#    define MAX_MEM_LEVEL 9
#  endif
#endif

/* Maximum value for windowBits in deflateInit2 and inflateInit2.
 * WARNING: reducing MAX_WBITS makes minigzip unable to extract .gz files
 * created by gzip. (Files created by minigzip can still be extracted by
 * gzip.)
 */
#ifndef MAX_WBITS
#  define MAX_WBITS   15 /* 32K LZ77 window */
#endif

/* The memory requirements for deflate are (in bytes):
            (1 << (windowBits+2)) +  (1 << (memLevel+9))
 that is: 128K for windowBits=15  +  128K for memLevel = 8  (default values)
 plus a few kilobytes for small objects. For example, if you want to reduce
 the default memory requirements from 256K to 128K, compile with
     make CFLAGS="-O -DMAX_WBITS=14 -DMAX_MEM_LEVEL=7"
 Of course this will generally degrade compression (there's no free lunch).

   The memory requirements for inflate are (in bytes) 1 << windowBits
 that is, 32K for windowBits=15 (default value) plus a few kilobytes
 for small objects.
*/

                        /* Type declarations */

#ifndef OF /* function prototypes */
#  ifdef STDC
#    define OF(args)  args
#  else
#    define OF(args)  ()
#  endif
#endif

/* The following definitions for FAR are needed only for MSDOS mixed
 * model programming (small or medium model with some far allocations).
 * This was tested only with MSC; for other MSDOS compilers you may have
 * to define NO_MEMCPY in zutil.h.  If you don't need the mixed model,
 * just define FAR to be empty.
 */
#if (defined(M_I86SM) || defined(M_I86MM)) && !defined(__32BIT__)
   /* MSC small or medium model */
#  define SMALL_MEDIUM
#  ifdef _MSC_VER
#    define FAR _far
#  else
#    define FAR far
#  endif
#endif
#if defined(__BORLANDC__) && (defined(__SMALL__) || defined(__MEDIUM__))
#  ifndef __32BIT__
#    define SMALL_MEDIUM
#    define FAR _far
#  endif
#endif

/* Compile with -DZLIB_DLL for Windows DLL support */
#if defined(ZLIB_DLL)
#  if defined(_WINDOWS) || defined(WINDOWS)
#    ifdef FAR
#      undef FAR
#    endif
#    include <windows.h>
#    define ZEXPORT  WINAPI
#    ifdef WIN32
#      define ZEXPORTVA  WINAPIV
#    else
#      define ZEXPORTVA  FAR _cdecl _export
#    endif
#  endif
#  if defined (__BORLANDC__)
#    if (__BORLANDC__ >= 0x0500) && defined (WIN32)
#      include <windows.h>
#      define ZEXPORT __declspec(dllexport) WINAPI
#      define ZEXPORTRVA __declspec(dllexport) WINAPIV
#    else
#      if defined (_Windows) && defined (__DLL__)
#        define ZEXPORT _export
#        define ZEXPORTVA _export
#      endif
#    endif
#  endif
#endif

#if defined (__BEOS__)
#  if defined (ZLIB_DLL)
#    define ZEXTERN extern __declspec(dllexport)
#  else
#    define ZEXTERN extern __declspec(dllimport)
#  endif
#endif

#ifndef ZEXPORT
#  define ZEXPORT
#endif
#ifndef ZEXPORTVA
#  define ZEXPORTVA
#endif
#ifndef ZEXTERN
#  define ZEXTERN extern
#endif

#ifndef FAR
#   define FAR
#endif

#if !defined(MACOS) && !defined(TARGET_OS_MAC)
typedef unsigned char  Byte;  /* 8 bits */
#endif
typedef unsigned int   uInt;  /* 16 bits or more */
typedef unsigned long  uLong; /* 32 bits or more */

#ifdef SMALL_MEDIUM
   /* Borland C/C++ and some old MSC versions ignore FAR inside typedef */
#  define Bytef Byte FAR
#else
   typedef Byte  FAR Bytef;
#endif
typedef char  FAR charf;
typedef int   FAR intf;
typedef uInt  FAR uIntf;
typedef uLong FAR uLongf;

#ifdef STDC
   typedef void FAR *voidpf;
   typedef void     *voidp;
#else
   typedef Byte FAR *voidpf;
   typedef Byte     *voidp;
#endif

#ifdef HAVE_UNISTD_H
#  include <sys/types.h> /* for off_t */
#  include <unistd.h>    /* for SEEK_* and off_t */
#  define z_off_t  off_t
#endif
#ifndef SEEK_SET
#  define SEEK_SET        0       /* Seek from beginning of file.  */
#  define SEEK_CUR        1       /* Seek from current position.  */
#  define SEEK_END        2       /* Set file pointer to EOF plus "offset" */
#endif
#ifndef z_off_t
#  define  z_off_t long
#endif

/* MVS linker does not support external names larger than 8 bytes */
#if defined(__MVS__)
#   pragma map(deflateInit_,"DEIN")
#   pragma map(deflateInit2_,"DEIN2")
#   pragma map(deflateEnd,"DEEND")
#   pragma map(inflateInit_,"ININ")
#   pragma map(inflateInit2_,"ININ2")
#   pragma map(inflateEnd,"INEND")
#   pragma map(inflateSync,"INSY")
#   pragma map(inflateSetDictionary,"INSEDI")
#   pragma map(inflate_blocks,"INBL")
#   pragma map(inflate_blocks_new,"INBLNE")
#   pragma map(inflate_blocks_free,"INBLFR")
#   pragma map(inflate_blocks_reset,"INBLRE")
#   pragma map(inflate_codes_free,"INCOFR")
#   pragma map(inflate_codes,"INCO")
#   pragma map(inflate_fast,"INFA")
#   pragma map(inflate_flush,"INFLU")
#   pragma map(inflate_mask,"INMA")
#   pragma map(inflate_set_dictionary,"INSEDI2")
#   pragma map(inflate_copyright,"INCOPY")
#   pragma map(inflate_trees_bits,"INTRBI")
#   pragma map(inflate_trees_dynamic,"INTRDY")
#   pragma map(inflate_trees_fixed,"INTRFI")
#   pragma map(inflate_trees_free,"INTRFR")
#endif

#endif /* _ZCONF_H */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\zutil.c ===
/* zutil.c -- target dependent utility functions for the compression library
 * Copyright (C) 1995-2002 Jean-loup Gailly.
 * For conditions of distribution and use, see copyright notice in zlib.h 
 */

/* @(#) $Id$ */

#include "zutil.h"

struct internal_state      {int dummy;}; /* for buggy compilers */

#ifndef STDC
extern void exit OF((int));
#endif

const char * const z_errmsg[10] = {
"need dictionary",     /* Z_NEED_DICT       2  */
"stream end",          /* Z_STREAM_END      1  */
"",                    /* Z_OK              0  */
"file error",          /* Z_ERRNO         (-1) */
"stream error",        /* Z_STREAM_ERROR  (-2) */
"data error",          /* Z_DATA_ERROR    (-3) */
"insufficient memory", /* Z_MEM_ERROR     (-4) */
"buffer error",        /* Z_BUF_ERROR     (-5) */
"incompatible version",/* Z_VERSION_ERROR (-6) */
""};


const char * ZEXPORT zlibVersion()
{
    return ZLIB_VERSION;
}

#ifdef DEBUG

#  ifndef verbose
#    define verbose 0
#  endif
int z_verbose = verbose;

void z_error (m)
    char *m;
{
    fprintf(stderr, "%s\n", m);
    exit(1);
}
#endif

/* exported to allow conversion of error code to string for compress() and
 * uncompress()
 */
const char * ZEXPORT zError(err)
    int err;
{
    return ERR_MSG(err);
}


#ifndef HAVE_MEMCPY

void zmemcpy(dest, source, len)
    Bytef* dest;
    const Bytef* source;
    uInt  len;
{
    if (len == 0) return;
    do {
        *dest++ = *source++; /* ??? to be unrolled */
    } while (--len != 0);
}

int zmemcmp(s1, s2, len)
    const Bytef* s1;
    const Bytef* s2;
    uInt  len;
{
    uInt j;

    for (j = 0; j < len; j++) {
        if (s1[j] != s2[j]) return 2*(s1[j] > s2[j])-1;
    }
    return 0;
}

void zmemzero(dest, len)
    Bytef* dest;
    uInt  len;
{
    if (len == 0) return;
    do {
        *dest++ = 0;  /* ??? to be unrolled */
    } while (--len != 0);
}
#endif

#ifdef __TURBOC__
#if (defined( __BORLANDC__) || !defined(SMALL_MEDIUM)) && !defined(__32BIT__)
/* Small and medium model in Turbo C are for now limited to near allocation
 * with reduced MAX_WBITS and MAX_MEM_LEVEL
 */
#  define MY_ZCALLOC

/* Turbo C malloc() does not allow dynamic allocation of 64K bytes
 * and farmalloc(64K) returns a pointer with an offset of 8, so we
 * must fix the pointer. Warning: the pointer must be put back to its
 * original form in order to free it, use zcfree().
 */

#define MAX_PTR 10
/* 10*64K = 640K */

local int next_ptr = 0;

typedef struct ptr_table_s {
    voidpf org_ptr;
    voidpf new_ptr;
} ptr_table;

local ptr_table table[MAX_PTR];
/* This table is used to remember the original form of pointers
 * to large buffers (64K). Such pointers are normalized with a zero offset.
 * Since MSDOS is not a preemptive multitasking OS, this table is not
 * protected from concurrent access. This hack doesn't work anyway on
 * a protected system like OS/2. Use Microsoft C instead.
 */

voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
{
    voidpf buf = opaque; /* just to make some compilers happy */
    ulg bsize = (ulg)items*size;

    /* If we allocate less than 65520 bytes, we assume that farmalloc
     * will return a usable pointer which doesn't have to be normalized.
     */
    if (bsize < 65520L) {
        buf = farmalloc(bsize);
        if (*(ush*)&buf != 0) return buf;
    } else {
        buf = farmalloc(bsize + 16L);
    }
    if (buf == NULL || next_ptr >= MAX_PTR) return NULL;
    table[next_ptr].org_ptr = buf;

    /* Normalize the pointer to seg:0 */
    *((ush*)&buf+1) += ((ush)((uch*)buf-0) + 15) >> 4;
    *(ush*)&buf = 0;
    table[next_ptr++].new_ptr = buf;
    return buf;
}

void  zcfree (voidpf opaque, voidpf ptr)
{
    int n;
    if (*(ush*)&ptr != 0) { /* object < 64K */
        farfree(ptr);
        return;
    }
    /* Find the original pointer */
    for (n = 0; n < next_ptr; n++) {
        if (ptr != table[n].new_ptr) continue;

        farfree(table[n].org_ptr);
        while (++n < next_ptr) {
            table[n-1] = table[n];
        }
        next_ptr--;
        return;
    }
    ptr = opaque; /* just to make some compilers happy */
    Assert(0, "zcfree: ptr not found");
}
#endif
#endif /* __TURBOC__ */


#if defined(M_I86) && !defined(__32BIT__)
/* Microsoft C in 16-bit mode */

#  define MY_ZCALLOC

#if (!defined(_MSC_VER) || (_MSC_VER <= 600))
#  define _halloc  halloc
#  define _hfree   hfree
#endif

voidpf zcalloc (voidpf opaque, unsigned items, unsigned size)
{
    if (opaque) opaque = 0; /* to make compiler happy */
    return _halloc((long)items, size);
}

void  zcfree (voidpf opaque, voidpf ptr)
{
    if (opaque) opaque = 0; /* to make compiler happy */
    _hfree(ptr);
}

#endif /* MSC */


#ifndef MY_ZCALLOC /* Any system without a special alloc function */

#ifndef STDC
extern voidp  calloc OF((uInt items, uInt size));
extern void   free   OF((voidpf ptr));
#endif

voidpf zcalloc (opaque, items, size)
    voidpf opaque;
    unsigned items;
    unsigned size;
{
    if (opaque) items += size - size; /* make compiler happy */
    return (voidpf)calloc(items, size);
}

void  zcfree (opaque, ptr)
    voidpf opaque;
    voidpf ptr;
{
    free(ptr);
    if (opaque) return; /* make compiler happy */
}

#endif /* MY_ZCALLOC */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\base\zlib\d3dx\makefile.inc ===
$(O)\zlib_d3dx.h : ..\zlib.h $(O)\d3dx_rename.h
   type $(O)\d3dx_rename.h > $@
   type ..\zlib.h >>$@
   
$(O)\d3dx_rename.h : makefile.inc
   type << > $@
#define z_errmsg d3dx_z_errmsg
#define zlibVersion d3dx_zlibVersion
#define zError d3dx_zError
#define zcalloc d3dx_zcalloc
#define zcfree d3dx_zcfree
#define uncompress d3dx_uncompress
#define _length_code d3dx__length_code
#define _dist_code d3dx__dist_code
#define _tr_tally d3dx__tr_tally
#define _tr_init d3dx__tr_init
#define _tr_stored_block d3dx__tr_stored_block
#define _tr_align d3dx__tr_align
#define _tr_flush_block d3dx__tr_flush_block
#define inflate_mask d3dx_inflate_mask
#define inflate_flush d3dx_inflate_flush
#define inflate_copyright d3dx_inflate_copyright
#define inflate_trees_bits d3dx_inflate_trees_bits
#define inflate_trees_dynamic d3dx_inflate_trees_dynamic
#define inflate_trees_fixed d3dx_inflate_trees_fixed
#define inflateReset d3dx_inflateReset
#define inflateEnd d3dx_inflateEnd
#define inflateInit2_ d3dx_inflateInit2_
#define inflateInit_ d3dx_inflateInit_
#define inflate d3dx_inflate
#define inflateSetDictionary d3dx_inflateSetDictionary
#define inflateSync d3dx_inflateSync
#define inflateSyncPoint d3dx_inflateSyncPoint
#define inflate_fast d3dx_inflate_fast
#define inflate_codes_new d3dx_inflate_codes_new
#define inflate_codes d3dx_inflate_codes
#define inflate_codes_free d3dx_inflate_codes_free
#define inflate_blocks_reset d3dx_inflate_blocks_reset
#define inflate_blocks_new d3dx_inflate_blocks_new
#define inflate_blocks d3dx_inflate_blocks
#define inflate_blocks_free d3dx_inflate_blocks_free
#define inflate_set_dictionary d3dx_inflate_set_dictionary
#define inflate_blocks_sync_point d3dx_inflate_blocks_sync_point
#define gzsetparams d3dx_gzsetparams
#define gzwrite d3dx_gzwrite
#define gzprintf d3dx_gzprintf
#define gzputc d3dx_gzputc
#define gzputs d3dx_gzputs
#define gzflush d3dx_gzflush
#define gzrewind d3dx_gzrewind
#define gzeof d3dx_gzeof
#define gzclose d3dx_gzclose
#define gzerror d3dx_gzerror
#define gzopen d3dx_gzopen
#define gzdopen d3dx_gzdopen
#define gzread d3dx_gzread
#define gzgetc d3dx_gzgetc
#define gzgets d3dx_gzgets
#define gzseek d3dx_gzseek
#define gztell d3dx_gztell
#define deflate_copyright d3dx_deflate_copyright
#define deflateSetDictionary d3dx_deflateSetDictionary
#define deflate d3dx_deflate
#define deflateEnd d3dx_deflateEnd
#define deflateCopy d3dx_deflateCopy
#define deflateReset d3dx_deflateReset
#define deflateParams d3dx_deflateParams
#define deflateInit2_ d3dx_deflateInit2_
#define deflateInit_ d3dx_deflateInit_
#define get_crc_table d3dx_get_crc_table
#define crc32 d3dx_crc32
#define compress2 d3dx_compress2
#define compress d3dx_compress
#define adler32 d3dx_adler32
#define ZEXPORT __stdcall
#define ZEXPORTVA __cdecl
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\inc\ndrshared\ndrtoken.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    ndrtoken.h

Abtract :

    Format character definitions, type flags, and other such stuff.
	Mainly from rpc\midl\inc\ndrtypes.h

Revision History :

	John Doty   johndoty May 2000  (Assembled from other ndr headers)

--------------------------------------------------------------------*/
#ifndef __NDRTOKEN_H__
#define __NDRTOKEN_H__

#ifdef __cplusplus
extern "C"
{
#endif

//
// Format character definitions.
//
// !!! WARNING WARNING WARNING !!!
//
// All of the format character values up to FC_PAD can no longer be changed,
// in order to preserve NT 3.5 compatability (excluding those marked as
// FC_UNUSED*, these were unused format characters in NDR library version 1.1).
// Their ordinal number, as well as semantics, must remain.
//
// When additional format characters are added (at the end), changes must
// be made in ndr20 as well as codegen\frmtstr.cxx to handle the new type.
// In particular, there is a pFormatCharNames table and a pNdrRoutineNames table
// that should be kept in ssync.
//
// !!! WARNING WARNING WARNING !!!
//

typedef enum {


    //
    // This might catch some errors, probably can be removed after debugging.
    //
    FC_ZERO,

    //
    // Simple integer and floating point types.
    //

    FC_BYTE,                    // 0x01
    FC_CHAR,                    // 0x02
    FC_SMALL,                   // 0x03
    FC_USMALL,                  // 0x04

    FC_WCHAR,                   // 0x05
    FC_SHORT,                   // 0x06
    FC_USHORT,                  // 0x07

    FC_LONG,                    // 0x08
    FC_ULONG,                   // 0x09

    FC_FLOAT,                   // 0x0a

    FC_HYPER,                   // 0x0b

    FC_DOUBLE,                  // 0x0c

    //
    // Enums.
    //
    FC_ENUM16,                  // 0x0d
    FC_ENUM32,                  // 0x0e

    //
    // !!!IMPORTANT!!!
    // All format charaters which appear before this comment must have an
    // enum value which will fit in 4 bits.
    //

    //
    // Special.
    //
    FC_IGNORE,                  // 0x0f
    FC_ERROR_STATUS_T,          // 0x10

    //
    // Pointer types :
    //     RP - reference pointer
    //     UP - unique pointer
    //     OP - OLE unique pointer
    //     FP - full pointer
    //

    FC_RP,                      // 0x11
    FC_UP,                      // 0x12
    FC_OP,                      // 0x13
    FC_FP,                      // 0x14

    //
    // Structures
    //

    //
    // Structure containing only simple types and fixed arrays.
    //
    FC_STRUCT,                  // 0x15

    //
    // Structure containing only simple types, pointers and fixed arrays.
    //
    FC_PSTRUCT,                 // 0x16

    //
    // Structure containing a conformant array plus all those types
    // allowed by FC_STRUCT.
    //
    FC_CSTRUCT,                 // 0x17

    //
    // Struct containing a conformant array plus all those types allowed by
    // FC_PSTRUCT.
    //
    FC_CPSTRUCT,                // 0x18

    //
    // Struct containing either a conformant varying array or a conformant
    // string, plus all those types allowed by FC_PSTRUCT.
    //
    FC_CVSTRUCT,                // 0x19

    //
    // Complex struct - totally bogus!
    //
    FC_BOGUS_STRUCT,            // 0x1a

    //
    // Arrays.
    //

    //
    // Conformant arrray.
    //
    FC_CARRAY,                  // 0x1b

    //
    // Conformant varying array.
    //
    FC_CVARRAY,                 // 0x1c

    //
    // Fixed array, small and large.
    //
    FC_SMFARRAY,                // 0x1d
    FC_LGFARRAY,                // 0x1e

    //
    // Varying array, small and large.
    //
    FC_SMVARRAY,                // 0x1f
    FC_LGVARRAY,                // 0x20

    //
    // Complex arrays - totally bogus!
    //
    FC_BOGUS_ARRAY,             // 0x21

    //
    // Strings :
    //
    // The order of these should have been moved around, but it's too late
    // now.
    //
    //     CSTRING - character string
    //     BSTRING - byte string (Beta2 compatability only)
    //     SSTRING - structure string
    //     WSTRING - wide charater string
    //

    //
    // Conformant strings.
    //
    FC_C_CSTRING,               // 0x22
    FC_C_BSTRING,               // 0x23
    FC_C_SSTRING,               // 0x24
    FC_C_WSTRING,               // 0x25

    //
    // Non-conformant strings.
    //
    FC_CSTRING,                 // 0x26
    FC_BSTRING,                 // 0x27
    FC_SSTRING,                 // 0x28
    FC_WSTRING,                 // 0x29

    //
    // Unions
    //
    FC_ENCAPSULATED_UNION,      // 0x2a
    FC_NON_ENCAPSULATED_UNION,  // 0x2b

    //
    // Byte count pointer.
    //
    FC_BYTE_COUNT_POINTER,      // 0x2c

    //
    // transmit_as and represent_as
    //
    FC_TRANSMIT_AS,             // 0x2d
    FC_REPRESENT_AS,            // 0x2e

    //
    // Cairo Interface pointer.
    //
    FC_IP,                      // 0x2f

    //
    // Binding handle types
    //
    FC_BIND_CONTEXT,            // 0x30
    FC_BIND_GENERIC,            // 0x31
    FC_BIND_PRIMITIVE,          // 0x32
    FC_AUTO_HANDLE,             // 0x33
    FC_CALLBACK_HANDLE,         // 0x34
    FC_UNUSED1,                 // 0x35

    // Embedded pointer - used in complex structure layouts only.
    FC_POINTER,                 // 0x36

    //
    // Alignment directives, used in structure layouts.
    // No longer generated with post NT5.0 MIDL.
    //

    FC_ALIGNM2,                 // 0x37 
    FC_ALIGNM4,                 // 0x38
    FC_ALIGNM8,                 // 0x39

    FC_UNUSED2,                 // 0x3a
    FC_UNUSED3,                 // 0x3b
    FC_UNUSED4,                 // 0x3c

    //
    // Structure padding directives, used in structure layouts only.
    //
    FC_STRUCTPAD1,              // 0x3d
    FC_STRUCTPAD2,              // 0x3e
    FC_STRUCTPAD3,              // 0x3f
    FC_STRUCTPAD4,              // 0x40
    FC_STRUCTPAD5,              // 0x41
    FC_STRUCTPAD6,              // 0x42
    FC_STRUCTPAD7,              // 0x43

    //
    // Additional string attribute.
    //
    FC_STRING_SIZED,            // 0x44

    FC_UNUSED5,                 // 0x45

    //
    // Pointer layout attributes.
    //
    FC_NO_REPEAT,               // 0x46
    FC_FIXED_REPEAT,            // 0x47
    FC_VARIABLE_REPEAT,         // 0x48
    FC_FIXED_OFFSET,            // 0x49
    FC_VARIABLE_OFFSET,         // 0x4a

    // Pointer section delimiter.
    FC_PP,                      // 0x4b

    // Embedded complex type.
    FC_EMBEDDED_COMPLEX,        // 0x4c

    // Parameter attributes.
    FC_IN_PARAM,                // 0x4d
    FC_IN_PARAM_BASETYPE,       // 0x4e
    FC_IN_PARAM_NO_FREE_INST,   // 0x4d
    FC_IN_OUT_PARAM,            // 0x50
    FC_OUT_PARAM,               // 0x51
    FC_RETURN_PARAM,            // 0x52
    FC_RETURN_PARAM_BASETYPE,   // 0x53

    //
    // Conformance/variance attributes.
    //
    FC_DEREFERENCE,             // 0x54
    FC_DIV_2,                   // 0x55
    FC_MULT_2,                  // 0x56
    FC_ADD_1,                   // 0x57
    FC_SUB_1,                   // 0x58
    FC_CALLBACK,                // 0x59

    // Iid flag.
    FC_CONSTANT_IID,            // 0x5a

    FC_END,                     // 0x5b
    FC_PAD,                     // 0x5c
    FC_EXPR,                    // 0x5d
    FC_PARTIAL_IGNORE_PARAM,    // 0x5e

    //
    // split Conformance/variance attributes.
    //
    FC_SPLIT_DEREFERENCE = 0x74,      // 0x74
    FC_SPLIT_DIV_2,                   // 0x75
    FC_SPLIT_MULT_2,                  // 0x76
    FC_SPLIT_ADD_1,                   // 0x77
    FC_SPLIT_SUB_1,                   // 0x78
    FC_SPLIT_CALLBACK,                // 0x79

    //
    // **********************************
    // New Post NT 3.5 format characters.
    // **********************************
    //

    //
    // Attributes, directives, etc.
    //

    //
    // New types.
    //
    // These start at 0xb1 (0x31 + 0x80) so that their routines can simply be
    // placed sequentially in the various routine tables, while using
    // a new ROUTINE_INDEX() macro which strips off the most significant bit
    // of the format character.  The value 0x31 is the next value after
    // FC_BIND_CONTEXT, whose routines were previously the last to appear
    // in the routine tables.
    //
    FC_HARD_STRUCT = 0xb1,      // 0xb1

    FC_TRANSMIT_AS_PTR,         // 0xb2
    FC_REPRESENT_AS_PTR,        // 0xb3

    FC_USER_MARSHAL,            // 0xb4

    FC_PIPE,                    // 0xb5

    FC_BLKHOLE,                 // 0xb6

    FC_RANGE,                   // 0xb7     NT 5 beta2 MIDL 3.3.110

    FC_INT3264,                 // 0xb8     NT 5 beta2, MIDL64, 5.1.194+
    FC_UINT3264,                // 0xb9     NT 5 beta2, MIDL64, 5.1.194+

    //
    // Post NT 5.0 strings
    //

    //
    // Arrays of international characters
    //
    FC_CSARRAY,                 // 0xba
    FC_CS_TAG,                  // 0xbb

    // Replacement for alignment in structure layout.
    FC_STRUCTPADN,              // 0xbc

    FC_INT128,                  // 0xbd
    FC_UINT128,                 // 0xbe
    FC_FLOAT80,                 // 0xbf
    FC_FLOAT128,                // 0xc0

    FC_BUFFER_ALIGN,            // 0xc1

    //
    // New Ndr64 codes
    //

    FC_ENCAP_UNION,             // 0xc2

    // new arrays types

    FC_FIX_ARRAY,               // 0xc3
    FC_CONF_ARRAY,              // 0xc4
    FC_VAR_ARRAY,               // 0xc5 
    FC_CONFVAR_ARRAY,           // 0xc6
    FC_FIX_FORCED_BOGUS_ARRAY,  // 0xc7
    FC_FIX_BOGUS_ARRAY,         // 0xc8 
    FC_FORCED_BOGUS_ARRAY,      // 0xc9

    FC_CHAR_STRING,             // 0xca
    FC_WCHAR_STRING,            // 0xcb
    FC_STRUCT_STRING,           // 0xcc

    FC_CONF_CHAR_STRING,        // 0xcd
    FC_CONF_WCHAR_STRING,       // 0xce
    FC_CONF_STRUCT_STRING,      // 0xcf

    // new structures types
    FC_CONF_STRUCT,             // 0xd0
    FC_CONF_PSTRUCT,            // 0xd1
    FC_CONFVAR_STRUCT,          // 0xd2
    FC_CONFVAR_PSTRUCT,         // 0xd3
    FC_FORCED_BOGUS_STRUCT,     // 0xd4
    FC_CONF_BOGUS_STRUCT,       // 0xd5
    FC_FORCED_CONF_BOGUS_STRUCT,// 0xd7
    
    FC_END_OF_UNIVERSE          // 0xd8

} FORMAT_CHARACTER;

//
// Conformance and variance constants
//
#define FC_NORMAL_CONFORMANCE           (unsigned char) 0x00
#define FC_POINTER_CONFORMANCE          (unsigned char) 0x10
#define FC_TOP_LEVEL_CONFORMANCE        (unsigned char) 0x20
#define FC_CONSTANT_CONFORMANCE         (unsigned char) 0x40
#define FC_TOP_LEVEL_MULTID_CONFORMANCE (unsigned char) 0x80

#define FC_NORMAL_VARIANCE              FC_NORMAL_CONFORMANCE
#define FC_POINTER_VARIANCE             FC_POINTER_CONFORMANCE
#define FC_TOP_LEVEL_VARIANCE           FC_TOP_LEVEL_CONFORMANCE
#define FC_CONSTANT_VARIANCE            FC_CONSTANT_CONFORMANCE
#define FC_TOP_LEVEL_MULTID_VARIANCE    FC_TOP_LEVEL_MULTID_CONFORMANCE

#define FC_NORMAL_SWITCH_IS             FC_NORMAL_CONFORMANCE
#define FC_POINTER_SWITCH_IS            FC_POINTER_CONFORMANCE
#define FC_TOP_LEVEL_SWITCH_IS          FC_TOP_LEVEL_CONFORMANCE
#define FC_CONSTANT_SWITCH_IS           FC_CONSTANT_CONFORMANCE

//
// Pointer attributes.
//
#define FC_ALLOCATE_ALL_NODES       0x01
#define FC_DONT_FREE                0x02
#define FC_ALLOCED_ON_STACK         0x04
#define FC_SIMPLE_POINTER           0x08
#define FC_POINTER_DEREF            0x10

#define NDR_DEFAULT_CORR_CACHE_SIZE 400

#if !defined(__RPC_MAC__)
//
// Interpreter bit flag structures.
//

// These are the old Oi interpreter proc flags.

typedef struct
    {
    unsigned char   FullPtrUsed             : 1;    // 0x01
    unsigned char   RpcSsAllocUsed          : 1;    // 0x02
    unsigned char   ObjectProc              : 1;    // 0x04
    unsigned char   HasRpcFlags             : 1;    // 0x08
    unsigned char   IgnoreObjectException   : 1;    // 0x10
    unsigned char   HasCommOrFault          : 1;    // 0x20
    unsigned char   UseNewInitRoutines      : 1;    // 0x40
    unsigned char   Unused                  : 1;
    } INTERPRETER_FLAGS, *PINTERPRETER_FLAGS;

// These are the Oi2 parameter flags.

typedef struct
    {
    unsigned short  MustSize            : 1;    // 0x0001
    unsigned short  MustFree            : 1;    // 0x0002
    unsigned short  IsPipe              : 1;    // 0x0004
    unsigned short  IsIn                : 1;    // 0x0008
    unsigned short  IsOut               : 1;    // 0x0010
    unsigned short  IsReturn            : 1;    // 0x0020
    unsigned short  IsBasetype          : 1;    // 0x0040
    unsigned short  IsByValue           : 1;    // 0x0080
    unsigned short  IsSimpleRef         : 1;    // 0x0100
    unsigned short  IsDontCallFreeInst  : 1;    // 0x0200
    unsigned short  SaveForAsyncFinish  : 1;    // 0x0400
    unsigned short  IsPartialIgnore     : 1;    // 0x0800
    unsigned short  IsForceAllocate     : 1;    // 0x1000
    unsigned short  ServerAllocSize     : 3;    // 0xe000
    } PARAM_ATTRIBUTES, *PPARAM_ATTRIBUTES;

// These are the new Oi2 proc flags.

typedef struct
    {
    unsigned char   ServerMustSize      : 1;    // 0x01
    unsigned char   ClientMustSize      : 1;    // 0x02
    unsigned char   HasReturn           : 1;    // 0x04
    unsigned char   HasPipes            : 1;    // 0x08
    unsigned char   Unused              : 1;
    unsigned char   HasAsyncUuid        : 1;    // 0x20
    unsigned char   HasExtensions       : 1;    // 0x40
    unsigned char   HasAsyncHandle      : 1;    // 0x80
    } INTERPRETER_OPT_FLAGS, *PINTERPRETER_OPT_FLAGS;

// This is the proc header layout for object procs starting with MIDL 3.3.129,
// introduced for the async_uuid() support in dcom but generated for ony object
// interface, regardless of the compiler mode and interface being async.
// Handle is always autohandle and so there never is explicit handle descriptor.
// RpcFlags are always present to make the layout fixed.

typedef struct _NDR_DCOM_OI2_PROC_HEADER
    {
    unsigned char               HandleType;          // The old Oi header
    INTERPRETER_FLAGS           OldOiFlags;          //
    unsigned short              RpcFlagsLow;         //
    unsigned short              RpcFlagsHi;          //
    unsigned short              ProcNum;             //
    unsigned short              StackSize;           //
    // expl handle descr is never generated          //
    unsigned short              ClientBufferSize;    // The Oi2 header
    unsigned short              ServerBufferSize;    //
    INTERPRETER_OPT_FLAGS       Oi2Flags;            //
    unsigned char               NumberParams;        //
    } NDR_DCOM_OI2_PROC_HEADER, *PNDR_DCOM_OI2_PROC_HEADER;

// These are extended Oi2 interpreter proc flags.
// They have been introduced for NT5 beta2.

typedef struct
    {
    unsigned char   HasNewCorrDesc      : 1;    // 0x01
    unsigned char   ClientCorrCheck     : 1;    // 0x02
    unsigned char   ServerCorrCheck     : 1;    // 0x04
    unsigned char   HasNotify           : 1;    // 0x08
    unsigned char   HasNotify2          : 1;    // 0x10
    unsigned char   HasComplexReturn    : 1;    // 0x20
    unsigned char   Unused              : 2;
    } INTERPRETER_OPT_FLAGS2, *PINTERPRETER_OPT_FLAGS2;

// This is the layout of the proc header extensions introduced for denial of
// attacks for NT5 beta2, MIDL version 3.3.129.
// The extensions would be announced by the HasExtensions Oi2 flag and would
// follow directly after the ParameterCount field of Oi2 header.

typedef struct
    {
    unsigned char               Size;   // size as the extension version
    INTERPRETER_OPT_FLAGS2      Flags2;
    unsigned short              ClientCorrHint;
    unsigned short              ServerCorrHint;
    unsigned short              NotifyIndex;
    } NDR_PROC_HEADER_EXTS, *PNDR_PROC_HEADER_EXTS;

typedef struct
    {
    unsigned char               Size;   // size as the extension version
    INTERPRETER_OPT_FLAGS2      Flags2;
    unsigned short              ClientCorrHint;
    unsigned short              ServerCorrHint;
    unsigned short              NotifyIndex;
    unsigned short              FloatArgMask;
    } NDR_PROC_HEADER_EXTS64, *PNDR_PROC_HEADER_EXTS64;


// Context handle flags

typedef struct
    {
    unsigned char   CannotBeNull        : 1;    // 0x01
    unsigned char   Serialize           : 1;    // 0x02
    unsigned char   NoSerialize         : 1;    // 0x04
    unsigned char   IsStrict            : 1;    // 0x08
    unsigned char   IsReturn            : 1;    // 0x10
    unsigned char   IsOut               : 1;    // 0x20
    unsigned char   IsIn                : 1;    // 0x40
    unsigned char   IsViaPtr            : 1;    // 0x80

    } NDR_CONTEXT_HANDLE_FLAGS, *PNDR_CONTEXT_HANDLE_FLAGS;

typedef struct
    {
    unsigned char               Fc;
    NDR_CONTEXT_HANDLE_FLAGS    Flags;
    unsigned char               RundownRtnIndex;
    unsigned char               ParamOrdinal;   // Oicf: ordinal, /Oi param num
    } NDR_CONTEXT_HANDLE_ARG_DESC, *PNDR_CONTEXT_HANDLE_ARG_DESC;

// Type pickling flags

typedef struct _MIDL_TYPE_PICKLING_FLAGS
    {
    unsigned long   Oicf                : 1;
    unsigned long   HasNewCorrDesc      : 1;
    unsigned long   Unused              : 30;
    } MIDL_TYPE_PICKLING_FLAGS, *PMIDL_TYPE_PICKLING_FLAGS;

/*

typedef struct 
    {
    unsigned long   HandleType          : 3;
    unsigned long   ProcType            : 3;
    unsigned long   IsInterpreted       : 2;
    unsigned long   IsObject            : 1;
    unsigned long   IsAsync             : 1;
    unsigned long   IsPickled           : 2;
    unsigned long   UsesFullPtrPackage  : 1;
    unsigned long   UsesRpcSmPackage    : 1;
    unsigned long   UsesPipes           : 1;
    unsigned long   HandlesExceptions   : 2;
    unsigned long   ServerMustsize      : 1;
    unsigned long   ClientMustsize      : 1;
    unsigned long   HasReturn           : 1;
    unsigned long   ClientCorrelation   : 1;
    unsigned long   ServerCorrelation   : 1;   
    unsigned long   HasNotify           : 1;
    unsigned long   HasOtherExtensions  : 1;
    unsigned long   Unused              : 8;
    } NDR64_FLAGS;

typedef struct
    {
    unsigned short  MustSize            : 1;    // 0x0001
    unsigned short  MustFree            : 1;    // 0x0002
    unsigned short  IsPipe              : 1;    // 0x0004
    unsigned short  IsIn                : 1;    // 0x0008
    unsigned short  IsOut               : 1;    // 0x0010
    unsigned short  IsReturn            : 1;    // 0x0020
    unsigned short  IsBasetype          : 1;    // 0x0040
    unsigned short  IsByValue           : 1;    // 0x0080
    unsigned short  IsSimpleRef         : 1;    // 0x0100
    unsigned short  IsDontCallFreeInst  : 1;    // 0x0200
    unsigned short  SaveForAsyncFinish  : 1;    // 0x0400
    unsigned short  Unused              : 5;
    unsigned short  UseCache            : 1;    // new
    } NDR64_PARAM_ATTRIBUTES, *PNDR64_PARAM_ATTRIBUTES;


typedef struct 
    {
    NDR64_PARAM_ATTRIBUTES  ParamAttr;
    union 
        {
        unsigned short      ParamOffset;
        struct 
            {
            unsigned char       Type;
            unsigned char       Unused;
            }   SimpleType;
    };
    unsigned long       StackOffset;
    } NDR64_PARAM_DESCRIPTION, *PNDR64_PARAM_DESCRIPTION;
*/

#else
// now Mac defs: bits are flipped on Mac.

typedef struct
    {
    unsigned char   Unused              : 3;
    unsigned char   HasNotify2          : 1;    // 0x10
    unsigned char   HasNotify           : 1;    // 0x08
    unsigned char   ServerCorrCheck     : 1;    // 0x04
    unsigned char   ClientCorrCheck     : 1;    // 0x02
    unsigned char   HasNewCorrDec       : 1;    // 0x01
    } INTERPRETER_OPT_FLAGS2, *PINTERPRETER_OPT_FLAGS2;

typedef struct
    {
    unsigned char   Unused                  : 1;
    unsigned char   UseNewInitRoutines      : 1;    // 0x40
    unsigned char   HasCommOrFault          : 1;    // 0x20
    unsigned char   IgnoreObjectException   : 1;    // 0x10
    unsigned char   HasRpcFlags             : 1;    // 0x08
    unsigned char   ObjectProc              : 1;    // 0x04
    unsigned char   RpcSsAllocUsed          : 1;    // 0x02
    unsigned char   FullPtrUsed             : 1;    // 0x01
    } INTERPRETER_FLAGS, *PINTERPRETER_FLAGS;

typedef struct
    {
    unsigned char   HasAsyncHandle      : 1;    // 0x80
    unsigned char   HasExtensions       : 1;    // 0x40
    unsigned char   Unused              : 2;
    unsigned char   HasPipes            : 1;    // 0x08
    unsigned char   HasReturn           : 1;    // 0x04
    unsigned char   ClientMustSize      : 1;    // 0x02
    unsigned char   ServerMustSize      : 1;    // 0x01
    } INTERPRETER_OPT_FLAGS, *PINTERPRETER_OPT_FLAGS;

typedef struct
    {
    unsigned short  ServerAllocSize     : 3;    // 0xe000
    unsigned short  Unused              : 2;
    unsigned short  SaveForAsyncFinish  : 1;    // 0x0400
    unsigned short  IsDontCallFreeInst  : 1;    // 0x0200
    unsigned short  IsSimpleRef         : 1;    // 0x0100
//
    unsigned short  IsByValue           : 1;    // 0x0080
    unsigned short  IsBasetype          : 1;    // 0x0040
    unsigned short  IsReturn            : 1;    // 0x0020
    unsigned short  IsOut               : 1;    // 0x0010
    unsigned short  IsIn                : 1;    // 0x0008
    unsigned short  IsPipe              : 1;    // 0x0004
    unsigned short  MustFree            : 1;    // 0x0002
    unsigned short  MustSize            : 1;    // 0x0001
    } PARAM_ATTRIBUTES, *PPARAM_ATTRIBUTES;

#endif

#pragma pack(2)
    typedef struct 
        {
        PARAM_ATTRIBUTES    ParamAttr;
        unsigned short      StackOffset;
        union 
            {
            unsigned short  TypeOffset;
            struct 
                {
                unsigned char  Type;
				unsigned char  Unused;
                } SimpleType;
            };
        } PARAM_DESCRIPTION, *PPARAM_DESCRIPTION;
#pragma pack()

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\inc\ndrshared\ndrmisc.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    ndrmisc.h

Abtract :

    Contains misc. function prototypes, flags, and macros, mainly from
	rpc\ndr20\ndrp.h.

Revision History :

	John Doty   johndoty May 2000  (Assembled from other ndr headers)

--------------------------------------------------------------------*/


#ifndef __NDRMISC_H__
#define __NDRMISC_H__

//
// Type marshalling and buffer manipulation
//
EXTERN_C uchar *
NdrpMemoryIncrement(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pMemory,
    PFORMAT_STRING      pFormat
    );

EXTERN_C void
NdrUnmarshallBasetypeInline(
    PMIDL_STUB_MESSAGE  pStubMsg,
    uchar *             pArg,
    uchar               Format
    );

EXTERN_C
unsigned char
RPC_ENTRY
NdrGetSimpleTypeBufferAlignment(
    unsigned char FormatChar
    );

EXTERN_C
unsigned char
RPC_ENTRY
NdrGetSimpleTypeBufferSize(
    unsigned char FormatChar
    );

EXTERN_C
unsigned char
RPC_ENTRY
NdrGetSimpleTypeMemorySize(
    unsigned char FormatChar
    );

EXTERN_C
unsigned long
RPC_ENTRY
NdrGetTypeFlags(
    unsigned char FormatChar
    );

EXTERN_C
void
RPC_ENTRY
NdrTypeSize(
    PMIDL_STUB_MESSAGE                  pStubMsg,
    unsigned char __RPC_FAR *           pMemory,
    PFORMAT_STRING                      pFormat
    );

EXTERN_C
unsigned char *
RPC_ENTRY
NdrTypeMarshall(
    PMIDL_STUB_MESSAGE                   pStubMsg,
    unsigned char __RPC_FAR *            pMemory,
    PFORMAT_STRING                       pFormat
    );

EXTERN_C
unsigned char *
RPC_ENTRY
NdrTypeUnmarshall(
    PMIDL_STUB_MESSAGE                   pStubMsg,
    unsigned char __RPC_FAR **           ppMemory,
    PFORMAT_STRING                       pFormat,
    unsigned char                        fSkipRefCheck
    );

EXTERN_C
void
RPC_ENTRY
NdrTypeFree(
	PMIDL_STUB_MESSAGE                   pStubMsg,
	unsigned char __RPC_FAR *            pMemory,
	PFORMAT_STRING                       pFormat
    );

// used by callframe guys
EXTERN_C void
NdrOutInit(
    PMIDL_STUB_MESSAGE      pStubMsg,
    PFORMAT_STRING          pFormat,
    uchar **                ppArg
    );


// This definition is adjusted for a native platform.
// The wire size is fixed for DCE NDR regardless of platform.

#define PTR_MEM_SIZE                    sizeof(void *)
#define PTR_MEM_ALIGN                   (sizeof(void *)-1)
#define PTR_WIRE_SIZE                   (4)
#define NDR_MAX_BUFFER_ALIGNMENT        (16)

#define CONTEXT_HANDLE_WIRE_SIZE        20

#define IGNORED(Param)


//
// Alignment macros.
//

#define ALIGN( pStuff, cAlign ) \
                pStuff = (uchar *)((LONG_PTR)((pStuff) + (cAlign)) \
                                   & ~ ((LONG_PTR)(cAlign)))

#define LENGTH_ALIGN( Length, cAlign ) \
                Length = (((Length) + (cAlign)) & ~ (cAlign))


//
// Simple type alignment and size lookup macros.
//
#ifdef _RPCRT4_

#define SIMPLE_TYPE_ALIGNMENT(FormatChar)   SimpleTypeAlignment[FormatChar]

#define SIMPLE_TYPE_BUFSIZE(FormatChar)     SimpleTypeBufferSize[FormatChar]

#define SIMPLE_TYPE_MEMSIZE(FormatChar)     SimpleTypeMemorySize[FormatChar]

#else

#define SIMPLE_TYPE_ALIGNMENT(FormatChar)   NdrGetSimpleTypeBufferAlignment(FormatChar)

#define SIMPLE_TYPE_BUFSIZE(FormatChar)     NdrGetSimpleTypeBufferSize(FormatChar)

#define SIMPLE_TYPE_MEMSIZE(FormatChar)     NdrGetSimpleTypeMemorySize(FormatChar)

#endif

//
// Format character attribute bits used in global NdrTypesFlags defined in
// global.c.
//
#define     _SIMPLE_TYPE_       0x0001L
#define     _POINTER_           0x0002L
#define     _STRUCT_            0x0004L
#define     _ARRAY_             0x0008L
#define     _STRING_            0x0010L
#define     _UNION_             0x0020L
#define     _XMIT_AS_           0x0040L

#define     _BY_VALUE_          0x0080L

#define     _HANDLE_            0x0100L

#define     _BASIC_POINTER_     0x0200L

//
// Format character query macros.
//
#ifdef __RPCRT4__

#define _FC_FLAGS(FC)  NdrTypeFlags[(FC)]

#else

#define _FC_FLAGS(FC)  NdrGetTypeFlags(FC)

#endif

#define IS_SIMPLE_TYPE(FC)     (_FC_FLAGS(FC) & _SIMPLE_TYPE_)

#define IS_POINTER_TYPE(FC)    (_FC_FLAGS(FC) & _POINTER_)

#define IS_BASIC_POINTER(FC)   (_FC_FLAGS(FC) & _BASIC_POINTER_)

#define IS_ARRAY(FC)           (_FC_FLAGS(FC) & _ARRAY_)

#define IS_STRUCT(FC)          (_FC_FLAGS(FC) & _STRUCT_)

#define IS_UNION(FC)           (_FC_FLAGS(FC) & _UNION_)

#define IS_STRING(FC)          (_FC_FLAGS(FC) & _STRING_)

#define IS_ARRAY_OR_STRING(FC) (_FC_FLAGS(FC) & (_STRING_ | _ARRAY_))

#define IS_XMIT_AS(FC)         (_FC_FLAGS(FC) & _XMIT_AS_)

#define IS_BY_VALUE(FC)        (_FC_FLAGS(FC) & _BY_VALUE_)

#define IS_HANDLE(FC)          (NdrTypeFlags[(FC)] & _HANDLE_)

//
// Pointer attribute extraction and querying macros.
//
#define ALLOCATE_ALL_NODES( FC )    ((FC) & FC_ALLOCATE_ALL_NODES)

#define DONT_FREE( FC )             ((FC) & FC_DONT_FREE)

#define ALLOCED_ON_STACK( FC )      ((FC) & FC_ALLOCED_ON_STACK)

#define SIMPLE_POINTER( FC )        ((FC) & FC_SIMPLE_POINTER)

#define POINTER_DEREF( FC )         ((FC) & FC_POINTER_DEREF)

//
// Handle query macros.
//
#define IS_HANDLE_PTR( FC )         ((FC) & HANDLE_PARAM_IS_VIA_PTR)

#define IS_HANDLE_IN( FC )          ((FC) & HANDLE_PARAM_IS_IN)

#define IS_HANDLE_OUT( FC )         ((FC) & HANDLE_PARAM_IS_OUT)

#define IS_HANDLE_RETURN( FC )      ((FC) & HANDLE_PARAM_IS_RETURN)


//
// Stack and argument defines.
//
#if defined(_AMD64_) || defined(_IA64_)
#define REGISTER_TYPE               _int64
#else
#define REGISTER_TYPE               int
#endif

#define RETURN_SIZE                 8

//
// Argument retrieval macros.
//

#define INIT_ARG(argptr,arg0)   va_start(argptr, arg0)

#ifndef _ALPHA_
//
// Both MIPS and x86 are 4 byte aligned stacks, with MIPS supporting 8byte
// alignment on the stack as well. Their va_list is essentially an
// unsigned char *.
//

#if defined(_IA64_)
#define GET_FIRST_IN_ARG(argptr)
#define GET_FIRST_OUT_ARG(argptr)
#elif defined(_AMD64_)
#define GET_FIRST_IN_ARG(argptr)            
#define GET_FIRST_OUT_ARG(argptr)           
#else
#define GET_FIRST_IN_ARG(argptr)            argptr = *(va_list *)argptr
#define GET_FIRST_OUT_ARG(argptr)           argptr = *(va_list *)argptr
#endif

#define GET_NEXT_C_ARG(argptr,type)         va_arg(argptr,type)

#define SKIP_STRUCT_ON_STACK(ArgPtr, Size)	ArgPtr += Size

#define GET_STACK_START(ArgPtr)			    ArgPtr
#define GET_STACK_POINTER(ArgPtr, mode)		ArgPtr

#else	// _ALPHA_
//
// The Alpha has an 8byte aligned stack, with its va_list being a structure
// consisting of an unsigned char *, a0 and an int offset. See stdarg.h for
// the gory details.
//

#define GET_FIRST_IN_ARG(argptr)    \
            argptr.a0 = va_arg(argptr, char *); \
            argptr.offset = 0
#define GET_FIRST_OUT_ARG(argptr)   \
            argptr.a0 = va_arg(argptr, char *); \
            argptr.offset = 0

//
// Note that this macro does nothing for the Alpha. The stack incrementing is
// folded into the GET_STACK_POINTER below.
//
#define GET_NEXT_C_ARG(argptr,type)

#define SKIP_STRUCT_ON_STACK(ArgPtr, Size)  \
		    Size += 7; Size &= ~7;	 \
		    for(Size /= sizeof(_int64);Size;--Size){va_arg(ArgPtr, _int64);}

#define GET_STACK_START(ArgPtr)		   ArgPtr.a0

//
// Ok, this ugly mess is just a trimmed dowm version of the va_arg macro for
// the alpha. What is missing is the dereference operator (*) and the test for
// a float (__builtin_isfloat()).
//
#define GET_STACK_POINTER(ArgPtr, mode)                             \
            (                                                       \
              ((ArgPtr).offset += ((int)sizeof(mode) + 7) & -8) ,   \
              (mode *)((ArgPtr).a0 +                                \
                       (ArgPtr).offset -                            \
		               (((int)sizeof(mode) + 7) & -8))              \
            )

#endif	// _ALPHA_

//
// Use the following macro _after_ argptr has been saved or processed
//
#define SKIP_PROCESSED_ARG(argptr, type) \
                    GET_NEXT_C_ARG(argptr, type); \
                    GET_STACK_POINTER(argptr,type)

#define GET_NEXT_S_ARG(argptr,type)     argptr += sizeof(type)


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\daytona.inc ===
#
# This file contains the common stuff related to SENS on NT5 platforms.
#

C_DEFINES=$(C_DEFINES) -DSENS_NT5

!if $(IA64)
# Emit LTCG codegen
LTCG_WKS=1
!endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\inc\ndrshared\ndrtypegen.h ===
/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

Copyright (c) 2000 Microsoft Corporation

Module Name :

    ndrtypegen.h

Abtract :

    Functions for generating type format strings from ITypeInfo *s.

	NOTE: I'd like to move this into either ndrmisc.h or ndrtoken.h,
	      but neither of those can include oaidl.h, which is needed for
		  ITypeInfo and it's related structures.

Revision History :

	John Doty   johndoty May 2000  

--------------------------------------------------------------------*/
#ifndef __NDRTYPEGEN_H__
#define __NDRTYPEGEN_H__

#ifdef __cplusplus
extern "C" {
#endif

//
// Type Format String Generation
//
HRESULT 
NdrpGetTypeGenCookie(void **ppvTypeGenCookie);

HRESULT
NdrpReleaseTypeGenCookie(void *pvTypeGenCookie);

HRESULT
NdrpGetProcFormatString(IN  void      *pvTypeGenCookie,
						IN  ITypeInfo *pTypeInfo,
						IN  FUNCDESC  *pFuncDesc,
						IN  USHORT     iMethod,
						OUT PFORMAT_STRING pProcFormatString,
						OUT USHORT    *pcbFormat);

HRESULT
NdrpGetTypeFormatString(IN void *            pvTypeGenCookie,
						OUT PFORMAT_STRING * pTypeFormatString,
						OUT USHORT *         pLength);

HRESULT
NdrpReleaseTypeFormatString(PFORMAT_STRING pTypeFormatString);

HRESULT 
NdrpVarVtOfTypeDesc(IN ITypeInfo *pTypeInfo,
					IN TYPEDESC  *ptdesc,
					OUT VARTYPE  *vt);

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\common\common.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    common.cxx

Abstract:

    This file contains some common stuff for SENS project.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/11/1997         Start.

--*/


#include "common.hxx"

#ifdef DBG
extern DWORD gdwDebugOutputLevel;
#endif // DBG

//
// Constants
//

#define MAX_DBGPRINT_LEN        512

//
// Available only on Debug builds.
//

#if DBG

#define SENS_DEBUG_PREFIXA "[SENS] "
#define SENS_DEBUG_PREFIXW L"[SENS] "


ULONG _cdecl
SensDbgPrintA(
    CHAR * Format,
    ...
    )
/*++

Routine Description:

    Equivalent of NT's DbgPrint().

Arguments:

    Same as for printf()

Return Value:

    0, if successful.

--*/
{
    va_list arglist;
    CHAR OutputBuffer[MAX_DBGPRINT_LEN];
    ULONG length;

    // See if we are supposed to print
    if (0x0 == gdwDebugOutputLevel)
        {
        return -1;
        }

    length = sizeof(SENS_DEBUG_PREFIXA);
    memcpy(OutputBuffer, SENS_DEBUG_PREFIXA, length); // indicate this is a SENS message.

    //
    // Put the information requested by the caller onto the line
    //

    va_start(arglist, Format);

    HRESULT hr = StringCchVPrintfA(&OutputBuffer[length - 1], MAX_DBGPRINT_LEN - length, Format, arglist);

    // We don't care about failures - this just means the result was truncated.

    va_end(arglist);

    //
    //  Just output to the debug terminal
    //

    OutputDebugStringA(OutputBuffer);

    return (0);
}


ULONG _cdecl
SensDbgPrintW(
    WCHAR * Format,
    ...
    )
/*++

Routine Description:

    Equivalent of NT's DbgPrint().

Arguments:

    Same as for printf()

Return Value:

    0, if successful.

--*/
{
    va_list arglist;
    WCHAR OutputBuffer[MAX_DBGPRINT_LEN];
    ULONG length;

    // See if we are supposed to print
    if (0x0 == gdwDebugOutputLevel)
        {
        return -1;
        }

    length = sizeof(SENS_DEBUG_PREFIXW);
    memcpy(OutputBuffer, SENS_DEBUG_PREFIXW, length); // indicate this is a SENS message.

    //
    // Put the information requested by the caller onto the line
    //

    va_start(arglist, Format);

    HRESULT hr = StringCchVPrintfW(&OutputBuffer[(length/sizeof(WCHAR))-1], MAX_DBGPRINT_LEN - (length/sizeof(WCHAR)), Format, arglist);

    // We don't care about failures - this just means the result was truncated.

    va_end(arglist);

    //
    //  Just output to the debug terminal
    //

    OutputDebugStringW(OutputBuffer);
    
    return (0);
}


BOOL
ValidateError(
    IN int Status,
    IN unsigned int Count,
    IN const int ErrorList[])
/*++
Routine Description

    Tests that 'Status' is one of an expected set of error codes.
    Used on debug builds as part of the VALIDATE() macro.

Example:

        VALIDATE(EventStatus)
            {
            RPC_P_CONNECTION_CLOSED,
            RPC_P_RECEIVE_FAILED,
            RPC_P_CONNECTION_SHUTDOWN
            // more error codes here
            } END_VALIDATE;

     This function is called with the RpcStatus and expected errors codes
     as parameters.  If RpcStatus is not one of the expected error
     codes and it not zero a message will be printed to the debugger
     and the function will return false.  The VALIDATE macro ASSERT's the
     return value.

Arguments:

    Status - Status code in question.
    Count - number of variable length arguments

    ... - One or more expected status codes.  Terminated with 0 (RPC_S_OK).

Return Value:

    TRUE - Status code is in the list or the status is 0.

    FALSE - Status code is not in the list.

--*/
{
    unsigned int i;

    for (i = 0; i < Count; i++)
        {
        if (ErrorList[i] == Status)
            {
            return TRUE;
            }
        }

    SensPrintToDebugger(SENS_DEB, ("[SENS] Assertion: unexpected failure %lu (0x%08x)\n",
                        (unsigned long)Status, (unsigned long)Status));

    return(FALSE);
}



void
EnableDebugOutputIfNecessary(
    void
    )
/*++

    This routine tries to set gdwDebugOuputLevel to the value defined
    in the regitry at HKLM\Software\Microsoft\Mobile\SENS\Debug value.
    All binaries using this function need to define the following
    global value:

        DWORD gdwDebugOutputLevel;

--*/
{
    HRESULT hr;
    HKEY hKeySens;
    LONG RegStatus;
    BOOL bStatus;
    DWORD dwType;
    DWORD cbData;
    LPBYTE lpbData;

    hr = S_OK;
    hKeySens = NULL;
    RegStatus = ERROR_SUCCESS;
    bStatus = FALSE;
    dwType = 0x0;
    cbData = 0x0;
    lpbData = NULL;

    RegStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE, // Handle of the key
                    SENS_REGISTRY_KEY,  // String which represents the sub-key to open
                    0,                  // Reserved (MBZ)
                    KEY_QUERY_VALUE,    // Security Access mask
                    &hKeySens           // Returned HKEY
                    );
    if (RegStatus != ERROR_SUCCESS)
        {
        SensPrintToDebugger(SENS_ERR, ("[SENS] RegOpenKeyEx(Sens) returned %d.\n", RegStatus));
        goto Cleanup;
        }

    //
    // Query the Configured value
    //
    lpbData = (LPBYTE) &gdwDebugOutputLevel;
    cbData = sizeof(DWORD);

    RegStatus = RegQueryValueEx(
                    hKeySens,           // Handle of the sub-key
                    SENS_DEBUG_LEVEL,   // Name of the Value
                    NULL,               // Reserved (MBZ)
                    &dwType,            // Address of the type of the Value
                    lpbData,            // Address of the data of the Value
                    &cbData             // Address of size of data of the Value
                    );
    if (RegStatus != ERROR_SUCCESS)
        {
        SensPrintToDebugger(SENS_ERR, ("[SENS] RegQueryValueEx(SENS_DEBUG_LEVEL) failed with 0x%x\n", RegStatus));
        gdwDebugOutputLevel = 0x0;
        goto Cleanup;
        }

    SensPrintToDebugger(SENS_INFO, ("[SENS] Debug Output is turned %s. The level is 0x%x.\n",
                        gdwDebugOutputLevel ? "ON" : "OFF", gdwDebugOutputLevel));

Cleanup:
    //
    // Cleanup
    //
    if (hKeySens)
        {
        RegCloseKey(hKeySens);
        }

    return;
}
#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\common\sysinc.h ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sysinc.h

Abstract:

    This contains all the platform-independent stuff for the SENS project.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          3/6/1998         Start.

--*/


#ifndef __SYSINC_H__
#define __SYSINC_H__

//
// Global defines
//

#ifndef SENS_CHICAGO

#define SENS_NT
#define UNICODE
#define _UNICODE

#else // SENS_CHICAGO

#undef UNICODE
#undef _UNICODE

#endif // SENS_CHICAGO



//
// Includes
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <tchar.h>
#include <stdio.h>
#include <windows.h>
#include <rpc.h>
#include <strsafe.h>



//
// Typedefs
//
typedef WCHAR               SENS_CHAR;
typedef SHORT               SENS_SCHAR;

typedef WCHAR               *PSENS_CHAR;
typedef SHORT               *PSENS_SCHAR;

//
// Defines
//
#define SENS_STRING(string)     L##string
#define SENS_BSTR(bstr)         L##bstr

//
// Function Mappings
//

//
// Threadpool Apis
//

#define SENS_TIMER_CALLBACK_RETURN          VOID NTAPI
#define SENS_LONG_ITEM                      (WT_EXECUTELONGFUNCTION)
#define SENS_TIMER_CREATE_FAILED(bStatus, hTimer) \
        (FALSE == bStatus)

// Use KERNEL32's Win32 functions
#define SensQueueUserWorkItem               QueueUserWorkItem
#define SensRegisterWaitForSingleObject     RegisterWaitForSingleObject
#define SensUnregisterWait                  UnregisterWait
#define SensCreateTimerQueue                CreateTimerQueue
#define SensDeleteTimerQueue                DeleteTimerQueue
#define SensCancelTimerQueueTimer(TimerQueue, Timer, Event) \
        DeleteTimerQueueTimer(TimerQueue, Timer, Event)      
#define SensSetTimerQueueTimer(bStatus, hTimer, hQueue, pfnCallback, pContext, dwDueTime, dwPeriod, dwFlags) \
        bStatus = CreateTimerQueueTimer(&hTimer, hQueue, pfnCallback, pContext, dwDueTime, dwPeriod, SENS_LONG_ITEM)        

//
// Output Macros and functions
//
#ifdef DBG

//
// Currently these macros get preprocesed as some some variants of printf.
// Eventually, these will be replaced by a function more comprehensive than
// printf.
//
// Notes:
//
// o SensDbgPrintW works like ntdll!DbgPrint() except that it can handle wide
//   strings.
//
#define SensPrint(_LEVEL_, _X_)             SensDbgPrintW _X_
#define SensPrintA(_LEVEL_, _X_)            SensDbgPrintA _X_
#define SensPrintW(_LEVEL_, _X_)            SensDbgPrintW _X_
#define SensPrintToDebugger(_LEVEL_, _X_)   DbgPrint      _X_
#define SensBreakPoint()                    DebugBreak()

#else // RETAIL

//
// The following functions do nothing and they should be optimized and no
// code should be generated by the compiler.
//
#define SensPrint(_LEVEL_, _X_)             // Nothing
#define SensPrintA(_LEVEL_, _X_)            // Nothing
#define SensPrintW(_LEVEL_, _X_)            // Nothing
#define SensPrintToDebugger(_LEVEL_, _X_)   // Nothing
#define SensBreakPoint()                    // Nothing

#endif // DBG


#endif // __SYSINC_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\notify\stub_usertok_c.c ===
#include <usertok_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\sensapi\sensutil.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sensutil.cxx

Abstract:

    Utility routines for SENS Connectivity API implementation.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          12/4/1997         Start.

--*/


#include "memfunc.hxx"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\sensapi\stub_api_c.c ===
#include <api_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\sensapi\sensapi.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sensapi.cxx

Abstract:

    Implementation of the SENS Connectivity APIs. These are just stubs
    which call into SENS to do the actual work.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          12/4/1997         Start.

--*/



#include <common.hxx>
#include <windows.h>
#include <api.h>
#include <sensapi.h>
#include <sensapi.hxx>
#include <cache.hxx>


//
// Globals
//

RPC_BINDING_HANDLE  ghSens;
CRITICAL_SECTION    gSensapiLock;
DWORD               gdwCacheLastUpdatedTime;
DWORD               gdwCacheFirstReadTime;
PSENS_CACHE         gpSensCache;


BOOL
IsNetworkAlive(
    OUT LPDWORD lpdwFlags
    )
/*++

Routine Description:

    We try to find out if this machine has any network connectivity.

Arguments:

    lpdwFlags - Receives information regarding the nature of the machine's
        network connectivity. It can be on of the following:
        o NETWORK_ALIVE_WAN
        o NETWORK_ALIVE_LAN

Notes:

    a. This is available only for TCP/IP
    b. This API does not generate any Network traffic.

Return Value:

    TRUE, if there is network connectivity

    FALSE, otherwise. Use GetLastError() to retrieve more error information.

--*/
{
    BOOL bNetState;
    RPC_STATUS RpcStatus;
    DWORD fNetNature;
    DWORD dwLastError;

    // Basic parameter checks
    if (lpdwFlags == NULL)
        {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }

    // OUT parameter intialization.
    *lpdwFlags = 0x0;
    fNetNature = 0x0;
    dwLastError = ERROR_SUCCESS;
    bNetState = FALSE;

    if (TRUE == ReadConnectivityCache(lpdwFlags))
        {
        return TRUE;
        }

    //
    // Need to contact SENS for information.
    //
    RpcStatus = DoRpcSetup();

    //
    // Try to get the state information.
    //
    if (RPC_S_OK == RpcStatus)
        {
        RpcStatus = RPC_IsNetworkAlive(
                        ghSens,
                        &fNetNature,
                        &bNetState,
                        &dwLastError
                        );
        }

    if (   (RPC_S_OK != RpcStatus)
        || (RPC_S_SERVER_UNAVAILABLE == dwLastError))
        {
        //
        // An RPC failure occurred. We treat this as a success and
        // set to return values to default values.
        //
        bNetState = TRUE;
        fNetNature = NETWORK_ALIVE_LAN;

        if (RPC_S_OK != RpcStatus)
            {
            dwLastError = RpcStatus;
            }
        }

    ASSERT((bNetState == TRUE) || (bNetState == FALSE));
    ASSERT(fNetNature <= (NETWORK_ALIVE_LAN | NETWORK_ALIVE_WAN));

    *lpdwFlags = fNetNature;
    SetLastError(dwLastError);

    // Since we retrieved information from SENS directly, reset the flag that
    // that indicates that we read from the cache.
    gdwCacheFirstReadTime = 0x0;

    return (bNetState);
}


BOOL
IsDestinationReachableA(
    LPCSTR lpszDestination,
    LPQOCINFO lpQOCInfo
    )
/*++

Routine Description:

    Given the name of a destination (IP Address, UNC, URL etc), we try to
    see if it is reachable.

Arguments:

    lpszDestination - The destination (an ANSI string) whose rechability
        is of interest.

    lpQOCInfo - Pointer to a buffer that will receive Quality of Connection
        (QOC) Information. Can be NULL if QOC is not desired.

Notes:

    a. This is available only for TCP/IP

Return Value:

    TRUE, if the destination is reachable.

    FALSE, otherwise. Use GetLastError() to retrieve more error information.

--*/
{
    BOOL bReachable;
    NTSTATUS NtStatus;
    ANSI_STRING AnsiString;
    UNICODE_STRING UnicodeString;
    size_t uiLength;

    // Basic parameter checks
    if (   (lpszDestination == NULL)
        || ((uiLength = strlen(lpszDestination)) > MAX_DESTINATION_LENGTH)
        || (uiLength == 0))
        {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }

    // OUT parameter intialization.
    bReachable = FALSE;

    RtlInitAnsiString(&AnsiString, (PSZ)lpszDestination);

    NtStatus = RtlAnsiStringToUnicodeString(
                   &UnicodeString,
                   &AnsiString,
                   TRUE
                   );
    if (!NT_SUCCESS(NtStatus))
        {
        SetLastError(ERROR_OUTOFMEMORY);  // Only possible error.
        return bReachable;
        }

    // Call the Unicode version.
    bReachable = IsDestinationReachableW(
                     UnicodeString.Buffer,
                     lpQOCInfo
                     );

    ASSERT((bReachable == TRUE) || (bReachable == FALSE));

    RtlFreeUnicodeString(&UnicodeString);

    return (bReachable);
}




BOOL
IsDestinationReachableW(
    LPCWSTR lpszDestination,
    LPQOCINFO lpQOCInfo
    )
/*++

Routine Description:

    Given the name of a destination (IP Address, UNC, URL etc), we try to
    see if it is reachable.

Arguments:

    lpszDestination - The destination (a UNICODE string) whose rechability
        is of interest.

    lpQOCInfo - Pointer to a buffer that will receive Quality of Connection
        (QOC) Information. Can be NULL if QOC is not desired.

Notes:

    a. This is available only for TCP/IP

Return Value:

    TRUE, if the destination is reachable.

    FALSE, otherwise. Use GetLastError() to retrieve more error information.

--*/
{
    BOOL bReachable;
    RPC_STATUS RpcStatus;
    DWORD dwLastError;
    DWORD dwCallerQOCInfoSize;
    size_t uiLength;

    // Basic parameter checks
    if (   (lpszDestination == NULL)
        || ((uiLength = wcslen(lpszDestination)) > MAX_DESTINATION_LENGTH)
        || (uiLength == 0)
        || ( (lpQOCInfo != NULL) && (lpQOCInfo->dwSize < sizeof(QOCINFO)) ) )
        {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
        }

    // OUT parameter intialization.
    dwLastError = ERROR_SUCCESS;
    bReachable = FALSE;
    if (lpQOCInfo != NULL)
        {
        dwCallerQOCInfoSize = lpQOCInfo->dwSize;
        memset(lpQOCInfo, 0, lpQOCInfo->dwSize);
        lpQOCInfo->dwSize = dwCallerQOCInfoSize;
        }

    RpcStatus = DoRpcSetup();

    //
    // Try to get the state information.
    //
    if (RPC_S_OK == RpcStatus)
        {
        RpcStatus = RPC_IsDestinationReachableW(
                        ghSens,
                        (PSENS_CHAR) lpszDestination,
                        lpQOCInfo,
                        &bReachable,
                        &dwLastError
                        );
        }

    if (   (RPC_S_OK != RpcStatus)
        || (RPC_S_SERVER_UNAVAILABLE == dwLastError))
        {
        //
        // An RPC failure occurred. We treat this as a success and
        // set to return values to default values.
        //
        if (lpQOCInfo != NULL)
            {
            lpQOCInfo->dwFlags  = NETWORK_ALIVE_LAN;
            lpQOCInfo->dwInSpeed  = DEFAULT_LAN_BANDWIDTH;
            lpQOCInfo->dwOutSpeed = DEFAULT_LAN_BANDWIDTH;
            }
        bReachable = TRUE;

        if (RPC_S_OK != RpcStatus)
            {
            dwLastError = RpcStatus;
            }
        }

    ASSERT((bReachable == TRUE) || (bReachable == FALSE));

    SetLastError(dwLastError);

    return (bReachable);
}


inline RPC_STATUS
DoRpcSetup(
    void
    )
/*++

Routine Description:

    Do the miscellaneous work to talk to SENS via RPC.

Arguments:

    None.

Return Value:

    None.

--*/
{
    RPC_BINDING_HANDLE bh = NULL;
    RPC_STATUS status = RPC_S_OK;
 
    if (ghSens != NULL)
        {
        return (status);
        }

    RequestLock();

    if (ghSens != NULL)
        {
        ReleaseLock();
        return (status);
        }

    status = BindToSensService(bh);

    if (status == RPC_S_OK)
        {
        ASSERT(bh);
        ghSens = bh;
        }

    ReleaseLock();

    return status;
}


BOOL
MapSensCacheView(
    void
    )
/*++

Routine Description:

    Prepare to read SENS information cache.

Arguments:

    None.

Notes:

    Should call it under a lock.

Return Value:

    TRUE, if successful.

    FALSE, otherwise.

--*/
{
    HANDLE hSensFile = NULL;

    //
    // First, open the SENS cache file mapping object
    //
    hSensFile = OpenFileMapping(
                        FILE_MAP_READ,      // Protection for mapping object
                        FALSE,              // Inherit flag
                        SENS_CACHE_NAME     // Name of the file mapping object
                        );
    if (NULL == hSensFile)
        {
        goto Cleanup;
        }
    //
    // Map a view of SENS cache into the address space
    //
    gpSensCache = (PSENS_CACHE) MapViewOfFile(
                      hSensFile,        // Map file object
                      FILE_MAP_READ,    // Access mode
                      0,                // High-order 32 bits of file offset
                      0,                // Low-order 32 bits of file offset
                      0                 // Number of bytes to map
                      );

    //
    // Close the file handle in all cases; we don't need it anymore.
    //
    CloseHandle(hSensFile);

    if (NULL == gpSensCache)
        {
        goto Cleanup;
        }

    ASSERT(gpSensCache->dwCacheVer  >= SENS_CACHE_VERSION);
    ASSERT(gpSensCache->dwCacheSize >= sizeof(SENS_CACHE));

    return TRUE;

Cleanup:
    //
    // Cleanup
    //
    UnmapSensCacheView();

    return FALSE;
}



void
UnmapSensCacheView(
    void
    )
/*++

Routine Description:

    Cleanup resources related to SENS information cache.

Arguments:

    None.

Notes:

    None.

Return Value:

    None.

--*/
{
    BOOL bStatus;

    //
    // Unmap the view of SENS cache from the address space
    //
    if (gpSensCache != NULL)
        {
        bStatus = UnmapViewOfFile(gpSensCache);
        ASSERT(bStatus);
        }

    gpSensCache = NULL;
}



BOOL
ReadConnectivityCache(
    OUT LPDWORD lpdwFlags
    )
/*++

Routine Description:

    Try to read SENS connectivity cache. Talk to SENS iff one of the following
    conditions is TRUE:

        o Failed to read the connectivity cache.
        o Read the cache but connectivity state is FALSE.
        o Read the cache and connectivity state is TRUE but stale.
        o Read the cache and there is updated information available.

Arguments:

    lpdwFlags - OUT parameter that contains the connectivity state.

Return Value:

    TRUE, successfully got cached information.

    FALSE, SENS needs to be contacted.

--*/
{
    DWORD dwNow;

    dwNow = GetTickCount();

    RequestLock();

    // Failed to initialize/read Sens Cache
    if (   (NULL == gpSensCache)
        && (FALSE == MapSensCacheView()))
        {
        goto Cleanup;
        }

    // Cache has been updated since we last read. Note that dwLastUpdateTime
    // can wrap around.
    if (gpSensCache->dwLastUpdateTime != gdwCacheLastUpdatedTime)
        {
        gdwCacheLastUpdatedTime = gpSensCache->dwLastUpdateTime;
        goto Cleanup;
        }

    // It's been a while.
    if (   (gdwCacheFirstReadTime != 0x0)
        && (dwNow - gdwCacheFirstReadTime) > CACHE_VALID_INTERVAL)
        {
        goto Cleanup;
        }

    // Cached state is FALSE
    if (0x0 == gpSensCache->dwLastUpdateState)
        {
        goto Cleanup;
        }

    *lpdwFlags = gpSensCache->dwLastUpdateState;
    if (0 == gdwCacheFirstReadTime)
        {
        gdwCacheFirstReadTime = dwNow;
        }
    ASSERT(gdwCacheLastUpdatedTime == gpSensCache->dwLastUpdateTime);

    ReleaseLock();

    SetLastError(ERROR_SUCCESS);

    return TRUE;

Cleanup:
    //
    // Cleanup
    //
    ReleaseLock();

    // Don't need to SetLastError() as we will go to SENS to retrieve it.

    return FALSE;
}



extern "C" int APIENTRY
DllMain(
    IN HINSTANCE hInstance,
    IN DWORD dwReason,
    IN LPVOID lpvReserved
    )
/*++

Routine Description:

    This routine will get called either when a process attaches to this dll
    or when a process detaches from this dll.

Return Value:

    TRUE - Initialization successfully occurred.

    FALSE - Insufficient memory is available for the process to attach to
        this dll.

--*/
{
    BOOL bSuccess;
    RPC_STATUS RpcStatus;

    switch (dwReason)
        {
        case DLL_PROCESS_ATTACH:
            // Disable Thread attach/detach calls
            bSuccess = DisableThreadLibraryCalls(hInstance);
            ASSERT(bSuccess == TRUE);

            // Initialize the lock
            InitializeCriticalSection(&gSensapiLock);
            break;

        case DLL_PROCESS_DETACH:
            // Clean the lock
            DeleteCriticalSection(&gSensapiLock);

            // Cleanup cache related resources
            UnmapSensCacheView();

            // Cleanup RPC Binding handle
            if (ghSens != NULL)
                {
                RpcStatus = RpcBindingFree(&ghSens);
                ASSERT(RPC_S_OK == RpcStatus);
                }
            break;

        }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\idl\makefile.inc ===
!INCLUDE $(NTMAKEENV)\makefile.plt

#
# Common MIDL related define
#

CPP_CMD = -cpp_cmd "$(MIDL_CPP)"
CPP_OPT = $(MIDL_FLAGS)
MIDL_INC = -I$(COM_INC_PATH) -I$(SDK_INC_PATH) -I$(CRT_INC_PATH) -I..\sensapi -I..\sensapip
COMMON_FLAGS= -Oicf -error all -robust -c_ext -ms_ext -oldnames -char unsigned $(CPP_CMD) $(CPP_OPT) $(MIDL_INC)

#
# Common variables
#

OUTPUT =$(_OBJ_DIR)\$(TARGET_DIRECTORY)
SENSAPI =api
NOTIFY =notify
TOKEN =usertok

#
# Destination for generated files
#

SENSAPI_HDR =..\senssvc\$(SENSAPI).h
SENSAPI_CSTUB=..\sensapi\$(SENSAPI)_c.c
SENSAPI_SSTUB=..\senssvc\$(SENSAPI)_s.c

NOTIFY_HDR =..\senssvc\$(NOTIFY).h
NOTIFY_CSTUB=..\sensapip\$(NOTIFY)_c.c
NOTIFY_CSTUB2=..\senslogn\$(NOTIFY)_c.c
NOTIFY_SSTUB=..\senssvc\$(NOTIFY)_s.c

TOKEN_HDR=..\senslogn\$(TOKEN).h
TOKEN_CSTUB=..\notify\$(TOKEN)_c.c
TOKEN_SSTUB=..\senslogn\$(TOKEN)_s.c


#
# Targets
#

allidl: sensapi notify token


#
# SENS Connectivity APIs
#
sensapi: $(OUTPUT)\$(SENSAPI).h $(OUTPUT)\$(SENSAPI)_c.c $(OUTPUT)\$(SENSAPI)_s.c

$(OUTPUT)\$(SENSAPI).h $(OUTPUT)\$(SENSAPI)_c.c $(OUTPUT)\$(SENSAPI)_s.c: $(SENSAPI).idl $(SENSAPI).acf
        midl $(COMMON_FLAGS) -out $(OUTPUT) $(SENSAPI).idl

#
# SENS Notify APIs (Private)
#
notify: $(OUTPUT)\$(NOTIFY).h $(OUTPUT)\$(NOTIFY)_c.c $(OUTPUT)\$(NOTIFY)_s.c

$(OUTPUT)\$(NOTIFY).h $(OUTPUT)\$(NOTIFY)_c.c $(OUTPUT)\$(NOTIFY)_s.c: $(NOTIFY).idl $(NOTIFY).acf
        midl $(COMMON_FLAGS) /prefix client "SensApip_" -out $(OUTPUT) $(NOTIFY).idl


#
# Info about currently logged-in user (Private)
#
token: $(OUTPUT)\$(TOKEN).h $(OUTPUT)\$(TOKEN)_c.c $(OUTPUT)\$(TOKEN)_s.c

$(OUTPUT)\$(TOKEN).h $(OUTPUT)\$(TOKEN)_c.c $(OUTPUT)\$(TOKEN)_s.c: $(TOKEN).idl $(TOKEN).acf
        midl $(COMMON_FLAGS) -prefix server _ -out $(OUTPUT) $(TOKEN).idl
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\sensapip\stub_notify_c.c ===
#include <notify_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\notify\token.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       token.cxx
//
//--------------------------------------------------------------------------

#include <common.hxx>
#include <usertok.h>

extern "C"
{
HANDLE
GetCurrentUserTokenW(
                      WCHAR Winsta[],
                      DWORD DesiredAccess
                      );

HANDLE
GetCurrentUserTokenA(
                     char Winsta[],
                     DWORD DesiredAccess
                     );
}

HANDLE
GetCurrentUserTokenW(
                      WCHAR Winsta[],
                      DWORD DesiredAccess
                      )
{
    unsigned long handle = 0;
    error_status_t status;
    handle_t binding;

    status = BindToLRpcService(binding, L"ncalrpc:[IUserProfile]");
    if (status)
        {
        SetLastError(status);
        return 0;
        }

    status = SecpGetCurrentUserToken( binding, Winsta, &handle, DesiredAccess);
    if (status)
        {
        RpcBindingFree( &binding );
        if (status == RPC_S_UNKNOWN_AUTHN_SERVICE ||
            status == RPC_S_SERVER_UNAVAILABLE    ||
            status == RPC_S_CALL_FAILED )
            {
            status = ERROR_NOT_LOGGED_ON;
            }

        SetLastError(status);
        return 0;
        }

    RpcBindingFree( &binding );

    return ULongToPtr(handle);
}

HANDLE
GetCurrentUserTokenA(
                     char Winsta[],
                     DWORD DesiredAccess
                     )
{
    HANDLE hToken = 0;
    PWSTR UnicodeWinsta;
    unsigned Length;

    Length = MultiByteToWideChar(CP_ACP, 0, Winsta, -1, 0, 0);

    UnicodeWinsta = (PWSTR)HeapAlloc(GetProcessHeap(), 0, Length*sizeof(WCHAR));
    if (!UnicodeWinsta)
        {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return hToken;
        }

    if (MultiByteToWideChar( CP_ACP,
                             0,        // no special flags
                             Winsta,
                             -1,
                             UnicodeWinsta,
                             Length
                             ) != 0)
        {
        hToken = GetCurrentUserTokenW( UnicodeWinsta, DesiredAccess );
        }
    // else LastError() set by MultiByteToWideChar

    HeapFree(GetProcessHeap(), 0, UnicodeWinsta);
    return hToken;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\sensapip\sensapip.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    sensapip.cxx

Abstract:

    Code for SensNotify* APIs which are called by external components
    to notify SENS of external events.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/4/1997         Start.

--*/



#include <common.hxx>
#include <rpc.h>
#include <notify.h>
#include <windows.h>


//
// Constants
//
#define FREE_NETCON_PROPERTIES  "NcFreeNetconProperties"
#define NETSHELL_DLL            SENS_STRING("netshell.dll")

//
// Define these constants to include respective portions of this
// file.
//
// #define SENSNOTIFY_OTHER_EVENT
// #define SENSNOTIFY_WINLOGON_EVENT
//

//
// Typedefs
//
typedef  void (STDAPICALLTYPE *PFN_FREE_NETCON_PROPERTIES) (NETCON_PROPERTIES* pProps);

//
// Globals
//

RPC_BINDING_HANDLE ghSensNotify = NULL;




inline RPC_STATUS
DoRpcSetup(
    void
    )
/*++

Routine Description:

    Do the miscellaneous work to talk to SENS via RPC.

Arguments:

    None.

Return Value:

    None.

--*/
{
    RPC_BINDING_HANDLE bh = NULL;
    RPC_STATUS status = RPC_S_OK;

    //
    // NOTE: This is called very early in the system startup and so, it is
    // guaranteed to be serialized. So, a lock is not necessary.
    //

    if (ghSensNotify != NULL)
        {
        return (status);
        }

    status = BindToSensService(bh);

    if (status == RPC_S_OK)
        {
        ASSERT(bh);
        ASSERT(ghSensNotify == NULL);
        ghSensNotify = bh;
        }

    return (status);
}

#if defined(SENSNOTIFY_WINLOGON_EVENT)


DWORD
SensNotifyWinlogonEvent(
    PSENS_NOTIFY_WINLOGON pEvent
    )
/*++

Routine Description:



Arguments:

    None.

Return Value:

    None.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = DoRpcSetup();
    if (RPC_S_OK != RpcStatus)
        {
        return RpcStatus;
        }

    RpcStatus = SensApip_RPC_SensNotifyWinlogonEvent(
                    ghSensNotify,
                    pEvent
                    );
    if (RpcStatus)
        {
        return RpcStatus;
        }

    return (ERROR_SUCCESS);
}


#endif // SENSNOTIFY_WINLOGON_EVENT

#if defined(SENSNOTIFY_OTHER_EVENT)


DWORD
SensNotifyRasEvent(
    PSENS_NOTIFY_RAS pEvent
    )
/*++

Routine Description:

    Entry point for RAS to notify SENS of various RAS Events.

Arguments:

    None.

Return Value:

    None.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = DoRpcSetup();
    if (RPC_S_OK != RpcStatus)
        {
        return RpcStatus;
        }

    RpcStatus = SensApip_RPC_SensNotifyRasEvent(
                    ghSensNotify,
                    pEvent
                    );
    if (RpcStatus)
        {
        return RpcStatus;
        }

    return (ERROR_SUCCESS);
}





DWORD
SensNotifyNetconEvent(
    PSENS_NOTIFY_NETCON pEvent
    )
/*++

Routine Description:

    Entry point for Network UI to notify SENS of LAN Connect/Disconnect events.

Arguments:

    pEvent - Pointer to Netcon event notification data.

Return Value:

    S_OK, if successful.

    Failed hr, otherwise

--*/
{
    HRESULT hr;
    RPC_STATUS RpcStatus;
    SENS_NOTIFY_NETCON_P Data;
    NETCON_PROPERTIES *pNetconProperties;

    hr = S_OK;
    pNetconProperties = NULL;

    //
    // Fill-in the data.
    //

    ASSERT(pEvent && pEvent->pINetConnection);
    ASSERT(   (pEvent->eType == SENS_NOTIFY_LAN_CONNECT)
           || (pEvent->eType == SENS_NOTIFY_LAN_DISCONNECT));

    hr = pEvent->pINetConnection->GetProperties(&pNetconProperties);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    if (   (NULL == pNetconProperties)
        || (pNetconProperties->MediaType != NCM_LAN)
        || (   (pNetconProperties->Status != NCS_CONNECTED)
            && (pNetconProperties->Status != NCS_DISCONNECTED)))
        {
        hr = HRESULT_FROM_WIN32(ERROR_INVALID_PARAMETER);
        goto Cleanup;
        }

    Data.eType = pEvent->eType;
    Data.Status = pNetconProperties->Status;
    Data.Type = pNetconProperties->MediaType;
    Data.Name = pNetconProperties->pszwName;


    //
    // Send the data across.
    //

    RpcStatus = DoRpcSetup();
    if (RPC_S_OK != RpcStatus)
        {
        hr = HRESULT_FROM_WIN32(RpcStatus);
        goto Cleanup;
        }

    RpcStatus = SensApip_RPC_SensNotifyNetconEvent(
                    ghSensNotify,
                    &Data
                    );
    if (RpcStatus)
        {
        hr = HRESULT_FROM_WIN32(RpcStatus);
        goto Cleanup;
        }

Cleanup:
    //
    // Cleanup
    //

    // Free NetconProperties, if necessary.
    if (pNetconProperties)
        {
        HMODULE hDll;
        PFN_FREE_NETCON_PROPERTIES pfnFreeNetconProperties;

        hDll = LoadLibrary(NETSHELL_DLL);
        if (NULL == hDll)
            {
            hr = HRESULT_FROM_WIN32(GetLastError());
            return hr;
            }

        pfnFreeNetconProperties = (PFN_FREE_NETCON_PROPERTIES)
                                  GetProcAddress(
                                       hDll,
                                       FREE_NETCON_PROPERTIES
                                       );
        if (NULL == pfnFreeNetconProperties)
            {
            hr = HRESULT_FROM_WIN32(GetLastError());
            FreeLibrary(hDll);
            return hr;
            }

        (*pfnFreeNetconProperties)(pNetconProperties);

        FreeLibrary(hDll);
        }

    return (hr);
}




DWORD
SyncMgrExecCmd(
    DWORD nCmdID,
    DWORD nCmdExecOpt
    )
/*++

Routine Description:

    Private function for Syncmgr to execute work on it's behalf.

Arguments:

    None.

Return Value:

    None.

--*/
{
    RPC_STATUS RpcStatus;

    RpcStatus = DoRpcSetup();
    if (RPC_S_OK != RpcStatus)
        {
        return RpcStatus;
        }

    RpcStatus = SensApip_RPC_SyncMgrExecCmd(
                    ghSensNotify,
                    nCmdID,
                    nCmdExecOpt
                    );
    if (RpcStatus)
        {
        return RpcStatus;
        }

    return (ERROR_SUCCESS);
}


#endif // SENSNOTIFY_OTHER_EVENT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senslogn\ntfysens.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    ntfysens.cxx

Abstract:

    File to include portions of sensapip.cxx which are relevant to
    notify SENS of Winlogon events. 

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          1/15/1999         Start.

--*/

//
// If SENSNOTIFY_WINLOGON_EVENT is defined, then Winlogon parts of the
// sensapip.cxx file are included.
//

#define SENSNOTIFY_WINLOGON_EVENT

#include <..\sensapip\sensapip.cxx>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senslogn\stub_notify_c.c ===
#include <notify_c.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senscfg\guids.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       guids.c
//
//--------------------------------------------------------------------------

INTERFACENAME = { /* d5978621-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978621,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978622-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978622,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978623-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978623,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978624-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978624,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978625-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978625,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978626-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978626,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978627-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978627,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978628-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978628,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978629-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978629,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d597862a-5b9f-11d1-8dd2-00aa004abd5e */
    0xd597862a,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d597862b-5b9f-11d1-8dd2-00aa004abd5e */
    0xd597862b,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d597862c-5b9f-11d1-8dd2-00aa004abd5e */
    0xd597862c,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d597862d-5b9f-11d1-8dd2-00aa004abd5e */
    0xd597862d,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d597862e-5b9f-11d1-8dd2-00aa004abd5e */
    0xd597862e,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d597862f-5b9f-11d1-8dd2-00aa004abd5e */
    0xd597862f,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978630-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978630,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978631-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978631,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978632-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978632,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978633-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978633,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978634-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978634,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978635-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978635,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978636-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978636,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978637-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978637,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978638-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978638,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d5978639-5b9f-11d1-8dd2-00aa004abd5e */
    0xd5978639,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d597863a-5b9f-11d1-8dd2-00aa004abd5e */
    0xd597863a,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d597863b-5b9f-11d1-8dd2-00aa004abd5e */
    0xd597863b,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d597863c-5b9f-11d1-8dd2-00aa004abd5e */
    0xd597863c,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
INTERFACENAME = { /* d597863d-5b9f-11d1-8dd2-00aa004abd5e */
    0xd597863d,
    0x5b9f,
    0x11d1,
    {0x8d, 0xd2, 0x00, 0xaa, 0x00, 0x4a, 0xbd, 0x5e}
  };
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senscfg\senscfg.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    senscfg.cxx

Abstract:

    Code to do the configuration (install/uninstall) for SENS.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          11/11/1997         Start.

--*/


#define INITGUID


#include <common.hxx>
#include <objbase.h>
#include <coguid.h>
#include <eventsys.h>
#include <sensevts.h>
#include <sens.h>
#include <wininet.h>
#include <winineti.h>
#include "senscfg.hxx"
#include "sensinfo.hxx"
#include "memfunc.hxx"


#define MAJOR_VER           1
#define MINOR_VER           0
#define DEFAULT_LCID        0x0
#define MAX_QUERY_SIZE      512
#define SENS_SETUP          "SENSCFG: "
#define SENS_SERVICEA       "SENS"
#define SENS_SETUPW         SENS_BSTR("SENSCFG: ")
#define SENS_SERVICE        SENS_STRING("SENS")
#define SENS_DISPLAY_NAME   SENS_STRING("System Event Notification")
#define SENS_SERVICE_GROUP  SENS_STRING("Network")
#define EVENTSYSTEM_REMOVE  SENS_STRING("esserver /remove")
#define EVENTSYSTEM_INSTALL SENS_STRING("esserver /install")
#define SENS_WINLOGON_DLL   SENS_STRING("senslogn.dll")
#define GUID_STR_SIZE       sizeof("{12345678-1234-1234-1234-123456789012}")
#define EVENTSYSTEM_KEY     SENS_STRING("SOFTWARE\\Microsoft\\EventSystem")
#define WINLOGON_NOTIFY_KEY SENS_STRING("SOFTWARE\\Microsoft\\Windows NT\\")   \
                            SENS_STRING("CurrentVersion\\Winlogon\\Notify\\")  \
                            SENS_STRING("senslogn")
#define WININET_SENS_EVENTS INETEVT_RAS_CONNECT     |   \
                            INETEVT_RAS_DISCONNECT  |   \
                            INETEVT_LOGON           |   \
                            INETEVT_LOGOFF


//
// DLL vs EXE dependent constants
//
#if defined(SENS_NT4)
#define SENS_TLBA           "SENS.EXE"
#define SENS_BINARYA        "SENS.EXE"
#define SENS_TLB            SENS_STRING("SENS.EXE")
#define SENS_BINARY         SENS_STRING("SENS.EXE")
#else  // SENS_NT4
#define SENS_TLBA           "SENS.DLL"
#define SENS_BINARYA        "SENS.DLL"
#define SENS_TLB            SENS_STRING("SENS.DLL")
#define SENS_BINARY         SENS_STRING("SENS.DLL")
#endif // SENS_NT4


//
// Misc debugging constants
//
#ifdef STRICT_HRESULT_CHECKS

#ifdef SUCCEEDED
#undef SUCCEEDED
#define SUCCEEDED(_HR_) (_HR_ == S_OK)
#endif // SUCCEEDED

#ifdef FAILED
#undef FAILED
#define FAILED(_HR_)    (_HR_ != S_OK)
#endif // FAILED

#endif // STRICT_HRESULT_CHECKS



//
// Globals
//

IEventSystem    *gpIEventSystem;
ITypeLib        *gpITypeLib;

#ifdef DBG
DWORD           gdwDebugOutputLevel;
#endif // DBG



HRESULT APIENTRY
SensRegister(
    void
    )
/*++

Routine Description:

    Register SENS.

Arguments:

    None.

Return Value:

    HRESULT returned from SensConfigurationHelper()

--*/
{
    return (SensConfigurationHelper(FALSE));
}




HRESULT APIENTRY
SensUnregister(
    void
    )
/*++

Routine Description:

    Unregister SENS.

Arguments:

    None.

Return Value:

    HRESULT returned from SensConfigurationHelper()

--*/
{
    return (SensConfigurationHelper(TRUE));
}




HRESULT
SensConfigurationHelper(
    BOOL bUnregister
    )
/*++

Routine Description:

    Main entry into the SENS configuration utility.

Arguments:

    bUnregister - If TRUE, then unregister SENS as a publisher.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HRESULT hr;

    hr = S_OK;
    gpIEventSystem = NULL;
    gpITypeLib = NULL;

#ifdef DBG
    EnableDebugOutputIfNecessary();
#endif // DBG

    //
    // Configure EventSystem first during an install and last during an uninstall.
    //
    if (FALSE == bUnregister)
        {
        hr = SensConfigureEventSystem(FALSE);
        if (FAILED(hr))
            {
            SensPrintA(SENS_ERR, (SENS_SETUP "Failed to configure EventSystem, HRESULT=%x\n", hr));
            goto Cleanup;
            }
        SensPrintA(SENS_INFO, (SENS_SETUP "Successfully configured EventSystem\n"));
        }

    //
    // Instantiate the Event System
    //
    hr = CoCreateInstance(
             CLSID_CEventSystem,
             NULL,
             CLSCTX_SERVER,
             IID_IEventSystem,
             (LPVOID *) &gpIEventSystem
             );
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "Failed to create CEventSystem, HRESULT=%x\n", hr));
        goto Cleanup;
        }
    SensPrintA(SENS_INFO, (SENS_SETUP "Successfully created CEventSystem\n"));

    //
    // Register Event Classes (and hence, indirectly events) published by SENS.
    //
    hr = RegisterSensEventClasses(bUnregister);
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "Failed to %sregister SENS Events"
                   " - hr = <%x>\n", bUnregister ? "un" : "", hr));
        goto Cleanup;
        }
    SensPrintA(SENS_INFO, (SENS_SETUP "%segistered SENS Publisher Events.\n",
               bUnregister ? "Unr" : "R", hr));

    //
    // Register the subscriptions of SENS.
    //
    hr = RegisterSensSubscriptions(bUnregister);
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "Failed to %sregister SENS Subscriptions"
                   " - hr = <%x>\n", bUnregister ? "un" : "", hr));
        goto Cleanup;
        }
    SensPrintA(SENS_ERR, (SENS_SETUP "%segistered SENS Subscriptions.\n",
               bUnregister ? "Unr" : "R", hr));

    //
    // Register the SENS TypeLibs.
    //
    hr = RegisterSensTypeLibraries(bUnregister);
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "Failed to %sregister SENS Type Libraries"
                   " - hr = <%x>\n", bUnregister ? "un" : "", hr));
        // Abort only during the Install phase...
        if (bUnregister == FALSE)
            {
            goto Cleanup;
            }
        }
    SensPrintA(SENS_INFO, (SENS_SETUP "%segistered SENS Type Libraries.\n",
               bUnregister ? "Unr" : "R", hr));

    //
    // Configure EventSystem first during an install and last during an uninstall.
    //
    if (TRUE == bUnregister)
        {
        hr = SensConfigureEventSystem(TRUE);
        if (FAILED(hr))
            {
            SensPrintA(SENS_ERR, (SENS_SETUP "Failed to configure EventSystem, HRESULT=%x\n", hr));
            goto Cleanup;
            }
        SensPrintA(SENS_INFO, (SENS_SETUP "Successfully configured EventSystem\n"));
        }

    //
    // Register SENS CLSID in the registry.
    //
    hr = RegisterSensCLSID(
             SENSGUID_SUBSCRIBER_LCE,
             SENS_SUBSCRIBER_NAME_EVENTOBJECTCHANGE,
             bUnregister
             );
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "Failed to %sregister SENS CLSID"
                   " - hr = <%x>\n", bUnregister ? "un" : "", hr));
        goto Cleanup;
        }
    SensPrintA(SENS_INFO, (SENS_SETUP "%segistered SENS CLSID.\n",
               bUnregister ? "Unr" : "R", hr));

    //
    // Update Configured value
    //
    hr = SensUpdateVersion(bUnregister);
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "Failed to update SENS version"
                   " - hr = <%x>\n", hr));
        goto Cleanup;
        }
    SensPrintA(SENS_INFO, (SENS_SETUP "Updated SENS version.\n"));


Cleanup:
    //
    // Cleanup
    //
    if (gpIEventSystem)
        {
        gpIEventSystem->Release();
        }

    if (gpITypeLib)
        {
        gpITypeLib->Release();
        }

    SensPrintA(SENS_ERR, ("\n" SENS_SETUP "SENS Configuration %s.\n",
               SUCCEEDED(hr) ? "successful" : "failed"));

    return (hr);
}




HRESULT
RegisterSensEventClasses(
    BOOL bUnregister
    )
/*++

Routine Description:

    Register/Unregister all the Events published by SENS.

Arguments:

    bUnregister - If TRUE, then unregister all SENS Events.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    int             i;
    int             errorIndex;
    HRESULT         hr;
    LPOLESTR        strGuid;
    LPOLESTR        strEventClassID;
    WCHAR           szQuery[MAX_QUERY_SIZE];
    BSTR            bstrEventClassID;
    BSTR            bstrEventClassName;
    BSTR            bstrFiringInterface;
    IEventClass     *pIEventClass;

    hr = S_OK;
    strGuid = NULL;
    errorIndex = 0;
    strEventClassID = NULL;
    bstrEventClassID = NULL;
    bstrEventClassName = NULL;
    bstrFiringInterface = NULL;
    pIEventClass = NULL;

    for (i = 0; i < SENS_PUBLISHER_EVENTCLASS_COUNT; i++)
        {
        // Get a new IEventClass.
        hr = CoCreateInstance(
                 CLSID_CEventClass,
                 NULL,
                 CLSCTX_SERVER,
                 IID_IEventClass,
                 (LPVOID *) &pIEventClass
                 );
        if (FAILED(hr))
            {
            SensPrintA(SENS_ERR, (SENS_SETUP "RegisterSensEventClasses() failed to create "
                       "IEventClass - hr = <%x>\n", hr));
            goto Cleanup;
            }

        if (bUnregister)
            {
            // Form the query
            StringCchCopy(szQuery, MAX_QUERY_SIZE, SENS_BSTR("EventClassID="));
            AllocateStrFromGuid(strEventClassID, *(gSensEventClasses[i].pEventClassID));
            StringCchCat(szQuery, MAX_QUERY_SIZE, strEventClassID);

            hr = gpIEventSystem->Remove(
                                     PROGID_EventClass,
                                     szQuery,
                                     &errorIndex
                                     );
            FreeStr(strEventClassID);
            if (FAILED(hr))
                {
                SensPrintA(SENS_ERR, (SENS_SETUP "RegisterSensEventClasses(%d) failed to Store"
                           " - hr = <%x>\n", i, hr));
                goto Cleanup;
                }

            pIEventClass->Release();
            pIEventClass = NULL;

            continue;
            }

        AllocateBstrFromGuid(bstrEventClassID, *(gSensEventClasses[i].pEventClassID));
        hr = pIEventClass->put_EventClassID(bstrEventClassID);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromString(bstrEventClassName, gSensEventClasses[i].strEventClassName);
        hr = pIEventClass->put_EventClassName(bstrEventClassName);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromGuid(bstrFiringInterface, *(gSensEventClasses[i].pFiringInterfaceGUID));
        hr = pIEventClass->put_FiringInterfaceID(bstrFiringInterface);
        ASSERT(SUCCEEDED(hr));

        FreeBstr(bstrEventClassID);
        FreeBstr(bstrEventClassName);
        FreeBstr(bstrFiringInterface);

        hr = gpIEventSystem->Store(PROGID_EventClass, pIEventClass);
        if (FAILED(hr))
            {
            SensPrintA(SENS_ERR, (SENS_SETUP "RegisterSensEventClasses(%d) failed to Store"
                       " - hr = <%x>\n", i, hr));
            goto Cleanup;
            }

        pIEventClass->Release();

        pIEventClass = NULL;
        } // for loop

Cleanup:
    //
    // Cleanup
    //
    if (pIEventClass)
        {
        pIEventClass->Release();
        }

    FreeStr(strGuid);

    return (hr);
}




HRESULT
RegisterSensSubscriptions(
    BOOL bUnregister
    )
/*++

Routine Description:

    Register/Unregister the Event subscriptions of SENS.

Arguments:

    bUnregister - If TRUE, then unregister all subscriptions of SENS.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    int                 i;
    int                 errorIndex;
    HRESULT             hr;
    LPOLESTR            strGuid;
    LPOLESTR            strSubscriptionID;
    LPOLESTR            strEventClassID;
    WCHAR               szQuery[MAX_QUERY_SIZE];
    BSTR                bstrEventClassID;
    BSTR                bstrInterfaceID;
    BSTR                bstrPublisherID;
    BSTR                bstrSubscriptionID;
    BSTR                bstrSubscriptionName;
    BSTR                bstrSubscriberCLSID;
    BSTR                bstrMethodName;
    BSTR                bstrPublisherPropertyName;
    BSTR                bstrPublisherPropertyValue;
    VARIANT             variantPublisherPropertyValue;
    BSTR                bstrPROGID_EventSubscription;
    IEventSubscription  *pIEventSubscription;

    hr = S_OK;
    strGuid = NULL;
    errorIndex = 0;
    strEventClassID = NULL;
    bstrEventClassID = NULL;
    bstrInterfaceID = NULL;
    bstrPublisherID = NULL;
    strSubscriptionID = NULL;
    bstrSubscriptionID = NULL;
    bstrSubscriberCLSID = NULL;
    bstrSubscriptionName = NULL;
    bstrMethodName = NULL;
    bstrPublisherPropertyName = NULL;
    bstrPublisherPropertyValue = NULL;
    bstrPROGID_EventSubscription = NULL;
    pIEventSubscription = NULL;

    AllocateBstrFromGuid(bstrPublisherID, SENSGUID_PUBLISHER);
    AllocateBstrFromGuid(bstrSubscriberCLSID, SENSGUID_SUBSCRIBER_LCE);
    AllocateBstrFromString(bstrPROGID_EventSubscription, PROGID_EventSubscription);

    for (i = 0; i < SENS_SUBSCRIPTIONS_COUNT; i++)
        {
        if (bUnregister)
            {
            // Form the query
            StringCchCopy(szQuery, MAX_QUERY_SIZE, SENS_BSTR("SubscriptionID="));
            AllocateStrFromGuid(strSubscriptionID, *(gSensSubscriptions[i].pSubscriptionID));
            StringCchCat(szQuery, MAX_QUERY_SIZE,  strSubscriptionID);

            hr = gpIEventSystem->Remove(
                                     PROGID_EventSubscription,
                                     szQuery,
                                     &errorIndex
                                     );
            FreeStr(strSubscriptionID);

            if (FAILED(hr))
                {
                SensPrintA(SENS_ERR, (SENS_SETUP "RegisterSensSubscriptionis(%d) failed to Remove"
                           " - hr = <%x>\n", i, hr));
                goto Cleanup;
                }

            continue;
            }

        // Get a new IEventSubscription object to play with.
        hr = CoCreateInstance(
                 CLSID_CEventSubscription,
                 NULL,
                 CLSCTX_SERVER,
                 IID_IEventSubscription,
                 (LPVOID *) &pIEventSubscription
                 );
        if (FAILED(hr))
            {
            SensPrintA(SENS_ERR, (SENS_SETUP "RegisterSensSubscriptions(%d) failed to create "
                       "IEventSubscriptions - hr = <%x>\n", i, hr));
            goto Cleanup;
            }

        AllocateBstrFromGuid(bstrSubscriptionID, *(gSensSubscriptions[i].pSubscriptionID));
        hr = pIEventSubscription->put_SubscriptionID(bstrSubscriptionID);
        ASSERT(SUCCEEDED(hr));

        hr = pIEventSubscription->put_PublisherID(bstrPublisherID);
        ASSERT(SUCCEEDED(hr));

        hr = pIEventSubscription->put_SubscriberCLSID(bstrSubscriberCLSID);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromString(bstrSubscriptionName, gSensSubscriptions[i].strSubscriptionName);
        hr = pIEventSubscription->put_SubscriptionName(bstrSubscriptionName);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromString(bstrMethodName, gSensSubscriptions[i].strMethodName);
        hr = pIEventSubscription->put_MethodName(bstrMethodName);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromGuid(bstrEventClassID, *(gSensSubscriptions[i].pEventClassID));
        hr = pIEventSubscription->put_EventClassID(bstrEventClassID);
        ASSERT(SUCCEEDED(hr));

        AllocateBstrFromGuid(bstrInterfaceID, *(gSensSubscriptions[i].pInterfaceID));
        hr = pIEventSubscription->put_InterfaceID(bstrInterfaceID);
        ASSERT(SUCCEEDED(hr));

        if (gSensSubscriptions[i].bPublisherPropertyPresent == TRUE)
            {
            if (NULL != (gSensSubscriptions[i].pPropertyEventClassIDValue))
                {
                // Create the Query string.
                StringCchCopy(szQuery, MAX_QUERY_SIZE,  gSensSubscriptions[i].strPropertyEventClassID);
                StringCchCat(szQuery, MAX_QUERY_SIZE,  SENS_BSTR("="));
                AllocateStrFromGuid(strEventClassID, *(gSensSubscriptions[i].pPropertyEventClassIDValue));
                StringCchCat(szQuery, MAX_QUERY_SIZE,  strEventClassID);
                StringCchCat(szQuery, MAX_QUERY_SIZE,  SENS_BSTR(" AND "));
                StringCchCat(szQuery, MAX_QUERY_SIZE,  gSensSubscriptions[i].strPropertyMethodName);
                StringCchCat(szQuery, MAX_QUERY_SIZE,  SENS_BSTR("=\'"));
                StringCchCat(szQuery, MAX_QUERY_SIZE,  gSensSubscriptions[i].strPropertyMethodNameValue);
                StringCchCat(szQuery, MAX_QUERY_SIZE,  SENS_BSTR("\'"));

                AllocateBstrFromString(bstrPublisherPropertyName, SENS_BSTR("Criteria"));
                AllocateBstrFromString(bstrPublisherPropertyValue, szQuery);
                InitializeBstrVariant(&variantPublisherPropertyValue, bstrPublisherPropertyValue);
                hr = pIEventSubscription->PutPublisherProperty(
                                              bstrPublisherPropertyName,
                                              &variantPublisherPropertyValue
                                              );
                ASSERT(SUCCEEDED(hr));
                SensPrintA(SENS_INFO, (SENS_SETUP "PutPublisherProperty(Criteria) returned 0x%x\n", hr));

                FreeStr(strEventClassID);
                FreeBstr(bstrPublisherPropertyName);
                FreeBstr(bstrPublisherPropertyValue);
                }
            else
                {
                //
                // We are dealing with the "ANY" subscription of SENS.
                //

                // Create the Query string.
                StringCchCopy(szQuery, MAX_QUERY_SIZE,  gSensSubscriptions[i].strPropertyEventClassID);
                StringCchCat(szQuery, MAX_QUERY_SIZE,  SENS_BSTR("="));
                AllocateStrFromGuid(strEventClassID, SENSGUID_EVENTCLASS_NETWORK);
                StringCchCat(szQuery, MAX_QUERY_SIZE,  strEventClassID);
                StringCchCat(szQuery, MAX_QUERY_SIZE,  SENS_BSTR(" OR "));
                FreeStr(strEventClassID);

                StringCchCat(szQuery, MAX_QUERY_SIZE,  gSensSubscriptions[i].strPropertyEventClassID);
                StringCchCat(szQuery, MAX_QUERY_SIZE,  SENS_BSTR("="));
                AllocateStrFromGuid(strEventClassID, SENSGUID_EVENTCLASS_LOGON);
                StringCchCat(szQuery, MAX_QUERY_SIZE,  strEventClassID);
                StringCchCat(szQuery, MAX_QUERY_SIZE,  SENS_BSTR(" OR "));
                FreeStr(strEventClassID);

                StringCchCat(szQuery, MAX_QUERY_SIZE,  gSensSubscriptions[i].strPropertyEventClassID);
                StringCchCat(szQuery, MAX_QUERY_SIZE,  SENS_BSTR("="));
                AllocateStrFromGuid(strEventClassID, SENSGUID_EVENTCLASS_ONNOW);
                StringCchCat(szQuery, MAX_QUERY_SIZE,  strEventClassID);
                FreeStr(strEventClassID);


                AllocateBstrFromString(bstrPublisherPropertyName, SENS_BSTR("Criteria"));
                AllocateBstrFromString(bstrPublisherPropertyValue, szQuery);
                InitializeBstrVariant(&variantPublisherPropertyValue, bstrPublisherPropertyValue);
                hr = pIEventSubscription->PutPublisherProperty(
                                              bstrPublisherPropertyName,
                                              &variantPublisherPropertyValue
                                              );
                ASSERT(SUCCEEDED(hr));
                SensPrintA(SENS_INFO, (SENS_SETUP "PutPublisherProperty(Criteria) returned 0x%x\n", hr));

                FreeBstr(bstrPublisherPropertyName);
                FreeBstr(bstrPublisherPropertyValue);
                }
            }

        FreeBstr(bstrSubscriptionID);
        FreeBstr(bstrSubscriptionName);
        FreeBstr(bstrMethodName);
        FreeBstr(bstrEventClassID);
        FreeBstr(bstrInterfaceID);

        hr = gpIEventSystem->Store(bstrPROGID_EventSubscription, pIEventSubscription);
        if (FAILED(hr))
            {
            SensPrintA(SENS_ERR, (SENS_SETUP "RegisterSensSubscriptions(%d) failed to Store"
                       " - hr = <%x>\n", i, hr));

            goto Cleanup;
            }

        pIEventSubscription->Release();

        pIEventSubscription = NULL;
        } // for loop

Cleanup:
    //
    // Cleanup
    //
    if (pIEventSubscription)
        {
        pIEventSubscription->Release();
        }

    FreeBstr(bstrPublisherID);
    FreeBstr(bstrSubscriberCLSID);
    FreeBstr(bstrPROGID_EventSubscription);
    FreeStr(strGuid);

    return (hr);
}




HRESULT
RegisterSensTypeLibraries(
    BOOL bUnregister
    )
/*++

Routine Description:

    Register/Unregister the Type Libraries of SENS.

Arguments:

    bUnregister - If TRUE, then unregister all subscriptions of SENS.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HRESULT hr;
    UINT uiLength;
    TCHAR buffer[MAX_PATH+1+sizeof(SENS_BINARYA)+1];    // +1 for '\'

    hr = S_OK;
    uiLength = 0;

    //
    // Get the Full path name to the SENS TLB (which is a resource in SENS.EXE)
    //
    uiLength = GetSystemDirectory(
                   buffer,
                   MAX_PATH
                   );
    if (uiLength == 0)
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        SensPrintA(SENS_ERR, (SENS_SETUP "GetSystemDirectory(%s) failed - hr = <%x>\n",
                   SENS_TLBA, hr));
        goto Cleanup;
        }
    StringCbCat(buffer, sizeof(buffer), SENS_STRING("\\") SENS_TLB);

    hr = LoadTypeLibEx(
             buffer,
             REGKIND_NONE,
             &gpITypeLib
             );
    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "LoadTypeLib(%s) failed "
                   " - hr = <%x>\n", SENS_TLBA, hr));
        goto Cleanup;
        }

    //
    // Ensure that the TypeLib is (un)registered
    //
    if (bUnregister)
        {
        hr = UnRegisterTypeLib(
                 LIBID_SensEvents,
                 MAJOR_VER,
                 MINOR_VER,
                 DEFAULT_LCID,
                 SYS_WIN32
                 );
        }
    else
        {
        hr = RegisterTypeLib(
                 gpITypeLib,
                 buffer,
                 NULL
                 );
        }

    if (FAILED(hr))
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "%sRegisterTypeLib(%s) failed "
                   " - hr = <%x>\n", (bUnregister ? "Un" : ""), SENS_TLBA, hr));
        }

Cleanup:
    //
    // Cleanup
    //

    return (hr);
}




HRESULT
RegisterSensCLSID(
    REFIID clsid,
    TCHAR* strSubscriberName,
    BOOL bUnregister
    )
/*++

Routine Description:

    Register/Unregister the CLSID of SENS.

Arguments:

    clsid - CLSID of the Subscriber for LCE events.

    strSubscriberName - Name of the Subscriber.

    bUnregister - If TRUE, then unregister the CLSID of SENS.

Notes:

    This function also registers SENS to receive IE5's WININET events.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HRESULT hr;
    HMODULE hModule;
    HKEY appidKey;
    HKEY clsidKey;
    HKEY serverKey;
    WCHAR *szCLSID;
    WCHAR *szCLSID2;
    WCHAR *szLIBID;
    TCHAR *szCLSID_t;
    TCHAR *szCLSID2_t;
    TCHAR *szLIBID_t;
    TCHAR *szFriendlyName;
    TCHAR szPath[MAX_PATH+1+sizeof(SENS_BINARYA)+1];    // +1 for '\'
    UINT uiLength;
    DWORD dwDisposition;
    LONG lResult;

    hr = S_OK;
    appidKey = NULL;
    clsidKey = NULL;
    serverKey = NULL;
    szCLSID = NULL;
    szCLSID2 = NULL;
    szLIBID = NULL;
    szCLSID_t = NULL;
    szCLSID2_t = NULL;
    szLIBID_t = NULL;
    uiLength = 0;
    dwDisposition = 0x0;
    szFriendlyName = strSubscriberName;

    //
    // Get the Full path name to the SENS executable
    //
    uiLength = GetSystemDirectory(
                   szPath,
                   MAX_PATH
                   );
    if (uiLength == 0)
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        SensPrintA(SENS_ERR, (SENS_SETUP "GetSystemDirectory(%s) failed - hr = <%x>\n",
                   SENS_BINARYA, hr));
        goto Cleanup;
        }
    StringCbCat(szPath, sizeof(szPath), SENS_STRING("\\") SENS_BINARY);

    //
    // Convert the CLSID into a WCHAR.
    //

    hr = StringFromCLSID(clsid, &szCLSID);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    if (bUnregister == FALSE)
        {
        hr = StringFromCLSID(LIBID_SensEvents, &szLIBID);
        if (FAILED(hr))
            {
            goto Cleanup;
            }
        }

    szCLSID_t  = szCLSID;
    szLIBID_t  = szLIBID;

    // Build the key CLSID\\{clsid}
    TCHAR clsidKeyName[sizeof "CLSID\\{12345678-1234-1234-1234-123456789012}"];
    StringCbCopy(clsidKeyName, sizeof(clsidKeyName), SENS_STRING("CLSID\\"));
    StringCbCat(clsidKeyName, sizeof(clsidKeyName), szCLSID_t);

    // Build the key AppID\\{clsid}
    TCHAR appidKeyName[sizeof "AppID\\{12345678-1234-1234-1234-123456789012}"];
    StringCbCopy(appidKeyName, sizeof(appidKeyName), SENS_STRING("AppID\\"));
    StringCbCat(appidKeyName, sizeof(appidKeyName), szCLSID_t);

    if (bUnregister)
        {
        hr = RecursiveDeleteKey(HKEY_CLASSES_ROOT, clsidKeyName);
        if (FAILED(hr))
            {
            goto Cleanup;
            }

        hr = RecursiveDeleteKey(HKEY_CLASSES_ROOT, appidKeyName);

        goto Cleanup;
        }

    // Create the CLSID\\{clsid} key
    hr = CreateKey(
             HKEY_CLASSES_ROOT,
             clsidKeyName,
             szFriendlyName,
             &clsidKey
             );
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    //
    // Under the CLSID\\{clsid} key, create a named value
    //          AppID = {clsid}
    hr = CreateNamedValue(clsidKey, SENS_STRING("AppID"), szCLSID_t);
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    //
    // Create the appropriate server key beneath the clsid key.
    // For servers, this is CLSID\\{clsid}\\LocalServer32.
    // In both cases, the default value is the module path name.
    //
    hr = CreateKey(
             clsidKey,
             SENS_STRING("LocalServer32"),
             szPath,
             &serverKey
             );
    if (FAILED(hr))
        {
        goto Cleanup;
        }
    RegCloseKey(serverKey);

    //
    // Create CLSID\\{clsid}\\TypeLib subkey with a default value of
    // the LIBID of the TypeLib
    //
    hr = CreateKey(
             clsidKey,
             SENS_STRING("TypeLib"),
             szLIBID_t,
             &serverKey
             );
    if (FAILED(hr))
        {
        goto Cleanup;
        }
    RegCloseKey(serverKey);


    // Register APPID.
    hr = CreateKey(
             HKEY_CLASSES_ROOT,
             appidKeyName,
             szFriendlyName,
             &appidKey
             );
    if (FAILED(hr))
        {
        goto Cleanup;
        }

    // Under AppId\{clsid} key, create a named value [LocalService = "SENS"]
    hr = CreateNamedValue(appidKey, SENS_STRING("LocalService"), SENS_STRING("SENS"));
    if (FAILED(hr))
        {
        goto Cleanup;
        }
Cleanup:
    //
    // Cleanup
    //
    CoTaskMemFree(szCLSID);
    CoTaskMemFree(szLIBID);

    if (clsidKey != NULL)
        {
        RegCloseKey(clsidKey);
        }
    if (appidKey != NULL)
        {
        RegCloseKey(appidKey);
        }

    return hr;
}


HRESULT
CreateKey(
    HKEY hParentKey,
    const TCHAR* KeyName,
    const TCHAR* defaultValue,
    HKEY* hKey
    )
/*++

Routine Description:

    Create a key (with an optional default value).  The handle to the key is
    returned as an [out] parameter.  If NULL is passed as the key parameter,
    the key is created in the registry, then closed.

Arguments:

    hParentKey - Handle to the parent Key.

    KeyName - Name of the key to create.

    defaultValue - The default value for the key to create.

    hKey - OUT Handle to key that was created.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HKEY hTempKey;
    LONG lResult;

    hTempKey = NULL;

    lResult = RegCreateKeyEx(
                  hParentKey,               // Handle to open key
                  KeyName,                  // Subkey name
                  0,                        // Reserved
                  NULL,                     // Class string
                  REG_OPTION_NON_VOLATILE,  // Options Flag
                  KEY_ALL_ACCESS,           // Desired Security access
                  NULL,                     // Pointer to Security Attributes structure
                  &hTempKey,                // Handle of the opened/created key
                  NULL                      // Disposition value
                  );

    if (lResult != ERROR_SUCCESS)
        {
        return HRESULT_FROM_WIN32(lResult);
        }

    // Set the default value for the key
    if (defaultValue != NULL)
        {
        lResult = RegSetValueEx(
                      hTempKey,             // Key to set Value for.
                      NULL,                 // Value to set
                      0,                    // Reserved
                      REG_SZ,               // Value Type
                      (BYTE*) defaultValue, // Address of Value data
                      sizeof(TCHAR) * (_tcslen(defaultValue)+1) // Size of Value
                      );

        if (lResult != ERROR_SUCCESS)
            {
            RegCloseKey(hTempKey);
            return HRESULT_FROM_WIN32(lResult);
            }
        }

    if (hKey == NULL)
        {
        RegCloseKey(hTempKey);
        }
    else
        {
        *hKey = hTempKey;
        }

    return S_OK;
}




HRESULT
CreateNamedValue(
    HKEY hKey,
    const TCHAR* title,
    const TCHAR* value
    )
/*++

Routine Description:

    Create a named value under a key

Arguments:

    hKey - Handle to the parent Key.

    title - Name of the Value to create.

    value - The data for the Value under the Key.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HRESULT hr;
    LONG lResult;

    hr = S_OK;

    lResult = RegSetValueEx(
                  hKey,             // Key to set Value for.
                  title,            // Value to set
                  0,                // Reserved
                  REG_SZ,           // Value Type
                  (BYTE*) value,    // Address of Value data
                  sizeof(TCHAR) * (_tcslen(value)+1) // Size of Value
                  );

    if (lResult != ERROR_SUCCESS)
        {
        hr = HRESULT_FROM_WIN32(lResult);
        }

    return hr;
}




HRESULT
CreateNamedDwordValue(
    HKEY hKey,
    const TCHAR* title,
    DWORD dwValue
    )
/*++

Routine Description:

    Create a named DWORD value under a key

Arguments:

    hKey - Handle to the parent Key.

    title - Name of the Value to create.

    dwValue - The data for the Value under the Key.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HRESULT hr;
    LONG lResult;

    hr = S_OK;

    lResult = RegSetValueEx(
                  hKey,             // Key to set Value for.
                  title,            // Value to set
                  0,                // Reserved
                  REG_DWORD,        // Value Type
                  (BYTE*) &dwValue, // Address of Value data
                  sizeof(DWORD)     // Size of Value
                  );

    if (lResult != ERROR_SUCCESS)
        {
        hr = HRESULT_FROM_WIN32(lResult);
        }

    return hr;
}




HRESULT
RecursiveDeleteKey(
    HKEY hKeyParent,
    const TCHAR* lpszKeyChild
    )
/*++

Routine Description:

    Delete a key and all of its descendents.

Arguments:

    hKeyParent - Handle to the parent Key.

    lpszKeyChild - The data for the Value under the Key.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HKEY hKeyChild;
    LONG lResult;

    //
    // Open the child.
    //
    lResult = RegOpenKeyEx(
                  hKeyParent,       // Handle to the Parent
                  lpszKeyChild,     // Name of the child key
                  0,                // Reserved
                  KEY_ALL_ACCESS,   // Security Access Mask
                  &hKeyChild        // Handle to the opened key
                  );

    if (lResult != ERROR_SUCCESS)
        {
        return HRESULT_FROM_WIN32(lResult);
        }

    //
    // Enumerate all of the decendents of this child.
    //
    FILETIME time;
    TCHAR szBuffer[MAX_PATH+1];
    const DWORD bufSize = sizeof szBuffer / sizeof szBuffer[0];
    DWORD dwSize = bufSize;

    while (TRUE)
        {
        lResult = RegEnumKeyEx(
                      hKeyChild,    // Handle of the key to enumerate
                      0,            // Index of the subkey to retrieve
                      szBuffer,     // OUT Name of the subkey
                      &dwSize,      // OUT Size of the buffer for name of subkey
                      NULL,         // Reserved
                      NULL,         // OUT Class of the enumerated subkey
                      NULL,         // OUT Size of the class of the subkey
                      &time         // OUT Last time the subkey was written to
                      );

        if (lResult != ERROR_SUCCESS)
            {
            break;
            }

        // Delete the decendents of this child.
        lResult = RecursiveDeleteKey(hKeyChild, szBuffer);
        if (lResult != ERROR_SUCCESS)
            {
            // Cleanup before exiting.
            RegCloseKey(hKeyChild);
            return HRESULT_FROM_WIN32(lResult);
            }

        dwSize = bufSize;
        } // while

    // Close the child.
    RegCloseKey(hKeyChild);

    // Delete this child.
    lResult = RegDeleteKey(hKeyParent, lpszKeyChild);

    return HRESULT_FROM_WIN32(lResult);
}




HRESULT
SensConfigureEventSystem(
    BOOL bUnregister
    )
/*++

Routine Description:

    As of NTbuild 1750, EventSystem is not auto-configured. So, SENS does
    the work of configuring EventSystem.

Arguments:

    bUnregister - If TRUE, then install EventSystem.

Notes:

    o This is a dummy call on NT4 because we don't need to configure
      EventSystem on NT4. IE5 setup (Webcheck.dll) configures LCE.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    return S_OK;
}




HRESULT
SensUpdateVersion(
    BOOL bUnregister
    )
/*++

Routine Description:

    Update the version of SENS in the registry.

Arguments:

    bUnregister - usual.

Return Value:

    S_OK, if successful

    hr, otherwise

--*/
{
    HRESULT hr;
    HKEY hKeySens;
    LONG RegStatus;
    DWORD dwConfigured;

    hr = S_OK;
    hKeySens = NULL;
    RegStatus = ERROR_SUCCESS;

    RegStatus = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE, // Handle of the key
                    SENS_REGISTRY_KEY,  // String which represents the sub-key to open
                    0,                  // Reserved (MBZ)
                    KEY_ALL_ACCESS,     // Security Access mask
                    &hKeySens           // Returned HKEY
                    );
    if (RegStatus != ERROR_SUCCESS)
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "RegOpenKeyEx(Sens) returned %d.\n", RegStatus));
        hr = HRESULT_FROM_WIN32(RegStatus);
        goto Cleanup;
        }

    if (TRUE == bUnregister)
        {
        dwConfigured = CONFIG_VERSION_NONE;
        }
    else
        {
        dwConfigured = CONFIG_VERSION_CURRENT;
        }

    // Update registry to reflect that SENS is now configured.
    RegStatus = RegSetValueEx(
                  hKeySens,             // Key to set Value for.
                  IS_SENS_CONFIGURED,   // Value to set
                  0,                    // Reserved
                  REG_DWORD,            // Value Type
                  (BYTE*) &dwConfigured,// Address of Value data
                  sizeof(DWORD)         // Size of Value
                  );
    if (RegStatus != ERROR_SUCCESS)
        {
        SensPrintA(SENS_ERR, (SENS_SETUP "RegSetValueEx(IS_SENS_CONFIGURED) failed with 0x%x\n", RegStatus));
        hr = HRESULT_FROM_WIN32(RegStatus);
        goto Cleanup;
        }

    SensPrintA(SENS_INFO, (SENS_SETUP "SENS is now configured successfully. "
               "Registry updated to 0x%x.\n", dwConfigured));

Cleanup:
    //
    // Cleanup
    //
    if (hKeySens)
        {
        RegCloseKey(hKeySens);
        }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senslogn\onestop.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    onestop.hxx

Abstract:

    This file contains the common functions that are helpful in notifying
    OneStop of logon/logoff events.

Author:

    Gopal Parupudi    <GopalP>

Notes:

    a. This is being used in senslogn.dll on NT5.
    b. It is also being used in sens.dll on NT4 and Win9x.

Revision History:

    GopalP          4/29/1998         Start.

--*/


#include <mobsyncp.h>
#include "onestop.hxx"




HRESULT
SensNotifyOneStop(
    HANDLE hToken,
    TCHAR *pCommandLine,
    BOOL bSync
    )
{
    TCHAR szCommandLine[256];
    DWORD dwLastError;
    STARTUPINFO si;
    PROCESS_INFORMATION ProcessInformation;

    dwLastError = 0;

    // CreateProcess* APIs require an editable buffer for command-line parameter
    HRESULT hr = StringCchCopy(szCommandLine, 256, pCommandLine);
    ASSERT(SUCCEEDED(hr));

    // Fill in the STARTUPINFO structure.
    memset(&si, 0x0, sizeof(STARTUPINFO));
    si.cb = sizeof(STARTUPINFO);
    si.lpReserved = NULL;
    si.lpTitle = NULL;
    si.lpDesktop = NULL;
    si.dwX = 0x0;
    si.dwY = 0x0;
    si.dwXSize = 0x0;
    si.dwYSize = 0x0;
    si.dwFlags = 0x0;
    si.wShowWindow = SW_SHOW;
    si.lpReserved2 = NULL;
    si.cbReserved2 = 0;

    LogMessage((SENSLOGN "[%d] Launching OneStop...\n", GetTickCount()));
    if (CreateProcessAsUser(
            hToken,             // Handle to the Token of the logged-on user
            NULL,               // Name of the executable module
            szCommandLine,      // Command-line string
            NULL,               // Security attributes
            NULL,               // Thread security attributes
            FALSE,              // Don't inherit handles
            0,                  // Creation flags
            NULL,               // New environment block
            NULL,               // Current directory name
            &si,                // Startup info
            &ProcessInformation // Process information
            ))
        {
        //
        // Wait until the process terminates
        //
        if (bSync)
            {
            LogMessage((SENSLOGN "[%d] Waiting for OneStop to return...\n", GetTickCount()));
            WaitForSingleObject(ProcessInformation.hProcess, INFINITE);
            LogMessage((SENSLOGN "[%d] OneStop returned successfully.\n", GetTickCount()));
            }

        CloseHandle(ProcessInformation.hProcess);
        CloseHandle(ProcessInformation.hThread);

        return S_OK;
        }
    else
        {
        dwLastError = GetLastError();
        SensPrintToDebugger(SENS_DBG, (SENSLOGN "SensNotifyOneStop() - CreateProcessXXX() "
                            "failed with 0x%x\n", dwLastError));
        return HRESULT_FROM_WIN32(dwLastError);
        }

    LogMessage((SENSLOGN "[%d] Successfully notified OneStop.\n", GetTickCount()));

    return S_OK;
}




BOOL
IsAutoSyncEnabled(
    HANDLE hToken,
    DWORD dwMask
    )
{
    HKEY hKeyAutoSync;
    LONG lResult;
    BOOL bEnabled;
    DWORD dwType;
    DWORD dwAutoSyncFlags;
    DWORD cbData;
    LPBYTE lpbData;

    hKeyAutoSync = NULL;
    lResult = 0;
    bEnabled = FALSE;
    dwType = 0x0;
    dwAutoSyncFlags = 0x0;
    cbData = 0x0;
    lpbData = NULL;

    //
    // Open AutoSync sub-key for this machine.
    //
    lResult = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,   // Handle of the open Key
                  AUTOSYNC_KEY,         // Name of the sub-key
                  0,                    // Reserved (MBZ)
                  KEY_QUERY_VALUE,      // Security access mask
                  &hKeyAutoSync         // Address of the handle of new key
                  );
    if (lResult != ERROR_SUCCESS)
        {
        SensPrintToDebugger(SENS_DBG, (SENSLOGN "RegOpenKeyEx(AUTOSYNC) failed with 0x%x\n", lResult));
        goto Cleanup;
        }

    //
    // Query the Flags value
    //
    lpbData = (LPBYTE) &dwAutoSyncFlags;
    cbData = sizeof(DWORD);

    lResult = RegQueryValueEx(
                  hKeyAutoSync,     // Handle of the sub-key
                  AUTOSYNC_FLAGS,   // Name of the Value
                  NULL,             // Reserved (MBZ)
                  &dwType,          // Address of the type of the Value
                  lpbData,          // Address of the data of the Value
                  &cbData           // Address of size of data of the Value
                  );
    if (lResult != ERROR_SUCCESS)
        {
        LogMessage((SENSLOGN "RegQueryValueEx(AUTOSYNC_FLAGS) failed with 0x%x\n", lResult));
        goto Cleanup;
        }
    ASSERT(dwType == REG_DWORD);

    //
    // Check to see if the Mask bit is set
    //
    if (dwMask == AUTOSYNC_ON_STARTSHELL)
        {
        if (  (dwAutoSyncFlags & AUTOSYNC_LAN_LOGON)
           || (dwAutoSyncFlags & AUTOSYNC_WAN_LOGON))
            {
            LogMessage((SENSLOGN "AutoSync is enabled for StartShell\n"));
            bEnabled = TRUE;
            goto Cleanup;
            }
        else
            {
            LogMessage((SENSLOGN "AutoSync is NOT enabled for Logon\n"));
            }
        }
    else
    if (dwMask == AUTOSYNC_ON_LOGOFF)
        {
        if (  (dwAutoSyncFlags & AUTOSYNC_LAN_LOGOFF)
           || (dwAutoSyncFlags & AUTOSYNC_WAN_LOGOFF))
            {
            LogMessage((SENSLOGN "AutoSync is enabled for Logoff\n"));
            bEnabled = TRUE;
            goto Cleanup;
            }
        else
            {
            LogMessage((SENSLOGN "AutoSync is NOT enabled for Logoff\n"));
            }
        }
    else
    if (dwMask == AUTOSYNC_ON_SCHEDULE)
        {
        if (dwAutoSyncFlags != NULL)
            {
            LogMessage((SENSLOGN "AutoSync is enabled for Schedule\n"));
            bEnabled = TRUE;
            goto Cleanup;
            }
        else
            {
            LogMessage((SENSLOGN "AutoSync is NOT enabled for Schedule\n"));
            }
        }

    //
    // Autosync is not enabled.
    //


Cleanup:
    //
    // Cleanup
    //
    if (hKeyAutoSync)
        {
        RegCloseKey(hKeyAutoSync);
        }
    
    return bEnabled;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senslogn\stub_usertok_s.c ===
#include <usertok_s.c>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senslogn\senslogn.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    senslogn.cxx

Abstract:

    This file contains the implementation of a Stub DLL to notify SENS of
    events generated by Winlogon.

Author:

    Gopal Parupudi    <GopalP>

Notes:

    a. This DLL notifies the following components:
        o EventSystem (contact DMcCrady)
        o IR service (contact JRoberts)
        o SENS service (contact GopalP)

    b. This DLL also maintains tokens of the currently logged on user. This
       is used by COM for activation.

Revision History:

    GopalP          12/7/1997         Start.

--*/



#include <common.hxx>
#include <stdio.h>
#include <windows.h>
#include <malloc.h>
#include <winwlx.h>
#include <sensapip.h>
#include <rpc.h>
#include "mutex.hxx"
#include "usertok.h"
#include "senslogn.hxx"
#include "onestop.cxx"


//
// Constants
//
#define NOTIFY_LCE_STARTSHELL   0x00000003
#define NOTIFY_LCE_LOGOFF       0x00000004

#define SENS_START_WAIT_TIMEOUT 180*1000    // 3 minutes
#define NOTIFY_LCE_LOGONUSER    "NotifyLogonUser"
#define NOTIFY_LCE_LOGOFFUSER   "NotifyLogoffUser"
#define SENS_SERVICE            SENS_STRING("SENS")
#define EVENTSYSTEM_DLL         SENS_STRING("ES.DLL")

//
// Globals
//

HANDLE ghSensStartedEvent;
BOOL gbIsTokenCodeInitialized;

// For GetCurrentUserToken
USER_LOGON_TABLE * ActiveUserList;

//
// Some useful Macros
//

#ifdef DETAIL_DEBUG


#define DUMP_INFO(_EventType_)                                                      \
                                                                                    \
    PWLX_NOTIFICATION_INFO pInfo = (PWLX_NOTIFICATION_INFO) lpvParam;               \
                                                                                    \
    LogMessage(("------------------------------------------------------\n"));       \
    LogMessage((SENSLOGN " Received a %s Event.\n", _EventType_));                  \
    LogMessage(("          Size        - %d\n", pInfo->Size));                      \
    LogMessage(("          Flags       - 0x%x\n", pInfo->Flags));                   \
    LogMessage(("          UserName    - %ws\n", pInfo->UserName));      \
    LogMessage(("          Domain      - %ws\n", pInfo->Domain));        \
    LogMessage(("          WinStation  - %ws\n", pInfo->WindowStation)); \
    LogMessage(("          hToken      - 0x%x\n", pInfo->hToken));                  \
    LogMessage(("          hDesktop    - 0x%x\n", pInfo->hDesktop));                \
    LogMessage(("          pCallback   - 0x%x\n", pInfo->pStatusCallback));         \
    LogMessage(("          dwSessionId - 0x%x\n", NtCurrentPeb()->SessionId));      \
    LogMessage(("------------------------------------------------------\n"));

#else // ! DETAIL_DEBUG

#define DUMP_INFO(_EventType_)

#endif // DETAIL_DEBUG



#define FIRE_EVENT(_EventType_)                                             \
    {                                                                       \
                                                                            \
    SENS_NOTIFY_WINLOGON Data;                                              \
                                                                            \
    Data.eType = _EventType_;                                               \
    Data.Info.Size = sizeof(SENS_NOTIFY_WINLOGON);                          \
    Data.Info.Flags = ((PWLX_NOTIFICATION_INFO)lpvParam)->Flags;            \
    Data.Info.UserName = ((PWLX_NOTIFICATION_INFO)lpvParam)->UserName;      \
    Data.Info.Domain = ((PWLX_NOTIFICATION_INFO)lpvParam)->Domain;          \
    Data.Info.WindowStation = ((PWLX_NOTIFICATION_INFO)lpvParam)->WindowStation;    \
    Data.Info.hToken = HandleToUlong(((PWLX_NOTIFICATION_INFO)lpvParam)->hToken);   \
    Data.Info.hDesktop = HandleToUlong(((PWLX_NOTIFICATION_INFO)lpvParam)->hDesktop); \
    Data.Info.dwSessionId = NtCurrentPeb()->SessionId;                      \
                                                                            \
    status = SensNotifyWinlogonEvent(&Data);                                \
                                                                            \
    if (status) {SensPrintToDebugger(SENS_DBG, (SENSLOGN "SensNotifyWinlogonEvent(0x%x) returned %d\n", _EventType_, status));}    \
    }


/*****************************************************************************
 *
 *  IsRemoteSession
 *
 *  On a Terminal Server: returns TRUE if current Session is the not the physical
 *  console , FALSE if it is the console session (SessionId == 0)
 *
 * ENTRY:
 *   nothing
 *
 * EXIT:
 *   nothing
 *
 ****************************************************************************/

BOOL
IsRemoteSession(VOID)
{
    DWORD dwSessionId;

    if (ProcessIdToSessionId(GetCurrentProcessId(), &dwSessionId))
        {
        return (dwSessionId != 0);
        }
    
    return FALSE;
}




DWORD WINAPI
SensLogonEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the Logon Event. In addition, we do the following:

    a. Populate our token table with the current token.
    b. Initialize The token RPC interface, if necessary.

Arguments:

    lpvParam - Winlogon notification info.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;
    PWLX_NOTIFICATION_INFO pTempInfo = (PWLX_NOTIFICATION_INFO) lpvParam;

    DUMP_INFO("Logon");

    ActiveUserList->Add( pTempInfo );

    FIRE_EVENT(SENS_NOTIFY_WINLOGON_LOGON);

    return status;
}




DWORD WINAPI
SensLogoffEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the Logoff Event. We notify various components
    (like OneStop, EventSystem, SENS) of the Logoff event.

Arguments:

    lpvParam - Winlogon notification info.

Notes:

    a. The system logoff will block till this call returns. Be very
       careful in adding code here.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;
    DWORD dwError;
    HRESULT hr;
    PWLX_NOTIFICATION_INFO pTempInfo;

    hr = S_OK;
    dwError = 0x0;
    pTempInfo = (PWLX_NOTIFICATION_INFO) lpvParam;

    LogMessage((SENSLOGN "[%d] Entered Logoff.\n", GetTickCount()));

    DUMP_INFO("Logoff");

    // Try to fire SENS Event
    LogMessage((SENSLOGN "[%d] Notifying SENS...\n", GetTickCount()));
    FIRE_EVENT(SENS_NOTIFY_WINLOGON_LOGOFF);
    LogMessage((SENSLOGN "[%d] SensNotifyWinlogonEvent(LOGOFF) succeeded.\n", GetTickCount()));

    // Start OneStop if necessary, except on Restart.
    if (   ((pTempInfo->Flags & EWX_REBOOT) == 0)
        && (IsAutoSyncEnabled(pTempInfo->hToken, AUTOSYNC_ON_LOGOFF)))
        {
        //
        // NOTE: If SENS ever becomes demandstarted on NT5, there are a couple
        //       of things that can be done:
        //          o Call StartSensIfNecessary() here. (OR)
        //          o Make Sens APIs call StartSensIfNecessary().
        //
        LogMessage((SENSLOGN "[%d] Notifying OneStop...\n", GetTickCount()));
        hr = SensNotifyOneStop(pTempInfo->hToken, SYNC_MANAGER_LOGOFF, TRUE);
        LogMessage((SENSLOGN "[%d] SensNotifyOneStop() returned 0x%x\n", GetTickCount(), hr));
        }

    // Notify EventSystem
    LogMessage((SENSLOGN "[%d] Notifying EventSystem...\n", GetTickCount()));
    hr = SensNotifyEventSystem(NOTIFY_LCE_LOGOFF, lpvParam);
    LogMessage((SENSLOGN "[%d] SensNotifyEventSystem() returned 0x%x\n", GetTickCount(), hr));

    //
    // Remove token handle from the list at the end so that COM activation
    // works till SENS gets done with event firings.
    //
    ActiveUserList->Remove( pTempInfo );
    LogMessage((SENSLOGN "Removed current user's token!\n"));

    return status;
}




DWORD WINAPI
SensStartupEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the Startup Event. Do some token management related
    initialization.

Arguments:

    lpvParam - Winlogon notification info.

Notes:

    a. This occurs very early in the bootup sequence. At this time,
       SENS service hasn't yet started up.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;
    DWORD dwLastError;

    status = 0x0;
    gbIsTokenCodeInitialized = FALSE;

    //
    // Create the table of logged-in users.
    //
    ActiveUserList = new USER_LOGON_TABLE( &status );
    if (!ActiveUserList || status)
        {
        delete ActiveUserList;
        return ERROR_NOT_ENOUGH_MEMORY;
        }

    InitializeNotifyInterface();

    //
    // We are ready to use Token Code.
    //
    gbIsTokenCodeInitialized = TRUE;
    LogMessage((SENSLOGN "**** Token code initialized successfully ****\n"));

    //
    // Create an Event to indicate the starting of SENS.
    //
    ghSensStartedEvent = CreateEvent(
                             NULL,      // Specific Security Attributes
                             TRUE,      // Event is ManualReset
                             FALSE,     // Initial state is not Signalled
                             SENS_STARTED_EVENT
                             );
    if (ghSensStartedEvent == NULL)
        {
        dwLastError = GetLastError();
        LogMessage((SENSLOGN "SensStartupEvent() - CreateEvent() failed - %x.\n",
                    dwLastError));
        }
    else
        {
        LogMessage((SENSLOGN "SensStartedEvent created successfully\n"));
        }

    DUMP_INFO("Startup");

    return status;
}




BOOLEAN
InitializeNotifyInterface(
    void
    )
/*++

Routine Description:

    Initialize RPC interface for accepting calls to GetCurrentUserToken() API.

Arguments:

    None.

Return Value:

    TRUE, if successful

    FALSE, otherwise.

--*/
{
    RPC_STATUS status;

    if (!IsRemoteSession())
        {
        status = RpcServerRegisterIfEx(
                     _GetUserToken_ServerIfHandle,
                     NULL,
                     NULL,
                     0,
                     RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                     AllowLocalSystem
                     );
        
        if (RPC_S_OK != status)
            {
            return FALSE;
            }
        }

    return TRUE;
}




DWORD WINAPI
SensStartShellEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the StartShell Event. We treat this as Logon and notify
    various components (OneStop, SENS, EventSystem) of Logon.

Arguments:

    lpvParam - Winlogon notification info.

Notes:

    a. When this function is called by Winlogon, the shell has begun starting.
       There is no guarantee that shell has started completely and is up and
       running.

    b. We create a thread to do bulk of the work and allow the function
       to return.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    BOOL bRetVal;
    DWORD status;
    DWORD dwLastError;
    PWLX_NOTIFICATION_INFO pTempInfo;
    PWLX_NOTIFICATION_INFO pDuplicateInfo;

    dwLastError = 0;
    bRetVal = TRUE;

    DUMP_INFO("StartShell");

    // Duplicate the parts of the notification info so we can process this 
    // event on another thread.
    pTempInfo = (PWLX_NOTIFICATION_INFO) lpvParam;

    SIZE_T sizeUserName = wcslen(pTempInfo->UserName) + 1;
    SIZE_T sizeDomain   = wcslen(pTempInfo->Domain) + 1;
    SIZE_T sizeWinsta   = wcslen(pTempInfo->WindowStation) + 1;

    //
    // Allocate space for the notification block
    //
    pDuplicateInfo = new WLX_NOTIFICATION_INFO;
    if (pDuplicateInfo == NULL)
        {
        dwLastError = GetLastError();
        LogMessage((SENSLOGN "SensStartShellEvent(): new() failed - %x.\n", dwLastError));
        return dwLastError;
        }

    //
    // Copy simple types, safely initialize everything in case of failure.
    //
    pDuplicateInfo->Size = sizeof(WLX_NOTIFICATION_INFO);
    pDuplicateInfo->Flags = pTempInfo->Flags;
    pDuplicateInfo->hToken = NULL;  // duplicated below, closed on error
    pDuplicateInfo->hDesktop = NULL; // not duplicated, unused
    pDuplicateInfo->pStatusCallback = NULL;
    
    // Allocate space for the string parameters.
    pDuplicateInfo->UserName = (PWSTR) new WCHAR[sizeUserName];
    pDuplicateInfo->Domain = (PWSTR) new WCHAR[sizeDomain];
    pDuplicateInfo->WindowStation = (PWSTR) new WCHAR[sizeWinsta];

    if (   (pDuplicateInfo->UserName == NULL)
        || (pDuplicateInfo->Domain == NULL)
        || (pDuplicateInfo->WindowStation == NULL))
        {
        dwLastError = GetLastError();
        LogMessage((SENSLOGN "SensStartShellEvent(): new() of strings failed - %x.\n", dwLastError));
        goto Cleanup;
        }

    //
    // Deep copy the parameters
    //
    StringCchCopy(pDuplicateInfo->UserName,      sizeUserName, pTempInfo->UserName);
    StringCchCopy(pDuplicateInfo->Domain,        sizeDomain,   pTempInfo->Domain);
    StringCchCopy(pDuplicateInfo->WindowStation, sizeWinsta,   pTempInfo->WindowStation);

    if ( !DuplicateHandle(GetCurrentProcess(),
                          pTempInfo->hToken,
                          GetCurrentProcess(),
                          &pDuplicateInfo->hToken,
                          0, // ignored, same access flag set
                          FALSE,
                          DUPLICATE_SAME_ACCESS))             
        {
        dwLastError = GetLastError();
        LogMessage((SENSLOGN "SensStartShellEvent(): failed to duplicate users token - %x\n", dwLastError));
        goto Cleanup;
        }

    //
    // Create a thread to wait on the StartShell event
    //
    bRetVal = SensQueueUserWorkItem(
                  (LPTHREAD_START_ROUTINE) SensWaitToStartRoutine,
                  pDuplicateInfo, // Winlogon event info
                  SENS_LONG_ITEM    // Flags
                  );
    if (FALSE == bRetVal)
        {
        dwLastError = GetLastError();
        LogMessage((SENSLOGN "SensStartShellEvent(): SensQueueUserWorkItem() failed with %x.\n",
                    dwLastError));
        }

    // Success - SensWaitToStartRoutine now owns pDuplicateInfo

    return 0;

Cleanup:
    // All branches here occur after the parameter block is copied and initalized
    ASSERT(pDuplicateInfo);

    if (pDuplicateInfo->hToken)
        {
        CloseHandle(pDuplicateInfo->hToken);
        }
    delete pDuplicateInfo->UserName;
    delete pDuplicateInfo->Domain;
    delete pDuplicateInfo->WindowStation;
    delete pDuplicateInfo;

    return dwLastError;
}




DWORD WINAPI
SensPostShellEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the Post Shell Event.

Arguments:

    lpvParam - Winlogon notification info.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;

    DUMP_INFO("Post Shell");

    FIRE_EVENT(SENS_NOTIFY_WINLOGON_POSTSHELL);

    return status;
}




DWORD WINAPI
SensDisconnectEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the Session Disconnect Event.

Arguments:

    lpvParam - Winlogon notification info.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;

    DUMP_INFO("Session Disconnect");

    FIRE_EVENT(SENS_NOTIFY_WINLOGON_SESSION_DISCONNECT);

    return status;
}




DWORD WINAPI
SensReconnectEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the Session Reconnect Event.

Arguments:

    lpvParam - Winlogon notification info.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;

    DUMP_INFO("Session Reconnect");

    FIRE_EVENT(SENS_NOTIFY_WINLOGON_SESSION_RECONNECT);

    return status;
}




DWORD WINAPI
SensShutdownEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the Shutdown Event. Do some cleanup.

Arguments:

    lpvParam - Winlogon notification info.

Notes:

    a. It is guaranteed that COM activation will not work when this event
       is received.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;

    status = ERROR_SUCCESS;

    DUMP_INFO("Shutdown");

    return status;
}




DWORD WINAPI
SensLockEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the Display Lock Event.

Arguments:

    lpvParam - Winlogon notification info.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;

    DUMP_INFO("Display Lock");

    FIRE_EVENT(SENS_NOTIFY_WINLOGON_LOCK);

    return status;
}




DWORD WINAPI
SensUnlockEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the Display unlock Event.

Arguments:

    lpvParam - Winlogon notification info.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;

    DUMP_INFO("Display Unlock");

    FIRE_EVENT(SENS_NOTIFY_WINLOGON_UNLOCK);

    return status;
}




DWORD WINAPI
SensStartScreenSaverEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the ScreenSaver Start Event.

Arguments:

    lpvParam - Winlogon notification info.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;

    DUMP_INFO("StartScreenSaver");

    FIRE_EVENT(SENS_NOTIFY_WINLOGON_STARTSCREENSAVER);

    return status;
}





DWORD WINAPI
SensStopScreenSaverEvent(
    LPVOID lpvParam
    )
/*++

Routine Description:

    Hook to trap the Screen Saver Stop Event.

Arguments:

    lpvParam - Winlogon notification info.

Return Value:

    RPC status from SensNotifyWinlogonEvent()

--*/
{
    DWORD status;

    DUMP_INFO("StopScreenSaver");

    FIRE_EVENT(SENS_NOTIFY_WINLOGON_STOPSCREENSAVER);

    return status;
}




DWORD WINAPI
SensWaitToStartRoutine(
    LPVOID lpvParam
    )
/*++

Routine Description:

    This routine implements the work item that is queued when the StartShell
    event is received.

Arguments:

    lpvParam - Winlogon notification info.

Return Value:

    ERROR_SUCCESS, always

--*/
{
    DWORD dwError;
    DWORD dwWaitStatus;
    DWORD status;
    HRESULT hr;
    PWLX_NOTIFICATION_INFO pTempInfo;

    dwError = ERROR_SUCCESS;
    dwWaitStatus = 0x0;
    pTempInfo = (PWLX_NOTIFICATION_INFO) lpvParam;

    // Give SENS a chance to start if it has not already stated.
    // Give up after a short time in case sens is has been set to manual start
    // We could check the service configuration but the thread as already been
    // created so we save won't very much.

    ASSERT(ghSensStartedEvent);
    
    dwError = WaitForSingleObject(ghSensStartedEvent, 20*1000);
    if (dwError != STATUS_WAIT_0)
        {
        LogMessage((SENSLOGN "[%d] Wait for sens start event timed out...\n", GetTickCount()));
        }

    // Notify EventSystem
    LogMessage((SENSLOGN "[%d] Notifying EventSystem...\n", GetTickCount()));
    hr = SensNotifyEventSystem(NOTIFY_LCE_STARTSHELL, lpvParam);
    LogMessage((SENSLOGN "[%d] SensNotifyEventSystem() returned 0x%x\n", GetTickCount(), hr));

    // Try to fire SENS Event
    LogMessage((SENSLOGN "[%d] Notifying SENS...\n", GetTickCount()));
    FIRE_EVENT(SENS_NOTIFY_WINLOGON_STARTSHELL);
    LogMessage((SENSLOGN "[%d] SensNotifyWinlogonEvent(STARTSHELL) succeeded.\n", GetTickCount()));

    // Cleanup
    CloseHandle(pTempInfo->hToken);
    delete pTempInfo->UserName;
    delete pTempInfo->Domain;
    delete pTempInfo->WindowStation;
    delete pTempInfo;

    return ERROR_SUCCESS;
}




HRESULT
SensNotifyEventSystem(
    DWORD dwEvent,
    LPVOID lpvParam
    )
/*++

Routine Description:

    This routine notifies EventSystem of the Logon/Logoff events.

Arguments:

    dwEvent - Tells if the event is Logon or Logoff.

    lpvParam - Winlogon notification info.

Notes:

    a. EventSystem's notify routine has been observed sometimes to take
       a long time causing Logoff to take longer time to complete.

Return Value:

    HRESULT from EventSystem's Notify routine.

--*/
{
    HRESULT hr;

    hr = S_OK;

    PWLX_NOTIFICATION_INFO pTempInfo = (PWLX_NOTIFICATION_INFO)lpvParam;

    //
    // Notify the COM+ Event System that a user has just logged on.
    // Per-user subscriptions will be activated.
    //

    typedef HRESULT (__stdcall *LPFN_NOTIFICATION)(HANDLE);

    HMODULE hDLL;
    LPFN_NOTIFICATION lpfnNotify = NULL;

    hDLL = (HMODULE) LoadLibrary(EVENTSYSTEM_DLL);
    if (hDLL == NULL)
        {
        hr = HRESULT_FROM_WIN32(GetLastError());
        }
    else
        {
        if (dwEvent == NOTIFY_LCE_STARTSHELL)
            {
            lpfnNotify = (LPFN_NOTIFICATION) GetProcAddress(hDLL, NOTIFY_LCE_LOGONUSER);
            }
        else
        if (dwEvent == NOTIFY_LCE_LOGOFF)
            {
            lpfnNotify = (LPFN_NOTIFICATION) GetProcAddress(hDLL, NOTIFY_LCE_LOGOFFUSER);
            }

        hr = (lpfnNotify == NULL) ? HRESULT_FROM_WIN32(GetLastError()) : (*lpfnNotify)(pTempInfo->hToken);

        FreeLibrary(hDLL);
        }

    return hr;
}

#define MAX_WINDOWSTATION_NAME_LENGTH 1000


DWORD
_SecpGetCurrentUserToken(
    handle_t      Binding,
    wchar_t       WindowStation[],
    unsigned long * pToken,
    unsigned long DesiredAccess
    )
/*++

Routine Description:

    RPC server manager routine.  This is the only method in the GetUserToken
    interface.
    
    The interface registered a callback function to verify that the caller is
    both non-remote and is local system.

Arguments:

    Binding - RPC server binding
    WindowStation - window station retrive the token from
    pToken - Upon return this is the handle ID of the duplicated token in the 
        callers process
    DesiredAccess - Access mask passed directly to the DuplicateHandle() call.

Return Value:

    WIN32 ERROR value or 0

--*/
{
    HANDLE LocalToken;
    HANDLE RemoteToken;
    HANDLE RemoteProcess;
    unsigned long ProcessId;

    if (FALSE == gbIsTokenCodeInitialized)
        {
        return ERROR_OUTOFMEMORY;
        }

    //
    // Validate arguments.  The only one that can cause us harm is the window station.
    //
    if (IsBadStringPtr( WindowStation, MAX_WINDOWSTATION_NAME_LENGTH))
        {
        return ERROR_ACCESS_DENIED;
        }

    if (I_RpcBindingInqLocalClientPID(0, &ProcessId))
        {
        return ERROR_ACCESS_DENIED;
        }

    //
    // Clone the token into the requested process.
    //
    LocalToken = ActiveUserList->CurrentUserTokenFromWindowStation( WindowStation );
    if (!LocalToken)
        {
        LogMessage((SENSLOGN "GetCurrentUserToken(): User not logged on!\n"));
        return ERROR_NOT_LOGGED_ON;
        }

    RemoteProcess = OpenProcess(
                        PROCESS_DUP_HANDLE,
                        FALSE,         // not inheritable
                        ProcessId
                        );
    if (!RemoteProcess)
        {
        LogMessage((SENSLOGN "GetCurrentUserToken(): OpenProcess() failed!\n"));
        return GetLastError();
        }

    // Only way to verify that the client process has not exited while waiting for
    // the response.  (this is to avoid duplicating the handle into another process).
    //
    // This is done after the OpenProcess() call to keep the PID from being reused before
    // we could open the process.

    if (RPC_S_OK != RpcImpersonateClient(0))
        {
        CloseHandle(RemoteProcess);
        return ERROR_ACCESS_DENIED;
        }

    // We have already validated that the caller is local system in the interface callback.

    RpcRevertToSelf();

    if (!DuplicateHandle(
             GetCurrentProcess(),
             LocalToken,
             RemoteProcess,
             &RemoteToken,
             DesiredAccess,
             FALSE,                // not inheritable
             0                     // no funny options
             ))
        {
        LogMessage((SENSLOGN "GetCurrentUserToken(): DuplicateHandle() failed!\n"));
        CloseHandle( RemoteProcess );
        return GetLastError();
        }

    CloseHandle( RemoteProcess );
    *pToken = HandleToUlong(RemoteToken);

    LogMessage((SENSLOGN "GetCurrentUserToken(): Succeeded. Returning 0x%x.\n", *pToken));

    return ERROR_SUCCESS;
}




BOOL
USER_LOGON_TABLE::Add(
    WLX_NOTIFICATION_INFO * User
    )
{
    USER_INFO_NODE * Entry;

    if (FALSE == gbIsTokenCodeInitialized)
        {
        return FALSE;
        }

    CLAIM_MUTEX Lock( Mutex );

    Entry = FindInactiveEntry();
    if (!Entry)
        {
        Entry = new USER_INFO_NODE;
        if (!Entry)
            {
            return FALSE;
            }

        Entry->fActive = FALSE;

        InsertTailList( &List, &Entry->Links );
        }

    Entry->Info.Size   = sizeof(WLX_NOTIFICATION_INFO);
    Entry->Info.Flags  = User->Flags;
    Entry->Info.hToken = User->hToken;

    SIZE_T sizeUserName = wcslen(User->UserName) + 1;
    SIZE_T sizeDomain   = wcslen(User->Domain) + 1;
    SIZE_T sizeWinsta   = wcslen(User->WindowStation) + 1;

    WCHAR * Buffer = new WCHAR[sizeUserName + sizeDomain + sizeWinsta];

    if (!Buffer)
        {
        Entry->Info.UserName      = 0;
        Entry->Info.Domain        = 0;
        Entry->Info.WindowStation = 0;

        return FALSE;
        }

    //
    // This must match the code in Remove().
    //
    Entry->Info.UserName      = Buffer;
    Entry->Info.Domain        = Entry->Info.UserName+1+wcslen(User->UserName);
    Entry->Info.WindowStation = Entry->Info.Domain  +1+wcslen(User->Domain);

    StringCchCopy(Entry->Info.UserName,      sizeUserName, User->UserName);
    StringCchCopy(Entry->Info.Domain,        sizeDomain,   User->Domain);
    StringCchCopy(Entry->Info.WindowStation, sizeWinsta,   User->WindowStation);

    Entry->fActive = TRUE;

    return TRUE;
}




BOOL
USER_LOGON_TABLE::Remove(
    WLX_NOTIFICATION_INFO * User
    )
{
    if (FALSE == gbIsTokenCodeInitialized)
        {
        return FALSE;
        }

    USER_INFO_NODE * Entry = FromWindowStation( User->WindowStation );

    if (Entry)
        {
        //
        // This must match the code in Add().
        //
        delete Entry->Info.UserName;

        Entry->fActive = FALSE;

        Mutex.Leave();
        return TRUE;
        }

    Mutex.Leave();
    return FALSE;
}




HANDLE
USER_LOGON_TABLE::CurrentUserTokenFromWindowStation(
    wchar_t WindowStation[]
    )
{
    HANDLE Token = NULL;
    USER_INFO_NODE * Node = FromWindowStation(WindowStation);

    if (Node)
        {
        Token = Node->Info.hToken;
        }

    Mutex.Leave();
    return Token;
}




USER_INFO_NODE *
USER_LOGON_TABLE::FromWindowStation(
    wchar_t WindowStation[]
    )
/*++

    Note that the mutex is held on exit, to avoid race conditions.

--*/
{
    USER_INFO_NODE * Node;
    LIST_ENTRY *     Link;

    Mutex.Enter();

    for (Link = List.Flink,  Node = CONTAINING_RECORD(Link, USER_INFO_NODE, Links);
         Link != &List;
         Link = Link->Flink, Node = CONTAINING_RECORD(Link, USER_INFO_NODE, Links))
        {
        if (Node->fActive && 0 == wcscmp(Node->Info.WindowStation, WindowStation))
            {
            return Node;
            }
        }

    return 0;
}




USER_INFO_NODE *
USER_LOGON_TABLE::FindInactiveEntry(
    void
    )
{
    USER_INFO_NODE * Node;
    LIST_ENTRY *     Link;

    for (Link = List.Flink,  Node = CONTAINING_RECORD(Link, USER_INFO_NODE, Links);
         Link != &List;
         Link = Link->Flink, Node = CONTAINING_RECORD(Link, USER_INFO_NODE, Links))
        {
        if (!Node->fActive)
            {
            return Node;
            }
        }

    return 0;
}


RPC_STATUS RPC_ENTRY
AllowLocalSystem (
    IN RPC_IF_HANDLE  InterfaceUuid,
    IN void *Context
    )
{
    unsigned fLocal = FALSE;
 
    if (RPC_S_OK != I_RpcBindingIsClientLocal(NULL, &fLocal))
        {
        return ERROR_ACCESS_DENIED;
        }

    if  (!fLocal)
        {
        return ERROR_ACCESS_DENIED;
        }


    if (!IsRpcCallerLocalSystem())
        {
        return ERROR_ACCESS_DENIED;
        }

    return RPC_S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senslogn\logoncli\logoncli.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    logoncli.cxx

Abstract:

    This file contains code to trigger the Winlogon Events for SENS. This
    is a test DLL and these private SENS APIs should not be called directly.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          1/17/1998         Start.

--*/


#include <stdio.h>
#include <stdlib.h>
#include <windows.h>
#include <winwlx.h>
#include <sensapip.h>
#include "senslogn.hxx"



void
Usage(
    void
    )
{
    printf("\nUsage:    logoncli [Winlogon Event Number] \n\n");
    printf("Options:\n\n");
    printf("    WinlogonEventNumber  1 - Logon\n"
           "                         2 - Logoff\n"
           "                         3 - Startup\n"
           "                         4 - StartShell\n"
           "                         5 - Shutdown\n"
           "                         6 - Lock\n"
           "                         7 - Unlock\n"
           "                         8 - StartScreenSaver\n"
           "                         9 - StopScreenSaver\n"
           "\n\n");

    exit(-1);
}


int
main(
    int argc,
    char **argv
    )
{

    if (argc != 2)
        {
        Usage();
        }

    if ((atoi(argv[1]) < 1) ||
        (atoi(argv[1]) > 9))
        {
        Usage();
        }


    WLX_NOTIFICATION_INFO Info;

    Info.Size = 24;
    Info.Flags = 0x0;
    Info.UserName = L"JohnDoe";
    Info.Domain = L"REDMOND";
    Info.WindowStation = L"Default";
    Info.hToken = NULL;


    switch (atoi(argv[1]))
        {
        case 1:
            SensLogonEvent(&Info);
            break;

        case 2:
            SensLogoffEvent(&Info);
            break;

        case 3:
            SensStartupEvent(&Info);
            break;

        case 4:
            SensStartShellEvent(&Info);
            break;

        case 5:
            SensShutdownEvent(&Info);
            break;

        case 6:
            SensLockEvent(&Info);
            break;

        case 7:
            SensUnlockEvent(&Info);
            break;

        case 8:
            SensStartScreenSaverEvent(&Info);
            break;

        case 9:
            SensStopScreenSaverEvent(&Info);
            break;

        default:
            printf("Bad Event id!\n");
            break;
        }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\mobile\sens\conn\senssvc\apiproc.cxx ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    apiproc.cxx

Abstract:

    This file contains the implementations of all the RPC Server
    Manager routines exported by SENS.

Author:

    Gopal Parupudi    <GopalP>

[Notes:]

    optional-notes

Revision History:

    GopalP          10/11/1997         Start.

--*/


#include <precomp.hxx>
#include <notify.h>



error_status_t
RPC_IsNetworkAlive(
    IN  handle_t hRpc,
    OUT LPDWORD lpdwFlags,
    OUT LPBOOL lpbAlive,
    OUT LPDWORD lpdwLastError
    )
/*++

Routine Description:

    Get the current Network State that is maintained by this service.
    If either WAN or LAN connectivity is not present, we try to re-evaluate
    and update the state, if possible.

Arguments:

    hRpc - The RPC Binding handle.

    lpdwFlags - The flags indicating which 