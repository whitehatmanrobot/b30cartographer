s caller
    fDwUseIE                = 0x00000020,   // always launch w/ IE
    fDwDeleteFiles          = 0x00000040,   // delete the additional files after use.
    fDwHeadless             = 0x00000080,   // DW will auto-report. policy required to enable
    fDwUseHKLM              = 0x00000100,   // DW reg from HKLM instead of HKCU
    fDwUseLitePlea          = 0x00000200,   // DW won't suggest product change in report plea
    fDwUsePrivacyHTA        = 0x00000400,   // DW won't suggest product change in report plea
    fDwManifestDebug        = 0x00000800,   // DW will provide a debug button in manifset mode
    fDwReportChoice         = 0x00001000,   // DW will tack on the command line of the user
    fDwSkipBucketLog      = 0x00002000, // DW won't log at bucket-time
    fDwNoDefaultCabLimit = 0x00004000, // DW under CER won't use 5 as the fallback but unlimited instead (policy still overrides)
    fDwAllowSuspend      = 0x00008000, // DW will allow powersave mode to suspend it, as long as we're not in reporting phase
   fDwMiniDumpWithUnloadedModules = 0x00010000, // DW will pass MiniDumpWithUnloadedModules to the minidump API
};


const WCHAR c_wszDWCmdLine[]  = L"dwwin.exe -d %ls";
const WCHAR c_wszDWExe[]      = L"%ls\\dwwin.exe";

const WCHAR c_wszRegErrRpt[]  = L"Software\\Microsoft\\PCHealth\\ErrorReporting";
const WCHAR c_wszRegDWPolicy[]= L"Software\\Policies\\Microsoft\\PCHealth\\ErrorReporting\\DW";
const WCHAR c_wszFileHeader[] = L"<?xml version=\"1.0\" encoding=\"UTF-16\"?>\r\n   <DATABASE>";
const WCHAR c_wszLblType[]    = L"Type=";
const WCHAR c_wszLblACW[]     = L"\r\nAppCompWiz=";
const WCHAR c_wszLblComment[] = L"\r\nComment=";
const WCHAR c_wszServer[]     = L"watson.microsoft.com";
const WCHAR c_wszManSubPath[] = L"\r\nRegSubPath=Microsoft\\PCHealth\\ErrorReporting\\DW";
const WCHAR c_wszManPID[]     = L"\r\nDigPidRegPath=HKLM\\Software\\Microsoft\\Windows NT\\CurrentVersion\\DigitalProductId";
const WCHAR c_wszManHdr[]     = L"\r\nServer=%ls\r\nUI LCID=%d\r\nFlags=%d\r\nBrand=%ls\r\nTitleName=";
const WCHAR c_wszStage1[]     = L"\r\nStage1URL=/StageOne/%ls/%d_%d_%d_%d/appcomp.rpt/0_0_0_0/%08lx.htm";
const WCHAR c_wszStage2[]     = L"\r\nStage2URL=/dw/stagetwo.asp?szAppName=%ls&szAppVer=%d.%d.%d.%d&szModName=appcomp.rpt&szModVer=0.0.0.0&offset=%08lx";
const WCHAR c_wszBrand[]      = L"WINDOWS";
const WCHAR c_wszManCorpPath[]  = L"\r\nErrorSubPath=";
const WCHAR c_wszManFiles[]     = L"\r\nDataFiles=";
const WCHAR c_wszManHdrText[]   = L"\r\nHeaderText=";
const WCHAR c_wszManErrText[]   = L"\r\nErrorText=";
const WCHAR c_wszManPleaText[]  = L"\r\nPlea=";
const WCHAR c_wszManSendText[]  = L"\r\nReportButton=";
const WCHAR c_wszManNSendText[] = L"\r\nNoReportButton=";
const WCHAR c_wszManEventSrc[]  = L"\r\nEventLogSource=";
const WCHAR c_wszManStageOne[]  = L"\r\nStage1URL=";
const WCHAR c_wszManStageTwo[]  = L"\r\nStage2URL=";







//
// Error values
//
#define ERROR_APPRPT_DW_LAUNCH        100
#define ERROR_APPRPT_DW_TIMEOUT       101
#define ERROR_APPRPT_OS_NOT_SUPPORTED 102
#define ERROR_APPRPT_COMPAT_TEXT      103
#define ERROR_APPRPT_UPLOADING        104


HRESULT
GenerateAppCompatText(
    LPWSTR wszAppName,
    LPWSTR *pwszAppCompatReport
    );

HRESULT
UploadAppProblem(
    LPWSTR wszAppName,
    LPWSTR wszProblemType,
    LPWSTR wszUserComment,
    LPWSTR wszACWResult,
    LPWSTR wszAppCompatText
    );

#endif // !defined _UPLOAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\cerupload\cerclient_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Jun 13 10:15:40 2001
 */
/* Compiler settings for E:\bluescreen\main\ENU\cerclient\CerClient.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ICerUpload = {0x54F6D251,0xAD78,0x4B78,{0xA6,0xE7,0x86,0x3E,0x36,0x2A,0x1F,0x0C}};


const IID LIBID_CERCLIENTLib = {0x012B3B9C,0xFB7D,0x4793,{0xA6,0x24,0x8C,0x5C,0xBF,0xCE,0x6B,0x8D}};


const CLSID CLSID_CerUpload = {0xC3397F18,0xDAC9,0x42C3,{0xBC,0x3B,0x78,0x53,0xA8,0x4A,0x8C,0xB9}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\cerupload\cerupload.cpp ===
// CERUpload.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To merge the proxy/stub code into the object DLL, add the file 
//      dlldatax.c to the project.  Make sure precompiled headers 
//      are turned off for this file, and add _MERGE_PROXYSTUB to the 
//      defines for the project.  
//
//      If you are not running WinNT4.0 or Win95 with DCOM, then you
//      need to remove the following define from dlldatax.c
//      #define _WIN32_WINNT 0x0400
//
//      Further, if you are running MIDL without /Oicf switch, you also 
//      need to remove the following define from dlldatax.c.
//      #define USE_STUBLESS_PROXY
//
//      Modify the custom build rule for CERUpload.idl by adding the following 
//      files to the Outputs.
//          CERUpload_p.c
//          dlldata.c
//      To build a separate proxy/stub DLL, 
//      run nmake -f CERUploadps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "CERUpload.h"
#include "dlldatax.h"

#include "CERUpload_i.c"
#include "CerClient.h"

#ifdef _MERGE_PROXYSTUB
extern "C" HINSTANCE hProxyDll;
#endif

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_CerClient, CCerClient)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{
    lpReserved;
#ifdef _MERGE_PROXYSTUB
    if (!PrxDllMain(hInstance, dwReason, lpReserved))
        return FALSE;
#endif
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_CERUPLOADLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllCanUnloadNow() != S_OK)
        return S_FALSE;
#endif
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
#ifdef _MERGE_PROXYSTUB
    if (PrxDllGetClassObject(rclsid, riid, ppv) == S_OK)
        return S_OK;
#endif
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    HRESULT hRes = PrxDllRegisterServer();
    if (FAILED(hRes))
        return hRes;
#endif
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
#ifdef _MERGE_PROXYSTUB
    PrxDllUnregisterServer();
#endif
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\cerupload\cerclient_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


/* File created by MIDL compiler version 5.01.0164 */
/* at Wed Jun 13 10:15:40 2001
 */
/* Compiler settings for E:\bluescreen\main\ENU\cerclient\CerClient.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )

#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "CerClient.h"

#define TYPE_FORMAT_STRING_SIZE   1011                              
#define PROC_FORMAT_STRING_SIZE   185                               

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ICerUpload, ver. 0.0,
   GUID={0x54F6D251,0xAD78,0x4B78,{0xA6,0xE7,0x86,0x3E,0x36,0x2A,0x1F,0x0C}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICerUpload_ServerInfo;

#pragma code_seg(".orpc")
extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[2];

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x50100a4, /* MIDL Version 5.1.164 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    1,  /* Flags */
    0,  /* Reserved3 */
    0,  /* Reserved4 */
    0   /* Reserved5 */
    };

static const unsigned short ICerUpload_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    58,
    92,
    138
    };

static const MIDL_SERVER_INFO ICerUpload_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICerUpload_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ICerUpload_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICerUpload_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(11) _ICerUploadProxyVtbl = 
{
    &ICerUpload_ProxyInfo,
    &IID_ICerUpload,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* ICerUpload::Upload */ ,
    (void *)-1 /* ICerUpload::Browse */ ,
    (void *)-1 /* ICerUpload::GetFileCount */ ,
    (void *)-1 /* ICerUpload::GetFileNames */
};


static const PRPC_STUB_FUNCTION ICerUpload_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ICerUploadStubVtbl =
{
    &IID_ICerUpload,
    &ICerUpload_ServerInfo,
    11,
    &ICerUpload_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

#pragma data_seg(".rdata")

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[2] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            },
            {
            VARIANT_UserSize
            ,VARIANT_UserMarshal
            ,VARIANT_UserUnmarshal
            ,VARIANT_UserFree
            }

        };


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf, [wire_marshal] or [user_marshal] attribute, more than 32 methods in the interface.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure Upload */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/*  8 */	NdrFcShort( 0x20 ),	/* x86, MIPS, PPC Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x7,		/* 7 */

	/* Parameter Path */

/* 16 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 18 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 20 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter TransID */

/* 22 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 24 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 26 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter FileName */

/* 28 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 30 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 32 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter IncidentID */

/* 34 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 36 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 38 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter RedirParam */

/* 40 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 42 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 44 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter RetCode */

/* 46 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
#ifndef _ALPHA_
/* 48 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 50 */	NdrFcShort( 0x3d6 ),	/* Type Offset=982 */

	/* Return value */

/* 52 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 54 */	NdrFcShort( 0x1c ),	/* x86, MIPS, PPC Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 56 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Browse */

/* 58 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 60 */	NdrFcLong( 0x0 ),	/* 0 */
/* 64 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 66 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 68 */	NdrFcShort( 0x0 ),	/* 0 */
/* 70 */	NdrFcShort( 0x8 ),	/* 8 */
/* 72 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter WindowTitle */

/* 74 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 76 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 78 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter Path */

/* 80 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
#ifndef _ALPHA_
/* 82 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 84 */	NdrFcShort( 0x3d6 ),	/* Type Offset=982 */

	/* Return value */

/* 86 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 88 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 90 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFileCount */

/* 92 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 94 */	NdrFcLong( 0x0 ),	/* 0 */
/* 98 */	NdrFcShort( 0x9 ),	/* 9 */
#ifndef _ALPHA_
/* 100 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 102 */	NdrFcShort( 0x0 ),	/* 0 */
/* 104 */	NdrFcShort( 0x8 ),	/* 8 */
/* 106 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter bstrSharePath */

/* 108 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 110 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 112 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter bstrTransactID */

/* 114 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 116 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 118 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter iMaxCount */

/* 120 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 122 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 124 */	NdrFcShort( 0x3e8 ),	/* Type Offset=1000 */

	/* Parameter RetVal */

/* 126 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
#ifndef _ALPHA_
/* 128 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 130 */	NdrFcShort( 0x3d6 ),	/* Type Offset=982 */

	/* Return value */

/* 132 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 134 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 136 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFileNames */

/* 138 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 140 */	NdrFcLong( 0x0 ),	/* 0 */
/* 144 */	NdrFcShort( 0xa ),	/* 10 */
#ifndef _ALPHA_
/* 146 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 148 */	NdrFcShort( 0x0 ),	/* 0 */
/* 150 */	NdrFcShort( 0x8 ),	/* 8 */
/* 152 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter Path */

/* 154 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 156 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 158 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter TransID */

/* 160 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 162 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 164 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter Count */

/* 166 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 168 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 170 */	NdrFcShort( 0x3e8 ),	/* Type Offset=1000 */

	/* Parameter FileList */

/* 172 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
#ifndef _ALPHA_
/* 174 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 176 */	NdrFcShort( 0x3d6 ),	/* Type Offset=982 */

	/* Return value */

/* 178 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 180 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 182 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x0,	/* FC_RP */
/*  4 */	NdrFcShort( 0x1a ),	/* Offset= 26 (30) */
/*  6 */	
			0x12, 0x0,	/* FC_UP */
/*  8 */	NdrFcShort( 0xc ),	/* Offset= 12 (20) */
/* 10 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 12 */	NdrFcShort( 0x2 ),	/* 2 */
/* 14 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 16 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 18 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 20 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 22 */	NdrFcShort( 0x8 ),	/* 8 */
/* 24 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (10) */
/* 26 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 28 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 30 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 32 */	NdrFcShort( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0x4 ),	/* 4 */
/* 36 */	NdrFcShort( 0x0 ),	/* 0 */
/* 38 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (6) */
/* 40 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 42 */	NdrFcShort( 0x3ac ),	/* Offset= 940 (982) */
/* 44 */	
			0x13, 0x0,	/* FC_OP */
/* 46 */	NdrFcShort( 0x394 ),	/* Offset= 916 (962) */
/* 48 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 50 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 52 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 54 */	NdrFcShort( 0x2 ),	/* Offset= 2 (56) */
/* 56 */	NdrFcShort( 0x10 ),	/* 16 */
/* 58 */	NdrFcShort( 0x2b ),	/* 43 */
/* 60 */	NdrFcLong( 0x3 ),	/* 3 */
/* 64 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 66 */	NdrFcLong( 0x11 ),	/* 17 */
/* 70 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 72 */	NdrFcLong( 0x2 ),	/* 2 */
/* 76 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 78 */	NdrFcLong( 0x4 ),	/* 4 */
/* 82 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 84 */	NdrFcLong( 0x5 ),	/* 5 */
/* 88 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 90 */	NdrFcLong( 0xb ),	/* 11 */
/* 94 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 96 */	NdrFcLong( 0xa ),	/* 10 */
/* 100 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 102 */	NdrFcLong( 0x6 ),	/* 6 */
/* 106 */	NdrFcShort( 0xd6 ),	/* Offset= 214 (320) */
/* 108 */	NdrFcLong( 0x7 ),	/* 7 */
/* 112 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 114 */	NdrFcLong( 0x8 ),	/* 8 */
/* 118 */	NdrFcShort( 0xd0 ),	/* Offset= 208 (326) */
/* 120 */	NdrFcLong( 0xd ),	/* 13 */
/* 124 */	NdrFcShort( 0xce ),	/* Offset= 206 (330) */
/* 126 */	NdrFcLong( 0x9 ),	/* 9 */
/* 130 */	NdrFcShort( 0xda ),	/* Offset= 218 (348) */
/* 132 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 136 */	NdrFcShort( 0xe6 ),	/* Offset= 230 (366) */
/* 138 */	NdrFcLong( 0x24 ),	/* 36 */
/* 142 */	NdrFcShort( 0x2f0 ),	/* Offset= 752 (894) */
/* 144 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 148 */	NdrFcShort( 0x2ea ),	/* Offset= 746 (894) */
/* 150 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 154 */	NdrFcShort( 0x2e8 ),	/* Offset= 744 (898) */
/* 156 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 160 */	NdrFcShort( 0x2e6 ),	/* Offset= 742 (902) */
/* 162 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 166 */	NdrFcShort( 0x2e4 ),	/* Offset= 740 (906) */
/* 168 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 172 */	NdrFcShort( 0x2e2 ),	/* Offset= 738 (910) */
/* 174 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 178 */	NdrFcShort( 0x2e0 ),	/* Offset= 736 (914) */
/* 180 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 184 */	NdrFcShort( 0x2ce ),	/* Offset= 718 (902) */
/* 186 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 190 */	NdrFcShort( 0x2cc ),	/* Offset= 716 (906) */
/* 192 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 196 */	NdrFcShort( 0x2d2 ),	/* Offset= 722 (918) */
/* 198 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 202 */	NdrFcShort( 0x2c8 ),	/* Offset= 712 (914) */
/* 204 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 208 */	NdrFcShort( 0x2ca ),	/* Offset= 714 (922) */
/* 210 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 214 */	NdrFcShort( 0x2c8 ),	/* Offset= 712 (926) */
/* 216 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 220 */	NdrFcShort( 0x2c6 ),	/* Offset= 710 (930) */
/* 222 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 226 */	NdrFcShort( 0x2c4 ),	/* Offset= 708 (934) */
/* 228 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 232 */	NdrFcShort( 0x2c2 ),	/* Offset= 706 (938) */
/* 234 */	NdrFcLong( 0x10 ),	/* 16 */
/* 238 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 240 */	NdrFcLong( 0x12 ),	/* 18 */
/* 244 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 246 */	NdrFcLong( 0x13 ),	/* 19 */
/* 250 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 252 */	NdrFcLong( 0x16 ),	/* 22 */
/* 256 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 258 */	NdrFcLong( 0x17 ),	/* 23 */
/* 262 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 264 */	NdrFcLong( 0xe ),	/* 14 */
/* 268 */	NdrFcShort( 0x2a6 ),	/* Offset= 678 (946) */
/* 270 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 274 */	NdrFcShort( 0x2ac ),	/* Offset= 684 (958) */
/* 276 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 280 */	NdrFcShort( 0x26a ),	/* Offset= 618 (898) */
/* 282 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 286 */	NdrFcShort( 0x268 ),	/* Offset= 616 (902) */
/* 288 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 292 */	NdrFcShort( 0x266 ),	/* Offset= 614 (906) */
/* 294 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 298 */	NdrFcShort( 0x260 ),	/* Offset= 608 (906) */
/* 300 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 304 */	NdrFcShort( 0x25a ),	/* Offset= 602 (906) */
/* 306 */	NdrFcLong( 0x0 ),	/* 0 */
/* 310 */	NdrFcShort( 0x0 ),	/* Offset= 0 (310) */
/* 312 */	NdrFcLong( 0x1 ),	/* 1 */
/* 316 */	NdrFcShort( 0x0 ),	/* Offset= 0 (316) */
/* 318 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (317) */
/* 320 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 322 */	NdrFcShort( 0x8 ),	/* 8 */
/* 324 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 326 */	
			0x13, 0x0,	/* FC_OP */
/* 328 */	NdrFcShort( 0xfffffecc ),	/* Offset= -308 (20) */
/* 330 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 332 */	NdrFcLong( 0x0 ),	/* 0 */
/* 336 */	NdrFcShort( 0x0 ),	/* 0 */
/* 338 */	NdrFcShort( 0x0 ),	/* 0 */
/* 340 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 342 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 344 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 346 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 348 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 350 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 354 */	NdrFcShort( 0x0 ),	/* 0 */
/* 356 */	NdrFcShort( 0x0 ),	/* 0 */
/* 358 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 360 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 362 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 364 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 366 */	
			0x13, 0x0,	/* FC_OP */
/* 368 */	NdrFcShort( 0x1fc ),	/* Offset= 508 (876) */
/* 370 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 372 */	NdrFcShort( 0x18 ),	/* 24 */
/* 374 */	NdrFcShort( 0xa ),	/* 10 */
/* 376 */	NdrFcLong( 0x8 ),	/* 8 */
/* 380 */	NdrFcShort( 0x58 ),	/* Offset= 88 (468) */
/* 382 */	NdrFcLong( 0xd ),	/* 13 */
/* 386 */	NdrFcShort( 0x78 ),	/* Offset= 120 (506) */
/* 388 */	NdrFcLong( 0x9 ),	/* 9 */
/* 392 */	NdrFcShort( 0x94 ),	/* Offset= 148 (540) */
/* 394 */	NdrFcLong( 0xc ),	/* 12 */
/* 398 */	NdrFcShort( 0xbc ),	/* Offset= 188 (586) */
/* 400 */	NdrFcLong( 0x24 ),	/* 36 */
/* 404 */	NdrFcShort( 0x114 ),	/* Offset= 276 (680) */
/* 406 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 410 */	NdrFcShort( 0x130 ),	/* Offset= 304 (714) */
/* 412 */	NdrFcLong( 0x10 ),	/* 16 */
/* 416 */	NdrFcShort( 0x148 ),	/* Offset= 328 (744) */
/* 418 */	NdrFcLong( 0x2 ),	/* 2 */
/* 422 */	NdrFcShort( 0x160 ),	/* Offset= 352 (774) */
/* 424 */	NdrFcLong( 0x3 ),	/* 3 */
/* 428 */	NdrFcShort( 0x178 ),	/* Offset= 376 (804) */
/* 430 */	NdrFcLong( 0x14 ),	/* 20 */
/* 434 */	NdrFcShort( 0x190 ),	/* Offset= 400 (834) */
/* 436 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (435) */
/* 438 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 440 */	NdrFcShort( 0x4 ),	/* 4 */
/* 442 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 444 */	NdrFcShort( 0x0 ),	/* 0 */
/* 446 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 448 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 450 */	NdrFcShort( 0x4 ),	/* 4 */
/* 452 */	NdrFcShort( 0x0 ),	/* 0 */
/* 454 */	NdrFcShort( 0x1 ),	/* 1 */
/* 456 */	NdrFcShort( 0x0 ),	/* 0 */
/* 458 */	NdrFcShort( 0x0 ),	/* 0 */
/* 460 */	0x13, 0x0,	/* FC_OP */
/* 462 */	NdrFcShort( 0xfffffe46 ),	/* Offset= -442 (20) */
/* 464 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 466 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 468 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 470 */	NdrFcShort( 0x8 ),	/* 8 */
/* 472 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 474 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 476 */	NdrFcShort( 0x4 ),	/* 4 */
/* 478 */	NdrFcShort( 0x4 ),	/* 4 */
/* 480 */	0x11, 0x0,	/* FC_RP */
/* 482 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (438) */
/* 484 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 486 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 488 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 490 */	NdrFcShort( 0x0 ),	/* 0 */
/* 492 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 494 */	NdrFcShort( 0x0 ),	/* 0 */
/* 496 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 500 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 502 */	NdrFcShort( 0xffffff54 ),	/* Offset= -172 (330) */
/* 504 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 506 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 508 */	NdrFcShort( 0x8 ),	/* 8 */
/* 510 */	NdrFcShort( 0x0 ),	/* 0 */
/* 512 */	NdrFcShort( 0x6 ),	/* Offset= 6 (518) */
/* 514 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 516 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 518 */	
			0x11, 0x0,	/* FC_RP */
/* 520 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (488) */
/* 522 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 524 */	NdrFcShort( 0x0 ),	/* 0 */
/* 526 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 528 */	NdrFcShort( 0x0 ),	/* 0 */
/* 530 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 534 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 536 */	NdrFcShort( 0xffffff44 ),	/* Offset= -188 (348) */
/* 538 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 540 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 542 */	NdrFcShort( 0x8 ),	/* 8 */
/* 544 */	NdrFcShort( 0x0 ),	/* 0 */
/* 546 */	NdrFcShort( 0x6 ),	/* Offset= 6 (552) */
/* 548 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 550 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 552 */	
			0x11, 0x0,	/* FC_RP */
/* 554 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (522) */
/* 556 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 558 */	NdrFcShort( 0x4 ),	/* 4 */
/* 560 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 562 */	NdrFcShort( 0x0 ),	/* 0 */
/* 564 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 566 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 568 */	NdrFcShort( 0x4 ),	/* 4 */
/* 570 */	NdrFcShort( 0x0 ),	/* 0 */
/* 572 */	NdrFcShort( 0x1 ),	/* 1 */
/* 574 */	NdrFcShort( 0x0 ),	/* 0 */
/* 576 */	NdrFcShort( 0x0 ),	/* 0 */
/* 578 */	0x13, 0x0,	/* FC_OP */
/* 580 */	NdrFcShort( 0x17e ),	/* Offset= 382 (962) */
/* 582 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 584 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 586 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 588 */	NdrFcShort( 0x8 ),	/* 8 */
/* 590 */	NdrFcShort( 0x0 ),	/* 0 */
/* 592 */	NdrFcShort( 0x6 ),	/* Offset= 6 (598) */
/* 594 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 596 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 598 */	
			0x11, 0x0,	/* FC_RP */
/* 600 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (556) */
/* 602 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 604 */	NdrFcLong( 0x2f ),	/* 47 */
/* 608 */	NdrFcShort( 0x0 ),	/* 0 */
/* 610 */	NdrFcShort( 0x0 ),	/* 0 */
/* 612 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 614 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 616 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 618 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 620 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 622 */	NdrFcShort( 0x1 ),	/* 1 */
/* 624 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 626 */	NdrFcShort( 0x4 ),	/* 4 */
/* 628 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 630 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 632 */	NdrFcShort( 0x10 ),	/* 16 */
/* 634 */	NdrFcShort( 0x0 ),	/* 0 */
/* 636 */	NdrFcShort( 0xa ),	/* Offset= 10 (646) */
/* 638 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 640 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 642 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (602) */
/* 644 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 646 */	
			0x13, 0x0,	/* FC_OP */
/* 648 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (620) */
/* 650 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 652 */	NdrFcShort( 0x4 ),	/* 4 */
/* 654 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 656 */	NdrFcShort( 0x0 ),	/* 0 */
/* 658 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 660 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 662 */	NdrFcShort( 0x4 ),	/* 4 */
/* 664 */	NdrFcShort( 0x0 ),	/* 0 */
/* 666 */	NdrFcShort( 0x1 ),	/* 1 */
/* 668 */	NdrFcShort( 0x0 ),	/* 0 */
/* 670 */	NdrFcShort( 0x0 ),	/* 0 */
/* 672 */	0x13, 0x0,	/* FC_OP */
/* 674 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (630) */
/* 676 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 678 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 680 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 682 */	NdrFcShort( 0x8 ),	/* 8 */
/* 684 */	NdrFcShort( 0x0 ),	/* 0 */
/* 686 */	NdrFcShort( 0x6 ),	/* Offset= 6 (692) */
/* 688 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 690 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 692 */	
			0x11, 0x0,	/* FC_RP */
/* 694 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (650) */
/* 696 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 698 */	NdrFcShort( 0x8 ),	/* 8 */
/* 700 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 702 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 704 */	NdrFcShort( 0x10 ),	/* 16 */
/* 706 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 708 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 710 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (696) */
			0x5b,		/* FC_END */
/* 714 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 716 */	NdrFcShort( 0x18 ),	/* 24 */
/* 718 */	NdrFcShort( 0x0 ),	/* 0 */
/* 720 */	NdrFcShort( 0xa ),	/* Offset= 10 (730) */
/* 722 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 724 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 726 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (702) */
/* 728 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 730 */	
			0x11, 0x0,	/* FC_RP */
/* 732 */	NdrFcShort( 0xffffff0c ),	/* Offset= -244 (488) */
/* 734 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 736 */	NdrFcShort( 0x1 ),	/* 1 */
/* 738 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 740 */	NdrFcShort( 0x0 ),	/* 0 */
/* 742 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 744 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 746 */	NdrFcShort( 0x8 ),	/* 8 */
/* 748 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 750 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 752 */	NdrFcShort( 0x4 ),	/* 4 */
/* 754 */	NdrFcShort( 0x4 ),	/* 4 */
/* 756 */	0x13, 0x0,	/* FC_OP */
/* 758 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (734) */
/* 760 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 762 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 764 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 766 */	NdrFcShort( 0x2 ),	/* 2 */
/* 768 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 770 */	NdrFcShort( 0x0 ),	/* 0 */
/* 772 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 774 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 776 */	NdrFcShort( 0x8 ),	/* 8 */
/* 778 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 780 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 782 */	NdrFcShort( 0x4 ),	/* 4 */
/* 784 */	NdrFcShort( 0x4 ),	/* 4 */
/* 786 */	0x13, 0x0,	/* FC_OP */
/* 788 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (764) */
/* 790 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 792 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 794 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 796 */	NdrFcShort( 0x4 ),	/* 4 */
/* 798 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 800 */	NdrFcShort( 0x0 ),	/* 0 */
/* 802 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 804 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 806 */	NdrFcShort( 0x8 ),	/* 8 */
/* 808 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 810 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 812 */	NdrFcShort( 0x4 ),	/* 4 */
/* 814 */	NdrFcShort( 0x4 ),	/* 4 */
/* 816 */	0x13, 0x0,	/* FC_OP */
/* 818 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (794) */
/* 820 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 822 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 824 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 826 */	NdrFcShort( 0x8 ),	/* 8 */
/* 828 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 830 */	NdrFcShort( 0x0 ),	/* 0 */
/* 832 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 834 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 836 */	NdrFcShort( 0x8 ),	/* 8 */
/* 838 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 840 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 842 */	NdrFcShort( 0x4 ),	/* 4 */
/* 844 */	NdrFcShort( 0x4 ),	/* 4 */
/* 846 */	0x13, 0x0,	/* FC_OP */
/* 848 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (824) */
/* 850 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 852 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 854 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 856 */	NdrFcShort( 0x8 ),	/* 8 */
/* 858 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 860 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 862 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 864 */	NdrFcShort( 0x8 ),	/* 8 */
/* 866 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 868 */	NdrFcShort( 0xffd8 ),	/* -40 */
/* 870 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 872 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (854) */
/* 874 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 876 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 878 */	NdrFcShort( 0x28 ),	/* 40 */
/* 880 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (862) */
/* 882 */	NdrFcShort( 0x0 ),	/* Offset= 0 (882) */
/* 884 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 886 */	0x38,		/* FC_ALIGNM4 */
			0x8,		/* FC_LONG */
/* 888 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 890 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffdf7 ),	/* Offset= -521 (370) */
			0x5b,		/* FC_END */
/* 894 */	
			0x13, 0x0,	/* FC_OP */
/* 896 */	NdrFcShort( 0xfffffef6 ),	/* Offset= -266 (630) */
/* 898 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 900 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 902 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 904 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 906 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 908 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 910 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 912 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 914 */	
			0x13, 0x8,	/* FC_OP [simple_pointer] */
/* 916 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 918 */	
			0x13, 0x0,	/* FC_OP */
/* 920 */	NdrFcShort( 0xfffffda8 ),	/* Offset= -600 (320) */
/* 922 */	
			0x13, 0x10,	/* FC_OP */
/* 924 */	NdrFcShort( 0xfffffdaa ),	/* Offset= -598 (326) */
/* 926 */	
			0x13, 0x10,	/* FC_OP */
/* 928 */	NdrFcShort( 0xfffffdaa ),	/* Offset= -598 (330) */
/* 930 */	
			0x13, 0x10,	/* FC_OP */
/* 932 */	NdrFcShort( 0xfffffdb8 ),	/* Offset= -584 (348) */
/* 934 */	
			0x13, 0x10,	/* FC_OP */
/* 936 */	NdrFcShort( 0xfffffdc6 ),	/* Offset= -570 (366) */
/* 938 */	
			0x13, 0x10,	/* FC_OP */
/* 940 */	NdrFcShort( 0x2 ),	/* Offset= 2 (942) */
/* 942 */	
			0x13, 0x0,	/* FC_OP */
/* 944 */	NdrFcShort( 0xfffffc50 ),	/* Offset= -944 (0) */
/* 946 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 948 */	NdrFcShort( 0x10 ),	/* 16 */
/* 950 */	0x6,		/* FC_SHORT */
			0x2,		/* FC_CHAR */
/* 952 */	0x2,		/* FC_CHAR */
			0x38,		/* FC_ALIGNM4 */
/* 954 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 956 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 958 */	
			0x13, 0x0,	/* FC_OP */
/* 960 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (946) */
/* 962 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 964 */	NdrFcShort( 0x20 ),	/* 32 */
/* 966 */	NdrFcShort( 0x0 ),	/* 0 */
/* 968 */	NdrFcShort( 0x0 ),	/* Offset= 0 (968) */
/* 970 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 972 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 974 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 976 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 978 */	NdrFcShort( 0xfffffc5e ),	/* Offset= -930 (48) */
/* 980 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 982 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 984 */	NdrFcShort( 0x1 ),	/* 1 */
/* 986 */	NdrFcShort( 0x10 ),	/* 16 */
/* 988 */	NdrFcShort( 0x0 ),	/* 0 */
/* 990 */	NdrFcShort( 0xfffffc4e ),	/* Offset= -946 (44) */
/* 992 */	
			0x11, 0x0,	/* FC_RP */
/* 994 */	NdrFcShort( 0x6 ),	/* Offset= 6 (1000) */
/* 996 */	
			0x12, 0x0,	/* FC_UP */
/* 998 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (962) */
/* 1000 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 1002 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1004 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1006 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1008 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (996) */

			0x0
        }
    };

const CInterfaceProxyVtbl * _CerClient_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ICerUploadProxyVtbl,
    0
};

const CInterfaceStubVtbl * _CerClient_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ICerUploadStubVtbl,
    0
};

PCInterfaceName const _CerClient_InterfaceNamesList[] = 
{
    "ICerUpload",
    0
};

const IID *  _CerClient_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _CerClient_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _CerClient, pIID, n)

int __stdcall _CerClient_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_CerClient_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo CerClient_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _CerClient_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _CerClient_StubVtblList,
    (const PCInterfaceName * ) & _CerClient_InterfaceNamesList,
    (const IID ** ) & _CerClient_BaseIIDList,
    & _CerClient_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\cerupload\cerupload.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Fri Aug 03 17:18:11 2001
 */
/* Compiler settings for E:\bluescreen\main\ENU\cerclient\CERUpload.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __CERUpload_h__
#define __CERUpload_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

#ifndef __ICerClient_FWD_DEFINED__
#define __ICerClient_FWD_DEFINED__
typedef interface ICerClient ICerClient;
#endif 	/* __ICerClient_FWD_DEFINED__ */


#ifndef __CerClient_FWD_DEFINED__
#define __CerClient_FWD_DEFINED__

#ifdef __cplusplus
typedef class CerClient CerClient;
#else
typedef struct CerClient CerClient;
#endif /* __cplusplus */

#endif 	/* __CerClient_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 

#ifndef __ICerClient_INTERFACE_DEFINED__
#define __ICerClient_INTERFACE_DEFINED__

/* interface ICerClient */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICerClient;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("26D7830B-20F6-4462-A4EA-573A60791F0E")
    ICerClient : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFileCount( 
            /* [in] */ BSTR __RPC_FAR *bstrSharePath,
            /* [in] */ BSTR __RPC_FAR *bstrTransactID,
            /* [in] */ VARIANT __RPC_FAR *iMaxCount,
            /* [retval][out] */ VARIANT __RPC_FAR *RetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Upload( 
            /* [in] */ BSTR __RPC_FAR *Path,
            /* [in] */ BSTR __RPC_FAR *TransID,
            /* [in] */ BSTR __RPC_FAR *FileName,
            /* [in] */ BSTR __RPC_FAR *IncidentID,
            /* [in] */ BSTR __RPC_FAR *RedirParam,
            /* [retval][out] */ VARIANT __RPC_FAR *RetCode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RetryTransaction( 
            /* [in] */ BSTR __RPC_FAR *Path,
            /* [in] */ BSTR __RPC_FAR *TransID,
            /* [in] */ BSTR __RPC_FAR *FileName,
            /* [retval][out] */ VARIANT __RPC_FAR *RetVal) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RetryFile( 
            /* [in] */ BSTR __RPC_FAR *Path,
            /* [in] */ BSTR __RPC_FAR *TransID,
            /* [in] */ BSTR FileName,
            /* [retval][out] */ VARIANT __RPC_FAR *RetCode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFileNames( 
            /* [in] */ BSTR __RPC_FAR *Path,
            /* [in] */ BSTR __RPC_FAR *TransID,
            /* [in] */ VARIANT __RPC_FAR *Count,
            /* [retval][out] */ VARIANT __RPC_FAR *FileList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Browse( 
            /* [in] */ BSTR __RPC_FAR *WindowTitle,
            /* [retval][out] */ VARIANT __RPC_FAR *Path) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetCompuerNames( 
            /* [in] */ BSTR __RPC_FAR *Path,
            /* [in] */ BSTR __RPC_FAR *TransID,
            /* [in] */ BSTR __RPC_FAR *FileList,
            /* [retval][out] */ VARIANT __RPC_FAR *RetFileList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetAllComputerNames( 
            /* [in] */ BSTR __RPC_FAR *Path,
            /* [in] */ BSTR __RPC_FAR *TransID,
            /* [in] */ BSTR __RPC_FAR *FileList,
            /* [retval][out] */ VARIANT __RPC_FAR *ReturnList) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE RetryFile1( 
            /* [in] */ BSTR __RPC_FAR *Path,
            /* [in] */ BSTR __RPC_FAR *TransID,
            /* [in] */ BSTR __RPC_FAR *FileName,
            /* [in] */ BSTR __RPC_FAR *IncidentID,
            /* [in] */ BSTR __RPC_FAR *RedirParam,
            /* [retval][out] */ VARIANT __RPC_FAR *RetCode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE EndTransaction( 
            /* [in] */ BSTR __RPC_FAR *SharePath,
            /* [in] */ BSTR __RPC_FAR *TransID,
            /* [retval][out] */ VARIANT __RPC_FAR *RetCode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE Upload1( 
            /* [in] */ BSTR __RPC_FAR *Path,
            /* [in] */ BSTR __RPC_FAR *TransID,
            /* [in] */ BSTR __RPC_FAR *FileName,
            /* [in] */ BSTR __RPC_FAR *IncidentID,
            /* [in] */ BSTR __RPC_FAR *RedirParam,
            /* [in] */ BSTR __RPC_FAR *Type,
            /* [retval][out] */ VARIANT __RPC_FAR *RetCode) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSuccessCount( 
            /* [in] */ BSTR __RPC_FAR *Path,
            /* [in] */ BSTR __RPC_FAR *TransID,
            /* [retval][out] */ VARIANT __RPC_FAR *RetVal) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICerClientVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *QueryInterface )( 
            ICerClient __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void __RPC_FAR *__RPC_FAR *ppvObject);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *AddRef )( 
            ICerClient __RPC_FAR * This);
        
        ULONG ( STDMETHODCALLTYPE __RPC_FAR *Release )( 
            ICerClient __RPC_FAR * This);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfoCount )( 
            ICerClient __RPC_FAR * This,
            /* [out] */ UINT __RPC_FAR *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetTypeInfo )( 
            ICerClient __RPC_FAR * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo __RPC_FAR *__RPC_FAR *ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetIDsOfNames )( 
            ICerClient __RPC_FAR * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR __RPC_FAR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID __RPC_FAR *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Invoke )( 
            ICerClient __RPC_FAR * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS __RPC_FAR *pDispParams,
            /* [out] */ VARIANT __RPC_FAR *pVarResult,
            /* [out] */ EXCEPINFO __RPC_FAR *pExcepInfo,
            /* [out] */ UINT __RPC_FAR *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileCount )( 
            ICerClient __RPC_FAR * This,
            /* [in] */ BSTR __RPC_FAR *bstrSharePath,
            /* [in] */ BSTR __RPC_FAR *bstrTransactID,
            /* [in] */ VARIANT __RPC_FAR *iMaxCount,
            /* [retval][out] */ VARIANT __RPC_FAR *RetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Upload )( 
            ICerClient __RPC_FAR * This,
            /* [in] */ BSTR __RPC_FAR *Path,
            /* [in] */ BSTR __RPC_FAR *TransID,
            /* [in] */ BSTR __RPC_FAR *FileName,
            /* [in] */ BSTR __RPC_FAR *IncidentID,
            /* [in] */ BSTR __RPC_FAR *RedirParam,
            /* [retval][out] */ VARIANT __RPC_FAR *RetCode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RetryTransaction )( 
            ICerClient __RPC_FAR * This,
            /* [in] */ BSTR __RPC_FAR *Path,
            /* [in] */ BSTR __RPC_FAR *TransID,
            /* [in] */ BSTR __RPC_FAR *FileName,
            /* [retval][out] */ VARIANT __RPC_FAR *RetVal);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RetryFile )( 
            ICerClient __RPC_FAR * This,
            /* [in] */ BSTR __RPC_FAR *Path,
            /* [in] */ BSTR __RPC_FAR *TransID,
            /* [in] */ BSTR FileName,
            /* [retval][out] */ VARIANT __RPC_FAR *RetCode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetFileNames )( 
            ICerClient __RPC_FAR * This,
            /* [in] */ BSTR __RPC_FAR *Path,
            /* [in] */ BSTR __RPC_FAR *TransID,
            /* [in] */ VARIANT __RPC_FAR *Count,
            /* [retval][out] */ VARIANT __RPC_FAR *FileList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Browse )( 
            ICerClient __RPC_FAR * This,
            /* [in] */ BSTR __RPC_FAR *WindowTitle,
            /* [retval][out] */ VARIANT __RPC_FAR *Path);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetCompuerNames )( 
            ICerClient __RPC_FAR * This,
            /* [in] */ BSTR __RPC_FAR *Path,
            /* [in] */ BSTR __RPC_FAR *TransID,
            /* [in] */ BSTR __RPC_FAR *FileList,
            /* [retval][out] */ VARIANT __RPC_FAR *RetFileList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetAllComputerNames )( 
            ICerClient __RPC_FAR * This,
            /* [in] */ BSTR __RPC_FAR *Path,
            /* [in] */ BSTR __RPC_FAR *TransID,
            /* [in] */ BSTR __RPC_FAR *FileList,
            /* [retval][out] */ VARIANT __RPC_FAR *ReturnList);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *RetryFile1 )( 
            ICerClient __RPC_FAR * This,
            /* [in] */ BSTR __RPC_FAR *Path,
            /* [in] */ BSTR __RPC_FAR *TransID,
            /* [in] */ BSTR __RPC_FAR *FileName,
            /* [in] */ BSTR __RPC_FAR *IncidentID,
            /* [in] */ BSTR __RPC_FAR *RedirParam,
            /* [retval][out] */ VARIANT __RPC_FAR *RetCode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *EndTransaction )( 
            ICerClient __RPC_FAR * This,
            /* [in] */ BSTR __RPC_FAR *SharePath,
            /* [in] */ BSTR __RPC_FAR *TransID,
            /* [retval][out] */ VARIANT __RPC_FAR *RetCode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *Upload1 )( 
            ICerClient __RPC_FAR * This,
            /* [in] */ BSTR __RPC_FAR *Path,
            /* [in] */ BSTR __RPC_FAR *TransID,
            /* [in] */ BSTR __RPC_FAR *FileName,
            /* [in] */ BSTR __RPC_FAR *IncidentID,
            /* [in] */ BSTR __RPC_FAR *RedirParam,
            /* [in] */ BSTR __RPC_FAR *Type,
            /* [retval][out] */ VARIANT __RPC_FAR *RetCode);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE __RPC_FAR *GetSuccessCount )( 
            ICerClient __RPC_FAR * This,
            /* [in] */ BSTR __RPC_FAR *Path,
            /* [in] */ BSTR __RPC_FAR *TransID,
            /* [retval][out] */ VARIANT __RPC_FAR *RetVal);
        
        END_INTERFACE
    } ICerClientVtbl;

    interface ICerClient
    {
        CONST_VTBL struct ICerClientVtbl __RPC_FAR *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICerClient_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICerClient_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICerClient_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICerClient_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICerClient_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICerClient_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICerClient_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICerClient_GetFileCount(This,bstrSharePath,bstrTransactID,iMaxCount,RetVal)	\
    (This)->lpVtbl -> GetFileCount(This,bstrSharePath,bstrTransactID,iMaxCount,RetVal)

#define ICerClient_Upload(This,Path,TransID,FileName,IncidentID,RedirParam,RetCode)	\
    (This)->lpVtbl -> Upload(This,Path,TransID,FileName,IncidentID,RedirParam,RetCode)

#define ICerClient_RetryTransaction(This,Path,TransID,FileName,RetVal)	\
    (This)->lpVtbl -> RetryTransaction(This,Path,TransID,FileName,RetVal)

#define ICerClient_RetryFile(This,Path,TransID,FileName,RetCode)	\
    (This)->lpVtbl -> RetryFile(This,Path,TransID,FileName,RetCode)

#define ICerClient_GetFileNames(This,Path,TransID,Count,FileList)	\
    (This)->lpVtbl -> GetFileNames(This,Path,TransID,Count,FileList)

#define ICerClient_Browse(This,WindowTitle,Path)	\
    (This)->lpVtbl -> Browse(This,WindowTitle,Path)

#define ICerClient_GetCompuerNames(This,Path,TransID,FileList,RetFileList)	\
    (This)->lpVtbl -> GetCompuerNames(This,Path,TransID,FileList,RetFileList)

#define ICerClient_GetAllComputerNames(This,Path,TransID,FileList,ReturnList)	\
    (This)->lpVtbl -> GetAllComputerNames(This,Path,TransID,FileList,ReturnList)

#define ICerClient_RetryFile1(This,Path,TransID,FileName,IncidentID,RedirParam,RetCode)	\
    (This)->lpVtbl -> RetryFile1(This,Path,TransID,FileName,IncidentID,RedirParam,RetCode)

#define ICerClient_EndTransaction(This,SharePath,TransID,RetCode)	\
    (This)->lpVtbl -> EndTransaction(This,SharePath,TransID,RetCode)

#define ICerClient_Upload1(This,Path,TransID,FileName,IncidentID,RedirParam,Type,RetCode)	\
    (This)->lpVtbl -> Upload1(This,Path,TransID,FileName,IncidentID,RedirParam,Type,RetCode)

#define ICerClient_GetSuccessCount(This,Path,TransID,RetVal)	\
    (This)->lpVtbl -> GetSuccessCount(This,Path,TransID,RetVal)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICerClient_GetFileCount_Proxy( 
    ICerClient __RPC_FAR * This,
    /* [in] */ BSTR __RPC_FAR *bstrSharePath,
    /* [in] */ BSTR __RPC_FAR *bstrTransactID,
    /* [in] */ VARIANT __RPC_FAR *iMaxCount,
    /* [retval][out] */ VARIANT __RPC_FAR *RetVal);


void __RPC_STUB ICerClient_GetFileCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICerClient_Upload_Proxy( 
    ICerClient __RPC_FAR * This,
    /* [in] */ BSTR __RPC_FAR *Path,
    /* [in] */ BSTR __RPC_FAR *TransID,
    /* [in] */ BSTR __RPC_FAR *FileName,
    /* [in] */ BSTR __RPC_FAR *IncidentID,
    /* [in] */ BSTR __RPC_FAR *RedirParam,
    /* [retval][out] */ VARIANT __RPC_FAR *RetCode);


void __RPC_STUB ICerClient_Upload_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICerClient_RetryTransaction_Proxy( 
    ICerClient __RPC_FAR * This,
    /* [in] */ BSTR __RPC_FAR *Path,
    /* [in] */ BSTR __RPC_FAR *TransID,
    /* [in] */ BSTR __RPC_FAR *FileName,
    /* [retval][out] */ VARIANT __RPC_FAR *RetVal);


void __RPC_STUB ICerClient_RetryTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICerClient_RetryFile_Proxy( 
    ICerClient __RPC_FAR * This,
    /* [in] */ BSTR __RPC_FAR *Path,
    /* [in] */ BSTR __RPC_FAR *TransID,
    /* [in] */ BSTR FileName,
    /* [retval][out] */ VARIANT __RPC_FAR *RetCode);


void __RPC_STUB ICerClient_RetryFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICerClient_GetFileNames_Proxy( 
    ICerClient __RPC_FAR * This,
    /* [in] */ BSTR __RPC_FAR *Path,
    /* [in] */ BSTR __RPC_FAR *TransID,
    /* [in] */ VARIANT __RPC_FAR *Count,
    /* [retval][out] */ VARIANT __RPC_FAR *FileList);


void __RPC_STUB ICerClient_GetFileNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICerClient_Browse_Proxy( 
    ICerClient __RPC_FAR * This,
    /* [in] */ BSTR __RPC_FAR *WindowTitle,
    /* [retval][out] */ VARIANT __RPC_FAR *Path);


void __RPC_STUB ICerClient_Browse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICerClient_GetCompuerNames_Proxy( 
    ICerClient __RPC_FAR * This,
    /* [in] */ BSTR __RPC_FAR *Path,
    /* [in] */ BSTR __RPC_FAR *TransID,
    /* [in] */ BSTR __RPC_FAR *FileList,
    /* [retval][out] */ VARIANT __RPC_FAR *RetFileList);


void __RPC_STUB ICerClient_GetCompuerNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICerClient_GetAllComputerNames_Proxy( 
    ICerClient __RPC_FAR * This,
    /* [in] */ BSTR __RPC_FAR *Path,
    /* [in] */ BSTR __RPC_FAR *TransID,
    /* [in] */ BSTR __RPC_FAR *FileList,
    /* [retval][out] */ VARIANT __RPC_FAR *ReturnList);


void __RPC_STUB ICerClient_GetAllComputerNames_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICerClient_RetryFile1_Proxy( 
    ICerClient __RPC_FAR * This,
    /* [in] */ BSTR __RPC_FAR *Path,
    /* [in] */ BSTR __RPC_FAR *TransID,
    /* [in] */ BSTR __RPC_FAR *FileName,
    /* [in] */ BSTR __RPC_FAR *IncidentID,
    /* [in] */ BSTR __RPC_FAR *RedirParam,
    /* [retval][out] */ VARIANT __RPC_FAR *RetCode);


void __RPC_STUB ICerClient_RetryFile1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICerClient_EndTransaction_Proxy( 
    ICerClient __RPC_FAR * This,
    /* [in] */ BSTR __RPC_FAR *SharePath,
    /* [in] */ BSTR __RPC_FAR *TransID,
    /* [retval][out] */ VARIANT __RPC_FAR *RetCode);


void __RPC_STUB ICerClient_EndTransaction_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICerClient_Upload1_Proxy( 
    ICerClient __RPC_FAR * This,
    /* [in] */ BSTR __RPC_FAR *Path,
    /* [in] */ BSTR __RPC_FAR *TransID,
    /* [in] */ BSTR __RPC_FAR *FileName,
    /* [in] */ BSTR __RPC_FAR *IncidentID,
    /* [in] */ BSTR __RPC_FAR *RedirParam,
    /* [in] */ BSTR __RPC_FAR *Type,
    /* [retval][out] */ VARIANT __RPC_FAR *RetCode);


void __RPC_STUB ICerClient_Upload1_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICerClient_GetSuccessCount_Proxy( 
    ICerClient __RPC_FAR * This,
    /* [in] */ BSTR __RPC_FAR *Path,
    /* [in] */ BSTR __RPC_FAR *TransID,
    /* [retval][out] */ VARIANT __RPC_FAR *RetVal);


void __RPC_STUB ICerClient_GetSuccessCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICerClient_INTERFACE_DEFINED__ */



#ifndef __CERUPLOADLib_LIBRARY_DEFINED__
#define __CERUPLOADLib_LIBRARY_DEFINED__

/* library CERUPLOADLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_CERUPLOADLib;

EXTERN_C const CLSID CLSID_CerClient;

#ifdef __cplusplus

class DECLSPEC_UUID("35D339D5-756E-4948-860E-30B6C3B4494A")
CerClient;
#endif
#endif /* __CERUPLOADLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long __RPC_FAR *, unsigned long            , BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  BSTR_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, BSTR __RPC_FAR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long __RPC_FAR *, BSTR __RPC_FAR * ); 

unsigned long             __RPC_USER  VARIANT_UserSize(     unsigned long __RPC_FAR *, unsigned long            , VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserMarshal(  unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
unsigned char __RPC_FAR * __RPC_USER  VARIANT_UserUnmarshal(unsigned long __RPC_FAR *, unsigned char __RPC_FAR *, VARIANT __RPC_FAR * ); 
void                      __RPC_USER  VARIANT_UserFree(     unsigned long __RPC_FAR *, VARIANT __RPC_FAR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\cerupload\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by CERUpload.rc
//
#define IDS_PROJNAME                    100
#define IDB_CERCLIENT                   101
#define IDR_CERCLIENT                   102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\cerupload\dlldatax.h ===
#if !defined(AFX_DLLDATAX_H__29FDC1BC_4163_441E_A57A_298FBF6EB383__INCLUDED_)
#define AFX_DLLDATAX_H__29FDC1BC_4163_441E_A57A_298FBF6EB383__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#ifdef _MERGE_PROXYSTUB

extern "C" 
{
BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, 
	LPVOID lpReserved);
STDAPI PrxDllCanUnloadNow(void);
STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv);
STDAPI PrxDllRegisterServer(void);
STDAPI PrxDllUnregisterServer(void);
}

#endif

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DLLDATAX_H__29FDC1BC_4163_441E_A57A_298FBF6EB383__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\cerupload\cerupload_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Fri Aug 03 17:18:11 2001
 */
/* Compiler settings for E:\bluescreen\main\ENU\cerclient\CERUpload.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID IID_ICerClient = {0x26D7830B,0x20F6,0x4462,{0xA4,0xEA,0x57,0x3A,0x60,0x79,0x1F,0x0E}};


const IID LIBID_CERUPLOADLib = {0xA3800A93,0x4BC1,0x4E96,{0xA3,0xF9,0x74,0x0E,0xF8,0x62,0x3B,0x23}};


const CLSID CLSID_CerClient = {0x35D339D5,0x756E,0x4948,{0x86,0x0E,0x30,0xB6,0xC3,0xB4,0x49,0x4A}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\cerupload\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( CERUpload )
EXTERN_PROXY_FILE( cerupload )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( CERUpload ),
  REFERENCE_PROXY_FILE( cerupload ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\cerupload\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\cerupload\errorcodes.h ===
#define NO_SHARE_PATH -1
#define OUT_OF_MEMORY -2
#define NO_TRANS_ID   -3
#define FILE_OPEN_FAILED -4
#define FILE_READ_FAILED -5
#define FILE_EXISTS -6
#define FILE_CREATE_FAILED -7
#define FILE_DOES_NOT_EXIST -8
#define RETRY_FAILED  -10
#define BAD_COUNT_VALUE -11
#define FAILED_TO_UPDATE_CSV -12
#define UNKNOWN_UPLOAD_TYPE -13
#define INVALID_COUNT_PARAM -14
#define INVALID_TRANSID -15
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\cerupload\dlldatax.c ===
// wrapper for dlldata.c

#ifdef _MERGE_PROXYSTUB // merge proxy stub DLL

#define REGISTER_PROXY_DLL //DllRegisterServer, etc.

#define _WIN32_WINNT 0x0400	//for WinNT 4.0 or Win95 with DCOM
#define USE_STUBLESS_PROXY	//defined only with MIDL switch /Oicf

#pragma comment(lib, "rpcndr.lib")
#pragma comment(lib, "rpcns4.lib")
#pragma comment(lib, "rpcrt4.lib")

#define DllMain				PrxDllMain
#define DllRegisterServer	PrxDllRegisterServer
#define DllUnregisterServer PrxDllUnregisterServer
#define DllGetClassObject   PrxDllGetClassObject
#define DllCanUnloadNow     PrxDllCanUnloadNow

#include "dlldata.c"
#include "CERUpload_p.c"

#ifdef _NOPROXY //no midl generated dlldata.c

#define STRICT 1
#include <ole2.h>

BOOL WINAPI PrxDllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID lpReserved)
{return TRUE;}

STDAPI PrxDllCanUnloadNow(void){return S_OK;}

STDAPI PrxDllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{return CLASS_E_CLASSNOTAVAILABLE;}

STDAPI PrxDllRegisterServer(void){return S_OK;}

STDAPI PrxDllUnregisterServer(void){return S_OK;}

#endif //!PROXY_DELEGATION

#endif //_MERGE_PROXYSTUB
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\cerupload\cerupload_p.c ===
/* this ALWAYS GENERATED file contains the proxy stub code */


/* File created by MIDL compiler version 5.01.0164 */
/* at Fri Aug 03 17:18:11 2001
 */
/* Compiler settings for E:\bluescreen\main\ENU\cerclient\CERUpload.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )

#define USE_STUBLESS_PROXY


/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "CERUpload.h"

#define TYPE_FORMAT_STRING_SIZE   1007                              
#define PROC_FORMAT_STRING_SIZE   571                               

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ICerClient, ver. 0.0,
   GUID={0x26D7830B,0x20F6,0x4462,{0xA4,0xEA,0x57,0x3A,0x60,0x79,0x1F,0x0E}} */


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICerClient_ServerInfo;

#pragma code_seg(".orpc")
extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[2];

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x50100a4, /* MIDL Version 5.1.164 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    1,  /* Flags */
    0,  /* Reserved3 */
    0,  /* Reserved4 */
    0   /* Reserved5 */
    };

static const unsigned short ICerClient_FormatStringOffsetTable[] = 
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    46,
    104,
    150,
    196,
    242,
    276,
    322,
    368,
    426,
    466,
    530
    };

static const MIDL_SERVER_INFO ICerClient_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICerClient_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0
    };

static const MIDL_STUBLESS_PROXY_INFO ICerClient_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICerClient_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };

CINTERFACE_PROXY_VTABLE(19) _ICerClientProxyVtbl = 
{
    &ICerClient_ProxyInfo,
    &IID_ICerClient,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfoCount */ ,
    0 /* (void *)-1 /* IDispatch::GetTypeInfo */ ,
    0 /* (void *)-1 /* IDispatch::GetIDsOfNames */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    (void *)-1 /* ICerClient::GetFileCount */ ,
    (void *)-1 /* ICerClient::Upload */ ,
    (void *)-1 /* ICerClient::RetryTransaction */ ,
    (void *)-1 /* ICerClient::RetryFile */ ,
    (void *)-1 /* ICerClient::GetFileNames */ ,
    (void *)-1 /* ICerClient::Browse */ ,
    (void *)-1 /* ICerClient::GetCompuerNames */ ,
    (void *)-1 /* ICerClient::GetAllComputerNames */ ,
    (void *)-1 /* ICerClient::RetryFile1 */ ,
    (void *)-1 /* ICerClient::EndTransaction */ ,
    (void *)-1 /* ICerClient::Upload1 */ ,
    (void *)-1 /* ICerClient::GetSuccessCount */
};


static const PRPC_STUB_FUNCTION ICerClient_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2,
    NdrStubCall2
};

CInterfaceStubVtbl _ICerClientStubVtbl =
{
    &IID_ICerClient,
    &ICerClient_ServerInfo,
    19,
    &ICerClient_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

#pragma data_seg(".rdata")

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[2] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            },
            {
            VARIANT_UserSize
            ,VARIANT_UserMarshal
            ,VARIANT_UserUnmarshal
            ,VARIANT_UserFree
            }

        };


#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   -Oif or -Oicf, [wire_marshal] or [user_marshal] attribute, more than 32 methods in the interface.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {

	/* Procedure GetFileCount */

			0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/*  2 */	NdrFcLong( 0x0 ),	/* 0 */
/*  6 */	NdrFcShort( 0x7 ),	/* 7 */
#ifndef _ALPHA_
/*  8 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 10 */	NdrFcShort( 0x0 ),	/* 0 */
/* 12 */	NdrFcShort( 0x8 ),	/* 8 */
/* 14 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter bstrSharePath */

/* 16 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 18 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 20 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter bstrTransactID */

/* 22 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 24 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 26 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter iMaxCount */

/* 28 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 30 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 32 */	NdrFcShort( 0x3d2 ),	/* Type Offset=978 */

	/* Parameter RetVal */

/* 34 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
#ifndef _ALPHA_
/* 36 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 38 */	NdrFcShort( 0x3e4 ),	/* Type Offset=996 */

	/* Return value */

/* 40 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 42 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 44 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Upload */

/* 46 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 48 */	NdrFcLong( 0x0 ),	/* 0 */
/* 52 */	NdrFcShort( 0x8 ),	/* 8 */
#ifndef _ALPHA_
/* 54 */	NdrFcShort( 0x20 ),	/* x86, MIPS, PPC Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 56 */	NdrFcShort( 0x0 ),	/* 0 */
/* 58 */	NdrFcShort( 0x8 ),	/* 8 */
/* 60 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x7,		/* 7 */

	/* Parameter Path */

/* 62 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 64 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 66 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter TransID */

/* 68 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 70 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 72 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter FileName */

/* 74 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 76 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 78 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter IncidentID */

/* 80 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 82 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 84 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter RedirParam */

/* 86 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 88 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 90 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter RetCode */

/* 92 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
#ifndef _ALPHA_
/* 94 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 96 */	NdrFcShort( 0x3e4 ),	/* Type Offset=996 */

	/* Return value */

/* 98 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 100 */	NdrFcShort( 0x1c ),	/* x86, MIPS, PPC Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 102 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RetryTransaction */

/* 104 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 106 */	NdrFcLong( 0x0 ),	/* 0 */
/* 110 */	NdrFcShort( 0x9 ),	/* 9 */
#ifndef _ALPHA_
/* 112 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 114 */	NdrFcShort( 0x0 ),	/* 0 */
/* 116 */	NdrFcShort( 0x8 ),	/* 8 */
/* 118 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter Path */

/* 120 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 122 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 124 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter TransID */

/* 126 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 128 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 130 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter FileName */

/* 132 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 134 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 136 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter RetVal */

/* 138 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
#ifndef _ALPHA_
/* 140 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 142 */	NdrFcShort( 0x3e4 ),	/* Type Offset=996 */

	/* Return value */

/* 144 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 146 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 148 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RetryFile */

/* 150 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 152 */	NdrFcLong( 0x0 ),	/* 0 */
/* 156 */	NdrFcShort( 0xa ),	/* 10 */
#ifndef _ALPHA_
/* 158 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 160 */	NdrFcShort( 0x0 ),	/* 0 */
/* 162 */	NdrFcShort( 0x8 ),	/* 8 */
/* 164 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter Path */

/* 166 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 168 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 170 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter TransID */

/* 172 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 174 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 176 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter FileName */

/* 178 */	NdrFcShort( 0x8b ),	/* Flags:  must size, must free, in, by val, */
#ifndef _ALPHA_
/* 180 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 182 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter RetCode */

/* 184 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
#ifndef _ALPHA_
/* 186 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 188 */	NdrFcShort( 0x3e4 ),	/* Type Offset=996 */

	/* Return value */

/* 190 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 192 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 194 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetFileNames */

/* 196 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 198 */	NdrFcLong( 0x0 ),	/* 0 */
/* 202 */	NdrFcShort( 0xb ),	/* 11 */
#ifndef _ALPHA_
/* 204 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 206 */	NdrFcShort( 0x0 ),	/* 0 */
/* 208 */	NdrFcShort( 0x8 ),	/* 8 */
/* 210 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter Path */

/* 212 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 214 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 216 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter TransID */

/* 218 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 220 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 222 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter Count */

/* 224 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 226 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 228 */	NdrFcShort( 0x3d2 ),	/* Type Offset=978 */

	/* Parameter FileList */

/* 230 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
#ifndef _ALPHA_
/* 232 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 234 */	NdrFcShort( 0x3e4 ),	/* Type Offset=996 */

	/* Return value */

/* 236 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 238 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 240 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Browse */

/* 242 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 244 */	NdrFcLong( 0x0 ),	/* 0 */
/* 248 */	NdrFcShort( 0xc ),	/* 12 */
#ifndef _ALPHA_
/* 250 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 252 */	NdrFcShort( 0x0 ),	/* 0 */
/* 254 */	NdrFcShort( 0x8 ),	/* 8 */
/* 256 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x3,		/* 3 */

	/* Parameter WindowTitle */

/* 258 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 260 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 262 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter Path */

/* 264 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
#ifndef _ALPHA_
/* 266 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 268 */	NdrFcShort( 0x3e4 ),	/* Type Offset=996 */

	/* Return value */

/* 270 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 272 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 274 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetCompuerNames */

/* 276 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 278 */	NdrFcLong( 0x0 ),	/* 0 */
/* 282 */	NdrFcShort( 0xd ),	/* 13 */
#ifndef _ALPHA_
/* 284 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 286 */	NdrFcShort( 0x0 ),	/* 0 */
/* 288 */	NdrFcShort( 0x8 ),	/* 8 */
/* 290 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter Path */

/* 292 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 294 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 296 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter TransID */

/* 298 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 300 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 302 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter FileList */

/* 304 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 306 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 308 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter RetFileList */

/* 310 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
#ifndef _ALPHA_
/* 312 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 314 */	NdrFcShort( 0x3e4 ),	/* Type Offset=996 */

	/* Return value */

/* 316 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 318 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 320 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetAllComputerNames */

/* 322 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 324 */	NdrFcLong( 0x0 ),	/* 0 */
/* 328 */	NdrFcShort( 0xe ),	/* 14 */
#ifndef _ALPHA_
/* 330 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 332 */	NdrFcShort( 0x0 ),	/* 0 */
/* 334 */	NdrFcShort( 0x8 ),	/* 8 */
/* 336 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x5,		/* 5 */

	/* Parameter Path */

/* 338 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 340 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 342 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter TransID */

/* 344 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 346 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 348 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter FileList */

/* 350 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 352 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 354 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter ReturnList */

/* 356 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
#ifndef _ALPHA_
/* 358 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 360 */	NdrFcShort( 0x3e4 ),	/* Type Offset=996 */

	/* Return value */

/* 362 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 364 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 366 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure RetryFile1 */

/* 368 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 370 */	NdrFcLong( 0x0 ),	/* 0 */
/* 374 */	NdrFcShort( 0xf ),	/* 15 */
#ifndef _ALPHA_
/* 376 */	NdrFcShort( 0x20 ),	/* x86, MIPS, PPC Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 378 */	NdrFcShort( 0x0 ),	/* 0 */
/* 380 */	NdrFcShort( 0x8 ),	/* 8 */
/* 382 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x7,		/* 7 */

	/* Parameter Path */

/* 384 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 386 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 388 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter TransID */

/* 390 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 392 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 394 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter FileName */

/* 396 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 398 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 400 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter IncidentID */

/* 402 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 404 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 406 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter RedirParam */

/* 408 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 410 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 412 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter RetCode */

/* 414 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
#ifndef _ALPHA_
/* 416 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 418 */	NdrFcShort( 0x3e4 ),	/* Type Offset=996 */

	/* Return value */

/* 420 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 422 */	NdrFcShort( 0x1c ),	/* x86, MIPS, PPC Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 424 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure EndTransaction */

/* 426 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 428 */	NdrFcLong( 0x0 ),	/* 0 */
/* 432 */	NdrFcShort( 0x10 ),	/* 16 */
#ifndef _ALPHA_
/* 434 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 436 */	NdrFcShort( 0x0 ),	/* 0 */
/* 438 */	NdrFcShort( 0x8 ),	/* 8 */
/* 440 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter SharePath */

/* 442 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 444 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 446 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter TransID */

/* 448 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 450 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 452 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter RetCode */

/* 454 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
#ifndef _ALPHA_
/* 456 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 458 */	NdrFcShort( 0x3e4 ),	/* Type Offset=996 */

	/* Return value */

/* 460 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 462 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 464 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure Upload1 */

/* 466 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 468 */	NdrFcLong( 0x0 ),	/* 0 */
/* 472 */	NdrFcShort( 0x11 ),	/* 17 */
#ifndef _ALPHA_
/* 474 */	NdrFcShort( 0x24 ),	/* x86, MIPS, PPC Stack size/offset = 36 */
#else
			NdrFcShort( 0x48 ),	/* Alpha Stack size/offset = 72 */
#endif
/* 476 */	NdrFcShort( 0x0 ),	/* 0 */
/* 478 */	NdrFcShort( 0x8 ),	/* 8 */
/* 480 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x8,		/* 8 */

	/* Parameter Path */

/* 482 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 484 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 486 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter TransID */

/* 488 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 490 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 492 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter FileName */

/* 494 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 496 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 498 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter IncidentID */

/* 500 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 502 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 504 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter RedirParam */

/* 506 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 508 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 510 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter Type */

/* 512 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 514 */	NdrFcShort( 0x18 ),	/* x86, MIPS, PPC Stack size/offset = 24 */
#else
			NdrFcShort( 0x30 ),	/* Alpha Stack size/offset = 48 */
#endif
/* 516 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter RetCode */

/* 518 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
#ifndef _ALPHA_
/* 520 */	NdrFcShort( 0x1c ),	/* x86, MIPS, PPC Stack size/offset = 28 */
#else
			NdrFcShort( 0x38 ),	/* Alpha Stack size/offset = 56 */
#endif
/* 522 */	NdrFcShort( 0x3e4 ),	/* Type Offset=996 */

	/* Return value */

/* 524 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 526 */	NdrFcShort( 0x20 ),	/* x86, MIPS, PPC Stack size/offset = 32 */
#else
			NdrFcShort( 0x40 ),	/* Alpha Stack size/offset = 64 */
#endif
/* 528 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

	/* Procedure GetSuccessCount */

/* 530 */	0x33,		/* FC_AUTO_HANDLE */
			0x6c,		/* Old Flags:  object, Oi2 */
/* 532 */	NdrFcLong( 0x0 ),	/* 0 */
/* 536 */	NdrFcShort( 0x12 ),	/* 18 */
#ifndef _ALPHA_
/* 538 */	NdrFcShort( 0x14 ),	/* x86, MIPS, PPC Stack size/offset = 20 */
#else
			NdrFcShort( 0x28 ),	/* Alpha Stack size/offset = 40 */
#endif
/* 540 */	NdrFcShort( 0x0 ),	/* 0 */
/* 542 */	NdrFcShort( 0x8 ),	/* 8 */
/* 544 */	0x7,		/* Oi2 Flags:  srv must size, clt must size, has return, */
			0x4,		/* 4 */

	/* Parameter Path */

/* 546 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 548 */	NdrFcShort( 0x4 ),	/* x86, MIPS, PPC Stack size/offset = 4 */
#else
			NdrFcShort( 0x8 ),	/* Alpha Stack size/offset = 8 */
#endif
/* 550 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter TransID */

/* 552 */	NdrFcShort( 0x10b ),	/* Flags:  must size, must free, in, simple ref, */
#ifndef _ALPHA_
/* 554 */	NdrFcShort( 0x8 ),	/* x86, MIPS, PPC Stack size/offset = 8 */
#else
			NdrFcShort( 0x10 ),	/* Alpha Stack size/offset = 16 */
#endif
/* 556 */	NdrFcShort( 0x1e ),	/* Type Offset=30 */

	/* Parameter RetVal */

/* 558 */	NdrFcShort( 0x4113 ),	/* Flags:  must size, must free, out, simple ref, srv alloc size=16 */
#ifndef _ALPHA_
/* 560 */	NdrFcShort( 0xc ),	/* x86, MIPS, PPC Stack size/offset = 12 */
#else
			NdrFcShort( 0x18 ),	/* Alpha Stack size/offset = 24 */
#endif
/* 562 */	NdrFcShort( 0x3e4 ),	/* Type Offset=996 */

	/* Return value */

/* 564 */	NdrFcShort( 0x70 ),	/* Flags:  out, return, base type, */
#ifndef _ALPHA_
/* 566 */	NdrFcShort( 0x10 ),	/* x86, MIPS, PPC Stack size/offset = 16 */
#else
			NdrFcShort( 0x20 ),	/* Alpha Stack size/offset = 32 */
#endif
/* 568 */	0x8,		/* FC_LONG */
			0x0,		/* 0 */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0x0,	/* FC_RP */
/*  4 */	NdrFcShort( 0x1a ),	/* Offset= 26 (30) */
/*  6 */	
			0x12, 0x0,	/* FC_UP */
/*  8 */	NdrFcShort( 0xc ),	/* Offset= 12 (20) */
/* 10 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 12 */	NdrFcShort( 0x2 ),	/* 2 */
/* 14 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 16 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 18 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 20 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 22 */	NdrFcShort( 0x8 ),	/* 8 */
/* 24 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (10) */
/* 26 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 28 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 30 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 32 */	NdrFcShort( 0x0 ),	/* 0 */
/* 34 */	NdrFcShort( 0x4 ),	/* 4 */
/* 36 */	NdrFcShort( 0x0 ),	/* 0 */
/* 38 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (6) */
/* 40 */	
			0x11, 0x0,	/* FC_RP */
/* 42 */	NdrFcShort( 0x3a8 ),	/* Offset= 936 (978) */
/* 44 */	
			0x12, 0x0,	/* FC_UP */
/* 46 */	NdrFcShort( 0x390 ),	/* Offset= 912 (958) */
/* 48 */	
			0x2b,		/* FC_NON_ENCAPSULATED_UNION */
			0x9,		/* FC_ULONG */
/* 50 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 52 */	NdrFcShort( 0xfff8 ),	/* -8 */
/* 54 */	NdrFcShort( 0x2 ),	/* Offset= 2 (56) */
/* 56 */	NdrFcShort( 0x10 ),	/* 16 */
/* 58 */	NdrFcShort( 0x2b ),	/* 43 */
/* 60 */	NdrFcLong( 0x3 ),	/* 3 */
/* 64 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 66 */	NdrFcLong( 0x11 ),	/* 17 */
/* 70 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 72 */	NdrFcLong( 0x2 ),	/* 2 */
/* 76 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 78 */	NdrFcLong( 0x4 ),	/* 4 */
/* 82 */	NdrFcShort( 0x800a ),	/* Simple arm type: FC_FLOAT */
/* 84 */	NdrFcLong( 0x5 ),	/* 5 */
/* 88 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 90 */	NdrFcLong( 0xb ),	/* 11 */
/* 94 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 96 */	NdrFcLong( 0xa ),	/* 10 */
/* 100 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 102 */	NdrFcLong( 0x6 ),	/* 6 */
/* 106 */	NdrFcShort( 0xd6 ),	/* Offset= 214 (320) */
/* 108 */	NdrFcLong( 0x7 ),	/* 7 */
/* 112 */	NdrFcShort( 0x800c ),	/* Simple arm type: FC_DOUBLE */
/* 114 */	NdrFcLong( 0x8 ),	/* 8 */
/* 118 */	NdrFcShort( 0xffffff90 ),	/* Offset= -112 (6) */
/* 120 */	NdrFcLong( 0xd ),	/* 13 */
/* 124 */	NdrFcShort( 0xca ),	/* Offset= 202 (326) */
/* 126 */	NdrFcLong( 0x9 ),	/* 9 */
/* 130 */	NdrFcShort( 0xd6 ),	/* Offset= 214 (344) */
/* 132 */	NdrFcLong( 0x2000 ),	/* 8192 */
/* 136 */	NdrFcShort( 0xe2 ),	/* Offset= 226 (362) */
/* 138 */	NdrFcLong( 0x24 ),	/* 36 */
/* 142 */	NdrFcShort( 0x2ec ),	/* Offset= 748 (890) */
/* 144 */	NdrFcLong( 0x4024 ),	/* 16420 */
/* 148 */	NdrFcShort( 0x2e6 ),	/* Offset= 742 (890) */
/* 150 */	NdrFcLong( 0x4011 ),	/* 16401 */
/* 154 */	NdrFcShort( 0x2e4 ),	/* Offset= 740 (894) */
/* 156 */	NdrFcLong( 0x4002 ),	/* 16386 */
/* 160 */	NdrFcShort( 0x2e2 ),	/* Offset= 738 (898) */
/* 162 */	NdrFcLong( 0x4003 ),	/* 16387 */
/* 166 */	NdrFcShort( 0x2e0 ),	/* Offset= 736 (902) */
/* 168 */	NdrFcLong( 0x4004 ),	/* 16388 */
/* 172 */	NdrFcShort( 0x2de ),	/* Offset= 734 (906) */
/* 174 */	NdrFcLong( 0x4005 ),	/* 16389 */
/* 178 */	NdrFcShort( 0x2dc ),	/* Offset= 732 (910) */
/* 180 */	NdrFcLong( 0x400b ),	/* 16395 */
/* 184 */	NdrFcShort( 0x2ca ),	/* Offset= 714 (898) */
/* 186 */	NdrFcLong( 0x400a ),	/* 16394 */
/* 190 */	NdrFcShort( 0x2c8 ),	/* Offset= 712 (902) */
/* 192 */	NdrFcLong( 0x4006 ),	/* 16390 */
/* 196 */	NdrFcShort( 0x2ce ),	/* Offset= 718 (914) */
/* 198 */	NdrFcLong( 0x4007 ),	/* 16391 */
/* 202 */	NdrFcShort( 0x2c4 ),	/* Offset= 708 (910) */
/* 204 */	NdrFcLong( 0x4008 ),	/* 16392 */
/* 208 */	NdrFcShort( 0x2c6 ),	/* Offset= 710 (918) */
/* 210 */	NdrFcLong( 0x400d ),	/* 16397 */
/* 214 */	NdrFcShort( 0x2c4 ),	/* Offset= 708 (922) */
/* 216 */	NdrFcLong( 0x4009 ),	/* 16393 */
/* 220 */	NdrFcShort( 0x2c2 ),	/* Offset= 706 (926) */
/* 222 */	NdrFcLong( 0x6000 ),	/* 24576 */
/* 226 */	NdrFcShort( 0x2c0 ),	/* Offset= 704 (930) */
/* 228 */	NdrFcLong( 0x400c ),	/* 16396 */
/* 232 */	NdrFcShort( 0x2be ),	/* Offset= 702 (934) */
/* 234 */	NdrFcLong( 0x10 ),	/* 16 */
/* 238 */	NdrFcShort( 0x8002 ),	/* Simple arm type: FC_CHAR */
/* 240 */	NdrFcLong( 0x12 ),	/* 18 */
/* 244 */	NdrFcShort( 0x8006 ),	/* Simple arm type: FC_SHORT */
/* 246 */	NdrFcLong( 0x13 ),	/* 19 */
/* 250 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 252 */	NdrFcLong( 0x16 ),	/* 22 */
/* 256 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 258 */	NdrFcLong( 0x17 ),	/* 23 */
/* 262 */	NdrFcShort( 0x8008 ),	/* Simple arm type: FC_LONG */
/* 264 */	NdrFcLong( 0xe ),	/* 14 */
/* 268 */	NdrFcShort( 0x2a2 ),	/* Offset= 674 (942) */
/* 270 */	NdrFcLong( 0x400e ),	/* 16398 */
/* 274 */	NdrFcShort( 0x2a8 ),	/* Offset= 680 (954) */
/* 276 */	NdrFcLong( 0x4010 ),	/* 16400 */
/* 280 */	NdrFcShort( 0x266 ),	/* Offset= 614 (894) */
/* 282 */	NdrFcLong( 0x4012 ),	/* 16402 */
/* 286 */	NdrFcShort( 0x264 ),	/* Offset= 612 (898) */
/* 288 */	NdrFcLong( 0x4013 ),	/* 16403 */
/* 292 */	NdrFcShort( 0x262 ),	/* Offset= 610 (902) */
/* 294 */	NdrFcLong( 0x4016 ),	/* 16406 */
/* 298 */	NdrFcShort( 0x25c ),	/* Offset= 604 (902) */
/* 300 */	NdrFcLong( 0x4017 ),	/* 16407 */
/* 304 */	NdrFcShort( 0x256 ),	/* Offset= 598 (902) */
/* 306 */	NdrFcLong( 0x0 ),	/* 0 */
/* 310 */	NdrFcShort( 0x0 ),	/* Offset= 0 (310) */
/* 312 */	NdrFcLong( 0x1 ),	/* 1 */
/* 316 */	NdrFcShort( 0x0 ),	/* Offset= 0 (316) */
/* 318 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (317) */
/* 320 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 322 */	NdrFcShort( 0x8 ),	/* 8 */
/* 324 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 326 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 328 */	NdrFcLong( 0x0 ),	/* 0 */
/* 332 */	NdrFcShort( 0x0 ),	/* 0 */
/* 334 */	NdrFcShort( 0x0 ),	/* 0 */
/* 336 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 338 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 340 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 342 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 344 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 346 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 350 */	NdrFcShort( 0x0 ),	/* 0 */
/* 352 */	NdrFcShort( 0x0 ),	/* 0 */
/* 354 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 356 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 358 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 360 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 362 */	
			0x12, 0x0,	/* FC_UP */
/* 364 */	NdrFcShort( 0x1fc ),	/* Offset= 508 (872) */
/* 366 */	
			0x2a,		/* FC_ENCAPSULATED_UNION */
			0x49,		/* 73 */
/* 368 */	NdrFcShort( 0x18 ),	/* 24 */
/* 370 */	NdrFcShort( 0xa ),	/* 10 */
/* 372 */	NdrFcLong( 0x8 ),	/* 8 */
/* 376 */	NdrFcShort( 0x58 ),	/* Offset= 88 (464) */
/* 378 */	NdrFcLong( 0xd ),	/* 13 */
/* 382 */	NdrFcShort( 0x78 ),	/* Offset= 120 (502) */
/* 384 */	NdrFcLong( 0x9 ),	/* 9 */
/* 388 */	NdrFcShort( 0x94 ),	/* Offset= 148 (536) */
/* 390 */	NdrFcLong( 0xc ),	/* 12 */
/* 394 */	NdrFcShort( 0xbc ),	/* Offset= 188 (582) */
/* 396 */	NdrFcLong( 0x24 ),	/* 36 */
/* 400 */	NdrFcShort( 0x114 ),	/* Offset= 276 (676) */
/* 402 */	NdrFcLong( 0x800d ),	/* 32781 */
/* 406 */	NdrFcShort( 0x130 ),	/* Offset= 304 (710) */
/* 408 */	NdrFcLong( 0x10 ),	/* 16 */
/* 412 */	NdrFcShort( 0x148 ),	/* Offset= 328 (740) */
/* 414 */	NdrFcLong( 0x2 ),	/* 2 */
/* 418 */	NdrFcShort( 0x160 ),	/* Offset= 352 (770) */
/* 420 */	NdrFcLong( 0x3 ),	/* 3 */
/* 424 */	NdrFcShort( 0x178 ),	/* Offset= 376 (800) */
/* 426 */	NdrFcLong( 0x14 ),	/* 20 */
/* 430 */	NdrFcShort( 0x190 ),	/* Offset= 400 (830) */
/* 432 */	NdrFcShort( 0xffffffff ),	/* Offset= -1 (431) */
/* 434 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 436 */	NdrFcShort( 0x4 ),	/* 4 */
/* 438 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 440 */	NdrFcShort( 0x0 ),	/* 0 */
/* 442 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 444 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 446 */	NdrFcShort( 0x4 ),	/* 4 */
/* 448 */	NdrFcShort( 0x0 ),	/* 0 */
/* 450 */	NdrFcShort( 0x1 ),	/* 1 */
/* 452 */	NdrFcShort( 0x0 ),	/* 0 */
/* 454 */	NdrFcShort( 0x0 ),	/* 0 */
/* 456 */	0x12, 0x0,	/* FC_UP */
/* 458 */	NdrFcShort( 0xfffffe4a ),	/* Offset= -438 (20) */
/* 460 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 462 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 464 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 466 */	NdrFcShort( 0x8 ),	/* 8 */
/* 468 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 470 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 472 */	NdrFcShort( 0x4 ),	/* 4 */
/* 474 */	NdrFcShort( 0x4 ),	/* 4 */
/* 476 */	0x11, 0x0,	/* FC_RP */
/* 478 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (434) */
/* 480 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 482 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 484 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 486 */	NdrFcShort( 0x0 ),	/* 0 */
/* 488 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 490 */	NdrFcShort( 0x0 ),	/* 0 */
/* 492 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 496 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 498 */	NdrFcShort( 0xffffff54 ),	/* Offset= -172 (326) */
/* 500 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 502 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 504 */	NdrFcShort( 0x8 ),	/* 8 */
/* 506 */	NdrFcShort( 0x0 ),	/* 0 */
/* 508 */	NdrFcShort( 0x6 ),	/* Offset= 6 (514) */
/* 510 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 512 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 514 */	
			0x11, 0x0,	/* FC_RP */
/* 516 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (484) */
/* 518 */	
			0x21,		/* FC_BOGUS_ARRAY */
			0x3,		/* 3 */
/* 520 */	NdrFcShort( 0x0 ),	/* 0 */
/* 522 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 524 */	NdrFcShort( 0x0 ),	/* 0 */
/* 526 */	NdrFcLong( 0xffffffff ),	/* -1 */
/* 530 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 532 */	NdrFcShort( 0xffffff44 ),	/* Offset= -188 (344) */
/* 534 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 536 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 538 */	NdrFcShort( 0x8 ),	/* 8 */
/* 540 */	NdrFcShort( 0x0 ),	/* 0 */
/* 542 */	NdrFcShort( 0x6 ),	/* Offset= 6 (548) */
/* 544 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 546 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 548 */	
			0x11, 0x0,	/* FC_RP */
/* 550 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (518) */
/* 552 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 554 */	NdrFcShort( 0x4 ),	/* 4 */
/* 556 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 558 */	NdrFcShort( 0x0 ),	/* 0 */
/* 560 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 562 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 564 */	NdrFcShort( 0x4 ),	/* 4 */
/* 566 */	NdrFcShort( 0x0 ),	/* 0 */
/* 568 */	NdrFcShort( 0x1 ),	/* 1 */
/* 570 */	NdrFcShort( 0x0 ),	/* 0 */
/* 572 */	NdrFcShort( 0x0 ),	/* 0 */
/* 574 */	0x12, 0x0,	/* FC_UP */
/* 576 */	NdrFcShort( 0x17e ),	/* Offset= 382 (958) */
/* 578 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 580 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 582 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 584 */	NdrFcShort( 0x8 ),	/* 8 */
/* 586 */	NdrFcShort( 0x0 ),	/* 0 */
/* 588 */	NdrFcShort( 0x6 ),	/* Offset= 6 (594) */
/* 590 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 592 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 594 */	
			0x11, 0x0,	/* FC_RP */
/* 596 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (552) */
/* 598 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 600 */	NdrFcLong( 0x2f ),	/* 47 */
/* 604 */	NdrFcShort( 0x0 ),	/* 0 */
/* 606 */	NdrFcShort( 0x0 ),	/* 0 */
/* 608 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 610 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 612 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 614 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 616 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 618 */	NdrFcShort( 0x1 ),	/* 1 */
/* 620 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 622 */	NdrFcShort( 0x4 ),	/* 4 */
/* 624 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 626 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 628 */	NdrFcShort( 0x10 ),	/* 16 */
/* 630 */	NdrFcShort( 0x0 ),	/* 0 */
/* 632 */	NdrFcShort( 0xa ),	/* Offset= 10 (642) */
/* 634 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 636 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 638 */	NdrFcShort( 0xffffffd8 ),	/* Offset= -40 (598) */
/* 640 */	0x36,		/* FC_POINTER */
			0x5b,		/* FC_END */
/* 642 */	
			0x12, 0x0,	/* FC_UP */
/* 644 */	NdrFcShort( 0xffffffe4 ),	/* Offset= -28 (616) */
/* 646 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 648 */	NdrFcShort( 0x4 ),	/* 4 */
/* 650 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 652 */	NdrFcShort( 0x0 ),	/* 0 */
/* 654 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 656 */	
			0x48,		/* FC_VARIABLE_REPEAT */
			0x49,		/* FC_FIXED_OFFSET */
/* 658 */	NdrFcShort( 0x4 ),	/* 4 */
/* 660 */	NdrFcShort( 0x0 ),	/* 0 */
/* 662 */	NdrFcShort( 0x1 ),	/* 1 */
/* 664 */	NdrFcShort( 0x0 ),	/* 0 */
/* 666 */	NdrFcShort( 0x0 ),	/* 0 */
/* 668 */	0x12, 0x0,	/* FC_UP */
/* 670 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (626) */
/* 672 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 674 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 676 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 678 */	NdrFcShort( 0x8 ),	/* 8 */
/* 680 */	NdrFcShort( 0x0 ),	/* 0 */
/* 682 */	NdrFcShort( 0x6 ),	/* Offset= 6 (688) */
/* 684 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 686 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 688 */	
			0x11, 0x0,	/* FC_RP */
/* 690 */	NdrFcShort( 0xffffffd4 ),	/* Offset= -44 (646) */
/* 692 */	
			0x1d,		/* FC_SMFARRAY */
			0x0,		/* 0 */
/* 694 */	NdrFcShort( 0x8 ),	/* 8 */
/* 696 */	0x2,		/* FC_CHAR */
			0x5b,		/* FC_END */
/* 698 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 700 */	NdrFcShort( 0x10 ),	/* 16 */
/* 702 */	0x8,		/* FC_LONG */
			0x6,		/* FC_SHORT */
/* 704 */	0x6,		/* FC_SHORT */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 706 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffff1 ),	/* Offset= -15 (692) */
			0x5b,		/* FC_END */
/* 710 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 712 */	NdrFcShort( 0x18 ),	/* 24 */
/* 714 */	NdrFcShort( 0x0 ),	/* 0 */
/* 716 */	NdrFcShort( 0xa ),	/* Offset= 10 (726) */
/* 718 */	0x8,		/* FC_LONG */
			0x36,		/* FC_POINTER */
/* 720 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 722 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (698) */
/* 724 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 726 */	
			0x11, 0x0,	/* FC_RP */
/* 728 */	NdrFcShort( 0xffffff0c ),	/* Offset= -244 (484) */
/* 730 */	
			0x1b,		/* FC_CARRAY */
			0x0,		/* 0 */
/* 732 */	NdrFcShort( 0x1 ),	/* 1 */
/* 734 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 736 */	NdrFcShort( 0x0 ),	/* 0 */
/* 738 */	0x1,		/* FC_BYTE */
			0x5b,		/* FC_END */
/* 740 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 742 */	NdrFcShort( 0x8 ),	/* 8 */
/* 744 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 746 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 748 */	NdrFcShort( 0x4 ),	/* 4 */
/* 750 */	NdrFcShort( 0x4 ),	/* 4 */
/* 752 */	0x12, 0x0,	/* FC_UP */
/* 754 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (730) */
/* 756 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 758 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 760 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 762 */	NdrFcShort( 0x2 ),	/* 2 */
/* 764 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 766 */	NdrFcShort( 0x0 ),	/* 0 */
/* 768 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 770 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 772 */	NdrFcShort( 0x8 ),	/* 8 */
/* 774 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 776 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 778 */	NdrFcShort( 0x4 ),	/* 4 */
/* 780 */	NdrFcShort( 0x4 ),	/* 4 */
/* 782 */	0x12, 0x0,	/* FC_UP */
/* 784 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (760) */
/* 786 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 788 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 790 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 792 */	NdrFcShort( 0x4 ),	/* 4 */
/* 794 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 796 */	NdrFcShort( 0x0 ),	/* 0 */
/* 798 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 800 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 802 */	NdrFcShort( 0x8 ),	/* 8 */
/* 804 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 806 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 808 */	NdrFcShort( 0x4 ),	/* 4 */
/* 810 */	NdrFcShort( 0x4 ),	/* 4 */
/* 812 */	0x12, 0x0,	/* FC_UP */
/* 814 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (790) */
/* 816 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 818 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 820 */	
			0x1b,		/* FC_CARRAY */
			0x7,		/* 7 */
/* 822 */	NdrFcShort( 0x8 ),	/* 8 */
/* 824 */	0x19,		/* Corr desc:  field pointer, FC_ULONG */
			0x0,		/*  */
/* 826 */	NdrFcShort( 0x0 ),	/* 0 */
/* 828 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 830 */	
			0x16,		/* FC_PSTRUCT */
			0x3,		/* 3 */
/* 832 */	NdrFcShort( 0x8 ),	/* 8 */
/* 834 */	
			0x4b,		/* FC_PP */
			0x5c,		/* FC_PAD */
/* 836 */	
			0x46,		/* FC_NO_REPEAT */
			0x5c,		/* FC_PAD */
/* 838 */	NdrFcShort( 0x4 ),	/* 4 */
/* 840 */	NdrFcShort( 0x4 ),	/* 4 */
/* 842 */	0x12, 0x0,	/* FC_UP */
/* 844 */	NdrFcShort( 0xffffffe8 ),	/* Offset= -24 (820) */
/* 846 */	
			0x5b,		/* FC_END */

			0x8,		/* FC_LONG */
/* 848 */	0x8,		/* FC_LONG */
			0x5b,		/* FC_END */
/* 850 */	
			0x15,		/* FC_STRUCT */
			0x3,		/* 3 */
/* 852 */	NdrFcShort( 0x8 ),	/* 8 */
/* 854 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 856 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 858 */	
			0x1b,		/* FC_CARRAY */
			0x3,		/* 3 */
/* 860 */	NdrFcShort( 0x8 ),	/* 8 */
/* 862 */	0x7,		/* Corr desc: FC_USHORT */
			0x0,		/*  */
/* 864 */	NdrFcShort( 0xffd8 ),	/* -40 */
/* 866 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 868 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (850) */
/* 870 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 872 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x3,		/* 3 */
/* 874 */	NdrFcShort( 0x28 ),	/* 40 */
/* 876 */	NdrFcShort( 0xffffffee ),	/* Offset= -18 (858) */
/* 878 */	NdrFcShort( 0x0 ),	/* Offset= 0 (878) */
/* 880 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 882 */	0x38,		/* FC_ALIGNM4 */
			0x8,		/* FC_LONG */
/* 884 */	0x8,		/* FC_LONG */
			0x4c,		/* FC_EMBEDDED_COMPLEX */
/* 886 */	0x0,		/* 0 */
			NdrFcShort( 0xfffffdf7 ),	/* Offset= -521 (366) */
			0x5b,		/* FC_END */
/* 890 */	
			0x12, 0x0,	/* FC_UP */
/* 892 */	NdrFcShort( 0xfffffef6 ),	/* Offset= -266 (626) */
/* 894 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 896 */	0x2,		/* FC_CHAR */
			0x5c,		/* FC_PAD */
/* 898 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 900 */	0x6,		/* FC_SHORT */
			0x5c,		/* FC_PAD */
/* 902 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 904 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/* 906 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 908 */	0xa,		/* FC_FLOAT */
			0x5c,		/* FC_PAD */
/* 910 */	
			0x12, 0x8,	/* FC_UP [simple_pointer] */
/* 912 */	0xc,		/* FC_DOUBLE */
			0x5c,		/* FC_PAD */
/* 914 */	
			0x12, 0x0,	/* FC_UP */
/* 916 */	NdrFcShort( 0xfffffdac ),	/* Offset= -596 (320) */
/* 918 */	
			0x12, 0x10,	/* FC_UP */
/* 920 */	NdrFcShort( 0xfffffc6e ),	/* Offset= -914 (6) */
/* 922 */	
			0x12, 0x10,	/* FC_UP */
/* 924 */	NdrFcShort( 0xfffffdaa ),	/* Offset= -598 (326) */
/* 926 */	
			0x12, 0x10,	/* FC_UP */
/* 928 */	NdrFcShort( 0xfffffdb8 ),	/* Offset= -584 (344) */
/* 930 */	
			0x12, 0x10,	/* FC_UP */
/* 932 */	NdrFcShort( 0xfffffdc6 ),	/* Offset= -570 (362) */
/* 934 */	
			0x12, 0x10,	/* FC_UP */
/* 936 */	NdrFcShort( 0x2 ),	/* Offset= 2 (938) */
/* 938 */	
			0x12, 0x0,	/* FC_UP */
/* 940 */	NdrFcShort( 0xfffffc54 ),	/* Offset= -940 (0) */
/* 942 */	
			0x15,		/* FC_STRUCT */
			0x7,		/* 7 */
/* 944 */	NdrFcShort( 0x10 ),	/* 16 */
/* 946 */	0x6,		/* FC_SHORT */
			0x2,		/* FC_CHAR */
/* 948 */	0x2,		/* FC_CHAR */
			0x38,		/* FC_ALIGNM4 */
/* 950 */	0x8,		/* FC_LONG */
			0x39,		/* FC_ALIGNM8 */
/* 952 */	0xb,		/* FC_HYPER */
			0x5b,		/* FC_END */
/* 954 */	
			0x12, 0x0,	/* FC_UP */
/* 956 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (942) */
/* 958 */	
			0x1a,		/* FC_BOGUS_STRUCT */
			0x7,		/* 7 */
/* 960 */	NdrFcShort( 0x20 ),	/* 32 */
/* 962 */	NdrFcShort( 0x0 ),	/* 0 */
/* 964 */	NdrFcShort( 0x0 ),	/* Offset= 0 (964) */
/* 966 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 968 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 970 */	0x6,		/* FC_SHORT */
			0x6,		/* FC_SHORT */
/* 972 */	0x4c,		/* FC_EMBEDDED_COMPLEX */
			0x0,		/* 0 */
/* 974 */	NdrFcShort( 0xfffffc62 ),	/* Offset= -926 (48) */
/* 976 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 978 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 980 */	NdrFcShort( 0x1 ),	/* 1 */
/* 982 */	NdrFcShort( 0x10 ),	/* 16 */
/* 984 */	NdrFcShort( 0x0 ),	/* 0 */
/* 986 */	NdrFcShort( 0xfffffc52 ),	/* Offset= -942 (44) */
/* 988 */	
			0x11, 0x4,	/* FC_RP [alloced_on_stack] */
/* 990 */	NdrFcShort( 0x6 ),	/* Offset= 6 (996) */
/* 992 */	
			0x13, 0x0,	/* FC_OP */
/* 994 */	NdrFcShort( 0xffffffdc ),	/* Offset= -36 (958) */
/* 996 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 998 */	NdrFcShort( 0x1 ),	/* 1 */
/* 1000 */	NdrFcShort( 0x10 ),	/* 16 */
/* 1002 */	NdrFcShort( 0x0 ),	/* 0 */
/* 1004 */	NdrFcShort( 0xfffffff4 ),	/* Offset= -12 (992) */

			0x0
        }
    };

const CInterfaceProxyVtbl * _CERUpload_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ICerClientProxyVtbl,
    0
};

const CInterfaceStubVtbl * _CERUpload_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ICerClientStubVtbl,
    0
};

PCInterfaceName const _CERUpload_InterfaceNamesList[] = 
{
    "ICerClient",
    0
};

const IID *  _CERUpload_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define _CERUpload_CHECK_IID(n)	IID_GENERIC_CHECK_IID( _CERUpload, pIID, n)

int __stdcall _CERUpload_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!_CERUpload_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo CERUpload_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & _CERUpload_ProxyVtblList,
    (PCInterfaceStubVtblList *) & _CERUpload_StubVtblList,
    (const PCInterfaceName * ) & _CERUpload_InterfaceNamesList,
    (const IID ** ) & _CERUpload_BaseIIDList,
    & _CERUpload_IID_Lookup, 
    1,
    2,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\cerupload\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__F2AFCAB7_8B25_4762_AE71_C42A9BB8CB71__INCLUDED_)
#define AFX_STDAFX_H__F2AFCAB7_8B25_4762_AE71_C42A9BB8CB71__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__F2AFCAB7_8B25_4762_AE71_C42A9BB8CB71__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\cerupload\utilities.h ===
#ifndef _UTILITIES_H
#define _UTILITIES_H




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\ocarpt\compress.h ===
#include "stdafx.h"
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <io.h>
#include <fcntl.h>
#include <dos.h>

#include <fci.h>
/*
 * When a CAB file reaches this size, a new CAB will be created
 * automatically.  This is useful for fitting CAB files onto disks.
 *
 * If you want to create just one huge CAB file with everything in
 * it, change this to a very very large number.
 */
#define MEDIA_SIZE          0x7fffffff

/*
 * When a folder has this much compressed data inside it,
 * automatically flush the folder.
 *
 * Flushing the folder hurts compression a little bit, but
 * helps random access significantly.
 */
#define FOLDER_THRESHOLD    0x7fffffff


/*
 * Compression type to use
 */

#define COMPRESSION_TYPE    tcompTYPE_MSZIP



typedef struct
{
    long    total_compressed_size;      /* total compressed size so far */
    long    total_uncompressed_size;    /* total uncompressed size so far */
    long    start_uncompressed_size;
} client_state;


extern ULONG g_CompressedPercentage;
extern BOOL g_CancelCompression;


/*
 * Function prototypes
 */

void    store_cab_name(char *cabname, int iCab);
void    set_cab_parameters(PCCAB cab_parms);
BOOL    test_fci(int num_files, char *file_list[]);
void    strip_path(char *filename, char *stripped_name);
int     get_percentage(unsigned long a, unsigned long b);
char    *return_fci_error_string(FCIERROR err);
void    UnicodeToAnsi1(wchar_t *pszW, LPSTR ppszA);
BOOL Compress (wchar_t *CabName, wchar_t *fileName, DWORD * UploadTime);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\ocarpt\ocarpt.cpp ===
// Ocarpt.cpp : Implementation of DLL Exports.


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f Ocarptps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "Ocarpt.h"

#include "Ocarpt_i.c"
#include "OcarptMain.h"


CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_OcarptMain, COcarptMain)
END_OBJECT_MAP()

/////////////////////////////////////////////////////////////////////////////
// DLL Entry Point

extern "C"
BOOL WINAPI DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        _Module.Init(ObjectMap, hInstance, &LIBID_OCARPTLib);
        DisableThreadLibraryCalls(hInstance);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
        _Module.Term();
    return TRUE;    // ok
}

/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow(void)
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}

/////////////////////////////////////////////////////////////////////////////
// DllRegisterServer - Adds entries to the system registry

STDAPI DllRegisterServer(void)
{
    // registers object, typelib and all interfaces in typelib
    return _Module.RegisterServer(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
// DllUnregisterServer - Removes entries from the system registry

STDAPI DllUnregisterServer(void)
{
    return _Module.UnregisterServer(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\ocarpt\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\ocarpt\ocarptmain.cpp ===
// OcarptMain.cpp : Implementation of COcarptMain

//#define UNICODE
//#define _UNICODE

#include "stdafx.h"
#include "Ocarpt.h"
#include "OcarptMain.h"
#include <direct.h>
#include <stdio.h>
#include <stdlib.h>
#include <commdlg.h>
#include <Wincrypt.h>
#include <io.h>
#include "Compress.h"

#define MAX_RETRIES 5
#define MAX_RETRY_COUNT 10
#include <strsafe.h>

TCHAR * COcarptMain::_approvedDomains[] = { _T("ocatest"),
                                            _T("oca.microsoft.com"),
                                            _T("oca.microsoft.de"),
                                            _T("oca.microsoft.fr"),
                                            _T("ocadeviis"),
                                            _T("redbgitwb10"),
                                            _T("redbgitwb11"),
                                            _T("ocajapan.rte.microsoft.com")};


TCHAR g_LastResponseURL[MAX_PATH];
TCHAR g_LastUploadedFile[MAX_PATH];

EnumUploadStatus g_UploadStatus;
ULONG g_UploadFailureCode;

typedef struct _UPLOAD_CONTEXT {
    WCHAR SourceFile[MAX_PATH];
    WCHAR DestFile[MAX_PATH];
    WCHAR Language[50];
    WCHAR OptionCode[20];
    BOOL ConvertToMini;
    COcarptMain *Caller;
    POCA_UPLOADFILE pUploadFile;
} UPLOAD_CONTEXT, *PUPLOAD_CONTEXT;


/***********************************************************************************
*
* Main proc to do file upload to server. This is started in a new thread.
*
***********************************************************************************/
DWORD WINAPI
UploadThreadStart(
    LPVOID pCtxt
)
{
    PUPLOAD_CONTEXT     pParams                 = (PUPLOAD_CONTEXT) pCtxt;
    ULONG               ReturnCode              = 100;
    HINTERNET           hInet                   = NULL;
    DWORD               dwUrlLength             = 0;
    WCHAR               wszServerName[MAX_PATH];
    BOOL                bRet;
    DWORD               dwLastError;
    HANDLE              hSourceFile             = INVALID_HANDLE_VALUE;
    wchar_t             ConvSourceFile[MAX_PATH];
    BOOL                Converted               = FALSE;
    wchar_t             RemoteFileName[MAX_PATH];
    BOOL                bIsCab                  = FALSE;
    DWORD               ErrorCode               = 0;
    BOOL                UploadSuccess           = FALSE;
    DWORD               NumRetries              = 0;
    DWORD               dwFileSize;
    HANDLE              hFile                   = NULL;
    HINTERNET           hRequest                = NULL;
    HINTERNET           hSession                = NULL;
    HINTERNET           hConnect                = NULL;
    DWORD               ResLength = 255;
    DWORD               index = 0;
    static const wchar_t *pszAccept[]           = {L"*.*", 0};
    DWORD               ResponseCode            = 0;
    // New Strings for temporary directory fix.
    wchar_t             TempPath[MAX_PATH];
    wchar_t             TempCabName[MAX_PATH];
    wchar_t             TempDumpName[MAX_PATH];
    wchar_t             ResponseURL[255];
    GUID                guidNewGuid;
    wchar_t             *szGuidRaw = NULL;
    BOOL                bConvertToMini = pParams->ConvertToMini;
    HRESULT             hResult = S_OK;
    BOOL                bSecure                 = TRUE;

//  ::MessageBoxW(NULL,L"UploadCalled",NULL,MB_OK);
    if ( (!pParams->SourceFile) || (!pParams->DestFile) ||
         (!pParams->Language) || (!pParams->OptionCode) ||
         (!pParams->Caller) )
    {
//      ::MessageBoxW(NULL,L"Failed Param Check",NULL,MB_OK);
        return S_OK;
    }

    if (!pParams->Caller->CreateTempDir(TempPath))
    {
        goto ExitUploadThread;
    }

    //Get a guid
    hResult = CoCreateGuid(&guidNewGuid);
    if (FAILED(hResult))
    {
        //-------------What do we send here....
        ErrorCode = GetLastError();
        ReturnCode = ErrorCode;
        goto ExitUploadThread;
    }
    else
    {
        if (UuidToStringW(&guidNewGuid, &szGuidRaw) != RPC_S_OK)
        {
            ErrorCode = GetLastError();
            ReturnCode = ErrorCode;
            goto ExitUploadThread;
        }
    }

    // build the tempfile name
    if (StringCbPrintfW(TempDumpName,sizeof TempDumpName, L"%s\\%sOCARPT.dmp",
                        TempPath,
                        szGuidRaw + 19) != S_OK)
    {
        goto ExitUploadThread;
    }

    // build the cabfile name
    if (StringCbPrintfW(TempCabName,sizeof TempCabName, L"%s\\%sOCARPT.Cab",
                        TempPath, szGuidRaw + 19) != S_OK)
    {
        goto ExitUploadThread;
    }
    // Determine if we need to convert the selected file.
    pParams->Caller->GetFileHandle(pParams->SourceFile, &hSourceFile);
    if (hSourceFile == INVALID_HANDLE_VALUE)
    {
        goto ExitUploadThread;
    }
    dwFileSize=GetFileSize(hSourceFile,NULL);
    CloseHandle(hSourceFile);
    g_UploadStatus = UploadCopyingFile;

    if (bConvertToMini)
    {
        // We need to convert this file.
        BSTR Destination, Source;

        Source = pParams->SourceFile;
        if (!pParams->Caller->ConvertFullDumpInternal(&Source,&Destination) )
        {
            ReturnCode = 3;
            goto ExitUploadThread;
        }
        else
        {
            Converted = TRUE;
            if (CopyFileW(Destination,TempDumpName,FALSE))
            {
                SetFileAttributesW(TempDumpName,FILE_ATTRIBUTE_NORMAL);
                if (StringCbCopyW(ConvSourceFile,sizeof ConvSourceFile,TempDumpName) != S_OK)
                {
                    ErrorCode = GetLastError();
                    ReturnCode = ErrorCode;
                    goto ExitUploadThread;
                }
                SysFreeString(Destination);
            }

        }
    }
    else
    {
        // ******   copy the file to cab to the temp path

        if (dwFileSize < 1000000 &&
            CopyFileW(pParams->SourceFile, TempDumpName,FALSE))
        {
            SetFileAttributesW(TempDumpName,FILE_ATTRIBUTE_NORMAL);
            // Place the location of the file into the string we use
            // for the file upload process.
            if (StringCbCopyW(ConvSourceFile,sizeof ConvSourceFile,TempDumpName)!= S_OK)
            {
                ErrorCode = GetLastError();
                ReturnCode = ErrorCode;
                goto ExitUploadThread;
            }
        } else
        {
            // We are unable to copy the file, use the file from original location
            if (StringCbCopyW(ConvSourceFile,sizeof ConvSourceFile, pParams->SourceFile)!= S_OK)
            {
                ErrorCode = GetLastError();
                ReturnCode = ErrorCode;
                goto ExitUploadThread;
            }
        }
    }
    if (dwFileSize > 10000000)
    {
//      ::MessageBoxW(NULL,L"File is too big ",NULL,MB_OK);
//      goto ExitUploadThread;
    }

    LPWSTR wszExt = wcsstr(ConvSourceFile, L".cab");

    if (wszExt == NULL || wcscmp(wszExt, L".cab"))
    {
        g_UploadStatus = UploadCompressingFile;
        if (Compress(TempCabName,ConvSourceFile,NULL))
        {
            if (StringCbCopyW(ConvSourceFile,sizeof ConvSourceFile, TempCabName) != S_OK)
            {
                ErrorCode = GetLastError();
                ReturnCode = ErrorCode;
                goto ExitUploadThread;
            }
        } else
        {
            // we failed to compress file
            ErrorCode = GetLastError();
            ReturnCode = ErrorCode;
            goto ExitUploadThread;
        }
    } else
    {
        if (!CopyFileW(ConvSourceFile, TempCabName,FALSE))
        {
            ReturnCode = ErrorCode = GetLastError();
            goto ExitUploadThread;
        }

        if (StringCbCopyW(ConvSourceFile,sizeof ConvSourceFile, TempCabName) != S_OK)
        {
            ReturnCode = ErrorCode = GetLastError();
            goto ExitUploadThread;

        }

    }
    // Now build the output file name.
    wchar_t * TempString;
    TempString = PathFindFileNameW(ConvSourceFile);
    if (StringCbPrintfW(RemoteFileName,sizeof RemoteFileName, L"/OCA/M_%s", TempString) != S_OK)
    {
        ErrorCode = GetLastError();
        ReturnCode = ErrorCode;
        goto ExitUploadThread;
    }

    if (szGuidRaw)
    {
        RpcStringFreeW(&szGuidRaw);
    }
    pParams->Caller->GetFileHandle(ConvSourceFile,&hFile);
    if (hFile == INVALID_HANDLE_VALUE)
    {
        ErrorCode = GetLastError();
        goto ExitUploadThread;
    } else
    {
        dwFileSize = GetFileSize (hFile, NULL);
        CloseHandle(hFile);
        hFile = INVALID_HANDLE_VALUE;
    }

    g_UploadStatus = UploadConnecting;
    if ((ErrorCode = pParams->pUploadFile->InitializeSession(pParams->OptionCode, (LPWSTR) ConvSourceFile)) != S_OK)
    {
        ReturnCode = ErrorCode;
        goto ExitUploadThread;
    }

    char TEMPString[MAX_PATH];
    wcstombs(TEMPString, wszServerName,MAX_PATH);

    while ((NumRetries < MAX_RETRIES) && (!UploadSuccess))
    {

        ErrorCode = 0;

        if ((ErrorCode = pParams->pUploadFile->SendFile(RemoteFileName,
                                                        bSecure)) != S_OK)
        {
            goto EndRetry;
        }
        if (ErrorCode == E_ABORT)
        {
            goto ExitUploadThread;
        }
        if (ErrorCode == ERROR_SUCCESS)
        {
            UploadSuccess = TRUE;
        }

EndRetry:

        if (!UploadSuccess)
        {
            ++NumRetries;
            bSecure = FALSE;
        }
    }
    if (UploadSuccess)
    {

        // So far so good... Now lets call the isapi.
        StringCbCopyW(wszServerName,sizeof(wszServerName),
                      pParams->pUploadFile->GetServerName());
        pParams->pUploadFile->UnInitialize();

        ResponseURL[0] = 0;
        StringCbCopyW(ResponseURL, sizeof(ResponseURL), L"Getting Server Response");
        pParams->pUploadFile->SetUploadResult(UploadGettingResponse,
                                              ResponseURL);
        if (
            pParams->Caller->GetResponseURL(
                (wchar_t *)wszServerName,
                PathFindFileNameW(RemoteFileName),
                (dwFileSize > 70000), ResponseURL) == 0)
        {
            pParams->pUploadFile->SetUploadResult(UploadSucceded,
                                                  ResponseURL);
            StringCbCopyW(g_LastResponseURL, sizeof(g_LastResponseURL), ResponseURL);

            // Cleanup and return

            // Clean up
            if (hFile!= INVALID_HANDLE_VALUE)
                CloseHandle (hFile);


            pParams->pUploadFile->UnInitialize();

            // Try to delete the cab. If for some reason we can't that ok.
            pParams->Caller->DeleteTempDir(TempPath, TempDumpName, TempCabName);

            g_UploadStatus = UploadSucceded;
            return S_OK;

        }
        else
        {

            // what here
            pParams->pUploadFile->SetUploadResult(UploadSucceded,
                                                  L"Unable to get valid response from server");
        }
    }
    else
    {
        ReturnCode = ErrorCode;
    }

ExitUploadThread:
    // Clean up
    if (hFile!= INVALID_HANDLE_VALUE)
        CloseHandle (hFile);

    pParams->pUploadFile->UnInitialize();

    pParams->Caller->DeleteTempDir(TempPath, TempDumpName, TempCabName);
    g_UploadStatus = UploadFailure;
    g_UploadFailureCode = ErrorCode;
    return S_OK;
}




/////////////////////////////////////////////////////////////////////////////
// COcarptMain

// UTILITY FUNCTIONS

BOOL COcarptMain::ValidMiniDump(LPCTSTR FileName)
{
    BOOL    ReturnValue = false;
    HANDLE  hFile                   = INVALID_HANDLE_VALUE;
    DWORD   dwBytesRead             = 0;
    char    buff[10];
    DWORD   dwSize                  = 0;


    hFile = CreateFile(FileName,
                       GENERIC_READ,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_EXISTING,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        dwSize = GetFileSize(hFile, NULL);
        if( (dwSize >= 65536)  && (dwSize < 1000000) )
        {
            ZeroMemory(buff, sizeof buff);
            if (ReadFile(hFile, buff, 10, &dwBytesRead, NULL))
            {
                if(strncmp(buff,"PAGEDUMP  ",8)==0)
                        ReturnValue = true;
            }
        }
        CloseHandle(hFile);
    }
    return ReturnValue;
}
BOOL COcarptMain::ValidMiniDump(BSTR FileName)
{
    BOOL ReturnValue = false;
    HANDLE hFile = INVALID_HANDLE_VALUE;
    DWORD  dwBytesRead = 0;
    char   buff[10];
    DWORD dwSize;

    GetFileHandle(FileName,&hFile);
    if (hFile != INVALID_HANDLE_VALUE)
    {
        dwSize = GetFileSize(hFile, NULL);
        if( ( dwSize >= 65536) && (dwSize < 1000000) )
        {
            ZeroMemory (buff, sizeof buff);
            if (ReadFile(hFile, buff, 10, &dwBytesRead, NULL))
            {
                if(strncmp(buff,"PAGEDUMP  ",8)==0)
                        ReturnValue = true;
            }
        }
        CloseHandle(hFile);
    }
    return ReturnValue;
}

/*****************************************************
Function:   CreateTempDirectory
Arguments:  [out] wchar_t *TempPath



Return Values:
    True  = Temp directory was created
    False = An error occured building the temp directory.

*/
BOOL COcarptMain::CreateTempDir(wchar_t *TempDirectory)
{

//  int         DriveNum;
    wchar_t     lpWindowsDir[MAX_PATH];
    BOOL        Status  = FALSE;
    wchar_t     TempFile[MAX_PATH * 2];
    BOOL        Done=FALSE;
    int         Retries = 0;
    wchar_t     *src;
    wchar_t     *dest;


    if (!GetWindowsDirectoryW(lpWindowsDir, MAX_PATH))
    {
        // ?
        return Status;
    }
    // now strip out the drive letter
    src  = lpWindowsDir;
    dest = TempDirectory;

    while (*src != _T('\\'))
    {
        *dest = *src;
        ++ src;
        ++ dest;
    }
    *dest = _T('\\');
    ++dest;
    *dest = _T('\0');


    // tack on the directory name we wish to create
    // in this case ocatemp.

    if (StringCbCatW(TempDirectory,MAX_PATH *2, L"OcaTemp\0") != S_OK)
    {
        goto ERRORS;
    }
    // Check to see if this directory exists.
    if (PathIsDirectoryW(TempDirectory) )
    {
        // Yes. Then use the existing path
        if (StringCbCopyW(TempFile,sizeof TempFile,TempDirectory) != S_OK)
        {
            goto ERRORS;
        }
        if (StringCbCatW(TempFile,sizeof TempFile,L"\\Mini.dmp") != S_OK)
        {
            goto ERRORS;
        }
        // First check to see if the file already exists
        if (PathFileExistsW(TempFile))
        {
            Done = FALSE;
            Retries = 0;
            // The file exists attempt to delete it.
            while (!Done)
            {
                if (DeleteFileW(TempFile))
                {
                    Done = TRUE;
                }
                else
                {
                    ++ Retries;
                    Sleep(1000);
                }
                if (Retries > 5)
                {
                    Done = TRUE;
                }
            }
            if (PathFileExistsW(TempFile))
            {
                return Status;
            }
        }

        if (StringCbCopyW(TempFile,sizeof TempFile,TempDirectory) != S_OK)
        {
            Status = FALSE;
            goto ERRORS;
        }
        if (StringCbCatW(TempFile,sizeof TempFile,L"\\Mini.cab") != S_OK)
        {
            Status = FALSE;
            goto ERRORS;
        }
        // Now check to see if the cab already exists
        if (PathFileExistsW(TempFile))
        {
            Done        =FALSE;
            Retries     = 0;
            // The file exists attempt to delete it.
            while (!Done)
            {
                if (DeleteFileW(TempFile))
                {
                    Done = TRUE;
                }
                else
                {
                    ++ Retries;
                    Sleep(1000);
                }
                if (Retries > 5)
                {
                    Done = TRUE;
                }
            }
            if (PathFileExistsW(TempFile))
            {
                return Status;
            }
        }
        Status = TRUE;
    }
    else
    {
        // No create it.
        if (! CreateDirectoryW(TempDirectory,NULL) )
        {
            return Status;
        }
        Status = TRUE;

    }
ERRORS:
    // return the path to the calling function.
    return Status;

}

/*****************************************************
Function:   DeleteTempDir
Arguments:  [in] wchar_t *TempPath -- directory to delete
            [in] wchar_t *FileName -- Dump file to delete
            [in] wchar_t *CabName  -- CabFile to delete



Return Values:
    True  = Cleanup Succeeded
    False = An error occured deleteing a file or directory

*/
BOOL COcarptMain::DeleteTempDir(wchar_t *TempDirectory,wchar_t *FileName,wchar_t *CabName)
{



    if (PathFileExistsW(FileName))
    {
        if (!DeleteFileW(FileName))
        {
            return FALSE;
        }
    }

    if (PathFileExistsW(CabName))
    {
        if (!DeleteFileW(CabName))
        {
            return FALSE;
        }
    }
    if (PathIsDirectoryW(TempDirectory))
    {

        if (!RemoveDirectoryW(TempDirectory))
        {

            return FALSE;
        }
    }
    return TRUE;
}

void COcarptMain::GetFileHandle(wchar_t *FileName, HANDLE *hFile)
{

    *hFile = CreateFileW(FileName,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);
}
BOOL COcarptMain::FindMiniDumps( BSTR *FileLists)
{
    CComBSTR FileList;
    TCHAR  strTMP[255];
    LONG lResult;
    BOOL blnResult;
    FILETIME FileTime;
    FILETIME LocalFileTime;
    //Get an instance of the ATL Registry wrapper class
    CRegKey objRegistry;
    TCHAR szPath[_MAX_PATH];
    TCHAR szValue[_MAX_PATH];
    DWORD dwLen = _MAX_PATH;

    // There is no sense attempting to locate the mini dump path since Win9x and NT4 don't generate them.
    DWORD dwVersion = GetVersion();
    DWORD dwWindowsMajorVersion =  (DWORD)(LOBYTE(LOWORD(dwVersion)));
    BOOL bWin9x = FALSE;
    BOOL bNT4   = FALSE;
    BOOL NoFiles = FALSE;
    SYSTEMTIME Systime;
    BOOL FoundFirst = FALSE;
    BOOL Status = TRUE;

    if (dwVersion < 0x80000000)
    {
        if (dwWindowsMajorVersion == 4)
                bNT4 = TRUE;
    }

    if (bNT4)
    {
        // clear the string
        *FileLists = FileList.Detach();
        return FALSE;
    }

    //Open The CrashControl section in the registry
    lResult = objRegistry.Open(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\CrashControl"));

    if (lResult == ERROR_SUCCESS)
    {

        //Get the Minidump path
        lResult = objRegistry.QueryValue(szValue, _T("MinidumpDir"), &dwLen);
        if (lResult == ERROR_SUCCESS){
            if(szValue[0] == _T('%')){

                /*  If the first character is '%' then this is an
                    environment variable which must be translated */

                //Find The Position of the Last '%'
                int i = 0;
                for(i = 1;i < (int)_tcslen(szValue); i++)
                {
                    if(szValue[i] == _T('%'))
                    {
                        break;
                    }
                }

                //Extract the environment variable for the path
                TCHAR szEnvStr[MAX_PATH];
                ZeroMemory( szEnvStr, sizeof szEnvStr);
                _tcsncpy(szEnvStr,szValue, (i+ 1));

            //  ::MessageBox(NULL, szEnvStr, "szEnvStr",MB_OK);
                //Extract the remainder of the path
                TCHAR szPathRemainder[MAX_PATH];
                ZeroMemory(szPathRemainder, sizeof szPathRemainder);
                _tcsncpy(szPathRemainder,szValue +(i + 1), (_tcslen(szValue)-(i+ 1)));

                //Join the path and filename together
                ZeroMemory(szPath,sizeof szPath);
                blnResult = ExpandEnvironmentStrings(szEnvStr,szPath,dwLen);
                if (StringCbCat(szPath,sizeof szPath,szPathRemainder) != S_OK)
                {
                    *FileLists = FileList.Detach();
                    objRegistry.Close();
                    return FALSE;
                }
            }
            else{
                if (StringCbCopy(szPath,sizeof szPath,szValue) != S_OK)
                {
                    *FileLists = FileList.Detach();
                    objRegistry.Close();
                    return FALSE;
                }
            }
        }
        else // Query Value Failed
        {
                *FileLists = FileList.Detach();
            objRegistry.Close();
            return FALSE;


        }
        objRegistry.Close();
    }
    else //Reg Open Failed
    {
        *FileLists = FileList.Detach();
        return FALSE;

    }


    /*  Next search the minidump directory and build a string with javaScript code
        This javascript code will have an eval applied to it so the browser can
        use the Array named _FileList.  The date in file list needs to be mm/dd/yyyy
        so the time_t from the finddata_t struct is converted to a tm struct by
        calling localtime on it.  The tm struct is then passed to a private function
        to extract  and concatenate the mm dd and yyyy.*/
    //::MessageBox(NULL, szPath, "Looking for Minidumps",MB_OK);
    if (PathIsDirectory(szPath))
    {

        BOOL Done = FALSE;
        HANDLE hFindFile = INVALID_HANDLE_VALUE;
        WIN32_FIND_DATA FindData;
        TCHAR  SearchPath[MAX_PATH];

        TCHAR FilePath[MAX_PATH];

        if (_tcslen(szPath) > 1)
        {
            if (szPath[_tcslen(szPath)-1] != _T('\\'))
            if (StringCbCat(szPath,sizeof szPath,_T("\\")) == S_OK)
            {
                if (StringCbCopy (SearchPath,sizeof SearchPath, szPath) == S_OK)
                {
                    if(StringCbCat(SearchPath,sizeof SearchPath, _T("*.dmp")) == S_OK)
                    {
                        Status = TRUE;
                    }
                    else
                        Status = FALSE;
                }
                else
                    Status = FALSE;
            }
            else
                Status = FALSE;
        }

        if (Status)
        {
        //  ::MessageBox(NULL, SearchPath, "Search Path",MB_OK);
            hFindFile = FindFirstFile(SearchPath, &FindData);
            /* Find first .dmp file in current directory */
            if( hFindFile == INVALID_HANDLE_VALUE )
            {

                *FileLists = FileList.Detach();
                return FALSE;

            }
            else
            {
                if (StringCbCopy(FilePath,sizeof FilePath, szPath) == S_OK)
                {
                    if (StringCbCat(FilePath, sizeof FilePath, FindData.cFileName) == S_OK)
                    {
                        if ( !(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                        {
                            //::MessageBox(NULL, FilePath, "Validating file",MB_OK);
                            if(ValidMiniDump(FilePath))
                            {

                                FileList = _T("2:");
                                FileList += FilePath;
                                FileList += _T(",");

                                //GetFileTime(FindData.cFileName, &FileTime,NULL,NULL);
                                FileTime = FindData.ftLastWriteTime;

                                FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
                                FileTimeToSystemTime(&LocalFileTime, &Systime);

                                GetDateFormat (LOCALE_USER_DEFAULT,
                                                    DATE_SHORTDATE,
                                                    &Systime,
                                                    NULL,
                                                    strTMP,
                                                    255);
                            //  FormatMiniDate(&Systime, strTMP);
                                FileList += strTMP;
                                FileList += _T(";");
                                FoundFirst = TRUE;
                            }
                        }
                        while(FindNextFile(hFindFile,&FindData))
                        {
                            if ( !(FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
                            {
                                if (StringCbCopy(FilePath,sizeof FilePath, szPath) == S_OK)
                                {
                                    if (StringCbCat(FilePath,sizeof FilePath, FindData.cFileName)== S_OK)
                                    {

                                        if(ValidMiniDump(FilePath))
                                        {
                                            if (!FoundFirst)
                                            {
                                                FileList = _T("2:");
                                                FoundFirst = TRUE;
                                            }
                                            FileList += FilePath;
                                            FileList += _T(",");

                                            FileTime = FindData.ftLastWriteTime;
                                            FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
                                            FileTimeToSystemTime(&LocalFileTime, &Systime);
                                            GetDateFormat (LOCALE_USER_DEFAULT,
                                                            DATE_SHORTDATE,
                                                            &Systime,
                                                            NULL,
                                                            strTMP,
                                                            255);
                                            FileList += strTMP;
                                            FileList += _T(";");
                                        } // end validate dump
                                    } // end string cat
                                } //end string copy
                            }// end file attributes
                        } // end while
                    }
                }
                FindClose( hFindFile );
            } // end valid file handle
        }// end if status
    } // end path is directory
    else
    {
    //  ::MessageBox(NULL, szPath, "Path not found",MB_OK);
        *FileLists = FileList.Detach();
        return FALSE;
    }

    if (!FoundFirst)
    {
        *FileLists = FileList.Detach();
        return FALSE;
    }

    *FileLists = FileList.Detach();
    return TRUE;



}



BOOL COcarptMain::FindFullDumps( BSTR *FileLists)
{
    CComBSTR FileList;
    LONG lResult;
    BOOL blnResult;

    //Get an instance of the ATL Registry wrapper class
    CRegKey objRegistry;
    TCHAR szFileName[MAX_PATH];


    ZeroMemory(szFileName,sizeof szFileName);

    DWORD dwVersion = GetVersion();
    DWORD dwWindowsMajorVersion =  (DWORD)(LOBYTE(LOWORD(dwVersion)));
    BOOL bWin9x = FALSE;
    BOOL bNT4   = FALSE;

    if (dwVersion < 0x80000000)
    {
        bWin9x = FALSE;
        if (dwWindowsMajorVersion == 4)
                bNT4 = TRUE;
    }
    else
    {
        bWin9x = TRUE;
        bNT4 = FALSE;
    }

    if (bWin9x || bNT4)
    {

        FileList = _T("");
        return FALSE;
    }
    //Open The CrashControl section in the registry
    lResult = objRegistry.Open(HKEY_LOCAL_MACHINE, _T("SYSTEM\\CurrentControlSet\\Control\\CrashControl"));

    if (lResult == ERROR_SUCCESS)
    {
        TCHAR szValue[_MAX_PATH];
        DWORD dwLen = _MAX_PATH;

        //Get the name of the full dump file
        lResult = objRegistry.QueryValue(szValue, _T("DumpFile"), &dwLen);

        if (lResult == ERROR_SUCCESS){
            /*  If the first character is '%' then this is an
                environment variable which must be translated */
            if(szValue[0] == _T('%')){

                //Find The Position of the Last '%'
                for(int i = 1;i < sizeof(szValue); i++){
                    if(szValue[i] == '%'){break;}
                }

                //Extract the environment variable for the path
                TCHAR szEnvStr[MAX_PATH];
                ZeroMemory(szEnvStr, sizeof szEnvStr);
                _tcsncpy(szEnvStr,szValue, (i+ 1));

                //Extract the remainder of the path
                TCHAR szFileNameRemainder[MAX_PATH];
                ZeroMemory(szFileNameRemainder, sizeof szFileNameRemainder);
                _tcsncpy(szFileNameRemainder,szValue +(i + 1), (_tcslen(szValue)-(i+ 1)));

                //Translate the environment variable

                blnResult = ExpandEnvironmentStrings(szEnvStr,szFileName,dwLen);

                //Join the path and filename together
                if (StringCbCat(szFileName,sizeof szFileName,szFileNameRemainder) != S_OK)
                {
                    FileList = _T("");
                    objRegistry.Close();
                    *FileLists = FileList.Detach();
                    return FALSE;
                }
            }
            else{
                if (StringCbCopy(szFileName,sizeof szFileName,szValue) != S_OK)
                {
                    FileList = _T("");
                    objRegistry.Close();
                    *FileLists = FileList.Detach();
                    return FALSE;
                }
            }

            FILETIME ftCreate, ftLastAccess, ftLastWrite;
//          SYSTEMTIME st;
            HANDLE fileHandle;

            fileHandle = CreateFile(szFileName,
                                    GENERIC_READ,
                                    FILE_SHARE_READ,
                                    NULL,
                                    OPEN_EXISTING,
                                    FILE_ATTRIBUTE_NORMAL,
                                    NULL);

            if (fileHandle == INVALID_HANDLE_VALUE)
            {
                FileList = _T("");
                objRegistry.Close();
                *FileLists = FileList.Detach();
                return FALSE;
            }
            blnResult = GetFileTime(fileHandle, &ftCreate, &ftLastAccess, &ftLastWrite);

            FileList = _T("3:");

            //Convert File time to a mm/dd/yyyy format
            FILETIME LocalFileTime;
            SYSTEMTIME SysTime;

            wchar_t LocaleTime[255];
            FileTimeToLocalFileTime(&ftCreate, &LocalFileTime);
            FileTimeToSystemTime(&LocalFileTime, &SysTime);


            GetDateFormatW (LOCALE_USER_DEFAULT,
                           DATE_SHORTDATE,
                           &SysTime,
                           NULL,
                           LocaleTime,
                           255);


            FileList += szFileName;
            FileList += _T(",");
            FileList += LocaleTime;
            FileList += _T(";");
            CloseHandle(fileHandle);



        }
        else //QueryValue failed
        {
            FileList = _T("");
            objRegistry.Close();
            *FileLists = FileList.Detach();
            return FALSE;

        }
        objRegistry.Close();
    }
    else //Key Open Failed
    {
        FileList = _T("");
        objRegistry.Close();
        *FileLists = FileList.Detach();
        return FALSE;

    }


    *FileLists = FileList.Detach();


    return TRUE;

}
void COcarptMain::FormatDate(tm *pTimeStruct, CComBSTR &strDate)
{
    strDate = L"";
    char BUFFER[5];

    if(pTimeStruct->tm_mon+1 < 10){
        _itoa((pTimeStruct->tm_mon +1),BUFFER,10);
        strDate += L"0";
        strDate += BUFFER;
    }
    else{
        _itoa((pTimeStruct->tm_mon +1),BUFFER,10);
        strDate += BUFFER;
    }

    strDate += L"/";

    if(pTimeStruct->tm_mday < 10){
        _itoa((pTimeStruct->tm_mday),BUFFER,10);
        strDate += L"0";
        strDate += BUFFER;
    }
    else{
        _itoa((pTimeStruct->tm_mday),BUFFER,10);
        strDate += BUFFER;
    }

    strDate += L"/";

    _itoa((pTimeStruct->tm_year +1900),BUFFER,10);
    strDate += BUFFER;
}

/*****************************************************8
Function:
Arguments:



Return Values:






*/
void COcarptMain::FormatDate(SYSTEMTIME *pTimeStruct, CComBSTR &strDate)
{
    strDate = L"";
    char BUFFER[5];

    //We want local time not GMT.
    SYSTEMTIME *pLocalTime = pTimeStruct;
    FILETIME    FileTime, LocalFileTime;


    SystemTimeToFileTime(pTimeStruct, &FileTime);
    FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
    FileTimeToSystemTime(&LocalFileTime, pLocalTime);

    if(pTimeStruct->wMonth < 10){
        _itoa((pLocalTime->wMonth),BUFFER,10);
        strDate += L"0";
        strDate += BUFFER;
    }
    else{
        _itoa((pLocalTime->wMonth),BUFFER,10);
        strDate += BUFFER;
    }

    strDate += L"/";

    if(pTimeStruct->wDay < 10){
        _itoa((pLocalTime->wDay),BUFFER,10);
        strDate += L"0";
        strDate += BUFFER;
    }
    else{
        _itoa((pLocalTime->wDay),BUFFER,10);
        strDate += BUFFER;
    }

    strDate += L"/";

    _itoa((pLocalTime->wYear),BUFFER,10);
    strDate += BUFFER;
}

/*****************************************************
Function:
Arguments:



Return Values:






*/
void COcarptMain::FormatMiniDate(SYSTEMTIME *pTimeStruct, CComBSTR &strDate)
{

    TCHAR Temp[255];

    //We want local time not GMT.
    SYSTEMTIME *pLocalTime = pTimeStruct;
    FILETIME    FileTime, LocalFileTime;

    SystemTimeToFileTime(pTimeStruct, &FileTime);
    FileTimeToLocalFileTime(&FileTime, &LocalFileTime);
    FileTimeToSystemTime(&LocalFileTime, pLocalTime);


    GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE, pLocalTime,NULL,Temp,255);
    strDate +=Temp;

}

/*****************************************************8
Function:
Arguments:



Return Values:






*/
BOOL COcarptMain::ConvertFullDumpInternal (BSTR *Source, BSTR *Destination)
{   int ReturnCode = 0;
    PROCESS_INFORMATION ProcessInfo;
    STARTUPINFOW        StartupInfoW;
    HANDLE  hMiniFile;
    wchar_t TempPathW[MAX_PATH];
    wchar_t Stringbuff[50];
    DWORD   dwBytesRead = 0;
    HANDLE  hFile;
    WORD *   BuildNum;
    CComBSTR Dest = L"";
    DWORD   BuildNumber = 0;
    DWORD   RetryCount = 0;
    wchar_t Windir[MAX_PATH];

    ZeroMemory(TempPathW,sizeof TempPathW);
    ZeroMemory(Windir, MAX_PATH *2);
    GetTempPathW(MAX_PATH, TempPathW);

    HANDLE hDir;
    // Validate the Temp Path
    if ( (hDir = CreateFileW(TempPathW,
                             GENERIC_READ,
                             FILE_SHARE_READ,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL|FILE_FLAG_BACKUP_SEMANTICS,
                             NULL)) == INVALID_HANDLE_VALUE)
    {
        if  (StringCbCopyW(TempPathW,sizeof TempPathW, L"\0") != S_OK)
        {
            return FALSE;
        }
        if (!GetWindowsDirectoryW(TempPathW,MAX_PATH))
        {
            //CloseHandle(hDir);
            return FALSE;
        }
    }
    PathAppendW(TempPathW, L"mini000000-00.dmp");
    GetFileHandle(TempPathW,&hMiniFile);
    if (hMiniFile == INVALID_HANDLE_VALUE)
    {
        RetryCount = 0;
        while ( (GetLastError() == ERROR_SHARING_VIOLATION) && (RetryCount < MAX_RETRY_COUNT))
        {
            ++ RetryCount;
            Sleep(1000); // Sleep for 1 second
            GetFileHandle(TempPathW,&hMiniFile);
        }
    }
    if ((GetLastError() == ERROR_SHARING_VIOLATION) && (RetryCount >= MAX_RETRY_COUNT))
    {
        if (hDir != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hDir);
        }
        return FALSE; // Well nothing we can do here return conversion failure.
    }
    if ( (hMiniFile != INVALID_HANDLE_VALUE) )      // Yes it does So we need to delete it.
    {
        CloseHandle(hMiniFile);
        DeleteFileW(TempPathW);
    }

    CComBSTR strCommand = L"";


/*  // open the full dump file and get the build number.
    // We don't need this any more
     hFile = CreateFileW(*Source,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL );

    if (hFile == INVALID_HANDLE_VALUE)
    {
        if (hDir != INVALID_HANDLE_VALUE)
        {
            CloseHandle(hDir);
            return FALSE;
        }
    }
    // Get the build number.
    if (ReadFile(hFile,Stringbuff,24,&dwBytesRead,NULL))
    {
        CloseHandle(hFile);
        BuildNum = (WORD*) (Stringbuff + 12);
        BuildNumber = _wtol ( BuildNum);
    }

    else
    {
        if (hFile != INVALID_HANDLE_VALUE)
        {
            CloseHandle (hFile);
        }
        if (hDir != INVALID_HANDLE_VALUE)
            CloseHandle (hDir);
        return FALSE;
    }
*/
    // Get the Windows Directory
    if (!GetWindowsDirectoryW(Windir, MAX_PATH))
    {
        // we can't continue
        if (hDir != INVALID_HANDLE_VALUE)
            CloseHandle (hDir);
        return FALSE;
    }

    strCommand += Windir;
    strCommand += L"\\Downloaded Program Files\\";
    strCommand += L"dumpconv.exe -i \"";
    strCommand += *Source;
    strCommand += L"\" -o ";
    strCommand += L"\"" ;
    strCommand += TempPathW;
    strCommand += "\"";

    ZeroMemory(&StartupInfoW,sizeof(STARTUPINFOW));
    StartupInfoW.cb = sizeof (STARTUPINFOW);
    ReturnCode = CreateProcessW(NULL,
                                strCommand,
                                NULL,
                                NULL,
                                FALSE,
                                CREATE_NO_WINDOW,
                                NULL,
                                NULL,
                                &StartupInfoW,
                                &ProcessInfo);

    if (ReturnCode)
    {
        CloseHandle(ProcessInfo.hThread);
        CloseHandle(ProcessInfo.hProcess);
        HANDLE hFile2 = INVALID_HANDLE_VALUE;
        Sleep(2000);
        for(short i = 0; i < 30; i++)
        {
            hFile2 = CreateFileW(TempPathW,
                                 GENERIC_READ,
                                 0,
                                 NULL,
                                 OPEN_EXISTING,
                                 FILE_ATTRIBUTE_NORMAL,
                                 NULL);

            if (hFile2 != INVALID_HANDLE_VALUE)
            {
                Dest += TempPathW;
                CloseHandle(hFile2);
                if (hDir != INVALID_HANDLE_VALUE)
                    CloseHandle(hDir);
                *Destination = Dest.Detach();
                return TRUE;
            }
            Sleep(1000);
        }
    }

    if (hDir != INVALID_HANDLE_VALUE)
        CloseHandle(hDir);
    return FALSE;
}


DWORD COcarptMain::GetResponseURL(wchar_t *HostName, wchar_t *RemoteFileName, BOOL fFullDump, wchar_t *ResponseURL)
{
    wchar_t IsapiUrl[255];
    wchar_t             ConnectString [255];
    HINTERNET           hInet                   = NULL;
    HINTERNET           hRedirUrl               = NULL;
    wchar_t*            pUploadUrl              = NULL;
    DWORD               dwUrlLength             = 0;
    URL_COMPONENTSW     urlComponents;
    BOOL                bRet;
    DWORD               dwLastError;
    HANDLE              hSourceFile             = INVALID_HANDLE_VALUE;
    wchar_t             ConvSourceFile[MAX_PATH];
    BOOL                Converted               = FALSE;
    BOOL                bIsCab                  = FALSE;
    DWORD               ErrorCode               = 0;
    BOOL                UploadSuccess           = FALSE;
    DWORD               NumRetries              = 0;
    DWORD               dwBytesRead;
    DWORD               dwBytesWritten;
    BYTE                *pBuffer;
    HANDLE              hFile;
    DWORD               ResLength = 255;
    DWORD               index = 0;
    static const wchar_t *pszAccept[]           = {L"*.*", 0};
    DWORD               ResponseCode            = 0;
    wchar_t             *temp;
    wchar_t             NewState;
    WCHAR               wszProxyServer[100], wszByPass[100];



    //wsprintfW (IsapiUrl, L"https://%s/isapi/oca_extension.dll?id=%s&Type=5",HostName, RemoteFileName);
    if (StringCbPrintfW(IsapiUrl,sizeof IsapiUrl,
                         L"/isapi/oca_extension.dll?id=%s&Type=%ld",
                        RemoteFileName,
                        (fFullDump ? 7 : 5)) != S_OK)
    {
        return 1;
    }
    //  ::MessageBoxW(NULL,L"Getting the isapi response",IsapiUrl,MB_OK);

    // Get the URL returned from the MS Corporate IIS redir.dll isapi URL redirector
    dwUrlLength = 512;
    pUploadUrl = (wchar_t*)malloc(dwUrlLength);
    if(!pUploadUrl)
    {

        //ReturnCode->intVal = GetLastError();
        ErrorCode = GetLastError();
        goto exitGetResonseURL;
    }

    ZeroMemory(pUploadUrl, dwUrlLength);

    ErrorCode = m_pUploadFile->GetUrlPageData(IsapiUrl, pUploadUrl, dwUrlLength);
    if(ErrorCode != ERROR_SUCCESS)
    {
        dwLastError = GetLastError();
        // If last error was due to insufficient buffer size, create a new one the correct size.
        if(dwLastError == ERROR_INSUFFICIENT_BUFFER)
        {
            if (pUploadUrl)
            {
                free(pUploadUrl);
                pUploadUrl = NULL;
            }
            pUploadUrl = (wchar_t*)malloc(dwUrlLength);
            if(!pUploadUrl)
            {
                ErrorCode = GetLastError();
                goto exitGetResonseURL;
            }
        }
        else
        {
            goto exitGetResonseURL;
        }

    }

    // Parse the returned url and swap the type value for the state value.
    if (StringCbCopyW(ResponseURL,MAX_PATH * 2, pUploadUrl) != S_OK)
    {
        ErrorCode = GetLastError();
        goto exitGetResonseURL;
    }
    temp = ResponseURL;
    temp += (wcslen(ResponseURL)-1);
    //::MessageBoxW(NULL,temp,L"New State Value",MB_OK);
    while (*temp != L'=')
        -- temp;
    // ok Temp + 1 is our new state value.
    NewState = *(temp+1);
//::MessageBoxW(NULL,temp,L"New State Value",MB_OK);
    //::MessageBoxW(NULL,temp,L"New State Value",MB_OK);
    // Now back up till the next =
    -- temp; // Skip the current =
    while (*temp != L'=')
        -- temp;
    //::MessageBoxW(NULL,temp,L"New State Value",MB_OK);
    if ( (*(temp - 1) == L'D') || (*(temp -1) == L'd')) // We have an ID field and have to go back further.
    {
        // first terminate the string after the Guid.
        while (*temp != '&')
            ++temp;
        *temp = L'\0';
    //  ::MessageBoxW(NULL,temp,L"New State Value",MB_OK);
        // now go back 2 = signs.
        while (*temp != L'=')
            -- temp;
        --temp;
    //  ::MessageBoxW(NULL,temp,L"New State Value",MB_OK);
        while (*temp != L'=')
            -- temp;
        *(temp+1) = NewState;
    //  ::MessageBoxW(NULL,temp,L"New State Value",MB_OK);
    }
    else
    {
        //::MessageBoxW(NULL,temp,L"New State Value else case (no id field)",MB_OK);
        *(temp+1) = NewState;
        *(temp+2) = L'\0'; // Null terminate the string after the state. (we don't wan't the type value
    }

//  ::MessageBoxW(NULL,temp,L"New State Value",MB_OK);
//  ::MessageBoxW(NULL,L"Returning URL to web page.",ResponseURL,MB_OK);
    ErrorCode = 0;
exitGetResonseURL:

    if (pUploadUrl)
        free(pUploadUrl);
    return ErrorCode;;
}

//INTERFACES

STDMETHODIMP
COcarptMain::Upload(
    BSTR *SourceFile,
    BSTR *DestFile,
    BSTR *Language,
    BSTR *OptionCode,
    int ConvertToMini,
    VARIANT *ReturnCode)
{
    HRESULT             hResult = S_OK;
    HANDLE              hThread;
    DWORD               dwThreadId;
    static UPLOAD_CONTEXT      UploadCtxt = {0};

    ReturnCode->vt = VT_INT;
    ReturnCode->intVal = 0;

//  ::MessageBoxW(NULL,L"UploadCalled",NULL,MB_OK);
    if ( (!SourceFile) || (!DestFile) || (!Language) || (!OptionCode))
    {
//      ::MessageBoxW(NULL,L"Failed Param Check",NULL,MB_OK);
        ReturnCode->intVal = 100;
    }
    if (!InApprovedDomain())
    {
        //      ::MessageBoxW(NULL,L"Failed Domain Check",NULL,MB_OK);
        return E_FAIL;
    }
    if (m_pUploadFile == NULL)
    {
        OcaUpldCreate(&m_pUploadFile);
    }
    if (m_pUploadFile == NULL)
    {
        ReturnCode->intVal = 100;
        return E_FAIL;
    }

    if (m_pUploadFile->IsUploadInProgress())
    {
        ReturnCode->intVal = 100;
        return S_OK;
    }

    g_UploadStatus = UploadStarted;

    StringCbCopyW(UploadCtxt.DestFile, sizeof(UploadCtxt.DestFile), *DestFile);
    StringCbCopyW(UploadCtxt.Language, sizeof(UploadCtxt.Language), *Language);
    StringCbCopyW(UploadCtxt.OptionCode, sizeof(UploadCtxt.OptionCode), *OptionCode);
    StringCbCopyW(UploadCtxt.SourceFile, sizeof(UploadCtxt.SourceFile), *SourceFile);
    UploadCtxt.pUploadFile = m_pUploadFile;
    UploadCtxt.Caller = this;
    UploadCtxt.ConvertToMini = ConvertToMini;


    hThread = CreateThread(NULL, 0, &UploadThreadStart, (PVOID) &UploadCtxt,
                           0, &dwThreadId);
//  hThread = NULL;
//  UploadThreadStart((LPVOID) &UploadCtxt);

    if (hThread)
    {
        WaitForSingleObject(hThread, 400);
        CloseHandle(hThread);
    } else
    {
        ReturnCode->intVal = 100;
        g_UploadStatus = UploadFailure;
    }
    return S_OK;
}




STDMETHODIMP COcarptMain::Search(VARIANT *pvFileList)
{
    CComBSTR FileList;
    FileList="";

    if (!InApprovedDomain())
    {
        return E_FAIL;
    }
    if (!FindMiniDumps(&FileList))
    {
        //::MessageBoxW(NULL, L"No MiniDumps Found", L"No mini's",MB_OK);
        FindFullDumps(&FileList);
    }
    pvFileList->vt = VT_BSTR;
    pvFileList->bstrVal = FileList.Detach();
    return S_OK;


}



STDMETHODIMP COcarptMain::Browse(BSTR *pbstrTitle, BSTR *Lang, VARIANT *Path)
{
    HWND hParent = NULL;
//  char *WindowTitle;
    CComBSTR WindowText = *pbstrTitle;
    WindowText += " - Microsoft Internet Explorer";
    // determine the language and Load the resource strings.
    wchar_t String1[200];
    wchar_t String2[200];

    static wchar_t szFilterW[400];


    if (!InApprovedDomain())
    {
        return E_FAIL;
    }

    LoadStringW(::_Module.GetModuleInstance(), IDS_STRING_ENU_DMPFILE, String1, 200);
    LoadStringW(::_Module.GetModuleInstance(), IDS_STRING_ENU_ALLFILES, String2, 200);
    // Build the buffer;

    wchar_t Pattern1[] = L"*.dmp";
    wchar_t Pattern2[] = L"*.*";
    wchar_t * src;
    wchar_t *dest;

    src = String1;
    dest = szFilterW;

    while (*src != L'\0')
    {
        *dest = *src;
        src ++;
        dest ++;
    }
    src = Pattern1;
    *dest = L'\0';
    ++dest;
    while (*src != L'\0')
    {
        *dest = *src;
        src ++;
        dest ++;
    }
    *dest = L'\0';
    ++dest;
    src = String2;
    while (*src != L'\0')
    {
        *dest = *src;
        src ++;
        dest ++;
    }
    src = Pattern2;
    *dest = L'\0';
    ++dest;
    while (*src != L'\0')
    {
        *dest = *src;
        src ++;
        dest ++;
    }
    *dest = L'\0';
    ++dest;
    *dest = L'\0';

    BOOL Return = FALSE;
    char szFileName[MAX_PATH] = "\0";
    char szDefaultPath[MAX_PATH] = "\0";

    wchar_t szFileNameW [MAX_PATH] = L"\0";
    wchar_t szDefaultPathW[MAX_PATH] = L"\0";

    BOOL bNT4   = FALSE;
    DWORD dwVersion = GetVersion();
    DWORD dwWindowsMajorVersion =  (DWORD)(LOBYTE(LOWORD(dwVersion)));
    if (dwVersion < 0x80000000)
    {
        if (dwWindowsMajorVersion == 4)
                bNT4 = TRUE;
    }


    CComBSTR RetrievedName = L"";

    hParent = FindWindowExW(NULL,NULL,L"IEFrame",WindowText);
    OPENFILENAMEW ofnw;
    if (!GetWindowsDirectoryW(szDefaultPathW,MAX_PATH))
    {
        Path->vt = VT_BSTR;
        Path->bstrVal = L"";
        return S_OK;
    }
    if (bNT4)
    {
        ofnw.lStructSize = sizeof(OPENFILENAME);
    }
    else
    {
        ofnw.lStructSize = sizeof (OPENFILENAMEW);
    }
    ofnw.lpstrFilter =  szFilterW;
    ofnw.lpstrInitialDir = szDefaultPathW;
    ofnw.lpstrFile = szFileNameW;
    ofnw.hInstance = NULL;
    ofnw.hwndOwner = hParent;
    ofnw.lCustData = NULL;
    ofnw.Flags = 0;
    //  | OFN_ALLOWMULTISELECT | OFN_EXPLORER ;        // - enable to allow multiple selection
    ofnw.lpstrDefExt = L"dmp";
    ofnw.lpstrCustomFilter = NULL;
    ofnw.nMaxFile = MAX_PATH;
    ofnw.lpstrFileTitle = NULL;
    ofnw.lpstrTitle = NULL;
    ofnw.nFileOffset = 0;
    ofnw.nFileExtension = 0;
    ofnw.lpfnHook = NULL;
    ofnw.lpTemplateName = NULL;
    if (!GetOpenFileNameW(&ofnw) )
    {
        Path->vt = VT_BSTR;
        Path->bstrVal = RetrievedName.Detach();
        return S_OK;
    }
    else
    {
        RetrievedName = ofnw.lpstrFile;

#if _WANT_MULTIPLE_DUMPS_SELECTED_
        LPWSTR szDir, szNextFile;

        szDir = ofnw.lpstrFile;

        szNextFile = wcslen(szDir) + szDir;
        ++szNextFile;
        if (*szNextFile)
        {
            RetrievedName.Append(L"\\");
            RetrievedName.Append(szNextFile);
            szNextFile = wcslen(szNextFile) + szNextFile;
            ++szNextFile;
        }
        while (*szNextFile)
        {
            RetrievedName.Append(L";");
            RetrievedName.Append(szDir);
            RetrievedName.Append(L"\\");
            RetrievedName.Append(szNextFile);
            szNextFile = wcslen(szNextFile) + szNextFile;
            ++szNextFile;
        }
#endif
        Path->vt = VT_BSTR;
        Path->bstrVal = RetrievedName.Detach();
    }
    return S_OK;;
}



STDMETHODIMP COcarptMain::ValidateDump( BSTR *FileName, VARIANT *Result)
{

    BOOL ReturnValue = false;
    HANDLE hFile;

    wchar_t TempFileName[MAX_PATH];


    if (!InApprovedDomain())
    {
        return E_FAIL;
    }
    //wcscpy(TempFileName,*FileName);
    if (StringCbPrintfW(TempFileName,sizeof TempFileName, L"\"%s\"",*FileName) != S_OK)
    {
        return E_FAIL;
    }

    GetFileHandle(TempFileName, &hFile);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        Result->vt = VT_INT;
        Result->intVal = 1;
        return S_OK;
    }

    DWORD dwSize;
    dwSize = GetFileSize(hFile, NULL);
    DWORD  dwBytesRead;
    BYTE   buff[40];
    WORD   *BuildNum;

    if ( dwSize < 65536 )
    {
        CloseHandle(hFile);
        Result->vt = VT_INT;
        Result->intVal = 1;
        return S_OK;
    }

    if( (dwSize >= 65536) && (dwSize <= 500000) )
    {
        ZeroMemory(buff,sizeof buff);
        if (ReadFile(hFile, buff, 24, &dwBytesRead, NULL))
        {
            if (strncmp ((const char *)buff,"PAGEDU64  ",8)== 0)
            {
                Result->vt = VT_INT;
                Result->intVal = 0;
            }
            else
            {
                if(strncmp((const char *)buff,"PAGEDUMP  ",8)==0)
                {

                    Result->vt = VT_INT;
                    Result->intVal = 0;
                }
                else
                {
                    Result->vt = VT_INT;
                    Result->intVal = 1;
                }
            }
            CloseHandle(hFile);
        }
        else
        {
            CloseHandle(hFile);
            Result->vt = VT_INT;
            Result->intVal = 1;
        }
    }
    else
    {
        ZeroMemory(buff,sizeof buff);
        if (ReadFile(hFile, buff, 24, &dwBytesRead, NULL))
        {
            CloseHandle(hFile);
            if (strncmp ((const char *)buff,"PAGEDU64  ",8)== 0)
            {
                Result->vt = VT_INT;
                Result->intVal = 0;
            }
            else
            {
                if(strncmp((const char *)buff,"PAGEDUMP  ",8)!=0)
                {
                    Result->vt = VT_INT;
                    Result->intVal = 1;
                }

                else
                {
                    BSTR Destination;
                    if(ConvertFullDumpInternal(FileName, &Destination))
                    {
                        // Validate the converted dump
                        HANDLE  hMiniDump;
                        BYTE Stringbuff[256];
                        //WORD *  BuildNum;

                        ZeroMemory(Stringbuff,30);

                        if (ValidMiniDump(Destination))
                        {
                            // add code here to get the OS Build
                            GetFileHandle(Destination, &hMiniDump);
                            if (hMiniDump != INVALID_HANDLE_VALUE)
                            {
                                if (ReadFile(hMiniDump,Stringbuff,24,&dwBytesRead,NULL))
                                {

                                    //  BuildNum = (WORD*) (Stringbuff + 12);

                                    Result->vt = VT_INT;
                                    Result->intVal = 0;
                                }
                                else
                                { // file read failed
                                    Result->vt = VT_INT;
                                    Result->intVal = 1;
                                }
                                CloseHandle(hMiniDump);
                            }
                            else
                            {
                                Result->vt = VT_INT;
                                Result->intVal = 2;
                            }
                        }
                        else
                        {
                            Result->vt = VT_INT;
                            Result->intVal = 2;
                        }
                        SysFreeString(Destination);
                    }
                    else
                    {
                        Result->vt = VT_INT;
                        Result->intVal = 2;
                    }
                }

            } // end else
        }// end if
        else
        {
            CloseHandle(hFile);
            Result->vt = VT_INT;
            Result->intVal = 1;
        }


    } // end else
    return S_OK;
}

STDMETHODIMP COcarptMain::RetrieveFileContents(BSTR *FileName, VARIANT *pvContents)
{
    CComBSTR Error = L"";
    CComBSTR HexString = L"";
    DWORD    dwBytesRead;
    wchar_t  LineBuffer [255];      // Buffer for hex portion of string
    wchar_t  AsciiBuffer [255];     // Buffer for Ascii portion of string
    BYTE*    nonhexbuffer = NULL;           // Raw file buffer.
    BYTE *   src = NULL;                    // Pointer into Raw File Buffer
    wchar_t * dest = NULL;                  // Pointer into Hex string
    wchar_t * dest2 = NULL;             // Pointer into Ascii string


    dest = LineBuffer;
    dest2 = AsciiBuffer;
    wchar_t *Temp2;                 // Used to copy Ascii string into hex string
    wchar_t HexDigit[4];            // Used to convert the character read to hex
    BYTE Temp ;                     // Pointer into the buffer read from the file
    char Temp3;                     // Used to convert the character read to a Unicode Character
    DWORD TotalCount = 0;           // Number of bytes processed from the file buffer
    DWORD BytesPerLine = 16;        // Number of hex bytes displayed per line
    DWORD ByteCount = 0;            // Number of hex bytes processed
    HANDLE hFile;
    BSTR Destination;

    wchar_t PathName[MAX_PATH];



    if (!InApprovedDomain())
    {
        return E_FAIL;
    }

    ZeroMemory(PathName,MAX_PATH);

    // Convert from a bstr to a wchar_t
    if (StringCbPrintfW(PathName,sizeof PathName,L"\"%s\"",*FileName) != S_OK)
    {
        goto ERRORS;

    }
    GetFileHandle(PathName, &hFile);
    //::MessageBoxW(NULL,PathName, L"Loading File",MB_OK);
    if (hFile == INVALID_HANDLE_VALUE)
    {
    //::MessageBoxW(NULL,PathName,L"Failed to get the File handle",NULL);
        pvContents->vt = VT_BSTR;
        pvContents->bstrVal = Error.Detach();
        return S_OK;
    }


    DWORD    FileSize = GetFileSize(hFile,NULL);    // Size of file in bytes
    if (FileSize > 1000000)
    {
        // Ok We have to convert it
        CloseHandle(hFile);

        if( !ConvertFullDumpInternal(FileName, &Destination))
        {
            pvContents->vt = VT_BSTR;
            pvContents->bstrVal = Error.Detach();
            return S_OK;
        }

        GetFileHandle(Destination, &hFile);
        if (hFile == INVALID_HANDLE_VALUE)
        {
            pvContents->vt = VT_BSTR;
            pvContents->bstrVal = Error.Detach();
            return S_OK;
        }
        FileSize = GetFileSize(hFile,NULL);
        if ( FileSize > 80000)
        {
            pvContents->vt = VT_BSTR;
            pvContents->bstrVal = Error.Detach();
            return S_OK;
        }
    }
    if ( (nonhexbuffer = (BYTE*) malloc (FileSize)) == NULL)
    {
        CloseHandle(hFile);
        pvContents->vt = VT_BSTR;
        pvContents->bstrVal = Error.Detach();
        return S_OK;
    }

    ZeroMemory(nonhexbuffer,sizeof nonhexbuffer);
    if (ReadFile(hFile, nonhexbuffer, FileSize, &dwBytesRead, NULL))
    {
        if (dwBytesRead < 10)               // make sure we got something
        {
            if (nonhexbuffer)
                free(nonhexbuffer);
            CloseHandle (hFile);
            pvContents->vt = VT_BSTR;
            pvContents->bstrVal = Error.Detach();
            return S_OK;
        }
    }
    else
    {
        if (nonhexbuffer)
            free(nonhexbuffer);
        CloseHandle (hFile);
        pvContents->vt = VT_BSTR;
        pvContents->bstrVal = Error.Detach();
        return S_OK;
    }

    // clear the buffers
    ZeroMemory(LineBuffer,255);
    ZeroMemory(AsciiBuffer,255);
    src = nonhexbuffer;
    while (TotalCount <= dwBytesRead)
    {
        while (ByteCount < BytesPerLine)
        {
            Temp =  *src;

            if (StringCbCopyW ( HexDigit,sizeof HexDigit, L"\0") != S_OK)
            {
                goto ERRORS;
            }
            _itow(Temp,HexDigit,16);

            if (Temp < 16 )
            {
                *dest = L'0';
                ++dest;
                *dest = HexDigit[0];
                ++dest;
            }
            else
            {
                *dest = HexDigit[0];
                ++dest;
                *dest = HexDigit[1];
                ++dest;
            }
            if ( (Temp< 32) || (Temp >126))
                *dest2 = L'.';
            else
            {
                Temp3 = (char) Temp;
                mbtowc (dest2,  &Temp3,1);
            }

            if (ByteCount == 7 )
            {
               *dest = L' ';
               ++dest;
            }

            ++dest2;
            ++TotalCount;
            ++ ByteCount;
            ++ src;

         }
         ByteCount = 0;

         // Add 5 spaces to the hex string
         for (int i = 0; i < 5; i++)
         {
            *dest = L' ';
            ++dest;
         }

         // Combine the strings
         Temp2 = AsciiBuffer;
         while( Temp2 != dest2)
         {
            *dest = *Temp2;
            ++dest;
            ++Temp2;

         }
         // add CR-LF combination
         *dest = L'\r';
         ++dest;

         *dest = L'\n';
         ++dest;
         // Null terminate the string
         *dest = L'\0';
         *dest = L'\0';

         // Add the complete strings to the Bstr to be returned.
         HexString += LineBuffer;

        // Clear buffers
         if (StringCbCopyW(AsciiBuffer,sizeof AsciiBuffer,L"\0") != S_OK)
         {
             // Major problem here jump to errors
             goto ERRORS;
         }
         if (StringCbCopyW(LineBuffer,sizeof LineBuffer,L"\0") != S_OK)
         {
             // same as above
             goto ERRORS;
         }
        // Reset the pointers
         dest  = LineBuffer;
         dest2 = AsciiBuffer;

    }
ERRORS:
    if (nonhexbuffer)
        free (nonhexbuffer);
    pvContents->vt = VT_BSTR;
    pvContents->bstrVal = HexString.Detach();
    return S_OK;

}

STDMETHODIMP COcarptMain::GetUploadStatus(VARIANT *PercentDone)
{
    ULONG Done = -1;

    Sleep(200);
    switch (g_UploadStatus)
    {
    case UploadNotStarted:
        Done = 0;
        break;
    case UploadStarted:
        Done = 1;
        break;
    case UploadCompressingFile:
        Done = g_CompressedPercentage;
        break;

    case UploadGettingResponse:
        Done = 0;
        break;
    case UploadCopyingFile:
    case UploadConnecting:
    case UploadTransferInProgress:
        Done = 1;
        if (m_pUploadFile != NULL)
        {
            Done = m_pUploadFile->GetPercentComplete();
        }
        break;
    case UploadSucceded:
        Done = 200;
        break;
    case UploadFailure:
        Done = 300;
        break;
    default:
        Done = 100;
    }
    PercentDone->vt = VT_INT;
    PercentDone->intVal = Done;
    return S_OK;
}

STDMETHODIMP COcarptMain::GetUploadResult(VARIANT *UploadResult)
{

    WCHAR wszUploadRes[MAX_PATH];
    CComBSTR Result = L"";


    switch (g_UploadStatus)
    {
    case UploadCompressingFile:
        Result = _T("Compressing ...");
        break;
    case UploadCopyingFile:
        Result = _T("Preparing files to report ...");
        break;

    case UploadConnecting:
    case UploadTransferInProgress:
        if (m_pUploadFile &&
            m_pUploadFile->GetUploadResult(wszUploadRes, sizeof(wszUploadRes)))
        {
            Result = wszUploadRes;
        } else
        {
            Result = _T("Transfering to server ...");
        }
        break;
    case UploadGettingResponse:
        Result = _T("Getting Response from server");
        break;
    case UploadSucceded:
        m_pUploadFile->GetUploadResult(wszUploadRes, sizeof(wszUploadRes));
        Result = wszUploadRes;
        break;
    default:
        StringCbPrintf(wszUploadRes, sizeof(wszUploadRes),
                       _T("Cannot get upload result - error %lx"),
                          g_UploadFailureCode);
        Result = wszUploadRes;
        break;
    }
    UploadResult->vt = VT_BSTR;
    UploadResult->bstrVal = Result.Detach();
    return S_OK;
}

STDMETHODIMP COcarptMain::CancelUpload(VARIANT *ReturnCode)
{
    ULONG res=0;
    if (g_UploadStatus == UploadCompressingFile)
    {
        g_CancelCompression = TRUE;
    }
    if (m_pUploadFile != NULL &&
        m_pUploadFile->IsUploadInProgress())
    {
        res = m_pUploadFile->Cancel();
    }
    ReturnCode->vt = VT_INT;
    ReturnCode->intVal = res;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\cerupload\utilities.cpp ===
// File: Utilities.cpp

#include "stdafx.h"
#include <tchar.h>
#include <wininet.h>
#include <windows.h>
#include "Utilities.h"


/*

int
UploadFile(

	)
{
	DWORD				ErrorCode		= 0;
	HINTERNET			hSession		= NULL;
	HINTERNET			hRequest		= NULL;
	HINTERNET			hConnect		= NULL;
	INTERNET_BUFFERS	BufferIn		= {0};
	DWORD				ResponseCode	= 0;
	BOOL				UploadSuccess	= FALSE;
	DWORD				NumRetries		= 0;
	HANDLE				hSourceFile		= INVALID_HANDLE_VALUE;
	BYTE				*pSourceBuffer	= NULL;
	DWORD				dwBytesRead		= 0;
	DWORD				dwBytesWritten	= 0;
	BOOL				bRet			= FALSE;
	DWORD				ResLength		= 255;
	DWORD				index			= 0;


	static const TCHAR  *pszAccept[]	= {_T("*.*"), 0};

	if (pSourceBuffer = (BYTE *) malloc (10000))
	{
		if (! pSourceBuffer)
		{
			return GetLastError();
		}
	}
	
	// Open the internet session

	while ((NumRetries < MaxRetries) && (!UploadSuccess))
	{
	
		hSession = InternetOpen(_T("OCARPT Control"),
								INTERNET_OPEN_TYPE_PRECONFIG,
                                NULL,
								NULL,
								0);
		if (!hSession)
		{
			free (pSourceBuffer);
			ErrorCode = GetLastError();
			return ErrorCode;
		}
		
		hConnect = InternetConnect(hSession, 
								   Url,
								   INTERNET_DEFAULT_HTTP_PORT,
								   NULL,
								   NULL,
								   INTERNET_SERVICE_HTTP,
								   0,
								   NULL);
		
		if (hConnect)
		{

			hRequest = HttpOpenRequest (hConnect,
										_T("PUT"),
										DestFileName,
										NULL,
										NULL,
										pszAccept,
										INTERNET_FLAG_NEED_FILE|INTERNET_FLAG_NO_CACHE_WRITE,
										0);
			if (hRequest)
			{
				hSourceFile = CreateFile( SourceFileName,
										  GENERIC_READ,
										  FILE_SHARE_READ,
										  NULL,
										  OPEN_EXISTING,
										  FILE_ATTRIBUTE_NORMAL,
										  NULL);
			
			
				if (hSourceFile != INVALID_HANDLE_VALUE)
				{
					
					// Clear the buffer
					
					BufferIn.dwStructSize = sizeof( INTERNET_BUFFERSW );
					BufferIn.Next = NULL; 
					BufferIn.lpcszHeader = NULL;
					BufferIn.dwHeadersLength = 0;
					BufferIn.dwHeadersTotal = 0;
					BufferIn.lpvBuffer = NULL;                
					BufferIn.dwBufferLength = 0;
					BufferIn.dwOffsetLow = 0;
					BufferIn.dwOffsetHigh = 0;
					BufferIn.dwBufferTotal = GetFileSize (hSourceFile, NULL);

					ZeroMemory(pSourceBuffer, 10000); // Fill buffer with data
					if(HttpSendRequestEx( hRequest, &BufferIn, NULL, HSR_INITIATE, 0))
					{
						
						do
						{
							dwBytesRead = 0;
							if(! ReadFile(hSourceFile, pSourceBuffer, 10000, &dwBytesRead, NULL) )
							{
								ErrorCode = GetLastError();
							}
							else
							{
								bRet = InternetWriteFile(hRequest, pSourceBuffer, dwBytesRead, &dwBytesWritten);
								if ( (!bRet) || (dwBytesWritten==0) )
								{
									ErrorCode = GetLastError();
								}

								
							}
						} while ((dwBytesRead == 10000) && (!ErrorCode) );

						if (!ErrorCode)
						{
							bRet = HttpEndRequest(hRequest, NULL, 0, 0);
							if (!bRet)
							{
								ErrorCode = GetLastError();
							}
							else
							{
							
				
								ResponseCode = 0;
								HttpQueryInfo(hRequest,
											  HTTP_QUERY_STATUS_CODE |HTTP_QUERY_FLAG_NUMBER ,
											  &ResponseCode,
											  &ResLength,
											  &index);
							
								if ( (ResponseCode != 200) || (ResponseCode != 201))
								{
									ErrorCode= ResponseCode;
								}
								else
								{
									ErrorCode = 0;
									UploadSuccess = TRUE;
								}

							}
						}
					}
				}
			}
		}

		if (!UploadSuccess)
		{
			++NumRetries;
		}
		if (hSourceFile != INVALID_HANDLE_VALUE)
			CloseHandle (hSourceFile);
		if (hRequest)
			InternetCloseHandle(hRequest);
		if (hConnect)
			InternetCloseHandle(hConnect);  
		if (hSession)
			InternetCloseHandle(hSession);   
	
	}
	if (pSourceBuffer)
	{
		free (pSourceBuffer);
		pSourceBuffer = NULL;
	}
	return 0;
	
}

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\ocarpt\compress.cpp ===
#include "stdafx.h"
#include "Compress.h"
char cCabName [MAX_PATH];
char CabPath[256];
ULONG g_CompressedPercentage=0;
BOOL g_CancelCompression = FALSE;

/*
 * Memory allocation function
 */
FNFCIALLOC(mem_alloc)
{
    return malloc(cb);
}


/*
 * Memory free function
 */
FNFCIFREE(mem_free)
{
    free(memory);
}


/*
 * File i/o functions
 */
FNFCIOPEN(fci_open)
{
    int result;

    result = _open(pszFile, oflag, pmode);

    if (result == -1)
        *err = errno;

    return result;
}

FNFCIREAD(fci_read)
{
    unsigned int result;

    result = (unsigned int) _read((int)hf, memory, cb);

    if (result != cb)
        *err = errno;

    return result;
}

FNFCIWRITE(fci_write)
{
    unsigned int result;

    result = (unsigned int) _write((int)hf, memory, cb);

    if (result != cb)
        *err = errno;

    return result;
}

FNFCICLOSE(fci_close)
{
    int result;

    result = _close((int)hf);

    if (result != 0)
        *err = errno;

    return result;
}

FNFCISEEK(fci_seek)
{
    long result;

    result = _lseek((int)hf, dist, seektype);

    if (result == -1)
        *err = errno;

    return result;
}

FNFCIDELETE(fci_delete)
{
    int result;

    result = remove(pszFile);

    if (result != 0)
        *err = errno;

    return result;
}


/*
 * File placed function called when a file has been committed
 * to a cabinet
 */
FNFCIFILEPLACED(file_placed)
{
    /*printf(
        "   placed file '%s' (size %d) on cabinet '%s'\n",
        pszFile,
        cbFile,
        pccab->szCab
    );

    if (fContinuation)
        printf("      (Above file is a later segment of a continued file)\n");
    */
    return 0;
}


/*
 * Function to obtain temporary files
 */
FNFCIGETTEMPFILE(get_temp_file)
{
    char    *psz;

    psz = _tempnam("","xx");            // Get a name
    if ((psz != NULL) && (strlen(psz) < (unsigned)cbTempName)) {
        strcpy(pszTempName,psz);        // Copy to caller's buffer
        free(psz);                      // Free temporary name buffer
        return TRUE;                    // Success
    }
    //** Failed
    if (psz) {
        free(psz);
    }

    return FALSE;
}


/*
 * Progress function
 */
FNFCISTATUS(progress)
{
    client_state    *cs;

    cs = (client_state *) pv;

    if (typeStatus == statusFile)
    {
        cs->total_compressed_size += cb1;
        cs->total_uncompressed_size += cb2;

        /*
         * Compressing a block into a folder
         *
         * cb2 = uncompressed size of block
         */
    /*  printf(
            "Compressing: %9ld -> %9ld             \r",
            cs->total_uncompressed_size,
            cs->total_compressed_size
        );
        fflush(stdout);
    */
        g_CompressedPercentage
             = get_percentage(cs->total_uncompressed_size,cs->start_uncompressed_size);


    }
    else if (typeStatus == statusFolder)
    {
        int percentage;

        /*
         * Adding a folder to a cabinet
         *
         * cb1 = amount of folder copied to cabinet so far
         * cb2 = total size of folder
         */
        percentage = get_percentage(cb1, cb2);

        cs->start_uncompressed_size = cb2;
    //  printf("Copying folder to cabinet: %d%%      \r", percentage);
        fflush(stdout);
    }

    if (g_CancelCompression)
    {
        // Abort the compression
        return -1;
    }
    return 0;
}


void store_cab_name(char *cabname, int iCab)
{
    sprintf(cabname, cCabName, iCab);
}


FNFCIGETNEXTCABINET(get_next_cabinet)
{
    /*
     * Cabinet counter has been incremented already by FCI
     */

    /*
     * Store next cabinet name
     */
    store_cab_name(pccab->szCab, pccab->iCab);

    /*
     * You could change the disk name here too, if you wanted
     */

    return TRUE;
}


FNFCIGETOPENINFO(get_open_info)
{
    BY_HANDLE_FILE_INFORMATION  finfo;
    FILETIME                    filetime;
    HANDLE                      handle;
    DWORD                       attrs;
    int                         hf;
    client_state                *cs;

    cs = (client_state *) pv;

    /*
     * Need a Win32 type handle to get file date/time
     * using the Win32 APIs, even though the handle we
     * will be returning is of the type compatible with
     * _open
     */
    handle = CreateFileA(
        pszName,
        GENERIC_READ,
        FILE_SHARE_READ,
        NULL,
        OPEN_EXISTING,
        FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
        NULL
    );

    if (handle == INVALID_HANDLE_VALUE)
    {
        return -1;
    }

    if (GetFileInformationByHandle(handle, &finfo) == FALSE)
    {
        CloseHandle(handle);
        return -1;
    }
    cs->start_uncompressed_size = finfo.nFileSizeLow;

    FileTimeToLocalFileTime(
        &finfo.ftLastWriteTime,
        &filetime
    );

    FileTimeToDosDateTime(
        &filetime,
        pdate,
        ptime
    );

    attrs = GetFileAttributesA(pszName);

    if (attrs == 0xFFFFFFFF)
    {
        /* failure */
        *pattribs = 0;
    }
    else
    {
        /*
         * Mask out all other bits except these four, since other
         * bits are used by the cabinet format to indicate a
         * special meaning.
         */
        *pattribs = (int) (attrs & (_A_RDONLY | _A_SYSTEM | _A_HIDDEN | _A_ARCH));
    }

    CloseHandle(handle);


    /*
     * Return handle using _open
     */
    hf = _open( pszName, _O_RDONLY | _O_BINARY );

    if (hf == -1)
        return -1; // abort on error

    return hf;
}


void set_cab_parameters(PCCAB cab_parms)
{
    memset(cab_parms, 0, sizeof(CCAB));

    cab_parms->cb = MEDIA_SIZE;
    cab_parms->cbFolderThresh = FOLDER_THRESHOLD;

    /*
     * Don't reserve space for any extensions
     */
    cab_parms->cbReserveCFHeader = 0;
    cab_parms->cbReserveCFFolder = 0;
    cab_parms->cbReserveCFData   = 0;

    /*
     * We use this to create the cabinet name
     */
    cab_parms->iCab = 1;

    /*
     * If you want to use disk names, use this to
     * count disks
     */
    cab_parms->iDisk = 0;

    /*
     * Choose your own number
     */
    cab_parms->setID = 12345;

    /*
     * Only important if CABs are spanning multiple
     * disks, in which case you will want to use a
     * real disk name.
     *
     * Can be left as an empty string.
     */
    strcpy(cab_parms->szDisk, "");

    /* where to store the created CAB files */
    strcpy(cab_parms->szCabPath, CabPath);

    /* store name of first CAB file */
    store_cab_name(cab_parms->szCab, cab_parms->iCab);
}


BOOL Compress (wchar_t *CabName, wchar_t *fileName, DWORD *UploadTime)
{
    HFCI            hfci;
    ERF             erf;
    CCAB            cab_parameters;
    int             i;
    client_state    cs;
    char FileName [MAX_PATH];

    int num_files = 1;

    g_CompressedPercentage = 0;
    g_CancelCompression = FALSE;
    UnicodeToAnsi1(fileName,FileName);
    UnicodeToAnsi1(CabName,cCabName);
    /*
     * Initialise our internal state
     */
    cs.total_compressed_size = 0;
    cs.total_uncompressed_size = 0;
    cs.start_uncompressed_size = 0;
    set_cab_parameters(&cab_parameters);

    hfci = FCICreate(
        &erf,
        file_placed,
        mem_alloc,
        mem_free,
        fci_open,
        fci_read,
        fci_write,
        fci_close,
        fci_seek,
        fci_delete,
        get_temp_file,
        &cab_parameters,
        &cs
    );

    if (hfci == NULL)
    {
        //printf("FCICreate() failed: code %d [%s]\n",
        //  erf.erfOper, return_fci_error_string(erf.erfOper)
        //);

        return FALSE;
    }

    for (i = 0; i < num_files; i++)
    {
        char    stripped_name[256];

        /*
         * Don't store the path name in the cabinet file!
         */
        strip_path(FileName, stripped_name);

        if (FALSE == FCIAddFile(
            hfci,
            FileName,  /* file to add */
            stripped_name, /* file name in cabinet file */
            FALSE, /* file is not executable */
            get_next_cabinet,
            progress,
            get_open_info,
            COMPRESSION_TYPE))
        {
        //  printf("FCIAddFile() failed: code %d [%s]\n",
        //      erf.erfOper, return_fci_error_string(erf.erfOper)
        //  );

            (void) FCIDestroy(hfci);

            return FALSE;
        }
    }

    /*
     * This will automatically flush the folder first
     */
    if (FALSE == FCIFlushCabinet(
        hfci,
        FALSE,
        get_next_cabinet,
        progress))
    {
    //  printf("FCIFlushCabinet() failed: code %d [%s]\n",
    //      erf.erfOper, return_fci_error_string(erf.erfOper)
    //  );

        (void) FCIDestroy(hfci);

        return FALSE;
    }

    if (FCIDestroy(hfci) != TRUE)
    {
    //  printf("FCIDestroy() failed: code %d [%s]\n",
    //      erf.erfOper, return_fci_error_string(erf.erfOper)
    //  );

        return FALSE;
    }

    //printf("                                                 \r");
    // *****************  Add Upload Estimate Here ******************
    return TRUE;
}


void strip_path(char *filename, char *stripped_name)
{
    char    *p;

    p = strrchr(filename, '\\');

    if (p == NULL)
        strcpy(stripped_name, filename);
    else
        strcpy(stripped_name, p+1);
}


int get_percentage(unsigned long a, unsigned long b)
{
    while (a > 10000000)
    {
        a >>= 3;
        b >>= 3;
    }

    if (b == 0)
        return 0;

    return ((a*100)/b);
}


char *return_fci_error_string(FCIERROR err)
{
    switch (err)
    {
        case FCIERR_NONE:
            return "No error";

        case FCIERR_OPEN_SRC:
            return "Failure opening file to be stored in cabinet";

        case FCIERR_READ_SRC:
            return "Failure reading file to be stored in cabinet";

        case FCIERR_ALLOC_FAIL:
            return "Insufficient memory in FCI";

        case FCIERR_TEMP_FILE:
            return "Could not create a temporary file";

        case FCIERR_BAD_COMPR_TYPE:
            return "Unknown compression type";

        case FCIERR_CAB_FILE:
            return "Could not create cabinet file";

        case FCIERR_USER_ABORT:
            return "Client requested abort";

        case FCIERR_MCI_FAIL:
            return "Failure compressing data";

        default:
            return "Unknown error";
    }
}
void UnicodeToAnsi1(wchar_t * pszW, LPSTR ppszA)
{

    ULONG cbAnsi, cCharacters;
    DWORD dwError;

    // If input is null then just return the same.

    //    return;// NOERROR;


    cCharacters = wcslen(pszW)+1;
    // Determine number of bytes to be allocated for ANSI string. An
    // ANSI string can have at most 2 bytes per character (for Double
    // Byte Character Strings.)
    cbAnsi = cCharacters*2;

    // Use of the OLE allocator is not required because the resultant
    // ANSI  string will never be passed to another COM component. You
    // can use your own allocator.
  ///  *ppszA = (LPSTR) CoTaskMemAlloc(cbAnsi);
  //  if (NULL == *ppszA)
   //     return E_OUTOFMEMORY;

    // Convert to ANSI.
    if (0 == WideCharToMultiByte(CP_ACP, 0, pszW, cCharacters, ppszA,
                  cbAnsi, NULL, NULL))
    {
        dwError = GetLastError();
        return;// HRESULT_FROM_WIN32(dwError);
    }

    //MessageBoxW(NULL,pszW,L"String conversion function recieved",MB_OK);
//  MessageBox(NULL,*ppszA,"String Convert Function is returning.",MB_OK);
    return;// NOERROR;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\ocarpt\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by Ocarpt.rc
//
#define IDS_PROJNAME                    100
#define IDB_OCARPTMAIN                  101
#define IDS_STRING_ENU_DMPFILE          101
#define IDR_OCARPTMAIN                  102
#define IDS_STRING_ENU_ALLFILES         102
#define IDS_STRINGDMP_FILTER            103
#define IDS_STRINT_ALL_FILES_FILTER     104

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           103
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\ocarpt\ocarptmain.h ===
// OcarptMain.h : Declaration of the COcarptMain

#ifndef __OCARPTMAIN_H_
#define __OCARPTMAIN_H_

#include "resource.h"       // main symbols
#include <atlctl.h>
#include <time.h>
#include "inetupld.h"
#include <exdisp.h>
#include <shlguid.h>
#include <strsafe.h>

#define _USE_WINHTTP 1

#ifdef _USE_WINHTTP
#include <winhttp.h>
#include <winhttpi.h>

#define MAX_URL_LENGTH 2176
#else
#include <wininet.h>
#define MAX_URL_LENGTH INTERNET_MAX_URL_LENGTH
#endif // _USE_WINHTTP

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

/////////////////////////////////////////////////////////////////////////////
// COcarptMain
class ATL_NO_VTABLE COcarptMain :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IOcarptMain, &IID_IOcarptMain, &LIBID_OCARPTLib>,
    public CComControl<COcarptMain>,
    public IPersistStreamInitImpl<COcarptMain>,
    public IOleControlImpl<COcarptMain>,
    public IOleObjectImpl<COcarptMain>,
    public IOleInPlaceActiveObjectImpl<COcarptMain>,
    public IViewObjectExImpl<COcarptMain>,
    public IOleInPlaceObjectWindowlessImpl<COcarptMain>,
    public IPersistStorageImpl<COcarptMain>,
    public ISpecifyPropertyPagesImpl<COcarptMain>,
    public IQuickActivateImpl<COcarptMain>,
    public IDataObjectImpl<COcarptMain>,
    public IProvideClassInfo2Impl<&CLSID_OcarptMain, NULL, &LIBID_OCARPTLib>,
    public CComCoClass<COcarptMain, &CLSID_OcarptMain>,
    public IObjectSafetyImpl<COcarptMain, INTERFACESAFE_FOR_UNTRUSTED_CALLER
                          |INTERFACESAFE_FOR_UNTRUSTED_DATA>

{
public:
    COcarptMain()
    {
        m_pUploadFile = NULL;
        m_b_SetSiteCalled = FALSE;
    }

DECLARE_REGISTRY_RESOURCEID(IDR_OCARPTMAIN)

DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(COcarptMain)
    COM_INTERFACE_ENTRY(IOcarptMain)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IPersistStreamInit)
    COM_INTERFACE_ENTRY2(IPersist, IPersistStreamInit)
    COM_INTERFACE_ENTRY(ISpecifyPropertyPages)
    COM_INTERFACE_ENTRY(IQuickActivate)
    COM_INTERFACE_ENTRY(IPersistStorage)
    COM_INTERFACE_ENTRY(IDataObject)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IObjectSafety)
END_COM_MAP()

BEGIN_PROP_MAP(COcarptMain)
    PROP_DATA_ENTRY("_cx", m_sizeExtent.cx, VT_UI4)
    PROP_DATA_ENTRY("_cy", m_sizeExtent.cy, VT_UI4)
    // Example entries
    // PROP_ENTRY("Property Description", dispid, clsid)
    // PROP_PAGE(CLSID_StockColorPage)
END_PROP_MAP()

BEGIN_MSG_MAP(COcarptMain)
    CHAIN_MSG_MAP(CComControl<COcarptMain>)
    DEFAULT_REFLECTION_HANDLER()
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);



// IViewObjectEx
    DECLARE_VIEW_STATUS(VIEWSTATUS_SOLIDBKGND | VIEWSTATUS_OPAQUE)

// IOcarptMain
public:
    STDMETHOD(RetrieveFileContents)(/*[in]*/BSTR *FileName,  /*[out,retval]*/ VARIANT *pvContents);
    STDMETHOD(ValidateDump)(/*[in]*/ BSTR *FileName, /*[out,retval]*/VARIANT *Result);
    STDMETHOD(Browse)(/*[in]*/ BSTR *pbstrTitle, /*[in]*/BSTR *Lang, /*[out,retval]*/ VARIANT *Path);
    STDMETHOD(Search)(/*[out,retval]*/ VARIANT *pvFileList);
    STDMETHOD(Upload)(/*[in]*/ BSTR *SourceFile, /*[in]*/BSTR *DestFile, /*[in]*/BSTR *Langage, /*[in]*/ BSTR *OptionCode, /*[in]*/ int ConvertToMini, /*[out,retval]*/ VARIANT *ReturnCode);
    STDMETHOD(GetUploadStatus)(/*[out,retval]*/ VARIANT *PercentDone);
    STDMETHOD(GetUploadResult)(/*[out,retval]*/ VARIANT *UploadResult);
    STDMETHOD(CancelUpload)(/*[out,retval]*/ VARIANT *ReturnCode);

    HRESULT OnDraw(ATL_DRAWINFO& di)
    {
        RECT& rc = *(RECT*)di.prcBounds;
        Rectangle(di.hdcDraw, rc.left, rc.top, rc.right, rc.bottom);

        SetTextAlign(di.hdcDraw, TA_CENTER|TA_BASELINE);
        LPCTSTR pszText = _T("");
        TextOut(di.hdcDraw,
            (rc.left + rc.right) / 2,
            (rc.top + rc.bottom) / 2,
            pszText,
            lstrlen(pszText));

        return S_OK;
    }

    STDMETHODIMP SetClientSite (IOleClientSite *pClientSite)
    {
        _spUnkSite = pClientSite;
        m_b_SetSiteCalled = TRUE;
        return S_OK;
    }

    STDMETHODIMP GetSite (REFIID riid, LPVOID* ppvSite)
    {
        if (m_b_SetSiteCalled)
            return _spUnkSite->QueryInterface(riid,ppvSite);
        else
            return E_FAIL;
    }

    bool InApprovedDomain()
    {
        TCHAR ourUrl[MAX_URL_LENGTH];

        return true;
        if (!GetOurUrl(ourUrl, sizeof ourUrl))
                return false;
        return IsApprovedDomain(ourUrl);
    }

     bool GetOurUrl(TCHAR* pszURL, int cbBuf)
     {
        HRESULT hr;
        CComPtr<IServiceProvider> spSrvProv;
        CComPtr<IWebBrowser2> spWebBrowser;

        hr = GetSite(IID_IServiceProvider, (void**)&spSrvProv);
        if (FAILED(hr))
           return false;

        hr = spSrvProv->QueryService(SID_SWebBrowserApp,
                                     IID_IWebBrowser2,
                                     (void**)&spWebBrowser);
        if (FAILED(hr))
           return false;

        CComBSTR bstrURL;
        if (FAILED(spWebBrowser->get_LocationURL(&bstrURL)))
           return false;

    #ifdef UNICODE
        StringCbCopy(pszURL, cbBuf, bstrURL);
    #else
        WideCharToMultiByte(CP_ACP, 0, bstrURL, -1, pszURL, cbBuf,
                            NULL, NULL);
    #endif
        return true;
     }

     bool IsApprovedDomain(TCHAR* ourUrl)
     {
        // Only allow http access.
        // You can change this to allow file:// access.
        //
        if (GetScheme(ourUrl) != INTERNET_SCHEME_HTTPS)
           return false;

        TCHAR ourDomain[256];
        if (!GetDomain(ourUrl, ourDomain, sizeof(ourDomain)))
           return false;

        for (int i = 0; i < ARRAYSIZE(_approvedDomains); i++)
        {
           if (MatchDomains(const_cast<TCHAR*>(_approvedDomains[i]),
                            ourDomain))
           {
              return true;
           }
        }

        return false;
     }

     INTERNET_SCHEME GetScheme(TCHAR* url)
     {
        TCHAR buf[32];
        URL_COMPONENTS uc;
        ZeroMemory(&uc, sizeof uc);

        uc.dwStructSize = sizeof uc;
        uc.lpszScheme = buf;
        uc.dwSchemeLength = sizeof buf;

#ifdef _USE_WINHTTP
        if (WinHttpCrackUrl(url, lstrlen(url), ICU_DECODE, &uc))
#else
        if (InternetCrackUrl(url, lstrlen(url), ICU_DECODE, &uc))
#endif
           return uc.nScheme;
        else
           return INTERNET_SCHEME_UNKNOWN;
     }

     bool GetDomain(TCHAR* url, TCHAR* buf, int cbBuf)
     {
        URL_COMPONENTS uc;
        ZeroMemory(&uc, sizeof uc);

        uc.dwStructSize = sizeof uc;
        uc.lpszHostName = buf;
        uc.dwHostNameLength = cbBuf;

#ifdef _USE_WINHTTP
        return (WinHttpCrackUrl(url, lstrlen(url), ICU_DECODE, &uc)
#else
        return (InternetCrackUrl(url, lstrlen(url), ICU_DECODE, &uc)
#endif
                != FALSE);
     }

     // Return if ourDomain is within approvedDomain.
     // approvedDomain must either match ourDomain
     // or be a suffix preceded by a dot.
     //
     bool MatchDomains(TCHAR* approvedDomain, TCHAR* ourDomain)
     {
        int apDomLen  = lstrlen(approvedDomain);
        int ourDomLen = lstrlen(ourDomain);

        if (apDomLen > ourDomLen)
           return false;

        if (lstrcmpi(ourDomain+ourDomLen-apDomLen, approvedDomain)
            != 0)
           return false;

        if (apDomLen == ourDomLen)
           return true;

        if (ourDomain[ourDomLen - apDomLen - 1] == '.')
           return true;

        return false;
     }

     void GetFileHandle(wchar_t *FileName, HANDLE *hFile);
     BOOL DeleteTempDir(wchar_t *TempDirectory,wchar_t *FileName,wchar_t *CabName);
     BOOL CreateTempDir(wchar_t *TempDirectory);
     BOOL ConvertFullDumpInternal (BSTR *Source, BSTR *Destination);
     DWORD GetResponseURL(wchar_t *HostName, wchar_t *RemoteFileName, BOOL fFullDump, wchar_t *ResponseURL);

private:
         static TCHAR* _approvedDomains[8];

private:

    IOleClientSite *_spUnkSite;
    BOOL m_b_SetSiteCalled;
    POCA_UPLOADFILE m_pUploadFile;
    void FormatMiniDate(SYSTEMTIME *pTimeStruct, CComBSTR &strDate);
    void FormatDate(SYSTEMTIME *pTimeStruct, CComBSTR &strDate);
    void FormatDate(tm *pTimeStruct, CComBSTR &strDate);
    BOOL FindFullDumps( BSTR *FileLists);
    BOOL FindMiniDumps( BSTR *FileLists);
    BOOL ValidMiniDump(BSTR FileName);
    BOOL ValidMiniDump(LPCTSTR FileName);
};
#endif //__OCARPTMAIN_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\cer\cw15\cerhelp.h ===
#ifndef _CERHELP_H
#define HELP_TOPIC_TABLE_OF_CONTENTS 1

enum
{
    HELP_SUCCESS,
    HELP_NO_SUCH_PAGE,
    HELP_FAILURE
};

void
MakeHelpFileName();

ULONG
OpenHelpTopic(ULONG PageConstant);

ULONG
OpenHelpIndex(PCSTR IndexText);


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\activex\ocarpt\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__6DA42A60_9EE5_4C06_A8F8_ECDD9E5BFB93__INCLUDED_)
#define AFX_STDAFX_H__6DA42A60_9EE5_4C06_A8F8_ECDD9E5BFB93__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__6DA42A60_9EE5_4C06_A8F8_ECDD9E5BFB93__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\cer\cw15\clist.h ===
#ifndef _CLIST_H
#define _CLIST_H
#include "Main.h"



typedef struct Kernel_Policy
{
	TCHAR	Tracking[25];
	TCHAR	UrlToLaunch[MAX_PATH];
	TCHAR	SecondLevelData[10];
	TCHAR 	FileCollection[10];
	TCHAR 	BucketID[100];
	TCHAR 	Response[MAX_PATH];
	TCHAR	fDoc[10];
	TCHAR 	iData[10];
	TCHAR	GetFile [1000];
	TCHAR	MemoryDump[10];
	TCHAR   RegKey[1000];
	TCHAR   GetFileVersion [1000];
	TCHAR   WQL[MAX_PATH];
	TCHAR   CrashPerBucketCount[10];
	TCHAR   AllowResponse[10];
}KERNEL_POLICY, *PKERNEL_POLICY;

typedef struct Csv_Layout
{
	int   iSBucketID;
	TCHAR szSBucketString[MAX_PATH];
	TCHAR szSBucketResponse[MAX_PATH];
	TCHAR szGBucketResponse[MAX_PATH];
	int   icount;
	struct Csv_Layout *Prev;
	struct Csv_Layout *Next;
} CSV_LAYOUT, *PCSV_LAYOUT;

class Clist 
{
private:
	PCSV_LAYOUT m_Head;
	PCSV_LAYOUT m_CurrentPos;
	HANDLE m_hCsv;
	FILE * m_fpCsv;
	TCHAR  m_szCsvFileName[MAX_PATH];
	BOOL LoadCsvFile();
	

public:
	KERNEL_POLICY KrnlPolicy;
	TCHAR KernelStatusDir[MAX_PATH];
	BOOL bInitialized;
	BOOL GetNextEntry(  TCHAR *szSBucketID, 
						TCHAR *szSBucketString,
						TCHAR *szSResponse1, 
						TCHAR *szGResponse2,
						TCHAR *szCount, 
						BOOL  *bEOF
						);
	BOOL AddEntry(TCHAR *szSBucketID,
				  TCHAR *szSBucketString,
				  TCHAR *szSResponse1,
				  TCHAR *szGResponse2,
				  TCHAR *szCount);

	BOOL Initialize(TCHAR *szCsvFileName);
	void ResetCurrPos() { m_CurrentPos = m_Head;}
	BOOL Clist::UpdateList(TCHAR *szSBucketID, 
						TCHAR *szSBucketString,
						TCHAR *szSResponse1, 
						TCHAR *szGResponse2
						);
	void Clist::WriteCsv();
	void CleanupList();
	BOOL IsInitialized() { return bInitialized;}
	Clist() {m_Head = NULL;m_CurrentPos = NULL; bInitialized = FALSE;}
	~Clist() { CleanupList(); m_Head = NULL; m_CurrentPos = NULL; }
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\cer\cw15\cuserlist.cpp ===
#include "CUserList.h"

BOOL CUserList::AddNode(PUSER_DATA UserData )
{
	PUSER_DATA Temp;
	if (UserData)
	{
		if (m_Head == NULL)
		{
			m_Head = UserData;
			UserData->Prev = NULL;
			UserData->Next = NULL;
			m_CurrentPos = m_Head;
		}
		else
		{
			Temp = m_Head;
			while (Temp->Next != NULL ) 
				Temp = Temp->Next;
			// Insert the new node.
			Temp->Next = UserData;
			UserData->Prev = Temp;
			UserData->Next = NULL;
		}

		return TRUE;
	}
	else
		return FALSE;

}

BOOL CUserList::GetNextEntry(PUSER_DATA CurrentNode, BOOL *bEOF)
{
	if ((!m_CurrentPos) || (!CurrentNode))
	{
		*bEOF = TRUE;
		return FALSE;
	}

	memcpy(CurrentNode, m_CurrentPos, sizeof USER_DATA);
	m_CurrentPos = m_CurrentPos->Next;
	return TRUE;
}

void CUserList::CleanupList()
{
	PUSER_DATA Temp;
	Temp = m_Head;
	while (Temp != NULL)
	{
		if (Temp->Next != NULL)
		{
			Temp = Temp->Next;
			free(Temp->Prev);
			Temp->Prev = NULL;
		}
		else
		{
			free(Temp);
			Temp = NULL;
			m_Head=NULL;

		}
	}
}

PUSER_DATA CUserList::GetEntry(int iIndex)
{
	// search the linked list for the requested index.
	BOOL Done = FALSE;
	m_CurrentPos = m_Head;

	if (!m_CurrentPos)
	{
		return NULL;
	}
	while (m_CurrentPos != NULL && !Done)
	{
		if (m_CurrentPos->iIndex == iIndex)
		{
			Done = TRUE;
		}
		else
		{
			m_CurrentPos = m_CurrentPos->Next;
		}
	}

	if (Done)
	{
		return m_CurrentPos;
	}
	else
	{
		return NULL;
	}
}

BOOL CUserList::GetNextEntryNoMove(PUSER_DATA CurrentNode, BOOL *bEOF)
{
	if ((!m_CurrentPos) || (!CurrentNode))
	{
		*bEOF = TRUE;
		return FALSE;
	}

	memcpy(CurrentNode, m_CurrentPos, sizeof USER_DATA);
	return TRUE;
}

int CUserList::SetCurrentEntry(PUSER_DATA CurrentNode)
{
	if (CurrentNode && m_CurrentPos)
	{
		memcpy(m_CurrentPos, CurrentNode, sizeof USER_DATA);
	}
	return 0;
}

void CUserList::SetIndex (int iIndex)
{
	if (m_CurrentPos)
	{
		m_CurrentPos->iIndex = iIndex;
	}
}

BOOL  CUserList::MoveNext( BOOL *bEOF)
{
	if (!m_CurrentPos)
	{
		*bEOF = TRUE;
		return FALSE;
	}
	else
	{
		m_CurrentPos = m_CurrentPos->Next;
		if (!m_CurrentPos)
		{
			*bEOF = TRUE;
			return FALSE;
		}
	}
	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\cer\cw15\clist.cpp ===
#include "Clist.h"

BOOL GetNextLineFromCsv(FILE *pFile, TCHAR *szBucketId, TCHAR *szBucketString,TCHAR *szResponse1, TCHAR *szResponse2, TCHAR *szCount)
{
	TCHAR Buffer[1024];
	TCHAR *CurrPos;
	TCHAR *Dest;
	ZeroMemory(Buffer, sizeof Buffer);

	if ( !_fgetts(Buffer,1024 , pFile))
	{
		return FALSE;
	}

	// Does the buffer contain anything?
	if (!_tcscmp(Buffer, _T("\0")))
	{
	
		return FALSE;
	}

	// do we have at least 1 comma?
	if (!_tcsstr(Buffer, _T(",")))
	{
		return FALSE;
	}

	CurrPos =  Buffer;
	Dest = szBucketId;
	while ( (*CurrPos != _T(',')) && (*CurrPos != _T('\0')))
	{
		*Dest = *CurrPos;
		++Dest, ++CurrPos;
	}
	// null Terminate the string.
	*Dest = _T('\0');
	if (*CurrPos == _T('\0'))
		goto DONE;

	Dest = szBucketString;
	++ CurrPos; // Skip the ,
	while ( (*CurrPos != _T(',')) && (*CurrPos != _T('\0')))
	{
		*Dest = *CurrPos;
		++Dest, ++CurrPos;
	}
	// null Terminate the string.
	*Dest = _T('\0');
	if (*CurrPos == _T('\0'))
		goto DONE;
	Dest = szResponse1;
	++ CurrPos; // Skip the ,

	
	while ( (*CurrPos != _T(',')) && (*CurrPos != _T('\0')))
	{
		*Dest = *CurrPos;
		++Dest, ++CurrPos;
	}
	// null Terminate the string.
	*Dest = _T('\0');
	if (*CurrPos == _T('\0'))
		goto DONE;

	Dest = szResponse2;
	++ CurrPos; // Skip the ,
	
	while ( (*CurrPos != _T(',')) && (*CurrPos != _T('\0')))
	{
		*Dest = *CurrPos;
		++Dest, ++CurrPos;
	}
	// null Terminate the string.
	*Dest = _T('\0');
	if (*CurrPos == _T('\0'))
	goto DONE;
	Dest = szCount;
	++ CurrPos; // Skip the ,
	ZeroMemory(szCount,sizeof szCount);
	while ( (*CurrPos != _T(',')) && (*CurrPos != _T('\r')) && (*CurrPos != _T('\0')))
	{
		*Dest = *CurrPos;
		++Dest, ++CurrPos;
	}
	// null Terminate the string.
	*Dest = _T('\0');

DONE:
	return TRUE;


}


BOOL Clist::LoadCsvFile()
{
	TCHAR szBucketID[100];
	FILE *pFile = NULL;
	TCHAR szResponse1[255];
	TCHAR szResponse2[255];
	TCHAR szCount [100];
	TCHAR szBucketString[255];
	TCHAR *Temp;
	TCHAR szFilePath[MAX_PATH];

//	int   iElement = 0;

	// Zero out the strings
	ZeroMemory(szBucketID, sizeof szBucketID);
	ZeroMemory(szResponse1, sizeof szResponse1);
	ZeroMemory(szResponse2, sizeof szResponse2);
	ZeroMemory(szCount, sizeof szCount);
	ZeroMemory(szBucketString, sizeof szBucketString);

	if (StringCbCopy(szFilePath, sizeof szFilePath, m_szCsvFileName) != S_OK)
	{
		goto ERRORS;
	}

	Temp = szFilePath;
	Temp+= _tcslen(szFilePath);
	if (Temp != szFilePath)
	{
		while ( (*Temp != _T('\\')) && (Temp != szFilePath))
		{
			-- Temp;
		}
		if (Temp != szFilePath)
		{
			*Temp = _T('\0');
		}
		if (!PathIsDirectory(szFilePath))
		{
			CreateDirectory(szFilePath, NULL);
		}
	}
	// Open the file
	pFile = _tfopen(m_szCsvFileName, _T("r"));
	if (pFile)
	{
		// get next line
		if (GetNextLineFromCsv(pFile, szBucketID, szBucketString, szResponse1, szResponse2, szCount))
		{
			do
			{
				// Build new node
				AddEntry(szBucketID, szBucketString, szResponse1, szResponse2, szCount);
				ZeroMemory(szBucketID, sizeof szBucketID);
				ZeroMemory(szResponse1, sizeof szResponse1);
				ZeroMemory(szResponse2, sizeof szResponse2);
				ZeroMemory(szCount, sizeof szCount);
				ZeroMemory(szBucketString, sizeof szBucketString);
			}while (GetNextLineFromCsv(pFile, szBucketID, szBucketString, szResponse1, szResponse2, szCount));
			fclose(pFile);
			return TRUE;
		}
		else
		{
			fclose (pFile);
			return TRUE;
		}
	}
ERRORS:
	return FALSE;
	
}

BOOL Clist::Initialize(TCHAR *CsvFileName)
{
	if (StringCbCopy(m_szCsvFileName,sizeof m_szCsvFileName, CsvFileName) != S_OK)
	{
		bInitialized = FALSE;
		return FALSE;

	}
	else
	{
		if (!LoadCsvFile())
		{
			bInitialized = FALSE;
			return FALSE;

		}
		else
		{
			bInitialized = TRUE;
			return TRUE;
		}
	}
}

BOOL Clist::AddEntry(TCHAR *szSBucketID, 
					 TCHAR *szSBucketString,
					 TCHAR *szSResponse1, 
					 TCHAR *szGResponse2,
					 TCHAR *szCount
					 )
{
	PCSV_LAYOUT NewNode;
	PCSV_LAYOUT Temp;
	NewNode = (PCSV_LAYOUT) malloc (sizeof CSV_LAYOUT);
	if (NewNode)
	{
		if (StringCbCopy (NewNode->szSBucketString,sizeof NewNode->szSBucketString, szSBucketString) != S_OK)
		{
			goto ERRORS;
		}
		NewNode->iSBucketID = _ttoi(szSBucketID);
		NewNode->icount = _ttoi(szCount);
		if (StringCbCopy (NewNode->szSBucketResponse, sizeof NewNode->szSBucketResponse, szSResponse1) != S_OK)
		{
			goto ERRORS;
		}
		if (StringCbCopy (NewNode->szGBucketResponse, sizeof NewNode->szGBucketResponse,szGResponse2) != S_OK)
		{
			goto ERRORS;
		}
		
		if (m_Head == NULL)
		{
			m_Head = NewNode;
			NewNode->Prev = NULL;
			NewNode->Next = NULL;
		}
		else
		{
			Temp = m_Head;
			while (Temp->Next != NULL ) 
				Temp = Temp->Next;
			// Insert the new node.
			Temp->Next = NewNode;
			NewNode->Prev = Temp;
			NewNode->Next = NULL;
		}

		return TRUE;
	}
	else
	{

		return FALSE;
	}
ERRORS:
	return FALSE;
}

BOOL Clist::GetNextEntry(TCHAR *szSBucketID, 
						TCHAR *szSBucketString,
						TCHAR *szSResponse1, 
						TCHAR *szGResponse2,
						TCHAR *szCount, 
						BOOL  *bEOF
						)
{
	if (m_CurrentPos == NULL)
	{
		*bEOF = TRUE;
		return FALSE;
	}
	
	if (StringCbCopy (szSBucketString,MAX_PATH *sizeof TCHAR, m_CurrentPos->szSBucketString) != S_OK)
	{
		goto ERRORS;
	}
	if (StringCbPrintf(szSBucketID,100 * sizeof TCHAR, _T("%d"), m_CurrentPos->iSBucketID)!= S_OK)
	{
		goto ERRORS;
	}
	if (StringCbPrintf(szCount,100 * sizeof TCHAR, _T("%d"), m_CurrentPos->icount) != S_OK)
	{
		goto ERRORS;
	}
	if (StringCbCopy (szSResponse1,MAX_PATH * sizeof TCHAR, m_CurrentPos->szSBucketResponse ) != S_OK)
	{
		goto ERRORS;
	}
	if (StringCbCopy (szGResponse2,MAX_PATH * sizeof TCHAR, m_CurrentPos->szGBucketResponse ) != S_OK)
	{
		goto ERRORS;
	}
	m_CurrentPos = m_CurrentPos->Next;
	return TRUE;
ERRORS:
	return FALSE;
}

BOOL Clist::UpdateList( TCHAR *szSBucketID, 
						TCHAR *szSBucketString,
						TCHAR *szSResponse1, 
						TCHAR *szGResponse2
						)
{
	PCSV_LAYOUT NewNode;
	PCSV_LAYOUT Temp;
	BOOL Done = FALSE;
	NewNode = (PCSV_LAYOUT) malloc (sizeof CSV_LAYOUT);

	if (NewNode)
	{
		if (StringCbCopy (NewNode->szSBucketString, sizeof NewNode->szSBucketString, szSBucketString) != S_OK)
		{
			goto ERRORS;
		}
		NewNode->iSBucketID = _ttoi(szSBucketID);
		NewNode->icount = 1;
		if (StringCbCopy (NewNode->szSBucketResponse,sizeof NewNode->szSBucketResponse,  szSResponse1) != S_OK)
		{
			goto ERRORS;
		}
		if (StringCbCopy (NewNode->szGBucketResponse, sizeof NewNode->szGBucketResponse, szGResponse2) != S_OK)
		{
			goto ERRORS;
		}
		
		if (m_Head == NULL)
		{
			m_Head = NewNode;
			NewNode->Prev = NULL;
			NewNode->Next = NULL;
		}
		else
		{
			Temp = m_Head;
			
			do
			{
				if (!_tcsicmp(Temp->szSBucketString, NewNode->szSBucketString))
				{
					// We found one update the count
					Temp->icount++;
					// Now free the new node we built we no longer need it
					if (NewNode)
					{
						free (NewNode);
					}
					Done = TRUE;
				}
				else
				{
					Temp = Temp->Next;
				}

			}while ( (Temp != NULL) && (!Done));
			if (!Done)
			{
				// We hit the end of the list without finding the node.
				// Add it. Move temp to the end of the list
				Temp = m_Head;
				while (Temp->Next != NULL)
				{
					Temp = Temp->Next;
				}
				Temp->Next = NewNode;
				NewNode->Prev = Temp;
				NewNode->Next = NULL;
			}
		}
		return TRUE; // Prefix - This is not a memory leak the memory will be freed when the list
					// is deallocated in the destructor
	}
	else
	{
		return FALSE;
	}
ERRORS:
	if (NewNode)
		free(NewNode);
	return FALSE;
}

void Clist::WriteCsv()
{
	TCHAR szSBucketID[100]; 
	TCHAR szSBucketString[MAX_PATH];
	TCHAR szSResponse1[MAX_PATH]; 
	TCHAR szGResponse2[MAX_PATH];
	TCHAR szCount[100]; 
	BOOL  bEOF;
	DWORD dwBytesWritten;
	TCHAR *Buffer = NULL;
	HANDLE hCsv;
	DWORD dwBufferSize = 0;
	hCsv = CreateFile( m_szCsvFileName, GENERIC_WRITE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	if (hCsv != INVALID_HANDLE_VALUE)
	{
		dwBufferSize = 200 * sizeof TCHAR + 3* (MAX_PATH *sizeof TCHAR);
		Buffer = (TCHAR *) malloc (dwBufferSize);
		if (Buffer)
		{
			
			ResetCurrPos();

			while (GetNextEntry(szSBucketID,
								szSBucketString,
								szSResponse1, 
								szGResponse2,
								szCount, 
								&bEOF
								) )
			{
				if (StringCbPrintf(Buffer,dwBufferSize, _T("%s,%s,%s,%s,%s\r\n"),
								szSBucketID,
								szSBucketString,
								szSResponse1, 
								szGResponse2,
								szCount ) != S_OK)
				{
					;
				}
				else
					WriteFile(hCsv, Buffer, _tcslen(Buffer) *sizeof TCHAR, &dwBytesWritten, NULL);
			}

			
			if (Buffer)
			{
				free (Buffer);
			}
		}
		CloseHandle(hCsv);
	}
}

void Clist::CleanupList()
{
	PCSV_LAYOUT Temp;
	Temp = m_Head;
	while (Temp != NULL)
	{
		if (Temp->Next != NULL)
		{
			Temp = Temp->Next;
			free(Temp->Prev);
			Temp->Prev = NULL;
		}
		else
		{
			free(Temp);
			Temp = NULL;
			m_Head=NULL;

		}
	}
	bInitialized = FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\cer\cw15\cuserlist.h ===
#ifndef _CUSER_LIST_H
#define _CUSER_LIST_H
#include "Main.h"
#include "UserMode.h"


// constants
#define CWC_FIELD			64		// office still follows something close to 8.3
#define CWC_VER_FIELD		24 		// Changed to match backend database varchar(24)
#define CWC_OFFSET_FIELD	16 		// size for a 64bit HEX offset
#define CWC_OFFSET_64BIT	16 		// size for a 64bit HEX offset } used for validating size
#define CWC_OFFSET_32BIT	8		// size for a 32bit HEX offset } 
#define DWURL_MAX			1024

#define POLICYSTRSIZE		512



typedef struct Global_Policy
{
	TCHAR AllowBasic[10];
	TCHAR AllowAdvanced[10];
	TCHAR CabsPerBucket[10];
	TCHAR EnableCrashTracking[10];
	TCHAR AllowMicrosoftResponse[10];
	TCHAR CustomURL[MAX_PATH];
	TCHAR RedirectFileServer[MAX_PATH];
}GLOBAL_POLICY, *PGLOBAL_POLICY;


typedef struct UserBucket_Policy
{
	TCHAR AllowBasic[10];
	TCHAR AllowAdvanced[10];
	TCHAR CabsPerBucket[10];
	TCHAR EnableCrashTracking[10];
	TCHAR AllowMicrosoftResponse[10];
	TCHAR CustomURL[MAX_PATH];
}SELECTED_POLICY, *PSELECTED_POLICY;

typedef struct Status_Contents
{
	TCHAR	Tracking[25];
	TCHAR	UrlToLaunch[MAX_PATH];
	TCHAR	SecondLevelData[10];
	TCHAR 	FileCollection[10];
	TCHAR 	BucketID[100];
	TCHAR 	Response[MAX_PATH];
	TCHAR	fDoc[10];
	TCHAR 	iData[10];
	TCHAR	GetFile [MAX_PATH];
	TCHAR	MemoryDump[10];
	TCHAR   RegKey[1024];
	TCHAR   GetFileVersion [MAX_PATH];
	TCHAR   WQL[1024];
	TCHAR   CrashPerBucketCount[10];
	TCHAR   AllowResponse[10];
}STATUS_FILE, *PSTATUS_FILE;

typedef struct User_Data
{
	struct User_Data *Prev;
	struct User_Data *Next;
	TCHAR  AppName[MAX_PATH];
	TCHAR  AppVer[50];
	TCHAR  ModName[100];
	TCHAR  ModVer[50];
	TCHAR  CountPath[MAX_PATH];
	TCHAR  StatusPath[MAX_PATH];
	TCHAR  BucketID[100];
	TCHAR  Hits[10];
	TCHAR  Cabs[10];
	TCHAR  Offset[100];
	BOOL   Is64Bit;
	TCHAR  BucketPath[MAX_PATH]; // ?
	SELECTED_POLICY Policy;
	STATUS_FILE		Status;
	int    iIndex;
	TCHAR  CabCount[10];
	int    CollectionRequested;
	int    CollectionAllowed;
	int    iReportedCount;
	TCHAR  ReportedCountPath[MAX_PATH];
}USER_DATA, *PUSER_DATA;

class CUserList 
{
private:
	PUSER_DATA m_Head;
	PUSER_DATA m_CurrentPos;
	BOOL bInitialized;
public:
	//BOOL GetNextEntry(PUSER_DATA);
	BOOL AddNode(PUSER_DATA);

	//BOOL Initialize(TCHAR *szCsvFileName);
	void ResetCurrPos() { m_CurrentPos = m_Head;}
	void CleanupList();
	BOOL IsInitialized() { return bInitialized;}
	BOOL GetNextEntry(PUSER_DATA CurrentNode, BOOL *bEOF);
	CUserList() {m_Head = NULL;m_CurrentPos = NULL; bInitialized = FALSE;}
	~CUserList() { CleanupList(); m_Head = NULL; m_CurrentPos = NULL; }
	PUSER_DATA GetEntry(int iIndex);
	void SetIndex(int iIndex);
	BOOL MoveNext( BOOL *bEOF);
	int GetNextEntryNoMove(PUSER_DATA CurrentNode,BOOL *bEOF);
	int SetCurrentEntry(PUSER_DATA CurrentNode);
};

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\cer\cw15\kernelmode.h ===
#ifndef _KRNLMODE_H
#define _KRNLMODE_H

#define KRNL_COL_COUNT 3


typedef struct stKModeData
{
	DWORD UnprocessedCount;
	DWORD BucketArray[10];
	TCHAR ResponseArray[10][255];

} KMODE_DATA, *PKMODE_DATA;

// Prototypes

void ResizeKrlMode(HWND hwnd);

BOOL
GetResponseUrl(
    IN  TCHAR *szWebSiteName,
    IN  TCHAR *szDumpFileName,
    OUT TCHAR *szResponseUrl
    );


DWORD
UploadDumpFile(
    IN  TCHAR *szWebSiteName,
    IN  TCHAR *szDumpFileName,
	IN  TCHAR *szVirtualDir, 
    OUT TCHAR *szUploadedDumpFileName
    );

LRESULT CALLBACK
 KrnlDlgProc(
	HWND hwnd,
	UINT iMsg,
	WPARAM wParam,
	LPARAM lParam
	);


BOOL LoadCsv(HANDLE hCsv, HWND hwnd);
int  GetKernelBuckets(HWND hwnd);
BOOL ParseKrnlStatusFile();
int  CALLBACK CompareFunc(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort);
//VOID DoSubmitKernelFaults();
void RefreshKrnlView(HWND hwnd);
void DoLaunchBrowser(HWND hwnd, BOOL URL_OVERRIDE);
BOOL WriteKernelStatusFile();
void DoSubmitKernelFaults(HWND hwnd);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\cer\cw15\cerhelp.cpp ===
//----------------------------------------------------------------------------
//
// Help support.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#include "main.h"

#include <htmlhelp.h>
#include "cerhelp.h"

//#include "cmnutil.hpp"
//#include "dhhelp.h"

TCHAR g_HelpFileName[MAX_PATH];

void
MakeHelpFileName()
{
    TCHAR *Tmp = NULL;

    //
    //  Get the file name for the base module.
    //

    if (GetModuleFileName(GetModuleHandle(NULL), g_HelpFileName,
                          sizeof g_HelpFileName / sizeof g_HelpFileName[0]))
    {
        // Remove the executable name.
		
        Tmp = g_HelpFileName + _tcslen(g_HelpFileName);
		if (Tmp != g_HelpFileName)
		{
			--Tmp;
		}
		while ( (*Tmp != NULL) && (*Tmp != _T('\\')) && Tmp != g_HelpFileName)
		{
			--Tmp;
		}

    }

    if ( (Tmp == NULL) || (Tmp == g_HelpFileName))
    {
        // Error.  Use the current directory.
        Tmp = g_HelpFileName;
        *Tmp++ = _T('.');
    }

    *Tmp = 0;

	if (StringCbCat(g_HelpFileName,sizeof g_HelpFileName, _T("\\")) != S_OK)
	{
		goto ERRORS;
	}
    //CatString(g_HelpFileName, "\\", DIMA(g_HelpFileName));
    //CatString(g_HelpFileName, File, DIMA(g_HelpFileName));
	if( StringCbCat(g_HelpFileName,sizeof g_HelpFileName, _T("CerHelp.chm")) != S_OK)
	{
		goto ERRORS;
	}
ERRORS:
	;
}

/*** OpenHelpTopic   -  opens the .chm and selects the specified topic
*
*   Purpose:
*       This opens the Help File and displays the specified page.
*       (This help file's name is stored as g_HelpFileName, but
*       this string will presumably always be "debugger.chm".)
*       If the .chm has already been opened for context-sensitive
*       help, the already-existing .chm will be used.
*
*       This function should be called when you know exactly what
*       page is needed -- for instance, if a "Help" button is pressed.
*
*   Input:
*       PageConstant -- this is one of the topic constants defined
*                       in the header file generated when the .chm
*                       is built -- these constants will always
*                       be of the form "help_topic_xxxxx"
*
*   Returns:
*       0 - debugger.chm opened and page displayed correctly
*       1 - debugger.chm opened, but specified page not found
*       2 - debugger.chm not opened (probably the file wasn't found)
*
*   Exceptions:
*       None
*
*************************************************************************/

ULONG
OpenHelpTopic(ULONG PageConstant)
{
    HWND helpfileHwnd;
    HWND returnedHwnd;

    //  If we knew we were in WinDbg, we could use WinDbg's HWND,
    //  but we could be in a console debugger.

    helpfileHwnd = GetDesktopWindow();

    //  Make "Contents" the active panel in debugger.chm

    returnedHwnd =
        HtmlHelp(helpfileHwnd,
                 g_HelpFileName,
                 HH_DISPLAY_TOC,
                 0);
    if (returnedHwnd == NULL)
    {
        return HELP_FAILURE;
    }

    //  Select the proper page

 /*   returnedHwnd =
        HtmlHelp(helpfileHwnd,
                 g_HelpFileName,
                 HH_HELP_CONTEXT,
                 PageConstant);
    if (returnedHwnd == NULL)
    {
        return HELP_NO_SUCH_PAGE;
    }
    */
    return HELP_SUCCESS;
}


/*** OpenHelpIndex   -  opens the .chm and searches for the specified text
*
*   Purpose:
*       This opens the Help File and looks up the specified text in
*       the Index.  (This help file's name is stored as g_HelpFileName,
*       but this string will presumably always be "debugger.chm".)
*       If the .chm has already been opened for context-sensitive
*       help, the already-existing .chm will be used.
*
*       This function should be called when you don't know exactly
*       which page is needed -- for instance, if someone types
*       "help bp" or "help breakpoints" in the Command window.
*
*   Input:
*       IndexText  --  any text string  (even ""); this string will
*                      appear in the Index panel of the .chm
*
*   Returns:
*       0 - debugger.chm opened and index search displayed correctly
*       2 - debugger.chm not opened (probably the file wasn't found)
*
*   Exceptions:
*       None
*
*************************************************************************/

ULONG
OpenHelpIndex(PCSTR IndexText)
{
    HWND helpfileHwnd;
    HWND returnedHwnd;

    //  If we knew we were in WinDbg, we could use WinDbg's HWND,
    //  but we could be in a console debugger.

    helpfileHwnd = GetDesktopWindow();

    //  Select the Index panel and clip IndexText into it.

    returnedHwnd =
        HtmlHelp(helpfileHwnd,
                 g_HelpFileName,
                 HH_DISPLAY_INDEX,
                 (DWORD_PTR)IndexText);
    if (returnedHwnd == NULL)
    {
        return HELP_FAILURE;
    }
    
    return HELP_SUCCESS;
}

ULONG
OpenHelpSearch(PCSTR SearchText)
{
    HWND helpfileHwnd;
    HWND returnedHwnd;
    HH_FTS_QUERY Query;

    //  If we knew we were in WinDbg, we could use WinDbg's HWND,
    //  but we could be in a console debugger.

    helpfileHwnd = GetDesktopWindow();

    //  Select the Search panel.

    ZeroMemory(&Query, sizeof(Query));
    Query.cbStruct = sizeof(Query);
    Query.pszSearchQuery = SearchText;
    
    returnedHwnd =
        HtmlHelp(helpfileHwnd,
                 g_HelpFileName,
                 HH_DISPLAY_SEARCH,
                 (DWORD_PTR)&Query);
    if (returnedHwnd == NULL)
    {
        return HELP_FAILURE;
    }
    
    return HELP_SUCCESS;
}

ULONG
OpenHelpKeyword(PCSTR Keyword, BOOL ShowErrorPopup)
{
    HWND helpfileHwnd;
    HWND returnedHwnd;
    HH_AKLINK helpfileLink;

    helpfileLink.cbStruct = sizeof(helpfileLink);
    helpfileLink.fReserved = FALSE;
    helpfileLink.pszKeywords = Keyword;
    helpfileLink.pszUrl = NULL;

    //  If ShowErrorPopup is TRUE, then entering an invalid keyword will cause
    //  an error message to be displayed.  If FALSE, it will cause the .chm to
    //  display the Index tab, and the keyword will be entered into the index
    //  box, just as with OpenHelpIndex.

    if (ShowErrorPopup)
    {
        helpfileLink.pszMsgText =
            "The text you entered is not in the index of this help file.";
        helpfileLink.pszMsgTitle = "HTML Help Error";
        helpfileLink.pszWindow = NULL;
        helpfileLink.fIndexOnFail = FALSE;
    }
    else
    {
        helpfileLink.pszMsgText = NULL;
        helpfileLink.pszMsgTitle = NULL;
        helpfileLink.pszWindow = NULL;
        helpfileLink.fIndexOnFail = TRUE;
    }

    //  If we knew we were in WinDbg, we could use WinDbg's HWND,
    //  but we could be in a console debugger.

    helpfileHwnd = GetDesktopWindow();

    //  Select the Index panel and clip IndexText into it.

    returnedHwnd =
        HtmlHelp(helpfileHwnd,
                 g_HelpFileName,
                 HH_KEYWORD_LOOKUP,
                 (DWORD_PTR)&helpfileLink);
    if (returnedHwnd == NULL)
    {
        return HELP_NO_SUCH_PAGE;
    }
    
    return HELP_SUCCESS;
}

BOOL
SpawnHelp(ULONG Topic)
{
    CHAR StartHelpCommand[MAX_PATH + 32];
    PROCESS_INFORMATION ProcInfo = {0};
    STARTUPINFO SI = {0};

    // Start help with the given arguments.

    if(StringCbPrintf(StartHelpCommand, sizeof StartHelpCommand,_T("hh.exe -mapid %d "), Topic) != S_OK)
	{
		goto ERRORS;
	}
//    CatString(StartHelpCommand, g_HelpFileName, DIMA(StartHelpCommand));
    if(StringCbCat(StartHelpCommand, sizeof StartHelpCommand, g_HelpFileName) != S_OK)
	{
		goto ERRORS;
	}
    return CreateProcess(NULL,
                         StartHelpCommand,
                         NULL,
                         NULL,
                         FALSE,
                         CREATE_BREAKAWAY_FROM_JOB,
                         NULL,
                         NULL,
                         &SI,
                         &ProcInfo);
ERRORS:
	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\cer\cw15\main.cpp ===
#include "Main.h"
#include "KernelMode.h"
#include "UserMode.h"
#include "WinMessages.h"
#include "resource.h"
#include "clist.h"
#include "cuserlist.h"
#include "reportFault.h"
#include "CERHELP.h"

HWND g_hWnd;
HINSTANCE g_hinst;
HWND hKrnlMode = NULL;
HWND hUserMode = NULL;
KMODE_DATA KModeData;
TCHAR CerRoot[MAX_PATH];
HWND LoadThreadParam = NULL;
MRU_LIST MruList;
Clist CsvContents;
CUserList cUserData;
GLOBAL_POLICY GlobalPolicy;
BOOL g_bFirstBucket = TRUE;
BOOL g_bAdminAccess = TRUE;

TCHAR szUserColumnHeaders[][100] = 
						{	_T("Bucket ID"),
							_T("App. Name"),
							_T("App. Ver"),
							_T("Module Name"),
							_T("Module Version"),
							_T("Offset"),
							_T("Hits"),
							_T("Cabs Collected"),
							_T("Cabs Not Reported"),
							_T("Requested Collection"),
							_T("Allowed Collection"),
							_T("Microsoft Response"), 
							_T("URL to Launch")
						}; 

TCHAR szKerenelColumnHeaders[][100] = 
					   {	_T("BucketID"),
							_T("Cabs Collected"),
							_T("Microsoft Response")
					   };
BOOL GetFileName(HWND hwnd, TCHAR *FileName, int iType)
{
	OPENFILENAME opfn;

	// if we are running on NT4.0 use sizeof (OPENFILENAME_SIZE_VERSION_400)
	ZeroMemory (&opfn, sizeof OPENFILENAME );
	opfn.lStructSize = sizeof OPENFILENAME;
	opfn.hwndOwner = hwnd;
	opfn.nMaxFileTitle = MAX_PATH * sizeof TCHAR;
	opfn.lpstrFileTitle = FileName;
	opfn.lpstrFilter=_T("*.TXT");
	opfn.nFilterIndex = iType;
	opfn.Flags = OFN_CREATEPROMPT | OFN_OVERWRITEPROMPT | OFN_OVERWRITEPROMPT;
	if (GetSaveFileName((LPOPENFILENAME) &opfn))
		return TRUE;
	else
		return FALSE;
}

void ExportUserModeData(HWND hwnd)
{
	TCHAR szFileName[MAX_PATH];
	int   iFileType = 1; 
	TCHAR tchDelimiter = _T(',');
	HANDLE hFile = INVALID_HANDLE_VALUE;
	USER_DATA UserData;
	DWORD dwWritten = 0;
	BOOL  bEOF = FALSE;

	ZeroMemory (szFileName, sizeof szFileName);
	if ( !GetFileName(hwnd, szFileName, iFileType))
	{
		goto ERRORS;
	}

	if (iFileType == 3)
	{
		 //determine the max column widths
		goto ERRORS; 
	}

	if (iFileType == 1)
	{
		tchDelimiter = _T(',');
	}

	if (iFileType == 2)
	{
		tchDelimiter = _T('\t');
	}
	
	
	
	// Write out the data
	hFile = CreateFile (szFileName,
						GENERIC_WRITE,
						FILE_SHARE_READ,
						NULL,
						CREATE_ALWAYS,
						FILE_ATTRIBUTE_NORMAL,
						NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		goto ERRORS;

	for (int i = 0; i < USER_COL_COUNT; i++)
	{
		
		WriteFile(hFile, szUserColumnHeaders[i], _tcslen(szUserColumnHeaders[i]) *sizeof TCHAR, &dwWritten, NULL);
		
	}

	CloseHandle (hFile);
	//loop through the linked list and write the data to the output file
	cUserData.ResetCurrPos();
	while (cUserData.GetNextEntry(&UserData, &bEOF))
	{ 
		// write the output buffer to the file
		;
		
	}
		
ERRORS:
	;
}

void ExportKernelModeData(HWND hwnd)
{
	TCHAR FileName[MAX_PATH];
	int iType = 0;
	GetFileName(hwnd, FileName, iType);
}

typedef enum REPORTING_MODES {USER_MODE, KERNEL_MODE,GENERAL_MODE}; 

REPORTING_MODES ReportMode = USER_MODE;


DLGTEMPLATE * WINAPI DoLockDlgRes(LPCSTR lpszResName) 
{ 
    HRSRC hrsrc = FindResource(NULL, lpszResName, RT_DIALOG); 
	if (hrsrc)
	{
		 HGLOBAL hglb = LoadResource(g_hinst, hrsrc); 
		 return (DLGTEMPLATE *) LockResource(hglb); 
	}
	else
	{
		return NULL;
	}
} 

void DoKernelMode(HWND hwnd)
{
	TCHAR DialogTitle[255];
	DLGTEMPLATE *Temp = NULL;

	if (_tcscmp(CerRoot, _T("\0")))
	{
		if (StringCbPrintf(DialogTitle, sizeof DialogTitle, _T("Corporate Error Reporting - KERNEL MODE - %s"), CerRoot)!= S_OK)
		{
			goto ERRORS;
		}
	}
	else
	{
		if (StringCbPrintf(DialogTitle, sizeof DialogTitle, _T("Corporate Error Reporting - KERNEL MODE")) != S_OK)
		{
			goto ERRORS;
		}
	}
	SendMessage(hwnd, WM_SETTEXT, 0, (LPARAM)DialogTitle);
	if (ReportMode != KERNEL_MODE)
	{
        ReportMode = KERNEL_MODE; 
		
		if (hKrnlMode == NULL)
		{
			Temp = DoLockDlgRes(MAKEINTRESOURCE(IDD_KERNEL_MODE));
			if (Temp)
			{
				hKrnlMode = CreateDialogIndirect(g_hinst,Temp , hwnd, (DLGPROC) KrnlDlgProc);
			}
		}
		else
		{
			HMENU hMenu = GetMenu(hwnd);
			if (hMenu)
			{
				EnableMenuItem (hMenu, ID_REPORT_SELECTEDCRASHES  , MF_BYCOMMAND| MF_GRAYED);
			}
			ShowWindow(hKrnlMode,1);
		}
		if (hUserMode != NULL)
		{
			ShowWindow(hUserMode,0);
		}
	}
ERRORS:
	return;
}

void DoUserMode(HWND hwnd)
{
	TCHAR DialogTitle[255];
	DLGTEMPLATE *Temp = NULL;

	if (_tcscmp(CerRoot, _T("\0")))
	{
		if (StringCbPrintf(DialogTitle, sizeof DialogTitle, _T("Corporate Error Reporting - USER MODE - %s"), CerRoot)!= S_OK)
		{
			goto ERRORS;
		}
	}
	else
	{
		if (StringCbPrintf(DialogTitle, sizeof DialogTitle, _T("Corporate Error Reporting - USER MODE")) != S_OK)
		{
			goto ERRORS;
		}
	}

	SendMessage(hwnd, WM_SETTEXT, 0, (LPARAM)DialogTitle);
	if (ReportMode != USER_MODE)
	{
		ReportMode = USER_MODE; 
		if (hUserMode == NULL)
		{
			Temp = DoLockDlgRes(MAKEINTRESOURCE(IDD_USER_MODE));
			if (Temp)
			{
				hUserMode = CreateDialogIndirect(g_hinst,Temp , hwnd, (DLGPROC) UserDlgProc);
			}
		}
		else
		{
			HMENU hMenu = GetMenu(hwnd);
			if (hMenu)
			{
				if (_tcscmp(CerRoot, _T("\0")))
				{
					EnableMenuItem (hMenu, ID_REPORT_SELECTEDCRASHES  , MF_BYCOMMAND| MF_ENABLED);
				}
			}
			ShowWindow(hUserMode,1);
		}
		if (hKrnlMode != NULL)
		{
			ShowWindow(hKrnlMode,0);
		}


	}
ERRORS:
	return;
}

BOOL FileSystemIsNTFS(TCHAR *szPath)
{
	TCHAR szPathToValidate[MAX_PATH];
	TCHAR szType[50];



	ZeroMemory (szPathToValidate, sizeof szPathToValidate);
	ZeroMemory (szType, sizeof szType);

	if (StringCbCopy (szPathToValidate, sizeof szPathToValidate, szPath) != S_OK)
		goto ERRORS;

	PathStripToRoot(szPathToValidate);

	// add a \ if one is not found
	if (_tcslen (szPathToValidate ) > 1)
	{
		if (szPathToValidate[_tcslen(szPathToValidate)-1] != _T('\\'))
		{
			if (StringCbCat(szPathToValidate, sizeof szPathToValidate, _T("\\"))!= S_OK)
				goto ERRORS;
		}
		if (GetVolumeInformation(szPathToValidate, NULL, 0, NULL, 0, NULL, szType, sizeof szType / sizeof TCHAR))
		{
			if (!_tcscmp(szType, _T("NTFS")))
			{
				return TRUE;
			}
		}
	}
ERRORS:
	return FALSE;
}

int CALLBACK BrowseCallbackProc(
    HWND hwnd, 
    UINT uMsg, 
    LPARAM lParam, 
    LPARAM lpData
    )
{
	TCHAR Msg [100];
	switch (uMsg)
	{
	case BFFM_VALIDATEFAILEDW:
		{
	 		if (StringCbPrintf(Msg, sizeof Msg, _T("The selected directory is not valid.\r\nPlease select another directory."))!= S_OK)
			{
				goto ERRORS;
			}

			MessageBox(hwnd, Msg, NULL,MB_OK);
			return 1;
		}
	 default:
		 return 0;
	}	
	
ERRORS:
	 return 0;
}

void DoCreateFileTree(HWND hwnd)
/*








*/
{
	TCHAR szSubDir[MAX_PATH];
	DWORD ErrorCode;
	WCHAR wzPath[MAX_PATH];
	BROWSEINFOW bi;
	ACL *NewAcl;
	EXPLICIT_ACCESS eAccess[3];
	TCHAR  szPath[MAX_PATH];
	ULARGE_INTEGER FreeBytesAvailable; 
	ULARGE_INTEGER TotalFreeBytes ;
	ULARGE_INTEGER TotalBytes ;
	LPMALLOC pMalloc = NULL;
	PSID pSidAdministrators = NULL;
	PSID pSidEveryone = NULL;
	ZeroMemory (&bi, sizeof BROWSEINFOW);
	bi.hwndOwner = hwnd;
	bi.pidlRoot = NULL;
	bi.pszDisplayName = wzPath;
	bi.lpszTitle = L"Select a file share to be used as the root of the CER file tree...";
	bi.ulFlags = BIF_USENEWUI | BIF_RETURNONLYFSDIRS | BIF_EDITBOX | BIF_VALIDATE;
	bi.lpfn = BrowseCallbackProc;

	SID_IDENTIFIER_AUTHORITY pSIANTAuth = SECURITY_NT_AUTHORITY;
	SID_IDENTIFIER_AUTHORITY pSIAWorld = SECURITY_WORLD_SID_AUTHORITY;
	CoInitialize(NULL);
	
	

	ZeroMemory (wzPath, sizeof wzPath);
	ITEMIDLIST *pidl = SHBrowseForFolderW(&bi);
	if (SHGetMalloc(&pMalloc) == E_FAIL)
	{
		// we couldn't get to the shell
		MessageBox(hwnd, _T("Failed to open the selected directory"), NULL,MB_OK);
		goto DONE;
	}

	if (!wcscmp(wzPath, L"My Documents"))
	{
		MessageBox(hwnd, _T("Failed to open the selected directory"), NULL,MB_OK);	
		goto DONE;
	}

	ZeroMemory(&FreeBytesAvailable, sizeof ULARGE_INTEGER);
	ZeroMemory(&TotalFreeBytes, sizeof ULARGE_INTEGER);
	ZeroMemory(&TotalBytes, sizeof ULARGE_INTEGER);
	if (pidl != NULL)
	{
		
		if (SHGetPathFromIDList(pidl, szPath))
		{
			if (StringCbCopy (CerRoot,sizeof CerRoot, szPath) != S_OK)
			{
				goto ERRORS;
			}
			if (PathIsDirectory(szPath))
			{
				
				if (!FileSystemIsNTFS(szPath))
				{
					MessageBox(hwnd, _T("The CER tree can only be created on an NTFS file system"), NULL, MB_OK);
					goto DONE;
				}
				// Now check for space 
				if (!GetDiskFreeSpaceEx(szPath, &FreeBytesAvailable, &TotalBytes,&TotalFreeBytes))
				{
					// We were unable to retrieve the space info. 
					// Now what.
					goto ERRORS;
				}
				else
				{
					if (FreeBytesAvailable.QuadPart <  2000000000)
					{
						MessageBox(hwnd, _T("There is not enough free space to create a CER tree.\r\nA minimum of 2GB free space is required."), NULL, MB_OK);
						goto DONE;
					}
				}

				

				
				// Builtin\Administrators
				AllocateAndInitializeSid(&pSIANTAuth, 2, SECURITY_BUILTIN_DOMAIN_RID, DOMAIN_ALIAS_RID_ADMINS, 0, 0, 0, 0, 0, 0, &pSidAdministrators);

				// Everyone
				AllocateAndInitializeSid(&pSIAWorld, 1, SECURITY_WORLD_RID, 0, 0, 0, 0, 0, 0, 0, &pSidEveryone);
				
				// Create the cabs subdirectory
				if (StringCbPrintf(szSubDir, sizeof szSubDir, _T("%s\\Cabs"), szPath) != S_OK)
				{
					goto ERRORS;
				}
				if ( !CreateDirectory(szSubDir,NULL))
				{
					ErrorCode = 2;
					goto ERRORS;
				}
				else
				{
				
					// Set Everyone = WriteAccess
					ZeroMemory (eAccess, sizeof EXPLICIT_ACCESS);

					eAccess[0].grfAccessMode = SET_ACCESS;
					eAccess[0].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT  ;
					eAccess[0].grfAccessPermissions = FILE_APPEND_DATA | FILE_WRITE_DATA | FILE_WRITE_ATTRIBUTES | FILE_WRITE_EA ;
					//eAccess[1].Trustee.TrusteeForm = TRUSTEE_IS_NAME;
					eAccess[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
					eAccess[0].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
					//eAccess[1].Trustee.ptstrName = _T("Everyone");
					eAccess[0].Trustee.ptstrName = (LPTSTR) pSidEveryone;
	
					eAccess[2].grfAccessMode = SET_ACCESS;
					eAccess[2].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT ;
					eAccess[2].grfAccessPermissions = GENERIC_ALL;
					eAccess[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;
					eAccess[2].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
					//eAccess[2].Trustee.ptstrName = _T("Administrators");
					eAccess[2].Trustee.ptstrName = (LPTSTR) pSidAdministrators;

					eAccess[1].grfAccessMode = SET_ACCESS;
					eAccess[1].grfInheritance =CONTAINER_INHERIT_ACE  ;
					eAccess[1].grfAccessPermissions = FILE_EXECUTE | GENERIC_READ | FILE_LIST_DIRECTORY;
					eAccess[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
					eAccess[1].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
					eAccess[1].Trustee.ptstrName = (LPTSTR) pSidEveryone;

					SetEntriesInAcl( 3, eAccess, NULL, &NewAcl);
					ErrorCode = SetNamedSecurityInfo(szSubDir,
										 SE_FILE_OBJECT,
										 DACL_SECURITY_INFORMATION |
										 PROTECTED_DACL_SECURITY_INFORMATION |
										 PROTECTED_SACL_SECURITY_INFORMATION,
										 NULL,
										 NULL,
										 NewAcl,
										 NULL) != ERROR_SUCCESS;

			
					if (ErrorCode != ERROR_SUCCESS)
					{
						LocalFree((HLOCAL) NewAcl);
						goto ERRORS;
					}
					else
						LocalFree((HLOCAL) NewAcl);
				
				}
				// Create the counts SubDirecotry
				if (StringCbPrintf(szSubDir, sizeof szSubDir, _T("%s\\Counts"), szPath) != S_OK)
				{
					goto ERRORS;
				}
				if ( !CreateDirectory(szSubDir,NULL))
				{
					ErrorCode = 2;
					goto ERRORS;
				}
				else
				{
					// Set Everyone = WriteAccess
					ZeroMemory (eAccess, sizeof EXPLICIT_ACCESS);

					eAccess[0].grfAccessMode = SET_ACCESS;
					eAccess[0].grfInheritance =SUB_CONTAINERS_AND_OBJECTS_INHERIT  ;
					eAccess[0].grfAccessPermissions =  FILE_LIST_DIRECTORY | GENERIC_READ | GENERIC_WRITE | FILE_APPEND_DATA;
					eAccess[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
					eAccess[0].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
					eAccess[0].Trustee.ptstrName = (LPTSTR) pSidEveryone;
	
					eAccess[1].grfAccessMode = SET_ACCESS;
					eAccess[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
					eAccess[1].grfAccessPermissions = GENERIC_ALL;
					eAccess[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
					eAccess[1].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
					eAccess[1].Trustee.ptstrName = (LPTSTR) pSidAdministrators;
	
					eAccess[2].grfAccessMode = SET_ACCESS;
					eAccess[2].grfInheritance =CONTAINER_INHERIT_ACE  ;
					eAccess[2].grfAccessPermissions = FILE_EXECUTE | GENERIC_READ | FILE_LIST_DIRECTORY | FILE_APPEND_DATA;
					eAccess[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;
					eAccess[2].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
					eAccess[2].Trustee.ptstrName =(LPTSTR) pSidEveryone;

					SetEntriesInAcl( 3, eAccess, NULL, &NewAcl);
					ErrorCode = SetNamedSecurityInfo(szSubDir,
										 SE_FILE_OBJECT,
										 DACL_SECURITY_INFORMATION |
										 PROTECTED_DACL_SECURITY_INFORMATION |
										 PROTECTED_SACL_SECURITY_INFORMATION,
										 NULL,
										 NULL,
										 NewAcl,
										 NULL) != ERROR_SUCCESS;
					if (ErrorCode != ERROR_SUCCESS)
					{
						LocalFree((HLOCAL) NewAcl);
						goto ERRORS;
					}
					else
						LocalFree((HLOCAL) NewAcl);
				}
				
				// Create the Status SubDirecotry
				if (StringCbPrintf(szSubDir, sizeof szSubDir, _T("%s\\Status"), szPath) != S_OK)
				{
					goto ERRORS;
				}
				if ( !CreateDirectory(szSubDir,NULL))
				{
					ErrorCode = 2;
					goto ERRORS;
				}
				else
				{
					
					ZeroMemory (eAccess, sizeof EXPLICIT_ACCESS);

					eAccess[2].grfAccessMode = SET_ACCESS;
					eAccess[2].grfInheritance =SUB_CONTAINERS_AND_OBJECTS_INHERIT  ;
					eAccess[2].grfAccessPermissions =  FILE_LIST_DIRECTORY | GENERIC_READ;
					eAccess[2].Trustee.TrusteeForm = TRUSTEE_IS_SID;
					eAccess[2].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
					eAccess[2].Trustee.ptstrName = (LPTSTR) pSidEveryone;
	
					eAccess[1].grfAccessMode = SET_ACCESS;
					eAccess[1].grfInheritance = SUB_CONTAINERS_AND_OBJECTS_INHERIT;
					eAccess[1].grfAccessPermissions = GENERIC_ALL;
					eAccess[1].Trustee.TrusteeForm = TRUSTEE_IS_SID;
					eAccess[1].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
					eAccess[1].Trustee.ptstrName = (LPTSTR) pSidAdministrators;
	
					eAccess[0].grfAccessMode = SET_ACCESS;
					eAccess[0].grfInheritance =CONTAINER_INHERIT_ACE  ;
					eAccess[0].grfAccessPermissions = FILE_EXECUTE | GENERIC_READ | FILE_LIST_DIRECTORY | FILE_APPEND_DATA;
					eAccess[0].Trustee.TrusteeForm = TRUSTEE_IS_SID;
					eAccess[0].Trustee.TrusteeType = TRUSTEE_IS_GROUP;
					eAccess[0].Trustee.ptstrName =(LPTSTR) pSidEveryone;
	
					SetEntriesInAcl( 3, eAccess, NULL, &NewAcl);
					ErrorCode = SetNamedSecurityInfo(szSubDir,
										 SE_FILE_OBJECT,
										 DACL_SECURITY_INFORMATION |
										 PROTECTED_DACL_SECURITY_INFORMATION |
										 PROTECTED_SACL_SECURITY_INFORMATION,
										 NULL,
										 NULL,
										 NewAcl,
										 NULL) != ERROR_SUCCESS;
					if (ErrorCode != ERROR_SUCCESS)
					{
						LocalFree((HLOCAL) NewAcl);
						goto ERRORS;
					}
					else
						LocalFree((HLOCAL) NewAcl);
				}
			}
			
			
		}
		MessageBox(hwnd, szPath, _T("Successfully created CER file tree in: "), MB_OK);
	}
	if(pidl)
    {
		if (pMalloc)
			pMalloc->Free(pidl);
    }
	if (pMalloc)
		pMalloc->Release();
	if (pSidAdministrators)
		FreeSid(pSidAdministrators);
	if (pSidEveryone)
		FreeSid(pSidEveryone);
	CoUninitialize();
	return;
ERRORS:
	
	MessageBox(hwnd, _T("Failed to Create CER File Tree."), NULL,MB_OK);
DONE:
	if(pidl)
    {
		if (pMalloc)
			pMalloc->Free(pidl);
    }
	if (pMalloc)
		pMalloc->Release();
	if (pSidAdministrators)
		FreeSid(pSidAdministrators);
	if (pSidEveryone)
		FreeSid(pSidEveryone);
	CoUninitialize();
	return;
}

void PopulateMruList(HWND hwnd, BOOL bUpdate)
{

	HMENU hmenu = GetSubMenu(GetMenu(hwnd), 0);
	HMENU hNewMenu = NULL;
	int   iCount = 0;
	
	if (!bUpdate)
	{
		hNewMenu = CreateMenu();
		if (hmenu && hNewMenu)
		{
			if (_tcscmp(MruList.szMRU1, _T("\0")))
			{
				AppendMenu(hNewMenu, MF_STRING, ID_FILE_MRU1, MruList.szMRU1);
				ModifyMenu(hmenu, ID_FILE_RECENTFILETREES165, MF_BYCOMMAND | MF_POPUP, (UINT_PTR) hNewMenu, _T("Recent File &Trees"));
				
				if (_tcscmp(MruList.szMRU2, _T("\0")))
				{
					AppendMenu(hNewMenu, MF_STRING, ID_FILE_MRU2, MruList.szMRU2);
				}
				if (_tcscmp(MruList.szMRU3, _T("\0")))
				{
					AppendMenu(hNewMenu, MF_STRING, ID_FILE_MRU3, MruList.szMRU3);
				}
				if (_tcscmp(MruList.szMRU3, _T("\0")))
				{
					AppendMenu(hNewMenu, MF_STRING, ID_FILE_MRU4, MruList.szMRU4);
				}
			}
		}
	}
	else
	{
		hNewMenu= GetSubMenu(hmenu, 6);
		if (!hNewMenu)
		{
			hNewMenu = CreateMenu();
			if (_tcscmp(MruList.szMRU1, _T("\0")))
			{
				ModifyMenu(hmenu, ID_FILE_RECENTFILETREES165, MF_BYCOMMAND | MF_POPUP, (UINT_PTR) hNewMenu, _T("Recent File &Trees"));
				AppendMenu(hNewMenu, MF_STRING, ID_FILE_MRU1, MruList.szMRU1);
			}
		}
		else
		{
			iCount = GetMenuItemCount(hNewMenu);
			// Delete the old menu items and rebuild the menu
			if (iCount == 4)
			{
				DeleteMenu(hNewMenu, ID_FILE_MRU4, MF_BYCOMMAND);
				DeleteMenu(hNewMenu, ID_FILE_MRU3, MF_BYCOMMAND);
				DeleteMenu(hNewMenu, ID_FILE_MRU2, MF_BYCOMMAND);
				DeleteMenu(hNewMenu, ID_FILE_MRU1, MF_BYCOMMAND);

				AppendMenu(hNewMenu, MF_STRING, ID_FILE_MRU1, MruList.szMRU1);
				AppendMenu(hNewMenu, MF_STRING, ID_FILE_MRU2, MruList.szMRU2);
				AppendMenu(hNewMenu, MF_STRING, ID_FILE_MRU3, MruList.szMRU3);
				AppendMenu(hNewMenu, MF_STRING, ID_FILE_MRU4, MruList.szMRU4);
			}
			else
			{
				
		
				switch (iCount)
				{
				case 3:
					// display Fourth
					if (_tcscmp(MruList.szMRU4, _T("\0")))
					{
						AppendMenu(hNewMenu, MF_STRING, ID_FILE_MRU4, MruList.szMRU4);
					}
					break;
				case 2:
					// display third
					if (_tcscmp(MruList.szMRU3, _T("\0")))
					{
						AppendMenu(hNewMenu, MF_STRING, ID_FILE_MRU3, MruList.szMRU3);
					}
					break;
				case 1:
					// Display second
					if (_tcscmp(MruList.szMRU2, _T("\0")))
					{
						AppendMenu(hNewMenu, MF_STRING, ID_FILE_MRU2, MruList.szMRU2);
					}
					break;
				default:
					// All the slots were full we need to change the menu item
					ModifyMenu(hNewMenu, ID_FILE_MRU4, MF_BYCOMMAND | MF_STRING, ID_FILE_MRU4, MruList.szMRU4);
							
					;
				}
			}
		}
	}
}
void OnDlgInit(HWND hwnd)
{
	HICON hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDI_MAIN));
	if (hIcon)
	{
		SendMessage(hwnd, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
		SendMessage(hwnd, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
	}
	if (StringCbCopy(CerRoot, sizeof CerRoot, _T("\0")) != S_OK)
	{
		goto ERRORS;
	}

	MakeHelpFileName();
	// Disable Menu items that cannot be accessed until a filetree is loaded
	HMENU hMenu = GetMenu(hwnd);
	if (hMenu)
	{
		//EnableMenuItem (hMenu, ID_EDIT_COPY115, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_EDIT_SELECTALL  , MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_EDIT_DEFAULTPOLICY  , MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_EDIT_SELECTEDBUCKETSPOLICY  , MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_REPORT_ALLCRASHES  , MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_REPORT_SELECTEDFAULTS  , MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_VIEW_BUCKETCABFILEDIRECTORY  , MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_VIEW_BUCKETINSTANCEDATA  , MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_VIEW_RESPONSESELECTED  , MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_VIEW_REFRESH  , MF_BYCOMMAND| MF_GRAYED);
		//EnableMenuItem (hMenu, ID_FILE_EXPORTBUCKETS  , MF_BYCOMMAND| MF_GRAYED);
		//EnableMenuItem (hMenu, ID_FILE_EXPORTSELECTEDBUCKETS  , MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_FILE_RELOADFILETREE, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_REPORT_USERMODEFAULTS, MF_BYCOMMAND | MF_GRAYED);
		EnableMenuItem (hMenu, ID_REPORT_KERNELMODEFAULTS, MF_BYCOMMAND | MF_GRAYED);
		EnableMenuItem (hMenu, ID_VIEW_CRASHLOG, MF_BYCOMMAND | MF_GRAYED);
	//	EnableMenuItem (hMenu, ID_EXPORT_USERMODEBUCKETDATA, MF_BYCOMMAND | MF_GRAYED);
	//	EnableMenuItem (hMenu, ID_EXPORT_KERNELMODEFAULTDATA, MF_BYCOMMAND | MF_GRAYED);
	}
	
	// Create the User and Kernel mode dialog boxes.
	ReportMode = USER_MODE;
	DoKernelMode(hwnd);

	ReportMode = KERNEL_MODE;
	DoUserMode(hwnd);

	if (LoadMruList())
	{
		//Populate the file menu with the mrulist;
		PopulateMruList(hwnd, FALSE);
	}

ERRORS:
	return;
	
}
int GetTreePBarRange()
{
	int Range = 10;
	
	// Count the directories to load - 2 for the . and .. directories.
	return Range;
}
DWORD WINAPI tfCollectBucketStart (void *ThreadParam)
{
	// Get progress bar range values
	   
	// Load the user mode tree
	   if (!GetAllBuckets (*((HWND *) ThreadParam)))
	   {
		   MessageBox(*((HWND *) ThreadParam), _T("Failed to load the CER file tree."), NULL,MB_OK);
       }
	   else
	   {
			PostMessage(hUserMode, WM_FileTreeLoaded, 0,0);
			// Load the kernel mode tree
			   
			PostMessage(hKrnlMode, WM_FileTreeLoaded, 0,0);
	   }
	   PostMessage(*((HWND *) ThreadParam), WmSyncDone, FALSE, 0);
	return TRUE;
}

void CenterDialogInParent(HWND hwnd)
{
	HWND hParent = GetParent(hwnd);
	RECT rcParent;  
	RECT rcDlg;  
	RECT newRect;

	GetWindowRect(hParent, &rcParent);
	GetWindowRect(hwnd, &rcDlg);

	newRect.left = rcParent.left + (rcParent.right - rcParent.left) /2  - (rcDlg.right - rcDlg.left) /2;
	newRect.top = rcParent.top + (rcParent.bottom - rcParent.top) /2 - (rcDlg.bottom - rcDlg.top) /2;
	MoveWindow(hwnd, newRect.left, newRect.top, rcDlg.right - rcDlg.left , rcDlg.bottom - rcDlg.top, TRUE); 
}
BOOL CALLBACK LoadDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
	HANDLE hThread = NULL;
//	DWORD dw;
	LoadThreadParam = hDlg;
	switch (uMsg)
		{
	case WM_INITDIALOG:
		CenterDialogInParent(hDlg);
		// Set Dialog Title
		TCHAR DialogTitle[MAX_PATH];
		if (StringCbPrintf(DialogTitle, sizeof DialogTitle, _T("Loading File Tree: %s"), CerRoot)!= S_OK)
		{
			goto ERRORS;
		}
		SendMessage(hDlg, WM_SETTEXT, 0, (LPARAM)DialogTitle);
		SendDlgItemMessage(hDlg, IDC_PB, PBM_SETSTEP, 1, 0);
		hThread = CreateThread(NULL, 0, tfCollectBucketStart, &LoadThreadParam, 0, NULL);
		if (hThread)
			CloseHandle(hThread);
		return TRUE;
	case WM_CLOSE:
		// Cancel the tree load and clear the Data structures.
		EndDialog(hDlg, TRUE);
		return TRUE;

	case WmSyncDone:
			EndDialog(hDlg, 1);
		return TRUE;
		}
ERRORS:
	return FALSE;	
}


BOOL DoLoadFileTree(HWND hwnd, TCHAR *Directory, BOOL bGetDir)
{

	WCHAR wzPath[MAX_PATH];
	BROWSEINFOW bi;
	TCHAR  szPath[MAX_PATH];
	TCHAR szSubDir[MAX_PATH];
	
	ZeroMemory (szSubDir, sizeof szSubDir);
	ZeroMemory (szPath, sizeof szPath); 
	
	if (bGetDir)
	{
		bi.hwndOwner = hwnd;
		bi.pidlRoot = NULL;
		bi.pszDisplayName = wzPath;
		bi.lpszTitle = L"Select a CER File Tree to open...";
		bi.ulFlags = BIF_USENEWUI | BIF_RETURNONLYFSDIRS | BIF_EDITBOX;
		bi.lpfn = NULL;
		ITEMIDLIST *pidl = SHBrowseForFolderW(&bi);
		if (pidl != NULL)
		{
		
			if (!SHGetPathFromIDList(pidl, szPath))
			{
				goto CANCELED;
			}
		}
		else
		{
			goto CANCELED;
		}
	}
	else
	{
		if (!Directory)
		{
			goto CANCELED;
		}
		if (StringCbCopy (szPath, sizeof szPath, Directory) != S_OK)
		{
			goto ERRORS;
		}
	}

	if (PathIsDirectory(szPath))
	{
		if (StringCbPrintf(szSubDir, sizeof szSubDir, _T("%s\\Cabs"), szPath) != S_OK)
		{
			goto ERRORS;
		}
	}
	else
	{
		if (!PathIsDirectory(szSubDir))
		{
			goto ERRORS;
		}

	}
	if (StringCbPrintf(szSubDir, sizeof szSubDir, _T("%s\\Counts"), szPath) != S_OK)
	{
		goto ERRORS;
	}
	else
	{
		if (!PathIsDirectory(szSubDir))
		{
			goto ERRORS;
		}

	}

	if (StringCbPrintf(szSubDir, sizeof szSubDir, _T("%s\\Status"), szPath) != S_OK)
	{
		goto ERRORS;
	}
	else
	{
		if (!PathIsDirectory(szSubDir))
		{
			goto ERRORS;
		}

	}

	if (StringCbCopy (CerRoot,sizeof CerRoot, szPath) != S_OK)
	{
		goto ERRORS;
	}
	
	if (!DialogBox(g_hinst, MAKEINTRESOURCE(IDD_LOAD), hwnd, (DLGPROC) LoadDlgProc))
	{
		//MessageBox(NULL, "FAILED TO LOAD TREE", NULL, MB_OK);
		goto ERRORS;
		
	}
	else
	{
		AddToMruList(hwnd, CerRoot);
		SaveMruList();
		PopulateMruList(hwnd, TRUE);
		
	}
	return TRUE;
ERRORS:

	MessageBox(hwnd, _T("Failed to load the CER file tree."), NULL,MB_OK);
	
CANCELED:
	return FALSE;
}

void OnAboutBoxInit(HWND hwnd)
{	
	TCHAR wz1[MAX_PATH];
	TCHAR wz2[MAX_PATH];

	HRSRC hRsrc = FindResourceW(GetModuleHandle(NULL), MAKEINTRESOURCEW(1), MAKEINTRESOURCEW(RT_VERSION));

	if (!hRsrc)
	{
		goto ERRORS;
	}
	void *pver = LoadResource(GetModuleHandle(NULL), hRsrc);

	if (!pver)
	{
		goto ERRORS;
	}
	VS_FIXEDFILEINFO *pVer = NULL;
	UINT dwVer;
	VerQueryValue(pver, _T("\\"), (void **)&pVer, &dwVer);
	if (!pVer)
	{
		goto ERRORS;
	}
	if (StringCbCopy(wz1, sizeof wz1, _T("Version %d.%d.%d.%d")) != S_OK)
	{
		goto ERRORS;
	}
	if (StringCbPrintf(wz2,sizeof wz2, wz1,
			HIWORD(pVer->dwProductVersionMS), LOWORD(pVer->dwProductVersionMS),
			HIWORD(pVer->dwProductVersionLS), LOWORD(pVer->dwProductVersionLS)) != S_OK)
	{
		goto ERRORS;
	}
	SetDlgItemText(hwnd, IDC_VERSION_STRING, wz2);

	WORD *lpTranslate = NULL;		
	VerQueryValue(pver,_T("\\VarFileInfo\\Translation"), (void **)&lpTranslate, &dwVer);
	if (!lpTranslate)
	{
		goto ERRORS;
	}
	if (StringCbPrintf(wz1,sizeof wz1, _T("\\StringFileInfo\\%04x%04x\\LegalCopyright"), lpTranslate[0], lpTranslate[1]) != S_OK)
	{
		goto ERRORS;
	}
	TCHAR  *wzCopyright = NULL;
	VerQueryValue(pver, wz1, (void **)&wzCopyright, &dwVer);
	if (!wzCopyright)
	{
		goto ERRORS;
	}
	SetDlgItemText(hwnd, IDC_COPYRIGHT_STRING, wzCopyright);

ERRORS:
	return;
	
}

LRESULT CALLBACK AboutDlgProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	switch (iMsg)
	{
	case WM_INITDIALOG:
		OnAboutBoxInit (hwnd);
		return TRUE;

	case WM_COMMAND:
		{
			switch (LOWORD(wParam))
			{
			case IDOK:
				EndDialog(hwnd, TRUE);
				return TRUE;
			}
		}
	case WM_DESTROY:
		EndDialog(hwnd, TRUE);
		return TRUE;
	default:
		break;
	}
	return FALSE;
}

void EnableMenuItems(HWND hwnd)
{
	// Main menu
	HMENU hMenu = GetMenu(hwnd);
	//
	//EnableMenuItem (hMenu, ID_EDIT_SELECTALL  , MF_BYCOMMAND| MF_ENABLED);
	if (hMenu)
	{
		EnableMenuItem (hMenu, ID_EDIT_DEFAULTPOLICY  , MF_BYCOMMAND| MF_ENABLED);
		EnableMenuItem (hMenu, ID_EDIT_SELECTEDBUCKETSPOLICY  , MF_BYCOMMAND| MF_ENABLED);
		EnableMenuItem (hMenu, ID_REPORT_ALLCRASHES  , MF_BYCOMMAND| MF_ENABLED);
		EnableMenuItem (hMenu, ID_REPORT_SELECTEDFAULTS  , MF_BYCOMMAND| MF_ENABLED);
		EnableMenuItem (hMenu, ID_VIEW_BUCKETCABFILEDIRECTORY  , MF_BYCOMMAND| MF_ENABLED);
		EnableMenuItem (hMenu, ID_VIEW_BUCKETINSTANCEDATA  , MF_BYCOMMAND| MF_ENABLED);
		EnableMenuItem (hMenu, ID_VIEW_RESPONSESELECTED  , MF_BYCOMMAND| MF_ENABLED);
		EnableMenuItem (hMenu, ID_VIEW_REFRESH  , MF_BYCOMMAND| MF_ENABLED);
		//EnableMenuItem (hMenu, ID_FILE_EXPORTBUCKETS  , MF_BYCOMMAND| MF_ENABLED);
		//EnableMenuItem (hMenu, ID_FILE_EXPORTSELECTEDBUCKETS  , MF_BYCOMMAND| MF_ENABLED);
		EnableMenuItem (hMenu, ID_FILE_RELOADFILETREE, MF_BYCOMMAND| MF_ENABLED);
		EnableMenuItem (hMenu, ID_REPORT_USERMODEFAULTS, MF_BYCOMMAND | MF_ENABLED);
		EnableMenuItem (hMenu, ID_REPORT_KERNELMODEFAULTS, MF_BYCOMMAND | MF_ENABLED);
		EnableMenuItem (hMenu, ID_VIEW_CRASHLOG, MF_BYCOMMAND | MF_ENABLED);
		//EnableMenuItem (hMenu, ID_EDIT_COPY115, MF_BYCOMMAND| MF_ENABLED);
		if ( !g_bAdminAccess)
		{
			EnableMenuItem (hMenu, ID_REPORT_ALLCRASHES  , MF_BYCOMMAND| MF_GRAYED);
			//EnableMenuItem (hMenu, ID_REPORT_SELECTEDCRASHES  , MF_BYCOMMAND| MF_GRAYED);
			EnableMenuItem (hMenu, ID_REPORT_SELECTEDFAULTS  , MF_BYCOMMAND| MF_GRAYED);
			EnableMenuItem (hMenu, ID_REPORT_USERMODEFAULTS, MF_BYCOMMAND | MF_GRAYED);
			EnableMenuItem (hMenu, ID_REPORT_KERNELMODEFAULTS, MF_BYCOMMAND | MF_GRAYED);
			EnableMenuItem (hMenu, ID_EDIT_DEFAULTPOLICY  , MF_BYCOMMAND| MF_GRAYED);
			EnableMenuItem (hMenu, ID_EDIT_SELECTEDBUCKETSPOLICY  , MF_BYCOMMAND| MF_GRAYED);
		}
	}
//	EnableMenuItem (hMenu, ID_EXPORT_USERMODEBUCKETDATA, MF_BYCOMMAND | MF_ENABLED);
//	EnableMenuItem (hMenu, ID_EXPORT_KERNELMODEFAULTDATA, MF_BYCOMMAND | MF_ENABLED);
}


BOOL SaveMruList()
{
	HKEY hHKLM = NULL;
	HKEY hMruKey = NULL;
//	BYTE Buffer[(MAX_PATH + 1) * sizeof TCHAR] ;
//	DWORD Type;
	DWORD BufferSize = MAX_PATH +1;	// Set for largest value
	BOOL Status = TRUE;

	if(!RegConnectRegistry(NULL, HKEY_CURRENT_USER, &hHKLM))
	{
		
		if(RegOpenKeyEx(hHKLM,_T("Software\\Microsoft\\CER1.5"), 0, KEY_ALL_ACCESS, &hMruKey))
		{
			// The key probably doesn't exists try to create it.
			if (RegCreateKey(hHKLM, _T("Software\\Microsoft\\CER1.5"), &hMruKey))
			{
				// Ok Now What
				goto ERRORS;
			}
		}
		
		if (hMruKey)
		{
			// Get the input queue directory path
			
			BufferSize = (_tcslen(MruList.szMRU1) + 1 ) * sizeof TCHAR;
			if (BufferSize > sizeof TCHAR)
			{
				if (RegSetValueEx(hMruKey,_T("CerMRU1"), 0, REG_SZ,(BYTE *) MruList.szMRU1, BufferSize) != ERROR_SUCCESS)
				{
					//LogEvent(_T("Failed to get InputQueue value from registry."));
					Status = FALSE;
				}
			}

			BufferSize = (_tcslen(MruList.szMRU2) + 1 ) * sizeof TCHAR;
			if (BufferSize > sizeof TCHAR)
			{
				if (RegSetValueEx(hMruKey,_T("CerMRU2"), 0, REG_SZ,(BYTE *) MruList.szMRU2, BufferSize) != ERROR_SUCCESS)
				{
					//LogEvent(_T("Failed to get InputQueue value from registry."));
					Status = FALSE;
				}
			}
			BufferSize = (_tcslen(MruList.szMRU3) + 1 ) * sizeof TCHAR;
			if (BufferSize > sizeof TCHAR)
			{
				if (RegSetValueEx(hMruKey,_T("CerMRU3"), 0, REG_SZ, (BYTE *)MruList.szMRU3, BufferSize) != ERROR_SUCCESS)
				{
					//LogEvent(_T("Failed to get InputQueue value from registry."));
					Status = FALSE;
				}
			}
			BufferSize = (_tcslen(MruList.szMRU4) + 1 ) * sizeof TCHAR;
			if (BufferSize > sizeof TCHAR)
			{
				if (RegSetValueEx(hMruKey,_T("CerMRU4"), 0, REG_SZ, (BYTE *)MruList.szMRU4, BufferSize) != ERROR_SUCCESS)
				{
					Status = FALSE;
				}
			}
			if (hMruKey)
			{
				RegCloseKey(hMruKey);
				hMruKey = NULL;
			}
			
		}
		if (hHKLM)
		{
			RegCloseKey(hHKLM);
			hHKLM = NULL;
		}
		return TRUE;
	}

ERRORS:
	if (hMruKey)
	{
		RegCloseKey(hMruKey);
	}
	if (hHKLM)
	{
		RegCloseKey(hHKLM);
	}

	return FALSE;
}
// Load the mru's
BOOL LoadMruList()
{
	
	HKEY hHKLM = NULL;
	HKEY hMruKey = NULL;
//	TCHAR ErrorString[20];
	BYTE Buffer[(MAX_PATH + 1) * sizeof TCHAR] ;
	DWORD Type;
	DWORD BufferSize = MAX_PATH +1;	// Set for largest value
	BOOL Status = TRUE;
	BOOL bNeedSave = FALSE;

	if(!RegConnectRegistry(NULL, HKEY_CURRENT_USER, &hHKLM))
	{
		
		if(RegOpenKeyEx(hHKLM,_T("Software\\Microsoft\\CER1.5"), 0, KEY_ALL_ACCESS, &hMruKey))
		{
			hMruKey = NULL;
			if (RegOpenKeyEx(hHKLM, _T("Software\\Microsoft\\Office\\10.0\\ResourceKit"), 0, KEY_ALL_ACCESS, &hMruKey))
			{
				goto ERRORS;
			}
			else
			{
				bNeedSave = TRUE;
			}
		}	
	
		if (hMruKey)
		{
			// Get the input queue directory path
			BufferSize = MAX_PATH +1;
			ZeroMemory(Buffer, BufferSize);
			if (RegQueryValueEx(hMruKey,_T("CerMRU1"), 0, &Type, Buffer, &BufferSize) != ERROR_SUCCESS)
			{
				//LogEvent(_T("Failed to get InputQueue value from registry."));
				Status = FALSE;
			}
			else
			{
				if (StringCbCopy(MruList.szMRU1, sizeof MruList.szMRU1, (TCHAR *)Buffer)!= S_OK)
				{
					goto ERRORS;
				}
			}
			
			BufferSize = MAX_PATH +1;
			ZeroMemory(Buffer, BufferSize);
			if (RegQueryValueEx(hMruKey,_T("CerMRU2"), 0, &Type, Buffer, &BufferSize) != ERROR_SUCCESS)
			{
				//LogEvent(_T("Failed to get InputQueue value from registry."));
				Status = FALSE;
			}
			else
			{
				if (StringCbCopy(MruList.szMRU2, sizeof MruList.szMRU2, (TCHAR *)Buffer)!= S_OK)
				{
					goto ERRORS;
				}
			}
			BufferSize = MAX_PATH +1;
			ZeroMemory(Buffer, BufferSize);
			if (RegQueryValueEx(hMruKey,_T("CerMRU3"), 0, &Type, Buffer, &BufferSize) != ERROR_SUCCESS)
			{
				//LogEvent(_T("Failed to get InputQueue value from registry."));
				Status = FALSE;
			}
			else
			{
				if (StringCbCopy(MruList.szMRU3, sizeof MruList.szMRU3, (TCHAR *)Buffer)!= S_OK)
				{
					goto ERRORS;
				}
			}
			BufferSize = MAX_PATH +1;
			ZeroMemory(Buffer, BufferSize);
			if (RegQueryValueEx(hMruKey,_T("CerMRU4"), 0, &Type, Buffer, &BufferSize) != ERROR_SUCCESS)
			{
				//LogEvent(_T("Failed to get InputQueue value from registry."));
				Status = FALSE;
			}
			else
			{
				if (StringCbCopy(MruList.szMRU4, sizeof MruList.szMRU4, (TCHAR *)Buffer)!= S_OK)
				{
					goto ERRORS;
				}
			}
			RegCloseKey(hMruKey);
			hMruKey = NULL;
		}
		RegCloseKey(hHKLM);
		hHKLM = NULL;
		if (bNeedSave)
			SaveMruList();
		return TRUE;
	}
ERRORS:
	if (hMruKey)
		RegCloseKey (hMruKey);
	if (hHKLM)
		RegCloseKey (hHKLM);
	return FALSE;
}

BOOL AddToMruList(HWND hwnd, TCHAR *NewEntry)
{
//	TCHAR Entry[MAX_PATH];
//	int   EntryNumber = 0;
	//if (StringCbPrintf(Entry, sizeof Entry, _T("

	// if entry not found in list
	if (!_tcscmp (NewEntry, MruList.szMRU1 + 4))
		goto DONE;
	if (!_tcscmp (NewEntry, MruList.szMRU2 + 4))
		goto DONE;
	if (!_tcscmp (NewEntry, MruList.szMRU3 + 4))
		goto DONE;
	if (!_tcscmp (NewEntry, MruList.szMRU4 + 4))
		goto DONE;
	
	// Find the first available slot or replace mru4
	if (!_tcscmp (_T("\0"), MruList.szMRU1))
	{
		if (StringCbPrintf(MruList.szMRU1, sizeof MruList.szMRU1, _T("&1. %s"),  NewEntry) != S_OK)
			goto ERRORS;
	}
	else
	{
		if (!_tcscmp (_T("\0"), MruList.szMRU2 ))
		{
			if (StringCbPrintf(MruList.szMRU2, sizeof MruList.szMRU2, _T("&2. %s"),  NewEntry) != S_OK)
				goto ERRORS;
		}
		else
		{
            if (!_tcscmp (_T("\0"), MruList.szMRU3))
			{
				if (StringCbPrintf(MruList.szMRU3, sizeof MruList.szMRU3, _T("&3. %s"),  NewEntry) != S_OK)
					goto ERRORS;
			}
			else
			{
				if (!_tcscmp (_T("\0"), MruList.szMRU4))
				{
					if (StringCbPrintf(MruList.szMRU4, sizeof MruList.szMRU4, _T("&4. %s"),  NewEntry) != S_OK)
						goto ERRORS;
				}
				else
				{
					// all of the slots are full move each of the entries up one 
					// slot and add the new entry at the bottom of the list.
					if (StringCbCopy(MruList.szMRU1 + 4, sizeof MruList.szMRU1, MruList.szMRU2 + 4) != S_OK)
					{
						goto ERRORS;
					}
					if (StringCbCopy(MruList.szMRU2 + 4, sizeof MruList.szMRU2, MruList.szMRU3 + 4) != S_OK)
					{
						goto ERRORS;
					}
					if (StringCbCopy(MruList.szMRU3 + 4, sizeof MruList.szMRU3, MruList.szMRU4 + 4) != S_OK)
					{
						goto ERRORS;
					}
					if (StringCbPrintf(MruList.szMRU4, sizeof MruList.szMRU4, _T("&4. %s"),  NewEntry) != S_OK)
						goto ERRORS;
				}
			}
		}
				
	}
	
	// Build the new entry String
		
DONE:
	
	return TRUE;
ERRORS:
	return FALSE;
}

void ViewCrashLog()
{
	

	TCHAR szCommandLine[MAX_PATH];

	
	if (_tcscmp(CerRoot, _T("\0")))
	{
		ZeroMemory (szCommandLine, sizeof szCommandLine);
		if (StringCbPrintf(szCommandLine, sizeof szCommandLine, _T("%s\\crash.log"), CerRoot)!= S_OK)
		{
			goto ERRORS;
		}
		
		if (_tcscmp(szCommandLine, _T("\0")))
		{
			SHELLEXECUTEINFOA sei = {0};
			sei.cbSize = sizeof(sei);
			sei.lpFile = szCommandLine;
			sei.nShow = SW_SHOWDEFAULT;
			if (! ShellExecuteEx(&sei) )
			{
				// What do we display here.
				;
			}
		}
	}
ERRORS:
	return;
}


BOOL WriteGlobalPolicyFile()
{
	TCHAR Buffer[1024];
	HANDLE hFile = INVALID_HANDLE_VALUE;
	TCHAR szPath[MAX_PATH];
	DWORD dwBytesWritten = 0;

	if (StringCbPrintf(szPath, sizeof szPath, _T("%s\\Policy.txt"), CerRoot) != S_OK)
	{
		goto ERRORS;
	}

	hFile = CreateFile(szPath,
					   GENERIC_WRITE, 
					   NULL,
					   NULL,
					   CREATE_ALWAYS,
					   FILE_ATTRIBUTE_NORMAL,
					   NULL);
	if (hFile == INVALID_HANDLE_VALUE)
		goto ERRORS;
	else
	{
		// write the Global Policy structure to the file
		ZeroMemory(Buffer, sizeof Buffer);
		if (_tcscmp(GlobalPolicy.EnableCrashTracking,_T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("%s%s\r\n"), TRACKING_PREFIX, GlobalPolicy.EnableCrashTracking)!= S_OK)
			{
				goto ERRORS;
			}
			else
			{
				if (!WriteFile(hFile, Buffer, _tcslen(Buffer) *sizeof TCHAR, &dwBytesWritten, NULL))
				{
					goto ERRORS;
				}
			}
		}

		ZeroMemory(Buffer, sizeof Buffer);
		if (_tcscmp(GlobalPolicy.AllowAdvanced,_T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("%s%s\r\n"), FILE_COLLECTION_PREFIX, GlobalPolicy.AllowAdvanced )!= S_OK)
			{
				goto ERRORS;
			}
			else
			{
				if (!WriteFile(hFile, Buffer, _tcslen(Buffer) *sizeof TCHAR, &dwBytesWritten, NULL))
				{
					goto ERRORS;
				}
			}
		}

		ZeroMemory(Buffer, sizeof Buffer);
		if (_tcscmp(GlobalPolicy.AllowBasic,_T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("%s%s\r\n"), SECOND_LEVEL_DATA_PREFIX, GlobalPolicy.AllowBasic )!= S_OK)
			{
				goto ERRORS;
			}
			else
			{
				if (!WriteFile(hFile, Buffer, _tcslen(Buffer) *sizeof TCHAR, &dwBytesWritten, NULL))
				{
					goto ERRORS;
				}
			}
		}

		ZeroMemory(Buffer, sizeof Buffer);
		if (_tcscmp(GlobalPolicy.CustomURL,_T("\0")))
		{
			

			if (StringCbPrintf(Buffer, sizeof Buffer, _T("%s%s\r\n"),URLLAUNCH_PREFIX, GlobalPolicy.CustomURL )!= S_OK)
			{
				goto ERRORS;
			}
			else
			{
				if (!WriteFile(hFile, Buffer, _tcslen(Buffer) *sizeof TCHAR, &dwBytesWritten, NULL))
				{
					goto ERRORS;
				}
			}
		}

		ZeroMemory(Buffer, sizeof Buffer);
		if (_tcscmp(GlobalPolicy.AllowMicrosoftResponse,_T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("%s%s\r\n"), ALLOW_EXTERNAL_PREFIX, GlobalPolicy.AllowMicrosoftResponse )!= S_OK)
			{
				goto ERRORS;
			}
			else
			{
				if (!WriteFile(hFile, Buffer, _tcslen(Buffer) *sizeof TCHAR, &dwBytesWritten, NULL))
				{
					goto ERRORS;
				}
			}
		}

		ZeroMemory(Buffer, sizeof Buffer);
		if (_tcscmp(GlobalPolicy.CabsPerBucket,_T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("%s%s\r\n"), CRASH_PERBUCKET_PREFIX, GlobalPolicy.CabsPerBucket )!= S_OK)
			{
				goto ERRORS;
			}
			else
			{
				if (!WriteFile(hFile, Buffer, _tcslen(Buffer) *sizeof TCHAR, &dwBytesWritten, NULL))
				{
					goto ERRORS;
				}
			}
		}

		ZeroMemory(Buffer, sizeof Buffer);
		if (_tcscmp(GlobalPolicy.RedirectFileServer,_T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("%s%s\r\n"), FILE_TREE_ROOT_PREFIX, GlobalPolicy.RedirectFileServer )!= S_OK)
			{
				goto ERRORS;
			}
			else
			{
				if (!WriteFile(hFile, Buffer, _tcslen(Buffer) *sizeof TCHAR, &dwBytesWritten, NULL))
				{
					goto ERRORS;
				}
			}
		}

		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
		RefreshUserMode(hUserMode);
		return TRUE;
	}	
ERRORS:
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);
	return FALSE;

}

BOOL InitEditPolicyDlg (HWND hwnd, HWND hMode, BOOL bUserMode,  BOOL bGlobal)
{
	HWND hList = NULL;
	int  sel   = 0;
	PUSER_DATA pUserData = NULL;
	LVITEM lvi;
	if (bUserMode)
	{
		hList = GetDlgItem(hUserMode, IDC_USER_LIST);
		sel = ListView_GetNextItem(hList,-1, LVNI_SELECTED);
		lvi.iItem = sel;
		lvi.mask = LVIF_PARAM;
		ListView_GetItem(hList, &lvi);
		sel = lvi.lParam;
		pUserData = cUserData.GetEntry(sel);
		if (!pUserData)
		{
			goto ERRORS;
		}
	}
	if (bGlobal)
	{
        if (_tcscmp (GlobalPolicy.AllowBasic, _T("YES")))
		{
			CheckDlgButton(hwnd, IDC_CHECK1,TRUE);
		}

		if (_tcscmp (GlobalPolicy.AllowAdvanced, _T("YES")))
		{
			CheckDlgButton(hwnd, IDC_CHECK2,TRUE);
		}
		
		if (_tcscmp (GlobalPolicy.AllowMicrosoftResponse, _T("YES")))
		{
			CheckDlgButton(hwnd, IDC_CHECK3,TRUE);
			
		}
		
		if (!_tcscmp (GlobalPolicy.EnableCrashTracking, _T("YES")))
		{
			CheckDlgButton(hwnd, IDC_CHECK4,TRUE);
			
		}

		SetDlgItemText(hwnd, IDC_EDIT1, GlobalPolicy.CustomURL);
		SetDlgItemText(hwnd, IDC_EDIT2, GlobalPolicy.RedirectFileServer);
		SetDlgItemText(hwnd, IDC_EDIT3, GlobalPolicy.CabsPerBucket);
	}
	else
	{
		// Get the selected bucket.
		if (bUserMode)
		{
			if (pUserData)
			{
				if (_tcscmp (pUserData->Status.SecondLevelData, _T("YES")))
				{
					CheckDlgButton(hwnd, IDC_CHECK1,TRUE);
				}

				if (_tcscmp (pUserData->Status.FileCollection, _T("YES")))
				{
					CheckDlgButton(hwnd, IDC_CHECK2,TRUE);
				}
				
				if (_tcscmp (pUserData->Status.AllowResponse, _T("YES")))
				{
					CheckDlgButton(hwnd, IDC_CHECK3,TRUE);
					
				}
				
				if (!_tcscmp (pUserData->Status.Tracking, _T("YES")))
				{
					CheckDlgButton(hwnd, IDC_CHECK4,TRUE);
					
				}
			
				SetDlgItemText(hwnd, IDC_EDIT1, pUserData->Status.UrlToLaunch);
				SetDlgItemText(hwnd, IDC_EDIT3, pUserData->Status.CrashPerBucketCount);
			}
			
		}
		else
		{
			// we only have one status file location for Bluescreens

			if (_tcscmp (CsvContents.KrnlPolicy.SecondLevelData, _T("YES")))
			{
				CheckDlgButton(hwnd, IDC_CHECK1,TRUE);
			}

			if (_tcscmp (CsvContents.KrnlPolicy.FileCollection, _T("YES")))
			{
				CheckDlgButton(hwnd, IDC_CHECK2,TRUE);
			}
			
			if (_tcscmp (CsvContents.KrnlPolicy.AllowResponse, _T("YES")))
			{
				CheckDlgButton(hwnd, IDC_CHECK3,TRUE);
				
			}
			
			if (!_tcscmp (CsvContents.KrnlPolicy.Tracking, _T("YES")))
			{
				CheckDlgButton(hwnd, IDC_CHECK4,TRUE);
				
			}
		
			SetDlgItemText(hwnd, IDC_EDIT1, CsvContents.KrnlPolicy.UrlToLaunch);
			SetDlgItemText(hwnd, IDC_EDIT3, CsvContents.KrnlPolicy.CrashPerBucketCount);

		}
			
	}
	return TRUE;
ERRORS:
	return FALSE;
}



BOOL GetSelPolicyDlgData(BOOL bUserMode, HWND hwnd)
{
	PUSER_DATA pUserData = NULL;
	HWND       hList = NULL;
	int		   sel = 0;
	LVITEM lvi;
	TCHAR      TempBuffer[MAX_PATH];
	TCHAR      *pTchar = NULL;
	ZeroMemory (TempBuffer, sizeof TempBuffer);
	if (bUserMode)
	{
		hList = GetDlgItem(hUserMode, IDC_USER_LIST);
		sel = ListView_GetNextItem(hList,-1, LVNI_SELECTED);
		lvi.iItem = sel;
		lvi.mask = LVIF_PARAM;
		ListView_GetItem(hList, &lvi);
		sel = lvi.lParam;
		pUserData = cUserData.GetEntry(sel);
	
		if (!pUserData)
		{
			goto ERRORS;
		}
	}

	// read the contents of the dialog box into the global policy structure.
	if (IsDlgButtonChecked(hwnd, IDC_CHECK1))
	{
		if (bUserMode)
		{
			if (StringCbCopy(pUserData->Status.SecondLevelData, sizeof pUserData->Status.SecondLevelData, _T("NO") )!= S_OK)
			{
				goto ERRORS;
			}
		}
		else
		{
			if (StringCbCopy(CsvContents.KrnlPolicy.SecondLevelData, sizeof CsvContents.KrnlPolicy.SecondLevelData, _T("NO") )!= S_OK)
			{
				goto ERRORS;
			}
		}
	}
	else
	{
		if (bUserMode)
		{
			if (StringCbCopy(pUserData->Status.SecondLevelData, sizeof pUserData->Status.SecondLevelData, _T("YES") )!= S_OK)
			{
				goto ERRORS;
			}
		}
		else
		{
			if (StringCbCopy(CsvContents.KrnlPolicy.SecondLevelData, sizeof CsvContents.KrnlPolicy.SecondLevelData, _T("YES") )!= S_OK)
			{
				goto ERRORS;
			}

		}
	}
	
	if (IsDlgButtonChecked(hwnd, IDC_CHECK2))
	{
		if (bUserMode)
		{
			if (StringCbCopy(pUserData->Status.FileCollection, sizeof pUserData->Status.FileCollection, _T("NO") )!= S_OK)
			{
				goto ERRORS;
			}
		}
		else
		{
			if (StringCbCopy(CsvContents.KrnlPolicy.FileCollection, sizeof CsvContents.KrnlPolicy.FileCollection, _T("NO") )!= S_OK)
			{
				goto ERRORS;
			}
		}
	}
	else
	{
		if (bUserMode)
		{
			if (StringCbCopy(pUserData->Status.FileCollection, sizeof pUserData->Status.FileCollection, _T("YES") )!= S_OK)
			{
				goto ERRORS;
			}
		}
		else
		{
			if (StringCbCopy(CsvContents.KrnlPolicy.FileCollection, sizeof CsvContents.KrnlPolicy.FileCollection, _T("YES") )!= S_OK)
			{
				goto ERRORS;
			}

		}
	}
	
	if (IsDlgButtonChecked(hwnd, IDC_CHECK3))
	{
		if (bUserMode)
		{
			if (StringCbCopy(pUserData->Status.AllowResponse, sizeof pUserData->Status.AllowResponse, _T("NO") )!= S_OK)
			{
				goto ERRORS;
			}
		}
		else
		{
			if (StringCbCopy(CsvContents.KrnlPolicy.AllowResponse, sizeof CsvContents.KrnlPolicy.AllowResponse, _T("NO") )!= S_OK)
			{
				goto ERRORS;
			}
		}
	}
	else
	{
		if (bUserMode)
		{
			if (StringCbCopy(pUserData->Status.AllowResponse, sizeof pUserData->Status.AllowResponse, _T("YES") )!= S_OK)
			{
				goto ERRORS;
			}
		}
		else
		{
			if (StringCbCopy(CsvContents.KrnlPolicy.AllowResponse, sizeof CsvContents.KrnlPolicy.AllowResponse, _T("YES") )!= S_OK)
			{
				goto ERRORS;
			}
		}
	}

	
	if (IsDlgButtonChecked(hwnd, IDC_CHECK4))
	{
		if (bUserMode)
		{
			if (StringCbCopy(pUserData->Status.Tracking, sizeof pUserData->Status.Tracking, _T("YES") )!= S_OK)
			{
				goto ERRORS;
			}
		}
		else
		{
			if (StringCbCopy(CsvContents.KrnlPolicy.Tracking, sizeof CsvContents.KrnlPolicy.Tracking, _T("YES") )!= S_OK)
			{
				goto ERRORS;
			}
		}
	}
	else
	{
		if (bUserMode)
		{
			if (StringCbCopy(pUserData->Status.Tracking, sizeof pUserData->Status.Tracking, _T("NO") )!= S_OK)
			{
				goto ERRORS;
			}
		}
		else
		{
			if (StringCbCopy(CsvContents.KrnlPolicy.Tracking, sizeof CsvContents.KrnlPolicy.Tracking, _T("NO") )!= S_OK)
			{
				goto ERRORS;
			}

		}
	}
	
	if (bUserMode)
	{
		// fill temp buffer with string 
		GetDlgItemText(hwnd, IDC_EDIT1,TempBuffer, sizeof TempBuffer / sizeof TCHAR); 
		pTchar = TempBuffer;
		while ( ( (*pTchar == _T(' ')) || (*pTchar == _T('\t')) ) && (*pTchar != _T('\0')))
		{
			++pTchar;
		}
		if (StringCbCopy(pUserData->Status.UrlToLaunch, sizeof pUserData->Status.UrlToLaunch, pTchar) != S_OK)
		{
			goto ERRORS;
		}

		
		GetDlgItemText(hwnd, IDC_EDIT3, pUserData->Status.CrashPerBucketCount, sizeof pUserData->Status.CrashPerBucketCount / sizeof TCHAR); 
		
	}
	else
	{
		GetDlgItemText(hwnd, IDC_EDIT1,TempBuffer, sizeof TempBuffer / sizeof TCHAR); 
		pTchar = TempBuffer;
		while ( ( (*pTchar == _T(' ')) || (*pTchar == _T('\t')) ) && (*pTchar != _T('\0')))
		{
			++pTchar;
		}
		if (StringCbCopy(CsvContents.KrnlPolicy.UrlToLaunch, sizeof CsvContents.KrnlPolicy.UrlToLaunch, pTchar) != S_OK)
		{
			goto ERRORS;
		}

		//GetDlgItemText(hwnd, IDC_EDIT1, CsvContents.KrnlPolicy.UrlToLaunch, sizeof CsvContents.KrnlPolicy.UrlToLaunch / sizeof TCHAR); 
		GetDlgItemText(hwnd, IDC_EDIT3, CsvContents.KrnlPolicy.CrashPerBucketCount, sizeof CsvContents.KrnlPolicy.CrashPerBucketCount / sizeof TCHAR); 
	}
    	return TRUE;
ERRORS:
		return FALSE;
}



LRESULT CALLBACK EditSelectedDlgProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	LVITEM lvi;
	switch (iMsg)
	{
	case WM_INITDIALOG:
		if (ReportMode==USER_MODE)
		{
			InitEditPolicyDlg (hwnd, hUserMode,TRUE,FALSE);
		}
		else
		{
			InitEditPolicyDlg (hwnd, hKrnlMode, FALSE,FALSE);
		}
		return TRUE;
	case WM_DESTROY:
		EndDialog(hwnd, TRUE);
	return TRUE;
	case WM_COMMAND:
		{
			switch (LOWORD(wParam))
			{
			case IDOK:
				if (ReportMode == USER_MODE)
				{
					GetSelPolicyDlgData(TRUE, hwnd);
					
					PUSER_DATA pUserData;
					HWND       hList = NULL;
					int		   sel = 0;
					hList = GetDlgItem(hUserMode, IDC_USER_LIST);
					sel = ListView_GetNextItem(hList,-1, LVNI_SELECTED);
					lvi.iItem = sel;
					lvi.mask = LVIF_PARAM;
					ListView_GetItem(hList, &lvi);
					sel = lvi.lParam;
					pUserData = cUserData.GetEntry(sel);
				
					if (!pUserData)
					{
						return TRUE;
					}
					
					WriteStatusFile(pUserData);

				}
				else
				{
					GetSelPolicyDlgData(FALSE, hwnd);
					WriteKernelStatusFile();
				}
				EndDialog(hwnd, TRUE);
				return TRUE;
			case IDCANCEL:
				EndDialog(hwnd, TRUE);
			}
		}
		break;
	
	default:
		break;
	}
	return FALSE;
	
}

BOOL GetPolicyDlgData(HWND hwnd)
{
	TCHAR *pTchar = NULL;
	TCHAR TempBuffer[MAX_PATH];
	ZeroMemory(TempBuffer, sizeof TempBuffer);
	// read the contents of the dialog box into the global policy structure.
	if (IsDlgButtonChecked(hwnd, IDC_CHECK1))
	{
		
		if (StringCbCopy(GlobalPolicy.AllowBasic, sizeof GlobalPolicy.AllowBasic, _T("NO") )!= S_OK)
		{
			goto ERRORS;
		}
	}
	else
	{
		if (StringCbCopy(GlobalPolicy.AllowBasic, sizeof GlobalPolicy.AllowBasic, _T("YES") )!= S_OK)
		{
			goto ERRORS;
		}
	}
	
	if (IsDlgButtonChecked(hwnd, IDC_CHECK2))
	{
		if (StringCbCopy(GlobalPolicy.AllowAdvanced, sizeof GlobalPolicy.AllowAdvanced, _T("NO") )!= S_OK)
		{
			goto ERRORS;
		}
	}
	else
	{
		if (StringCbCopy(GlobalPolicy.AllowAdvanced, sizeof GlobalPolicy.AllowAdvanced, _T("YES") )!= S_OK)
		{
			goto ERRORS;
		}
	}
	
	if (IsDlgButtonChecked(hwnd, IDC_CHECK3))
	{
		if (StringCbCopy(GlobalPolicy.AllowMicrosoftResponse, sizeof GlobalPolicy.AllowMicrosoftResponse, _T("NO") )!= S_OK)
		{
			goto ERRORS;
		}
	}
	else
	{
		if (StringCbCopy(GlobalPolicy.AllowMicrosoftResponse, sizeof GlobalPolicy.AllowMicrosoftResponse, _T("YES") )!= S_OK)
		{
			goto ERRORS;
		}
	}

	
	if (IsDlgButtonChecked(hwnd, IDC_CHECK4))
	{
		if (StringCbCopy(GlobalPolicy.EnableCrashTracking, sizeof GlobalPolicy.EnableCrashTracking, _T("YES") )!= S_OK)
		{
			goto ERRORS;
		}
	}
	else
	{
		if (StringCbCopy(GlobalPolicy.EnableCrashTracking, sizeof GlobalPolicy.EnableCrashTracking, _T("NO") )!= S_OK)
		{
			goto ERRORS;
		}
	}
	GetDlgItemText(hwnd, IDC_EDIT1,TempBuffer, sizeof TempBuffer / sizeof TCHAR); 
	pTchar = TempBuffer;
	while ( ( (*pTchar == _T(' ')) || (*pTchar == _T('\t')) ) && (*pTchar != _T('\0')))
	{
		++pTchar;
	}
	if (StringCbCopy(GlobalPolicy.CustomURL, sizeof GlobalPolicy.CustomURL, pTchar) != S_OK)
	{
		goto ERRORS;
	}
	//GetDlgItemText(hwnd, IDC_EDIT1, GlobalPolicy.CustomURL, sizeof GlobalPolicy.CustomURL / sizeof TCHAR); 
	GetDlgItemText(hwnd, IDC_EDIT2, GlobalPolicy.RedirectFileServer, sizeof GlobalPolicy.RedirectFileServer / sizeof TCHAR); 
	GetDlgItemText(hwnd, IDC_EDIT3, GlobalPolicy.CabsPerBucket, sizeof GlobalPolicy.CabsPerBucket / sizeof TCHAR); 

		return TRUE;
ERRORS:
		return FALSE;
}

LRESULT CALLBACK EditDefaultDlgProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	switch (iMsg)
	{
	case WM_INITDIALOG:
		InitEditPolicyDlg (hwnd,NULL,FALSE, TRUE);
		return TRUE;

	case WM_DESTROY:
		EndDialog(hwnd,  TRUE);
		return TRUE;

	case WM_COMMAND:
		{
			switch (LOWORD(wParam))
			{
			case IDOK:
				if (GetPolicyDlgData(hwnd))
				{
					WriteGlobalPolicyFile();
				}
				else
					; // What message do we want to display here.
				EndDialog(hwnd, TRUE);
				break;
			case IDCANCEL:
				EndDialog(hwnd, TRUE);
				break;

			}
		}
		break;
	
	default:
		break;
	}
	return FALSE;
}

void DoEditSelectedBucketPolicy(HWND hwnd)
{
	if (!DialogBox(g_hinst, MAKEINTRESOURCE(IDD_BUCKET_POLICY), hwnd, (DLGPROC) EditSelectedDlgProc))
	{
		; //MessageBox(NULL, "FAILED TO LOAD TREE", NULL, MB_OK);
	
	}
}

void DoEditDefaultPolicy(HWND hwnd)
{

	if (!DialogBox(g_hinst, MAKEINTRESOURCE(IDD_GLOBAL_POLICY), hwnd, (DLGPROC) EditDefaultDlgProc))
	{
		; //MessageBox(NULL, "FAILED TO LOAD TREE", NULL, MB_OK);
	
	}
	
	
}

LRESULT CALLBACK MainDlgProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	TCHAR szPath[MAX_PATH];
	HMENU hMenu = NULL;
	switch (iMsg)
	{
	case WM_INITDIALOG:
		OnDlgInit(hwnd);
		return TRUE;
		case WM_DESTROY:
		case WM_CLOSE:
			PostQuitMessage(0);
			return TRUE;
		case WM_COMMAND:
			{
				switch (LOWORD(wParam))
				{
				case ID_FILE_MRU1:
				case ID_FILE_MRU2:
				case ID_FILE_MRU3:
				case ID_FILE_MRU4:
					g_bFirstBucket = TRUE;
					g_bAdminAccess = TRUE;
					ZeroMemory(szPath, sizeof szPath);
					cUserData.CleanupList();
					CsvContents.CleanupList();
					hMenu = GetMenu(hwnd);
					if (hMenu)
					{
						GetMenuStringA(hMenu, LOWORD(wParam), szPath, MAX_PATH, MF_BYCOMMAND);
						if (_tcslen (szPath) > 4)
						{
							if (DoLoadFileTree(hwnd, szPath + 4, FALSE))
							{
								if (ReportMode == USER_MODE)
								{
									DoUserMode(hwnd);
								}
								else
								{
									DoKernelMode(hwnd);
								}
								EnableMenuItems(hwnd);
							}
						}
						//RefreshUserMode(hUserMode);
						//RefreshKrnlView(hKrnlMode);
					}
					break;
				case IDC_KRNLMODE:
					DoKernelMode(hwnd);
					return TRUE;
				case IDC_USERMODE:
					DoUserMode(hwnd);
					return TRUE;
				case ID_REPORT_USERMODEFAULTS:
					ReportUserModeFault(hUserMode, FALSE,0);
					RefreshUserMode(hUserMode);
					return TRUE;

				case ID_REPORT_SELECTEDFAULTS:
					if (ReportMode==USER_MODE)
					{
						ReportUserModeFault(hUserMode, TRUE, GetDlgItem(hUserMode,IDC_USER_LIST));
						RefreshUserMode(hUserMode);
					}
					return TRUE;

				case ID_REPORT_KERNELMODEFAULTS:
					DoSubmitKernelFaults(hKrnlMode);
					return TRUE;
				case ID_FILE_LOADFILETREE:
					g_bFirstBucket = TRUE;
					g_bAdminAccess = TRUE;
					if (DoLoadFileTree(hwnd, NULL, TRUE))
					{
						if (ReportMode == USER_MODE)
						{
							DoUserMode(hwnd);
						}
						else
						{
							DoKernelMode(hwnd);
						}
						EnableMenuItems(hwnd);
					}
					//RefreshUserMode(hUserMode);
					//RefreshKrnlView(hKrnlMode);
					return TRUE;
				case ID_VIEW_REFRESH:
					if (ReportMode == KERNEL_MODE)
						RefreshKrnlView(hKrnlMode);
					else
						RefreshUserMode(hUserMode);
					return TRUE;
				case ID_EDIT_DEFAULTPOLICY:
					DoEditDefaultPolicy(hwnd);
					return TRUE;
				case ID_EDIT_SELECTEDBUCKETSPOLICY:
					if (ReportMode==USER_MODE)
					{
						if (ListView_GetSelectedCount(GetDlgItem(hUserMode, IDC_USER_LIST)) == 1)
						{
							DoEditSelectedBucketPolicy(hwnd);
							RefreshUserMode(hUserMode);
						}
						else
						{
							// what error do we want to display here.
						}
                    }
					else
					{
						DoEditSelectedBucketPolicy(hwnd);
						RefreshKrnlView(hKrnlMode);
					}
					return TRUE;
				case ID_VIEW_CRASHLOG:
					ViewCrashLog();
					return TRUE;
				case ID_REPORT_ALLCRASHES:
					ReportUserModeFault(hUserMode, FALSE,0);
					RefreshUserMode(hUserMode);
					DoSubmitKernelFaults(hKrnlMode);
					return FALSE;
				case ID_FILE_CREATEFILETREE:
					DoCreateFileTree(hwnd);
					return TRUE;
				case ID_HELP_ABOUT:
					if (!DialogBox(g_hinst, MAKEINTRESOURCE(IDD_ABOUT), hwnd, (DLGPROC) AboutDlgProc))
					{
						; //MessageBox(NULL, "FAILED TO LOAD TREE", NULL, MB_OK);
					
					}
					break;
				case ID_HELP_INDEX120:
					OpenHelpIndex(_T(""));
					break;
				case ID_HELP_CONTENTS:
					OpenHelpTopic(0);
					break;

				/*case ID_EDIT_COPY115:
					if (ReportMode==KERNEL_MODE)
					{
						PostMessage(hKrnlMode, WM_COMMAND, MAKEWPARAM(ID_EDIT_COPY147,0), 0);
					}
					else
					{
						PostMessage(hUserMode, WM_COMMAND, MAKEWPARAM(ID_EDIT_COPY144,0),0);
					}
					break;
					*/
				case ID_VIEW_BUCKETCABFILEDIRECTORY:
					if (ReportMode==KERNEL_MODE)
					{
						PostMessage(hKrnlMode, WM_COMMAND, MAKEWPARAM(ID_VIEW_BUCKETCABFILEDIRECTORY,0), 0);
					}
					else
					{
						PostMessage(hUserMode, WM_COMMAND, MAKEWPARAM(ID_VIEW_BUCKETCABFILEDIRECTORY157,0),0);
					}
					break;
				case ID_VIEW_BUCKETOVERRIDERESPONSE:
					if (ReportMode==USER_MODE )
						ViewResponse(hUserMode, FALSE);
					else
						DoLaunchBrowser(hKrnlMode, TRUE);
					break;
				case ID_VIEW_RESPONSESELECTED:
					if (ReportMode==USER_MODE)
						ViewResponse(hUserMode, TRUE);
					else
						DoLaunchBrowser(hKrnlMode, FALSE);
					break;
				case ID_FILE_RELOADFILETREE:
					g_bFirstBucket = TRUE;
					g_bAdminAccess = TRUE;
					cUserData.CleanupList();
					CsvContents.CleanupList();
					if (DoLoadFileTree(hwnd, CerRoot, FALSE))
					{
						EnableMenuItems(hwnd);
					}
					
					break;
				case ID_FILE_EXIT:
					PostQuitMessage(0);
					break;
				case ID_EXPORT_USERMODEBUCKETDATA:
						ExportUserModeData(hwnd);
					break;
				case ID_EXPORT_KERNELMODEFAULTDATA:
						ExportKernelModeData(hwnd);
					break;
				default:
					break;
				}
			}
			return FALSE;

		case WM_SIZE:
			ResizeKrlMode(hKrnlMode);
			ResizeUserMode(hUserMode);
			
			return TRUE;
		case WM_ERASEBKGND:
		// Don't know why this doesn't happen automatically...
			{
			HDC hdc = (HDC)wParam;
			HPEN hpen = (HPEN)CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNFACE));
			HPEN hpenOld = (HPEN)SelectObject(hdc, hpen);
			SelectObject(hdc, GetSysColorBrush(COLOR_BTNFACE));
			RECT rc;
			GetClientRect(hwnd, &rc);
			Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
			SelectObject(hdc, hpenOld);
			DeleteObject(hpen);
			return TRUE;
			}

	}
	return FALSE;
}


/*----------------------------------------------------------------------------
	DragWndProcV

	Window Proc for Vertical Drag Control -- UNICODE WndProc
----------------------------------------------------------------- MichMarc --*/
LRESULT CALLBACK DragWndProcV(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	switch(iMsg)
		{
	case WM_CREATE:
		return 0;

	case WM_PAINT:
		{
		PAINTSTRUCT ps;

		HDC hdc = BeginPaint(hwnd, &ps);

		HPEN hpenOld = (HPEN)SelectObject(hdc, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_ACTIVEBORDER)));
		MoveToEx(hdc, ps.rcPaint.left, 0, NULL);
		LineTo(hdc, ps.rcPaint.right,0);
		MoveToEx(hdc, ps.rcPaint.left, 2, NULL);
		LineTo(hdc, ps.rcPaint.right,2);
		MoveToEx(hdc, ps.rcPaint.left, 3, NULL);
		LineTo(hdc, ps.rcPaint.right,3);

		DeleteObject(SelectObject(hdc, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DHIGHLIGHT))));
		MoveToEx(hdc, ps.rcPaint.left, 1, NULL);
		LineTo(hdc, ps.rcPaint.right,1);

		DeleteObject(SelectObject(hdc, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW))));
		SelectObject(hdc, GetSysColorBrush(COLOR_3DLIGHT));
		MoveToEx(hdc, ps.rcPaint.left, 4, NULL);
		LineTo(hdc, ps.rcPaint.right,4);

		DeleteObject(SelectObject(hdc, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DDKSHADOW))));
		SelectObject(hdc, GetSysColorBrush(COLOR_3DLIGHT));
		MoveToEx(hdc, ps.rcPaint.left, 5, NULL);
		LineTo(hdc, ps.rcPaint.right,5);

		DeleteObject(SelectObject(hdc, hpenOld));
		EndPaint(hwnd, &ps);
		return 0;
		}

	case WM_LBUTTONDOWN:
		PostMessage(GetParent(hwnd), WM_COMMAND, GetWindowLong(hwnd, GWL_ID), (LPARAM)hwnd);
		return 0;				
		}
	return DefWindowProcW(hwnd, iMsg, wParam, lParam);
};
/*---------------------------------------------------------------------------
	InitWindowClasses

	Registers custom window classes
--------------------------------------------------------------- MichMarc --*/
/*void InitWindowClasses(void)
{
	WNDCLASSEXW wc;

	wc.cbSize = sizeof(WNDCLASSEXW);
	wc.style = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc = DragWndProcV;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	wc.hInstance = g_hinst;
	wc.hIcon = NULL;
	wc.hCursor = LoadCursor(NULL, IDC_SIZENS);
	wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
	wc.lpszMenuName = NULL;
	wc.lpszClassName = L"DragControlV";
	wc.hIconSm = NULL;

	RegisterClassExW(&wc);	

	wc.cbSize = sizeof(WNDCLASSEXW);
	wc.style = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc = DragWndProcH;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	wc.hInstance = vhintl;
	wc.hIcon = NULL;
	wc.hCursor = LoadCursor(NULL, IDC_SIZENS);
	wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
	wc.lpszMenuName = NULL;
	wc.lpszClassName = L"DragControlH";
	wc.hIconSm = NULL;

	RegisterClassExW(&wc);
	
}
	*/
int WINAPI WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR szCmdLine,
						 int nShowCmd)
{
	MSG msg;
	HWND hwnd = NULL;
	g_hinst = hinst;

	INITCOMMONCONTROLSEX InitCtrls;
	InitCommonControlsEx(&InitCtrls);
	//InitWindowClasses();
	
	LoadIcon(hinst, MAKEINTRESOURCE(IDI_MAIN));
	hwnd = CreateDialog(g_hinst,
						MAKEINTRESOURCE(IDD_MAIN),
						NULL, 
						(DLGPROC)MainDlgProc);
	g_hWnd = hwnd;
	if (hwnd)
	{
		while(GetMessageW(&msg, NULL, 0, 0))
			//if (!TranslateAcceleratorW(hwnd, hAccel, &msg))
				if (!IsDialogMessageW(hwnd, &msg))
				{
					TranslateMessage(&msg);
					DispatchMessageW(&msg);
				}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\cer\cw15\reportfault.h ===
#ifndef _REPORT_FAULT_H
#define _REPORT_FAULT_H

BOOL 
ParseStage1File(BYTE *Stage1HtmlContents, 
				PSTATUS_FILE StatusContents);

BOOL 
ParseStage2File(BYTE *Stage2HtmlContents, 
				PSTATUS_FILE StatusContents);

BOOL 
ProcessStage1(TCHAR *Stage1URL, 
			  PSTATUS_FILE StatusContents);

BOOL 
ProcessStage2(TCHAR *Stage2URL,
				   BOOL b64Bit,
				   PSTATUS_FILE StatusContents);

BOOL 
ProcessStage3(TCHAR *Stage3Request);

BOOL 
ProcessStage4(TCHAR *Stage4URL);

BOOL 
WriteStatusFile(PUSER_DATA UserData);

void 
RenameUmCabToOld(TCHAR *szFileName);

BOOL 
RenameAllCabsToOld(TCHAR *szPath);

BOOL
ReportUserModeFault(HWND hwnd, BOOL bSelected, HWND hList);




#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\cer\cw15\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by Script1.rc
//
#define MANIFEST_RESOURCE_ID            1
#define IDOK2                           3
#define IDCANCEL3                       3
#define IDCANCEL2                       4
#define ID_FILE_MRU1                    101
#define ID_FILE_MRU2                    102
#define ID_FILE_MRU3                    103
#define IDD_MAIN                        104
#define ID_FILE_MRU4                    104
#define IDD_KERNEL_MODE                 105
#define IDD_USER_MODE                   108
#define IDR_MAINMENU                    110
#define IDD_LOAD                        111
#define IDR_KRNLCONTEXT                 112
#define IDD_KERNEL_SYNC                 113
#define ID_VIEW_REFRESH                 114
#define ID_EDIT_COPY115                 115
#define ID_VIEW_CRASHLOG                117
#define ID_REPORT_USERMODEFAULTS        118
#define ID_REPORT_KERNELMODEFAULTS      119
#define ID_HELP_INDEX120                120
#define ID_VIEW_REFRESH121              121
#define ID_POPUP_REPORT                 122
#define ID_REPORT_SELECTEDFAULTS        123
#define ID_Menu                         124
#define ID_VIEW_BUCKETCABFILEDIRECTORY125 125
#define IDR_USERCONTEXT                 126
#define ID_REPORT                       127
#define ID_POPUP_REPORT128              128
#define ID_REPORT_SELECTEDBUCKET        129
#define IDD_ABOUT                       130
#define ID_POPUP_VIEW                   132
#define ID_VIEW_MICROSOFTRESPONSE       133
#define ID_VIEW_BUCKETOVERRIDERESPONSE  134
#define ID_REPORT_ALLUSERMODEFAULTS     135
#define ID_REPORT_ALL                   136
#define ID_REPORT_ALLKERNELMODEFAULTS   137
#define ID_Menu138                      138
#define ID_EDIT_USERMODEREPORTINGOPTIONS 139
#define ID_VIEW_REFRESH140              140
#define ID_EDIT_SELECTEDBUCKETREPORTINGOPTIONS 141
#define ID_POPUP_EDIT                   142
#define ID_EDIT_D                       143
#define ID_EDIT_COPY144                 144
#define ID_Menu145                      145
#define ID_POPUP_EDIT146                146
#define ID_EDIT_COPY147                 147
#define ID_EDIT_DEFAULTREPORTINGOPTIONS 148
#define ID_Menu149                      149
#define IDD_DIALOG1                     150
#define IDD_USERMODE_SYNC               150
#define IDD_GLOBAL_POLICY               151
#define IDD_BUCKET_POLICY               152
#define ID_VIEW_CRASH                   153
#define ID_VIEW_VIEWCRASHLOG            154
#define ID_VIEW_BUCKETOVERRIDERESPONSE155 155
#define ID_VIEW_BUCKETCABFILEDIRECTORY157 157
#define ID_FILE_RECENTFILETREES         158
#define ID_RECENTFILETREES_MRU          159
#define ID_RECENTFILETREES_MRU160       160
#define ID_RECENTFILETREES_MRU161       161
#define ID_RECENTFILETREES_MRU162       162
#define ID_Menu163                      163
#define ID_RECENTFILETREES_PLACEHOLDER  164
#define ID_FILE_RECENTFILETREES165      165
#define ID_VIEW_BUCKETOVERRIDERESPONSE166 166
#define ID_Menu167                      167
#define ID_EXPORT_USERMODEBUCKETDATA    168
#define ID_EXPORT_KERNELMODEFAULTDATA   169
#define ID_POPUP_EXPORT                 170
#define ID_EXPORT_USERMODEFAULTDATA     171
#define ID_EXPORT_KERNELMODEFAULTDATA172 172
#define ID_POPUP_EXPORT173              173
#define ID_EXPORT_USERMODEFAULTDATA174  174
#define ID_EXPORT_KERNELMODEFAULTDATA175 175
#define ID_Menu176                      176
#define IDI_MAIN                        179
#define IDC_KRNL_LIST                   1008
#define IDC_USERMODE                    1010
#define IDC_KRNLMODE                    1011
#define IDC_USERMODE2                   1012
#define IDC_KRNL_EDIT                   1016
#define IDC_BUCKETTEXT                  1017
#define IDC_FLTR_RESPONSE               1018
#define IDC_FLTR_MODVER_FILTER          1018
#define IDC_MODVER_FILTER               1018
#define IDC_PB                          1019
#define IDC_LOADPB                      1019
#define IDC_PROGRESS1                   1022
#define IDC_FILE_PROGRESS               1022
#define IDC_PROGRESS2                   1023
#define IDC_TOTAL_PROGRESS              1024
#define IDC_CAB_TEXT                    1025
#define IDC_COMBO1                      1026
#define IDC_APPNAME_FILTER              1026
#define IDC_COMBO2                      1027
#define IDC_APPVER_FILTER               1027
#define IDC_COMBO3                      1028
#define IDC_MODNAME_FILTER              1028
#define IDC_USER_EDIT                   1029
#define IDC_USER_LIST                   1030
#define IDC_SPIN1                       1031
#define IDC_VERSION_STRING              1032
#define IDC_COPYRIGHT_STRING            1033
#define IDC_CHECK1                      1034
#define IDC_CHECK2                      1035
#define IDC_CHECK3                      1036
#define IDC_EDIT1                       1037
#define IDC_EDIT2                       1038
#define IDC_CHECK4                      1039
#define IDC_EDIT3                       1040
#define IDC_NOTES                       1041
#define IDC_NOTESTEXT                   1042
#define IDC_SUBDIR                      1043
#define IDC_CUSTOM1                     1044
#define IDC_VERT_SLIDER                 1044
#define IDC_LIST1                       1045
#define ID_FILE_LOADFILETREE            40001
#define ID_FILE_RELOADFILETREE          40002
#define ID_FILE_CREATEFILETREE          40003
#define ID_FILE_EXPORTBUCKETS           40004
#define ID_FILE_EXPORTSELECTEDBUCKETS   40005
#define ID_FILE_EXIT                    40007
#define ID_EDIT_SELECTALL               40009
#define ID_EDIT_DEFAULTPOLICY           40010
#define ID_EDIT_SELECTEDBUCKETSPOLICY   40011
#define ID_REPORT_ALLCRASHES            40012
#define ID_REPORT_SELECTEDCRASHES       40013
#define ID_VIEW_BUCKETCABFILEDIRECTORY  40017
#define ID_VIEW_BUCKETINSTANCEDATA      40018
#define ID_VIEW_RESPONSESELECTED        40019
#define ID_HELP_CONTENTS                40020
#define ID_HELP_ABOUT                   40022
#define ID_SUBMIT_FAULTS                40026
#define ID_SPECIFIC_BUCKET              40029
#define ID_GENERAL_BUCKET               40030
#define ID_POPUP_VIEW_KERNELBUCKETPOLICY 40031

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        180
#define _APS_NEXT_COMMAND_VALUE         40033
#define _APS_NEXT_CONTROL_VALUE         1046
#define _APS_NEXT_SYMED_VALUE           105
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\cer\cw15\main.h ===
#ifndef _MAIN_H
#define _MAIN_H

#include <windows.h>
#include <Windowsx.h>
#include <commctrl.h>
#include <wininet.h>
#include <TCHAR.h>
#include <shlwapi.h>
#include <strsafe.h>
#include <Shlobj.h>
#include <shellapi.h>
#include <aclapi.h>
#include <commdlg.h>
#include "resource.h"

//#define DEBUG 1
//#define _DEBUG 1
void ViewCrashLog();
BOOL LoadMruList();
BOOL AddToMruList(HWND hwnd, TCHAR *NewEntry);
BOOL SaveMruList();
BOOL DisplayUserBucketData(HWND hwnd, int iItem);
void CenterDialogInParent(HWND hwnd);
typedef struct strMRULIST
{
	TCHAR szMRU1[MAX_PATH];
	TCHAR szMRU2[MAX_PATH];
	TCHAR szMRU3[MAX_PATH];
	TCHAR szMRU4[MAX_PATH];
} MRU_LIST, *PMRU_LIST;
const TCHAR szHttpPrefix[] = "http://";
// Needed for clipboard support
const char rtfPrologue  [] = "{\\rtf1\\ansi\\ansicpg1252\n{\\fonttbl{\\f1\\fnil Arial;}}\n\\plain\n";
const char rtfRowHeader1[] = "\\trowd \\trgaph30\\trleft-30\\trrh247 ";
const char rtfRowHeader2[] = "\\cellx";
const char rtfRowHeader3[] = "\\pard \\intbl ";
const char rtfRowPref   [] = "\\ql ";
const char rtfRowSuff   [] = "\\cell";
const char rtfRowFooter [] = "\\pard\\intbl\\row\n";
const char rtfEpilogue  [] = "}\n";
const char szRTFClipFormat[] = "Rich Text Format";
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\cer\cw15\kernelmode.cpp ===
/*++

Copyright (c) 1989  Microsoft Corporation

Module Name:

    KernelMode.cpp

Abstract:

    This module contains all code necessary to upload and process a
	Kernel mode fault through the OCA Web Site
    executive.

Author:

    Steven Beerbroer (sbeer) 20-Jun-2002

Environment:

    User mode only.

Revision History:

--*/

#include "main.h"
#include "Kernelmode.h"
#include "WinMessages.h"
#include "Clist.h"
#include "usermode.h"
#ifdef  DEBUG
#define KRNL_MODE_SERVER _T("Redbgitwb10")
#else
#define KRNL_MODE_SERVER _T("oca.microsoft.com")
#endif


extern TCHAR CerRoot[];
extern KMODE_DATA KModeData;
extern HINSTANCE g_hinst;
extern HWND hKrnlMode;
HWND   g_hListView = NULL;
BOOL   g_bSortAsc = TRUE;
HANDLE g_hStopEvent = NULL;
//Globals
HANDLE ThreadParam;
    

DWORD BucketWindowSize = 120;
DWORD TextOffset = 10;
int g_CurrentIndex = -1;
extern Clist CsvContents;
extern TCHAR szKerenelColumnHeaders[][100];
extern BOOL g_bAdminAccess;
// ListView CallBacks for sorting.


/*----------------------------------------------------------------------------	
	FMicrosoftComURL

	Returns TRUE if we think the sz is a URL to a microsoft.com web site
----------------------------------------------------------------- MRuhlen --*/
BOOL IsMicrosoftComURL(TCHAR *sz)
{
	TCHAR *pch;
	
	if (sz == NULL || _tcslen(sz) < 20)  // "http://microsoft.com
		return FALSE;
		
	if (_tcsncicmp(sz, szHttpPrefix, _tcslen(szHttpPrefix)))
		return FALSE;
		
	pch = sz + _tcslen(szHttpPrefix);
	
	while (*pch != _T('/') && *pch != _T('\0'))
		pch++;
		
	if (*pch == _T('\0'))
		return FALSE;
		
	// found the end of the server name
	if (_tcsncicmp(pch - strlen(_T(".microsoft.com")), _T(".microsoft.com"),_tcslen(_T(".microsoft.com"))
				  ) &&
		_tcsncicmp(pch - strlen(_T("/microsoft.com")), _T("/microsoft.com"),_tcslen(_T("/microsoft.com"))
				 ) &&
		_tcsncicmp(pch - _tcslen(_T(".msn.com")), _T(".msn.com") ,_tcslen(_T(".msn.com"))
				 )
#ifdef DEBUG
	   &&	_tcsncicmp(pch - _tcslen(_T("ocatest.msbpn.com")), _T("ocatest.msbpn.com") ,_tcslen(_T("ocatest.msbpn.com")))
	   &&   _tcsncicmp(pch - _tcslen(_T("redbgitwb10")), _T("redbgitwb10") ,_tcslen(_T("redbgitwb10"))) 

#endif
		)
		return FALSE;
		
	return TRUE;
}	


int CALLBACK CompareFunc (LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	int Result = -1;
	int SubItemIndex = (INT) lParamSort;
	int Item1, Item2;
	TCHAR String1[1000];
	TCHAR String2 [1000];

	ZeroMemory(String1, sizeof String1);
	ZeroMemory(String2, sizeof String2);
	ListView_GetItemText( g_hListView, lParam1, SubItemIndex, String1, 1000);
	ListView_GetItemText( g_hListView, lParam2, SubItemIndex, String2, 1000);
	if (! (String1 && String2) )
		return 1;


	if (lParam1 == 0)
	{
		return 0;
	}
	else
	{
		if (g_bSortAsc)   // Sort Acending
		{
			if ((lParamSort == 0) || (lParamSort == 1))
			{
				// Conver to int and compare
				Item1 = atoi(String1);
				Item2 = atoi(String2);
				if (Item1 > Item2) 
					Result = 1;
				else
					Result = -1;
			}
			else
			{
				Result = _tcsicmp(String1,String2);
			}
		}
		else						// Sort Decending
		{
			if ((lParamSort == 0) || (lParamSort == 1))
			{
				// Conver to int and compare
				Item1 = atoi(String1);
				Item2 = atoi(String2);
				if (Item1 > Item2) 
					Result = -1;
				else
					Result = 1;
			}
			else
			{
				Result = -_tcsicmp(String1,String2);
			}
		
		
		}
	}
	if (Result == 0)
		Result = -1;
	return Result; 
}

int
GetResponseUrl(
    IN  TCHAR *szWebSiteName,
    IN  TCHAR *szDumpFileName,
    OUT TCHAR *szResponseUrl
    )

/*++

Routine Description:

This routine calles the Oca_Extension.dll and returns the URL received to the caller

Arguments:

    szWebSiteName	- Name of OCA Web Site to process the dump file

    szDumpFileName	- Name of file returned from the UploadDumpFile() function

    szResponseUrl	- TCHAR string to hold the URL returned from the OCA Isapi Dll

Return value:

    0 on Success.
	Win32 Error Code on failure.
++*/

{
		TCHAR		IsapiUrl[255];
	HINTERNET	hSession			= NULL;
	TCHAR       LocalUrl[255];
	HINTERNET	hUrlFile			= NULL;
	TCHAR		buffer[255] ;
	DWORD		dwBytesRead			= 0;
	BOOL		bRead				= TRUE;
	BOOL        Status				= FALSE;
	DWORD		ResponseCode		= 0;
	DWORD		ResLength			= 255;
	DWORD		index				= 0;
	ZeroMemory (buffer,	  sizeof buffer);
	ZeroMemory (IsapiUrl, sizeof IsapiUrl);
	ZeroMemory (LocalUrl, sizeof LocalUrl);	
	if (StringCbPrintf (IsapiUrl,sizeof IsapiUrl,  _T("http://%s/isapi/oca_extension.dll?id=%s&Type=2"),szWebSiteName, szDumpFileName)!= S_OK)
	{
		// Busted
		goto ERRORS;
	}
	hSession = InternetOpen(_T("CER15"),
							 INTERNET_OPEN_TYPE_PRECONFIG,
                             NULL,
							 NULL,
							 0);
	if (hSession)
	{
		// Open the url we want to connect to.
		hUrlFile = InternetOpenUrl(hSession,
								   IsapiUrl, 
								   NULL,
								   0,
								   0,
								   0);
		if (hUrlFile)
		{
			if (HttpQueryInfo(	hUrlFile,
							HTTP_QUERY_STATUS_CODE |HTTP_QUERY_FLAG_NUMBER,
							&ResponseCode,
							&ResLength,
							&index) )
			{
				if ( (ResponseCode < 200 ) || (ResponseCode > 299))
				{
					Status = -1;
					goto ERRORS;
				}
				// Read the page returned by the isapi dll.
				if (hUrlFile)
				{
					bRead = InternetReadFile(hUrlFile,
												buffer,
												sizeof(buffer),
												&dwBytesRead);

					if (StringCbCopy (szResponseUrl, sizeof buffer, buffer) != S_OK)
					{
						Status = -1;
						goto ERRORS;
					}
					else
					{
						if (!IsMicrosoftComURL(szResponseUrl))
						{
							// Zero out the response
							ZeroMemory(szResponseUrl,MAX_PATH);
						}
						// Check the return value of the url if it is a time out stop 
						// uploading and return FALSE.
						TCHAR *pCode = _tcsstr( szResponseUrl,_T("Code="));
						if (pCode)
						{
							Status = -2;
						}
						else
						{
							Status = 0;
						}
					}
				}
				else
				{
					//MessageBox(NULL,_T("Failed to open response URL"), NULL,MB_OK);
					Status = -1;
					goto ERRORS;
				}
			}
		}
		else
		{
			Status = -1;
		}
	}
	else
	{
		Status = -1;
	}

ERRORS:
	if (Status == -1)
		MessageBox(hKrnlMode, _T("Failed to connect to the Internet.\r\nPlease verify your Internet connection."),NULL, MB_OK);
		
	if (hUrlFile)
		InternetCloseHandle(hUrlFile);
	if (hSession)
		InternetCloseHandle(hSession);
	return Status;
}


DWORD
UploadDumpFile(
    IN  TCHAR *szWebSiteName,
    IN  TCHAR *szDumpFileName,
	IN  TCHAR *szVirtualDir, 
    OUT TCHAR *szUploadedDumpFileName
    )

/*++

Routine Description:

This routine calles the Oca_Extension.dll and returns the URL received to the caller

Arguments:

    szWebSiteName	- Name of OCA Web Site to process the dump file

    szDumpFileName	- Name of file to Uploaded
	szVirtualDir	- Virtual directory to put file to.

    szResponseUrl	- TCHAR string to hold the name the file was uploaded as

Return value:

    0 on Success.
	Win32 Error Code on failure.
++*/
{
	static		const TCHAR *pszAccept[] = {_T("*.*"), 0};
//	TCHAR       RemoteFileName[MAX_PATH]; // Host/Virtualdirectory/filename
	BOOL		bRet				= FALSE;
	BOOL		UploadSuccess		= FALSE;
	DWORD		dwBytesRead			= 0;
	DWORD		dwBytesWritten		= 0;
	DWORD		ResponseCode		= 0;
	DWORD		ResLength			= 255;
	DWORD		index				= 0;
	DWORD		ErrorCode			= 0;
	HINTERNET   hSession			= NULL;
	HINTERNET	hConnect			= NULL;
	HINTERNET	hRequest			= NULL;
	INTERNET_BUFFERS   BufferIn		= {0};
	HANDLE      hFile				= INVALID_HANDLE_VALUE;
	BYTE		*pBuffer			= NULL;
	GUID		guidNewGuid;
	char		*szGuidRaw			= NULL;
	HRESULT		hResult				= S_OK;
	wchar_t		*wszGuidRaw			= NULL;
	TCHAR       DestinationName[MAX_PATH];


	CoInitialize(NULL);
	hResult = CoCreateGuid(&guidNewGuid);
	if (FAILED(hResult))
	{
		//-------------What do we send here....
		goto cleanup;
		;
	}
	else
	{
		if (UuidToStringW(&guidNewGuid, &wszGuidRaw) == RPC_S_OK)
		{
			if ( (szGuidRaw = (char *) malloc ( wcslen(wszGuidRaw)*2 )) != NULL)
			{
				// clear the memory
				ZeroMemory(szGuidRaw, wcslen(wszGuidRaw) * 2);
				wcstombs( szGuidRaw, wszGuidRaw, wcslen(wszGuidRaw));
			}
			else
			{
				ErrorCode = GetLastError();
				goto cleanup;
			}
		}
	}


	if (StringCbPrintf(DestinationName, MAX_PATH * sizeof TCHAR, _T("\\%s\\%s_%s"),szVirtualDir,szGuidRaw + 19, PathFindFileName(szDumpFileName)) != S_OK)
	{
		goto cleanup;
	}
	
	//StringCbPrintf(szUploadedDumpFileName, MAX_PATH * sizeof TCHAR, _T("%s.cab"),szGuidRaw + 19);
	if (StringCbPrintf(szUploadedDumpFileName, MAX_PATH * sizeof TCHAR, _T("%s_%s"),szGuidRaw + 19, PathFindFileName(szDumpFileName)) != S_OK)
	{
		goto cleanup;
	}

	hSession = InternetOpen(	_T("CER15"),
								INTERNET_OPEN_TYPE_PRECONFIG,
								NULL,
								NULL,
								0);
	if (!hSession)
	{
		ErrorCode = 1;
		//MessageBox(NULL, _T("Internet Open Failed"), NULL, MB_OK);
		goto cleanup;
	}

	hConnect = InternetConnect(hSession,
								szWebSiteName,
								INTERNET_DEFAULT_HTTPS_PORT,
								NULL,
								NULL,
								INTERNET_SERVICE_HTTP,
								0,
								NULL);

	if (!hConnect)
	{
		//MessageBox(NULL, _T("Internet Connect Failed"), NULL, MB_OK);
		ErrorCode = 1;
		goto cleanup;
	}
	hRequest = HttpOpenRequest(	hConnect,
								_T("PUT"),
								DestinationName, 
								NULL,
								NULL,
								pszAccept,
								INTERNET_FLAG_NEED_FILE|INTERNET_FLAG_NO_CACHE_WRITE | INTERNET_FLAG_SECURE,
								0);
	if (hRequest)
	{
		hFile = CreateFile( szDumpFileName,
							GENERIC_READ,
							FILE_SHARE_READ,
							NULL,
							OPEN_EXISTING,
							FILE_ATTRIBUTE_NORMAL,
							NULL);
						
		if (hFile != INVALID_HANDLE_VALUE)
		{
		

			// Clear the buffer
			if ( (pBuffer = (BYTE *)malloc (70000)) != NULL)
			{
				BufferIn.dwStructSize = sizeof( INTERNET_BUFFERS );
				BufferIn.Next = NULL; 
				BufferIn.lpcszHeader = NULL;
				BufferIn.dwHeadersLength = 0;
				BufferIn.dwHeadersTotal = 0;
				BufferIn.lpvBuffer = NULL;                
				BufferIn.dwBufferLength = 0;
				BufferIn.dwOffsetLow = 0;
				BufferIn.dwOffsetHigh = 0;
				BufferIn.dwBufferTotal = GetFileSize (hFile, NULL);
				FillMemory(pBuffer, 70000,'\0'); // Fill buffer with data
			
//				DWORD dwBuffLen = sizeof DWORD; 

				if(!HttpSendRequestEx(	hRequest,
										&BufferIn,
										NULL,
										HSR_INITIATE,
										0))
				{
					;
				}
				else
				{
					do
					{
						dwBytesRead = 0;
						bRet = ReadFile(hFile,
										pBuffer, 
										70000,
										&dwBytesRead,
										NULL);
						if (bRet != 0)
						{
							bRet = InternetWriteFile(hRequest,
													pBuffer,
													dwBytesRead,
													&dwBytesWritten);

							if ( (!bRet) || (dwBytesWritten==0) )
							{
								;
							}

						
						}
					} while (dwBytesRead == 70000);

					CloseHandle(hFile);
					hFile = INVALID_HANDLE_VALUE;
					bRet = HttpEndRequest(	hRequest,
											NULL, 
											0, 
											0);
					if (bRet)
					{
						ResponseCode = 0;
						HttpQueryInfo(hRequest,
									HTTP_QUERY_STATUS_CODE |HTTP_QUERY_FLAG_NUMBER,
									&ResponseCode,
									&ResLength,
									&index);
					
						if ( (ResponseCode != 200) && (ResponseCode != 201))
						{
							ErrorCode=1;
						}						
						else
						{
							ErrorCode = 0;
							UploadSuccess = TRUE;

						}
					}
					else
					{
						//MessageBox(NULL, _T("End Request Failed"), NULL, MB_OK);
						ErrorCode = 1;
					}
				}
				

			}
			else
			{
				//MessageBox(NULL, _T("Malloc  Failed"), NULL, MB_OK);
				ErrorCode = 1;
			}
		}
		else
		{
			//MessageBox(NULL, _T("File Open Failed"), NULL, MB_OK);
			ErrorCode = 3;
		}
		
	}
	else
	{
		//MessageBox(NULL, _T("Internet Open Request Failed"), NULL, MB_OK);
		ErrorCode = 1;
	}

cleanup:
	// Clean up
	if (hFile!= INVALID_HANDLE_VALUE)
	{
		CloseHandle (hFile);
		hFile = INVALID_HANDLE_VALUE;
	}

	if (hSession)
	{
		InternetCloseHandle(hSession);
		hSession = INVALID_HANDLE_VALUE;
	}
	
	if (hConnect)
	{
		InternetCloseHandle(hConnect);
		hConnect = INVALID_HANDLE_VALUE;
	}


	if (hRequest)
	{
		InternetCloseHandle(hRequest);
		hRequest = INVALID_HANDLE_VALUE;
	}
	
	if (pBuffer)
	{
		free (pBuffer);
		pBuffer = NULL;
	}

	if (wszGuidRaw)
	{
		RpcStringFreeW(&wszGuidRaw);
		wszGuidRaw = NULL;
	}
	if (szGuidRaw)
	{
		free(szGuidRaw);
		szGuidRaw = NULL;
	}
	CoUninitialize();
	return ErrorCode;
	
}

void UpdateKrnlList(HWND hwnd,
					int BucketId,
					TCHAR *BucketString,
					TCHAR *Response1,
					TCHAR *Response2,
					DWORD Count)
/*++

Routine Description:

Adds a row to the Kernel Mode list view control

Arguments:

    hwnd			- Handle of the Dialog box to be updated
    BucketID    	- The Integer ID of the Current Bucket
    Response    	- The Microsoft response for the current bucket
	Count			- The number of hits for the current bucket

Return value:

    Does not return a value
++*/
{
	LVITEM lvi;
//	TCHAR  Temp[100];
//	double ElapsedTime;
	ZeroMemory(&lvi, sizeof LVITEM);
//	TCHAR tmpbuf[128];
//	COLORREF CurrentColor;
//	HWND hEditBox;
	TCHAR TempString [50];
	TCHAR *pTchar = NULL;
	lvi.mask = LVIF_TEXT | LVIF_STATE;
	lvi.state = 0;
	lvi.stateMask = 0;

	++g_CurrentIndex;
	lvi.iItem = g_CurrentIndex ;
   // lvI.iImage = index;
	lvi.iSubItem = 0;

	if (BucketId == -2)
	{
		if (StringCbCopy(TempString, sizeof TempString, _T("Kernel Faults not reported to Microsoft")) != S_OK)
		{
			goto ERRORS;
		}
		BucketId = 0;
	}
	
	else
	{
		if (BucketId == -1)
		{
			if (StringCbCopy(TempString, sizeof TempString, _T("Invalid Dump File")) != S_OK)
			{
				goto ERRORS;
			}
		}
		else
		{
			//BucketId = 0;
			if (BucketId > 0)
			{
				if (StringCbPrintf(TempString, sizeof TempString, _T("%d"), BucketId) != S_OK)
				{
					goto ERRORS;
				}
			}
			else
			{
				// Invalid bucket id 
				goto ERRORS;
			}
		}
	}

	
	
	
	lvi.pszText = TempString;
	ListView_InsertItem(hwnd,&lvi);
	
	lvi.iSubItem = 1;
	if (StringCbPrintf(TempString, sizeof TempString, _T("%d"), Count) != S_OK)
	{
		goto ERRORS;
	}
	lvi.pszText = TempString;

	ListView_SetItem(hwnd,&lvi);
	
	lvi.iSubItem = 2;

	// if response1 = -1 use response2
	pTchar = _tcsstr(Response1, _T("sid="));
	if (pTchar)
	{
		pTchar += 4;
		if (_ttoi(pTchar) == -1)
		{
			lvi.pszText = Response2;
		}
		else
		{
			// use response1
			lvi.pszText = Response1;
		}
		ListView_SetItem(hwnd,&lvi);
	}
	
	
	

ERRORS:
	return;

}

void RefreshKrnlView(HWND hwnd)
/*++

Routine Description:

Reloads the kernel mode Cer tree data and refreshes the GUI View.

Arguments:

    hwnd			- Handle of the Dialog box to be updated
    
Return value:

    Does not return a value
++*/
{
	TCHAR BucketId[100];
	TCHAR BucketString[MAX_PATH];
	TCHAR Response1[MAX_PATH];
	TCHAR Response2[MAX_PATH]; 
	TCHAR Count[100];
//	TCHAR szPolicyText[512];
	BOOL bEOF;
	ListView_DeleteAllItems(g_hListView);
	

	g_CurrentIndex = -1;

	TCHAR	szPath[MAX_PATH];
	HANDLE	hFind = INVALID_HANDLE_VALUE;
//	HANDLE	hCsv  = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA FindData;
	CsvContents.CleanupList();
	CsvContents.ResetCurrPos();
	CsvContents.bInitialized = FALSE;
	
	if (_tcscmp(CerRoot, _T("\0")))
	{
		ZeroMemory (szPath, sizeof szPath);
		// From the filetree root goto cabs/bluescreen
		
		if (StringCbCopy(szPath, sizeof szPath, CerRoot) != S_OK)
		{
			goto ERRORS;
		}
		if (StringCbCat(szPath, sizeof szPath,  _T("\\cabs\\blue\\*.cab")) != S_OK)
		{
			goto ERRORS;
		}

		if (!PathIsDirectory(CerRoot))
		{
			MessageBox(NULL,_T("Failed to connect to the CER Tree."), NULL, MB_OK);
		}
		hFind = FindFirstFile(szPath, &FindData);
		KModeData.UnprocessedCount = 0;
		// Check to see if the blue.csv exists.
		if ( hFind != INVALID_HANDLE_VALUE)
		{
			do 
			{
				++ KModeData.UnprocessedCount;
			}	while (FindNextFile(hFind, &FindData));
			FindClose(hFind);
		}
		UpdateKrnlList(g_hListView,
						-2,
						_T("Kernel Faults not reported to Microsoft"),
						_T(""),
						_T(""),
						KModeData.UnprocessedCount);
		// Search for all unprocessed (not .old) cabs and get a count
		if (StringCbCopy(szPath, sizeof szPath, CerRoot) != S_OK)
		{
			goto ERRORS;
		}
		if (StringCbCat(szPath, sizeof szPath, _T("\\Status\\Blue\\Kernel.csv")) != S_OK)
		{
			goto ERRORS;
		}
		CsvContents.Initialize(szPath);
		CsvContents.ResetCurrPos();
		
		while (CsvContents.GetNextEntry(BucketId, 
										BucketString, 
										Response1,
										Response2, 
										Count, 
										&bEOF))
		{
			UpdateKrnlList(	g_hListView,
							_ttoi(BucketId), 
							BucketString, 
							Response1,
							Response2,
							_ttoi(Count));
		}
		
		
	
	
		// Set the kernel mode status file path
		// First make sure the direcory exists.
		
		if (StringCbPrintf(CsvContents.KernelStatusDir, sizeof CsvContents.KernelStatusDir, _T("%s\\Status\\blue"), CerRoot) != S_OK)
		{
			goto ERRORS;
		}
		if (!PathIsDirectory(CsvContents.KernelStatusDir))
		{
			CreateDirectory(CsvContents.KernelStatusDir, NULL);
		}

		if (StringCbCat(CsvContents.KernelStatusDir, sizeof CsvContents.KernelStatusDir, _T("\\status.txt")) != S_OK)
		{
			goto ERRORS;
		}
		
		
		if (PathFileExists(CsvContents.KernelStatusDir))
		{
			ParseKrnlStatusFile();
		}
	}
	SendMessage(GetDlgItem(hwnd,IDC_KRNL_EDIT ), WM_SETTEXT, NULL, (LPARAM)_T(""));
	//PopulateKrnlBucketData(hwnd);
	//SetDlgItemText(hwnd, IDC_KRNL_EDIT, szPolicyText);
ERRORS:
	return;
}


void 
OnKrnlDialogInit(
	IN HWND hwnd
	)

/*++

Routine Description:

This routine is called when the Kernel mode dialog is initialized.
1) Posisions all of the dialog box controls
2) Calls RefreshKrnlView()
Arguments:

    hwnd			- Handle of the Kernel mode dialog box
    
Return value:

    Does not return a value
++*/
{
	DWORD yOffset = 5;
	RECT rc;
	RECT rcButton;
	RECT rcDlg;
	RECT rcList;
	RECT rcStatic;
	//RECT rcCombo;

	HWND hParent = GetParent(hwnd);
	HWND hButton = GetDlgItem(hParent, IDC_USERMODE);
	
	GetClientRect(hParent, &rc);
	GetWindowRect(hButton, &rcButton);

	ScreenToClient(hButton, (LPPOINT)&rcButton.left);
	ScreenToClient(hButton, (LPPOINT)&rcButton.right);


	SetWindowPos(hwnd, HWND_TOP, rc.left + yOffset, rcButton.bottom + yOffset , rc.right - rc.left - yOffset, rc.bottom - rcButton.bottom - yOffset , 0);

	GetWindowRect(hwnd, &rcDlg);
	ScreenToClient(hwnd, (LPPOINT)&rcDlg.left);
	ScreenToClient(hwnd, (LPPOINT)&rcDlg.right);


	// Position the List View
	HWND hList = GetDlgItem(hwnd, IDC_KRNL_LIST);
	SetWindowPos(hList,NULL, rcDlg.left + yOffset, rcDlg.top , rcDlg.right - rcDlg.left - yOffset, rcDlg.bottom - BucketWindowSize - rcDlg.top  , SWP_NOZORDER);
	GetWindowRect(hList, &rcList);
	ScreenToClient(hList, (LPPOINT)&rcList.left);
	ScreenToClient(hList, (LPPOINT)&rcList.right);

	// Position the bucket info window.
	HWND hBucket2 = GetDlgItem(hwnd, IDC_BUCKETTEXT);
	SetWindowPos(hBucket2,
				 NULL, 
				 rcDlg.left + yOffset,
				 rcList.bottom + TextOffset  ,
				 0,
				 0, 
				 SWP_NOSIZE | SWP_NOZORDER);
	SetDlgItemText(hwnd, IDC_BUCKETTEXT,"Bucket Information:");
	//SetDlgItemText(hwnd, IDC_FLTR_RESPONSE, "All Responses");

	GetClientRect (hBucket2, &rcStatic);

	HWND hBucket = GetDlgItem (hwnd, IDC_KRNL_EDIT);
	SetWindowPos(hBucket,
				 NULL,
				 rcDlg.left + yOffset,
				 rcList.bottom +  TextOffset + (rcStatic.bottom - rcStatic.top)  +5,
				 rcDlg.right - rcDlg.left - yOffset, 
				 rcDlg.bottom - (rcList.bottom + TextOffset + (rcStatic.bottom - rcStatic.top)   ),
				 SWP_NOZORDER);



	
    LVCOLUMN lvc; 
    int iCol; 
 
	
	// Set the extended styles
	ListView_SetExtendedListViewStyleEx(hList,
										LVS_EX_GRIDLINES |
										LVS_EX_HEADERDRAGDROP |
										LVS_EX_FULLROWSELECT,
										LVS_EX_GRIDLINES | 
										LVS_EX_FULLROWSELECT | 
										LVS_EX_HEADERDRAGDROP);
    // Initialize the LVCOLUMN structure.
    // The mask specifies that the format, width, text, and subitem
    // members of the structure are valid. 
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM; 
     
    // Add the columns. 
    for (iCol = 0; iCol < KRNL_COL_COUNT; iCol++) 
	{ 
        lvc.iSubItem = iCol;
        lvc.pszText = szKerenelColumnHeaders[iCol];	
        lvc.cx = 100;           // width of column in pixels
        lvc.fmt = LVCFMT_LEFT;  // left-aligned column
        if (ListView_InsertColumn(hList, iCol, &lvc) == -1) 
		{
			;
		}
		
    } 
	ListView_SetColumnWidth(hList, KRNL_COL_COUNT-1, LVSCW_AUTOSIZE_USEHEADER);
 

	
	
	g_hListView = hList;
	
	RefreshKrnlView(hwnd);
}

void ResizeKrlMode(HWND hwnd)
/*++

Routine Description:

This routine handles the vertical and horizontal dialog resizing.
Arguments:

    hwnd			- Handle of the Kernel mode dialog box
    
Return value:

    Does not return a value
++*/
{
	DWORD yOffset = 5;
	RECT rc;
	RECT rcButton;
	RECT rcDlg;
	RECT rcList;
	RECT rcStatic;
	HWND hParent = GetParent(hwnd);
	HWND hButton = GetDlgItem(hParent, IDC_USERMODE);
	//HWND hCombo  = GetDlgItem(hwnd, IDC_FLTR_RESPONSE);
//	RECT rcCombo;

	
	GetClientRect(hParent, &rc);
	GetWindowRect(hButton, &rcButton);

	ScreenToClient(hButton, (LPPOINT)&rcButton.left);
	ScreenToClient(hButton, (LPPOINT)&rcButton.right);


	SetWindowPos(hwnd, HWND_TOP, rc.left + yOffset, rcButton.bottom + yOffset , rc.right - rc.left - yOffset, rc.bottom - rcButton.bottom - yOffset , 0);

	GetWindowRect(hwnd, &rcDlg);
	ScreenToClient(hwnd, (LPPOINT)&rcDlg.left);
	ScreenToClient(hwnd, (LPPOINT)&rcDlg.right);


	// Position the List View
	HWND hList = GetDlgItem(hwnd, IDC_KRNL_LIST);
	SetWindowPos(hList,NULL, rcDlg.left + yOffset, rcDlg.top , rcDlg.right - rcDlg.left - yOffset, rcDlg.bottom - BucketWindowSize - rcDlg.top  , SWP_NOZORDER);
	GetWindowRect(hList, &rcList);
	ScreenToClient(hList, (LPPOINT)&rcList.left);
	ScreenToClient(hList, (LPPOINT)&rcList.right);

	// Position the bucket info window.
	HWND hBucket2 = GetDlgItem(hwnd, IDC_BUCKETTEXT);
	SetWindowPos(hBucket2,
				 NULL, 
				 rcDlg.left + yOffset,
				 rcList.bottom + TextOffset  ,
				 0,
				 0, 
				 SWP_NOSIZE | SWP_NOZORDER);
	SetDlgItemText(hwnd, IDC_BUCKETTEXT,"Bucket Information:");
	//SetDlgItemText(hwnd, IDC_FLTR_RESPONSE, "All Responses");

	GetClientRect (hBucket2, &rcStatic);

	HWND hBucket = GetDlgItem (hwnd, IDC_KRNL_EDIT);
	SetWindowPos(hBucket,
				 NULL,
				 rcDlg.left + yOffset,
				 rcList.bottom +  TextOffset + (rcStatic.bottom - rcStatic.top)  +5,
				 rcDlg.right - rcDlg.left - yOffset, 
				 rcDlg.bottom - (rcList.bottom + TextOffset + (rcStatic.bottom - rcStatic.top)   ),
				 SWP_NOZORDER);
	

	ListView_SetColumnWidth(hList, KRNL_COL_COUNT-1, LVSCW_AUTOSIZE_USEHEADER);
}
BOOL WriteKernelStatusFile()
/*++

Routine Description:

This routine renames a proccessed cab file from .cab to .old
Arguments:

    ResponseUrl			- Microsoft response for the recently submitted dump file.
    
Return value:

    Does not return a value
++*/
{
	BOOL bStatus = FALSE;
	// move the existing status file to .old

	TCHAR szFileNameOld[MAX_PATH];
	TCHAR *Temp;
	TCHAR Buffer[1024];
	HANDLE hFile = INVALID_HANDLE_VALUE;
	DWORD dwWritten = 0;
	if (StringCbCopy(szFileNameOld,sizeof szFileNameOld, CsvContents.KernelStatusDir) != S_OK)
	{
		goto ERRORS;
	}
	Temp = szFileNameOld;
	Temp += _tcslen(szFileNameOld) * sizeof TCHAR;
	while ( (*Temp != _T('.')) && (Temp != szFileNameOld))
	{
		Temp --;
	}

	if (Temp == szFileNameOld)
	{
		goto ERRORS;
	}
	else
	{
		if (StringCbCopy (Temp,sizeof szFileNameOld , _T(".old")) != S_OK)
		{
			goto ERRORS;
		}

		if (PathFileExists(CsvContents.KernelStatusDir))
		{
			MoveFileEx(CsvContents.KernelStatusDir, szFileNameOld, TRUE);
		}
		

		// create a new status file.
	
		hFile = CreateFile(CsvContents.KernelStatusDir,
						   GENERIC_WRITE, 
						   NULL, 
						   NULL,
						   CREATE_ALWAYS, 
						   FILE_ATTRIBUTE_NORMAL,
						   NULL);

		// Write the StatusContents data to the new status file
		if (_tcscmp (CsvContents.KrnlPolicy.Tracking, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("Tracking=%s\r\n"), CsvContents.KrnlPolicy.Tracking) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}
		
		// Write the StatusContents data to the new status file
		if (_tcscmp (CsvContents.KrnlPolicy.CrashPerBucketCount, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("Crashes per bucket=%s\r\n"), CsvContents.KrnlPolicy.CrashPerBucketCount) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}

		// Write the StatusContents data to the new status file
		if (_tcscmp (CsvContents.KrnlPolicy.UrlToLaunch, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("URLLaunch=%s\r\n"), CsvContents.KrnlPolicy.UrlToLaunch)  != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}

		// Write the StatusContents data to the new status file
		if (_tcscmp (CsvContents.KrnlPolicy.SecondLevelData, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("NoSecondLevelCollection=%s\r\n"), CsvContents.KrnlPolicy.SecondLevelData) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}

		// Write the StatusContents data to the new status file
		if (_tcscmp (CsvContents.KrnlPolicy.FileCollection, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("NoFileCollection=%s\r\n"), CsvContents.KrnlPolicy.FileCollection) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}

		// Write the StatusContents data to the new status file
		if (_tcscmp (CsvContents.KrnlPolicy.Response, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("Response=%s\r\n"), CsvContents.KrnlPolicy.Response) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}

		// Write the StatusContents data to the new status file
		if (_tcscmp (CsvContents.KrnlPolicy.BucketID, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("Bucket=%s\r\n"), CsvContents.KrnlPolicy.BucketID) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}

		// Write the StatusContents data to the new status file
		if (_tcscmp (CsvContents.KrnlPolicy.RegKey, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("RegKey=%s\r\n"), CsvContents.KrnlPolicy.RegKey) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);
		}

			
		// Write the StatusContents data to the new status file
		if (_tcscmp (CsvContents.KrnlPolicy.iData, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("iData=%s\r\n"),CsvContents.KrnlPolicy.iData) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}

		// Write the StatusContents data to the new status file
		if (_tcscmp (CsvContents.KrnlPolicy.WQL, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("WQL=%s\r\n"), CsvContents.KrnlPolicy.WQL) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}

		// Write the StatusContents data to the new status file
		if (_tcscmp (CsvContents.KrnlPolicy.GetFile, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("GetFile=%s\r\n"), CsvContents.KrnlPolicy.GetFile) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}

		// Write the StatusContents data to the new status file
		if (_tcscmp (CsvContents.KrnlPolicy.GetFileVersion, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("GetFileVersion=%s\r\n"), CsvContents.KrnlPolicy.GetFileVersion) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}
		
		if (_tcscmp (CsvContents.KrnlPolicy.AllowResponse, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("NoExternalURL=%s\r\n"), CsvContents.KrnlPolicy.AllowResponse) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}
		
		
		// Close the new status file
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
		// if all ok delete the old status file.
		//DeleteFile(szFileNameOld);
	}
	
ERRORS:

	if (hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hFile);
	}
	return bStatus;
}

BOOL ParseKrnlStatusFile()
{
	FILE *pFile = NULL;
	TCHAR Buffer[100];
//	TCHAR szTempDir[MAX_PATH];
	TCHAR *Temp = NULL;
//	int   id = 0;
	ZeroMemory(Buffer,sizeof Buffer);


	pFile = _tfopen(CsvContents.KernelStatusDir, _T("r"));
	if (pFile)
	{

		// Get the Cabs Gathered Count

		if (!_fgetts(Buffer, sizeof Buffer, pFile))
		{
			goto ERRORS;
		}
		do 
		{
			// Remove \r\n and force termination of the buffer.
			Temp = Buffer;
			while ( (*Temp != _T('\r')) && (*Temp != _T('\n')) && (*Temp != _T('\0')) )
			{
				++Temp;
			}
			*Temp = _T('\0');

			Temp = _tcsstr(Buffer, BUCKET_PREFIX);
			if (Temp == Buffer)
			{
				Temp+= _tcslen(BUCKET_PREFIX);
				if (StringCbCopy(CsvContents.KrnlPolicy.BucketID, sizeof CsvContents.KrnlPolicy.BucketID, Temp) != S_OK)
				{
					goto ERRORS;
				}
				continue;
			}
			
			Temp = _tcsstr(Buffer,RESPONSE_PREFIX);
			if (Temp == Buffer)
			{
				Temp+= _tcslen(RESPONSE_PREFIX);
				if (StringCbCopy(CsvContents.KrnlPolicy.Response, sizeof CsvContents.KrnlPolicy.Response, Temp) != S_OK)
				{
					goto ERRORS;
				}
				continue;
			}
			
			Temp = _tcsstr(Buffer, URLLAUNCH_PREFIX);
			if (Temp == Buffer)
			{
				Temp+= _tcslen(URLLAUNCH_PREFIX);
				if (StringCbCopy(CsvContents.KrnlPolicy.UrlToLaunch , sizeof CsvContents.KrnlPolicy.UrlToLaunch , Temp) != S_OK)
				{
					goto ERRORS;
				}
				continue;
			}

			Temp = _tcsstr(Buffer, SECOND_LEVEL_DATA_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(SECOND_LEVEL_DATA_PREFIX);
				if (StringCbCopy(CsvContents.KrnlPolicy.SecondLevelData , sizeof CsvContents.KrnlPolicy.SecondLevelData , Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
				
			Temp = _tcsstr(Buffer, TRACKING_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(TRACKING_PREFIX);
				if (StringCbCopy(CsvContents.KrnlPolicy.Tracking , sizeof CsvContents.KrnlPolicy.Tracking , Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			
			Temp = _tcsstr(Buffer, CRASH_PERBUCKET_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(CRASH_PERBUCKET_PREFIX);
				if (StringCbCopy(CsvContents.KrnlPolicy.CrashPerBucketCount , sizeof CsvContents.KrnlPolicy.CrashPerBucketCount , Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			Temp = _tcsstr(Buffer, FILE_COLLECTION_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(FILE_COLLECTION_PREFIX);
				if (StringCbCopy(CsvContents.KrnlPolicy.FileCollection , sizeof CsvContents.KrnlPolicy.FileCollection, Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			Temp = _tcsstr(Buffer, REGKEY_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(REGKEY_PREFIX);
				if (StringCbCopy(CsvContents.KrnlPolicy.RegKey , sizeof CsvContents.KrnlPolicy.RegKey , Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			Temp = _tcsstr(Buffer, FDOC_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(FDOC_PREFIX);
				if (StringCbCopy(CsvContents.KrnlPolicy.fDoc , sizeof CsvContents.KrnlPolicy.fDoc , Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			Temp = _tcsstr(Buffer, IDATA_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(IDATA_PREFIX);
				if (StringCbCopy(CsvContents.KrnlPolicy.iData , sizeof CsvContents.KrnlPolicy.iData , Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			Temp = _tcsstr(Buffer, WQL_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(WQL_PREFIX);
				if (StringCbCopy(CsvContents.KrnlPolicy.WQL , sizeof CsvContents.KrnlPolicy.WQL , Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			Temp = _tcsstr(Buffer, GETFILE_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(GETFILE_PREFIX);
				if (StringCbCopy(CsvContents.KrnlPolicy.GetFile , sizeof CsvContents.KrnlPolicy.GetFile, Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			Temp = _tcsstr(Buffer, GETFILEVER_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(GETFILEVER_PREFIX);
				if (StringCbCopy(CsvContents.KrnlPolicy.GetFileVersion , sizeof CsvContents.KrnlPolicy.GetFileVersion , Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			Temp = _tcsstr(Buffer, MEMDUMP_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(MEMDUMP_PREFIX);
				if (StringCbCopy(CsvContents.KrnlPolicy.MemoryDump , sizeof CsvContents.KrnlPolicy.MemoryDump, Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			
			Temp = _tcsstr(Buffer, ALLOW_EXTERNAL_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(ALLOW_EXTERNAL_PREFIX);
				if (StringCbCopy(CsvContents.KrnlPolicy.AllowResponse , sizeof CsvContents.KrnlPolicy.AllowResponse, Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			
			ZeroMemory(Buffer, sizeof Buffer);
		} while (_fgetts(Buffer, sizeof Buffer, pFile));
		fclose(pFile);
		return TRUE;
	}
	else
	{
		return FALSE;
	}
ERRORS:
	if (pFile)
	{
		fclose(pFile);
	}
	return FALSE;
}



void OnKrnlContextMenu(HWND hwnd,
					   LPARAM lParam)
/*++

Routine Description:

This routine Loads and provides a message pump for the Kernel mode context menu
Arguments:

    hwnd			- Handle of the Kernel mode dialog box
	lParam			- Not Used
    
Return value:

    Does not return a value
++*/
{
	BOOL Result = FALSE;
	HMENU hMenu = NULL;
	HMENU hmenuPopup = NULL;

	int xPos, yPos;
	hMenu = LoadMenu(g_hinst, MAKEINTRESOURCE( IDR_KRNLCONTEXT));
	hmenuPopup = GetSubMenu (hMenu,0);

	



	if (!hmenuPopup)
	{
		//MessageBox(NULL,"Failed to get sub item", NULL,MB_OK);
		;
	}
	else
	{
		
		// Grey out the menu items
		EnableMenuItem (hMenu, ID_SUBMIT_FAULTS, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_REPORT_ALLKERNELMODEFAULTS, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_VIEW_BUCKETCABFILEDIRECTORY125, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_SPECIFIC_BUCKET, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_VIEW_BUCKETOVERRIDERESPONSE166, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_VIEW_CRASH, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_VIEW_REFRESH121, MF_BYCOMMAND| MF_GRAYED);
		//EnableMenuItem (hMenu, ID_EDIT_COPY147, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_POPUP_VIEW_KERNELBUCKETPOLICY, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_EDIT_DEFAULTREPORTINGOPTIONS, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_EXPORT_KERNELMODEFAULTDATA172, MF_BYCOMMAND| MF_GRAYED);
		if (_tcscmp(CerRoot, _T("\0")))
		{
			// Enable the menu items
			EnableMenuItem (hMenu, ID_SUBMIT_FAULTS, MF_BYCOMMAND| MF_ENABLED);
			EnableMenuItem (hMenu, ID_REPORT_ALLKERNELMODEFAULTS, MF_BYCOMMAND| MF_ENABLED);
			EnableMenuItem (hMenu, ID_VIEW_BUCKETCABFILEDIRECTORY125, MF_BYCOMMAND| MF_ENABLED);
			EnableMenuItem (hMenu, ID_SPECIFIC_BUCKET, MF_BYCOMMAND| MF_ENABLED);
			EnableMenuItem (hMenu, ID_VIEW_BUCKETOVERRIDERESPONSE166, MF_BYCOMMAND| MF_ENABLED);
			EnableMenuItem (hMenu, ID_VIEW_CRASH, MF_BYCOMMAND| MF_ENABLED);
			EnableMenuItem (hMenu, ID_VIEW_REFRESH121, MF_BYCOMMAND| MF_ENABLED);
			//EnableMenuItem (hMenu, ID_EDIT_COPY147, MF_BYCOMMAND| MF_ENABLED);
			EnableMenuItem (hMenu, ID_POPUP_VIEW_KERNELBUCKETPOLICY, MF_BYCOMMAND| MF_ENABLED);
			EnableMenuItem (hMenu, ID_EDIT_DEFAULTREPORTINGOPTIONS, MF_BYCOMMAND| MF_ENABLED);
		//	EnableMenuItem (hMenu, ID_EXPORT_KERNELMODEFAULTDATA172, MF_BYCOMMAND| MF_ENABLED);
			if (!g_bAdminAccess)
			{
				EnableMenuItem (hMenu, ID_SUBMIT_FAULTS, MF_BYCOMMAND| MF_GRAYED);
				EnableMenuItem (hMenu, ID_REPORT_ALLKERNELMODEFAULTS, MF_BYCOMMAND| MF_GRAYED);
				EnableMenuItem (hMenu, ID_EDIT_DEFAULTREPORTINGOPTIONS, MF_BYCOMMAND| MF_GRAYED);
				EnableMenuItem (hMenu, ID_POPUP_VIEW_KERNELBUCKETPOLICY, MF_BYCOMMAND| MF_GRAYED);
				
			}
		}
		xPos = GET_X_LPARAM(lParam); 
		yPos = GET_Y_LPARAM(lParam); 
		Result = TrackPopupMenu (hmenuPopup, TPM_LEFTALIGN | TPM_RIGHTBUTTON, xPos,yPos,0,hwnd,NULL);
		
	}
	if (hMenu)
		DestroyMenu(hMenu);
}
	
void DoLaunchBrowser(HWND hwnd, BOOL URL_OVERRIDE)

/*++

Routine Description:

This routine Launches the system default Web browser useing shellexec
Arguments:

    hwnd			- Handle of the Kernel mode dialog box
	    
Return value:

    Does not return a value
++*/
{
	TCHAR Url [255];
	HWND hList = GetDlgItem(hwnd, IDC_KRNL_LIST);
//	TCHAR CommandLine[512];
//	STARTUPINFO StartupInfo;
//	PROCESS_INFORMATION ProcessInfo;
	int sel;
	ZeroMemory (Url, sizeof Url);

	if (!URL_OVERRIDE)
	{
		sel = ListView_GetNextItem(hList,-1, LVNI_SELECTED);
		ListView_GetItemText(hList, sel,2, Url,sizeof Url);
	}
	else
	{
		if (StringCbCopy(Url, sizeof Url, CsvContents.KrnlPolicy.UrlToLaunch) != S_OK)
		{
			goto ERRORS;
		}
	}
	if ( (!_tcsncicmp(Url, _T("http://"), _tcslen(_T("http://")))) ||   (!_tcsncicmp(Url, _T("https://"), _tcslen(_T("https://")))))
	{

		if (_tcscmp(Url, _T("\0")))
		{
			SHELLEXECUTEINFOA sei = {0};
			sei.cbSize = sizeof(sei);
			sei.lpFile = Url;
			sei.nShow = SW_SHOWDEFAULT;
			if (! ShellExecuteEx(&sei) )
			{
				// What do we display here.
				;
			}
		}
	}
	
ERRORS:
	;
	
}

void UpdateCsv(TCHAR *ResponseUrl)
/*++

Routine Description:

This routine updates Kernel.csv with the current Microsoft response data and bucket counts.
Called by KrnlUploadThreadProc() 
Arguments:

    ResponseUrl			- Microsoft response for the recently submitted dump file.
    
Return value:

    Does not return a value
++*/
{
	TCHAR BucketId[100];
	TCHAR BucketString[MAX_PATH];
	TCHAR szResponse1[MAX_PATH];
	TCHAR szResponse2[MAX_PATH]; 
	TCHAR *SourceChar;
	TCHAR *DestChar;
	TCHAR GBsid[100];
    int   CharCount = 0;
	// Parse the returned url and update the Csv file data structurs.

	// Make sure the response URL has data.
	if (!_tcscmp(ResponseUrl, _T("\0")))
	{
		goto ERRORS;
	}
	// TO DO--- Add a check for an SID of -1 and zero out the string if found.
	SourceChar = ResponseUrl;
	DestChar   = szResponse1;
	CharCount = sizeof szResponse1/ sizeof TCHAR - sizeof TCHAR;
	while ((CharCount > 0) && (*SourceChar != _T('&'))  &&( *SourceChar != _T('\0')) )
	{
		--CharCount;
		*DestChar = *SourceChar;
		++DestChar;
		++SourceChar;
	}
	*DestChar = _T('\0');
	++SourceChar; // Skip the &

	// Get the SBucket String
	SourceChar = _tcsstr(ResponseUrl, _T("szSBucket="));

	if (SourceChar)
	{
		CharCount = sizeof BucketString/ sizeof TCHAR - sizeof TCHAR;
		SourceChar += 10;
		DestChar = BucketString;
		while ((CharCount > 0) && (*SourceChar != _T('&')))
		{
			--CharCount;
			*DestChar = *SourceChar;
			++DestChar;
			++SourceChar;
		}
		*DestChar = _T('\0');
	}

	// Get the sbucket int
	SourceChar = _tcsstr(ResponseUrl, _T("iSBucket="));
	if (SourceChar)
	{
		SourceChar += 9;
		DestChar = BucketId;
		CharCount = sizeof BucketId/ sizeof TCHAR - sizeof TCHAR;
		while ((CharCount > 0) && (*SourceChar != _T('&'))   )
		{
			--CharCount;
			*DestChar = *SourceChar;
			++DestChar;
			++SourceChar;
		}
		*DestChar = _T('\0');
	}
	// Get the gBucket sid
	SourceChar = _tcsstr(ResponseUrl, _T("gsid="));
	if (SourceChar)
	{
		SourceChar += 5;
		DestChar = GBsid;
		CharCount = sizeof GBsid/ sizeof TCHAR - sizeof TCHAR;
		while((CharCount > 0) &&  (*SourceChar != _T('&')) && (*SourceChar != _T('\0')) )
		{
			--CharCount;
			*DestChar = *SourceChar;
			++DestChar;
			++SourceChar;
		}
		*DestChar = _T('\0');
	}

	// Build the gBucket Response String

	if (StringCbCopy(szResponse2,sizeof szResponse2, szResponse1) != S_OK)
	{
		goto ERRORS;
	}
	SourceChar = szResponse2;
	SourceChar += _tcslen(szResponse2) * sizeof TCHAR;

	if (SourceChar != szResponse2)
	{
		while((*(SourceChar -1) != _T('=')) && ( (SourceChar -1) != szResponse2))
		{
			-- SourceChar;
		}
		if (StringCbCopy (SourceChar, sizeof szResponse2 - (_tcslen(SourceChar) *sizeof TCHAR), GBsid) != S_OK)
		{
			goto ERRORS;
		}
	}
    CsvContents.UpdateList(BucketId,BucketString, szResponse1, szResponse2);
ERRORS:
	return;
}

void RenameToOld(TCHAR *szFileName)
/*++

Routine Description:

This routine renames a proccessed cab file from .cab to .old
Arguments:

    ResponseUrl			- Microsoft response for the recently submitted dump file.
    
Return value:

    Does not return a value
++*/
{
	TCHAR szFileNameOld[MAX_PATH];
	TCHAR *Temp;

	if (StringCbCopy(szFileNameOld,sizeof szFileNameOld, szFileName) != S_OK)
	{
		goto ERRORS;
	}
	Temp = szFileNameOld;
	Temp += _tcslen(szFileNameOld) * sizeof TCHAR;
	while ( (*Temp != _T('.')) && (Temp != szFileNameOld))
	{
		Temp --;
	}

	if (Temp == szFileNameOld)
	{
		// Abort since we did not find the .cab extension.
		goto ERRORS;
	}
	else
	{
		if (StringCbCopy (Temp, (_tcslen(szFileNameOld) * sizeof TCHAR) - ( _tcslen(szFileNameOld) * sizeof TCHAR - 5 * sizeof TCHAR), _T(".old")) != S_OK)
		{
			goto ERRORS;
		}

		MoveFileEx(szFileName, szFileNameOld, TRUE);
	}
ERRORS:
	return;
}

DWORD WINAPI KrnlUploadThreadProc (void *ThreadParam)
/*++

Routine Description:

This routine renames a proccessed cab file from .cab to .old
Arguments:

    ResponseUrl			- Microsoft response for the recently submitted dump file.
    
Return value:

    Does not return a value
++*/

{
	HANDLE hFind = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA FindData;
	TCHAR szFileName[MAX_PATH];
//	HANDLE hCsv;
	TCHAR szSearchPath[MAX_PATH];
	TCHAR ResponseURL[MAX_PATH];
	TCHAR DestinationName[MAX_PATH];
	TCHAR StaticText[MAX_PATH];
//	int CurrentPos = 0;
	TCHAR CsvName[MAX_PATH];
	int ErrorCode = 0;
	HANDLE hEvent = NULL;

	ZeroMemory( szFileName,			sizeof		szFileName);
	ZeroMemory(	ResponseURL,		sizeof		ResponseURL);
	ZeroMemory(	szSearchPath,		sizeof		szSearchPath);
	ZeroMemory(	DestinationName,	sizeof		DestinationName);
	ZeroMemory(	StaticText,			sizeof		StaticText);
	ZeroMemory( CsvName,			sizeof		CsvName);

	hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, _T("StopKernelUpload"));
	if (!hEvent)
	{
		goto ERRORS;
	}

	else 
	{
		if (WaitForSingleObject(hEvent, 50) == WAIT_OBJECT_0)
		{
			goto ERRORS;
		}
	}
	if (StringCbPrintf(CsvName, sizeof CsvName, _T("%s\\cabs\\blue\\Kernel.csv"), CerRoot) != S_OK)
	{
		goto ERRORS;
	}
	if (StringCbPrintf(szSearchPath,sizeof szSearchPath, _T("%s\\cabs\\blue\\*.cab"), CerRoot) != S_OK)
	{
		goto ERRORS;
	}
// Get the next file to upload
	hFind = FindFirstFile(szSearchPath, &FindData);

	if (hFind != INVALID_HANDLE_VALUE)
	{
		do {
			// Did the upload get canceled
			if (WaitForSingleObject(hEvent, 50) == WAIT_OBJECT_0)
			{
				goto Canceled;
			}
			if (StringCbPrintf(szFileName, sizeof szFileName, _T("%s\\cabs\\blue\\%s"), CerRoot, FindData.cFileName) != S_OK)
			{
				goto ERRORS;
			}
			// Upload the file
			if (StringCbPrintf(StaticText, sizeof StaticText, _T("Uploading File: %s"), szFileName) != S_OK)
			{
				goto ERRORS;
			}
				
			SetDlgItemText(* ((HWND *) ThreadParam), IDC_CAB_TEXT, StaticText);
			ErrorCode = UploadDumpFile(KRNL_MODE_SERVER, szFileName,_T("OCA"), DestinationName);
			if (ErrorCode == 1)
			{
				goto ERRORS;
			}
			if (ErrorCode != 0) // all other errors are related to a particular file not the internet connection
			{					// Move on to the next file.
				goto SKIPIT;
			}
			SendDlgItemMessage(*((HWND *) ThreadParam) ,IDC_FILE_PROGRESS, PBM_STEPIT, 0,0);
			
			// Get the response for the file.
			if (StringCbPrintf(StaticText, sizeof StaticText, _T("Retrieving response for: %s"), szFileName) != S_OK)
			{
				goto ERRORS;
			}
			else
			{
				SetDlgItemText(* ((HWND *) ThreadParam), IDC_CAB_TEXT, StaticText);
				ErrorCode = GetResponseUrl(KRNL_MODE_SERVER, DestinationName, ResponseURL);
				if (ErrorCode == -1)
				{
					// Internet connection error.
					// We need to stop processing.
					goto ERRORS;
					//RenameToOld(szFileName); // we don't want to halt processing for these errors.
					//ErrorCode = 2;
					//goto ERRORS;
					
				}
				
				else
				{
					if (ErrorCode == -2)
					{
						// all other errors we just rename the file and keep going.
						RenameToOld(szFileName);
						goto SKIPIT;
					}
					else
					{
						RenameToOld(szFileName);
					
				
					//	MessageBox(NULL, ResponseURL, "Received Response", MB_OK);
						
						SendDlgItemMessage(*((HWND *) ThreadParam) ,IDC_FILE_PROGRESS, PBM_STEPIT, 0,0);
					
						// Update the CSV File
							//
						if (StringCbPrintf(StaticText, sizeof StaticText, _T("Updating local data:")) != S_OK)
						{
							goto ERRORS;
						}
						SetDlgItemText(* ((HWND *) ThreadParam), IDC_CAB_TEXT, StaticText);
						SendDlgItemMessage(*((HWND *) ThreadParam) ,IDC_FILE_PROGRESS, PBM_STEPIT, 0,0);
					
						
						// Update Status
						UpdateCsv(ResponseURL);
						//CsvContents.WriteCsv();
						SendDlgItemMessage(*((HWND *) ThreadParam) ,IDC_TOTAL_PROGRESS, PBM_STEPIT, 0,0);
						SendDlgItemMessage(*((HWND *) ThreadParam) ,IDC_FILE_PROGRESS, PBM_SETPOS, 0,0);
					}
				}
			}
SKIPIT:
			;
		} while (FindNextFile(hFind, &FindData));
		FindClose( hFind);
		hFind = INVALID_HANDLE_VALUE;
Canceled:
		CsvContents.WriteCsv();
	}
	
	
ERRORS:
	if (ErrorCode == 1)
	{
		MessageBox(* ((HWND *) ThreadParam), _T("Upload to Microsoft failed.\r\nPlease check your Internet Connection"), NULL,MB_OK);
	}
	if (ErrorCode == 2)
	{
		//MessageBox(* ((HWND *) ThreadParam), _T("Failed to retrieve a response from Microsoft."), NULL,MB_OK);
	}
	if (hFind != INVALID_HANDLE_VALUE)
	{
		FindClose(hFind);
	}
	PostMessage(*((HWND *) ThreadParam), WmSyncDone, FALSE, 0);
	if (hEvent)
	{
		CloseHandle(hEvent);
		hEvent = NULL;
	}
	//RefreshKrnlView(*((HWND *) ThreadParam));
	return 0;

}

LRESULT CALLBACK 
KrnlSubmitDlgProc(
	HWND hwnd,
	UINT iMsg,
	WPARAM wParam,
	LPARAM lParam
	)
/*++

Routine Description:

This routine renames a proccessed cab file from .cab to .old
Arguments:

    ResponseUrl			- Microsoft response for the recently submitted dump file.
    
Return value:

    Does not return a value
++*/
{
//	int CurrentPos = 0;
	
//	HWND Parent = GetParent(hwnd);
	switch (iMsg)
	{
	case WM_INITDIALOG:
		// Start the upload process in a new thread.
		// Report results using WM_FILEDONE 
		
//		CreateEvent();

		SendDlgItemMessage(hwnd,IDC_TOTAL_PROGRESS, PBM_SETRANGE,0, MAKELPARAM(0, KModeData.UnprocessedCount));
		SendDlgItemMessage(hwnd ,IDC_TOTAL_PROGRESS, PBM_SETSTEP, MAKELONG( 1,0),0);

		SendDlgItemMessage(hwnd,IDC_FILE_PROGRESS, PBM_SETRANGE,0, MAKELPARAM(0, 3));
		SendDlgItemMessage(hwnd ,IDC_FILE_PROGRESS, PBM_SETSTEP, MAKELONG( 1,0),0);
		g_hStopEvent = CreateEvent(NULL, FALSE, FALSE, _T("StopKernelUpload"));
		if (!g_hStopEvent)
		{
			PostMessage(hwnd, WmSyncDone, FALSE,0);
		}
		PostMessage(hwnd, WmSyncStart, FALSE, 0);
		break;

	case WmSyncStart:
		HANDLE hThread;

		ThreadParam = hwnd;
		hThread = CreateThread(NULL, 0,KrnlUploadThreadProc , &ThreadParam, 0 , NULL );
		CloseHandle(hThread);
//		OnSubmitDlgInit(hwnd);
		
		break;

	case WmSetStatus:
		
		break;

	case WmSyncDone:
			if (g_hStopEvent)
			{
				CloseHandle(g_hStopEvent);
				g_hStopEvent = NULL;
			}

			EndDialog(hwnd, 1);
		return TRUE;

	case WM_DESTROY:
		if (g_hStopEvent)
		{
			SetEvent(g_hStopEvent);
			if (g_hStopEvent)
					CloseHandle(g_hStopEvent);
		}
		else
		{
			EndDialog(hwnd, 1);
		}
		break;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDCANCEL:
			if (g_hStopEvent)
			{
				SetEvent(g_hStopEvent);
				CloseHandle(g_hStopEvent);
				g_hStopEvent = NULL;
			}
			else
			{
				EndDialog(hwnd, 1);
			}
		break;
		}
	
	
	}

	return FALSE;
}

void DoViewBucketDirectory()
{
	TCHAR szPath[MAX_PATH];
	if (StringCbPrintf(szPath, sizeof szPath, _T("%s\\cabs\\blue"), CerRoot) != S_OK)
		return;
	else
	{
		SHELLEXECUTEINFOA sei = {0};
		sei.cbSize = sizeof(sei);
		sei.lpFile = szPath;
		sei.nShow = SW_SHOWDEFAULT;
		if (! ShellExecuteEx(&sei) )
		{
			// What do we display here.
			;
		}
	}
}
	
	

VOID DoSubmitKernelFaults(HWND hwnd)
/*++

Routine Description:

This routine renames a proccessed cab file from .cab to .old
Arguments:

    ResponseUrl			- Microsoft response for the recently submitted dump file.
    
Return value:

    Does not return a value
++*/
{
	//HANDLE hFind = INVALID_HANDLE_VALUE;
	//WIN32_FIND_DATA FindData;
	//TCHAR szPath[MAX_PATH];
	// handled by the Progress bar dialog box.

	// First check to see if there are any cabs to submit
   /* if (_tcscmp(CerRoot, _T("\0")))
	{
		ZeroMemory (szPath, sizeof szPath);
		// From the filetree root goto cabs/bluescreen
		
		if (StringCbCopy(szPath, sizeof szPath, CerRoot) != S_OK)
		{
			goto ERRORS;
		}
		if (StringCbCat(szPath, sizeof szPath,  _T("\\cabs\\blue\\*.cab")) != S_OK)
		{
			goto ERRORS;
		}
		hFind = FindFirstFile(szPath, &FindData);
		if (hFind != INVALID_HANDLE_VALUE)
		{
			// we have at least 1 to upload
			FindClose(hFind);
			*/
			DialogBox (g_hinst,MAKEINTRESOURCE(IDD_KERNEL_SYNC) , hwnd, (DLGPROC)KrnlSubmitDlgProc);
			if (g_hStopEvent)
			{
				CloseHandle(g_hStopEvent);
				g_hStopEvent = NULL;
			}
	//	}
	///}
	RefreshKrnlView(hwnd);
//ERRORS:
    return;
}


BOOL DisplayKrnlBucketData(HWND hwnd, int iItem)
{
	HWND hEditBox = GetDlgItem(hwnd, IDC_KRNL_EDIT);
	TCHAR *Buffer = NULL;		// we have to use a dynamic buffer since we don't 
								// have a clue as to the text length.
	DWORD BufferLength = 100000; // 100k bytes should be plenty. or 50K unicode chars.
	TCHAR *Dest = NULL;
	TCHAR *Source = NULL;
	TCHAR TempBuffer[1000];

	ZeroMemory (TempBuffer,sizeof TempBuffer);
	Buffer = (TCHAR *) malloc (BufferLength);
	if (Buffer)
	{
		ZeroMemory(Buffer,BufferLength);
		
			// Basic data collection first.
			if ( (!_tcscmp (CsvContents.KrnlPolicy.SecondLevelData, _T("YES"))) && (_tcscmp(CsvContents.KrnlPolicy.FileCollection, _T("YES"))) )
			{
				if (StringCbPrintf(Buffer, BufferLength, _T("The following information will be sent to Microsoft.\r\n\tHowever, this bucket's policy would prevent files and user documents from being reported.\r\n"))!= S_OK)
				{
					goto ERRORS;
				}

			}

			else
			{

				if (!_tcscmp(CsvContents.KrnlPolicy.FileCollection, _T("YES")))
				{
					if (StringCbCat(Buffer,BufferLength, _T(" Microsoft would like to collect the following information but default policy\r\n\tprevents files and user documents from being reported.\r\n\t As a result, no exchange will take place.\r\n"))!= S_OK)
					{
						goto ERRORS;
					}
				}
				else
				{
					if ( !_tcscmp (CsvContents.KrnlPolicy.SecondLevelData, _T("YES")))
					{
						if (StringCbPrintf(Buffer, BufferLength, _T("Microsoft would like to collect the following information but the default policy prevents the exchange.\r\n"))!= S_OK)
						{
							goto ERRORS;
						}

					}
					else
					{
						if (StringCbPrintf(Buffer, BufferLength, _T("The following information will be sent to Microsoft:\r\n"))!= S_OK)
						{
							goto ERRORS;
						}
					}
				}
			}
			
			if (_tcscmp(CsvContents.KrnlPolicy.GetFile, _T("\0")))
			{
				if (StringCbCat(Buffer, BufferLength, _T("These files:\r\n"))!= S_OK)
				{
					goto ERRORS;
				}
				Source = CsvContents.KrnlPolicy.GetFile;
				
				while ((*Source != _T('\0')) && (*Source != _T('\r')) && (*Source != _T('\n')) )
				{
					ZeroMemory (TempBuffer, sizeof TempBuffer);
					Dest = TempBuffer;
					while ( (*Source != _T('\0')) && (*Source != _T('\r')) && (*Source != _T('\n'))&& (*Source != _T(';') ))
					{
						*Dest = *Source;
						++Dest; 
						++Source;
					}
					if (*Source == _T(';'))
					{
						++Source;
					}
					*Dest =_T('\0');
					if (StringCbCat(Dest, sizeof TempBuffer, _T("\r\n")) != S_OK)
					{
						goto ERRORS;
					}
					if (StringCbCat(Buffer, BufferLength,  _T("\t") )!= S_OK)
					{
						goto ERRORS;
					}
					if (StringCbCat(Buffer, BufferLength,  TempBuffer )!= S_OK)
					{
						goto ERRORS;
					}
				}
			}
			if (_tcscmp(CsvContents.KrnlPolicy.RegKey, _T("\0")))
			{
				if (StringCbCat(Buffer, BufferLength, _T("These Registry Keys:\r\n"))!= S_OK)
				{
					goto ERRORS;
				}
				
				Source = CsvContents.KrnlPolicy.RegKey;
				
				while ((*Source != _T('\0')) && (*Source != _T('\r')) && (*Source != _T('\n')) )
				{
					ZeroMemory (TempBuffer, sizeof TempBuffer);
					Dest = TempBuffer;
					while ( (*Source != _T('\0')) && (*Source != _T('\r')) && (*Source != _T('\n'))&& (*Source != _T(';') ))
					{
						*Dest = *Source;
						++Dest; 
						++Source;
					}
					if (*Source == _T(';'))
					{
						++Source;
					}
					*Dest =_T('\0');
					if (StringCbCat(Dest, sizeof TempBuffer, _T("\r\n")) != S_OK)
					{
						goto ERRORS;
					}
					if (StringCbCat(Buffer, BufferLength,  _T("\t") )!= S_OK)
					{
						goto ERRORS;
					}
					if (StringCbCat(Buffer, BufferLength,  TempBuffer )!= S_OK)
					{
						goto ERRORS;
					}
				}
			}
			if (_tcscmp(CsvContents.KrnlPolicy.WQL, _T("\0")))
			{
				if (StringCbCat(Buffer, BufferLength, _T("The Results of these WQL queries:\r\n"))!= S_OK)
				{
					goto ERRORS;
				}

				// Replace ; with \t\r\n 

				
				Source = CsvContents.KrnlPolicy.WQL;
				
				while ((*Source != _T('\0')) && (*Source != _T('\r')) && (*Source != _T('\n')) )
				{
					ZeroMemory (TempBuffer, sizeof TempBuffer);
					Dest = TempBuffer;
					while ( (*Source != _T('\0')) && (*Source != _T('\r')) && (*Source != _T('\n'))&& (*Source != _T(';') ))
					{
						*Dest = *Source;
						++Dest; 
						++Source;
					}
					if (*Source == _T(';'))
					{
						++Source;
					}
					*Dest =_T('\0');
					if (StringCbCat(Dest, sizeof TempBuffer, _T("\r\n")) != S_OK)
					{
						goto ERRORS;
					}
					if (StringCbCat(Buffer, BufferLength,  _T("\t") )!= S_OK)
					{
						goto ERRORS;
					}
					if (StringCbCat(Buffer, BufferLength,  TempBuffer )!= S_OK)
					{
						goto ERRORS;
					}
				}
			}
	
			if (!_tcscmp (CsvContents.KrnlPolicy.MemoryDump, _T("YES")))
			{
				if (StringCbCat(Buffer, BufferLength, _T("The contents of memory\r\n"))!= S_OK)
				{
					goto ERRORS;
				}
			}
			if (_tcscmp(CsvContents.KrnlPolicy.GetFileVersion, _T("\0")))
			{
				if (StringCbCat(Buffer, BufferLength, _T("The versions of these files:\r\n"))!= S_OK)
				{
					goto ERRORS;
				}
				Source = CsvContents.KrnlPolicy.GetFileVersion;
				
				while ((*Source != _T('\0')) && (*Source != _T('\r')) && (*Source != _T('\n')) )
				{
					ZeroMemory (TempBuffer, sizeof TempBuffer);
					Dest = TempBuffer;
					while ( (*Source != _T('\0')) && (*Source != _T('\r')) && (*Source != _T('\n'))&& (*Source != _T(';') ))
					{
						*Dest = *Source;
						++Dest; 
						++Source;
					}
					if (*Source == _T(';'))
					{
						++Source;
					}
					*Dest =_T('\0');
					if (StringCbCat(Dest, sizeof TempBuffer, _T("\r\n")) != S_OK)
					{
						goto ERRORS;
					}
					if (StringCbCat(Buffer, BufferLength,  _T("\t") )!= S_OK)
					{
						goto ERRORS;
					}
					if (StringCbCat(Buffer, BufferLength,  TempBuffer )!= S_OK)
					{
						goto ERRORS;
					}
				}
			}

			if (_tcscmp(CsvContents.KrnlPolicy.fDoc, _T("\0")))
			{
				if (StringCbCat(Buffer, BufferLength, _T("The users current document.\r\n"))!= S_OK)
				{
					goto ERRORS;
				}
			}
			SendMessage(hEditBox, WM_SETTEXT, NULL, (LPARAM)Buffer);
		
		
	}


ERRORS:
	if (Buffer)
		free(Buffer);
	return TRUE;
}
		 /*
void KMCopyToClipboard(HWND hwnd)
{
	if (!OpenClipboard(NULL))
		return;

	EmptyClipboard();
	char rtfRowHeader[sizeof(rtfRowHeader1) + (sizeof(rtfRowHeader2)+6)*KRNL_COL_COUNT + sizeof(rtfRowHeader3)];
	char *rtfWalk = rtfRowHeader;
	memcpy(rtfWalk, rtfRowHeader1, sizeof(rtfRowHeader1));
	rtfWalk += sizeof(rtfRowHeader1)-1;
	DWORD cxTotal = 0;
	for(int i=0;i<KRNL_COL_COUNT;i++)
		{
		LVCOLUMNA lv;
		lv.mask = LVCF_WIDTH;
		lv.iSubItem = i;
		SendMessageA(GetDlgItem(hwnd,IDC_KRNL_LIST), LVM_GETCOLUMN, i, (LPARAM)&lv);
		cxTotal += lv.cx;
		wsprintf(rtfWalk, "%s%d", rtfRowHeader2, cxTotal);
		while(*++rtfWalk)
			;
		};
	memcpy(rtfWalk, rtfRowHeader3, sizeof(rtfRowHeader3));
	DWORD crtfHeader = strlen(rtfRowHeader);
	DWORD crtf = 0, cwz = 0;
	
	crtf += sizeof(rtfPrologue)-1;

	int iSel = -1;
	while ((iSel = SendMessageW(GetDlgItem(hwnd,IDC_KRNL_LIST), LVM_GETNEXTITEM, iSel, MAKELPARAM(LVNI_SELECTED, 0))) != -1)
		{
		crtf += crtfHeader;
		for(int i=0;i<KRNL_COL_COUNT;i++)
			{
			WCHAR wzBuffer[1024];
			LVITEMW lv;

			lv.pszText = wzBuffer;
			lv.cchTextMax = sizeof(wzBuffer);
			lv.iSubItem = i;
			lv.iItem = iSel;
			cwz += SendMessageW(GetDlgItem(hwnd,IDC_KRNL_LIST), LVM_GETITEMTEXTW, iSel, (LPARAM)&lv);
			cwz++;
			crtf += WideCharToMultiByte(CP_ACP, 0, wzBuffer, -1, NULL, 0, NULL, NULL) - 1;
			crtf += sizeof(rtfRowPref)-1;
			crtf += sizeof(rtfRowSuff)-1;
			};
		cwz++;
		crtf += sizeof(rtfRowFooter)-1;
		};

	crtf += sizeof(rtfEpilogue);
	cwz++;

	HGLOBAL hgwz = GlobalAlloc(GMEM_FIXED, cwz*sizeof(WCHAR));
	HGLOBAL hgrtf = GlobalAlloc(GMEM_FIXED, crtf);

	WCHAR *wz = (WCHAR *)GlobalLock(hgwz);
	char *rtf = (char *)GlobalLock(hgrtf);

	rtfWalk = rtf;
	WCHAR *wzWalk = wz;
	memcpy(rtfWalk, rtfPrologue, sizeof(rtfPrologue));
	rtfWalk += sizeof(rtfPrologue)-1;

	iSel = -1;
	while ((iSel = SendMessageW(GetDlgItem(hwnd,IDC_KRNL_LIST), LVM_GETNEXTITEM, iSel, MAKELPARAM(LVNI_SELECTED, 0))) != -1)
		{
		memcpy(rtfWalk, rtfRowHeader, crtfHeader);
		rtfWalk += crtfHeader;
		for(int i=0;i<KRNL_COL_COUNT;i++)
			{
			memcpy(rtfWalk, rtfRowPref, sizeof(rtfRowPref));
			rtfWalk += sizeof(rtfRowPref)-1;

			LVITEMW lv;

			lv.pszText = wzWalk;
			lv.cchTextMax = cwz;
			lv.iSubItem = i;
			lv.iItem = iSel;
			SendMessageW(GetDlgItem(hwnd, IDC_KRNL_LIST), LVM_GETITEMTEXTW, iSel, (LPARAM)&lv);

			WideCharToMultiByte(CP_ACP, 0, wzWalk, -1, rtfWalk, crtf, NULL, NULL);
			wzWalk += wcslen(wzWalk);
			if (i == 11)
				{
				*wzWalk++ = L'\r';
				*wzWalk++ = L'\n';
				}
			else
				*wzWalk++ = L'\t';

			rtfWalk += strlen(rtfWalk);		
			memcpy(rtfWalk, rtfRowSuff, sizeof(rtfRowSuff));
			rtfWalk += sizeof(rtfRowSuff)-1;
			};
		memcpy(rtfWalk, rtfRowFooter, sizeof(rtfRowFooter));
		rtfWalk += sizeof(rtfRowFooter)-1;
		};

	memcpy(rtfWalk, rtfEpilogue, sizeof(rtfEpilogue));
	rtfWalk += sizeof(rtfEpilogue);
	*wzWalk++ = 0;

//	Assert(rtfWalk - rtf == crtf);
//	Assert(wzWalk - wz == cwz);

	GlobalUnlock(hgwz);
	GlobalUnlock(hgrtf);

	SetClipboardData(CF_UNICODETEXT, hgwz);
	SetClipboardData(RegisterClipboardFormatA(szRTFClipFormat), hgrtf);

	// hgwz and hgrtf are now owned by the system.  DO NOT FREE!
	CloseClipboard();
}
  */
LRESULT CALLBACK 
KrnlDlgProc(
	HWND hwnd,
	UINT iMsg,
	WPARAM wParam,
	LPARAM lParam
	)
/*++

Routine Description:

This routine Is the notification handler for the Kernel Mode dialog box
Arguments:

    ResponseUrl			- Microsoft response for the recently submitted dump file.
    
Return value:

   returns an LRESULT
   TRUE = The message was handled.
   FALSE = The message was ignored.
++*/
{
	TCHAR Temp[100];
	switch (iMsg)
	{
	case WM_NOTIFY:
		{	
			
			switch(((NMHDR *)lParam)->code)
			{
			
				case LVN_COLUMNCLICK:
				
					_itot(((NM_LISTVIEW*)lParam)->iSubItem,Temp,10);

					ListView_SortItemsEx( ((NMHDR *)lParam)->hwndFrom,
											CompareFunc,
											((NM_LISTVIEW*)lParam)->iSubItem
										);

					g_bSortAsc = !g_bSortAsc;
					break;
				case NM_CLICK:
					DisplayKrnlBucketData(hwnd, ((NM_LISTVIEW*)lParam)->iItem);
					break;
			}
			return TRUE;
		}
	
	case WM_INITDIALOG:
			OnKrnlDialogInit(hwnd);
		return TRUE;

	case WM_FileTreeLoaded:
			RefreshKrnlView(hwnd);
		return TRUE;
	case WM_CONTEXTMENU:
			OnKrnlContextMenu(hwnd, lParam );
		return TRUE;
	case WM_ERASEBKGND:
	// Don't know why this doesn't happen automatically...
		{
		HDC hdc = (HDC)wParam;
		HPEN hpen = (HPEN)CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNFACE));
		HPEN hpenOld = (HPEN)SelectObject(hdc, hpen);
		SelectObject(hdc, GetSysColorBrush(COLOR_BTNFACE));
		RECT rc;
		GetClientRect(hwnd, &rc);
		Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
		SelectObject(hdc, hpenOld);
		DeleteObject(hpen);
		return TRUE;
		}

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case ID_SPECIFIC_BUCKET:
				DoLaunchBrowser(hwnd, FALSE);
			break;
		case ID_VIEW_BUCKETOVERRIDERESPONSE166:
				DoLaunchBrowser(hwnd, TRUE);
			break;
		case ID_REPORT_ALLKERNELMODEFAULTS:
				DoSubmitKernelFaults(hwnd);
				//RefreshKrnlView(hwnd);
			break;
		case ID_VIEW_BUCKETCABFILEDIRECTORY125:
		case ID_VIEW_BUCKETCABFILEDIRECTORY:
			DoViewBucketDirectory();
			break;
		case ID_VIEW_REFRESH121:
		case ID_VIEW_REFRESH:
			RefreshKrnlView(hwnd);
			break;
		case ID_VIEW_CRASH:
			ViewCrashLog();
			break;
		case ID_SUBMIT_FAULTS:
			PostMessage(GetParent(hwnd), WM_COMMAND, MAKEWPARAM(ID_REPORT_ALLCRASHES,0),0);
			break;
		case ID_EDIT_DEFAULTREPORTINGOPTIONS:	
			PostMessage(GetParent(hwnd), WM_COMMAND, MAKEWPARAM(ID_EDIT_DEFAULTPOLICY,0),0);
			break;
	///	case ID_EDIT_COPY147:
	//	KMCopyToClipboard(hwnd);
	//		break;
		case ID_POPUP_VIEW_KERNELBUCKETPOLICY:
			PostMessage(GetParent(hwnd), WM_COMMAND, MAKEWPARAM(ID_EDIT_SELECTEDBUCKETSPOLICY,0),0);
			break;
		}

	}
	return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\cer\cw15\usermode.h ===
#ifndef _USERMODE_H
#define _USERMODE_H
#include "Main.h"


#define USER_COL_COUNT 13




// Partial URLS for stage 1 and 2
#define PARTIALURL_STAGE_ONE    	_T("/StageOne")
#define PARTIALURL_STAGE_TWO_32		_T("/dw/stagetwo.asp")
#define PARTIALURL_STAGE_TWO_64		_T("/dw/stagetwo64.asp")

// Buffer step size when reading large files.
#define READFILE_BUFFER_INCREMENT 10000


// Status.txt Element Strings.
#define TRACKING_PREFIX				_T("Tracking=")
#define URLLAUNCH_PREFIX			_T("URLLaunch=")
#define SECOND_LEVEL_DATA_PREFIX	_T("NoSecondLevelCollection=")
#define FILE_COLLECTION_PREFIX		_T("NoFileCollection=")
#define BUCKET_PREFIX				_T("Bucket=")
#define RESPONSE_PREFIX				_T("Response=")
#define FDOC_PREFIX					_T("fDoc=")
#define IDATA_PREFIX				_T("iData=")
#define GETFILE_PREFIX				_T("GetFile=")
#define MEMDUMP_PREFIX				_T("MemoryDump=")
#define WQL_PREFIX					_T("WQL=")
#define GETFILEVER_PREFIX			_T("GetFileVersion=")
#define REGKEY_PREFIX				_T("RegKey=")
#define CRASH_PERBUCKET_PREFIX		_T("Crashes per bucket=")
#define STAGE3_SERVER_PREFIX		_T("DumpServer=")
#define STAGE3_FILENAME_PREFIX		_T("DumpFile=")
#define STAGE4_SERVER_PREFIX		_T("ResponseServer=")
#define STAGE4_URL_PREFIX 			_T("ResponseURL=")
#define FILE_TREE_ROOT_PREFIX       _T("FileTreeRoot=")
#define ALLOW_EXTERNAL_PREFIX		_T("NoExternalURL=")



LRESULT CALLBACK
 UserDlgProc(
	HWND hwnd,
	UINT iMsg,
	WPARAM wParam,
	LPARAM lParam
	);


void ResizeUserMode(HWND hwnd);
BOOL GetAllBuckets(HWND hwnd);
void ViewResponse(HWND hwnd, BOOL bMSResponse);
void RefreshUserMode(HWND hwnd);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\cer\cw15\reportfault.cpp ===
// Report User mode faults
#include "Main.h"
#include "WinMessages.h"
#include "CuserList.h"
#include "UserMode.h"
#include "ReportFault.h"

#define INTERNAL_SERVER   _T("officewatson")
#define LIVE_SERVER       _T("watson.microsoft.com")
#ifdef DEBUG
	#define DEFAULT_SERVER   INTERNAL_SERVER
	
#else
	#define DEFAULT_SERVER LIVE_SERVER
#endif

typedef struct strStage3Data
{
	TCHAR szServerName[MAX_PATH];
	TCHAR szFileName[MAX_PATH];
} STAGE3DATA;

typedef struct strThreadParams
{
	BOOL bSelected;
	HWND hListView;
	HWND hwnd;
} THREAD_PARAMS, *PTHREAD_PARAMS;

typedef struct strStage4Data
{
	TCHAR szServerName[MAX_PATH];
	TCHAR szUrl[MAX_PATH];
} STAGE4DATA;


HANDLE g_hUserStopEvent = NULL;
THREAD_PARAMS ThreadParams;
extern CUserList cUserData;
extern HINSTANCE g_hinst;
extern CUserList cUserList;
extern TCHAR CerRoot[MAX_PATH];
extern HWND hUserMode;



/*----------------------------------------------------------------------------	
	FMicrosoftComURL

	Returns TRUE if we think the sz is a URL to a microsoft.com web site
----------------------------------------------------------------- MRuhlen --*/
BOOL FMicrosoftComURL(TCHAR *sz)
{
	TCHAR *pch;
	
	if (sz == NULL || _tcslen(sz) < 20)  // "http://microsoft.com
		return FALSE;
		
	if (_tcsncicmp(sz, szHttpPrefix, _tcslen(szHttpPrefix)))
		return FALSE;
		
	pch = sz + _tcslen(szHttpPrefix);
	
	while (*pch != _T('/') && *pch != _T('\0'))
		pch++;
		
	if (*pch == _T('\0'))
		return FALSE;
		
	// found the end of the server name
	if (_tcsncicmp(pch - strlen(_T(".microsoft.com")), _T(".microsoft.com"),_tcslen(_T(".microsoft.com"))
				  ) &&
		_tcsncicmp(pch - strlen(_T("/microsoft.com")), _T("/microsoft.com"),_tcslen(_T("/microsoft.com"))
				 ) &&
		_tcsncicmp(pch - _tcslen(_T(".msn.com")), _T(".msn.com") ,_tcslen(_T(".msn.com"))
				 )
#ifdef DEBUG
	   &&	_tcsncicmp(pch - _tcslen(_T("officewatson")), _T("officewatson") ,_tcslen(_T("officewatson")))
#endif
		)
		return FALSE;
		
	return TRUE;
}	


//----------------Response Parsing Routines. -------------------------------------------
BOOL 
ParseStage1File(BYTE *Stage1HtmlContents, 
				PSTATUS_FILE StatusContents)
/*++

Routine Description:

This routine Parses the Response from the Stage1 url query.
Arguments:

    ResponseUrl	- Microsoft response for the recently submitted dump file.
    
Return value:

    Does not return a value
++*/
{
	BOOL bStatus = FALSE;
	TCHAR *Temp = NULL;
	TCHAR *Destination = NULL;
	DWORD charcount = 0;
	if ( (!Stage1HtmlContents) || (!StatusContents))
	{
		goto ERRORS;
	}

	
	// Clear out the requested data items from the status file. 
	// We don't need them anymore since there is a stage 1 page available.
	
	if (StringCbCopy(StatusContents->Response, sizeof StatusContents->Response, _T("\0"))!= S_OK)
	{
		goto ERRORS;
	}
	if (StringCbCopy(StatusContents->BucketID, sizeof StatusContents->BucketID, _T("\0"))!= S_OK)
	{
		goto ERRORS;
	}
	if (StringCbCopy(StatusContents->RegKey, sizeof StatusContents->RegKey, _T("\0"))!= S_OK)
	{
		goto ERRORS;
	}
	if (StringCbCopy(StatusContents->iData, sizeof StatusContents->iData, _T("\0"))!= S_OK)
	{
		goto ERRORS;
	}
	if (StringCbCopy(StatusContents->GetFile, sizeof StatusContents->GetFile, _T("\0"))!= S_OK)
	{
		goto ERRORS;
	}
	if (StringCbCopy(StatusContents->GetFileVersion, sizeof StatusContents->GetFileVersion, _T("\0"))!= S_OK)
	{
		goto ERRORS;
	}
	if (StringCbCopy(StatusContents->fDoc, sizeof StatusContents->fDoc, _T("\0"))!= S_OK)
	{
		goto ERRORS;
	}
	if (StringCbCopy(StatusContents->WQL, sizeof StatusContents->WQL, _T("\0"))!= S_OK)
	{
		goto ERRORS;
	}
    if (StringCbCopy(StatusContents->MemoryDump, sizeof StatusContents->MemoryDump, _T("\0"))!= S_OK)
	{
		goto ERRORS;
	}

	// Lets get the bucketid

	
	Temp = _tcsstr((TCHAR *)Stage1HtmlContents, _T("Bucket="));
	if (Temp)
	{
		Temp += _tcslen(_T("Bucket="));
		Destination = StatusContents->BucketID;
	    charcount = sizeof StatusContents->BucketID / sizeof TCHAR  - sizeof TCHAR	;
		while ( (charcount > 0) && 
				(*Temp != _T(' ')) && 
				(*Temp != _T('\0')) &&
				(*Temp != _T('\r')))
		{
			-- charcount;
			*Destination = *Temp;
			++Destination;
			++Temp;
		}
		*Destination = _T('\0');
		bStatus= TRUE;
	}
	else
	{
		goto ERRORS;
	}
	
	// Now for the Response
	Temp = _tcsstr( (TCHAR *)Stage1HtmlContents, _T("Response="));
	if (Temp)
	{
		Temp += _tcslen(_T("Response="));
		Destination = StatusContents->Response;

		if (!FMicrosoftComURL(Temp))
		{
			if (StringCbCopy(StatusContents->Response, sizeof StatusContents->Response, _T("1")) != S_OK)
			{
				goto ERRORS;
			}
		}
		else
		{
			charcount = sizeof StatusContents->Response / sizeof TCHAR  - sizeof TCHAR	;
			while ( (charcount > 0) && 
					(*Temp != _T(' ')) && 
					(*Temp != _T('\0')) &&
					(*Temp != _T('\r')))
			{
				-- charcount;
				*Destination = *Temp;
				++Destination;
				++Temp;
				bStatus = TRUE;
			}
			*Destination = _T('\0');
		}
	}
	if (StringCbCopy(StatusContents->iData, sizeof StatusContents->iData, _T("0\0"))!= S_OK)
	{
		goto ERRORS;
	}

ERRORS:
	return bStatus;

}

BOOL 
ParseStage2File(BYTE *Stage2HtmlContents, 
				PSTATUS_FILE StatusContents,
				STAGE3DATA *Stage3Data,
				STAGE4DATA *Stage4Data)
/*++

Routine Description:

This routing parses the contents of the html file returned by the process stage2
	function into the UserData.Status data structure. see CUserList.h for the definition
	of this structure. And Usermode.h for the definition of the Prefix values used to parse 
	the Stage2HtmlContents buffer.
    
Arguments:

    Stage2HtmlContents	- The contents of this file will constitute the contents of the new status.txt file.
						- See Spec for details on value meaning and usage.

	Sample file:
		Tracking=YES
		URLLaunch=asfsafsafsafsafsafdsdafsafsadf
		NoSecondLevelCollection=NO
		NoFileCollection=NO
		Bucket=985561
		Response=http://www.microsoft.com/ms.htm?iBucketTable=1&iBucket=985561&Cab=29728988.cab
		fDoc=NO
		iData=1
		GetFile=c:\errorlog.log
		MemoryDump=NO

		// Stage3 data
		DumpFile=/Upload/66585585.cab
		DumpServer=watson5.watson.microsoft.com

		// Stage4 data
		ResponseServer=watson5.watson.microsoft.com 
		ResponseURL=/dw/StageFour.asp?iBucket=985561&Cab=/Upload/66585585.cab&Hang=0&Restricted=1&CorpWatson=1 

Return value:

    Returns True on success and FALSE if there were problems.
++*/
{
	BOOL bStatus = TRUE;
	TCHAR *Temp;
	TCHAR *Dest;
	int   CharCount = 0;
//	TCHAR szStage3Server[MAX_PATH];
//	TCHAR szStage3FileName[MAX_PATH];
//	TCHAR szStage4Server[MAX_PATH];
//	TCHAR szStage4URL [MAX_PATH];

	if (StringCbCopy(StatusContents->Response, sizeof StatusContents->Response, _T("\0"))!= S_OK)
	{
		goto ERRORS;
	}
	if (StringCbCopy(StatusContents->BucketID, sizeof StatusContents->BucketID, _T("\0"))!= S_OK)
	{
		goto ERRORS;
	}
	if (StringCbCopy(StatusContents->RegKey, sizeof StatusContents->RegKey, _T("\0"))!= S_OK)
	{
		goto ERRORS;
	}
	if (StringCbCopy(StatusContents->iData, sizeof StatusContents->iData, _T("\0"))!= S_OK)
	{
		goto ERRORS;
	}
	if (StringCbCopy(StatusContents->GetFile, sizeof StatusContents->GetFile, _T("\0"))!= S_OK)
	{
		goto ERRORS;
	}
	if (StringCbCopy(StatusContents->GetFileVersion, sizeof StatusContents->GetFileVersion, _T("\0"))!= S_OK)
	{
		goto ERRORS;
	}
	if (StringCbCopy(StatusContents->fDoc, sizeof StatusContents->fDoc, _T("\0"))!= S_OK)
	{
		goto ERRORS;
	}
	if (StringCbCopy(StatusContents->WQL, sizeof StatusContents->WQL, _T("\0"))!= S_OK)
	{
		goto ERRORS;
	}
    if (StringCbCopy(StatusContents->MemoryDump, sizeof StatusContents->MemoryDump, _T("\0"))!= S_OK)
	{
		goto ERRORS;
	}
	/*********** Get the Tracking Status ******************/
	Temp = _tcsstr((TCHAR *) Stage2HtmlContents, TRACKING_PREFIX);
	if (Temp)
	{
		Dest = StatusContents->Tracking;
		Temp += _tcslen (TRACKING_PREFIX);
		CharCount =	 sizeof StatusContents->Tracking / sizeof TCHAR  - sizeof TCHAR	;
		while ( (CharCount > 0) && (*Temp != _T('\0') ) && (*Temp != _T('\n')) && (*Temp != _T('\r')) )
		{
			-- CharCount;
			*Dest = *Temp;
			++Dest;
			++Temp;
		}
		*Dest = _T('\0');
	}
	
	/*********** Get the Stage3 Server Name *****************************/
	Temp = _tcsstr((TCHAR *) Stage2HtmlContents, STAGE3_SERVER_PREFIX);
	if (Temp)
	{
		Dest = Stage3Data->szServerName;
		Temp += _tcslen (STAGE3_SERVER_PREFIX);
		CharCount =	 sizeof Stage3Data->szServerName / sizeof TCHAR  - sizeof TCHAR	;
		while ( (CharCount > 0) &&(*Temp != _T('\0') ) && (*Temp != _T('\n')) && (*Temp != _T('\r')) )
		{
			-- CharCount;
			*Dest = *Temp;
			++Dest;
			++Temp;
		}
		*Dest = _T('\0');
		//MessageBox(NULL, Stage3Data->szServerName, "Stage3 Server", MB_OK);
	}

	/************ Get the name to upload the dump file as in Stage3 ***************/
	Temp = _tcsstr((TCHAR *) Stage2HtmlContents, STAGE3_FILENAME_PREFIX);
	if (Temp)
	{
		Dest = Stage3Data->szFileName;
		Temp += _tcslen (STAGE3_FILENAME_PREFIX);
		CharCount =	 sizeof Stage3Data->szFileName / sizeof TCHAR  - sizeof TCHAR	;
		while ((CharCount > 0) && (*Temp != _T('\0') ) && (*Temp != _T('\n')) && (*Temp != _T('\r')) )
		{
			-- CharCount;
			*Dest = *Temp;
			++Dest;
			++Temp;
		}
		*Dest = _T('\0');
//		MessageBox(NULL, Stage3Data->szFileName, "Stage3 FileName", MB_OK);
	}

	/************ Get the Stage4 ResponseServer name ***************/
	Temp = _tcsstr((TCHAR *) Stage2HtmlContents, STAGE4_SERVER_PREFIX);
	if (Temp)
	{
		Dest = Stage4Data->szServerName;
		Temp += _tcslen (STAGE4_SERVER_PREFIX);
		CharCount =	 sizeof Stage4Data->szServerName / sizeof TCHAR  - sizeof TCHAR	;
		while ( (CharCount > 0) &&(*Temp != _T('\0') ) && (*Temp != _T('\n')) && (*Temp != _T('\r')) )
		{
			-- CharCount;
			*Dest = *Temp;
			++Dest;
			++Temp;
		}
		*Dest = _T('\0');
	}

	/************ Get the Stage4 Response url ***************/
	Temp = _tcsstr((TCHAR *) Stage2HtmlContents, STAGE4_URL_PREFIX);
	if (Temp)
	{
		Dest = Stage4Data->szUrl;
		Temp += _tcslen (STAGE4_URL_PREFIX);
		CharCount =	 sizeof Stage4Data->szUrl / sizeof TCHAR  - sizeof TCHAR	;
		while ( (CharCount > 0) &&(*Temp != _T('\0') ) && (*Temp != _T('\n')) && (*Temp != _T('\r')) )
		{
			-- CharCount;
			*Dest = *Temp;
			++Dest;
			++Temp;
		}
		*Dest = _T('\0');
	}

	/************ Get the bucketID ***************/
	Temp = _tcsstr((TCHAR *) Stage2HtmlContents, BUCKET_PREFIX);
	if (Temp)
	{
		if ( *(Temp-1) == _T('i'))
		{
			// Find the next occurrence
			Temp += _tcslen (BUCKET_PREFIX);
			Temp = _tcsstr(Temp, BUCKET_PREFIX);
			if (Temp)
			{
				Dest = StatusContents->BucketID;
				Temp += _tcslen (BUCKET_PREFIX);
				CharCount =	 sizeof StatusContents->BucketID / sizeof TCHAR  - sizeof TCHAR	;
				while ((CharCount > 0) && (*Temp != _T('\0') ) && (*Temp != _T('\n')) && (*Temp != _T('\r')) )
				{
					-- CharCount;
					*Dest = *Temp;
					++Dest;
					++Temp;
				}
				*Dest = _T('\0');
			}
			else
			{
				if (StringCbCopy(StatusContents->BucketID, sizeof StatusContents->BucketID, _T("\0"))!= S_OK)
				{
					bStatus = FALSE;
					goto ERRORS;
				}
			}
		}
		else
		{	
			Dest = StatusContents->BucketID;
			Temp += _tcslen (BUCKET_PREFIX);
			CharCount =	 sizeof StatusContents->BucketID / sizeof TCHAR  - sizeof TCHAR	;
		    while ((CharCount > 0) && (*Temp != _T('\0') ) && (*Temp != _T('\n')) && (*Temp != _T('\r')) )
			{
				-- CharCount;
				*Dest = *Temp;
				++Dest;
				++Temp;
			}
			*Dest = _T('\0');
		}

	//	MessageBox(NULL, szStage3Server, "Stage3 Server", MB_OK);
	}
	else
	{
		if (StringCbCopy(StatusContents->BucketID, sizeof StatusContents->BucketID, _T("\0"))!= S_OK)
		{
			bStatus = FALSE;
			goto ERRORS;
		}
	}
	/************ Get the Microsoft Response ***************/
	Temp = _tcsstr((TCHAR *) Stage2HtmlContents, RESPONSE_PREFIX);
	if (Temp)
	{
		Dest = StatusContents->Response;
		Temp += _tcslen (RESPONSE_PREFIX);
		if (!FMicrosoftComURL(Temp))
		{
			if (StringCbCopy(StatusContents->Response, sizeof StatusContents->Response, _T("1")) != S_OK)
			{
				goto ERRORS;
			}
		}
		else
		{
			CharCount =	 sizeof StatusContents->Response / sizeof TCHAR  - sizeof TCHAR	;
			while ( (CharCount > 0) &&(*Temp != _T('\0') ) && (*Temp != _T('\n')) && (*Temp != _T('\r')) )
			{
				-- CharCount;
				*Dest = *Temp;
				++Dest;
				++Temp;
			}
			*Dest = _T('\0');
		}
		//MessageBox(NULL, szStage3Server, "Stage3 Server", MB_OK);
	}
	else
    {
		if (StringCbCopy(StatusContents->Response, sizeof StatusContents->Response, _T("\0"))!= S_OK)
		{
			bStatus = FALSE;
			goto ERRORS;
		}
	}
	/************ Get the Regkey data Item         ***************/
	Temp = _tcsstr((TCHAR *) Stage2HtmlContents, REGKEY_PREFIX);
	if (Temp)
	{
		Dest = StatusContents->RegKey;
		Temp += _tcslen (REGKEY_PREFIX);
		CharCount =	 sizeof StatusContents->RegKey / sizeof TCHAR  - sizeof TCHAR	;
		while ( (CharCount > 0) &&(*Temp != _T('\0') ) && (*Temp != _T('\n')) && (*Temp != _T('\r')) )
		{
			-- CharCount;
			*Dest = *Temp;
			++Dest;
			++Temp;
		}
	}
	else
    {
		if (StringCbCopy(StatusContents->RegKey, sizeof StatusContents->RegKey, _T("\0"))!= S_OK)
		{
			bStatus = FALSE;
			goto ERRORS;
		}
	}
	/************ Get the idata value        ***************/
	Temp = _tcsstr((TCHAR *) Stage2HtmlContents, IDATA_PREFIX);
	if (Temp)
	{
		Dest = StatusContents->iData;
		Temp += _tcslen (IDATA_PREFIX);
		CharCount =	 sizeof StatusContents->iData / sizeof TCHAR  - sizeof TCHAR	;
		while ( (CharCount > 0) &&(*Temp != _T('\0') ) && (*Temp != _T('\n')) && (*Temp != _T('\r')) )
		{
			-- CharCount;
			*Dest = *Temp;
			++Dest;
			++Temp;
		}
		*Dest = _T('\0');
	}
	else
    {
		if (StringCbCopy(StatusContents->iData, sizeof StatusContents->iData, _T("0\0"))!= S_OK)
		{
			bStatus = FALSE;
			goto ERRORS;
		}
	}
	/************ Get the list of files that need to be collected. ***************/
	Temp = _tcsstr((TCHAR *) Stage2HtmlContents, GETFILE_PREFIX);
	if (Temp)
	{
		Dest = StatusContents->GetFile;
		Temp += _tcslen (GETFILE_PREFIX);
		CharCount =	 sizeof StatusContents->GetFile / sizeof TCHAR  - sizeof TCHAR	;
		while ( (CharCount > 0) &&(*Temp != _T('\0') ) && (*Temp != _T('\n')) && (*Temp != _T('\r')) )
		{
			-- CharCount;
			*Dest = *Temp;
			++Dest;
			++Temp;
		}
		*Dest = _T('\0');
	}
	else
    {
		if (StringCbCopy(StatusContents->GetFile, sizeof StatusContents->GetFile, _T("\0"))!= S_OK)
		{
			bStatus = FALSE;
			goto ERRORS;
		}
	}

	/************ Get the collect file version data to be collected ***************/
	Temp = _tcsstr((TCHAR *) Stage2HtmlContents, GETFILEVER_PREFIX);
	if (Temp)
	{
		Dest = StatusContents->GetFileVersion;
		Temp += _tcslen (GETFILEVER_PREFIX);
		CharCount =	 sizeof StatusContents->GetFileVersion / sizeof TCHAR  - sizeof TCHAR	;
		while ( (CharCount > 0) &&(*Temp != _T('\0') ) && (*Temp != _T('\n')) && (*Temp != _T('\r')) )
		{
			-- CharCount;
			*Dest = *Temp;
			++Dest;
			++Temp;
		}
		*Dest = _T('\0');
	}
	else
    {
		if (StringCbCopy(StatusContents->GetFileVersion, sizeof StatusContents->GetFileVersion, _T("\0"))!= S_OK)
		{
			bStatus = FALSE;
			goto ERRORS;
		}
	}
	

	/************ Get the fDoc  Setting ***************/
	Temp = _tcsstr((TCHAR *) Stage2HtmlContents, FDOC_PREFIX);
	if (Temp)
	{
		Dest = StatusContents->fDoc ;
		Temp += _tcslen (FDOC_PREFIX);
		CharCount =	 sizeof StatusContents->fDoc / sizeof TCHAR  - sizeof TCHAR	;
		while ((CharCount > 0) && (*Temp != _T('\0') ) && (*Temp != _T('\n')) && (*Temp != _T('\r')) )
		{
			-- CharCount ;
			*Dest = *Temp;
			++Dest;
			++Temp;
		}
		*Dest = _T('\0');
	}
	else
    {
		if (StringCbCopy(StatusContents->fDoc, sizeof StatusContents->fDoc, _T("\0"))!= S_OK)
		{
			bStatus = FALSE;
			goto ERRORS;
		}
	}
	
	Temp = _tcsstr((TCHAR *) Stage2HtmlContents, MEMDUMP_PREFIX);
	if (Temp)
	{
		Dest = StatusContents->MemoryDump ;
		Temp += _tcslen (MEMDUMP_PREFIX);
		CharCount =	 sizeof StatusContents->MemoryDump / sizeof TCHAR  - sizeof TCHAR	;
		while ( (CharCount > 0) &&(*Temp != _T('\0') ) && (*Temp != _T('\n')) && (*Temp != _T('\r')) )
		{
			-- CharCount;
			*Dest = *Temp;
			++Dest;
			++Temp;
		}
		*Dest = _T('\0');
	}
	else
    {
		if (StringCbCopy(StatusContents->MemoryDump, sizeof StatusContents->MemoryDump, _T("\0"))!= S_OK)
		{
			bStatus = FALSE;
			goto ERRORS;
		}
	}
	/************ Get the WQL Setting ***************/
	Temp = _tcsstr((TCHAR *) Stage2HtmlContents, WQL_PREFIX);
	if (Temp)
	{
		Dest = StatusContents->WQL ;
		Temp += _tcslen (WQL_PREFIX);
		CharCount =	 sizeof StatusContents->WQL / sizeof TCHAR  - sizeof TCHAR	;
		while ((CharCount > 0) && (*Temp != _T('\0') ) && (*Temp != _T('\n')) && (*Temp != _T('\r')) )
		{
			-- CharCount ;
			*Dest = *Temp;
			++Dest;
			++Temp;
		}
		*Dest = _T('\0');
	}
	else
    {
		if (StringCbCopy(StatusContents->WQL, sizeof StatusContents->WQL, _T("\0"))!= S_OK)
		{
			bStatus = FALSE;
			goto ERRORS;
		}
	}
ERRORS:
	;
	return bStatus;
}

//-----------------------  Stage 1-4 Processing routines --------------------------------

BOOL 
ProcessStage1(TCHAR *Stage1URL, 
			  PSTATUS_FILE StatusContents)
/*++
Routine Description:

Parses the ASP page returned by the Stage1 URL if it exists.

Arguments:
    Stage1Url		- URL that points to the static Htm page for this bucket.

Return value:
	TRUE - We found the page and we are done.
    FALSE - The page was not found and we need to continue on to Stage2

++*/
{
	
	HINTERNET hSession = NULL;
	HINTERNET hConnect = NULL;
	DWORD     dwBytesRead = 0;
	int      ErrorCode = 0;  // Set to true if the page exists and the
										  // contents were successfully parsed.
	BYTE      *Buffer = NULL;
	DWORD     dwBufferSize = 0;
//	BYTE	  *BufferPos = NULL;
	BYTE	  *NewBuffer = NULL;
	DWORD	ResponseCode = 0;
	DWORD	index = 0;
	DWORD	ResLength = 255;

	hSession = InternetOpen(_T("Microsoft CER"),
							INTERNET_OPEN_TYPE_PRECONFIG,
							NULL,
							NULL,
							0);
	if (hSession)
	{
		// Connect to the stage1 url 
		// If the Stage1 URL page exists read 
		//     1. read the page
		//	   2. Parse the page contents for the bucketid and the response URL.
	
		hConnect = InternetOpenUrl(hSession,
								   Stage1URL,
								   NULL,
								   NULL,
								   INTERNET_FLAG_RELOAD, 
								   NULL);
		if (hConnect)
		{

			// Check the HTTP Header return code.
			
			HttpQueryInfo(hConnect,
						HTTP_QUERY_STATUS_CODE |HTTP_QUERY_FLAG_NUMBER,
						&ResponseCode,
						&ResLength,
						&index);
			if ( (ResponseCode < 200 ) || (ResponseCode > 299))
			{
				ErrorCode = -2;
				//MessageBox(hUserMode, _T("Failed to connect to the Internet.\r\nPlease verify your Internet connection."),NULL, MB_OK);
	
				goto ERRORS;
			}
		
			// Allocate the buffer Memory
			Buffer = (BYTE*) malloc (READFILE_BUFFER_INCREMENT);
			if (Buffer)
			{
				ZeroMemory(Buffer,READFILE_BUFFER_INCREMENT);
				do
				{
					dwBytesRead = 0;
					InternetReadFile( hConnect,
									  Buffer,
									  READFILE_BUFFER_INCREMENT,
									  &dwBytesRead);
					dwBufferSize += dwBytesRead;
					if (dwBytesRead == READFILE_BUFFER_INCREMENT)
					{
						// Ok we filled up a buffer allocate a new one 
						
						NewBuffer = (BYTE *) malloc (dwBufferSize + READFILE_BUFFER_INCREMENT);
						if (NewBuffer)
						{
							ZeroMemory (NewBuffer, dwBufferSize + READFILE_BUFFER_INCREMENT);
							memcpy(NewBuffer,Buffer, dwBufferSize);
							free(Buffer);
							Buffer = NewBuffer;
						}
						else
						{
							free(Buffer);
							Buffer = NULL;
							goto ERRORS;
						}
					}
				} while (dwBytesRead > 0);

				if (dwBufferSize > 0)
				{
					if (ParseStage1File(Buffer, StatusContents))
					{
						ErrorCode = 1;
					}
				}
			}
		}
		else
		{
			ErrorCode = -1;
			MessageBox(hUserMode, _T("Failed to connect to the Internet.\r\nPlease verify your Internet connection."),NULL, MB_OK);
		}
	}
	else
	{
		ErrorCode = -1;
		MessageBox(hUserMode, _T("Failed to connect to the Internet.\r\nPlease verify your Internet connection."),NULL, MB_OK);
	}
ERRORS:

	// Cleanup
	if (Buffer)
		free (Buffer);
	if (hConnect)
		InternetCloseHandle(hConnect);
	if (hSession)
		InternetCloseHandle(hSession);
	return ErrorCode;
}

BOOL 
ProcessStage2(TCHAR *Stage2URL,
				   BOOL b64Bit,
				   PSTATUS_FILE StatusContents,
				   STAGE3DATA *Stage3Data,
				   STAGE4DATA *Stage4Data)
/*++
Routine Description:

Parses the ASP page returned by the Stage2 URL.
Data the Page Contains:
	a)Does Microsoft need more data.
	b)What to name the dumpfile
	c)Where to upload the dumpfile
	d)The stage4 response server.
	e)The data to be added to the cab
	f)The stage4 url to use.
	g)The bucketID
	f)The response URL for this bucket.

// Sample file Contents:
Stage2 Response:
iData=1 
DumpFile=/Upload/66585585.cab 
DumpServer=watson5.watson.microsoft.com 
ResponseServer=watson5.watson.microsoft.com 
GetFile=c:\errorlog.log 
ResponseURL=
   /dw/StageFour.asp?iBucket=985561&Cab=/Upload/66585585.cab&Hang=0&Restricted=1&CorpWatson=1 
Bucket=985561 
Response=http://www.microsoft.com/ms.htm?iBucketTable=1&iBucket=985561&Cab=66585585.cab 

Arguments:

    Stage2Url		- URL that points to the static Htm page for this bucket.

Return value:
	TRUE - We Successfully Processed Stage2 move on to stage3.
    FALSE - There was an error processing the file move on to the next cab.

++*/
{
	HINTERNET hSession = NULL;
	HINTERNET hConnect = NULL;
	DWORD     dwBytesRead = 0;
	BOOL      bStage2Success = FALSE;  // Set to true if the page exists and the
										  // contents were successfully parsed.
	BYTE      *Buffer = NULL;
	DWORD     dwBufferSize = 0;
//	BYTE	  *BufferPos = NULL;
	BYTE      *NewBuffer = NULL;
	int       ResponseCode = 0;
	DWORD	index = 0;
	DWORD	ResLength = 255;
	
	hSession = InternetOpen(_T("Microsoft CER"),
							INTERNET_OPEN_TYPE_PRECONFIG,
							NULL,
							NULL,
							0);
	if (hSession)
	{
		// Connect to the stage1 url 
		// If the Stage1 URL page exists read 
		//     1. read the page
		//	   2. Parse the page contents for the bucketid and the response URL.
	
		hConnect = InternetOpenUrl( hSession,
									Stage2URL,
									NULL,
									NULL,
									INTERNET_FLAG_RELOAD,
									NULL);
		if (hConnect)
		{
			HttpQueryInfo(hConnect,
				HTTP_QUERY_STATUS_CODE |HTTP_QUERY_FLAG_NUMBER,
				&ResponseCode,
				&ResLength,
				&index);
			if ( (ResponseCode < 200 ) || (ResponseCode > 299))
			{
				bStage2Success = FALSE;
				MessageBox(hUserMode, _T("Failed to connect to the Internet.\r\nPlease verify your Internet connection."),NULL, MB_OK);
				goto ERRORS;
			}
			// Allocate the buffer Memory
			Buffer = (BYTE*) malloc (READFILE_BUFFER_INCREMENT);
			
			if (Buffer)
			{
				ZeroMemory(Buffer, READFILE_BUFFER_INCREMENT);
				do
				{
					dwBytesRead = 0;
					InternetReadFile(hConnect,
									Buffer + dwBufferSize,
									READFILE_BUFFER_INCREMENT,
									&dwBytesRead);
					dwBufferSize += dwBytesRead;
					if (dwBytesRead == READFILE_BUFFER_INCREMENT)
					{
						// Ok we filled up a buffer allocate a new one 
						
						NewBuffer = (BYTE *) malloc (dwBufferSize + READFILE_BUFFER_INCREMENT);
						if (NewBuffer)
						{
							ZeroMemory (NewBuffer, dwBufferSize + READFILE_BUFFER_INCREMENT);
							memcpy(NewBuffer,Buffer, dwBufferSize);
							free(Buffer);
							Buffer = NewBuffer;
						}
						else
						{
							free(Buffer);
							Buffer = NULL;
							goto ERRORS;
						}
					}

				} while (dwBytesRead > 0);

				if ((dwBufferSize > 0) && (Buffer[0] != _T('\0')))
				{
					//MessageBox(NULL, (TCHAR*) Buffer, "Stage2 Response", MB_OK);
					if (ParseStage2File(Buffer, StatusContents, Stage3Data, Stage4Data))
					{
						bStage2Success = TRUE;
					}
				}
			}
		}
		else
		{
			MessageBox(hUserMode, _T("Failed to connect to the Internet.\r\nPlease verify your Internet connection."),NULL, MB_OK);
			bStage2Success = FALSE;
			goto ERRORS;
		}
	}
	else
	{
		MessageBox(hUserMode, _T("Failed to connect to the Internet.\r\nPlease verify your Internet connection."),NULL, MB_OK);
		bStage2Success = FALSE;
	}
ERRORS:

	// Cleanup
	if (Buffer)
		free(Buffer);
	if (hConnect)
		InternetCloseHandle(hConnect);
	if (hSession)
		InternetCloseHandle(hSession);
	return bStage2Success;
}

BOOL 
ProcessStage3(TCHAR *szStage3FilePath, STAGE3DATA *Stage3Data)
/*++
Routine Description:

Builds and uploads the dumpfile cab.

Arguments:

    Stage3Url		Url Contains location to upload dumpfile to.

Return value:
	TRUE - We Successfully uploaded the file
    FALSE - An error occurred and the dumpfile was not successfully uploaded.

++*/
{
	static		const TCHAR *pszAccept[] = {_T("*.*"), 0};
	BOOL		bRet				= FALSE;
//	BOOL		UploadSuccess		= FALSE;
	DWORD		dwBytesRead			= 0;
	DWORD		dwBytesWritten		= 0;
	DWORD		ResponseCode		= 0;
	DWORD		ResLength			= 255;
	DWORD		index				= 0;
	DWORD		ErrorCode			= 0;
	HINTERNET   hSession			= NULL;
	HINTERNET	hConnect			= NULL;
	HINTERNET	hRequest			= NULL;
	INTERNET_BUFFERS   BufferIn		= {0};
	HANDLE      hFile				= INVALID_HANDLE_VALUE;
	BYTE		*pBuffer			= NULL;
//	HRESULT		hResult				= S_OK;
	BOOL		bStatus				= FALSE;

	hSession = InternetOpen(	_T("Microsoft CER"),
								INTERNET_OPEN_TYPE_PRECONFIG,
								NULL,
								NULL,
								0);
	if (!hSession)
	{
		ErrorCode = GetLastError();
		goto cleanup;
	}

	hConnect = InternetConnect(hSession,
								Stage3Data->szServerName,
								INTERNET_DEFAULT_HTTPS_PORT,
								NULL,
								NULL,
								INTERNET_SERVICE_HTTP,
								0,
								NULL);

	if (!hConnect)
	{
		ErrorCode = GetLastError();
		goto cleanup;
	}
	hRequest = HttpOpenRequest(	hConnect,
								_T("PUT"),
								Stage3Data->szFileName, 
								NULL,
								NULL,
								pszAccept,
								INTERNET_FLAG_NEED_FILE|INTERNET_FLAG_NO_CACHE_WRITE | INTERNET_FLAG_SECURE, 
								0);
	if (hRequest)
	{
		hFile = CreateFile( szStage3FilePath,
							GENERIC_READ,
							FILE_SHARE_READ,
							NULL,
							OPEN_EXISTING,
							FILE_ATTRIBUTE_NORMAL,
							NULL);
						
		if (hFile != INVALID_HANDLE_VALUE)
		{
		

			// Clear the buffer
			if ( (pBuffer = (BYTE *)malloc (70000)) != NULL)
			{
				BufferIn.dwStructSize = sizeof( INTERNET_BUFFERS );
				BufferIn.Next = NULL; 
				BufferIn.lpcszHeader = NULL;
				BufferIn.dwHeadersLength = 0;
				BufferIn.dwHeadersTotal = 0;
				BufferIn.lpvBuffer = NULL;                
				BufferIn.dwBufferLength = 0;
				BufferIn.dwOffsetLow = 0;
				BufferIn.dwOffsetHigh = 0;
				BufferIn.dwBufferTotal = GetFileSize (hFile, NULL);
				FillMemory(pBuffer, 70000,'\0'); // Fill buffer with data
			
//				DWORD dwBuffLen = sizeof DWORD; 

				if(!HttpSendRequestEx(	hRequest,
										&BufferIn,
										NULL,
										HSR_INITIATE,
										0))
				{
					;
				}
				else
				{
					do
					{
						dwBytesRead = 0;
						bRet = ReadFile(hFile,
										pBuffer, 
										70000,
										&dwBytesRead,
										NULL);
						if (bRet != 0)
						{
							bRet = InternetWriteFile(hRequest,
													pBuffer,
													dwBytesRead,
													&dwBytesWritten);

							if ( (!bRet) || (dwBytesWritten==0) )
							{
								;
							}

						
						}
					} while (dwBytesRead == 70000);
					CloseHandle(hFile);
					hFile = INVALID_HANDLE_VALUE;
					bRet = HttpEndRequest(	hRequest,
											NULL, 
											0, 
											0);
					if (bRet)
					{
						ResponseCode = 0;
						HttpQueryInfo(hRequest,
									HTTP_QUERY_STATUS_CODE |HTTP_QUERY_FLAG_NUMBER,
									&ResponseCode,
									&ResLength,
									&index);
					
						if ( (ResponseCode == 200) || (ResponseCode == 201))
						{
							ErrorCode = 0;
							bStatus = TRUE;
						}
					}
					
				}
				

			}
			
		}
		
		
	}


cleanup:
	// Clean up
	if (hFile!= INVALID_HANDLE_VALUE)
	{
		CloseHandle (hFile);
		hFile = INVALID_HANDLE_VALUE;
	}

	if (hSession)
	{
		InternetCloseHandle(hSession);
		hSession = NULL;
	}
	
	if (hConnect)
	{
		InternetCloseHandle(hConnect);
		hConnect = NULL;
	}


	if (hRequest)
	{
		InternetCloseHandle(hRequest);
		hRequest = NULL;
	}
	
	if (pBuffer)
	{
		free (pBuffer);
		pBuffer = NULL;
	}
	return bStatus;
}

BOOL 
ProcessStage4(STAGE4DATA *Stage4Data)
/*++
Routine Description:

	Sends the Cab Name and bucket number to the Watson server.
	The watson server then:
		1) Archives the cab
		2) Adds a record to cab table.
		3) Decrements DataWanted count.
		4) if DataWanted hits 0 Creates a static htm page.
		5) in the case of shutdown and appcompat reports returns the 
			url to launch the OCA site to process the file. ( Not used for CER )

Arguments:

   Stage4	- URL Contains the Bucketid and cabname to archive

Return value:
	TRUE - We successfully completed stage4
    FALSE - We failed to process Stage4

++*/
{

	HINTERNET hSession = NULL;
	HINTERNET hConnect = NULL;
	BOOL      bStage4Success = FALSE;  // Set to true if the page exists and the
										  // contents were successfully parsed.
	TCHAR     szStage4URL[MAX_PATH];

	if (StringCbPrintf(szStage4URL, 
					   sizeof szStage4URL,
					   _T("https://%s%s"),
					   Stage4Data->szServerName,
					   Stage4Data->szUrl)
					   != S_OK)
	{
		goto ERRORS;
	}

	hSession = InternetOpen(_T("Microsoft CER"),
							INTERNET_OPEN_TYPE_PRECONFIG,
							NULL,
							NULL,
							0);
	if (hSession)
	{
		hConnect = InternetOpenUrl(hSession, szStage4URL, NULL, NULL, 0, NULL);
		if (hConnect)
		{
			// We are done there is no response from stage 4
			// That we need to parse.
			bStage4Success = TRUE;
		}
	}
ERRORS:

	// Cleanup
	if (hConnect)
		InternetCloseHandle(hConnect);
	if (hSession)
		InternetCloseHandle(hSession);
	return bStage4Success;
	
}

BOOL 
WriteStatusFile(PUSER_DATA UserData)
/*++

Routine Description:

This routine renames a proccessed cab file from .cab to .old
Arguments:

    ResponseUrl			- Microsoft response for the recently submitted dump file.
    
Return value:

    Does not return a value
++*/
{
	BOOL bStatus = FALSE;
	// move the existing status file to .old

	TCHAR szFileNameOld[MAX_PATH];
	TCHAR *Temp;
	TCHAR Buffer[1024];
	HANDLE hFile = INVALID_HANDLE_VALUE;
	DWORD dwWritten = 0;
	if (StringCbCopy(szFileNameOld,sizeof szFileNameOld, UserData->StatusPath) != S_OK)
	{
		goto ERRORS;
	}
	Temp = szFileNameOld;
	Temp += _tcslen(szFileNameOld) * sizeof TCHAR;
	while ( (*Temp != _T('.')) && (Temp != szFileNameOld))
	{
		Temp --;
	}

	if (Temp == szFileNameOld)
	{
		goto ERRORS;
	}
	else
	{
		if (StringCbCopy (Temp,sizeof szFileNameOld , _T(".old")) != S_OK)
		{
			goto ERRORS;
		}

		if (PathFileExists(UserData->StatusPath))
		{
			MoveFileEx(UserData->StatusPath, szFileNameOld, TRUE);
		}
		

		// create a new status file.
	
		hFile = CreateFile(UserData->StatusPath, GENERIC_WRITE, NULL, NULL,CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,NULL);

		// Write the StatusContents data to the new status file
		if (_tcscmp (UserData->Status.Tracking, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("Tracking=%s\r\n"), UserData->Status.Tracking) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}
		
		
		// Write the StatusContents data to the new status file
		if (_tcscmp (UserData->Status.CrashPerBucketCount, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("Crashes per bucket=%s\r\n"), UserData->Status.CrashPerBucketCount) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}

		// Write the StatusContents data to the new status file
		if (_tcscmp (UserData->Status.UrlToLaunch, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("URLLaunch=%s\r\n"), UserData->Status.UrlToLaunch)  != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}

		// Write the StatusContents data to the new status file
		if (_tcscmp (UserData->Status.SecondLevelData, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("NoSecondLevelCollection=%s\r\n"), UserData->Status.SecondLevelData) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}

		// Write the StatusContents data to the new status file
		if (_tcscmp (UserData->Status.FileCollection, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("NoFileCollection=%s\r\n"), UserData->Status.FileCollection) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}

		// Write the StatusContents data to the new status file
		if (_tcscmp (UserData->Status.Response, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("Response=%s\r\n"), UserData->Status.Response) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}

		// Write the StatusContents data to the new status file
		if (_tcscmp (UserData->Status.BucketID, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("Bucket=%s\r\n"), UserData->Status.BucketID) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}

		// Write the StatusContents data to the new status file
		if (_tcscmp (UserData->Status.RegKey, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("RegKey=%s\r\n"), UserData->Status.RegKey) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);
		}

			
		// Write the StatusContents data to the new status file
		if (_tcscmp (UserData->Status.iData, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("iData=%s\r\n"),UserData->Status.iData) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}

		// Write the StatusContents data to the new status file
		if (_tcscmp (UserData->Status.WQL, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("WQL=%s\r\n"), UserData->Status.WQL) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}

		// Write the StatusContents data to the new status file
		if (_tcscmp (UserData->Status.GetFile, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("GetFile=%s\r\n"), UserData->Status.GetFile) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}

		// Write the StatusContents data to the new status file
		if (_tcscmp (UserData->Status.GetFileVersion, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("GetFileVersion=%s\r\n"), UserData->Status.GetFileVersion) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}
		
		if (_tcscmp (UserData->Status.AllowResponse, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("NoExternalURL=%s\r\n"), UserData->Status.AllowResponse) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);

		}
		
		if (_tcscmp (UserData->Status.MemoryDump, _T("\0")))
		{
			if (StringCbPrintf(Buffer, sizeof Buffer, _T("MemoryDump=%s\r\n"), UserData->Status.MemoryDump) != S_OK)
			{
				goto ERRORS;
			}
			WriteFile(hFile , Buffer, _tcslen(Buffer) *sizeof TCHAR , &dwWritten, NULL);
		}
		
		// Close the new status file
		CloseHandle(hFile);
		hFile = INVALID_HANDLE_VALUE;
		// if all ok delete the old status file.
		//DeleteFile(szFileNameOld);
	}
	
ERRORS:

	if (hFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hFile);
	}
	return bStatus;
}

void 
RenameUmCabToOld(TCHAR *szFileName)
/*++

Routine Description:

This routine renames a proccessed cab file from .cab to .old
Arguments:

    ResponseUrl			- Microsoft response for the recently submitted dump file.
    
Return value:

    Does not return a value
++*/
{
	TCHAR szFileNameOld[MAX_PATH];
	TCHAR *Temp;

	if (StringCbCopy(szFileNameOld,sizeof szFileNameOld, szFileName) != S_OK)
	{
		goto ERRORS;
	}
	Temp = szFileNameOld;
	Temp += _tcslen(szFileNameOld) * sizeof TCHAR;
	while ( (*Temp != _T('.')) && (Temp != szFileNameOld))
	{
		Temp --;
	}

	if (Temp == szFileNameOld)
	{
		// Abort since we did not find the .cab extension.
		goto ERRORS;
	}
	else
	{
		if (StringCbCopy (Temp,sizeof szFileNameOld , _T(".old")) != S_OK)
		{
			goto ERRORS;
		}

		MoveFileEx(szFileName, szFileNameOld, TRUE);
	}
ERRORS:
	return;
}

BOOL 
RenameAllCabsToOld(TCHAR *szPath)
/*++

Routine Description:

This routine renames a proccessed cab file from .cab to .old
Arguments:

    ResponseUrl			- Microsoft response for the recently submitted dump file.
    
Return value:

    Does not return a value
++*/
{
	WIN32_FIND_DATA FindData;
	HANDLE hFind = INVALID_HANDLE_VALUE;
	TCHAR szSearchPath[MAX_PATH];
	TCHAR szFilePath[MAX_PATH];
	if (!szPath)
	{
		return FALSE;
	}
	if (StringCbPrintf(szSearchPath, sizeof szSearchPath, _T("%s\\*.cab"), szPath) != S_OK)
	{
		return FALSE;
	}
	
	// find first find next loop
	hFind = FindFirstFile(szSearchPath, &FindData);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		
		// Build file path
		do
		{
			if (StringCbPrintf(szFilePath, sizeof szFilePath, _T("%s\\%s"),szPath, FindData.cFileName) != S_OK)
			{
				FindClose (hFind);
				return FALSE;
			}
			RenameUmCabToOld(szFilePath);
		}while (FindNextFile(hFind, &FindData));
		FindClose(hFind);
	}
	
	return TRUE;
}
BOOL  WriteRepCountFile(TCHAR *FilePath, int Count)
{
	HANDLE hFile = INVALID_HANDLE_VALUE;
	TCHAR  Buffer[100];
    BOOL   Status = FALSE;
	DWORD  dwWritten = 0;

	ZeroMemory(Buffer, sizeof Buffer);
	hFile = CreateFile(FilePath, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL,NULL);
	if (hFile != INVALID_HANDLE_VALUE)
	{
		if (StringCbPrintf(Buffer,sizeof Buffer, _T("ReportedCount=%d"), Count) == S_OK)
		{
		   if (WriteFile(hFile, Buffer, _tcslen (Buffer) * sizeof TCHAR, &dwWritten, NULL))
		   {
			   Status = TRUE;
		   }
		   else
		   {
			   Status = FALSE;
		   }
		}
		else
		{
			Status = FALSE;
		}
		CloseHandle (hFile);
		hFile = INVALID_HANDLE_VALUE;
	}
	return Status;
}


//-----------------------  User Mode Reporting Control Function --------------------------------
DWORD WINAPI UserUploadThreadProc (void *ThreadParam)
/*++

Routine Description:

This routine renames a proccessed cab file from .cab to .old
Arguments:

    ResponseUrl			- Microsoft response for the recently submitted dump file.
    
Return value:

    Does not return a value
++*/

{
	TCHAR Stage1URL[1024];
	TCHAR Stage2URL[1024];
//	TCHAR Stage3Request[1024];
	TCHAR Stage4Request[1024];
	TCHAR szSearchPath[MAX_PATH];
	TCHAR szStage3FilePath[MAX_PATH];
	TCHAR szDestFileName[MAX_PATH];
	PTHREAD_PARAMS pParams = NULL;
	WIN32_FIND_DATA FindData;
	HANDLE hFind = INVALID_HANDLE_VALUE;
	PUSER_DATA pUserData = NULL;
	BOOL bContinue = FALSE;
	BOOL bEOF = FALSE;
	int iCabCount = 0;
	STAGE3DATA Stage3Data;
	STAGE4DATA Stage4Data;
	int iBucketCount = 0;
	BOOL bDone = FALSE;
	HANDLE hEvent = NULL;
	USER_DATA UserData;
	int i = 0;
	int iIndex = 0;
	TCHAR ProcessText[MAX_PATH];
	LVITEM lvi;
	TCHAR *Source = NULL;
	TCHAR Stage1Part1[1000];
	int iResult = 0;
	int	iCount = 0;
	BOOL bResult = FALSE;
	BOOL bSyncForSolution = FALSE;
	ZeroMemory (Stage1URL, sizeof Stage1URL);
	ZeroMemory (Stage2URL, sizeof Stage2URL);
	ZeroMemory (ProcessText, sizeof ProcessText);
	ZeroMemory (Stage4Request, sizeof Stage4Request);
	ZeroMemory (szSearchPath, sizeof szSearchPath);
	ZeroMemory (szStage3FilePath, sizeof szStage3FilePath);
	ZeroMemory (szDestFileName, sizeof szDestFileName);
	ZeroMemory (Stage1Part1, sizeof Stage1Part1);
	pParams = (PTHREAD_PARAMS) ThreadParam;
	
	hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, _T("StopUserUpload"));

	if (!hEvent)
	{
		goto ERRORS;
	}

	if ( pParams->bSelected)
	{
		// We are uploading a subset of the total buckets
		iBucketCount = ListView_GetSelectedCount(pParams->hListView);
		if (iBucketCount <= 0)
		{
			goto ERRORS;
		}
		else
		{
			// Set the PB Range to the count of selected items
			SendDlgItemMessage(pParams->hwnd,IDC_TOTAL_PROGRESS, PBM_SETRANGE,0, MAKELPARAM(0, iBucketCount));
			SendDlgItemMessage(pParams->hwnd,IDC_TOTAL_PROGRESS, PBM_SETSTEP,1,0);
		}
	}
	
	else
	{
		cUserData.ResetCurrPos();
		cUserData.GetNextEntry(&UserData, &bEOF);
		if (!bEOF )
		{
			do 
			{
				++iBucketCount;
			} while (cUserData.GetNextEntry(&UserData, &bEOF));
			cUserData.ResetCurrPos();
			SendDlgItemMessage(pParams->hwnd,IDC_TOTAL_PROGRESS, PBM_SETRANGE,0, MAKELPARAM(0, iBucketCount));
			SendDlgItemMessage(pParams->hwnd,IDC_TOTAL_PROGRESS, PBM_SETSTEP,1,0);
		}
		else
			goto ERRORS; // No buckets to upload
    }

	iIndex = -1;
	do
	{
		if (!PathIsDirectory(CerRoot))
		{
			MessageBox(pParams->hwnd, _T("Reporting to Microsoft failed.\r\nUnable to connect to CER tree."), NULL,MB_OK);
			goto ERRORS;
		}

		if (WaitForSingleObject(hEvent, 50) == WAIT_OBJECT_0)
		{
			bDone = TRUE;
			goto ERRORS;
		}
		if (!pParams->bSelected)
		{
			bEOF = FALSE;
			cUserData.GetNextEntryNoMove(&UserData, &bEOF);
			pUserData = &UserData;
		}
		else
		{
			if (iBucketCount  <= 0)
			{
				goto ERRORS; // Were done
			}
			--iBucketCount;
			// get the next index from the list view and decrement iBucketCount
			iIndex = ListView_GetNextItem(pParams->hListView,iIndex, LVNI_SELECTED);
			ZeroMemory(&lvi, sizeof LVITEM);
			lvi.iItem = iIndex;
			lvi.mask = LVIF_PARAM ;
			ListView_GetItem(pParams->hListView,&lvi);
			iIndex = lvi.lParam;

			pUserData = cUserData.GetEntry(iIndex);
			if (!pUserData)
			{
				goto Done;
			}
		}
		
		if (StringCbPrintf(szSearchPath, sizeof szSearchPath,_T("%s\\*.cab"),pUserData->BucketPath) != S_OK)
		{
			goto ERRORS;
		}
		if (StringCbPrintf(ProcessText, sizeof ProcessText, _T("Processing Bucket: %s"), pUserData->BucketPath) != S_OK)
		{
			goto ERRORS;
		}
		SetDlgItemText(pParams->hwnd, IDC_CAB_TEXT, ProcessText);
		bSyncForSolution = FALSE;
		// Get the cab count
		hFind = FindFirstFile(szSearchPath, &FindData);
		if (hFind != INVALID_HANDLE_VALUE)
		{
			do
			{
                ++iCabCount;
			} while (FindNextFile(hFind, &FindData));
			FindClose(hFind);
			// Set Bucket PB range to iCabCount or 100 if iCabCount > 100
			SendDlgItemMessage(pParams->hwnd,IDC_FILE_PROGRESS, PBM_SETRANGE,0, MAKELPARAM(0, iCabCount));
			SendDlgItemMessage(pParams->hwnd,IDC_FILE_PROGRESS, PBM_SETSTEP,1,0);
	
		}
		else
		{
			// Done with bucket
			bSyncForSolution = TRUE;
			SendDlgItemMessage(pParams->hwnd ,IDC_TOTAL_PROGRESS, PBM_STEPIT, 0,0);
			//goto Done;
	
		}
		// Build Stage 1 url
	/*	if (StringCbPrintf(Stage1URL, 
						sizeof Stage1URL,
						_T("http://%s%s/%s/%s/%s/%s/%s.htm"),
						DEFAULT_SERVER,
						PARTIALURL_STAGE_ONE,
						pUserData->AppName,
						pUserData->AppVer,
						pUserData->ModName,
						pUserData->ModVer,
						pUserData->Offset) != S_OK)
		{
			goto ERRORS;
		}
		*/
		ZeroMemory (Stage1Part1, sizeof Stage1Part1);
		if (StringCbPrintf(Stage1Part1, sizeof Stage1Part1, _T("/%s/%s/%s/%s/%s"), 
												pUserData->AppName,
												pUserData->AppVer,
												pUserData->ModName,
												pUserData->ModVer,
												pUserData->Offset) != S_OK)
		{
			goto ERRORS;
		}

		Source = Stage1Part1;
		while (*Source != _T('\0'))
		{
			if (*Source == _T('.'))
			{
				*Source = _T('_');
			}
			++Source;
		}

		// Now build the rest of the url
		if (StringCbPrintf(Stage1URL, sizeof Stage1URL, _T("http://%s%s%s.htm?CER=15"), DEFAULT_SERVER,PARTIALURL_STAGE_ONE, Stage1Part1 ) != S_OK)
		{
			goto ERRORS;
		}
	
		// GetStage1 Response
		iResult = ProcessStage1(Stage1URL, &(pUserData->Status));
		++ pUserData->iReportedCount;
		if (iResult == 1 )
		{
			// we are done.
			// rename all of the cabs in this bucket to .old and Update the status.txt 
			RenameAllCabsToOld(pUserData->BucketPath);
			if (StringCbCopy(pUserData->CabCount, sizeof pUserData->CabCount, _T("0"))!= S_OK)
			{
				goto ERRORS;
			}
			WriteStatusFile(pUserData);
			goto Done;
		}

		if (iResult == -1)
		{
			goto ERRORS;
		}

		if (!bSyncForSolution)
		{
			if (!PathIsDirectory(CerRoot))
			{

				MessageBox(pParams->hwnd, _T("Reporting to Microsoft failed.\r\nUnable to connect to CER tree."), NULL,MB_OK);
				goto ERRORS;
			}
			hFind = FindFirstFile(szSearchPath, &FindData);
			if (hFind == INVALID_HANDLE_VALUE)
			{
				// No need to continue there are no cabs to upload.
				goto Done;
			}
			// Build Stage 2 Url
			if (!pUserData->Is64Bit)
			{
				// if 32 bit use this one.
				// Get Stage 2 response
				if (StringCbPrintf(Stage2URL,
					sizeof Stage2URL, 
					_T("https://%s%s?szAppName=%s&szAppVer=%s&szModName=%s&szModVer=%s&offset=%s&szBuiltBy=CORPWATSON"),
					DEFAULT_SERVER,
					PARTIALURL_STAGE_TWO_32,
					pUserData->AppName,
					pUserData->AppVer,
					pUserData->ModName,
					pUserData->ModVer,
					pUserData->Offset) != S_OK)
				{
					goto ERRORS;
				}
			}
			else
			{
				// If 64Bit Use this one.
				if (StringCbPrintf(Stage2URL,
					sizeof Stage2URL, 
					_T("https://%s%s?szAppName=%s&szAppVer=%s&szModName=%s&szModVer=%s&offset=%s&szBuiltBy=CORPWATSON"),
					DEFAULT_SERVER,
					PARTIALURL_STAGE_TWO_64,
					pUserData->AppName,
					pUserData->AppVer,
					pUserData->ModName,
					pUserData->ModVer,
					pUserData->Offset) != S_OK)
				{
					goto ERRORS;
				}
			}
			
			ZeroMemory (&Stage3Data, sizeof Stage3Data);
			ZeroMemory (&Stage4Data, sizeof Stage4Data);
			if (ProcessStage2(Stage2URL,TRUE, &(pUserData->Status), &Stage3Data, &Stage4Data ))
			{
				
				do 
				{
					if (!PathIsDirectory(CerRoot))
					{
						MessageBox(pParams->hwnd, _T("Reporting to Microsoft failed.\r\nUnable to connect to CER tree."), NULL,MB_OK);
						goto ERRORS;
					}
					if (WaitForSingleObject(hEvent, 50) == WAIT_OBJECT_0)
					{
						bDone = TRUE;
						goto ERRORS;
					}
					// Build Stage3 Strings
					WriteStatusFile(pUserData);
					if (StringCbPrintf(szStage3FilePath, sizeof szStage3FilePath, _T("%s\\%s"), pUserData->BucketPath, FindData.cFileName) != S_OK)
					{
						goto ERRORS;
					}
					// Get the next cab and move on to stage3

					if (!_tcscmp(Stage3Data.szServerName, _T("\0")))
					{
						// We are done with this bucket
						RenameAllCabsToOld(pUserData->BucketPath);
						if (StringCbCopy(pUserData->CabCount, sizeof pUserData->CabCount, _T("0"))!= S_OK)
						{
							goto ERRORS;
						}
						bContinue = FALSE;
						goto Done; // Jump to the end of the loop
					}
					if (ProcessStage3(szStage3FilePath, &Stage3Data))
					{
						// We successfully uploaded the cab rename it and move on to stage4
						RenameUmCabToOld(szStage3FilePath);
						i = _ttoi(pUserData->CabCount);
						if ( i > 0)
						{
							_itot (i-1, pUserData->CabCount, 10);
						}
						
						ProcessStage4(&Stage4Data);
					}
					ZeroMemory (&Stage3Data, sizeof Stage3Data);
					ZeroMemory (&Stage4Data, sizeof Stage4Data);

					bResult = FALSE;
					bResult = ProcessStage2(Stage2URL,TRUE, &(pUserData->Status), &Stage3Data, &Stage4Data );
					if (bResult)
					{
						WriteStatusFile(pUserData);
						if (_tcscmp(Stage3Data.szServerName, _T("\0")))
						{
							iResult = ProcessStage1(Stage1URL, &(pUserData->Status));
							++ pUserData->iReportedCount;
							if (iResult == 1 )
							{
								// we are done.
								// rename all of the cabs in this bucket to .old and Update the status.txt 
								RenameAllCabsToOld(pUserData->BucketPath);
								if (StringCbCopy(pUserData->CabCount, sizeof pUserData->CabCount, _T("0"))!= S_OK)
								{
									goto ERRORS;
								}
								WriteStatusFile(pUserData);
								goto Done;
							}

							if (iResult == -1)
							{
								goto ERRORS;
							}
							bContinue = TRUE;
						}
						else
						{
							bContinue = FALSE;
						}
						
					}

					// Do we need to do this each time? 
					SendDlgItemMessage(pParams->hwnd ,IDC_FILE_PROGRESS, PBM_STEPIT, 0,0);
				}while( (bResult) && (bContinue) && FindNextFile(hFind, &FindData) ) ;
				FindClose(hFind);
				if (!bResult)
					goto Done;
				SendDlgItemMessage(pParams->hwnd ,IDC_TOTAL_PROGRESS, PBM_STEPIT, 0,0);
				if (!bContinue)
				{
					// Microsoft doesn't want anymore cabs.
					// Rename the remaining cabs to .old
					RenameAllCabsToOld(pUserData->BucketPath);
					if (StringCbCopy(pUserData->CabCount, sizeof pUserData->CabCount, _T("0"))!= S_OK)
					{
						goto ERRORS;
					}
				}
			}
			if (WaitForSingleObject(hEvent, 50) == WAIT_OBJECT_0)
			{
				bDone = TRUE;
				
			}
		}
Done:
	    
		// Now that we are done with the stage 1 - 4 processing for new dumps.
		// Hit the Stage 1 url for this bucket pUserData->HitCount - pUserData->Reported count times
		// This will ensure that we have an accurate count of how many times this issue has been encountered.
		iCount = (_ttoi(pUserData->Hits) - pUserData->iReportedCount);
		if (iCount > 0)
		{
			for (int Counter = 0; Counter < iCount; Counter++)
			{
				iResult = ProcessStage1(Stage1URL, &(pUserData->Status));
				// We don't care if it succeeded or not we just want to bump up the counts.
				++ pUserData->iReportedCount;
            }
		}

	    WriteRepCountFile(pUserData->ReportedCountPath, pUserData->iReportedCount);

		if (!pParams->bSelected)
		{
			// Write back the new data for this bucket
			cUserData.SetCurrentEntry(&UserData);
			cUserData.MoveNext(&bEOF);
		}
	} while ( (!bEOF) && (iBucketCount > 0) && (!bDone));
ERRORS:
	PostMessage(pParams->hwnd, WmSyncDone, FALSE, 0);
	if (hEvent)
	{
		CloseHandle(hEvent);
		hEvent = NULL;
	}
	return 0;

}


void OnUserSubmitDlgInit(HWND hwnd)
/*++

Routine Description:

This routine renames a proccessed cab file from .cab to .old
Arguments:

    ResponseUrl			- Microsoft response for the recently submitted dump file.
    
Return value:

    Does not return a value
++*/
{
	// create a thread to process the uploads
	HANDLE hThread;

	ThreadParams.hwnd = hwnd;
	hThread = CreateThread(NULL, 0,UserUploadThreadProc , &ThreadParams, 0 , NULL );
	CloseHandle(hThread);
}

LRESULT CALLBACK 
UserSubmitDlgProc(
	HWND hwnd,
	UINT iMsg,
	WPARAM wParam,
	LPARAM lParam
	)
/*++

Routine Description:

This routine renames a proccessed cab file from .cab to .old
Arguments:

    ResponseUrl			- Microsoft response for the recently submitted dump file.
    
Return value:

    Does not return a value
++*/
{
//	int CurrentPos = 0;
	
	//HWND Parent = GetParent(hwnd);
	switch (iMsg)
	{
	case WM_INITDIALOG:
		// Start the upload process in a new thread.
		// Report results using WM_FILEDONE 
		
//		CreateEvent();

		
		SendDlgItemMessage(hwnd ,IDC_TOTAL_PROGRESS, PBM_SETSTEP, MAKELONG( 1,0),0);

		CenterDialogInParent(hwnd);
		SendDlgItemMessage(hwnd ,IDC_FILE_PROGRESS, PBM_SETSTEP, MAKELONG( 1,0),0);
		g_hUserStopEvent = CreateEvent(NULL, FALSE, FALSE, _T("StopUserUpload"));
		if (!g_hUserStopEvent)
		{
			// Now What
		}
		PostMessage(hwnd, WmSyncStart, FALSE, 0);
		
		//OnSubmitDlgInit(hwnd);
		return TRUE;

	case WmSyncStart:
		OnUserSubmitDlgInit(hwnd);
		
		return TRUE;

	case WmSetStatus:
		
		return TRUE;

	case WmSyncDone:
			if (g_hUserStopEvent)
			{
				SetEvent(g_hUserStopEvent);
				CloseHandle(g_hUserStopEvent);
				g_hUserStopEvent = NULL;
			}
			
			EndDialog(hwnd, 1);
			
		return TRUE;

	case WM_DESTROY:
		if (g_hUserStopEvent)
		{
			SetEvent(g_hUserStopEvent);
			CloseHandle(g_hUserStopEvent);
			g_hUserStopEvent = NULL;
		}
		else
		{
			EndDialog(hwnd, 1);
		}
		return TRUE;

	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		case IDCANCEL:
			if (g_hUserStopEvent)
			{
				SetEvent(g_hUserStopEvent);
				CloseHandle(g_hUserStopEvent);
				g_hUserStopEvent = NULL;
			}
			else
			{
				EndDialog(hwnd, 1);
			}
		break;
		}
	
	
	}

	return FALSE;
}



BOOL
ReportUserModeFault(HWND hwnd, BOOL bSelected,HWND hList)
/*++

Routine Description:

This routine renames a proccessed cab file from .cab to .old
Arguments:

    ResponseUrl			- Microsoft response for the recently submitted dump file.
    
Return value:

    Does not return a value
++*/
{
	

	ThreadParams.bSelected = bSelected;
	ThreadParams.hListView = hList;
	
	if (!DialogBox(g_hinst,MAKEINTRESOURCE(IDD_USERMODE_SYNC ), hwnd, (DLGPROC) UserSubmitDlgProc))
	{
		// Failed somewhere to upload the user mode files to Microsoft.
		// What error do we want to give to the User.
		return FALSE;
	}
	return TRUE;
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\cer\cw15\winmessages.h ===
#ifndef _WIN_MESSAGES_H
#define _WIN_MESSAGES_H

enum
{
	WmSyncNextBucket = WM_USER + 0x1027,
	WmSyncNextCab,
	WmSyncDoneCab,
	WmSyncDoneBucket,
	WmSyncStart,
	WmSyncCompleted,
	WmSyncAborted,
	WmSetStatus,
	WmSyncDone,
	WM_FileTreeLoaded
	
};	
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\cer\cw15\usermode.cpp ===
#include "main.h"
#include "UserMode.h"
#include "WinMessages.h"
#include "CUserList.h"
#include "ReportFault.h"


DWORD uTextOffset = 10;
DWORD uBucketWindowSize = 120;
BOOL UserListItemSelected = FALSE;



extern TCHAR szUserColumnHeaders[][100];   
extern GLOBAL_POLICY GlobalPolicy;

typedef enum LEVEL {APPNAME, APPVER, MODNAME,MODVER, OFFSET};
extern TCHAR CerRoot[];
extern HINSTANCE g_hinst;
extern HWND  hUserMode;
extern CUserList cUserData;
HWND   g_hUMListView = NULL;
BOOL   g_bUMSortAsc = TRUE;
int  g_dwUmodeIndex = -1;
int  g_iSelCurrent = -1;
extern BOOL g_bFirstBucket;
extern g_bAdminAccess;
BOOL   bCapture = FALSE;

BOOL ParsePolicy( TCHAR *Path, PUSER_DATA pUserData, BOOL Global);
int CALLBACK UmCompareFunc (LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
	int Result = -1;
	int SubItemIndex = (INT) lParamSort;
	int Item1 = 0;
	int Item2 = 0;
//	int OldIndex = 0;
	TCHAR String1 [1000];
	TCHAR String2 [1000];
	PUSER_DATA pItem1 = NULL;
	PUSER_DATA pItem2 = NULL;

	ZeroMemory(String1, sizeof String1);
	ZeroMemory(String2, sizeof String2);

	ListView_GetItemText( g_hUMListView, lParam1, SubItemIndex, String1, 1000);
	ListView_GetItemText( g_hUMListView, lParam2, SubItemIndex, String2, 1000);

	pItem1 = cUserData.GetEntry(lParam1);
	pItem2 = cUserData.GetEntry(lParam2);
	if (g_bUMSortAsc)   // Sort Acending
	{
		if ((lParamSort == 0) || (lParamSort == 6) || (lParamSort == 7) || (lParamSort == 8))
		{
			// Conver to int and compare
			Item1 = atoi(String1);
			Item2 = atoi(String2);
			if (Item1 > Item2) 
				Result = 1;
			else
				Result = -1;
		}
		else
		{
			Result = _tcsicmp(String1,String2);
		}
	}
	else						// Sort Decending
	{
		if ((lParamSort == 0) || (lParamSort == 6) || (lParamSort == 7) || (lParamSort == 8))
		{
			// Conver to int and compare
			Item1 = atoi(String1);
			Item2 = atoi(String2);
			if (Item1 > Item2) 
				Result = -1;
			else
				Result = 1;
		}
		else
		{
			Result = -_tcsicmp(String1,String2);
		}
		
	}
	return Result; 
}


void PopulateFilters(HWND hwnd)
{
	COMBOBOXEXITEM cbi;
	BOOL bEOF = FALSE;
//	int iIndex = 0;
	USER_DATA UserData;
	HWND hAppnameFltr = GetDlgItem(hwnd, IDC_APPNAME_FILTER);
	HWND hAppverFltr = GetDlgItem(hwnd, IDC_APPVER_FILTER);
	HWND hModnameFltr = GetDlgItem(hwnd, IDC_MODNAME_FILTER);
	HWND hModverFltr = GetDlgItem(hwnd, IDC_MODVER_FILTER);
	// Now run through the UserMode linked list and populate the filters.
	ZeroMemory(&cbi, sizeof COMBOBOXEXITEM);

	ComboBox_ResetContent(hAppnameFltr);
	ComboBox_ResetContent(hAppverFltr);
    ComboBox_ResetContent(hModnameFltr);
    ComboBox_ResetContent(hModverFltr);
	ComboBox_InsertString(hAppnameFltr,0,_T("(All Applications)"));
	ComboBox_SetCurSel(hAppnameFltr, 0);
	ComboBox_InsertString(hAppverFltr,0,_T("(All Application Versions)"));
	ComboBox_SetCurSel(hAppverFltr, 0);
	ComboBox_InsertString(hModnameFltr,0,_T("(All Modules)"));
	ComboBox_SetCurSel(hModnameFltr, 0);
	ComboBox_InsertString(hModverFltr,0,_T("(All Module Versions)"));
	ComboBox_SetCurSel(hModverFltr, 0);

	// Now for each entry in the cUserData Linked list fill in the filters
	// Avoiding duplicates if possible.
	cUserData.ResetCurrPos();
	while(cUserData.GetNextEntry(&UserData, &bEOF))
	{
		if (ComboBox_FindStringExact(hAppnameFltr, -1, UserData.AppName) == CB_ERR)
			ComboBox_InsertString(hAppnameFltr,1,UserData.AppName);
		if (ComboBox_FindStringExact(hAppverFltr, -1, UserData.AppVer) == CB_ERR)
			ComboBox_InsertString(hAppverFltr,1,UserData.AppVer);
		if (ComboBox_FindStringExact(hModnameFltr, -1, UserData.ModName) == CB_ERR)
			ComboBox_InsertString(hModnameFltr,1,UserData.ModName);
		if (ComboBox_FindStringExact(hModverFltr, -1, UserData.ModVer) == CB_ERR)
			ComboBox_InsertString(hModverFltr,1,UserData.ModVer);
	}
}


void PopulateFiltersWSelection(HWND hwnd)
{
//	COMBOBOXEXITEM cbi;
	BOOL bEOF = FALSE;
//	int iIndex = 0;
	USER_DATA UserData;
	HWND hAppnameFltr = GetDlgItem(hwnd, IDC_APPNAME_FILTER);
	HWND hAppverFltr = GetDlgItem(hwnd, IDC_APPVER_FILTER);
	HWND hModnameFltr = GetDlgItem(hwnd, IDC_MODNAME_FILTER);
	HWND hModverFltr = GetDlgItem(hwnd, IDC_MODVER_FILTER);

	TCHAR       AppNameFilter[MAX_PATH];
	TCHAR       AppVerFilter[MAX_PATH];
	TCHAR       ModNameFilter[MAX_PATH];
	TCHAR       ModVerFilter[MAX_PATH];

	BOOL bUseAppName = FALSE;
	BOOL bUseAppVer = FALSE;
	BOOL bUseModName = FALSE;
	BOOL bUseModVer = FALSE;
	
	
	int iAppNameSel = 0;
	int iAppVerSel = 0;
	int iModNameSel = 0;
	int iModVerSel = 0;

	iAppNameSel = ComboBox_GetCurSel(hAppnameFltr);
	iAppVerSel  = ComboBox_GetCurSel(hAppverFltr);
	iModNameSel = ComboBox_GetCurSel(hModnameFltr);
	iModVerSel  = ComboBox_GetCurSel(hModverFltr);
	// Get the current Filter Selection Strings.
	if (iAppNameSel != 0)
	{
		bUseAppName = TRUE;
		ComboBox_GetLBText(hAppnameFltr,iAppNameSel, AppNameFilter);
	}
	if (iAppVerSel != 0) 
	{
		bUseAppVer = TRUE;
		ComboBox_GetLBText(hAppverFltr,iAppVerSel, AppVerFilter);
	}
	if (iModNameSel != 0)
	{
		bUseModName = TRUE;
        ComboBox_GetLBText(hModnameFltr,iModNameSel, ModNameFilter);
	}
	if (iModVerSel != 0)
	{
		bUseModVer = TRUE;
		ComboBox_GetLBText(hModverFltr,iModVerSel, ModVerFilter);
		
	}

	// Now run through the UserMode linked list and populate the filters.
	//ZeroMemory(&cbi, sizeof COMBOBOXEXITEM);

	
	ComboBox_ResetContent(hAppnameFltr);
	ComboBox_ResetContent(hAppverFltr);
    ComboBox_ResetContent(hModnameFltr);
    ComboBox_ResetContent(hModverFltr);

	ComboBox_InsertString(hAppnameFltr,0,_T("(All Applications)"));
	ComboBox_SetCurSel(hAppnameFltr, 0);
	ComboBox_InsertString(hAppverFltr,0,_T("(All Application Versions)"));
	ComboBox_SetCurSel(hAppverFltr, 0);
	ComboBox_InsertString(hModnameFltr,0,_T("(All Modules)"));
	ComboBox_SetCurSel(hModnameFltr, 0);
	ComboBox_InsertString(hModverFltr,0,_T("(All Module Versions)"));
	ComboBox_SetCurSel(hModverFltr, 0);

	if (bUseAppName)
	{
		bUseAppName = TRUE;
		//ComboBox_GetLBText(hAppnameFltr,iAppNameSel, AppNameFilter);
		ComboBox_InsertString(hAppnameFltr,1,AppNameFilter);
		ComboBox_SetCurSel(hAppnameFltr, 1);
	}
	if (iAppVerSel != 0) 
	{
		bUseAppVer = TRUE;
		ComboBox_InsertString(hAppverFltr,1, AppVerFilter);
		ComboBox_SetCurSel(hAppverFltr,1);
	}
	if (iModNameSel != 0)
	{
		bUseModName = TRUE;
        ComboBox_InsertString(hModnameFltr,1, ModNameFilter);
		ComboBox_SetCurSel(hModnameFltr,1);
	}
	if (iModVerSel != 0)
	{
		bUseModVer = TRUE;
		ComboBox_InsertString(hModverFltr,1, ModVerFilter);
		ComboBox_SetCurSel (hModverFltr,1);
		
	}
	

	
	// Now for each entry in the cUserData Linked list fill in the filters
	// Based on the previous filter settings.

	cUserData.ResetCurrPos();
	while(cUserData.GetNextEntry(&UserData, &bEOF))
	{

		//Add filters here.
		if (bUseAppName)
		{
			// only show entries with the selected application name
			if (_tcscmp(AppNameFilter, UserData.AppName))
			{
				// Nope continue on
				goto SkipEntry;
			}
		}
		
		if (bUseAppVer)
		{
			if (_tcscmp(AppVerFilter, UserData.AppVer))
			{
				// Nope continue on
				goto SkipEntry;
			}
		}

		if (bUseModName)
		{
			if (_tcscmp(ModNameFilter, UserData.ModName))
			{
				// Nope continue on
				goto SkipEntry;
			}
		}

		if (bUseModVer)
		{
			if (_tcscmp(ModVerFilter, UserData.ModVer))
			{
				// Nope continue on
				goto SkipEntry;
			}
		}


		if (ComboBox_FindStringExact(hAppnameFltr, -1, UserData.AppName) == CB_ERR)
			ComboBox_InsertString(hAppnameFltr,1,UserData.AppName);
		if (ComboBox_FindStringExact(hAppverFltr, -1, UserData.AppVer) == CB_ERR)
			ComboBox_InsertString(hAppverFltr,1,UserData.AppVer);
		if (ComboBox_FindStringExact(hModnameFltr, -1, UserData.ModName) == CB_ERR)
			ComboBox_InsertString(hModnameFltr,1,UserData.ModName);
		if (ComboBox_FindStringExact(hModverFltr, -1, UserData.ModVer) == CB_ERR)
			ComboBox_InsertString(hModverFltr,1,UserData.ModVer);

SkipEntry:
		;
	}
}


void 
OnUserDialogInit(
	IN HWND hwnd
	)
{
	DWORD yOffset = 5;
	RECT rc;
	RECT rcButton;
	RECT rcDlg;
	RECT rcList;
	RECT rcStatic;
	//RECT rcVSlider;
	HWND hParent = GetParent(hwnd);
	HWND hButton = GetDlgItem(hParent, IDC_USERMODE);
	HWND hCombo  = GetDlgItem(hwnd, IDC_FLTR_RESPONSE);
	RECT rcCombo;
	HWND hVSlider = GetDlgItem(hwnd, IDC_VERT_SLIDER);

	UserListItemSelected = FALSE;
	HDC  hDC = NULL;
	TEXTMETRIC TextMetric;
	GetClientRect(hParent, &rc);
	GetWindowRect(hButton, &rcButton);
	
	ScreenToClient(hButton, (LPPOINT)&rcButton.left);
	ScreenToClient(hButton, (LPPOINT)&rcButton.right);


	SetWindowPos(hwnd, HWND_TOP, rc.left + yOffset, rcButton.bottom + yOffset , rc.right - rc.left - yOffset, rc.bottom - rcButton.bottom - yOffset , 0);

	GetWindowRect(hwnd, &rcDlg);
	ScreenToClient(hwnd, (LPPOINT)&rcDlg.left);
	ScreenToClient(hwnd, (LPPOINT)&rcDlg.right);

	// Position the List View
	GetClientRect(hCombo, &rcCombo);
	// Position the List View
	HWND hList = GetDlgItem(hwnd, IDC_USER_LIST);
	SetWindowPos(hList,NULL, rcDlg.left + yOffset, rcDlg.top + (rcCombo.bottom - rcCombo.top), rcDlg.right - rcDlg.left - yOffset, rcDlg.bottom - uBucketWindowSize - (rcDlg.top + (rcCombo.bottom - rcCombo.top))  , SWP_NOZORDER);
	GetWindowRect(hList, &rcList);
	ScreenToClient(hList, (LPPOINT)&rcList.left);
	ScreenToClient(hList, (LPPOINT)&rcList.right);

	SetWindowPos(hVSlider, 
				 NULL,
				 rcDlg.left  + yOffset,
				 rcList.bottom + (rcCombo.bottom - rcCombo.top) ,
				 rcDlg.right - rcDlg.left - yOffset,
				 6, 
				 SWP_NOZORDER);
	// Position the bucket info window.
	HWND hBucket2 = GetDlgItem(hwnd, IDC_BUCKETTEXT);
	SetWindowPos(hBucket2,
				 NULL, 
				 rcDlg.left + yOffset,
				 rcList.bottom + uTextOffset + (rcCombo.bottom - rcCombo.top)  ,
				 0,
				 0, 
				 SWP_NOSIZE | SWP_NOZORDER);

	hBucket2 = GetDlgItem(hwnd, IDC_NOTESTEXT);
	SetWindowPos(hBucket2,
				 NULL, 
				 (rcDlg.right - rcDlg.left) /2 + uTextOffset,
				 rcList.bottom + uTextOffset + (rcCombo.bottom - rcCombo.top),
				 0,
				 0, 
				 SWP_NOSIZE | SWP_NOZORDER);
	SetDlgItemText(hwnd, IDC_BUCKETTEXT,"Bucket Information:");

	GetClientRect (hBucket2, &rcStatic);

	HWND hBucket = GetDlgItem (hwnd, IDC_USER_EDIT);
	if (hBucket)
	{
		SetWindowPos(hBucket,
				 NULL,
				 rcDlg.left + yOffset,
				 rcList.bottom +  uTextOffset + (rcStatic.bottom - rcStatic.top) + (rcCombo.bottom - rcCombo.top) + 5 ,
				 (rcDlg.right - rcDlg.left) /2 - yOffset , 
				 rcDlg.bottom - (rcList.bottom +  uTextOffset + (rcStatic.bottom - rcStatic.top) + (rcCombo.bottom - rcCombo.top)+5  ),
				 SWP_NOZORDER);
	}
	HWND hNotes = GetDlgItem (hwnd, IDC_NOTES);
	if (hNotes)
	{
		SetWindowPos(hNotes,
					 NULL,
					 (rcDlg.right - rcDlg.left) /2 + uTextOffset,
					 rcList.bottom +  uTextOffset + (rcStatic.bottom - rcStatic.top) + (rcCombo.bottom - rcCombo.top) + 5 ,
					 (rcDlg.right - rcDlg.left) /2 - uTextOffset,
					 rcDlg.bottom - (rcList.bottom +  uTextOffset + (rcStatic.bottom - rcStatic.top) + (rcCombo.bottom - rcCombo.top)+5  ),
					 SWP_NOZORDER); 
	}
				

	LVCOLUMN lvc; 
	int iCol; 

	// Set the extended styles
	ListView_SetExtendedListViewStyleEx(hList,
										LVS_EX_GRIDLINES |
										LVS_EX_HEADERDRAGDROP |
										LVS_EX_FULLROWSELECT,
										LVS_EX_GRIDLINES | 
										LVS_EX_FULLROWSELECT | 
										LVS_EX_HEADERDRAGDROP);

	// Initialize the LVCOLUMN structure.
	// The mask specifies that the format, width, text, and subitem
	// members of the structure are valid. 
	lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM; 

	hDC = GetDC(hwnd);
	GetTextMetrics(hDC, &TextMetric);
	// Add the columns. 
	for (iCol = 0; iCol < USER_COL_COUNT; iCol++) 
	{ 
        lvc.iSubItem = iCol;
        lvc.pszText = szUserColumnHeaders[iCol];	
        lvc.cx = _tcslen(szUserColumnHeaders[iCol]) * TextMetric.tmAveCharWidth + 8 ;           // width of column in pixels
        lvc.fmt = LVCFMT_LEFT;  // left-aligned column
        if (ListView_InsertColumn(hList, iCol, &lvc) == -1) 
		{
			;
		}
		
    } 
	
	ReleaseDC(hwnd, hDC);
	ListView_SetColumnWidth(hList, USER_COL_COUNT-1, LVSCW_AUTOSIZE_USEHEADER);
	g_hUMListView = hList;
	
}

void ResizeUserMode(HWND hwnd)
{
	DWORD yOffset = 5;
	RECT rc;
	RECT rcButton;
	RECT rcDlg;
	RECT rcList;
	RECT rcStatic;
	HWND hParent = GetParent(hwnd);
	HWND hButton = GetDlgItem(hParent, IDC_USERMODE);
	HWND hCombo  = GetDlgItem(hwnd, IDC_FLTR_RESPONSE);
	RECT rcCombo;
    HWND hVSlider = GetDlgItem(hwnd, IDC_VERT_SLIDER);
	UserListItemSelected = FALSE;
	GetClientRect(hParent, &rc);
	GetWindowRect(hButton, &rcButton);

	ScreenToClient(hButton, (LPPOINT)&rcButton.left);
	ScreenToClient(hButton, (LPPOINT)&rcButton.right);


	SetWindowPos(hwnd, HWND_TOP, rc.left + yOffset, rcButton.bottom + yOffset , rc.right - rc.left - yOffset, rc.bottom - rcButton.bottom - yOffset , 0);

	GetWindowRect(hwnd, &rcDlg);
	ScreenToClient(hwnd, (LPPOINT)&rcDlg.left);
	ScreenToClient(hwnd, (LPPOINT)&rcDlg.right);

	// Position the List View
	GetClientRect(hCombo, &rcCombo);
	// Position the List View
	HWND hList = GetDlgItem(hwnd, IDC_USER_LIST);
	SetWindowPos(hList,NULL, rcDlg.left + yOffset, rcDlg.top + (rcCombo.bottom - rcCombo.top) , rcDlg.right - rcDlg.left - yOffset, rcDlg.bottom - uBucketWindowSize - (rcDlg.top + (rcCombo.bottom - rcCombo.top))  , SWP_NOZORDER);
	GetWindowRect(hList, &rcList);
	ScreenToClient(hList, (LPPOINT)&rcList.left);
	ScreenToClient(hList, (LPPOINT)&rcList.right);

	SetWindowPos(hVSlider, 
				 NULL,
				 rcDlg.left  + yOffset,
				 rcList.bottom + (rcCombo.bottom - rcCombo.top) ,
				 rcDlg.right - rcDlg.left - yOffset,
				 6, 
				 SWP_NOZORDER);
	// Position the bucket info window.
	HWND hBucket2 = GetDlgItem(hwnd, IDC_BUCKETTEXT);
	SetWindowPos(hBucket2,
				 NULL, 
				 rcDlg.left + yOffset,
				 rcList.bottom + uTextOffset + (rcCombo.bottom - rcCombo.top)  ,
				 0,
				 0, 
				 SWP_NOSIZE | SWP_NOZORDER);

	hBucket2 = GetDlgItem(hwnd, IDC_NOTESTEXT);
	SetWindowPos(hBucket2,
				 NULL, 
				 (rcDlg.right - rcDlg.left) /2 + uTextOffset,
				 rcList.bottom + uTextOffset + (rcCombo.bottom - rcCombo.top) ,
				 0,
				 0, 
				 SWP_NOSIZE | SWP_NOZORDER);
	SetDlgItemText(hwnd, IDC_BUCKETTEXT,"Bucket Information:");

	GetClientRect (hBucket2, &rcStatic);

	HWND hBucket = GetDlgItem (hwnd, IDC_USER_EDIT);
	if (hBucket)
	{
		SetWindowPos(hBucket,
				 NULL,
				 rcDlg.left + yOffset,
				 rcList.bottom +  uTextOffset + (rcStatic.bottom - rcStatic.top) + (rcCombo.bottom - rcCombo.top) + 5 ,
				 (rcDlg.right - rcDlg.left) /2 - yOffset , 
				 rcDlg.bottom - (rcList.bottom +  uTextOffset + (rcStatic.bottom - rcStatic.top) + (rcCombo.bottom - rcCombo.top)+5  ),
				 SWP_NOZORDER);
	}
	HWND hNotes = GetDlgItem (hwnd, IDC_NOTES);
	if (hNotes)
	{
		SetWindowPos(hNotes,
					 NULL,
					 (rcDlg.right - rcDlg.left) /2 + uTextOffset,
					 rcList.bottom +  uTextOffset + (rcStatic.bottom - rcStatic.top) + (rcCombo.bottom - rcCombo.top) + 5 ,
					 (rcDlg.right - rcDlg.left) /2 - uTextOffset,
					 rcDlg.bottom - (rcList.bottom +  uTextOffset + (rcStatic.bottom - rcStatic.top) + (rcCombo.bottom - rcCombo.top)+5  ),
					 SWP_NOZORDER); 
	}
	
	
	
	ListView_SetColumnWidth(hList, USER_COL_COUNT-1, LVSCW_AUTOSIZE_USEHEADER);

}


void RefreshUserMode(HWND hwnd)
{
	

	LVITEM		lvi;
//	TCHAR		Temp[100];
//	double		ElapsedTime;
//	TCHAR		tmpbuf[128];
//	COLORREF	CurrentColor;
//	HWND		hEditBox;
//	TCHAR		TempString [50];
	USER_DATA	UserData;
	BOOL		bEOL = FALSE;
	TCHAR       AppNameFilter[MAX_PATH];
	TCHAR       AppVerFilter[MAX_PATH];
	TCHAR       ModNameFilter[MAX_PATH];
	TCHAR       ModVerFilter[MAX_PATH];

	HWND hList = GetDlgItem(hwnd, IDC_USER_LIST);
	ZeroMemory(&lvi, sizeof LVITEM);
	ListView_DeleteAllItems(hList);
	g_dwUmodeIndex = -1;
	cUserData.ResetCurrPos();

	
	BOOL bUseAppName = FALSE;
	BOOL bUseAppVer = FALSE;
	BOOL bUseModName = FALSE;
	BOOL bUseModVer = FALSE;
	
	HWND hAppName = GetDlgItem(hwnd, IDC_APPNAME_FILTER);
	HWND hAppVer  = GetDlgItem(hwnd, IDC_APPVER_FILTER);
	HWND hModName = GetDlgItem(hwnd, IDC_MODNAME_FILTER);
	HWND hModVer  = GetDlgItem(hwnd, IDC_MODVER_FILTER);

	int iAppNameSel = 0;
	int iAppVerSel = 0;
	int iModNameSel = 0;
	int iModVerSel = 0;

	iAppNameSel = ComboBox_GetCurSel(hAppName);
	iAppVerSel  = ComboBox_GetCurSel(hAppVer);
	iModNameSel = ComboBox_GetCurSel(hModName);
	iModVerSel  = ComboBox_GetCurSel(hModVer);
	g_iSelCurrent = -1;
	// Get the current Filter Selection Strings.
	if (iAppNameSel != 0)
	{
		bUseAppName = TRUE;
		ComboBox_GetLBText(hAppName,iAppNameSel, AppNameFilter);
	}
	if (iAppVerSel != 0) 
	{
		bUseAppVer = TRUE;
		ComboBox_GetLBText(hAppVer,iAppVerSel, AppVerFilter);
	}
	if (iModNameSel != 0)
	{
		bUseModName = TRUE;
        ComboBox_GetLBText(hModName,iModNameSel, ModNameFilter);
	}
	if (iModVerSel != 0)
	{
		bUseModVer = TRUE;
		ComboBox_GetLBText(hModVer,iModVerSel, ModVerFilter);
	}

	while ( (cUserData.GetNextEntryNoMove(&UserData, &bEOL)) && (!bEOL) )
	{

		//Add filters here.
		if (bUseAppName)
		{
			// only show entries with the selected application name
			if (_tcscmp(AppNameFilter, UserData.AppName))
			{
				// Nope continue on
				goto SkipEntry;
			}
		}
		
		if (bUseAppVer)
		{
			if (_tcscmp(AppVerFilter, UserData.AppVer))
			{
				// Nope continue on
				goto SkipEntry;
			}
		}

		if (bUseModName)
		{
			if (_tcscmp(ModNameFilter, UserData.ModName))
			{
				// Nope continue on
				goto SkipEntry;
			}
		}

		if (bUseModVer)
		{
			if (_tcscmp(ModVerFilter, UserData.ModVer))
			{
				// Nope continue on
				goto SkipEntry;
			}
		}
		


		++g_dwUmodeIndex;

	
		cUserData.SetIndex(g_dwUmodeIndex);
		lvi.mask = LVIF_TEXT |  LVIF_PARAM ;
	
		/*if (g_dwUmodeIndex == 0)
		{
			lvi.state = LVIS_SELECTED | LVIS_FOCUSED;
			lvi.stateMask = (UINT)-1;
			UserListItemSelected = TRUE;
			g_iSelCurrent = 0;
		}
		else
		{
			lvi.state= 0;
			lvi.stateMask = 0;
		}
*/
		lvi.iItem = g_dwUmodeIndex ;
		lvi.iSubItem = 0;
		lvi.pszText = UserData.Status.BucketID;
		lvi.lParam = g_dwUmodeIndex;
		ListView_InsertItem(hList,&lvi);

		lvi.mask = LVIF_TEXT ;
	//	lvi.iItem = g_dwUmodeIndex ;
		lvi.iSubItem = 1;
		lvi.pszText = UserData.AppName;
		ListView_SetItem(hList,&lvi);

	//	lvi.iItem = g_dwUmodeIndex ;
		lvi.iSubItem = 2;
		lvi.pszText = UserData.AppVer;
		ListView_SetItem(hList,&lvi);

	//	lvi.iItem = g_dwUmodeIndex ;
		lvi.iSubItem = 3;
		lvi.pszText = UserData.ModName ;
		ListView_SetItem(hList,&lvi);

//		lvi.iItem = g_dwUmodeIndex ;
		lvi.iSubItem = 4;
		lvi.pszText = UserData.ModVer;
		ListView_SetItem(hList,&lvi);

//		lvi.iItem = g_dwUmodeIndex ;
		lvi.iSubItem = 5;
		lvi.pszText = UserData.Offset;
		ListView_SetItem(hList,&lvi);

	//	lvi.iItem = g_dwUmodeIndex ;
		lvi.iSubItem = 6;
		lvi.pszText = UserData.Hits;
		ListView_SetItem(hList,&lvi);

	//	lvi.iItem = g_dwUmodeIndex ;
		lvi.iSubItem = 7;
		lvi.pszText = UserData.Cabs;
		ListView_SetItem(hList,&lvi);

	//	lvi.iItem = g_dwUmodeIndex ;
		
		lvi.iSubItem = 8;
		lvi.pszText = UserData.CabCount;
		ListView_SetItem(hList,&lvi);

		lvi.iSubItem = 9;

		if ( (UserData.Status.GetFile[0] != _T('\0')) || (!_tcscmp(UserData.Status.fDoc, _T("1"))))
		{
			lvi.pszText=_T("Advanced"); // Advanced
		}
		else
		{
			if ( (UserData.Status.RegKey[0] != _T('\0')) ||
				(UserData.Status.WQL[0] != _T('\0')) ||
				(UserData.Status.GetFileVersion[0] != _T('\0')) ||
				( !_tcscmp(UserData.Status.MemoryDump, _T("1")))  )
				{
					lvi.pszText=_T("Basic"); // Basic Collection
				}
				else
					lvi.pszText = _T("");
		}
		ListView_SetItem(hList,&lvi);

		lvi.iSubItem = 10;
		
		
		lvi.pszText = _T("");
		if (!_tcscmp(UserData.Status.SecondLevelData,_T("\0"))) 
		{
			// Use Global
			if( (!_tcscmp(GlobalPolicy.AllowBasic, _T("NO"))) || (!_tcscmp(GlobalPolicy.AllowBasic, _T("\0"))) )
			{
				lvi.pszText=_T("Basic"); // basic
			}
		}
		else
		{
			if ((!_tcscmp(UserData.Status.SecondLevelData,_T("NO"))) || (!_tcscmp(UserData.Status.SecondLevelData,_T("\0"))) )
			{
				lvi.pszText=_T("Basic"); // basic
			}
				
				
		}
		if ( !_tcscmp (UserData.Status.FileCollection, _T("\0")))
		{
			if ((!_tcscmp(GlobalPolicy.AllowAdvanced, _T("NO"))) || (!_tcscmp(GlobalPolicy.AllowAdvanced, _T("\0")))) 
			{
				lvi.pszText=_T("Advanced"); // Advanced
			}
	
		}
		else
		{
			if ((!_tcscmp(UserData.Status.FileCollection,_T("NO")))|| (!_tcscmp(UserData.Status.FileCollection,_T("\0"))))
			{
				lvi.pszText=_T("Advanced"); // Advanced
			}
			
		}
		
			




/*
		if ( ((!_tcscmp(UserData.Status.FileCollection,_T("NO"))) || (!_tcscmp(UserData.Status.FileCollection,_T("\0")))) && ( (!_tcscmp(GlobalPolicy.AllowAdvanced, _T("NO"))) || (!_tcscmp(GlobalPolicy.AllowAdvanced, _T("\0")))) )
		{
			lvi.pszText=_T("Advanced"); // Advanced
		}
		else
		{
			if ( ( (!_tcscmp(UserData.Status.SecondLevelData,_T("NO"))) || (!_tcscmp(UserData.Status.SecondLevelData,_T("\0"))) ) && ( (!_tcscmp(GlobalPolicy.AllowBasic, _T("NO"))) || (!_tcscmp(GlobalPolicy.AllowBasic, _T("\0"))) ) )
			{
				lvi.pszText=_T("Basic"); // Advanced
			}
		}
		*/
		ListView_SetItem(hList,&lvi);
		lvi.pszText = _T("");
		
		if (_tcscmp(UserData.Status.Response, _T("1")) && _tcscmp(UserData.Status.Response, _T("\0")) )
		{
			lvi.iSubItem = 11;
			lvi.pszText = UserData.Status.Response;
			ListView_SetItem(hList,&lvi);

		}
		

		lvi.iSubItem = 12;
		lvi.pszText = _T("");
		if (_tcscmp(UserData.Status.UrlToLaunch, _T("\0")))
		{
			lvi.pszText = UserData.Status.UrlToLaunch ;
		}
		else
		{
			// try the default policy
			lvi.pszText = GlobalPolicy.CustomURL;
		}
		ListView_SetItem(hList,&lvi);

SkipEntry:
		cUserData.MoveNext(&bEOL);
	}
	
	
	SendMessage(GetDlgItem(hwnd,IDC_USER_EDIT ), WM_SETTEXT, NULL, (LPARAM)_T(""));
	if (g_iSelCurrent == -1)
	{
		SendMessage(GetDlgItem(hwnd,IDC_NOTES ), WM_SETTEXT, NULL, (LPARAM)_T(""));
	}
	//DisplayUserBucketData(hwnd, g_iSelCurrent);
	PopulateFiltersWSelection(hwnd);
	//UserListItemSelected = FALSE;
}
BOOL VerifyFileAccess(TCHAR *szPath, BOOL fOptional)
{
	HANDLE hFile = CreateFile(szPath, GENERIC_READ | GENERIC_WRITE | DELETE, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);

	if ((hFile == INVALID_HANDLE_VALUE) && !((GetLastError() == ERROR_FILE_NOT_FOUND) ||(GetLastError() == ERROR_PATH_NOT_FOUND)))
	{
		MessageBox(NULL, _T("You do not have the required Administrative access to the selected CER file tree.\r\nAs a result, administrative options will be disabled."), NULL, MB_OK | MB_TASKMODAL);
		g_bFirstBucket = FALSE;
		return FALSE;
	}
	if (hFile == INVALID_HANDLE_VALUE)
	{
	
		// Try to Create the Status.txt file
		hFile =	 CreateFile(szPath, GENERIC_READ | GENERIC_WRITE | DELETE, FILE_SHARE_READ, NULL, CREATE_ALWAYS, 0, NULL);
		if (hFile == INVALID_HANDLE_VALUE)
		{
			MessageBox(NULL, _T("You do not have the required Administrative access to the selected CER file tree.\r\nAs a result, administrative options will be disabled."), NULL, MB_OK | MB_TASKMODAL);
			g_bFirstBucket = FALSE;
			return FALSE;
		}
		else
		{
			CloseHandle(hFile);
			hFile = INVALID_HANDLE_VALUE;
			g_bFirstBucket = FALSE;
			return TRUE;
		}
	}
	g_bFirstBucket = FALSE;
	if (hFile != INVALID_HANDLE_VALUE)
		CloseHandle(hFile);
	return TRUE;
}
//////////////////////////////////////////////////////////////////
// Get user mode Data
/////////////////////////////////////////////////////////////////

BOOL ParseCountsFile(PUSER_DATA UserData)
{
	FILE *pFile = NULL;
	TCHAR Buffer[100];
	TCHAR *Temp = NULL;
	BOOL Status = TRUE;
	ZeroMemory(Buffer,sizeof Buffer);
	pFile = _tfopen(UserData->CountPath, _T("r"));
	if (pFile)
	{
		// Get the Cabs Gathered Count

		if (!_fgetts(Buffer, sizeof Buffer, pFile))
		{
			Status = FALSE;
			goto ERRORS;
		}
		// Remove \r\n and 
		Temp = Buffer;
		while ( (*Temp != _T('\r')) && (*Temp != _T('\n')) && (*Temp != _T('\0')) )
		{
			++Temp;
		}
		*Temp = _T('\0');

		Temp = _tcsstr(Buffer, _T("="));
		if (Temp)
		{
			++Temp; // move path the = sign
			if (StringCbCopy(UserData->Cabs, sizeof UserData->Cabs, Temp) != S_OK)
			{
				Status = FALSE;
				goto ERRORS;
			}
		}
        
        // Get the Total Hits Count
		ZeroMemory(Buffer,sizeof Buffer);
		if (! _fgetts(Buffer, sizeof Buffer, pFile))
		{
			Status = FALSE;
			goto ERRORS;
		}
		Temp = Buffer;
		while ( (*Temp != _T('\r')) && (*Temp != _T('\n')) && (*Temp != _T('\0')) )
		{
			++Temp;
		}
		*Temp = _T('\0');

		Temp = _tcsstr(Buffer, _T("="));
		if (Temp)
		{
			++Temp; // move path the = sign
			if (StringCbCopy(UserData->Hits, sizeof UserData->Hits, Temp) != S_OK)
			{
				Status = FALSE;
				goto ERRORS;
			}
		}
		fclose(pFile);
		pFile = NULL;
		Status =  TRUE;
	}
	else
	{
		Status =  FALSE;
	}

	pFile = NULL;
	UserData->iReportedCount = 0;
	pFile = _tfopen(UserData->ReportedCountPath, _T("r"));
	if (pFile)
	{
		// Get the Cabs Gathered Count
	    ZeroMemory (Buffer,sizeof Buffer);
		if (!_fgetts(Buffer, sizeof Buffer, pFile))
		{
			Status = FALSE;
			goto ERRORS;
		}

		// Remove \r\n and 
		Temp = Buffer;
		while ( (*Temp != _T('\r')) && (*Temp != _T('\n')) && (*Temp != _T('\0')) )
		{
			++Temp;
		}
		*Temp = _T('\0');

		Temp = _tcsstr(Buffer, _T("="));
		if (Temp)
		{
			++Temp; // move past the = sign
			UserData->iReportedCount = _ttoi (Temp);
		}
        
    
		fclose(pFile);
		pFile = NULL;
		Status = TRUE;
		
	}
	else
	{
		Status = FALSE;
	}
ERRORS:
	if (pFile)
	{
		fclose(pFile);
	}
	return Status;

}

BOOL ParseStatusFile(PUSER_DATA UserData)
{
	FILE *pFile = NULL;
	TCHAR Buffer[1024];
//	TCHAR szTempDir[MAX_PATH];
	TCHAR *Temp = NULL;
//	int   id = 0;
	ZeroMemory(Buffer,sizeof Buffer);


	pFile = _tfopen(UserData->StatusPath, _T("r"));
	if (pFile)
	{

		// Get the Cabs Gathered Count

		if (!_fgetts(Buffer, sizeof Buffer, pFile))
		{
			goto ERRORS;
		}
		do 
		{
			// Remove \r\n and force termination of the buffer.
			Temp = Buffer;
			while ( (*Temp != _T('\r')) && (*Temp != _T('\n')) && (*Temp != _T('\0')) )
			{
				++Temp;
			}
			*Temp = _T('\0');

			Temp = _tcsstr(Buffer, BUCKET_PREFIX);
			if (Temp == Buffer)
			{
				Temp+= _tcslen(BUCKET_PREFIX);
				if (StringCbCopy(UserData->Status.BucketID, sizeof UserData->Status.BucketID, Temp) != S_OK)
				{
					goto ERRORS;
				}
				continue;
			}
			
			Temp = _tcsstr(Buffer,RESPONSE_PREFIX);
			if (Temp == Buffer)
			{
				Temp+= _tcslen(RESPONSE_PREFIX);
				if (StringCbCopy(UserData->Status.Response, sizeof UserData->Status.Response, Temp) != S_OK)
				{
					goto ERRORS;
				}
				continue;
			}
			
			Temp = _tcsstr(Buffer, URLLAUNCH_PREFIX);
			if (Temp == Buffer)
			{
				Temp+= _tcslen(URLLAUNCH_PREFIX);
				if (StringCbCopy(UserData->Status.UrlToLaunch , sizeof UserData->Status.UrlToLaunch , Temp) != S_OK)
				{
					goto ERRORS;
				}
				continue;
			}

			Temp = _tcsstr(Buffer, SECOND_LEVEL_DATA_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(SECOND_LEVEL_DATA_PREFIX);
				if (StringCbCopy(UserData->Status.SecondLevelData , sizeof UserData->Status.SecondLevelData , Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
				
			Temp = _tcsstr(Buffer, TRACKING_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(TRACKING_PREFIX);
				if (StringCbCopy(UserData->Status.Tracking , sizeof UserData->Status.Tracking , Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			
			Temp = _tcsstr(Buffer, CRASH_PERBUCKET_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(CRASH_PERBUCKET_PREFIX);
				if (StringCbCopy(UserData->Status.CrashPerBucketCount , sizeof UserData->Status.CrashPerBucketCount , Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			Temp = _tcsstr(Buffer, FILE_COLLECTION_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(FILE_COLLECTION_PREFIX);
				if (StringCbCopy(UserData->Status.FileCollection , sizeof UserData->Status.FileCollection, Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			Temp = _tcsstr(Buffer, REGKEY_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(REGKEY_PREFIX);
				if (StringCbCopy(UserData->Status.RegKey , sizeof UserData->Status.RegKey , Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			Temp = _tcsstr(Buffer, FDOC_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(FDOC_PREFIX);
				if (StringCbCopy(UserData->Status.fDoc , sizeof UserData->Status.fDoc , Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			Temp = _tcsstr(Buffer, IDATA_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(IDATA_PREFIX);
				if (StringCbCopy(UserData->Status.iData , sizeof UserData->Status.iData , Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			Temp = _tcsstr(Buffer, WQL_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(WQL_PREFIX);
				if (StringCbCopy(UserData->Status.WQL , sizeof UserData->Status.WQL , Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			Temp = _tcsstr(Buffer, GETFILE_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(GETFILE_PREFIX);
				if (StringCbCopy(UserData->Status.GetFile , sizeof UserData->Status.GetFile, Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			Temp = _tcsstr(Buffer, GETFILEVER_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(GETFILEVER_PREFIX);
				if (StringCbCopy(UserData->Status.GetFileVersion , sizeof UserData->Status.GetFileVersion , Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			Temp = _tcsstr(Buffer, MEMDUMP_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(MEMDUMP_PREFIX);
				if (StringCbCopy(UserData->Status.MemoryDump , sizeof UserData->Status.MemoryDump, Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			
			Temp = _tcsstr(Buffer, ALLOW_EXTERNAL_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(ALLOW_EXTERNAL_PREFIX);
				if (StringCbCopy(UserData->Status.AllowResponse , sizeof UserData->Status.AllowResponse, Temp) != S_OK)
				{
					goto ERRORS;
				}		
				continue;
			}
			
			ZeroMemory(Buffer, sizeof Buffer);
		} while (_fgetts(Buffer, sizeof Buffer, pFile));
		fclose(pFile);
		return TRUE;
	}
	else
	{
		return FALSE;
	}
ERRORS:
	if (pFile)
	{
		fclose(pFile);
	}
	return FALSE;
}


BOOL CreateStatusDir(TCHAR *szPath)
{
	if (!PathIsDirectory(szPath))
		return CreateDirectory(szPath,NULL);
	else 
		return TRUE;
}

BOOL IsHexDigit(TCHAR Digit)
{
	if ((_T('0') <= Digit && Digit <= _T('9')) ||
		(_T('A') <= Digit && Digit <= _T('F')) ||
		(_T('a') <= Digit && Digit <= _T('f')))
		return TRUE;
		
	return FALSE;
}
BOOL GetBucketData(HWND hwnd, TCHAR *FilePath, int iLevel)
/*
	Recursively process the user mode filetree schema

*/
{
	WIN32_FIND_DATA FindData;
	HANDLE hFind = INVALID_HANDLE_VALUE;
	TCHAR  szSubPath [MAX_PATH];
	TCHAR  szSearchPath[MAX_PATH];
	TCHAR  szTempDir[MAX_PATH];
	PUSER_DATA NewNode = NULL;
	TCHAR *Temp;
	HANDLE hCabFind = INVALID_HANDLE_VALUE;
	WIN32_FIND_DATA CabFindData;
//	TCHAR szPolicyFilePath[MAX_PATH];
	int   iCabCount;
	if (iLevel != OFFSET)
	{
		if (StringCbPrintf(szSearchPath,sizeof szSearchPath, _T("%s\\*.*"), FilePath) != S_OK)
		{
			goto ERRORS;
		}
	}
	else
	{
		if (StringCbPrintf(szSearchPath,sizeof szSearchPath, _T("%s\\*.cab"), FilePath) != S_OK)
		{
			goto ERRORS;
		}
	}
	if (iLevel < OFFSET)
	{
		hFind = FindFirstFile(szSearchPath, &FindData);
		if ( hFind != INVALID_HANDLE_VALUE)
		{
			do 
			{
				// find the next directory
				// skip the . and .. 
				if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
					// recursively call ourselves with the level incremented.
					if ( (_tcscmp(FindData.cFileName, _T("."))) && (_tcscmp(FindData.cFileName,  _T(".."))) )
					{
						if (StringCbPrintf( szSubPath, 
										sizeof szSubPath, 
										_T("%s\\%s"),
										FilePath,
										FindData.cFileName) != S_OK)
						{
							goto ERRORS;
						}
						GetBucketData(hwnd, szSubPath, iLevel+1);
					}
				}
			}while (FindNextFile(hFind, &FindData));
			FindClose(hFind);
			hFind = INVALID_HANDLE_VALUE;
		}
		else
		{
			// This is an invalid case 
			// we are done with this tree segment
			goto ERRORS;
		}
	}
	
	if (iLevel == OFFSET)
	{
		// Verify that this directory name meets the OFFSET criteria
		Temp = FilePath + _tcslen(FilePath) * sizeof TCHAR;
		while ((*Temp != _T('\\')))
		{
			--Temp;
		}
		if ( (_tcslen(Temp+1) == 8) || (_tcslen(Temp+1) == 16) )
		{
			// The string should be hex
			for (UINT i = 0; i < _tcslen(Temp+1); i++)
			{
				if (!IsHexDigit(Temp[i+1]))
				{
					goto DONE;
				}
			}
		}
		else
		{
			// Failed
			goto DONE;
		}
	/*	if ( !IsStringHexDigits (Temp))
		{
			// Nope
				goto DONE;
		}
		*/
		// If we made it here we are calling it good.

		// We should now be at a leaf node. 
		NewNode = (PUSER_DATA) malloc (sizeof (USER_DATA));

		// Now we need to parse the path into it's component parts 
		if (!NewNode )
		{
			goto ERRORS;
		}
		ZeroMemory(NewNode, sizeof USER_DATA);

		if (StringCbCopy(NewNode->BucketPath, sizeof NewNode->BucketPath, FilePath)!= S_OK)
		{
			goto ERRORS;
		}
		Temp = FilePath + _tcslen(FilePath) * sizeof TCHAR;
		while ((*Temp != _T('\\')))
		{
			--Temp;
		}
		// Copy Temp+1 into Offset
		if (StringCbCopy(NewNode->Offset, sizeof NewNode->Offset, Temp+1) != S_OK)
		{
			goto ERRORS;
		}
		else
		{
			if (_tcslen (NewNode->Offset) == 16)
			{
				NewNode->Is64Bit = TRUE;
			}
		}
		*Temp = _T('\0');
		
		while ((*Temp != _T('\\')))
		{
			--Temp;
		}
		if (StringCbCopy(NewNode->ModVer, sizeof NewNode->ModVer, Temp+1) != S_OK)
		{
			goto ERRORS;
		}
		*Temp = _T('\0');
	
	
		while ((*Temp != _T('\\')))
		{
			--Temp;
		}
		if (StringCbCopy(NewNode->ModName, sizeof NewNode->ModName, Temp+1) != S_OK)
		{
			goto ERRORS;
		}

		*Temp = _T('\0');
		
		while ((*Temp != _T('\\')))
		{
			--Temp;
		}
		if (StringCbCopy(NewNode->AppVer, sizeof NewNode->AppVer, Temp+1) != S_OK)
		{
			goto ERRORS;
		}

		*Temp = _T('\0');
		
		while ((*Temp != _T('\\')))
		{
			--Temp;
		}
		if (StringCbCopy(NewNode->AppName, sizeof NewNode->AppName, Temp+1) != S_OK)
		{
			goto ERRORS;
		}
	//	MessageBox(NULL, NewNode->AppName, "AddingNode",MB_OK);
		
		// Count the number of unprocessed cabs.
		iCabCount = 0;
		hCabFind = FindFirstFile(szSearchPath, &CabFindData);
		if (hCabFind != INVALID_HANDLE_VALUE)
		{
			do 
			{
				++iCabCount;
			}
			while (FindNextFile(hCabFind, &FindData));
			FindClose (hCabFind);
		}
		else
		{
			iCabCount = 0;
		}

		_itot(iCabCount, NewNode->CabCount, 10);

		// Read the status.txt file for each entry in the Data Structure ?
		// Build path to Status file
		if (StringCbPrintf(NewNode->StatusPath,
						sizeof NewNode->StatusPath,
						_T("%s\\Status\\%s\\%s\\%s\\%s\\%s\\Status.txt"),
							CerRoot, 
							NewNode->AppName, 
							NewNode->AppVer,
							NewNode->ModName,
							NewNode->ModVer,
							NewNode->Offset
							) != S_OK)
		{
			goto ERRORS;
		}

		if (StringCbPrintf(szTempDir,
						sizeof szTempDir,
						_T("%s\\Status\\%s\\%s\\%s\\%s\\%s"),
							CerRoot, 
							NewNode->AppName, 
							NewNode->AppVer,
							NewNode->ModName,
							NewNode->ModVer,
							NewNode->Offset
							) != S_OK)
		{
			goto ERRORS;
		}

		if (!PathIsDirectory(szTempDir))
		{
			// Let's create it
			if (StringCbPrintf(szTempDir,
						sizeof szTempDir,
						_T("%s\\Status"),CerRoot)!= S_OK)
			{
				goto ERRORS;
			}
			else
			{
				if (CreateStatusDir(szTempDir))
				{
					// Next
					if (StringCbCat(szTempDir, sizeof szTempDir,_T("\\")) !=S_OK)
					{
						goto ERRORS;
					}
					if (StringCbCat(szTempDir, sizeof szTempDir, NewNode->AppName) !=S_OK)
					{
						goto ERRORS;
					}
					if (CreateStatusDir(szTempDir))
					{
						if (StringCbCat(szTempDir, sizeof szTempDir,_T("\\")) !=S_OK)
						{
							goto ERRORS;
						}
						if (StringCbCat(szTempDir, sizeof szTempDir, NewNode->AppVer) !=S_OK)
						{
							goto ERRORS;
						}
						if (CreateStatusDir(szTempDir))
						{
							if (StringCbCat(szTempDir, sizeof szTempDir,_T("\\")) !=S_OK)
							{
								goto ERRORS;
							}
							if (StringCbCat(szTempDir, sizeof szTempDir, NewNode->ModName) !=S_OK)
							{
								goto ERRORS;
							}
							if (CreateStatusDir(szTempDir))
							{
								if (StringCbCat(szTempDir, sizeof szTempDir,_T("\\")) !=S_OK)
								{
									goto ERRORS;
								}
								if (StringCbCat(szTempDir, sizeof szTempDir, NewNode->ModVer) !=S_OK)
								{
									goto ERRORS;
								}
								if (CreateStatusDir(szTempDir))
								{
									if (StringCbCat(szTempDir, sizeof szTempDir,_T("\\")) !=S_OK)
									{
										goto ERRORS;
									}
									if (StringCbCat(szTempDir, sizeof szTempDir, NewNode->Offset) !=S_OK)
									{
										goto ERRORS;
									}
									CreateStatusDir(szTempDir);
								}
							}
						}
					}

				}
			}
		
		}
		//Verify That we can create and delete a file from the status directory
		if (g_bFirstBucket)
		{
			// Build the file name
			if (!VerifyFileAccess(NewNode->StatusPath, FALSE))
			{
				g_bAdminAccess = FALSE;
			}
		}
		ParseStatusFile(NewNode);
		
		// Read the counts file for each entry in the data structure. ?
		// Build path to counts file
		if (StringCbPrintf(NewNode->CountPath,
						sizeof NewNode->CountPath,
						_T("%s\\Counts\\%s\\%s\\%s\\%s\\%s\\count.txt"),
							CerRoot, 
							NewNode->AppName, 
							NewNode->AppVer,
							NewNode->ModName,
							NewNode->ModVer,
							NewNode->Offset
							) != S_OK)
		{
			goto ERRORS;
		}

		if (StringCbPrintf(NewNode->ReportedCountPath,
					sizeof NewNode->ReportedCountPath,
					_T("%s\\Counts\\%s\\%s\\%s\\%s\\%s\\RepCounts.txt"),
					CerRoot, 
					NewNode->AppName, 
					NewNode->AppVer,
					NewNode->ModName,
					NewNode->ModVer,
					NewNode->Offset
					) != S_OK)
		{
			goto ERRORS;
		}

		ParseCountsFile(NewNode);
		// Update the linked list
		cUserData.AddNode(NewNode);
		// Update Progress Bar
	  
		//if (Pos == 99)
		//{
		//	SendDlgItemMessage(hwnd, IDC_LOADPB, PBM_SETPOS, 
	}
DONE:
	--iLevel;
	
	return TRUE; // Prefix Note: This is not a memory leak the node will be freed when the 
				 // linked list is freed in the cUserData destructor
ERRORS:
	if (hFind != INVALID_HANDLE_VALUE)
	{
		FindClose(hFind);
	}

	return FALSE;
	
}


BOOL ParsePolicy( TCHAR *Path, PUSER_DATA pUserData, BOOL Global)
{
	// Same basic parsing of Status file
	// Will cleanup at a later date.
	FILE *pFile = NULL;
	TCHAR Buffer[MAX_PATH + 10];
//	TCHAR szTempDir[MAX_PATH];
	TCHAR *Temp = NULL;
//	int   id = 0;
	ZeroMemory(Buffer,sizeof Buffer);
	ZeroMemory(&GlobalPolicy, sizeof GLOBAL_POLICY);
	
	pFile = _tfopen(Path, _T("r"));
	if (pFile)
	{

		// Get the Cabs Gathered Count

		if (!_fgetts(Buffer, sizeof Buffer, pFile))
		{
			goto ERRORS;
		}
		do 
		{
			// Remove \r\n and force termination of the buffer.
			Temp = Buffer;
			while ( (*Temp != _T('\r')) && (*Temp != _T('\n')) && (*Temp != _T('\0')) )
			{
				++Temp;
			}
			*Temp = _T('\0');

			Temp = _tcsstr(Buffer, URLLAUNCH_PREFIX);
			if (Temp == Buffer)
			{
				Temp+= _tcslen(URLLAUNCH_PREFIX);
				if (Global)
				{
					if (StringCbCopy(GlobalPolicy.CustomURL , sizeof GlobalPolicy.CustomURL , Temp) != S_OK)
					{
						goto ERRORS;
					}
				}
				else
				{
					if (StringCbCopy(pUserData->Policy.CustomURL , sizeof pUserData->Policy.CustomURL , Temp) != S_OK)
					{
						goto ERRORS;
					}
				}
				continue;
			}

			Temp = _tcsstr(Buffer, SECOND_LEVEL_DATA_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(SECOND_LEVEL_DATA_PREFIX);

				if (Global)
				{
					if (StringCbCopy(GlobalPolicy.AllowBasic , sizeof GlobalPolicy.AllowBasic , Temp) != S_OK)
					{
						goto ERRORS;
					}
				}
				else
				{
					if (StringCbCopy(pUserData->Policy.AllowBasic , sizeof pUserData->Policy.AllowBasic , Temp) != S_OK)
					{
						goto ERRORS;
					}		
				}
				continue;
			}
			Temp = _tcsstr(Buffer, FILE_COLLECTION_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(FILE_COLLECTION_PREFIX);
				if (Global)
				{
					if (StringCbCopy(GlobalPolicy.AllowAdvanced , sizeof GlobalPolicy.AllowAdvanced, Temp) != S_OK)
					{
						goto ERRORS;
					}
				}
				else
				{
					if (StringCbCopy(pUserData->Policy.AllowAdvanced , sizeof pUserData->Policy.AllowAdvanced, Temp) != S_OK)
					{
						goto ERRORS;
					}	
				}
				continue;
			}

				
			Temp = _tcsstr(Buffer, TRACKING_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(TRACKING_PREFIX);
				if (Global)
				{	
					if (StringCbCopy(GlobalPolicy.EnableCrashTracking , sizeof GlobalPolicy.EnableCrashTracking , Temp) != S_OK)
					{
						goto ERRORS;
					}	
				}
				else
				{
					if (StringCbCopy(pUserData->Policy.EnableCrashTracking , sizeof pUserData->Policy.EnableCrashTracking , Temp) != S_OK)
					{
						goto ERRORS;
					}	
				}
				continue;
			}
			
			Temp = _tcsstr(Buffer, CRASH_PERBUCKET_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(CRASH_PERBUCKET_PREFIX);
				if (Global)
				{
					if (StringCbCopy(GlobalPolicy.CabsPerBucket , sizeof GlobalPolicy.CabsPerBucket , Temp) != S_OK)
					{
						goto ERRORS;
					}	
				}
				else
				{
					if (StringCbCopy(pUserData->Policy.CabsPerBucket , sizeof pUserData->Policy.CabsPerBucket , Temp) != S_OK)
					{
						goto ERRORS;
					}	
				}
				continue;
			}

			Temp = _tcsstr(Buffer, ALLOW_EXTERNAL_PREFIX);
			if (Temp==Buffer)
			{
				Temp+= _tcslen(ALLOW_EXTERNAL_PREFIX);
				if (Global)
				{
					if (StringCbCopy(GlobalPolicy.AllowMicrosoftResponse , sizeof GlobalPolicy.AllowMicrosoftResponse , Temp) != S_OK)
					{
						goto ERRORS;
					}	
				}
				else
				{
					if (StringCbCopy(pUserData->Policy.AllowMicrosoftResponse , sizeof pUserData->Policy.AllowMicrosoftResponse , Temp) != S_OK)
					{
						goto ERRORS;
					}	
				}
				continue;
			}

			if (Global) // This entry is not available on a per bucket basis.
			{
				Temp = _tcsstr(Buffer, FILE_TREE_ROOT_PREFIX);
				if (Temp==Buffer)
				{
					Temp+= _tcslen(FILE_TREE_ROOT_PREFIX);
					if (StringCbCopy(GlobalPolicy.RedirectFileServer , sizeof GlobalPolicy.RedirectFileServer , Temp) != S_OK)
					{
						goto ERRORS;
					}	
					continue;
				}
			}
			ZeroMemory(Buffer, sizeof Buffer);
		} while (_fgetts(Buffer, sizeof Buffer, pFile));
		fclose(pFile);
		return TRUE;
	}
	else
	{
		return FALSE;
	}
ERRORS:
	if (pFile)
	{
		fclose(pFile);
	}
	return FALSE;
}

BOOL GetAllBuckets(HWND hwnd)
{
	WIN32_FIND_DATA FindData;
	HANDLE hFind = INVALID_HANDLE_VALUE;
	TCHAR  szSearchPattern[MAX_PATH];
	TCHAR  szSubPath[MAX_PATH];
	int	   iDirCount = 0;
	TCHAR  PolicyPath[MAX_PATH];


	// Parse the global Policy
	if (StringCbPrintf(PolicyPath, sizeof PolicyPath,_T("%s\\policy.txt"), CerRoot) != S_OK)
	{
		goto ERRORS;
	}
    ParsePolicy(PolicyPath,
				NULL,  // Use the Global Policy Structure.
				TRUE); // Set to true if Global policy False = selected.
	
	// Start with a clean Linked List.
	cUserData.CleanupList();
	if (StringCbPrintf(szSearchPattern,sizeof szSearchPattern,_T("%s\\cabs\\*.*"), CerRoot) != S_OK)
	{

		; // Need to define error case handling code here.
	}
	// Count all the directories and set the progress bar range.
	hFind = FindFirstFile(szSearchPattern, &FindData);
	if (hFind != INVALID_HANDLE_VALUE)
	{
		do 
		{
			if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
			{
				// skip the . and .. directories.
				if ( (_tcscmp(FindData.cFileName, _T("."))) && (_tcscmp(FindData.cFileName, _T(".."))) )
				{
					++iDirCount;
				}
			}
		} while (FindNextFile(hFind, &FindData));
		FindClose (hFind);
		hFind = INVALID_HANDLE_VALUE;
		//if (iDirCount > 100)
			//iDirCount = 100;
//		SetDlgItemText(hwnd, IDC_STATIC1, _T("Reading current status of user mode tree..."));
		SendDlgItemMessage(hwnd, IDC_LOADPB, PBM_SETRANGE, 0, MAKELPARAM(0, iDirCount));
		SendDlgItemMessage(hwnd, IDC_LOADPB, PBM_SETSTEP, 1, 0);

	}
	else
	{
		goto ERRORS;
	}

	hFind = FindFirstFile(szSearchPattern, &FindData);
	if (hFind != INVALID_HANDLE_VALUE)
	{

		if ( hFind != INVALID_HANDLE_VALUE)
		{
			do 
			{
				if (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
				{
					// skip the . and .. directories.
					if ( (_tcscmp(FindData.cFileName, _T("."))) && (_tcscmp(FindData.cFileName, _T(".."))) )
					{
						// now skip the blue shutdown and appcompat
						if (_tcscmp(FindData.cFileName, _T("blue")) && 
							_tcscmp(FindData.cFileName, _T("shutdown")) &&
							_tcscmp(FindData.cFileName, _T("appcompat")) )
						{
							if (StringCbPrintf(szSubPath, sizeof szSubPath, _T("%s\\cabs\\%s"), CerRoot, FindData.cFileName)!= S_OK)
							{
								goto ERRORS;
							}
							SetDlgItemText(hwnd, IDC_SUBDIR, szSubPath);
							GetBucketData(hwnd, szSubPath, APPNAME);
							SendDlgItemMessage(hwnd,IDC_LOADPB, PBM_STEPIT, 0,0);
						}
					}
				}
			}while (FindNextFile(hFind, &FindData));
			FindClose(hFind);
			hFind = INVALID_HANDLE_VALUE;
		}
	}
	PopulateFilters(hUserMode);
	return TRUE;
ERRORS:

	if (hFind != INVALID_HANDLE_VALUE)
	{
		FindClose(hFind);
	}
	return FALSE;
}

void 
OnUserContextMenu(HWND hwnd, 
				  LPARAM lParam )
/*++

Routine Description:

This routine Loads and provides a message pump for the User mode context menu
Arguments:

    hwnd			- Handle of the Kernel mode dialog box
	lParam			- Not Used
    
Return value:

    Does not return a value
++*/
{
	BOOL Result = FALSE;
	HMENU hMenu = NULL;
	HMENU hmenuPopup = NULL;

	int xPos, yPos;
	hMenu = LoadMenu(g_hinst, MAKEINTRESOURCE( IDR_USERCONTEXT));
	hmenuPopup = GetSubMenu (hMenu,0);
	if (!hmenuPopup)
	{
		//MessageBox(NULL,"Failed to get sub item", NULL,MB_OK);
		;
	}
	else
	{
		
		
		// Grey out the menu items
		EnableMenuItem (hMenu, ID_REPORT_ALL, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_REPORT_ALLUSERMODEFAULTS, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_REPORT_SELECTEDBUCKET, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_VIEW_MICROSOFTRESPONSE, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_VIEW_BUCKETOVERRIDERESPONSE155, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_VIEW_REFRESH140, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_VIEW_REFRESH121, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_VIEW_CRASHLOG, MF_BYCOMMAND| MF_GRAYED);
		//EnableMenuItem (hMenu, ID_EDIT_COPY144, MF_BYCOMMAND| MF_GRAYED);
		//EnableMenuItem (hMenu, ID_EDIT_DEFAULTREPORTINGOPTIONS, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_EDIT_USERMODEREPORTINGOPTIONS, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_EDIT_SELECTEDBUCKETREPORTINGOPTIONS, MF_BYCOMMAND| MF_GRAYED);
		//EnableMenuItem (hMenu, ID_EXPORT_USERMODEFAULTDATA174, MF_BYCOMMAND| MF_GRAYED);
		EnableMenuItem (hMenu, ID_VIEW_BUCKETCABFILEDIRECTORY157, MF_BYCOMMAND| MF_GRAYED);
		if (_tcscmp(CerRoot, _T("\0")))
		{
		
			EnableMenuItem (hMenu, ID_REPORT_ALL, MF_BYCOMMAND| MF_ENABLED);
			EnableMenuItem (hMenu, ID_REPORT_ALLUSERMODEFAULTS, MF_BYCOMMAND| MF_ENABLED);
			EnableMenuItem (hMenu, ID_REPORT_SELECTEDBUCKET, MF_BYCOMMAND| MF_ENABLED);
			EnableMenuItem (hMenu, ID_VIEW_MICROSOFTRESPONSE, MF_BYCOMMAND| MF_ENABLED);
			EnableMenuItem (hMenu, ID_VIEW_BUCKETOVERRIDERESPONSE155, MF_BYCOMMAND| MF_ENABLED);
			EnableMenuItem (hMenu, ID_VIEW_REFRESH140, MF_BYCOMMAND| MF_ENABLED);
			EnableMenuItem (hMenu, ID_VIEW_REFRESH121, MF_BYCOMMAND| MF_ENABLED);
			EnableMenuItem (hMenu, ID_VIEW_CRASHLOG, MF_BYCOMMAND| MF_ENABLED);
			//EnableMenuItem (hMenu, ID_EDIT_COPY144, MF_BYCOMMAND| MF_ENABLED);
			//EnableMenuItem (hMenu, ID_EDIT_DEFAULTREPORTINGOPTIONS, MF_BYCOMMAND| MF_ENABLED);
			EnableMenuItem (hMenu, ID_EDIT_USERMODEREPORTINGOPTIONS, MF_BYCOMMAND| MF_ENABLED);
			EnableMenuItem (hMenu, ID_EDIT_SELECTEDBUCKETREPORTINGOPTIONS, MF_BYCOMMAND| MF_ENABLED);
			//EnableMenuItem (hMenu, ID_EXPORT_USERMODEFAULTDATA174, MF_BYCOMMAND| MF_ENABLED);
			EnableMenuItem (hMenu, ID_VIEW_BUCKETCABFILEDIRECTORY157, MF_BYCOMMAND| MF_ENABLED);
			if ( !g_bAdminAccess)
			{
				EnableMenuItem (hMenu, ID_REPORT_ALL, MF_BYCOMMAND| MF_GRAYED);
				EnableMenuItem (hMenu, ID_REPORT_ALLUSERMODEFAULTS, MF_BYCOMMAND| MF_GRAYED);
				EnableMenuItem (hMenu, ID_REPORT_SELECTEDBUCKET, MF_BYCOMMAND| MF_GRAYED);
				EnableMenuItem (hMenu, ID_EDIT_USERMODEREPORTINGOPTIONS, MF_BYCOMMAND| MF_GRAYED);
				EnableMenuItem (hMenu, ID_EDIT_SELECTEDBUCKETREPORTINGOPTIONS, MF_BYCOMMAND| MF_GRAYED);
			}
			
		
		}
        xPos = GET_X_LPARAM(lParam); 
		yPos = GET_Y_LPARAM(lParam); 
		Result = TrackPopupMenu (hmenuPopup, TPM_LEFTALIGN | TPM_RIGHTBUTTON, xPos,yPos,0,hwnd,NULL);
		
	}
	if (hMenu)
		DestroyMenu(hMenu);
}

void ViewResponse(HWND hwnd, BOOL bMSResponse)

/*++

Routine Description:

This routine Launches the system default Web browser useing shellexec
Arguments:

    hwnd			- Handle of the Kernel mode dialog box
	    
Return value:

    Does not return a value
++*/
{
	TCHAR Url [255];
	HWND hList = GetDlgItem(hwnd, IDC_USER_LIST);
	int sel;
//	LVITEM lvi;
	if (!hList)
		return;
	ZeroMemory (Url, sizeof Url);

	sel = ListView_GetNextItem(hList,-1, LVNI_SELECTED);
	// Now get the lParam for this item
	if (bMSResponse)
	{
		ListView_GetItemText(hList, sel,11, Url,sizeof Url);
	}
	else
	{
		ListView_GetItemText(hList, sel,12, Url,sizeof Url);
	}
	if ( (!_tcsncicmp(Url, _T("http://"), _tcslen(_T("http://")))) || (!_tcsncicmp(Url, _T("https://"), _tcslen(_T("https://")))) )
	{
		SHELLEXECUTEINFOA sei = {0};
		sei.cbSize = sizeof(sei);
		sei.lpFile = Url;
		sei.nShow = SW_SHOWDEFAULT;
		if (! ShellExecuteEx(&sei) )
		{
			// What do we display here.
			;
		}
	}
	
}
void ErrorLoadTree()
{
	MessageBox(NULL, _T("To complete the requested operation you must first load a file tree"), NULL,MB_OK);
}

void ViewBucketDir(HWND hwnd)
{

	TCHAR szPath[MAX_PATH];
//	TCHAR TempBuffer[MAX_PATH];
	PUSER_DATA pUserData;
	LVITEM lvi;
	int sel;

	HWND hList = GetDlgItem(hwnd, IDC_USER_LIST);
	sel = ListView_GetNextItem(hList,-1, LVNI_SELECTED);
	lvi.iItem = sel;
	lvi.mask = LVIF_PARAM;
	ListView_GetItem(hList, &lvi);
	sel = lvi.lParam;
	pUserData = cUserData.GetEntry(sel);
	if (pUserData)
	{
        if (StringCbPrintf(szPath, sizeof szPath, _T("%s\\cabs\\%s\\%s\\%s\\%s\\%s"),
			CerRoot,
			pUserData->AppName,
			pUserData->AppVer,
			pUserData->ModName,
			pUserData->ModVer,
			pUserData->Offset) != S_OK)
		{
			return;
		}
		else
		{
			SHELLEXECUTEINFOA sei = {0};
			sei.cbSize = sizeof(sei);
			sei.lpFile = szPath;
			sei.nShow = SW_SHOWDEFAULT;
			if (! ShellExecuteEx(&sei) )
			{
				// What do we display here.
				;
			}
		}
	}
}

BOOL WriteNotesFile(HWND hwnd)
{
	TCHAR szNotesPath[MAX_PATH];
//	TCHAR TempBuffer[MAX_PATH];
	PUSER_DATA pUserData;
//	int sel;
	TCHAR *Buffer = NULL;
	DWORD dwBufferSize = 100000; // 100000 bytes or 50K Unicode characters 
	HANDLE hFile = INVALID_HANDLE_VALUE;
	TCHAR *Temp = NULL;
	Buffer = (TCHAR *) malloc (dwBufferSize);
	if (!Buffer)
	{
		goto ERRORS;
	}
	ZeroMemory(Buffer,dwBufferSize);
	DWORD dwBytesWritten = 0;

	// Get current notes file text
	GetDlgItemText(hwnd, IDC_NOTES, Buffer, dwBufferSize / sizeof TCHAR - sizeof TCHAR);

	// Get Current selected item Index
	pUserData = cUserData.GetEntry(g_iSelCurrent);
	if (pUserData)
	{
		
		if (StringCbCopy(szNotesPath, sizeof szNotesPath, pUserData->StatusPath)!= S_OK)
		{
			goto ERRORS;
		}
		Temp = _tcsstr(szNotesPath, _T("Status.txt"));
		if (!Temp)
		{
			goto ERRORS;
		}
		else
		{ 
			*Temp = _T('\0');
			if (StringCbCat(szNotesPath, sizeof szNotesPath, _T("Notes.txt")) != S_OK)
			{
				goto ERRORS;
			}
			hFile = CreateFile(szNotesPath, GENERIC_WRITE, NULL,NULL, CREATE_ALWAYS,FILE_ATTRIBUTE_NORMAL,NULL);
			if (hFile != INVALID_HANDLE_VALUE)
			{
				WriteFile(hFile, Buffer, _tcslen(Buffer)*sizeof TCHAR, &dwBytesWritten, NULL);
			}
			CloseHandle(hFile);
		}
		
	}
	if (g_iSelCurrent == -1)
	{
		SendMessage(GetDlgItem(hwnd,IDC_NOTES ), WM_SETTEXT, NULL, (LPARAM)_T(""));
	}
	//SetWindowText(GetDlgItem(hwnd,IDC_NOTES ),_T(""));
ERRORS:	
	if (Buffer)
		free(Buffer);
	return TRUE;
}

BOOL DisplayUserBucketData(HWND hwnd, int iItem)
{
	HWND hEditBox = GetDlgItem(hwnd, IDC_USER_EDIT);
	HANDLE hFile = INVALID_HANDLE_VALUE;
	TCHAR NotesFilePath[MAX_PATH];
	PUSER_DATA pUserData = NULL;
	TCHAR *Temp = NULL;
	DWORD dwBytesRead = 0;
	TCHAR *Source = NULL;
	TCHAR *Dest = NULL;
	TCHAR TempBuffer[1000];
	TCHAR *Buffer = NULL;				// we have to use a dynamic buffer since we don't 
								// have a clue as to the text length.
	DWORD BufferLength = 100000; // 100k bytes should be plenty. or 50K unicode chars.

	Buffer = (TCHAR *) malloc (BufferLength);
	if (Buffer)
	{
		ZeroMemory(Buffer,BufferLength);
		if (g_iSelCurrent == -1)
		{
			SendMessage(GetDlgItem(hwnd,IDC_NOTES ), WM_SETTEXT, NULL, (LPARAM)_T(""));
		}
		//SetWindowText(GetDlgItem(hwnd,IDC_NOTES ),_T(""));
		
		pUserData = cUserData.GetEntry(iItem);
		if (pUserData)
		{
			// Build the strings for the Edit box.

			// Basic data collection first.
			if ( (!_tcscmp (pUserData->Status.SecondLevelData, _T("YES"))) && (_tcscmp(pUserData->Status.FileCollection, _T("YES"))) )
			{
				if (StringCbPrintf(Buffer, BufferLength, _T("The following information will be sent to Microsoft.\r\n\tHowever, this bucket's policy would prevent files and user documents from being reported.\r\n"))!= S_OK)
				{
					goto ERRORS;
				}

			}

			else
			{

				if ( !_tcscmp (pUserData->Status.SecondLevelData, _T("YES")))
				{
					if (StringCbPrintf(Buffer, BufferLength, _T("Microsoft would like to collect the following information but the default policy prevents the exchange.\r\n"))!= S_OK)
					{
						goto ERRORS;
					}

				}
				else
				{
					if (!_tcscmp(pUserData->Status.FileCollection, _T("YES")))
					{
						if (StringCbCat(Buffer,BufferLength, _T(" Microsoft would like to collect the following information but default policy\r\n\tprevents files and user documents from being reported.\r\n\t As a result, no exchange will take place.\r\n"))!= S_OK)
						{
							goto ERRORS;
						}
					}
					else
					{
						if (StringCbPrintf(Buffer, BufferLength, _T("The following information will be sent to Microsoft:\r\n"))!= S_OK)
						{
							goto ERRORS;
						}
					}
				}
			}
			
			if (_tcscmp(pUserData->Status.GetFile, _T("\0")))
			{
				if (StringCbCat(Buffer, BufferLength, _T("These files:\r\n"))!= S_OK)
				{
					goto ERRORS;
				}
				Source = pUserData->Status.GetFile;
				
				while ((*Source != _T('\0')) && (*Source != _T('\r')) && (*Source != _T('\n')) )
				{
					ZeroMemory (TempBuffer, sizeof TempBuffer);
					Dest = TempBuffer;
					while ( (*Source != _T('\0')) && (*Source != _T('\r')) && (*Source != _T('\n'))&& (*Source != _T(';') ))
					{
						*Dest = *Source;
						++Dest; 
						++Source;
					}
					if (*Source == _T(';'))
					{
						++Source;
					}
					*Dest =_T('\0');
					if (StringCbCat(Dest, sizeof TempBuffer, _T("\r\n")) != S_OK)
					{
						goto ERRORS;
					}
					if (StringCbCat(Buffer, BufferLength,  _T("\t") )!= S_OK)
					{
						goto ERRORS;
					}
					if (StringCbCat(Buffer, BufferLength,  TempBuffer )!= S_OK)
					{
						goto ERRORS;
					}
				}
			}
			if (_tcscmp(pUserData->Status.RegKey, _T("\0")))
			{
				if (StringCbCat(Buffer, BufferLength, _T("These Registry Keys:\r\n"))!= S_OK)
				{
					goto ERRORS;
				}
				
				Source = pUserData->Status.RegKey;
				
				while ((*Source != _T('\0')) && (*Source != _T('\r')) && (*Source != _T('\n')) )
				{
					ZeroMemory (TempBuffer, sizeof TempBuffer);
					Dest = TempBuffer;
					while ( (*Source != _T('\0')) && (*Source != _T('\r')) && (*Source != _T('\n'))&& (*Source != _T(';') ))
					{
						*Dest = *Source;
						++Dest; 
						++Source;
					}
					if (*Source == _T(';'))
					{
						++Source;
					}
					*Dest =_T('\0');
					if (StringCbCat(Dest, sizeof TempBuffer, _T("\r\n")) != S_OK)
					{
						goto ERRORS;
					}
					if (StringCbCat(Buffer, BufferLength,  _T("\t") )!= S_OK)
					{
						goto ERRORS;
					}
					if (StringCbCat(Buffer, BufferLength,  TempBuffer )!= S_OK)
					{
						goto ERRORS;
					}
				}
			}
			if (_tcscmp(pUserData->Status.WQL, _T("\0")))
			{
				if (StringCbCat(Buffer, BufferLength, _T("The Results of these WQL queries:\r\n"))!= S_OK)
				{
					goto ERRORS;
				}

				// Replace ; with \t\r\n 

				
				Source = pUserData->Status.WQL;
				
				while ((*Source != _T('\0')) && (*Source != _T('\r')) && (*Source != _T('\n')) )
				{
					ZeroMemory (TempBuffer, sizeof TempBuffer);
					Dest = TempBuffer;
					while ( (*Source != _T('\0')) && (*Source != _T('\r')) && (*Source != _T('\n'))&& (*Source != _T(';') ))
					{
						*Dest = *Source;
						++Dest; 
						++Source;
					}
					if (*Source == _T(';'))
					{
						++Source;
					}
					*Dest =_T('\0');
					if (StringCbCat(Dest, sizeof TempBuffer, _T("\r\n")) != S_OK)
					{
						goto ERRORS;
					}
					if (StringCbCat(Buffer, BufferLength,  _T("\t") )!= S_OK)
					{
						goto ERRORS;
					}
					if (StringCbCat(Buffer, BufferLength,  TempBuffer )!= S_OK)
					{
						goto ERRORS;
					}
				}
			}

			if (!_tcscmp (pUserData->Status.MemoryDump, _T("1")))
			{
				if (StringCbCat(Buffer, BufferLength, _T("The contents of global memory\r\n"))!= S_OK)
				{
					goto ERRORS;
				}
			}
			if (_tcscmp(pUserData->Status.GetFileVersion, _T("\0")))
			{
				if (StringCbCat(Buffer, BufferLength, _T("The versions of these files:\r\n"))!= S_OK)
				{
					goto ERRORS;
				}
				Source = pUserData->Status.GetFileVersion;
				
				while ((*Source != _T('\0')) && (*Source != _T('\r')) && (*Source != _T('\n')) )
				{
					ZeroMemory (TempBuffer, sizeof TempBuffer);
					Dest = TempBuffer;
					while ( (*Source != _T('\0')) && (*Source != _T('\r')) && (*Source != _T('\n'))&& (*Source != _T(';') ))
					{
						*Dest = *Source;
						++Dest; 
						++Source;
					}
					if (*Source == _T(';'))
					{
						++Source;
					}
					*Dest =_T('\0');
					if (StringCbCat(Dest, sizeof TempBuffer, _T("\r\n")) != S_OK)
					{
						goto ERRORS;
					}
					if (StringCbCat(Buffer, BufferLength,  _T("\t") )!= S_OK)
					{
						goto ERRORS;
					}
					if (StringCbCat(Buffer, BufferLength,  TempBuffer )!= S_OK)
					{
						goto ERRORS;
					}
				}
			}

			if (!_tcscmp(pUserData->Status.fDoc, _T("1")))
			{
				if (StringCbCat(Buffer, BufferLength, _T("The users current document.\r\n"))!= S_OK)
				{
					goto ERRORS;
				}
			}
			SendMessage(hEditBox, WM_SETTEXT, NULL, (LPARAM)Buffer);
		

			// Now display the Notes file
			// Use the same buffer. Just truncate if it doesn't fit
			ZeroMemory(Buffer,  BufferLength);
		
			if (StringCbCopy(NotesFilePath, sizeof NotesFilePath, pUserData->StatusPath)!= S_OK)
			{
				goto ERRORS;
			}
			Temp = _tcsstr(NotesFilePath, _T("Status.txt"));
			if (!Temp)
			{
				goto ERRORS;
			}
			else
			{ 
				*Temp = _T('\0');
				if (StringCbCat(NotesFilePath, sizeof NotesFilePath, _T("Notes.txt")) != S_OK)
				{
					goto ERRORS;
				}

				hFile = CreateFile(NotesFilePath, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,NULL);
				if (hFile != INVALID_HANDLE_VALUE)
				{
					if (ReadFile(hFile, Buffer, BufferLength  - sizeof TCHAR, &dwBytesRead, NULL))
					{
						SendMessage(GetDlgItem(hwnd,IDC_NOTES ), WM_SETTEXT, NULL, (LPARAM) Buffer);
						
					}
					CloseHandle (hFile);
				}
				
				
			}
		}

	}

ERRORS:
	if (Buffer)
		free(Buffer);
	return TRUE;
}
 /*
void UMCopyToClipboard(HWND hwnd )
{
	if (!OpenClipboard(NULL))
		return;

	EmptyClipboard();
	char rtfRowHeader[sizeof(rtfRowHeader1) + (sizeof(rtfRowHeader2)+6)*USER_COL_COUNT + sizeof(rtfRowHeader3)];
	char *rtfWalk = rtfRowHeader;
	memcpy(rtfWalk, rtfRowHeader1, sizeof(rtfRowHeader1));
	rtfWalk += sizeof(rtfRowHeader1)-1;
	DWORD cxTotal = 0;
	for(int i=0;i<USER_COL_COUNT;i++)
		{
		LVCOLUMNA lv;
		lv.mask = LVCF_WIDTH;
		lv.iSubItem = i;
		SendMessageA(GetDlgItem(hwnd,IDC_USER_LIST), LVM_GETCOLUMN, i, (LPARAM)&lv);
		cxTotal += lv.cx;
		wsprintf(rtfWalk, "%s%d", rtfRowHeader2, cxTotal);
		while(*++rtfWalk)
			;
		};
	memcpy(rtfWalk, rtfRowHeader3, sizeof(rtfRowHeader3));
	DWORD crtfHeader = strlen(rtfRowHeader);
	DWORD crtf = 0, cwz = 0;
	
	crtf += sizeof(rtfPrologue)-1;

	int iSel = -1;
	while ((iSel = SendMessageW(GetDlgItem(hwnd,IDC_USER_LIST), LVM_GETNEXTITEM, iSel, MAKELPARAM(LVNI_SELECTED, 0))) != -1)
		{
		crtf += crtfHeader;
		for(int i=0;i<USER_COL_COUNT;i++)
			{
			WCHAR wzBuffer[1024];
			LVITEMW lv;

			lv.pszText = wzBuffer;
			lv.cchTextMax = sizeof(wzBuffer);
			lv.iSubItem = i;
			lv.iItem = iSel;
			cwz += SendMessageW(GetDlgItem(hwnd,IDC_USER_LIST), LVM_GETITEMTEXTW, iSel, (LPARAM)&lv);
			cwz++;
			crtf += WideCharToMultiByte(CP_ACP, 0, wzBuffer, -1, NULL, 0, NULL, NULL) - 1;
			crtf += sizeof(rtfRowPref)-1;
			crtf += sizeof(rtfRowSuff)-1;
			};
		cwz++;
		crtf += sizeof(rtfRowFooter)-1;
		};

	crtf += sizeof(rtfEpilogue);
	cwz++;

	HGLOBAL hgwz = GlobalAlloc(GMEM_FIXED, cwz*sizeof(WCHAR));
	HGLOBAL hgrtf = GlobalAlloc(GMEM_FIXED, crtf);

	WCHAR *wz = (WCHAR *)GlobalLock(hgwz);
	char *rtf = (char *)GlobalLock(hgrtf);

	rtfWalk = rtf;
	WCHAR *wzWalk = wz;
	memcpy(rtfWalk, rtfPrologue, sizeof(rtfPrologue));
	rtfWalk += sizeof(rtfPrologue)-1;

	iSel = -1;
	while ((iSel = SendMessageW(GetDlgItem(hwnd,IDC_USER_LIST), LVM_GETNEXTITEM, iSel, MAKELPARAM(LVNI_SELECTED, 0))) != -1)
		{
		memcpy(rtfWalk, rtfRowHeader, crtfHeader);
		rtfWalk += crtfHeader;
		for(int i=0;i<USER_COL_COUNT;i++)
			{
			memcpy(rtfWalk, rtfRowPref, sizeof(rtfRowPref));
			rtfWalk += sizeof(rtfRowPref)-1;

			LVITEMW lv;

			lv.pszText = wzWalk;
			lv.cchTextMax = cwz;
			lv.iSubItem = i;
			lv.iItem = iSel;
			SendMessageW(GetDlgItem(hwnd, IDC_USER_LIST), LVM_GETITEMTEXTW, iSel, (LPARAM)&lv);

			WideCharToMultiByte(CP_ACP, 0, wzWalk, -1, rtfWalk, crtf, NULL, NULL);
			wzWalk += wcslen(wzWalk);
			if (i == 11)
				{
				*wzWalk++ = L'\r';
				*wzWalk++ = L'\n';
				}
			else
				*wzWalk++ = L'\t';

			rtfWalk += strlen(rtfWalk);		
			memcpy(rtfWalk, rtfRowSuff, sizeof(rtfRowSuff));
			rtfWalk += sizeof(rtfRowSuff)-1;
			};
		memcpy(rtfWalk, rtfRowFooter, sizeof(rtfRowFooter));
		rtfWalk += sizeof(rtfRowFooter)-1;
		};

	memcpy(rtfWalk, rtfEpilogue, sizeof(rtfEpilogue));
	rtfWalk += sizeof(rtfEpilogue);
	*wzWalk++ = 0;

//	Assert(rtfWalk - rtf == crtf);
//	Assert(wzWalk - wz == cwz);

	GlobalUnlock(hgwz);
	GlobalUnlock(hgrtf);

	SetClipboardData(CF_UNICODETEXT, hgwz);
	SetClipboardData(RegisterClipboardFormatA(szRTFClipFormat), hgrtf);

	// hgwz and hgrtf are now owned by the system.  DO NOT FREE!
	CloseClipboard();




}
void UMExportDataToCSV (TCHAR *FileName)
{
	// Open file

	// write headers


	// loop through data structure and write all fields.

	// Should we include filtered data views?

}

 */
LRESULT CALLBACK 
UserDlgProc(
	HWND hwnd,
	UINT iMsg,
	WPARAM wParam,
	LPARAM lParam
	)
{

//	int Index = 0;
	TCHAR Temp[100];
	LVITEM lvi;
	static int cDragOffset;
	switch (iMsg)
	{
	case WM_NOTIFY:
		{	
			
			switch(((NMHDR *)lParam)->code)
			{
			
			case LVN_COLUMNCLICK:
				if (g_iSelCurrent > -1)
				{
					WriteNotesFile(hwnd);
					g_iSelCurrent = -1;
				}
				_itot(((NM_LISTVIEW*)lParam)->iSubItem,Temp,10);

				ListView_SortItemsEx( ((NMHDR *)lParam)->hwndFrom,
										UmCompareFunc,
										((NM_LISTVIEW*)lParam)->iSubItem
									);

				g_bUMSortAsc = !g_bUMSortAsc;
				break;
			case NM_CLICK:
				if (g_iSelCurrent > -1)
				{
					WriteNotesFile(hwnd);
					g_iSelCurrent = -1;
				}
				
				g_iSelCurrent = ((NM_LISTVIEW*)lParam)->iItem;
				lvi.iItem = g_iSelCurrent;
				lvi.mask = LVIF_PARAM;
				ListView_GetItem(((NMHDR *)lParam)->hwndFrom, &lvi);
				g_iSelCurrent = lvi.lParam;

				DisplayUserBucketData(hwnd, g_iSelCurrent);
				break;
			}
			return TRUE;
		}
	
	
	case WM_INITDIALOG:
			OnUserDialogInit(hwnd);
		return TRUE;

	case WM_FileTreeLoaded:
			
			RefreshUserMode(hwnd);
		return TRUE;
		
	case WM_CONTEXTMENU:
			//if (g_iSelCurrent > -1)
					//WriteNotesFile(hwnd);
			OnUserContextMenu(hwnd, lParam );
		return TRUE;
	case WM_ERASEBKGND:
	// Don't know why this doesn't happen automatically...
		{
		HDC hdc = (HDC)wParam;
		HPEN hpen = (HPEN)CreatePen(PS_SOLID, 1, GetSysColor(COLOR_BTNFACE));
		HPEN hpenOld = (HPEN)SelectObject(hdc, hpen);
		SelectObject(hdc, GetSysColorBrush(COLOR_BTNFACE));
		RECT rc;
		GetClientRect(hwnd, &rc);
		Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);
		SelectObject(hdc, hpenOld);
		DeleteObject(hpen);
		return TRUE;
		}
	/*case WM_LBUTTONUP:
		 if (bCapture)
		 {
			HWND hSlider = GetDlgItem(hwnd, IDC_VERT_SLIDER);
			RECT rcDlg;
			GetClientRect(hwnd, &rcDlg);
			//MoveWindow(hSlider, 
			SetWindowPos(	hSlider, 
							NULL,
							rcDlg.left  + yOffset,
							rcList.bottom + (rcCombo.bottom - rcCombo.top) ,
							rcDlg.right - rcDlg.left - yOffset,
							6, 
							SWP_NOZORDER);
							

		    
			ReleaseCapture();
			bCapture = FALSE;
		 }
	*/
	case WM_COMMAND:
		switch (LOWORD(wParam))
		{
		 

	/*	case IDC_VERT_SLIDER:
				{
				RECT r;
				GetWindowRect(GetDlgItem(hwnd, IDC_USER_EDIT), &r);
				//cDragOffset = GET_X_LPARAM(GetMessagePos()) - r.right;
				//fCapture = DRAG_HORIZ;
				
				cDragOffset = GET_Y_LPARAM(GetMessagePos()) - r.bottom;

				bCapture = TRUE;
				SetCapture(hwnd);
				return 0;
				};
				*/
		case ID_REPORT_ALLUSERMODEFAULTS:
			if (g_iSelCurrent > -1)
			{
				WriteNotesFile(hwnd);
				g_iSelCurrent = -1;
			}
			ReportUserModeFault(hwnd, FALSE,0);
			RefreshUserMode(hwnd);
			break;
		case ID_REPORT_SELECTEDBUCKET:
			if (g_iSelCurrent > -1)
			{
				WriteNotesFile(hwnd);
				g_iSelCurrent = -1;
			}
			ReportUserModeFault(hwnd, TRUE, GetDlgItem(hwnd, IDC_USER_LIST));
			RefreshUserMode(hwnd);
			break;
		case ID_VIEW_CRASHLOG:
			if (g_iSelCurrent > -1)
			{
				WriteNotesFile(hwnd);
				g_iSelCurrent = -1;
			}
			if (_tcscmp(CerRoot, _T("\0")))
			{
				ViewCrashLog();
			}
			else
			{
				ErrorLoadTree();
			}
			break;
		case ID_VIEW_REFRESH140:
			if (g_iSelCurrent > -1)
			{
				WriteNotesFile(hwnd);
				g_iSelCurrent = -1;
			}
			if (_tcscmp(CerRoot, _T("\0")))
			{
				RefreshUserMode(hwnd);
			}
			else
			{
				ErrorLoadTree();
			}
			
			break;
		case ID_VIEW_MICROSOFTRESPONSE:
			if (g_iSelCurrent > -1)
			{
				WriteNotesFile(hwnd);
				g_iSelCurrent = -1;
			}
			if (_tcscmp(CerRoot, _T("\0")))
			{
				ViewResponse(hwnd, TRUE);
			}
			else
			{
				ErrorLoadTree();
			}
			break;
//		case ID_EDIT_COPY144:
//			 UMCopyToClipboard(hwnd);
//			 break;
		case ID_VIEW_BUCKETOVERRIDERESPONSE155:
			if (g_iSelCurrent > -1)
			{
				WriteNotesFile(hwnd);
				g_iSelCurrent = -1;
			}
			if (_tcscmp(CerRoot, _T("\0")))
			{
				ViewResponse(hwnd, FALSE);
			}
			else
			{
				ErrorLoadTree();
			}
			break;
		case ID_VIEW_BUCKETCABFILEDIRECTORY157:
			if (g_iSelCurrent > -1)
			{
				WriteNotesFile(hwnd);
				g_iSelCurrent = -1;
			}
			ViewBucketDir(hwnd);
			break;
		case ID_REPORT_ALL:
			if (g_iSelCurrent > -1)
			{
				WriteNotesFile(hwnd);
				g_iSelCurrent = -1;
			}
			//SendMessage(GetParent(hwnd), WM_COMMAND, 0, 0);
			PostMessage(GetParent(hwnd), WM_COMMAND, MAKEWPARAM(ID_REPORT_ALLCRASHES,0),0);
			break;
		case ID_EDIT_USERMODEREPORTINGOPTIONS:	
			if (g_iSelCurrent > -1)
			{
				WriteNotesFile(hwnd);
				g_iSelCurrent = -1;
			}
			PostMessage(GetParent(hwnd), WM_COMMAND, MAKEWPARAM(ID_EDIT_DEFAULTPOLICY,0),0);
			RefreshUserMode(hwnd);
			break;
		case ID_EDIT_SELECTEDBUCKETREPORTINGOPTIONS:
			if (g_iSelCurrent > -1)
			{
				WriteNotesFile(hwnd);
				g_iSelCurrent = -1;
			}
			PostMessage(GetParent(hwnd), WM_COMMAND, MAKEWPARAM(ID_EDIT_SELECTEDBUCKETSPOLICY,0),0);
			break;

		} 
		
		switch (HIWORD(wParam))
		{
			case CBN_SELCHANGE:
				if (g_iSelCurrent > -1)
				{
					WriteNotesFile(hwnd);
					g_iSelCurrent = -1;
				}
				RefreshUserMode(hwnd);
				break;
		}

	}
	
	return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\msmq\mqrcvr.cpp ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:
    mqrcvr.cpp

Abstract:
    Receives file names from server and launches debugger

--*/


//
// Includes
//

#ifndef MQEXTDLL
#include <stdio.h>
#include <windows.h>
#include <objbase.h>

#define dprintf printf
#else
#include "mqext.h"
#endif


//
// Unique include file for ActiveX MSMQ apps
//
#include <mqoai.h>
#include <mq.h>
#include <strsafe.h>

//
// Various defines
//
#define MAX_VAR       20
#define MAX_BUFFER   500

//
// GUID created with the tool "GUIDGEN"
//
static WCHAR strGuidMQTestType[] =
L"{c30e0960-a2c0-11cf-9785-00608cb3e80c}";
//
// Prototypes
//
void PrintError(char *s, HRESULT hr);
HRESULT Syntax();

char g_DebuggerName[MAX_PATH];
char g_SymCache[MAX_PATH];
char g_ServerMachine[MAX_COMPUTERNAME_LENGTH*4 + 1];
char g_FormatName[MAX_PATH] = {0};
char g_QueueName[100];
CHAR g_DumpPath[MAX_PATH + 1];
BOOL g_Retriage = FALSE;
BOOL g_NoCustomer = FALSE;
BOOL g_SendMail = FALSE;

ULONG g_MaxMemUsage = 50;
ULONG g_PauseForNext = 1000;
BOOL g_CreateQ = 0;
BOOL g_bSend = FALSE;

// Some useful macros
#define RELEASE(punk) if (punk) { (punk)->Release(); (punk) = NULL; }
#define ADDREF(punk) ((punk) ? (punk)->AddRef() : 0)
#define PRINTERROR(s, hr) { PrintError(s, hr); goto Cleanup; }


BOOL
GetArgs(int Argc, CHAR ** Argv)
{

    int i = 1;
    g_ServerMachine[0] = 0;
    g_QueueName[0] = 0;
    StringCchCopy(g_DebuggerName, sizeof(g_DebuggerName), "c:\\Debuggers\\ocakd.exe");
    StringCchCopy(g_SymCache, sizeof(g_SymCache), "c:\\symcache");
    g_bSend = FALSE;
    while (i<Argc)
    {
        if (!strcmp(Argv[i], "-create"))
        {
           ++i;
           g_CreateQ = TRUE;
        }
        else if (!strcmp(Argv[i],"-d"))
        {
            // Get sender format name
            ++i;
            if ((i < Argc) &&
                (strlen(Argv[i]) < MAX_PATH))
            {
                StringCchCopy(g_DebuggerName, sizeof(g_DebuggerName), Argv[i]);
                ++i;
            }
        }
        else if (!strcmp(Argv[i],"-f"))
        {
            // Get sender format name
            ++i;
            if ((i < Argc) &&
                (strlen(Argv[i]) < MAX_PATH))
            {
                StringCchCopy(g_FormatName, sizeof(g_FormatName), Argv[i]);
                ++i;
            }
        }
        else if (!strcmp(Argv[i], "-m"))
        {
            ++i;
            // get memory usage value
            if (i<Argc)
            {
                g_MaxMemUsage = atoi(Argv[i]);
                ++i;
            }
        }
        else if (!strcmp(Argv[i], "-mail"))
        {
            ++i;
            g_SendMail = TRUE;
        }
        else if (!strcmp(Argv[i], "-nocust"))
        {
            ++i;
            g_NoCustomer = TRUE;
        }
        else if (!strcmp(Argv[i], "-p") ||
                 !strcmp(Argv[i], "-pause"))
        {
            ++i;
            // get memory usage value
            if (i<Argc)
            {
                g_PauseForNext = atoi(Argv[i]);
                ++i;
            }
        }
        else if (!strcmp(Argv[i], "-q"))
        {
            ++i;
            // Get Queue name
            if ((i < Argc) &&
                (strlen(Argv[i]) < sizeof(g_QueueName)))
            {
                StringCchCopy(g_QueueName, sizeof(g_QueueName), Argv[i]);
                ++i;
            }
        }
        else if (!strcmp(Argv[i],"-retriage"))
        {
            // Get sender server machine name
            ++i;
            g_Retriage = TRUE;
        }
        else if (!strcmp(Argv[i],"-s"))
        {
            // Get sender server machine name
            ++i;
            if ((i < Argc) &&
                (strlen(Argv[i]) < MAX_COMPUTERNAME_LENGTH*4))
            {
                StringCchCopy(g_ServerMachine, sizeof(g_ServerMachine), Argv[i]);
                ++i;
            }
        }
        else if (!strcmp(Argv[i],"-send"))
        {
            // Get sender server machine name
            ++i;
            g_bSend = TRUE;
        }
        else if (!strcmp(Argv[i],"-y"))
        {
            ++i;
            if ((i < Argc) &&
                (strlen(Argv[i]) < MAX_PATH))
            {
                StringCchCopy(g_SymCache, sizeof(g_SymCache), Argv[i]);
                ++i;
            }
        }
        else
        {
            printf("Unkonwn argument %s\n", Argv[i]);
            return FALSE;
        }
    }

    return (g_ServerMachine[0] && g_QueueName[0]) || g_FormatName[0] ;
}


/*
    LaunchDebugger - Launches a debugger process
        Input : g_DumpPath has the dump file name to run debugger on
                fWait - Wait for process to finish
        Return: Succesful creation of process or the process exit code 
*/
HRESULT
LaunchDebugger(BOOL fWait)
{
    STARTUPINFO StartupInfo;
    PROCESS_INFORMATION ProcessInfo;
    ULONG ExitCode;
    TCHAR CommandLine[2048];
    HRESULT hr;

    ZeroMemory(&StartupInfo,sizeof(STARTUPINFO));
    StartupInfo.cb = sizeof(STARTUPINFO);

    StringCbPrintf(CommandLine, sizeof(CommandLine),
                   "%s -i srv*%s*\\\\symbols\\symbols -y srv*%s*\\\\symbols\\symbols -z %s "
                   "-c \"!dbaddcrash %s %s %s -p %s;q\"",
                   g_DebuggerName,
                   g_SymCache,
                   g_SymCache,
                   g_DumpPath, 
                   g_Retriage ? ("-retriage") : (""),
                   g_SendMail ? ("-mail") : (""),
                   g_NoCustomer ? ("-nocust") : (""),
                   g_DumpPath);
    dprintf("Executing: %s\n", CommandLine);
    if (!CreateProcess(g_DebuggerName,
                       CommandLine,
                       NULL,
                       NULL,
                       FALSE,
                       CREATE_NEW_CONSOLE,
//                       CREATE_NO_WINDOW,
                       NULL,
                       NULL,
                       &StartupInfo,
                       &ProcessInfo))
    {
        hr = GetLastError();
        dprintf("Failed to launch debugger for %s, error %lx\n",
                g_DumpPath, hr);
        return hr;
    }
    else if (fWait)
    {
        // wait for process to finish
        WaitForSingleObject(ProcessInfo.hProcess,INFINITE);
        GetExitCodeProcess( ProcessInfo.hProcess, (LPDWORD) &hr);

        dprintf ("Debugger Exited with Exit code: %lx",hr);
    }
    else
    {
        hr = S_OK;
    }
    CloseHandle( ProcessInfo.hThread );
    CloseHandle( ProcessInfo.hProcess);
    return hr;
}

/**************************************************************************************************************
//
// This creates and opens up a MSMQ to send messages. Queue is created / opened on g_ServerMachine and Queue name
// is taken from g_QueueName.
//
//      pwszQueueFormatName - Format name identyfying the queue to be opened
//
//      pwszQueuePathName   - Path name identyfying the queue to be opened, this isn't used when
//                            pwszQueueFormatName is present
//
//      bSendQueue          - Specifies whether Queue has send or receive access
//
// On success the queue handle is returned in pStartedQ. bCreated is set depending on whether the Queue was created
// Caller must CloseSendQ after its done sending messages.
//
***************************************************************************************************************/
HRESULT 
StartMessageQ(
    PWSTR pwszQueueFormatName,
    PWSTR pwszQueuePathName,
    BOOL  bSendQueue,
    QUEUEHANDLE* pStartedQ, 
    BOOL* bCreated)
{
    HRESULT Hr = S_OK;
    QUEUEHANDLE hQueue;
    DWORD i;

    if (!pwszQueueFormatName && !pwszQueuePathName )
    {
        Hr = E_INVALIDARG;
        PRINTERROR("No queue connection string specified", Hr);
    }

    if (g_CreateQ)
    {
        MQQUEUEPROPS QueueProps;
        QUEUEPROPID PropIDs[2];
        MQPROPVARIANT PropVariants[2];
        HRESULT hrProps[2];
        ULONG FormatLength = 0;
        
        i = 0;
        if (pwszQueueFormatName)
        {
            FormatLength = sizeof(WCHAR) * (1 + wcslen(pwszQueueFormatName));
        } else if (pwszQueuePathName)
        {
            PropIDs[i] = PROPID_Q_PATHNAME;
            PropVariants[i].vt = VT_LPWSTR;
            PropVariants[i].pwszVal = pwszQueuePathName;
            i++;
        }
        PropIDs[i] = PROPID_Q_LABEL;
        PropVariants[i].vt = VT_LPWSTR;
        PropVariants[i].pwszVal = L"MSMQ for dumpfiles";
        i++;

        QueueProps.aPropID = PropIDs;
        QueueProps.aPropVar = PropVariants;
        QueueProps.cProp = i;
        QueueProps.aStatus = hrProps;
        
        Hr = MQCreateQueue(NULL,
                           &QueueProps,
                           pwszQueueFormatName,
                           &FormatLength);

        if (FAILED(Hr))
        {
            //
            // API Fails, not because the queue exists
            //
            if (((LONG) Hr) != MQ_ERROR_QUEUE_EXISTS)
                PRINTERROR("Cannot create queue", Hr);
        }

    }
    


    Hr = MQOpenQueue(pwszQueueFormatName,
                     bSendQueue ? MQ_SEND_ACCESS : MQ_RECEIVE_ACCESS,
                     MQ_DENY_NONE,
                     &hQueue);
    if (FAILED(Hr))
    {
        PRINTERROR("MQOpenQueue failed", Hr);
    }
    if (FAILED(Hr))
    {
        PRINTERROR("Cannot open queue", Hr);
    }
    *pStartedQ = (IMSMQQueue*) hQueue;
    
    if (g_CreateQ)
    {
        *bCreated  = TRUE;
    }
    return S_OK;

 Cleanup:
    return Hr;
}

/********************************************************************************************
//
// SendMSMQMessage: Sends the message string to the queue
//
//         hSendQ                   QUEUEHANDLE from MQOpenQueue
//
//         pwszMessage              WCHAR array of message body to be send
//
//         pwszMessageLabel         WCHAR array specifying message label
//
//   Returns S_OK for success
//     
*******************************************************************************************/
HRESULT
SendMsmQMessage(
    QUEUEHANDLE hSendQ,
    PWCHAR pwszMessage,
    PWCHAR pwszMessageLabel
    )
{
    HRESULT Hr = S_OK;
    DWORD i;
#define NUM_PROPS 4
    MSGPROPID PropIds[NUM_PROPS];
    MQPROPVARIANT PropVariants[NUM_PROPS] = {0};
    MQMSGPROPS MsgProps = {0};
    HRESULT hrProps[NUM_PROPS];

    if (!hSendQ)
    {
        Hr = E_INVALIDARG;
        PRINTERROR("Invalid Send Q handle", Hr);
    }
    
    i = 0;

    PropIds[i] = PROPID_M_LABEL;
    PropVariants[i].vt = VT_LPWSTR;
    PropVariants[i].pwszVal = pwszMessageLabel;
    
    i++;
    PropIds[i] = PROPID_M_BODY;
    PropVariants[i].vt = VT_VECTOR|VT_UI1;
    PropVariants[i].caub.pElems = (LPBYTE) pwszMessage;
    PropVariants[i].caub.cElems = sizeof(WCHAR) * ( 1 + wcslen (pwszMessage) );

    i++;
    PropIds[i] = PROPID_M_BODY_TYPE;
    PropVariants[i].vt = VT_UI4;
    PropVariants[i].ulVal = VT_LPWSTR;

    PropIds[i] = PROPID_M_TIME_TO_BE_RECEIVED;
    PropVariants[i].vt = VT_UI4; 
    PropVariants[i].ulVal = 60*5;
    i++;

    
    MsgProps.cProp = NUM_PROPS;
    MsgProps.aPropID = PropIds;
    MsgProps.aPropVar = PropVariants;
    MsgProps.aStatus = hrProps;

    Hr = MQSendMessage(hSendQ, &MsgProps, MQ_NO_TRANSACTION);

    if (Hr == MQ_ERROR_PROPERTY)
    {
        dprintf("MQProperty errors\n");
        for (i = 0; i < NUM_PROPS; i++)
        {
            dprintf("%lx: %8lx  --> %08lx\n", i, PropIds[i], hrProps[i]);
        }
    }

    if (FAILED(Hr))
    {
        PRINTERROR("MQSendMessage failed", Hr);
    }
#undef NUM_PROPS
    Hr = S_OK;
    Cleanup:
    return Hr;
}

/****************************************************************************************
// This reveives message from an already opened queue.
//
//         hReceiveQ                QUEUEHANDLE from MQOpenQueue
//
//         pwszMessageBuff          WCHAR array for receiving message body
//
//         SizeofMessageBuff        size of available memory in pwszMessageBuff
//
//         pwszMessageLabelBuff     WCHAR array for receiving label associated with message
//
//         SizeofMessageLabelBuff   size of available memory in pwszMessageLabelBuff
//
//   Returns S_OK for success
//*************************************************************************************/
HRESULT
ReceiveMsmQMessage(
    QUEUEHANDLE hReceiveQ,
    PWCHAR pwszMessageBuff,
    ULONG SizeofMessageBuff,
    PWCHAR pwszMessageLabelBuff,
    ULONG SizeofMessageLabelBuff
    )
{
    HRESULT Hr = S_OK;
#define NUM_RCV_PROPS 5
    MSGPROPID PropIds[NUM_RCV_PROPS];
    MQPROPVARIANT PropVariants[NUM_RCV_PROPS];
    HRESULT hrProps[NUM_RCV_PROPS];
    MQMSGPROPS MessageProps;
    DWORD i;

    if (!hReceiveQ)
    {
        Hr = E_INVALIDARG;
        PRINTERROR("Invalid Receive Q handle", Hr);
    }

    i = 0;

    PropIds[i] = PROPID_M_LABEL_LEN;
    PropVariants[i].vt = VT_UI4;
    PropVariants[i].ulVal = SizeofMessageLabelBuff;
    
    i++;
    PropIds[i] = PROPID_M_LABEL;
    PropVariants[i].vt = VT_LPWSTR;
    PropVariants[i].pwszVal = pwszMessageLabelBuff;
    
    i++;
    PropIds[i] = PROPID_M_BODY_SIZE;
    PropVariants[i].vt = VT_UI4;
    
    i++;
    PropIds[i] = PROPID_M_BODY_TYPE;
    PropVariants[i].vt = VT_UI4;
    
    i++;
    PropIds[i] = PROPID_M_BODY;
    PropVariants[i].vt = VT_VECTOR|VT_UI1;
    PropVariants[i].caub.pElems = (LPBYTE) pwszMessageBuff;
    PropVariants[i].caub.cElems = SizeofMessageBuff;

    i++;

    MessageProps.aPropID = PropIds;
    MessageProps.aPropVar = PropVariants;
    MessageProps.aStatus = hrProps;
    MessageProps.cProp = i;

    Hr = MQReceiveMessage(hReceiveQ, -1, MQ_ACTION_RECEIVE,
                          &MessageProps, NULL, NULL, NULL, MQ_NO_TRANSACTION);
    if (Hr == MQ_ERROR_PROPERTY)
    {
        dprintf("MQProperty errors\n");
        for (i = 0; i < NUM_RCV_PROPS; i++)
        {
            dprintf("%lx: %8lx  --> %08lx\n", i, PropIds[i], hrProps[i]);
        }
    }

    if (FAILED(Hr))
    {
        PRINTERROR("MQReceiveMessage failed", Hr);
    }

    Cleanup:
    return Hr;

}

/******************************************************************************
//
// Close a MsmQ opened with MQOpenQueue
//
//         hQueue               QUEUEHANDLE from MQOpenQueue
//      
//         bDeleteQ             If set TRUE , queue would be deleted
//
// Returns S_OK on success
//
/*****************************************************************************/
HRESULT
CloseMessageQ(
    QUEUEHANDLE hQueue,
    BOOL bDeleteQ
    )
{
    HRESULT Hr = S_OK;
    
    if (!hQueue || FAILED(Hr = MQCloseQueue(hQueue)))
    {
        PRINTERROR("Cannot close queue", Hr);
    }


    if (bDeleteQ)
    {
        // XXX - need a format name 
        // MQDeleteQueue();
    }
    if (FAILED(Hr))
    {
        PRINTERROR("Cannot delete queue", Hr);
    }

    Cleanup:
    return Hr;

}

//--------------------------------------------------------
//
// Receiver Mode
// -------------
// The receiver side does the following:
//    1. Creates a queue on its given computer'
//       of type "guidMQTestType".
//    2. Opens the queue
//    3. In a Loop
//          Receives messages
//          Prints message body and message label
//          Launches debugger
//    4. Cleanup handles
//    5. Deletes the queue from the directory service
//
//--------------------------------------------------------

HRESULT Receiver()
{
    QUEUEHANDLE pqReceive = NULL;
    BSTR bstrFormatName = NULL;
    BSTR bstrPathName = NULL;
    BSTR bstrServiceType = NULL;
    BSTR bstrLabel = NULL;
    BSTR bstrMsgLabel = NULL;
    VARIANT varIsTransactional, varIsWorldReadable, varBody, varBody2, varWantDestQueue, varWantBody, varReceiveTimeout;
    WCHAR wcsPathName[1000];
    BOOL fQuit = FALSE;
    BOOL Created= FALSE;
    HRESULT hresult = NOERROR;

    dprintf("\nReceiver for queue %s on machine %s\nLimit memusage to %ld%%\n", 
            g_QueueName, 
            g_ServerMachine,
            g_MaxMemUsage);

    //
    // Prepare properties to create a queue on local machine
    //

    if (g_FormatName[0])
    {
        // access by formatname
        // Set the FormatName
        StringCbPrintfW(wcsPathName, sizeof(wcsPathName), L"%S", g_FormatName);

        dprintf("Openeing q byt formatname: %ws\n", wcsPathName);
        bstrFormatName = SysAllocString(wcsPathName);
        if (bstrFormatName == NULL)
        {
            PRINTERROR("OOM: formatname", E_OUTOFMEMORY);
        }
    } else 
    {
        // access by pathname
        // Set the PathName
        StringCbPrintfW(wcsPathName, sizeof(wcsPathName), L"%S\\%S", g_ServerMachine,g_QueueName);

        dprintf("Openeing q %ws\n", wcsPathName);
        bstrPathName = SysAllocString(wcsPathName);
        if (bstrPathName == NULL)
        {
            PRINTERROR("OOM: pathname", E_OUTOFMEMORY);
        }
    }


    hresult = StartMessageQ(bstrFormatName, bstrPathName, FALSE,
                            &pqReceive, &Created);
    if (FAILED(hresult))
    {
        PRINTERROR("Cannot start Q", hresult);
    }
    
    g_DumpPath[0] = 0;

    //
    // Main receiver loop
    //
    dprintf("\nWaiting for messages ...\n");
    while (!fQuit)
    {
        WCHAR BufferMsg[1024], BufferLabel[100];
        MEMORYSTATUS stat;
        ULONG nWaitCount;
        
        //
        // Receive the message
        //
        hresult = ReceiveMsmQMessage(pqReceive,BufferMsg, sizeof(BufferMsg),
                                     BufferLabel, sizeof(BufferLabel));

        if (FAILED(hresult))
        {
            PRINTERROR("Receive message", hresult);
        }

        dprintf("%ws : %ws\n", BufferLabel, BufferMsg);

        //
        // Check for end of app
        //
        if (_wcsicmp(BufferMsg, L"quit") == 0)
        {
            fQuit = TRUE;
        }
        else
        {
            // Launch the debugger

            StringCbPrintfA(g_DumpPath, sizeof(g_DumpPath), "%ws", BufferMsg);
            if (LaunchDebugger(FALSE) == S_OK)
            {
                // done with this dump
                g_DumpPath[0] = 0;
            }
        }

        // wait for sometime before launching another process
        stat.dwMemoryLoad = -1;
        nWaitCount = 0;
        while (stat.dwMemoryLoad > g_MaxMemUsage)
        {
            //
            //
            // Check CPU load and return when it's below our bound
            //

            GlobalMemoryStatus(&stat);
            nWaitCount++;
            if (stat.dwMemoryLoad > g_MaxMemUsage)
            {
                dprintf("Memory usage now is %ld%%, waiting (%ldms) for usage < %ld%%\r",
                        stat.dwMemoryLoad,
                        g_PauseForNext * nWaitCount,
                        g_MaxMemUsage);
                if (nWaitCount > 100)
                {
                    nWaitCount = 100;
                }
            }
            Sleep( g_PauseForNext * nWaitCount );
        
        }
        dprintf("Memory usage now is %ld%%, waiting for message ...\r",
               stat.dwMemoryLoad);

    } /* while (!fQuit) */

    // fall through...

    Cleanup:
    CloseMessageQ(pqReceive, Created);
    if (bstrPathName) SysFreeString(bstrPathName);
    if (bstrFormatName) SysFreeString(bstrFormatName);
    return hresult;
}


/************************************************************************************************
// 
// SendMessageText - generic API to send message on an MSMQ, It opens the queue, puts message in it
//                   and closes the queue.
//
//    pwszMsmqFormat      - Format name identifying the queue where message is to be sent
//
//    pwszMesgLabel       - Label for the message to be sent
// 
//    pwszMesgText        - Message to be sent
//
// Reuturns S_OK on sucess
//
*************************************************************************************************/
HRESULT
SendMessageText(
    PWCHAR pwszMsmqFormat,
    PWCHAR pwszMesgLabel,
    PWCHAR pwszMesgText
    )
{
    HRESULT Hr;
    BOOL Created = FALSE;
    QUEUEHANDLE hSendQ = NULL;

    Hr = StartMessageQ(pwszMsmqFormat, NULL, TRUE,
                       &hSendQ, &Created);
    if (FAILED(Hr))
    {
        PRINTERROR("Cannot start Q", Hr);
    }
    
    SendMsmQMessage(hSendQ, pwszMesgText, pwszMesgLabel);

    Cleanup:
    CloseMessageQ(hSendQ, Created);
    return Hr;
}

void PrintError(char *s, HRESULT hr)
{
    dprintf("Cleanup: %s (0x%X)\n", s, hr);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\msmq\dll\mqext.cpp ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    ext.cpp

Abstract:

    Generic cross-platform and cross-processor extensions.

Environment:

    User Mode

--*/

#include "mqext.h"

#include <ntverp.h>
#include <time.h>
#include <lm.h>

// To get _open to work
#include <crt\io.h>
#include <fcntl.h>
#include <sys\types.h>
#include <sys\stat.h>

//
// Valid for the lifetime of the debug session.
//

WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG   TargetMachine;
BOOL    Connected;
ULONG   g_TargetClass;
ULONG   g_TargetBuild;
ULONG   g_TargetPlatform;

//
// Valid only during an extension API call
//

PDEBUG_ADVANCED        g_ExtAdvanced;
PDEBUG_CLIENT          g_ExtClient;
PDEBUG_DATA_SPACES3    g_ExtData;
PDEBUG_REGISTERS       g_ExtRegisters;
PDEBUG_SYMBOLS2        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS3 g_ExtSystem;
// Version 3 Interfaces
PDEBUG_CONTROL3        g_ExtControl;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;

    if ((Status = Client->QueryInterface(__uuidof(IDebugAdvanced),
                                 (void **)&g_ExtAdvanced)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugDataSpaces3),
                                 (void **)&g_ExtData)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                 (void **)&g_ExtRegisters)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                 (void **)&g_ExtSymbols)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSystemObjects3),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl2),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }

    g_ExtClient = Client;

    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtAdvanced);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
    EXT_RELEASE(g_ExtControl);
}

// Normal output.
void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

// Error output.
void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

// Warning output.
void __cdecl
ExtWarn(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_WARNING, Format, Args);
    va_end(Args);
}

// Verbose output.
void __cdecl
ExtVerb(PCSTR Format, ...)
{
    va_list Args;

    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_VERBOSE, Format, Args);
    va_end(Args);
}


extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        return Hr;
    }

    ExtensionApis.nSize = sizeof (ExtensionApis);
    if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK) {
        return Hr;
    }

    DebugControl->Release();
    DebugClient->Release();
    
    return S_OK;

}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    //
    // The first time we actually connect to a target, get the page size
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        PDEBUG_DATA_SPACES DebugDataSpaces;
        PDEBUG_CONTROL DebugControl;
        HRESULT Hr;
        ULONG64 Page;

        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK)
        {
            //
            // Get the architecture type.
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                                  (void **)&DebugControl)) == S_OK)
            {
                if ((Hr = DebugControl->GetActualProcessorType(
                    &TargetMachine)) == S_OK)
                {
                    Connected = TRUE;
                }
                ULONG MajorVer, SrvPack;
                if ((Hr = DebugControl->GetSystemVersion(
                                         &g_TargetPlatform, &MajorVer,
                                         &g_TargetBuild, NULL,
                                         0, NULL,
                                         &SrvPack, NULL,
                                         0, NULL)) == S_OK) {
                }

                ULONG Qualifier;
                if ((Hr = DebugControl->GetDebuggeeType(&g_TargetClass, &Qualifier)) == S_OK)
                {
                }

                DebugControl->Release();
            }

            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    return;
}


DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}

extern char g_FormatName[MAX_PATH];
extern BOOL g_bSend;


BOOL
GetArgs(int Argc, CHAR ** Argv);
HRESULT
SendMessageText(
    PWCHAR pwszMsmqFormat,
    PWCHAR pwszMesgLabel,
    PWCHAR pwszMesgText
    );


DECLARE_API( initmq )
{
    PCHAR ArgTokens[100];
    ULONG Argc;
    CHAR seps[] = " \t";
    PCHAR tok;
    CHAR LocArgs[1024];

    INIT_API();

    if (StringCchCopy(LocArgs, sizeof(LocArgs), args) != S_OK)
    {
        LocArgs[0] = 0;
    }

    Argc = 0;
    tok = strtok(LocArgs, seps);
    while (tok && (Argc < sizeof(ArgTokens)/sizeof(ArgTokens[0])))
    {
        ArgTokens[Argc++] = tok;
        tok = strtok(NULL, seps);
    }
    GetArgs(Argc, ArgTokens);

    EXIT_API();
    return S_OK;
}

DECLARE_API( send )
{
    WCHAR Message[MAX_PATH], wszFormat[MAX_PATH];
    INIT_API();

    if ((StringCbPrintfW(Message, sizeof(Message), L"%S", args) != S_OK) ||
        (StringCbPrintfW(wszFormat, sizeof(wszFormat), L"%S", g_FormatName) != S_OK))
    {
        EXIT_API();
        return E_FAIL;
    }

    SendMessageText(wszFormat, L"MQEXT", Message);

    EXIT_API();
    return S_OK;
}

HRESULT
_EFN_SendMQMessageText(
    LPWSTR pwszFormat,
    LPWSTR pwszLabel,
    LPWSTR pwszMessage
    )
{
    return SendMessageText(pwszFormat, pwszLabel, pwszMessage);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\msmq\dll\mqext.h ===
/*++

Copyright (c) 1993-1999  Microsoft Corporation

Module Name:

    precomp.h

Abstract:

    This header file is used to cause the correct machine/platform specific
    data structures to be used when compiling for a non-hosted platform.

--*/

// This is a 64 bit aware debugger extension
#define KDEXT_64BIT

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <wdbgexts.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <strsafe.h>

#define INITGUID
#include <dbgeng.h>
#include <guiddef.h>
#include <lmerr.h>

#ifdef __cplusplus
extern "C" {
#endif

//
// undef the wdbgexts
//
#undef DECLARE_API

#define DECLARE_API(extension)     \
CPPMOD HRESULT CALLBACK extension(PDEBUG_CLIENT Client, PCSTR args)

#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status; 

#define EXIT_API     ExtRelease


// Safe release and NULL.
#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

// Global variables initialized by query.
extern PDEBUG_ADVANCED        g_ExtAdvanced;
extern PDEBUG_CLIENT          g_ExtClient;
extern PDEBUG_DATA_SPACES3    g_ExtData;
extern PDEBUG_REGISTERS       g_ExtRegisters;
extern PDEBUG_SYMBOLS2        g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS3 g_ExtSystem;
extern PDEBUG_CONTROL3        g_ExtControl;

extern ULONG   TargetMachine;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);

// Error output.
void __cdecl ExtErr(PCSTR Format, ...);

//-----------------------------------------------------------------------------------------
//
//  api declaration macros & api access macros
//
//-----------------------------------------------------------------------------------------

extern WINDBG_EXTENSION_APIS ExtensionApis;
extern ULONG TargetMachine;
extern ULONG g_TargetClass;
extern ULONG g_TargetBuild;
extern ULONG g_TargetPlatform;

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\msmq\exe\main.cpp ===
/*++

Copyright (c) 1992-2001  Microsoft Corporation

Module Name:
    mqrcvr.cpp

Abstract:
    Receives file names from server and launches debugger

--*/


//
// Includes
//
#include <stdio.h>
#include <windows.h>
#include <objbase.h>
#include <tchar.h>

//
// Unique include file for ActiveX MSMQ apps
//
#include <mqoai.h>

//
// Various defines
//
#define MAX_VAR       20
#define MAX_BUFFER   500

extern char g_ServerMachine[MAX_COMPUTERNAME_LENGTH*4 + 1];
extern char g_FormatName[MAX_PATH];
extern CHAR g_DumpPath[MAX_PATH + 1];
extern BOOL g_SendMail;

extern BOOL g_CreateQ;
extern BOOL g_bSend;

//
// Prototypes
//
HRESULT Syntax();

HRESULT Receiver();

HRESULT
LaunchDebugger(BOOL fWait);

HRESULT
SendMessageText(
    PWCHAR pwszMsmqFormat,
    PWCHAR pwszMesgLabel,
    PWCHAR pwszMesgText
    );

BOOL
GetArgs(int Argc, CHAR ** Argv);


int __cdecl
CheckForUnprocessedDumps()
{
    // This check s if any dumps was left unprocessed when this
    // process exited (abnormally)

    if (g_DumpPath[0])
    {
        // we have an unprocessed dump.
        // try and launch debugger on it
        printf("Found unprocessed dump\n");
        if (LaunchDebugger(FALSE) == S_OK)
        {
            g_DumpPath[0] = 0;
        }
    }

    return 0;
}

void
SendLoop()
{
    WCHAR Msg[100]={0}, Label[100]={0}, Format[100]={0};
    CHAR Buffer[100]={0};
    DWORD MsgId = 0;

    _snwprintf(Format, sizeof(Format)/sizeof(Format[0]), L"%S", g_FormatName);
    Format[sizeof(Format)/sizeof(Format[0]) - 1] = 0;
    while (Buffer[0] != 'q')
    {
        printf("Enter label : ");
        if (!scanf("%50s", Buffer))
        {
            Buffer[0] =0;
        }
        _snwprintf(Label, sizeof(Label)/sizeof(Label[0]), L"%02ld: %S", MsgId, Buffer);
        Label[sizeof(Label)/sizeof(Label[0]) -1] = 0;
        printf("Message %02ld : ", MsgId++);
        if (!scanf("%50s", Buffer))
        {
            Buffer[0] =0;
        }
        _snwprintf(Msg, sizeof(Msg) / sizeof(Msg[0]), L"%S", Buffer);
        Msg[sizeof(Msg) / sizeof(Msg[0]) -1] = 0;
        SendMessageText(Format, Label, Msg );
    }

}
//-----------------------------------------------------
//
//  MAIN
//
//-----------------------------------------------------
int __cdecl main(int argc, char * * argv)
{
    DWORD dwNumChars;
    HRESULT hresult = NOERROR;


    hresult = OleInitialize(NULL);
    if (FAILED(hresult))
    {
        printf("Cannot init OLE", hresult);
        goto Cleanup;
    }

    //
    // Retrieve machine name
    //
    dwNumChars = MAX_COMPUTERNAME_LENGTH + 1;
    GetComputerNameA(g_ServerMachine, &dwNumChars);


    if (GetArgs(argc, argv))
    {
        g_DumpPath[0] = 0;
        _onexit( CheckForUnprocessedDumps );
        if (!g_bSend)
        {
            hresult = Receiver();
        } else
        {
            SendLoop();
        }

    }
    else
    {
        hresult = Syntax();
    }

    printf("\nOK\n");

    // fall through...


    Cleanup:
    return(int)hresult;
}


HRESULT Syntax()
{
    printf("\n");
    printf("Syntax: mqrcvr.exe -d <debugger> \n"
           "                   -f <formatname> \n"
           "                   -m <memoryusage> \n"
           "                   -mail\n"
           "                   -p <miliseconds>\n"
           "                   -q <queue>\n"
           "                   -retriage\n"
           "                   -s <server> \n"
           "                   -y <local symbol cache> \n");
    return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca-common\ocaver.h ===
//----------------------------------------------------------------------------
//
// Debugger package binary version information.
//
// Copyright (C) Microsoft Corporation, 2000-2002.
//
//----------------------------------------------------------------------------

#if _MSC_VER > 1000
#pragma once
#endif

#ifdef OFFICIAL_BUILD
#include <ntverp.h>
#else

#define VER_PRODUCTMAJORVERSION     3
#define VER_PRODUCTMINORVERSION     0
#define VER_PRODUCTBUILD            0
#define VER_PRODUCTBUILD_QFE        0
#define VER_PRODUCTVERSION_W        (0x0100)
#define VER_PRODUCTVERSION_DW       (0x01000000 | VER_PRODUCTBUILD)

#define VER_PRODUCTBETA_STR         ""

#define VER_PRODUCTVERSION_MAJORMINOR2(x,y) #x "." #y
#define VER_PRODUCTVERSION_MAJORMINOR1(x,y) VER_PRODUCTVERSION_MAJORMINOR2(x, y)
#define VER_PRODUCTVERSION_STRING   VER_PRODUCTVERSION_MAJORMINOR1(VER_PRODUCTMAJORVERSION, VER_PRODUCTMINORVERSION)

#define VER_PRODUCTVERSION          VER_PRODUCTMAJORVERSION,VER_PRODUCTMINORVERSION,VER_PRODUCTBUILD,VER_PRODUCTBUILD_QFE

#if     (VER_PRODUCTBUILD < 10)
#define VER_BPAD "000"
#elif   (VER_PRODUCTBUILD < 100)
#define VER_BPAD "00"
#elif   (VER_PRODUCTBUILD < 1000)
#define VER_BPAD "0"
#else
#define VER_BPAD
#endif

#define VER_PRODUCTVERSION_STR2(x,y) VER_PRODUCTVERSION_STRING "." VER_BPAD #x "." #y
#define VER_PRODUCTVERSION_STR1(x,y) VER_PRODUCTVERSION_STR2(x, y)
#define VER_PRODUCTVERSION_STR       VER_PRODUCTVERSION_STR1(VER_PRODUCTBUILD, VER_PRODUCTBUILD_QFE)

/*--------------------------------------------------------------*/
/* the following section defines values used in the version     */
/* data structure for all files, and which do not change.       */
/*--------------------------------------------------------------*/

/* default is nodebug */
#if DBG
#define VER_DEBUG                   VS_FF_DEBUG
#else
#define VER_DEBUG                   0
#endif

/* default is prerelease */
#if BETA
#define VER_PRERELEASE              VS_FF_PRERELEASE
#else
#define VER_PRERELEASE              0
#endif

#if OFFICIAL_BUILD
#define VER_PRIVATE                 0
#else
#define VER_PRIVATE                 VS_FF_PRIVATEBUILD
#endif

#define VER_FILEFLAGSMASK           VS_FFI_FILEFLAGSMASK
#define VER_FILEOS                  VOS_NT_WINDOWS32
#define VER_FILEFLAGS               (VER_PRERELEASE|VER_DEBUG|VER_PRIVATE)

#define VER_COMPANYNAME_STR         "Microsoft Corporation"
#define VER_PRODUCTNAME_STR         "Windows Online Crash Analysis"
#define VER_LEGALTRADEMARKS_STR     \
"Microsoft(R) is a registered trademark of Microsoft Corporation. Windows (R) is a registered trademark of Microsoft Corporation."

#endif

#ifndef _WIN32_WCE
#include <common.ver>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca-common\ocamon.h ===
/*******************************************************************
*
*    DESCRIPTION:
*           headers for monitoring service for debugger on oca dump processing server
*
*    AUTHOR: kksharma
*
*    HISTORY:
*
*    DATE:9/23/2002
*
*******************************************************************/


#ifndef _OCAMON_H_
#define _OCAMON_H_

#include <windows.h>
#include <wtypes.h>
#include <tchar.h>

const TCHAR c_tszCollectPipeName[]   = _T("\\\\.\\pipe\\OcaKdMonPipe");


typedef struct _OCAKD_RESULT {
    ULONG   SizeOfStruct;                // Must be sizeof(OCAKD_RESULT)
    CHAR    CrashGuid[40];               // Unique id associated with this crash
    HRESULT hrAddCrash;                  // Contains result of database addcrash operation
    ULONG   SolutionId;                  // SolutionId for th crash
    ULONG   ResponseType;                // Type of response (depends on solution Id)
    CHAR    BucketId[100];               // Bucket of the crash
    CHAR    ArchivePath[200];            // Full path of Archived crash
} OCAKD_RESULT, *POCAKD_RESULT;

typedef struct _DBGLAUNCH_NOTICE {
    ULONG   SizeOfStruct;                // Must be sizeof(DBGLAUNCHER_REPORT)
    CHAR    CrashGuid[40];               // Guid with which debugger was launched
    ULONG   Source;                      // Source of message received
    ULONG   nKdsRunning;                 // Dbglauncher's count of number of debuggers running
    CHAR    OriginalPath[MAX_PATH];      // Path of crash which is going to be analysed
} DBGLAUNCH_NOTICE, *PDBGLAUNCH_NOTICE;

#define OKD_MESSAGE_DEBUGGER_RESULT      1
#define OKD_MESSAGE_DBGLAUNCH_NOTIFY     2

typedef struct _OCAKD_MONITOR_MESSAGE {
    ULONG   MessageId;                   // Determines which kind of message is being sent/received
    union {
        OCAKD_RESULT KdResult;           // Message Id should be 1
        DBGLAUNCH_NOTICE DbglNotice;     // Message Id should be 2
    } u;
} OCAKD_MONITOR_MESSAGE, *POCAKD_MONITOR_MESSAGE;

typedef struct _OCAKD_MONITOR_RESULT {
    ULONG   SizeOfStruct;                // must be sizeof (OCAKD_MONITOR_RESULT)
    ULONG   NumProcessedLas;
    ULONG   AverageTime;                 // average time in miliseconds between dbglauncher
} OCAKD_MONITOR_RESULT, *POCAKD_MONITOR_RESULT;

#endif // _OCAMON_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\msmqmon\msmqmon.h ===
#pragma once
#include <objbase.h>
#include <Windows.h>
#include <stdio.h>
#include <tchar.h>
#include <mq.h>
#include <strsafe.h>



#ifndef __MSMQMON
#define __MSMQMON

class MSMQMon
{
public:
	//constructors
	MSMQMon( TCHAR *szQueueToMonitor);
	MSMQMon();


	//de-structors 
	~MSMQMon(void);

	void	DisplayCurrentQueue( TCHAR *szUserRetVal );
	void	SetMessageWaitTime( DWORD dwNewWaitTime );

	HRESULT ConnectToQueue( void );
	HRESULT ConnectToQueue( DWORD constAccessType );
	HRESULT CloseOpenQueue( void );
	DWORD	CountMessagesInQueue( int *count );



	BOOL SendQueueMessage( void );

private:
	TCHAR			szQueueName[256];			//name of the queue to monitor
	QUEUEHANDLE		hOpenQueue;					//handle to the open queue
	DWORD			dwQueueAccessType;
	DWORD			dwMsgWaitTime;				//Amount of time to wait for a message to enter the queue (ms)

};


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca-common\inetupld.h ===
/*******************************************************************
*
*    DESCRIPTION:
*               Header for uploading file to server
*
*    DATE:8/22/2002
*
*******************************************************************/

#ifndef __INETUPLOAD_H_
#define __INETUPLOAD_H_

typedef enum _EnumUploadStatus {
    UploadNotStarted,
    UploadStarted,
    UploadCompressingFile,
    UploadCopyingFile,
    UploadConnecting,
    UploadTransferInProgress,
    UploadGettingResponse,
    UploadFailure,
    UploadSucceded
} EnumUploadStatus;

// {1131D95E-FFF0-4063-A744-00001555C706}
DEFINE_GUID(IID_IOcaUploadFile, 0x1131D95E, 0xFFF0, 0x4063,
            0xA7, 0x44, 0x00,0x00,  0x15, 0x55, 0xC7, 0x06);

typedef interface DECLSPEC_UUID("1131D95E-FFF0-4063-A744-00001555C706")
    IOcaUploadFile* POCA_UPLOADFILE;

#undef INTERFACE
#define INTERFACE IOcaUploadFile
DECLARE_INTERFACE_(IOcaUploadFile, IUnknown)
{
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        ) PURE;
    STDMETHOD_(ULONG, AddRef)(
        THIS
        ) PURE;
    STDMETHOD_(ULONG, Release)(
        THIS
        ) PURE;

    // IOcaUploadFile.


    STDMETHOD(InitializeSession)(
        THIS_
        LPWSTR OptionCode,
        LPWSTR wszFileToSend
        ) PURE;
    STDMETHOD(SendFile)(
        THIS_
        LPWSTR wszRemoteFileName,
        BOOL bSecureMode
        ) PURE;
    STDMETHOD(UnInitialize)(
        THIS_
        ) PURE;
    STDMETHOD(Cancel)(
        THIS_
        ) PURE;

    STDMETHOD(GetUrlPageData)(
        THIS_
        LPWSTR wszUrl,
        LPWSTR wszUrlPage,
        ULONG cbUrlPage
        ) PURE;
    STDMETHOD_(ULONG, GetPercentComplete)(
        THIS_
        ) PURE;
    STDMETHOD_(LPWSTR, GetServerName)(
        THIS_
        ) PURE;
    STDMETHOD_(BOOL, IsUploadInProgress)(
        THIS_
        ) PURE;
    STDMETHOD_(BOOL, GetUploadResult)(
        THIS_
        LPTSTR Result,
        ULONG cbResult
        ) PURE;

    STDMETHOD(SetUploadResult)(
        THIS_
        EnumUploadStatus Success,
        LPCTSTR Text
        ) PURE;

};

BOOL
OcaUpldCreate(POCA_UPLOADFILE* pUpload);

#endif // __INETUPLOAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\countdaily.cpp ===
// CountDaily.cpp : Implementation of CCountDaily
#include "stdafx.h"
#include "CountDaily.h"
#include "ReportCountDaily.h"
#include "ReportDailyBuckets.h"
#include "ReportAnonUsers.h"
#include "ReportSpecificSolutions.h"
#include "ReportGeneralSolutions.h"
#include "ReportGetHelpInfo.h"
#include "ReportGetAutoUploads.h"
#include "ReportGetManualUploads.h"
#include "ReportGetIncompleteUploads.h"

#include "ATLComTime.h"
#include <comutil.h>
#include <stdio.h>


#import "c:\Program Files\Common Files\System\ADO\msado15.dll" \
   no_namespace rename("EOF", "EndOfFile")

const CComBSTR cScore = "_";
const CComBSTR cDash = "-";

// CCountDaily

/*************************************************************************************
*	module: CountDaily.cpp
*
*	author: Tim Ragain
*	date: Jan 2, 2002
*
*	Purpose: To return the incident count for a specific date.  This uses OLEDB template
*	CReportCountDaily.h that calls stored procedure ReportCountDaily.  
*	
*************************************************************************************/

STDMETHODIMP CCountDaily::GetDailyCount(DATE dDate, LONG* iCount)
{
	CReportCountDaily pRep;
	COleDateTime pDate(dDate);
	long lCount = 0;

	pRep.m_ReportDate.year = pDate.GetYear();
	pRep.m_ReportDate.day = pDate.GetDay();
	pRep.m_ReportDate.month = pDate.GetMonth();
	pRep.m_ReportDate.hour = 0;
	pRep.m_ReportDate.minute = 0;
	pRep.m_ReportDate.second = 0;
	pRep.m_ReportDate.fraction = 0;
	
	HRESULT hr = pRep.OpenAll();
	_ASSERTE(SUCCEEDED(hr));
	if(SUCCEEDED(hr)==false)
	{
		Error(_T("Unable to open the database"));
		return E_FAIL;
	}
	hr = S_OK;
	hr = pRep.MoveFirst();
	_ASSERTE(SUCCEEDED(hr));
	if(SUCCEEDED(hr)==false)
	{
		Error(_T("No data was returned"));
		return E_FAIL;
	}
	lCount = pRep.m_IncidentID;
	*iCount = lCount;
	pRep.CloseAll();

	return S_OK;
}

/*************************************************************************************
*	module: CountDaily.cpp
*
*	author: Tim Ragain
*	date: Jan 2, 2002
*
*	Purpose: To return an ado recordset from the results of calling stored procedure
*	ReportCountDaily.  Presently this is not used but left for future implementation.
*	
*************************************************************************************/

STDMETHODIMP CCountDaily::GetDailyCountADO(DATE dDate, LONG* iCount)
{
	_RecordsetPtr   pRs("ADODB.Recordset");
	_ConnectionPtr  pCn("ADODB.Connection");
	_CommandPtr pCm("ADODB.Command");
	_ParameterPtr pPa("ADODB.Parameter");
	VARIANT v_stamp;
	ErrorPtr  pErr  = NULL;
	COleDateTime pDate(dDate);

	v_stamp.vt = VT_CY;
	v_stamp.date = dDate;
	pCn->Open(L"Provider=SQLOLEDB.1;Integrated Security=SSPI;Persist Security Info=False;Initial Catalog=KaCustomer2;Data Source=OCATOOLSDB;Use Procedure for Prepare=1;Auto Translate=True;Packet Size=4096;Workstation ID=TIMRAGAIN05;Use Encryption for Data=False;Tag with column collation when possible=False","", "", NULL);
    if((pCn->Errors->Count) > 0)
    {
		pErr = pCn->Errors->GetItem(0);
		return E_FAIL;
	}
	pCm->ActiveConnection = pCn;
	pCm->CommandText = "ReportCountDaily";
	pCm->CommandType = adCmdText;
	
	pPa = pCm->CreateParameter("ReportDate", adDBTimeStamp, adParamInput, NULL, dDate);
    pCm->Parameters->Append(pPa);

	pPa->Value = v_stamp.date;

	pRs = pCm->Execute(NULL, NULL, adCmdStoredProc);
    if((pCn->Errors->Count) > 0)
    {
		pErr = pCn->Errors->GetItem(0);
		return E_FAIL;
	}
	if(pRs->State != adStateOpen)
	{
		return E_FAIL;
	}
	HRESULT hr = pRs->MoveFirst();
	_ASSERTE(SUCCEEDED(hr));
	if(SUCCEEDED(hr)==false)
	{
		return E_FAIL;
	}
	*iCount = pRs->Fields->Item["iCount"]->Value;

	pRs->Close();
	pCn->Close();

	pPa = NULL;
	pCm = NULL;
	pCn = NULL;
	pRs = NULL;

	return S_OK;
}

/*************************************************************************************
*	module: CountDaily.cpp
*
*	author: Tim Ragain
*	date: Jan 2, 2002
*
*	Purpose: To return an ADO recordset of daily buckets for a specific date.
*	This is presently not used but remains for future use.  
*	
*************************************************************************************/

STDMETHODIMP CCountDaily::ReportDailyBuckets(DATE dDate, IDispatch** p_Rs)
{
	CReportDailyBuckets pRep;
	COleDateTime pDate(dDate);

	pRep.m_ReportDate.year = pDate.GetYear();
	pRep.m_ReportDate.day = pDate.GetDay();
	pRep.m_ReportDate.month = pDate.GetMonth();
	pRep.m_ReportDate.hour = 0;
	pRep.m_ReportDate.minute = 0;
	pRep.m_ReportDate.second = 0;
	pRep.m_ReportDate.fraction = 0;
	
	HRESULT hr = pRep.OpenAll();
	_ASSERTE(SUCCEEDED(hr));
	if(SUCCEEDED(hr)==false)
	{
		return E_FAIL;
	}
	hr = pRep.MoveFirst();
	_ASSERTE(SUCCEEDED(hr));
	if(SUCCEEDED(hr)==false)
	{
		return E_FAIL;
	}


	ADORecordsetConstructionPtr pCRS;
	_RecordsetPtr pTempRS(__uuidof(Recordset));
	pCRS = pTempRS;
	
	hr = pCRS->put_Rowset((LPUNKNOWN)(pRep.m_spRowset));
	_ASSERTE(SUCCEEDED(hr));
	if(SUCCEEDED(hr)==false)
	{
		return E_FAIL;
	}
	hr = pCRS->QueryInterface(__uuidof(_Recordset),(void **)p_Rs);
	if(SUCCEEDED(hr)==false)
	{
		return E_FAIL;
	}
	pRep.CloseAll();
	
	return S_OK;
}

/*************************************************************************************
*	module: CountDaily.cpp
*
*	author: Tim Ragain
*	date: Jan 2, 2002
*
*	Purpose: to count the specific files for a specific date on the Watson or Archive server.
*	The directory format is different on each server.  The watson uses "1_2_2002" while the Archive uses 
*	"1-2-2002".  
*************************************************************************************/

STDMETHODIMP CCountDaily::GetFileCount(ServerLocation eServer, BSTR b_Location, DATE d_Date, LONG* iCount)
{
	
	HANDLE hSearch=NULL;
	WIN32_FIND_DATA FileData; 
	LONG l_FileCount = 0;
	CComBSTR b_Path, b_DateDirectory;
	COleDateTime pDate(d_Date);
	LONG l_Day = 0, l_Year = 0, l_Month = 0;
	char * s_Temp;
	//LPCSTR szFindFiles;
	TCHAR * szFindFiles;
	USES_CONVERSION;

	s_Temp = new char;

	b_Path.AppendBSTR(b_Location);

	l_Day = pDate.GetDay();
	l_Year = pDate.GetYear();
	l_Month = pDate.GetMonth();
	//month
	_itoa(l_Month, s_Temp, 10);
	b_DateDirectory.Append(s_Temp);
	if(eServer==0)
	{
		b_DateDirectory.Append(cScore);
	}
	else
	{
		b_DateDirectory.Append(cDash);
	}
	//Day
	_itoa(l_Day, s_Temp, 10);
	b_DateDirectory.Append(s_Temp);
	if(eServer==0)
	{
		b_DateDirectory.Append(cScore);
	}
	else
	{
		b_DateDirectory.Append(cDash);
	}
	//Year
	_itoa(l_Year, s_Temp, 10);
	b_DateDirectory.Append(s_Temp);

	b_Path.AppendBSTR(b_DateDirectory);
	b_Path.Append("\\");
	b_Path.Append("*.cab");

	szFindFiles = OLE2T(b_Path);
	

	hSearch = FindFirstFile(szFindFiles, &FileData);
	if (hSearch == INVALID_HANDLE_VALUE) 
	{ 
		l_FileCount = 0;
		*iCount = l_FileCount;
		return S_OK;
	} 
	l_FileCount = 0;
	do
	{
		l_FileCount++;
	} while(FindNextFile(hSearch, &FileData));
	*iCount = l_FileCount;
	FindClose(hSearch);
	
	return S_OK;
}

/*************************************************************************************
*	module: CountDaily.cpp
*
*	author: Tim Ragain
*	date: Jan 2, 2002
*
*	Purpose: To count the anonymous users uploading files for a specific date.  This uses
*	the OLEDB template CReportAnonUsers.h that calls the stored procedure ReportGetAnonUsers.
*	
*************************************************************************************/

STDMETHODIMP CCountDaily::GetDailyAnon(DATE dDate, LONG* iCount)
{

	CReportAnonUsers pRep;
	COleDateTime pDate(dDate);
	long lCount = 0;

	pRep.m_ReportDate.year = pDate.GetYear();
	pRep.m_ReportDate.day = pDate.GetDay();
	pRep.m_ReportDate.month = pDate.GetMonth();
	pRep.m_ReportDate.hour = 0;
	pRep.m_ReportDate.minute = 0;
	pRep.m_ReportDate.second = 0;
	pRep.m_ReportDate.fraction = 0;
	

	HRESULT hr = pRep.OpenAll();
	_ASSERTE(SUCCEEDED(hr));
	if(SUCCEEDED(hr)==false)
	{
		return E_FAIL;
	}
	hr = S_OK;
	hr = pRep.MoveFirst();
	_ASSERTE(SUCCEEDED(hr));
	if(SUCCEEDED(hr)==false)
	{
		return E_FAIL;
	}
	lCount = pRep.m_Count;
	*iCount = lCount;
	pRep.CloseAll();
	return S_OK;
}

/*************************************************************************************
*	module: CountDaily.cpp
*
*	author: Tim Ragain
*	date: Jan 2, 2002
*
*	Purpose: To count the specific solutions, SBuckets, for a specific date.  This calls
*	the OLEDB template CReportSpecificSolutions.h that uses the stored procedure
*	ReportGetSBuckets.
*************************************************************************************/

STDMETHODIMP CCountDaily::GetSpecificSolutions(DATE dDate, LONG* iCount)
{
	CReportSpecificSolutions pRep;

	COleDateTime pDate(dDate);
	long lCount = 0;

	pRep.m_ReportDate.year = pDate.GetYear();
	pRep.m_ReportDate.day = pDate.GetDay();
	pRep.m_ReportDate.month = pDate.GetMonth();
	pRep.m_ReportDate.hour = 0;
	pRep.m_ReportDate.minute = 0;
	pRep.m_ReportDate.second = 0;
	pRep.m_ReportDate.fraction = 0;
	
	HRESULT hr = pRep.OpenAll();
	_ASSERTE(SUCCEEDED(hr));
	if(SUCCEEDED(hr)==false)
	{
		return E_FAIL;
	}
	hr = S_OK;
	hr = pRep.MoveFirst();
	_ASSERTE(SUCCEEDED(hr));
	if(SUCCEEDED(hr)==false)
	{
		return E_FAIL;
	}
	lCount = pRep.m_Count;
	*iCount = lCount;
	pRep.CloseAll();

	return S_OK;
}

/*************************************************************************************
*	module: CountDaily.cpp
*
*	author: Tim Ragain
*	date: Jan 2, 2002
*
*	Purpose: To obtain a count for a specific date of the GBuckets that have no solved SBucket.  This
*	uses the OLEDB template located in CReportGeneralSolutions.h file that calls the stored procedure
*	ReportGetGBucket.
*************************************************************************************/

STDMETHODIMP CCountDaily::GetGeneralSolutions(DATE dDate, LONG* iCount)
{
	CReportGeneralSolutions pRep;

	COleDateTime pDate(dDate);
	long lCount = 0;

	pRep.m_ReportDate.year = pDate.GetYear();
	pRep.m_ReportDate.day = pDate.GetDay();
	pRep.m_ReportDate.month = pDate.GetMonth();
	pRep.m_ReportDate.hour = 0;
	pRep.m_ReportDate.minute = 0;
	pRep.m_ReportDate.second = 0;
	pRep.m_ReportDate.fraction = 0;
	
	HRESULT hr = pRep.OpenAll();
	_ASSERTE(SUCCEEDED(hr));
	if(SUCCEEDED(hr)==false)
	{
		return E_FAIL;
	}
	hr = S_OK;
	hr = pRep.MoveFirst();
	_ASSERTE(SUCCEEDED(hr));
	if(SUCCEEDED(hr)==false)
	{
		return E_FAIL;
	}
	lCount = pRep.m_Count;
	*iCount = lCount;
	pRep.CloseAll();

	return S_OK;
}

/*************************************************************************************
*	module: CountDaily.cpp
*
*	author: Tim Ragain
*	date: Jan 2, 2002
*
*	Purpose: To obtain the count of incidents on a specific date that have StopCode solutions
*	but they do not have a SBucket or GBucket.  This uses the OLEDB template located in CReportGetHelpInfo.h
*	and the stored procedure ReportGetHelpInfo
*************************************************************************************/

STDMETHODIMP CCountDaily::GetStopCodeSolutions(DATE dDate, LONG* iCount)
{
	CReportGetHelpInfo pRep;
	COleDateTime pDate(dDate);
	long lCount = 0;

	pRep.m_dDate.year = pDate.GetYear();
	pRep.m_dDate.day = pDate.GetDay();
	pRep.m_dDate.month = pDate.GetMonth();
	pRep.m_dDate.hour = 0;
	pRep.m_dDate.minute = 0;
	pRep.m_dDate.second = 0;
	pRep.m_dDate.fraction = 0;

	CComPtr<ICommand> cm = pRep.m_spCommand;
	HACCESSOR ac = pRep.m_hParameterAccessor;
	
	
	
	
	HRESULT hr = pRep.OpenAll();
	_ASSERTE(SUCCEEDED(hr));
	if(SUCCEEDED(hr)==false)
	{
		return E_FAIL;
	}
	hr = S_OK;
	
	hr = pRep.MoveFirst();
	_ASSERTE(SUCCEEDED(hr));
	if(SUCCEEDED(hr)==false)
	{
		return E_FAIL;
	}
	lCount = pRep.m_iCount;
	
	*iCount = lCount;
	pRep.CloseAll();
	


	return S_OK;
}

/*************************************************************************************
*	module: CountDaily.cpp
*
*	author: Tim Ragain
*	date: Jan 2, 2002
*
*	Purpose: to count the files on the Watson or Archive server that contain "Mini" in the file name.  
*	This is a physical count of the actual files on the servers that were manually uploaded.
*	
*************************************************************************************/

STDMETHODIMP CCountDaily::GetFileMiniCount(ServerLocation eServer, BSTR b_Location, DATE d_Date, LONG* iCount)
{
	HANDLE hSearch=NULL;
	WIN32_FIND_DATA FileData; 
	LONG l_FileCount = 0;
	CComBSTR b_Path, b_DateDirectory;
	COleDateTime pDate(d_Date);
	LONG l_Day = 0, l_Year = 0, l_Month = 0;
	char * s_Temp;
	//LPCSTR szFindFiles;
	TCHAR * szFindFiles = new TCHAR[MAX_PATH];
	USES_CONVERSION;

	s_Temp = new char;

	b_Path.AppendBSTR(b_Location);

	l_Day = pDate.GetDay();
	l_Year = pDate.GetYear();
	l_Month = pDate.GetMonth();
	//month
	_itoa(l_Month, s_Temp, 10);
	b_DateDirectory.Append(s_Temp);
	if(eServer==0)
	{
		b_DateDirectory.Append(cScore);
	}
	else
	{
		b_DateDirectory.Append(cDash);
	}
	//Day
	_itoa(l_Day, s_Temp, 10);
	b_DateDirectory.Append(s_Temp);
	if(eServer==0)
	{
		b_DateDirectory.Append(cScore);
	}
	else
	{
		b_DateDirectory.Append(cDash);
	}
	//Year
	_itoa(l_Year, s_Temp, 10);
	b_DateDirectory.Append(s_Temp);

	b_Path.AppendBSTR(b_DateDirectory);
	b_Path.Append("\\");
	b_Path.Append("*Mini.cab");

	szFindFiles = OLE2T(b_Path);
	
	

	hSearch = FindFirstFile(szFindFiles, &FileData); 
	if (hSearch == INVALID_HANDLE_VALUE) 
	{ 
		*iCount = 0;
		return S_OK;
	} 
	l_FileCount = 0;
	do
	{
		l_FileCount++;
	} while(FindNextFile(hSearch, &FileData));
	*iCount = l_FileCount;
	FindClose(hSearch);


	return S_OK;
}

/*************************************************************************************
*	module: CountDaily.cpp
*
*	author: Tim Ragain
*	date: Jan 23, 2002
*
*	Purpose: Routine return the count for auto uploads by checking where null is in the path
*	set in the database.  Null indicates a failed upload.  The routine calls CReportGetIncompleteUploads.h 
*	OLEDB template, which uses the ReportGetIncompleteUploads stored procedure.
*************************************************************************************/

STDMETHODIMP CCountDaily::GetIncompleteUploads(DATE dDate, LONG* iCount)
{
	CReportGetIncompleteUploads pRep;
	
	COleDateTime pDate(dDate);
	long lCount = 0;

	pRep.m_ReportDate.year = pDate.GetYear();
	pRep.m_ReportDate.day = pDate.GetDay();
	pRep.m_ReportDate.month = pDate.GetMonth();
	pRep.m_ReportDate.hour = 0;
	pRep.m_ReportDate.minute = 0;
	pRep.m_ReportDate.second = 0;
	pRep.m_ReportDate.fraction = 0;
	
	HRESULT hr = pRep.OpenAll();
	_ASSERTE(SUCCEEDED(hr));
	if(SUCCEEDED(hr)==false)
	{
		return E_FAIL;
	}
	hr = S_OK;
	hr = pRep.MoveFirst();
	_ASSERTE(SUCCEEDED(hr));
	if(SUCCEEDED(hr)==false)
	{
		return E_FAIL;
	}
	lCount = pRep.m_Count;
	*iCount = lCount;
	pRep.CloseAll();

	return S_OK;
}

/*************************************************************************************
*	module: CountDaily.cpp
*
*	author: Tim Ragain
*	date: Jan 23, 2002
*
*	Purpose: Routine return the count for auto uploads by checking where "Mini" is in the path
*	set in the database.  Mini indicates a manual upload.  The routine calls CReportGetManualUploads.h 
*	OLEDB template, which uses the ReportGetManualUploads stored procedure.
*************************************************************************************/

STDMETHODIMP CCountDaily::GetManualUploads(DATE dDate, LONG* iCount)
{
	CReportGetManualUploads pRep;
	
	COleDateTime pDate(dDate);
	long lCount = 0;

	pRep.m_ReportDate.year = pDate.GetYear();
	pRep.m_ReportDate.day = pDate.GetDay();
	pRep.m_ReportDate.month = pDate.GetMonth();
	pRep.m_ReportDate.hour = 0;
	pRep.m_ReportDate.minute = 0;
	pRep.m_ReportDate.second = 0;
	pRep.m_ReportDate.fraction = 0;
	
	HRESULT hr = pRep.OpenAll();
	_ASSERTE(SUCCEEDED(hr));
	if(SUCCEEDED(hr)==false)
	{
		return E_FAIL;
	}
	hr = S_OK;
	hr = pRep.MoveFirst();
	_ASSERTE(SUCCEEDED(hr));
	if(SUCCEEDED(hr)==false)
	{
		return E_FAIL;
	}
	lCount = pRep.m_Count;
	*iCount = lCount;
	pRep.CloseAll();

	return S_OK;
}

/*************************************************************************************
*	module: CountDaily.cpp
*
*	author: Tim Ragain
*	date: Jan 23, 2002
*
*	Purpose: Routine return the count for auto uploads by checking where "Mini" is not in the path
*	set in the database.  Mini indicates a manual upload.  The routine calls CReportGetAutoUploads.h 
*	OLEDB template, which uses the ReportGetAutoUploads stored procedure.
*************************************************************************************/

STDMETHODIMP CCountDaily::GetAutoUploads(DATE dDate, LONG* iCount)
{
	CReportGetAutoUploads pRep;

	COleDateTime pDate(dDate);
	long lCount = 0;

	pRep.m_ReportDate.year = pDate.GetYear();
	pRep.m_ReportDate.day = pDate.GetDay();
	pRep.m_ReportDate.month = pDate.GetMonth();
	pRep.m_ReportDate.hour = 0;
	pRep.m_ReportDate.minute = 0;
	pRep.m_ReportDate.second = 0;
	pRep.m_ReportDate.fraction = 0;
	
	HRESULT hr = pRep.OpenAll();
	_ASSERTE(SUCCEEDED(hr));
	if(SUCCEEDED(hr)==false)
	{
		return E_FAIL;
	}
	hr = S_OK;
	hr = pRep.MoveFirst();
	_ASSERTE(SUCCEEDED(hr));
	if(SUCCEEDED(hr)==false)
	{
		return E_FAIL;
	}
	
	lCount = pRep.m_Count;
	*iCount = lCount;
	pRep.CloseAll();


	return S_OK;
}

		//ICreateErrorInfo * err;
		//HRESULT HRerr;

		//HRerr = CreateErrorInfo(&err);


		//MessageBox(NULL, "Failed to open database!", "Database Error", MB_OK);
		//if(SUCCEEDED(HRerr))
		//{
		//	err->SetDescription(L"Failed to open the database");
		//	IErrorInfo *pEI;
		//	HR2 = err->QueryInterface(IID_IErrorInfo, (void**)&pEI);
		//	if(SUCCEEDED(HR2))
		//	{
		//		SetErrorInfo(0, pEI);
		//		err->Release();
		//	}
		//	pEI->Release();
		//}
	/*
		char * sDate = new char;

		int iDate = oDate.GetDay();
		itoa(iDate, sDate, 10);

		MessageBox(NULL, sDate, "Year", MB_OK);
		return S_OK;
		delete(sDate);
			//memset(szFindFiles, 0, sizeof(szFindFiles));
				//TCHAR * t_Temp;
	//t_Temp = (TCHAR *)b_Location;


	*/

STDMETHODIMP CCountDaily::GetTest(ServerLocation eServer, BSTR b_Location, DATE d_Date, LONG* iCount)
{
	HANDLE hSearch=NULL;
	WIN32_FIND_DATA FileData; 
	LONG l_FileCount = 0;
	CComBSTR b_Path, b_DateDirectory;
	COleDateTime pDate(d_Date);
	LONG l_Day = 0, l_Year = 0, l_Month = 0;
	char * s_Temp;
	//LPCSTR szFindFiles;
	TCHAR * szFindFiles;
	USES_CONVERSION;

	s_Temp = new char;

	b_Path.AppendBSTR(b_Location);

	l_Day = pDate.GetDay();
	l_Year = pDate.GetYear();
	l_Month = pDate.GetMonth();
	//month
	_itoa(l_Month, s_Temp, 10);
	b_DateDirectory.Append(s_Temp);
	if(eServer==0)
	{
		b_DateDirectory.Append(cScore);
	}
	else
	{
		b_DateDirectory.Append(cDash);
	}
	//Day
	_itoa(l_Day, s_Temp, 10);
	b_DateDirectory.Append(s_Temp);
	if(eServer==0)
	{
		b_DateDirectory.Append(cScore);
	}
	else
	{
		b_DateDirectory.Append(cDash);
	}
	//Year
	_itoa(l_Year, s_Temp, 10);
	b_DateDirectory.Append(s_Temp);

	b_Path.AppendBSTR(b_DateDirectory);
	b_Path.Append("\\\\");
	b_Path.Append("*.cab");

	szFindFiles = OLE2T(b_Path);
	

	hSearch = FindFirstFile(szFindFiles, &FileData); 
	if (hSearch == INVALID_HANDLE_VALUE) 
	{ 
		l_FileCount = 0;
		*iCount = l_FileCount;
		return S_OK;
	} 
	l_FileCount = 0;
	do
	{
		l_FileCount++;
	} while(FindNextFile(hSearch, &FileData));
	*iCount = l_FileCount;
	FindClose(hSearch);

	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\msmqmon\testapp.cpp ===
#include "MSMQMon.h"


int __cdecl main( int argc, TCHAR *argv[])
{
	//TCHAR szConnectString[] = _T("TKBGITWB16\\PRIVATE$\\OCAIN");
	TCHAR szConnectString[] = _T("SOLSON22\\PRIVATE$\\TEST");
	int count;
	HRESULT hResult;

	MSMQMon Test( szConnectString );

	TCHAR Queue[256];

	Test.DisplayCurrentQueue( Queue );
	
	hResult = Test.ConnectToQueue();

	if( S_OK == hResult || MQ_OK == hResult )
	{
		_tprintf( _T("running count\n"));
	
		hResult = Test.CountMessagesInQueue( &count );

		if( MQ_OK == hResult )
			_tprintf( _T("Count of messages: %i\n"), count );
	
		if( Test.CloseOpenQueue() != MQ_OK )
			_tprintf( _T("it failed to close the queue\n"));
	}
	else
	{
		printf("FAILED - Great error message eh?: %x", hResult );
	}



	Test.ConnectToQueue( MQ_SEND_ACCESS );
	for( int i=0 ; i < 200000 ; i++ )
	{
		if( !Test.SendQueueMessage() )
		{
			_tprintf( _T("Failed to send message\n"));
		}
	}



	if( Test.CloseOpenQueue() != MQ_OK )
		_tprintf( _T("it failed to close the queue\n"));


	//Test.ConnectToQueue( MQ_PEEK_ACCESS );
	//_tprintf( _T("running count\n"));
	//Test.CountMessagesInQueue();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\countdaily.h ===
// CountDaily.h : Declaration of the CCountDaily
[export]
enum ServerLocation
{
	Watson, 
	Archive,
}; 

#pragma once
#include "resource.h"       // main symbols



// ICountDaily
[
	object,
	uuid("CEF1A8A8-F31A-4C4B-96EB-EF31CFDB40F5"),
	dual,	helpstring("ICountDaily Interface"),
	pointer_default(unique)
]

__interface ICountDaily : IDispatch
{
	[id(1), helpstring("method GetDailyCount")] HRESULT GetDailyCount([in] DATE dDate, [out,retval] LONG* iCount);
	[id(2), helpstring("method GetDailyCountADO")] HRESULT GetDailyCountADO([in] DATE dDate, [out,retval] LONG* iCount);
	[id(3), helpstring("method ReportDailyBuckets")] HRESULT ReportDailyBuckets([in] DATE dDate, [out,retval] IDispatch** p_Rs);
	[id(4), helpstring("method GetFileCount")] HRESULT GetFileCount([in] ServerLocation eServer, [in] BSTR b_Location, [in] DATE d_Date, [out,retval] LONG* iCount);
	[id(5), helpstring("method GetDailyAnon")] HRESULT GetDailyAnon([in] DATE dDate, [out,retval] LONG* iCount);
	[id(6), helpstring("method GetSpecificSolutions")] HRESULT GetSpecificSolutions([in] DATE dDate, [out,retval] LONG* iCount);
	[id(7), helpstring("method GetGeneralSolutions")] HRESULT GetGeneralSolutions([in] DATE dDate, [out,retval] LONG* iCount);
	[id(8), helpstring("method GetStopCodeSolutions")] HRESULT GetStopCodeSolutions([in] DATE dDate, [out,retval] LONG* iCount);
	[id(9), helpstring("method GetFileMiniCount")] HRESULT GetFileMiniCount([in] ServerLocation eServer, [in] BSTR b_Location, [in] DATE d_Date, [out,retval] LONG* iCount);
	[id(10), helpstring("method GetIncompleteUploads")] HRESULT GetIncompleteUploads([in] DATE dDate, [out,retval] LONG* iCount);
	[id(11), helpstring("method GetManualUploads")] HRESULT GetManualUploads([in] DATE dDate, [out,retval] LONG* iCount);
	[id(12), helpstring("method GetAutoUploads")] HRESULT GetAutoUploads([in] DATE dDate, [out,retval] LONG* iCount);
	[id(13), helpstring("method GetTest")] HRESULT GetTest([in] ServerLocation eServer, [in] BSTR b_Location, [in] DATE d_Date, [out,retval] LONG* iCount);
};



// CCountDaily

[
	coclass,
	threading("apartment"),
	vi_progid("OCAData.CountDaily"),
	progid("OCAData.CountDaily.1"),
	version(1.0),
	uuid("1614E060-0196-4771-AD9B-FEA1A6778B59"),
	helpstring("CountDaily Class")
]

class ATL_NO_VTABLE CCountDaily : 
	public ICountDaily
{
public:
	CCountDaily()
	{
	}

 
	DECLARE_PROTECT_FINAL_CONSTRUCT()

	HRESULT FinalConstruct()
	{
		return S_OK;
	}
	
	void FinalRelease() 
	{
	}

public:

	STDMETHOD(GetDailyCount)(DATE dDate, LONG* iCount);
	STDMETHOD(GetDailyCountADO)(DATE dDate, LONG* iCount);
	STDMETHOD(ReportDailyBuckets)(DATE dDate, IDispatch** p_Rs);
	STDMETHOD(GetFileCount)(ServerLocation eServer, BSTR b_Location, DATE d_Date, LONG* iCount);
	STDMETHOD(GetDailyAnon)(DATE dDate, LONG* iCount);
	STDMETHOD(GetSpecificSolutions)(DATE dDate, LONG* iCount);
	STDMETHOD(GetGeneralSolutions)(DATE dDate, LONG* iCount);
	STDMETHOD(GetStopCodeSolutions)(DATE dDate, LONG* iCount);
	STDMETHOD(GetFileMiniCount)(ServerLocation eServer, BSTR b_Location, DATE d_Date, LONG* iCount);
	STDMETHOD(GetIncompleteUploads)(DATE dDate, LONG* iCount);
	STDMETHOD(GetManualUploads)(DATE dDate, LONG* iCount);
	STDMETHOD(GetAutoUploads)(DATE dDate, LONG* iCount);
	STDMETHOD(GetTest)(ServerLocation eServer, BSTR b_Location, DATE d_Date, LONG* iCount);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\msmqmon\msmqmon.cpp ===
#include "msmqmon.h"

const int         NUMBEROFPROPERTIES = 5;

MSMQMon::MSMQMon()
{
	ZeroMemory( szQueueName, sizeof szQueueName );
	hOpenQueue = NULL;
	dwQueueAccessType = MQ_PEEK_ACCESS;			//default queue access type to peeking
	dwMsgWaitTime = 1;
}


MSMQMon::MSMQMon( TCHAR *szQueueToMonitor)
{

	ZeroMemory( szQueueName, sizeof szQueueName );
	hOpenQueue = NULL;
	dwMsgWaitTime = 1;
	dwQueueAccessType = MQ_PEEK_ACCESS;			//default queue access type to peeking

	StringCbCopy( szQueueName, sizeof szQueueName, szQueueToMonitor );

}

MSMQMon::~MSMQMon(void)
{
}

void MSMQMon::DisplayCurrentQueue( TCHAR *szUserVar ) 
{
	_tprintf( _T("Current queue: %s\n"), szQueueName );

}

void MSMQMon::SetMessageWaitTime( DWORD dwNewWaitTime )
{
	if ( 0 >= dwNewWaitTime )
		dwMsgWaitTime = dwNewWaitTime;
}






HRESULT MSMQMon::ConnectToQueue( DWORD constAccessType )
{
	dwQueueAccessType = constAccessType;
	return ( ConnectToQueue() );
}

HRESULT MSMQMon::ConnectToQueue( void )
{
	TCHAR		szConnectString[256];
	HRESULT		hResult = MQ_OK;	

	hResult = StringCbCopy( szConnectString, sizeof szConnectString, _T("DIRECT=OS:") );

	if ( SUCCEEDED( hResult ) )
	{
		hResult = StringCbCat ( szConnectString, sizeof szConnectString, szQueueName );

		if SUCCEEDED( hResult )
		{
			hResult = MQOpenQueue( (LPCWSTR)szConnectString, dwQueueAccessType, MQ_DENY_NONE, &hOpenQueue );
		}
	}

	return ( hResult );

}

HRESULT MSMQMon::CloseOpenQueue( void )
{
	return ( MQCloseQueue( hOpenQueue ) );
}

DWORD MSMQMon::CountMessagesInQueue( int *count ) 
{

	HRESULT			hResult;		//MSMQ function return results
	MQMSGPROPS		mqProperties;
	HANDLE			hQueueCursor;

	//initialize the structure with junk, we aren't reading messages, so it doesn't matter
	mqProperties.cProp = 0;
	mqProperties.aPropID = NULL;
	mqProperties.aStatus = NULL;
	mqProperties.aPropVar = NULL;

	*count = 0;
	hResult = MQCreateCursor( hOpenQueue, &hQueueCursor );

	if( MQ_OK != hResult )
		return hResult;

	hResult = MQReceiveMessage	(	hOpenQueue, 
									dwMsgWaitTime,						//amount of time to wait for a message (MS)
									MQ_ACTION_PEEK_CURRENT,
									&mqProperties,				
									NULL,						//overlapped structure
									NULL,						//callback
									hQueueCursor,				//cursor
									MQ_NO_TRANSACTION
								);

	if ( MQ_OK == hResult )
	{
		(*count)++;

		do
		{
			hResult = MQReceiveMessage(hOpenQueue,           
								dwMsgWaitTime,                         
								MQ_ACTION_PEEK_NEXT,       
								&mqProperties,             
								NULL,                      
								NULL,                      
								hQueueCursor,              
								MQ_NO_TRANSACTION          
								);
			if (FAILED(hResult))
			{
			break;
			}
			(*count)++;

		} while (SUCCEEDED(hResult));

		MQCloseCursor( hQueueCursor );

		return MQ_OK;
	}
	else
	{
		MQCloseCursor( hQueueCursor );
		return hResult;
	}
	

}



//This function was borrwed from the ISAPI dll, and modified slighly to fit here in this app.
//if you have a problem with this, then, go buy a bridge.
BOOL MSMQMon::SendQueueMessage( void )
{
    MQMSGPROPS      msgProps;
    MSGPROPID       aMsgPropId[NUMBEROFPROPERTIES];
    MQPROPVARIANT   aMsgPropVar[NUMBEROFPROPERTIES];
    HRESULT         aMsgStatus[NUMBEROFPROPERTIES];
    DWORD           cPropId = 0;
    BOOL            Status = TRUE;
    HRESULT         hResult = S_OK;
    char            szGuid[512];
    char            szPath[512];

	TCHAR			szMessageTitle[] = _T("This is a test message title");
	TCHAR			szMessageBody[] = _T("This is a test message body");


	aMsgPropId [cPropId]         = PROPID_M_LABEL;   // Property ID.
    aMsgPropVar[cPropId].vt      = VT_LPWSTR;        // Type indicator.
    aMsgPropVar[cPropId].pwszVal =  szMessageTitle;     // The message label.
    cPropId++;

    aMsgPropId [cPropId]         = PROPID_M_BODY;
    aMsgPropVar [cPropId].vt     = VT_VECTOR|VT_UI1;
    aMsgPropVar [cPropId].caub.pElems = (LPBYTE) szMessageBody;
    aMsgPropVar [cPropId].caub.cElems = (DWORD) sizeof szMessageBody;
    cPropId++;

    aMsgPropId [cPropId]         = PROPID_M_BODY_TYPE;
    aMsgPropVar[cPropId].vt      = VT_UI4;
    aMsgPropVar[cPropId].ulVal   = (DWORD) VT_BSTR;

    cPropId++;

    // Initialize the MQMSGPROPS structure.
    msgProps.cProp      = cPropId;
    msgProps.aPropID    = aMsgPropId;
    msgProps.aPropVar   = aMsgPropVar;
    msgProps.aStatus    = aMsgStatus;

    //
    // Send it
    //
    hResult = MQSendMessage(
                        hOpenQueue,                  // Queue handle.
                        &msgProps,                       // Message property structure.
                        MQ_NO_TRANSACTION                // No transaction.
                        );

    if (FAILED(hResult))
    {
		Status = FALSE;
    }

    return Status;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\dlldata.c ===
/*********************************************************
   DllData file -- generated by MIDL compiler 

        DO NOT ALTER THIS FILE

   This file is regenerated by MIDL on every IDL file compile.

   To completely reconstruct this file, delete it and rerun MIDL
   on all the IDL files in this DLL, specifying this file for the
   /dlldata command line option

*********************************************************/

#define PROXY_DELEGATION

#include <rpcproxy.h>

#ifdef __cplusplus
extern "C"   {
#endif

EXTERN_PROXY_FILE( _OCAData )


PROXYFILE_LIST_START
/* Start of list */
  REFERENCE_PROXY_FILE( _OCAData ),
/* End of list */
PROXYFILE_LIST_END


DLLDATA_ROUTINES( aProxyFileList, GET_DLL_CLSID )

#ifdef __cplusplus
}  /*extern "C" */
#endif

/* end of generated dlldata file */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\getresources.cpp ===
// GetResources.cpp : Implementation of CGetResources

#include "stdafx.h"
#include "GetResources.h"
#include "GetResourceLink.h"
#include "windows.h"
// CGetResources


STDMETHODIMP CGetResources::GetAllResources(BSTR bstLang, IDispatch** oRS)
{
	// TODO: Add your implementation code here
	CGetResourceLink ogrl;
	TCHAR strLang[5];
	CComBSTR strTemp;

	strTemp = bstLang;
	//strLang = (TCHAR *)strTemp;
	lstrcpyn(strLang, OLE2T(strTemp),4);



	ogrl.m_Lang = strLang;
	ogrl.OpenAll();
	MessageBox(NULL, "Test", "Test", MB_OK);
	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\getresourcelink.h ===
// GetResourceLink.h : Declaration of the CGetResourceLink

#pragma once

// code generated on Tuesday, November 13, 2001, 3:07 PM

[
	db_source(L"Provider=SQLOLEDB.1;Integrated Security=SSPI;Persist Security Info=False;Initial Catalog=KaCustomer;Data Source=bsod_db1;Use Procedure for Prepare=1;Auto Translate=True;Packet Size=4096;Workstation ID=TIMRAGAI03;Use Encryption for Data=False;Tag with column collation when possible=False"),
	db_command(L"{ ? = CALL dbo.GetResourceLink(?) }")
]
class CGetResourceLink
{
public:

	// In order to fix several issues with some providers, the code below may bind
	// columns in a different order than reported by the provider

	[ db_column(1, status=m_dwCategoryStatus, length=m_dwCategoryLength) ] TCHAR m_Category[65];
	[ db_column(2, status=m_dwLinkTitleStatus, length=m_dwLinkTitleLength) ] TCHAR m_LinkTitle[129];
	[ db_column(3, status=m_dwURLStatus, length=m_dwURLLength) ] TCHAR m_URL[129];

	// The following wizard-generated data members contain status
	// values for the corresponding fields. You
	// can use these values to hold NULL values that the database
	// returns or to hold error information when the compiler returns
	// errors. See Field Status Data Members in Wizard-Generated
	// Accessors in the Visual C++ documentation for more information
	// on using these fields.
	// NOTE: You must initialize these fields before setting/inserting data!

	DBSTATUS m_dwCategoryStatus;
	DBSTATUS m_dwLinkTitleStatus;
	DBSTATUS m_dwURLStatus;

	// The following wizard-generated data members contain length
	// values for the corresponding fields.
	// NOTE: For variable-length columns, you must initialize these
	//       fields before setting/inserting data!

	DBLENGTH m_dwCategoryLength;
	DBLENGTH m_dwLinkTitleLength;
	DBLENGTH m_dwURLLength;

	[ db_param(1, DBPARAMIO_OUTPUT) ] LONG m_RETURN_VALUE;
	[ db_param(2, DBPARAMIO_INPUT) ] TCHAR m_Lang[5];

	void GetRowsetProperties(CDBPropSet* pPropSet)
	{
		pPropSet->AddProperty(DBPROP_CANFETCHBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
		pPropSet->AddProperty(DBPROP_CANSCROLLBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\ocadata.cpp ===
// OCAData.cpp : Implementation of DLL Exports.

#include "stdafx.h"
#include "resource.h"

// The module attribute causes DllMain, DllRegisterServer and DllUnregisterServer to be automatically implemented for you
[ module(dll, uuid = "{D264DB42-7095-489E-B84D-404CBB3FF668}", 
		 name = "OCAData", 
		 helpstring = "OCAData 1.0 Type Library",
		 resource_name = "IDR_OCADATA") ];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\reportcountdaily.h ===
// ReportCountDaily.h : Declaration of the CReportCountDaily
/*************************************************************************************
*	module: ReportCountDaily.h - OLEDB Template
*
*	author: Tim Ragain
*	date: Jan 2, 2002
*
*	Purpose: to return the incident count for a specific date by calling the 
*	stored procedure ReportCountDaily.
*	
*************************************************************************************/
#pragma once

// code generated on Thursday, December 27, 2001, 12:25 PM
//Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=TIMRAGAIN04\\TIMRAGAIN04

#include "Settings.h"

[
#if(lDatabase == 0)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=ocarp;User ID=ocarp;Initial Catalog=KaCustomer2;Data Source=OCATOOLSDB"),
#elif(lDatabase == 1)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=TIMRAGAIN04\\TIMRAGAIN04"),
#elif(lDatabase == 2)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=TIMRAGAIN05"),
#elif(lDatabase == 3)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=Homebase"),
#elif(lDatabase == 4)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=KaCustomer2;Data Source=tkwucdsqla02"),
#endif
	db_command(L"{ ? = CALL dbo.ReportCountDaily(?) }")
]

class CReportCountDaily
{
public:


	[ db_column(1, status=m_dwIncidentIDStatus, length=m_dwIncidentIDLength) ] LONG m_IncidentID;

	DBSTATUS m_dwIncidentIDStatus;
	DBLENGTH m_dwIncidentIDLength;

	[ db_param(1, DBPARAMIO_OUTPUT) ] LONG m_RETURN_VALUE;
	[ db_param(2, DBPARAMIO_INPUT) ] DBTIMESTAMP m_ReportDate;

	void GetRowsetProperties(CDBPropSet* pPropSet)
	{
		VARIANT vCT;
		vCT.lVal = 600;
		pPropSet->AddProperty(DBPROP_CANFETCHBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
		pPropSet->AddProperty(DBPROP_CANSCROLLBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
		pPropSet->AddProperty(DBPROP_COMMANDTIMEOUT, vCT);
	}
};

// code generated on Thursday, December 27, 2001, 12:25 PM
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\getresources.h ===
// GetResources.h : Declaration of the CGetResources

#pragma once
#include "resource.h"       // main symbols


// IGetResources
[
	object,
	uuid("31C8E3CB-F4CF-42C1-BC8C-3CF259127BBD"),
	dual,	helpstring("IGetResources Interface"),
	pointer_default(unique)
]
__interface IGetResources : IDispatch
{
	[id(1), helpstring("method GetAllResources")] HRESULT GetAllResources([in] BSTR bstLang, [out,retval] IDispatch** oRS);
};



// CGetResources

[
	coclass,
	threading("apartment"),
	vi_progid("OcaData.GetResources"),
	progid("OcaData.GetResources.1"),
	version(1.0),
	uuid("A88C1857-5B4A-44C0-B256-1F33A38B0B5F"),
	helpstring("GetResources Class")
]
class ATL_NO_VTABLE CGetResources : 
	public IGetResources
{
public:
	CGetResources()
	{
	}


	DECLARE_PROTECT_FINAL_CONSTRUCT()

	HRESULT FinalConstruct()
	{
		return S_OK;
	}
	
	void FinalRelease() 
	{
	}

public:

	STDMETHOD(GetAllResources)(BSTR bstLang, IDispatch** oRS);
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\reportdailybuckets.h ===
// ReportDailyBuckets.h : Declaration of the CReportCountDaily
/*************************************************************************************
*	module: ReportDailyBuckets.h - OLEDB Template
*
*	author: Tim Ragain
*	date: Jan 2, 2002
*
*	Purpose: To get the sBucket, gBucket & StopCode information from the database
*	for a specific date by calling the ReportDailyBuckets stored procedure.
*	
*************************************************************************************/
#pragma once


#include "Settings.h"

[
#if(lDatabase == 0)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=ocarp;User ID=ocarp;Initial Catalog=KaCustomer2;Data Source=OCATOOLSDB"),
#elif(lDatabase == 1)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=TIMRAGAIN04\\TIMRAGAIN04"),
#elif(lDatabase == 2)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=TIMRAGAIN05"),
#elif(lDatabase == 3)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=Homebase"),
#elif(lDatabase == 4)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=KaCustomer2;Data Source=tkwucdsqla02"),
#endif
	db_command(L"{ ? = CALL dbo.ReportDailyBuckets(?) }")
]

class CReportDailyBuckets
{
public:

	// In order to fix several issues with some providers, the code below may bind
	// columns in a different order than reported by the provider

	//[ db_column(1, status=m_dwIncidentIDStatus, length=m_dwIncidentIDLength) ] LONG m_IncidentID;
	//[ db_column(2, status=m_dwCreatedStatus, length=m_dwCreatedLength) ] DBTIMESTAMP m_Created;

	[ db_column(1, status=m_dwSbucketStatus, length=m_dwSbucketLength) ] LONG m_Sbucket;
	[ db_column(2, status=m_dwGbucketStatus, length=m_dwGbucketLength) ] LONG m_Gbucket;
	[ db_column(3, status=m_dwStopCodeStatus, length=m_dwStopCodeLength) ] LONG m_StopCode;
	// The following wizard-generated data members contain status
	// values for the corresponding fields. You
	// can use these values to hold NULL values that the database
	// returns or to hold error information when the compiler returns
	// errors. See Field Status Data Members in Wizard-Generated
	// Accessors in the Visual C++ documentation for more information
	// on using these fields.
	// NOTE: You must initialize these fields before setting/inserting data!

	DBSTATUS m_dwSbucketStatus;
	DBSTATUS m_dwGbucketStatus;
	DBSTATUS m_dwStopCodeStatus;
	//DBSTATUS m_dwCreatedStatus;

	// The following wizard-generated data members contain length
	// values for the corresponding fields.
	// NOTE: For variable-length columns, you must initialize these
	//       fields before setting/inserting data!

	DBLENGTH m_dwSbucketLength;
	DBLENGTH m_dwGbucketLength;
	DBLENGTH m_dwStopCodeLength;

	//DBLENGTH m_dwCreatedLength;
	
	[ db_param(1, DBPARAMIO_OUTPUT) ] LONG m_RETURN_VALUE;
	[ db_param(2, DBPARAMIO_INPUT) ] DBTIMESTAMP m_ReportDate;

	/*[ db_accessor(0, TRUE) ];
	[ db_column(1) ] LONG m_Sbucket;
	[ db_column(2) ] LONG m_Gbucket;
	[ db_column(4) ] LONG m_StopCode;*/

	void GetRowsetProperties(CDBPropSet* pPropSet)
	{
		VARIANT vCT;
		vCT.lVal = 600;
		pPropSet->AddProperty(DBPROP_CANFETCHBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
		pPropSet->AddProperty(DBPROP_CANSCROLLBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
		pPropSet->AddProperty(DBPROP_COMMANDTIMEOUT, vCT);
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\reportgetautouploads.h ===
// ReportGetAutoUploads.h : Declaration of the CReportAnonUsers
/*************************************************************************************
*	module: ReportGetAutoUploads.h - OLEDB Template
*
*	author: Tim Ragain
*	date: Jan 2, 2002
*
*	Purpose: To return the count for auto uploads for a specific date.  Uses stored 
*	procedure ReportGetAutoUploads
*	
*************************************************************************************/
#pragma once
#include "Settings.h"


[
#if(lDatabase == 0)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=ocarp;User ID=ocarp;Initial Catalog=KaCustomer2;Data Source=OCATOOLSDB"),
#elif(lDatabase == 1)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=TIMRAGAIN04\\TIMRAGAIN04"),
#elif(lDatabase == 2)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=TIMRAGAIN05"),
#elif(lDatabase == 3)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=Homebase"),
#elif(lDatabase == 4)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=KaCustomer2;Data Source=tkwucdsqla02"),
#endif
	db_command(L"{ ? = CALL dbo.ReportGetAutoUploads(?) }")
]

class CReportGetAutoUploads
{
public:

	[ db_column(1, status=m_dwCountStatus, length=m_dwCountLength) ] LONG m_Count;

	DBSTATUS m_dwCountStatus;

	DBLENGTH m_dwCountLength;

	[ db_param(1, DBPARAMIO_OUTPUT) ] LONG m_RETURN_VALUE;
	[ db_param(2, DBPARAMIO_INPUT) ] DBTIMESTAMP m_ReportDate;


	void GetRowsetProperties(CDBPropSet* pPropSet)
	{
		VARIANT vCT;
		vCT.lVal = 600;
		pPropSet->AddProperty(DBPROP_CANFETCHBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
		pPropSet->AddProperty(DBPROP_CANSCROLLBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
		pPropSet->AddProperty(DBPROP_COMMANDTIMEOUT, vCT);
	}

};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\reportanonusers.h ===
// ReportAnonUsers.h : Declaration of the CReportAnonUsers
/*************************************************************************************
*	module: ReportAnonUsers.h - OLEDB Template
*
*	author: Tim Ragain
*	date: Jan 2, 2002
*
*	Purpose: To Return the anonymous users for a specific date by calling strored  
*	procedure ReportGetAnonUsers.
*	
*************************************************************************************/
#pragma once
#include "Settings.h"


[
#if(lDatabase == 0)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=ocarp;User ID=ocarp;Initial Catalog=KaCustomer2;Data Source=OCATOOLSDB"),
#elif(lDatabase == 1)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=TIMRAGAIN04\\TIMRAGAIN04"),
#elif(lDatabase == 2)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=TIMRAGAIN05"),
#elif(lDatabase == 3)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=Homebase"),
#elif(lDatabase == 4)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=KaCustomer2;Data Source=tkwucdsqla02"),
#endif
	db_command(L"{ ? = CALL dbo.ReportGetAnonUsers(?) }")
]

class CReportAnonUsers
{
public:

	[ db_column(1, status=m_dwCountStatus, length=m_dwCountLength) ] LONG m_Count;

	DBSTATUS m_dwCountStatus;

	DBLENGTH m_dwCountLength;

	[ db_param(1, DBPARAMIO_OUTPUT) ] LONG m_RETURN_VALUE;
	[ db_param(2, DBPARAMIO_INPUT) ] DBTIMESTAMP m_ReportDate;


	void GetRowsetProperties(CDBPropSet* pPropSet)
	{
		VARIANT vCT;
		vCT.lVal = 600;
		pPropSet->AddProperty(DBPROP_CANFETCHBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
		pPropSet->AddProperty(DBPROP_CANSCROLLBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
		pPropSet->AddProperty(DBPROP_COMMANDTIMEOUT, vCT);

		
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\reportgethelpinfo.h ===
// ReportGetHelpInfo.h : Declaration of the CReportGetHelpInfo
/*************************************************************************************
*	module: ReportGetHelpInfo.h - OLEDB Template
*
*	author: Tim Ragain
*	date: Jan 2, 2002
*
*	Purpose: To return StopCodes for a specific date using stored procedure ReportGetHelpInfo.
*	
*	
*************************************************************************************/
#pragma once

// code generated on Monday, January 07, 2002, 2:49 PM
#include "Settings.h"



[
#if(lDatabase == 0)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=ocarp;User ID=ocarp;Initial Catalog=KaCustomer2;Data Source=OCATOOLSDB"),
#elif(lDatabase == 1)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=TIMRAGAIN04\\TIMRAGAIN04"),
#elif(lDatabase == 2)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=TIMRAGAIN05"),
#elif(lDatabase == 3)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=Homebase"),
#elif(lDatabase == 4)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=KaCustomer2;Data Source=tkwucdsqla02"),
#endif
	db_command(L"{ ? = CALL dbo.ReportGetHelpInfo(?) }")
]
class CReportGetHelpInfo
{
public:

	[ db_column(1, status=m_dwiCountStatus, length=m_dwiCountLength) ] LONG m_iCount;

	DBSTATUS m_dwiCountStatus;


	DBLENGTH m_dwiCountLength;

	[ db_param(1, DBPARAMIO_OUTPUT) ] LONG m_RETURN_VALUE;
	[ db_param(2, DBPARAMIO_INPUT) ] DBTIMESTAMP m_dDate;

	void GetRowsetProperties(CDBPropSet* pPropSet)
	{
		VARIANT vCT;
		vCT.lVal = 600;
		pPropSet->AddProperty(DBPROP_CANFETCHBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
		pPropSet->AddProperty(DBPROP_CANSCROLLBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
		pPropSet->AddProperty(DBPROP_COMMANDTIMEOUT, vCT);

	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\reportgeneralsolutions.h ===
// ReportGeneralSolutions.h : Declaration of the CReportAnonUsers
/*************************************************************************************
*	module: ReportGeneralSolutions.h - OLEDB Template
*
*	author: Tim Ragain
*	date: Jan 2, 2002
*
*	Purpose: to return the GBucket count for a specific date by calling ReportGetGBucket
*	stored procedure
*	
*************************************************************************************/
#pragma once
#include "Settings.h"

[
#if(lDatabase == 0)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=ocarp;User ID=ocarp;Initial Catalog=KaCustomer2;Data Source=OCATOOLSDB"),
#elif(lDatabase == 1)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=TIMRAGAIN04\\TIMRAGAIN04"),
#elif(lDatabase == 2)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=TIMRAGAIN05"),
#elif(lDatabase == 3)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=Homebase"),
#elif(lDatabase == 4)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=KaCustomer2;Data Source=tkwucdsqla02"),
#endif
	db_command(L"{ ? = CALL dbo.ReportGetGBucket(?) }")
]

class CReportGeneralSolutions
{
public:


	[ db_column(1, status=m_dwCountStatus, length=m_dwCountLength) ] LONG m_Count;

	DBSTATUS m_dwCountStatus;

	DBLENGTH m_dwCountLength;

	[ db_param(1, DBPARAMIO_OUTPUT) ] LONG m_RETURN_VALUE;
	[ db_param(2, DBPARAMIO_INPUT) ] DBTIMESTAMP m_ReportDate;

	void GetRowsetProperties(CDBPropSet* pPropSet)
	{
		VARIANT vCT;
		vCT.lVal = 600;
		pPropSet->AddProperty(DBPROP_CANFETCHBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
		pPropSet->AddProperty(DBPROP_CANSCROLLBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
		pPropSet->AddProperty(DBPROP_COMMANDTIMEOUT, vCT);
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\reporthelpinfosolutions.h ===
// ReportStopCodeSolutions.h : Declaration of the CReportStopCodeSolutions

#pragma once


[
	db_source(L"Provider=SQLOLEDB.1;Integrated Security=SSPI;Persist Security Info=False;Initial Catalog=KaCustomer;Data Source=TIMRAGAIN04\\TIMRAGAIN04;Use Procedure for Prepare=1;Auto Translate=True;Packet Size=4096;Workstation ID=TIMRAGAIN05;Use Encryption for Data=False;Tag with column collation when possible=False"),
	db_command(L"{ ? = CALL dbo.ReportGetHelpInfo(?) }")
]

class CReportHelpInfoSolutions
{
public:


	[ db_column(1, status=m_dwCountStatus, length=m_dwCountLength) ] LONG m_Count;

	DBSTATUS m_dwCountStatus;

	DBLENGTH m_dwCountLength;

	[ db_param(1, DBPARAMIO_OUTPUT) ] LONG m_RETURN_VALUE;
	[ db_param(2, DBPARAMIO_INPUT) ] DBTIMESTAMP m_ReportDate;

	void GetRowsetProperties(CDBPropSet* pPropSet)
	{
		pPropSet->AddProperty(DBPROP_CANFETCHBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
		pPropSet->AddProperty(DBPROP_CANSCROLLBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\reportgetmanualuploads.h ===
// ReportGetManualUploads.h : Declaration of the CReportAnonUsers
/*************************************************************************************
*	module: ReportGetManualUploads.h - OLEDB Template
*
*	author: Tim Ragain
*	date: Jan 2, 2002
*
*	Purpose: To return a count of manual uploads, which is indicated by having "Mini" in the path
*	field.  Uses the stored procedure ReportGetManualUploads.
*	
*************************************************************************************/
#pragma once
#include "Settings.h"


[
#if(lDatabase == 0)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=ocarp;User ID=ocarp;Initial Catalog=KaCustomer2;Data Source=OCATOOLSDB"),
#elif(lDatabase == 1)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=TIMRAGAIN04\\TIMRAGAIN04"),
#elif(lDatabase == 2)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=TIMRAGAIN05"),
#elif(lDatabase == 3)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=Homebase"),
#elif(lDatabase == 4)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=KaCustomer2;Data Source=tkwucdsqla02"),
#endif
	db_command(L"{ ? = CALL dbo.ReportGetManualUploads(?) }")
]

class CReportGetManualUploads
{
public:

	[ db_column(1, status=m_dwCountStatus, length=m_dwCountLength) ] LONG m_Count;

	DBSTATUS m_dwCountStatus;

	DBLENGTH m_dwCountLength;

	[ db_param(1, DBPARAMIO_OUTPUT) ] LONG m_RETURN_VALUE;
	[ db_param(2, DBPARAMIO_INPUT) ] DBTIMESTAMP m_ReportDate;


	void GetRowsetProperties(CDBPropSet* pPropSet)
	{
		VARIANT vCT;
		vCT.lVal = 600;
		pPropSet->AddProperty(DBPROP_CANFETCHBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
		pPropSet->AddProperty(DBPROP_CANSCROLLBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
		pPropSet->AddProperty(DBPROP_COMMANDTIMEOUT, vCT);
		
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\reportspecificsolutions.h ===
// ReportSpecificSolutions.h : Declaration of the CReportSpecificSolutions
/*************************************************************************************
*	module: ReportSpecificSolutions.h - OLEDB Template
*
*	author: Tim Ragain
*	date: Jan 2, 2002
*
*	Purpose: To count the SBucket or Specific solutions for as specific date.  Uses 
*	stored procedure ReportGetSBuckets
*	
*************************************************************************************/
#pragma once

#include "Settings.h"


[
#if(lDatabase == 0)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=ocarp;User ID=ocarp;Initial Catalog=KaCustomer2;Data Source=OCATOOLSDB"),
#elif(lDatabase == 1)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=TIMRAGAIN04\\TIMRAGAIN04"),
#elif(lDatabase == 2)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=TIMRAGAIN05"),
#elif(lDatabase == 3)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=Homebase"),
#elif(lDatabase == 4)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=KaCustomer2;Data Source=tkwucdsqla02"),
#endif
	db_command(L"{ ? = CALL dbo.ReportGetSBuckets(?) }")
]

class CReportSpecificSolutions
{
public:


	[ db_column(1, status=m_dwCountStatus, length=m_dwCountLength) ] LONG m_Count;

	DBSTATUS m_dwCountStatus;

	DBLENGTH m_dwCountLength;

	[ db_param(1, DBPARAMIO_OUTPUT) ] LONG m_RETURN_VALUE;
	[ db_param(2, DBPARAMIO_INPUT) ] DBTIMESTAMP m_ReportDate;

	void GetRowsetProperties(CDBPropSet* pPropSet)
	{
		VARIANT vCT;
		vCT.lVal = 600;
		pPropSet->AddProperty(DBPROP_CANFETCHBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
		pPropSet->AddProperty(DBPROP_CANSCROLLBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
		pPropSet->AddProperty(DBPROP_COMMANDTIMEOUT, vCT);
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\reportgetincompleteuploads.h ===
// ReportGetIncompleteUploads.h : Declaration of the CReportAnonUsers
/*************************************************************************************
*	module: ReportGetIncompleteUploads.h - OLEDB Template
*
*	author: Tim Ragain
*	date: Jan 2, 2002
*
*	Purpose: To look for nulls in the path field in the incident table to return 
*	a count for failed uploads using stored procedure ReportGetIncompleteUploads
*	
*************************************************************************************/
#pragma once
#include "Settings.h"


[
#if(lDatabase == 0)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=ocarp;User ID=ocarp;Initial Catalog=KaCustomer2;Data Source=OCATOOLSDB"),
#elif(lDatabase == 1)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=TIMRAGAIN04\\TIMRAGAIN04"),
#elif(lDatabase == 2)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=TIMRAGAIN05"),
#elif(lDatabase == 3)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=Tim5;User ID=Tim5;Initial Catalog=KaCustomer;Data Source=Homebase"),
#elif(lDatabase == 4)
	db_source(L"Provider=SQLOLEDB.1;Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=KaCustomer2;Data Source=tkwucdsqla02"),
#endif
	db_command(L"{ ? = CALL dbo.ReportGetIncompleteUploads(?) }")
]

class CReportGetIncompleteUploads
{
public:

	[ db_column(1, status=m_dwCountStatus, length=m_dwCountLength) ] LONG m_Count;

	DBSTATUS m_dwCountStatus;

	DBLENGTH m_dwCountLength;

	[ db_param(1, DBPARAMIO_OUTPUT) ] LONG m_RETURN_VALUE;
	[ db_param(2, DBPARAMIO_INPUT) ] DBTIMESTAMP m_ReportDate;


	void GetRowsetProperties(CDBPropSet* pPropSet)
	{
		VARIANT vCT;
		vCT.lVal = 600;
		pPropSet->AddProperty(DBPROP_CANFETCHBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
		pPropSet->AddProperty(DBPROP_CANSCROLLBACKWARDS, true, DBPROPOPTIONS_OPTIONAL);
		pPropSet->AddProperty(DBPROP_COMMANDTIMEOUT, vCT);

		
	}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by OCAData.rc
//
#define IDS_PROJNAME                    100
#define IDR_OCADATA                     101
#define IDS_NOTE100                     101
#define IDS_NOTE101                     102

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           102
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\settings.h ===
#define lDatabase 4
/*
	0 = OCAToolsdb
	1 = Timragain04
	2 = Timragain05
	3 = Homebase
	4 = TKWUCDSQLA02

*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
// OCAData.pch will be the pre-compiled header
// stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\stdafx.h ===
// stdafx.h : include file for standard system include files,
// or project specific include files that are used frequently,
// but are changed infrequently

#pragma once

#ifndef STRICT
#define STRICT
#endif

// Modify the following defines if you have to target a platform prior to the ones specified below.
// Refer to MSDN for the latest info on corresponding values for different platforms.
#ifndef WINVER				// Allow use of features specific to Windows 95 and Windows NT 4 or later.
#define WINVER 0x0400		// Change this to the appropriate value to target Windows 98 and Windows 2000 or later.
#endif

#ifndef _WIN32_WINNT		// Allow use of features specific to Windows NT 4 or later.
#define _WIN32_WINNT 0x0400	// Change this to the appropriate value to target Windows 2000 or later.
#endif						

#ifndef _WIN32_WINDOWS		// Allow use of features specific to Windows 98 or later.
#define _WIN32_WINDOWS 0x0410 // Change this to the appropriate value to target Windows Me or later.
#endif

#ifndef _WIN32_IE			// Allow use of features specific to IE 4.0 or later.
#define _WIN32_IE 0x0400	// Change this to the appropriate value to target IE 5.0 or later.
#endif

#define _ATL_APARTMENT_THREADED
#define _ATL_NO_AUTOMATIC_NAMESPACE

#define _ATL_CSTRING_EXPLICIT_CONSTRUCTORS	// some CString constructors will be explicit

// turns off ATL's hiding of some common and often safely ignored warning messages
#define _ATL_ALL_WARNINGS

#include <atlbase.h>
#include <atlcom.h>
#include <atlwin.h>
#include <atltypes.h>
#include <atlctl.h>
#include <atlhost.h>
#include <atldbcli.h>


using namespace ATL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\_ocadata.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon May 20 11:18:54 2002
 */
/* Compiler settings for _OCAData.idl:
    Os, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef ___OCAData_h__
#define ___OCAData_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ICountDaily_FWD_DEFINED__
#define __ICountDaily_FWD_DEFINED__
typedef interface ICountDaily ICountDaily;
#endif 	/* __ICountDaily_FWD_DEFINED__ */


#ifndef __CCountDaily_FWD_DEFINED__
#define __CCountDaily_FWD_DEFINED__

#ifdef __cplusplus
typedef class CCountDaily CCountDaily;
#else
typedef struct CCountDaily CCountDaily;
#endif /* __cplusplus */

#endif 	/* __CCountDaily_FWD_DEFINED__ */


/* header files for imported files */
#include "prsht.h"
#include "mshtml.h"
#include "mshtmhst.h"
#include "exdisp.h"
#include "objsafe.h"
#include "oledb.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf__OCAData_0000 */
/* [local] */ 


enum ServerLocation
    {	Watson	= 0,
	Archive	= 1
    } ;


extern RPC_IF_HANDLE __MIDL_itf__OCAData_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf__OCAData_0000_v0_0_s_ifspec;

#ifndef __ICountDaily_INTERFACE_DEFINED__
#define __ICountDaily_INTERFACE_DEFINED__

/* interface ICountDaily */
/* [unique][helpstring][dual][uuid][object] */ 


EXTERN_C const IID IID_ICountDaily;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CEF1A8A8-F31A-4C4B-96EB-EF31CFDB40F5")
    ICountDaily : public IDispatch
    {
    public:
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDailyCount( 
            /* [in] */ DATE dDate,
            /* [retval][out] */ LONG *iCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDailyCountADO( 
            /* [in] */ DATE dDate,
            /* [retval][out] */ LONG *iCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ReportDailyBuckets( 
            /* [in] */ DATE dDate,
            /* [retval][out] */ IDispatch **p_Rs) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFileCount( 
            /* [in] */ enum ServerLocation eServer,
            /* [in] */ BSTR b_Location,
            /* [in] */ DATE d_Date,
            /* [retval][out] */ LONG *iCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetDailyAnon( 
            /* [in] */ DATE dDate,
            /* [retval][out] */ LONG *iCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetSpecificSolutions( 
            /* [in] */ DATE dDate,
            /* [retval][out] */ LONG *iCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetGeneralSolutions( 
            /* [in] */ DATE dDate,
            /* [retval][out] */ LONG *iCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetStopCodeSolutions( 
            /* [in] */ DATE dDate,
            /* [retval][out] */ LONG *iCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetFileMiniCount( 
            /* [in] */ enum ServerLocation eServer,
            /* [in] */ BSTR b_Location,
            /* [in] */ DATE d_Date,
            /* [retval][out] */ LONG *iCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetIncompleteUploads( 
            /* [in] */ DATE dDate,
            /* [retval][out] */ LONG *iCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetManualUploads( 
            /* [in] */ DATE dDate,
            /* [retval][out] */ LONG *iCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetAutoUploads( 
            /* [in] */ DATE dDate,
            /* [retval][out] */ LONG *iCount) = 0;
        
        virtual /* [helpstring][id] */ HRESULT STDMETHODCALLTYPE GetTest( 
            /* [in] */ enum ServerLocation eServer,
            /* [in] */ BSTR b_Location,
            /* [in] */ DATE d_Date,
            /* [retval][out] */ LONG *iCount) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ICountDailyVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ICountDaily * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ICountDaily * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ICountDaily * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfoCount )( 
            ICountDaily * This,
            /* [out] */ UINT *pctinfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetTypeInfo )( 
            ICountDaily * This,
            /* [in] */ UINT iTInfo,
            /* [in] */ LCID lcid,
            /* [out] */ ITypeInfo **ppTInfo);
        
        HRESULT ( STDMETHODCALLTYPE *GetIDsOfNames )( 
            ICountDaily * This,
            /* [in] */ REFIID riid,
            /* [size_is][in] */ LPOLESTR *rgszNames,
            /* [in] */ UINT cNames,
            /* [in] */ LCID lcid,
            /* [size_is][out] */ DISPID *rgDispId);
        
        /* [local] */ HRESULT ( STDMETHODCALLTYPE *Invoke )( 
            ICountDaily * This,
            /* [in] */ DISPID dispIdMember,
            /* [in] */ REFIID riid,
            /* [in] */ LCID lcid,
            /* [in] */ WORD wFlags,
            /* [out][in] */ DISPPARAMS *pDispParams,
            /* [out] */ VARIANT *pVarResult,
            /* [out] */ EXCEPINFO *pExcepInfo,
            /* [out] */ UINT *puArgErr);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDailyCount )( 
            ICountDaily * This,
            /* [in] */ DATE dDate,
            /* [retval][out] */ LONG *iCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDailyCountADO )( 
            ICountDaily * This,
            /* [in] */ DATE dDate,
            /* [retval][out] */ LONG *iCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *ReportDailyBuckets )( 
            ICountDaily * This,
            /* [in] */ DATE dDate,
            /* [retval][out] */ IDispatch **p_Rs);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetFileCount )( 
            ICountDaily * This,
            /* [in] */ enum ServerLocation eServer,
            /* [in] */ BSTR b_Location,
            /* [in] */ DATE d_Date,
            /* [retval][out] */ LONG *iCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetDailyAnon )( 
            ICountDaily * This,
            /* [in] */ DATE dDate,
            /* [retval][out] */ LONG *iCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetSpecificSolutions )( 
            ICountDaily * This,
            /* [in] */ DATE dDate,
            /* [retval][out] */ LONG *iCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetGeneralSolutions )( 
            ICountDaily * This,
            /* [in] */ DATE dDate,
            /* [retval][out] */ LONG *iCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetStopCodeSolutions )( 
            ICountDaily * This,
            /* [in] */ DATE dDate,
            /* [retval][out] */ LONG *iCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetFileMiniCount )( 
            ICountDaily * This,
            /* [in] */ enum ServerLocation eServer,
            /* [in] */ BSTR b_Location,
            /* [in] */ DATE d_Date,
            /* [retval][out] */ LONG *iCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetIncompleteUploads )( 
            ICountDaily * This,
            /* [in] */ DATE dDate,
            /* [retval][out] */ LONG *iCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetManualUploads )( 
            ICountDaily * This,
            /* [in] */ DATE dDate,
            /* [retval][out] */ LONG *iCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetAutoUploads )( 
            ICountDaily * This,
            /* [in] */ DATE dDate,
            /* [retval][out] */ LONG *iCount);
        
        /* [helpstring][id] */ HRESULT ( STDMETHODCALLTYPE *GetTest )( 
            ICountDaily * This,
            /* [in] */ enum ServerLocation eServer,
            /* [in] */ BSTR b_Location,
            /* [in] */ DATE d_Date,
            /* [retval][out] */ LONG *iCount);
        
        END_INTERFACE
    } ICountDailyVtbl;

    interface ICountDaily
    {
        CONST_VTBL struct ICountDailyVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ICountDaily_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ICountDaily_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ICountDaily_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ICountDaily_GetTypeInfoCount(This,pctinfo)	\
    (This)->lpVtbl -> GetTypeInfoCount(This,pctinfo)

#define ICountDaily_GetTypeInfo(This,iTInfo,lcid,ppTInfo)	\
    (This)->lpVtbl -> GetTypeInfo(This,iTInfo,lcid,ppTInfo)

#define ICountDaily_GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)	\
    (This)->lpVtbl -> GetIDsOfNames(This,riid,rgszNames,cNames,lcid,rgDispId)

#define ICountDaily_Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)	\
    (This)->lpVtbl -> Invoke(This,dispIdMember,riid,lcid,wFlags,pDispParams,pVarResult,pExcepInfo,puArgErr)


#define ICountDaily_GetDailyCount(This,dDate,iCount)	\
    (This)->lpVtbl -> GetDailyCount(This,dDate,iCount)

#define ICountDaily_GetDailyCountADO(This,dDate,iCount)	\
    (This)->lpVtbl -> GetDailyCountADO(This,dDate,iCount)

#define ICountDaily_ReportDailyBuckets(This,dDate,p_Rs)	\
    (This)->lpVtbl -> ReportDailyBuckets(This,dDate,p_Rs)

#define ICountDaily_GetFileCount(This,eServer,b_Location,d_Date,iCount)	\
    (This)->lpVtbl -> GetFileCount(This,eServer,b_Location,d_Date,iCount)

#define ICountDaily_GetDailyAnon(This,dDate,iCount)	\
    (This)->lpVtbl -> GetDailyAnon(This,dDate,iCount)

#define ICountDaily_GetSpecificSolutions(This,dDate,iCount)	\
    (This)->lpVtbl -> GetSpecificSolutions(This,dDate,iCount)

#define ICountDaily_GetGeneralSolutions(This,dDate,iCount)	\
    (This)->lpVtbl -> GetGeneralSolutions(This,dDate,iCount)

#define ICountDaily_GetStopCodeSolutions(This,dDate,iCount)	\
    (This)->lpVtbl -> GetStopCodeSolutions(This,dDate,iCount)

#define ICountDaily_GetFileMiniCount(This,eServer,b_Location,d_Date,iCount)	\
    (This)->lpVtbl -> GetFileMiniCount(This,eServer,b_Location,d_Date,iCount)

#define ICountDaily_GetIncompleteUploads(This,dDate,iCount)	\
    (This)->lpVtbl -> GetIncompleteUploads(This,dDate,iCount)

#define ICountDaily_GetManualUploads(This,dDate,iCount)	\
    (This)->lpVtbl -> GetManualUploads(This,dDate,iCount)

#define ICountDaily_GetAutoUploads(This,dDate,iCount)	\
    (This)->lpVtbl -> GetAutoUploads(This,dDate,iCount)

#define ICountDaily_GetTest(This,eServer,b_Location,d_Date,iCount)	\
    (This)->lpVtbl -> GetTest(This,eServer,b_Location,d_Date,iCount)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetDailyCount_Proxy( 
    ICountDaily * This,
    /* [in] */ DATE dDate,
    /* [retval][out] */ LONG *iCount);


void __RPC_STUB ICountDaily_GetDailyCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetDailyCountADO_Proxy( 
    ICountDaily * This,
    /* [in] */ DATE dDate,
    /* [retval][out] */ LONG *iCount);


void __RPC_STUB ICountDaily_GetDailyCountADO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_ReportDailyBuckets_Proxy( 
    ICountDaily * This,
    /* [in] */ DATE dDate,
    /* [retval][out] */ IDispatch **p_Rs);


void __RPC_STUB ICountDaily_ReportDailyBuckets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetFileCount_Proxy( 
    ICountDaily * This,
    /* [in] */ enum ServerLocation eServer,
    /* [in] */ BSTR b_Location,
    /* [in] */ DATE d_Date,
    /* [retval][out] */ LONG *iCount);


void __RPC_STUB ICountDaily_GetFileCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetDailyAnon_Proxy( 
    ICountDaily * This,
    /* [in] */ DATE dDate,
    /* [retval][out] */ LONG *iCount);


void __RPC_STUB ICountDaily_GetDailyAnon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetSpecificSolutions_Proxy( 
    ICountDaily * This,
    /* [in] */ DATE dDate,
    /* [retval][out] */ LONG *iCount);


void __RPC_STUB ICountDaily_GetSpecificSolutions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetGeneralSolutions_Proxy( 
    ICountDaily * This,
    /* [in] */ DATE dDate,
    /* [retval][out] */ LONG *iCount);


void __RPC_STUB ICountDaily_GetGeneralSolutions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetStopCodeSolutions_Proxy( 
    ICountDaily * This,
    /* [in] */ DATE dDate,
    /* [retval][out] */ LONG *iCount);


void __RPC_STUB ICountDaily_GetStopCodeSolutions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetFileMiniCount_Proxy( 
    ICountDaily * This,
    /* [in] */ enum ServerLocation eServer,
    /* [in] */ BSTR b_Location,
    /* [in] */ DATE d_Date,
    /* [retval][out] */ LONG *iCount);


void __RPC_STUB ICountDaily_GetFileMiniCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetIncompleteUploads_Proxy( 
    ICountDaily * This,
    /* [in] */ DATE dDate,
    /* [retval][out] */ LONG *iCount);


void __RPC_STUB ICountDaily_GetIncompleteUploads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetManualUploads_Proxy( 
    ICountDaily * This,
    /* [in] */ DATE dDate,
    /* [retval][out] */ LONG *iCount);


void __RPC_STUB ICountDaily_GetManualUploads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetAutoUploads_Proxy( 
    ICountDaily * This,
    /* [in] */ DATE dDate,
    /* [retval][out] */ LONG *iCount);


void __RPC_STUB ICountDaily_GetAutoUploads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetTest_Proxy( 
    ICountDaily * This,
    /* [in] */ enum ServerLocation eServer,
    /* [in] */ BSTR b_Location,
    /* [in] */ DATE d_Date,
    /* [retval][out] */ LONG *iCount);


void __RPC_STUB ICountDaily_GetTest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ICountDaily_INTERFACE_DEFINED__ */



#ifndef __OCAData_LIBRARY_DEFINED__
#define __OCAData_LIBRARY_DEFINED__

/* library OCAData */
/* [helpstring][uuid][version] */ 


EXTERN_C const IID LIBID_OCAData;

EXTERN_C const CLSID CLSID_CCountDaily;

#ifdef __cplusplus

class DECLSPEC_UUID("1614E060-0196-4771-AD9B-FEA1A6778B59")
CCountDaily;
#endif
#endif /* __OCAData_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

unsigned long             __RPC_USER  BSTR_UserSize(     unsigned long *, unsigned long            , BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserMarshal(  unsigned long *, unsigned char *, BSTR * ); 
unsigned char * __RPC_USER  BSTR_UserUnmarshal(unsigned long *, unsigned char *, BSTR * ); 
void                      __RPC_USER  BSTR_UserFree(     unsigned long *, BSTR * ); 

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\_ocadata_p.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the proxy stub code */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon May 20 11:18:54 2002
 */
/* Compiler settings for _OCAData.idl:
    Os, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

/* verify that the <rpcproxy.h> version is high enough to compile this file*/
#ifndef __REDQ_RPCPROXY_H_VERSION__
#define __REQUIRED_RPCPROXY_H_VERSION__ 440
#endif


#include "rpcproxy.h"
#ifndef __RPCPROXY_H_VERSION__
#error this stub requires an updated version of <rpcproxy.h>
#endif // __RPCPROXY_H_VERSION__


#include "_OCAData.h"

#define TYPE_FORMAT_STRING_SIZE   63                                
#define PROC_FORMAT_STRING_SIZE   31                                
#define TRANSMIT_AS_TABLE_SIZE    0            
#define WIRE_MARSHAL_TABLE_SIZE   1            

typedef struct _MIDL_TYPE_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ TYPE_FORMAT_STRING_SIZE ];
    } MIDL_TYPE_FORMAT_STRING;

typedef struct _MIDL_PROC_FORMAT_STRING
    {
    short          Pad;
    unsigned char  Format[ PROC_FORMAT_STRING_SIZE ];
    } MIDL_PROC_FORMAT_STRING;


static RPC_SYNTAX_IDENTIFIER  _RpcTransferSyntax = 
{{0x8A885D04,0x1CEB,0x11C9,{0x9F,0xE8,0x08,0x00,0x2B,0x10,0x48,0x60}},{2,0}};


extern const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString;
extern const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString;


extern const MIDL_STUB_DESC Object_StubDesc;


extern const MIDL_SERVER_INFO ICountDaily_ServerInfo;
extern const MIDL_STUBLESS_PROXY_INFO ICountDaily_ProxyInfo;


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetDailyCount_Proxy( 
    ICountDaily * This,
    /* [in] */ DATE dDate,
    /* [retval][out] */ LONG *iCount)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      7);
        
        
        
        if(!iCount)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 16;
            NdrProxyGetBuffer(This, &_StubMsg);
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
            *(( DATE * )_StubMsg.Buffer)++ = dDate;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            _StubMsg.BufferStart = (unsigned char *) _RpcMessage.Buffer; 
            _StubMsg.BufferEnd   = _StubMsg.BufferStart + _RpcMessage.BufferLength;
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            *iCount = *(( LONG * )_StubMsg.Buffer)++;
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            
            if(_StubMsg.Buffer + 4 > _StubMsg.BufferEnd)
                {
                RpcRaiseException(RPC_X_BAD_STUB_DATA);
                }
            _RetVal = *(( HRESULT * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[2],
                         ( void * )iCount);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB ICountDaily_GetDailyCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LONG _M0	=	0;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    DATE dDate;
    LONG *iCount;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    dDate = 0;
    ( LONG * )iCount = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
        
        if(_StubMsg.Buffer + 8 > _StubMsg.BufferEnd)
            {
            RpcRaiseException(RPC_X_BAD_STUB_DATA);
            }
        dDate = *(( DATE * )_StubMsg.Buffer)++;
        
        iCount = &_M0;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((ICountDaily*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> GetDailyCount(
                 (ICountDaily *) ((CStdStubBuffer *)This)->pvServerObject,
                 dDate,
                 iCount);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 36;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( LONG * )_StubMsg.Buffer)++ = *iCount;
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)(_StubMsg.Buffer - (unsigned char *)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetDailyCountADO_Proxy( 
    ICountDaily * This,
    /* [in] */ DATE dDate,
    /* [retval][out] */ LONG *iCount)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      8);
        
        
        
        if(!iCount)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 16;
            NdrProxyGetBuffer(This, &_StubMsg);
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
            *(( DATE * )_StubMsg.Buffer)++ = dDate;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            _StubMsg.BufferStart = (unsigned char *) _RpcMessage.Buffer; 
            _StubMsg.BufferEnd   = _StubMsg.BufferStart + _RpcMessage.BufferLength;
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            *iCount = *(( LONG * )_StubMsg.Buffer)++;
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            
            if(_StubMsg.Buffer + 4 > _StubMsg.BufferEnd)
                {
                RpcRaiseException(RPC_X_BAD_STUB_DATA);
                }
            _RetVal = *(( HRESULT * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[2],
                         ( void * )iCount);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB ICountDaily_GetDailyCountADO_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LONG _M1	=	0;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    DATE dDate;
    LONG *iCount;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    dDate = 0;
    ( LONG * )iCount = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
        
        if(_StubMsg.Buffer + 8 > _StubMsg.BufferEnd)
            {
            RpcRaiseException(RPC_X_BAD_STUB_DATA);
            }
        dDate = *(( DATE * )_StubMsg.Buffer)++;
        
        iCount = &_M1;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((ICountDaily*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> GetDailyCountADO(
                    (ICountDaily *) ((CStdStubBuffer *)This)->pvServerObject,
                    dDate,
                    iCount);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 36;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( LONG * )_StubMsg.Buffer)++ = *iCount;
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)(_StubMsg.Buffer - (unsigned char *)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_ReportDailyBuckets_Proxy( 
    ICountDaily * This,
    /* [in] */ DATE dDate,
    /* [retval][out] */ IDispatch **p_Rs)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    if(p_Rs)
        {
        MIDL_memset(
               p_Rs,
               0,
               sizeof( IDispatch ** ));
        }
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      9);
        
        
        
        if(!p_Rs)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 16;
            NdrProxyGetBuffer(This, &_StubMsg);
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
            *(( DATE * )_StubMsg.Buffer)++ = dDate;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            _StubMsg.BufferStart = (unsigned char *) _RpcMessage.Buffer; 
            _StubMsg.BufferEnd   = _StubMsg.BufferStart + _RpcMessage.BufferLength;
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[8] );
            
            NdrPointerUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char * *)&p_Rs,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[6],
                                  (unsigned char)0 );
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            
            if(_StubMsg.Buffer + 4 > _StubMsg.BufferEnd)
                {
                RpcRaiseException(RPC_X_BAD_STUB_DATA);
                }
            _RetVal = *(( HRESULT * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[6],
                         ( void * )p_Rs);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB ICountDaily_ReportDailyBuckets_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    IDispatch *_M2;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    DATE dDate;
    IDispatch **p_Rs;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    dDate = 0;
    ( IDispatch ** )p_Rs = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[8] );
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
        
        if(_StubMsg.Buffer + 8 > _StubMsg.BufferEnd)
            {
            RpcRaiseException(RPC_X_BAD_STUB_DATA);
            }
        dDate = *(( DATE * )_StubMsg.Buffer)++;
        
        p_Rs = &_M2;
        _M2 = 0;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((ICountDaily*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> ReportDailyBuckets(
                      (ICountDaily *) ((CStdStubBuffer *)This)->pvServerObject,
                      dDate,
                      p_Rs);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 8;
        NdrPointerBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                              (unsigned char *)p_Rs,
                              (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[6] );
        
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        NdrPointerMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                            (unsigned char *)p_Rs,
                            (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[6] );
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrPointerFree( &_StubMsg,
                        (unsigned char *)p_Rs,
                        &__MIDL_TypeFormatString.Format[6] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)(_StubMsg.Buffer - (unsigned char *)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetFileCount_Proxy( 
    ICountDaily * This,
    /* [in] */ enum ServerLocation eServer,
    /* [in] */ BSTR b_Location,
    /* [in] */ DATE d_Date,
    /* [retval][out] */ LONG *iCount)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      10);
        
        
        
        if(!iCount)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 22;
            NdrUserMarshalBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                      (unsigned char *)&b_Location,
                                      (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[52] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrSimpleTypeMarshall(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( unsigned char * )&eServer,
                         13);
            NdrUserMarshalMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                    (unsigned char *)&b_Location,
                                    (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[52] );
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
            *(( DATE * )_StubMsg.Buffer)++ = d_Date;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            _StubMsg.BufferStart = (unsigned char *) _RpcMessage.Buffer; 
            _StubMsg.BufferEnd   = _StubMsg.BufferStart + _RpcMessage.BufferLength;
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[16] );
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            *iCount = *(( LONG * )_StubMsg.Buffer)++;
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            
            if(_StubMsg.Buffer + 4 > _StubMsg.BufferEnd)
                {
                RpcRaiseException(RPC_X_BAD_STUB_DATA);
                }
            _RetVal = *(( HRESULT * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[2],
                         ( void * )iCount);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB ICountDaily_GetFileCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LONG _M3	=	0;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    void *_p_b_Location;
    BSTR b_Location;
    DATE d_Date;
    enum ServerLocation eServer;
    LONG *iCount;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    eServer = 0;
    _p_b_Location = &b_Location;
    MIDL_memset(
               _p_b_Location,
               0,
               sizeof( BSTR  ));
    d_Date = 0;
    ( LONG * )iCount = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[16] );
        
        NdrSimpleTypeUnmarshall(
                           ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                           ( unsigned char * )&eServer,
                           13);
        NdrUserMarshalUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char * *)&_p_b_Location,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[52],
                                  (unsigned char)0 );
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
        
        if(_StubMsg.Buffer + 8 > _StubMsg.BufferEnd)
            {
            RpcRaiseException(RPC_X_BAD_STUB_DATA);
            }
        d_Date = *(( DATE * )_StubMsg.Buffer)++;
        
        iCount = &_M3;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((ICountDaily*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> GetFileCount(
                (ICountDaily *) ((CStdStubBuffer *)This)->pvServerObject,
                eServer,
                b_Location,
                d_Date,
                iCount);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 36;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( LONG * )_StubMsg.Buffer)++ = *iCount;
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrUserMarshalFree( &_StubMsg,
                            (unsigned char *)&b_Location,
                            &__MIDL_TypeFormatString.Format[52] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)(_StubMsg.Buffer - (unsigned char *)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetDailyAnon_Proxy( 
    ICountDaily * This,
    /* [in] */ DATE dDate,
    /* [retval][out] */ LONG *iCount)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      11);
        
        
        
        if(!iCount)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 16;
            NdrProxyGetBuffer(This, &_StubMsg);
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
            *(( DATE * )_StubMsg.Buffer)++ = dDate;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            _StubMsg.BufferStart = (unsigned char *) _RpcMessage.Buffer; 
            _StubMsg.BufferEnd   = _StubMsg.BufferStart + _RpcMessage.BufferLength;
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            *iCount = *(( LONG * )_StubMsg.Buffer)++;
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            
            if(_StubMsg.Buffer + 4 > _StubMsg.BufferEnd)
                {
                RpcRaiseException(RPC_X_BAD_STUB_DATA);
                }
            _RetVal = *(( HRESULT * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[2],
                         ( void * )iCount);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB ICountDaily_GetDailyAnon_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LONG _M4	=	0;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    DATE dDate;
    LONG *iCount;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    dDate = 0;
    ( LONG * )iCount = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
        
        if(_StubMsg.Buffer + 8 > _StubMsg.BufferEnd)
            {
            RpcRaiseException(RPC_X_BAD_STUB_DATA);
            }
        dDate = *(( DATE * )_StubMsg.Buffer)++;
        
        iCount = &_M4;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((ICountDaily*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> GetDailyAnon(
                (ICountDaily *) ((CStdStubBuffer *)This)->pvServerObject,
                dDate,
                iCount);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 36;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( LONG * )_StubMsg.Buffer)++ = *iCount;
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)(_StubMsg.Buffer - (unsigned char *)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetSpecificSolutions_Proxy( 
    ICountDaily * This,
    /* [in] */ DATE dDate,
    /* [retval][out] */ LONG *iCount)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      12);
        
        
        
        if(!iCount)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 16;
            NdrProxyGetBuffer(This, &_StubMsg);
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
            *(( DATE * )_StubMsg.Buffer)++ = dDate;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            _StubMsg.BufferStart = (unsigned char *) _RpcMessage.Buffer; 
            _StubMsg.BufferEnd   = _StubMsg.BufferStart + _RpcMessage.BufferLength;
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            *iCount = *(( LONG * )_StubMsg.Buffer)++;
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            
            if(_StubMsg.Buffer + 4 > _StubMsg.BufferEnd)
                {
                RpcRaiseException(RPC_X_BAD_STUB_DATA);
                }
            _RetVal = *(( HRESULT * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[2],
                         ( void * )iCount);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB ICountDaily_GetSpecificSolutions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LONG _M5	=	0;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    DATE dDate;
    LONG *iCount;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    dDate = 0;
    ( LONG * )iCount = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
        
        if(_StubMsg.Buffer + 8 > _StubMsg.BufferEnd)
            {
            RpcRaiseException(RPC_X_BAD_STUB_DATA);
            }
        dDate = *(( DATE * )_StubMsg.Buffer)++;
        
        iCount = &_M5;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((ICountDaily*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> GetSpecificSolutions(
                        (ICountDaily *) ((CStdStubBuffer *)This)->pvServerObject,
                        dDate,
                        iCount);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 36;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( LONG * )_StubMsg.Buffer)++ = *iCount;
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)(_StubMsg.Buffer - (unsigned char *)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetGeneralSolutions_Proxy( 
    ICountDaily * This,
    /* [in] */ DATE dDate,
    /* [retval][out] */ LONG *iCount)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      13);
        
        
        
        if(!iCount)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 16;
            NdrProxyGetBuffer(This, &_StubMsg);
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
            *(( DATE * )_StubMsg.Buffer)++ = dDate;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            _StubMsg.BufferStart = (unsigned char *) _RpcMessage.Buffer; 
            _StubMsg.BufferEnd   = _StubMsg.BufferStart + _RpcMessage.BufferLength;
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            *iCount = *(( LONG * )_StubMsg.Buffer)++;
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            
            if(_StubMsg.Buffer + 4 > _StubMsg.BufferEnd)
                {
                RpcRaiseException(RPC_X_BAD_STUB_DATA);
                }
            _RetVal = *(( HRESULT * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[2],
                         ( void * )iCount);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB ICountDaily_GetGeneralSolutions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LONG _M6	=	0;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    DATE dDate;
    LONG *iCount;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    dDate = 0;
    ( LONG * )iCount = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
        
        if(_StubMsg.Buffer + 8 > _StubMsg.BufferEnd)
            {
            RpcRaiseException(RPC_X_BAD_STUB_DATA);
            }
        dDate = *(( DATE * )_StubMsg.Buffer)++;
        
        iCount = &_M6;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((ICountDaily*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> GetGeneralSolutions(
                       (ICountDaily *) ((CStdStubBuffer *)This)->pvServerObject,
                       dDate,
                       iCount);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 36;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( LONG * )_StubMsg.Buffer)++ = *iCount;
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)(_StubMsg.Buffer - (unsigned char *)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetStopCodeSolutions_Proxy( 
    ICountDaily * This,
    /* [in] */ DATE dDate,
    /* [retval][out] */ LONG *iCount)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      14);
        
        
        
        if(!iCount)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 16;
            NdrProxyGetBuffer(This, &_StubMsg);
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
            *(( DATE * )_StubMsg.Buffer)++ = dDate;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            _StubMsg.BufferStart = (unsigned char *) _RpcMessage.Buffer; 
            _StubMsg.BufferEnd   = _StubMsg.BufferStart + _RpcMessage.BufferLength;
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            *iCount = *(( LONG * )_StubMsg.Buffer)++;
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            
            if(_StubMsg.Buffer + 4 > _StubMsg.BufferEnd)
                {
                RpcRaiseException(RPC_X_BAD_STUB_DATA);
                }
            _RetVal = *(( HRESULT * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[2],
                         ( void * )iCount);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB ICountDaily_GetStopCodeSolutions_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LONG _M7	=	0;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    DATE dDate;
    LONG *iCount;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    dDate = 0;
    ( LONG * )iCount = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
        
        if(_StubMsg.Buffer + 8 > _StubMsg.BufferEnd)
            {
            RpcRaiseException(RPC_X_BAD_STUB_DATA);
            }
        dDate = *(( DATE * )_StubMsg.Buffer)++;
        
        iCount = &_M7;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((ICountDaily*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> GetStopCodeSolutions(
                        (ICountDaily *) ((CStdStubBuffer *)This)->pvServerObject,
                        dDate,
                        iCount);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 36;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( LONG * )_StubMsg.Buffer)++ = *iCount;
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)(_StubMsg.Buffer - (unsigned char *)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetFileMiniCount_Proxy( 
    ICountDaily * This,
    /* [in] */ enum ServerLocation eServer,
    /* [in] */ BSTR b_Location,
    /* [in] */ DATE d_Date,
    /* [retval][out] */ LONG *iCount)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      15);
        
        
        
        if(!iCount)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 22;
            NdrUserMarshalBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                      (unsigned char *)&b_Location,
                                      (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[52] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrSimpleTypeMarshall(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( unsigned char * )&eServer,
                         13);
            NdrUserMarshalMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                    (unsigned char *)&b_Location,
                                    (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[52] );
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
            *(( DATE * )_StubMsg.Buffer)++ = d_Date;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            _StubMsg.BufferStart = (unsigned char *) _RpcMessage.Buffer; 
            _StubMsg.BufferEnd   = _StubMsg.BufferStart + _RpcMessage.BufferLength;
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[16] );
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            *iCount = *(( LONG * )_StubMsg.Buffer)++;
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            
            if(_StubMsg.Buffer + 4 > _StubMsg.BufferEnd)
                {
                RpcRaiseException(RPC_X_BAD_STUB_DATA);
                }
            _RetVal = *(( HRESULT * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[2],
                         ( void * )iCount);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB ICountDaily_GetFileMiniCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LONG _M8	=	0;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    void *_p_b_Location;
    BSTR b_Location;
    DATE d_Date;
    enum ServerLocation eServer;
    LONG *iCount;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    eServer = 0;
    _p_b_Location = &b_Location;
    MIDL_memset(
               _p_b_Location,
               0,
               sizeof( BSTR  ));
    d_Date = 0;
    ( LONG * )iCount = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[16] );
        
        NdrSimpleTypeUnmarshall(
                           ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                           ( unsigned char * )&eServer,
                           13);
        NdrUserMarshalUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char * *)&_p_b_Location,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[52],
                                  (unsigned char)0 );
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
        
        if(_StubMsg.Buffer + 8 > _StubMsg.BufferEnd)
            {
            RpcRaiseException(RPC_X_BAD_STUB_DATA);
            }
        d_Date = *(( DATE * )_StubMsg.Buffer)++;
        
        iCount = &_M8;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((ICountDaily*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> GetFileMiniCount(
                    (ICountDaily *) ((CStdStubBuffer *)This)->pvServerObject,
                    eServer,
                    b_Location,
                    d_Date,
                    iCount);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 36;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( LONG * )_StubMsg.Buffer)++ = *iCount;
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrUserMarshalFree( &_StubMsg,
                            (unsigned char *)&b_Location,
                            &__MIDL_TypeFormatString.Format[52] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)(_StubMsg.Buffer - (unsigned char *)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetIncompleteUploads_Proxy( 
    ICountDaily * This,
    /* [in] */ DATE dDate,
    /* [retval][out] */ LONG *iCount)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      16);
        
        
        
        if(!iCount)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 16;
            NdrProxyGetBuffer(This, &_StubMsg);
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
            *(( DATE * )_StubMsg.Buffer)++ = dDate;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            _StubMsg.BufferStart = (unsigned char *) _RpcMessage.Buffer; 
            _StubMsg.BufferEnd   = _StubMsg.BufferStart + _RpcMessage.BufferLength;
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            *iCount = *(( LONG * )_StubMsg.Buffer)++;
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            
            if(_StubMsg.Buffer + 4 > _StubMsg.BufferEnd)
                {
                RpcRaiseException(RPC_X_BAD_STUB_DATA);
                }
            _RetVal = *(( HRESULT * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[2],
                         ( void * )iCount);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB ICountDaily_GetIncompleteUploads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LONG _M9	=	0;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    DATE dDate;
    LONG *iCount;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    dDate = 0;
    ( LONG * )iCount = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
        
        if(_StubMsg.Buffer + 8 > _StubMsg.BufferEnd)
            {
            RpcRaiseException(RPC_X_BAD_STUB_DATA);
            }
        dDate = *(( DATE * )_StubMsg.Buffer)++;
        
        iCount = &_M9;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((ICountDaily*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> GetIncompleteUploads(
                        (ICountDaily *) ((CStdStubBuffer *)This)->pvServerObject,
                        dDate,
                        iCount);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 36;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( LONG * )_StubMsg.Buffer)++ = *iCount;
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)(_StubMsg.Buffer - (unsigned char *)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetManualUploads_Proxy( 
    ICountDaily * This,
    /* [in] */ DATE dDate,
    /* [retval][out] */ LONG *iCount)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      17);
        
        
        
        if(!iCount)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 16;
            NdrProxyGetBuffer(This, &_StubMsg);
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
            *(( DATE * )_StubMsg.Buffer)++ = dDate;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            _StubMsg.BufferStart = (unsigned char *) _RpcMessage.Buffer; 
            _StubMsg.BufferEnd   = _StubMsg.BufferStart + _RpcMessage.BufferLength;
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            *iCount = *(( LONG * )_StubMsg.Buffer)++;
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            
            if(_StubMsg.Buffer + 4 > _StubMsg.BufferEnd)
                {
                RpcRaiseException(RPC_X_BAD_STUB_DATA);
                }
            _RetVal = *(( HRESULT * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[2],
                         ( void * )iCount);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB ICountDaily_GetManualUploads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LONG _M10	=	0;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    DATE dDate;
    LONG *iCount;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    dDate = 0;
    ( LONG * )iCount = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
        
        if(_StubMsg.Buffer + 8 > _StubMsg.BufferEnd)
            {
            RpcRaiseException(RPC_X_BAD_STUB_DATA);
            }
        dDate = *(( DATE * )_StubMsg.Buffer)++;
        
        iCount = &_M10;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((ICountDaily*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> GetManualUploads(
                    (ICountDaily *) ((CStdStubBuffer *)This)->pvServerObject,
                    dDate,
                    iCount);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 36;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( LONG * )_StubMsg.Buffer)++ = *iCount;
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)(_StubMsg.Buffer - (unsigned char *)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetAutoUploads_Proxy( 
    ICountDaily * This,
    /* [in] */ DATE dDate,
    /* [retval][out] */ LONG *iCount)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      18);
        
        
        
        if(!iCount)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 16;
            NdrProxyGetBuffer(This, &_StubMsg);
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
            *(( DATE * )_StubMsg.Buffer)++ = dDate;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            _StubMsg.BufferStart = (unsigned char *) _RpcMessage.Buffer; 
            _StubMsg.BufferEnd   = _StubMsg.BufferStart + _RpcMessage.BufferLength;
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            *iCount = *(( LONG * )_StubMsg.Buffer)++;
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            
            if(_StubMsg.Buffer + 4 > _StubMsg.BufferEnd)
                {
                RpcRaiseException(RPC_X_BAD_STUB_DATA);
                }
            _RetVal = *(( HRESULT * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[2],
                         ( void * )iCount);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB ICountDaily_GetAutoUploads_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LONG _M11	=	0;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    DATE dDate;
    LONG *iCount;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    dDate = 0;
    ( LONG * )iCount = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[0] );
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
        
        if(_StubMsg.Buffer + 8 > _StubMsg.BufferEnd)
            {
            RpcRaiseException(RPC_X_BAD_STUB_DATA);
            }
        dDate = *(( DATE * )_StubMsg.Buffer)++;
        
        iCount = &_M11;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((ICountDaily*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> GetAutoUploads(
                  (ICountDaily *) ((CStdStubBuffer *)This)->pvServerObject,
                  dDate,
                  iCount);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 36;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( LONG * )_StubMsg.Buffer)++ = *iCount;
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)(_StubMsg.Buffer - (unsigned char *)_pRpcMessage->Buffer);
    
}


/* [helpstring][id] */ HRESULT STDMETHODCALLTYPE ICountDaily_GetTest_Proxy( 
    ICountDaily * This,
    /* [in] */ enum ServerLocation eServer,
    /* [in] */ BSTR b_Location,
    /* [in] */ DATE d_Date,
    /* [retval][out] */ LONG *iCount)
{

    HRESULT _RetVal;
    
    RPC_MESSAGE _RpcMessage;
    
    MIDL_STUB_MESSAGE _StubMsg;
    
    RpcTryExcept
        {
        NdrProxyInitialize(
                      ( void *  )This,
                      ( PRPC_MESSAGE  )&_RpcMessage,
                      ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                      ( PMIDL_STUB_DESC  )&Object_StubDesc,
                      19);
        
        
        
        if(!iCount)
            {
            RpcRaiseException(RPC_X_NULL_REF_POINTER);
            }
        RpcTryFinally
            {
            
            _StubMsg.BufferLength = 22;
            NdrUserMarshalBufferSize( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                      (unsigned char *)&b_Location,
                                      (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[52] );
            
            NdrProxyGetBuffer(This, &_StubMsg);
            NdrSimpleTypeMarshall(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( unsigned char * )&eServer,
                         13);
            NdrUserMarshalMarshall( (PMIDL_STUB_MESSAGE)& _StubMsg,
                                    (unsigned char *)&b_Location,
                                    (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[52] );
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
            *(( DATE * )_StubMsg.Buffer)++ = d_Date;
            
            NdrProxySendReceive(This, &_StubMsg);
            
            _StubMsg.BufferStart = (unsigned char *) _RpcMessage.Buffer; 
            _StubMsg.BufferEnd   = _StubMsg.BufferStart + _RpcMessage.BufferLength;
            
            if ( (_RpcMessage.DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
                NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[16] );
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            *iCount = *(( LONG * )_StubMsg.Buffer)++;
            
            _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
            
            if(_StubMsg.Buffer + 4 > _StubMsg.BufferEnd)
                {
                RpcRaiseException(RPC_X_BAD_STUB_DATA);
                }
            _RetVal = *(( HRESULT * )_StubMsg.Buffer)++;
            
            }
        RpcFinally
            {
            NdrProxyFreeBuffer(This, &_StubMsg);
            
            }
        RpcEndFinally
        
        }
    RpcExcept(_StubMsg.dwStubPhase != PROXY_SENDRECEIVE)
        {
        NdrClearOutParameters(
                         ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                         ( PFORMAT_STRING  )&__MIDL_TypeFormatString.Format[2],
                         ( void * )iCount);
        _RetVal = NdrProxyErrorHandler(RpcExceptionCode());
        }
    RpcEndExcept
    return _RetVal;
}

void __RPC_STUB ICountDaily_GetTest_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase)
{
    LONG _M12	=	0;
    HRESULT _RetVal;
    MIDL_STUB_MESSAGE _StubMsg;
    void *_p_b_Location;
    BSTR b_Location;
    DATE d_Date;
    enum ServerLocation eServer;
    LONG *iCount;
    
NdrStubInitialize(
                     _pRpcMessage,
                     &_StubMsg,
                     &Object_StubDesc,
                     _pRpcChannelBuffer);
    eServer = 0;
    _p_b_Location = &b_Location;
    MIDL_memset(
               _p_b_Location,
               0,
               sizeof( BSTR  ));
    d_Date = 0;
    ( LONG * )iCount = 0;
    RpcTryFinally
        {
        if ( (_pRpcMessage->DataRepresentation & 0X0000FFFFUL) != NDR_LOCAL_DATA_REPRESENTATION )
            NdrConvert( (PMIDL_STUB_MESSAGE) &_StubMsg, (PFORMAT_STRING) &__MIDL_ProcFormatString.Format[16] );
        
        NdrSimpleTypeUnmarshall(
                           ( PMIDL_STUB_MESSAGE  )&_StubMsg,
                           ( unsigned char * )&eServer,
                           13);
        NdrUserMarshalUnmarshall( (PMIDL_STUB_MESSAGE) &_StubMsg,
                                  (unsigned char * *)&_p_b_Location,
                                  (PFORMAT_STRING) &__MIDL_TypeFormatString.Format[52],
                                  (unsigned char)0 );
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 7) & ~ 0x7);
        
        if(_StubMsg.Buffer + 8 > _StubMsg.BufferEnd)
            {
            RpcRaiseException(RPC_X_BAD_STUB_DATA);
            }
        d_Date = *(( DATE * )_StubMsg.Buffer)++;
        
        iCount = &_M12;
        
        *_pdwStubPhase = STUB_CALL_SERVER;
        _RetVal = (((ICountDaily*) ((CStdStubBuffer *)This)->pvServerObject)->lpVtbl) -> GetTest(
           (ICountDaily *) ((CStdStubBuffer *)This)->pvServerObject,
           eServer,
           b_Location,
           d_Date,
           iCount);
        
        *_pdwStubPhase = STUB_MARSHAL;
        
        _StubMsg.BufferLength = 36;
        NdrStubGetBuffer(This, _pRpcChannelBuffer, &_StubMsg);
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( LONG * )_StubMsg.Buffer)++ = *iCount;
        
        _StubMsg.Buffer = (unsigned char *)(((long)_StubMsg.Buffer + 3) & ~ 0x3);
        *(( HRESULT * )_StubMsg.Buffer)++ = _RetVal;
        
        }
    RpcFinally
        {
        NdrUserMarshalFree( &_StubMsg,
                            (unsigned char *)&b_Location,
                            &__MIDL_TypeFormatString.Format[52] );
        
        }
    RpcEndFinally
    _pRpcMessage->BufferLength = 
        (unsigned int)(_StubMsg.Buffer - (unsigned char *)_pRpcMessage->Buffer);
    
}


extern const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ];

#if !defined(__RPC_WIN32__)
#error  Invalid build platform for this stub.
#endif

#if !(TARGET_IS_NT40_OR_LATER)
#error You need a Windows NT 4.0 or later to run this stub because it uses these features:
#error   [wire_marshal] or [user_marshal] attribute.
#error However, your C/C++ compilation flags indicate you intend to run this app on earlier systems.
#error This app will die there with the RPC_X_WRONG_STUB_VERSION error.
#endif


static const MIDL_PROC_FORMAT_STRING __MIDL_ProcFormatString =
    {
        0,
        {
			0x4e,		/* FC_IN_PARAM_BASETYPE */
			0xc,		/* FC_DOUBLE */
/*  2 */	
			0x51,		/* FC_OUT_PARAM */
			0x1,		/* x86 stack size = 1 */
/*  4 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */
/*  6 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/*  8 */	0x4e,		/* FC_IN_PARAM_BASETYPE */
			0xc,		/* FC_DOUBLE */
/* 10 */	
			0x51,		/* FC_OUT_PARAM */
			0x1,		/* x86 stack size = 1 */
/* 12 */	NdrFcShort( 0x6 ),	/* Type Offset=6 */
/* 14 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */
/* 16 */	0x4e,		/* FC_IN_PARAM_BASETYPE */
			0xd,		/* FC_ENUM16 */
/* 18 */	
			0x4d,		/* FC_IN_PARAM */
			0x1,		/* x86 stack size = 1 */
/* 20 */	NdrFcShort( 0x34 ),	/* Type Offset=52 */
/* 22 */	0x4e,		/* FC_IN_PARAM_BASETYPE */
			0xc,		/* FC_DOUBLE */
/* 24 */	
			0x51,		/* FC_OUT_PARAM */
			0x1,		/* x86 stack size = 1 */
/* 26 */	NdrFcShort( 0x2 ),	/* Type Offset=2 */
/* 28 */	0x53,		/* FC_RETURN_PARAM_BASETYPE */
			0x8,		/* FC_LONG */

			0x0
        }
    };

static const MIDL_TYPE_FORMAT_STRING __MIDL_TypeFormatString =
    {
        0,
        {
			NdrFcShort( 0x0 ),	/* 0 */
/*  2 */	
			0x11, 0xc,	/* FC_RP [alloced_on_stack] [simple_pointer] */
/*  4 */	0x8,		/* FC_LONG */
			0x5c,		/* FC_PAD */
/*  6 */	
			0x11, 0x14,	/* FC_RP [alloced_on_stack] [pointer_deref] */
/*  8 */	NdrFcShort( 0x2 ),	/* Offset= 2 (10) */
/* 10 */	
			0x2f,		/* FC_IP */
			0x5a,		/* FC_CONSTANT_IID */
/* 12 */	NdrFcLong( 0x20400 ),	/* 132096 */
/* 16 */	NdrFcShort( 0x0 ),	/* 0 */
/* 18 */	NdrFcShort( 0x0 ),	/* 0 */
/* 20 */	0xc0,		/* 192 */
			0x0,		/* 0 */
/* 22 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 24 */	0x0,		/* 0 */
			0x0,		/* 0 */
/* 26 */	0x0,		/* 0 */
			0x46,		/* 70 */
/* 28 */	
			0x12, 0x0,	/* FC_UP */
/* 30 */	NdrFcShort( 0xc ),	/* Offset= 12 (42) */
/* 32 */	
			0x1b,		/* FC_CARRAY */
			0x1,		/* 1 */
/* 34 */	NdrFcShort( 0x2 ),	/* 2 */
/* 36 */	0x9,		/* Corr desc: FC_ULONG */
			0x0,		/*  */
/* 38 */	NdrFcShort( 0xfffc ),	/* -4 */
/* 40 */	0x6,		/* FC_SHORT */
			0x5b,		/* FC_END */
/* 42 */	
			0x17,		/* FC_CSTRUCT */
			0x3,		/* 3 */
/* 44 */	NdrFcShort( 0x8 ),	/* 8 */
/* 46 */	NdrFcShort( 0xfffffff2 ),	/* Offset= -14 (32) */
/* 48 */	0x8,		/* FC_LONG */
			0x8,		/* FC_LONG */
/* 50 */	0x5c,		/* FC_PAD */
			0x5b,		/* FC_END */
/* 52 */	0xb4,		/* FC_USER_MARSHAL */
			0x83,		/* 131 */
/* 54 */	NdrFcShort( 0x0 ),	/* 0 */
/* 56 */	NdrFcShort( 0x4 ),	/* 4 */
/* 58 */	NdrFcShort( 0x0 ),	/* 0 */
/* 60 */	NdrFcShort( 0xffffffe0 ),	/* Offset= -32 (28) */

			0x0
        }
    };

static const USER_MARSHAL_ROUTINE_QUADRUPLE UserMarshalRoutines[ WIRE_MARSHAL_TABLE_SIZE ] = 
        {
            
            {
            BSTR_UserSize
            ,BSTR_UserMarshal
            ,BSTR_UserUnmarshal
            ,BSTR_UserFree
            }

        };



/* Standard interface: __MIDL_itf__OCAData_0000, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}} */


/* Object interface: IUnknown, ver. 0.0,
   GUID={0x00000000,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: IDispatch, ver. 0.0,
   GUID={0x00020400,0x0000,0x0000,{0xC0,0x00,0x00,0x00,0x00,0x00,0x00,0x46}} */


/* Object interface: ICountDaily, ver. 0.0,
   GUID={0xCEF1A8A8,0xF31A,0x4C4B,{0x96,0xEB,0xEF,0x31,0xCF,0xDB,0x40,0xF5}} */

#pragma code_seg(".orpc")
static const unsigned short ICountDaily_FormatStringOffsetTable[] =
    {
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    (unsigned short) -1,
    0,
    0,
    8,
    16,
    0,
    0,
    0,
    0,
    16,
    0,
    0,
    0,
    16
    };

static const MIDL_STUBLESS_PROXY_INFO ICountDaily_ProxyInfo =
    {
    &Object_StubDesc,
    __MIDL_ProcFormatString.Format,
    &ICountDaily_FormatStringOffsetTable[-3],
    0,
    0,
    0
    };


static const MIDL_SERVER_INFO ICountDaily_ServerInfo = 
    {
    &Object_StubDesc,
    0,
    __MIDL_ProcFormatString.Format,
    &ICountDaily_FormatStringOffsetTable[-3],
    0,
    0,
    0,
    0};
CINTERFACE_PROXY_VTABLE(20) _ICountDailyProxyVtbl = 
{
    &IID_ICountDaily,
    IUnknown_QueryInterface_Proxy,
    IUnknown_AddRef_Proxy,
    IUnknown_Release_Proxy ,
    0 /* IDispatch_GetTypeInfoCount_Proxy */ ,
    0 /* IDispatch_GetTypeInfo_Proxy */ ,
    0 /* IDispatch_GetIDsOfNames_Proxy */ ,
    0 /* IDispatch_Invoke_Proxy */ ,
    ICountDaily_GetDailyCount_Proxy ,
    ICountDaily_GetDailyCountADO_Proxy ,
    ICountDaily_ReportDailyBuckets_Proxy ,
    ICountDaily_GetFileCount_Proxy ,
    ICountDaily_GetDailyAnon_Proxy ,
    ICountDaily_GetSpecificSolutions_Proxy ,
    ICountDaily_GetGeneralSolutions_Proxy ,
    ICountDaily_GetStopCodeSolutions_Proxy ,
    ICountDaily_GetFileMiniCount_Proxy ,
    ICountDaily_GetIncompleteUploads_Proxy ,
    ICountDaily_GetManualUploads_Proxy ,
    ICountDaily_GetAutoUploads_Proxy ,
    ICountDaily_GetTest_Proxy
};


static const PRPC_STUB_FUNCTION ICountDaily_table[] =
{
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    STUB_FORWARDING_FUNCTION,
    ICountDaily_GetDailyCount_Stub,
    ICountDaily_GetDailyCountADO_Stub,
    ICountDaily_ReportDailyBuckets_Stub,
    ICountDaily_GetFileCount_Stub,
    ICountDaily_GetDailyAnon_Stub,
    ICountDaily_GetSpecificSolutions_Stub,
    ICountDaily_GetGeneralSolutions_Stub,
    ICountDaily_GetStopCodeSolutions_Stub,
    ICountDaily_GetFileMiniCount_Stub,
    ICountDaily_GetIncompleteUploads_Stub,
    ICountDaily_GetManualUploads_Stub,
    ICountDaily_GetAutoUploads_Stub,
    ICountDaily_GetTest_Stub
};

CInterfaceStubVtbl _ICountDailyStubVtbl =
{
    &IID_ICountDaily,
    &ICountDaily_ServerInfo,
    20,
    &ICountDaily_table[-3],
    CStdStubBuffer_DELEGATING_METHODS
};

static const MIDL_STUB_DESC Object_StubDesc = 
    {
    0,
    NdrOleAllocate,
    NdrOleFree,
    0,
    0,
    0,
    0,
    0,
    __MIDL_TypeFormatString.Format,
    1, /* -error bounds_check flag */
    0x20000, /* Ndr library version */
    0,
    0x600015b, /* MIDL Version 6.0.347 */
    0,
    UserMarshalRoutines,
    0,  /* notify & notify_flag routine table */
    0x1, /* MIDL flag */
    0, /* cs routines */
    0,   /* proxy/server info */
    0   /* Reserved5 */
    };

const CInterfaceProxyVtbl * __OCAData_ProxyVtblList[] = 
{
    ( CInterfaceProxyVtbl *) &_ICountDailyProxyVtbl,
    0
};

const CInterfaceStubVtbl * __OCAData_StubVtblList[] = 
{
    ( CInterfaceStubVtbl *) &_ICountDailyStubVtbl,
    0
};

PCInterfaceName const __OCAData_InterfaceNamesList[] = 
{
    "ICountDaily",
    0
};

const IID *  __OCAData_BaseIIDList[] = 
{
    &IID_IDispatch,
    0
};


#define __OCAData_CHECK_IID(n)	IID_GENERIC_CHECK_IID( __OCAData, pIID, n)

int __stdcall __OCAData_IID_Lookup( const IID * pIID, int * pIndex )
{
    
    if(!__OCAData_CHECK_IID(0))
        {
        *pIndex = 0;
        return 1;
        }

    return 0;
}

const ExtendedProxyFileInfo _OCAData_ProxyFileInfo = 
{
    (PCInterfaceProxyVtblList *) & __OCAData_ProxyVtblList,
    (PCInterfaceStubVtblList *) & __OCAData_StubVtblList,
    (const PCInterfaceName * ) & __OCAData_InterfaceNamesList,
    (const IID ** ) & __OCAData_BaseIIDList,
    & __OCAData_IID_Lookup, 
    1,
    1,
    0, /* table of [async_uuid] interfaces */
    0, /* Filler1 */
    0, /* Filler2 */
    0  /* Filler3 */
};


#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocadata\_ocadata_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 6.00.0347 */
/* at Mon May 20 11:18:54 2002
 */
/* Compiler settings for _OCAData.idl:
    Os, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AMD64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, IID_ICountDaily,0xCEF1A8A8,0xF31A,0x4C4B,0x96,0xEB,0xEF,0x31,0xCF,0xDB,0x40,0xF5);


MIDL_DEFINE_GUID(IID, LIBID_OCAData,0xD264DB42,0x7095,0x489E,0xB8,0x4D,0x40,0x4C,0xBB,0x3F,0xF6,0x68);


MIDL_DEFINE_GUID(CLSID, CLSID_CCountDaily,0x1614E060,0x0196,0x4771,0xAD,0x9B,0xFE,0xA1,0xA6,0x77,0x8B,0x59);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AMD64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocareports\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//       When specifying the KeyFile, the location of the KeyFile should be
//       relative to the project output directory which is
//       %Project Directory%\obj\<configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocareports\frmautoman.cs ===
#define FILE_SERVER			//FILE_LOCAL	FILE_SERVER

using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Threading;
using System.Text;
using Microsoft.Win32;
using System.Security.Permissions;


namespace OCAReports
{
	/// <summary>
	/// Summary description for frmAutoMan.
	/// </summary>
	public class frmAutoMan : System.Windows.Forms.Form
	{
		private System.Windows.Forms.TabControl tabControl1;
		private System.Windows.Forms.TabPage tabPage1;
		private AxMSChart20Lib.AxMSChart axMSChart1;
		private System.Windows.Forms.TabPage tabPage2;
		private System.Windows.Forms.TabPage tabPage3;
		private System.Windows.Forms.Label label5;
		private System.Windows.Forms.Label label7;
		private System.Windows.Forms.ProgressBar progressBar1;
		private System.Windows.Forms.Label lblPurpose;
		private System.Windows.Forms.StatusBar statusBar1;
		private System.Windows.Forms.Label lblStatement;
		private System.Windows.Forms.MonthCalendar monthCalendar1;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		/// 
		#region ##########################Global Variables#################################
		/*************************************************************************************
		*	module: frmAutoman.cs - Global varibles and objects
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: All global threads and variables are declared.
		*	
		*************************************************************************************/

		private System.ComponentModel.Container components = null;
		public long[] lAutoUploads = new long[7];
		public long[] lManualUploads = new long[7];
		public long[] lNullUploads = new long[7];
		public DateTime[] lDate = new DateTime[7];
		Thread t_DayOne;
		Thread t_DayTwo;
		Thread t_DayThree;
		Thread t_DayFour;
		Thread t_DayFive;
		Thread t_DaySix;
		public System.Windows.Forms.CheckBox chkDatabaseCount;
		Thread t_DaySeven;
		private bool bIsStillProcessing = false;
		private bool bHasProcessed = false;

		#endregion
		public frmAutoMan()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(frmAutoMan));
			this.tabControl1 = new System.Windows.Forms.TabControl();
			this.tabPage1 = new System.Windows.Forms.TabPage();
			this.axMSChart1 = new AxMSChart20Lib.AxMSChart();
			this.tabPage2 = new System.Windows.Forms.TabPage();
			this.tabPage3 = new System.Windows.Forms.TabPage();
			this.label5 = new System.Windows.Forms.Label();
			this.label7 = new System.Windows.Forms.Label();
			this.progressBar1 = new System.Windows.Forms.ProgressBar();
			this.lblPurpose = new System.Windows.Forms.Label();
			this.statusBar1 = new System.Windows.Forms.StatusBar();
			this.lblStatement = new System.Windows.Forms.Label();
			this.monthCalendar1 = new System.Windows.Forms.MonthCalendar();
			this.chkDatabaseCount = new System.Windows.Forms.CheckBox();
			this.tabControl1.SuspendLayout();
			this.tabPage1.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.axMSChart1)).BeginInit();
			this.tabPage3.SuspendLayout();
			this.SuspendLayout();
			// 
			// tabControl1
			// 
			this.tabControl1.Controls.AddRange(new System.Windows.Forms.Control[] {
																					  this.tabPage1,
																					  this.tabPage2,
																					  this.tabPage3});
			this.tabControl1.Location = new System.Drawing.Point(8, 82);
			this.tabControl1.Name = "tabControl1";
			this.tabControl1.SelectedIndex = 0;
			this.tabControl1.Size = new System.Drawing.Size(736, 400);
			this.tabControl1.TabIndex = 92;
			// 
			// tabPage1
			// 
			this.tabPage1.Controls.AddRange(new System.Windows.Forms.Control[] {
																				   this.axMSChart1});
			this.tabPage1.Location = new System.Drawing.Point(4, 22);
			this.tabPage1.Name = "tabPage1";
			this.tabPage1.Size = new System.Drawing.Size(728, 374);
			this.tabPage1.TabIndex = 0;
			this.tabPage1.Text = "Graphical";
			// 
			// axMSChart1
			// 
			this.axMSChart1.ContainingControl = this;
			this.axMSChart1.DataSource = null;
			this.axMSChart1.Location = new System.Drawing.Point(8, 8);
			this.axMSChart1.Name = "axMSChart1";
			this.axMSChart1.OcxState = ((System.Windows.Forms.AxHost.State)(resources.GetObject("axMSChart1.OcxState")));
			this.axMSChart1.Size = new System.Drawing.Size(720, 344);
			this.axMSChart1.TabIndex = 71;
			// 
			// tabPage2
			// 
			this.tabPage2.Location = new System.Drawing.Point(4, 22);
			this.tabPage2.Name = "tabPage2";
			this.tabPage2.Size = new System.Drawing.Size(728, 374);
			this.tabPage2.TabIndex = 1;
			this.tabPage2.Text = "Statistical";
			this.tabPage2.Visible = false;
			this.tabPage2.Paint += new System.Windows.Forms.PaintEventHandler(this.tabPage2_Paint);
			// 
			// tabPage3
			// 
			this.tabPage3.Controls.AddRange(new System.Windows.Forms.Control[] {
																				   this.label5,
																				   this.label7});
			this.tabPage3.Location = new System.Drawing.Point(4, 22);
			this.tabPage3.Name = "tabPage3";
			this.tabPage3.Size = new System.Drawing.Size(728, 374);
			this.tabPage3.TabIndex = 2;
			this.tabPage3.Text = "Notes";
			this.tabPage3.Visible = false;
			// 
			// label5
			// 
			this.label5.Location = new System.Drawing.Point(32, 72);
			this.label5.Name = "label5";
			this.label5.Size = new System.Drawing.Size(576, 72);
			this.label5.TabIndex = 80;
			this.label5.Text = @"Only about a quarter of the people uploading choose to associate the submitted file with their customer information.  Although this seems like a small percentage, it is actually quite a good response.  Things to consider moving forward, are how to improve the nonanonymous uploads by reducing the amount of information required for association.";
			// 
			// label7
			// 
			this.label7.Font = new System.Drawing.Font("Microsoft Sans Serif", 10F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label7.Location = new System.Drawing.Point(32, 32);
			this.label7.Name = "label7";
			this.label7.Size = new System.Drawing.Size(240, 24);
			this.label7.TabIndex = 76;
			this.label7.Text = "Notes";
			// 
			// progressBar1
			// 
			this.progressBar1.Location = new System.Drawing.Point(568, 502);
			this.progressBar1.Name = "progressBar1";
			this.progressBar1.Size = new System.Drawing.Size(384, 23);
			this.progressBar1.TabIndex = 89;
			this.progressBar1.Visible = false;
			// 
			// lblPurpose
			// 
			this.lblPurpose.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.lblPurpose.Location = new System.Drawing.Point(8, 2);
			this.lblPurpose.Name = "lblPurpose";
			this.lblPurpose.Size = new System.Drawing.Size(112, 24);
			this.lblPurpose.TabIndex = 91;
			this.lblPurpose.Text = "Purpose";
			// 
			// statusBar1
			// 
			this.statusBar1.Location = new System.Drawing.Point(0, 512);
			this.statusBar1.Name = "statusBar1";
			this.statusBar1.Size = new System.Drawing.Size(968, 22);
			this.statusBar1.TabIndex = 88;
			// 
			// lblStatement
			// 
			this.lblStatement.Location = new System.Drawing.Point(8, 32);
			this.lblStatement.Name = "lblStatement";
			this.lblStatement.Size = new System.Drawing.Size(744, 30);
			this.lblStatement.TabIndex = 90;
			this.lblStatement.Text = "The data below outlines and graphs the daily\\weekly number\\percentage of anonymou" +
				"s versus customer associated uploads.";
			// 
			// monthCalendar1
			// 
			this.monthCalendar1.Location = new System.Drawing.Point(760, 82);
			this.monthCalendar1.Name = "monthCalendar1";
			this.monthCalendar1.TabIndex = 86;
			this.monthCalendar1.DateSelected += new System.Windows.Forms.DateRangeEventHandler(this.monthCalendar1_DateSelected);
			// 
			// chkDatabaseCount
			// 
			this.chkDatabaseCount.Location = new System.Drawing.Point(768, 264);
			this.chkDatabaseCount.Name = "chkDatabaseCount";
			this.chkDatabaseCount.Size = new System.Drawing.Size(184, 16);
			this.chkDatabaseCount.TabIndex = 93;
			this.chkDatabaseCount.Text = "Database Count";
			this.chkDatabaseCount.CheckedChanged += new System.EventHandler(this.chkDatabaseCount_CheckedChanged);
			// 
			// frmAutoMan
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(968, 534);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.chkDatabaseCount,
																		  this.tabControl1,
																		  this.progressBar1,
																		  this.lblPurpose,
																		  this.statusBar1,
																		  this.lblStatement,
																		  this.monthCalendar1});
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.Name = "frmAutoMan";
			this.Text = "frmAutoMan";
			this.Resize += new System.EventHandler(this.frmAutoMan_Resize);
			this.Closing += new System.ComponentModel.CancelEventHandler(this.frmAutoMan_Closing);
			this.Load += new System.EventHandler(this.frmAutoMan_Load);
			this.tabControl1.ResumeLayout(false);
			this.tabPage1.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.axMSChart1)).EndInit();
			this.tabPage3.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion
		/*************************************************************************************
		*	module: frmAutoMan.cs - frmAutoMan_Load
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: Initialize the calendar control to display one week. Each day is represented
		*	by a global thread.  Set the form title bar to the appropriate start and end days.
		*************************************************************************************/
		private void frmAutoMan_Load(object sender, System.EventArgs e)
		{
			DateTime dDate = DateTime.Today;
			short x = 0, y = 0;

			for(x=7, y=1;x>=1;x--, y++)
			{
				axMSChart1.Row = y;
				axMSChart1.RowLabel = dDate.AddDays(-(x)).ToShortDateString(); //+ dDate.Date.ToString();
			}
			axMSChart1.Plot.SeriesCollection[1].LegendText = "Auto Uploads";
			axMSChart1.Plot.SeriesCollection[2].LegendText = "Manual Uploads";
			axMSChart1.ColumnCount = 2;
			monthCalendar1.SelectionStart = dDate.AddDays(-7);
			monthCalendar1.SelectionEnd = dDate.AddDays(-1);
			this.Show();
			this.Refresh();
			axMSChart1.RowCount = 7;
			this.ParentForm.Refresh();
			this.Text = "Auto vs Manual Uploads  " + monthCalendar1.SelectionStart.ToShortDateString() + " - " +
				monthCalendar1.SelectionEnd.ToShortDateString();
		}
		/*************************************************************************************
		*	module: frmAutoMan.cs - frmAutoMan_Resize
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: to set the controls to the proper position and resize after resizing
		*	the form
		*************************************************************************************/
		private void frmAutoMan_Resize(object sender, System.EventArgs e)
		{
			int buf = 20;

			progressBar1.Top = statusBar1.Top;
			progressBar1.Left = this.Width - progressBar1.Width;
			monthCalendar1.Left = this.Width - (monthCalendar1.Width + buf);
			chkDatabaseCount.Left = monthCalendar1.Left;
			tabControl1.Width = this.Width - (monthCalendar1.Width + (buf * 3));
			tabControl1.Height = this.Height - (statusBar1.Height + lblPurpose.Height + lblStatement.Height + (buf * 4));
			axMSChart1.Height = tabPage1.Height - buf;
			axMSChart1.Width = tabPage1.Width - buf;
		}
		/*************************************************************************************
		*	module: frmAutoMan.cs - monthCalendar1_DateSelected
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: To set the selection dates for one week after the user selects an ending
		*	date.  Also resets the title bar of the form for the new dates.
		*************************************************************************************/
		private void monthCalendar1_DateSelected(object sender, System.Windows.Forms.DateRangeEventArgs e)
		{
			System.DateTime dDate = new System.DateTime(monthCalendar1.SelectionStart.Year, monthCalendar1.SelectionStart.Month, 
				monthCalendar1.SelectionStart.Day);

			monthCalendar1.SelectionStart = dDate.AddDays(-6);
			monthCalendar1.SelectionEnd = dDate.Date;
			this.Text = "Executive Summary Weekly Report  " + monthCalendar1.SelectionStart.ToShortDateString() + " - " +
				monthCalendar1.SelectionEnd.ToShortDateString();

			tabPage2.Refresh();

		}
		public void GetData()
		{
			
			short x = 0;
			System.DateTime dDate = new System.DateTime(monthCalendar1.SelectionStart.Year, monthCalendar1.SelectionStart.Month, 
				monthCalendar1.SelectionStart.Day);
			bIsStillProcessing = true;
//			cmdGetData.Enabled = false;
			progressBar1.Visible = true;
			progressBar1.Refresh();
			axMSChart1.ShowLegend = true;
			if(chkDatabaseCount.Checked == true)
			{
				axMSChart1.ColumnCount = 3;
				axMSChart1.Plot.SeriesCollection[1].LegendText = "Auto Uploads";
				axMSChart1.Plot.SeriesCollection[2].LegendText = "Manual Uploads";
				axMSChart1.Plot.SeriesCollection[3].LegendText = "Null Uploads";
			}
			else
			{
				axMSChart1.ColumnCount = 2;
				axMSChart1.Plot.SeriesCollection[1].LegendText = "Auto Uploads";
				axMSChart1.Plot.SeriesCollection[2].LegendText = "Manual Uploads";
			}
			progressBar1.Visible = true;
			progressBar1.Minimum = 0;
			progressBar1.Maximum = 29;
			progressBar1.Value = 0;
			for(x=1;x<8;x++)
			{
				axMSChart1.Row = x;
				axMSChart1.RowLabel = dDate.AddDays(x-1).ToShortDateString(); //+ dDate.Date.ToString();
			}

			ThreadStart s_DayOne = new ThreadStart(this.TDayOne);
			t_DayOne = new Thread(s_DayOne);
			t_DayOne.Name = "Thread Day One";
			t_DayOne.Start();

			ThreadStart s_DayTwo = new ThreadStart(this.TDayTwo);
			t_DayTwo = new Thread(s_DayTwo);
			t_DayTwo.Name = "Thread Two";
			t_DayTwo.Start();

			ThreadStart s_DayThree = new ThreadStart(this.TDayThree);
			t_DayThree = new Thread(s_DayThree);
			t_DayThree.Name = "Thread Three";
			t_DayThree.Start();

			ThreadStart s_DayFour = new ThreadStart(this.TDayFour);
			t_DayFour = new Thread(s_DayFour);
			t_DayFour.Name = "Thread Four";
			t_DayFour.Start();

			ThreadStart s_DayFive = new ThreadStart(this.TDayFive);
			t_DayFive = new Thread(s_DayFive);
			t_DayFive.Name = "Thread Five";
			t_DayFive.Start();

			ThreadStart s_DaySix = new ThreadStart(this.TDaySix);
			t_DaySix = new Thread(s_DaySix);
			t_DaySix.Name = "Thread Six";
			t_DaySix.Start();

			ThreadStart s_DaySeven = new ThreadStart(this.TDaySeven);
			t_DaySeven = new Thread(s_DaySeven);
			t_DaySeven.Name = "Thread Seven";
			t_DaySeven.Start();
		}
		/*************************************************************************************
		*	module: frmAutoMan.cs - All TDay___ procedures 
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: calls TLoadData and sends the appropriate day and count information.
		*	
		*************************************************************************************/
		private void TDayOne()
		{
			this.TLoadData(0, 1);
		}
		private void TDayTwo()
		{
			this.TLoadData(1, 2);
		}
		private void TDayThree()
		{
			this.TLoadData(2, 3);
		}
		private void TDayFour()
		{
			this.TLoadData(3, 4);
		}
		private void TDayFive()
		{
			this.TLoadData(4, 5);
		}
		private void TDaySix()
		{
			this.TLoadData(5, 6);
		}
		private void TDaySeven()
		{
			this.TLoadData(6, 7);
		}
		/*************************************************************************************
		*	module: frmAutoMan.cs - TLoadData
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: Takes two variables the x represents the day as an integer and the sCount is a 
		*	short representing the column of the Calendar control.  This initializes the OCAData.dll
		*	control and calls the GetDailyCount and GetDailyAnon procedures.  The anonymous count is
		*	subtracted from the total count to get the customer count.  The appropriate column 
		*	and row is updated.
		*************************************************************************************/
		private void TLoadData(int x, short sCount)
		{
			OCAData.CCountDailyClass rpt = new OCAData.CCountDailyClass();
			RegistryKey regArchive = Registry.CurrentUser.OpenSubKey("software").OpenSubKey("microsoft", true).CreateSubKey("OCATools").CreateSubKey("OCAReports").CreateSubKey("Archive");
			RegistryKey regWatson = Registry.CurrentUser.OpenSubKey("software").OpenSubKey("microsoft", true).CreateSubKey("OCATools").CreateSubKey("OCAReports").CreateSubKey("Watson");
			System.DateTime dDate = new System.DateTime(monthCalendar1.SelectionStart.Year, monthCalendar1.SelectionStart.Month, 
				monthCalendar1.SelectionStart.Day);
			string strArchive;
			int y = 0;
			long l_AutoUploads = 0, l_ManualUploads = 0, l_NullUploads = 0;
			
			//***********Total Record Count***************
			if(chkDatabaseCount.Checked == true)
			{
				statusBar1.Text = "Getting Database Auto Uploads for " + dDate.AddDays(x).Date.ToString();
				lDate[x] = dDate.AddDays(x);
				UpdateStatus();
				l_AutoUploads = rpt.GetAutoUploads(dDate.AddDays(x));
			}
			else
			{
				statusBar1.Text = "Getting Archive File Auto Uploads for " + dDate.AddDays(x).Date.ToString();
				lDate[x] = dDate.AddDays(x);
				UpdateStatus();

#if(FILE_SERVER)
				try
				{
					for(y = 0;y < 10; y++)
					{
						if(regArchive.GetValue("Loc" + y.ToString()).ToString().Length > 0)
						{
							strArchive = regArchive.GetValue("Loc" + y.ToString()).ToString();
							l_AutoUploads = rpt.GetFileCount(OCAData.ServerLocation.Archive, strArchive, dDate.AddDays(x));
							if(l_AutoUploads > 0)
							{
								y = 10;
							}
						}
						else
						{
							l_AutoUploads = 0;
						}
					}
					//l_AutoUploads = rpt.GetFileCount(OCAData.ServerLocation.Archive, "Y:\\", dDate.AddDays(x));
				}
				catch
				{
					l_AutoUploads = 0;
				}
#elif(FILE_LOCAL)
				l_AutoUploads = rpt.GetFileCount(OCAData.ServerLocation.Archive, "C:\\MiniDumps\\Archive\\", dDate.AddDays(x));
#endif
			}

			UpdateStatus();
			if(chkDatabaseCount.Checked == true)
			{
				statusBar1.Text = "Getting Database Manual Uploads for " + dDate.AddDays(x).Date.ToString();
				try
				{
					l_ManualUploads = rpt.GetManualUploads(dDate.AddDays(x));
				}
				catch
				{
					l_ManualUploads = -1;
				}
			}
			else
			{
				statusBar1.Text = "Getting Database Manual Uploads for " + dDate.AddDays(x).Date.ToString();
#if(FILE_SERVER)
				try
				{
					for(y = 0;y < 10; y++)
					{
						if(regArchive.GetValue("Loc" + y.ToString()).ToString().Length > 0)
						{
							strArchive = regArchive.GetValue("Loc" + y.ToString()).ToString();
							l_ManualUploads = rpt.GetFileMiniCount(OCAData.ServerLocation.Archive, strArchive, dDate.AddDays(x));
							if(l_ManualUploads > 0)
							{
								y = 10;
							}
						}
						else
						{
							l_ManualUploads = 0;
						}
					}
					//l_ManualUploads = rpt.GetFileMiniCount(OCAData.ServerLocation.Archive, "Y:\\", dDate.AddDays(x));
				}
				catch
				{
					l_ManualUploads = 0;
				}
#elif(FILE_LOCAL)
				l_ManualUploads = rpt.GetFileMiniCount(OCAData.ServerLocation.Archive, "C:\\MiniDumps\\Archive\\", dDate.AddDays(x));
#endif
//				l_ManualUploads = rpt.GetFileMiniCount(OCAData.ServerLocation.Archive, "C:\\MiniDumps\\Archive\\", dDate.AddDays(x));
			}
			lock(this)
			{
				axMSChart1.Row = sCount;
				axMSChart1.Column = 1;
				axMSChart1.RowLabel = dDate.AddDays(x).ToShortDateString(); //+ dDate.Date.ToString();
				if(chkDatabaseCount.Checked == false)
				{
					l_AutoUploads = l_AutoUploads - l_ManualUploads;
				}
				axMSChart1.Data = l_AutoUploads.ToString();
				lAutoUploads[x] = l_AutoUploads;
			}
			lock(this)
			{
				axMSChart1.Row = sCount;
				axMSChart1.Column = 2;
				axMSChart1.Data = l_ManualUploads.ToString();
				lManualUploads[x] = l_ManualUploads;
			}
			UpdateStatus();
			if(chkDatabaseCount.Checked == true)
			{

				statusBar1.Text = "Getting Null Uploads for " + dDate.AddDays(x).Date.ToString();
				try
				{
					l_NullUploads = rpt.GetIncompleteUploads(dDate.AddDays(x));
				}
				catch
				{
					l_NullUploads = -1;
				}
				lock(this)
				{
					axMSChart1.Row = sCount;
					axMSChart1.Column = 3;
					axMSChart1.Data = l_NullUploads.ToString();
					lNullUploads[x] = l_NullUploads;
				}
			}
			UpdateStatus();
			this.Refresh();

		}
		/*************************************************************************************
		*	module: frmAutoMan.cs - UpdateStatus
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: This updates the progress bar and when all threads are returned the 
		*	status bar is updated to done and the cmdGetData button is enabled.
		*************************************************************************************/
		private void UpdateStatus()
		{
			progressBar1.Value = progressBar1.Value + 1;
			axMSChart1.Refresh();
			progressBar1.Refresh();
			if(progressBar1.Value >= 28)
			{
				statusBar1.Text = "Done";
				progressBar1.Visible = false;
//				cmdGetData.Enabled = true;
				bIsStillProcessing = false;
				bHasProcessed = true;
			}

		}
		/*************************************************************************************
		*	module: frmAutoMan.cs - tabPage2_Paint
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: Paints the grid for the tab2 control.  The global variables lAnonymous[x] and 
		*	lCustomer[x] are used to display the appropriate information to the grid.  
		*************************************************************************************/
		private void tabPage2_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
		{
			Pen curvePen = new Pen(Color.Blue);
			Pen dbPen = new Pen(Color.DarkBlue);
			Pen whPen = new Pen(Color.White);
			float row = .05F;
			int x = 0, y = 0, min = 3, max = 12, pad = 10, top = 5, cols=4;
			int colwidth = 0;
			PointF pt = new PointF(0, 0);
			Font ft = new Font("Verdona", 12);
			SolidBrush sb = new SolidBrush(Color.Black);
			StringBuilder strTemp = new StringBuilder(40);
			System.DateTime dDate = new System.DateTime(monthCalendar1.SelectionEnd.Year, monthCalendar1.SelectionEnd.Month, 
				monthCalendar1.SelectionEnd.Day);

			colwidth = tabPage2.Width / cols;

			for(x=min;x<max;x++)
			{
				if(x > (min - 1) && x < top)
				{
					e.Graphics.DrawLine(dbPen,  pad, tabPage2.Height * (row * x), 
						tabPage2.Width - pad, tabPage2.Height * (row * x));
				}
				else
				{
					e.Graphics.DrawLine(curvePen,  pad, tabPage2.Height * (row * x), 
						tabPage2.Width - pad, tabPage2.Height * (row * x));
				}
			}
			//x y x1 y1
			for(x=0;x<cols;x++)
			{

				//left side light blue
				e.Graphics.DrawLine(curvePen,  pad + (colwidth * x), 
					tabPage2.Height * (row * (min + 1)), 
					pad + (colwidth * x), tabPage2.Height * (row * (max - 1)));
				//right side light blue
				e.Graphics.DrawLine(curvePen,  tabPage2.Width - pad, 
					tabPage2.Height * (row * (min + 1)), 
					tabPage2.Width - pad, tabPage2.Height * (row * (max - 1)));
				//left side upper dark blue
				e.Graphics.DrawLine(dbPen,  pad + (colwidth * x), 
					tabPage2.Height * (row * min), 
					pad + (colwidth * x), tabPage2.Height * (row * (min + 1)));
				//right side upper dark blue
				e.Graphics.DrawLine(dbPen,  tabPage2.Width - pad, 
					tabPage2.Height * (row * min), 
					tabPage2.Width - pad, tabPage2.Height * (row * (min + 1)));
			}
			for(x=0,y=6;x<7;x++,y--)
			{
				pt.X =  pad + (colwidth * x);
				pt.Y = tabPage2.Height * (row * min);
				strTemp.Remove(0, strTemp.Length);
				switch(x)
				{
					case 0:
						strTemp.Append("Date");
						break;
					case 1:
						strTemp.Append("Auto Uploads");
						break;
					case 2:
						strTemp.Append("Manual Uploads");
						break;
					case 3:
						strTemp.Append("Null Uploads");
						break;
					default:
						strTemp.Append("");
						break;
				}
				e.Graphics.DrawString(strTemp.ToString(), ft, sb, pt, System.Drawing.StringFormat.GenericDefault);
				pt.X =  pad + (colwidth * 0);
				pt.Y = ((tabPage2.Height * row) * (min + (x + 1)));
				e.Graphics.DrawString(dDate.AddDays(-y).Date.ToShortDateString(), ft, sb, pt, System.Drawing.StringFormat.GenericDefault);
				pt.X =  pad + (colwidth * 1);
				pt.Y = ((tabPage2.Height * row) * (min + (x + 1)));
				e.Graphics.DrawString(lAutoUploads[x].ToString(), ft, sb, pt, System.Drawing.StringFormat.GenericDefault);
				pt.X =  pad + (colwidth * 2);
				pt.Y = ((tabPage2.Height * row) * (min + (x + 1)));
				e.Graphics.DrawString(lManualUploads[x].ToString(), ft, sb, pt, System.Drawing.StringFormat.GenericDefault);
				pt.X =  pad + (colwidth * 3);
				pt.Y = ((tabPage2.Height * row) * (min + (x + 1)));
				e.Graphics.DrawString(lNullUploads[x].ToString(), ft, sb, pt, System.Drawing.StringFormat.GenericDefault);
				
			}
			curvePen.Dispose();
			dbPen.Dispose();
			whPen.Dispose();
		}
		/*************************************************************************************
		*	module: frmAutoMan.cs - frmAutoMan_Closing
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: If any threads are still  alive meaning the user prematurely closes the form
		*	before all threads are returned then the threads are checked to see if they are still
		*	running and if so then the thread is aborted.
		*************************************************************************************/
		private void frmAutoMan_Closing(object sender, System.ComponentModel.CancelEventArgs e)
		{
			if(t_DayOne != null)
			{
				if(t_DayOne.IsAlive)
				{
					t_DayOne.Abort();
				}
			}
			if(t_DayTwo != null)
			{
				if(t_DayTwo.IsAlive)
				{
					t_DayTwo.Abort();
				}
			}
			if(t_DayThree != null)
			{
				if(t_DayThree.IsAlive)
				{
					t_DayThree.Abort();
				}
			}
			if(t_DayFour != null)
			{
				if(t_DayFour.IsAlive)
				{
					t_DayFour.Abort();
				}
			}
			if(t_DayFive != null)
			{
				if(t_DayFive.IsAlive)
				{
					t_DayFive.Abort();
				}
			}
			if(t_DaySix != null)
			{
				if(t_DaySix.IsAlive)
				{
					t_DaySix.Abort();
				}
			}
			if(t_DaySeven != null)
			{
				if(t_DaySeven.IsAlive)
				{
					t_DaySeven.Abort();
				}
			}
		}

		private void chkDatabaseCount_CheckedChanged(object sender, System.EventArgs e)
		{
			if(chkDatabaseCount.Checked == true)
			{
				axMSChart1.ColumnCount = 3;
				axMSChart1.Plot.SeriesCollection[1].LegendText = "Auto Uploads";
				axMSChart1.Plot.SeriesCollection[2].LegendText = "Manual Uploads";
				axMSChart1.Plot.SeriesCollection[3].LegendText = "Null Uploads";
			}
			else
			{
				axMSChart1.ColumnCount = 2;
				axMSChart1.Plot.SeriesCollection[1].LegendText = "Auto Uploads";
				axMSChart1.Plot.SeriesCollection[2].LegendText = "Manual Uploads";
			}

		}
		public bool HasProcessed
		{
			get
			{
				return bHasProcessed;
			}
		}
		public bool StillProcessing
		{
			get
			{
				return bIsStillProcessing;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocareports\frmanoncust.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Threading;
using System.Text;
using System.Drawing.Imaging;

namespace OCAReports
{
	/// <summary>
	/// Summary description for frmAnonCust.
	/// </summary>
	public class frmAnonCust : System.Windows.Forms.Form
	{
		private System.Windows.Forms.TabControl tabControl1;
		private System.Windows.Forms.TabPage tabPage1;
		private System.Windows.Forms.TabPage tabPage2;
		private System.Windows.Forms.TabPage tabPage3;
		private System.Windows.Forms.Label label5;
		private System.Windows.Forms.Label label7;
		private System.Windows.Forms.ProgressBar progressBar1;
		private System.Windows.Forms.Label lblPurpose;
		private System.Windows.Forms.Label lblStatement;
		private System.Windows.Forms.MonthCalendar monthCalendar1;
		private System.Windows.Forms.StatusBar statusBar1;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;
		private System.Windows.Forms.PictureBox pictureBox1;
		private AxMSChart20Lib.AxMSChart axMSChart1;

		#region ########################Global Variables######################################33
		/*************************************************************************************
		*	module: frmAnonCust.cs - Global varibles and objects
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: All global threads and variables are declared.
		*	
		*************************************************************************************/
		public long[] lCustomer = new long[7];
		public long[] lAnonymous = new long[7];
		public DateTime[] lDate = new DateTime[7];
		Thread t_DayOne;
		Thread t_DayTwo;
		Thread t_DayThree;
		Thread t_DayFour;
		Thread t_DayFive;
		Thread t_DaySix;
		Thread t_DaySeven;
		private bool bIsStillProcessing = false;
		private bool bHasProcessed = false;
		#endregion

		public frmAnonCust()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(frmAnonCust));
			this.tabControl1 = new System.Windows.Forms.TabControl();
			this.tabPage1 = new System.Windows.Forms.TabPage();
			this.axMSChart1 = new AxMSChart20Lib.AxMSChart();
			this.pictureBox1 = new System.Windows.Forms.PictureBox();
			this.tabPage2 = new System.Windows.Forms.TabPage();
			this.tabPage3 = new System.Windows.Forms.TabPage();
			this.label5 = new System.Windows.Forms.Label();
			this.label7 = new System.Windows.Forms.Label();
			this.progressBar1 = new System.Windows.Forms.ProgressBar();
			this.lblPurpose = new System.Windows.Forms.Label();
			this.lblStatement = new System.Windows.Forms.Label();
			this.monthCalendar1 = new System.Windows.Forms.MonthCalendar();
			this.statusBar1 = new System.Windows.Forms.StatusBar();
			this.tabControl1.SuspendLayout();
			this.tabPage1.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.axMSChart1)).BeginInit();
			this.tabPage3.SuspendLayout();
			this.SuspendLayout();
			// 
			// tabControl1
			// 
			this.tabControl1.Controls.AddRange(new System.Windows.Forms.Control[] {
																					  this.tabPage1,
																					  this.tabPage2,
																					  this.tabPage3});
			this.tabControl1.Location = new System.Drawing.Point(8, 84);
			this.tabControl1.Name = "tabControl1";
			this.tabControl1.SelectedIndex = 0;
			this.tabControl1.Size = new System.Drawing.Size(736, 400);
			this.tabControl1.TabIndex = 85;
			// 
			// tabPage1
			// 
			this.tabPage1.Controls.AddRange(new System.Windows.Forms.Control[] {
																				   this.axMSChart1,
																				   this.pictureBox1});
			this.tabPage1.Location = new System.Drawing.Point(4, 22);
			this.tabPage1.Name = "tabPage1";
			this.tabPage1.Size = new System.Drawing.Size(728, 374);
			this.tabPage1.TabIndex = 0;
			this.tabPage1.Text = "Graphical";
			// 
			// axMSChart1
			// 
			this.axMSChart1.ContainingControl = this;
			this.axMSChart1.DataSource = null;
			this.axMSChart1.Location = new System.Drawing.Point(0, 16);
			this.axMSChart1.Name = "axMSChart1";
			this.axMSChart1.OcxState = ((System.Windows.Forms.AxHost.State)(resources.GetObject("axMSChart1.OcxState")));
			this.axMSChart1.Size = new System.Drawing.Size(720, 344);
			this.axMSChart1.TabIndex = 75;
			// 
			// pictureBox1
			// 
			this.pictureBox1.Location = new System.Drawing.Point(48, 32);
			this.pictureBox1.Name = "pictureBox1";
			this.pictureBox1.Size = new System.Drawing.Size(128, 112);
			this.pictureBox1.TabIndex = 73;
			this.pictureBox1.TabStop = false;
			// 
			// tabPage2
			// 
			this.tabPage2.Location = new System.Drawing.Point(4, 22);
			this.tabPage2.Name = "tabPage2";
			this.tabPage2.Size = new System.Drawing.Size(728, 374);
			this.tabPage2.TabIndex = 1;
			this.tabPage2.Text = "Statistical";
			this.tabPage2.Visible = false;
			this.tabPage2.Paint += new System.Windows.Forms.PaintEventHandler(this.tabPage2_Paint);
			// 
			// tabPage3
			// 
			this.tabPage3.Controls.AddRange(new System.Windows.Forms.Control[] {
																				   this.label5,
																				   this.label7});
			this.tabPage3.Location = new System.Drawing.Point(4, 22);
			this.tabPage3.Name = "tabPage3";
			this.tabPage3.Size = new System.Drawing.Size(728, 374);
			this.tabPage3.TabIndex = 2;
			this.tabPage3.Text = "Notes";
			this.tabPage3.Visible = false;
			// 
			// label5
			// 
			this.label5.Location = new System.Drawing.Point(32, 72);
			this.label5.Name = "label5";
			this.label5.Size = new System.Drawing.Size(576, 72);
			this.label5.TabIndex = 80;
			this.label5.Text = @"Only about a quarter of the people uploading choose to associate the submitted file with their customer information.  Although this seems like a small percentage, it is actually quite a good response.  Things to consider moving forward, are how to improve the nonanonymous uploads by reducing the amount of information required for association.";
			// 
			// label7
			// 
			this.label7.Font = new System.Drawing.Font("Microsoft Sans Serif", 10F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label7.Location = new System.Drawing.Point(32, 32);
			this.label7.Name = "label7";
			this.label7.Size = new System.Drawing.Size(240, 24);
			this.label7.TabIndex = 76;
			this.label7.Text = "Notes";
			// 
			// progressBar1
			// 
			this.progressBar1.Location = new System.Drawing.Point(568, 504);
			this.progressBar1.Name = "progressBar1";
			this.progressBar1.Size = new System.Drawing.Size(384, 23);
			this.progressBar1.TabIndex = 82;
			this.progressBar1.Visible = false;
			// 
			// lblPurpose
			// 
			this.lblPurpose.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.lblPurpose.Location = new System.Drawing.Point(8, 4);
			this.lblPurpose.Name = "lblPurpose";
			this.lblPurpose.Size = new System.Drawing.Size(112, 24);
			this.lblPurpose.TabIndex = 84;
			this.lblPurpose.Text = "Purpose";
			// 
			// lblStatement
			// 
			this.lblStatement.Location = new System.Drawing.Point(8, 34);
			this.lblStatement.Name = "lblStatement";
			this.lblStatement.Size = new System.Drawing.Size(744, 30);
			this.lblStatement.TabIndex = 83;
			this.lblStatement.Text = "The data below outlines and graphs the daily\\weekly number\\percentage of anonymou" +
				"s versus customer associated uploads.";
			// 
			// monthCalendar1
			// 
			this.monthCalendar1.Location = new System.Drawing.Point(760, 84);
			this.monthCalendar1.Name = "monthCalendar1";
			this.monthCalendar1.TabIndex = 79;
			this.monthCalendar1.DateSelected += new System.Windows.Forms.DateRangeEventHandler(this.monthCalendar1_DateSelected);
			// 
			// statusBar1
			// 
			this.statusBar1.Location = new System.Drawing.Point(0, 512);
			this.statusBar1.Name = "statusBar1";
			this.statusBar1.Size = new System.Drawing.Size(968, 22);
			this.statusBar1.TabIndex = 81;
			// 
			// frmAnonCust
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(968, 534);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.tabControl1,
																		  this.progressBar1,
																		  this.lblPurpose,
																		  this.lblStatement,
																		  this.monthCalendar1,
																		  this.statusBar1});
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.Name = "frmAnonCust";
			this.Text = "Anonymous vs Customer Information";
			this.Resize += new System.EventHandler(this.frmAnonCust_Resize);
			this.Closing += new System.ComponentModel.CancelEventHandler(this.frmAnonCust_Closing);
			this.Load += new System.EventHandler(this.frmAnonCust_Load);
			this.tabControl1.ResumeLayout(false);
			this.tabPage1.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.axMSChart1)).EndInit();
			this.tabPage3.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion
		/*************************************************************************************
		*	module: frmAnonCust.cs - frmAnonCust_Load
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: Initialize the calendar control to display one week. Each day is represented
		*	by a global thread.  Set the form title bar to the appropriate start and end days.
		*************************************************************************************/
		private void frmAnonCust_Load(object sender, System.EventArgs e)
		{
			DateTime dDate = DateTime.Today;
			short x = 0, y = 0;

			for(x=7, y=1;x>=1;x--, y++)
			{
				axMSChart1.Row = y;
				axMSChart1.RowLabel = dDate.AddDays(-(x)).ToShortDateString(); //+ dDate.Date.ToString();
			}
			monthCalendar1.SelectionStart = dDate.AddDays(-7);
			monthCalendar1.SelectionEnd = dDate.AddDays(-1);
			this.Show();
			this.Refresh();
			axMSChart1.RowCount = 7;
			this.ParentForm.Refresh();
			this.Text = "Anonymous vs Customer Uploads  " + monthCalendar1.SelectionStart.ToShortDateString() + " - " +
				monthCalendar1.SelectionEnd.ToShortDateString();
		}
		/*************************************************************************************
		*	module: frmAnonCust.cs - frmAnonCust_Resize
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: to set the controls to the proper position and resize after resizing
		*	the form
		*************************************************************************************/
		private void frmAnonCust_Resize(object sender, System.EventArgs e)
		{
			int buf = 20;

			progressBar1.Top = statusBar1.Top;
			progressBar1.Left = this.Width - progressBar1.Width;
			monthCalendar1.Left = this.Width - (monthCalendar1.Width + buf);
//			cmdGetData.Left = monthCalendar1.Left;
			tabControl1.Width = this.Width - (monthCalendar1.Width + (buf * 3));
			tabControl1.Height = this.Height - (statusBar1.Height + lblPurpose.Height + lblStatement.Height + (buf * 4));
			axMSChart1.Height = tabPage1.Height - buf;
			axMSChart1.Width = tabPage1.Width - buf;
		}
		/*************************************************************************************
		*	module: frmAnonCust.cs - monthCalendar1_DateSelected
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: To set the selection dates for one week after the user selects an ending
		*	date.  Also resets the title bar of the form for the new dates.
		*************************************************************************************/
		private void monthCalendar1_DateSelected(object sender, System.Windows.Forms.DateRangeEventArgs e)
		{
			System.DateTime dDate = new System.DateTime(monthCalendar1.SelectionStart.Year, monthCalendar1.SelectionStart.Month, 
				monthCalendar1.SelectionStart.Day);

			monthCalendar1.SelectionStart = dDate.AddDays(-6);
			monthCalendar1.SelectionEnd = dDate.Date;
			this.Text = "Executive Summary Weekly Report  " + monthCalendar1.SelectionStart.ToShortDateString() + " - " +
				monthCalendar1.SelectionEnd.ToShortDateString();

			tabPage2.Refresh();

		}
		public void GetData()
		{
			short x = 0;
			System.DateTime dDate = new System.DateTime(monthCalendar1.SelectionStart.Year, monthCalendar1.SelectionStart.Month, 
				monthCalendar1.SelectionStart.Day);

//			cmdGetData.Enabled = false;
			bIsStillProcessing = true;
			progressBar1.Visible = true;
			progressBar1.Refresh();
			axMSChart1.ShowLegend = true;
			axMSChart1.Plot.SeriesCollection[1].LegendText = "Anonymous";
			axMSChart1.Plot.SeriesCollection[2].LegendText = "Customer";
			progressBar1.Visible = true;
			progressBar1.Minimum = 0;
			progressBar1.Maximum = 29;
			progressBar1.Value = 0;
			for(x=1;x<8;x++)
			{
				axMSChart1.Row = x;
				axMSChart1.RowLabel = dDate.AddDays(x-1).ToShortDateString(); //+ dDate.Date.ToString();
			}

			ThreadStart s_DayOne = new ThreadStart(this.TDayOne);
			t_DayOne = new Thread(s_DayOne);
			t_DayOne.Name = "Thread One";
			t_DayOne.Start();

			ThreadStart s_DayTwo = new ThreadStart(this.TDayTwo);
			t_DayTwo = new Thread(s_DayTwo);
			t_DayTwo.Name = "Thread Two";
			t_DayTwo.Start();

			ThreadStart s_DayThree = new ThreadStart(this.TDayThree);
			t_DayThree = new Thread(s_DayThree);
			t_DayThree.Name = "Thread Three";
			t_DayThree.Start();

			ThreadStart s_DayFour = new ThreadStart(this.TDayFour);
			t_DayFour = new Thread(s_DayFour);
			t_DayFour.Name = "Thread Four";
			t_DayFour.Start();

			ThreadStart s_DayFive = new ThreadStart(this.TDayFive);
			t_DayFive = new Thread(s_DayFive);
			t_DayFive.Name = "Thread Five";
			t_DayFive.Start();

			ThreadStart s_DaySix = new ThreadStart(this.TDaySix);
			t_DaySix = new Thread(s_DaySix);
			t_DaySix.Name = "Thread Six";
			t_DaySix.Start();

			ThreadStart s_DaySeven = new ThreadStart(this.TDaySeven);
			t_DaySeven = new Thread(s_DaySeven);
			t_DaySeven.Name = "Thread Seven";
			t_DaySeven.Start();
			statusBar1.Text = "Done";
		}
		/*************************************************************************************
		*	module: frmAnonCust.cs - All procedures 
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: calls TLoadData and sends the appropriate day and count information.
		*	
		*************************************************************************************/
		private void TDayOne()
		{
			this.TLoadData(0, 1);
		}
		private void TDayTwo()
		{
			this.TLoadData(1, 2);
		}
		private void TDayThree()
		{
			this.TLoadData(2, 3);
		}
		private void TDayFour()
		{
			this.TLoadData(3, 4);
		}
		private void TDayFive()
		{
			this.TLoadData(4, 5);
		}
		private void TDaySix()
		{
			this.TLoadData(5, 6);
		}
		private void TDaySeven()
		{
			this.TLoadData(6, 7);
		}
		/*************************************************************************************
		*	module: frmAnonCust.cs - TLoadData
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: Takes two variables the x represents the day as an integer and the sCount is a 
		*	short representing the column of the Calendar control.  This initializes the OCAData.dll
		*	control and calls the GetDailyCount and GetDailyAnon procedures.  The anonymous count is
		*	subtracted from the total count to get the customer count.  The appropriate column 
		*	and row is updated.
		*************************************************************************************/
		private void TLoadData(int x, short sCount)
		{
			OCAData.CCountDailyClass rpt = new OCAData.CCountDailyClass();
			System.DateTime dDate = new System.DateTime(monthCalendar1.SelectionStart.Year, monthCalendar1.SelectionStart.Month, 
				monthCalendar1.SelectionStart.Day);

			long lngCount = 0, l_AnonUploads = 0;
			
			UpdateStatus();
			//***********Total Record Count***************
			statusBar1.Text = "Getting Daily Count for " + dDate.AddDays(x).Date.ToString();
			lngCount = rpt.GetDailyCount(dDate.AddDays(x));
			lDate[x] = dDate.AddDays(x);
			//***********Total Anon Count***************
			UpdateStatus();
			statusBar1.Text = "Getting Anon Users for " + dDate.AddDays(x).Date.ToString();
			l_AnonUploads = rpt.GetDailyAnon(dDate.AddDays(x));
			lock(this)
			{
				axMSChart1.Row = sCount;
				axMSChart1.Column = 1;
				axMSChart1.RowLabel = dDate.AddDays(x).Date.ToShortDateString(); //+ dDate.Date.ToString();
				axMSChart1.Data = l_AnonUploads.ToString();
			}

			UpdateStatus();
			//***********Calculate Customer Count***************
			statusBar1.Text = "Calculating Customer Count for " + dDate.AddDays(x).Date.ToString();
			if(l_AnonUploads > lngCount) 
			{
				lngCount = l_AnonUploads - lngCount;
			}
			else
			{
				lngCount = lngCount - l_AnonUploads;
			}
			lock(this)
			{
				axMSChart1.Row = sCount;
				axMSChart1.Column = 2;
				lAnonymous[x] = l_AnonUploads;
				lCustomer[x] = lngCount;
				axMSChart1.Data = lngCount.ToString();
			}
			//**********************************				
			UpdateStatus();
			this.Refresh();

		}
		/*************************************************************************************
		*	module: frmAnonCust.cs - UpdateStatus
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: This updates the progress bar and when all threads are returned the 
		*	status bar is updated to done and the cmdGetData button is enabled.
		*************************************************************************************/
		private void UpdateStatus()
		{
			progressBar1.Value = progressBar1.Value + 1;
			axMSChart1.Refresh();
			progressBar1.Refresh();
			if(progressBar1.Value >= 28)
			{
				statusBar1.Text = "Done";
				progressBar1.Visible = false;
//				cmdGetData.Enabled = true;
				bIsStillProcessing = false;
				bHasProcessed = true;
			}

		}
		/*************************************************************************************
		*	module: frmAnonCust.cs - tabPage2_Paint
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: Paints the grid for the tab2 control.  The global variables lAnonymous[x] and 
		*	lCustomer[x] are used to display the appropriate information to the grid.  
		*************************************************************************************/
		private void tabPage2_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
		{
			Pen curvePen = new Pen(Color.Blue);
			Pen dbPen = new Pen(Color.DarkBlue);
			Pen whPen = new Pen(Color.White);
			float row = .05F;
			int x = 0, y = 0, min = 3, max = 12, pad = 10, top = 5, cols=3;
			int colwidth = 0;
			PointF pt = new PointF(0, 0);
			Font ft = new Font("Verdona", 12);
			SolidBrush sb = new SolidBrush(Color.Black);
			StringBuilder strTemp = new StringBuilder(40);
			System.DateTime dDate = new System.DateTime(monthCalendar1.SelectionEnd.Year, monthCalendar1.SelectionEnd.Month, 
				monthCalendar1.SelectionEnd.Day);

			colwidth = tabPage2.Width / cols;

			for(x=min;x<max;x++)
			{
				if(x > (min - 1) && x < top)
				{
					e.Graphics.DrawLine(dbPen,  pad, tabPage2.Height * (row * x), 
						tabPage2.Width - pad, tabPage2.Height * (row * x));
				}
				else
				{
					e.Graphics.DrawLine(curvePen,  pad, tabPage2.Height * (row * x), 
						tabPage2.Width - pad, tabPage2.Height * (row * x));
				}
			}
			//x y x1 y1
			for(x=0;x<cols;x++)
			{

				//left side light blue
				e.Graphics.DrawLine(curvePen,  pad + (colwidth * x), 
					tabPage2.Height * (row * (min + 1)), 
					pad + (colwidth * x), tabPage2.Height * (row * (max - 1)));
				//right side light blue
				e.Graphics.DrawLine(curvePen,  tabPage2.Width - pad, 
					tabPage2.Height * (row * (min + 1)), 
					tabPage2.Width - pad, tabPage2.Height * (row * (max - 1)));
				//left side upper dark blue
				e.Graphics.DrawLine(dbPen,  pad + (colwidth * x), 
					tabPage2.Height * (row * min), 
					pad + (colwidth * x), tabPage2.Height * (row * (min + 1)));
				//right side upper dark blue
				e.Graphics.DrawLine(dbPen,  tabPage2.Width - pad, 
					tabPage2.Height * (row * min), 
					tabPage2.Width - pad, tabPage2.Height * (row * (min + 1)));
			}
			for(x=0,y=6;x<7;x++,y--)
			{
				pt.X =  pad + (colwidth * x);
				pt.Y = tabPage2.Height * (row * min);
				strTemp.Remove(0, strTemp.Length);
				switch(x)
				{
					case 0:
						strTemp.Append("Date");
						break;
					case 1:
						strTemp.Append("Anonymous");
						break;
					case 2:
						strTemp.Append("Customer");
						break;
					default:
						strTemp.Append("");
						break;
				}
				e.Graphics.DrawString(strTemp.ToString(), ft, sb, pt, System.Drawing.StringFormat.GenericDefault);
				pt.X =  pad + (colwidth * 0);
				pt.Y = ((tabPage2.Height * row) * (min + (x + 1)));
				e.Graphics.DrawString(dDate.AddDays(-y).Date.ToShortDateString(), ft, sb, pt, System.Drawing.StringFormat.GenericDefault);
				pt.X =  pad + (colwidth * 1);
				pt.Y = ((tabPage2.Height * row) * (min + (x + 1)));
				e.Graphics.DrawString(lAnonymous[x].ToString(), ft, sb, pt, System.Drawing.StringFormat.GenericDefault);
				pt.X =  pad + (colwidth * 2);
				pt.Y = ((tabPage2.Height * row) * (min + (x + 1)));
				e.Graphics.DrawString(lCustomer[x].ToString(), ft, sb, pt, System.Drawing.StringFormat.GenericDefault);
				
			}
			curvePen.Dispose();
			dbPen.Dispose();
			whPen.Dispose();
		}
		/*************************************************************************************
		*	module: frmAnonCust.cs - frmAnonCust_Closing
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: If any threads are still  alive meaning the user prematurely closes the form
		*	before all threads are returned then the threads are checked to see if they are still
		*	running and if so then the thread is aborted.
		*************************************************************************************/
		private void frmAnonCust_Closing(object sender, System.ComponentModel.CancelEventArgs e)
		{
			if(t_DayOne != null)
			{
				if(t_DayOne.IsAlive)
				{
					t_DayOne.Abort();
				}
			}
			if(t_DayTwo != null)
			{
				if(t_DayTwo.IsAlive)
				{
					t_DayTwo.Abort();
				}
			}
			if(t_DayThree != null)
			{
				if(t_DayThree.IsAlive)
				{
					t_DayThree.Abort();
				}
			}
			if(t_DayFour != null)
			{
				if(t_DayFour.IsAlive)
				{
					t_DayFour.Abort();
				}
			}
			if(t_DayFive != null)
			{
				if(t_DayFive.IsAlive)
				{
					t_DayFive.Abort();
				}
			}
			if(t_DaySix != null)
			{
				if(t_DaySix.IsAlive)
				{
					t_DaySix.Abort();
				}
			}
			if(t_DaySeven != null)
			{
				if(t_DaySeven.IsAlive)
				{
					t_DaySeven.Abort();
				}
			}
		}
		public bool HasProcessed
		{
			get
			{
				return bHasProcessed;
			}
		}
		public bool StillProcessing
		{
			get
			{
				return bIsStillProcessing;
			}
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocareports\frmdaily.cs ===
#define FILE_SERVER			//FILE_LOCAL	FILE_SERVER
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Threading;
using Microsoft.Win32;


namespace OCAReports
{
	/// <summary>
	/// Summary description for frmDaily.
	/// </summary>
	public class frmDaily : System.Windows.Forms.Form
	{
		internal System.Windows.Forms.CheckBox chkReports13;
		internal System.Windows.Forms.CheckBox chkReports12;
		internal System.Windows.Forms.CheckBox chkReports11;
		internal System.Windows.Forms.CheckBox chkReports8;
		internal System.Windows.Forms.CheckBox chkReports10;
		internal System.Windows.Forms.CheckBox chkReports9;
		internal System.Windows.Forms.CheckBox chkReports7;
		internal System.Windows.Forms.CheckBox chkReports6;
		internal System.Windows.Forms.CheckBox chkReports5;
		internal System.Windows.Forms.CheckBox chkReports4;
		internal System.Windows.Forms.CheckBox chkReports3;
		internal System.Windows.Forms.CheckBox chkReports2;
		internal System.Windows.Forms.CheckBox chkReports1;
		private System.Windows.Forms.MonthCalendar monthCalendar1;
		private System.Windows.Forms.StatusBar statusBar1;
		private System.Windows.Forms.ProgressBar progressBar1;
		private System.Windows.Forms.TabControl tabControl1;
		private System.Windows.Forms.TabPage tabPage1;
		private System.Windows.Forms.TabPage tabPage2;
		private System.Windows.Forms.TabPage tabPage3;
		private System.Windows.Forms.Label label5;
		private System.Windows.Forms.Label label6;
		private System.Windows.Forms.Label label4;
		private System.Windows.Forms.Label label3;
		private AxMSChart20Lib.AxMSChart axMSChart1;
		private System.Windows.Forms.Label label7;
		private System.Windows.Forms.Label label8;
		private System.Windows.Forms.Label label9;
		private System.Windows.Forms.Label label10;
		private System.Windows.Forms.Label label11;
		private System.Windows.Forms.Label lblGeneralSolutions;
		private System.Windows.Forms.Label lblSpecificCount;
		private System.Windows.Forms.Label lblAnonymousCount;
		private System.Windows.Forms.Label lblCustomerCount;
		private System.Windows.Forms.Label lblDailyCount;
		private System.Windows.Forms.Label lblArchiveMiniCount;
		private System.Windows.Forms.Label lblWatsonMiniCount;
		private System.Windows.Forms.Label lblArchiveCount;
		private System.Windows.Forms.Label lblWatsonCount;
		private System.Windows.Forms.Label lblStopCodeCount;
		private System.Windows.Forms.Label label22;
		private System.Windows.Forms.Label label23;
		private System.Windows.Forms.Label label24;
		private System.Windows.Forms.Label label25;
		private System.Windows.Forms.Label label26;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;
		private System.Windows.Forms.Label lblWA;
		private System.Windows.Forms.Label label13;
		private System.Windows.Forms.Label lblAD;
		private System.Windows.Forms.Label label14;


		#region ########################Global Variables######################################33
		/*************************************************************************************
		*	module: frmAnonCust.cs - Global varibles and objects
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: All global threads and variables are declared.
		*	
		*************************************************************************************/

		Thread t_ThreadGBucket;
		Thread t_ThreadSBucket;
		private System.Windows.Forms.Label lblPurpose;
		private System.Windows.Forms.Label lblStatement;
		internal System.Windows.Forms.CheckBox chkSelectAll;
		Thread t_ThreadStopCode;


		#endregion
		
		public frmDaily()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(frmDaily));
			this.chkReports13 = new System.Windows.Forms.CheckBox();
			this.chkReports12 = new System.Windows.Forms.CheckBox();
			this.chkReports11 = new System.Windows.Forms.CheckBox();
			this.chkReports8 = new System.Windows.Forms.CheckBox();
			this.chkReports10 = new System.Windows.Forms.CheckBox();
			this.chkReports9 = new System.Windows.Forms.CheckBox();
			this.chkReports7 = new System.Windows.Forms.CheckBox();
			this.chkReports6 = new System.Windows.Forms.CheckBox();
			this.chkReports5 = new System.Windows.Forms.CheckBox();
			this.chkReports4 = new System.Windows.Forms.CheckBox();
			this.chkReports3 = new System.Windows.Forms.CheckBox();
			this.chkReports2 = new System.Windows.Forms.CheckBox();
			this.chkReports1 = new System.Windows.Forms.CheckBox();
			this.monthCalendar1 = new System.Windows.Forms.MonthCalendar();
			this.statusBar1 = new System.Windows.Forms.StatusBar();
			this.progressBar1 = new System.Windows.Forms.ProgressBar();
			this.lblPurpose = new System.Windows.Forms.Label();
			this.lblStatement = new System.Windows.Forms.Label();
			this.tabControl1 = new System.Windows.Forms.TabControl();
			this.tabPage1 = new System.Windows.Forms.TabPage();
			this.axMSChart1 = new AxMSChart20Lib.AxMSChart();
			this.tabPage2 = new System.Windows.Forms.TabPage();
			this.lblAD = new System.Windows.Forms.Label();
			this.label14 = new System.Windows.Forms.Label();
			this.lblWA = new System.Windows.Forms.Label();
			this.label13 = new System.Windows.Forms.Label();
			this.lblArchiveMiniCount = new System.Windows.Forms.Label();
			this.lblWatsonMiniCount = new System.Windows.Forms.Label();
			this.lblArchiveCount = new System.Windows.Forms.Label();
			this.lblWatsonCount = new System.Windows.Forms.Label();
			this.lblStopCodeCount = new System.Windows.Forms.Label();
			this.label22 = new System.Windows.Forms.Label();
			this.label23 = new System.Windows.Forms.Label();
			this.label24 = new System.Windows.Forms.Label();
			this.label25 = new System.Windows.Forms.Label();
			this.label26 = new System.Windows.Forms.Label();
			this.lblGeneralSolutions = new System.Windows.Forms.Label();
			this.lblSpecificCount = new System.Windows.Forms.Label();
			this.lblAnonymousCount = new System.Windows.Forms.Label();
			this.lblCustomerCount = new System.Windows.Forms.Label();
			this.lblDailyCount = new System.Windows.Forms.Label();
			this.label11 = new System.Windows.Forms.Label();
			this.label10 = new System.Windows.Forms.Label();
			this.label9 = new System.Windows.Forms.Label();
			this.label8 = new System.Windows.Forms.Label();
			this.label7 = new System.Windows.Forms.Label();
			this.tabPage3 = new System.Windows.Forms.TabPage();
			this.label5 = new System.Windows.Forms.Label();
			this.label6 = new System.Windows.Forms.Label();
			this.label4 = new System.Windows.Forms.Label();
			this.label3 = new System.Windows.Forms.Label();
			this.chkSelectAll = new System.Windows.Forms.CheckBox();
			this.tabControl1.SuspendLayout();
			this.tabPage1.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.axMSChart1)).BeginInit();
			this.tabPage2.SuspendLayout();
			this.tabPage3.SuspendLayout();
			this.SuspendLayout();
			// 
			// chkReports13
			// 
			this.chkReports13.Location = new System.Drawing.Point(696, 444);
			this.chkReports13.Name = "chkReports13";
			this.chkReports13.Size = new System.Drawing.Size(128, 16);
			this.chkReports13.TabIndex = 60;
			this.chkReports13.Text = "Get Archive Mini";
			// 
			// chkReports12
			// 
			this.chkReports12.Location = new System.Drawing.Point(696, 416);
			this.chkReports12.Name = "chkReports12";
			this.chkReports12.Size = new System.Drawing.Size(128, 16);
			this.chkReports12.TabIndex = 59;
			this.chkReports12.Text = "Get Watson Mini";
			// 
			// chkReports11
			// 
			this.chkReports11.Location = new System.Drawing.Point(296, 480);
			this.chkReports11.Name = "chkReports11";
			this.chkReports11.Size = new System.Drawing.Size(128, 16);
			this.chkReports11.TabIndex = 58;
			this.chkReports11.Text = "Get StopCodes ADO RS";
			this.chkReports11.Visible = false;
			// 
			// chkReports8
			// 
			this.chkReports8.Location = new System.Drawing.Point(696, 304);
			this.chkReports8.Name = "chkReports8";
			this.chkReports8.Size = new System.Drawing.Size(128, 16);
			this.chkReports8.TabIndex = 57;
			this.chkReports8.Text = "General Solutions";
			// 
			// chkReports10
			// 
			this.chkReports10.Location = new System.Drawing.Point(296, 504);
			this.chkReports10.Name = "chkReports10";
			this.chkReports10.Size = new System.Drawing.Size(128, 16);
			this.chkReports10.TabIndex = 56;
			this.chkReports10.Text = "Get Daily ADO";
			this.chkReports10.Visible = false;
			// 
			// chkReports9
			// 
			this.chkReports9.Location = new System.Drawing.Point(696, 332);
			this.chkReports9.Name = "chkReports9";
			this.chkReports9.Size = new System.Drawing.Size(128, 16);
			this.chkReports9.TabIndex = 55;
			this.chkReports9.Text = "StopCode Count";
			// 
			// chkReports7
			// 
			this.chkReports7.Location = new System.Drawing.Point(696, 276);
			this.chkReports7.Name = "chkReports7";
			this.chkReports7.Size = new System.Drawing.Size(128, 16);
			this.chkReports7.TabIndex = 54;
			this.chkReports7.Text = "Specific Solutions";
			// 
			// chkReports6
			// 
			this.chkReports6.Location = new System.Drawing.Point(696, 248);
			this.chkReports6.Name = "chkReports6";
			this.chkReports6.Size = new System.Drawing.Size(128, 16);
			this.chkReports6.TabIndex = 53;
			this.chkReports6.Text = "Anon Uploads";
			this.chkReports6.CheckedChanged += new System.EventHandler(this.chkReports6_CheckedChanged);
			// 
			// chkReports5
			// 
			this.chkReports5.Location = new System.Drawing.Point(696, 388);
			this.chkReports5.Name = "chkReports5";
			this.chkReports5.Size = new System.Drawing.Size(128, 16);
			this.chkReports5.TabIndex = 52;
			this.chkReports5.Text = "Archive Count";
			// 
			// chkReports4
			// 
			this.chkReports4.Location = new System.Drawing.Point(696, 360);
			this.chkReports4.Name = "chkReports4";
			this.chkReports4.Size = new System.Drawing.Size(128, 16);
			this.chkReports4.TabIndex = 51;
			this.chkReports4.Text = "Watson Count";
			// 
			// chkReports3
			// 
			this.chkReports3.Location = new System.Drawing.Point(696, 220);
			this.chkReports3.Name = "chkReports3";
			this.chkReports3.Size = new System.Drawing.Size(128, 16);
			this.chkReports3.TabIndex = 50;
			this.chkReports3.Text = "Cutomer Count";
			this.chkReports3.CheckedChanged += new System.EventHandler(this.chkReports3_CheckedChanged);
			// 
			// chkReports2
			// 
			this.chkReports2.Location = new System.Drawing.Point(288, 488);
			this.chkReports2.Name = "chkReports2";
			this.chkReports2.Size = new System.Drawing.Size(128, 16);
			this.chkReports2.TabIndex = 49;
			this.chkReports2.Text = "Get Daily Plus 1";
			this.chkReports2.Visible = false;
			// 
			// chkReports1
			// 
			this.chkReports1.Location = new System.Drawing.Point(696, 192);
			this.chkReports1.Name = "chkReports1";
			this.chkReports1.Size = new System.Drawing.Size(128, 16);
			this.chkReports1.TabIndex = 48;
			this.chkReports1.Text = "Get Daily";
			this.chkReports1.CheckedChanged += new System.EventHandler(this.chkReports1_CheckedChanged);
			// 
			// monthCalendar1
			// 
			this.monthCalendar1.Location = new System.Drawing.Point(688, 24);
			this.monthCalendar1.Name = "monthCalendar1";
			this.monthCalendar1.TabIndex = 61;
			// 
			// statusBar1
			// 
			this.statusBar1.Location = new System.Drawing.Point(0, 559);
			this.statusBar1.Name = "statusBar1";
			this.statusBar1.Size = new System.Drawing.Size(896, 22);
			this.statusBar1.TabIndex = 63;
			// 
			// progressBar1
			// 
			this.progressBar1.Location = new System.Drawing.Point(504, 552);
			this.progressBar1.Name = "progressBar1";
			this.progressBar1.Size = new System.Drawing.Size(384, 23);
			this.progressBar1.TabIndex = 64;
			this.progressBar1.Visible = false;
			// 
			// lblPurpose
			// 
			this.lblPurpose.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.lblPurpose.Location = new System.Drawing.Point(16, 8);
			this.lblPurpose.Name = "lblPurpose";
			this.lblPurpose.Size = new System.Drawing.Size(112, 24);
			this.lblPurpose.TabIndex = 78;
			this.lblPurpose.Text = "Purpose";
			// 
			// lblStatement
			// 
			this.lblStatement.Location = new System.Drawing.Point(16, 40);
			this.lblStatement.Name = "lblStatement";
			this.lblStatement.Size = new System.Drawing.Size(632, 40);
			this.lblStatement.TabIndex = 77;
			this.lblStatement.Text = @"The purpose of the following report is to gauge the overall condition and status of  the Windows Online Crash Analysis Web site. Through the use of SQL queries and  file counts it should be possible to generate a high level understanding of Web  site traffic, type of submissions and solution status";
			// 
			// tabControl1
			// 
			this.tabControl1.Controls.AddRange(new System.Windows.Forms.Control[] {
																					  this.tabPage1,
																					  this.tabPage2,
																					  this.tabPage3});
			this.tabControl1.Location = new System.Drawing.Point(16, 96);
			this.tabControl1.Name = "tabControl1";
			this.tabControl1.SelectedIndex = 0;
			this.tabControl1.Size = new System.Drawing.Size(656, 432);
			this.tabControl1.TabIndex = 83;
			// 
			// tabPage1
			// 
			this.tabPage1.Controls.AddRange(new System.Windows.Forms.Control[] {
																				   this.axMSChart1});
			this.tabPage1.Location = new System.Drawing.Point(4, 22);
			this.tabPage1.Name = "tabPage1";
			this.tabPage1.Size = new System.Drawing.Size(648, 406);
			this.tabPage1.TabIndex = 0;
			this.tabPage1.Text = "Graphical";
			// 
			// axMSChart1
			// 
			this.axMSChart1.ContainingControl = this;
			this.axMSChart1.DataSource = null;
			this.axMSChart1.Location = new System.Drawing.Point(8, 8);
			this.axMSChart1.Name = "axMSChart1";
			this.axMSChart1.OcxState = ((System.Windows.Forms.AxHost.State)(resources.GetObject("axMSChart1.OcxState")));
			this.axMSChart1.Size = new System.Drawing.Size(632, 392);
			this.axMSChart1.TabIndex = 66;
			// 
			// tabPage2
			// 
			this.tabPage2.Controls.AddRange(new System.Windows.Forms.Control[] {
																				   this.lblAD,
																				   this.label14,
																				   this.lblWA,
																				   this.label13,
																				   this.lblArchiveMiniCount,
																				   this.lblWatsonMiniCount,
																				   this.lblArchiveCount,
																				   this.lblWatsonCount,
																				   this.lblStopCodeCount,
																				   this.label22,
																				   this.label23,
																				   this.label24,
																				   this.label25,
																				   this.label26,
																				   this.lblGeneralSolutions,
																				   this.lblSpecificCount,
																				   this.lblAnonymousCount,
																				   this.lblCustomerCount,
																				   this.lblDailyCount,
																				   this.label11,
																				   this.label10,
																				   this.label9,
																				   this.label8,
																				   this.label7});
			this.tabPage2.Location = new System.Drawing.Point(4, 22);
			this.tabPage2.Name = "tabPage2";
			this.tabPage2.Size = new System.Drawing.Size(648, 406);
			this.tabPage2.TabIndex = 1;
			this.tabPage2.Text = "Statistical";
			// 
			// lblAD
			// 
			this.lblAD.Location = new System.Drawing.Point(136, 296);
			this.lblAD.Name = "lblAD";
			this.lblAD.Size = new System.Drawing.Size(152, 16);
			this.lblAD.TabIndex = 23;
			// 
			// label14
			// 
			this.label14.Location = new System.Drawing.Point(24, 296);
			this.label14.Name = "label14";
			this.label14.Size = new System.Drawing.Size(104, 16);
			this.label14.TabIndex = 22;
			this.label14.Text = "A-D:";
			this.label14.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// lblWA
			// 
			this.lblWA.Location = new System.Drawing.Point(136, 272);
			this.lblWA.Name = "lblWA";
			this.lblWA.Size = new System.Drawing.Size(152, 16);
			this.lblWA.TabIndex = 21;
			// 
			// label13
			// 
			this.label13.Location = new System.Drawing.Point(24, 272);
			this.label13.Name = "label13";
			this.label13.Size = new System.Drawing.Size(104, 16);
			this.label13.TabIndex = 20;
			this.label13.Text = "W-A:";
			this.label13.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// lblArchiveMiniCount
			// 
			this.lblArchiveMiniCount.Location = new System.Drawing.Point(136, 248);
			this.lblArchiveMiniCount.Name = "lblArchiveMiniCount";
			this.lblArchiveMiniCount.Size = new System.Drawing.Size(152, 16);
			this.lblArchiveMiniCount.TabIndex = 19;
			// 
			// lblWatsonMiniCount
			// 
			this.lblWatsonMiniCount.Location = new System.Drawing.Point(136, 224);
			this.lblWatsonMiniCount.Name = "lblWatsonMiniCount";
			this.lblWatsonMiniCount.Size = new System.Drawing.Size(152, 16);
			this.lblWatsonMiniCount.TabIndex = 18;
			// 
			// lblArchiveCount
			// 
			this.lblArchiveCount.Location = new System.Drawing.Point(136, 200);
			this.lblArchiveCount.Name = "lblArchiveCount";
			this.lblArchiveCount.Size = new System.Drawing.Size(152, 16);
			this.lblArchiveCount.TabIndex = 17;
			// 
			// lblWatsonCount
			// 
			this.lblWatsonCount.Location = new System.Drawing.Point(136, 176);
			this.lblWatsonCount.Name = "lblWatsonCount";
			this.lblWatsonCount.Size = new System.Drawing.Size(152, 16);
			this.lblWatsonCount.TabIndex = 16;
			// 
			// lblStopCodeCount
			// 
			this.lblStopCodeCount.Location = new System.Drawing.Point(136, 152);
			this.lblStopCodeCount.Name = "lblStopCodeCount";
			this.lblStopCodeCount.Size = new System.Drawing.Size(152, 16);
			this.lblStopCodeCount.TabIndex = 15;
			// 
			// label22
			// 
			this.label22.Location = new System.Drawing.Point(24, 248);
			this.label22.Name = "label22";
			this.label22.Size = new System.Drawing.Size(104, 16);
			this.label22.TabIndex = 14;
			this.label22.Text = "Archive Mini Count";
			this.label22.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// label23
			// 
			this.label23.Location = new System.Drawing.Point(24, 224);
			this.label23.Name = "label23";
			this.label23.Size = new System.Drawing.Size(104, 16);
			this.label23.TabIndex = 13;
			this.label23.Text = "Watson Mini Count";
			this.label23.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// label24
			// 
			this.label24.Location = new System.Drawing.Point(24, 200);
			this.label24.Name = "label24";
			this.label24.Size = new System.Drawing.Size(104, 16);
			this.label24.TabIndex = 12;
			this.label24.Text = "Archive Count";
			this.label24.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// label25
			// 
			this.label25.Location = new System.Drawing.Point(24, 176);
			this.label25.Name = "label25";
			this.label25.Size = new System.Drawing.Size(104, 16);
			this.label25.TabIndex = 11;
			this.label25.Text = "Watson Count";
			this.label25.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// label26
			// 
			this.label26.Location = new System.Drawing.Point(24, 152);
			this.label26.Name = "label26";
			this.label26.Size = new System.Drawing.Size(104, 16);
			this.label26.TabIndex = 10;
			this.label26.Text = "StopCode Count:";
			this.label26.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// lblGeneralSolutions
			// 
			this.lblGeneralSolutions.Location = new System.Drawing.Point(136, 128);
			this.lblGeneralSolutions.Name = "lblGeneralSolutions";
			this.lblGeneralSolutions.Size = new System.Drawing.Size(152, 16);
			this.lblGeneralSolutions.TabIndex = 9;
			// 
			// lblSpecificCount
			// 
			this.lblSpecificCount.Location = new System.Drawing.Point(136, 104);
			this.lblSpecificCount.Name = "lblSpecificCount";
			this.lblSpecificCount.Size = new System.Drawing.Size(152, 16);
			this.lblSpecificCount.TabIndex = 8;
			// 
			// lblAnonymousCount
			// 
			this.lblAnonymousCount.Location = new System.Drawing.Point(136, 80);
			this.lblAnonymousCount.Name = "lblAnonymousCount";
			this.lblAnonymousCount.Size = new System.Drawing.Size(152, 16);
			this.lblAnonymousCount.TabIndex = 7;
			// 
			// lblCustomerCount
			// 
			this.lblCustomerCount.Location = new System.Drawing.Point(136, 56);
			this.lblCustomerCount.Name = "lblCustomerCount";
			this.lblCustomerCount.Size = new System.Drawing.Size(152, 16);
			this.lblCustomerCount.TabIndex = 6;
			// 
			// lblDailyCount
			// 
			this.lblDailyCount.Location = new System.Drawing.Point(136, 32);
			this.lblDailyCount.Name = "lblDailyCount";
			this.lblDailyCount.Size = new System.Drawing.Size(152, 16);
			this.lblDailyCount.TabIndex = 5;
			// 
			// label11
			// 
			this.label11.Location = new System.Drawing.Point(24, 128);
			this.label11.Name = "label11";
			this.label11.Size = new System.Drawing.Size(104, 16);
			this.label11.TabIndex = 4;
			this.label11.Text = "General Solutions:";
			this.label11.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// label10
			// 
			this.label10.Location = new System.Drawing.Point(24, 104);
			this.label10.Name = "label10";
			this.label10.Size = new System.Drawing.Size(104, 16);
			this.label10.TabIndex = 3;
			this.label10.Text = "Specific Solutions:";
			this.label10.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// label9
			// 
			this.label9.Location = new System.Drawing.Point(24, 80);
			this.label9.Name = "label9";
			this.label9.Size = new System.Drawing.Size(104, 16);
			this.label9.TabIndex = 2;
			this.label9.Text = "Anonymous Count:";
			this.label9.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// label8
			// 
			this.label8.Location = new System.Drawing.Point(24, 56);
			this.label8.Name = "label8";
			this.label8.Size = new System.Drawing.Size(104, 16);
			this.label8.TabIndex = 1;
			this.label8.Text = "Customer Count:";
			this.label8.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// label7
			// 
			this.label7.Location = new System.Drawing.Point(24, 32);
			this.label7.Name = "label7";
			this.label7.Size = new System.Drawing.Size(104, 16);
			this.label7.TabIndex = 0;
			this.label7.Text = "Daily File Count:";
			this.label7.TextAlign = System.Drawing.ContentAlignment.MiddleRight;
			// 
			// tabPage3
			// 
			this.tabPage3.Controls.AddRange(new System.Windows.Forms.Control[] {
																				   this.label5,
																				   this.label6,
																				   this.label4,
																				   this.label3});
			this.tabPage3.Location = new System.Drawing.Point(4, 22);
			this.tabPage3.Name = "tabPage3";
			this.tabPage3.Size = new System.Drawing.Size(648, 406);
			this.tabPage3.TabIndex = 2;
			this.tabPage3.Text = "Notes";
			// 
			// label5
			// 
			this.label5.Location = new System.Drawing.Point(8, 120);
			this.label5.Name = "label5";
			this.label5.Size = new System.Drawing.Size(632, 40);
			this.label5.TabIndex = 86;
			this.label5.Text = "The data contained with the table below describes the files which were uploaded f" +
				"or each respective server and the entries made by the Online Crash Analysis Web " +
				"Site.";
			// 
			// label6
			// 
			this.label6.Font = new System.Drawing.Font("Microsoft Sans Serif", 10F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label6.Location = new System.Drawing.Point(8, 88);
			this.label6.Name = "label6";
			this.label6.Size = new System.Drawing.Size(240, 24);
			this.label6.TabIndex = 85;
			this.label6.Text = "Upload File";
			// 
			// label4
			// 
			this.label4.Location = new System.Drawing.Point(8, 40);
			this.label4.Name = "label4";
			this.label4.Size = new System.Drawing.Size(632, 40);
			this.label4.TabIndex = 84;
			this.label4.Text = "The data below has been compiled for a one week period and is formatted into sepa" +
				"rate tables for readability and general understanding of how the data was graphe" +
				"d.";
			// 
			// label3
			// 
			this.label3.Font = new System.Drawing.Font("Microsoft Sans Serif", 10F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label3.Location = new System.Drawing.Point(8, 16);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(240, 24);
			this.label3.TabIndex = 83;
			this.label3.Text = "Site Data";
			// 
			// chkSelectAll
			// 
			this.chkSelectAll.Location = new System.Drawing.Point(696, 472);
			this.chkSelectAll.Name = "chkSelectAll";
			this.chkSelectAll.Size = new System.Drawing.Size(128, 16);
			this.chkSelectAll.TabIndex = 84;
			this.chkSelectAll.Text = "Select All";
			this.chkSelectAll.CheckedChanged += new System.EventHandler(this.chkSelectAll_CheckedChanged);
			// 
			// frmDaily
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(896, 581);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.chkSelectAll,
																		  this.progressBar1,
																		  this.tabControl1,
																		  this.lblPurpose,
																		  this.lblStatement,
																		  this.statusBar1,
																		  this.monthCalendar1,
																		  this.chkReports13,
																		  this.chkReports12,
																		  this.chkReports11,
																		  this.chkReports8,
																		  this.chkReports10,
																		  this.chkReports9,
																		  this.chkReports7,
																		  this.chkReports6,
																		  this.chkReports5,
																		  this.chkReports4,
																		  this.chkReports3,
																		  this.chkReports2,
																		  this.chkReports1});
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.Name = "frmDaily";
			this.Text = "Executive Summary Daily Report";
			this.Resize += new System.EventHandler(this.frmDaily_Resize);
			this.Closing += new System.ComponentModel.CancelEventHandler(this.frmDaily_Closing);
			this.Load += new System.EventHandler(this.frmDaily_Load);
			this.tabControl1.ResumeLayout(false);
			this.tabPage1.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.axMSChart1)).EndInit();
			this.tabPage2.ResumeLayout(false);
			this.tabPage3.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion
		
		
		/*************************************************************************************
		*	module: frmDaily.cs - cmdGetData_Click
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: Executes code depending on which checkboxes were selected.  Initializes 
		*	any threads.  Appropriately sets the legend of the calendar control,
		*	initializes the progress bar, disables the cmdGetData button.  Initializes each
		*	column on the calendar to the appropriated days.  New ThreadStart delegate is created
		*	and each delegate is set to the appropriate day from the end date.  All threads are then
		*	started.
		*************************************************************************************/
		public void GetData()
		{
			int y = 0;
			long lngCount = 0, lngCount2 = 0, lngCount3 = 0;
			long l_AnonUploads = 0;
			long l_WatsonCount = 0, l_ArchiveCount = 0, l_ArchiveSQL = 0;
			long l_WatsonArchive = 0, l_WatsonMini = 0, l_ArchiveMini = 0;
			short rowCount = 0;
			short iCount = 0;
			string strArchive, strWatson;
			OCAData.CCountDailyClass rpt = new OCAData.CCountDailyClass();
			RegistryKey regArchive = Registry.CurrentUser.OpenSubKey("software").OpenSubKey("microsoft", true).CreateSubKey("OCATools").CreateSubKey("OCAReports").CreateSubKey("Archive");
			RegistryKey regWatson = Registry.CurrentUser.OpenSubKey("software").OpenSubKey("microsoft", true).CreateSubKey("OCATools").CreateSubKey("OCAReports").CreateSubKey("Watson");
			System.DateTime dDate = new System.DateTime(monthCalendar1.SelectionStart.Year, monthCalendar1.SelectionStart.Month, 
				monthCalendar1.SelectionStart.Day);
		
			

			progressBar1.Minimum = 0;
			progressBar1.Maximum = 16;
			progressBar1.Value = 0;
			progressBar1.Visible = true;
			progressBar1.Value = progressBar1.Value + 1;
			progressBar1.Refresh();
			this.Refresh();
			//11111111111111111111111111111111111111111
			if(chkReports1.Checked == true)
			{
				iCount++;
				rowCount++;
				statusBar1.Text = "Getting Daily Count for " + dDate.Date.ToString();
				lngCount = rpt.GetDailyCount(dDate);
				axMSChart1.RowCount = rowCount;
				axMSChart1.Row = iCount;
				axMSChart1.RowLabel = "Daily";
				axMSChart1.Data = lngCount.ToString();
				lblDailyCount.Text = lngCount.ToString();
			}
			progressBar1.Value = progressBar1.Value + 1;
			progressBar1.Refresh();
			this.Refresh();
			//222222222222222222222222222222222222222222
			if(chkReports2.Checked == true)
			{
				iCount++;
				rowCount++;
				statusBar1.Text = "Getting Daily Count for " + dDate.AddDays(-1).Date.ToString();
				lngCount2 = rpt.GetDailyCount(dDate);
				axMSChart1.RowCount = rowCount;
				axMSChart1.Row = iCount;
				axMSChart1.RowLabel = dDate.Date.ToString();
				axMSChart1.Data = lngCount2.ToString();
			}

			//**************************************************************


			progressBar1.Value = progressBar1.Value + 1;
			progressBar1.Refresh();
			this.Refresh();
			//3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 
			//'6 6 6 6 6 6 6 6 6 6 6 6 6 6 6 
			if(chkReports6.Checked == true)
			{
				iCount++;
				rowCount++;
				statusBar1.Text = "Getting Anon Users for " + dDate.Date.ToString();
				l_AnonUploads = rpt.GetDailyAnon(dDate);
				axMSChart1.RowCount = rowCount;
				axMSChart1.Row = iCount;
				axMSChart1.RowLabel = "Anon"; //+ dDate.Date.ToString();
				axMSChart1.Data = l_AnonUploads.ToString();
				lblAnonymousCount.Text = l_AnonUploads.ToString();
			}
			progressBar1.Value = progressBar1.Value + 1;
			progressBar1.Refresh();
			this.Refresh();
			if(chkReports3.Checked == true)
			{
				iCount++;
				rowCount++;
				statusBar1.Text = "Calculating Customer Count for " + dDate.Date.ToString();
				if(l_AnonUploads > lngCount) 
				{
					lngCount = l_AnonUploads - lngCount;
				}
				else
				{
					lngCount = lngCount - l_AnonUploads;
				}
				axMSChart1.RowCount = rowCount;
				axMSChart1.Row = iCount;
				axMSChart1.RowLabel = "Cust"; //& dDate.Date.ToString();
				axMSChart1.Data = lngCount.ToString();
				lblCustomerCount.Text = lngCount.ToString();
			}
			progressBar1.Value = progressBar1.Value + 1;
			progressBar1.Refresh();
			this.Refresh();
			//10 10 10 10 10 10 10 10 10
			if(chkReports10.Checked == true)
			{
				iCount++;
				rowCount++;
				statusBar1.Text = "Getting Daily Count for " + dDate.Date.ToString() + " through ADO";
				lngCount3 = rpt.GetDailyCountADO(dDate);
				axMSChart1.RowCount = rowCount;
				axMSChart1.Row = iCount;
				axMSChart1.RowLabel = dDate.AddDays(-1).Date.ToString();
				axMSChart1.Data = lngCount3.ToString();
			}
			progressBar1.Value = progressBar1.Value + 1;
			progressBar1.Refresh();
			this.Refresh();

			//'4 4 4 4 4 4 4 4 4 4 4 4 4 4 4
			if(chkReports4.Checked == true)
			{
				iCount++;
				rowCount++;
				statusBar1.Text = "Getting Watson file count for " + dDate.Date.ToString();
#if(FILE_SERVER)
//				l_WatsonCount = rpt.GetFileCount(OCAData.ServerLocation.Watson, "Z:\\\\", dDate);
				for(y = 0;y < 10; y++)
				{
					if(regWatson.GetValue("Loc" + y.ToString()).ToString().Length > 0)
					{
						strWatson = regWatson.GetValue("Loc" + y.ToString()).ToString();
						l_WatsonCount = rpt.GetFileCount(OCAData.ServerLocation.Watson, strWatson, dDate);
						if(l_WatsonCount > 0)
						{
							y = 10;
						}
					}
					else
					{
						l_WatsonCount = 0;
					}
				}

#elif(FILE_LOCAL)
				l_WatsonCount = rpt.GetFileCount(OCAData.ServerLocation.Watson, "C:\\\\MiniDumps\\Watson\\", dDate);
#endif
				axMSChart1.RowCount = rowCount;
				axMSChart1.Row = iCount;
				axMSChart1.RowLabel = "Watson";
				axMSChart1.Data = l_WatsonCount.ToString();
				lblWatsonCount.Text = l_WatsonCount.ToString();
			}

			progressBar1.Value = progressBar1.Value + 1;
			progressBar1.Refresh();
			this.Refresh();
			//'5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5 5
			if(chkReports5.Checked == true)
			{
				iCount++;
				rowCount++;
				statusBar1.Text = "Getting Archive file count for " + dDate.Date.ToString();
#if(FILE_SERVER)
//				l_ArchiveCount = rpt.GetFileCount(OCAData.ServerLocation.Archive, "Y:\\\\", dDate);
				try
				{
					for(y = 0;y < 10; y++)
					{
						if(regArchive.GetValue("Loc" + y.ToString()).ToString().Length > 0)
						{
							strArchive = regArchive.GetValue("Loc" + y.ToString()).ToString();
							l_ArchiveCount = rpt.GetFileCount(OCAData.ServerLocation.Archive, strArchive, dDate);
							if(l_ArchiveCount > 0)
							{
								y = 10;
							}
						}
						else
						{
							l_ArchiveCount = 0;
						}
					}
					//l_ArchiveCount = rpt.GetFileCount(OCAData.ServerLocation.Archive, "Y:\\", dDate.AddDays(x));
				}
				catch
				{
					l_ArchiveCount = 0;
				}
#elif(FILE_LOCAL)
				l_ArchiveCount = rpt.GetFileCount(OCAData.ServerLocation.Archive, "C:\\\\MiniDumps\\Archive\\", dDate);
#endif
//				if(l_ArchiveCount == 0)
//				{
//#if(FILE_SERVER)
//					l_ArchiveCount = rpt.GetFileCount(OCAData.ServerLocation.Archive, "X:\\\\", dDate);
//#elif(FILE_LOCAL)
//				l_ArchiveCount = rpt.GetFileCount(OCAData.ServerLocation.Archive, "C:\\\\MiniDumps\\Archive\\", dDate);
//#endif
//				}
				axMSChart1.RowCount = rowCount;
				axMSChart1.Row = iCount;
				axMSChart1.RowLabel = "Archive";
				axMSChart1.Data = l_ArchiveCount.ToString();
				lblArchiveCount.Text = l_ArchiveCount.ToString();
			}
			progressBar1.Value = progressBar1.Value + 1;
			progressBar1.Refresh();
			this.Refresh();
			//'5 1 5 1 5 1 5 1 5 1 5 1
			if(chkReports5.Checked == true && chkReports1.Checked == true)
			{
				iCount++;
				rowCount++;
				if(l_ArchiveCount > lngCount)
				{
					l_ArchiveSQL = l_ArchiveCount - lngCount;
				}
				else
				{
					l_ArchiveSQL = lngCount - l_ArchiveCount;
				}
				axMSChart1.RowCount = rowCount;
				axMSChart1.Row = iCount;
				axMSChart1.RowLabel = "A - D";
				axMSChart1.Data = l_ArchiveSQL.ToString();
				lblAD.Text = l_ArchiveSQL.ToString();
			}
			progressBar1.Value = progressBar1.Value + 1;
			progressBar1.Refresh();
			this.Refresh();
			//'5 4 5 4 5 4 5 4 5 4 5 4
			if(chkReports5.Checked == true && chkReports4.Checked == true)
			{
				iCount++;
				rowCount++;
				if(l_WatsonCount > l_ArchiveCount)
				{
					l_WatsonArchive = l_WatsonCount - l_ArchiveCount;
				}
				else
				{
					l_WatsonArchive = l_ArchiveCount - l_WatsonArchive;
				}
				axMSChart1.RowCount = rowCount;
				axMSChart1.Row = iCount;
				axMSChart1.RowLabel = "W - A";
				axMSChart1.Data = l_WatsonArchive.ToString();
				lblWA.Text = l_WatsonArchive.ToString();

			}
			progressBar1.Value = progressBar1.Value + 1;
			progressBar1.Refresh();
			this.Refresh();

			//12 12 12 12 12 12 12 12 12 12 12 12 12
			if(chkReports12.Checked == true)
			{
				iCount++;
				rowCount++;
#if(FILE_SERVER)
				l_WatsonMini = rpt.GetFileMiniCount(OCAData.ServerLocation.Watson, "Z:\\", dDate);
#elif(FILE_LOCAL)
				l_WatsonMini = rpt.GetFileMiniCount(OCAData.ServerLocation.Watson, "C:\\\\MiniDumps\\Watson\\", dDate);
#endif
				axMSChart1.RowCount = rowCount;
				axMSChart1.Row = iCount;
				axMSChart1.RowLabel = "W Mini";
				axMSChart1.Data = l_WatsonMini.ToString();
				lblWatsonMiniCount.Text = l_WatsonMini.ToString();
			}

			progressBar1.Value = progressBar1.Value + 1;
			progressBar1.Refresh();
			this.Refresh();
			//13 13 13 13 13 13 13 13 13 13 13 13 13 
			if(chkReports13.Checked == true)
			{
				iCount++;
				rowCount++;
#if(FILE_SERVER)
				l_ArchiveMini = rpt.GetFileMiniCount(OCAData.ServerLocation.Archive, "Y:\\", dDate);
#elif(FILE_LOCAL)
				l_WatsonMini = rpt.GetFileMiniCount(OCAData.ServerLocation.Archive, "C:\\\\MiniDumps\\Archive\\", dDate);
#endif
				if(l_ArchiveMini == 0)
				{
#if(FILE_SERVER)
					l_ArchiveMini = rpt.GetFileMiniCount(OCAData.ServerLocation.Archive, "X:\\", dDate);
#elif(FILE_LOCAL)
				l_WatsonMini = rpt.GetFileMiniCount(OCAData.ServerLocation.Archive, "C:\\\\MiniDumps\\Archive\\", dDate);
#endif
				}
				axMSChart1.RowCount = rowCount;
				axMSChart1.Row = iCount;
				axMSChart1.RowLabel = "A Mini";
				axMSChart1.Data = l_ArchiveMini.ToString();
				lblArchiveMiniCount.Text = l_ArchiveMini.ToString();
			}


			//'7 7 7 7 7 7 7 7 7 7 7 7 7 7
			if(chkReports7.Checked == true)
			{
				iCount++;
				rowCount++;
				statusBar1.Text = "Getting Specific Solutions Count for " + dDate.Date.ToString();
				ThreadStart s_StartSBucket = new ThreadStart(this.GetSBuckets);
				t_ThreadSBucket = new Thread(s_StartSBucket);
				t_ThreadSBucket.Name = "Thread One";
				t_ThreadSBucket.Start();
			}

			//'8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 8 
			if(chkReports8.Checked == true)
			{
				iCount++;
				rowCount++;
				statusBar1.Text = "Getting General Solutions Count for " + dDate.Date.ToString();
				ThreadStart t_StartGBucket = new ThreadStart(this.GetGBuckets);
				t_ThreadGBucket = new Thread(t_StartGBucket);
				t_ThreadGBucket.Name = "Thread Two";
				t_ThreadGBucket.Start();
			}
			progressBar1.Value = progressBar1.Value + 1;
			progressBar1.Refresh();
			this.Refresh();
			//        '9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 9 
			if(chkReports9.Checked == true)
			{
				iCount++;
				rowCount++;
				statusBar1.Text = "Getting StopCode Solutions Count for " + dDate.Date.ToString();
				ThreadStart t_StartStopCode = new ThreadStart(this.GetStopCode);
				t_ThreadStopCode = new Thread(t_StartStopCode);
				t_ThreadStopCode.Name = "Thread Three";

				t_ThreadStopCode.Start();
				
			}
		
			progressBar1.Value = progressBar1.Value + 1;
			progressBar1.Refresh();
			this.Refresh();


			//**************************************************************************
			axMSChart1.Refresh();
			progressBar1.Visible = false;
			statusBar1.Text = "Done";
			this.ParentForm.Refresh();

		}
		private void GetStopCode()
		{
			long l_StopCodeReports = 0;
			OCAData.CCountDailyClass rpt = new OCAData.CCountDailyClass();
			System.DateTime dDate = new System.DateTime(monthCalendar1.SelectionStart.Year, monthCalendar1.SelectionStart.Month, 
				monthCalendar1.SelectionStart.Day);

			l_StopCodeReports = rpt.GetStopCodeSolutions(dDate);
			if(t_ThreadGBucket != null)
			{
				if(t_ThreadGBucket.IsAlive == true)
				{
					t_ThreadGBucket.Suspend();
				}
			}
			if(t_ThreadSBucket != null)
			{
				if(t_ThreadSBucket.IsAlive == true)
				{
					t_ThreadSBucket.Suspend();
				}
			}
			lock(this)
			{
				axMSChart1.RowCount = (short)(axMSChart1.RowCount + 1);
				axMSChart1.Row = (short)(axMSChart1.Row + 1);
				axMSChart1.RowLabel = "Stop Code";
				axMSChart1.Data = l_StopCodeReports.ToString();
				lblStopCodeCount.Text = l_StopCodeReports.ToString();
				progressBar1.Value = progressBar1.Value + 1;
				progressBar1.Refresh();
				this.Refresh();
			}

			if(t_ThreadGBucket != null)
			{
				if(t_ThreadGBucket.IsAlive == true)
				{
					t_ThreadGBucket.Resume();
				}
			}
			if(t_ThreadSBucket != null)
			{
				if(t_ThreadSBucket.IsAlive == true)
				{
					t_ThreadSBucket.Resume();
				}
			}
		}

		private void GetGBuckets()
		{
			long l_SpecificReports = 0;
			OCAData.CCountDailyClass rpt = new OCAData.CCountDailyClass();
			System.DateTime dDate = new System.DateTime(monthCalendar1.SelectionStart.Year, monthCalendar1.SelectionStart.Month, 
				monthCalendar1.SelectionStart.Day);

			l_SpecificReports = rpt.GetGeneralSolutions(dDate);
			if(t_ThreadStopCode != null)
			{
				if(t_ThreadStopCode.IsAlive == true)
				{
					t_ThreadStopCode.Suspend();
				}
			}
			if(t_ThreadSBucket != null)
			{
				if(t_ThreadSBucket.IsAlive == true)
				{
					t_ThreadSBucket.Suspend();
				}
			}
			lock(this)
			{
				axMSChart1.RowCount = (short)(axMSChart1.RowCount + 1);
				axMSChart1.Row = (short)(axMSChart1.Row + 1);
				axMSChart1.RowLabel = "General";
				axMSChart1.Data = l_SpecificReports.ToString();
				lblGeneralSolutions.Text = l_SpecificReports.ToString();
				progressBar1.Value = progressBar1.Value + 1;
				progressBar1.Refresh();
				this.Refresh();
			}

			if(t_ThreadStopCode != null)
			{
				if(t_ThreadStopCode.IsAlive == true)
				{
					t_ThreadStopCode.Resume();
				}
			}
			if(t_ThreadSBucket != null)
			{
				if(t_ThreadSBucket.IsAlive == true)
				{
					t_ThreadSBucket.Resume();
				}
			}
		}

		private void GetSBuckets()
		{
			long l_SpecificReports = 0;
			OCAData.CCountDailyClass rpt = new OCAData.CCountDailyClass();
			System.DateTime dDate = new System.DateTime(monthCalendar1.SelectionStart.Year, monthCalendar1.SelectionStart.Month, 
				monthCalendar1.SelectionStart.Day);

			l_SpecificReports = rpt.GetSpecificSolutions(dDate);
			if(t_ThreadGBucket != null)
			{
				if(t_ThreadGBucket.IsAlive == true)
				{
					t_ThreadGBucket.Suspend();
				}
			}
			if(t_ThreadStopCode != null)
			{
				if(t_ThreadStopCode.IsAlive == true)
				{
					t_ThreadStopCode.Suspend();
				}
			}
			lock(this)
			{
				axMSChart1.RowCount = (short)(axMSChart1.RowCount + 1);
				axMSChart1.Row = (short)(axMSChart1.Row + 1);
				axMSChart1.RowLabel = "Specific";
				axMSChart1.Data = l_SpecificReports.ToString();
				lblSpecificCount.Text = l_SpecificReports.ToString();
				progressBar1.Value = progressBar1.Value + 1;
				progressBar1.Refresh();
				this.Refresh();
			}
			if(t_ThreadGBucket != null)
			{
				if(t_ThreadGBucket.IsAlive == true)
				{
					t_ThreadGBucket.Resume();
				}
			}
			if(t_ThreadStopCode != null)
			{
				if(t_ThreadStopCode.IsAlive == true)
				{
					t_ThreadStopCode.Resume();
				}
			}
		}

		private void UpdateStatus()
		{
			progressBar1.Value = progressBar1.Value + 1;
			axMSChart1.Refresh();
			progressBar1.Refresh();
			if(progressBar1.Value >= 28)
			{
				statusBar1.Text = "Done";
				progressBar1.Visible = false;
//				cmdGetData.Enabled = true;
			}

		}

		private void frmDaily_Load(object sender, System.EventArgs e)
		{
			DateTime dDate = DateTime.Today;
			
			monthCalendar1.SelectionEnd = dDate.AddDays(-1);
			this.ParentForm.Refresh();
		}


		private void chkReports6_CheckedChanged(object sender, System.EventArgs e)
		{
			if(chkReports6.Checked == false)
			{
				chkReports3.Checked = false;
			}
		}



		private void chkReports1_CheckedChanged(object sender, System.EventArgs e)
		{
			if(chkReports1.Checked == false)
			{
				chkReports3.Checked = false;
			}
		}

		private void chkReports3_CheckedChanged(object sender, System.EventArgs e)
		{
			if(chkReports3.Checked == true)
			{
				chkReports6.Checked = true;
				chkReports1.Checked = true;
			}

		}
		/*************************************************************************************
		*	module: frmDaily.cs - frmDaily_Resize
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: Adjust the controls and graph if the form is resized.
		*	
		*	
		*************************************************************************************/
		private void frmDaily_Resize(object sender, System.EventArgs e)
		{
			int buf = 20;

			progressBar1.Top = statusBar1.Top;
			progressBar1.Left = this.Width - progressBar1.Width;
			monthCalendar1.Left = this.Width - (monthCalendar1.Width + buf);
//			cmdGetData.Left = monthCalendar1.Left;
			tabControl1.Width = this.Width - (monthCalendar1.Width + (buf * 3));
			tabControl1.Height = this.Height - (statusBar1.Height + lblPurpose.Height + lblStatement.Height + (buf * 4));
			axMSChart1.Height = tabPage1.Height - buf;
			axMSChart1.Width = tabPage1.Width - buf;

			chkReports1.Left = monthCalendar1.Left;
			chkReports3.Left = monthCalendar1.Left;
			chkReports6.Left = monthCalendar1.Left;
			chkReports7.Left = monthCalendar1.Left;
			chkReports8.Left = monthCalendar1.Left;
			chkReports9.Left = monthCalendar1.Left;
			chkReports4.Left = monthCalendar1.Left;
			chkReports5.Left = monthCalendar1.Left;
			chkReports12.Left = monthCalendar1.Left;
			chkReports13.Left = monthCalendar1.Left;
		}

		/*************************************************************************************
		*	module: frmDaily.cs - frmDaily_Closing
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: If any threads are still  alive meaning the user prematurely closes the form
		*	before all threads are returned then the threads are checked to see if they are still
		*	running and if so then the thread is aborted.
		*************************************************************************************/
		private void frmDaily_Closing(object sender, System.ComponentModel.CancelEventArgs e)
		{
			if(t_ThreadSBucket != null)
			{
				if(t_ThreadSBucket.IsAlive)
				{
					t_ThreadSBucket.Abort();
				}
			}
			if(t_ThreadGBucket != null)
			{
				if(t_ThreadGBucket.IsAlive)
				{
					t_ThreadGBucket.Abort();
				}
			}
			if(t_ThreadStopCode != null)
			{
				if(t_ThreadStopCode.IsAlive)
				{
					t_ThreadStopCode.Abort();
				}
			}
		}

		private void chkSelectAll_CheckedChanged(object sender, System.EventArgs e)
		{
			if(chkSelectAll.Checked == true)
			{
				chkReports1.Checked = true;
				chkReports3.Checked = true;
				chkReports6.Checked = true;
				chkReports7.Checked = true;
				chkReports8.Checked = true;
				chkReports9.Checked = true;
				chkReports4.Checked = true;
				chkReports5.Checked = true;
				chkReports12.Checked = true;
				chkReports13.Checked = true;
			}
			else
			{
				chkReports1.Checked = false;
				chkReports3.Checked = false;
				chkReports6.Checked = false;
				chkReports7.Checked = false;
				chkReports8.Checked = false;
				chkReports9.Checked = false;
				chkReports4.Checked = false;
				chkReports5.Checked = false;
				chkReports12.Checked = false;
				chkReports13.Checked = false;
			}
	}


	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocareports\frmabout.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace OCAReports
{
	/// <summary>
	/// Summary description for Form2.
	/// </summary>
	public class frmAbout : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Button cmdOK;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.Label label2;
		private System.Windows.Forms.Label label3;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public frmAbout()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(frmAbout));
			this.cmdOK = new System.Windows.Forms.Button();
			this.label1 = new System.Windows.Forms.Label();
			this.label2 = new System.Windows.Forms.Label();
			this.label3 = new System.Windows.Forms.Label();
			this.SuspendLayout();
			// 
			// cmdOK
			// 
			this.cmdOK.Location = new System.Drawing.Point(168, 192);
			this.cmdOK.Name = "cmdOK";
			this.cmdOK.TabIndex = 0;
			this.cmdOK.Text = "&OK";
			this.cmdOK.Click += new System.EventHandler(this.cmdOK_Click);
			// 
			// label1
			// 
			this.label1.Font = new System.Drawing.Font("Microsoft Sans Serif", 18F, System.Drawing.FontStyle.Regular, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label1.Location = new System.Drawing.Point(24, 16);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(368, 23);
			this.label1.TabIndex = 1;
			this.label1.Text = "On Line Crash Analysis";
			this.label1.TextAlign = System.Drawing.ContentAlignment.TopCenter;
			// 
			// label2
			// 
			this.label2.Location = new System.Drawing.Point(24, 56);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(368, 16);
			this.label2.TabIndex = 2;
			this.label2.Text = "Created By Tim Ragain V1.0";
			this.label2.TextAlign = System.Drawing.ContentAlignment.TopCenter;
			// 
			// label3
			// 
			this.label3.Location = new System.Drawing.Point(24, 88);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(368, 16);
			this.label3.TabIndex = 3;
			this.label3.Text = "Developed with C# and VC++ Visual Studio 7.0";
			this.label3.TextAlign = System.Drawing.ContentAlignment.TopCenter;
			// 
			// Form2
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(416, 294);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.label3,
																		  this.label2,
																		  this.label1,
																		  this.cmdOK});
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.Name = "Form2";
			this.Text = "About";
			this.ResumeLayout(false);

		}
		#endregion

		private void cmdOK_Click(object sender, System.EventArgs e)
		{
			this.Close();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocareports\frmexport.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Reflection;


namespace OCAReports
{
	/// <summary>
	/// Summary description for frmExport.
	/// </summary>
	public class frmExport : System.Windows.Forms.Form
	{
		private System.Windows.Forms.CheckedListBox checkedListBox1;
		private System.Windows.Forms.Button cmdExcel;
		private System.Windows.Forms.Button cmdDone;
		private System.Windows.Forms.CheckBox chk3DCharts;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public frmExport()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(frmExport));
			this.checkedListBox1 = new System.Windows.Forms.CheckedListBox();
			this.cmdExcel = new System.Windows.Forms.Button();
			this.cmdDone = new System.Windows.Forms.Button();
			this.chk3DCharts = new System.Windows.Forms.CheckBox();
			this.SuspendLayout();
			// 
			// checkedListBox1
			// 
			this.checkedListBox1.Location = new System.Drawing.Point(8, 8);
			this.checkedListBox1.Name = "checkedListBox1";
			this.checkedListBox1.Size = new System.Drawing.Size(344, 229);
			this.checkedListBox1.TabIndex = 0;
			// 
			// cmdExcel
			// 
			this.cmdExcel.Location = new System.Drawing.Point(368, 56);
			this.cmdExcel.Name = "cmdExcel";
			this.cmdExcel.TabIndex = 1;
			this.cmdExcel.Text = "To Excel";
			this.cmdExcel.Click += new System.EventHandler(this.cmdExcel_Click);
			// 
			// cmdDone
			// 
			this.cmdDone.Location = new System.Drawing.Point(368, 16);
			this.cmdDone.Name = "cmdDone";
			this.cmdDone.TabIndex = 2;
			this.cmdDone.Text = "&Done";
			this.cmdDone.Click += new System.EventHandler(this.cmdDone_Click);
			// 
			// chk3DCharts
			// 
			this.chk3DCharts.FlatStyle = System.Windows.Forms.FlatStyle.Flat;
			this.chk3DCharts.Location = new System.Drawing.Point(360, 216);
			this.chk3DCharts.Name = "chk3DCharts";
			this.chk3DCharts.Size = new System.Drawing.Size(88, 16);
			this.chk3DCharts.TabIndex = 3;
			this.chk3DCharts.Text = "3D Charts";
			// 
			// frmExport
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(456, 254);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.chk3DCharts,
																		  this.cmdDone,
																		  this.cmdExcel,
																		  this.checkedListBox1});
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "frmExport";
			this.Text = "Export to Excel";
			this.Load += new System.EventHandler(this.frmExport_Load);
			this.ResumeLayout(false);

		}
		#endregion


		#region ########################Global Variables######################################
		/*************************************************************************************
		*	module: frmAnonCust.cs - Global varibles and objects
		*
		*	author: Tim Ragain
		*	date: Feb 6, 2002
		*
		*	Purpose: All global threads and variables are declared.
		*	
		*************************************************************************************/
		public const string cFRMWEEKLY = "Executive Summary Weekly Report";
		#endregion
		private void frmExport_Load(object sender, System.EventArgs e)
		{
			int x = 0;

			for(x = 0;x <  this.Owner.MdiChildren.Length; x++)
			{
				checkedListBox1.Items.Add(this.Owner.MdiChildren[x].Text, CheckState.Checked);
			}
		}

		private void cmdExcel_Click(object sender, System.EventArgs e)
		{
			object oBlank = "";
			object oType = 1;
			int x = 0, y = 0, z = 0;
			int iWeeklyCount = 0, iWeeklyTitle = 65, iWeeklyFiles = 1 ;
			int iAnonCustCount = 0, iAnonCustTitle = 65, iAnonCustFiles = 1;	//65 - 90
			int iAutoManCount = 0, iAutoManTitle = 65, iAutoManFiles = 1;
			int iSolutionStatusCount = 0, iSolutionStatusTitle = 65, iSolutionStatusFiles = 1;
			char cTitle, cChart, cTitleEnd;
			long lAvgWatson = 0, lAvgArchive = 0, lAvgDaily = 0;
			long lAvgAnon = 0, lAvgCustomer = 0;
			long lAvgMan = 0, lAvgAuto = 0, lAvgNull = 0;
			long lAvgSpecific = 0, lAvgGeneral = 0, lAvgStopCode = 0, lAvgNoSolution = 0;
			
			
			frmWeekly oWeekly;
			frmAnonCust oAnonCust;
			frmAutoMan oAutoMan;
			frmSolutionStatus oSolutionStatus;


			if(this.Owner.MdiChildren.Length < 1)
			{
				MessageBox.Show("There are no reports to generate an Excel spreadsheet", "Generate required reports!", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
				return;
			}
			
			Excel.Application oApp = new Excel.Application();
			Excel.Workbooks oBooks;
			Excel.Workbook oBook;
			Excel.Worksheet oWorkSheet = new Excel.Worksheet();
			Excel.Sheets oSheets;
			Excel.Range oRange, oRangeTitle;
			Excel.ChartObjects oChartObjects;
			Excel.ChartObject oChartObject;
			Excel.Chart oChart;
			Excel.SeriesCollection oSeries;
			Excel.Legend oLegend;
			
			


			object oRow = "B5", oCol = "H5";

			oApp.Visible = true;
			oBooks = (Excel.Workbooks) oApp.Workbooks;
			oBook = oApp.Workbooks.Add(oBlank);
			oBook = (Excel.Workbook) oBooks.get_Item(1);
			oSheets = oBook.Worksheets;
			oWorkSheet = (Excel.Worksheet) oBook.Worksheets["Sheet1"];
			oWorkSheet.Name = "OCA Reports";
			y = 0;
			foreach(Form oForm in this.Owner.MdiChildren)
			{
				
				oChart = null;
				if(this.Owner.MdiChildren[y].Name == "frmSolutionStatus")
				{
					for(z = 0;z < checkedListBox1.CheckedItems.Count;z++)
					{
						if(checkedListBox1.CheckedItems[z].ToString() == oForm.Text)
						{
							oSolutionStatus = (frmSolutionStatus) oForm;
							oWorkSheet.Cells[105, iSolutionStatusFiles] = oSolutionStatus.Text;
							cTitle = (char)iSolutionStatusTitle;
							cTitleEnd = (char)(iSolutionStatusTitle + 4);
							cChart = (char)(iSolutionStatusTitle + 3);
							oRangeTitle = oWorkSheet.get_Range(cTitle + "105", cTitle + "106");
							oRangeTitle.Font.Bold = true;
							oRangeTitle.ColumnWidth = 10;
							oRangeTitle = oWorkSheet.get_Range(cTitle + "106", cTitleEnd + "106");
							oRangeTitle.Font.Bold = true;
							oRangeTitle.ColumnWidth = 10;
							oRangeTitle = oWorkSheet.get_Range(cTitle + "114", cTitle + "114");
							oRangeTitle.Font.Bold = true;
							oRangeTitle.ColumnWidth = 10;

							oWorkSheet.Cells[106, iSolutionStatusFiles] = "Date";
							oWorkSheet.Cells[106, iSolutionStatusFiles + 1] = "S-Bucket";
							oWorkSheet.Cells[106, iSolutionStatusFiles + 2] = "G-Bucket";
							oWorkSheet.Cells[106, iSolutionStatusFiles + 3] = "Stop Code";
							oWorkSheet.Cells[106, iSolutionStatusFiles + 4] = "No Solution";
							oWorkSheet.Cells[114, iSolutionStatusFiles + 0] = "Average";

							lAvgSpecific = 0;
							lAvgGeneral = 0;
							lAvgStopCode = 0;
							lAvgNoSolution = 0;
							for(x = 0; x < 7; x++)
							{
								oWorkSheet.Cells[x + 107, iSolutionStatusFiles + 0] = oSolutionStatus.lDate[x];
								oWorkSheet.Cells[x + 107, iSolutionStatusFiles + 1] = oSolutionStatus.lSpecific[x];
								lAvgSpecific = lAvgSpecific + oSolutionStatus.lSpecific[x];
								oWorkSheet.Cells[x + 107, iSolutionStatusFiles + 2] = oSolutionStatus.lGeneral[x];
								lAvgGeneral = lAvgGeneral + oSolutionStatus.lGeneral[x];
								oWorkSheet.Cells[x + 107, iSolutionStatusFiles + 3] = oSolutionStatus.lStopCode[x];
								lAvgStopCode = lAvgStopCode + oSolutionStatus.lStopCode[x];
								oWorkSheet.Cells[x + 107, iSolutionStatusFiles + 4] = oSolutionStatus.lNoSolution[x];
								lAvgNoSolution = lAvgNoSolution + oSolutionStatus.lNoSolution[x];
							}
							oWorkSheet.Cells[114, iSolutionStatusFiles + 1] = lAvgSpecific / 7;
							oWorkSheet.Cells[114, iSolutionStatusFiles + 2] = lAvgGeneral / 7;
							oWorkSheet.Cells[114, iSolutionStatusFiles + 3] = lAvgStopCode / 7;
							oWorkSheet.Cells[114, iSolutionStatusFiles + 4] = lAvgNoSolution / 7;
							oRange = (Excel.Range) oWorkSheet.Cells[64, 2];

							oChartObjects = (Excel.ChartObjects) oWorkSheet.ChartObjects(Missing.Value);
							oChartObject = oChartObjects.Add(10, 90, 370, 300);
							if(chk3DCharts.Checked == true)
							{
								oChartObject.Chart.Type = (int) Excel.XlChartType.xl3DColumn;
							}
							else
							{
								oChartObject.Chart.Type = (int) 3;//Excel.XlChartType.xl3DColumn;
							}
							oChart = oChartObject.Chart;
							oWorkSheet.Shapes.Item(oWorkSheet.Shapes.Count).Top = 1475;
							if(iSolutionStatusCount > 0)
							{
								oWorkSheet.Shapes.Item(y + 1).Left = 400 * iSolutionStatusCount;
								
							}
							oRange = oWorkSheet.get_Range(cTitle + "106:" + cTitle + "113", cChart + "106:" + cChart + "113");
							oChart.SetSourceData(oRange, Excel.XlRowCol.xlColumns);
							oSeries = (Excel.SeriesCollection) oChart.SeriesCollection(Missing.Value);
							oChart.HasLegend = true;
							oLegend = oChart.Legend;
							oChart.HasTitle = true;
							oChart.ChartTitle.Text = oSolutionStatus.Text;

				
							iSolutionStatusTitle += 8;
							iSolutionStatusFiles += 8;
							iSolutionStatusCount++;

							z = checkedListBox1.Items.Count;
						}
					}

				}
				if(this.Owner.MdiChildren[y].Name == "frmAutoMan")
				{
					oAutoMan = (frmAutoMan) oForm;
					for(z = 0;z < checkedListBox1.CheckedItems.Count;z++)
					{
						if(checkedListBox1.CheckedItems[z].ToString() == oForm.Text)
						{
							oWorkSheet.Cells[70, iAutoManFiles] = oAutoMan.Text;
							cTitle = (char)iAutoManTitle;
							cTitleEnd = (char)(iAutoManTitle + 3);
							cChart = (char)(iAutoManTitle + 2);
							oRangeTitle = oWorkSheet.get_Range(cTitle + "70", cTitle + "71");
							oRangeTitle.Font.Bold = true;
							oRangeTitle.ColumnWidth = 10;
							oRangeTitle = oWorkSheet.get_Range(cTitle + "71", cTitleEnd + "71");
							oRangeTitle.Font.Bold = true;
							oRangeTitle.ColumnWidth = 10;
							oRangeTitle = oWorkSheet.get_Range(cTitle + "79", cTitle + "79");
							oRangeTitle.Font.Bold = true;
							oRangeTitle.ColumnWidth = 10;

							oWorkSheet.Cells[71, iAutoManFiles + 0] = "Date";
							oWorkSheet.Cells[71, iAutoManFiles + 1] = "Manual";
							oWorkSheet.Cells[71, iAutoManFiles + 2] = "Auto";
							oWorkSheet.Cells[79, iAutoManFiles + 0] = "Average";

							if(oAutoMan.chkDatabaseCount.Checked == true)
							{
								oWorkSheet.Cells[71, iAutoManFiles + 3] = "Null Uploads";
							}
							lAvgMan = 0;
							lAvgAuto = 0;
							lAvgNull = 0;
							for(x = 0; x < 7; x++)
							{
								oWorkSheet.Cells[x + 72, iAutoManFiles + 0] = oAutoMan.lDate[x];
								oWorkSheet.Cells[x + 72, iAutoManFiles + 1] = oAutoMan.lManualUploads[x];
								lAvgMan = lAvgMan + oAutoMan.lManualUploads[x];
								oWorkSheet.Cells[x + 72, iAutoManFiles + 2] = oAutoMan.lAutoUploads[x];
								lAvgAuto = lAvgAuto + oAutoMan.lAutoUploads[x];
								if(oAutoMan.chkDatabaseCount.Checked == true)
								{
									oWorkSheet.Cells[x + 72, iAutoManFiles + 3] = oAutoMan.lNullUploads[x];
									lAvgNull = lAvgNull + oAutoMan.lNullUploads[x];
								}
							}
							oWorkSheet.Cells[79, iAutoManFiles + 1] = lAvgMan / 7;
							oWorkSheet.Cells[79, iAutoManFiles + 2] = lAvgAuto / 7;
							if(oAutoMan.chkDatabaseCount.Checked == true)
							{
								oWorkSheet.Cells[79, iAnonCustFiles + 3] = lAvgNull / 7;
							}
							oRange = (Excel.Range) oWorkSheet.Cells[72, 2];

							oChartObjects = (Excel.ChartObjects) oWorkSheet.ChartObjects(Missing.Value);
							oChartObject = oChartObjects.Add(10, 90, 370, 300);
							if(chk3DCharts.Checked == true)
							{
								oChartObject.Chart.Type = (int) Excel.XlChartType.xl3DColumn;
							}
							else
							{
								oChartObject.Chart.Type = (int) 3;//Excel.XlChartType.xl3DColumn;
							}
							oChart = oChartObject.Chart;
							oWorkSheet.Shapes.Item(oWorkSheet.Shapes.Count).Top = 1020;
							if(iAutoManCount > 0)
							{
								oWorkSheet.Shapes.Item(y + 1).Left = 400 * iAutoManCount;
								
							}
							if(oAutoMan.chkDatabaseCount.Checked == true)
							{
								oRange = oWorkSheet.get_Range(cTitle + "71:" + cTitle + "78", cChart + "71:" + cChart + "78");
							}
							else
							{
								oRange = oWorkSheet.get_Range(cTitle + "71:" + cTitle + "78", cChart + "71:" + cChart + "78");
							}
							
							oChart.SetSourceData(oRange, Excel.XlRowCol.xlColumns);
							oSeries = (Excel.SeriesCollection) oChart.SeriesCollection(Missing.Value);
							oChart.HasLegend = true;
							oLegend = oChart.Legend;
							oChart.HasTitle = true;
							oChart.ChartTitle.Text = oAutoMan.Text;

							iAutoManTitle += 8;
							iAutoManFiles += 8;
							iAutoManCount++;
							z = checkedListBox1.Items.Count;
						}
					}
				}

				if(this.Owner.MdiChildren[y].Name == "frmAnonCust")
				{
					oAnonCust = (frmAnonCust) oForm;
					for(z = 0;z < checkedListBox1.CheckedItems.Count;z++)
					{
						if(checkedListBox1.CheckedItems[z].ToString() == oForm.Text)
						{
							oWorkSheet.Cells[36, iAnonCustFiles] = oAnonCust.Text;
							cTitle = (char)iAnonCustTitle;
							cTitleEnd = (char)(iAnonCustTitle + 3);
							cChart = (char)(iAnonCustTitle + 2);
							oRangeTitle = oWorkSheet.get_Range(cTitle + "36", cTitle + "37");
							oRangeTitle.Font.Bold = true;
							oRangeTitle.ColumnWidth = 10;
							oRangeTitle = oWorkSheet.get_Range(cTitle + "37", cTitleEnd + "37");
							oRangeTitle.Font.Bold = true;
							oRangeTitle.ColumnWidth = 10;
							oRangeTitle = oWorkSheet.get_Range(cTitle + "45", cTitle + "45");
							oRangeTitle.Font.Bold = true;
							oRangeTitle.ColumnWidth = 10;

							oWorkSheet.Cells[37, iAnonCustFiles + 0] = "Date";
							oWorkSheet.Cells[37, iAnonCustFiles + 1] = "Customer";
							oWorkSheet.Cells[37, iAnonCustFiles + 2] = "Anonymous";
							oWorkSheet.Cells[45, iAnonCustFiles + 0] = "Average";
							lAvgAnon = 0;
							lAvgCustomer = 0;
							for(x = 0; x < 7; x++)
							{
								oWorkSheet.Cells[x + 38, 0 + iAnonCustFiles] = oAnonCust.lDate[x];
								oWorkSheet.Cells[x + 38, 1 + iAnonCustFiles] = oAnonCust.lCustomer[x];
								lAvgCustomer = lAvgCustomer + oAnonCust.lCustomer[x];
								oWorkSheet.Cells[x + 38, 2 + iAnonCustFiles] = oAnonCust.lAnonymous[x];
								lAvgAnon = lAvgAnon + oAnonCust.lAnonymous[x];
							}
							oWorkSheet.Cells[45, iAnonCustFiles + 1] = lAvgCustomer / 7;
							oWorkSheet.Cells[45, iAnonCustFiles + 2] = lAvgAnon / 7;
							oRange = (Excel.Range) oWorkSheet.Cells[36, 2];
					

							oChartObjects = (Excel.ChartObjects) oWorkSheet.ChartObjects(Missing.Value);
							oChartObject = oChartObjects.Add(10, 90, 370, 300);
							if(chk3DCharts.Checked == true)
							{
								oChartObject.Chart.Type = (int) Excel.XlChartType.xl3DColumn;
							}
							else
							{
								oChartObject.Chart.Type = (int) 3;//Excel.XlChartType.xl3DColumn;
							}
							oChart = oChartObject.Chart;
							oWorkSheet.Shapes.Item(oWorkSheet.Shapes.Count).Top = 575;
							if(iAnonCustCount > 0)
							{
								oWorkSheet.Shapes.Item(y + 1).Left = 400 * iAnonCustCount;
								
							}
							oRange = oWorkSheet.get_Range(cTitle + "37:" + cTitle + "44", cChart + "37:" + cChart + "44");
							
							oChart.SetSourceData(oRange, Excel.XlRowCol.xlColumns);
							oSeries = (Excel.SeriesCollection) oChart.SeriesCollection(Missing.Value);
							oChart.HasLegend = true;
							oLegend = oChart.Legend;
							oChart.HasTitle = true;
							oChart.ChartTitle.Text = oAnonCust.Text;
							
							iAnonCustTitle += 8;
							iAnonCustFiles += 8;
							iAnonCustCount++;
							z = checkedListBox1.Items.Count;
						}
					}
				}

				if(this.Owner.MdiChildren[y].Name == "frmWeekly")
				{
					oWeekly = (frmWeekly) oForm;
					//checkedListBox1.Items.Add(this.Owner.MdiChildren[x].Text, CheckState.Checked);
					for(z = 0;z < checkedListBox1.CheckedItems.Count;z++)
					{
						if(checkedListBox1.CheckedItems[z].ToString() == oForm.Text)
						{
							oWorkSheet.Cells[1, iWeeklyFiles] = oWeekly.Text;
							oWorkSheet.Cells[2, iWeeklyFiles] = "Date";
							cTitle = (char)iWeeklyTitle;
							cTitleEnd = (char)(iWeeklyTitle + 6);
							cChart = (char)(iWeeklyTitle + 3);
							oRangeTitle = oWorkSheet.get_Range(cTitle + "1", cTitle + "2");
							oRangeTitle.Font.Bold = true;
							oRangeTitle.ColumnWidth = 10;
							oRangeTitle = oWorkSheet.get_Range(cTitle + "2", cTitleEnd + "2");
							oRangeTitle.Font.Bold = true;
							oRangeTitle.ColumnWidth = 10;
							oRangeTitle = oWorkSheet.get_Range(cTitle + "10", cTitle + "10");
							oRangeTitle.Font.Bold = true;
							oRangeTitle.ColumnWidth = 10;

							oWorkSheet.Cells[2, iWeeklyFiles + 1] = "Archive";
							oWorkSheet.Cells[2, iWeeklyFiles + 2] = "Watson";
							oWorkSheet.Cells[2, iWeeklyFiles + 3] = "Database";
							oWorkSheet.Cells[2, iWeeklyFiles + 4] = "W - A";
							oWorkSheet.Cells[2, iWeeklyFiles + 5] = "A - DB";
							oWorkSheet.Cells[10, iWeeklyFiles + 0] = "Average";
					
							lAvgArchive = 0;
							lAvgWatson = 0;
							lAvgDaily = 0;
							for(x = 0; x < 7; x++)
							{
								oWorkSheet.Cells[x + 3, 0 + iWeeklyFiles] = oWeekly.lDate[x];
								oWorkSheet.Cells[x + 3, 1 + iWeeklyFiles] = oWeekly.lArchive[x];
								lAvgArchive = lAvgArchive + oWeekly.lArchive[x];
								oWorkSheet.Cells[x + 3, 2 + iWeeklyFiles] = oWeekly.lWatson[x];
								lAvgWatson = lAvgWatson + oWeekly.lWatson[x];
								oWorkSheet.Cells[x + 3, 3 + iWeeklyFiles] = oWeekly.lCount[x];
								lAvgDaily = lAvgDaily + oWeekly.lCount[x];
								oWorkSheet.Cells[x + 3, 4 + iWeeklyFiles] = oWeekly.lWatson[x] - oWeekly.lArchive[x];
								oWorkSheet.Cells[x + 3, 5 + iWeeklyFiles] = oWeekly.lArchive[x] - oWeekly.lCount[x];

							}
							oWorkSheet.Cells[10, iWeeklyFiles + 1] = lAvgArchive / 7;
							oWorkSheet.Cells[10, iWeeklyFiles + 2] = lAvgWatson / 7;
							oWorkSheet.Cells[10, iWeeklyFiles + 3] = lAvgDaily / 7;
							oRange = (Excel.Range) oWorkSheet.Cells[2, 2];
					

							oChartObjects = (Excel.ChartObjects) oWorkSheet.ChartObjects(Missing.Value);
							oChartObject = oChartObjects.Add(10, 90, 370, 300);
							if(chk3DCharts.Checked == true)
							{
								oChartObject.Chart.Type = (int) Excel.XlChartType.xl3DColumn;
							}
							else
							{
								oChartObject.Chart.Type = (int) 3;//Excel.XlChartType.xl3DColumn;
							}
							oChart = oChartObject.Chart;
							oWorkSheet.Shapes.Item(oWorkSheet.Shapes.Count).Top = 135;
							if(iWeeklyCount > 0)
							{
								oWorkSheet.Shapes.Item(y + 1).Left = 400 * iWeeklyCount;
							}
							oRange = oWorkSheet.get_Range(cTitle + "2:" + cTitle + "9", cChart + "2:" + cChart + "9");
							
							oChart.SetSourceData(oRange, Excel.XlRowCol.xlColumns);
							oSeries = (Excel.SeriesCollection) oChart.SeriesCollection(Missing.Value);
							oChart.HasLegend = true;
							oLegend = oChart.Legend;
							oChart.HasTitle = true;
							oChart.ChartTitle.Text = oWeekly.Text;
							
							iWeeklyTitle += 8;
							iWeeklyFiles += 8;
							iWeeklyCount++;
							z = checkedListBox1.Items.Count;
						}
					}

				}
				y++;
			}
			cmdDone.Focus();
				
		}

		private void cmdDone_Click(object sender, System.EventArgs e)
		{
			this.Close();
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocareports\frmlocation.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using Microsoft.Win32;
using System.Security.Permissions;

namespace OCAReports
{
	/// <summary>
	/// Summary description for frmLocation.
	/// </summary>
	public class frmLocation : System.Windows.Forms.Form
	{
		private System.Windows.Forms.GroupBox groupBox1;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.Label label2;
		private Microsoft.VisualBasic.Compatibility.VB6.DriveListBox driveListBox1;
		private System.Windows.Forms.Button cmdDone;
		private System.Windows.Forms.Button cmdAdd;
		private System.Windows.Forms.RadioButton optArchive;
		private System.Windows.Forms.RadioButton optWatson;
		private System.Windows.Forms.ListBox lstLocations;
		private System.Windows.Forms.TextBox txtNetwork;
		private System.Windows.Forms.Button cmdRemove;
		private System.Windows.Forms.RadioButton rDirectory;
		private System.Windows.Forms.RadioButton rPath;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public frmLocation()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(frmLocation));
			this.cmdDone = new System.Windows.Forms.Button();
			this.cmdAdd = new System.Windows.Forms.Button();
			this.groupBox1 = new System.Windows.Forms.GroupBox();
			this.optArchive = new System.Windows.Forms.RadioButton();
			this.optWatson = new System.Windows.Forms.RadioButton();
			this.lstLocations = new System.Windows.Forms.ListBox();
			this.label1 = new System.Windows.Forms.Label();
			this.label2 = new System.Windows.Forms.Label();
			this.driveListBox1 = new Microsoft.VisualBasic.Compatibility.VB6.DriveListBox();
			this.txtNetwork = new System.Windows.Forms.TextBox();
			this.rDirectory = new System.Windows.Forms.RadioButton();
			this.rPath = new System.Windows.Forms.RadioButton();
			this.cmdRemove = new System.Windows.Forms.Button();
			this.groupBox1.SuspendLayout();
			this.SuspendLayout();
			// 
			// cmdDone
			// 
			this.cmdDone.Location = new System.Drawing.Point(440, 16);
			this.cmdDone.Name = "cmdDone";
			this.cmdDone.TabIndex = 0;
			this.cmdDone.Text = "&Done";
			this.cmdDone.Click += new System.EventHandler(this.cmdDone_Click);
			// 
			// cmdAdd
			// 
			this.cmdAdd.Location = new System.Drawing.Point(440, 52);
			this.cmdAdd.Name = "cmdAdd";
			this.cmdAdd.TabIndex = 1;
			this.cmdAdd.Text = "&Add";
			this.cmdAdd.Click += new System.EventHandler(this.cmdAdd_Click);
			// 
			// groupBox1
			// 
			this.groupBox1.Controls.AddRange(new System.Windows.Forms.Control[] {
																					this.optArchive,
																					this.optWatson});
			this.groupBox1.Location = new System.Drawing.Point(408, 120);
			this.groupBox1.Name = "groupBox1";
			this.groupBox1.Size = new System.Drawing.Size(112, 72);
			this.groupBox1.TabIndex = 2;
			this.groupBox1.TabStop = false;
			// 
			// optArchive
			// 
			this.optArchive.Location = new System.Drawing.Point(16, 48);
			this.optArchive.Name = "optArchive";
			this.optArchive.Size = new System.Drawing.Size(64, 16);
			this.optArchive.TabIndex = 1;
			this.optArchive.Text = "Archive";
			this.optArchive.CheckedChanged += new System.EventHandler(this.optArchive_CheckedChanged);
			// 
			// optWatson
			// 
			this.optWatson.Checked = true;
			this.optWatson.Location = new System.Drawing.Point(16, 16);
			this.optWatson.Name = "optWatson";
			this.optWatson.Size = new System.Drawing.Size(64, 16);
			this.optWatson.TabIndex = 0;
			this.optWatson.TabStop = true;
			this.optWatson.Text = "Watson";
			this.optWatson.CheckedChanged += new System.EventHandler(this.optWatson_CheckedChanged);
			// 
			// lstLocations
			// 
			this.lstLocations.Location = new System.Drawing.Point(240, 48);
			this.lstLocations.Name = "lstLocations";
			this.lstLocations.Size = new System.Drawing.Size(144, 147);
			this.lstLocations.TabIndex = 3;
			this.lstLocations.Leave += new System.EventHandler(this.lstLocations_Leave);
			this.lstLocations.Enter += new System.EventHandler(this.lstLocations_Enter);
			this.lstLocations.SelectedIndexChanged += new System.EventHandler(this.lstLocations_SelectedIndexChanged);
			// 
			// label1
			// 
			this.label1.Location = new System.Drawing.Point(16, 16);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(120, 24);
			this.label1.TabIndex = 4;
			this.label1.Text = "Directory";
			// 
			// label2
			// 
			this.label2.Location = new System.Drawing.Point(248, 16);
			this.label2.Name = "label2";
			this.label2.Size = new System.Drawing.Size(120, 24);
			this.label2.TabIndex = 5;
			this.label2.Text = "Location:";
			// 
			// driveListBox1
			// 
			this.driveListBox1.Location = new System.Drawing.Point(40, 48);
			this.driveListBox1.Name = "driveListBox1";
			this.driveListBox1.Size = new System.Drawing.Size(168, 21);
			this.driveListBox1.TabIndex = 7;
			// 
			// txtNetwork
			// 
			this.txtNetwork.Location = new System.Drawing.Point(40, 88);
			this.txtNetwork.Name = "txtNetwork";
			this.txtNetwork.Size = new System.Drawing.Size(168, 20);
			this.txtNetwork.TabIndex = 8;
			this.txtNetwork.Text = "";
			this.txtNetwork.KeyUp += new System.Windows.Forms.KeyEventHandler(this.txtNetwork_KeyUp);
			this.txtNetwork.Enter += new System.EventHandler(this.txtNetwork_Enter);
			// 
			// rDirectory
			// 
			this.rDirectory.Checked = true;
			this.rDirectory.Location = new System.Drawing.Point(16, 48);
			this.rDirectory.Name = "rDirectory";
			this.rDirectory.Size = new System.Drawing.Size(16, 16);
			this.rDirectory.TabIndex = 10;
			this.rDirectory.TabStop = true;
			// 
			// rPath
			// 
			this.rPath.Location = new System.Drawing.Point(16, 88);
			this.rPath.Name = "rPath";
			this.rPath.Size = new System.Drawing.Size(16, 16);
			this.rPath.TabIndex = 1;
			this.rPath.CheckedChanged += new System.EventHandler(this.rPath_CheckedChanged);
			// 
			// cmdRemove
			// 
			this.cmdRemove.Location = new System.Drawing.Point(440, 88);
			this.cmdRemove.Name = "cmdRemove";
			this.cmdRemove.TabIndex = 11;
			this.cmdRemove.Text = "&Remove";
			this.cmdRemove.Click += new System.EventHandler(this.cmdRemove_Click);
			// 
			// frmLocation
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(536, 206);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.rDirectory,
																		  this.txtNetwork,
																		  this.driveListBox1,
																		  this.label2,
																		  this.label1,
																		  this.lstLocations,
																		  this.groupBox1,
																		  this.cmdAdd,
																		  this.cmdDone,
																		  this.rPath,
																		  this.cmdRemove});
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedDialog;
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "frmLocation";
			this.Text = "Locate directories to search";
			this.Load += new System.EventHandler(this.frmLocation_Load);
			this.groupBox1.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		private void cmdAdd_Click(object sender, System.EventArgs e)
		{
			AddToList();
		}

		private void lstLocations_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			
		}

		private void lstLocations_Enter(object sender, System.EventArgs e)
		{
		}

		private void lstLocations_Leave(object sender, System.EventArgs e)
		{
		}

		private void cmdRemove_Click(object sender, System.EventArgs e)
		{
			RegistryKey reg;
			
			if(optArchive.Checked == true)
			{
				reg = Registry.CurrentUser.OpenSubKey("software").OpenSubKey("microsoft", true).CreateSubKey("OCATools").CreateSubKey("OCAReports").CreateSubKey("Archive");
			}
			else
			{
				reg = Registry.CurrentUser.OpenSubKey("software").OpenSubKey("microsoft", true).CreateSubKey("OCATools").CreateSubKey("OCAReports").CreateSubKey("Watson");
			}
			int x = 0;

//			RegistryPermission f = new RegistryPermission(RegistryPermissionAccess.Read | RegistryPermissionAccess.Write, 
//				"HKEY_CURRENT_USER\\Software\\Microsoft\\OCATools\\OCAReports\\Watson");
//			f.AddPathList(RegistryPermissionAccess.Write | RegistryPermissionAccess.Read | RegistryPermissionAccess.Write,
//				"HKEY_CURRENT_USER\\Software\\Microsoft\\OCATools\\OCAReports\\Watson");


			if(lstLocations.SelectedIndex > -1)
			{
				lstLocations.Items.Remove(lstLocations.SelectedItem);
			}
			for(x = 0;x < 5; x++)
			{
				reg.SetValue("Loc" + x.ToString(), "");
			}

			for(x = 0;x < lstLocations.Items.Count; x++)
			{
				reg.SetValue("Loc" + x.ToString(), lstLocations.Items[x].ToString());
			}
		}

		private void cmdDone_Click(object sender, System.EventArgs e)
		{
			this.Close();
		}

		private void txtNetwork_Enter(object sender, System.EventArgs e)
		{
			rPath.Checked = true;
		}

		private void txtNetwork_KeyUp(object sender, System.Windows.Forms.KeyEventArgs e)
		{
			if(e.KeyCode == System.Windows.Forms.Keys.Enter)
			{
				AddToList();
			}
		}
		private void AddToList()
		{
			string sDrive;
			int x = 0;
			bool bolFound = false;
			string[] strWatson = new string[5];
			RegistryKey reg;

			if(optArchive.Checked == true)
			{
				reg = Registry.CurrentUser.OpenSubKey("software").OpenSubKey("microsoft", true).CreateSubKey("OCATools").CreateSubKey("OCAReports").CreateSubKey("Archive");
			}
			else
			{
				reg = Registry.CurrentUser.OpenSubKey("software").OpenSubKey("microsoft", true).CreateSubKey("OCATools").CreateSubKey("OCAReports").CreateSubKey("Watson");
			}
			if(lstLocations.Items.Count >= 11)
			{
				MessageBox.Show("The maximum drives is 10", "Cannot add drive", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
				return;
			}
											
			if(rDirectory.Checked == true)
			{
				sDrive = driveListBox1.Drive.ToString();
				sDrive = sDrive.Substring(0, 1);
				sDrive = sDrive + ":\\";
				for(x = 0; x < lstLocations.Items.Count;x++)
				{
					if(sDrive == lstLocations.Items[x].ToString())
					{
						bolFound = true;
					}
				}
				if(bolFound == false)
				{
					lstLocations.Items.Add(sDrive);
				}
				else
				{
					MessageBox.Show("This item already exist in the listbox", "Cannot add drive", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
				}
			}
			if(rPath.Checked == true)
			{

				sDrive = txtNetwork.Text;
				for(x = 0; x < lstLocations.Items.Count;x++)
				{
					if(sDrive == lstLocations.Items[x].ToString())
					{
						bolFound = true;
					}
				}
				if(bolFound == false)
				{
					lstLocations.Items.Add(sDrive);
				}
				else
				{
					MessageBox.Show("This item already exist in the listbox", "Cannot add drive", MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
				}
				txtNetwork.Focus();
				txtNetwork.SelectAll();
				
			}
			for(x = 0;x < 10; x++)
			{
				reg.SetValue("Loc" + x.ToString(), "");
			}

			for(x = 0;x < lstLocations.Items.Count; x++)
			{
				reg.SetValue("Loc" + x.ToString(), lstLocations.Items[x].ToString());
			}
		}

		private void rPath_CheckedChanged(object sender, System.EventArgs e)
		{
			if(rPath.Checked == true)
			{
				txtNetwork.Focus();
			}

		}

		private void frmLocation_Load(object sender, System.EventArgs e)
		{
			int x = 0;

			RegistryKey reg = Registry.CurrentUser.OpenSubKey("software").OpenSubKey("microsoft", true).CreateSubKey("OCATools").CreateSubKey("OCAReports").CreateSubKey("Watson");
			for(x = 0;x < 10; x++)
			{
				try
				{
					if(reg.GetValue("Loc" + x.ToString()).ToString().Length > 0)
					{
						lstLocations.Items.Add(reg.GetValue("Loc" + x.ToString()));
					}
				}
				catch
				{
					x = 10;
				}
			}
		}

		private void optWatson_CheckedChanged(object sender, System.EventArgs e)
		{
			int x = 0;

			lstLocations.Items.Clear();
			RegistryKey reg = Registry.CurrentUser.OpenSubKey("software").OpenSubKey("microsoft", true).CreateSubKey("OCATools").CreateSubKey("OCAReports").CreateSubKey("Watson");
			for(x = 0;x < 5; x++)
			{
				try
				{
					if(reg.GetValue("Loc" + x.ToString()).ToString().Length > 0)
					{
						lstLocations.Items.Add(reg.GetValue("Loc" + x.ToString()));
					}
				}
				catch
				{
					x = 10;
				}
			}
		}

		private void optArchive_CheckedChanged(object sender, System.EventArgs e)
		{
			int x = 0;

			lstLocations.Items.Clear();
			RegistryKey reg = Registry.CurrentUser.OpenSubKey("software").OpenSubKey("microsoft", true).CreateSubKey("OCATools").CreateSubKey("OCAReports").CreateSubKey("Archive");
			for(x = 0;x < 10; x++)
			{
				try
				{
					if(reg.GetValue("Loc" + x.ToString()).ToString().Length > 0)
					{
						lstLocations.Items.Add(reg.GetValue("Loc" + x.ToString()));
					}
				}
				catch
				{
					x = 10;
				}
			}
		}

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocareports\frmmini.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;

namespace OCAReports
{
	/// <summary>
	/// Summary description for frmMini.
	/// </summary>
	public class frmMini : System.Windows.Forms.Form
	{
		private System.Windows.Forms.TabControl tabControl1;
		private System.Windows.Forms.TabPage tabPage1;
		private AxMSChart20Lib.AxMSChart axMSChart1;
		private System.Windows.Forms.TabPage tabPage2;
		private System.Windows.Forms.TabPage tabPage3;
		private System.Windows.Forms.Label label5;
		private System.Windows.Forms.Label label7;
		private System.Windows.Forms.Label lblPurpose;
		private System.Windows.Forms.ProgressBar progressBar1;
		private System.Windows.Forms.Label lblStatement;
		private System.Windows.Forms.MonthCalendar monthCalendar1;
		private System.Windows.Forms.StatusBar statusBar1;
		private System.Windows.Forms.Button cmdGetData;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		private System.ComponentModel.Container components = null;

		public frmMini()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(frmMini));
			this.tabControl1 = new System.Windows.Forms.TabControl();
			this.tabPage1 = new System.Windows.Forms.TabPage();
			this.axMSChart1 = new AxMSChart20Lib.AxMSChart();
			this.tabPage2 = new System.Windows.Forms.TabPage();
			this.tabPage3 = new System.Windows.Forms.TabPage();
			this.label5 = new System.Windows.Forms.Label();
			this.label7 = new System.Windows.Forms.Label();
			this.lblPurpose = new System.Windows.Forms.Label();
			this.progressBar1 = new System.Windows.Forms.ProgressBar();
			this.lblStatement = new System.Windows.Forms.Label();
			this.monthCalendar1 = new System.Windows.Forms.MonthCalendar();
			this.statusBar1 = new System.Windows.Forms.StatusBar();
			this.cmdGetData = new System.Windows.Forms.Button();
			this.tabControl1.SuspendLayout();
			this.tabPage1.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.axMSChart1)).BeginInit();
			this.tabPage3.SuspendLayout();
			this.SuspendLayout();
			// 
			// tabControl1
			// 
			this.tabControl1.Controls.AddRange(new System.Windows.Forms.Control[] {
																					  this.tabPage1,
																					  this.tabPage2,
																					  this.tabPage3});
			this.tabControl1.Location = new System.Drawing.Point(8, 82);
			this.tabControl1.Name = "tabControl1";
			this.tabControl1.SelectedIndex = 0;
			this.tabControl1.Size = new System.Drawing.Size(736, 400);
			this.tabControl1.TabIndex = 92;
			// 
			// tabPage1
			// 
			this.tabPage1.Controls.AddRange(new System.Windows.Forms.Control[] {
																				   this.axMSChart1});
			this.tabPage1.Location = new System.Drawing.Point(4, 22);
			this.tabPage1.Name = "tabPage1";
			this.tabPage1.Size = new System.Drawing.Size(728, 374);
			this.tabPage1.TabIndex = 0;
			this.tabPage1.Text = "Graphical";
			// 
			// axMSChart1
			// 
			this.axMSChart1.ContainingControl = this;
			this.axMSChart1.DataSource = null;
			this.axMSChart1.Location = new System.Drawing.Point(8, 8);
			this.axMSChart1.Name = "axMSChart1";
			this.axMSChart1.OcxState = ((System.Windows.Forms.AxHost.State)(resources.GetObject("axMSChart1.OcxState")));
			this.axMSChart1.Size = new System.Drawing.Size(720, 344);
			this.axMSChart1.TabIndex = 71;
			// 
			// tabPage2
			// 
			this.tabPage2.Location = new System.Drawing.Point(4, 22);
			this.tabPage2.Name = "tabPage2";
			this.tabPage2.Size = new System.Drawing.Size(728, 374);
			this.tabPage2.TabIndex = 1;
			this.tabPage2.Text = "Statistical";
			this.tabPage2.Visible = false;
			// 
			// tabPage3
			// 
			this.tabPage3.Controls.AddRange(new System.Windows.Forms.Control[] {
																				   this.label5,
																				   this.label7});
			this.tabPage3.Location = new System.Drawing.Point(4, 22);
			this.tabPage3.Name = "tabPage3";
			this.tabPage3.Size = new System.Drawing.Size(728, 374);
			this.tabPage3.TabIndex = 2;
			this.tabPage3.Text = "Notes";
			this.tabPage3.Visible = false;
			// 
			// label5
			// 
			this.label5.Location = new System.Drawing.Point(32, 72);
			this.label5.Name = "label5";
			this.label5.Size = new System.Drawing.Size(576, 72);
			this.label5.TabIndex = 80;
			this.label5.Text = @"Only about a quarter of the people uploading choose to associate the submitted file with their customer information.  Although this seems like a small percentage, it is actually quite a good response.  Things to consider moving forward, are how to improve the nonanonymous uploads by reducing the amount of information required for association.";
			// 
			// label7
			// 
			this.label7.Font = new System.Drawing.Font("Microsoft Sans Serif", 10F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label7.Location = new System.Drawing.Point(32, 32);
			this.label7.Name = "label7";
			this.label7.Size = new System.Drawing.Size(240, 24);
			this.label7.TabIndex = 76;
			this.label7.Text = "Notes";
			// 
			// lblPurpose
			// 
			this.lblPurpose.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.lblPurpose.Location = new System.Drawing.Point(8, 2);
			this.lblPurpose.Name = "lblPurpose";
			this.lblPurpose.Size = new System.Drawing.Size(112, 24);
			this.lblPurpose.TabIndex = 91;
			this.lblPurpose.Text = "Purpose";
			// 
			// progressBar1
			// 
			this.progressBar1.Location = new System.Drawing.Point(568, 502);
			this.progressBar1.Name = "progressBar1";
			this.progressBar1.Size = new System.Drawing.Size(384, 23);
			this.progressBar1.TabIndex = 89;
			this.progressBar1.Visible = false;
			// 
			// lblStatement
			// 
			this.lblStatement.Location = new System.Drawing.Point(8, 32);
			this.lblStatement.Name = "lblStatement";
			this.lblStatement.Size = new System.Drawing.Size(744, 30);
			this.lblStatement.TabIndex = 90;
			this.lblStatement.Text = "The data below outlines and graphs the daily\\weekly number\\percentage of anonymou" +
				"s versus customer associated uploads.";
			// 
			// monthCalendar1
			// 
			this.monthCalendar1.Location = new System.Drawing.Point(760, 82);
			this.monthCalendar1.Name = "monthCalendar1";
			this.monthCalendar1.TabIndex = 86;
			// 
			// statusBar1
			// 
			this.statusBar1.Location = new System.Drawing.Point(0, 512);
			this.statusBar1.Name = "statusBar1";
			this.statusBar1.Size = new System.Drawing.Size(968, 22);
			this.statusBar1.TabIndex = 88;
			// 
			// cmdGetData
			// 
			this.cmdGetData.Location = new System.Drawing.Point(760, 250);
			this.cmdGetData.Name = "cmdGetData";
			this.cmdGetData.TabIndex = 87;
			this.cmdGetData.Text = "&Refresh";
			// 
			// frmMini
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(968, 534);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.tabControl1,
																		  this.lblPurpose,
																		  this.progressBar1,
																		  this.lblStatement,
																		  this.monthCalendar1,
																		  this.statusBar1,
																		  this.cmdGetData});
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.Name = "frmMini";
			this.Text = "Manual Uploads";
			this.tabControl1.ResumeLayout(false);
			this.tabPage1.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.axMSChart1)).EndInit();
			this.tabPage3.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocareports\frmautoreport.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Runtime.InteropServices;
using System.Reflection;

namespace OCAReports
{
	/// <summary>
	/// Summary description for frmAutoReport.
	/// </summary>
	public class frmAutoReport : System.Windows.Forms.Form
	{
		private System.Windows.Forms.Button cmdClose;
		private System.Windows.Forms.Timer timer1;
		private System.Windows.Forms.Label label1;
		private System.Windows.Forms.Label lblNotification;
		private System.ComponentModel.IContainer components;

		public frmAutoReport()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(frmAutoReport));
			this.cmdClose = new System.Windows.Forms.Button();
			this.timer1 = new System.Windows.Forms.Timer(this.components);
			this.label1 = new System.Windows.Forms.Label();
			this.lblNotification = new System.Windows.Forms.Label();
			this.SuspendLayout();
			// 
			// cmdClose
			// 
			this.cmdClose.Location = new System.Drawing.Point(136, 104);
			this.cmdClose.Name = "cmdClose";
			this.cmdClose.TabIndex = 1;
			this.cmdClose.Text = "&Close";
			this.cmdClose.Click += new System.EventHandler(this.cmdClose_Click);
			// 
			// timer1
			// 
			this.timer1.Interval = 60000;
			this.timer1.Tick += new System.EventHandler(this.timer1_Tick);
			// 
			// label1
			// 
			this.label1.Font = new System.Drawing.Font("Microsoft Sans Serif", 18F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label1.Location = new System.Drawing.Point(0, 8);
			this.label1.Name = "label1";
			this.label1.Size = new System.Drawing.Size(336, 32);
			this.label1.TabIndex = 2;
			this.label1.Text = "One Touch Reporting";
			this.label1.TextAlign = System.Drawing.ContentAlignment.MiddleCenter;
			// 
			// lblNotification
			// 
			this.lblNotification.Font = new System.Drawing.Font("Microsoft Sans Serif", 8.25F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.lblNotification.ForeColor = System.Drawing.Color.Red;
			this.lblNotification.Location = new System.Drawing.Point(40, 56);
			this.lblNotification.Name = "lblNotification";
			this.lblNotification.Size = new System.Drawing.Size(256, 16);
			this.lblNotification.TabIndex = 3;
			this.lblNotification.Text = "In Process...";
			// 
			// frmAutoReport
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(346, 152);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.lblNotification,
																		  this.label1,
																		  this.cmdClose});
			this.FormBorderStyle = System.Windows.Forms.FormBorderStyle.FixedSingle;
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.MaximizeBox = false;
			this.MinimizeBox = false;
			this.Name = "frmAutoReport";
			this.StartPosition = System.Windows.Forms.FormStartPosition.CenterScreen;
			this.Text = "Generating Weekly Reports";
			this.Load += new System.EventHandler(this.frmAutoReport_Load);
			this.ResumeLayout(false);

		}
		#endregion

		#region  Global Variables
			frmWeekly oWeekly;
			frmAnonCust oAnonCust;
			frmAutoMan oAutoMan;
			frmSolutionStatus oSolutionStatus;


		#endregion

		private void cmdClose_Click(object sender, System.EventArgs e)
		{
			timer1.Enabled = false;
			this.Close();
			this.Dispose();
			
		}

		private void frmAutoReport_Load(object sender, System.EventArgs e)
		{
			oWeekly = new frmWeekly();
			oWeekly.MdiParent = this.Owner;
			oAnonCust = new frmAnonCust();
			oAnonCust.MdiParent = this.Owner;
			oAutoMan = new frmAutoMan();
			oAutoMan.MdiParent = this.Owner;
			oSolutionStatus = new frmSolutionStatus();
			oSolutionStatus.MdiParent = this.Owner;
		

			timer1.Enabled = true;
			timer1.Interval = 1000;

		}

		private void timer1_Tick(object sender, System.EventArgs e)
		{
			timer1.Interval = 15000;
			if(oWeekly.HasProcessed == false && oWeekly.StillProcessing == false)
			{
				oWeekly.Show();
				oWeekly.GetData();
				lblNotification.Text = "Processing Weekly Solution Information";
			}

			if(oWeekly.HasProcessed == true && oWeekly.StillProcessing == false)
			{
				if(oAnonCust.HasProcessed == false && oAnonCust.StillProcessing == false)
				{
					oAnonCust.Show();
					oAnonCust.GetData();
					lblNotification.Text = "Processing Anon vs Customer Information";
				}
			}
			if(oWeekly.HasProcessed == true && oWeekly.StillProcessing == false)
			{
				if(oAnonCust.HasProcessed == true && oAnonCust.StillProcessing == false)
				{
					if(oAutoMan.HasProcessed == false && oAutoMan.StillProcessing == false)
					{
						oAutoMan.Show();
						oAutoMan.GetData();
						lblNotification.Text = "Processing Auto Manual Upload Information";
					}
				}
			}

			if(oWeekly.HasProcessed == true && oWeekly.StillProcessing == false)
			{
				if(oAnonCust.HasProcessed == true && oAnonCust.StillProcessing == false)
				{
					if(oAutoMan.HasProcessed == true && oAutoMan.StillProcessing == false)
					{
						if(oSolutionStatus.HasProcessed == false && oSolutionStatus.StillProcessing == false)
						{
							oSolutionStatus.Show();
							oSolutionStatus.GetData();
							lblNotification.Text = "Processing Solution Status Information";
						}
					}
				}
			}
			if(oWeekly.HasProcessed == true && oWeekly.StillProcessing == false)
			{
				if(oAnonCust.HasProcessed == true && oAnonCust.StillProcessing == false)
				{
					if(oAutoMan.HasProcessed == true && oAutoMan.StillProcessing == false)
					{
						if(oSolutionStatus.HasProcessed == true && oSolutionStatus.StillProcessing == false)
						{
							timer1.Enabled = false;
							lblNotification.Text = "Completed Processing";
						}
					}
				}
			}

		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocareports\frmweekly.cs ===
#define FILE_SERVER			//FILE_LOCAL	FILE_SERVER
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Threading;
using System.IO;
using System.Resources;
using System.Globalization;
using System.Text;
using System.Runtime.InteropServices;
using Microsoft.Win32;
using System.Security.Permissions;




namespace OCAReports
{
	/// <summary>
	/// Summary description for frmWeekly.
	/// </summary>
	public class frmWeekly : System.Windows.Forms.Form
	{
		private System.Windows.Forms.StatusBar statusBar1;
		private System.Windows.Forms.MonthCalendar monthCalendar1;
		private System.Windows.Forms.TabControl tabControl1;
		private System.Windows.Forms.TabPage tabPage1;
		private System.Windows.Forms.TabPage tabPage2;
		private System.Windows.Forms.TabPage tabPage3;
		private AxMSChart20Lib.AxMSChart axMSChart1;
		private System.Windows.Forms.Label lblNotes100;
		private System.Windows.Forms.Label label7;
		private System.Windows.Forms.Label label5;
		private System.Windows.Forms.Label label6;
		private System.Windows.Forms.Label label4;
		private System.Windows.Forms.Label label3;
		private System.Windows.Forms.Label lblPurpose;
		private System.Windows.Forms.Label lblStatement;
		private System.ComponentModel.Container components = null;
		private System.Windows.Forms.ProgressBar progressBar1;
		/// <summary>
		/// Required designer variable.
		/// </summary>
		#region ########################Global Variables######################################
		/*************************************************************************************
		*	module: frmAnonCust.cs - Global varibles and objects
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: All global threads and variables are declared.
		*	
		*************************************************************************************/
		public long[] lCount = new long[7];
		public long[] lWatson = new long[7];
		public long[] lArchive = new long[7];
		public DateTime[] lDate = new DateTime[7];
		Thread t_DayOne;
		Thread t_DayTwo;
		Thread t_DayThree;
		Thread t_DayFour;
		Thread t_DayFive;
		Thread t_DaySix;
		Thread t_DaySeven;
		const string sPurpose = "Purpose";
		private System.Windows.Forms.PictureBox pictureBox1;
		const string sPurposeDetails = "The purpose of the following report is to gauge the overall condition and status of " + 
			"the Windows Online Crash Analysis Web site. Through the use of SQL queries and  file counts it should be possible " +
			"to generate a high level understanding of Web  site traffic, type of submissions and solution status";
		private bool bIsStillProcessing = false;
		private bool bHasProcessed = false;

		#endregion


		public frmWeekly()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(frmWeekly));
			this.statusBar1 = new System.Windows.Forms.StatusBar();
			this.monthCalendar1 = new System.Windows.Forms.MonthCalendar();
			this.tabControl1 = new System.Windows.Forms.TabControl();
			this.tabPage1 = new System.Windows.Forms.TabPage();
			this.axMSChart1 = new AxMSChart20Lib.AxMSChart();
			this.pictureBox1 = new System.Windows.Forms.PictureBox();
			this.tabPage2 = new System.Windows.Forms.TabPage();
			this.tabPage3 = new System.Windows.Forms.TabPage();
			this.label5 = new System.Windows.Forms.Label();
			this.label6 = new System.Windows.Forms.Label();
			this.label4 = new System.Windows.Forms.Label();
			this.label3 = new System.Windows.Forms.Label();
			this.label7 = new System.Windows.Forms.Label();
			this.lblNotes100 = new System.Windows.Forms.Label();
			this.progressBar1 = new System.Windows.Forms.ProgressBar();
			this.lblPurpose = new System.Windows.Forms.Label();
			this.lblStatement = new System.Windows.Forms.Label();
			this.tabControl1.SuspendLayout();
			this.tabPage1.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.axMSChart1)).BeginInit();
			this.tabPage3.SuspendLayout();
			this.SuspendLayout();
			// 
			// statusBar1
			// 
			this.statusBar1.Location = new System.Drawing.Point(0, 512);
			this.statusBar1.Name = "statusBar1";
			this.statusBar1.Size = new System.Drawing.Size(968, 22);
			this.statusBar1.TabIndex = 68;
			// 
			// monthCalendar1
			// 
			this.monthCalendar1.Location = new System.Drawing.Point(760, 88);
			this.monthCalendar1.Name = "monthCalendar1";
			this.monthCalendar1.TabIndex = 66;
			this.monthCalendar1.DateSelected += new System.Windows.Forms.DateRangeEventHandler(this.monthCalendar1_DateSelected);
			// 
			// tabControl1
			// 
			this.tabControl1.Controls.AddRange(new System.Windows.Forms.Control[] {
																					  this.tabPage1,
																					  this.tabPage2,
																					  this.tabPage3});
			this.tabControl1.Location = new System.Drawing.Point(8, 88);
			this.tabControl1.Name = "tabControl1";
			this.tabControl1.SelectedIndex = 0;
			this.tabControl1.Size = new System.Drawing.Size(736, 400);
			this.tabControl1.TabIndex = 78;
			// 
			// tabPage1
			// 
			this.tabPage1.Controls.AddRange(new System.Windows.Forms.Control[] {
																				   this.axMSChart1,
																				   this.pictureBox1});
			this.tabPage1.Location = new System.Drawing.Point(4, 22);
			this.tabPage1.Name = "tabPage1";
			this.tabPage1.Size = new System.Drawing.Size(728, 374);
			this.tabPage1.TabIndex = 0;
			this.tabPage1.Text = "Graphical";
			// 
			// axMSChart1
			// 
			this.axMSChart1.ContainingControl = this;
			this.axMSChart1.DataSource = null;
			this.axMSChart1.Location = new System.Drawing.Point(8, 8);
			this.axMSChart1.Name = "axMSChart1";
			this.axMSChart1.OcxState = ((System.Windows.Forms.AxHost.State)(resources.GetObject("axMSChart1.OcxState")));
			this.axMSChart1.Size = new System.Drawing.Size(720, 344);
			this.axMSChart1.TabIndex = 71;
			// 
			// pictureBox1
			// 
			this.pictureBox1.Name = "pictureBox1";
			this.pictureBox1.Size = new System.Drawing.Size(720, 360);
			this.pictureBox1.TabIndex = 72;
			this.pictureBox1.TabStop = false;
			this.pictureBox1.Visible = false;
			// 
			// tabPage2
			// 
			this.tabPage2.Location = new System.Drawing.Point(4, 22);
			this.tabPage2.Name = "tabPage2";
			this.tabPage2.Size = new System.Drawing.Size(728, 374);
			this.tabPage2.TabIndex = 1;
			this.tabPage2.Text = "Statistical";
			this.tabPage2.Paint += new System.Windows.Forms.PaintEventHandler(this.tabPage2_Paint);
			// 
			// tabPage3
			// 
			this.tabPage3.Controls.AddRange(new System.Windows.Forms.Control[] {
																				   this.label5,
																				   this.label6,
																				   this.label4,
																				   this.label3,
																				   this.label7,
																				   this.lblNotes100});
			this.tabPage3.Location = new System.Drawing.Point(4, 22);
			this.tabPage3.Name = "tabPage3";
			this.tabPage3.Size = new System.Drawing.Size(728, 374);
			this.tabPage3.TabIndex = 2;
			this.tabPage3.Text = "Notes";
			// 
			// label5
			// 
			this.label5.Location = new System.Drawing.Point(32, 146);
			this.label5.Name = "label5";
			this.label5.Size = new System.Drawing.Size(576, 40);
			this.label5.TabIndex = 80;
			this.label5.Text = "The data contained with the table below describes the files which were uploaded f" +
				"or each respective server and the entries made by the Online Crash Analysis Web " +
				"Site.";
			// 
			// label6
			// 
			this.label6.Font = new System.Drawing.Font("Microsoft Sans Serif", 10F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label6.Location = new System.Drawing.Point(32, 108);
			this.label6.Name = "label6";
			this.label6.Size = new System.Drawing.Size(240, 24);
			this.label6.TabIndex = 79;
			this.label6.Text = "Upload File";
			// 
			// label4
			// 
			this.label4.Location = new System.Drawing.Point(32, 54);
			this.label4.Name = "label4";
			this.label4.Size = new System.Drawing.Size(576, 40);
			this.label4.TabIndex = 78;
			this.label4.Text = "The data below has been compiled for a one week period and is formatted into sepa" +
				"rate tables for readability and general understanding of how the data was graphe" +
				"d.";
			// 
			// label3
			// 
			this.label3.Font = new System.Drawing.Font("Microsoft Sans Serif", 10F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label3.Location = new System.Drawing.Point(32, 16);
			this.label3.Name = "label3";
			this.label3.Size = new System.Drawing.Size(240, 24);
			this.label3.TabIndex = 77;
			this.label3.Text = "Site Data";
			// 
			// label7
			// 
			this.label7.Font = new System.Drawing.Font("Microsoft Sans Serif", 10F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label7.Location = new System.Drawing.Point(32, 200);
			this.label7.Name = "label7";
			this.label7.Size = new System.Drawing.Size(240, 24);
			this.label7.TabIndex = 76;
			this.label7.Text = "Notes";
			// 
			// lblNotes100
			// 
			this.lblNotes100.Location = new System.Drawing.Point(32, 238);
			this.lblNotes100.Name = "lblNotes100";
			this.lblNotes100.Size = new System.Drawing.Size(576, 98);
			this.lblNotes100.TabIndex = 0;
			this.lblNotes100.Text = @"Under optimal conditions, the baseline should be the number of files uploaded to the Office Watson server*.  This value corresponds to the number of customers that encounter a Stop error and choose to submit the file to Microsoft for analysis.  Once the user clicks the Close button on the Error reporting dialog, Internet Explorer is launched and the Auto.asp Web page is displayed.  At this time, the Web page connects to the Office Watson server and copies the file locally.  At the same time, an entry is made in the KACustomer2 database, which corresponds to the SQL entry.  This file is then submitted to the Online Crash Analysis central FileMover for processing and archival.  At the time of archival, the file is moved to our Archive server and moved to a directory corresponding the data  that the file was moved.";
			// 
			// progressBar1
			// 
			this.progressBar1.Location = new System.Drawing.Point(560, 504);
			this.progressBar1.Name = "progressBar1";
			this.progressBar1.Size = new System.Drawing.Size(384, 23);
			this.progressBar1.TabIndex = 69;
			this.progressBar1.Visible = false;
			// 
			// lblPurpose
			// 
			this.lblPurpose.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.lblPurpose.Location = new System.Drawing.Point(8, 8);
			this.lblPurpose.Name = "lblPurpose";
			this.lblPurpose.Size = new System.Drawing.Size(112, 24);
			this.lblPurpose.TabIndex = 72;
			this.lblPurpose.Text = "Purpose";
			// 
			// lblStatement
			// 
			this.lblStatement.Location = new System.Drawing.Point(8, 38);
			this.lblStatement.Name = "lblStatement";
			this.lblStatement.Size = new System.Drawing.Size(744, 40);
			this.lblStatement.TabIndex = 71;
			this.lblStatement.Text = @"The purpose of the following report is to gauge the overall condition and status of  the Windows Online Crash Analysis Web site. Through the use of SQL queries and  file counts it should be possible to generate a high level understanding of Web  site traffic, type of submissions and solution status";
			// 
			// frmWeekly
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(968, 534);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.progressBar1,
																		  this.tabControl1,
																		  this.lblPurpose,
																		  this.lblStatement,
																		  this.statusBar1,
																		  this.monthCalendar1});
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.Name = "frmWeekly";
			this.Text = "Executive Summary Weekly Report";
			this.Resize += new System.EventHandler(this.frmWeekly_Resize);
			this.Closing += new System.ComponentModel.CancelEventHandler(this.frmWeekly_Closing);
			this.Load += new System.EventHandler(this.frmWeekly_Load);
			this.tabControl1.ResumeLayout(false);
			this.tabPage1.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.axMSChart1)).EndInit();
			this.tabPage3.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion
		/*************************************************************************************
		*	module: frmWeekly.cs - frmWeekly_Load
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: Initialize the calendar control to display one week. Each day is represented
		*	by a global thread.  Set the form title bar to the appropriate start and end days.
		*************************************************************************************/
		private void frmWeekly_Load(object sender, System.EventArgs e)
		{
			DateTime dDate = DateTime.Today;
			short x = 0, y = 0;

			for(x=7, y=1;x>=1;x--, y++)
			{
				axMSChart1.Row = y;
				axMSChart1.RowLabel = dDate.AddDays(-(x)).ToShortDateString(); //+ dDate.Date.ToString();
			}

			monthCalendar1.SelectionStart = dDate.AddDays(-7);
			monthCalendar1.SelectionEnd = dDate.AddDays(-1);
			this.Show();
			this.Refresh();
			axMSChart1.RowCount = 7;
			this.ParentForm.Refresh();
			this.Text = "Executive Summary Weekly Report  " + monthCalendar1.SelectionStart.ToShortDateString() + " - " +
				monthCalendar1.SelectionEnd.ToShortDateString();
			
		}
		/*************************************************************************************
		*	module: frmWeekly.cs - GetData
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: Initializes the threads.  Appropriately sets the legend of the calendar control,
		*	initializes the progress bar, disables the cmdGetData button.  Initializes each
		*	column on the calendar to the appropriated days.  New ThreadStart delegate is created
		*	and each delegate is set to the appropriate day from the end date.  All threads are then
		*	started.
		*************************************************************************************/
		public void GetData()
		{
			System.DateTime dDate = new System.DateTime(monthCalendar1.SelectionStart.Year, monthCalendar1.SelectionStart.Month, 
				monthCalendar1.SelectionStart.Day);
			RegistryKey regArchive = Registry.CurrentUser.OpenSubKey("software").OpenSubKey("microsoft", true).CreateSubKey("OCATools").CreateSubKey("OCAReports").CreateSubKey("Archive");
			RegistryKey regWatson = Registry.CurrentUser.OpenSubKey("software").OpenSubKey("microsoft", true).CreateSubKey("OCATools").CreateSubKey("OCAReports").CreateSubKey("Watson");
			bIsStillProcessing = true;
			try
			{
				if(regArchive.GetValue("Loc0").ToString().Length == 0)
				{
					
					frmLocation fLoc = new frmLocation();
					fLoc.ShowDialog(this);
				}
			}
			catch
			{
				frmLocation fLoc = new frmLocation();
				fLoc.ShowDialog(this);
			}
			try
			{
				if(regWatson.GetValue("Loc0").ToString().Length == 0)
				{
					frmLocation fLoc = new frmLocation();
					fLoc.ShowDialog(this);
				}
			}
			catch
			{
				frmLocation fLoc = new frmLocation();
				fLoc.ShowDialog(this);
			}
//			cmdGetData.Enabled = false;
			progressBar1.Visible = true;
			progressBar1.Minimum = 0;
			progressBar1.Maximum = 22;
			progressBar1.Value = 0;
			progressBar1.Visible = true;
			progressBar1.Refresh();
			axMSChart1.ShowLegend = true;
			axMSChart1.Plot.SeriesCollection[1].LegendText = "Database";
			axMSChart1.Plot.SeriesCollection[2].LegendText = "Watson";
			axMSChart1.Plot.SeriesCollection[3].LegendText = "Archive";

			ThreadStart s_DayOne = new ThreadStart(this.TDayOne);
			t_DayOne = new Thread(s_DayOne);
			t_DayOne.Name = "Thread One";
			
			ThreadStart s_DayTwo = new ThreadStart(this.TDayTwo);
			t_DayTwo = new Thread(s_DayTwo);
			t_DayTwo.Name = "Thread Two";

			ThreadStart s_DayThree = new ThreadStart(this.TDayThree);
			t_DayThree = new Thread(s_DayThree);
			t_DayThree.Name = "Thread Three";

			ThreadStart s_DayFour = new ThreadStart(this.TDayFour);
			t_DayFour = new Thread(s_DayFour);
			t_DayFour.Name = "Thread Four";

			ThreadStart s_DayFive = new ThreadStart(this.TDayFive);
			t_DayFive = new Thread(s_DayFive);
			t_DayFive.Name = "Thread Five";

			ThreadStart s_DaySix = new ThreadStart(this.TDaySix);
			t_DaySix = new Thread(s_DaySix);
			t_DaySix.Name = "Thread Six";

			ThreadStart s_DaySeven = new ThreadStart(this.TDaySeven);
			t_DaySeven = new Thread(s_DaySeven);
			t_DaySeven.Name = "Thread Seven";
			//WaitForSingleObject(tSeven, -1);


			t_DayOne.Start();
			t_DayTwo.Start();
			t_DayThree.Start();
			t_DayFour.Start();
			t_DayFive.Start();
			t_DaySix.Start();
			t_DaySeven.Start();

			statusBar1.Text = "Done";


		}
		/*************************************************************************************
		*	module: frmWeekly.cs - All procedures 
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: calls TLoadData and sends the appropriate day and count information.
		*	
		*************************************************************************************/
		private void TDayOne()
		{
			this.TLoadData(0, 1);
		}
		private void TDayTwo()
		{
			this.TLoadData(1, 2);
		}
		private void TDayThree()
		{
			this.TLoadData(2, 3);
		}
		private void TDayFour()
		{
			this.TLoadData(3, 4);
		}
		private void TDayFive()
		{
			this.TLoadData(4, 5);
		}
		private void TDaySix()
		{
			this.TLoadData(5, 6);
		}
		private void TDaySeven()
		{
			this.TLoadData(6, 7);
		}
		/*************************************************************************************
		*	module: frmWeekly.cs - TLoadData
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: Takes two variables the x represents the day as an integer and the sCount is a 
		*	short representing the column of the Calendar control.  This initializes the OCAData.dll
		*	control and calls the GetDailyCount and GetDailyAnon procedures.  The anonymous count is
		*	subtracted from the total count to get the customer count.  The appropriate column 
		*	and row is updated.
		*************************************************************************************/
		private void TLoadData(int x, short sCount)
		{
			OCAData.CCountDailyClass rpt = new OCAData.CCountDailyClass();
			string strArchive, strWatson;
			int y = 0;
			RegistryKey regArchive = Registry.CurrentUser.OpenSubKey("software").OpenSubKey("microsoft", true).CreateSubKey("OCATools").CreateSubKey("OCAReports").CreateSubKey("Archive");
			RegistryKey regWatson = Registry.CurrentUser.OpenSubKey("software").OpenSubKey("microsoft", true).CreateSubKey("OCATools").CreateSubKey("OCAReports").CreateSubKey("Watson");
			System.DateTime dDate = new System.DateTime(monthCalendar1.SelectionStart.Year, monthCalendar1.SelectionStart.Month, 
				monthCalendar1.SelectionStart.Day);

			long lngCount = 0, l_WatsonCount = 0, l_ArchiveCount = 0;
			
			statusBar1.Text = "Getting Daily Count for " + dDate.AddDays(x).Date.ToShortDateString() + " from database";
			lDate[x] = dDate.AddDays(x).Date;
			try
			{
				lngCount = rpt.GetDailyCount(dDate.AddDays(x));

			}
			catch
			{
//				MessageBox.Show("Error: " + e.Message.ToString(), iLast.ToString(), MessageBoxButtons.OK, MessageBoxIcon.Exclamation);
			}
			lock(this)
			{
				lCount[x] = lngCount;
				axMSChart1.Column = 1;
				axMSChart1.Row = sCount;
				axMSChart1.RowLabel = dDate.AddDays(x).ToShortDateString();
				axMSChart1.Data = lngCount.ToString();
			}
			UpdateStatus();
			
			statusBar1.Text = "Getting Daily Count for " + dDate.AddDays(x).Date.ToString() + " from Watson Server";
#if(FILE_SERVER)
			for(y = 0;y < 10; y++)
			{
				if(regWatson.GetValue("Loc" + y.ToString()).ToString().Length > 0)
				{
					strWatson = regWatson.GetValue("Loc" + y.ToString()).ToString();
					l_WatsonCount = rpt.GetFileCount(OCAData.ServerLocation.Watson, strWatson, dDate.AddDays(x));
					if(l_WatsonCount > 0)
					{
						y = 10;
					}
				}
				else
				{
					l_WatsonCount = 0;
				}
			}
			//l_WatsonCount = rpt.GetFileCount(OCAData.ServerLocation.Watson, "Z:\\", dDate.AddDays(x));
#elif(FILE_LOCAL)
			l_WatsonCount = rpt.GetFileCount(OCAData.ServerLocation.Watson, "C:\\MiniDumps\\Watson\\", dDate.AddDays(x));
#endif
			lock(this)
			{
				lWatson[x] = l_WatsonCount;
				axMSChart1.Column = 2;
				axMSChart1.Row = sCount;
				axMSChart1.Data = l_WatsonCount.ToString();
			}
			UpdateStatus();

			statusBar1.Text = "Getting Daily Count for " + dDate.AddDays(x).Date.ToString() + " from Archive Server";
#if(FILE_SERVER)
			try
			{
				for(y = 0;y < 10; y++)
				{
					if(regArchive.GetValue("Loc" + y.ToString()).ToString().Length > 0)
					{
						strArchive = regArchive.GetValue("Loc" + y.ToString()).ToString();
						l_ArchiveCount = rpt.GetFileCount(OCAData.ServerLocation.Archive, strArchive, dDate.AddDays(x));
						if(l_ArchiveCount > 0)
						{
							y = 10;
						}
					}
					else
					{
						l_ArchiveCount = 0;
					}
				}
				//l_ArchiveCount = rpt.GetFileCount(OCAData.ServerLocation.Archive, "Y:\\", dDate.AddDays(x));
			}
			catch
			{
				l_ArchiveCount = 0;
			}
#elif(FILE_LOCAL)
			l_ArchiveCount = rpt.GetFileCount(OCAData.ServerLocation.Archive, "C:\\MiniDumps\\Archive\\", dDate.AddDays(x));
#endif
//			if(l_ArchiveCount == 0)
//			{
//#if(FILE_SERVER)
//				l_ArchiveCount = rpt.GetFileCount(OCAData.ServerLocation.Archive, "X:\\", dDate.AddDays(x));
//#elif(FILE_LOCAL)
//			l_ArchiveCount = rpt.GetFileCount(OCAData.ServerLocation.Archive, "C:\\MiniDumps\\Archive\\", dDate.AddDays(x));
//#endif
//			}
			lock(this)
			{
				lArchive[x] = l_ArchiveCount;
				axMSChart1.Column = 3;
				axMSChart1.Row = sCount;
				axMSChart1.Data = l_ArchiveCount.ToString();
			}
			UpdateStatus();
			this.Refresh();

		}
		/*************************************************************************************
		*	module: frmWeekly.cs - monthCalendar1_DateSelected
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: To set the selection dates for one week after the user selects an ending
		*	date.  Also resets the title bar of the form for the new dates.
		*************************************************************************************/
		private void monthCalendar1_DateSelected(object sender, System.Windows.Forms.DateRangeEventArgs e)
		{
			System.DateTime dDate = new System.DateTime(monthCalendar1.SelectionStart.Year, monthCalendar1.SelectionStart.Month, 
				monthCalendar1.SelectionStart.Day);

			monthCalendar1.SelectionStart = dDate.AddDays(-6);
			monthCalendar1.SelectionEnd = dDate.Date;
			this.Text = "Executive Summary Weekly Report  " + monthCalendar1.SelectionStart.ToShortDateString() + " - " +
				monthCalendar1.SelectionEnd.ToShortDateString();

			tabPage2.Refresh();
		}
		/*************************************************************************************
		*	module: frmWeekly.cs - tabPage2_Paint
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: Paints the grid for the tab2 control.  The global variables lAnonymous[x] and 
		*	lCustomer[x] are used to display the appropriate information to the grid.  
		*************************************************************************************/
		private void tabPage2_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
		{
			Pen curvePen = new Pen(Color.Blue);
			Pen dbPen = new Pen(Color.DarkBlue);
			Pen whPen = new Pen(Color.White);
			float row = .05F;
			int x = 0, y = 0, min = 3, max = 12, pad = 10, top = 5, cols=4;
			int colwidth = 0;
			PointF pt = new PointF(0, 0);
			Font ft = new Font("Verdona", 12);
			SolidBrush sb = new SolidBrush(Color.Black);
			StringBuilder strTemp = new StringBuilder(40);
			System.DateTime dDate = new System.DateTime(monthCalendar1.SelectionEnd.Year, monthCalendar1.SelectionEnd.Month, 
				monthCalendar1.SelectionEnd.Day);

			colwidth = tabPage2.Width / cols;

			for(x=min;x<max;x++)
			{
				if(x > (min - 1) && x < top)
				{
					e.Graphics.DrawLine(dbPen,  pad, tabPage2.Height * (row * x), 
						tabPage2.Width - pad, tabPage2.Height * (row * x));
				}
				else
				{
					e.Graphics.DrawLine(curvePen,  pad, tabPage2.Height * (row * x), 
						tabPage2.Width - pad, tabPage2.Height * (row * x));
				}
			}
			//x y x1 y1
			for(x=0;x<cols;x++)
			{

				//left side light blue
				e.Graphics.DrawLine(curvePen,  pad + (colwidth * x), 
					tabPage2.Height * (row * (min + 1)), 
					pad + (colwidth * x), tabPage2.Height * (row * (max - 1)));
				//right side light blue
				e.Graphics.DrawLine(curvePen,  tabPage2.Width - pad, 
					tabPage2.Height * (row * (min + 1)), 
					tabPage2.Width - pad, tabPage2.Height * (row * (max - 1)));
				//left side upper dark blue
				e.Graphics.DrawLine(dbPen,  pad + (colwidth * x), 
					tabPage2.Height * (row * min), 
					pad + (colwidth * x), tabPage2.Height * (row * (min + 1)));
				//right side upper dark blue
				e.Graphics.DrawLine(dbPen,  tabPage2.Width - pad, 
					tabPage2.Height * (row * min), 
					tabPage2.Width - pad, tabPage2.Height * (row * (min + 1)));
			}
			for(x=0,y=6;x<7;x++,y--)
			{
				pt.X =  pad + (colwidth * x);
				pt.Y = tabPage2.Height * (row * min);
				strTemp.Remove(0, strTemp.Length);
				switch(x)
				{
					case 0:
						strTemp.Append("Date");
						break;
					case 1:
						strTemp.Append("Daily");
						break;
					case 2:
						strTemp.Append("Watson");
						break;
					case 3:
						strTemp.Append("Archive");
						break;
					default:
						strTemp.Append("");
						break;
				}
				e.Graphics.DrawString(strTemp.ToString(), ft, sb, pt, System.Drawing.StringFormat.GenericDefault);
				pt.X =  pad + (colwidth * 0);
				pt.Y = ((tabPage2.Height * row) * (min + (x + 1)));
				e.Graphics.DrawString(dDate.AddDays(-y).Date.ToString(), ft, sb, pt, System.Drawing.StringFormat.GenericDefault);
				pt.X =  pad + (colwidth * 1);
				pt.Y = ((tabPage2.Height * row) * (min + (x + 1)));
				e.Graphics.DrawString(lCount[x].ToString(), ft, sb, pt, System.Drawing.StringFormat.GenericDefault);
				pt.X =  pad + (colwidth * 2);
				pt.Y = ((tabPage2.Height * row) * (min + (x + 1)));
				e.Graphics.DrawString(lWatson[x].ToString(), ft, sb, pt, System.Drawing.StringFormat.GenericDefault);
				pt.X =  pad + (colwidth * 3);
				pt.Y = ((tabPage2.Height * row) * (min + (x + 1)));
				e.Graphics.DrawString(lArchive[x].ToString(), ft, sb, pt, System.Drawing.StringFormat.GenericDefault);
			}
			curvePen.Dispose();
			dbPen.Dispose();
			whPen.Dispose();

		}
		/*************************************************************************************
		*	module: frmWeekly.cs - frmWeekly_Resize
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: to set the controls to the proper position and resize after resizing
		*	the form
		*************************************************************************************/
		private void frmWeekly_Resize(object sender, System.EventArgs e)
		{
			int buf = 20;

			progressBar1.Top = statusBar1.Top;
			progressBar1.Left = this.Width - progressBar1.Width;
			monthCalendar1.Left = this.Width - (monthCalendar1.Width + buf);
//			cmdGetData.Left = monthCalendar1.Left;
			tabControl1.Width = this.Width - (monthCalendar1.Width + (buf * 3));
			tabControl1.Height = this.Height - (statusBar1.Height + lblPurpose.Height + lblStatement.Height + (buf * 4));
			axMSChart1.Height = tabPage1.Height - buf;
			axMSChart1.Width = tabPage1.Width - buf;

		}
		/*************************************************************************************
		*	module: frmWeekly.cs - UpdateStatus
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: This updates the progress bar and when all threads are returned the 
		*	status bar is updated to done and the cmdGetData button is enabled.
		*************************************************************************************/
		private void UpdateStatus()
		{
			progressBar1.Value = progressBar1.Value + 1;
			axMSChart1.Refresh();
			progressBar1.Refresh();
			if(progressBar1.Value >= 21)
			{
				statusBar1.Text = "Done";
				progressBar1.Visible = false;
				bIsStillProcessing = false;
				bHasProcessed = true;
//				cmdGetData.Enabled = true;
			}

		}
		/*************************************************************************************
		*	module: frmWeekly.cs - frmWeekly_Closing
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: If any threads are still  alive meaning the user prematurely closes the form
		*	before all threads are returned then the threads are checked to see if they are still
		*	running and if so then the thread is aborted.
		*************************************************************************************/
		private void frmWeekly_Closing(object sender, System.ComponentModel.CancelEventArgs e)
		{
			if(t_DayOne != null)
			{
				if(t_DayOne.IsAlive)
				{
					t_DayOne.Abort();
				}
			}
			if(t_DayTwo != null)
			{
				if(t_DayTwo.IsAlive)
				{
					t_DayTwo.Abort();
				}
			}
			if(t_DayThree != null)
			{
				if(t_DayThree.IsAlive)
				{
					t_DayThree.Abort();
				}
			}
			if(t_DayFour != null)
			{
				if(t_DayFour.IsAlive)
				{
					t_DayFour.Abort();
				}
			}
			if(t_DayFive != null)
			{
				if(t_DayFive.IsAlive)
				{
					t_DayFive.Abort();
				}
			}
			if(t_DaySix != null)
			{
				if(t_DaySix.IsAlive)
				{
					t_DaySix.Abort();
				}
			}
			if(t_DaySeven != null)
			{
				if(t_DaySeven.IsAlive)
				{
					t_DaySeven.Abort();
				}
			}
		}
		public bool HasProcessed
		{
			get
			{
				return bHasProcessed;
			}
		}
		public bool StillProcessing
		{
			get
			{
				return bIsStillProcessing;
			}
//			set 
//			{
//				if(IsStillProcessing!=value) 
//				{
//					IsStillProcessing = value;
//				}
//			}
		}


	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocaupld\makefile.inc ===
$(O)\ocaupldp.def : ocaupld.def
   @echo Creating $@ from $?
    $(C_PREPROCESSOR_NAME) /DPRIVATE= $(C_PREPROCESSOR_FLAGS) $** > $@

$(O)\ocaupldp.lib : $(O)\ocaupldp.def 
    -$(LIB_NAME) -out:$@ $(LIBRARIAN_FLAGS) @<<
-def:$(O)\ocaupldp.def
<<NOKEEP
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocareports\frmsolutionstatus.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Threading;
using System.Text;

namespace OCAReports
{
	/// <summary>
	/// Summary description for frmSolutionStatus.
	/// </summary>
	public class frmSolutionStatus : System.Windows.Forms.Form
	{
		private System.Windows.Forms.TabControl tabControl1;
		private System.Windows.Forms.TabPage tabPage1;
		private AxMSChart20Lib.AxMSChart axMSChart1;
		private System.Windows.Forms.TabPage tabPage2;
		private System.Windows.Forms.TabPage tabPage3;
		private System.Windows.Forms.Label label5;
		private System.Windows.Forms.Label label7;
		private System.Windows.Forms.ProgressBar progressBar1;
		private System.Windows.Forms.Label lblPurpose;
		private System.Windows.Forms.StatusBar statusBar1;
		private System.Windows.Forms.Label lblStatement;
		private System.Windows.Forms.MonthCalendar monthCalendar1;
		private System.ComponentModel.Container components = null;
		/// <summary>
		/// Required designer variable.
		/// </summary>

		#region ########################Global Variables######################################33
		/*************************************************************************************
		*	module: frmAnonCust.cs - Global varibles and objects
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: All global threads and variables are declared.
		*	
		*************************************************************************************/
		public long[] lSpecific = new long[7];
		public long[] lGeneral = new long[7];
		public long[] lStopCode = new long[7];
		public long[] lNoSolution = new long[7];
		public DateTime[] lDate = new DateTime[7];

		Thread t_DayOne;
		Thread t_DayTwo;
		Thread t_DayThree;
		Thread t_DayFour;
		Thread t_DayFive;
		Thread t_DaySix;
		Thread t_DaySeven;
		private bool bIsStillProcessing = false;
		private bool bHasProcessed = false;
		#endregion
		public frmSolutionStatus()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//

		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if(components != null)
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(frmSolutionStatus));
			this.tabControl1 = new System.Windows.Forms.TabControl();
			this.tabPage1 = new System.Windows.Forms.TabPage();
			this.axMSChart1 = new AxMSChart20Lib.AxMSChart();
			this.tabPage2 = new System.Windows.Forms.TabPage();
			this.tabPage3 = new System.Windows.Forms.TabPage();
			this.label5 = new System.Windows.Forms.Label();
			this.label7 = new System.Windows.Forms.Label();
			this.progressBar1 = new System.Windows.Forms.ProgressBar();
			this.lblPurpose = new System.Windows.Forms.Label();
			this.statusBar1 = new System.Windows.Forms.StatusBar();
			this.lblStatement = new System.Windows.Forms.Label();
			this.monthCalendar1 = new System.Windows.Forms.MonthCalendar();
			this.tabControl1.SuspendLayout();
			this.tabPage1.SuspendLayout();
			((System.ComponentModel.ISupportInitialize)(this.axMSChart1)).BeginInit();
			this.tabPage3.SuspendLayout();
			this.SuspendLayout();
			// 
			// tabControl1
			// 
			this.tabControl1.Controls.AddRange(new System.Windows.Forms.Control[] {
																					  this.tabPage1,
																					  this.tabPage2,
																					  this.tabPage3});
			this.tabControl1.Location = new System.Drawing.Point(8, 88);
			this.tabControl1.Name = "tabControl1";
			this.tabControl1.SelectedIndex = 0;
			this.tabControl1.Size = new System.Drawing.Size(736, 400);
			this.tabControl1.TabIndex = 92;
			// 
			// tabPage1
			// 
			this.tabPage1.Controls.AddRange(new System.Windows.Forms.Control[] {
																				   this.axMSChart1});
			this.tabPage1.Location = new System.Drawing.Point(4, 22);
			this.tabPage1.Name = "tabPage1";
			this.tabPage1.Size = new System.Drawing.Size(728, 374);
			this.tabPage1.TabIndex = 0;
			this.tabPage1.Text = "Graphical";
			// 
			// axMSChart1
			// 
			this.axMSChart1.ContainingControl = this;
			this.axMSChart1.DataSource = null;
			this.axMSChart1.Location = new System.Drawing.Point(8, 8);
			this.axMSChart1.Name = "axMSChart1";
			this.axMSChart1.OcxState = ((System.Windows.Forms.AxHost.State)(resources.GetObject("axMSChart1.OcxState")));
			this.axMSChart1.Size = new System.Drawing.Size(720, 344);
			this.axMSChart1.TabIndex = 71;
			this.axMSChart1.ChartSelected += new AxMSChart20Lib._DMSChartEvents_ChartSelectedEventHandler(this.axMSChart1_ChartSelected);
			// 
			// tabPage2
			// 
			this.tabPage2.Location = new System.Drawing.Point(4, 22);
			this.tabPage2.Name = "tabPage2";
			this.tabPage2.Size = new System.Drawing.Size(728, 374);
			this.tabPage2.TabIndex = 1;
			this.tabPage2.Text = "Statistical";
			this.tabPage2.Visible = false;
			this.tabPage2.Paint += new System.Windows.Forms.PaintEventHandler(this.tabPage2_Paint);
			// 
			// tabPage3
			// 
			this.tabPage3.Controls.AddRange(new System.Windows.Forms.Control[] {
																				   this.label5,
																				   this.label7});
			this.tabPage3.Location = new System.Drawing.Point(4, 22);
			this.tabPage3.Name = "tabPage3";
			this.tabPage3.Size = new System.Drawing.Size(728, 374);
			this.tabPage3.TabIndex = 2;
			this.tabPage3.Text = "Notes";
			this.tabPage3.Visible = false;
			// 
			// label5
			// 
			this.label5.Location = new System.Drawing.Point(32, 72);
			this.label5.Name = "label5";
			this.label5.Size = new System.Drawing.Size(576, 56);
			this.label5.TabIndex = 80;
			this.label5.Text = @"The Stop Code troubleshooter solutions are displayed should a specific or general solution not exist and the stop code associated with the stop error link to a known Knowledge Base article.  There will eventually be replaced by general solutions when teh full set of general buckets have been identified and solutions developed.";
			// 
			// label7
			// 
			this.label7.Font = new System.Drawing.Font("Microsoft Sans Serif", 10F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.label7.Location = new System.Drawing.Point(32, 32);
			this.label7.Name = "label7";
			this.label7.Size = new System.Drawing.Size(240, 24);
			this.label7.TabIndex = 76;
			this.label7.Text = "Notes";
			// 
			// progressBar1
			// 
			this.progressBar1.Location = new System.Drawing.Point(568, 502);
			this.progressBar1.Name = "progressBar1";
			this.progressBar1.Size = new System.Drawing.Size(384, 23);
			this.progressBar1.TabIndex = 89;
			this.progressBar1.Visible = false;
			// 
			// lblPurpose
			// 
			this.lblPurpose.Font = new System.Drawing.Font("Microsoft Sans Serif", 12F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((System.Byte)(0)));
			this.lblPurpose.Location = new System.Drawing.Point(8, 2);
			this.lblPurpose.Name = "lblPurpose";
			this.lblPurpose.Size = new System.Drawing.Size(112, 24);
			this.lblPurpose.TabIndex = 91;
			this.lblPurpose.Text = "Purpose";
			// 
			// statusBar1
			// 
			this.statusBar1.Location = new System.Drawing.Point(0, 512);
			this.statusBar1.Name = "statusBar1";
			this.statusBar1.Size = new System.Drawing.Size(968, 22);
			this.statusBar1.TabIndex = 88;
			// 
			// lblStatement
			// 
			this.lblStatement.Location = new System.Drawing.Point(8, 32);
			this.lblStatement.Name = "lblStatement";
			this.lblStatement.Size = new System.Drawing.Size(744, 40);
			this.lblStatement.TabIndex = 90;
			this.lblStatement.Text = @"The information below outlines the relationship between files in our database and the associated solution status.  The table header describes the type of solution displayed to the customer.  In the case of no solution, the Online Crash Analysis Web site displays information indicating that our service is currently researching the issue in question.";
			// 
			// monthCalendar1
			// 
			this.monthCalendar1.Location = new System.Drawing.Point(760, 82);
			this.monthCalendar1.Name = "monthCalendar1";
			this.monthCalendar1.TabIndex = 86;
			this.monthCalendar1.DateSelected += new System.Windows.Forms.DateRangeEventHandler(this.monthCalendar1_DateSelected);
			// 
			// frmSolutionStatus
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(968, 534);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.tabControl1,
																		  this.progressBar1,
																		  this.lblPurpose,
																		  this.statusBar1,
																		  this.lblStatement,
																		  this.monthCalendar1});
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.Name = "frmSolutionStatus";
			this.Text = "frmSolutionStatus";
			this.Resize += new System.EventHandler(this.frmSolutionStatus_Resize);
			this.Closing += new System.ComponentModel.CancelEventHandler(this.frmSolutionStatus_Closing);
			this.Load += new System.EventHandler(this.frmSolutionStatus_Load);
			this.tabControl1.ResumeLayout(false);
			this.tabPage1.ResumeLayout(false);
			((System.ComponentModel.ISupportInitialize)(this.axMSChart1)).EndInit();
			this.tabPage3.ResumeLayout(false);
			this.ResumeLayout(false);

		}
		#endregion

		/*************************************************************************************
		*	module: frmSolutionStatus.cs - frmSolutionStatus_Load
		*
		*	author: Tim Ragain
		*	date: Jan 23, 2002
		*
		*	Purpose: Initialize the calendar control to display one week. Each day is represented
		*	by a global thread.  Set the form title bar to the appropriate start and end days.
		*************************************************************************************/
		private void frmSolutionStatus_Load(object sender, System.EventArgs e)
		{
			DateTime dDate = DateTime.Today;
			short x = 0, y = 0;

			for(x=7, y=1;x>=1;x--, y++)
			{
				axMSChart1.Row = y;
				axMSChart1.RowLabel = dDate.AddDays(-(x)).ToShortDateString(); //+ dDate.Date.ToString();
			}
			monthCalendar1.SelectionStart = dDate.AddDays(-7);
			monthCalendar1.SelectionEnd = dDate.AddDays(-1);
			this.Show();
			this.Refresh();
			axMSChart1.RowCount = 7;
			this.ParentForm.Refresh();
			this.Text = "Solutions Status  " + monthCalendar1.SelectionStart.ToShortDateString() + " - " +
				monthCalendar1.SelectionEnd.ToShortDateString();
		
		}
		/*************************************************************************************
		*	module: frmSolutionStatus.cs - frmSolutionStatus_Resize
		*
		*	author: Tim Ragain
		*	date: Jan 24, 2002
		*
		*	Purpose: to set the controls to the proper position and resize after resizing
		*	the form
		*************************************************************************************/
		private void frmSolutionStatus_Resize(object sender, System.EventArgs e)
		{
			int buf = 20;

			progressBar1.Top = statusBar1.Top;
			progressBar1.Left = this.Width - progressBar1.Width;
			monthCalendar1.Left = this.Width - (monthCalendar1.Width + buf);
//			cmdGetData.Left = monthCalendar1.Left;
			tabControl1.Width = this.Width - (monthCalendar1.Width + (buf * 3));
			tabControl1.Height = this.Height - (statusBar1.Height + lblPurpose.Height + lblStatement.Height + (buf * 4));
			axMSChart1.Height = tabPage1.Height - buf;
			axMSChart1.Width = tabPage1.Width - buf;
		}
		/*************************************************************************************
		*	module: frmSolutionStatus.cs - monthCalendar1_DateSelected
		*
		*	author: Tim Ragain
		*	date: Jan 24, 2002
		*
		*	Purpose: To set the selection dates for one week after the user selects an ending
		*	date.  Also resets the title bar of the form for the new dates.
		*************************************************************************************/
		private void monthCalendar1_DateSelected(object sender, System.Windows.Forms.DateRangeEventArgs e)
		{
			System.DateTime dDate = new System.DateTime(monthCalendar1.SelectionStart.Year, monthCalendar1.SelectionStart.Month, 
				monthCalendar1.SelectionStart.Day);

			monthCalendar1.SelectionStart = dDate.AddDays(-6);
			monthCalendar1.SelectionEnd = dDate.Date;
			this.Text = "Executive Summary Weekly Report  " + monthCalendar1.SelectionStart.ToShortDateString() + " - " +
				monthCalendar1.SelectionEnd.ToShortDateString();

			tabPage2.Refresh();

		}
		public void GetData()
		{
			short x = 0;
			System.DateTime dDate = new System.DateTime(monthCalendar1.SelectionStart.Year, monthCalendar1.SelectionStart.Month, 
				monthCalendar1.SelectionStart.Day);
			axMSChart1.ColumnCount = 4;
			axMSChart1.RowCount = 7;
//			cmdGetData.Enabled = false;
			bIsStillProcessing = true;
			progressBar1.Visible = true;
			progressBar1.Minimum = 0;
			progressBar1.Maximum = 35;
			progressBar1.Value = 0;
			progressBar1.Refresh();
			axMSChart1.ShowLegend = true;
			axMSChart1.Plot.SeriesCollection[1].LegendText = "Specific";
			axMSChart1.Plot.SeriesCollection[2].LegendText = "General";
			axMSChart1.Plot.SeriesCollection[3].LegendText = "Stop Code";
			axMSChart1.Plot.SeriesCollection[4].LegendText = "No Solution";
			for(x=1;x<8;x++)
			{
				axMSChart1.Row = x;
				axMSChart1.RowLabel = dDate.AddDays(x-1).ToShortDateString(); //+ dDate.Date.ToString();
			}

			ThreadStart s_DayOne = new ThreadStart(this.TDayOne);
			t_DayOne = new Thread(s_DayOne);
			t_DayOne.Name = "Thread One";
			

			ThreadStart s_DayTwo = new ThreadStart(this.TDayTwo);
			t_DayTwo = new Thread(s_DayTwo);
			t_DayTwo.Name = "Thread Two";

			ThreadStart s_DayThree = new ThreadStart(this.TDayThree);
			t_DayThree = new Thread(s_DayThree);
			t_DayThree.Name = "Thread Three";

			ThreadStart s_DayFour = new ThreadStart(this.TDayFour);
			t_DayFour = new Thread(s_DayFour);
			t_DayFour.Name = "Thread Four";

			ThreadStart s_DayFive = new ThreadStart(this.TDayFive);
			t_DayFive = new Thread(s_DayFive);
			t_DayFive.Name = "Thread Five";

			ThreadStart s_DaySix = new ThreadStart(this.TDaySix);
			t_DaySix = new Thread(s_DaySix);
			t_DaySix.Name = "Thread Six";

			ThreadStart s_DaySeven = new ThreadStart(this.TDaySeven);
			t_DaySeven = new Thread(s_DaySeven);
			t_DaySeven.Name = "Thread Seven";


			t_DayOne.Start();		
			t_DayTwo.Start();
			t_DayThree.Start();
			t_DayFour.Start();
			t_DayFive.Start();
			t_DaySix.Start();
			t_DaySeven.Start();
		}
		/*************************************************************************************
		*	module: frmSolutionStatus.cs - All procedures 
		*
		*	author: Tim Ragain
		*	date: Jan 24, 2002
		*
		*	Purpose: calls TLoadData and sends the appropriate day and count information.
		*	
		*************************************************************************************/
		private void TDayOne()
		{
			this.TLoadData(0, 1);
		}
		private void TDayTwo()
		{
			this.TLoadData(1, 2);
		}
		private void TDayThree()
		{
			this.TLoadData(2, 3);
		}
		private void TDayFour()
		{
			this.TLoadData(3, 4);
		}
		private void TDayFive()
		{
			this.TLoadData(4, 5);
		}
		private void TDaySix()
		{
			this.TLoadData(5, 6);
		}
		private void TDaySeven()
		{
			this.TLoadData(6, 7);
		}
		/*************************************************************************************
		*	module: frmSolutionStatus.cs - TLoadData
		*
		*	author: Tim Ragain
		*	date: Jan 24, 2002
		*
		*	Purpose: Takes two variables the x represents the day as an integer and the sCount is a 
		*	short representing the column of the Calendar control.  This initializes the OCAData.dll
		*	control and calls the GetDailyCount and GetDailyAnon procedures.  The anonymous count is
		*	subtracted from the total count to get the customer count.  The appropriate column 
		*	and row is updated.
		*************************************************************************************/
		private void TLoadData(int x, short sCount)
		{
			OCAData.CCountDailyClass rpt = new OCAData.CCountDailyClass();
			System.DateTime dDate = new System.DateTime(monthCalendar1.SelectionStart.Year, monthCalendar1.SelectionStart.Month, 
				monthCalendar1.SelectionStart.Day);

			long l_SpecificSolutions = 0, l_GeneralSolutions = 0, l_StopCodes = 0, l_TotalRecords = 0;

			//***********Total Record Count***************
			UpdateStatus();
			statusBar1.Text = "Getting Specific Solutions for " + dDate.AddDays(x).Date.ToString();
			lDate[x] = dDate.AddDays(x);

			try
			{
				l_SpecificSolutions = rpt.GetSpecificSolutions(dDate.AddDays(x));
			}
			catch
			{
				l_SpecificSolutions = -1;
			}
			lock(this)
			{
				axMSChart1.Row = sCount;
				axMSChart1.Column = (short)1;
				axMSChart1.RowLabel = dDate.AddDays(x).ToShortDateString(); //+ dDate.Date.ToString();
				axMSChart1.Data = l_SpecificSolutions.ToString();
				lSpecific[x] = l_SpecificSolutions;
			}

			UpdateStatus();
			statusBar1.Text = "Getting General Solutions for " + dDate.AddDays(x).Date.ToString();
			try
			{
				l_GeneralSolutions = rpt.GetGeneralSolutions(dDate.AddDays(x));
			}
			catch
			{
				l_GeneralSolutions = -1;
			}
			lock(this)
			{
				axMSChart1.Row = sCount;
				axMSChart1.Column = (short)2;
				axMSChart1.Data = l_GeneralSolutions.ToString();
				lGeneral[x] = l_GeneralSolutions;
			}
			UpdateStatus();
			statusBar1.Text = "Getting Stop Code Troubleshooters for " + dDate.AddDays(x).Date.ToString();
			try
			{
				l_StopCodes = rpt.GetStopCodeSolutions(dDate.AddDays(x));
			}
			catch
			{
				l_StopCodes = -1;
			}
			lock(this)
			{
				axMSChart1.Row = sCount;
				axMSChart1.Column = (short)3;
				axMSChart1.Data = l_StopCodes.ToString();
				lStopCode[x] = l_StopCodes;
			}
			UpdateStatus();
			statusBar1.Text = "Getting No Solution incidents for " + dDate.AddDays(x).Date.ToString();
			try
			{
				l_TotalRecords = rpt.GetDailyCount(dDate.AddDays(x));
			}
			catch
			{
				l_TotalRecords = -1;
			}
			lock(this)
			{
				axMSChart1.Row = sCount;
				axMSChart1.Column = (short)4;
				l_TotalRecords = l_TotalRecords - (l_StopCodes + l_GeneralSolutions + l_SpecificSolutions);
				axMSChart1.Data = l_TotalRecords.ToString();
				lNoSolution[x] = l_TotalRecords;
			}
			UpdateStatus();
			this.Refresh();
		}
		/*************************************************************************************
		*	module: frmSolutionStatus.cs - UpdateStatus
		*
		*	author: Tim Ragain
		*	date: Jan 24, 2002
		*
		*	Purpose: This updates the progress bar and when all threads are returned the 
		*	status bar is updated to done and the cmdGetData button is enabled.
		*************************************************************************************/
		private void UpdateStatus()
		{
			progressBar1.Value = progressBar1.Value + 1;
			axMSChart1.Refresh();
			progressBar1.Refresh();
			if(progressBar1.Value >= 34)
			{
				statusBar1.Text = "Done";
				progressBar1.Visible = false;
//				cmdGetData.Enabled = true;
				bIsStillProcessing = false;
				bHasProcessed = true;
			}

		}
		/*************************************************************************************
		*	module: frmSolutionStatus.cs - tabPage2_Paint
		*
		*	author: Tim Ragain
		*	date: Jan 24, 2002
		*
		*	Purpose: Paints the grid for the tab2 control.  The global variables lAnonymous[x] and 
		*	lCustomer[x] are used to display the appropriate information to the grid.  
		*************************************************************************************/
		private void tabPage2_Paint(object sender, System.Windows.Forms.PaintEventArgs e)
		{
			Pen curvePen = new Pen(Color.Blue);
			Pen dbPen = new Pen(Color.DarkBlue);
			Pen whPen = new Pen(Color.White);
			float row = .05F;
			int x = 0, y = 0, min = 3, max = 12, pad = 10, top = 5, cols=5;
			int colwidth = 0;
			PointF pt = new PointF(0, 0);
			Font ft = new Font("Verdona", 12);
			SolidBrush sb = new SolidBrush(Color.Black);
			StringBuilder strTemp = new StringBuilder(40);
			System.DateTime dDate = new System.DateTime(monthCalendar1.SelectionEnd.Year, monthCalendar1.SelectionEnd.Month, 
				monthCalendar1.SelectionEnd.Day);

			colwidth = tabPage2.Width / cols;

			for(x=min;x<max;x++)
			{
				if(x > (min - 1) && x < top)
				{
					e.Graphics.DrawLine(dbPen,  pad, tabPage2.Height * (row * x), 
						tabPage2.Width - pad, tabPage2.Height * (row * x));
				}
				else
				{
					e.Graphics.DrawLine(curvePen,  pad, tabPage2.Height * (row * x), 
						tabPage2.Width - pad, tabPage2.Height * (row * x));
				}
			}
			//x y x1 y1
			for(x=0;x<cols;x++)
			{

				//left side light blue
				e.Graphics.DrawLine(curvePen,  pad + (colwidth * x), 
					tabPage2.Height * (row * (min + 1)), 
					pad + (colwidth * x), tabPage2.Height * (row * (max - 1)));
				//right side light blue
				e.Graphics.DrawLine(curvePen,  tabPage2.Width - pad, 
					tabPage2.Height * (row * (min + 1)), 
					tabPage2.Width - pad, tabPage2.Height * (row * (max - 1)));
				//left side upper dark blue
				e.Graphics.DrawLine(dbPen,  pad + (colwidth * x), 
					tabPage2.Height * (row * min), 
					pad + (colwidth * x), tabPage2.Height * (row * (min + 1)));
				//right side upper dark blue
				e.Graphics.DrawLine(dbPen,  tabPage2.Width - pad, 
					tabPage2.Height * (row * min), 
					tabPage2.Width - pad, tabPage2.Height * (row * (min + 1)));
			}
			for(x=0,y=6;x<7;x++,y--)
			{
				pt.X =  pad + (colwidth * x);
				pt.Y = tabPage2.Height * (row * min);
				strTemp.Remove(0, strTemp.Length);
				switch(x)
				{
					case 0:
						strTemp.Append("Date");
						break;
					case 1:
						strTemp.Append("Specific");
						break;
					case 2:
						strTemp.Append("General");
						break;
					case 3:
						strTemp.Append("Stop Code");
						break;
					case 4:
						strTemp.Append("No Solution");
						break;
					default:
						strTemp.Append("");
						break;
				}
				e.Graphics.DrawString(strTemp.ToString(), ft, sb, pt, System.Drawing.StringFormat.GenericDefault);
				pt.X =  pad + (colwidth * 0);
				pt.Y = ((tabPage2.Height * row) * (min + (x + 1)));
				e.Graphics.DrawString(dDate.AddDays(-y).Date.ToShortDateString(), ft, sb, pt, System.Drawing.StringFormat.GenericDefault);
				pt.X =  pad + (colwidth * 1);
				pt.Y = ((tabPage2.Height * row) * (min + (x + 1)));
				e.Graphics.DrawString(lSpecific[x].ToString(), ft, sb, pt, System.Drawing.StringFormat.GenericDefault);
				pt.X =  pad + (colwidth * 2);
				pt.Y = ((tabPage2.Height * row) * (min + (x + 1)));
				e.Graphics.DrawString(lGeneral[x].ToString(), ft, sb, pt, System.Drawing.StringFormat.GenericDefault);
				pt.X =  pad + (colwidth * 3);
				pt.Y = ((tabPage2.Height * row) * (min + (x + 1)));
				e.Graphics.DrawString(lStopCode[x].ToString(), ft, sb, pt, System.Drawing.StringFormat.GenericDefault);
				pt.X =  pad + (colwidth * 4);
				pt.Y = ((tabPage2.Height * row) * (min + (x + 1)));
				e.Graphics.DrawString(lNoSolution[x].ToString(), ft, sb, pt, System.Drawing.StringFormat.GenericDefault);
				
			}
			curvePen.Dispose();
			dbPen.Dispose();
			whPen.Dispose();
		}
		/*************************************************************************************
		*	module: frmAnonCust.cs - frmAnonCust_Closing
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: If any threads are still  alive meaning the user prematurely closes the form
		*	before all threads are returned then the threads are checked to see if they are still
		*	running and if so then the thread is aborted.
		*************************************************************************************/
		private void frmSolutionStatus_Closing(object sender, System.ComponentModel.CancelEventArgs e)
		{
			if(t_DayOne != null)
			{
				if(t_DayOne.IsAlive)
				{
					t_DayOne.Abort();
				}
			}
			if(t_DayTwo != null)
			{
				if(t_DayTwo.IsAlive)
				{
					t_DayTwo.Abort();
				}
			}
			if(t_DayThree != null)
			{
				if(t_DayThree.IsAlive)
				{
					t_DayThree.Abort();
				}
			}
			if(t_DayFour != null)
			{
				if(t_DayFour.IsAlive)
				{
					t_DayFour.Abort();
				}
			}
			if(t_DayFive != null)
			{
				if(t_DayFive.IsAlive)
				{
					t_DayFive.Abort();
				}
			}
			if(t_DaySix != null)
			{
				if(t_DaySix.IsAlive)
				{
					t_DaySix.Abort();
				}
			}
			if(t_DaySeven != null)
			{
				if(t_DaySeven.IsAlive)
				{
					t_DaySeven.Abort();
				}
			}
		}
		public bool HasProcessed
		{
			get
			{
				return bHasProcessed;
			}
		}
		public bool StillProcessing
		{
			get
			{
				return bIsStillProcessing;
			}
		}
		private void axMSChart1_ChartSelected(object sender, AxMSChart20Lib._DMSChartEvents_ChartSelectedEvent e)
		{
		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocaupld\ocaupld.h ===
/*******************************************************************
*
*    DESCRIPTION:
*               Header for uploading file to server
*
*    DATE:8/22/2002
*
*******************************************************************/

#include <inetupld.h>

#ifndef __UPLOAD_H_
#define __UPLOAD_H_

#define _USE_WINHTTP 1

#ifdef _USE_WINHTTP
#include <winhttp.h>
#include <winhttpi.h>
#else
#include <wininet.h>
#endif



class UploadFile : public IOcaUploadFile {
public:
    UploadFile();
    ~UploadFile();

    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    STDMETHOD(InitializeSession)(
        THIS_
        LPWSTR OptionCode,
        LPWSTR wszFileToSend
        );
    STDMETHOD(SendFile)(
        THIS_
        LPWSTR wszRemoteFileName,
        BOOL bSecureMode
        );
    STDMETHOD(UnInitialize)(
        THIS_
        );
    STDMETHOD(Cancel)(
        THIS_
        );

    STDMETHOD(GetUrlPageData)(
        THIS_
        LPWSTR wszUrl,
        LPWSTR wszUrlPage,
        ULONG cbUrlPage
        );
    STDMETHOD_(ULONG, GetPercentComplete)(
        THIS_
        );
    STDMETHOD_(LPWSTR, GetServerName)(
        THIS_
        );
    STDMETHOD_(BOOL, IsUploadInProgress)(
        THIS_
        );
    STDMETHOD_(BOOL, GetUploadResult)(
        THIS_
        LPTSTR Result,
        ULONG cbResult
        );

    STDMETHOD(SetUploadResult)(
        THIS_
        EnumUploadStatus Success,
        LPCTSTR Text
        );


private:

    HRESULT OpenSession();
    HRESULT SetFileToSend(LPWSTR wszFileName);
    BOOL CheckCancelRequest();
    HRESULT CreateCancelEventObject();
    HRESULT GetSessionRedirUrl(LPWSTR SessionUrl, LPWSTR wszRedirUrl, ULONG SizeofRedirUrl);
    HRESULT OpenConnection(LPWSTR wszRemoteFileName,
                           BOOL bSecureMode);
    HRESULT StartSend();
    HRESULT CompleteSend();
    HRESULT CloseConnection();
    HRESULT CloseSession();

    HRESULT GetProxySettings(LPWSTR wszServerName, ULONG ServerNameSIze,
                             LPWSTR wszByPass, ULONG ByPassSize);
    BOOL FireCancelEvent();
    BOOL GetRedirServerName(LPWSTR OptionCode, LPWSTR ConnectUrl,
                            LPWSTR lpwszServerName, ULONG dwServerNameLength,
                            LPWSTR lpwszUrl, ULONG UrlLength);

    ULONG m_Refs;
    BOOL m_fInitialized;
    LPCTSTR m_szFile;
    ULONG64 m_Sent;
    ULONG64 m_Size;
    HANDLE    m_hCancelEvent;
    HANDLE    m_hFile;
    HINTERNET m_hSession;
    HINTERNET m_hConnect;
    HINTERNET m_hRequest;
    ULONG     m_NumTries;
    WCHAR     m_wszServerName[MAX_PATH];
    EnumUploadStatus  m_fLastUploadStatus;
    ULONG     m_dwConnectPercentage;
    WCHAR     m_wszLastUploadResult[MAX_PATH];
};

#endif // __UPLOAD_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocareports\frmmain.cs ===
using System;
using System.Drawing;
using System.Collections;
using System.ComponentModel;
using System.Windows.Forms;
using System.Data;
using System.Reflection;
using System.Threading;


namespace OCAReports
{
	/// <summary>
	/// Summary description for Form1.
	/// </summary>
	public class frmMain : System.Windows.Forms.Form
	{
		private System.Windows.Forms.MainMenu mainMenu1;
		private System.Windows.Forms.MenuItem mnuFile;
		private System.Windows.Forms.MenuItem mnuFileExit;
		private System.Windows.Forms.MenuItem menuItem1;
		private System.Windows.Forms.MenuItem mnuDataDaily;
		private System.Windows.Forms.MenuItem mnuDataWeekly;
		private System.Windows.Forms.MenuItem menuItem2;
		private System.Windows.Forms.MenuItem mnuAnonCustomer;
		private System.Windows.Forms.MenuItem mnuAutoMan;
		private System.Windows.Forms.MenuItem mnuSolutionStatus;
		private System.Windows.Forms.MenuItem mnuAbout;
		private System.Windows.Forms.ToolBar toolBar1;
		private System.Windows.Forms.ToolBarButton toolBarButton1;
		private System.Windows.Forms.ToolBarButton toolBarButton2;
		private System.Windows.Forms.ToolBarButton toolBarButton3;
		private System.Windows.Forms.ToolBarButton toolBarButton4;
		private System.Windows.Forms.ToolBarButton toolBarButton5;
		private System.Windows.Forms.ToolBarButton toolBarButton6;
		private System.Windows.Forms.ToolBarButton toolBarButton7;
		private System.Windows.Forms.ToolBarButton toolBarButton8;
		private System.Windows.Forms.ToolBarButton toolBarButton9;
		private System.Windows.Forms.ImageList imageList1;
		private System.Windows.Forms.MenuItem menuItem3;
		private System.Windows.Forms.MenuItem mnuOptions;
		private System.Windows.Forms.MenuItem mnuExport;
		private System.Windows.Forms.MenuItem menuItem5;
		private System.Windows.Forms.ToolBarButton toolBarButton10;
		private System.Windows.Forms.ToolBarButton cmdExport;
		private System.Windows.Forms.ToolBarButton toolBarButton11;
		private System.Windows.Forms.ToolBarButton toolBarButton12;
		private System.Windows.Forms.MenuItem mnuRefresh;
		private System.Windows.Forms.ToolBarButton toolBarButton15;
		private System.Windows.Forms.Timer timer1;
		private System.Windows.Forms.ToolBarButton toolBarButton16;
		private System.Windows.Forms.ToolBarButton toolBarButton17;
		private System.Windows.Forms.ToolBarButton toolBarButton18;
		private System.Windows.Forms.MenuItem menuItem4;
		private System.ComponentModel.IContainer components;

		public frmMain()
		{
			//
			// Required for Windows Form Designer support
			//
			InitializeComponent();

			//
			// TODO: Add any constructor code after InitializeComponent call
			//
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if( disposing )
			{
				if (components != null) 
				{
					components.Dispose();
				}
			}
			base.Dispose( disposing );
		}

		#region Windows Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
			this.components = new System.ComponentModel.Container();
			System.Resources.ResourceManager resources = new System.Resources.ResourceManager(typeof(frmMain));
			this.mainMenu1 = new System.Windows.Forms.MainMenu();
			this.mnuFile = new System.Windows.Forms.MenuItem();
			this.mnuRefresh = new System.Windows.Forms.MenuItem();
			this.mnuExport = new System.Windows.Forms.MenuItem();
			this.menuItem5 = new System.Windows.Forms.MenuItem();
			this.mnuFileExit = new System.Windows.Forms.MenuItem();
			this.menuItem1 = new System.Windows.Forms.MenuItem();
			this.mnuDataDaily = new System.Windows.Forms.MenuItem();
			this.mnuDataWeekly = new System.Windows.Forms.MenuItem();
			this.mnuAnonCustomer = new System.Windows.Forms.MenuItem();
			this.mnuAutoMan = new System.Windows.Forms.MenuItem();
			this.mnuSolutionStatus = new System.Windows.Forms.MenuItem();
			this.menuItem3 = new System.Windows.Forms.MenuItem();
			this.mnuOptions = new System.Windows.Forms.MenuItem();
			this.menuItem2 = new System.Windows.Forms.MenuItem();
			this.mnuAbout = new System.Windows.Forms.MenuItem();
			this.toolBar1 = new System.Windows.Forms.ToolBar();
			this.toolBarButton1 = new System.Windows.Forms.ToolBarButton();
			this.toolBarButton2 = new System.Windows.Forms.ToolBarButton();
			this.toolBarButton4 = new System.Windows.Forms.ToolBarButton();
			this.toolBarButton5 = new System.Windows.Forms.ToolBarButton();
			this.toolBarButton15 = new System.Windows.Forms.ToolBarButton();
			this.toolBarButton3 = new System.Windows.Forms.ToolBarButton();
			this.toolBarButton6 = new System.Windows.Forms.ToolBarButton();
			this.cmdExport = new System.Windows.Forms.ToolBarButton();
			this.toolBarButton10 = new System.Windows.Forms.ToolBarButton();
			this.toolBarButton7 = new System.Windows.Forms.ToolBarButton();
			this.toolBarButton11 = new System.Windows.Forms.ToolBarButton();
			this.toolBarButton12 = new System.Windows.Forms.ToolBarButton();
			this.toolBarButton17 = new System.Windows.Forms.ToolBarButton();
			this.toolBarButton16 = new System.Windows.Forms.ToolBarButton();
			this.toolBarButton18 = new System.Windows.Forms.ToolBarButton();
			this.toolBarButton8 = new System.Windows.Forms.ToolBarButton();
			this.toolBarButton9 = new System.Windows.Forms.ToolBarButton();
			this.imageList1 = new System.Windows.Forms.ImageList(this.components);
			this.timer1 = new System.Windows.Forms.Timer(this.components);
			this.menuItem4 = new System.Windows.Forms.MenuItem();
			this.SuspendLayout();
			// 
			// mainMenu1
			// 
			this.mainMenu1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.mnuFile,
																					  this.menuItem1,
																					  this.menuItem3,
																					  this.menuItem2});
			// 
			// mnuFile
			// 
			this.mnuFile.Index = 0;
			this.mnuFile.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					this.mnuRefresh,
																					this.menuItem4,
																					this.mnuExport,
																					this.menuItem5,
																					this.mnuFileExit});
			this.mnuFile.Text = "&File";
			// 
			// mnuRefresh
			// 
			this.mnuRefresh.Index = 0;
			this.mnuRefresh.Shortcut = System.Windows.Forms.Shortcut.F5;
			this.mnuRefresh.Text = "&Refresh";
			this.mnuRefresh.Click += new System.EventHandler(this.mnuRefresh_Click);
			// 
			// mnuExport
			// 
			this.mnuExport.Index = 2;
			this.mnuExport.Text = "&Export...";
			this.mnuExport.Click += new System.EventHandler(this.mnuExport_Click);
			// 
			// menuItem5
			// 
			this.menuItem5.Index = 3;
			this.menuItem5.Text = "-";
			// 
			// mnuFileExit
			// 
			this.mnuFileExit.Index = 4;
			this.mnuFileExit.Text = "E&xit";
			this.mnuFileExit.Click += new System.EventHandler(this.mnuFileExit_Click);
			// 
			// menuItem1
			// 
			this.menuItem1.Index = 1;
			this.menuItem1.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.mnuDataDaily,
																					  this.mnuDataWeekly,
																					  this.mnuAnonCustomer,
																					  this.mnuAutoMan,
																					  this.mnuSolutionStatus});
			this.menuItem1.Text = "&Data";
			// 
			// mnuDataDaily
			// 
			this.mnuDataDaily.Index = 0;
			this.mnuDataDaily.Text = "&Daily";
			this.mnuDataDaily.Click += new System.EventHandler(this.mnuDataDaily_Click);
			// 
			// mnuDataWeekly
			// 
			this.mnuDataWeekly.Index = 1;
			this.mnuDataWeekly.Text = "&Weekly";
			this.mnuDataWeekly.Click += new System.EventHandler(this.mnuDataWeekly_Click);
			// 
			// mnuAnonCustomer
			// 
			this.mnuAnonCustomer.Index = 2;
			this.mnuAnonCustomer.Text = "Anon/Customer";
			this.mnuAnonCustomer.Click += new System.EventHandler(this.mnuAnonCustomer_Click);
			// 
			// mnuAutoMan
			// 
			this.mnuAutoMan.Index = 3;
			this.mnuAutoMan.Text = "Auto/Manual";
			this.mnuAutoMan.Click += new System.EventHandler(this.mnuAutoMan_Click);
			// 
			// mnuSolutionStatus
			// 
			this.mnuSolutionStatus.Index = 4;
			this.mnuSolutionStatus.Text = "Solution Status";
			this.mnuSolutionStatus.Click += new System.EventHandler(this.mnuSolutionStatus_Click);
			// 
			// menuItem3
			// 
			this.menuItem3.Index = 2;
			this.menuItem3.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.mnuOptions});
			this.menuItem3.Text = "&Tools";
			// 
			// mnuOptions
			// 
			this.mnuOptions.Index = 0;
			this.mnuOptions.Text = "Options...";
			this.mnuOptions.Click += new System.EventHandler(this.mnuOptions_Click);
			// 
			// menuItem2
			// 
			this.menuItem2.Index = 3;
			this.menuItem2.MdiList = true;
			this.menuItem2.MenuItems.AddRange(new System.Windows.Forms.MenuItem[] {
																					  this.mnuAbout});
			this.menuItem2.Text = "&Help";
			// 
			// mnuAbout
			// 
			this.mnuAbout.Index = 0;
			this.mnuAbout.Text = "&About";
			this.mnuAbout.Click += new System.EventHandler(this.mnuAbout_Click);
			// 
			// toolBar1
			// 
			this.toolBar1.Buttons.AddRange(new System.Windows.Forms.ToolBarButton[] {
																						this.toolBarButton1,
																						this.toolBarButton2,
																						this.toolBarButton4,
																						this.toolBarButton5,
																						this.toolBarButton15,
																						this.toolBarButton3,
																						this.toolBarButton6,
																						this.cmdExport,
																						this.toolBarButton10,
																						this.toolBarButton7,
																						this.toolBarButton11,
																						this.toolBarButton12,
																						this.toolBarButton17,
																						this.toolBarButton16,
																						this.toolBarButton18,
																						this.toolBarButton8,
																						this.toolBarButton9});
			this.toolBar1.DropDownArrows = true;
			this.toolBar1.ImageList = this.imageList1;
			this.toolBar1.Name = "toolBar1";
			this.toolBar1.ShowToolTips = true;
			this.toolBar1.Size = new System.Drawing.Size(1028, 25);
			this.toolBar1.TabIndex = 1;
			this.toolBar1.ButtonClick += new System.Windows.Forms.ToolBarButtonClickEventHandler(this.toolBar1_ButtonClick);
			// 
			// toolBarButton1
			// 
			this.toolBarButton1.ImageIndex = 1;
			this.toolBarButton1.ToolTipText = "Anonymous vs Customer Report";
			// 
			// toolBarButton2
			// 
			this.toolBarButton2.ImageIndex = 7;
			this.toolBarButton2.ToolTipText = "Auto vs Manual Uploads Report";
			// 
			// toolBarButton4
			// 
			this.toolBarButton4.ImageIndex = 2;
			this.toolBarButton4.ToolTipText = "Solution Status Report";
			// 
			// toolBarButton5
			// 
			this.toolBarButton5.ImageIndex = 4;
			this.toolBarButton5.ToolTipText = "Weekly Report";
			// 
			// toolBarButton15
			// 
			this.toolBarButton15.Style = System.Windows.Forms.ToolBarButtonStyle.Separator;
			// 
			// toolBarButton3
			// 
			this.toolBarButton3.ImageIndex = 3;
			this.toolBarButton3.ToolTipText = "Daily Count Report";
			// 
			// toolBarButton6
			// 
			this.toolBarButton6.Style = System.Windows.Forms.ToolBarButtonStyle.Separator;
			// 
			// cmdExport
			// 
			this.cmdExport.ImageIndex = 8;
			this.cmdExport.ToolTipText = "Export Graphs To Excel Spreadsheet";
			// 
			// toolBarButton10
			// 
			this.toolBarButton10.Style = System.Windows.Forms.ToolBarButtonStyle.Separator;
			// 
			// toolBarButton7
			// 
			this.toolBarButton7.ImageIndex = 0;
			this.toolBarButton7.ToolTipText = "Set locations for Watson and Archive Servers";
			// 
			// toolBarButton11
			// 
			this.toolBarButton11.Style = System.Windows.Forms.ToolBarButtonStyle.Separator;
			// 
			// toolBarButton12
			// 
			this.toolBarButton12.ImageIndex = 9;
			this.toolBarButton12.ToolTipText = "Refresh Current Report";
			// 
			// toolBarButton17
			// 
			this.toolBarButton17.Style = System.Windows.Forms.ToolBarButtonStyle.Separator;
			// 
			// toolBarButton16
			// 
			this.toolBarButton16.ImageIndex = 12;
			this.toolBarButton16.ToolTipText = "One Touch Reporting";
			// 
			// toolBarButton18
			// 
			this.toolBarButton18.Style = System.Windows.Forms.ToolBarButtonStyle.Separator;
			// 
			// toolBarButton8
			// 
			this.toolBarButton8.Style = System.Windows.Forms.ToolBarButtonStyle.Separator;
			// 
			// toolBarButton9
			// 
			this.toolBarButton9.ImageIndex = 6;
			this.toolBarButton9.ToolTipText = "About";
			// 
			// imageList1
			// 
			this.imageList1.ColorDepth = System.Windows.Forms.ColorDepth.Depth8Bit;
			this.imageList1.ImageSize = new System.Drawing.Size(16, 16);
			this.imageList1.ImageStream = ((System.Windows.Forms.ImageListStreamer)(resources.GetObject("imageList1.ImageStream")));
			this.imageList1.TransparentColor = System.Drawing.Color.Transparent;
			// 
			// timer1
			// 
			this.timer1.Interval = 6000;
			// 
			// menuItem4
			// 
			this.menuItem4.Index = 1;
			this.menuItem4.Text = "-";
			// 
			// frmMain
			// 
			this.AutoScaleBaseSize = new System.Drawing.Size(5, 13);
			this.ClientSize = new System.Drawing.Size(1028, 470);
			this.Controls.AddRange(new System.Windows.Forms.Control[] {
																		  this.toolBar1});
			this.Icon = ((System.Drawing.Icon)(resources.GetObject("$this.Icon")));
			this.IsMdiContainer = true;
			this.Menu = this.mainMenu1;
			this.Name = "frmMain";
			this.Text = "OCA Reports";
			this.WindowState = System.Windows.Forms.FormWindowState.Maximized;
			this.Load += new System.EventHandler(this.frmMain_Load);
			this.ResumeLayout(false);

		}
		#endregion
		#region Public Variables


		#endregion
		/// <summary>
		/// The main entry point for the application.
		/// </summary>
		[STAThread]
		static void Main() 
		{
			Application.Run(new frmMain());
		}

		private void mnuDataDaily_Click(object sender, System.EventArgs e)
		{
			frmDaily fDaily = new frmDaily();
			fDaily.MdiParent = this;
			fDaily.Show();

		}

		private void mnuDataWeekly_Click(object sender, System.EventArgs e)
		{
			frmWeekly fWeekly = new frmWeekly();
			fWeekly.MdiParent = this;
			fWeekly.Show();
		}

		private void frmMain_Load(object sender, System.EventArgs e)
		{
			this.Show();
			frmWeekly fWeekly = new frmWeekly();
			fWeekly.MdiParent = this;
			fWeekly.Show();

		}

		private void mnuAnonCustomer_Click(object sender, System.EventArgs e)
		{
			frmAnonCust fAnon = new frmAnonCust();
			fAnon.MdiParent = this;
			fAnon.Show();
		}

		private void mnuAutoMan_Click(object sender, System.EventArgs e)
		{
			frmAutoMan fAuto = new frmAutoMan();
			fAuto.MdiParent = this;
			fAuto.Show();
		}

		private void mnuSolutionStatus_Click(object sender, System.EventArgs e)
		{
			frmSolutionStatus fSol = new frmSolutionStatus();
			fSol.MdiParent = this;
			fSol.Show();
		}

		private void mnuAbout_Click(object sender, System.EventArgs e)
		{
			frmAbout fAbout = new frmAbout();
			fAbout.ShowDialog(this);
			
		}

		private void toolBar1_ButtonClick(object sender, System.Windows.Forms.ToolBarButtonClickEventArgs e)
		{
			switch(toolBar1.Buttons.IndexOf(e.Button))
			{
				case 0:
					frmAnonCust fAnon = new frmAnonCust();
					fAnon.MdiParent = this;
					fAnon.Show();
					break; 
				case 1:
					frmAutoMan fAuto = new frmAutoMan();
					fAuto.MdiParent = this;
					fAuto.Show();
					break; 
				case 5:
					frmDaily fDaily = new frmDaily();
					fDaily.MdiParent = this;
					fDaily.Show();
					break; 
				case 2:
					frmSolutionStatus fSol = new frmSolutionStatus();
					fSol.MdiParent = this;
					fSol.Show();
					break;
				case 3:
					frmWeekly fWeekly = new frmWeekly();
					fWeekly.MdiParent = this;
					fWeekly.Show();
					break;
				case 7:
					frmExport fExp = new frmExport();
					fExp.ShowDialog(this);
					break;
				case 9:
					frmLocation fLoc = new frmLocation();
					fLoc.ShowDialog(this);
					break;
				case 16:
					frmAbout fAbout = new frmAbout();
					fAbout.ShowDialog(this);
					break;
				case 13:
					OneTouch();
					break;
				case 11:
					if(this.ActiveMdiChild.Name == "frmWeekly")
					{
						frmWeekly oWeekly = (frmWeekly) this.ActiveMdiChild;
						oWeekly.GetData();
					}
					else if(this.ActiveMdiChild.Name == "frmDaily")
					{
						frmDaily oDaily = (frmDaily) this.ActiveMdiChild;
						oDaily.GetData();
					}
					else if(this.ActiveMdiChild.Name == "frmAnonCust")
					{
						frmAnonCust oAnonCust = (frmAnonCust) this.ActiveMdiChild;
						oAnonCust.GetData();
					}
					else if(this.ActiveMdiChild.Name == "frmAutoMan")
					{
						frmAutoMan oAutoMan = (frmAutoMan) this.ActiveMdiChild;
						oAutoMan.GetData();
					}
					else if(this.ActiveMdiChild.Name == "frmSolutionStatus")
					{
						frmSolutionStatus oSolutionStatus = (frmSolutionStatus) this.ActiveMdiChild;
						oSolutionStatus.GetData();
					}
					break;
			}

		}

		private void mnuOptions_Click(object sender, System.EventArgs e)
		{
			frmLocation fLoc = new frmLocation();
			fLoc.ShowDialog(this);

		}

		private void mnuExport_Click(object sender, System.EventArgs e)
		{
			frmExport fExp = new frmExport();
			fExp.ShowDialog(this);
		}

		private void mnuFileExit_Click(object sender, System.EventArgs e)
		{
			this.Close();
		}

		private void mnuRefresh_Click(object sender, System.EventArgs e)
		{
			if(this.ActiveMdiChild.Name == "frmWeekly")
			{
				frmWeekly oWeekly = (frmWeekly) this.ActiveMdiChild;
				oWeekly.GetData();
			}
			else if(this.ActiveMdiChild.Name == "frmDaily")
			{
				frmDaily oDaily = (frmDaily) this.ActiveMdiChild;
				oDaily.GetData();
			}
			else if(this.ActiveMdiChild.Name == "frmAnonCust")
			{
				frmAnonCust oAnonCust = (frmAnonCust) this.ActiveMdiChild;
				oAnonCust.GetData();
			}
			else if(this.ActiveMdiChild.Name == "frmAutoMan")
			{
				frmAutoMan oAutoMan = (frmAutoMan) this.ActiveMdiChild;
				oAutoMan.GetData();
			}
			else if(this.ActiveMdiChild.Name == "frmSolutionStatus")
			{
				frmSolutionStatus oSolutionStatus = (frmSolutionStatus) this.ActiveMdiChild;
				oSolutionStatus.GetData();
			}
		}


		public void OneTouch()
		{
			foreach(Form oForm in this.MdiChildren)
			{
				oForm.Close();

			}
			frmAutoReport oAutoReports = new frmAutoReport();
			oAutoReports.ShowDialog(this);



		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocaupld\ocaupld.cpp ===
/*******************************************************************
*
*    DESCRIPTION:
*                   Upload.cpp : Implements Class UploadFile to upload dumps to servers
*    AUTHOR:
*
*    DATE:8/22/2002
*
*******************************************************************/

#include <windows.h>
#include <malloc.h>
#include <strsafe.h>
#include <unknwn.h>
#include "ocaupld.h"

BOOL
OcaUpldCreate(POCA_UPLOADFILE* pUpload)
{
    *pUpload = (POCA_UPLOADFILE) new UploadFile();
    return TRUE;
}

UploadFile::UploadFile()
{
    m_szFile = NULL;
    m_Sent = NULL;
    m_Size = NULL;
    m_fInitialized = FALSE;
    m_hFile = NULL;
    m_hRequest = NULL;
    m_hSession = NULL;
    m_hConnect = NULL;
    m_hCancelEvent = NULL;
    m_Refs = 0;
    m_fLastUploadStatus = UploadNotStarted;
    CreateCancelEventObject();
}

UploadFile::~UploadFile()
{
    UnInitialize();
    if (m_hCancelEvent)
    {
        CloseHandle(m_hCancelEvent);
    }
}

STDMETHODIMP
UploadFile::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    HRESULT Status;

    *Interface = NULL;
    Status = S_OK;

    if (IsEqualIID(InterfaceId, IID_IUnknown) ||
        IsEqualIID(InterfaceId, __uuidof(IOcaUploadFile)))
    {
        *Interface = (IOcaUploadFile *)this;
        AddRef();
    }
    else
    {
        Status = E_NOINTERFACE;
    }

    return Status;
}

STDMETHODIMP_(ULONG)
UploadFile::AddRef(
    THIS
    )
{
    return InterlockedIncrement((PLONG)&m_Refs);
}

STDMETHODIMP_(ULONG)
UploadFile::Release(
    THIS
    )
{
    LONG Refs = InterlockedDecrement((PLONG)&m_Refs);
    if (Refs == 0)
    {
        delete this;
    }
    return Refs;
}


HRESULT
UploadFile::SetFileToSend(
    LPWSTR wszFileName
    )
{
    HRESULT Hr;
    ULONG dwSizeHigh=0;

    if (m_hFile || m_fInitialized)
    {
        // Already in middle of upload
        return E_FAIL;
    }
    m_szFile = wszFileName;
    m_NumTries = 0;
    if (m_hCancelEvent == NULL)
    {
        CreateCancelEventObject();

    }
    m_hFile = CreateFile(m_szFile,
                         GENERIC_READ,
                         FILE_SHARE_READ,
                         NULL,
                         OPEN_EXISTING,
                         FILE_ATTRIBUTE_NORMAL,
                         NULL);

    if (m_hFile == NULL || m_hFile == INVALID_HANDLE_VALUE)
    {
        m_szFile = NULL;
        return E_FAIL;
    }

    m_Size = GetFileSize(m_hFile, &dwSizeHigh);
    m_Size += ((ULONG64) dwSizeHigh << 32);

    m_fLastUploadStatus = UploadNotStarted;
    m_wszLastUploadResult[0] = 0;
    m_fInitialized = TRUE;
    return S_OK;
}

HRESULT
UploadFile::UnInitialize()
{
    if (m_hFile)
    {
        CloseHandle(m_hFile);
        m_hFile = NULL;
    }
    CloseSession();
    m_fInitialized = FALSE;
    return S_OK;
}


//
// Lookup registry entry to get default proxy settings from Internet Settings key
//
HRESULT
UploadFile::GetProxySettings(
    LPWSTR wszServerName,
    ULONG ServerNameSIze,
    LPWSTR wszByPass,
    ULONG ByPassSize
    )
{
    HKEY hkey, hkeySettings;
    const WCHAR c_wszInetSettings[] = L"Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings";
    BOOL bProxyEnabled = FALSE;
    DWORD cb, err;

    if (RegOpenKeyExW(HKEY_CURRENT_USER, c_wszInetSettings, 0,
                      KEY_READ | KEY_WOW64_64KEY, &hkey) == ERROR_SUCCESS)
    {
        cb = sizeof(bProxyEnabled);
        if ((err = RegQueryValueEx(hkey, L"ProxyEnable", NULL, NULL, (PBYTE)&bProxyEnabled,
                            &cb)) != ERROR_SUCCESS)
        {
            RegCloseKey(hkey);
            return err;
        }

        if (bProxyEnabled)
        {
            cb = ServerNameSIze;
            if ((err = RegQueryValueEx(hkey, L"ProxyServer", NULL, NULL, (PBYTE)wszServerName,
                                &cb)) != ERROR_SUCCESS)
            {
                wszServerName[0] = 0;
            }

            cb = ByPassSize;
            if ((err = RegQueryValueEx(hkey, L"ProxyOverride", NULL, NULL, (PBYTE)wszByPass,
                                &cb)) != ERROR_SUCCESS)
            {
                wszByPass[0] = 0;
            }
        } else
        {
            wszServerName[0] = 0;
            wszByPass[0] = 0;
        }

        RegCloseKey(hkey);
    }
    return S_OK;
}

HRESULT
UploadFile::GetSessionRedirUrl(
    LPWSTR SessionUrl,
    LPWSTR wszRedirUrl,
    ULONG SizeofRedirUrl
    )
{
    HRESULT Hr;

    Hr = OpenSession();
    if (FAILED(Hr))
    {
        return Hr;
    }

    if (!GetRedirServerName(NULL, SessionUrl,
                            NULL, 0,
                            wszRedirUrl, SizeofRedirUrl))
    {

        CloseSession();
        Hr = GetLastError();
        return Hr;
    }


    return Hr;

}

//
// Gets the data on the web page wszUrl. This should be used with pages with small data size only.
//
HRESULT
UploadFile::GetUrlPageData(
    LPWSTR wszUrl,
    LPWSTR wszUrlPage,
    ULONG cbUrlPage
    )
{
    HRESULT Hr;
    BOOL    bRet;
    wchar_t             ConnectString [255];
    HINTERNET           hInet                   = NULL;
    HINTERNET           hRedirUrl               = NULL;
    HINTERNET           hConnect                = NULL;
    DWORD               dwDownloaded , dwSize = 0;
    PCHAR               Buffer;

    Hr = OpenSession();
    if (FAILED(Hr))
    {
        return Hr;
    }

    hConnect = WinHttpConnect(m_hSession, m_wszServerName, INTERNET_DEFAULT_HTTP_PORT, 0);
    if (hConnect == NULL)
    {
        goto exitPageData;
    }

    hRedirUrl = WinHttpOpenRequest(hConnect, L"GET", wszUrl, NULL, WINHTTP_NO_REFERER,
                                   WINHTTP_DEFAULT_ACCEPT_TYPES, 0);
    if(!hRedirUrl)
    {
        goto exitPageData;
    }

    bRet = WinHttpSendRequest( hRedirUrl,
                               WINHTTP_NO_ADDITIONAL_HEADERS, 0,
                               WINHTTP_NO_REQUEST_DATA, 0,
                               0, 0);
    if (bRet)
    {
        bRet = WinHttpReceiveResponse(hRedirUrl, NULL);
    }
    if (!bRet)
    {
        goto exitPageData;
    }


    if (!WinHttpQueryDataAvailable( hRedirUrl, &dwSize))
    {
        goto exitPageData;
    }
    // Allocate space for the buffer.
    Buffer = (PCHAR) malloc(dwSize);
    if (!Buffer)
    {
        goto exitPageData;
    }
    if (dwSize >= cbUrlPage/sizeof(WCHAR))
    {
            //      ::MessageBoxW(NULL,L"Failed pUploadurl memory allocation",NULL,MB_OK);
        SetLastError(STG_E_INSUFFICIENTMEMORY);
        free(Buffer);
        goto exitPageData;
    }
    else
    {
        ZeroMemory(Buffer, dwSize);
        // Read the Data.
        if (!WinHttpReadData( hRedirUrl, (LPVOID)Buffer,
                              dwSize, &dwDownloaded))
        {
            free(Buffer);
            goto exitPageData;
        }
        ZeroMemory(wszUrlPage, cbUrlPage);
        if (!MultiByteToWideChar(CP_ACP, 0, Buffer, dwSize, wszUrlPage, cbUrlPage/sizeof(WCHAR)))
        {
        }
        free (Buffer);
    }

    CloseSession();

exitPageData:
    Hr = GetLastError();
    return Hr;

}

HRESULT
UploadFile::InitializeSession(
    LPWSTR OptionCode,
    LPWSTR wszFileToSend
    )
{
    HRESULT Hr;

    Hr = SetFileToSend(wszFileToSend);
    if (FAILED(Hr))
    {
        return Hr;
    }

    m_fLastUploadStatus = UploadConnecting;
    m_dwConnectPercentage = 10;
    Hr = OpenSession();
    if (FAILED(Hr))
    {
        return Hr;
    }

    if (!GetRedirServerName(OptionCode, NULL,
                            m_wszServerName, sizeof(m_wszServerName),
                            NULL, 0))
    {

        CloseSession();
        Hr = GetLastError();
        return Hr;
    }


    return Hr;
}

HRESULT
UploadFile::SendFile(
    LPWSTR wszRemoteFileName,
    BOOL bSecureMode
    )
{
    HRESULT Hr;

    Hr = OpenConnection(wszRemoteFileName, bSecureMode);

    if (SUCCEEDED(Hr))
    {
        m_fLastUploadStatus = UploadTransferInProgress;
        Hr = StartSend();

        if (SUCCEEDED(Hr))
        {
            Hr = CompleteSend();
        }
        CloseConnection();
    }
    return Hr;
}


HRESULT
UploadFile::OpenSession(
    void
    )
{
    ULONG ErrorCode;
    WCHAR wszProxyServer[100], wszByPass[100];

    if (m_hSession != NULL)
    {
        return E_UNEXPECTED;
    }

#ifdef _USE_WINHTTP

    wszByPass[0] = wszProxyServer[0] = 0;
    GetProxySettings(wszProxyServer, sizeof(wszProxyServer),
                     wszByPass, sizeof(wszByPass));
    if (wszProxyServer[0])
    {
        m_hSession = WinHttpOpen(L"OCARPT Control",
                                 WINHTTP_ACCESS_TYPE_NAMED_PROXY,
                                 wszProxyServer, wszByPass,
                                 //L"itgproxy:80", L"<local>",
                                 0);
    } else
    {
        m_hSession = WinHttpOpen(L"OCARPT Control",
                                 WINHTTP_ACCESS_TYPE_NO_PROXY,
                                 WINHTTP_NO_PROXY_NAME,
                                 WINHTTP_NO_PROXY_BYPASS,
                                 // L"itgproxy:80", L"<local>",
                                 0);
    }
#else
    m_hSession = InternetOpenW(L"OCARPT Control", INTERNET_OPEN_TYPE_PRECONFIG,
                               NULL, NULL, 0);

    InetCheckTimeouts(m_hSession);

    if (InternetSetStatusCallback(hSession, (INTERNET_STATUS_CALLBACK) InetCallback)
        == INTERNET_INVALID_STATUS_CALLBACK)
    {
        // Not significant if this fails
    }

#endif
    if (!m_hSession)
    {
        ErrorCode = GetLastError();
        return ErrorCode;
    }

    return S_OK;
}

HRESULT
UploadFile::OpenConnection(
    LPWSTR wszRemoteFileName,
    BOOL bSecureMode
    )
{

#ifndef _USE_WINHTTP
    INTERNET_BUFFERSW   BufferInW               = {0};
#endif
    static const wchar_t *pszAccept[]           = {L"*.*", 0};


    if (m_hSession == NULL)
    {
        return E_UNEXPECTED;
    }

    if (m_hFile == NULL || m_hFile == INVALID_HANDLE_VALUE)
    {
        return E_UNEXPECTED;
    }

    if (m_NumTries > 0)
    {
//      m_Size /= 2;
    }
//  m_NumTries++;

    if (!m_hConnect)
    {

#ifdef _USE_WINHTTP
        m_hConnect = WinHttpConnect(m_hSession,
                                    m_wszServerName,
                                    (bSecureMode ? INTERNET_DEFAULT_HTTPS_PORT : INTERNET_DEFAULT_HTTP_PORT),
                                    0);
#else
        m_hConnect = InternetConnectW(m_hSession,
                                      (wchar_t *)m_wszServerName,
                                      (bSecureMode ? INTERNET_DEFAULT_HTTPS_PORT : INTERNET_DEFAULT_HTTP_PORT),
                                      L"",
                                      L"",
                                      INTERNET_SERVICE_HTTP,
                                      0,
                                      NULL);
#endif // _USE_WINHTTP
        if (!m_hConnect)
        {
            return GetLastError();
        }
    }

    if (!m_hRequest)
    {
#ifdef _USE_WINHTTP
        m_hRequest = WinHttpOpenRequest(m_hConnect,
                                        L"PUT",
                                        wszRemoteFileName,
                                        NULL,
                                        WINHTTP_NO_REFERER,
                                        pszAccept, //WINHTTP_DEFAULT_ACCEPT_TYPES,
                                        (bSecureMode ? WINHTTP_FLAG_SECURE : 0) | WINHTTP_FLAG_REFRESH);
#else
        m_hRequest = HttpOpenRequestW(m_hConnect,
                                      L"PUT",
                                      wszRemoteFileName,
                                      NULL,
                                      NULL,
                                      pszAccept,
                                      INTERNET_FLAG_NEED_FILE|
                                      INTERNET_FLAG_NO_CACHE_WRITE |
                                      (bSecureMode ? INTERNET_FLAG_SECURE : 0),
                                      0);
#endif // _USE_WINHTTP
        if (!m_hRequest)
        {
            //      ::MessageBoxW(NULL,L"Put request failed ",NULL,MB_OK);
            return GetLastError();
        }

    }

    // Clear the buffer

#ifdef _USE_WINHTTP

    if (!WinHttpSendRequest(m_hRequest, WINHTTP_NO_ADDITIONAL_HEADERS, 0,
                            WINHTTP_NO_REQUEST_DATA, 0,
                            (ULONG) m_Size, 0))
#else
    InetCheckTimeouts(m_hRequest);

    BufferInW.dwStructSize = sizeof( INTERNET_BUFFERSW );
    BufferInW.Next = NULL;
    BufferInW.lpcszHeader = NULL;
    BufferInW.dwHeadersLength = 0;
    BufferInW.dwHeadersTotal = 0;
    BufferInW.lpvBuffer = NULL;
    BufferInW.dwBufferLength = 0;
    BufferInW.dwOffsetLow = 0;
    BufferInW.dwOffsetHigh = 0;
    BufferInW.dwBufferTotal = (ULONG) m_Size;
    if(!HttpSendRequestExW( m_hRequest, &BufferInW, NULL, 0, 0))
#endif
    {
        //          ::MessageBoxW(NULL,L"Failed to send request ",NULL,MB_OK);
        return GetLastError();
    }

    return S_OK;
}

HRESULT
UploadFile::CompleteSend()
{
    BOOL bRet;
    ULONG ResLength;
    ULONG ResponseCode;
    WCHAR Text[500];
    ULONG index;
    ULONG ErrorCode = 0;

#ifdef _USE_WINHTTP

    bRet = WinHttpReceiveResponse(m_hRequest, NULL);
#else

    bRet = HttpEndRequest(m_hRequest, NULL, 0, 0);
#endif
    if (!bRet)
    {
        //          ::MessageBoxW(NULL,L"End RequestFailed ",NULL,MB_OK);
        ErrorCode = GetLastError();

    }
    else
    {

        ResLength = sizeof(ResponseCode);
        ResponseCode = 0;
#ifdef _USE_WINHTTP
        WinHttpQueryHeaders(m_hRequest,
                            WINHTTP_QUERY_STATUS_CODE | WINHTTP_QUERY_FLAG_NUMBER,
                            WINHTTP_HEADER_NAME_BY_INDEX,
                            &ResponseCode,
                            &ResLength,
                            WINHTTP_NO_HEADER_INDEX);

        ResLength = sizeof(Text);
        WinHttpQueryHeaders(m_hRequest, WINHTTP_QUERY_STATUS_TEXT,
                            WINHTTP_HEADER_NAME_BY_INDEX,
                            Text, &ResLength, &index);


        if ( ResponseCode >= 400 )
#else

        HttpQueryInfo(m_hRequest,
                      HTTP_QUERY_STATUS_CODE |HTTP_QUERY_FLAG_NUMBER,
                      &ResponseCode,
                      &ResLength,
                      &index);

        ResLength = sizeof(Text);
        HttpQueryInfo(m_hRequest, HTTP_QUERY_STATUS_TEXT,
                      Text, &ResLength, &index);
        if ( (ResponseCode != HTTP_STATUS_CREATED) &&
             (ResponseCode != HTTP_STATUS_OK))
#endif
        {
            ::MessageBoxW(NULL,Text,NULL,MB_OK);

            ErrorCode= ResponseCode;
            // Cleanup for retry
            // InternetCloseHandle(hRequest); hRequest = NULL;
            // InternetCloseHandle(hConnect); hConnect = NULL;

        }
        else
        {
            ErrorCode = 0;

        }
    }
    return ErrorCode;
}

HRESULT
UploadFile::CloseConnection()
{
#ifdef _USE_WINHTTP
    if (m_hConnect) WinHttpCloseHandle(m_hConnect);
    if (m_hRequest) WinHttpCloseHandle(m_hRequest);
#else
    if (m_hConnect) InternetCloseHandle(m_hConnect);
    if (m_hRequest) InternetCloseHandle(m_hRequest);
#endif
    m_hRequest = NULL;
    m_hConnect = NULL;
    return S_OK;
}

HRESULT
UploadFile::CloseSession()
{
    if (m_hConnect || m_hRequest)
    {
        CloseConnection();
    }
#ifdef _USE_WINHTTP
    if (m_hSession)
        WinHttpCloseHandle(m_hSession);
#else
    if (m_hSession)
        InternetCloseHandle(m_hSession);
#endif // _USE_WINHTTP

    m_hSession = NULL;
    return S_OK;
}


BOOL
UploadFile::GetUploadResult(
    LPTSTR Result,
    ULONG cbResult
    )
{
    if (Result)
    {
        if (m_fLastUploadStatus == UploadTransferInProgress)
        {
            StringCbPrintfW(Result, cbResult, L"Transferring to server (%ld KB) ...",
                            m_Size / 1024);
            return TRUE;
        } else if (m_fLastUploadStatus == UploadConnecting)
        {
            StringCbPrintfW(Result, cbResult, L"Connecting to server ...");
            return TRUE;

        }

        StringCbCopyW(Result, cbResult, m_wszLastUploadResult);
    }
    return m_wszLastUploadResult[0] != 0;
}

HRESULT
UploadFile::SetUploadResult(
    EnumUploadStatus Success,
    LPCTSTR Text
    )
{
    m_fLastUploadStatus = Success;
    return StringCbCopyW(m_wszLastUploadResult, sizeof(m_wszLastUploadResult),
                         Text);
}

HRESULT
UploadFile::StartSend()
{
    HRESULT Hr = S_OK;
    BYTE   *pBuffer;
    BOOL    bRet;
    DWORD   dwBytesWritten, dwBytesRead = 0;
#define MAX_SEND_SIZE 50000

    if (m_hFile == NULL || m_hRequest == NULL)
    {
        return E_UNEXPECTED;
    }

    if (m_hCancelEvent)
    {
        ResetEvent(m_hCancelEvent);
    }

    // Get the buffer memory from the heap
    if ( (pBuffer = (BYTE *)malloc (MAX_SEND_SIZE)) == NULL)
    {
        // ::MessageBoxW(NULL,L"Failed Memory allocation",NULL,MB_OK);
        return E_OUTOFMEMORY;
    }

    SetFilePointer(m_hFile, 0, NULL, FILE_BEGIN);

    m_fLastUploadStatus = UploadTransferInProgress;
    m_Sent = 0;
    do
    {
        bRet = ReadFile(m_hFile, pBuffer, MAX_SEND_SIZE, &dwBytesRead, NULL);
        if (bRet != 0)
        {
            if (dwBytesRead > (ULONG)(m_Size - m_Sent))
            {
                dwBytesRead = (ULONG)(m_Size - m_Sent);
            }

            #ifdef _USE_WINHTTP
            bRet = WinHttpWriteData(m_hRequest,
                                    pBuffer,
                                    dwBytesRead,
                                    &dwBytesWritten);
            #else
            bRet = InternetWriteFile(m_hRequest,
                                     pBuffer,
                                     dwBytesRead,
                                     &dwBytesWritten);

            #endif
            if ( (!bRet) || (dwBytesWritten==0) )
            {
                // ::MessageBoxW(NULL,L"Failed write ",NULL,MB_OK);
                Hr = HRESULT_FROM_NT (GetLastError());
                break;
            }
            m_Sent += dwBytesWritten;
            if (CheckCancelRequest())
            {
                // Send was aborted
                Hr = E_ABORT;
                break;
            }

        } else
        {
            Hr = E_FAIL;
            break;
        }
    } while (dwBytesRead == MAX_SEND_SIZE && m_Sent < m_Size);

    if (Hr == S_OK)
    {
        m_fLastUploadStatus = UploadSucceded;
    }
    free (pBuffer);
    return Hr;
}

HRESULT
UploadFile::Cancel()
{
    FireCancelEvent();
    m_fLastUploadStatus = UploadFailure;
    return S_OK;
}

HRESULT
UploadFile::CreateCancelEventObject()
{

    m_hCancelEvent = CreateEvent(NULL, TRUE, FALSE,
                                L"OCA_CancelUpload");
    if (m_hCancelEvent == NULL)
    {
        return E_FAIL;
    }
    return S_OK;
}

BOOL
UploadFile::FireCancelEvent()
{
    if (m_hCancelEvent)
    {
        return SetEvent(m_hCancelEvent);
    }
    return FALSE;
}

ULONG
UploadFile::GetPercentComplete()
{
    if (m_fLastUploadStatus == UploadSucceded)
    {
        return 101;
    }
    else if (m_fLastUploadStatus == UploadFailure)
    {
        return -1;
    } else if (m_fLastUploadStatus == UploadNotStarted)
    {
        return 0;
    } else if (m_fLastUploadStatus == UploadConnecting)
    {
        return m_dwConnectPercentage;
    } else if (m_fLastUploadStatus == UploadTransferInProgress)
    {
        return (ULONG) ((m_Sent * 100) / m_Size);
    }
    return 0;
}

BOOL
UploadFile::IsUploadInProgress()
{
    if (m_fLastUploadStatus == UploadNotStarted ||
        m_fLastUploadStatus == UploadSucceded ||
        m_fLastUploadStatus == UploadFailure)
    {
        return FALSE;
    }
    return m_fInitialized;
}

BOOL
UploadFile::CheckCancelRequest()
{
    DWORD dwWait;
    if (m_hCancelEvent)
    {
        if ((dwWait = WaitForSingleObject(m_hCancelEvent, 1)) == WAIT_TIMEOUT)
        {
            return FALSE;
        } else if (dwWait == WAIT_OBJECT_0)
        {
            return TRUE;
        }
    }
    return FALSE;
}

void
InetCheckTimeouts(
    HINTERNET hInet
    )
{
    ULONG dwConnectTimeout;
    ULONG dwSendTimeOut;
    ULONG dwSize;

    dwSize = sizeof(ULONG);
#ifndef _USE_WINHTTP
    if (!InternetQueryOption(hInet,
                            INTERNET_OPTION_DATA_SEND_TIMEOUT,
                            &dwSendTimeOut,
                            &dwSize))
    {
        dwSendTimeOut = 0;
    }
    if (!InternetQueryOption(hInet,
                            INTERNET_OPTION_CONNECT_TIMEOUT,
                            &dwConnectTimeout,
                            &dwSize))
    {
        dwConnectTimeout = 0;
    }

    if (dwSendTimeOut != 0)
    {
        dwSendTimeOut *= 4;
        InternetSetOption(hInet, INTERNET_OPTION_DATA_SEND_TIMEOUT,
                          &dwSendTimeOut, dwSize);
    }
    if (dwConnectTimeout != 0)
    {
        dwConnectTimeout *= 4;
        InternetSetOption(hInet, INTERNET_OPTION_CONNECT_TIMEOUT,
                          &dwConnectTimeout, dwSize);
    }
#endif // _USE_WINHTTP
}

/**********************************************************************************
*
* Callback for WinInet APIs
*
**********************************************************************************/
void
__stdcall InetCallback(
    HINTERNET hInet,
    DWORD dwContext,
    DWORD dwInetStatus,
    LPVOID lpvStatusInfo,
    DWORD dwStatusInfoLength
    )
{
#ifndef _USE_WINHTTP
    switch (dwInetStatus)
    {
    case 0:
        dwInetStatus = 2;
        break;
    default:
        break;
    }
#endif
    return;
}

BOOL
LocalCrackUrlServer(
    LPWSTR lpwszUrlName,
    DWORD dwUrlLength,
    DWORD Flags,
    LPWSTR *lpServerName
    )
{
    URL_COMPONENTSW urlComponents;
    BOOL bRet = FALSE;
    DWORD dwLastError;


    ZeroMemory(&urlComponents, sizeof(URL_COMPONENTSW));
    urlComponents.dwStructSize = sizeof(URL_COMPONENTSW);
    urlComponents.lpszHostName = NULL;
    urlComponents.dwHostNameLength = 512;

    urlComponents.lpszHostName = (wchar_t*)malloc(urlComponents.dwHostNameLength );
    if(!urlComponents.lpszHostName)
    {
        return FALSE;
    }
    do
    {

        ZeroMemory(urlComponents.lpszHostName, urlComponents.dwHostNameLength);
#ifdef _USE_WINHTTP
        bRet = WinHttpCrackUrl(lpwszUrlName, dwUrlLength, 0, &urlComponents);
#else
        bRet = InternetCrackUrlW(lpwszUrlName, dwUrlLength, 0, &urlComponents);
#endif
        if(!bRet)
        {
            dwLastError = GetLastError();
            // If last error was due to insufficient buffer size, create a new one the correct size.
            if(dwLastError == ERROR_INSUFFICIENT_BUFFER)
            {
                free(urlComponents.lpszHostName);
                urlComponents.lpszHostName = (wchar_t*)malloc(urlComponents.dwHostNameLength);

                    if(!urlComponents.lpszHostName)
                    {
                        return FALSE;
                    }
            }
            else
            {
                return FALSE;
            }
        }

    }while(!bRet);

    *lpServerName = urlComponents.lpszHostName;
    return TRUE;
}

LPWSTR
UploadFile::GetServerName()
{
    return m_wszServerName;
}

BOOL
UploadFile::GetRedirServerName(
    LPWSTR OptionCode,
    LPWSTR ConnectUrl,
    LPWSTR lpwszServerName,
    ULONG dwServerNameLength,
    LPWSTR lpwszUrl,
    ULONG dwUrlLength
    )
{
    wchar_t             ConnectString [255];
    HINTERNET           hInet                   = NULL;
    HINTERNET           hRedirUrl               = NULL;
    HINTERNET           hConnect                = NULL;
    wchar_t*            pUploadUrl              = NULL;
    ULONG               dwUploadUrlLength;
    URL_COMPONENTSW     urlComponents;
    BOOL                bRet;
    DWORD               dwLastError;
    LPWSTR              lpszHostName            = NULL;

#ifdef _USE_WINHTTP

    if (ConnectUrl == NULL)
    {
        if (StringCbPrintfW(ConnectString,
                            sizeof (ConnectString),
                            L"/fwlink/?linkid=%s",
                            OptionCode
                            // L"908" // LIVE SITE
                            ) != S_OK)
        {
            goto exitServerName;
        }

        hConnect = WinHttpConnect(m_hSession, L"go.microsoft.com", INTERNET_DEFAULT_HTTP_PORT, 0);
        if (hConnect == NULL)
        {
            goto exitServerName;
        }
    } else
    {
        hConnect = WinHttpConnect(m_hSession, m_wszServerName, INTERNET_DEFAULT_HTTP_PORT, 0);
        if (hConnect == NULL)
        {
            goto exitServerName;
        }

        if (StringCbCopyW(ConnectString, sizeof(ConnectString), ConnectUrl) != S_OK)
        {
            goto exitServerName;
        }
    }
    hRedirUrl = WinHttpOpenRequest(hConnect, L"GET", ConnectString, NULL, WINHTTP_NO_REFERER,
                                   WINHTTP_DEFAULT_ACCEPT_TYPES, 0);
#else
    if (ConnectUrl == NULL)
    {
        if (StringCbPrintfW(ConnectString,
                            sizeof (ConnectString),
                            L"http://go.microsoft.com/fwlink/?linkid=%s",
                            OptionCode
                            // L"908" // LIVE SITE
                            ) != S_OK)
        {
            goto exitServerName;
        }

    } else
    {
        if (StringCbCopyW(ConnectString, sizeof(ConnectString), ConnectUrl) != S_OK)
        {
            goto exitServerName;
        }
    }

    hRedirUrl = InternetOpenUrlW(m_hSession, ConnectString, NULL, 0, 0, 0);
#endif
    if(!hRedirUrl)
    {
        goto exitServerName;
    }

#ifdef _USE_WINHTTP
    bRet = WinHttpSendRequest( hRedirUrl,
                               WINHTTP_NO_ADDITIONAL_HEADERS, 0,
                               WINHTTP_NO_REQUEST_DATA, 0,
                               0, 0);
    if (bRet)
    {
        bRet = WinHttpReceiveResponse(hRedirUrl, NULL);
    }
    if (!bRet)
    {
        goto exitServerName;
    }

#endif
        // Get the URL returned from the MS Corporate IIS redir.dll isapi URL redirector
    dwUploadUrlLength = 512;
    pUploadUrl = (wchar_t*)malloc(dwUploadUrlLength);
    if(!pUploadUrl)
    {
        //      ::MessageBoxW(NULL,L"Failed pUploadurl memory allocation",NULL,MB_OK);
        goto exitServerName;
        return FALSE;
    }

    do
    {

        ZeroMemory(pUploadUrl, dwUploadUrlLength);
#ifdef _USE_WINHTTP

        bRet = WinHttpQueryOption(hRedirUrl, WINHTTP_OPTION_URL, pUploadUrl, &dwUploadUrlLength);
#else
        bRet = InternetQueryOptionW(hRedirUrl, INTERNET_OPTION_URL, pUploadUrl, &dwUploadUrlLength);
#endif
        if(!bRet)
        {

            dwLastError = GetLastError();

            // If last error was due to insufficient buffer size, create a new one the correct size.
            if(dwLastError == ERROR_INSUFFICIENT_BUFFER)
            {
                if (pUploadUrl)
                {
                    free(pUploadUrl);
                    pUploadUrl = NULL;
                }
                pUploadUrl = (wchar_t*)malloc(dwUploadUrlLength);
                if(!pUploadUrl)
                {
                    goto exitServerName;
                }
            }
            else
            {
                goto exitServerName;
            }
        }

        m_dwConnectPercentage+=10;
    }while(!bRet);


    // Strip out the host name from the URL
    ZeroMemory(&urlComponents, sizeof(URL_COMPONENTSW));
    urlComponents.dwStructSize = sizeof(URL_COMPONENTSW);
    urlComponents.lpszHostName = NULL;
    urlComponents.dwHostNameLength = 512;

    urlComponents.lpszHostName = (wchar_t*)malloc(urlComponents.dwHostNameLength );
    if(!urlComponents.lpszHostName)
    {
        goto exitServerName;;
    }
    do
    {

        ZeroMemory(urlComponents.lpszHostName, urlComponents.dwHostNameLength);
#ifdef _USE_WINHTTP
        bRet = WinHttpCrackUrl(pUploadUrl, dwUploadUrlLength, 0, &urlComponents);
#else
        bRet = InternetCrackUrlW(pUploadUrl, dwUploadUrlLength, 0, &urlComponents);
#endif
        if(!bRet)
        {
            dwLastError = GetLastError();
            // If last error was due to insufficient buffer size, create a new one the correct size.
            if(dwLastError == ERROR_INSUFFICIENT_BUFFER)
            {
                free(urlComponents.lpszHostName);
                urlComponents.lpszHostName = (wchar_t*)malloc(urlComponents.dwHostNameLength);

                    if(!urlComponents.lpszHostName)
                    {
                        goto exitServerName;
                    }
            }
            else
            {
                goto exitServerName;
            }
        }

    }while(!bRet);
    bRet = TRUE;
    if (lpwszServerName)
    {
        if (!_wcsicmp(OptionCode, L"908"))
        {
            if (StringCbCopyW(lpwszServerName, dwServerNameLength,
                              L"redbgitwb10"
                              ) != S_OK)
            {
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
                bRet = FALSE;
            }

        } else
        if (StringCbCopyW(lpwszServerName, dwServerNameLength,
                          //L"tkbgitwb15"
                          //L"tkbgitwb16"
                          L"redbgitwb10"
                          //L"redbgitwb11"
                          //L"tkbgitwb18"
                          //L"oca.microsoft.com"
                          //urlComponents.lpszHostName
                          ) != S_OK)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            bRet = FALSE;
        }
    }

    if (lpwszUrl)
    {
        if (StringCbCopyW(lpwszUrl, dwUrlLength, pUploadUrl) != S_OK)
        {
            SetLastError(ERROR_INSUFFICIENT_BUFFER);
            bRet = FALSE;

        }
    }

exitServerName:

    if (pUploadUrl)
    {
        free (pUploadUrl);
    }
    if (urlComponents.lpszHostName)
    {
        free (urlComponents.lpszHostName);
    }
    if (hRedirUrl)
    {
#ifdef _USE_WINHTTP
        if (hConnect)
            WinHttpCloseHandle(hConnect);
        WinHttpCloseHandle(hRedirUrl);
#else
        InternetCloseHandle(hRedirUrl);
#endif
    }
    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocawreports\anoncustomer.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace OCAWReports
{
	/// <summary>
	/// Summary description for anoncustomer.
	/// </summary>
	public class anoncustomer : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Table tblAnonCustomer;
		protected System.Web.UI.WebControls.Image imgAnonTotal;
		protected System.Web.UI.WebControls.Image imgAnonDaily1;
		/*************************************************************************************
		*	module: anoncustomer.aspx.cs - Page_Load
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: to Create both gif charts from the Office Watson Controls and set the images to those
		*	files.  Create OCAData object and return data for anonymous versus customer uploads.  Set the information
		*	in the tables to correspond to the graphs.  
		*************************************************************************************/
		private void Page_Load(object sender, System.EventArgs e)
		{
			int x = -1;
			int rowCnt = 7;
			int rowCtr = 0;
			int cellCtr = 0;
			int cellCnt = 3;
			string sFName;
			long[]  LACustomer = new long[7];
			long[] LAAnon = new long[7];
			long lTemp = 0,lTotalAnon = 0,lTotalCustomer = 0;
			Object[] yCustomerCol = new Object[7];
			Object[] xAonCol = new Object[7];
			Object[] yCustomerValues = new Object[2];
			Object[] xAnonValues = new Object[2];
			OCAData.CCountDailyClass rpt = new OCAData.CCountDailyClass();
			
			System.DateTime dDate = new System.DateTime(System.DateTime.Now.Year, System.DateTime.Now.Month, 
				System.DateTime.Now.Day);
			OWC.WCChart oWeeklyChart, oRatioChart;
			OWC.ChartSpaceClass oSpace = new OWC.ChartSpaceClass();
			OWC.ChartSpaceClass oSpace1 = new OWC.ChartSpaceClass();
			OWC.WCSeries oSeries1;
			OWC.WCDataLabels oLabels;
			OWC.WCDataLabelsCollection oLabelCollection;
			
			
			oSpace.Clear();
			oSpace.Refresh();
			oWeeklyChart = oSpace.Charts.Add(0);
			oWeeklyChart.HasLegend = true;
			//Begin Image One
			for(x=0;x<2;x++)
			{
				oWeeklyChart.SeriesCollection.Add(x);
			}
			for(x=0;x<7;x++)
			{
				LACustomer[x] = rpt.GetDailyCount(dDate.AddDays(-(x + 1)));
				try
				{
					LAAnon[x] = rpt.GetDailyAnon(dDate.AddDays(-(x + 1)));
				}
				catch
				{
					LAAnon[x] = 0;
				}
				if(LACustomer[x] > LAAnon[x])
				{
//					xAonCol.SetValue((LACustomer[x] - LAAnon[x]), 0);
					lTotalCustomer = lTotalCustomer + (LACustomer[x] - LAAnon[x]);
				}
				else
				{
//					xAonCol.SetValue((LAAnon[x] - LACustomer[x]), 0);
					lTotalCustomer = lTotalCustomer + (LAAnon[x] - LACustomer[x]);
				}
				lTotalAnon = lTotalAnon + LAAnon[x];
			}
//*******************************************************************************************************
			oWeeklyChart.HasTitle = true;
			oWeeklyChart.Title.Caption = "Database - Anonymouse vs Customer";
			for(x = 0; x < 6; x++)
			{
				xAonCol[x] = LAAnon[x].ToString();
			}
			oWeeklyChart.SeriesCollection[0].Caption = "Anonymous";
			oWeeklyChart.SeriesCollection[0].SetData(OWC.ChartDimensionsEnum.chDimValues, -1, xAonCol);
			for(x = 0; x < 6; x++)
			{
				if(LACustomer[x] > LAAnon[x])
				{
					lTemp = LACustomer[x] - LAAnon[x];
					xAonCol[x] = lTemp.ToString();
				}
				else
				{
					lTemp = LAAnon[x] - LACustomer[x];
					xAonCol[x] = lTemp.ToString();
				}
			}
			oWeeklyChart.SeriesCollection[1].Caption = "Customer";
			oWeeklyChart.SeriesCollection[1].SetData(OWC.ChartDimensionsEnum.chDimValues, -1, xAonCol);
			for(x = 0; x < 6; x++)
			{
				xAonCol.SetValue(dDate.AddDays(x).ToShortDateString(), x);
			}
			oWeeklyChart.SeriesCollection[0].SetData(OWC.ChartDimensionsEnum.chDimCategories, -1, xAonCol);
//*******************************************************************************************************
			sFName = "Anon";
			try
			{
				oSpace.ExportPicture(Server.MapPath(sFName), "gif", 707, 476);
				imgAnonDaily1.ImageUrl = sFName;
			}
			catch
			{
			}

			//End Image one


			//Begin Image Two
			oSpace1.Clear();
			oSpace1.Refresh();
			oRatioChart = oSpace1.Charts.Add(0);
			oRatioChart.Type = OWC.ChartChartTypeEnum.chChartTypeBarClustered;
			oRatioChart.HasLegend = true;

			lTemp = lTotalCustomer + lTotalAnon;
			oSeries1 = oRatioChart.SeriesCollection.Add(0);
			oLabelCollection = oSeries1.DataLabelsCollection;
			
			oLabels = oLabelCollection.Add();
			oLabels.HasPercentage = true;
			oLabels.HasValue = false;
		

			xAnonValues.SetValue(lTotalAnon.ToString(), 0);
			xAnonValues.SetValue(lTotalCustomer.ToString(), 1);
			yCustomerValues.SetValue("Anonymous", 0);
			yCustomerValues.SetValue("Customer", 1);
			oRatioChart.HasTitle = true;
			oRatioChart.Title.Caption = "Database - Average Weekly Uploads";
			oSeries1.Caption = "Average Weekly";	//chDimCategories
			oSeries1.SetData(OWC.ChartDimensionsEnum.chDimCategories, -1, yCustomerValues);
			oSeries1.SetData(OWC.ChartDimensionsEnum.chDimValues, -1, xAnonValues);
			oSeries1.Type = OWC.ChartChartTypeEnum.chChartTypePie;

			sFName = "AnonPer";
			try
			{
				oSpace1.ExportPicture(Server.MapPath(sFName), "gif", 707, 476);
				imgAnonTotal.ImageUrl = sFName;
			}
			catch
			{
			}

			//End Image Two

			//Begin Table
			for(rowCtr=0; rowCtr <= rowCnt; rowCtr++) 
			{
				TableRow tRow = new TableRow();
				tblAnonCustomer.Rows.Add(tRow);
				//tRow.CssClass = "clsTRMenu";
				for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
				{
					TableCell tCell = new TableCell();

					if(rowCtr == 0)
					{
						switch(cellCtr)
						{
							case 1 :
								tCell.Text = "Date";
								break;
							case 2 :
								tCell.Text = "Anonymous";
								break;
							case 3 :
								tCell.Text = "Customer";
								break;
							default:
								tCell.Text = "0";
								break;
						
						}
						tCell.Style["font-size"] = "small";

					}
					else
					{
						switch(cellCtr)
						{
							case 1 :
								tCell.Text = dDate.AddDays(-rowCtr).ToShortDateString();
								break;
							case 2 :
								tCell.Text = LAAnon[rowCtr-1].ToString();
								break;
							case 3 :
								if(LAAnon[rowCtr-1] > LACustomer[rowCtr-1])
								{
									lTemp = LAAnon[rowCtr-1] - LACustomer[rowCtr-1];
								}
								else
								{
									lTemp = LACustomer[rowCtr-1] - LAAnon[rowCtr-1];
								}
								tCell.Text = lTemp.ToString();
								break;
							default:
								tCell.Text = "0";
								break;
						
						}
						tCell.Style["background-color"] = "white";
						tCell.Style["font-size"] = "small-x";
						tCell.Style["color"] = "#6487dc";
						tCell.Style["font-weight"] = "Bold";
						
					}
					tCell.Style["font-family"] = "Tahoma";
					tRow.Cells.Add(tCell);
				}
			}

			//End Table 
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocaupld\sources.inc ===
MAJORCOMP=oca 
MINORCOMP=activex 
TARGETNAME=OCAUPLD
TARGETPATH=obj
DLLENTRY=_DllMainCRTStartup 
UMTYPE=console  

USE_NATIVE_EH=1
C_DEFINES=$(C_DEFINES) -DWIN32 -DUSE_NT_VERSION -DUNICODE

INCLUDES= \
    ..;                     \
	..\..\..\oca-common;    \
    ..\..\..\..\dbg-common; \
     $(PUBLIC_INTERNAL_PATH)\inetcore\inc \

SOURCES= \
	..\ocaupld.rc 		\
	..\ocaupld.cpp  

TARGETLIBS= $(SDK_LIB_PATH)\kernel32.lib \
        	$(SDK_LIB_PATH)\user32.lib \
        	$(SDK_LIB_PATH)\advapi32.lib \
            $(SDK_LIB_PATH)\uuid.lib  \
        	$(SDK_LIB_PATH)\Winhttp.lib \
	    	$(SDK_LIB_PATH)\Rpcrt4.lib

#NTTARGETFILES=$(O)\$(TARGETNAME)p.lib

#INCLUDES=$(SDK_INC_PATH)\atl30 
#        	$(SDK_LIB_PATH)\Wininet.lib \
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocawreports\global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace OCAWReports 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocawreports\dailyreport.aspx.cs ===
#define FILE_SERVER			//FILE_LOCAL	FILE_SERVER

using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Text;
using System.Data.SqlClient;
using System.Web.Security;
using System.Security.Principal;
using System.Security.Permissions;

namespace OCAWReports
{
	/// <summary>
	/// Summary description for DailyReport1.
	/// </summary>
	public class DailyReport1 : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Image imgWeekly;
		protected System.Web.UI.WebControls.Table tblDifference;
		protected System.Web.UI.WebControls.Table tblUploads;
	
		private void Page_Load(object sender, System.EventArgs e)
		{
			int rowCnt = 1;
			int rowCtr=0;
			int cellCtr=0;
			int cellCnt = 4;
			string sFName;
			long  lACount;
			long LAWatson;
			long LAArchive;
			long lCount=0;
			Object[] yValues = new Object[7];
			Object[] xValues = new Object[7];
			SqlConnection cn = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TKWUCDSQLA02");
			SqlCommand cm = new SqlCommand();
			SqlDataReader dr;
			string sPath;
			OCAData.CCountDailyClass rpt = new OCAData.CCountDailyClass();

			System.DateTime dDate = new System.DateTime(System.DateTime.Now.Year, System.DateTime.Now.Month, 
				System.DateTime.Now.Day);
			OWC.WCChart oChart, oChart1;
			OWC.ChartSpaceClass oSpace = new OWC.ChartSpaceClass();
			OWC.ChartSpaceClass oSpace1 = new OWC.ChartSpaceClass();
			OWC.WCSeries oSeries, oSeries1;


			cn.Open();
			cm.CommandType = CommandType.StoredProcedure;
			cm.CommandTimeout = 240;
			cm.CommandText = "GetDailySnapshot";
			cm.Connection = cn;
			cm.Parameters.Add("@CreatedDate", System.Data.SqlDbType.DateTime);
			cm.Parameters["@CreatedDate"].Value = dDate.AddDays(-1);
			dr = cm.ExecuteReader();
			try
			{
				dr.Read();
				LAWatson = dr.GetInt32(0);
				LAArchive = dr.GetInt32(1);
			}
			catch
			{
				LAWatson = 0;
				LAArchive = 0;
			}
			
			oSpace.Clear();
			oSpace.Refresh();
			oChart = oSpace.Charts.Add(0);
			oChart.Type = OWC.ChartChartTypeEnum.chChartTypeBarClustered;
			oSeries = oChart.SeriesCollection.Add(0);
			lACount = rpt.GetDailyCount(dDate.AddDays(-1));
			

			
			xValues.SetValue(lACount.ToString(), 0);
			xValues.SetValue(LAWatson.ToString(), 1);
			xValues.SetValue(LAArchive.ToString(), 2);
			yValues.SetValue("Database", 0);
			yValues.SetValue("Watson", 1);
			yValues.SetValue("Archive", 2);
			oChart.HasTitle = true;
			oChart.Title.Caption = "Database - Server Comparison Chart";
			oSeries.Caption = dDate.Date.ToString();	//chDimCategories
			oSeries.SetData(OWC.ChartDimensionsEnum.chDimCategories, -1, yValues);
			oSeries.SetData(OWC.ChartDimensionsEnum.chDimValues, -1, xValues);
			oSeries.Type = OWC.ChartChartTypeEnum.chChartTypeColumnClustered;
			sFName = "Daily";
			
			sPath = Server.MapPath(sFName);
			try
			{
				oSpace.ExportPicture(sPath, "gif", 707, 476);
				imgWeekly.ImageUrl = sFName;
			}
			catch
			{

			}
//			Response.Write(Server.MapPath(sFName));

			oSpace1.Clear();
			oSpace1.Refresh();
			oChart1 = oSpace1.Charts.Add(0);
			oChart1.Type = OWC.ChartChartTypeEnum.chChartTypeBarClustered;
			oSeries1 = oChart1.SeriesCollection.Add(0);
			
			

			
			for(rowCtr=0; rowCtr <= rowCnt; rowCtr++) 
			{
				TableRow tRow = new TableRow();
				tblUploads.Rows.Add(tRow);
				for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
				{
					TableCell tCell = new TableCell();

					if(rowCtr == 0)
					{
						switch(cellCtr)
						{
							case 1 :
								tCell.Text = "Date";
								break;
							case 2 :
								tCell.Text = "DB Count";
								break;
							case 3 :
								tCell.Text = "Watson";
								break;
							case 4 :
								tCell.Text = "Archive";
								break;
							default:
								tCell.Text = "0";
								break;
						
						}
						tCell.Style["font-size"] = "small";

					}
					else
					{
						switch(cellCtr)
						{
							case 1 :
								tCell.Text = dDate.AddDays(-1).ToShortDateString();
								break;
							case 2 :
								tCell.Text = lACount.ToString();
								break;
							case 3 :
								tCell.Text = LAWatson.ToString();
								break;
							case 4 :
								tCell.Text = LAArchive.ToString();
								break;
							default:
								tCell.Text = "0";
								break;
						
						}
						tCell.Style["background-color"] = "white";
						tCell.Style["font-size"] = "x-small";
						tCell.Style["color"] = "#6487dc";
						tCell.Style["font-weight"] = "Bold";
						
					}
					tCell.Style["font-family"] = "Tahoma";
					tRow.Cells.Add(tCell);
				}

			}

			for(rowCtr=0; rowCtr <= rowCnt; rowCtr++) 
			{
				TableRow tRow = new TableRow();
				tblDifference.Rows.Add(tRow);
				for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
				{
					TableCell tCell = new TableCell();

					if(rowCtr == 0)
					{
						switch(cellCtr)
						{
							case 1 :
								tCell.Text = "Date";
								break;
							case 2 :
								tCell.Text = "Archive vs Watson";
								break;
							case 3 :
								tCell.Text = "SQL vs Archive";
								break;
							case 4 :
								tCell.Text = "SQL vs Watson";
								break;
							default:
								tCell.Text = "0";
								break;
						
						}
						tCell.Style["font-size"] = "small";

					}
					else
					{
						switch(cellCtr)
						{
							case 1 :
								tCell.Text = dDate.AddDays(-1).ToShortDateString();
								break;
							case 2 :
								lCount = LAArchive - LAWatson;
								tCell.Text = lCount.ToString();
								break;
							case 3 :
								lCount = lACount - LAArchive;
								tCell.Text = lCount.ToString();;
								break;
							case 4 :
								lCount = lACount - LAWatson;
								tCell.Text = lCount.ToString();
								break;
							default:
								tCell.Text = "0";
								break;
						
						}
						tCell.Style["background-color"] = "white";
						tCell.Style["font-size"] = "x-small";
						tCell.Style["color"] = "#6487dc";
						tCell.Style["font-weight"] = "Bold";
						
					}
					tCell.Style["font-family"] = "Tahoma";
					tRow.Cells.Add(tCell);
				}

			}

		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocawreports\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//        When specifying the KeyFile, the location of the KeyFile should be
//        relative to the "project output directory". The location of the project output
//        directory is dependent on whether you are working with a local or web project.
//        For local projects, the project output directory is defined as
//       <Project Directory>\obj\<Configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//        For web projects, the project output directory is defined as
//       %HOMEPATH%\VSWebCache\<Machine Name>\<Project Directory>\obj\<Configuration>.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocawreports\automanual.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.SqlClient;


namespace OCAWReports
{
	/// <summary>
	/// Summary description for automanual.
	/// </summary>
	public class automanual : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Table tblAutoManual;
		protected System.Web.UI.WebControls.Image imgAutoManualDaily;
		protected System.Web.UI.WebControls.Image imgAutoManualTotal;
		/*************************************************************************************
		*	module: automanual.aspx.cs - Page_Load
		*
		*	author: Tim Ragain
		*	date: Jan 22, 2002
		*
		*	Purpose: to Create both gif charts from the Office Watson Controls and set the images to those
		*	files.  Create OCAData object and return data for anonymous versus customer uploads.  Set the information
		*	in the tables to correspond to the graphs.  
		*************************************************************************************/
		private void Page_Load(object sender, System.EventArgs e)
		{
			int x = -1;
			int y = 0;
			int rowCnt = 7;
			int rowCtr = 0;
			int cellCtr = 0;
			int cellCnt = 3;
			string sFName;
			long[]  LACustomer = new long[7];
			long[] LAAnon = new long[7];
			long[] LANulls = new long[7];
			long lTemp = 0,lTotalAnon = 0,lTotalCustomer = 0;
			Object[] yColTitle = new Object[7];
			Object[] xAutoManValues = new Object[7];
			Object[] yColTitle2 = new Object[3];
			Object[] xAutoManValues2 = new Object[3];
			OCAData.CCountDailyClass rpt = new OCAData.CCountDailyClass();
			
			System.DateTime dDate = new System.DateTime(System.DateTime.Now.Year, System.DateTime.Now.Month, 
				System.DateTime.Now.Day);
			OWC.WCChart oWeeklyChart, oAvgChart;
			OWC.ChartSpaceClass oSpace = new OWC.ChartSpaceClass();
			OWC.ChartSpaceClass oSpace1 = new OWC.ChartSpaceClass();
			OWC.WCSeries oSeries, oSeries1;
			OWC.WCDataLabels oLabels;
			OWC.WCDataLabelsCollection oLabelCollection;
			SqlConnection cn = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TKWUCDSQLA02");
			SqlCommand cm = new SqlCommand();
			SqlDataReader dr;
			
			oSpace.Clear();
			oSpace.Refresh();
			oWeeklyChart = oSpace.Charts.Add(0);
			oWeeklyChart.Type = OWC.ChartChartTypeEnum.chChartTypeBarClustered;
			oWeeklyChart.HasLegend = true;
			cn.Open();
			cm.CommandType = CommandType.StoredProcedure;
			cm.CommandTimeout = 240;
			cm.CommandText = "GetSnapshot";
			cm.Connection = cn;
			cm.Parameters.Add("@CreatedDate", System.Data.SqlDbType.DateTime);
			cm.Parameters["@CreatedDate"].Value = dDate.AddDays(-1);
			dr = cm.ExecuteReader();
			for(x = 0; x < 7; x++)
			{
				try
				{
					dr.Read();
					lTotalCustomer = dr.GetInt32(3);
					//				LAAnon[x] = lTotalCustomer;
					lTemp = dr.GetInt32(4);
					LAAnon[x] = lTemp;
					lTemp = lTotalCustomer - lTemp;
					LACustomer[x] = lTemp;
					lTotalCustomer = lTotalCustomer + LACustomer[x];
					lTotalAnon = lTotalAnon + lTemp;
				}
				catch
				{
					LAAnon[x] = 0;
					lTemp = 0;
					LACustomer[x] = 0;
				}

			}
			//Begin Image One

			for(x=0, y=6;x<7;x++,y--)
			{
				oSeries = oWeeklyChart.SeriesCollection.Add(x);
				xAutoManValues.SetValue(LACustomer[x].ToString(), 0);
				xAutoManValues.SetValue(LAAnon[x].ToString(), 1);

				yColTitle.SetValue("Auto", 0);
				yColTitle.SetValue("Manual", 1);
				oWeeklyChart.HasTitle = true;
				oWeeklyChart.Title.Caption = "Database - Manual vs Auto Uploads";
				oSeries.Caption = dDate.AddDays(-y).Date.ToString();	//chDimCategories
				oSeries.SetData(OWC.ChartDimensionsEnum.chDimCategories, -1, yColTitle);
				oSeries.SetData(OWC.ChartDimensionsEnum.chDimValues, -1, xAutoManValues);
				oSeries.Type = OWC.ChartChartTypeEnum.chChartTypeColumnClustered;
			}

			sFName = "Anon";
			try
			{
				oSpace.ExportPicture(Server.MapPath(sFName), "gif", 707, 476);
				imgAutoManualDaily.ImageUrl = sFName;
			}
			catch
			{
			}

			//End Image one


			//Begin Image Two
			oSpace1.Clear();
			oSpace1.Refresh();
			oAvgChart = oSpace1.Charts.Add(0);
			oAvgChart.Type = OWC.ChartChartTypeEnum.chChartTypeBarClustered;
			oAvgChart.HasLegend = true;

			lTemp = lTotalCustomer + lTotalAnon;
			oSeries1 = oAvgChart.SeriesCollection.Add(0);
			oLabelCollection = oSeries1.DataLabelsCollection;
			
			oLabels = oLabelCollection.Add();
			oLabels.HasPercentage = true;
			oLabels.HasValue = false;
		

			xAutoManValues2.SetValue(lTotalAnon.ToString(), 0);
			xAutoManValues2.SetValue(lTotalCustomer.ToString(), 1);
			yColTitle2.SetValue("Manual", 0);
			yColTitle2.SetValue("Auto", 1);
			oAvgChart.HasTitle = true;
			oAvgChart.Title.Caption = "Database - Average Weekly Uploads";
			oSeries1.Caption = "Average Weekly";	//chDimCategories
			oSeries1.SetData(OWC.ChartDimensionsEnum.chDimCategories, -1, yColTitle2);
			oSeries1.SetData(OWC.ChartDimensionsEnum.chDimValues, -1, xAutoManValues2);
			oSeries1.Type = OWC.ChartChartTypeEnum.chChartTypePie;

			sFName = "AnonPer";
			try
			{
				oSpace1.ExportPicture(Server.MapPath(sFName), "gif", 707, 476);
				imgAutoManualTotal.ImageUrl = sFName;
			}
			catch
			{
			}

			//End Image Two

			//Begin Table
			for(rowCtr=0, y=8; rowCtr <= rowCnt; rowCtr++, y--) 
			{
				TableRow tRow = new TableRow();
				tblAutoManual.Rows.Add(tRow);
				//tRow.CssClass = "clsTRMenu";
				for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
				{
					TableCell tCell = new TableCell();

					if(rowCtr == 0)
					{
						switch(cellCtr)
						{
							case 1 :
								tCell.Text = "Date";
								break;
							case 2 :
								tCell.Text = "Auto";
								break;
							case 3 :
								tCell.Text = "Manual";
								break;
							default:
								tCell.Text = "0";
								break;
						
						}
						tCell.Style["font-size"] = "small";

					}
					else
					{
						switch(cellCtr)
						{
							case 1 :
								tCell.Text = dDate.AddDays(-y).ToShortDateString();
								break;
							case 2 :
								tCell.Text = LACustomer[rowCtr-1].ToString();
								break;
							case 3 :
								tCell.Text = LAAnon[rowCtr-1].ToString();
								break;
							default:
								tCell.Text = "0";
								break;
						
						}
						tCell.Style["background-color"] = "white";
						tCell.Style["font-size"] = "small-x";
						tCell.Style["color"] = "#6487dc";
						tCell.Style["font-weight"] = "Bold";
						
					}
					tCell.Style["font-family"] = "Tahoma";
					tRow.Cells.Add(tCell);
				}
			}

			//End Table 
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocawreports\foot.inc ===
<TABLE WIDTH="100%" CELLPADDING="5" CELLSPACING="0" BORDER="0" BGCOLOR="#FFFFFF" VALIGN="bottom">
<TR VALIGN="MIDDLE" align="left">
<TD COLSPAN="2" HEIGHT="30" WIDTH="100%" BGCOLOR="#6487DC" valign="bottom">
<FONT COLOR="#FFFFFF" FACE="Verdana, Arial, Helvetica"SIZE="1">
<NOBR>
&nbsp;&#169; 2001 Microsoft Corporation. All rights reserved.
<A STYLE="color:#FFFFFF;"HREF="http://www.microsoft.com/isapi/gomscom.asp?target=/info/cpyright.htm">Terms of use</A>&nbsp;<FONT COLOR="#FFFFFF">|</FONT>
<A STYLE="color:#FFFFFF;"HREF="http://www.microsoft.com/isapi/gomscom.asp?target=/info/privacy.htm">Privacy Statement</A>&nbsp;<FONT COLOR="#FFFFFF">|</FONT>
<A STYLE="color:#FFFFFF;"HREF="http://www.microsoft.com/enable/default.htm">Accessibility</A>
</NOBR>
</FONT>
</TD>
</TR>
</TABLE>

</BODY>
</HTML>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocawreports\home.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace OCAWReports
{
	/// <summary>
	/// Summary description for home.
	/// </summary>
	public class home : System.Web.UI.Page
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocawreports\side.inc ===
<table BORDER="0" height="100%" cellpadding="0" cellspacing="0" width="182">
				<tr valign="top">
					<td>	
					<table width="100%" cellpadding="0" cellspacing="0" border="0">
						<tr>
							<td class="sys-toppane-header">
								On Line Crash Analysis Tools
							</td>
						</tr>
					</table>
					<table width="100%" cellpadding="0" cellspacing="0" border="0" height="100%">
						<tr>
							<td rowspan="2" height="100%" class="flyoutMenu" valign="top">
						<table width="100%" cellpadding="0" cellspacing="0" border="0">
							<tr>
								<td class="flyoutLink" valign="middle">
									<img src="endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;
									<a href="home.aspx">Home</a>
								</td>
							</tr>
						</table>
						<table width="100%" cellpadding="0" cellspacing="0" border="0">
							<tr>
								<td class="flyoutLink" valign="middle">
									<img src="endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;
									<a href="DailyReport.aspx">Daily Report</a>
								</td>
							</tr>
						</table>
						<table width="100%" cellpadding="0" cellspacing="0" border="0">
							<tr>
								<td class="flyoutLink" valign="middle">
									<img src="endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;
									<a href="WeeklyReport.aspx">Weekly Report</a>
								</td>
							</tr>
						</table>
						<table width="100%" cellpadding="0" cellspacing="0" border="0">
							<tr>
								<td class="flyoutLink" valign="middle">
									<img src="endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;
									<a href="anoncustomer.aspx">AnonymousVsCustomer</a>
								</td>
							</tr>
						</table>
						<table width="100%" cellpadding="0" cellspacing="0" border="0">
							<tr>
								<td class="flyoutLink" valign="middle">
									<img src="endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;
									<a href="automanual.aspx">AutoVsManual</a>
								</td>
							</tr>
						</table>
						<table width="100%" cellpadding="0" cellspacing="0" border="0">
							<tr>
								<td class="flyoutLink" valign="middle">
									<img src="endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;
									<a href="downloads.aspx">Downloads</a>
								</td>
							</tr>
						</table>
						<table width="100%" cellpadding="0" cellspacing="0" border="0">
							<tr>
								<td class="flyoutLink" valign="middle">
									<img src="endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;
									<a href="http://timragain06/xreports/home.aspx">XML Reports</a>
								</td>
							</tr>
						</table>
						</td>
					</tr>
				</table>
				</td>
			</tr>
		</table>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocawreports\solutionstatus.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace OCAWReports
{
	/// <summary>
	/// Summary description for solutionstatus.
	/// </summary>
	public class solutionstatus : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Table tblWeeklySolution;
		protected System.Web.UI.WebControls.Image imgDailySolution;
		protected System.Web.UI.WebControls.Image imgWeeklySolution;
	
		private void Page_Load(object sender, System.EventArgs e)
		{
			int x = -1;
//			int y = 0;
//			int rowCnt = 7;
//			int rowCtr=0;
//			int cellCtr=0;
//			int cellCnt = 3;
			string sFName;
			long[]  LASpecific = new long[7];
			long[] LAGeneral = new long[7];
			long[] LAStopCode = new long[7];
//			long lTemp=0,lTotalAnon=0,lTotalCustomer=0;
			Object[] yValues = new Object[7];
			Object[] xValues = new Object[7];
			Object[] yValues1 = new Object[3];
			Object[] xValues1 = new Object[3];
			OCAData.CCountDailyClass rpt = new OCAData.CCountDailyClass();
			
			System.DateTime dDate = new System.DateTime(System.DateTime.Now.Year, System.DateTime.Now.Month, 
				System.DateTime.Now.Day);
			OWC.WCChart oChart;
//			OWC.WCChart oChart1;
			OWC.ChartSpaceClass oSpace = new OWC.ChartSpaceClass();
			OWC.ChartSpaceClass oSpace1 = new OWC.ChartSpaceClass();
			OWC.WCSeries oSeries;
//			OWC.WCSeries oSeries1;
//			OWC.WCDataLabels oLabels;
//			OWC.WCDataLabelsCollection oLabelCollection;
			
			//System.Array xValues = System.Array.CreateInstance(typeof(Object), 7, 1);
			//Array xValues = Array.CreateInstance(typeof(Object),3);
			Server.ScriptTimeout = 360;
			
			oSpace.Clear();
			oSpace.Refresh();
			oChart = oSpace.Charts.Add(0);
			oChart.Type = OWC.ChartChartTypeEnum.chChartTypeBarClustered;
			oChart.HasLegend = true;
			//Begin Image One
			for(x=0;x<7;x++)
			{
				oSeries = oChart.SeriesCollection.Add(x);
				try
				{
					LASpecific[x] = rpt.GetSpecificSolutions(dDate.AddDays(-(x + 1)));
				}
				catch
				{
					LASpecific[x] = 0;
				}
				try
				{
					LAGeneral[x] = rpt.GetGeneralSolutions(dDate.AddDays(-(x + 1)));
				}
				catch
				{
					LAGeneral[x] = 0;
				}
				try
				{
					LAStopCode[x] = rpt.GetStopCodeSolutions(dDate.AddDays(-(x + 1)));
				}
				catch
				{
					LAStopCode[x] = 0;
				}
				xValues.SetValue(LASpecific[x], 0);
				xValues.SetValue(LAGeneral[x], 1);
				xValues.SetValue(LAStopCode[x], 2);
				yValues.SetValue("Specific", 0);
				yValues.SetValue("General", 1);
				yValues.SetValue("StopCode", 2);
				oChart.HasTitle = true;
				oChart.Title.Caption = "Daily Solution Status";
				oSeries.Caption = dDate.AddDays(-(x + 1)).Date.ToString();	//chDimCategories
				oSeries.SetData(OWC.ChartDimensionsEnum.chDimCategories, -1, yValues);
				oSeries.SetData(OWC.ChartDimensionsEnum.chDimValues, -1, xValues);
				oSeries.Type = OWC.ChartChartTypeEnum.chChartTypeColumnClustered;
			}

			sFName = "DailySolution";
			oSpace.ExportPicture(Server.MapPath(sFName), "gif", 1000, 512);
			imgDailySolution.ImageUrl = sFName;

		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\sitemonitor\errorcodes.h ===
// Isapi error codes returned with the response url
#define MESSAGE_RECEIVE_TIMEOUT		1
#define FAILED_TO_SEND_MESSAGE		2
#define FAILED_CONNECT_SEND			3
#define FAILED_CONNECT_RECEIVE		4
#define FILE_NOT_FOUND				5
#define EXCEEDED_MAX_THREAD_COUNT	6
#define FAILED_TO_IMPERSONATE_USER	7
#define FAILED_TO_PARSE_QUERYSTRING 8
#define INVALID_TYPE_SPECIFIED		9
#define FAILED_TO_COPY_FILE			10
#define INTERNAL_ERROR				11
#define FAILED_RECONNECT_RECEIVE	12
#define FAILED_TO_CREATE_CURSOR		13
#define FAILED_TO_CREATE_GUID		14
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocawreports\headerstrings.inc ===
<%

	string L_HEADER_INC_TITLE_PAGETITLE;
	string L_HEADERINC_ALINK_HOME_MENUITEM;
	string L_HEADERINC_ALINK_HOME2_MENUITEM;
	string L_HEADERINC_ALINK_SUBMITREPORT_MENUITEM;
	string L_HEADERINC_ALINK_CHECKSTATUS_MENUITEM;
	string L_HEADERINC_ALINK_RESOURCES_MENUITEM;
	string L_HEADERINC_ALINK_PRIVACY_MENUITEM;
	string L_HEADERINC_ALINK_FEEDBACK_MENUITEM;
	string L_HEADERINC_ALINK_FAQ_MENUITEM;
	string L_HEADERINC_ALINK_SIGNIN;
	string L_HEADERINC_ALINK_SIGNIN_MENUITEM;
	string L_HEADERINC_IMAGE_ALT_TOOLTIP;
	string L_HEADERINC_TOP10STATUS_LINK_TEXT;
	string L_HEADERINC_ALINK_MICROSOFT_MENUITEM;
	string L_HEADERINC_TITLE_OCAHOME_TOOLTIP;
	string L_HEADERINC_TITLE_CERHOME_TOOLTIP;
	string L_HEADERINC_IMAGES_BANNER_TEXT;
	string L_HEADERINC_ISAPI_HOME_MENUITEM;
	string L_HEADERINC_MICROSOFT_HOME_MENUITEM;
	string L_HEADERINC_ALL_PRODUCTS_MENUITEM;
	string L_HEADERINC_ALLPRODUCTS_LINK_TEXT;
	string L_HEADERINC_DOWNLOADS_DOWNLOADS_MENUITEM;
	string L_HEADERINC_DOWNLOADS_LINK_TEXT;
	string L_HEADERINC_MSPRODUCT_CATALOG_MENUITEM;
	string L_HEADERINC_MSPRODUCT_CATALOG_TEXT;
	string L_HEADERINC_MICROSOFT_ACCESSIBILITY_MENUITEM;
	string L_HEADERINC_MICROSOFT_ACCESSIBILITY_TEXT;
	string L_HEADERINC_SERVER_PRODUCTS_MENUITEM;
	string L_HEADERINC_SERVER_PRODUCTS_TEXT;
	string L_HEADERINC_DEVELOPER_TOOLS_MENUITEM;
	string L_HEADERINC_DEVELOPER_TOOLS_TEXT;
	string L_HEADERINC_OFFICE_FAMILY_MENUITEM;
	string L_HEADERINC_OFFICE_FAMILY_TEXT;
	string L_HEADERINC_WINDOWS_FAMILY_MENUITEM;
	string L_HEADERINC_WINDOWS_FAMILY_TEXT;
	string L_HEADERINC_MSN_LINK_TEXT;
	string L_HEADERINC_MSN_LINK_MENUITEM;
	string L_HEADERINC_SUPPORT_LINK_TEXT;
	string L_HEADERINC_SUPPORT_LINK_MENUITEM;
	string L_HEADERINC_KNOWLEDGE_BASE_TEXT;
	string L_HEADERINC_KNOWLEDGE_BASE_MENUITEM;
	string L_HEADERINC_PRODUCTSUPPORT_OPTIONS_TEXT;
	string L_HEADERINC_PRODUCTSUPPORT_OPTIONS_MENUITEM;
	string L_HEADERINC_SERVICEPARTNER_REFERRALS_TEXT;
	string L_HEADERINC_SERVICEPARTNER_REFERRALS_MENUITEM;
	string L_HEADERINC_SEARCH_LINK_TEXT;
	string L_HEADERINC_SEARCH_LINK_MENUITEM;
	string L_HEADERINC_SEARCH_MICROSOFT_TEXT;
	string L_HEADERINC_SEARCH_MICROSOFT_MENUITEM;
	string L_HEADERINC_MSNWEB_SEARCH_TEXT;
	string L_HEADERINC_MSNWEB_SEARCH_MENUITEM;
	string L_HEADERINC_MICROSOFTCOM_GUIDE_TEXT;
	string L_HEADERINC_MICROSOFTCOM_GUIDE_MENUITEM;
	string L_HEADERINC_MICROSOFTCOM_HOME_TEXT;
	string L_HEADERINC_MICROSOFTCOM_HOME_MENUITEM;
	string L_HEADERINC_MSN_HOME_TEXT;
	string L_HEADERINC_MSN_HOME_MENUITEM;
	string L_HEADERINC_CONTACT_US_TEXT;
	string L_HEADERINC_CONTACT_US_MENUITEM;
	string L_HEADERINC_EVENTS_LINK_TEXT;
	string L_HEADERINC_EVENTS_LINK_MENUITEM;
	string L_HEADERINC_NEWSLETTERS_LINK_TEXT;
	string L_HEADERINC_NEWSLETTERS_LINK_MENUITEM;
	string L_HEADERINC_PROFILE_CENTER_TEXT;
	string L_HEADERINC_PROFILE_CENTER_MENUITEM;
	string L_HEADERINC_TRAINING_CERTIFICATION_TEXT;
	string L_HEADERINC_TRAINING_CERTIFICATION_MENUITEM;
	string L_HEADERINC_FREEEMAIL_ACCOUNT_TEXT;
	string L_HEADERINC_FREEEMAIL_ACCOUNT_MENUITEM;
	string L_HEADERINC_MICROSOFT_RIGHTSRESERVED_TEXT;
	string L_HEADERINC_TERMSOF_USE_TEXT;
	string L_HEADERINC_TERMSOF_USE_MENUITEM;
	string L_HEADERINC_PRIVACY_STATEMENT_TEXT;
	string L_HEADERINC_PRIVACY_STATEMENT_MENUITEM;
	string L_HEADERINC_ACCESSIBILITY_LINK_TEXT;
	string L_HEADERINC_ACCESSIBILITY_LINK_MENUITEM;
	string L_HEADERINC_ALINK_CER_MENUITEM;
	string L_HEADERINC_ALINK_WORLD_MENUITEM; 
	string L_HEADERINC_TITLE_WORLDHOME_TOOLTIP;
	string L_HEADERINC_LEFT_NAV_TEXT;
	string L_HEADERCERINC_LEFT_NAV_TEXT;
	
	//'-------------------------header.asp Page Strings-------------------------
	L_HEADERCERINC_LEFT_NAV_TEXT = "Corporate reports";
	L_HEADERINC_LEFT_NAV_TEXT = "OCA Reports";
	L_HEADERINC_ALINK_CER_MENUITEM = "Corporate Error Reporting";
	L_HEADERINC_ALINK_WORLD_MENUITEM = "Online Crash Analysis Worldwide";
	L_HEADERINC_ACCESSIBILITY_LINK_TEXT = "http:////www.microsoft.com//enable//default.htm";
	L_HEADERINC_ACCESSIBILITY_LINK_MENUITEM = "Accessibility";
	L_HEADERINC_PRIVACY_STATEMENT_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//info//privacy.htm";
	L_HEADERINC_PRIVACY_STATEMENT_MENUITEM = "Privacy Statement";
	L_HEADERINC_TERMSOF_USE_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//info//cpyright.htm";
	L_HEADERINC_TERMSOF_USE_MENUITEM = "Terms of Use";
	L_HEADERINC_MICROSOFT_RIGHTSRESERVED_TEXT = "&#169; 2001 Microsoft Corporation. All rights reserved.";
	L_HEADERINC_FREEEMAIL_ACCOUNT_TEXT = "http:////www.hotmail.com//";
	L_HEADERINC_FREEEMAIL_ACCOUNT_MENUITEM = "Free E-mail Account";
	L_HEADERINC_TRAINING_CERTIFICATION_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//train_cert//";
	L_HEADERINC_TRAINING_CERTIFICATION_MENUITEM = "Training & Certification";
	L_HEADERINC_PROFILE_CENTER_TEXT = "http:////www.microsoft.com//isapi//goregwiz.asp?target=//regsys//pic.asp";
	L_HEADERINC_PROFILE_CENTER_MENUITEM = "Profile Center";
	L_HEADERINC_NEWSLETTERS_LINK_TEXT = "http:////www.microsoft.com//isapi//goregwiz.asp?target=//regsys//pic.asp?sec=0";
	L_HEADERINC_NEWSLETTERS_LINK_MENUITEM = "Newsletters";
	L_HEADERINC_EVENTS_LINK_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//usa//events//default.asp";
	L_HEADERINC_EVENTS_LINK_MENUITEM = "Events";
	L_HEADERINC_CONTACT_US_TEXT = "http:////www.microsoft.com//isapi//goregwiz.asp?target=//regwiz//forms//contactus.asp";
	L_HEADERINC_CONTACT_US_MENUITEM = "Contact Us";
	L_HEADERINC_MSN_HOME_TEXT = "http:////www.msn.com//";
	L_HEADERINC_MSN_HOME_MENUITEM = "MSN Home";
	L_HEADERINC_MICROSOFTCOM_HOME_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//";
	L_HEADERINC_MICROSOFTCOM_HOME_MENUITEM = "microsoft.com Home";
	L_HEADERINC_MICROSOFTCOM_GUIDE_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//";
	L_HEADERINC_MICROSOFTCOM_GUIDE_MENUITEM = "microsoft.com Guide";
	L_HEADERINC_MSNWEB_SEARCH_TEXT = "http:////search.msn.com//";
	L_HEADERINC_MSNWEB_SEARCH_MENUITEM = "MSN Web Search";
	L_HEADERINC_SEARCH_MICROSOFT_TEXT = "http:////www.microsoft.com//isapi//gosearch.asp?target=//us//default.asp";
	L_HEADERINC_SEARCH_MICROSOFT_MENUITEM = "Search microsoft.com";
	L_HEADERINC_SEARCH_LINK_TEXT = "http:////www.microsoft.com//isapi//gosearch.asp?target=//us//default.asp";
	L_HEADERINC_SEARCH_LINK_MENUITEM = "Search";
	L_HEADERINC_SERVICEPARTNER_REFERRALS_TEXT = "http:////mcspreferral.microsoft.com//";
	L_HEADERINC_SERVICEPARTNER_REFERRALS_MENUITEM = "Service Partner Referrals";
	L_HEADERINC_PRODUCTSUPPORT_OPTIONS_TEXT = "http:////www.microsoft.com//isapi//gosupport.asp?target=//directory//";
	L_HEADERINC_PRODUCTSUPPORT_OPTIONS_MENUITEM = "Product Support Options";
	L_HEADERINC_KNOWLEDGE_BASE_TEXT = "http:////support.microsoft.com//search//";
	L_HEADERINC_KNOWLEDGE_BASE_MENUITEM = "Knowledge Base";
	L_HEADERINC_SUPPORT_LINK_TEXT = "http:////www.microsoft.com//isapi//gosupport.asp?target=//directory//";
	L_HEADERINC_SUPPORT_LINK_MENUITEM = "Support";
	L_HEADERINC_MSN_LINK_TEXT = "http:////www.msn.com//";
	L_HEADERINC_MSN_LINK_MENUITEM = "MSN";
	L_HEADERINC_WINDOWS_FAMILY_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//windows//";
	L_HEADERINC_WINDOWS_FAMILY_MENUITEM = "Windows Family";
	L_HEADERINC_OFFICE_FAMILY_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//office//";
	L_HEADERINC_OFFICE_FAMILY_MENUITEM = "Office Family";
	L_HEADERINC_DEVELOPER_TOOLS_TEXT = "http:////www.microsoft.com//isapi//gomsdn.asp?target=//vstudio//";
	L_HEADERINC_DEVELOPER_TOOLS_MENUITEM = "Developer Tools";
	L_HEADERINC_SERVER_PRODUCTS_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//servers//";
	L_HEADERINC_SERVER_PRODUCTS_MENUITEM = "Server Products";
	L_HEADERINC_MICROSOFT_ACCESSIBILITY_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//enable//";
	L_HEADERINC_MICROSOFT_ACCESSIBILITY_MENUITEM = "Microsoft Accessibility";
	L_HEADERINC_MSPRODUCT_CATALOG_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//catalog//default.asp?subid=22";
	L_HEADERINC_MSPRODUCT_CATALOG_MENUITEM = "MS Product Catalog";
	L_HEADERINC_DOWNLOADS_LINK_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//downloads//";
	L_HEADERINC_DOWNLOADS_DOWNLOADS_MENUITEM = "Downloads";
	L_HEADERINC_ALLPRODUCTS_LINK_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//catalog//default.asp?subid=22";
	L_HEADERINC_ALL_PRODUCTS_MENUITEM = "All Products";
	L_HEADERINC_TOP10STATUS_LINK_TEXT = "Transaction status";
	L_HEADER_INC_TITLE_PAGETITLE = "Windows Online Crash Analysis";
	L_HEADERINC_ALINK_HOME_MENUITEM = "Home";
	L_HEADERINC_ALINK_HOME2_MENUITEM = "OCA Reporting Tools";
	L_HEADERINC_ALINK_SUBMITREPORT_MENUITEM = "Submit Report";
	L_HEADERINC_ALINK_CHECKSTATUS_MENUITEM = "Status";
	L_HEADERINC_ALINK_RESOURCES_MENUITEM = "Resources";
	L_HEADERINC_ALINK_PRIVACY_MENUITEM = "Privacy";
	L_HEADERINC_ALINK_FEEDBACK_MENUITEM = "Feedback";
	L_HEADERINC_ALINK_FAQ_MENUITEM = "FAQ";
	L_HEADERINC_ALINK_SIGNIN_MENUITEM = "Sign-in with your Passport";
	L_HEADERINC_IMAGE_ALT_TOOLTIP = "Windows Online Crash Analysis home page";
	L_HEADERINC_ALINK_MICROSOFT_MENUITEM = "http:////www.microsoft.com";
	L_HEADERINC_TITLE_OCAHOME_TOOLTIP = "Windows Online Crash Analysis home page";
	L_HEADERINC_TITLE_CERHOME_TOOLTIP = "Corporate Error Reporting home page";
	L_HEADERINC_TITLE_WORLDHOME_TOOLTIP = "Windows Online Crash Analysis Worldwide home page";
	L_HEADERINC_IMAGES_BANNER_TEXT = "http:////www.microsoft.com//library//toolbar//images//banner.gif";
	L_HEADERINC_ISAPI_HOME_MENUITEM = "//isapi//gomscom.asp?target=//";
	L_HEADERINC_MICROSOFT_HOME_MENUITEM = "Microsoft Home";
	
	
	////'-------------------------End-------------------------

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocawreports\weeklyreport.aspx.cs ===
#define FILE_SERVER			//FILE_LOCAL	FILE_SERVER

using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Reflection;
using System.Runtime.InteropServices;
using Microsoft.Win32;
using System.Security.Permissions;
using System.Data.SqlClient;
using System.IO;




namespace OCAWReports
{
	/// <summary>
	/// Summary description for WeeklyReport.
	/// </summary>
	public class DailyReport : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Table tblUploads;
		protected System.Web.UI.WebControls.Image imgAvg;
		protected System.Web.UI.WebControls.Table tblDifference;
		protected System.Web.UI.WebControls.Calendar Calendar1;
		protected System.Web.UI.WebControls.Image imgWeekly;

		private void Page_Load(object sender, System.EventArgs e)
		{
			Response.Cache.SetExpires(DateTime.Now.AddHours(-1));
			Response.ExpiresAbsolute = DateTime.Now;
			Response.Cache.SetCacheability(HttpCacheability.NoCache);


			Response.CacheControl = "no-cache";
			Response.AddHeader("Pragma", "no-cache");
			Response.AddHeader("Expires", "-1");
			Response.Expires = -1;
			Page.Response.Expires = -1;
			Response.Cache.SetExpires(DateTime.Now.AddSeconds(-1));
//			Response.Cache.SetExpires(DateTime.Now.AddSeconds(-1));
//			Response.Cache.SetCacheability(HttpCacheability.Public);
//			Response.Cache.SetValidUntilExpires(true);
//			Cache.
//			imgWeekly.EnableViewState = false;
//			imgWeekly.Page.EnableViewState = false;
//			Page.EnableViewState = false;
			
			
			if(Page.IsPostBack == false)
			{
				int x = -1;
				int rowCnt = 7;
				int rowCtr=0;
				int cellCtr=0;
				int cellCnt = 4;
				string sFName;
				long[]  lACount = new long[7];
				long[] LAWatson = new long[7];
				long[] LAArchive = new long[7];
				long lCount=0, lArchive=0, lWatson=0;
				Object[] yValues = new Object[7];
				Object[] LAGraph = new Object[3];
				Object[] xValues = new Object[7];
				Object[] yValues1 = new Object[3];
				Object[] xValues1 = new Object[3];
				OCAData.CCountDailyClass rpt = new OCAData.CCountDailyClass();
				System.DateTime dDate = new System.DateTime(System.DateTime.Now.Year, System.DateTime.Now.Month, 
					System.DateTime.Now.Day);
				OWC.WCChart oChart, oChart1;
				OWC.ChartSpaceClass oSpace = new OWC.ChartSpaceClass();
				OWC.ChartSpaceClass oSpace1 = new OWC.ChartSpaceClass();
				OWC.WCSeries oSeries1;
				SqlConnection cn = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TKWUCDSQLA02");
				SqlCommand cm = new SqlCommand();
				SqlDataReader dr;
				double dbDays = -7;
				DateTime dDate2 = DateTime.Now;

				oSpace.Clear();
				oSpace.Refresh();
				oChart = oSpace.Charts.Add(0);

				oChart.HasLegend = true;
				oChart.HasTitle = true;
				for(x=0;x<3;x++)
				{
					oChart.SeriesCollection.Add(x);
				}
				for(x=0;x<7;x++)
				{
					lACount[x] = rpt.GetDailyCount(dDate.AddDays(-(x + 1)));

				}
				cn.Open();
				cm.CommandType = CommandType.StoredProcedure;
				cm.CommandTimeout = 240;
				cm.CommandText = "GetSnapshot";
				cm.Connection = cn;
				cm.Parameters.Add("@CreatedDate", System.Data.SqlDbType.DateTime);
				dDate2 = dDate.AddDays(dbDays);
				cm.Parameters["@CreatedDate"].Value = dDate.AddDays(-1);
				dr = cm.ExecuteReader();
				Calendar1.SelectedDate = dDate2;
				dr.Read();
				for(x = 0; x < 7; x++)
				{
					try
					{
						if(dr.GetDateTime(1) == dDate.AddDays(-(x + 1)))
						{
							LAWatson[x] = dr.GetInt32(2);
							LAArchive[x] = dr.GetInt32(3);
							dr.Read();
						}
						else
						{
							LAWatson[x] = 0;
							LAArchive[x] = 0;
						}
					}
					catch
					{
						LAWatson[x] = 0;
						LAArchive[x] = 0;
					}
				}
				
				//**********************************************************************************************************
				oChart.Title.Caption = "Database - Server Comparison Chart";
				for(x = 0; x < 7; x++)
				{
					xValues[x] = lACount[x].ToString();
				}
				

				oChart.SeriesCollection[0].Caption = "Database";
				oChart.SeriesCollection[0].SetData((OWC.ChartDimensionsEnum) OWC.ChartDimensionsEnum.chDimValues, -1, xValues);

				OWC.ChartDimensionsEnum c = OWC.ChartDimensionsEnum.chDimValues;

				oChart.SeriesCollection[0].SetData(c, -1, xValues);
				
				for(x = 0; x < 7; x++)
				{
					xValues[x] = LAWatson[x].ToString();
				}
				oChart.SeriesCollection[1].Caption = "Watson";
				oChart.SeriesCollection[1].SetData(OWC.ChartDimensionsEnum.chDimValues, -1, xValues);
				for(x = 0; x < 7; x++)
				{
					xValues[x] = LAArchive[x].ToString();
				}
				oChart.SeriesCollection[2].Caption = "Archive";
				oChart.SeriesCollection[2].SetData(OWC.ChartDimensionsEnum.chDimValues, -1, xValues);
				for(x = 0; x < 7; x++)
				{
					yValues.SetValue(dDate.AddDays(-(x + 1)).ToShortDateString(), x);
				}
				oChart.SeriesCollection[0].SetData(OWC.ChartDimensionsEnum.chDimCategories, -1, yValues);
				//**********************************************************************************************************
				sFName = "Weekly";
				try
				{
					oSpace.ExportPicture(Server.MapPath(sFName + ".gif"), "gif", 707, 476);
					imgWeekly.ImageUrl = sFName + ".gif";
				}
				catch
				{
				}
				imgWeekly.EnableViewState = false;
				oSpace1.Clear();
				oSpace1.Refresh();
				oChart1 = oSpace1.Charts.Add(0);
				oChart1.Type = OWC.ChartChartTypeEnum.chChartTypeBarClustered;
				oSeries1 = oChart1.SeriesCollection.Add(0);
				for(x=0;x<7;x++)
				{
					lCount = lCount + lACount[x];
					lWatson = lWatson + LAWatson[x];
					lArchive = lArchive + LAArchive[x];
				}
				lCount = lCount / x;
				lWatson = lWatson / x;
				lArchive = lArchive / x;
				xValues1.SetValue(lCount.ToString(), 0);
				xValues1.SetValue(lWatson.ToString(), 1);
				xValues1.SetValue(lArchive.ToString(), 2);
				yValues1.SetValue("Database", 0);
				yValues1.SetValue("Watson", 1);
				yValues1.SetValue("Archive", 2);
				oChart1.HasTitle = true;
				oChart1.Title.Caption = "Database - Average Weekly Uploads";
				oSeries1.Caption = "Average Weekly";	//chDimCategories
				oSeries1.SetData(OWC.ChartDimensionsEnum.chDimCategories, -1, yValues1);
				oSeries1.SetData(OWC.ChartDimensionsEnum.chDimValues, -1, xValues1);
				oSeries1.Type = OWC.ChartChartTypeEnum.chChartTypeColumnStacked;

				sFName = "Avg";
				try
				{
					oSpace1.ExportPicture(Server.MapPath(sFName), "gif", 707, 476);
					imgAvg.ImageUrl = sFName;
				}
				catch
				{
				}
				for(rowCtr=0; rowCtr <= rowCnt; rowCtr++) 
				{
					TableRow tRow = new TableRow();
					tblUploads.Rows.Add(tRow);
					for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
					{
						TableCell tCell = new TableCell();

						if(rowCtr == 0)
						{
							switch(cellCtr)
							{
								case 1 :
									tCell.Text = "Date";
									break;
								case 2 :
									tCell.Text = "DB Count";
									break;
								case 3 :
									tCell.Text = "Watson";
									break;
								case 4 :
									tCell.Text = "Archive";
									break;
								default:
									tCell.Text = "0";
									break;
							
							}
							tCell.Style["font-size"] = "small";

						}
						else
						{
							switch(cellCtr)
							{
								case 1 :
									tCell.Text = dDate.AddDays(-rowCtr).ToShortDateString();
									break;
								case 2 :
									tCell.Text = lACount[rowCtr-1].ToString();
									break;
								case 3 :
									tCell.Text = LAWatson[rowCtr-1].ToString();
									break;
								case 4 :
									tCell.Text = LAArchive[rowCtr-1].ToString();
									break;
								default:
									tCell.Text = "0";
									break;
							
							}
							tCell.Style["background-color"] = "white";
							tCell.Style["font-size"] = "small-x";
							tCell.Style["color"] = "#6487dc";
							tCell.Style["font-weight"] = "Bold";
							
						}
						tCell.Style["font-family"] = "Tahoma";
						tRow.Cells.Add(tCell);
					}
				}

				
				for(rowCtr=0; rowCtr <= rowCnt; rowCtr++) 
				{
					TableRow tRowDiff = new TableRow();
					tblDifference.Rows.Add(tRowDiff);
					for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
					{
						TableCell tCell = new TableCell();

						if(rowCtr == 0)
						{
							switch(cellCtr)
							{
								case 1 :
									tCell.Text = "Date";
									break;
								case 2 :
									tCell.Text = "Archive vs Watson";
									break;
								case 3 :
									tCell.Text = "SQL vs Archive";
									break;
								case 4 :
									tCell.Text = "SQL vs Watson";
									break;
								default:
									tCell.Text = "0";
									break;
							
							}
							tCell.Style["font-size"] = "small";

						}
						else
						{
							switch(cellCtr)
							{
								case 1 :
									tCell.Text = dDate.AddDays(-(rowCtr)).ToShortDateString();
									break;
								case 2 :
									lCount = LAArchive[rowCtr-1] - LAWatson[rowCtr-1];
									tCell.Text = lCount.ToString();
									break;
								case 3 :
									lCount = lACount[rowCtr-1] - LAWatson[rowCtr-1];
									tCell.Text = lCount.ToString();
									break;
								case 4 :
									lCount = lACount[rowCtr-1] - LAArchive[rowCtr-1];
									tCell.Text = lCount.ToString();
									break;
								default:
									tCell.Text = "0";
									break;
							
							}
							tCell.Style["background-color"] = "white";
							tCell.Style["font-size"] = "small-x";
							tCell.Style["color"] = "#6487dc";
							tCell.Style["font-weight"] = "Bold";
							
						}
						tCell.Style["font-family"] = "Tahoma";
						tRowDiff.Cells.Add(tCell);
					}
				}
			}
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.imgWeekly.PreRender += new System.EventHandler(this.imgWeekly_PreRender);
			this.imgWeekly.Load += new System.EventHandler(this.imgWeekly_Load);
			this.Calendar1.SelectionChanged += new System.EventHandler(this.Calendar1_SelectionChanged);
			this.ID = "DailyReport";
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		private void Calendar1_SelectionChanged(object sender, System.EventArgs e)
		{
			int x = -1;
			int y = 0;
			int rowCnt = 7;
			int rowCtr=0;
			int cellCtr=0;
			int cellCnt = 4;
			string sFName;
			long[]  lACount = new long[7];
			long[] LAWatson = new long[7];
			long[] LAArchive = new long[7];
			long lCount=0, lArchive=0, lWatson=0;
			Object[] yValues = new Object[7];
			Object[] LAGraph = new Object[3];
			Object[] xValues = new Object[7];
			Object[] yValues1 = new Object[3];
			Object[] xValues1 = new Object[3];
			OCAData.CCountDailyClass rpt = new OCAData.CCountDailyClass();
			System.DateTime dDate = new System.DateTime(System.DateTime.Now.Year, System.DateTime.Now.Month, 
				System.DateTime.Now.Day);
			OWC.WCChart oChart, oChart1;
			OWC.ChartSpaceClass oSpace = new OWC.ChartSpaceClass();
			OWC.ChartSpaceClass oSpace1 = new OWC.ChartSpaceClass();
			OWC.WCSeries oSeries1;
			SqlConnection cn = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TKWUCDSQLA02");
			SqlCommand cm = new SqlCommand();
			SqlDataReader dr;



			Response.CacheControl = "no-cache";
			Response.AddHeader("Pragma", "no-cache");
			Response.AddHeader("Expires", "-1");
			Response.Expires = -1;



			oSpace.Clear();
			oSpace.Refresh();
			oChart = oSpace.Charts.Add(0);

			oChart.HasLegend = true;
			oChart.HasTitle = true;
			for(x=0;x<3;x++)
			{
				oChart.SeriesCollection.Add(x);
			}
			dDate = Calendar1.SelectedDate;
			for(x = 0, y = 6;x < 7;x++, y--)
			{
				lACount[x] = rpt.GetDailyCount(dDate.AddDays(y));

			}
			cn.Open();
			cm.CommandType = CommandType.StoredProcedure;
			cm.CommandTimeout = 240;
			cm.CommandText = "GetSnapshot";
			cm.Connection = cn;
			cm.Parameters.Add("@CreatedDate", System.Data.SqlDbType.DateTime);
			cm.Parameters["@CreatedDate"].Value = dDate.AddDays(6);
			dr = cm.ExecuteReader();
			dr.Read();
			for(x = 0; x < 7; x++)
			{
				try
				{
//					if(dr.GetDateTime(1) == dDate.AddDays((x + 1)))
//					{
						LAWatson[x] = dr.GetInt32(2);
						LAArchive[x] = dr.GetInt32(3);
						dr.Read();
//					}
//					else
//					{
//						LAWatson[x] = 0;
//						LAArchive[x] = 0;
//					}
				}
				catch
				{
					LAWatson[x] = 0;
					LAArchive[x] = 0;
				}
			}
				
			//**********************************************************************************************************
			oChart.Title.Caption = "Database - Server Comparison Chart";
			for(x = 0; x < 7; x++)
			{
				xValues[x] = lACount[x].ToString();
			}
				

			oChart.SeriesCollection[0].Caption = "Database";
			oChart.SeriesCollection[0].SetData((OWC.ChartDimensionsEnum) OWC.ChartDimensionsEnum.chDimValues, -1, xValues);

			OWC.ChartDimensionsEnum c = OWC.ChartDimensionsEnum.chDimValues;

			oChart.SeriesCollection[0].SetData(c, -1, xValues);
				
			for(x = 0; x < 7; x++)
			{
				xValues[x] = LAWatson[x].ToString();
			}
			oChart.SeriesCollection[1].Caption = "Watson";
			oChart.SeriesCollection[1].SetData(OWC.ChartDimensionsEnum.chDimValues, -1, xValues);
			for(x = 0; x < 7; x++)
			{
				xValues[x] = LAArchive[x].ToString();
			}
			oChart.SeriesCollection[2].Caption = "Archive";
			oChart.SeriesCollection[2].SetData(OWC.ChartDimensionsEnum.chDimValues, -1, xValues);
			for(x = 0, y = 6; x < 7; x++, y--)
			{
				yValues.SetValue(dDate.AddDays((y)).ToShortDateString(), x);
			}
			oChart.SeriesCollection[0].SetData(OWC.ChartDimensionsEnum.chDimCategories, -1, yValues);
			//**********************************************************************************************************
			sFName = "Weekly";
			try
			{
				oSpace.ExportPicture(Server.MapPath(sFName + ".gif"), "gif", 707, 476);
			}
			catch
			{

			}

			imgWeekly.EnableViewState = false;
			imgWeekly.Page.EnableViewState = false;
			Page.EnableViewState = false;
			
			imgWeekly.ImageUrl = sFName + ".gif";
			oSpace1.Clear();
			oSpace1.Refresh();
			oChart1 = oSpace1.Charts.Add(0);
			oChart1.Type = OWC.ChartChartTypeEnum.chChartTypeBarClustered;
			oSeries1 = oChart1.SeriesCollection.Add(0);
			for(x=0;x<7;x++)
			{
				lCount = lCount + lACount[x];
				lWatson = lWatson + LAWatson[x];
				lArchive = lArchive + LAArchive[x];
			}
			lCount = lCount / x;
			lWatson = lWatson / x;
			lArchive = lArchive / x;
			xValues1.SetValue(lCount.ToString(), 0);
			xValues1.SetValue(lWatson.ToString(), 1);
			xValues1.SetValue(lArchive.ToString(), 2);
			yValues1.SetValue("Database", 0);
			yValues1.SetValue("Watson", 1);
			yValues1.SetValue("Archive", 2);
			oChart1.HasTitle = true;
			oChart1.Title.Caption = "Database - Average Weekly Uploads";
			oSeries1.Caption = "Average Weekly";	//chDimCategories
			oSeries1.SetData(OWC.ChartDimensionsEnum.chDimCategories, -1, yValues1);
			oSeries1.SetData(OWC.ChartDimensionsEnum.chDimValues, -1, xValues1);
			oSeries1.Type = OWC.ChartChartTypeEnum.chChartTypeColumnStacked;

			sFName = "Avg";
			try
			{
				oSpace1.ExportPicture(Server.MapPath(sFName), "gif", 707, 476);
				imgAvg.ImageUrl = sFName;
			}
			catch
			{
			}
			for(rowCtr=0, y = 7; rowCtr <= rowCnt; rowCtr++, y--) 
			{
				TableRow tRow = new TableRow();
				tblUploads.Rows.Add(tRow);
				for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
				{
					TableCell tCell = new TableCell();

					if(rowCtr == 0)
					{
						switch(cellCtr)
						{
							case 1 :
								tCell.Text = "Date";
								break;
							case 2 :
								tCell.Text = "DB Count";
								break;
							case 3 :
								tCell.Text = "Watson";
								break;
							case 4 :
								tCell.Text = "Archive";
								break;
							default:
								tCell.Text = "0";
								break;
							
						}
						tCell.Style["font-size"] = "small";

					}
					else
					{
						switch(cellCtr)
						{
							case 1 :
								tCell.Text = dDate.AddDays(y).ToShortDateString();
								break;
							case 2 :
								tCell.Text = lACount[rowCtr-1].ToString();
								break;
							case 3 :
								tCell.Text = LAWatson[rowCtr-1].ToString();
								break;
							case 4 :
								tCell.Text = LAArchive[rowCtr-1].ToString();
								break;
							default:
								tCell.Text = "0";
								break;
							
						}
						tCell.Style["background-color"] = "white";
						tCell.Style["font-size"] = "small-x";
						tCell.Style["color"] = "#6487dc";
						tCell.Style["font-weight"] = "Bold";
							
					}
					tCell.Style["font-family"] = "Tahoma";
					tRow.Cells.Add(tCell);
				}
			}

				
			for(rowCtr=0, y = 7; rowCtr <= rowCnt; rowCtr++, y--) 
			{
				TableRow tRowDiff = new TableRow();
				tblDifference.Rows.Add(tRowDiff);
				for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
				{
					TableCell tCell = new TableCell();

					if(rowCtr == 0)
					{
						switch(cellCtr)
						{
							case 1 :
								tCell.Text = "Date";
								break;
							case 2 :
								tCell.Text = "Archive vs Watson";
								break;
							case 3 :
								tCell.Text = "SQL vs Archive";
								break;
							case 4 :
								tCell.Text = "SQL vs Watson";
								break;
							default:
								tCell.Text = "0";
								break;
							
						}
						tCell.Style["font-size"] = "small";

					}
					else
					{
						switch(cellCtr)
						{
							case 1 :
								tCell.Text = dDate.AddDays(y).ToShortDateString();
								break;
							case 2 :
								lCount = LAArchive[rowCtr-1] - LAWatson[rowCtr-1];
								tCell.Text = lCount.ToString();
								break;
							case 3 :
								lCount = lACount[rowCtr-1] - LAWatson[rowCtr-1];
								tCell.Text = lCount.ToString();
								break;
							case 4 :
								lCount = lACount[rowCtr-1] - LAArchive[rowCtr-1];
								tCell.Text = lCount.ToString();
								break;
							default:
								tCell.Text = "0";
								break;
							
						}
						tCell.Style["background-color"] = "white";
						tCell.Style["font-size"] = "small-x";
						tCell.Style["color"] = "#6487dc";
						tCell.Style["font-weight"] = "Bold";
							
					}
					tCell.Style["font-family"] = "Tahoma";
					tRowDiff.Cells.Add(tCell);
				}
			}
		}

		private void imgWeekly_Load(object sender, System.EventArgs e)
		{
			imgWeekly.ImageUrl = "";
		
		}

		private void imgWeekly_PreRender(object sender, System.EventArgs e)
		{
			imgWeekly.ImageUrl = "Weekly.gif";
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\sitemonitor\logging.cpp ===
#include "main.h"
#include "resource.h"
// Write log entry()
extern HINSTANCE g_hinst;
extern time_t LogStart;
extern TCHAR  LogFileName[MAX_PATH];
extern HANDLE hLogFile;
BOOL   bLoggingEnabled = TRUE;

TCHAR  szHeader[] = _T("Time,UploadTime,UploadStatus,ProcessTime,ProcessStatus,ThreadExecution,MessageRecieve,MessageSend,ReturnedUrl,ErrorText\r\n");

void 
LogMessage(TCHAR *pFormat,...)
{
	
	// Routine to Log Fatal Errors to NT Event Log
    TCHAR    chMsg[256];
	DWORD    dwBytesWritten;
    va_list  pArg;
	
    va_start(pArg, pFormat);
    StringCbVPrintf(chMsg, sizeof chMsg,pFormat, pArg);
    va_end(pArg);

	if (bLoggingEnabled)
	{
		if (LogStart == 0)
		{
			// We need to create a new log file
			time (&LogStart);
			hLogFile = CreateFile (LogFileName,
									GENERIC_WRITE,
									FILE_SHARE_READ,
									NULL,
									CREATE_ALWAYS,
									FILE_ATTRIBUTE_NORMAL,
									NULL);
			// write the header
			WriteFile(hLogFile,
					  szHeader,
					  _tcslen(szHeader) * (DWORD)sizeof TCHAR,
					  &dwBytesWritten,
					  NULL);

		}
		

		// add a cr\lf combination for file fomrating.
		StringCbCat(chMsg, sizeof chMsg,_T("\r\n"));

		/* Write to event log. */
		if (hLogFile != INVALID_HANDLE_VALUE)
		{
			WriteFile(hLogFile,
					  chMsg,
					  _tcslen(chMsg) * (DWORD)sizeof TCHAR,
					  &dwBytesWritten,
					  NULL);
		}
	}
}

void On_LoggingInit(HWND hwnd)
{
//	HWND hComboBox;

	// read app reg key for user specified settings.
	//GetRegData(	);
	
	CheckDlgButton(hwnd, IDC_RADIO1, TRUE);


	// Populate the combo box
	
	SetDlgItemText(hwnd, IDC_EDIT1, LogFileName);
	
}


void On_LogBrowse(HWND hwnd)
{

	HWND hParent = hwnd;
//	char *WindowTitle;


	// determine the language and Load the resource strings. 
	TCHAR String1[] = _T("Cab Files (*.cab)");
	TCHAR String2[] = _T("All Files (*.*)");

	static TCHAR szFilterW[400];


	// Build the buffer;

	TCHAR Pattern1[] = _T("*.cab");
	TCHAR Pattern2[] = _T("*.*");
	TCHAR * src;
	TCHAR *dest;

	src = String1;
	dest = szFilterW;

	while (*src != _T('\0'))
	{
		*dest = *src;
		src ++;
		dest ++;
	}
	src = Pattern1;
	*dest = _T('\0');
	++dest;
	while (*src != _T('\0'))
	{
		*dest = *src;
		src ++;
		dest ++;
	}
	*dest = _T('\0');
	++dest;
	src = String2;
	while (*src != _T('\0'))
	{
		*dest = *src;
		src ++;
		dest ++;
	}
	src = Pattern2;
	*dest = _T('\0');
	++dest;
	while (*src != _T('\0'))
	{
		*dest = *src;
		src ++;
		dest ++;
	}
	*dest = _T('\0');
	++dest;
	*dest = _T('\0');

	BOOL Return = FALSE;


	TCHAR szFileNameW [MAX_PATH] = _T("\0");
	TCHAR szDefaultPathW[MAX_PATH] = _T("\0");



	OPENFILENAME ofn;
	GetWindowsDirectory(szDefaultPathW,MAX_PATH);
	

	ofn.lStructSize = sizeof (OPENFILENAME);
	
	ofn.lpstrFilter =  szFilterW;
	ofn.lpstrInitialDir = szDefaultPathW;
	ofn.lpstrFile = szFileNameW;
	ofn.hInstance = NULL;
	ofn.hwndOwner = hParent;
	ofn.lCustData = NULL;
	ofn.Flags = 0;
	ofn.lpstrDefExt = _T("*.cab");
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxFile = MAX_PATH;
	ofn.lpstrFileTitle = NULL;
	ofn.lpstrTitle = NULL;
	ofn.nFileOffset = 0;
	ofn.nFileExtension = 0;
	ofn.lpfnHook = NULL;
	ofn.lpTemplateName = NULL;
	if (GetOpenFileName(&ofn))
	{
		SetDlgItemText(hwnd, IDC_EDIT5, ofn.lpstrFile);
	}



}

void OnLoggingOk(HWND hwnd)
{
	if (hLogFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hLogFile);
		LogStart = 0;
	}
	GetDlgItemText(hwnd, IDC_EDIT1, LogFileName, MAX_PATH);

	if(IsDlgButtonChecked(hwnd, IDC_RADIO3))
		bLoggingEnabled = FALSE;
	if (hLogFile != INVALID_HANDLE_VALUE)
	{
		CloseHandle(hLogFile);
		hLogFile = INVALID_HANDLE_VALUE;
		LogStart = 0;
	}
}

LRESULT CALLBACK LoggingDlgBox(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	switch (iMsg)
	{
	case WM_INITDIALOG:
		{
			On_LoggingInit(hwnd);


			return TRUE;
		}
	case WM_COMMAND:
		{
			switch (LOWORD(wParam))
			{
			case IDOK:
				OnLoggingOk(hwnd);
				EndDialog(hwnd, 0);
				// Save the current option settings
				return TRUE;
		
			case IDCANCEL:
				EndDialog(hwnd, 0);
				return TRUE;
			
		///	case ID_APPLY:
				//OnOptionsOk(hwnd);
				// Save the current option settings
		//		return TRUE;
		//	case IDC_BROWSE:
			//	On_Browse(hwnd);
		//		return TRUE;
		
			}

			break;
		}

	case WM_NOTIFY:
	
		return DefDlgProc(hwnd, iMsg, wParam, lParam);
	}
	return 0;
}

void On_ToolsLogging(HWND hwnd)
{
	DialogBox(g_hinst,MAKEINTRESOURCE(IDD_LOGGING)  ,hwnd, (DLGPROC) LoggingDlgBox);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\sitemonitor\logging.h ===
#ifndef _LOGGING_H
#define _LOGGING_H

void On_ToolsLogging(HWND hwnd);
LRESULT CALLBACK LoggingDlgBox(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam);
void LogMessage(TCHAR *pFormat,...);
void On_LoggingInit(HWND hwnd);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocawreports\language.inc ===
<%
	'Response.Write "<br>LCID: " &  session.LCID
	'Response.Write "<br>GetLocale Function: " & GetLocale
	'Response.Write "<Br>Hex: " & Hex(GetLocale)
	'Response.Write "<br> HTTP_ACCEPT_LANGUAGE: "  & Request.ServerVariables("HTTP_ACCEPT_LANGUAGE")

	Dim strAcceptLanguage
	Dim strLCID
	Dim strPos
	Dim strAbb
	  
	strAcceptLanguage = Request.ServerVariables("HTTP_ACCEPT_LANGUAGE")

	strPos = InStr(1, strAcceptLanguage, ",")
	If strPos > 0 Then
	strAcceptLanguage = Left(strAcceptLanguage, strPos - 1)
	End If
	'Response.Write "<br>Results: " & strAcceptLanguage
	Select Case LCase(strAcceptLanguage)
		Case "af"
		  strLCID = 1078  ' Afrikaans 
		  strAbb = "AFK"
		Case "sq"
		  strLCID = 1052  ' Albanian 
		  strAbb = "SQI"
		Case "ar-sa"
		  strLCID = 1025  ' Arabic(Saudi Arabia) 
		  strAbb = "ARA"
		Case "ar-iq"
		  strLCID = 2049  ' Arabic(Iraq) 
		  strAbb = "ARI"
		Case "ar-eg"
		  strLCID = 3073  ' Arabic(Egypt) 
		  strAbb = "ARE"
		Case "ar-ly"
		  strLCID = 4097  ' Arabic(Libya)
		   strAbb = "ARL"
		Case "ar-dz"
		  strLCID = 5121  ' Arabic(Algeria) 
		  strAbb = "ARG"
		Case "ar-ma"
		  strLCID = 6145  ' Arabic(Morocco) 
		  strAbb = "ARM"
		Case "ar-tn"
		  strLCID = 7169  ' Arabic(Tunisia) 
		  strAbb = "ART"
		Case "ar-om"
		  strLCID = 8193  ' Arabic(Oman) 
		  strAbb = "ARO"
		Case "ar-ye"
		  strLCID = 9217  ' Arabic(Yemen) 
		  strAbb = "ARY"
		Case "ar-sy"
		  strLCID = 10241 ' Arabic(Syria) 
		  strAbb = "ARS"
		Case "ar-jo"
		  strLCID = 11265 ' Arabic(Jordan) 
		  strAbb = "ARJ"
		Case "ar-lb"
		  strLCID = 12289 ' Arabic(Lebanon) 
		  strAbb = "ARB"
		Case "ar-kw"
		  strLCID = 13313 ' Arabic(Kuwait) 
		  strAbb = "ARK"
		Case "ar-ae"
		  strLCID = 14337 ' Arabic(U.A.E.) 
		  strAbb = "ARU"
		Case "ar-bh"
		  strLCID = 15361 ' Arabic(Bahrain) 
		  strAbb = "ARH"
		Case "ar-qa"
		  strLCID = 16385 ' Arabic(Qatar) 
		  strAbb = "ARQ"
		Case "eu"
		  strLCID = 1069  ' Basque 
		  strAbb = "EUQ"
		Case "bg"
		  strLCID = 1026  ' Bulgarian 
		  strAbb = "BGR"
		Case "be"
		  strLCID = 1059  ' Belarusian 
		  strAbb = "BEL"
		Case "ca"
		  strLCID = 1027  ' Catalan 
		  strAbb = "CAT"
		Case "zh-tw"
		  strLCID = 1028  ' Chinese(Taiwan) 
		  strAbb = "CHT"
		Case "zh-cn"
		  strLCID = 2052  ' Chinese(PRC) 
		  strAbb = "CHS"
		Case "zh-hk"
		  strLCID = 3076  ' Chinese(Hong Kong) 
		  strAbb = "ZHH"
		Case "zh-sg"
		  strLCID = 4100  ' Chinese(Singapore)
		  strAbb = "ZHI"
		Case "hr"
		  strLCID = 1050  ' Croatian 
		  strAbb = "HRV"
		Case "cs"
		  strLCID = 1029  ' Czech 
		  strAbb = "CSY"
		Case "da"
		  strLCID = 1030  ' Danish 
		  strAbb = "DAN"
		Case "n"
		  strLCID = 1043  ' Dutch(Standard) 
		  strAbb = "NLD"
		Case "nl-be"
		  strLCID = 2067  ' Dutch(Belgian) 
		  strAbb = "NLB"
		Case "en"
		  strLCID = 9     ' English 
		  strAbb = "USA"
		Case "en-us"
		  strLCID = 1033  ' English(United States) 
		  strAbb = "USA"
		Case "en-gb"
		  strLCID = 2057  ' English(British) 
		  strAbb = "ENG"
		Case "en-au"
		  strLCID = 3081  ' English(Australian) 
		  strAbb = "ENA"
		Case "en-ca"
		  strLCID = 4105  ' English(Canadian) 
		  strAbb = "ENC"
		Case "en-nz"
		  strLCID = 5129  ' English(New Zealand) 
		  strAbb = "ENZ"
		Case "en-ie"
		  strLCID = 6153  ' English(Ireland) 
		  strAbb = "ENI"
		Case "en-za"
		  strLCID = 7177  ' English(South Africa) 
		  strAbb = "ENS"
		Case "en-jm"
		  strLCID = 8201  ' English(Jamaica) 
		  strAbb = "ENJ"
		Case "en"
		  strLCID = 9225  ' English(Caribbean) 
		  strAbb = "ENB"
		Case "en-bz"
		  strLCID = 10249 ' English(Belize) 
		  strAbb = "ENL"
		Case "en-tt"
		  strLCID = 11273 ' English(Trinidad) 
		  strAbb = "ENT"
		Case "et"
		  strLCID = 1061  ' Estonian 
		  strAbb = "ETI"
		Case "fo"
		  strLCID = 1080  ' Faeroese 
		  strAbb = "FOS"
		Case "fa"
		  strLCID = 1065  ' Farsi 
		  strAbb = "FAR"
		Case "fi"
		  strLCID = 1035  ' Finnish 
		  strAbb = "FIN"
		Case "fr"
		  strLCID = 1036  ' French(Standard) 
		  strAbb = "FRA"
		Case "fr-be"
		  strLCID = 2060  ' French(Belgian) 
		  strAbb = "FRB"
		Case "fr-ca"
		  strLCID = 3084  ' French(Canadian) 
		  strAbb = "FRC"
		Case "fr-ch"
		  strLCID = 4108  ' French(Swiss) 
		  strAbb = "FRS"
		Case "fr-lu"
		  strLCID = 5132  ' French(Luxembourg) 
		  strAbb = "FRL"
		'Case "gd"
		  'strLCID = 1084  ' Gaelic(Scots) 
		  'strAbb = ""
		'Case "gd-ie"
		  'strLCID = 2108  ' Gaelic(Irish) 
		  'strAbb = ""
		Case "de"
		  strLCID = 1031  ' German(Standard) 
		  strAbb = "GER"
		Case "de-ch"
		  strLCID = 2055  ' German(Swiss) 
		  strAbb = "DES"
		Case "de-at"
		  strLCID = 3079  ' German(Austrian) 
		  strAbb = "DEA"
		Case "de-lu"
		  strLCID = 4103  ' German(Luxembourg) 
		  strAbb = "DEL"
		Case "de-li"
		  strLCID = 5127  ' German(Liechtenstein) 
		  strAbb = "DEC"
		Case "e"
		  strLCID = 1032  ' Greek 
		  strAbb = "ELL"
		Case "he"
		  strLCID = 1037  ' Hebrew 
		  strAbb = "HEB"
		Case "hi"
		  strLCID = 1081  ' Hindi 
		  strAbb = "HIN"
		Case "hu"
		  strLCID = 1038  ' Hungarian 
		  strAbb = "HUN"
		Case "is"
		  strLCID = 1039  ' Icelandic 
		  strAbb = "ISL"
		Case "in"
		  strLCID = 1057  ' Indonesian 
		  strAbb = "IND"
		Case "it"
		  strLCID = 1040  ' Italian(Standard) 
		  strAbb = "ITA"
		Case "it-ch"
		  strLCID = 2064  ' Italian(Swiss) 
		  strAbb = "ITS"
		Case "ja"
		  strLCID = 1041  ' Japanese 
		  strAbb = "JPN"
		Case "ko"
		  strLCID = 1042  ' Korean 
		  strAbb = "KOR"
		'Case "ko"
		  'strLCID = 2066  ' Korean(Johab) 
		  'strAbb = ""
		Case "lv"
		  strLCID = 1062  ' Latvian 
		  strAbb = "LVI"
		Case "lt"
		  strLCID = 1063  ' Lithuanian 
		  strAbb = "LTH"
		Case "mk"
		  strLCID = 1071  ' Macedonian 
		  strAbb = "MKD"
		Case "ms"
		  strLCID = 1086  ' Malaysian 
		  strAbb = "MSL"
		'Case "mt"
		 ' strLCID = 1082  ' Maltese 
		  'strAbb = ""
		Case "no"
		  strLCID = 1044  ' Norwegian(Bokmal) 
		  strAbb = "NOR"
		Case "no"
		  strLCID = 2068  ' Norwegian(Nynorsk) 
		  strAbb = "NON"
		Case "p"
		  strLCID = 1045  ' Polish 
		  strAbb = "PLK"
		Case "pt-br"
		  strLCID = 1046  ' Portuguese(Brazilian) 
		  strAbb = "PTB"
		Case "pt"
		  strLCID = 2070  ' Portuguese(Standard) 
		  strAbb = "PTG"
		'Case "rm"
		 ' strLCID = 1047  ' Rhaeto-Romanic 
		  'strAbb = ""
		Case "ro"
		  strLCID = 1048  ' Romanian 
		  strAbb = "ROM"
		'Case "ro-mo"
		  'strLCID = 2072  ' Romanian(Moldavia) 
		  'strAbb = ""
		Case "ru"
		  strLCID = 1049  ' Russian 
		  strAbb = "RUS"
		'Case "ru-mo"
		  'strLCID = 2073  ' Russian(Moldavia) 
		  'strAbb = ""
		'Case "sz"
		 ' strLCID = 1083  ' Sami(Lappish) 
		  'strAbb = ""
		Case "sr"
		  strLCID = 3098  ' Serbian(Cyrillic) 
		  strAbb = "SRB"
		Case "sr"
		  strLCID = 2074  ' Serbian(Latin) 
		  strAbb = "SRL"
		Case "sk"
		  strLCID = 1051  ' Slovak 
		  strAbb = "SKY"
		Case "s"
		  strLCID = 1060  ' Slovenian 
		  strAbb = "SLV"
		'Case "sb"
		  'strLCID = 1070  ' Sorbian 
		  'strAbb = ""
		Case "es"
		  strLCID = 1034  ' Spanish(Spain - Traditional Sort)
		   strAbb = "ESP"
		Case "es-mx"
		  strLCID = 2058  ' Spanish(Mexican) 
		  strAbb = "ESM"
		Case "es"
		  strLCID = 3082  ' Spanish(Spain - Modern Sort) 
		  strAbb = "ESN"
		Case "es-gt"
		  strLCID = 4106  ' Spanish(Guatemala) 
		  strAbb = "ESG"
		Case "es-cr"
		  strLCID = 5130  ' Spanish(Costa Rica)
		   strAbb = "ESC"
		Case "es-pa"
		  strLCID = 6154  ' Spanish(Panama) 
		  strAbb = "ESA"
		Case "es-do"
		  strLCID = 7178  ' Spanish(Dominican Republic) 
		  strAbb = "ESD"
		Case "es-ve"
		  strLCID = 8202  ' Spanish(Venezuela) 
		  strAbb = "ESV"
		Case "es-co"
		  strLCID = 9226  ' Spanish(Colombia) 
		  strAbb = "ESO"
		Case "es-pe"
		  strLCID = 10250 ' Spanish(Peru) 
		  strAbb = "ESR"
		Case "es-ar"
		  strLCID = 11274 ' Spanish(Argentina) 
		  strAbb = "ESS"
		Case "es-ec"
		  strLCID = 12298 ' Spanish(Ecuador) 
		  strAbb = "ESF"
		Case "es-c"
		  strLCID = 13322 ' Spanish(Chile)
		   strAbb = "ESL"
		Case "es-uy"
		  strLCID = 14346 ' Spanish(Uruguay) 
		  strAbb = "ESY"
		Case "es-py"
		  strLCID = 15370 ' Spanish(Paraguay) 
		  strAbb = "ESZ"
		Case "es-bo"
		  strLCID = 16394 ' Spanish(Bolivia) 
		  strAbb = "ESB"
		Case "es-sv"
		  strLCID = 17418 ' Spanish(El Salvador) 
		  strAbb = "ESE"
		Case "es-hn"
		  strLCID = 18442 ' Spanish(Honduras) 
		  strAbb = "ESH"
		Case "es-ni"
		  strLCID = 19466 ' Spanish(Nicaragua) 
		  strAbb = "ESI"
		Case "es-pr"
		  strLCID = 20490 ' Spanish(Puerto Rico) 
		  strAbb = "ESU"
		'Case "sx"
		 ' strLCID = 1072  ' Sutu 
		  'strAbb = ""
		Case "sv"
		  strLCID = 1053  ' Swedish 
		  strAbb = "SVE"
		Case "sv-fi"
		  strLCID = 2077  ' Swedish(Finland) 
		  strAbb = "SVF"
		Case "th"
		  strLCID = 1054  ' Thai 
		  strAbb = "THA"
		'Case "ts"
		 ' strLCID = 1073  ' Tsonga 
		  'strAbb = ""
		'Case "tn"
		'  strLCID = 1074  ' Tswana 
		'  strAbb = ""
		Case "tr"
		  strLCID = 1055  ' Turkish 
		  strAbb = "TRK"
		Case "uk"
		  strLCID = 1058  ' Ukrainian 
		  strAbb = "UKR"
		Case "ur"
		  strLCID = 1056  ' Urdu 
		  strAbb = "URD"
		'Case "ve"
		  'strLCID = 1075  ' Venda 
		  strAbb = ""
		Case "vi"
		  strLCID = 1066  ' Vietnamese 
		  strAbb = "VIT"
		'Case "xh"
		  'strLCID = 1076  ' Xhosa 
		  'strAbb = ""
		'Case "ji"
		  'strLCID = 1085  ' Yiddish 
		  'strAbb = ""
		'Case "zu"
		  'strLCID = 1077  ' Zulu 
		  'strAbb = ""
		Case Else
		  strLCID = 2048  ' default
		  strAbb = "USA"
	End Select 

	'Session.LCID = clng(strLCID)
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\sitemonitor\main.h ===
#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <wininet.h>
#include <time.h>
#include <tchar.h>
#include <stdio.h>
#include <shlwapi.h>
#include <strsafe.h>
#include <commdlg.h>
#include <stdlib.h>
#include <stdio.h>
#include "ErrorCodes.h"
#include "Logging.h"

#define C_COLUMNS 9
typedef struct SiteStats
{
	TCHAR UploadTime[255];
	TCHAR ProcessingTime[255];
	TCHAR Status[255];
	TCHAR ReturnedUrl[255];
	TCHAR ProcessStatus[50];
	TCHAR UploadStatus[50];
	TCHAR ErrorString[255];
	TCHAR AvgProcessTime[50];
	TCHAR AvgUploadTime[50];
	TCHAR ThreadExecution[50];
	TCHAR SendQueueTime[50];
	TCHAR ReceiveQueueTime[50];
}SITESTATS, *PSITESTATS;

typedef struct MonitoringOptions
{
	DWORD dwPingRate;
	DWORD dwSiteID;
	TCHAR LogFileName[MAX_PATH];
	BOOL  bUploadMethod;   // True = Manual, False = Auto ( no upload timing available
	TCHAR ServerName[MAX_PATH];
	BOOL  CollectUploadTime;
	BOOL  CollectProcessTime;
	BOOL  UploadSingle;
	TCHAR FilePath[MAX_PATH];
	TCHAR Directory[MAX_PATH];
	TCHAR VirtualDirectory[255];
	int   iSeverIndex;

	
}MONITOR_OPTIONS, *PMONINTOR_OPTIONS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\stresssvc\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\xmlreports\assemblyinfo.cs ===
using System.Reflection;
using System.Runtime.CompilerServices;

//
// General Information about an assembly is controlled through the following 
// set of attributes. Change these attribute values to modify the information
// associated with an assembly.
//
[assembly: AssemblyTitle("")]
[assembly: AssemblyDescription("")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")]
[assembly: AssemblyProduct("")]
[assembly: AssemblyCopyright("")]
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]		

//
// Version information for an assembly consists of the following four values:
//
//      Major Version
//      Minor Version 
//      Build Number
//      Revision
//
// You can specify all the values or you can default the Revision and Build Numbers 
// by using the '*' as shown below:

[assembly: AssemblyVersion("1.0.*")]

//
// In order to sign your assembly you must specify a key to use. Refer to the 
// Microsoft .NET Framework documentation for more information on assembly signing.
//
// Use the attributes below to control which key is used for signing. 
//
// Notes: 
//   (*) If no key is specified, the assembly is not signed.
//   (*) KeyName refers to a key that has been installed in the Crypto Service
//       Provider (CSP) on your machine. KeyFile refers to a file which contains
//       a key.
//   (*) If the KeyFile and the KeyName values are both specified, the 
//       following processing occurs:
//       (1) If the KeyName can be found in the CSP, that key is used.
//       (2) If the KeyName does not exist and the KeyFile does exist, the key 
//           in the KeyFile is installed into the CSP and used.
//   (*) In order to create a KeyFile, you can use the sn.exe (Strong Name) utility.
//        When specifying the KeyFile, the location of the KeyFile should be
//        relative to the "project output directory". The location of the project output
//        directory is dependent on whether you are working with a local or web project.
//        For local projects, the project output directory is defined as
//       <Project Directory>\obj\<Configuration>. For example, if your KeyFile is
//       located in the project directory, you would specify the AssemblyKeyFile 
//       attribute as [assembly: AssemblyKeyFile("..\\..\\mykey.snk")]
//        For web projects, the project output directory is defined as
//       %HOMEPATH%\VSWebCache\<Machine Name>\<Project Directory>\obj\<Configuration>.
//   (*) Delay Signing is an advanced option - see the Microsoft .NET Framework
//       documentation for more information on this.
//
[assembly: AssemblyDelaySign(false)]
[assembly: AssemblyKeyFile("")]
[assembly: AssemblyKeyName("")]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\stresssvc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by StressSvc.rc
//
#define IDS_SERVICENAME 100

#define IDR_StressSvc		100


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\sitemonitor\main.cpp ===
#include "main.h"
#include "resource.h"
CRITICAL_SECTION ReportResults;
#include <Richedit.h>

// Globals
HINSTANCE	g_hinst;
HWND		g_hWnd;
BOOL		ContinuePing	= FALSE;
TCHAR		g_szPingEvent[] = _T("PingEvent");
BOOL		g_bMonitoring	= FALSE;
HANDLE		g_hPingEvent	= NULL;
DWORD		g_CurrentIndex	= -1;
double		RunningTime     = 0.0;
DWORD		TotalFilesProcessed = 0;
DWORD		TotalUploadFailures = 0;
DWORD		TotalUnknownErrors = 0;
DWORD		TotalTimeouts = 0;
time_t		appStart = 0;
time_t		appStop  = 0;
MONITOR_OPTIONS g_MonitorOptions;

DWORD		dwBufferPos = 0;
TCHAR		LogFileName[MAX_PATH];
HANDLE		hLogFile = INVALID_HANDLE_VALUE;
time_t		LogStart = 0;
double			TotalUploadTime = 0.0;
double			AvgUploadTime = 0.0;
double			TotalProcessTime = 0.0;
double			AvgProcessTime = 0.0;

double		TotalRecQueueTime = 0.0;
double		TotalSndQueueTime = 0.0;
double		TotalThreadTime   = 0.0;

BOOL UpdateListView(HWND hwnd, PSITESTATS pStats )
{
	LVITEM lvi;
	TCHAR  Temp[100];
	double ElapsedTime;
	ZeroMemory(&lvi, sizeof LVITEM);
	TCHAR tmpbuf[128];
	HWND hListControl = GetDlgItem( hwnd, IDC_LIST1);
	COLORREF CurrentColor;
	HWND hEditBox;


	lvi.mask = LVIF_TEXT | LVIF_STATE;
	lvi.state = 0;
	lvi.stateMask = 0;

	if ( (!_tcscmp(_T("FAILED"), pStats->UploadStatus) )|| (!_tcscmp(_T("FAILED"), pStats->ProcessStatus)) )
	{
	//	ListView_SetItemState( hListControl, g_CurrentIndex, LVIS_DROPHILITED,LVIS_DROPHILITED);
	//	hEditBox = ListView_GetEditControl(hListControl);
	//	SendMessage(hEditBox, EM_SETBKGNDCOLOR, 0, RGB(100,0,0));
		lvi.state = LVIS_DROPHILITED;

	}
	++g_CurrentIndex;
	if (g_CurrentIndex > 1000)
	{
		ListView_DeleteItem(hListControl,0);
			
		g_CurrentIndex -=1;
	}

	
	lvi.iItem = g_CurrentIndex ;
   // lvI.iImage = index;
	lvi.iSubItem = 0;
	lvi.pszText = pStats->UploadTime;

	ListView_InsertItem(hListControl,&lvi);

	lvi.iSubItem = 1;
	lvi.pszText = pStats->UploadStatus;

	ListView_SetItem(hListControl,&lvi);

	lvi.iSubItem = 2;
	lvi.pszText = pStats->ProcessingTime;

	ListView_SetItem(hListControl, &lvi);

	lvi.iSubItem = 3;
	lvi.pszText = pStats->ProcessStatus;
	ListView_SetItem(hListControl, &lvi);

	lvi.iSubItem = 4;
	lvi.pszText = pStats->ThreadExecution;
	ListView_SetItem(hListControl, &lvi);

	lvi.iSubItem = 5;
	lvi.pszText = pStats->ReceiveQueueTime;
	ListView_SetItem(hListControl, &lvi);

	
	lvi.iSubItem = 6;
	lvi.pszText = pStats->SendQueueTime;
	ListView_SetItem(hListControl, &lvi);

	
	lvi.iSubItem = 7;
	lvi.pszText = pStats->ReturnedUrl;
	ListView_SetItem(hListControl, &lvi);

	lvi.iSubItem = 8;
	lvi.pszText = pStats->ErrorString;;
	ListView_SetItem(hListControl, &lvi);

	ListView_EnsureVisible(hListControl, g_CurrentIndex, FALSE);


	_itot(TotalFilesProcessed,Temp,  10);
	SetDlgItemText(hwnd, IDC_EDIT3, Temp);
	
	_itot (TotalTimeouts,Temp, 10);
	SetDlgItemText(hwnd, IDC_EDIT2, Temp);
	
	_itot(TotalUploadFailures,Temp,10);
	SetDlgItemText(hwnd, IDC_EDIT4, Temp);
	
	_itot(TotalUnknownErrors,Temp,10);
	SetDlgItemText(hwnd, IDC_EDIT6, Temp);

	
	time(&appStop);
	ElapsedTime = difftime(appStop, appStart);
	StringCbPrintf(Temp, sizeof Temp, _T("%6.02f"), ElapsedTime);
	SetDlgItemText(hwnd, IDC_EDIT5, Temp);

	SetDlgItemText(hwnd, IDC_EDIT1, pStats->AvgUploadTime);
	SetDlgItemText(hwnd, IDC_EDIT7, pStats->AvgProcessTime);
	SetDlgItemText(hwnd, IDC_EDIT8, pStats->ThreadExecution);
	SetDlgItemText(hwnd, IDC_EDIT9, pStats->SendQueueTime);
	SetDlgItemText(hwnd, IDC_EDIT10, pStats->ReceiveQueueTime);
	LogMessage(_T("%s %s,%s,%s,%s,%s,%s,%s,%s,%s,%s"),_tstrdate(tmpbuf), _tstrtime( tmpbuf ),
										  pStats->UploadTime, pStats->UploadStatus,
										  pStats->ProcessingTime, pStats->ProcessStatus,
										  pStats->ThreadExecution, pStats->ReceiveQueueTime, pStats->SendQueueTime,
										  pStats->ReturnedUrl,
										  pStats->ErrorString);
return TRUE;

}

void GetRegData()
{

}




DWORD  Upload(TCHAR *SourceFileName, TCHAR *VirtualDir, TCHAR *HostName, TCHAR *RemoteFileName)
{
	static		const TCHAR *pszAccept[] = {_T("*.*"), 0};
	//TCHAR       RemoteFileName[MAX_PATH]; // Host/Virtualdirectory/filename
	BOOL		bRet				= FALSE;
	BOOL		UploadSuccess		= FALSE;
	DWORD		dwBytesRead			= 0;
	DWORD		dwBytesWritten		= 0;
	DWORD		ResponseCode		= 0;
	DWORD		ResLength			= 255;
	DWORD		index				= 0;
	DWORD		ErrorCode			= 0;
	HINTERNET   hSession			= NULL;
	HINTERNET	hConnect			= NULL;
	HINTERNET	hRequest			= NULL;
	INTERNET_BUFFERS   BufferIn		= {0};
	INTERNET_BUFFERS   BufferOut	= {0};
	HANDLE      hFile				= INVALID_HANDLE_VALUE;
	BYTE		*pBuffer;
	BOOL		bOnce				= FALSE;
	GUID		guidNewGuid;
	char		*szGuidRaw			= NULL;
	HRESULT		hResult				= S_OK;
	wchar_t		*wszGuidRaw			= NULL;
	TCHAR       DestinationName[MAX_PATH];


	
	CoInitialize(NULL);
	hResult = CoCreateGuid(&guidNewGuid);
	if (FAILED(hResult))
	{
		//-------------What do we send here....
		//goto ERRORS;
		;
	}
	else
	{
		if (UuidToStringW(&guidNewGuid, &wszGuidRaw) == RPC_S_OK)
		{
			if ( (szGuidRaw = (char *) malloc ( wcslen(wszGuidRaw)*2 )) != NULL)
			{
				// clear the memory
				ZeroMemory(szGuidRaw, wcslen(wszGuidRaw) * 2);
				wcstombs( szGuidRaw, wszGuidRaw, wcslen(wszGuidRaw));
			}
			else
			{
//				LogMessage(_T("Memory allocation failed: ErrorCode:%d"),GetLastError());
				ErrorCode = GetLastError();
				goto cleanup;
			}
		}
	}


	StringCbPrintf(DestinationName, MAX_PATH * sizeof TCHAR, _T("\\%s\\%s%s"),VirtualDir,szGuidRaw + 19, PathFindFileName(SourceFileName));
	
	StringCbPrintf(RemoteFileName, MAX_PATH * sizeof TCHAR, _T("%s%s"),szGuidRaw + 19, PathFindFileName(SourceFileName));

	hSession = InternetOpen(	_T("IsapiStress"),
								INTERNET_OPEN_TYPE_PRECONFIG,
								NULL,
								NULL,
								0);
	if (!hSession)
	{
//		LogMessage(_T("Failed to create an internet session."));
			CoUninitialize();
		ErrorCode = GetLastError();
		goto cleanup;
	}

	hConnect = InternetConnect(hSession,
								HostName,
								INTERNET_DEFAULT_HTTP_PORT,
								NULL,
								NULL,
								INTERNET_SERVICE_HTTP,
								0,
								NULL);

	if (hConnect == INVALID_HANDLE_VALUE)
	{
//		LogMessage(_T("Failed to create an internet connection."));
		ErrorCode = GetLastError();
		goto cleanup;
	}
//	LogMessage(_T("Connecting to: %s"),HostName);
//	LogMessage(_T("Uploading file: %s"),DestinationName);

	hRequest = HttpOpenRequest(	hConnect,
								_T("PUT"),
								DestinationName, 
								NULL,
								NULL,
								pszAccept,
								INTERNET_FLAG_NEED_FILE|INTERNET_FLAG_NO_CACHE_WRITE ,
								0);
	if (hRequest != INVALID_HANDLE_VALUE)
	{
		hFile = CreateFile( SourceFileName,
							GENERIC_READ,
							FILE_SHARE_READ,
							NULL,
							OPEN_EXISTING,
							FILE_ATTRIBUTE_NORMAL,
							NULL);
						
		if (hFile != INVALID_HANDLE_VALUE)
		{
		

			// Clear the buffer
			if ( (pBuffer = (BYTE *)malloc (70000)) != NULL)
			{
				BufferIn.dwStructSize = sizeof( INTERNET_BUFFERS );
				BufferIn.Next = NULL; 
				BufferIn.lpcszHeader = NULL;
				BufferIn.dwHeadersLength = 0;
				BufferIn.dwHeadersTotal = 0;
				BufferIn.lpvBuffer = NULL;                
				BufferIn.dwBufferLength = 0;
				BufferIn.dwOffsetLow = 0;
				BufferIn.dwOffsetHigh = 0;
				BufferIn.dwBufferTotal = GetFileSize (hFile, NULL);
				FillMemory(pBuffer, 70000,'/0'); // Fill buffer with data
			
				DWORD dwBuffLen = sizeof DWORD; 

				if(!HttpSendRequestEx(	hRequest,
										&BufferIn,
										NULL,
										HSR_INITIATE,
										0))
				{
//					LogMessage(_T("HttpSendRequestEx Failed."));
				}
				else
				{
					do
					{
						dwBytesRead = 0;
						bRet = ReadFile(hFile,
										pBuffer, 
										70000,
										&dwBytesRead,
										NULL);
						if (bRet != 0)
						{
							bRet = InternetWriteFile(hRequest,
													pBuffer,
													dwBytesRead,
													&dwBytesWritten);

							if ( (!bRet) || (dwBytesWritten==0) )
							{
//								LogMessage(_T("Error Writting File: %d"),ErrorCode = GetLastError());

							}

						
						}
					} while (dwBytesRead == sizeof (pBuffer));

					CloseHandle(hFile);
					hFile = INVALID_HANDLE_VALUE;
					bRet = HttpEndRequest(	hRequest,
											NULL, 
											0, 
											0);
					if (bRet)
					{
						ResponseCode = 0;
						HttpQueryInfo(hRequest,
									HTTP_QUERY_STATUS_CODE |HTTP_QUERY_FLAG_NUMBER,
									&ResponseCode,
									&ResLength,
									&index);
					
						if ( (ResponseCode != 200) && (ResponseCode != 201))
						{
							ErrorCode=ResponseCode;
//							LogMessage(_T("IIS Response Code = %d"),ResponseCode);
							// Cleanup for retry
						}						
						else
						{
							ErrorCode = 0;
//							LogMessage(_T("IIS Response Code = %d"),ResponseCode);
							UploadSuccess = TRUE;

						}
					}
					else
					{
						ErrorCode = GetLastError();
//						LogMessage(_T("HttpEndrequest Returned an Error: %d"), ErrorCode);
						
					}
				}
				

			}
			else
			{
				ErrorCode = GetLastError();
//				LogMessage(_T("Failed to allocate buffer memory"));
				
			}
		}
		else
		{
			ErrorCode = -1;
//			LogMessage(_T("Failed to Open Source File"));
			
		}
		
	}
	else
	{
		ErrorCode = GetLastError();
//		LogMessage(_T("Failed to Create Put Request"));
		
	}

cleanup:
	// Clean up
	if (hFile!= INVALID_HANDLE_VALUE)
	{
		CloseHandle (hFile);
		hFile = INVALID_HANDLE_VALUE;
	}

	if (hSession)
	{
		InternetCloseHandle(hSession);
		hSession = INVALID_HANDLE_VALUE;
	}
	
	if (hConnect)
	{
		InternetCloseHandle(hConnect);
		hConnect = INVALID_HANDLE_VALUE;
	}


	if (hRequest)
	{
		InternetCloseHandle(hRequest);
		hRequest = INVALID_HANDLE_VALUE;
	}
	
	if (pBuffer)
	{
		free (pBuffer);
		pBuffer = NULL;
	}

	if (wszGuidRaw)
	{
		RpcStringFreeW(&wszGuidRaw);
		wszGuidRaw = NULL;
	}
	if (szGuidRaw)
	{
		free(szGuidRaw);
		szGuidRaw = NULL;
	}
	CoUninitialize();
	return ErrorCode;
	
}

DWORD GetResponseUrl(TCHAR * HostName, TCHAR *RemoteFileName,TCHAR *ResponseURL)
{


	TCHAR		IsapiUrl[255];
	TCHAR		*pUploadUrl			= NULL;
	TCHAR       *temp				= NULL;
	BOOL		bRet				= FALSE;
	DWORD		dwUrlLength			= 0;
	DWORD		ErrorCode			= 0;
	DWORD		dwLastError			= 0;
	TCHAR 		NewState;
	HINTERNET	hSession;
	HINTERNET	hRedirUrl;
	BOOL		bOnce				= FALSE;
	DWORD		dwBuffLen			= 0;
	DWORD		dwFlags				= 0;
	TCHAR       LocalUrl[255];
	ZeroMemory (IsapiUrl, sizeof IsapiUrl);
	ZeroMemory (LocalUrl, sizeof LocalUrl);	
	HINTERNET hUrlFile = NULL;


	
	StringCbPrintf (IsapiUrl,sizeof IsapiUrl,  _T("http://%s/isapi/oca_extension.dll?id=%s&Type=5"),HostName, RemoteFileName);
//	LogMessage(_T("Connecting to url: %s"),IsapiUrl);
	//StringCbPrintf (IsapiUrl,sizeof IsapiUrl,  _T("http://www.microsoft.com"));

	hSession = InternetOpen(_T("Isapi Stress"),
							 INTERNET_OPEN_TYPE_PRECONFIG,
                             NULL,
							 NULL,
							 0);
	if (hSession)
	{
		// Open the url we want to connect to.
		hUrlFile = InternetOpenUrl(hSession,
								   IsapiUrl, 
								   NULL,
								   0,
								   0,
								   0);

		// Read the page returned by the isapi dll.
		TCHAR buffer[255] ;
		ZeroMemory (buffer, sizeof buffer);
		DWORD dwBytesRead = 0;
		BOOL bRead = InternetReadFile(hUrlFile,
									  buffer,
									  sizeof(buffer),
									  &dwBytesRead);

		//buffer[sizeof (buffer) -1] = _T('\0');
		StringCbCopy (ResponseURL, sizeof buffer, buffer);
//		LogMessage(_T("Received URL: %s"), ResponseURL);
	}
	InternetCloseHandle(hUrlFile);
	InternetCloseHandle(hSession);

	return 0;
}



ULONG __stdcall ThreadFunc(void * args)
{
	SITESTATS Stats;
	HANDLE hEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, g_szPingEvent);
	time_t UploadStart;
	time_t UploadStop;
	time_t ProcessStart;
	time_t ProcessStop;
	TCHAR  ReturnedUrl[255];
	TCHAR  RemoteFileName[MAX_PATH];
	DWORD  ResponseCode = 0;
	int    ResponseCode1 = 0;
	ZeroMemory( &Stats, sizeof SITESTATS);
	int		iCode = 0;
	TCHAR  *pCode = NULL;
	DWORD  tempTime = 0;

	time(&appStart);
//	LogMessage(_T("Pinging Site: %s"), g_MonitorOptions.ServerName);
//	LogMessage(_T("----------------"));
	double  ElapsedTime;
	do
	{
		UploadStart = 0;
		UploadStop = 0;
		ProcessStart = 0;
		ProcessStop = 0;

		ZeroMemory(RemoteFileName, sizeof RemoteFileName);
		ZeroMemory(ReturnedUrl, sizeof ReturnedUrl);
		ZeroMemory(&Stats, sizeof SITESTATS);
	
		if (g_MonitorOptions.UploadSingle)
		{
			if (g_MonitorOptions.CollectUploadTime)
			{
				// Start upload timer
				time( &UploadStart);
				//	UploadSingle(g_MonitorOptions.ServerName, g_MonitorOptions.dwSiteID, g_MonitorOptions.FilePath,g_MonitorOptions.bUploadMethod);
				ResponseCode = Upload(g_MonitorOptions.FilePath,
									  g_MonitorOptions.VirtualDirectory,
									  g_MonitorOptions.ServerName ,
									  RemoteFileName);

		
				if (ResponseCode == 0)
					StringCbCopy(Stats.UploadStatus,sizeof Stats.UploadStatus, _T("Succeded"));
				else
					StringCbCopy(Stats.UploadStatus ,sizeof Stats.UploadStatus,_T("FAILED"));
				// End UploadTimer
				time( &UploadStop);
				
				//MessageBox(NULL,Stats.UploadStatus,NULL,MB_OK);
				
				

			}
			else
			{
				
			//	UploadSingle(g_MonitorOptions.ServerName, g_MonitorOptions.dwSiteID, g_MonitorOptions.FilePath,g_MonitorOptions.bUploadMethod);
			
			}
			

		}
		else
		{
			// find first file loop
			

		}

		if ((g_MonitorOptions.CollectProcessTime) && (ResponseCode == 0))
		{
			time ( &ProcessStart);
			ResponseCode1 = GetResponseUrl(g_MonitorOptions.ServerName,
										   RemoteFileName,
										   ReturnedUrl);
			if (ResponseCode1 == 0)
			{
				StringCbCopy(Stats.ProcessStatus ,sizeof Stats.ProcessStatus,     _T("Succeded"));
			}
			else
			{
				StringCbCopy(Stats.ProcessStatus ,sizeof Stats.ProcessStatus,     _T("FAILED"));
			}
		
		//	GetReturnUrl();
			time ( &ProcessStop);

			
			// end process timer
		}
		else
		{
			//GetReturnUrl();
		}
	
		// Fill in the stats structure
		
		ElapsedTime = difftime(UploadStop,UploadStart) ;
		StringCbPrintf(Stats.UploadTime,  sizeof Stats.UploadTime, _T("%6.2f\0"),ElapsedTime);

		++TotalFilesProcessed;
		if (ResponseCode == 0)
		{
			TotalUploadTime += ElapsedTime;
			AvgUploadTime = TotalUploadTime / (TotalFilesProcessed - TotalUploadFailures) ;

			ElapsedTime = difftime(ProcessStop,ProcessStart) ;
			TotalProcessTime += ElapsedTime;
			AvgProcessTime = TotalProcessTime / (TotalFilesProcessed - TotalUploadFailures) ;
			
			StringCbPrintf(Stats.AvgProcessTime, sizeof AvgProcessTime, _T("%2.2f"), AvgProcessTime);
			StringCbPrintf(Stats.ProcessingTime,sizeof Stats.ProcessingTime, _T( "%6.2f\0"),ElapsedTime);
			StringCbCopy(Stats.ReturnedUrl, sizeof Stats.ReturnedUrl, ReturnedUrl);
			StringCbPrintf(Stats.AvgUploadTime, sizeof AvgUploadTime, _T("%2.2f"), AvgUploadTime);
			// Update the List View Control
		}
		else
		{
			++TotalUploadFailures;
			goto Done;
		}

		pCode = _tcsstr( ReturnedUrl,_T("Code="));
		if (pCode)
		{
			
			pCode += 5; // skip past the = sign
			
			iCode = _ttoi(pCode);


			switch (iCode)
			{
			case MESSAGE_RECEIVE_TIMEOUT:
				if (StringCbCopy(Stats.ErrorString, sizeof Stats.ErrorString,_T("Timed out waiting for Kd response")) == S_OK)
				{
					++TotalTimeouts;
					StringCbCopy(Stats.ProcessStatus ,sizeof Stats.ProcessStatus,     _T("FAILED"));
					
				}
				break;
			case FAILED_TO_SEND_MESSAGE:
				if (StringCbCopy(Stats.ErrorString, sizeof Stats.ErrorString,_T("Failed to send MQ message to the queue")) == S_OK)
				{
					StringCbCopy(Stats.ProcessStatus ,sizeof Stats.ProcessStatus,     _T("FAILED"));
					++TotalUnknownErrors;
				}
				break;
			case FAILED_CONNECT_SEND:
				if (StringCbCopy(Stats.ErrorString, sizeof Stats.ErrorString,_T("Failed to connect to the outgoing queue")) == S_OK)
				{
					StringCbCopy(Stats.ProcessStatus ,sizeof Stats.ProcessStatus,     _T("FAILED"));
					++TotalUnknownErrors;
				}
				break;
			case FAILED_CONNECT_RECEIVE:
				if (StringCbCopy(Stats.ErrorString, sizeof Stats.ErrorString,_T("Failed to connect to the Incomming message queue")) == S_OK)
				{
					StringCbCopy(Stats.ProcessStatus ,sizeof Stats.ProcessStatus,     _T("FAILED"));
					++TotalUnknownErrors;
				}
				break;
			case FILE_NOT_FOUND:
				if (StringCbCopy(Stats.ErrorString, sizeof Stats.ErrorString,_T("File Not Found. Either the upload failed or the watson server could not be reached.")) == S_OK)
				{
					StringCbCopy(Stats.ProcessStatus ,sizeof Stats.ProcessStatus,     _T("FAILED"));
					++TotalUnknownErrors;
				}
				break;
			case EXCEEDED_MAX_THREAD_COUNT:
				if (StringCbCopy(Stats.ErrorString, sizeof Stats.ErrorString,_T("EXCEEDED THE MAX THREAD COUNT")) == S_OK)
				{
					StringCbCopy(Stats.ProcessStatus ,sizeof Stats.ProcessStatus,     _T("FAILED"));
					++TotalFilesProcessed;
				}
				break;
			case FAILED_TO_IMPERSONATE_USER:
				if (StringCbCopy(Stats.ErrorString, sizeof Stats.ErrorString,_T("Failed to impersonate the Anonymous user account")) == S_OK)
				{
					StringCbCopy(Stats.ProcessStatus ,sizeof Stats.ProcessStatus,     _T("FAILED"));
					++TotalUnknownErrors;
				}
				break;
			case FAILED_TO_PARSE_QUERYSTRING:
				if (StringCbCopy(Stats.ErrorString, sizeof Stats.ErrorString,_T("Failed to parse the query string")) == S_OK)
				{
					StringCbCopy(Stats.ProcessStatus ,sizeof Stats.ProcessStatus,     _T("FAILED"));
					++TotalUnknownErrors;
				}
				break;
			case INVALID_TYPE_SPECIFIED:
				if (StringCbCopy(Stats.ErrorString, sizeof Stats.ErrorString,_T("An Invalid type was specified on the URL")) == S_OK)
				{
					StringCbCopy(Stats.ProcessStatus ,sizeof Stats.ProcessStatus,     _T("FAILED"));
					++TotalUnknownErrors;
				}
				break;
			case FAILED_TO_COPY_FILE:
				if (StringCbCopy(Stats.ErrorString, sizeof Stats.ErrorString,_T("Failed to copy the file from Watson server locally")) == S_OK)
				{
					StringCbCopy(Stats.ProcessStatus ,sizeof Stats.ProcessStatus,     _T("FAILED"));
					++TotalUnknownErrors;
				}
				break;
			case INTERNAL_ERROR:
				if (StringCbCopy(Stats.ErrorString, sizeof Stats.ErrorString,_T("INTERNAL ERROR!!!")) == S_OK)
				{
					StringCbCopy(Stats.ProcessStatus ,sizeof Stats.ProcessStatus,     _T("FAILED"));
					++TotalUnknownErrors;
				}
				break;
			case FAILED_RECONNECT_RECEIVE:
				if (StringCbCopy(Stats.ErrorString, sizeof Stats.ErrorString,_T("Failed to reconnect to the Receiving queue")) == S_OK)
				{
					StringCbCopy(Stats.ProcessStatus ,sizeof Stats.ProcessStatus,     _T("FAILED"));
					++TotalUnknownErrors;
				}
				break;
			case FAILED_TO_CREATE_CURSOR:
				if (StringCbCopy(Stats.ErrorString, sizeof Stats.ErrorString,_T("Failed to create Receive queue Cursor")) == S_OK)
				{
					StringCbCopy(Stats.ProcessStatus ,sizeof Stats.ProcessStatus,     _T("FAILED"));
					++TotalUnknownErrors;
				}
				break;
			case FAILED_TO_CREATE_GUID:
				if (StringCbCopy(Stats.ErrorString, sizeof Stats.ErrorString,_T("Failed to create a guid for the current message")) == S_OK)
				{
					StringCbCopy(Stats.ProcessStatus ,sizeof Stats.ProcessStatus,     _T("FAILED"));
					++TotalUnknownErrors;
				}
				break;
			default:
				++TotalUnknownErrors;
				break;
			}
		
		}
		else
		{
			if (!_tcscmp(ReturnedUrl,_T("\0")))
			{
				if (StringCbCopy(Stats.ErrorString, sizeof Stats.ErrorString,_T("The Web server did not return a URL. Possibly the server is unavailable or being restarted.")) == S_OK)
				{
					StringCbCopy(Stats.ProcessStatus ,sizeof Stats.ProcessStatus,     _T("FAILED"));
					++TotalUnknownErrors;
				}

			}

			if (_tcsstr( ReturnedUrl,_T("HTTP://")))
			{
				if (StringCbCopy(Stats.ErrorString, sizeof Stats.ErrorString,_T("The Web server redirected us to an incorrect page. Possibly the server is unavailable or being restarted.")) == S_OK)
				{
					StringCbCopy(Stats.ProcessStatus ,sizeof Stats.ProcessStatus,     _T("FAILED"));
					++TotalUnknownErrors;
				}
			}
		}
Done:
		// Get PerfCounters if available
		if (pCode = _tcsstr( ReturnedUrl, _T("PerfThread=")))
		{
			pCode += 11;
			tempTime = _ttol( pCode );
			StringCbPrintf(Stats.ThreadExecution, sizeof Stats.ThreadExecution, _T("%6.2f"), (double)tempTime /1000);
		}
		
		if (pCode = _tcsstr( ReturnedUrl, _T("PerfSendQueue=")))
		{
			pCode += 14;
			tempTime = _ttol( pCode );

			StringCbPrintf(Stats.SendQueueTime, sizeof Stats.SendQueueTime, _T("%6.2f"), (double)tempTime /1000);
		}
		
		if (pCode = _tcsstr( ReturnedUrl, _T("PerfRecvQueue=")))
		{
			pCode += 14;
			tempTime = _ttol( pCode );


			StringCbPrintf(Stats.ReceiveQueueTime, sizeof Stats.ReceiveQueueTime, _T("%6.2f"), (double)tempTime /1000);
		}

		UpdateListView(g_hWnd, &Stats);

		
		
	} while (WaitForSingleObject (hEvent, g_MonitorOptions.dwPingRate) != WAIT_OBJECT_0);
	CloseHandle (hEvent);
	g_bMonitoring = FALSE;
	ExitThread(0);
	return 0;
}

BOOL OnStartSitePing(HWND hwnd)
{
	DWORD ThreadId;
	HANDLE hThread;

	
	
	if (!g_bMonitoring)
	{
		g_hPingEvent = CreateEvent(NULL,FALSE, FALSE, g_szPingEvent);
		hThread = CreateThread(NULL, 0, &ThreadFunc,NULL,0,&ThreadId  );
		g_bMonitoring = TRUE;
		CloseHandle (hThread);
	}
	else
	{
		MessageBox(hwnd, _T("Site Ping is already running"), NULL, MB_OK);
	}
	return TRUE;
}

BOOL InitListView(HWND hwnd)
{
	HWND hListControl = GetDlgItem(hwnd, IDC_LIST1);
	TCHAR szText[][100] = { _T("Upload Time"),
							_T("Upload Status"),
							_T("Response Time"),
							_T("Process  Status"),
							_T("Thread Time"),
							_T("ReciveQ Time"),
							_T("SendQ Time"),
							_T("Returned Url"),
							_T("Error")};     // temporary buffer 

    LVCOLUMN lvc; 
    int iCol; 
 
	
	// Set the extended styles
	ListView_SetExtendedListViewStyleEx(hListControl,LVS_EX_GRIDLINES | LVS_EX_HEADERDRAGDROP | LVS_EX_FULLROWSELECT,LVS_EX_GRIDLINES | LVS_EX_FULLROWSELECT | LVS_EX_HEADERDRAGDROP);
    // Initialize the LVCOLUMN structure.
    // The mask specifies that the format, width, text, and subitem
    // members of the structure are valid. 
    lvc.mask = LVCF_FMT | LVCF_WIDTH | LVCF_TEXT | LVCF_SUBITEM; 
     
    // Add the columns. 
    for (iCol = 0; iCol < C_COLUMNS; iCol++) 
	{ 
        lvc.iSubItem = iCol;
        lvc.pszText = szText[iCol];	
        lvc.cx = 100;           // width of column in pixels
        lvc.fmt = LVCFMT_LEFT;  // left-aligned column
        if (ListView_InsertColumn(hListControl, iCol, &lvc) == -1) 
            return FALSE; 
    } 
	

    return TRUE; 

}



VOID WINAPI OnDialogInit(HWND hwndDlg) 
{
	InitListView(hwndDlg);
	GetRegData();
	HICON hIcon = LoadIcon(g_hinst, MAKEINTRESOURCE(IDR_MAINFRAME));
	SendMessage(hwndDlg, WM_SETICON, ICON_BIG, (LPARAM)hIcon);
	SendMessage(hwndDlg, WM_SETICON, ICON_SMALL, (LPARAM)hIcon);
    	// Fill Options structure with default values.
	ZeroMemory(&g_MonitorOptions, sizeof MONITOR_OPTIONS);
	g_MonitorOptions.bUploadMethod = TRUE;
	g_MonitorOptions.dwPingRate = 1000;
	g_MonitorOptions.CollectProcessTime = TRUE;
	g_MonitorOptions.CollectUploadTime = TRUE;
	g_MonitorOptions.UploadSingle = TRUE;
	StringCbCopy(g_MonitorOptions.ServerName,sizeof g_MonitorOptions.ServerName, _T("ocatest.msbpn.com"));
	g_MonitorOptions.iSeverIndex = 1;
	StringCbCopy(g_MonitorOptions.VirtualDirectory, sizeof g_MonitorOptions.VirtualDirectory, _T("OCA"));
	
	StringCbCopy(LogFileName,sizeof LogFileName, _T("c:\\SiteMon.csv"));
}

void OnOptionsOk(HWND hwnd)
{
	HANDLE hControl = NULL;
	TCHAR  szDlgText[255];
	TCHAR  szServer[MAX_PATH];
	TCHAR  *temp;
	TCHAR szTempDelay[30];
	ZeroMemory (szDlgText, sizeof szDlgText);
	// Get the option settings from the dialog and store them in the global options Structure.
	//GetDlgItem(hwnd, IDC_EDIT1);
	GetDlgItemText(hwnd, IDC_EDIT1, szDlgText, (sizeof szDlgText) / sizeof szDlgText[0]);
	StringCbCopy ( g_MonitorOptions.LogFileName, sizeof g_MonitorOptions.LogFileName, szDlgText);

	if (IsDlgButtonChecked(hwnd, IDC_RADIO1))
	{
		g_MonitorOptions.bUploadMethod = TRUE;
	}
	else 
	{
		if (IsDlgButtonChecked(hwnd, IDC_RADIO2))
			g_MonitorOptions.bUploadMethod = FALSE;
		
	}

	if (IsDlgButtonChecked (hwnd, IDC_RADIO3))
	{
		GetDlgItemText(hwnd, IDC_EDIT5,g_MonitorOptions.FilePath, MAX_PATH  );
		g_MonitorOptions.UploadSingle = TRUE;

	}
	else
	{
		GetDlgItemText(hwnd, IDC_EDIT5,g_MonitorOptions.Directory, MAX_PATH  );
		g_MonitorOptions.UploadSingle = FALSE;
	}

	GetDlgItemText(hwnd, IDC_EDIT6, szTempDelay, 30);
	g_MonitorOptions.dwPingRate = atol (szTempDelay);

	if (g_MonitorOptions.dwPingRate <= 0)
	{
		g_MonitorOptions.dwPingRate = 1000;
	}

	g_MonitorOptions.iSeverIndex = ComboBox_GetCurSel(GetDlgItem(hwnd, IDC_COMBO1));
	GetDlgItemText(hwnd, IDC_COMBO1, szServer, MAX_PATH);
	temp = szServer+_tcslen(szServer);
	while (*temp != _T('-'))
	{
		--temp;
	}
	// skip the - 
	--temp;
	*temp = _T('\0');
	StringCbCopy(g_MonitorOptions.ServerName, sizeof g_MonitorOptions.ServerName, szServer);
	//	MessageBox(hwnd, szDlgText, "Value of Text Resource", MB_OK);
}


void On_OptionsInit(HWND hwnd)
{
	HWND hComboBox;

	// read app reg key for user specified settings.
	//GetRegData(	);
	
	CheckDlgButton(hwnd, IDC_RADIO1, TRUE);
	CheckDlgButton(hwnd, IDC_RADIO3, TRUE);
	CheckDlgButton(hwnd, IDC_CHECK2, TRUE);
	CheckDlgButton(hwnd, IDC_CHECK3, TRUE);

	// Populate the combo box
	hComboBox = GetDlgItem(hwnd, IDC_COMBO1);
	ComboBox_InsertString(hComboBox, 0, _T("oca.microsoft.com - 908"));
	ComboBox_InsertString(hComboBox, 1, _T("ocatest - 909"));
	ComboBox_InsertString(hComboBox, 2, _T("ocatest.msbpn.com - 910"));
	ComboBox_SetCurSel(hComboBox, g_MonitorOptions.iSeverIndex);
	SetDlgItemText(hwnd, IDC_EDIT6, _T("1000"));
	SetDlgItemText(hwnd, IDC_EDIT5 , g_MonitorOptions.FilePath);


}

void On_Browse(HWND hwnd)
{

	HWND hParent = hwnd;
//	char *WindowTitle;


	// determine the language and Load the resource strings. 
	TCHAR String1[] = _T("Cab Files (*.cab)");
	TCHAR String2[] = _T("All Files (*.*)");

	static TCHAR szFilterW[400];




//	LoadStringW(::_Module.GetModuleInstance(), IDS_STRING_ENU_DMPFILE, String1, 200);
//	LoadStringW(::_Module.GetModuleInstance(), IDS_STRING_ENU_ALLFILES, String2, 200);
	// Build the buffer;

	TCHAR Pattern1[] = _T("*.cab");
	TCHAR Pattern2[] = _T("*.*");
	TCHAR * src;
	TCHAR *dest;

	src = String1;
	dest = szFilterW;

	while (*src != _T('\0'))
	{
		*dest = *src;
		src ++;
		dest ++;
	}
	src = Pattern1;
	*dest = _T('\0');
	++dest;
	while (*src != _T('\0'))
	{
		*dest = *src;
		src ++;
		dest ++;
	}
	*dest = _T('\0');
	++dest;
	src = String2;
	while (*src != _T('\0'))
	{
		*dest = *src;
		src ++;
		dest ++;
	}
	src = Pattern2;
	*dest = _T('\0');
	++dest;
	while (*src != _T('\0'))
	{
		*dest = *src;
		src ++;
		dest ++;
	}
	*dest = _T('\0');
	++dest;
	*dest = _T('\0');

	BOOL Return = FALSE;


	TCHAR szFileNameW [MAX_PATH] = _T("\0");
	TCHAR szDefaultPathW[MAX_PATH] = _T("\0");



	OPENFILENAME ofn;
	GetWindowsDirectory(szDefaultPathW,MAX_PATH);
	

	ofn.lStructSize = sizeof (OPENFILENAME);
	
	ofn.lpstrFilter =  szFilterW;
	ofn.lpstrInitialDir = szDefaultPathW;
	ofn.lpstrFile = szFileNameW;
	ofn.hInstance = NULL;
	ofn.hwndOwner = hParent;
	ofn.lCustData = NULL;
	ofn.Flags = 0;
	ofn.lpstrDefExt = _T("*.cab");
	ofn.lpstrCustomFilter = NULL;
	ofn.nMaxFile = MAX_PATH;
	ofn.lpstrFileTitle = NULL;
	ofn.lpstrTitle = NULL;
	ofn.nFileOffset = 0;
	ofn.nFileExtension = 0;
	ofn.lpfnHook = NULL;
	ofn.lpTemplateName = NULL;
	if (GetOpenFileName(&ofn))
	{
		SetDlgItemText(hwnd, IDC_EDIT5, ofn.lpstrFile);
	}



}


LRESULT CALLBACK OptionsDlgProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	switch (iMsg)
	{
	case WM_INITDIALOG:
		{
			On_OptionsInit(hwnd);


			return TRUE;
		}
	case WM_COMMAND:
		{
			switch (LOWORD(wParam))
			{
			case IDOK:
				OnOptionsOk(hwnd);
				EndDialog(hwnd, 0);
				// Save the current option settings
				return TRUE;
		
			case IDCANCEL:
				EndDialog(hwnd, 0);
				return TRUE;
			
			case ID_APPLY:
				OnOptionsOk(hwnd);
				// Save the current option settings
				return TRUE;
			case IDC_BROWSE:
				On_Browse(hwnd);
				return TRUE;
		
			}

			break;
		}

	case WM_NOTIFY:
	
		return DefDlgProc(hwnd, iMsg, wParam, lParam);
	}
	return 0;
}
void On_Options(HWND hwnd)
{
	DialogBox(g_hinst,MAKEINTRESOURCE(IDD_COLLECTION_OPTIONS)  ,hwnd, (DLGPROC) OptionsDlgProc);
	// Fill in the dialog items based on the current options.
	
	// For now set the default settings.
	


}

void On_DlgSize(HWND hwnd)
{
	RECT rcDlg;
	RECT rcList;

	GetClientRect(hwnd, &rcDlg);
	SetWindowPos(GetDlgItem(hwnd, IDC_LIST1), NULL, rcDlg.left, rcDlg.top, rcDlg.right- rcDlg.left, (rcDlg.bottom - rcDlg.top) /2, SWP_NOMOVE);
	GetWindowRect (GetDlgItem(hwnd, IDC_LIST1), &rcList);

	
	ScreenToClient(GetDlgItem(hwnd, IDC_LIST1), (LPPOINT)&rcList.left);
	ScreenToClient(GetDlgItem(hwnd, IDC_LIST1), (LPPOINT)&rcList.right);

//	SetWindowPos(GetDlgItem(hwnd, IDC_CUSTOM1), NULL, rcDlg.left, rcList.bottom + 5, rcDlg.right- rcDlg.left, 5,0);

//	SetWindowPos(GetDlgItem(hwnd, IDC_EDIT1), NULL, rcDlg.left, rcList.bottom + 15, rcDlg.right- rcDlg.left, rcDlg.bottom - rcList.bottom - 10, 0);


}
/*
void OnSliderMoved(HWND hwnd, RECT *rcList)
{
		GetWindowRect(GetDlgItem(hwnd, IDC_LIST), &r);
		size2 = r.right - r.left;
		GetWindowRect(GetDlgItem(hwnd, IDC_BUCKETS), &r);
		MapWindowPoints(NULL, hwnd, (POINT *)&r, 2);
		size1 = max(0, GET_Y_LPARAM(lParam) - r.top - cDragOffset);
		GetClientRect(hwnd, &r);
	//	AutoLayoutMain(hwnd, pidal, r.bottom - r.top, r.right - r.left, size1, size2);

		
}
*/

void ResetCounters(HWND hwnd)
{
	RunningTime			= 0.0;
	TotalFilesProcessed = 0;
	TotalUploadFailures = 0;
	TotalUnknownErrors	= 0;
	TotalTimeouts		= 0;
	appStart			= 0;
	appStop				= 0;
	TotalUploadTime     = 0.0;
	TotalProcessTime    = 0;

	// Clear the list view


	ListView_DeleteAllItems(GetDlgItem(hwnd, IDC_LIST1));

	g_CurrentIndex = -1;



}

LRESULT CALLBACK MainDlgProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
//	char TempString[255];
	static int cDragOffset;
	BOOL       fCapture = FALSE;
	switch (iMsg)
	{
		case WM_INITDIALOG:
			
			OnDialogInit(hwnd);
			return TRUE;
		case WM_CLOSE:
			if (g_hPingEvent)
			{
				CloseHandle(g_hPingEvent);
				g_hPingEvent = NULL;
			}

			PostQuitMessage(0);
			return TRUE;
/*		case WM_LBUTTONUP:
			if (fCapture)
			{
				RECT r;
				int size1, size2;
				
			//	On_SliderMoved( hwnd, r.bottom - r.top, r.right- r.left);
			
				ReleaseCapture();
				fCapture = FALSE;
			
				return TRUE;
			}
		break;
		*/
		case WM_COMMAND:
			{
				switch (LOWORD(wParam))
				{
				case ID_FILE_STARTSITEPING:
					OnStartSitePing(hwnd);
					return TRUE;
				
				case ID_FILE_STOPSITEPING:
					if (g_bMonitoring)
					{
						SetEvent(g_hPingEvent);
						Sleep(1000);
						if (g_hPingEvent)
						{
							CloseHandle(g_hPingEvent);
							g_hPingEvent= NULL;
						}
						g_bMonitoring = FALSE;
					}
					return TRUE;
				
				case ID_TOOLS_OPTIONS:
					On_Options(hwnd);
					return TRUE;

				case ID_TOOLS_LOGGING:
					On_ToolsLogging(hwnd);
					return TRUE;
				case ID_FILE_RESTARTPING:
					if (g_bMonitoring)
					{
						SetEvent(g_hPingEvent);
						if (g_hPingEvent)
						{
							CloseHandle(g_hPingEvent);
							g_hPingEvent = NULL;
							
						}
						g_bMonitoring = FALSE;
						ResetCounters(hwnd);
						if (hLogFile != INVALID_HANDLE_VALUE)
						{
							CloseHandle(hLogFile);
							LogStart = 0;
							hLogFile = INVALID_HANDLE_VALUE;
						}
						OnStartSitePing(hwnd);
					}
/*				case IDC_CUSTOM1:
					{
					RECT r;
					GetWindowRect(GetDlgItem(hwnd, IDC_LIST1), &r);
					cDragOffset = GET_Y_LPARAM(GetMessagePos()) - r.right;
					fCapture = TRUE;;
					SetCapture(hwnd);
					return 0;
					}
			*/
				}
			}
		case WM_SIZE:
		//	On_DlgSize(hwnd);
			return FALSE;
		case WM_NOTIFY:
			{
				switch(wParam)
					{
					case IDC_LIST1:
						switch(((NMHDR *)lParam)->code)
						{
						case LVN_ITEMCHANGED:
							
							return TRUE;

						case LVN_COLUMNCLICK:
							{
								
								return TRUE;
							}
						case LVN_GETDISPINFO:
							{
								return TRUE;
							}
							
						}
					}
				 break;
			}
		case WM_DESTROY:
			if (g_hPingEvent)
			{
				if (hLogFile != INVALID_HANDLE_VALUE)
				{
					CloseHandle(hLogFile);
					hLogFile = INVALID_HANDLE_VALUE;
				}
				CloseHandle(g_hPingEvent);
				g_hPingEvent= NULL;
			}
			break;
			
		
			 
	}
	return FALSE;

}


LRESULT CALLBACK MySliderProc(HWND hwnd, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
	switch(iMsg)
		{
	case WM_CREATE:
		return 0;

	case WM_PAINT:
		{
		PAINTSTRUCT ps;

		HDC hdc = BeginPaint(hwnd, &ps);

		HPEN hpenOld = (HPEN)SelectObject(hdc, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_ACTIVEBORDER)));
		MoveToEx(hdc, ps.rcPaint.left, 0, NULL);
		LineTo(hdc, ps.rcPaint.right,0);
		MoveToEx(hdc, ps.rcPaint.left, 2, NULL);
		LineTo(hdc, ps.rcPaint.right,2);
		MoveToEx(hdc, ps.rcPaint.left, 3, NULL);
		LineTo(hdc, ps.rcPaint.right,3);

		DeleteObject(SelectObject(hdc, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DHIGHLIGHT))));
		MoveToEx(hdc, ps.rcPaint.left, 1, NULL);
		LineTo(hdc, ps.rcPaint.right,1);

		DeleteObject(SelectObject(hdc, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DSHADOW))));
		SelectObject(hdc, GetSysColorBrush(COLOR_3DLIGHT));
		MoveToEx(hdc, ps.rcPaint.left, 4, NULL);
		LineTo(hdc, ps.rcPaint.right,4);

		DeleteObject(SelectObject(hdc, CreatePen(PS_SOLID, 1, GetSysColor(COLOR_3DDKSHADOW))));
		SelectObject(hdc, GetSysColorBrush(COLOR_3DLIGHT));
		MoveToEx(hdc, ps.rcPaint.left, 5, NULL);
		LineTo(hdc, ps.rcPaint.right,5);

		DeleteObject(SelectObject(hdc, hpenOld));
		EndPaint(hwnd, &ps);
		return 0;
		};

	case WM_LBUTTONDOWN:
		PostMessage(GetParent(hwnd), WM_COMMAND, GetWindowLong(hwnd, GWL_ID), (LPARAM)hwnd);
		return 0;				
		};
	return DefWindowProcW(hwnd, iMsg, wParam, lParam);
};


void InitWindowClasses()
{
	WNDCLASSEXW wc;

	wc.cbSize = sizeof(WNDCLASSEXW);
	wc.style = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc = MySliderProc;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	wc.hInstance = g_hinst;
	wc.hIcon = NULL;
	wc.hCursor = LoadCursor(NULL, IDC_SIZENS);
	wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE+1);
	wc.lpszMenuName = NULL;
	wc.lpszClassName = L"MySliderClass";
	wc.hIconSm = NULL;

	RegisterClassExW(&wc);

}



int WINAPI WinMain(HINSTANCE hinst, HINSTANCE hinstPrev, LPSTR szCmdLine,
						 int nShowCmd)
{
	MSG msg;
	HWND hwnd;
	INITCOMMONCONTROLSEX InitCtrls;
	InitializeCriticalSection(&ReportResults);

	InitCommonControlsEx(&InitCtrls);
	InitWindowClasses();
	g_hinst = hinst;

	LoadIcon(hinst, MAKEINTRESOURCE(IDR_MAINFRAME));
	hwnd = CreateDialog(g_hinst, MAKEINTRESOURCE(IDD_MAIN) ,NULL, 
						 (DLGPROC)MainDlgProc);
	g_hWnd = hwnd;
	if (hwnd)
	{
		while(GetMessageW(&msg, NULL, 0, 0))
			//if (!TranslateAcceleratorW(hwnd, hAccel, &msg))
				if (!IsDialogMessageW(hwnd, &msg))
				{
					TranslateMessage(&msg);
					DispatchMessageW(&msg);
				}
	}

	return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\xmlreports\foot.inc ===
<TABLE WIDTH="100%" CELLPADDING="5" CELLSPACING="0" BORDER="0" BGCOLOR="#FFFFFF" VALIGN="bottom">
<TR VALIGN="MIDDLE" align="left">
<TD COLSPAN="2" HEIGHT="30" WIDTH="100%" BGCOLOR="#6487DC" valign="bottom">
<FONT COLOR="#FFFFFF" FACE="Verdana, Arial, Helvetica"SIZE="1">
<NOBR>
&nbsp;&#169; 2001 Microsoft Corporation. All rights reserved.
<A STYLE="color:#FFFFFF;"HREF="http://www.microsoft.com/isapi/gomscom.asp?target=/info/cpyright.htm">Terms of use</A>&nbsp;<FONT COLOR="#FFFFFF">|</FONT>
<A STYLE="color:#FFFFFF;"HREF="http://www.microsoft.com/isapi/gomscom.asp?target=/info/privacy.htm">Privacy Statement</A>&nbsp;<FONT COLOR="#FFFFFF">|</FONT>
<A STYLE="color:#FFFFFF;"HREF="http://www.microsoft.com/enable/default.htm">Accessibility</A>
</NOBR>
</FONT>
</TD>
</TR>
</TABLE>

</BODY>
</HTML>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\sitemonitor\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by OcaSiteMonitor.rc
//
#define IDD_MAIN                        101
#define IDR_MENU1                       102
#define ID_FILE_NEW103                  103
#define ID_NEW_LOGFILE                  104
#define ID_FILE_SAVE105                 105
#define ID_FILE_EXIT                    106
#define ID_FILE_OPEN107                 107
#define ID_VIEW_CURRENTACTIVITY         108
#define ID_Menu                         109
#define ID_FILE_STARTSITEPING           110
#define ID_FILE_STOPSITEPING            111
#define ID_TOOLS_OPTIONS                112
#define IDD_DIALOG2                     113
#define IDD_COLLECTION_OPTIONS          113
#define IDD_DIALOG1                     118
#define IDD_LOGGING                     118
#define IDD_DIALOG3                     119
#define IDD_ESCELATION                  119
#define IDR_MAINFRAME                   120
#define IDC_EDIT1                       1001
#define IDC_LIST1                       1002
#define IDC_EDIT2                       1003
#define IDC_CHECK1                      1004
#define IDC_EDIT4                       1004
#define ID_APPLY                        1005
#define IDC_CHECK2                      1006
#define IDC_CHECK3                      1007
#define IDC_CHECK4                      1008
#define IDC_CHECK5                      1009
#define IDC_RADIO1                      1011
#define IDC_RADIO2                      1012
#define IDC_RADIO3                      1014
#define IDC_RADIO4                      1016
#define IDC_EDIT5                       1017
#define IDC_COMBO1                      1020
#define IDC_BROWSE                      1021
#define IDC_EDIT6                       1022
#define IDC_EDIT3                       1027
#define IDC_BUTTON1                     1028
#define IDC_BUTTON2                     1029
#define IDC_LOGBROWSE                   1029
#define IDC_COMBO2                      1030
#define IDC_COMBO3                      1031
#define IDC_COMBO4                      1032
#define IDC_COMBO5                      1033
#define IDC_COMBO6                      1034
#define IDC_EDIT7                       1035
#define IDC_EDIT8                       1036
#define IDC_EDIT9                       1037
#define IDC_EDIT10                      1038
#define ID_TOOLS_CONTACTOPTIONS         40001
#define ID_TOOLS_THRESHOLDOPTIONS       40002
#define ID_TOOLS_LOGGINGOPTIONS         40003
#define ID_TOOLS_LOGGING                40003
#define ID_EDIT_RESTARTCOUNTERS         40004
#define ID_FILE_RESTARTPING             40005

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        121
#define _APS_NEXT_COMMAND_VALUE         40006
#define _APS_NEXT_CONTROL_VALUE         1039
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\stresssvc\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__985A2EB9_ECE0_4406_AB2C_1B7B05DCDA32__INCLUDED_)
#define AFX_STDAFX_H__985A2EB9_ECE0_4406_AB2C_1B7B05DCDA32__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

class CServiceModule : public CComModule
{
public:
    HRESULT RegisterServer(BOOL bRegTypeLib, BOOL bService);
    HRESULT UnregisterServer();
    void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid = NULL);
    void Start();
    void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    void Handler(DWORD dwOpcode);
    void Run();
    BOOL IsInstalled();
    BOOL Install();
    BOOL Uninstall();
    LONG Unlock();
    void LogEvent(LPCTSTR pszFormat, ...);
    void SetServiceStatus(DWORD dwState);
    void SetupAsLocalServer();
    BOOL GetRegData();

//Implementation
private:
    static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static void WINAPI _Handler(DWORD dwOpcode);

// data members
public:
    TCHAR m_szServiceName[256];
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
    DWORD dwThreadID;
    BOOL m_bService;

private:

    void RenameCabFile(TCHAR * tFileName);
    void SearchRootDirectory(void);
    int SearchDirectory(TCHAR * tzDirectory);
    BOOL GetResponseURL(wchar_t *RemoteFileName);
};

BOOL
RenameFile(TCHAR *CurrentPath,
           TCHAR *CurrentName,
           TCHAR *NewName);

#define s_cszStopEvent   _T("StressSvc_Event")
extern CServiceModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__985A2EB9_ECE0_4406_AB2C_1B7B05DCDA32__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\stresssvc\stresssvc.cpp ===
// StressSvc.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f StressSvcps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "StressSvc.h"
#include "StressSvc_i.c"
#include <stdio.h>
#include <windows.h>
#include <wtypes.h>
#include <malloc.h>
#include <wininet.h>
#include <strsafe.h>
#include <io.h>
#include <fcntl.h>
#include <cmnutil.hpp>

//Globals
TCHAR tszHostName[MAX_PATH];
TCHAR tszRootDirectory[MAX_PATH];
HANDLE  g_hStopEvent = NULL;
HANDLE  g_hStopEvent1 = NULL;

CServiceModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

// Although some of these functions are big they are declared inline since they are only used once

inline HRESULT CServiceModule::RegisterServer(BOOL bRegTypeLib, BOOL bService)
{
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Remove any previous service since it may point to
    // the incorrect file
   // Uninstall();

    // Add service entries
    UpdateRegistryFromResource(IDR_StressSvc, TRUE);

    // Adjust the AppID for Local Server or Service
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_WRITE);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    CRegKey key;
    lRes = key.Open(keyAppID, _T("{AC57FB6A-13ED-443D-9A9F-D34966576A62}"), KEY_WRITE);
    if (lRes != ERROR_SUCCESS)
        return lRes;
    key.DeleteValue(_T("LocalService"));

    if (bService)
    {
        key.SetValue(_T("StressSvc"), _T("LocalService"));
        key.SetValue(_T("-Service"), _T("ServiceParameters"));
        // Create service
        Install();
    }

    // Add object entries
    hr = CComModule::RegisterServer(bRegTypeLib);

    CoUninitialize();
    return hr;
}

inline HRESULT CServiceModule::UnregisterServer()
{
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Remove service entries
    UpdateRegistryFromResource(IDR_StressSvc, FALSE);
    // Remove service
    Uninstall();
    // Remove object entries
    CComModule::UnregisterServer(TRUE);
    CoUninitialize();
    return S_OK;
}

inline void CServiceModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid)
{
    CComModule::Init(p, h, plibid);

    m_bService = TRUE;

    LoadString(h, nServiceNameID, m_szServiceName, sizeof(m_szServiceName) / sizeof(TCHAR));

    // set up the initial service status
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    g_hStopEvent = CreateEvent(NULL, FALSE, FALSE, s_cszStopEvent);
    if(NULL == g_hStopEvent)
    {
        LogEvent( _T("Failed to create stop event: %s; hr=%ld"),
            s_cszStopEvent,
            GetLastError());
    }
}

LONG CServiceModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0 && !m_bService)
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
    return l;
}

BOOL CServiceModule::IsInstalled()
{
    BOOL bResult = FALSE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM != NULL)
    {
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
        if (hService != NULL)
        {
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }
        ::CloseServiceHandle(hSCM);
    }
    return bResult;
}

inline BOOL CServiceModule::Install()
{
    if (IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
    {
        MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
    }

    // Get the executable file path
    TCHAR szFilePath[_MAX_PATH];
    ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);

    SC_HANDLE hService = ::CreateService(
        hSCM, m_szServiceName, m_szServiceName,
        SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
        SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL,
        szFilePath, NULL, NULL, _T("RPCSS\0"), NULL, NULL);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, _T("Couldn't create service"), m_szServiceName, MB_OK);
        return FALSE;
    }

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);
    return TRUE;
}

inline BOOL CServiceModule::Uninstall()
{
    if (!IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM == NULL)
    {
        MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
    }

    SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_STOP | DELETE);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, _T("Couldn't open service"), m_szServiceName, MB_OK);
        return FALSE;
    }
    SERVICE_STATUS status;
    ::ControlService(hService, SERVICE_CONTROL_STOP, &status);

    BOOL bDelete = ::DeleteService(hService);
    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);

    if (bDelete)
        return TRUE;

    MessageBox(NULL, _T("Service could not be deleted"), m_szServiceName, MB_OK);
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////////////
// Logging functions
void CServiceModule::LogEvent(LPCTSTR pFormat, ...)
{
    TCHAR    chMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[1];
    va_list pArg;

    va_start(pArg, pFormat);
    if (StringCbVPrintf(chMsg,sizeof chMsg, pFormat, pArg) != S_OK)
    {
        return;
    }
    va_end(pArg);

    lpszStrings[0] = chMsg;

    if (m_bService)
    {
        /* Get a handle to use with ReportEvent(). */
        hEventSource = RegisterEventSource(NULL, m_szServiceName);
        if (hEventSource != NULL)
        {
            /* Write to event log. */
            ReportEvent(hEventSource, EVENTLOG_INFORMATION_TYPE, 0, 0, NULL, 1, 0, (LPCTSTR*) &lpszStrings[0], NULL);
            DeregisterEventSource(hEventSource);
        }
    }
    else
    {
        // As we are not running as a service, just write the error to the console.
        _putts(chMsg);
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Service startup and registration
inline void CServiceModule::Start()
{
    SERVICE_TABLE_ENTRY st[] =
    {
        { m_szServiceName, _ServiceMain },
        { NULL, NULL }
    };
    if (m_bService && !::StartServiceCtrlDispatcher(st))
    {
        m_bService = FALSE;
    }
    if (m_bService == FALSE)
        Run();
}

inline void CServiceModule::ServiceMain(DWORD /* dwArgc */, LPTSTR* /* lpszArgv */)
{
    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;
    m_hServiceStatus = RegisterServiceCtrlHandler(m_szServiceName, _Handler);
    if (m_hServiceStatus == NULL)
    {
        LogEvent(_T("Handler not installed"));
        return;
    }
    SetServiceStatus(SERVICE_START_PENDING);

    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    // When the Run function returns, the service has stopped.
    Run();

    SetServiceStatus(SERVICE_STOPPED);
    LogEvent(_T("Service stopped"));
}

inline void CServiceModule::Handler(DWORD dwOpcode)
{
    switch (dwOpcode)
    {
    case SERVICE_CONTROL_STOP:
        SetServiceStatus(SERVICE_STOP_PENDING);

        if(g_hStopEvent)
        {
            if( (FALSE == SetEvent( g_hStopEvent )) || (FALSE == SetEvent( g_hStopEvent1 )) )
            {
                LogEvent( _T("Unable to signal Stop Event; Error: %ld"), GetLastError());
            }

            CloseHandle( g_hStopEvent );
        }
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
        break;
    case SERVICE_CONTROL_PAUSE:
        break;
    case SERVICE_CONTROL_CONTINUE:
        break;
    case SERVICE_CONTROL_INTERROGATE:
        break;
    case SERVICE_CONTROL_SHUTDOWN:
        break;
    default:
        LogEvent(_T("Bad service request"));
    }
}

void WINAPI CServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}
void WINAPI CServiceModule::_Handler(DWORD dwOpcode)
{
    _Module.Handler(dwOpcode);
}

void CServiceModule::SetServiceStatus(DWORD dwState)
{
    m_status.dwCurrentState = dwState;
    ::SetServiceStatus(m_hServiceStatus, &m_status);
}

void CServiceModule::Run()
{
    _Module.dwThreadID = GetCurrentThreadId();

    HRESULT hr = CoInitialize(NULL);
//  If you are running on NT 4.0 or higher you can use the following call
//  instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
//  HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    _ASSERTE(SUCCEEDED(hr));

    // This provides a NULL DACL which will allow access to everyone.
    CSecurityDescriptor sd;
    sd.InitializeFromThreadToken();
    hr = CoInitializeSecurity(sd, -1, NULL, NULL,
        RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
    _ASSERTE(SUCCEEDED(hr));

    hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE);
    _ASSERTE(SUCCEEDED(hr));

    LogEvent(_T("Service started"));
    if (m_bService)
        SetServiceStatus(SERVICE_RUNNING);

    //-------------------------
    try
    {

        SearchRootDirectory();

    }
    catch(...)
    {
        LogEvent(_T("Stress Service Crashed!!!!!"));
    }
    //-------------------------
    MSG msg;
    while (GetMessage(&msg, 0, 0, 0))
        DispatchMessage(&msg);

    _Module.RevokeClassObjects();

    CoUninitialize();
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance,
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
    _Module.Init(ObjectMap, hInstance, IDS_SERVICENAME, &LIBID_STRESSSVCLib);
    _Module.m_bService = TRUE;

    TCHAR szTokens[] = _T("-/");

    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT),
                      NORM_IGNORECASE,
                      lpszToken,
                      -1,
                      _T("UnregServer"),
                      -1 ) == CSTR_EQUAL)

      ///if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
            return _Module.UnregisterServer();

        // Register as Local Server
        if (CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT),
                      NORM_IGNORECASE,
                      lpszToken,
                      -1,
                      _T("RegServer"),
                      -1 ) == CSTR_EQUAL)

        //if (lstrcmpi(lpszToken, _T("RegServer"))==0)
            return _Module.RegisterServer(TRUE, FALSE);

        // Register as Service
        if (CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT),
                      NORM_IGNORECASE,
                      lpszToken,
                      -1,
                      _T("Service"),
                      -1 ) == CSTR_EQUAL)

      //  if (lstrcmpi(lpszToken, _T("Service"))==0)
            return _Module.RegisterServer(TRUE, TRUE);

        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    // Are we Service or Local Server
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    CRegKey key;
    lRes = key.Open(keyAppID, _T("{AC57FB6A-13ED-443D-9A9F-D34966576A62}"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    TCHAR szValue[_MAX_PATH];
    DWORD dwLen = _MAX_PATH;
    lRes = key.QueryValue(szValue, _T("LocalService"), &dwLen);

    _Module.m_bService = FALSE;
    if (lRes == ERROR_SUCCESS)
        _Module.m_bService = TRUE;

    _Module.Start();

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}

BOOL
CServiceModule::GetRegData()
{
    HKEY  hHKLM;
    HKEY  hPrimaryKey = NULL;
    BOOL  Status = TRUE;
    BYTE  Buffer[MAX_PATH * sizeof TCHAR];
    DWORD BufferSize = 0;
    DWORD Type;

    if(!RegConnectRegistry(NULL, HKEY_LOCAL_MACHINE, &hHKLM))
    {

        if(!RegOpenKeyEx(hHKLM,_T("Software\\Microsoft\\StressSvc"), 0, KEY_ALL_ACCESS, &hPrimaryKey))
        {
            // Get the input queue directory path
            BufferSize = MAX_PATH * sizeof TCHAR;
            ZeroMemory(Buffer, MAX_PATH * sizeof TCHAR);
            if (RegQueryValueEx(hPrimaryKey,_T("HostName"), 0, &Type, Buffer, &BufferSize) != ERROR_SUCCESS)
            {
                LogEvent(_T("Failed to get HostName value from registry."));
                Status = FALSE;
            }
            else
            {
                if (StringCbCopy (tszHostName, sizeof tszHostName,(TCHAR *) Buffer)!= S_OK)
                {
                    LogEvent (_T("Failed to copy HostName reg value to tszHostName"));
                    Status = FALSE;
                }
            }
            BufferSize = MAX_PATH * sizeof TCHAR;
            ZeroMemory(Buffer, MAX_PATH * sizeof TCHAR);
            // Now get the Primary Queue connection string
            if (RegQueryValueEx(hPrimaryKey,_T("RootDirectory"), 0, &Type, Buffer, &BufferSize) != ERROR_SUCCESS)
            {
                LogEvent(_T("Failed to get PrimaryQueue value from registry."));
                Status = FALSE;
            }
            else
            {
                if (StringCbCopy(tszRootDirectory,sizeof tszRootDirectory, (TCHAR *) Buffer)!= S_OK)
                {
                    LogEvent (_T("Failed to copy RootDirectory reg value to tszRootDirectory"));
                    Status = FALSE;
                }
            }
            RegCloseKey(hPrimaryKey);
        }
        RegCloseKey(hHKLM);
    }
    return Status;
}

void
CServiceModule::SearchRootDirectory(void)
/*
    Function: SearchDirectory
    Purpose: Recursively search a series of directories to locate .cab files.
             When a .cab file is found calles GetResponseUrl to process the file.
    Parameters:
        in tszSearchDirectory - Directory in which to begin serarching for cab files.
    Returns:
        NONE

*/
{
    HANDLE           hFindFile  = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA  FindData;
    TCHAR            tszSearchDir[MAX_PATH];
    TCHAR            tszSubDir[MAX_PATH];
    TCHAR            *temp      = NULL;
    int              iRetCode   = 0;
 //   HANDLE           hStopEvent = NULL;
    DWORD            dwWaitResult = 0;
    TCHAR            tszCurrentFileName[MAX_PATH];

    if (!GetRegData())
    {
        LogEvent(_T("Failed to read ServiceParams."));
        goto Done;
    }
    g_hStopEvent1 = OpenEvent(EVENT_ALL_ACCESS, FALSE, s_cszStopEvent);
    if (g_hStopEvent1 == NULL)
    {
        LogEvent(_T("Failed to open stop event. Terminating"));
        goto Done;
    }

    while (1) // Start the infinit service loop
    {
        if (StringCbCopy (tszSearchDir, sizeof tszSearchDir, tszRootDirectory) == S_OK)
        {
            if (StringCbCat (tszSearchDir, sizeof tszSearchDir, _T("\\*.*")) == S_OK)
            {
                hFindFile = FindFirstFile(tszSearchDir, &FindData);
                if (hFindFile != INVALID_HANDLE_VALUE)
                {
                    do
                    {
                        dwWaitResult = WaitForSingleObject(g_hStopEvent1, 200);
                        switch (dwWaitResult)
                        {
                        case WAIT_OBJECT_0:
                                // we're stopping return immediately
                                goto Done;
                            break;
                        case WAIT_FAILED:
                            // we hit an error somewhere log the event and return
                                LogEvent (_T(" Failed wait in recursive search: ErrorCode: %d"), GetLastError());
                                goto Done;
                            break;
                        default:
                            break;
                        }

                        if (FindData.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY)
                        {
                            // Skip the . and .. directories all directories trigger a recursive call
                            if ( (_tcscmp (FindData.cFileName, _T("."))) && (_tcscmp (FindData.cFileName, _T(".."))) )
                            {
                                // We have a directory
                                if (StringCbPrintf(tszSubDir, sizeof tszSubDir, _T("%s\\%s"), tszRootDirectory, FindData.cFileName) == S_OK)
                                {
									//LogEvent(_T("Searching directory: %s"), tszSubDir);
                                    if (SearchDirectory(tszSubDir) == 1)
										goto Done;
                                }
                            }
                        }
                        else
                        {
                            // check to see if this file as a .cab extenstion
                            temp = FindData.cFileName + _tcslen(FindData.cFileName) -3;
                            if (!_tcscmp (temp, _T(".cab")))
                            {
                                // we have a cab. Now lets process it
                                if (StringCbPrintf(tszCurrentFileName, sizeof tszCurrentFileName, _T("%s\\%s"),tszRootDirectory, FindData.cFileName) == S_OK)
                                {
									//LogEvent(_T("Main() Processing file: %s"), tszCurrentFileName);
                                    if (GetResponseURL(tszCurrentFileName)) // This function returns TRUE on success
                                    {
                                        RenameCabFile(tszCurrentFileName);
                                    }
                                }
                            }
                        }
                    } while (FindNextFile(hFindFile, &FindData));
                    FindClose (hFindFile);
                }
            }
        }
    }
Done:
    // we can jump here from inside the find file loop so if the handle is not closed close it.
    if (hFindFile != INVALID_HANDLE_VALUE)
        FindClose(hFindFile);
    CloseHandle(g_hStopEvent1);
    // We are done return up the chain.
}


int
CServiceModule::SearchDirectory(TCHAR * tszDirectory)
/*
    Function: SearchDirectory
    Purpose: Recursively search a series of directories to locate .cab files.
             When a .cab file is found calles GetResponseUrl to process the file.
    Parameters:
        in tszSearchDirectory - Directory in which to begin serarching for cab files.
    Returns:
        NONE

*/
{
    // recursive function to search a directory for cab files.
    HANDLE hFindFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA  FindData;
    TCHAR tszSearchDir[MAX_PATH];
    TCHAR tszSubDir[MAX_PATH];
    TCHAR *temp = NULL;
    int   iRetCode = 0;
    HANDLE hStopEvent = NULL;
    TCHAR tszCurrentFileName[255];
    DWORD dwWaitResult = 0;
    int   Status = 0;

 /*   hStopEvent = OpenEvent(EVENT_ALL_ACCESS, FALSE, s_cszStopEvent);
    if (hStopEvent == NULL)
    {
        LogEvent(_T("Failed to open stop event. Terminating"));
        Status = 1;
        goto Done;
    }
	*/
    if (StringCbCopy (tszSearchDir, sizeof tszSearchDir, tszDirectory) == S_OK)
    {
        if (StringCbCat (tszSearchDir, sizeof tszSearchDir, _T("\\*.*")) == S_OK)
        {
			//LogEvent(_T("Current Search Path: %s"), tszSearchDir);
            hFindFile = FindFirstFile(tszSearchDir, &FindData);
            if (hFindFile != INVALID_HANDLE_VALUE)
            {
                do
                {
                    dwWaitResult = WaitForSingleObject(g_hStopEvent1, 200);
                    switch (dwWaitResult)
                    {
                    case WAIT_OBJECT_0:
                            // we're stopping return immediately
                            Status = 1; // Signal the rest of the functions up the chain to stop.

                            goto Done;
                        break;
                    case WAIT_FAILED:
                        // we hit an error somewhere log the event and return
                            LogEvent (_T(" Failed wait in recursive search: ErrorCode: %d"), GetLastError());
                            Status = 1; // We have an unrecoverable failure shut down
                            goto Done;
                        break;
                    default:
                        break;
                    }

                    if (FindData.dwFileAttributes == FILE_ATTRIBUTE_DIRECTORY)
                    {
                        // Skip the . and .. directories all directories trigger a recursive call
                        if ( (_tcscmp (FindData.cFileName, _T("."))) && (_tcscmp (FindData.cFileName, _T(".."))) )
                        {
                            // We have another directory
                            // recursively call this function with the new direcory name.
                            if (StringCbPrintf(tszSubDir, sizeof tszSubDir, _T("%s\\%s"), tszDirectory, FindData.cFileName) == S_OK)
                            {
								//LogEvent(_T("Recursively Searching subdir: %s"), tszSubDir);
                                if (SearchDirectory(tszSubDir) == 1)
                                {
                                    goto Done;
                                }
                            }
                        }
                    }
                    else
                    {
                        // check to see if this file as a .cab extenstion
					
                        temp = FindData.cFileName + _tcslen(FindData.cFileName) -3;
						//LogEvent(_T("Checking Extension on file: %s extension is: %s"), FindData.cFileName,temp);
                        if (!_tcscmp (temp, _T("cab")))
                        {
                            // we have a cab. Now lets process it
                            if (StringCbPrintf(tszCurrentFileName, sizeof tszCurrentFileName, _T("%s\\%s"),tszDirectory, FindData.cFileName) == S_OK)
                            {
								//LogEvent(_T("Calling renamefile for: %s"), FindData.cFileName);
                                RenameFile(tszDirectory, FindData.cFileName, tszCurrentFileName);
								//LogEvent(_T("NewFileName is: %s"),tszCurrentFileName);
                                if (GetResponseURL(tszCurrentFileName)) // This function returns TRUE on success
                                {
                                    RenameCabFile(tszCurrentFileName);
                                }
                            }
                        }
                    }
                } while (FindNextFile(hFindFile, &FindData));
                FindClose(hFindFile);
            }
        }
    }
Done:
    // we can jump here from inside the find file loop so if the handle is not closed close it.
    if (hFindFile != INVALID_HANDLE_VALUE)
        FindClose(hFindFile);
   // CloseHandle(hStopEvent);
    return Status;
    // We are done return up the chain.
}

void
CServiceModule::RenameCabFile(TCHAR * tFileName)
/*
    Function: RenameCabFile
    Purpose: Rename a file from .cab to .old
    Parameters:
        in tFileName - Name of file to rename to .old
    Returns:
        NONE

*/
{
    TCHAR tNewFileName[MAX_PATH];
    BOOL bSuccess = FALSE;
    int  iStatus = 0;

    // Verify incomming pointer
    if (!tFileName)
        return;
    ZeroMemory(tNewFileName, sizeof tNewFileName);
    if(_tcslen(tFileName) < MAX_PATH)
    {
        if (StringCbCopy(tNewFileName, sizeof tNewFileName,tFileName) == S_OK)
        {
            if (StringCbCat(tNewFileName,sizeof tNewFileName, _T(".old")) == S_OK)
            {
                bSuccess = CopyFile(tFileName, tNewFileName, true);
                if(bSuccess)
                {
                    bSuccess = DeleteFile(tFileName);
                    if (!bSuccess)
                        iStatus = -1;
                }
                else
                    bSuccess = -1;
            }
            else
                bSuccess = -1;
        }
        else
            bSuccess = -1;
    }
    else
        bSuccess = -1;
    return;
}

BOOL
CServiceModule::GetResponseURL(TCHAR *RemoteFileName)
/*
    Function: GetResponseURL
    Purpose: Process the RemoteFileName file through the OCA System
    Parameters:
        in HostName - Name of IIS server hosting the OCA_Extension dll
        in RemoteFileName - Name of file to process.
    Returns:
        NONE

*/
{
    HINTERNET hRedirUrl = NULL;
    HINTERNET hSession  = NULL;
    TCHAR     IsapiUrl[512];

    if (StringCbPrintfW(IsapiUrl, sizeof IsapiUrl, L"http://%s/isapi/oca_extension.dll?id=%s&Type=6",tszHostName, RemoteFileName) != S_OK)
    {
        return FALSE;
    }
    hSession = InternetOpenW(L"Stresssvc_Control", INTERNET_OPEN_TYPE_PRECONFIG, NULL, NULL, 0);
    if (!hSession)
    {
        LogEvent(_T("Failed InternetOpenW"));
        return FALSE;
    }
    hRedirUrl = InternetOpenUrlW(hSession,
                                 IsapiUrl,
                                 NULL,
                                 0,
                                 INTERNET_FLAG_IGNORE_CERT_CN_INVALID|INTERNET_FLAG_IGNORE_CERT_DATE_INVALID,
                                 0);
    if(!hRedirUrl)
    {
        InternetCloseHandle(hSession);
        LogEvent(_T("Failed InternetOpenW"));
        return FALSE;
    }
    InternetCloseHandle(hRedirUrl);
    InternetCloseHandle(hSession);
    return TRUE;
}

BOOL
OpenRegFileFromCab(
    TCHAR *CabFile,
    HANDLE *FileHandle
    )
{
    CHAR RegFile[2 * MAX_PATH];
    TCHAR *tszRegFile = NULL;
    PSTR AnsiFile = NULL;
    INT_PTR CabFh;
    HRESULT Status;
    
#ifdef  UNICODE
    if ((Status = WideToAnsi(CabFile, &AnsiFile)) != S_OK)
    {
        return FALSE;
    }
#else
    AnsiFile = CabFile;
#endif   

    Status = ExpandDumpCab(AnsiFile,
                  _O_CREAT | _O_EXCL | _O_TEMPORARY,
                  "registry.txt",
                  RegFile, DIMA(RegFile),
                  &CabFh);
    if (Status != S_OK)
    {
        goto exitRegFileOpen;
    }

#ifdef  UNICODE
    if ((AnsiToWide(RegFile, &tszRegFile)) != S_OK)
    {
        goto exitRegFileOpen;
    }
#else
    tszRegFile = RegFile;
#endif   


    *FileHandle = CreateFile(tszRegFile, GENERIC_READ,
                             FILE_SHARE_READ | FILE_SHARE_WRITE |
                             FILE_SHARE_DELETE,
                             NULL,
                             OPEN_EXISTING,
                             FILE_ATTRIBUTE_NORMAL,
                             NULL);
    if (*FileHandle == NULL || *FileHandle == INVALID_HANDLE_VALUE)
    {
        Status = E_FAIL;
    }
    if (CabFh >= 0)
    {
        // no longer needed
        _close((int)CabFh);
    }

exitRegFileOpen:

#ifdef UNICODE
    if (AnsiFile)
    {
        FreeAnsi(AnsiFile);
    }
    if (tszRegFile)
    {
        FreeWide(tszRegFile);
    }
#endif
    return Status == S_OK;
}

BOOL
GetStressId(
    HANDLE hRegFile,
    PULONG StressId
    )
{
    const char cszStressIdTag[] = "StressID:(DWORD)";
    ULONG SizeLow, SizeHigh;

    SizeLow = GetFileSize(hRegFile, &SizeHigh);

    // Sanity check
    if (SizeHigh != 0 || SizeLow > 0x10000)
    {
        return FALSE;
    }

    PSTR szRegFile = (PSTR) malloc(SizeLow+1);
    ULONG BytesRead;
    
    if (!szRegFile)
    {
        return FALSE;
    }
    szRegFile[SizeLow] = 0;
    if (ReadFile(hRegFile, szRegFile, SizeLow, &BytesRead,
                 NULL) == FALSE)
    {
        free (szRegFile);
        return FALSE;
    }

    PSTR szId;
    if (szId = strstr(szRegFile, cszStressIdTag))
    {
        szId += DIMA(cszStressIdTag);
        
        free (szRegFile);
        return sscanf(szId, "%lx", StressId);
    }
    free (szRegFile);
    return FALSE;
}

// Rename cab based on stressid contained in the reg.txt file in the cab
BOOL
RenameFile(TCHAR *CurrentPath,
           TCHAR *CurrentName,
           TCHAR *NewName)
{
    BOOL Status = TRUE;
    HANDLE FileHandle;
    TCHAR CabFile[MAX_PATH];
    ULONG StressID;

    if (StringCbCopy(CabFile, sizeof(CabFile), CurrentPath) != S_OK ||
        StringCbCat(CabFile, sizeof(CabFile), _T("\\")) != S_OK ||
        StringCbCat(CabFile, sizeof(CabFile), CurrentName) != S_OK)
    {
        return FALSE;
    }


    // Rename cab based on stressid contained in the reg.txt file in the cab
    // Extract the reg.txt file.
    if (!OpenRegFileFromCab(CabFile, &FileHandle))
    {
        return FALSE;
    }

    // Get StressID(StressID)
    if ((Status = GetStressId(FileHandle, &StressID)) == FALSE)
    {
        return FALSE;
    }
    CloseHandle(FileHandle);

    // Build new file name
    TCHAR NewFileName[MAX_PATH];
    StringCbPrintf(NewFileName,sizeof (NewFileName),_T("%s\\%08lX_%s"), CurrentPath,StressID,CurrentName);

    if ((Status = CopyFile (CabFile, NewFileName, TRUE)) == TRUE)
    {
        Status = DeleteFile(CabFile);
    }

    StringCbCopy(NewName, 255 * sizeof TCHAR, NewFileName);

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\xmlreports\countbydate.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.SqlClient;

namespace XReports
{
	/// <summary>
	/// Summary description for countbydate.
	/// </summary>
	public class countbydate : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Calendar Calendar1;
		protected System.Web.UI.WebControls.Table tblUploads;
	
		private void Page_Load(object sender, System.EventArgs e)
		{
			SqlConnection cn = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TimRagain06");
			SqlCommand cm = new SqlCommand();
			SqlDataReader dr;
			DateTime dDate = DateTime.Now;
			int rowCtr=0;
			int cellCtr=0;
			int cellCnt = 4;
			double dbDays = -7;

			if(Page.IsPostBack == false)
			{
				cn.Open();
				cm.CommandType = CommandType.StoredProcedure;
				cm.CommandTimeout = 240;
				cm.CommandText = "spCountByDate";
				cm.Parameters.Add("@sDate", System.Data.SqlDbType.VarChar, 12);
				dDate = dDate.AddDays(dbDays);
				cm.Parameters[0].Value = dDate.ToShortDateString();
				cm.Connection = cn;
				dr = cm.ExecuteReader();
				//			dr.Read();
				Calendar1.SelectedDate = dDate;
				//for(rowCtr=0; rowCtr <= rowCnt; rowCtr++) 
				do
				{
					TableRow tRow = new TableRow();
					tblUploads.Rows.Add(tRow);

					for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
					{
						TableCell tCell = new TableCell();

						if(rowCtr == 0)
						{
							switch(cellCtr)
							{
								case 1 :
									tCell.Text = "Date Uploaded";
									break;
								case 2 :
									tCell.Text = "Total";
									break;
								case 3 :
									tCell.Text = "OS Name";
									break;
								case 4 :
									tCell.Text = "OS Version";
									break;
								default:
									tCell.Text = "";
									break;
							
							}
							tCell.Style["font-size"] = "small";

						}
						else
						{
							switch(cellCtr)
							{
								case 1 :
									
									if(dr.IsDBNull(0))
									{
										tCell.Text = "";
									}
									else
									{
										tCell.Text = dr.GetDateTime(0).ToShortDateString();
									}
									break;
								case 2 :
									tCell.Text = dr.GetInt32(1).ToString();
									break;
								case 3 :
									tCell.Text = dr.GetString(2);
									break;
								case 4 :
									tCell.Text = dr.GetString(3);
									break;
								default:
									tCell.Text = "0";
									break;
							
							}
							tCell.Style["background-color"] = "white";
							tCell.Style["font-size"] = "small-x";
							tCell.Style["color"] = "#6487dc";
							tCell.Style["font-weight"] = "Bold";
							
						}
						tCell.Style["font-family"] = "Tahoma";
						tRow.Cells.Add(tCell);
					}
					rowCtr++;
				}while(dr.Read() == true);
			}
		}
		

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Calendar1.VisibleMonthChanged += new System.Web.UI.WebControls.MonthChangedEventHandler(this.Calendar1_VisibleMonthChanged);
			this.Calendar1.SelectionChanged += new System.EventHandler(this.Calendar1_SelectionChanged);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		private void Calendar1_SelectionChanged(object sender, System.EventArgs e)
		{
			SqlConnection cn = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TimRagain06");
			SqlCommand cm = new SqlCommand();
			SqlDataReader dr;
			DateTime dDate = DateTime.Now;
			int rowCtr=0;
			int cellCtr=0;
			int cellCnt = 4;

			cn.Open();
			cm.CommandType = CommandType.StoredProcedure;
			cm.CommandTimeout = 240;
			cm.CommandText = "spCountByDate";
			cm.Parameters.Add("@sDate", System.Data.SqlDbType.VarChar, 12);
			dDate = Calendar1.SelectedDate;
			cm.Parameters[0].Value = dDate.ToShortDateString();
			cm.Connection = cn;
			dr = cm.ExecuteReader();
			//			dr.Read();
			Calendar1.SelectedDate = dDate;
			//for(rowCtr=0; rowCtr <= rowCnt; rowCtr++) 
			do
			{
				TableRow tRow = new TableRow();
				tblUploads.Rows.Add(tRow);

				for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
				{
					TableCell tCell = new TableCell();

					if(rowCtr == 0)
					{
						switch(cellCtr)
						{
							case 1 :
								tCell.Text = "Date Uploaded";
								break;
							case 2 :
								tCell.Text = "Total";
								break;
							case 3 :
								tCell.Text = "OS Name";
								break;
							case 4 :
								tCell.Text = "OS Version";
								break;
							default:
								tCell.Text = "";
								break;
						
						}
						tCell.Style["font-size"] = "small";

					}
					else
					{
						switch(cellCtr)
						{
							case 1 :
								
								if(dr.IsDBNull(0))
								{
									tCell.Text = "";
								}
								else
								{
									tCell.Text = dr.GetDateTime(0).ToShortDateString();
								}
								break;
							case 2 :
								tCell.Text = dr.GetInt32(1).ToString();
								break;
							case 3 :
								tCell.Text = dr.GetString(2);
								break;
							case 4 :
								tCell.Text = dr.GetString(3);
								break;
							default:
								tCell.Text = "0";
								break;
						
						}
						tCell.Style["background-color"] = "white";
						tCell.Style["font-size"] = "small-x";
						tCell.Style["color"] = "#6487dc";
						tCell.Style["font-weight"] = "Bold";
						
					}
					tCell.Style["font-family"] = "Tahoma";
					tRow.Cells.Add(tCell);
				}
				rowCtr++;
			}while(dr.Read() == true);
		}

		private void Calendar1_VisibleMonthChanged(object sender, System.Web.UI.WebControls.MonthChangedEventArgs e)
		{
			SqlConnection cn = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TimRagain06");
			SqlCommand cm = new SqlCommand();
			SqlDataReader dr;
			DateTime dDate = DateTime.Now;
			int rowCtr=0;
			int cellCtr=0;
			int cellCnt = 4;

			cn.Open();
			cm.CommandType = CommandType.StoredProcedure;
			cm.CommandTimeout = 240;
			cm.CommandText = "spCountByDate";
			cm.Parameters.Add("@sDate", System.Data.SqlDbType.VarChar, 12);
			dDate = Calendar1.SelectedDate;
			cm.Parameters[0].Value = dDate.ToShortDateString();
			cm.Connection = cn;
			dr = cm.ExecuteReader();
			//			dr.Read();
			Calendar1.SelectedDate = dDate;
			//for(rowCtr=0; rowCtr <= rowCnt; rowCtr++) 
			do
			{
				TableRow tRow = new TableRow();
				tblUploads.Rows.Add(tRow);

				for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
				{
					TableCell tCell = new TableCell();

					if(rowCtr == 0)
					{
						switch(cellCtr)
						{
							case 1 :
								tCell.Text = "Date Uploaded";
								break;
							case 2 :
								tCell.Text = "Total";
								break;
							case 3 :
								tCell.Text = "OS Name";
								break;
							case 4 :
								tCell.Text = "OS Version";
								break;
							default:
								tCell.Text = "";
								break;
						
						}
						tCell.Style["font-size"] = "small";

					}
					else
					{
						switch(cellCtr)
						{
							case 1 :
								
								if(dr.IsDBNull(0))
								{
									tCell.Text = "";
								}
								else
								{
									tCell.Text = dr.GetDateTime(0).ToShortDateString();
								}
								break;
							case 2 :
								tCell.Text = dr.GetInt32(1).ToString();
								break;
							case 3 :
								tCell.Text = dr.GetString(2);
								break;
							case 4 :
								tCell.Text = dr.GetString(3);
								break;
							default:
								tCell.Text = "0";
								break;
						
						}
						tCell.Style["background-color"] = "white";
						tCell.Style["font-size"] = "small-x";
						tCell.Style["color"] = "#6487dc";
						tCell.Style["font-weight"] = "Bold";
						
					}
					tCell.Style["font-family"] = "Tahoma";
					tRow.Cells.Add(tCell);
				}
				rowCtr++;
			}while(dr.Read() == true);
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\xmlreports\global.asax.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Web;
using System.Web.SessionState;

namespace XReports 
{
	/// <summary>
	/// Summary description for Global.
	/// </summary>
	public class Global : System.Web.HttpApplication
	{
		public Global()
		{
			InitializeComponent();
		}	
		
		protected void Application_Start(Object sender, EventArgs e)
		{

		}
 
		protected void Session_Start(Object sender, EventArgs e)
		{

		}

		protected void Application_BeginRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_EndRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_AuthenticateRequest(Object sender, EventArgs e)
		{

		}

		protected void Application_Error(Object sender, EventArgs e)
		{

		}

		protected void Session_End(Object sender, EventArgs e)
		{

		}

		protected void Application_End(Object sender, EventArgs e)
		{

		}
			
		#region Web Form Designer generated code
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocawreports\top.inc ===
<!--#include file="headerstrings.inc"-->
<script LANGUAGE="javascript">
<!--
	var headerinctitleworldhometooltip = "<% = L_HEADERINC_TITLE_WORLDHOME_TOOLTIP %>";
	var headerincimagealttooltip = "<% = L_HEADERINC_IMAGE_ALT_TOOLTIP %>";
	var headerincalinkmicrosoftmenuitem = "<% = L_HEADERINC_ALINK_MICROSOFT_MENUITEM %>";
	var headerincalinkhomemenuitem = "<% = L_HEADERINC_ALINK_HOME2_MENUITEM %>";
	var headerincalinkcermenuitem = "<% = L_HEADERINC_ALINK_CER_MENUITEM %>";
	var headerincalinkworldmenuitem = "<% = L_HEADERINC_ALINK_WORLD_MENUITEM %>";
	var headertitleocahometooltip = "<% = L_HEADERINC_TITLE_OCAHOME_TOOLTIP %>";
	var headerinctitlecerhometooltip = "<% = L_HEADERINC_TITLE_CERHOME_TOOLTIP %>";
	var headerimagesbannertext = "<% = L_HEADERINC_IMAGES_BANNER_TEXT%>";
	var headerisapihomemenuitem = "<% = L_HEADERINC_ISAPI_HOME_MENUITEM %>";
	var headerincmicrosofthomemenuitem = "<% = L_HEADERINC_MICROSOFT_HOME_MENUITEM %>";
	var heaerincallproductsmenuitem = "<% = L_HEADERINC_ALL_PRODUCTS_MENUITEM %>";
	var headerincallproductslinktext = "<% = L_HEADERINC_ALLPRODUCTS_LINK_TEXT %>";
	var headerincdownloadsdownloadsmenuitem = "<% = L_HEADERINC_DOWNLOADS_DOWNLOADS_MENUITEM %>";
	var headerincdownloadslinktext = "<% = L_HEADERINC_DOWNLOADS_LINK_TEXT %>";
	var headerincmsproductcatalogmenuitem = "<% = L_HEADERINC_MSPRODUCT_CATALOG_MENUITEM %>";
	var headerincmsproductcatalogtext = "<% = L_HEADERINC_MSPRODUCT_CATALOG_TEXT %>";
	var headerincmicrosoftaccessibilitymenuitem = "<% = L_HEADERINC_MICROSOFT_ACCESSIBILITY_MENUITEM %>";
	var headerincmicrosoftaccessibilitytext = "<% = L_HEADERINC_MICROSOFT_ACCESSIBILITY_TEXT %>";
	var headerincserverproductsmenuitem = "<% = L_HEADERINC_SERVER_PRODUCTS_MENUITEM %>";
	var headerincserverproductstext = "<% = L_HEADERINC_SERVER_PRODUCTS_TEXT %>";
	var headerincdevelopertoolsmenuitem = "<% = L_HEADERINC_DEVELOPER_TOOLS_MENUITEM %>";
	var headerincdevelopertoolstext = "<% = L_HEADERINC_DEVELOPER_TOOLS_TEXT %>";
	var headerincofficefamilymenuitem = "<% = L_HEADERINC_OFFICE_FAMILY_MENUITEM %>";
	var headerincofficefamilytext = "<% = L_HEADERINC_OFFICE_FAMILY_TEXT %>";
	var headerincwindowsfamilymenuitem = "<% = L_HEADERINC_WINDOWS_FAMILY_MENUITEM %>";
	var headerincwindowsfamilytext = "<% = L_HEADERINC_WINDOWS_FAMILY_TEXT %>";
	var headerincmsnlinkmenuitem = "<% = L_HEADERINC_MSN_LINK_MENUITEM %>";
	var headerincmsnlinktext = "<% = L_HEADERINC_MSN_LINK_TEXT %>";
	var headerincsupportlinkmenuitem = "<% = L_HEADERINC_SUPPORT_LINK_MENUITEM %>";
	var headerincsupportlinktext = "<% = L_HEADERINC_SUPPORT_LINK_TEXT %>";
	var headerincknowledgebasemenuitem = "<% = L_HEADERINC_KNOWLEDGE_BASE_MENUITEM %>";
	var headerincknowledgebasetext = "<% = L_HEADERINC_KNOWLEDGE_BASE_TEXT %>";
	var headerincproductsupportoptionsmenuitem = "<% = L_HEADERINC_PRODUCTSUPPORT_OPTIONS_MENUITEM %>";
	var headerincproductsupportoptionstext = "<% = L_HEADERINC_PRODUCTSUPPORT_OPTIONS_TEXT %>";
	var headerincservicepartnerreferralsmenuitem = "<% = L_HEADERINC_SERVICEPARTNER_REFERRALS_MENUITEM %>";
	var headerincservicepartnerreferralstext = "<% = L_HEADERINC_SERVICEPARTNER_REFERRALS_TEXT %>";
	var headerincsearchlinkmenuitem = "<% = L_HEADERINC_SEARCH_LINK_MENUITEM %>";
	var headerincsearchlinktext = "<% = L_HEADERINC_SEARCH_LINK_TEXT %>";
	var headerincsearchmicrosoftmenuitem = "<% = L_HEADERINC_SEARCH_MICROSOFT_MENUITEM %>";
	var headerincsearchmicrosofttext = "<% = L_HEADERINC_SEARCH_MICROSOFT_TEXT %>";
	var headerincmsnwebsearchmenuitem = "<% = L_HEADERINC_MSNWEB_SEARCH_MENUITEM %>";
	var headerincmsnwebsearchtext = "<% = L_HEADERINC_MSNWEB_SEARCH_TEXT %>";
	var headerincmicrosoftcomguidemenuitem = "<% = L_HEADERINC_MICROSOFTCOM_GUIDE_MENUITEM %>";
	var headerincmicrosoftcomguidetext = "<% = L_HEADERINC_MICROSOFTCOM_GUIDE_TEXT %>";
	var headerincmicrosoftcomhomemenuitem = "<% = L_HEADERINC_MICROSOFTCOM_HOME_MENUITEM %>";
	var headerincmicrosoftcomhometext = "<% = L_HEADERINC_MICROSOFTCOM_HOME_TEXT %>";
	var headerincmsnhomemenuitem = "<% = L_HEADERINC_MSN_HOME_MENUITEM %>";
	var headerincmsnhometext = "<% = L_HEADERINC_MSN_HOME_TEXT %>";
	var headerinccontactusmenuitem = "<% = L_HEADERINC_CONTACT_US_MENUITEM %>";
	var headerinccontactustext = "<% = L_HEADERINC_CONTACT_US_TEXT %>";
	var headerinceventslinkmenuitem = "<% = L_HEADERINC_EVENTS_LINK_MENUITEM %>";
	var headerinceventslinktext = "<% = L_HEADERINC_EVENTS_LINK_TEXT %>";
	var headerincnewsletterslinkmenuitem = "<% = L_HEADERINC_NEWSLETTERS_LINK_MENUITEM %>";
	var headerincnewsletterslinktext = "<% = L_HEADERINC_NEWSLETTERS_LINK_TEXT %>";
	var headerincprofilecentermenuitem = "<% = L_HEADERINC_PROFILE_CENTER_MENUITEM %>";
	var headerincprofilecentertext = "<% = L_HEADERINC_PROFILE_CENTER_TEXT %>";
	var headerinctrainingcertificationmenuitem = "<% = L_HEADERINC_TRAINING_CERTIFICATION_MENUITEM %>";
	var headerinctrainingcertificationtext = "<% = L_HEADERINC_TRAINING_CERTIFICATION_TEXT %>";
	var headerincfreemailaccountmenuitem = "<% = L_HEADERINC_FREEEMAIL_ACCOUNT_MENUITEM %>";
	var headerincfreemailaccounttext = "<% = L_HEADERINC_FREEEMAIL_ACCOUNT_TEXT %>";
	var headerincmicrosoftrightsreservedtext = "<% = L_HEADERINC_MICROSOFT_RIGHTSRESERVED_TEXT %>";
	var headerinctermsofusemenuitem = "<% = L_HEADERINC_TERMSOF_USE_MENUITEM %>";
	var headerinctermsofusetext = "<% = L_HEADERINC_TERMSOF_USE_TEXT %>";
	var headerincprivacystatementmenuitem = "<% = L_HEADERINC_PRIVACY_STATEMENT_MENUITEM %>";
	var headerincprivacystatementtext = "<% = L_HEADERINC_PRIVACY_STATEMENT_TEXT %>";
	var headerincaccessibilitylinkmenuitem = "<% = L_HEADERINC_ACCESSIBILITY_LINK_MENUITEM %>";
	var headerincaccessibilitylinktext = "<% = L_HEADERINC_ACCESSIBILITY_LINK_TEXT %>";
//-->
</script>

		<script language="JavaScript" src="toolbar.js"></script>
		<script language="JavaScript" src="globalMNP.js"></script>
		<script language="JavaScript" src="localMNP.js"></script>
		<script language="JavaScript">drawToolbar();</script>
		

								

		<script language="JavaScript">
		//spnTop.insertAdjacentHTML("beforeEnd", "<SPAN STYLE='font:" + cFont + ";color:" + cColor1 + "'>||&nbsp;</SPAN><Span style='position:absolute;top:0;right:5;height:20;width:100;'><center><span style='background-color:white'></span></center></span>");
		</script>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\xmlreports\home.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;

namespace XReports
{
	/// <summary>
	/// Summary description for home.
	/// </summary>
	public class home : System.Web.UI.Page
	{
		private void Page_Load(object sender, System.EventArgs e)
		{
			// Put user code to initialize the page here
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);
		}
		#endregion
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\xmlreports\language.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.SqlClient;


namespace XReports
{
	/// <summary>
	/// Summary description for language.
	/// </summary>
	public class language : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Table tblUploads;
		protected System.Web.UI.WebControls.DropDownList ddlLanguages;
		protected System.Web.UI.WebControls.Calendar Calendar1;
	
		private void Page_Load(object sender, System.EventArgs e)
		{
			if(Page.IsPostBack == false)
			{
				SqlConnection cn = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TimRagain06");
				SqlConnection cn2 = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TimRagain06");
				SqlCommand cm = new SqlCommand();
				SqlCommand cm2 = new SqlCommand();
				SqlDataReader dr;
				SqlDataReader dr2;
				int rowCtr=0;
				int cellCtr=0;
				int cellCnt = 5;
				int x = 0;
				double dbDays = -7;
				DateTime dDate = DateTime.Now;
				ArrayList strLanguages = new ArrayList();
				

				cn.Open();
				cm.CommandType = CommandType.StoredProcedure;
				cm.CommandTimeout = 240;
				cm.CommandText = "GetOSLanguage";
				cm.Parameters.Add("@sDate", System.Data.SqlDbType.VarChar, 12);
				dDate = dDate.AddDays(dbDays);
				cm.Parameters[0].Value = dDate.ToShortDateString();
				cm.Connection = cn;
				dr = cm.ExecuteReader();
				cn2.Open();
				cm2.CommandType = CommandType.StoredProcedure;
				cm2.CommandTimeout = 240;
				cm2.CommandText = "GetOSLanguageHeaders";
				cm2.Parameters.Add("@sDate", System.Data.SqlDbType.VarChar, 12);
				cm2.Parameters[0].Value = dDate.ToShortDateString();
				cm2.Connection = cn2;
				dr2 = cm2.ExecuteReader();
				ddlLanguages.DataSource = dr2;
				ddlLanguages.Items.Add("ALL");
				dr2.Read();
				do 
				{
					//					ddlLanguages.Items.Add(dr2.GetString(0));
					try
					{
						strLanguages.Add(GetLanguage(System.Convert.ToInt16(dr2.GetString(0), 10)));
					}
					catch
					{
						strLanguages.Add("Unknown" + dr2.GetString(0));
					}
				}while(dr2.Read() == true);	
				strLanguages.Sort();
				for(x = 0; x < strLanguages.Count; x++)
				{
//					ddlLanguages.Items.Add(dr2.GetString(0));
					try
					{
						
						ddlLanguages.Items.Add(strLanguages[x].ToString());
					}
					catch
					{
						ddlLanguages.Items.Add("Unknown" + strLanguages[x].ToString());
					}
				}
				
				Calendar1.SelectedDate = dDate;
				//				dr.Read();
				do
				{
					TableRow tRow = new TableRow();
					tblUploads.Rows.Add(tRow);

					for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
					{
						TableCell tCell = new TableCell();

						if(rowCtr == 0)
						{
							switch(cellCtr)
							{
								case 1: 
									tCell.Text = "OS Lang";
									break;
								case 2 :
									tCell.Text = "Total";
									break;
								case 3 :
									tCell.Text = "OS Version";
									break;
								case 4:
									tCell.Text = "OS Name";
									break;
								case 5:
									tCell.Text = "Date";
									break;
								default:
									tCell.Text = "";
									break;
							
							}
							tCell.Style["font-size"] = "small";
							tCell.Height = 20;

						}
						else
						{
							switch(cellCtr)
							{
								case 1 :
//									tCell.Text = dr.GetString(0).ToString();
									try
									{
										tCell.Text = GetLanguage(System.Convert.ToInt16(dr.GetString(0), 10));
									}
									catch
									{
										tCell.Text = "Unknown" + dr.GetString(0);
									}
									break;
								case 2 :
									tCell.Text = dr.GetInt32(1).ToString();
									break;
								case 3 :
									tCell.Text = dr.GetString(2).ToString();
									break;
								case 4 :
									tCell.Text = dr.GetString(3).ToString();
									break;
								case 5 :
									if(dr.IsDBNull(4))
									{
										tCell.Text = "";
									}
									else
									{
										tCell.Text = dr.GetDateTime(4).ToShortDateString();
									}
									break;

								default:
									tCell.Text = "0";
									break;
							
							}
							tCell.Style["background-color"] = "white";
							tCell.Style["font-size"] = "small-x";
							tCell.Style["color"] = "#6487dc";
							tCell.Style["font-weight"] = "Bold";
							tCell.Height = 20;
							
						}
						tCell.Style["font-family"] = "Tahoma";
						tRow.Cells.Add(tCell);
					}
					rowCtr++;
				}while(dr.Read() == true);	
			}
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Calendar1.VisibleMonthChanged += new System.Web.UI.WebControls.MonthChangedEventHandler(this.Calendar1_VisibleMonthChanged);
			this.Calendar1.SelectionChanged += new System.EventHandler(this.Calendar1_SelectionChanged);
			this.ddlLanguages.SelectedIndexChanged += new System.EventHandler(this.ddlLanguages_SelectedIndexChanged);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		private void Calendar1_SelectionChanged(object sender, System.EventArgs e)
		{
			SqlConnection cn = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TimRagain06");
			SqlCommand cm = new SqlCommand();
			SqlDataReader dr;
			DateTime dDate = DateTime.Now;
			int rowCtr=0;
			int cellCtr=0;
			int cellCnt = 5;
			int iLang = 0;
			string sLang;
			TableRow tRow;
			TableCell tCell;


			cn.Open();
			cm.CommandType = CommandType.StoredProcedure;
			cm.CommandTimeout = 240;
			cm.CommandText = "GetOSLanguage";
			cm.Parameters.Add("@sDate", System.Data.SqlDbType.VarChar, 12);
			dDate = Calendar1.SelectedDate;
			cm.Parameters[0].Value = dDate.ToShortDateString();
			cm.Connection = cn;
			dr = cm.ExecuteReader();
			//dr.Read();
			
			do
			{
				if(rowCtr > 0)
				{
					sLang = dr.GetString(0);
					if(sLang == "")
					{
						iLang = 0;
					}
					else
					{
						iLang = System.Convert.ToInt16(dr.GetString(0), 10);
					}
				}
				if(rowCtr == 0 || ddlLanguages.SelectedItem.Value == "ALL" || GetLanguage(iLang) == ddlLanguages.SelectedItem.Value)
				{
					tRow = new TableRow();
					//				}
					for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
					{
						
						tblUploads.Rows.Add(tRow);
						tCell = new TableCell();

						if(rowCtr == 0)
						{
							
							switch(cellCtr)
							{
								case 1: 
									tCell.Text = "OS Lang";
									break;
								case 2 :
									tCell.Text = "Total";
									break;
								case 3 :
									tCell.Text = "OS Version";
									break;
								case 4:
									tCell.Text = "OS Name";
									break;
								case 5:
									tCell.Text = "Date";
									break;
								default:
									tCell.Text = "";
									break;
							
							}
							tCell.Style["font-size"] = "small";
							tCell.Height = 20;

						}
						else
						{
							switch(cellCtr)
							{
								case 1 :
									//									tCell.Text = dr.GetString(0).ToString();
									try
									{
										tCell.Text = GetLanguage(System.Convert.ToInt16(dr.GetString(0), 10));
									}
									catch
									{
										tCell.Text = "Unknown" + dr.GetString(0);
									}
									break;
								case 2 :
									tCell.Text = dr.GetInt32(1).ToString();
									break;
								case 3 :
									tCell.Text = dr.GetString(2).ToString();
									break;
								case 4 :
									tCell.Text = dr.GetString(3).ToString();
									break;
								case 5 :
									if(dr.IsDBNull(4))
									{
										tCell.Text = "";
									}
									else
									{
										tCell.Text = dr.GetDateTime(4).ToShortDateString();
									}
									break;

								default:
									tCell.Text = "0";
									break;
							}
							tCell.Style["background-color"] = "white";
							tCell.Style["font-size"] = "small-x";
							tCell.Style["color"] = "#6487dc";
							tCell.Style["font-weight"] = "Bold";
							tCell.Height = 20;
							
						}
						tCell.Style["font-family"] = "Tahoma";
						tRow.Cells.Add(tCell);
					}//for
				}
				rowCtr++;
			}while(dr.Read() == true);		

		}

		private void Calendar1_VisibleMonthChanged(object sender, System.Web.UI.WebControls.MonthChangedEventArgs e)
		{
			SqlConnection cn = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TimRagain06");
			SqlCommand cm = new SqlCommand();
			SqlDataReader dr;
			DateTime dDate = DateTime.Now;
			int rowCtr=0;
			int cellCtr=0;
			int cellCnt = 5;
			int iLang = 0;
			string sLang;
			TableRow tRow;
			TableCell tCell;


			cn.Open();
			cm.CommandType = CommandType.StoredProcedure;
			cm.CommandTimeout = 240;
			cm.CommandText = "GetOSLanguage";
			cm.Parameters.Add("@sDate", System.Data.SqlDbType.VarChar, 12);
			dDate = Calendar1.SelectedDate;
			cm.Parameters[0].Value = dDate.ToShortDateString();
			cm.Connection = cn;
			dr = cm.ExecuteReader();
			//dr.Read();
			
			do
			{
				if(rowCtr > 0)
				{
					sLang = dr.GetString(0);
					if(sLang == "")
					{
						iLang = 0;
					}
					else
					{
						iLang = System.Convert.ToInt16(dr.GetString(0), 10);
					}
				}
				if(rowCtr == 0 || ddlLanguages.SelectedItem.Value == "ALL" || GetLanguage(iLang) == ddlLanguages.SelectedItem.Value)
				{
					tRow = new TableRow();
					//				}
					for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
					{
						
						tblUploads.Rows.Add(tRow);
						tCell = new TableCell();

						if(rowCtr == 0)
						{
							
							switch(cellCtr)
							{
								case 1: 
									tCell.Text = "OS Lang";
									break;
								case 2 :
									tCell.Text = "Total";
									break;
								case 3 :
									tCell.Text = "OS Version";
									break;
								case 4:
									tCell.Text = "OS Name";
									break;
								case 5:
									tCell.Text = "Date";
									break;
								default:
									tCell.Text = "";
									break;
							
							}
							tCell.Style["font-size"] = "small";
							tCell.Height = 20;

						}
						else
						{
							switch(cellCtr)
							{
								case 1 :
									//									tCell.Text = dr.GetString(0).ToString();
									try
									{
										tCell.Text = GetLanguage(System.Convert.ToInt16(dr.GetString(0), 10));
									}
									catch
									{
										tCell.Text = "Unknown" + dr.GetString(0);
									}
									break;
								case 2 :
									tCell.Text = dr.GetInt32(1).ToString();
									break;
								case 3 :
									tCell.Text = dr.GetString(2).ToString();
									break;
								case 4 :
									tCell.Text = dr.GetString(3).ToString();
									break;
								case 5 :
									if(dr.IsDBNull(4))
									{
										tCell.Text = "";
									}
									else
									{
										tCell.Text = dr.GetDateTime(4).ToShortDateString();
									}
									break;

								default:
									tCell.Text = "0";
									break;
							}
							tCell.Style["background-color"] = "white";
							tCell.Style["font-size"] = "small-x";
							tCell.Style["color"] = "#6487dc";
							tCell.Style["font-weight"] = "Bold";
							tCell.Height = 20;
							
						}
						tCell.Style["font-family"] = "Tahoma";
						tRow.Cells.Add(tCell);
					}//for
				}
				rowCtr++;
			}while(dr.Read() == true);		
		}
		private string GetLanguage(int iLang)
		{
			string strLang = "";

			switch(iLang)
			{
				case 0:
					strLang = "Unknown" + iLang.ToString();
					break;
				case 1078: 
	//				strLCID = 1078  ' Afrikaans 
					strLang = "Afrikaans";
					break;
				case 1052:
	//				strLCID = 1052  ' Albanian 
					strLang = "Albanian";
					break;
				case 1025:
	//				strLCID = 1025  ' Arabic(Saudi Arabia) 
					strLang = "Arabic(Saudi Arabia)";
					break;
				case 2049:
	//				strLCID = 2049  ' Arabic(Iraq) 
					strLang = "Arabic(Iraq)";
					break;
				case 3073 :
	//				strLCID = 3073  ' Arabic(Egypt) 
					strLang = "Arabic(Egypt)";
					break;
				case 4097:
	//				strLCID = 4097  ' Arabic(Libya)
					strLang = "Arabic(Libya)";
					break;
				case 5121:
	//				strLCID = 5121  ' Arabic(Algeria) 
					strLang = "Arabic(Algeria)";
					break;
				case 6145:
	//				strLCID = 6145  ' Arabic(Morocco) 
					strLang = "Arabic(Morocco)";
					break;
				case 7169:
	//				strLCID = 7169  ' Arabic(Tunisia) 
					strLang = "Arabic(Tunisia)";
					break;
				case 8193:
	//				strLCID = 8193  ' Arabic(Oman) 
					strLang = "Arabic(Oman)";
					break;
				case 9217:
	//				strLCID = 9217  ' Arabic(Yemen) 
					strLang = "Arabic(Yemen)";
					break;
				case 10241:
	//				strLCID = 10241 ' Arabic(Syria) 
					strLang = "Arabic(Syria)";
					break;
				case 11265:
	//				strLCID = 11265 ' Arabic(Jordan) 
					strLang = "Arabic(Jordan)";
					break;
				case 12289:
	//				strLCID = 12289 ' Arabic(Lebanon) 
					strLang = "Arabic(Lebanon)";
					break;
				case 13313:
	//				strLCID = 13313 ' Arabic(Kuwait) 
					strLang = "Arabic(Kuwait)";
					break;
				case 14337:
	//				strLCID = 14337 ' Arabic(U.A.E.) 
					strLang = "Arabic(U.A.E.)";
					break;
				case 15361:
	//				strLCID = 15361 ' Arabic(Bahrain) 
					strLang = "Arabic(Bahrain)";
					break;
				case 16385:
	//				strLCID = 16385 ' Arabic(Qatar) 
					strLang = "Arabic(Qatar)";
					break;
				case 1069:
//					strLCID = 1069  ' Basque 
					strLang = "Basque";
					break;
				case 1026:
//					strLCID = 1026  ' Bulgarian 
					strLang = "Bulgarian";
					break;
				case 1059:
//					strLCID = 1059  ' Belarusian 
					strLang = "Belarusian";
					break;
				case 1027:
//					strLCID = 1027  ' Catalan 
					strLang = "Catalan";
					break;
				case 1028:
//					strLCID = 1028  ' Chinese(Taiwan) 
					strLang = "Chinese(Taiwan)";
					break;
				case 2052:
//					strLCID = 2052  ' Chinese(PRC) 
					strLang = "Chinese(PRC)";
					break;
				case 3076:
//					strLCID = 3076  ' Chinese(Hong Kong) 
					strLang = "Chinese(Hong Kong)";
					break;
				case 4100:
//					strLCID = 4100  ' Chinese(Singapore)
					strLang = "Chinese(Singapore)";
					break;
				case 1050:
//					strLCID = 1050  ' Croatian 
					strLang = "Croatian";
					break;
				case 1029:
//					strLCID = 1029  ' Czech 
					strLang = "Czech";
					break;
				case 1030:
//					strLCID = 1030  ' Danish 
					strLang = "Danish";
					break;
				case 1043:
//					strLCID = 1043  ' Dutch(Standard) 
					strLang = "Dutch(Standard)";
					break;
				case 2067:
//					strLCID = 2067  ' Dutch(Belgian) 
					strLang = "Dutch(Belgian)";
					break;
				case 9:
//					strLCID = 9     ' English 
					strLang = "English";
					break;
				case 1033:
//					strLCID = 1033  ' English(United States) 
					strLang = "English(United States)";
					break;
				case 2057:
//					strLCID = 2057  ' English(British) 
					strLang = "English(British)";
					break;
				case 3081:
//					strLCID = 3081  ' English(Australian) 
					strLang = "English(Australian)";
					break;
				case 4105:
//					strLCID = 4105  ' English(Canadian) 
					strLang = "English(Canadian)";
					break;
				case 5129:
//					strLCID = 5129  ' English(New Zealand) 
					strLang = "English(New Zealand)";
					break;
				case 6153:
//					strLCID = 6153  ' English(Ireland) 
					strLang = "English(Ireland)";
					break;
				case 7177:
//					strLCID = 7177  ' English(South Africa) 
					strLang = "English(South Africa)";
					break;
				case 8201:
//					strLCID = 8201  ' English(Jamaica) 
					strLang = "English(Jamaica)";
					break;
				case 9225:
//					strLCID = 9225  ' English(Caribbean) 
					strLang = "English(Caribbean)";
					break;
				case 10249:
//					strLCID = 10249 ' English(Belize) 
					strLang = "English(Belize)";
					break;
				case 11273:
//					strLCID = 11273 ' English(Trinidad) 
					strLang = "English(Trinidad)";
					break;
				case 1061:
//					strLCID = 1061  ' Estonian 
					strLang = "Estonian";
					break;
				case 1080:
//					strLCID = 1080  ' Faeroese 
					strLang = "Faeroese";
					break;
				case 1065:
//					strLCID = 1065  ' Farsi 
					strLang = "Farsi";
					break;
				case 1035:
//					strLCID = 1035  ' Finnish 
					strLang = "Finnish";
					break;
				case 1036:
//					strLCID = 1036  ' French(Standard) 
					strLang = "French(Standard)";
					break;
				case 2060:
//					strLCID = 2060  ' French(Belgian) 
					strLang = "French(Belgian)";
					break;
				case 3084:
//					strLCID = 3084  ' French(Canadian) 
					strLang = "French(Canadian)";
					break;
				case 4108:
//					strLCID = 4108  ' French(Swiss) 
					strLang = "French(Swiss)";
					break;
				case 5132:
//					strLCID = 5132  ' French(Luxembourg) 
					strLang = "French(Luxembourg)";
					break;
				case 1084:
//					strLCID = 1084  ' Gaelic(Scots) 
					strLang = "Gaelic(Scots)";
					break;
				case 2108:
//					strLCID = 2108  ' Gaelic(Irish) 
					strLang = "Gaelic(Irish)";
					break;
				case 1031:
//					strLCID = 1031  ' German(Standard) 
					strLang = "German(Standard)";
					break;
				case 2055:
//					strLCID = 2055  ' German(Swiss) 
					strLang = "German(Swiss)";
					break;
				case 3079:
//					strLCID = 3079  ' German(Austrian) 
					strLang = "German(Austrian)";
					break;
				case 4103:
//					strLCID = 4103  ' German(Luxembourg) 
					strLang = "German(Luxembourg)";
					break;
				case 5127:
//					strLCID = 5127  ' German(Liechtenstein) 
					strLang = "German(Liechtenstein)";
					break;
				case 1032:
//					strLCID = 1032  ' Greek 
					strLang = "Greek";
					break;
				case 1037:
//					strLCID = 1037  ' Hebrew 
					strLang = "Hebrew";
					break;
				case 1081:
//					strLCID = 1081  ' Hindi 
					strLang = "Hindi";
					break;
				case 1038:
//					strLCID = 1038  ' Hungarian 
					strLang = "Hungarian";
					break;
				case 1039:
//					strLCID = 1039  ' Icelandic 
					strLang = "Icelandic";
					break;
				case 1057:
//					strLCID = 1057  ' Indonesian 
					strLang = "Indonesian";
					break;
				case 1040:
//					strLCID = 1040  ' Italian(Standard) 
					strLang = "Italian(Standard)";
					break;
				case 2064:
//					strLCID = 2064  ' Italian(Swiss) 
					strLang = "Italian(Swiss)";
					break;
				case 1041:
//					strLCID = 1041  ' Japanese 
					strLang = "Japanese";
					break;
				case 1042:
//					strLCID = 1042  ' Korean 
					strLang = "Korean";
					break;
				case 2066:
//					strLCID = 2066  ' Korean(Johab) 
					strLang = "Korean(Johab)";
					break;
				case 1062:
//					strLCID = 1062  ' Latvian 
					strLang = "Latvian";
					break;
				case 1063:
//					strLCID = 1063  ' Lithuanian 
					strLang = "Lithuanian";
					break;
				case 1071:
//					strLCID = 1071  ' Macedonian 
					strLang = "Macedonian";
					break;
				case 1086:
//					strLCID = 1086  ' Malaysian 
					strLang = "Malaysian";
					break;
				case 1082:
//					strLCID = 1082  ' Maltese 
					strLang = "Maltese";
					break;
				case 1044:
//					strLCID = 1044  ' Norwegian(Bokmal) 
					strLang = "Norwegian(Bokmal)";
					break;
				case 2068:
//					strLCID = 2068  ' Norwegian(Nynorsk) 
					strLang = "Norwegian(Nynorsk)";
					break;
				case 1045:
//					strLCID = 1045  ' Polish 
					strLang = "Polish";
					break;
				case 1046:
//					strLCID = 1046  ' Portuguese(Brazilian) 
					strLang = "Portuguese(Brazilian)";
					break;
				case 2070:
//					strLCID = 2070  ' Portuguese(Standard) 
					strLang = "Portuguese(Standard)";
					break;
				case 1047:
//					strLCID = 1047  ' Rhaeto-Romanic 
					strLang = "Rhaeto-Romanic";
					break;
				case 1048:
//					strLCID = 1048  ' Romanian 
					strLang = "Romanian";
					break;
				case 2072:
//					strLCID = 2072  ' Romanian(Moldavia) 
					strLang = "Romanian(Moldavia)";
					break;
				case 1049:
//					strLCID = 1049  ' Russian 
					strLang = "Russian";
					break;
				case 2073:
//					strLCID = 2073  ' Russian(Moldavia) 
					strLang = "Russian(Moldavia)";
					break;
				case 1083:
//					strLCID = 1083  ' Sami(Lappish) 
					strLang = "Sami(Lappish)";
					break;
				case 3098:
//					strLCID = 3098  ' Serbian(Cyrillic) 
					strLang = "Serbian(Cyrillic)";
					break;
				case 2074:
//					strLCID = 2074  ' Serbian(Latin) 
					strLang = "Serbian(Latin)";
					break;
				case 1051:
//					strLCID = 1051  ' Slovak 
					strLang = "Slovak";
					break;
				case 1060:
//					strLCID = 1060  ' Slovenian 
					strLang = "Slovenian";
					break;
				case 1070:
//					strLCID = 1070  ' Sorbian 
					strLang = "Sorbian";
					break;
				case 1034:
//					strLCID = 1034  ' Spanish(Spain - Traditional Sort)
					strLang = "Spanish(Spain - Traditional Sort)";
					break;
				case 2058:
//					strLCID = 2058  ' Spanish(Mexican) 
					strLang = "Spanish(Mexican)";
					break;
				case 3082:
//					strLCID = 3082  ' Spanish(Spain - Modern Sort) 
					strLang = "Spanish(Spain - Modern Sort)";
					break;
				case 4106:
//					strLCID = 4106  ' Spanish(Guatemala) 
					strLang = "Spanish(Guatemala)";
					break;
				case 5130:
//					strLCID = 5130  ' Spanish(Costa Rica)
					strLang = "Spanish(Costa Rica)";
					break;
				case 6154:
//					strLCID = 6154  ' Spanish(Panama) 
					strLang = "Spanish(Panama)";
					break;
				case 7178:
//					strLCID = 7178  ' Spanish(Dominican Republic) 
					strLang = "Spanish(Dominican Republic)";
					break;
				case 8202:
//					strLCID = 8202  ' Spanish(Venezuela) 
					strLang = "Spanish(Venezuela)";
					break;
				case 9226:
//					strLCID = 9226  ' Spanish(Colombia) 
					strLang = "Spanish(Colombia)";
					break;
				case 10250:
//					strLCID = 10250 ' Spanish(Peru) 
					strLang = "Spanish(Peru)";
					break;
				case 11274:
//					strLCID = 11274 ' Spanish(Argentina) 
					strLang = "Spanish(Argentina)";
					break;
				case 12298:
//					strLCID = 12298 ' Spanish(Ecuador) 
					strLang = "Spanish(Ecuador)";
					break;
				case 13322:
//					strLCID = 13322 ' Spanish(Chile)
					strLang = "Spanish(Chile)";
					break;
				case 14346:
//					strLCID = 14346 ' Spanish(Uruguay) 
					strLang = "Spanish(Uruguay)";
					break;
				case 15370:
//					strLCID = 15370 ' Spanish(Paraguay) 
					strLang = "Spanish(Paraguay)";
					break;
				case 16394:
//					strLCID = 16394 ' Spanish(Bolivia) 
					strLang = "Spanish(Bolivia)";
					break;
				case 17418:
//					strLCID = 17418 ' Spanish(El Salvador) 
					strLang = "Spanish(El Salvador)";
					break;
				case 18442:
//					strLCID = 18442 ' Spanish(Honduras) 
					strLang = "Spanish(Honduras)";
					break;
				case 19466:
//					strLCID = 19466 ' Spanish(Nicaragua) 
					strLang = "Spanish(Nicaragua)";
					break;
				case 20490:
//					strLCID = 20490 ' Spanish(Puerto Rico) 
					strLang = "Spanish(Puerto Rico)";
					break;
				case 1072:
//					strLCID = 1072  ' Sutu 
					strLang = "Sutu";
					break;
				case 1053:
//					strLCID = 1053  ' Swedish 
					strLang = "Swedish";
					break;
				case 2077:
//					strLCID = 2077  ' Swedish(Finland) 
					strLang = "Swedish(Finland)";
					break;
				case 1054:
//					strLCID = 1054  ' Thai 
					strLang = "Thai";
					break;
				case 1073:
//					strLCID = 1073  ' Tsonga 
					strLang = "Tsonga";
					break;
				case 1074:
//					strLCID = 1074  ' Tswana 
					strLang = "Tswana";
					break;
				case 1055:
//					strLCID = 1055  ' Turkish 
					strLang = "Turkish";
					break;
				case 1058:
//					strLCID = 1058  ' Ukrainian 
					strLang = "Ukrainian";
					break;
				case 1056:
//					strLCID = 1056  ' Urdu 
					strLang = "Urdu";
					break;
				case 1075:
//					strLCID = 1075  ' Venda 
					strLang = "Venda";
					break;
				case 1066:
//					strLCID = 1066  ' Vietnamese 
					strLang = "Vietnamese";
					break;
				case 1076:
//					strLCID = 1076  ' Xhosa 
					strLang = "Xhosa";
					break;
				case 1085:
//					strLCID = 1085  ' Yiddish 
					strLang = "Yiddish";
					break;
				case 1077:
//					strLCID = 1077  ' Zulu 
					strLang = "Zulu";
					break;
				default:
//					strLCID = 2048  ' default
					strLang = "Unknown" + iLang.ToString();
					break;
			}
			return strLang;
		}

		private void ddlLanguages_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			SqlConnection cn = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TimRagain06");
			SqlCommand cm = new SqlCommand();
			SqlDataReader dr;
			DateTime dDate = DateTime.Now;
			int rowCtr=0;
			int cellCtr=0;
			int cellCnt = 5;
			int iLang = 0;
			string sLang;
			TableRow tRow;
			TableCell tCell;


			cn.Open();
			cm.CommandType = CommandType.StoredProcedure;
			cm.CommandTimeout = 240;
			cm.CommandText = "GetOSLanguage";
			cm.Parameters.Add("@sDate", System.Data.SqlDbType.VarChar, 12);
			dDate = Calendar1.SelectedDate;
			cm.Parameters[0].Value = dDate.ToShortDateString();
			cm.Connection = cn;
			dr = cm.ExecuteReader();
			//dr.Read();
			
			do
			{
				if(rowCtr > 0)
				{
					sLang = dr.GetString(0);
					if(sLang == "")
					{
						iLang = 0;
					}
					else
					{
						iLang = System.Convert.ToInt16(dr.GetString(0), 10);
					}
				}
				if(rowCtr == 0 || ddlLanguages.SelectedItem.Value == "ALL" || GetLanguage(iLang) == ddlLanguages.SelectedItem.Value)
				{
					tRow = new TableRow();
					//				}
					for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
					{
						
						tblUploads.Rows.Add(tRow);
						tCell = new TableCell();

						if(rowCtr == 0)
						{
							
							switch(cellCtr)
							{
								case 1: 
									tCell.Text = "OS Lang";
									break;
								case 2 :
									tCell.Text = "Total";
									break;
								case 3 :
									tCell.Text = "OS Version";
									break;
								case 4:
									tCell.Text = "OS Name";
									break;
								case 5:
									tCell.Text = "Date";
									break;
								default:
									tCell.Text = "";
									break;
							
							}
							tCell.Style["font-size"] = "small";
							tCell.Height = 20;

						}
						else
						{
							switch(cellCtr)
							{
								case 1 :
									//									tCell.Text = dr.GetString(0).ToString();
									try
									{
										tCell.Text = GetLanguage(System.Convert.ToInt16(dr.GetString(0), 10));
									}
									catch
									{
										tCell.Text = "Unknown" + dr.GetString(0);
									}
									break;
								case 2 :
									tCell.Text = dr.GetInt32(1).ToString();
									break;
								case 3 :
									tCell.Text = dr.GetString(2).ToString();
									break;
								case 4 :
									tCell.Text = dr.GetString(3).ToString();
									break;
								case 5 :
									if(dr.IsDBNull(4))
									{
										tCell.Text = "";
									}
									else
									{
										tCell.Text = dr.GetDateTime(4).ToShortDateString();
									}
									break;

								default:
									tCell.Text = "0";
									break;
							}
							tCell.Style["background-color"] = "white";
							tCell.Style["font-size"] = "small-x";
							tCell.Style["color"] = "#6487dc";
							tCell.Style["font-weight"] = "Bold";
							tCell.Height = 20;
							
						}
						tCell.Style["font-family"] = "Tahoma";
						tRow.Cells.Add(tCell);
					}//for
				}
				rowCtr++;
			}while(dr.Read() == true);		
		}
	}
}
//			SqlConnection cn = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TimRagain06");
//			SqlCommand cm = new SqlCommand();
//			SqlDataReader dr;
//			DateTime dDate = DateTime.Now;
//			int rowCtr=0;
//			int cellCtr=0;
//			int cellCnt = 5;
//
//			cn.Open();
//			cm.CommandType = CommandType.StoredProcedure;
//			cm.CommandTimeout = 240;
//			cm.CommandText = "GetOSLanguage";
//			cm.Parameters.Add("@sDate", System.Data.SqlDbType.VarChar, 12);
//			dDate = Calendar1.SelectedDate;
//			cm.Parameters[0].Value = dDate.ToShortDateString();
//			cm.Connection = cn;
//			dr = cm.ExecuteReader();
//			//dr.Read();
//			
//			do
//			{
//				TableRow tRow = new TableRow();
//				tblUploads.Rows.Add(tRow);
//
//				for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
//				{
//					TableCell tCell = new TableCell();
//
//					if(rowCtr == 0)
//					{
//						switch(cellCtr)
//						{
//							case 1: 
//								tCell.Text = "OS Lang";
//								break;
//							case 2 :
//								tCell.Text = "Total";
//								break;
//							case 3 :
//								tCell.Text = "OS Version";
//								break;
//							case 4:
//								tCell.Text = "OS Name";
//								break;
//							case 5:
//								tCell.Text = "Date";
//								break;
//							default:
//								tCell.Text = "";
//								break;
//						
//						}
//						tCell.Style["font-size"] = "small";
//						tCell.Height = 20;
//
//					}
//					else
//					{
//						switch(cellCtr)
//						{
//							case 1 :
////									tCell.Text = dr.GetString(0).ToString();
//								try
//								{
//									tCell.Text = GetLanguage(System.Convert.ToInt16(dr.GetString(0), 10));
//								}
//								catch
//								{
//									tCell.Text = "Unknown" + dr.GetString(0);
//								}
//								break;
//							case 2 :
//								tCell.Text = dr.GetInt32(1).ToString();
//								break;
//							case 3 :
//								tCell.Text = dr.GetString(2).ToString();
//								break;
//							case 4 :
//								tCell.Text = dr.GetString(3).ToString();
//								break;
//							case 5 :
//								if(dr.IsDBNull(4))
//								{
//									tCell.Text = "";
//								}
//								else
//								{
//									tCell.Text = dr.GetDateTime(4).ToShortDateString();
//								}
//								break;
//
//							default:
//								tCell.Text = "0";
//								break;
//					
//						}
//						tCell.Style["background-color"] = "white";
//						tCell.Style["font-size"] = "small-x";
//						tCell.Style["color"] = "#6487dc";
//						tCell.Style["font-weight"] = "Bold";
//						tCell.Height = 20;
//						
//					}
//					tCell.Style["font-family"] = "Tahoma";
//					tRow.Cells.Add(tCell);
//				}
//				rowCtr++;
//			}while(dr.Read() == true);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\xmlreports\side.inc ===
<table BORDER="0" height="100%" cellpadding="0" cellspacing="0" width="182">
				<tr valign="top">
					<td>	
					<table width="100%" cellpadding="0" cellspacing="0" border="0">
						<tr>
							<td class="sys-toppane-header">
								On Line Crash Analysis Tools
							</td>
						</tr>
					</table>
					<table width="100%" cellpadding="0" cellspacing="0" border="0" height="100%">
						<tr>
							<td rowspan="2" height="100%" class="flyoutMenu" valign="top">
								<table width="100%" cellpadding="0" cellspacing="0" border="0">
									<tr>
										<td class="flyoutLink" valign="middle">
											<img src="endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;
											<a href="home.aspx">Home</a>
										</td>
									</tr>
								</table>
								<table width="100%" cellpadding="0" cellspacing="0" border="0">
									<tr>
										<td class="flyoutLink" valign="middle">
											<img src="endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;
											<a href="languagereport.aspx">Language By Code Report</a>
										</td>
									</tr>
								</table>
								<table width="100%" cellpadding="0" cellspacing="0" border="0">
									<tr>
										<td class="flyoutLink" valign="middle">
											<img src="endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;
											<a href="language.aspx">Language Report</a>
										</td>
									</tr>
								</table>
								<table width="100%" cellpadding="0" cellspacing="0" border="0">
									<tr>
										<td class="flyoutLink" valign="middle">
											<img src="endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;
											<a href="xcounts.aspx">Counts</a>
										</td>
									</tr>
								</table>
								<table width="100%" cellpadding="0" cellspacing="0" border="0">
									<tr>
										<td class="flyoutLink" valign="middle">
											<img src="endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;
											<a href="versiontotal.aspx">Version Total</a>
										</td>
									</tr>
								</table>
								<table width="100%" cellpadding="0" cellspacing="0" border="0">
									<tr>
										<td class="flyoutLink" valign="middle">
											<img src="endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;
											<a href="countbydate.aspx">Count By Date</a>
										</td>
									</tr>
								</table>
								<table width="100%" cellpadding="0" cellspacing="0" border="0">
									<tr>
										<td class="flyoutLink" valign="middle">
											<img src="endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;
											<a href="http://timragain06/OCAWReports/home.aspx">Weekly Reports</a>
										</td>
									</tr>
								</table>
						</td>
					</tr>
				</table>
				</td>
			</tr>
		</table>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\xmlreports\languagereport.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.SqlClient;

namespace XReports
{
	/// <summary>
	/// Summary description for languagereport.
	/// </summary>
	public class languagereport : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Table tblUploads;
		protected System.Web.UI.WebControls.DropDownList ddlLangs;
		protected System.Web.UI.WebControls.Calendar Calendar1;
	
		private void Page_Load(object sender, System.EventArgs e)
		{

			if(Page.IsPostBack == false)
			{
				SqlConnection cn = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TimRagain06");
				SqlConnection cn2 = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TimRagain06");
				SqlCommand cm = new SqlCommand();
				SqlDataReader dr;
				int rowCtr=0;
				int cellCtr=0;
				int cellCnt = 5;
				int x = 0;
				double dbDays = -7;
				DateTime dDate = DateTime.Now;
				cn.Open();
				cm.CommandType = CommandType.StoredProcedure;
				cm.CommandTimeout = 240;
				cm.CommandText = "GetOSLangReport";
				cm.Parameters.Add("@sDate", System.Data.SqlDbType.VarChar, 12);
				dDate = dDate.AddDays(dbDays);
				cm.Parameters[0].Value = dDate.ToShortDateString();
				cm.Connection = cn;
				dr = cm.ExecuteReader();
				Calendar1.SelectedDate = dDate;
				SqlCommand cm2 = new SqlCommand();
				SqlDataReader dr2;
				ArrayList strLanguages = new ArrayList();
				//				dr.Read();


				cn2.Open();
				cm2.CommandType = CommandType.StoredProcedure;
				cm2.CommandTimeout = 240;
				cm2.CommandText = "GetOSLanguageHeaders";
				cm2.Parameters.Add("@sDate", System.Data.SqlDbType.VarChar, 12);
				cm2.Parameters[0].Value = dDate.ToShortDateString();
				cm2.Connection = cn2;
				dr2 = cm2.ExecuteReader();
				ddlLangs.DataSource = dr2;
				ddlLangs.Items.Add("ALL");
				dr2.Read();

				do 
				{
					//					ddlLanguages.Items.Add(dr2.GetString(0));
					try
					{
						strLanguages.Add(dr2.GetString(0));
					}
					catch
					{
						
					}
				}while(dr2.Read() == true);	
				strLanguages.Sort();
				for(x = 0; x < strLanguages.Count; x++)
				{
					//					ddlLanguages.Items.Add(dr2.GetString(0));
					try
					{
						
						ddlLangs.Items.Add(strLanguages[x].ToString());
					}
					catch
					{
						ddlLangs.Items.Add("Unknown" + strLanguages[x].ToString());
					}
				}



				do
				{
					TableRow tRow = new TableRow();
					tblUploads.Rows.Add(tRow);

					for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
					{
						TableCell tCell = new TableCell();

						if(rowCtr == 0)
						{
							switch(cellCtr)
							{
								case 1: 
									tCell.Text = "OS Lang";
									break;
								case 2 :
									tCell.Text = "Total";
									break;
								case 3 :
									tCell.Text = "OS Version";
									break;
								case 4:
									tCell.Text = "OS Name";
									break;
								case 5:
									tCell.Text = "Date";
									break;
								default:
									tCell.Text = "";
									break;
							
							}
							tCell.Style["font-size"] = "small";
							tCell.Height = 20;

						}
						else
						{
							switch(cellCtr)
							{
								case 1 :
									tCell.Text = dr.GetString(0).ToString();
									break;
								case 2 :
									tCell.Text = dr.GetInt32(1).ToString();
									break;
								case 3 :
									tCell.Text = dr.GetString(2).ToString();
									break;
								case 4 :
									tCell.Text = dr.GetString(3).ToString();
									break;
								case 5 :
									if(dr.IsDBNull(4))
									{
										tCell.Text = "";
									}
									else
									{
										tCell.Text = dr.GetDateTime(4).ToShortDateString();
									}
									break;

								default:
									tCell.Text = "0";
									break;
							
							}
							tCell.Style["background-color"] = "white";
							tCell.Style["font-size"] = "small-x";
							tCell.Style["color"] = "#6487dc";
							tCell.Style["font-weight"] = "Bold";
							tCell.Height = 20;
							
						}
						tCell.Style["font-family"] = "Tahoma";
						tRow.Cells.Add(tCell);
					}
					rowCtr++;
				}while(dr.Read() == true);	
			}
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Calendar1.VisibleMonthChanged += new System.Web.UI.WebControls.MonthChangedEventHandler(this.Calendar1_VisibleMonthChanged);
			this.Calendar1.SelectionChanged += new System.EventHandler(this.Calendar1_SelectionChanged);
			this.ddlLangs.SelectedIndexChanged += new System.EventHandler(this.ddlLangs_SelectedIndexChanged);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		private void Calendar1_SelectionChanged(object sender, System.EventArgs e)
		{
			SqlConnection cn = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TimRagain06");
			SqlCommand cm = new SqlCommand();
			SqlDataReader dr;
			DateTime dDate = DateTime.Now;
			int rowCtr=0;
			int cellCtr=0;
			int cellCnt = 5;
			int iLang = 0;
			string sLang;
			TableRow tRow;
			TableCell tCell;


			cn.Open();
			cm.CommandType = CommandType.StoredProcedure;
			cm.CommandTimeout = 240;
			cm.CommandText = "GetOSLangReport";
			cm.Parameters.Add("@sDate", System.Data.SqlDbType.VarChar, 12);
			dDate = Calendar1.SelectedDate;
			cm.Parameters[0].Value = dDate.ToShortDateString();
			cm.Connection = cn;
			dr = cm.ExecuteReader();
			//dr.Read();
			
			do
			{
				if(rowCtr > 0)
				{
					sLang = dr.GetString(0);
					if(sLang == "")
					{
						iLang = 0;
					}
					else
					{
						iLang = System.Convert.ToInt16(dr.GetString(0), 10);
					}
				}
				if(rowCtr == 0 || ddlLangs.SelectedItem.Value == "ALL" || iLang.ToString() == ddlLangs.SelectedItem.Value)
				{
					tRow = new TableRow();
					//				}
					for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
					{
						
						tblUploads.Rows.Add(tRow);
						tCell = new TableCell();

						if(rowCtr == 0)
						{
							
							switch(cellCtr)
							{
								case 1: 
									tCell.Text = "OS Lang2";
									break;
								case 2 :
									tCell.Text = "Total";
									break;
								case 3 :
									tCell.Text = "OS Version";
									break;
								case 4:
									tCell.Text = "OS Name";
									break;
								case 5:
									tCell.Text = "Date";
									break;
								default:
									tCell.Text = "";
									break;
							
							}
							tCell.Style["font-size"] = "small";
							tCell.Height = 20;

						}
						else
						{
							switch(cellCtr)
							{
								case 1 :
									//									tCell.Text = dr.GetString(0).ToString();
									try
									{
										tCell.Text = dr.GetString(0);
									}
									catch
									{
										tCell.Text = "Unknown" + dr.GetString(0);
									}
									break;
								case 2 :
									tCell.Text = dr.GetInt32(1).ToString();
									break;
								case 3 :
									tCell.Text = dr.GetString(2).ToString();
									break;
								case 4 :
									tCell.Text = dr.GetString(3).ToString();
									break;
								case 5 :
									if(dr.IsDBNull(4))
									{
										tCell.Text = "";
									}
									else
									{
										tCell.Text = dr.GetDateTime(4).ToShortDateString();
									}
									break;

								default:
									tCell.Text = "0";
									break;
							}
							tCell.Style["background-color"] = "white";
							tCell.Style["font-size"] = "small-x";
							tCell.Style["color"] = "#6487dc";
							tCell.Style["font-weight"] = "Bold";
							tCell.Height = 20;
							
						}
						tCell.Style["font-family"] = "Tahoma";
						tRow.Cells.Add(tCell);
					}//for
				}
				rowCtr++;
			}while(dr.Read() == true);		
		}

		private void Calendar1_VisibleMonthChanged(object sender, System.Web.UI.WebControls.MonthChangedEventArgs e)
		{
			SqlConnection cn = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TimRagain06");
			SqlCommand cm = new SqlCommand();
			SqlDataReader dr;
			DateTime dDate = DateTime.Now;
			int rowCtr=0;
			int cellCtr=0;
			int cellCnt = 5;
			int iLang = 0;
			string sLang;
			TableRow tRow;
			TableCell tCell;


			cn.Open();
			cm.CommandType = CommandType.StoredProcedure;
			cm.CommandTimeout = 240;
			cm.CommandText = "GetOSLangReport";
			cm.Parameters.Add("@sDate", System.Data.SqlDbType.VarChar, 12);
			dDate = Calendar1.SelectedDate;
			cm.Parameters[0].Value = dDate.ToShortDateString();
			cm.Connection = cn;
			dr = cm.ExecuteReader();
			//dr.Read();
			
			do
			{
				if(rowCtr > 0)
				{
					sLang = dr.GetString(0);
					if(sLang == "")
					{
						iLang = 0;
					}
					else
					{
						iLang = System.Convert.ToInt16(dr.GetString(0), 10);
					}
				}
				if(rowCtr == 0 || ddlLangs.SelectedItem.Value == "ALL" || iLang.ToString() == ddlLangs.SelectedItem.Value)
				{
					tRow = new TableRow();
					//				}
					for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
					{
						
						tblUploads.Rows.Add(tRow);
						tCell = new TableCell();

						if(rowCtr == 0)
						{
							
							switch(cellCtr)
							{
								case 1: 
									tCell.Text = "OS Lang2";
									break;
								case 2 :
									tCell.Text = "Total";
									break;
								case 3 :
									tCell.Text = "OS Version";
									break;
								case 4:
									tCell.Text = "OS Name";
									break;
								case 5:
									tCell.Text = "Date";
									break;
								default:
									tCell.Text = "";
									break;
							
							}
							tCell.Style["font-size"] = "small";
							tCell.Height = 20;

						}
						else
						{
							switch(cellCtr)
							{
								case 1 :
									//									tCell.Text = dr.GetString(0).ToString();
									try
									{
										tCell.Text = dr.GetString(0);
									}
									catch
									{
										tCell.Text = "Unknown" + dr.GetString(0);
									}
									break;
								case 2 :
									tCell.Text = dr.GetInt32(1).ToString();
									break;
								case 3 :
									tCell.Text = dr.GetString(2).ToString();
									break;
								case 4 :
									tCell.Text = dr.GetString(3).ToString();
									break;
								case 5 :
									if(dr.IsDBNull(4))
									{
										tCell.Text = "";
									}
									else
									{
										tCell.Text = dr.GetDateTime(4).ToShortDateString();
									}
									break;

								default:
									tCell.Text = "0";
									break;
							}
							tCell.Style["background-color"] = "white";
							tCell.Style["font-size"] = "small-x";
							tCell.Style["color"] = "#6487dc";
							tCell.Style["font-weight"] = "Bold";
							tCell.Height = 20;
							
						}
						tCell.Style["font-family"] = "Tahoma";
						tRow.Cells.Add(tCell);
					}//for
				}
				rowCtr++;
			}while(dr.Read() == true);		
		}

		private void ddlLangs_SelectedIndexChanged(object sender, System.EventArgs e)
		{
			SqlConnection cn = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TimRagain06");
			SqlCommand cm = new SqlCommand();
			SqlDataReader dr;
			DateTime dDate = DateTime.Now;
			int rowCtr=0;
			int cellCtr=0;
			int cellCnt = 5;
			int iLang = 0;
			string sLang;
			TableRow tRow;
			TableCell tCell;


			cn.Open();
			cm.CommandType = CommandType.StoredProcedure;
			cm.CommandTimeout = 240;
			cm.CommandText = "GetOSLangReport";
			cm.Parameters.Add("@sDate", System.Data.SqlDbType.VarChar, 12);
			dDate = Calendar1.SelectedDate;
			cm.Parameters[0].Value = dDate.ToShortDateString();
			cm.Connection = cn;
			dr = cm.ExecuteReader();
			//dr.Read();
			
			do
			{
				if(rowCtr > 0)
				{
					sLang = dr.GetString(0);
					if(sLang == "")
					{
						iLang = 0;
					}
					else
					{
						iLang = System.Convert.ToInt16(dr.GetString(0), 10);
					}
				}
				if(rowCtr == 0 || ddlLangs.SelectedItem.Value == "ALL" || iLang.ToString() == ddlLangs.SelectedItem.Value)
				{
					tRow = new TableRow();
					//				}
					for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
					{
						
						tblUploads.Rows.Add(tRow);
						tCell = new TableCell();

						if(rowCtr == 0)
						{
							
							switch(cellCtr)
							{
								case 1: 
									tCell.Text = "OS Lang2";
									break;
								case 2 :
									tCell.Text = "Total";
									break;
								case 3 :
									tCell.Text = "OS Version";
									break;
								case 4:
									tCell.Text = "OS Name";
									break;
								case 5:
									tCell.Text = "Date";
									break;
								default:
									tCell.Text = "";
									break;
							
							}
							tCell.Style["font-size"] = "small";
							tCell.Height = 20;

						}
						else
						{
							switch(cellCtr)
							{
								case 1 :
									//									tCell.Text = dr.GetString(0).ToString();
									try
									{
										tCell.Text = dr.GetString(0);
									}
									catch
									{
										tCell.Text = "Unknown" + dr.GetString(0);
									}
									break;
								case 2 :
									tCell.Text = dr.GetInt32(1).ToString();
									break;
								case 3 :
									tCell.Text = dr.GetString(2).ToString();
									break;
								case 4 :
									tCell.Text = dr.GetString(3).ToString();
									break;
								case 5 :
									if(dr.IsDBNull(4))
									{
										tCell.Text = "";
									}
									else
									{
										tCell.Text = dr.GetDateTime(4).ToShortDateString();
									}
									break;

								default:
									tCell.Text = "0";
									break;
							}
							tCell.Style["background-color"] = "white";
							tCell.Style["font-size"] = "small-x";
							tCell.Style["color"] = "#6487dc";
							tCell.Style["font-weight"] = "Bold";
							tCell.Height = 20;
							
						}
						tCell.Style["font-family"] = "Tahoma";
						tRow.Cells.Add(tCell);
					}//for
				}
				rowCtr++;
			}while(dr.Read() == true);		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\xmlreports\headerstrings.inc ===
<%

	string L_HEADER_INC_TITLE_PAGETITLE;
	string L_HEADERINC_ALINK_HOME_MENUITEM;
	string L_HEADERINC_ALINK_HOME2_MENUITEM;
	string L_HEADERINC_ALINK_SUBMITREPORT_MENUITEM;
	string L_HEADERINC_ALINK_CHECKSTATUS_MENUITEM;
	string L_HEADERINC_ALINK_RESOURCES_MENUITEM;
	string L_HEADERINC_ALINK_PRIVACY_MENUITEM;
	string L_HEADERINC_ALINK_FEEDBACK_MENUITEM;
	string L_HEADERINC_ALINK_FAQ_MENUITEM;
	string L_HEADERINC_ALINK_SIGNIN;
	string L_HEADERINC_ALINK_SIGNIN_MENUITEM;
	string L_HEADERINC_IMAGE_ALT_TOOLTIP;
	string L_HEADERINC_TOP10STATUS_LINK_TEXT;
	string L_HEADERINC_ALINK_MICROSOFT_MENUITEM;
	string L_HEADERINC_TITLE_OCAHOME_TOOLTIP;
	string L_HEADERINC_TITLE_CERHOME_TOOLTIP;
	string L_HEADERINC_IMAGES_BANNER_TEXT;
	string L_HEADERINC_ISAPI_HOME_MENUITEM;
	string L_HEADERINC_MICROSOFT_HOME_MENUITEM;
	string L_HEADERINC_ALL_PRODUCTS_MENUITEM;
	string L_HEADERINC_ALLPRODUCTS_LINK_TEXT;
	string L_HEADERINC_DOWNLOADS_DOWNLOADS_MENUITEM;
	string L_HEADERINC_DOWNLOADS_LINK_TEXT;
	string L_HEADERINC_MSPRODUCT_CATALOG_MENUITEM;
	string L_HEADERINC_MSPRODUCT_CATALOG_TEXT;
	string L_HEADERINC_MICROSOFT_ACCESSIBILITY_MENUITEM;
	string L_HEADERINC_MICROSOFT_ACCESSIBILITY_TEXT;
	string L_HEADERINC_SERVER_PRODUCTS_MENUITEM;
	string L_HEADERINC_SERVER_PRODUCTS_TEXT;
	string L_HEADERINC_DEVELOPER_TOOLS_MENUITEM;
	string L_HEADERINC_DEVELOPER_TOOLS_TEXT;
	string L_HEADERINC_OFFICE_FAMILY_MENUITEM;
	string L_HEADERINC_OFFICE_FAMILY_TEXT;
	string L_HEADERINC_WINDOWS_FAMILY_MENUITEM;
	string L_HEADERINC_WINDOWS_FAMILY_TEXT;
	string L_HEADERINC_MSN_LINK_TEXT;
	string L_HEADERINC_MSN_LINK_MENUITEM;
	string L_HEADERINC_SUPPORT_LINK_TEXT;
	string L_HEADERINC_SUPPORT_LINK_MENUITEM;
	string L_HEADERINC_KNOWLEDGE_BASE_TEXT;
	string L_HEADERINC_KNOWLEDGE_BASE_MENUITEM;
	string L_HEADERINC_PRODUCTSUPPORT_OPTIONS_TEXT;
	string L_HEADERINC_PRODUCTSUPPORT_OPTIONS_MENUITEM;
	string L_HEADERINC_SERVICEPARTNER_REFERRALS_TEXT;
	string L_HEADERINC_SERVICEPARTNER_REFERRALS_MENUITEM;
	string L_HEADERINC_SEARCH_LINK_TEXT;
	string L_HEADERINC_SEARCH_LINK_MENUITEM;
	string L_HEADERINC_SEARCH_MICROSOFT_TEXT;
	string L_HEADERINC_SEARCH_MICROSOFT_MENUITEM;
	string L_HEADERINC_MSNWEB_SEARCH_TEXT;
	string L_HEADERINC_MSNWEB_SEARCH_MENUITEM;
	string L_HEADERINC_MICROSOFTCOM_GUIDE_TEXT;
	string L_HEADERINC_MICROSOFTCOM_GUIDE_MENUITEM;
	string L_HEADERINC_MICROSOFTCOM_HOME_TEXT;
	string L_HEADERINC_MICROSOFTCOM_HOME_MENUITEM;
	string L_HEADERINC_MSN_HOME_TEXT;
	string L_HEADERINC_MSN_HOME_MENUITEM;
	string L_HEADERINC_CONTACT_US_TEXT;
	string L_HEADERINC_CONTACT_US_MENUITEM;
	string L_HEADERINC_EVENTS_LINK_TEXT;
	string L_HEADERINC_EVENTS_LINK_MENUITEM;
	string L_HEADERINC_NEWSLETTERS_LINK_TEXT;
	string L_HEADERINC_NEWSLETTERS_LINK_MENUITEM;
	string L_HEADERINC_PROFILE_CENTER_TEXT;
	string L_HEADERINC_PROFILE_CENTER_MENUITEM;
	string L_HEADERINC_TRAINING_CERTIFICATION_TEXT;
	string L_HEADERINC_TRAINING_CERTIFICATION_MENUITEM;
	string L_HEADERINC_FREEEMAIL_ACCOUNT_TEXT;
	string L_HEADERINC_FREEEMAIL_ACCOUNT_MENUITEM;
	string L_HEADERINC_MICROSOFT_RIGHTSRESERVED_TEXT;
	string L_HEADERINC_TERMSOF_USE_TEXT;
	string L_HEADERINC_TERMSOF_USE_MENUITEM;
	string L_HEADERINC_PRIVACY_STATEMENT_TEXT;
	string L_HEADERINC_PRIVACY_STATEMENT_MENUITEM;
	string L_HEADERINC_ACCESSIBILITY_LINK_TEXT;
	string L_HEADERINC_ACCESSIBILITY_LINK_MENUITEM;
	string L_HEADERINC_ALINK_CER_MENUITEM;
	string L_HEADERINC_ALINK_WORLD_MENUITEM; 
	string L_HEADERINC_TITLE_WORLDHOME_TOOLTIP;
	string L_HEADERINC_LEFT_NAV_TEXT;
	string L_HEADERCERINC_LEFT_NAV_TEXT;
	
	//'-------------------------header.asp Page Strings-------------------------
	L_HEADERCERINC_LEFT_NAV_TEXT = "Corporate reports";
	L_HEADERINC_LEFT_NAV_TEXT = "OCA Reports";
	L_HEADERINC_ALINK_CER_MENUITEM = "Corporate Error Reporting";
	L_HEADERINC_ALINK_WORLD_MENUITEM = "Online Crash Analysis Worldwide";
	L_HEADERINC_ACCESSIBILITY_LINK_TEXT = "http:////www.microsoft.com//enable//default.htm";
	L_HEADERINC_ACCESSIBILITY_LINK_MENUITEM = "Accessibility";
	L_HEADERINC_PRIVACY_STATEMENT_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//info//privacy.htm";
	L_HEADERINC_PRIVACY_STATEMENT_MENUITEM = "Privacy Statement";
	L_HEADERINC_TERMSOF_USE_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//info//cpyright.htm";
	L_HEADERINC_TERMSOF_USE_MENUITEM = "Terms of Use";
	L_HEADERINC_MICROSOFT_RIGHTSRESERVED_TEXT = "&#169; 2001 Microsoft Corporation. All rights reserved.";
	L_HEADERINC_FREEEMAIL_ACCOUNT_TEXT = "http:////www.hotmail.com//";
	L_HEADERINC_FREEEMAIL_ACCOUNT_MENUITEM = "Free E-mail Account";
	L_HEADERINC_TRAINING_CERTIFICATION_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//train_cert//";
	L_HEADERINC_TRAINING_CERTIFICATION_MENUITEM = "Training & Certification";
	L_HEADERINC_PROFILE_CENTER_TEXT = "http:////www.microsoft.com//isapi//goregwiz.asp?target=//regsys//pic.asp";
	L_HEADERINC_PROFILE_CENTER_MENUITEM = "Profile Center";
	L_HEADERINC_NEWSLETTERS_LINK_TEXT = "http:////www.microsoft.com//isapi//goregwiz.asp?target=//regsys//pic.asp?sec=0";
	L_HEADERINC_NEWSLETTERS_LINK_MENUITEM = "Newsletters";
	L_HEADERINC_EVENTS_LINK_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//usa//events//default.asp";
	L_HEADERINC_EVENTS_LINK_MENUITEM = "Events";
	L_HEADERINC_CONTACT_US_TEXT = "http:////www.microsoft.com//isapi//goregwiz.asp?target=//regwiz//forms//contactus.asp";
	L_HEADERINC_CONTACT_US_MENUITEM = "Contact Us";
	L_HEADERINC_MSN_HOME_TEXT = "http:////www.msn.com//";
	L_HEADERINC_MSN_HOME_MENUITEM = "MSN Home";
	L_HEADERINC_MICROSOFTCOM_HOME_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//";
	L_HEADERINC_MICROSOFTCOM_HOME_MENUITEM = "microsoft.com Home";
	L_HEADERINC_MICROSOFTCOM_GUIDE_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//";
	L_HEADERINC_MICROSOFTCOM_GUIDE_MENUITEM = "microsoft.com Guide";
	L_HEADERINC_MSNWEB_SEARCH_TEXT = "http:////search.msn.com//";
	L_HEADERINC_MSNWEB_SEARCH_MENUITEM = "MSN Web Search";
	L_HEADERINC_SEARCH_MICROSOFT_TEXT = "http:////www.microsoft.com//isapi//gosearch.asp?target=//us//default.asp";
	L_HEADERINC_SEARCH_MICROSOFT_MENUITEM = "Search microsoft.com";
	L_HEADERINC_SEARCH_LINK_TEXT = "http:////www.microsoft.com//isapi//gosearch.asp?target=//us//default.asp";
	L_HEADERINC_SEARCH_LINK_MENUITEM = "Search";
	L_HEADERINC_SERVICEPARTNER_REFERRALS_TEXT = "http:////mcspreferral.microsoft.com//";
	L_HEADERINC_SERVICEPARTNER_REFERRALS_MENUITEM = "Service Partner Referrals";
	L_HEADERINC_PRODUCTSUPPORT_OPTIONS_TEXT = "http:////www.microsoft.com//isapi//gosupport.asp?target=//directory//";
	L_HEADERINC_PRODUCTSUPPORT_OPTIONS_MENUITEM = "Product Support Options";
	L_HEADERINC_KNOWLEDGE_BASE_TEXT = "http:////support.microsoft.com//search//";
	L_HEADERINC_KNOWLEDGE_BASE_MENUITEM = "Knowledge Base";
	L_HEADERINC_SUPPORT_LINK_TEXT = "http:////www.microsoft.com//isapi//gosupport.asp?target=//directory//";
	L_HEADERINC_SUPPORT_LINK_MENUITEM = "Support";
	L_HEADERINC_MSN_LINK_TEXT = "http:////www.msn.com//";
	L_HEADERINC_MSN_LINK_MENUITEM = "MSN";
	L_HEADERINC_WINDOWS_FAMILY_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//windows//";
	L_HEADERINC_WINDOWS_FAMILY_MENUITEM = "Windows Family";
	L_HEADERINC_OFFICE_FAMILY_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//office//";
	L_HEADERINC_OFFICE_FAMILY_MENUITEM = "Office Family";
	L_HEADERINC_DEVELOPER_TOOLS_TEXT = "http:////www.microsoft.com//isapi//gomsdn.asp?target=//vstudio//";
	L_HEADERINC_DEVELOPER_TOOLS_MENUITEM = "Developer Tools";
	L_HEADERINC_SERVER_PRODUCTS_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//servers//";
	L_HEADERINC_SERVER_PRODUCTS_MENUITEM = "Server Products";
	L_HEADERINC_MICROSOFT_ACCESSIBILITY_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//enable//";
	L_HEADERINC_MICROSOFT_ACCESSIBILITY_MENUITEM = "Microsoft Accessibility";
	L_HEADERINC_MSPRODUCT_CATALOG_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//catalog//default.asp?subid=22";
	L_HEADERINC_MSPRODUCT_CATALOG_MENUITEM = "MS Product Catalog";
	L_HEADERINC_DOWNLOADS_LINK_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//downloads//";
	L_HEADERINC_DOWNLOADS_DOWNLOADS_MENUITEM = "Downloads";
	L_HEADERINC_ALLPRODUCTS_LINK_TEXT = "http:////www.microsoft.com//isapi//gomscom.asp?target=//catalog//default.asp?subid=22";
	L_HEADERINC_ALL_PRODUCTS_MENUITEM = "All Products";
	L_HEADERINC_TOP10STATUS_LINK_TEXT = "Transaction status";
	L_HEADER_INC_TITLE_PAGETITLE = "Windows Online Crash Analysis";
	L_HEADERINC_ALINK_HOME_MENUITEM = "Home";
	L_HEADERINC_ALINK_HOME2_MENUITEM = "XML Reporting Tools";
	L_HEADERINC_ALINK_SUBMITREPORT_MENUITEM = "Submit Report";
	L_HEADERINC_ALINK_CHECKSTATUS_MENUITEM = "Status";
	L_HEADERINC_ALINK_RESOURCES_MENUITEM = "Resources";
	L_HEADERINC_ALINK_PRIVACY_MENUITEM = "Privacy";
	L_HEADERINC_ALINK_FEEDBACK_MENUITEM = "Feedback";
	L_HEADERINC_ALINK_FAQ_MENUITEM = "FAQ";
	L_HEADERINC_ALINK_SIGNIN_MENUITEM = "Sign-in with your Passport";
	L_HEADERINC_IMAGE_ALT_TOOLTIP = "Windows Online Crash Analysis home page";
	L_HEADERINC_ALINK_MICROSOFT_MENUITEM = "http:////www.microsoft.com";
	L_HEADERINC_TITLE_OCAHOME_TOOLTIP = "Windows Online Crash Analysis home page";
	L_HEADERINC_TITLE_CERHOME_TOOLTIP = "Corporate Error Reporting home page";
	L_HEADERINC_TITLE_WORLDHOME_TOOLTIP = "Windows Online Crash Analysis Worldwide home page";
	L_HEADERINC_IMAGES_BANNER_TEXT = "http:////www.microsoft.com//library//toolbar//images//banner.gif";
	L_HEADERINC_ISAPI_HOME_MENUITEM = "//isapi//gomscom.asp?target=//";
	L_HEADERINC_MICROSOFT_HOME_MENUITEM = "Microsoft Home";
	
	
	////'-------------------------End-------------------------

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\xmlreports\versiontotal.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.SqlClient;


namespace XReports
{
	/// <summary>
	/// Summary description for versiontotal1.
	/// </summary>
	public class versiontotal1 : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Table tblUploads;

		private void Page_Load(object sender, System.EventArgs e)
		{
			SqlConnection cn = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TimRagain06");
			SqlCommand cm = new SqlCommand();
			SqlDataReader dr;
			DateTime dDate = DateTime.Now;
			int rowCtr=0;
			int cellCtr=0;
			int cellCnt = 3;
				cn.Open();
				cm.CommandType = CommandType.StoredProcedure;
				cm.CommandTimeout = 240;
				cm.CommandText = "spVersionTotal";
				cm.Connection = cn;
				dr = cm.ExecuteReader();
				//			dr.Read();
				//for(rowCtr=0; rowCtr <= rowCnt; rowCtr++) 
				do
				{
					TableRow tRow = new TableRow();
					tblUploads.Rows.Add(tRow);

					for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
					{
						TableCell tCell = new TableCell();

						if(rowCtr == 0)
						{
							switch(cellCtr)
							{
								case 1 :
									tCell.Text = "Total";
									break;
								case 2 :
									tCell.Text = "OS Name";
									break;
								case 3 :
									tCell.Text = "OS Version";
									break;
								default:
									tCell.Text = "";
									break;
							
							}
							tCell.Style["font-size"] = "small";

						}
						else
						{
							switch(cellCtr)
							{
								case 1 :
									tCell.Text = dr.GetInt32(0).ToString();
									break;
								case 2 :
									tCell.Text = dr.GetString(1);
									break;
								case 3 :
									tCell.Text = dr.GetString(2);
									break;
								default:
									tCell.Text = "0";
									break;
							
							}
							tCell.Style["background-color"] = "white";
							tCell.Style["font-size"] = "small-x";
							tCell.Style["color"] = "#6487dc";
							tCell.Style["font-weight"] = "Bold";
							
						}
						tCell.Style["font-family"] = "Tahoma";
						tRow.Cells.Add(tCell);
					}
					rowCtr++;
				}while(dr.Read() == true);
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\centralfmsvc\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\centralfmsvc\centralfmsvc.cpp ===
// CentralFMSvc.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f CentralFMSvcps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "CentralFMSvc.h"

#include "CentralFMSvc_i.c"
#include <mqoai.h>
#include <mq.h>
#include <TCHAR.h>
#include <Rpcdce.h>
#include <stdio.h>
//#include <mq.h>

//#import "d:\\windows\\system32\\mqoa.dll" no_namespace
CServiceModule _Module;

HANDLE  g_hStopEvent = NULL;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

// Although some of these functions are big they are declared inline since they are only used once

inline HRESULT CServiceModule::RegisterServer(BOOL bRegTypeLib, BOOL bService)
{
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Remove any previous service since it may point to
    // the incorrect file
    Uninstall();

    // Add service entries
    UpdateRegistryFromResource(IDR_CentralFMSvc, TRUE);

    // Adjust the AppID for Local Server or Service
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_WRITE);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    CRegKey key;
    lRes = key.Open(keyAppID, _T("{4E27CC20-0519-4E8C-BFF1-03C0F14DCDDA}"), KEY_WRITE);
    if (lRes != ERROR_SUCCESS)
        return lRes;
    key.DeleteValue(_T("LocalService"));
    
    if (bService)
    {
        key.SetValue(_T("CentralFMSvc"), _T("LocalService"));
        key.SetValue(_T("-Service"), _T("ServiceParameters"));
        // Create service
        Install();
    }

    // Add object entries
    hr = CComModule::RegisterServer(bRegTypeLib);

    CoUninitialize();
    return hr;
}

inline HRESULT CServiceModule::UnregisterServer()
{
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Remove service entries
    UpdateRegistryFromResource(IDR_CentralFMSvc, FALSE);
    // Remove service
    Uninstall();
    // Remove object entries
    CComModule::UnregisterServer(TRUE);
    CoUninitialize();
    return S_OK;
}

inline void CServiceModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid)
{
    CComModule::Init(p, h, plibid);

    m_bService = TRUE;

    LoadString(h, nServiceNameID, m_szServiceName, sizeof(m_szServiceName) / sizeof(TCHAR));

    // set up the initial service status 
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

	g_hStopEvent = CreateEvent(
        NULL,
        FALSE,
        FALSE,
        s_cszStopEvent
        );
    if(NULL == g_hStopEvent)
    {
        LogEvent( _T("Failed to create: %s; hr=%ld"),
            s_cszStopEvent,
            GetLastError());
    }
}

LONG CServiceModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0 && !m_bService)
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
    return l;
}

BOOL CServiceModule::IsInstalled()
{
    BOOL bResult = FALSE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM != NULL)
    {
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
        if (hService != NULL)
        {
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }
        ::CloseServiceHandle(hSCM);
    }
    return bResult;
}

inline BOOL CServiceModule::Install()
{
    if (IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
    {
        MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
    }

    // Get the executable file path
    TCHAR szFilePath[_MAX_PATH];
    ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);

     SC_HANDLE hService = ::CreateService(
        hSCM, m_szServiceName, m_szServiceName,
        SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
        SERVICE_AUTO_START, SERVICE_ERROR_NORMAL,
        szFilePath, NULL, NULL, _T("RPCSS\0"), NULL, NULL);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, _T("Couldn't create service"), m_szServiceName, MB_OK);
        return FALSE;
    }
	SERVICE_FAILURE_ACTIONS Failure;
	SC_ACTION Actions[3];

	Failure.cActions = 3;
	Failure.dwResetPeriod = 1200;
	Failure.lpCommand = _T("");
	Failure.lpRebootMsg = _T("");
	Failure.lpsaActions = Actions;

	Actions[0].Delay = 2000;
	Actions[0].Type = SC_ACTION_RESTART;

	Actions[1].Delay = 2000;
	Actions[1].Type = SC_ACTION_RESTART;

	Actions[2].Delay = 2000;
	Actions[2].Type = SC_ACTION_RESTART;

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);
    return TRUE;
}

inline BOOL CServiceModule::Uninstall()
{
    if (!IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM == NULL)
    {
        MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
    }

    SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_STOP | DELETE);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, _T("Couldn't open service"), m_szServiceName, MB_OK);
        return FALSE;
    }
    SERVICE_STATUS status;
    ::ControlService(hService, SERVICE_CONTROL_STOP, &status);

    BOOL bDelete = ::DeleteService(hService);
    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);

    if (bDelete)
        return TRUE;

    MessageBox(NULL, _T("Service could not be deleted"), m_szServiceName, MB_OK);
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////////////
// Logging functions
void CServiceModule::LogEvent(LPCTSTR pFormat, ...)
{
    TCHAR    chMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[1];
    va_list pArg;

    va_start(pArg, pFormat);
    _vstprintf(chMsg, pFormat, pArg);
    va_end(pArg);

    lpszStrings[0] = chMsg;

    if (m_bService)
    {
        /* Get a handle to use with ReportEvent(). */
        hEventSource = RegisterEventSource(NULL, m_szServiceName);
        if (hEventSource != NULL)
        {
            /* Write to event log. */
            ReportEvent(hEventSource, EVENTLOG_INFORMATION_TYPE, 0, 0, NULL, 1, 0, (LPCTSTR*) &lpszStrings[0], NULL);
            DeregisterEventSource(hEventSource);
        }
    }
    else
    {
        // As we are not running as a service, just write the error to the console.
        _putts(chMsg);
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Service startup and registration
inline void CServiceModule::Start()
{
    SERVICE_TABLE_ENTRY st[] =
    {
        { m_szServiceName, _ServiceMain },
        { NULL, NULL }
    };
    if (m_bService && !::StartServiceCtrlDispatcher(st))
    {
        m_bService = FALSE;
    }
    if (m_bService == FALSE)
        Run();
}

inline void CServiceModule::ServiceMain(DWORD /* dwArgc */, LPTSTR* /* lpszArgv */)
{
    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;
    m_hServiceStatus = RegisterServiceCtrlHandler(m_szServiceName, _Handler);
    if (m_hServiceStatus == NULL)
    {
        LogEvent(_T("Handler not installed"));
        return;
    }
    SetServiceStatus(SERVICE_START_PENDING);

    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    // When the Run function returns, the service has stopped.
    Run();

    SetServiceStatus(SERVICE_STOPPED);
    LogEvent(_T("Service stopped"));
}

inline void CServiceModule::Handler(DWORD dwOpcode)
{
    switch (dwOpcode)
    {
    case SERVICE_CONTROL_STOP:
        SetServiceStatus(SERVICE_STOP_PENDING);
		if(NULL != g_hStopEvent)
        {
            if(FALSE == SetEvent( g_hStopEvent ))
            {
                LogEvent( _T("Unable to signal Stop Event; Error: %ld"), GetLastError());
            }

            CloseHandle( g_hStopEvent );
        }
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
        break;
    case SERVICE_CONTROL_PAUSE:
        break;
    case SERVICE_CONTROL_CONTINUE:
        break;
    case SERVICE_CONTROL_INTERROGATE:
        break;
    case SERVICE_CONTROL_SHUTDOWN:
        break;
    default:
        LogEvent(_T("Bad service request"));
    }
}

void WINAPI CServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}
void WINAPI CServiceModule::_Handler(DWORD dwOpcode)
{
    _Module.Handler(dwOpcode); 
}

void CServiceModule::SetServiceStatus(DWORD dwState)
{
    m_status.dwCurrentState = dwState;
    ::SetServiceStatus(m_hServiceStatus, &m_status);
}

void CServiceModule::Run()
{
	BYTE *byteVersionBuff;
	VS_FIXEDFILEINFO *pVersionInfo;
	UINT uLength;
    _Module.dwThreadID = GetCurrentThreadId();

    HRESULT hr = CoInitialize(NULL);
//  If you are running on NT 4.0 or higher you can use the following call
//  instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
//  HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    _ASSERTE(SUCCEEDED(hr));

    // This provides a NULL DACL which will allow access to everyone.
    CSecurityDescriptor sd;
    sd.InitializeFromThreadToken();
    hr = CoInitializeSecurity(sd, -1, NULL, NULL,
        RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
    _ASSERTE(SUCCEEDED(hr));

    hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE);
    _ASSERTE(SUCCEEDED(hr));

    TCHAR szFilePath[_MAX_PATH];
    ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);
	DWORD dwBufferSize = GetFileVersionInfoSize(szFilePath,0);
	byteVersionBuff = (BYTE*) malloc (dwBufferSize);

	GetFileVersionInfo(szFilePath,NULL,dwBufferSize,byteVersionBuff);
	VerQueryValue(byteVersionBuff,_T("\\"),(VOID **) &pVersionInfo, &uLength);

    LogEvent(_T("CentralFileMover service version: %d.%d.%d.%d  Started."), HIWORD (pVersionInfo->dwFileVersionMS),LOWORD(pVersionInfo->dwFileVersionMS) 
						,HIWORD(pVersionInfo->dwFileVersionLS),LOWORD(pVersionInfo->dwFileVersionLS)) ;

    if (m_bService)
        SetServiceStatus(SERVICE_RUNNING);

	//
	// Execute Archive Service
	//
	try
	{
		FMMain();
	}
	catch(...)
	{
		 LogEvent( _T("CentralFilemover Service CRASHED !!! "));
	}

    MSG msg;
    while (GetMessage(&msg, 0, 0, 0))
        DispatchMessage(&msg);

    _Module.RevokeClassObjects();

    CoUninitialize();
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
    _Module.Init(ObjectMap, hInstance, IDS_SERVICENAME, &LIBID_CENTRALFMSVCLib);
    _Module.m_bService = TRUE;

    TCHAR szTokens[] = _T("-/");

    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
            return _Module.UnregisterServer();

        // Register as Local Server
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
            return _Module.RegisterServer(TRUE, FALSE);
        
        // Register as Service
        if (lstrcmpi(lpszToken, _T("Service"))==0)
            return _Module.RegisterServer(TRUE, TRUE);
        
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    // Are we Service or Local Server
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    CRegKey key;
    lRes = key.Open(keyAppID, _T("{4E27CC20-0519-4E8C-BFF1-03C0F14DCDDA}"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    TCHAR szValue[_MAX_PATH];
    DWORD dwLen = _MAX_PATH;
    lRes = key.QueryValue(szValue, _T("LocalService"), &dwLen);

    _Module.m_bService = FALSE;
    if (lRes == ERROR_SUCCESS)
        _Module.m_bService = TRUE;

    _Module.Start();

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}



BOOL CServiceModule::GetRegData(DWORD *Interval, TCHAR *SourceDir, TCHAR *ArchiveDir, TCHAR *MQConnectionString)
{

	HKEY hHKLM;
	HKEY hArchiveKey;
	BYTE Buffer[MAX_PATH + 1];
	DWORD Type;
	DWORD BufferSize = MAX_PATH +1;	// Set for largest value
	
	if(!RegConnectRegistry(NULL, HKEY_LOCAL_MACHINE, &hHKLM))
	{
		if(!RegOpenKeyEx(hHKLM,_T("Software\\Microsoft\\CentralFMService"), 0, KEY_ALL_ACCESS, &hArchiveKey))
		{
			// Get the input queue directory path
			if (RegQueryValueEx(hArchiveKey,_T("SourceDir"), 0, &Type, Buffer, &BufferSize) != ERROR_SUCCESS)
			{
				LogEvent(_T("Failed to get InputQueue value from registry. Useing c:\\ as the default"));
			}
			else
			{
				_tcscpy (SourceDir, (TCHAR *) Buffer);
				BufferSize = MAX_PATH +1;
				ZeroMemory(Buffer, BufferSize);
			}

			// Now get the Win2kDSN 
			RegQueryValueEx(hArchiveKey,_T("ArchiveDir"), 0, &Type, Buffer, &BufferSize);
			_tcscpy(ArchiveDir, (TCHAR *) Buffer);

			BufferSize = MAX_PATH +1;
			ZeroMemory(Buffer, BufferSize);

			// Now get the MSMQ Connection String 
			RegQueryValueEx(hArchiveKey,_T("MQConnectionString"), 0, &Type, Buffer, &BufferSize);
			_tcscpy(MQConnectionString, (TCHAR *) Buffer);

			BufferSize = MAX_PATH +1;
			ZeroMemory(Buffer, BufferSize);

			// Get the sleep interval
			RegQueryValueEx(hArchiveKey,_T("Interval"), 0, &Type, Buffer, &BufferSize);
			*Interval = (DWORD)Buffer[0];
		
			RegCloseKey(hHKLM);
			RegCloseKey(hArchiveKey);
			return TRUE;
		}
		else
		{	RegCloseKey(hHKLM);
			return FALSE;
		}
	}
	else
		return FALSE;

}

BOOL CServiceModule::FMMain()
{

	
	HANDLE hFind = INVALID_HANDLE_VALUE;
	TCHAR  SourceDir[MAX_PATH];
	TCHAR  SearchPath[MAX_PATH];
	TCHAR  ArchiveDir[MAX_PATH];
	TCHAR  ArchivePath[MAX_PATH];
	TCHAR  SourceFile[MAX_PATH];
	TCHAR  MQConnectionString[MAX_PATH];
	WIN32_FIND_DATA FindData;
	DWORD Interval = 0;
	TCHAR CurrentDate[100];
	HRESULT  hresult;
	HANDLE hStopEvent = NULL;
	SYSTEMTIME systime;
	QUEUEHANDLE	hOutgoingQueue;
	BOOL OkToContinue = TRUE;
	const int NUMBEROFPROPERTIES = 5;                   // Number of properties.

	MQMSGPROPS		msgProps;
	MSGPROPID		aMsgPropId[NUMBEROFPROPERTIES];
	MQPROPVARIANT	aMsgPropVar[NUMBEROFPROPERTIES];
	HRESULT			aMsgStatus[NUMBEROFPROPERTIES];
	DWORD			cPropId = 0; 


	ZeroMemory (&FindData, sizeof(WIN32_FIND_DATA));

	hStopEvent = OpenEvent(
                EVENT_ALL_ACCESS,
                FALSE,
                s_cszStopEvent
                );

	if (hStopEvent == NULL)
	{
		LogEvent(_T("Failed to open stop event"));
		goto done;
	}

	
	LogEvent(_T("Get Reg Data"));
	//Get reg Data
	GetRegData(&Interval, SourceDir, ArchiveDir, MQConnectionString);

	LogEvent (_T("Obtained reg data: Interval:%d SourceDir:%s ArchiveDir: %s"), Interval,SourceDir,ArchiveDir);
	
	// Connect to the queue
  // pqinfo->PathName = _T(".\\PRIVATE$\\FileQueue700");
   // pqinfo->ServiceTypeGuid=L"{c30e0960-a2c0-11cf-9785-00608cb3e80c}";
 
 
		//pqinfo->Create();
		hresult = MQOpenQueue(MQConnectionString,
						 MQ_SEND_ACCESS,
						 MQ_DENY_NONE,
						 &hOutgoingQueue);


   
    if (FAILED(hresult))
    {
		LogEvent(_T("Unable to connect to message queue: %s"), MQConnectionString);
    }

	while (1)
	{
		// Build SearchPath
		_stprintf(SearchPath, _T("%s\\*.cab"), SourceDir);
		

		//Find file loop start
		hFind = FindFirstFile(SearchPath, &FindData);
		if (hFind != INVALID_HANDLE_VALUE)
		{
		
			do
			{
				if ( ! (FindData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
				{	
					if(WAIT_OBJECT_0 == WaitForSingleObject( hStopEvent, 10))
					{
						FindClose(hFind);
						LogEvent( _T("Stop Event received. Terminating Central FM  Service") );
						goto done;
					}
					//Get Current Date
					GetLocalTime(&systime);
					_stprintf(CurrentDate,_T("%0d-%0d-%0d"),systime.wMonth,systime.wDay,systime.wYear);
					_stprintf(SourceFile, _T("%s\\%s"), SourceDir, FindData.cFileName);
					//build archive path
					_stprintf (ArchivePath, _T("%s\\%s"), ArchiveDir, CurrentDate);
					if (!PathIsDirectory(ArchivePath))
					{
						
						CreateDirectory(ArchivePath,NULL);
					
					}

					
					_stprintf (ArchivePath, _T("%s\\%s\\%s"), ArchiveDir, CurrentDate, FindData.cFileName+2);
					//Move File to Archive Path
				    if (CopyFile(SourceFile, ArchivePath, FALSE))
					{
						//Add file Path to MSMG
				
							
							
  
  	
						////////////////////////////////////////////////////////////
						// Send message.
						////////////////////////////////////////////////////////////
										
					
						// Specify the message properties to be sent.
						aMsgPropId [cPropId]		 = PROPID_M_LABEL;    // Property ID.
						aMsgPropVar[cPropId].vt		 = VT_LPWSTR;         // Type indicator.
						aMsgPropVar[cPropId].pwszVal = L"FilePath";     // The message label.
						cPropId++;

						aMsgPropId [cPropId]		 = PROPID_M_BODY;
						aMsgPropVar [cPropId].vt	 = VT_VECTOR|VT_UI1;  
						aMsgPropVar [cPropId].caub.pElems = (LPBYTE) ArchivePath;
						aMsgPropVar [cPropId].caub.cElems = wcslen(ArchivePath) * sizeof wchar_t;
						cPropId++;

						aMsgPropId [cPropId]		 = PROPID_M_BODY_TYPE;
						aMsgPropVar[cPropId].vt      = VT_UI4;
						aMsgPropVar[cPropId].ulVal   = (DWORD) VT_BSTR;

						cPropId++;
						
						

						// Initialize the MQMSGPROPS structure.
						msgProps.cProp		= cPropId;    
						msgProps.aPropID	= aMsgPropId;
						msgProps.aPropVar	= aMsgPropVar;
						msgProps.aStatus	= aMsgStatus;
						

						// Send it 

						
						
						hresult = MQSendMessage(
										 hOutgoingQueue,                          // Queue handle.
										 &msgProps,                       // Message property structure.
										 MQ_NO_TRANSACTION               // No transaction.
										 );
						if (FAILED(hresult))
						{
							LogEvent(_T("Failed to send Message"));
						}
					


						////////////////////////////////////////////////////////////
						// Close queue.
						////////////////////////////////////////////////////////////
					//	qSend->Close();

						// Delete the local file
						if (!DeleteFile(SourceFile))
						{
							LogEvent(_T("Unable to delete file: %s"), SourceFile);
						}
					}
						
					

					
					else
					{
						// The server is down what do we want to do here
						while (!OkToContinue)
						{
							LogEvent(_T("The Archive Path: %s is unreachable Sleeping for 1 minute."),ArchivePath);
							goto done;
						}
					}
				}
				
			}while (FindNextFile(hFind, &FindData));
			
			MQCloseQueue(hOutgoingQueue);
			FindClose(hFind);
			ZeroMemory (&FindData, sizeof(WIN32_FIND_DATA));	
		}
	
		if(WAIT_OBJECT_0 == WaitForSingleObject( hStopEvent, Interval*60*1000))
		{
			FindClose(hFind);
			LogEvent( _T("Stop Event received. Terminating Central FM  Service") );
			goto done;
		}
		//End File Loop
	}
done:
	CloseHandle(hStopEvent);
	return TRUE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\centralfmsvc\centralfmsvc.h ===
/* this ALWAYS GENERATED file contains the definitions for the interfaces */


/* File created by MIDL compiler version 5.01.0164 */
/* at Fri Nov 16 15:58:57 2001
 */
/* Compiler settings for E:\bluescreen\main\ENU\CentralFMSvc\CentralFMSvc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __CentralFMSvc_h__
#define __CentralFMSvc_h__

#ifdef __cplusplus
extern "C"{
#endif 

/* Forward Declarations */ 

/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __CENTRALFMSVCLib_LIBRARY_DEFINED__
#define __CENTRALFMSVCLib_LIBRARY_DEFINED__

/* library CENTRALFMSVCLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_CENTRALFMSVCLib;
#endif /* __CENTRALFMSVCLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\centralfmsvc\centralfmsvc_i.c ===
/* this file contains the actual definitions of */
/* the IIDs and CLSIDs */

/* link this file in with the server and any clients */


/* File created by MIDL compiler version 5.01.0164 */
/* at Fri Nov 16 15:58:57 2001
 */
/* Compiler settings for E:\bluescreen\main\ENU\CentralFMSvc\CentralFMSvc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32, ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
*/
//@@MIDL_FILE_HEADING(  )
#ifdef __cplusplus
extern "C"{
#endif 


#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

const IID LIBID_CENTRALFMSVCLib = {0x371F60A0,0x3B6B,0x44BE,{0x93,0x38,0x22,0x88,0xE4,0x56,0x70,0xD3}};


#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\xmlreports\xcounts.aspx.cs ===
using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Drawing;
using System.Web;
using System.Web.SessionState;
using System.Web.UI;
using System.Web.UI.WebControls;
using System.Web.UI.HtmlControls;
using System.Data.SqlClient;



namespace XReports
{
	/// <summary>
	/// Summary description for xcounts.
	/// </summary>
	public class xcounts : System.Web.UI.Page
	{
		protected System.Web.UI.WebControls.Table tblUploads;
		protected System.Web.UI.WebControls.Calendar Calendar1;
	
		private void Page_Load(object sender, System.EventArgs e)
		{
			SqlConnection cn = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TimRagain06");
			SqlCommand cm = new SqlCommand();
			SqlDataReader dr;
			int rowCtr=0;
			int cellCtr=0;
			int cellCnt = 2;
			double dbDays = -7;
			DateTime dDate = DateTime.Now;

			if(Page.IsPostBack == false)
			{
				cn.Open();
				cm.CommandType = CommandType.StoredProcedure;
				cm.CommandTimeout = 240;
				cm.CommandText = "WeeklyCountsByDates";
				cm.Parameters.Add("@sDate", System.Data.SqlDbType.VarChar, 12);
				dDate = dDate.AddDays(dbDays);
				cm.Parameters[0].Value = dDate.ToShortDateString();
				cm.Connection = cn;
				dr = cm.ExecuteReader();
				Calendar1.SelectedDate = dDate;
//				dr.Read();
				do
				{
					TableRow tRow = new TableRow();
					tblUploads.Rows.Add(tRow);

					for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
					{
						TableCell tCell = new TableCell();

						if(rowCtr == 0)
						{
							switch(cellCtr)
							{
								case 1 :
									tCell.Text = "Total";
									break;
								case 2 :
									tCell.Text = "Date";
									break;
								default:
									tCell.Text = "";
									break;
							
							}
							tCell.Style["font-size"] = "small";
							tCell.Height = 20;

						}
						else
						{
							switch(cellCtr)
							{
								case 1 :
									tCell.Text = dr.GetInt32(0).ToString();
									break;
								case 2 :
									if(dr.IsDBNull(0))
									{
										tCell.Text = "";
									}
									else
									{
										tCell.Text = dr.GetDateTime(1).ToShortDateString();
									}
									break;
								default:
									tCell.Text = "0";
									break;
							
							}
							tCell.Style["background-color"] = "white";
							tCell.Style["font-size"] = "small-x";
							tCell.Style["color"] = "#6487dc";
							tCell.Style["font-weight"] = "Bold";
							tCell.Height = 20;
							
						}
						tCell.Style["font-family"] = "Tahoma";
						tRow.Cells.Add(tCell);
					}
					rowCtr++;
				}while(dr.Read() == true);	
			}
		}

		#region Web Form Designer generated code
		override protected void OnInit(EventArgs e)
		{
			//
			// CODEGEN: This call is required by the ASP.NET Web Form Designer.
			//
			InitializeComponent();
			base.OnInit(e);
		}
		
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{    
			this.Calendar1.VisibleMonthChanged += new System.Web.UI.WebControls.MonthChangedEventHandler(this.Calendar1_VisibleMonthChanged);
			this.Calendar1.SelectionChanged += new System.EventHandler(this.Calendar1_SelectionChanged);
			this.Load += new System.EventHandler(this.Page_Load);

		}
		#endregion

		private void Calendar1_SelectionChanged(object sender, System.EventArgs e)
		{
			SqlConnection cn = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TimRagain06");
			SqlCommand cm = new SqlCommand();
			SqlDataReader dr;
			DateTime dDate = DateTime.Now;
			int rowCtr=0;
			int cellCtr=0;
			int cellCnt = 2;

			cn.Open();
			cm.CommandType = CommandType.StoredProcedure;
			cm.CommandTimeout = 240;
			cm.CommandText = "WeeklyCountsByDates";
			cm.Parameters.Add("@sDate", System.Data.SqlDbType.VarChar, 12);
			dDate = Calendar1.SelectedDate;
			cm.Parameters[0].Value = dDate.ToShortDateString();
			cm.Connection = cn;
			dr = cm.ExecuteReader();
			//dr.Read();
			
			do
			{
				TableRow tRow = new TableRow();
				tblUploads.Rows.Add(tRow);

				for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
				{
					TableCell tCell = new TableCell();

					if(rowCtr == 0)
					{
						switch(cellCtr)
						{
							case 1 :
								tCell.Text = "Total";
								break;
							case 2 :
								tCell.Text = "Date";
								break;
							default:
								tCell.Text = "";
								break;
						
						}
						tCell.Style["font-size"] = "small";
						tCell.Height = 20;

					}
					else
					{
						switch(cellCtr)
						{
							case 1 :
								tCell.Text = dr.GetInt32(0).ToString();
								break;
							case 2 :
								if(dr.IsDBNull(0))
								{
									tCell.Text = "";
								}
								else
								{
									tCell.Text = dr.GetDateTime(1).ToShortDateString();
								}
								break;
							default:
								tCell.Text = "0";
								break;
						
						}
						tCell.Style["background-color"] = "white";
						tCell.Style["font-size"] = "small-x";
						tCell.Style["color"] = "#6487dc";
						tCell.Style["font-weight"] = "Bold";
						tCell.Height = 20;
						
					}
					tCell.Style["font-family"] = "Tahoma";
					tRow.Cells.Add(tCell);
				}
				rowCtr++;
			}while(dr.Read() == true);		


		}

		private void Calendar1_VisibleMonthChanged(object sender, System.Web.UI.WebControls.MonthChangedEventArgs e)
		{
			SqlConnection cn = new SqlConnection("Persist Security Info=False;Pwd=ocarpts@2;User ID=ocarpts;Initial Catalog=SnapShot;Data Source=TimRagain06");
			SqlCommand cm = new SqlCommand();
			SqlDataReader dr;
			DateTime dDate = DateTime.Now;
			int rowCtr=0;
			int cellCtr=0;
			int cellCnt = 2;

			cn.Open();
			cm.CommandType = CommandType.StoredProcedure;
			cm.CommandTimeout = 240;
			cm.CommandText = "WeeklyCountsByDates";
			cm.Parameters.Add("@sDate", System.Data.SqlDbType.VarChar, 12);
			dDate = Calendar1.SelectedDate;
			cm.Parameters[0].Value = dDate.ToShortDateString();
			cm.Connection = cn;
			dr = cm.ExecuteReader();
			//dr.Read();
			
			do
			{
				TableRow tRow = new TableRow();
				tblUploads.Rows.Add(tRow);

				for (cellCtr = 1; cellCtr <= cellCnt; cellCtr++) 
				{
					TableCell tCell = new TableCell();

					if(rowCtr == 0)
					{
						switch(cellCtr)
						{
							case 1 :
								tCell.Text = "Total";
								break;
							case 2 :
								tCell.Text = "Date";
								break;
							default:
								tCell.Text = "";
								break;
						
						}
						tCell.Style["font-size"] = "small";
						tCell.Height = 20;

					}
					else
					{
						switch(cellCtr)
						{
							case 1 :
								tCell.Text = dr.GetInt32(0).ToString();
								break;
							case 2 :
								if(dr.IsDBNull(0))
								{
									tCell.Text = "";
								}
								else
								{
									tCell.Text = dr.GetDateTime(1).ToShortDateString();
								}
								break;
							default:
								tCell.Text = "0";
								break;
						
						}
						tCell.Style["background-color"] = "white";
						tCell.Style["font-size"] = "small-x";
						tCell.Style["color"] = "#6487dc";
						tCell.Style["font-weight"] = "Bold";
						tCell.Height = 20;
						
					}
					tCell.Style["font-family"] = "Tahoma";
					tRow.Cells.Add(tCell);
				}
				rowCtr++;
			}while(dr.Read() == true);		
		}
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\dbglauncher\quereader.h ===
#include "stdafx.h"

class CMessageQueue 
{
private:
	// data items for reading messages from a queue
public:
	GetNextMessage(TCHAR *szFilePath);
	Initialize(TCHAR *ConnectionString);
	CMessageQueue() {;}
	~CMessageQueue() {;}
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\dbglauncher\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by DBGLauncher.rc
//
#define IDS_SERVICENAME 100

#define IDR_DBGLauncher		100


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\centralfmsvc\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by CentralFMSvc.rc
//
#define IDS_SERVICENAME 100

#define IDR_CentralFMSvc		100


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\dbglauncher\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\centralfmsvc\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__45E0CB04_09E8_49C7_9D4D_EFB99DA65BD5__INCLUDED_)
#define AFX_STDAFX_H__45E0CB04_09E8_49C7_9D4D_EFB99DA65BD5__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

class CServiceModule : public CComModule
{
public:
	HRESULT RegisterServer(BOOL bRegTypeLib, BOOL bService);
	HRESULT UnregisterServer();
	void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid = NULL);
    void Start();
	void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    void Handler(DWORD dwOpcode);
    void Run();
    BOOL IsInstalled();
    BOOL Install();
    BOOL Uninstall();
	LONG Unlock();
	void LogEvent(LPCTSTR pszFormat, ...);
    void SetServiceStatus(DWORD dwState);
    void SetupAsLocalServer();
	BOOL FMMain();
	BOOL GetRegData(DWORD *Interval, TCHAR *SourceDir, TCHAR *ArchiveDir, TCHAR *MQConnectionString);
	
//Implementation
private:
	static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static void WINAPI _Handler(DWORD dwOpcode);

// data members
public:
    TCHAR m_szServiceName[256];
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
	DWORD dwThreadID;
	BOOL m_bService;
};
#define s_cszStopEvent   _T("CentralFilemover_Event") 
extern CServiceModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__45E0CB04_09E8_49C7_9D4D_EFB99DA65BD5__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\xmlreports\top.inc ===
<!--#include file="headerstrings.inc"-->
<script LANGUAGE="javascript">
<!--
	var headerinctitleworldhometooltip = "<% = L_HEADERINC_TITLE_WORLDHOME_TOOLTIP %>";
	var headerincimagealttooltip = "<% = L_HEADERINC_IMAGE_ALT_TOOLTIP %>";
	var headerincalinkmicrosoftmenuitem = "<% = L_HEADERINC_ALINK_MICROSOFT_MENUITEM %>";
	var headerincalinkhomemenuitem = "<% = L_HEADERINC_ALINK_HOME2_MENUITEM %>";
	var headerincalinkcermenuitem = "<% = L_HEADERINC_ALINK_CER_MENUITEM %>";
	var headerincalinkworldmenuitem = "<% = L_HEADERINC_ALINK_WORLD_MENUITEM %>";
	var headertitleocahometooltip = "<% = L_HEADERINC_TITLE_OCAHOME_TOOLTIP %>";
	var headerinctitlecerhometooltip = "<% = L_HEADERINC_TITLE_CERHOME_TOOLTIP %>";
	var headerimagesbannertext = "<% = L_HEADERINC_IMAGES_BANNER_TEXT%>";
	var headerisapihomemenuitem = "<% = L_HEADERINC_ISAPI_HOME_MENUITEM %>";
	var headerincmicrosofthomemenuitem = "<% = L_HEADERINC_MICROSOFT_HOME_MENUITEM %>";
	var heaerincallproductsmenuitem = "<% = L_HEADERINC_ALL_PRODUCTS_MENUITEM %>";
	var headerincallproductslinktext = "<% = L_HEADERINC_ALLPRODUCTS_LINK_TEXT %>";
	var headerincdownloadsdownloadsmenuitem = "<% = L_HEADERINC_DOWNLOADS_DOWNLOADS_MENUITEM %>";
	var headerincdownloadslinktext = "<% = L_HEADERINC_DOWNLOADS_LINK_TEXT %>";
	var headerincmsproductcatalogmenuitem = "<% = L_HEADERINC_MSPRODUCT_CATALOG_MENUITEM %>";
	var headerincmsproductcatalogtext = "<% = L_HEADERINC_MSPRODUCT_CATALOG_TEXT %>";
	var headerincmicrosoftaccessibilitymenuitem = "<% = L_HEADERINC_MICROSOFT_ACCESSIBILITY_MENUITEM %>";
	var headerincmicrosoftaccessibilitytext = "<% = L_HEADERINC_MICROSOFT_ACCESSIBILITY_TEXT %>";
	var headerincserverproductsmenuitem = "<% = L_HEADERINC_SERVER_PRODUCTS_MENUITEM %>";
	var headerincserverproductstext = "<% = L_HEADERINC_SERVER_PRODUCTS_TEXT %>";
	var headerincdevelopertoolsmenuitem = "<% = L_HEADERINC_DEVELOPER_TOOLS_MENUITEM %>";
	var headerincdevelopertoolstext = "<% = L_HEADERINC_DEVELOPER_TOOLS_TEXT %>";
	var headerincofficefamilymenuitem = "<% = L_HEADERINC_OFFICE_FAMILY_MENUITEM %>";
	var headerincofficefamilytext = "<% = L_HEADERINC_OFFICE_FAMILY_TEXT %>";
	var headerincwindowsfamilymenuitem = "<% = L_HEADERINC_WINDOWS_FAMILY_MENUITEM %>";
	var headerincwindowsfamilytext = "<% = L_HEADERINC_WINDOWS_FAMILY_TEXT %>";
	var headerincmsnlinkmenuitem = "<% = L_HEADERINC_MSN_LINK_MENUITEM %>";
	var headerincmsnlinktext = "<% = L_HEADERINC_MSN_LINK_TEXT %>";
	var headerincsupportlinkmenuitem = "<% = L_HEADERINC_SUPPORT_LINK_MENUITEM %>";
	var headerincsupportlinktext = "<% = L_HEADERINC_SUPPORT_LINK_TEXT %>";
	var headerincknowledgebasemenuitem = "<% = L_HEADERINC_KNOWLEDGE_BASE_MENUITEM %>";
	var headerincknowledgebasetext = "<% = L_HEADERINC_KNOWLEDGE_BASE_TEXT %>";
	var headerincproductsupportoptionsmenuitem = "<% = L_HEADERINC_PRODUCTSUPPORT_OPTIONS_MENUITEM %>";
	var headerincproductsupportoptionstext = "<% = L_HEADERINC_PRODUCTSUPPORT_OPTIONS_TEXT %>";
	var headerincservicepartnerreferralsmenuitem = "<% = L_HEADERINC_SERVICEPARTNER_REFERRALS_MENUITEM %>";
	var headerincservicepartnerreferralstext = "<% = L_HEADERINC_SERVICEPARTNER_REFERRALS_TEXT %>";
	var headerincsearchlinkmenuitem = "<% = L_HEADERINC_SEARCH_LINK_MENUITEM %>";
	var headerincsearchlinktext = "<% = L_HEADERINC_SEARCH_LINK_TEXT %>";
	var headerincsearchmicrosoftmenuitem = "<% = L_HEADERINC_SEARCH_MICROSOFT_MENUITEM %>";
	var headerincsearchmicrosofttext = "<% = L_HEADERINC_SEARCH_MICROSOFT_TEXT %>";
	var headerincmsnwebsearchmenuitem = "<% = L_HEADERINC_MSNWEB_SEARCH_MENUITEM %>";
	var headerincmsnwebsearchtext = "<% = L_HEADERINC_MSNWEB_SEARCH_TEXT %>";
	var headerincmicrosoftcomguidemenuitem = "<% = L_HEADERINC_MICROSOFTCOM_GUIDE_MENUITEM %>";
	var headerincmicrosoftcomguidetext = "<% = L_HEADERINC_MICROSOFTCOM_GUIDE_TEXT %>";
	var headerincmicrosoftcomhomemenuitem = "<% = L_HEADERINC_MICROSOFTCOM_HOME_MENUITEM %>";
	var headerincmicrosoftcomhometext = "<% = L_HEADERINC_MICROSOFTCOM_HOME_TEXT %>";
	var headerincmsnhomemenuitem = "<% = L_HEADERINC_MSN_HOME_MENUITEM %>";
	var headerincmsnhometext = "<% = L_HEADERINC_MSN_HOME_TEXT %>";
	var headerinccontactusmenuitem = "<% = L_HEADERINC_CONTACT_US_MENUITEM %>";
	var headerinccontactustext = "<% = L_HEADERINC_CONTACT_US_TEXT %>";
	var headerinceventslinkmenuitem = "<% = L_HEADERINC_EVENTS_LINK_MENUITEM %>";
	var headerinceventslinktext = "<% = L_HEADERINC_EVENTS_LINK_TEXT %>";
	var headerincnewsletterslinkmenuitem = "<% = L_HEADERINC_NEWSLETTERS_LINK_MENUITEM %>";
	var headerincnewsletterslinktext = "<% = L_HEADERINC_NEWSLETTERS_LINK_TEXT %>";
	var headerincprofilecentermenuitem = "<% = L_HEADERINC_PROFILE_CENTER_MENUITEM %>";
	var headerincprofilecentertext = "<% = L_HEADERINC_PROFILE_CENTER_TEXT %>";
	var headerinctrainingcertificationmenuitem = "<% = L_HEADERINC_TRAINING_CERTIFICATION_MENUITEM %>";
	var headerinctrainingcertificationtext = "<% = L_HEADERINC_TRAINING_CERTIFICATION_TEXT %>";
	var headerincfreemailaccountmenuitem = "<% = L_HEADERINC_FREEEMAIL_ACCOUNT_MENUITEM %>";
	var headerincfreemailaccounttext = "<% = L_HEADERINC_FREEEMAIL_ACCOUNT_TEXT %>";
	var headerincmicrosoftrightsreservedtext = "<% = L_HEADERINC_MICROSOFT_RIGHTSRESERVED_TEXT %>";
	var headerinctermsofusemenuitem = "<% = L_HEADERINC_TERMSOF_USE_MENUITEM %>";
	var headerinctermsofusetext = "<% = L_HEADERINC_TERMSOF_USE_TEXT %>";
	var headerincprivacystatementmenuitem = "<% = L_HEADERINC_PRIVACY_STATEMENT_MENUITEM %>";
	var headerincprivacystatementtext = "<% = L_HEADERINC_PRIVACY_STATEMENT_TEXT %>";
	var headerincaccessibilitylinkmenuitem = "<% = L_HEADERINC_ACCESSIBILITY_LINK_MENUITEM %>";
	var headerincaccessibilitylinktext = "<% = L_HEADERINC_ACCESSIBILITY_LINK_TEXT %>";
//-->
</script>

		<script language="JavaScript" src="toolbar.js"></script>
		<script language="JavaScript" src="globalMNP.js"></script>
		<script language="JavaScript" src="localMNP.js"></script>
		<script language="JavaScript">drawToolbar();</script>
		

								

		<script language="JavaScript">
		//spnTop.insertAdjacentHTML("beforeEnd", "<SPAN STYLE='font:" + cFont + ";color:" + cColor1 + "'>||&nbsp;</SPAN><Span style='position:absolute;top:0;right:5;height:20;width:100;'><center><span style='background-color:white'></span></center></span>");
		</script>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\dbglauncher\quereader.cpp ===
#include <Windows.h>
#include <objBase.h>
#include <stdio.h>
#include <mqoai.h> // MSMQ include file
// Existing code

//-----------------------------------------------------
//
// Check if local computer is DS enabled or DS disabled
//
//----------------------------------------------------- 
short DetectDsConnection(void)
{
    IMSMQApplication2 *pqapp = NULL;
    short fDsConnection;
    HRESULT hresult;

    hresult = CoCreateInstance(
                              CLSID_MSMQApplication,
                              NULL,      // punkOuter
                              CLSCTX_SERVER,
                              IID_IMSMQApplication2,
                              (LPVOID *)&pqapp);

    if (FAILED(hresult))
        PRINTERROR("Cannot create application", hresult);

    pqapp->get_IsDsEnabled(&fDsConnection);

    Cleanup:
    RELEASE(pqapp);
    return fDsConnection;
}


// Split this routine into initialize and get next file path
//--------------------------------------------------------
//
// Receiver Mode
// -------------
// The receiver side does the following:
//    1. Creates a queue on its given computer'
//       of type "guidMQTestType".
//    2. Opens the queue
//    3. In a Loop
//          Receives messages
//          Prints message body and message label
//          Launches debugger
//    4. Cleanup handles
//    5. Deletes the queue from the directory service
//
//--------------------------------------------------------
// rename this function to reciever
HRESULT CMessageQueue::Initialize(/* send connect params*/)
{
    IMSMQMessage *pmessageReceive = NULL;
    IMSMQQueue *pqReceive = NULL;
    IMSMQQueueInfo  *pqinfo = NULL;
    BSTR bstrPathName = NULL;
    BSTR bstrServiceType = NULL;
    BSTR bstrLabel = NULL;
    BSTR bstrMsgLabel = NULL;
    VARIANT varIsTransactional, varIsWorldReadable, varBody, varBody2, varWantDestQueue, varWantBody, varReceiveTimeout;
    WCHAR wcsPathName[1000];
    BOOL fQuit = FALSE;
    HRESULT hresult = NOERROR;

   /* printf("\nReceiver for queue %s on machine %s\nLimit memusage to %ld%%\n", 
           g_QueueName, 
           g_ServerMachine,
           g_MaxMemUsage);
*/
    //
    // Create MSMQQueueInfo object
    //
    hresult = CoCreateInstance(
                              CLSID_MSMQQueueInfo,
                              NULL,      // punkOuter
                              CLSCTX_SERVER,
                              IID_IMSMQQueueInfo,
                              (LPVOID *)&pqinfo);
    if (FAILED(hresult))
    {
        //PRINTERROR("Cannot create queue instance", hresult);
    }

    //
    // Prepare properties to create a queue on local machine
    //

    if (g_FormatName[0])
    {
        // access by formatname
        // Set the FormatName
        swprintf(wcsPathName, L"DIRECT=%S\\%S", g_FormatName,g_QueueName);

        //printf("Openeing q byt formatname: %ws\n", wcsPathName);
        bstrPathName = SysAllocString(wcsPathName);
        if (bstrPathName == NULL)
        {
          //  PRINTERROR("OOM: formatname", E_OUTOFMEMORY);
        }
        pqinfo->put_FormatName(bstrPathName);
    } else 
    {
        // access by pathname
        // Set the PathName
        swprintf(wcsPathName, L"%S\\%S", g_ServerMachine,g_QueueName);

        //printf("Openeing q %ws\n", wcsPathName);
        bstrPathName = SysAllocString(wcsPathName);
        if (bstrPathName == NULL)
        {
           // PRINTERROR("OOM: pathname", E_OUTOFMEMORY);
        }
        pqinfo->put_PathName(bstrPathName);
    }

    //
    // Set the type of the queue
    // (Will be used to locate all the queues of this type)
    //
    bstrServiceType = SysAllocString(strGuidMQTestType);
    if (bstrServiceType == NULL)
    {
        PRINTERROR("OOM: ServiceType", E_OUTOFMEMORY);
    }
    pqinfo->put_ServiceTypeGuid(bstrServiceType);

    //
    // Put a description to the queue
    // (Useful for administration through the MSMQ admin tools)
    //
    bstrLabel =
    SysAllocString(L"MSMQ for dumpfiles");
    if (bstrLabel == NULL)
    {
        //PRINTERROR("OOM: label ", E_OUTOFMEMORY);
    }
    pqinfo->put_Label(bstrLabel);

    //
    // specify if transactional
    //
    VariantInit(&varIsTransactional);
    varIsTransactional.vt = VT_BOOL;
    varIsTransactional.boolVal = MQ_TRANSACTIONAL_NONE;
    VariantInit(&varIsWorldReadable);
    varIsWorldReadable.vt = VT_BOOL;
    varIsWorldReadable.boolVal = FALSE;
    //
    // create the queue
    //
    if (g_CreateQ)
    {
        hresult = pqinfo->Create(&varIsTransactional, &varIsWorldReadable);
        if (FAILED(hresult))
        {
            //
            // API Fails, not because the queue exists
            //
            if (hresult != MQ_ERROR_QUEUE_EXISTS)
               // PRINTERROR("Cannot create queue", hresult);
        }
    }

    //
    // Open the queue for receive access
    //
    hresult = pqinfo->Open(MQ_RECEIVE_ACCESS,
                           MQ_DENY_NONE,
                           &pqReceive);

    //
    // Little bit tricky. MQCreateQueue succeeded but, in case 
    // it's a public queue, it does not mean that MQOpenQueue
    // will, because of replication delay. The queue is registered
    //  in MQIS, but it might take a replication interval
    // until the replica reaches the server I am connected to.
    // To overcome this, open the queue in a loop.
    //
    // (in this specific case, this can happen only if this
    //  program is run on a Backup Server Controller - BSC, or on
    //  a client connected to a BSC)
    // To be totally on the safe side, we should have put some code
    // to exit the loop after a few retries, but hey, this is just a sample.
    //
    while (hresult == MQ_ERROR_QUEUE_NOT_FOUND && iCurrentRetry < g_MaxRetry)
    {
       // printf(".");
        fflush(stdout);

        // Wait a bit
        Sleep(500);

        // And retry
        hresult = pqinfo->Open(MQ_RECEIVE_ACCESS,
                               MQ_DENY_NONE,
                               &pqReceive);
    }
    if (FAILED(hresult))
    {
       // PRINTERROR("Cannot open queue", hresult);
		//We sould stop here
    }

    g_DumpPath[0] = 0;

    //
    // Main receiver loop
    //
   // printf("\nWaiting for messages ...\n");
   // while (!fQuit)
 //   {
     //   MEMORYSTATUS stat;

	//--------------------------------------------------------------------------------------//
	//  this goes into GetNextFilePath()
	//--------------------------------------------------------------------------------------//
        ULONG nWaitCount;
        
        //
        // Receive the message
        //
        VariantInit(&varWantDestQueue);
        VariantInit(&varWantBody);
        VariantInit(&varReceiveTimeout);
        varWantDestQueue.vt = VT_BOOL;
        varWantDestQueue.boolVal = TRUE;    // yes we want the dest queue
        varWantBody.vt = VT_BOOL;
        varWantBody.boolVal = TRUE;         // yes we want the msg body
        varReceiveTimeout.vt = VT_I4;
        varReceiveTimeout.lVal = INFINITE;  // infinite timeout <--- This needs to be set to a reasonable value so that we 
											// can bounce between queues.
        hresult = pqReceive->Receive(
                                    NULL,
                                    &varWantDestQueue,
                                    &varWantBody,
                                    &varReceiveTimeout,
                                    &pmessageReceive);
        if (FAILED(hresult))
        {
           // PRINTERROR("Receive message", hresult);
			// we should stop here
        }

        //
        // Display the received message
        //
        pmessageReceive->get_Label(&bstrMsgLabel);
        VariantInit(&varBody);
        VariantInit(&varBody2);
        hresult = pmessageReceive->get_Body(&varBody);
        if (FAILED(hresult))
        {
           // PRINTERROR("can't get body", hresult);
			//log event nd exit
        }
        hresult = VariantChangeType(&varBody2,
                                    &varBody,
                                    0,
                                    VT_BSTR);
        if (FAILED(hresult))
        {
           // PRINTERROR("can't convert message to string.", hresult);
			// log event and exit
        }

        VariantClear(&varBody);
        VariantClear(&varBody2);

        //
        // release the current message
        //
        RELEASE(pmessageReceive);


      //
    // Cleanup - Close handle to the queue
    //
    pqReceive->Close();
    if (FAILED(hresult))
    {
       // PRINTERROR("Cannot close queue", hresult);
		// Log Error and Exit
    }

//-----------------------------------------------------------------------------------//
//			This code goes in the constructor.
//-----------------------------------------------------------------------------------//
   // Move this to class destructor
    // Finish - Let's delete the queue from the directory service
    // (We don't need to do it. In case of a public queue, leaving 
    //  it in the DS enables sender applications to send messages 
    //  even if the receiver is not available.)
    //
    hresult = pqinfo->Delete();
    if (FAILED(hresult))
    {
        PRINTERROR("Cannot delete queue", hresult);
    }
    // fall through...

    Cleanup:
    SysFreeString(bstrPathName);
    SysFreeString(bstrMsgLabel);
    SysFreeString(bstrServiceType);
    SysFreeString(bstrLabel);
    RELEASE(pmessageReceive);
    RELEASE(pqReceive);
    RELEASE(pqinfo);
    return hresult;
	*/
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\dbglauncher\dbglauncher.cpp ===
// DBGLauncher.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL,
//      run nmake -f DBGLauncherps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include "Messages.h"
#include <time.h>
#include <sys/timeb.h>
#include <strsafe.h>
#include "DBGLauncher_i.c"
#include "ocamon.h"
#define  MAX_QUEUE_OPEN_RETRY 5



static WCHAR strGuidMQTestType[] =
L"{c30e0960-a2c0-11cf-9785-00608cb3e80c}";



// Some useful macros
#define RELEASE(punk) if (punk) { (punk)->Release(); (punk) = NULL; }
#define ADDREF(punk) ((punk) ? (punk)->AddRef() : 0)

CServiceModule _Module;
HANDLE  g_hStopEvent = NULL;
BOOL    g_ReadQueueFlag = TRUE;
BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

// Although some of these functions are big they are declared inline since they are only used once

inline HRESULT CServiceModule::RegisterServer(BOOL bRegTypeLib, BOOL bService)
{
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Remove any previous service since it may point to
    // the incorrect file
    Uninstall();
    SetupEventLog(FALSE);
    // Add service entries
    UpdateRegistryFromResource(IDR_DBGLauncher, TRUE);

    // Adjust the AppID for Local Server or Service
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_WRITE);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    CRegKey key;
    lRes = key.Open(keyAppID, _T("{5D3C7CA6-DF04-4864-897D-83BF996692B3}"), KEY_WRITE);
    if (lRes != ERROR_SUCCESS)
        return lRes;
    key.DeleteValue(_T("LocalService"));

    if (bService)
    {
        key.SetValue(_T("DBGLauncher"), _T("LocalService") );
        key.SetValue(_T("-Service"), _T("ServiceParameters"));
        // Create service
        Install();
    }

    // Add object entries
    hr = CComModule::RegisterServer(bRegTypeLib);

    CoUninitialize();
    return hr;
}

inline HRESULT CServiceModule::UnregisterServer()
{
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

    // Remove service entries
    UpdateRegistryFromResource(IDR_DBGLauncher, FALSE);
    // Remove service
    Uninstall();
    // Remove object entries
    CComModule::UnregisterServer(TRUE);
    CoUninitialize();
    return S_OK;
}

inline void CServiceModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid)
{
    CComModule::Init(p, h, plibid);

    m_bService = TRUE;

    LoadString(h, nServiceNameID, m_szServiceName, sizeof(m_szServiceName) / sizeof(TCHAR));

    // set up the initial service status
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;
    //
    // Create Named Events
    //
    g_hStopEvent = CreateEvent(
        NULL,
        FALSE,
        FALSE,
        s_cszStopEvent
        );
    if(NULL == g_hStopEvent)
    {
        LogEvent( _T("Failed to create stop event: %s; hr=%ld"),
            s_cszStopEvent,
            GetLastError());
    }
    m_hMonNotifyPipe = NULL;
}

LONG CServiceModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0 && !m_bService)
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
    return l;
}

BOOL CServiceModule::IsInstalled()
{
    BOOL bResult = FALSE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM != NULL)
    {
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
        if (hService != NULL)
        {
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }
        ::CloseServiceHandle(hSCM);
    }
    return bResult;
}

inline BOOL CServiceModule::Install()
{
    if (IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
    {
        MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
    }
    SetupEventLog(TRUE);
    // Get the executable file path
    TCHAR szFilePath[_MAX_PATH];
    ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);

    SC_HANDLE hService = ::CreateService(
        hSCM, m_szServiceName, m_szServiceName,
        SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
        SERVICE_AUTO_START, SERVICE_ERROR_NORMAL,
        szFilePath, NULL, NULL, _T("RPCSS\0"), NULL, NULL);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, _T("Couldn't create service"), m_szServiceName, MB_OK);
        return FALSE;
    }
    SERVICE_FAILURE_ACTIONS Failure;
    SC_ACTION Actions[3];

    Failure.cActions = 3;
    Failure.dwResetPeriod = 1200;
    Failure.lpCommand = _T("");
    Failure.lpRebootMsg = _T("");
    Failure.lpsaActions = Actions;

    Actions[0].Delay = 2000;
    Actions[0].Type = SC_ACTION_RESTART;

    Actions[1].Delay = 2000;
    Actions[1].Type = SC_ACTION_RESTART;

    Actions[2].Delay = 2000;
    Actions[2].Type = SC_ACTION_RESTART;

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);
    return TRUE;
}

inline BOOL CServiceModule::Uninstall()
{
    if (!IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM == NULL)
    {
        MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
    }

    SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_STOP | DELETE);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, _T("Couldn't open service"), m_szServiceName, MB_OK);
        return FALSE;
    }
    SERVICE_STATUS status;
    ::ControlService(hService, SERVICE_CONTROL_STOP, &status);

    BOOL bDelete = ::DeleteService(hService);
    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);

    if (bDelete)
        return TRUE;

    MessageBox(NULL, _T("Service could not be deleted"), m_szServiceName, MB_OK);
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////////////
// Logging functions
void CServiceModule::LogEvent(LPCTSTR pFormat, ...)
{
    TCHAR    chMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[1];
    va_list pArg;

    va_start(pArg, pFormat);
   // _vstprintf(chMsg, pFormat, pArg);
    if (StringCbVPrintf(chMsg,sizeof chMsg, pFormat, pArg) != S_OK)
    {
        return;
    }
    va_end(pArg);

    lpszStrings[0] = chMsg;

    if (m_bService)
    {
        /* Get a handle to use with ReportEvent(). */
        hEventSource = RegisterEventSource(NULL, m_szServiceName);
        if (hEventSource != NULL)
        {
            /* Write to event log. */

            ReportEvent(hEventSource, EVENTLOG_INFORMATION_TYPE, 0, EVENT_MESSAGE, NULL, 1, 0, (LPCTSTR*) &lpszStrings[0], NULL);
            DeregisterEventSource(hEventSource);
        }
    }
    else
    {
        // As we are not running as a service, just write the error to the console.
        _putts(chMsg);
    }
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Service startup and registration
inline void CServiceModule::Start()
{
    SERVICE_TABLE_ENTRY st[] =
    {
        { m_szServiceName, _ServiceMain },
        { NULL, NULL }
    };
    if (m_bService && !::StartServiceCtrlDispatcher(st))
    {
        m_bService = FALSE;
    }
    if (m_bService == FALSE)
        Run();
}

inline void CServiceModule::ServiceMain(DWORD /* dwArgc */, LPTSTR* /* lpszArgv */)
{
    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;
    m_hServiceStatus = RegisterServiceCtrlHandler(m_szServiceName, _Handler);
    if (m_hServiceStatus == NULL)
    {
        LogEvent(_T("Handler not installed"));
        return;
    }
    SetServiceStatus(SERVICE_START_PENDING);

    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    // When the Run function returns, the service has stopped.
    Run();

    SetupEventLog(TRUE);
    SetServiceStatus(SERVICE_STOPPED);

    LogEvent(_T("Service stopped"));
}

inline void CServiceModule::Handler(DWORD dwOpcode)
{
    switch (dwOpcode)
    {
    case SERVICE_CONTROL_STOP:
        SetServiceStatus(SERVICE_STOP_PENDING);
        // SetServiceStatus(SERVICE_STOP_PENDING);

        if(NULL != g_hStopEvent)
        {
            if(FALSE == SetEvent( g_hStopEvent ))
            {
                LogFatalEvent( _T("Unable to signal Stop Event; Error: %ld"), GetLastError());
            }

            CloseHandle( g_hStopEvent );
        }
       /// PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
      //  break;
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
        break;
    case SERVICE_CONTROL_PAUSE:
        break;
    case SERVICE_CONTROL_CONTINUE:
        break;
    case SERVICE_CONTROL_INTERROGATE:
        break;
    case SERVICE_CONTROL_SHUTDOWN:
        break;
    default:
        LogEvent(_T("Bad service request"));
    }
}

void WINAPI CServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}
void WINAPI CServiceModule::_Handler(DWORD dwOpcode)
{
    _Module.Handler(dwOpcode);
}

void CServiceModule::SetServiceStatus(DWORD dwState)
{
    m_status.dwCurrentState = dwState;
    ::SetServiceStatus(m_hServiceStatus, &m_status);
}

void CServiceModule::Run()
{
    BYTE *byteVersionBuff = NULL;
    VS_FIXEDFILEINFO *pVersionInfo = NULL;
    UINT uLength = 0;
    _Module.dwThreadID = GetCurrentThreadId();
    TCHAR szFilePath[_MAX_PATH];
    DWORD dwPlaceHolder = 0;

 //   HRESULT hr = CoInitialize(NULL);
//  If you are running on NT 4.0 or higher you can use the following call
//  instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    _ASSERTE(SUCCEEDED(hr));

    // This provides a NULL DACL which will allow access to everyone.
    CSecurityDescriptor sd;
    sd.InitializeFromThreadToken();
    hr = CoInitializeSecurity(sd, -1, NULL, NULL,
        RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
    _ASSERTE(SUCCEEDED(hr));

    hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE);
    _ASSERTE(SUCCEEDED(hr));


    ZeroMemory(szFilePath, sizeof szFilePath);
    ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);
    if (szFilePath[0] != _T('\0'))
    {
        DWORD dwBufferSize = GetFileVersionInfoSize(szFilePath,&dwPlaceHolder);
        if (dwBufferSize > 0)
            byteVersionBuff = (BYTE*) malloc (dwBufferSize);
        if (byteVersionBuff)
        {
            GetFileVersionInfo(szFilePath,NULL,dwBufferSize,byteVersionBuff);
            VerQueryValue(byteVersionBuff,_T("\\"),(VOID **) &pVersionInfo, &uLength);

            LogEvent(_T("DbgLauncher service version: %d.%d.%d.%d  Started."), HIWORD (pVersionInfo->dwFileVersionMS),LOWORD(pVersionInfo->dwFileVersionMS)
                                ,HIWORD(pVersionInfo->dwFileVersionLS),LOWORD(pVersionInfo->dwFileVersionLS)) ;
        }
    }

//  DWORD NameLength = sizeof(TCHAR) * (MAX_COMPUTERNAME_LENGTH + 1);

    if (m_bService)
        SetServiceStatus(SERVICE_RUNNING);


    //
    // Execute Archive Service
    //
    try
    {
        PrepareForDebuggerLaunch();
    }
    catch(...)
    {
         LogEvent( _T("dbgLauncher Service CRASHED !!! "));
    }
    if (m_hMonNotifyPipe != NULL &&
        m_hMonNotifyPipe != INVALID_HANDLE_VALUE)
    {
        CloseHandle(m_hMonNotifyPipe);
        m_hMonNotifyPipe = NULL;
    }
    MSG msg;
    while (GetMessage(&msg, 0, 0, 0))
        DispatchMessage(&msg);

    _Module.RevokeClassObjects();

    CoUninitialize();
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance,
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
    _Module.Init(ObjectMap, hInstance, IDS_SERVICENAME, &LIBID_DBGLAUNCHERLib);
    _Module.m_bService = TRUE;

    TCHAR szTokens[] = _T("-/");

    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT),
                      NORM_IGNORECASE,
                      lpszToken,
                      -1,
                      _T("UnregServer"),
                      -1 ) == CSTR_EQUAL)

      // if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
            return _Module.UnregisterServer();

        // Register as Local Server
        if (CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT),
                      NORM_IGNORECASE,
                      lpszToken,
                      -1,
                      _T("RegServer"),
                      -1 ) == CSTR_EQUAL)

        //if (lstrcmpi(lpszToken, _T("RegServer"))==0)
            return _Module.RegisterServer(TRUE, FALSE);

        // Register as Service
        if (CompareString(MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT),
                      NORM_IGNORECASE,
                      lpszToken,
                      -1,
                      _T("Service"),
                      -1 ) == CSTR_EQUAL)

      //  if (lstrcmpi(lpszToken, _T("Service"))==0)
            return _Module.RegisterServer(TRUE, TRUE);

        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    // Are we Service or Local Server
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    CRegKey key;
    lRes = key.Open(keyAppID, _T("{5D3C7CA6-DF04-4864-897D-83BF996692B3}"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    TCHAR szValue[_MAX_PATH];
    DWORD dwLen = _MAX_PATH;
    lRes = key.QueryValue(szValue,_T("LocalService"), &dwLen);

    _Module.m_bService = FALSE;
    if (lRes == ERROR_SUCCESS)
        _Module.m_bService = TRUE;

    _Module.Start();

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}

BOOL
CServiceModule::GetServiceParams(SVCPARAMS *ServiceParams)
{
    HKEY hHKLM;
    HKEY hDbgLauncherKey;
    BYTE Buffer[MAX_PATH + 1];
    DWORD Type;
    DWORD BufferSize = MAX_PATH +1; // Set for largest value
    BOOL Status = TRUE;

    if(!RegConnectRegistry(NULL, HKEY_LOCAL_MACHINE, &hHKLM))
    {

        if(!RegOpenKeyEx(hHKLM,_T("Software\\Microsoft\\DbgLauncherSvc"), 0, KEY_ALL_ACCESS, &hDbgLauncherKey))
        {
            // Get the input queue directory path
            BufferSize = MAX_PATH +1;
            ZeroMemory(Buffer, BufferSize);
            if (RegQueryValueEx(hDbgLauncherKey,_T("DebuggerName"), 0, &Type, Buffer, &BufferSize) != ERROR_SUCCESS)
            {
                LogEvent(_T("Failed to get InputQueue value from registry."));
                Status = FALSE;
            }
            else
            {
                if (StringCbCopy (ServiceParams->DebuggerName, sizeof ServiceParams->DebuggerName,(TCHAR *) Buffer)!= S_OK)
                {
                    LogEvent (_T("Failed to copy debuggername reg value to ServiceParams->DebuggerName"));
                    Status = FALSE;
                }
            }
            BufferSize = MAX_PATH +1;
            ZeroMemory(Buffer, BufferSize);
            // Now get the Primary Queue connection string
            if (RegQueryValueEx(hDbgLauncherKey,_T("PrimaryQueue"), 0, &Type, Buffer, &BufferSize) != ERROR_SUCCESS)
            {
                LogEvent(_T("Failed to get PrimaryQueue value from registry."));
                Status = FALSE;
            }
            else
            {
                if (StringCbCopy(ServiceParams->PrimaryQueue,sizeof ServiceParams->PrimaryQueue, (TCHAR *) Buffer)!= S_OK)
                {
                    LogEvent (_T("Failed to copy PrimaryQueue reg value to ServiceParams->PrimaryQueue"));
                    Status = FALSE;
                }


            }
            BufferSize = MAX_PATH +1;
            ZeroMemory(Buffer, BufferSize);

            // Now get the Primary Queue connection string
            if (RegQueryValueEx(hDbgLauncherKey,_T("SecondaryQueue"), 0, &Type, Buffer, &BufferSize) != ERROR_SUCCESS)
            {
                LogEvent(_T("Failed to get SecondaryQueue value from registry."));
                Status = FALSE;
            }
            else
            {
                if (StringCbCopy(ServiceParams->SecondaryQueue,sizeof ServiceParams->SecondaryQueue, (TCHAR *) Buffer)!= S_OK)
                {
                    LogEvent (_T("Failed to copy SecondaryQueue reg value to ServiceParams->SecondaryQueue"));
                    Status = FALSE;
                }

            }
            BufferSize = MAX_PATH +1;
            ZeroMemory(Buffer, BufferSize);


            // now get the primary response queue
            if (RegQueryValueEx(hDbgLauncherKey,_T("PrimaryResponseQueue"), 0, &Type, Buffer, &BufferSize) != ERROR_SUCCESS)
            {
                LogEvent(_T("Failed to get Primary ResponseQueue value from registry."));
                Status = FALSE;
            }
            else
            {
                if (StringCbCopy(ServiceParams->PrimaryResponseQueue,sizeof ServiceParams->PrimaryResponseQueue, (TCHAR *) Buffer) != S_OK)
                {
                    LogEvent (_T("Failed to copy PrimaryResponseQueue reg value to ServiceParams->PrimaryResponseQueue"));
                    Status = FALSE;
                }
            }
            BufferSize = MAX_PATH +1;
            ZeroMemory(Buffer, BufferSize);

            // now get the secondary response queue
            if (RegQueryValueEx(hDbgLauncherKey,_T("SecondaryResponseQueue"), 0, &Type, Buffer, &BufferSize) != ERROR_SUCCESS)
            {
                LogEvent(_T("Failed to get Secondary ResponseQueue value from registry."));
                Status = FALSE;
             }
            else
            {
                if (StringCbCopy(ServiceParams->SecondaryResponseQueue,sizeof ServiceParams->SecondaryResponseQueue, (TCHAR *) Buffer)!= S_OK)
                {
                    LogEvent (_T("Failed to copy SecondaryResponseQueue reg value to ServiceParams->SecondaryResponseQueue"));
                    Status = FALSE;
                }

            }
            BufferSize = MAX_PATH +1;
            ZeroMemory(Buffer, BufferSize);
            // Now get the ini release point
            if (RegQueryValueEx(hDbgLauncherKey,_T("IniInstallLocation"), 0, &Type, Buffer, &BufferSize) != ERROR_SUCCESS)
            {
                LogEvent(_T("Failed to get IniInstallLocation Queue value from registry."));
                Status = FALSE;
            }
            else
            {
                if (StringCbCopy(ServiceParams->IniInstallLocation,sizeof ServiceParams->IniInstallLocation, (TCHAR *) Buffer)!= S_OK)
                {
                    LogEvent (_T("Failed to copy IniInstallLocation reg value to ServiceParams->IniInstallLocation"));
                    Status = FALSE;
                }

            }

            BufferSize = MAX_PATH +1;
            ZeroMemory(Buffer, BufferSize);


            // Now get the Symbols server connection string
            if (RegQueryValueEx(hDbgLauncherKey,_T("SymSrv"), 0, &Type, Buffer, &BufferSize) != ERROR_SUCCESS)
            {
                LogFatalEvent(_T("Failed to get the symbol server value from the registry."));
                Status = FALSE;
            }
            else
            {
                if (StringCbCopy(ServiceParams->Symsrv,sizeof ServiceParams->Symsrv, (TCHAR *) Buffer) != S_OK)
                {
                    LogEvent (_T("Failed to copy Symsrv reg value to ServiceParams->Symsrv"));
                    Status = FALSE;
                }

            }
            BufferSize = MAX_PATH +1;
            ZeroMemory(Buffer, BufferSize);


            // Now get the Delay -- Min time between kd launches
            if (RegQueryValueEx(hDbgLauncherKey,_T("Delay"), 0, &Type, Buffer, &BufferSize))
            {
                LogEvent(_T("Failed to get the min delay between dbg launches."));
            }
            else
            {
                ServiceParams->dwDelay = *((DWORD*)Buffer);
            }
            BufferSize = MAX_PATH +1;
            ZeroMemory(Buffer, BufferSize);

            // Now get the Primary Queue delay
            if (RegQueryValueEx(hDbgLauncherKey,_T("PrimaryInterval"), 0, &Type, Buffer, &BufferSize))
            {
                LogFatalEvent(_T("Failed to get the Primary queue wait interval."));
                Status = FALSE;
            }
            else
            {
                ServiceParams->dwPrimaryWait = *((DWORD*)Buffer);
            }
            BufferSize = MAX_PATH +1;
            ZeroMemory(Buffer, BufferSize);



            // Now get the Primary Queue delay
            if (RegQueryValueEx(hDbgLauncherKey,_T("IniWaitTime"), 0, &Type, Buffer, &BufferSize))
            {
                LogFatalEvent(_T("Failed to get the triage.Ini wait interval."));
                Status = FALSE;
            }
            else
            {
                ServiceParams->IniCheckWaitTime = *((DWORD*)Buffer);
            }
            BufferSize = MAX_PATH +1;
            ZeroMemory(Buffer, BufferSize);

            // Now get the Memory usage threshold
            if (RegQueryValueEx(hDbgLauncherKey,_T("MaxKdProcesses"), 0, &Type, Buffer, &BufferSize))
            {
                LogFatalEvent(_T("Failed to get the Max Kd Processes setting."));
                Status = FALSE;
            }
            else
            {
                ServiceParams->dwMaxKdProcesses = *((DWORD*)Buffer);
            }
            BufferSize = MAX_PATH +1;
            ZeroMemory(Buffer, BufferSize);

            // Now get the Memory usage threshold
            if (RegQueryValueEx(hDbgLauncherKey,_T("MaxDumpSize"), 0, &Type, Buffer, &BufferSize))
            {
                LogEvent(_T("Failed to get the Max Dump Size setting."));
                ServiceParams->dwMaxDumpSize = -1;
            }
            else
            {
                ServiceParams->dwMaxDumpSize = *((DWORD*)Buffer);
            }
            RegCloseKey(hHKLM);
            RegCloseKey(hDbgLauncherKey);
            return TRUE;
        }
        else
        {
            RegCloseKey(hHKLM);
            return FALSE;
        }
    }
    else
        return FALSE;



}






DWORD
CServiceModule::CheckForIni (SVCPARAMS *ServiceParams)
{
    FILETIME CreationTimeCurrent;
    FILETIME CreationTimeNew;
    TCHAR    IniFileName[MAX_PATH];
    TCHAR    DebuggerPath[MAX_PATH];
    TCHAR    *Temp = NULL;
    HANDLE   hFile = INVALID_HANDLE_VALUE;
    HANDLE   hFile2 = INVALID_HANDLE_VALUE;

    ZeroMemory (&CreationTimeCurrent, sizeof FILETIME);
    ZeroMemory (&CreationTimeNew, sizeof FILETIME);

    if (_tcslen(ServiceParams->DebuggerName) + _tcslen(_T("\\winxp\\triage.ini")) < MAX_PATH)
    {
        if (StringCbCopy(DebuggerPath, sizeof DebuggerPath, ServiceParams->DebuggerName)!= S_OK)
        {
            LogEvent(_T("CheckForIni: Failed to build Debugger Path"));
        }
        Temp = DebuggerPath;
        Temp += _tcslen(DebuggerPath);
        if (Temp != DebuggerPath)
        {
            while(*Temp != _T('\\'))
            {
                -- Temp;
            }
            *(Temp+1) = _T('\0');
        }
        // Get the file path of the debugger remove the ocakd.exe string then add triage\\triage.ini
        if (StringCbCat (DebuggerPath,sizeof DebuggerPath, _T("winxp\\triage.ini")) != S_OK)
        {
            LogEvent(_T("CheckForIni: Failed to build debugger path"));
        }
        // Check to see if we need a new triage.ini file.
        // open a shared read handle to the existing ini file.
        hFile = CreateFile(DebuggerPath,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            0,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            // Get the time date stamp of the existing triage ini file.
            if ( GetFileTime(hFile,NULL,NULL,&CreationTimeCurrent) )
            {
                // Now get the filetime for the triage.ini replacement.
                hFile2 = CreateFile(ServiceParams->IniInstallLocation,
                            GENERIC_READ,
                            FILE_SHARE_READ,
                            0,
                            OPEN_EXISTING,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL);
                if (hFile2 != INVALID_HANDLE_VALUE)
                {
                    if (GetFileTime(hFile2, NULL,NULL,&CreationTimeNew))
                    {
                    //  LogEvent (_T("Comparing the creation times"));
                        if ( CompareFileTime( &CreationTimeNew , &CreationTimeCurrent) == 1)
                        {
                            // copy the new file here.
                            if (hFile != INVALID_HANDLE_VALUE)
                                CloseHandle (hFile);
                            if (hFile2 != INVALID_HANDLE_VALUE)
                                CloseHandle (hFile2);
                            if (CopyFile(ServiceParams->IniInstallLocation, DebuggerPath,FALSE) )
                            {
                            //  LogEvent(_T("Successfully copied triage.ini from: %s to %s"),
                                    //       ServiceParams->IniInstallLocation, DebuggerPath);
                                ;
                            }
                            else
                            {
                            //  LogEvent(_T("Copy of file:%s to %s failed\n error code: %d"),ServiceParams->IniInstallLocation, DebuggerPath, GetLastError());
                                ;
                            }

                        }

                    }
                    if (hFile2 != INVALID_HANDLE_VALUE)
                            CloseHandle (hFile2);
                }
            }

            if (hFile != INVALID_HANDLE_VALUE)
                CloseHandle (hFile);
        }
    }
    return 0;
}


HRESULT CServiceModule::ConnectToMSMQ(QUEUEHANDLE *hQueue, wchar_t *QueueConnectStr)
/*++

Routine Description:

    This function is called when the WWW service is shutdown.

Arguments:

    dwFlags - HSE_TERM_ADVISORY_UNLOAD or HSE_TERM_MUST_UNLOAD

Return Value:

    TRUE when extension is ready to be unloaded,

--*/
{
    HRESULT Hr = S_OK;
    DWORD i;
    i = 0;

    Hr = MQOpenQueue(QueueConnectStr,
                     MQ_RECEIVE_ACCESS,
                     MQ_DENY_NONE,
                     hQueue);
    return Hr;

}
BOOL CServiceModule::Initialize(PSVCPARAMS pParams)
{
    HRESULT hr;
    if (!GetServiceParams(pParams) )
    {
        LogFatalEvent(_T("Failed to read initialization data from the registry."));
        return FALSE;
    }

    //ConnectToMSMQ
    hr = ConnectToMSMQ(&(pParams->hPrimaryQueue),pParams->PrimaryQueue);
    if (SUCCEEDED(hr))
    {
        LogEvent(_T("Connected to primary Queue"));
        //pParams->PrimaryConnected = TRUE;
    }
    else
    {
        //pParams->PrimaryConnected = FALSE;
        LogEvent(_T("Cannot connected to primary Queue %s, error %lx"), pParams->PrimaryQueue, hr);
    }
    hr = ConnectToMSMQ(&(pParams->hSecondaryQueue),pParams->SecondaryQueue);
    if (SUCCEEDED(hr))
    {
        //pParams->PrimaryConnected = TRUE;
        LogEvent(_T("Connected to secondary Queue"));
    }
    else
    {
        //pParams->PrimaryConnected = FALSE;
        LogEvent(_T("Cannot connected to secondary Queue %s, error %lx"), pParams->SecondaryQueue, hr);
    }
    return TRUE;
}


BOOL CServiceModule::ReceiveQueueMessage(PSVCPARAMS pParams,
                                         wchar_t *RecMessageBody,
                                         wchar_t *szMessageGuid,
                                         BOOL *bUsePrimary,
                                         int *Type,
                                         wchar_t *szSR)

{
    MSGPROPID       PropIds[5];
    MQPROPVARIANT   PropVariants[5];
    HRESULT         hrProps[5];
    MQMSGPROPS      MessageProps;
    DWORD   i                   = 0;
    wchar_t RecLabel[100];
    wchar_t LocalRecBody[MAX_PATH];
    DWORD   RecMessageBodySize  = sizeof LocalRecBody;
    DWORD   RecLabelLength      = sizeof RecLabel;
    HRESULT hResult             = 0;
    BOOL    Status              = FALSE;

    TCHAR   *Temp = NULL;




    ZeroMemory(LocalRecBody,sizeof LocalRecBody);
    ZeroMemory(RecLabel,sizeof RecLabel);

    i = 0;
    PropIds[i] = PROPID_M_LABEL_LEN;
    PropVariants[i].vt = VT_UI4;
    PropVariants[i].ulVal = RecLabelLength;
    i++;

    PropIds[i] = PROPID_M_LABEL;
    PropVariants[i].vt = VT_LPWSTR;
    PropVariants[i].pwszVal = RecLabel;
    i++;

    MessageProps.aPropID = PropIds;
    MessageProps.aPropVar = PropVariants;
    MessageProps.aStatus = hrProps;
    MessageProps.cProp = i;

    // retrieve the current message
    i = 0;
    PropIds[i] = PROPID_M_LABEL_LEN;
    PropVariants[i].vt = VT_UI4;
    PropVariants[i].ulVal = RecLabelLength;
    i++;

    PropIds[i] = PROPID_M_LABEL;
    PropVariants[i].vt = VT_LPWSTR;
    PropVariants[i].pwszVal = RecLabel;

    i++;
    PropIds[i] = PROPID_M_BODY_SIZE;
    PropVariants[i].vt = VT_UI4;

    i++;
    PropIds[i] = PROPID_M_BODY_TYPE;
    PropVariants[i].vt = VT_UI4;

    i++;
    PropIds[i] = PROPID_M_BODY;
    PropVariants[i].vt = VT_VECTOR|VT_UI1;
    PropVariants[i].caub.pElems = (LPBYTE) LocalRecBody;
    PropVariants[i].caub.cElems = RecMessageBodySize;

    i++;

    MessageProps.aPropID = PropIds;
    MessageProps.aPropVar = PropVariants;
    MessageProps.aStatus = hrProps;
    MessageProps.cProp = i;

    hResult = MQReceiveMessage( pParams->hPrimaryQueue,
                                0,
                                MQ_ACTION_RECEIVE,
                                &MessageProps,
                                NULL,
                                NULL,
                                NULL,
                                MQ_NO_TRANSACTION);

    if (FAILED (hResult) )
    {

        if (hResult != (HRESULT) MQ_ERROR_IO_TIMEOUT)
        {
            if (hResult == (HRESULT) MQ_ERROR_QUEUE_NOT_AVAILABLE)
            {
                // Non Fatal Event
                LogFatalEvent(_T("The %s MSMQ is unavailable."), pParams->PrimaryQueue );
            }
            else
            {
                if (hResult == (HRESULT) MQ_ERROR_INVALID_HANDLE)
                {
                    // Close the current handle and attempt to reconnect to the MSMQ
                    MQCloseQueue( pParams->hPrimaryQueue );
                    ConnectToMSMQ(&(pParams->hPrimaryQueue), pParams->PrimaryQueue );
                }
            }
        }
        //g_ReadQueueFlag = !g_ReadQueueFlag;
        hResult = MQReceiveMessage( pParams->hSecondaryQueue,
                                    0,
                                    MQ_ACTION_RECEIVE,
                                    &MessageProps,
                                    NULL,
                                    NULL,
                                    NULL,
                                    MQ_NO_TRANSACTION);
        if (FAILED(hResult) )
        {
            Status = FALSE;

            if (hResult != (HRESULT)MQ_ERROR_IO_TIMEOUT)
            {
                if (hResult == (HRESULT)MQ_ERROR_QUEUE_NOT_AVAILABLE)
                {
                    // Non Fatal Event
                    LogFatalEvent(_T("The %s MSMQ is unavailable."), pParams->SecondaryQueue);
                }
                else
                {
                    if (hResult == (HRESULT)MQ_ERROR_INVALID_HANDLE)
                    {
                        // Close the current handle and attempt to reconnect to the MSMQ
                        MQCloseQueue(pParams->hSecondaryQueue);
                        ConnectToMSMQ(&(pParams->hSecondaryQueue), pParams->SecondaryQueue);
                    }
                }
            }
            return Status;
        }
        //
        // We have valid message from SecondaryQueue
        //
    }

    else
    {
        //
        // We have valid message from Primary Queue
        //

    }

    //
    // Copy the messge parameters
    //
    if (StringCbCopy(RecMessageBody,RecMessageBodySize,  LocalRecBody) != S_OK)
    {
        LogEvent(_T("Failed to copy the recieved message body to RecMessageBody"));
    }
    if (StringCbCopy(szMessageGuid,RecLabelLength, RecLabel) != S_OK)
    {
        LogEvent(_T("Failed to copy the RecLabel into szMessageGuid."));
    }
    Status = TRUE;
    *bUsePrimary = TRUE;
    Temp = RecMessageBody;
    while ( (*Temp != _T(';')) && (*Temp != _T('\0')))
    {
        ++Temp;
    }
    if (*Temp != _T('\0'))
    {
        *Type = _wtoi (Temp+1);
        // terminate the string here.
        *Temp = _T('\0');
    }
    else
    {
        *Type = 1;
    }


    Temp = _tcsstr(LocalRecBody, _T(";SR="));
    if (Temp != NULL)
    {
        // we got a SR number in message
        Temp += 4;
        StringCbCopy(szSR, 50, Temp);
    } else
    {
        *szSR = _T('\0');
    }

    // Flip the read from queue flag for the next call
    //g_ReadQueueFlag = !g_ReadQueueFlag;
    return Status;
}

ULONG64
CServiceModule::GetFileSize(
    LPWSTR wszFile
    )
{
    HANDLE hFile;
    DWORD dwFileSize, dwFileSizeHi;

    hFile = CreateFileW(wszFile, GENERIC_READ,
                        FILE_SHARE_READ, NULL,
                        OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                        NULL);
    if (hFile != NULL && hFile != INVALID_HANDLE_VALUE)
    {
        dwFileSizeHi = 0;
        dwFileSize=::GetFileSize(hFile,&dwFileSizeHi);

        return (ULONG64) dwFileSize + ((ULONG64)dwFileSizeHi << 32);
    }
    return -1;
}

VOID
CServiceModule::NotifyDebuggerLaunch(
    PDBADDCRASH_PARAMS pDbParams
    )
{
    HANDLE hPipe;
    DWORD dwMode, cbWritten;
    OCAKD_MONITOR_MESSAGE Msg;
    OVERLAPPED WriteOverlapped;

    Msg.MessageId = OKD_MESSAGE_DBGLAUNCH_NOTIFY;
    Msg.u.DbglNotice.SizeOfStruct = sizeof(Msg.u.DbglNotice);
    Msg.u.DbglNotice.Source     = pDbParams->Source;
    Msg.u.DbglNotice.nKdsRunning = m_DebuggerCount;
    if (StringCbPrintfA(Msg.u.DbglNotice.CrashGuid,   sizeof(Msg.u.DbglNotice.CrashGuid),
                        "%ws", pDbParams->Guid) != S_OK ||
        StringCbPrintfA(Msg.u.DbglNotice.OriginalPath,sizeof(Msg.u.DbglNotice.OriginalPath),
                        "%ws", pDbParams->DumpPath) != S_OK)
    {
        return;
    }


    for (hPipe = m_hMonNotifyPipe;m_hMonNotifyPipe == NULL;)
    {
        hPipe = CreateFile(c_tszCollectPipeName, FILE_WRITE_DATA,
                           0, NULL, OPEN_EXISTING, FILE_FLAG_OVERLAPPED,
                           NULL);
        if (hPipe != INVALID_HANDLE_VALUE)
        {
            m_hMonNotifyPipe = hPipe;
            break;
        }
        if (GetLastError() != ERROR_PIPE_BUSY)
        {
            return;
        }
        // Do not wait long, this might block other processes
        if (!WaitNamedPipe(c_tszCollectPipeName, 5*1000))
        {
            return;
        }
    }

    // We are now connected to pipe

    WriteOverlapped.hEvent = CreateEvent(NULL, TRUE, TRUE, NULL);
    if (WriteOverlapped.hEvent != NULL)
    {
        // Send crash information to monitor pipe
        if (!WriteFile(hPipe, (LPVOID) &Msg, sizeof(Msg),
                       &cbWritten, &WriteOverlapped))
        {

            if (GetLastError() == ERROR_NO_DATA ||
                GetLastError() == ERROR_BAD_PIPE)
            {
                // Open a different pipe next time
                CloseHandle(hPipe);
                m_hMonNotifyPipe = NULL;
            } else if (GetLastError() == ERROR_IO_PENDING ||
                !GetOverlappedResult(hPipe, &WriteOverlapped, &cbWritten,
                                     TRUE))
            {
                // failed to write, exit silently
                // Its up to monitor if it is keeping track of kds launched
            } else
            {
                // Open a different pipe next time
                CloseHandle(hPipe);
                m_hMonNotifyPipe = NULL;
            }

        }
        CloseHandle(WriteOverlapped.hEvent);
    }
    FlushFileBuffers(hPipe);
    return;
}


BOOL CServiceModule::LaunchDebugger(
    PDBADDCRASH_PARAMS pDbParams,
    PPROCESS_INFORMATION pDbgProcess
    )
{
    STARTUPINFO  StartupInfo;
    wchar_t      CommandLine [1024];
    wchar_t      SrParam[100];
    HRESULT      hr;

    ZeroMemory(&StartupInfo,sizeof(STARTUPINFO));
    StartupInfo.cb = sizeof(STARTUPINFO);

    if ((pDbParams->dwMaxDumpSize != 0) && (pDbParams->dwMaxDumpSize != -1) &&
        (GetFileSize(pDbParams->DumpPath) > pDbParams->dwMaxDumpSize))
    {
        LogEvent(_T("Dump %s is too large, deleting file\n"), pDbParams->DumpPath);
        DeleteFileW(pDbParams->DumpPath);
        return FALSE;
    }
    if (pDbParams->SrNumber[0])
    {
        hr = StringCbPrintf(SrParam, sizeof(SrParam), _T(" -sr %s"), pDbParams->SrNumber);
        if (hr != S_OK)
        {
            LogEvent(_T("Bad SR %s: %lx"), pDbParams->SrNumber, hr);
            return FALSE;
        }
    } else
    {
        SrParam[0] = _T('\0');
    }
    if ((hr = StringCbPrintf(CommandLine,sizeof CommandLine,
                             _T("%s -i %s -y %s -z \"%s\" -c \"!dbaddcrash -source %d -g %s -s %s -p %s%s;q\""),
                             pDbParams->Debugger,
                             pDbParams->SymPath,
                             pDbParams->SymPath,
                             pDbParams->DumpPath,
                             pDbParams->Source,
                             pDbParams->Guid,
                             pDbParams->ResponseMQ,
                             pDbParams->DumpPath,
                             SrParam)) != S_OK)
    {
        LogEvent(_T("Failed to build command line: %lx"), hr);
    }
    //LogEvent(_T("CommandLine Guid=%s queue=%d"),szMessageLabel,bUsePrimary);
    //LogEvent(_T("CommandLine Path=%s"),szFilePath);
    //LogEvent(_T("CommandLine: %s"),CommandLine);
    if (!CreateProcess(NULL,
                       CommandLine,
                       NULL,
                       NULL,
                       FALSE,
                       //CREATE_NEW_CONSOLE,
                       CREATE_NO_WINDOW,
                       NULL,
                       NULL,
                       &StartupInfo,
                       pDbgProcess))
    {
        hr = GetLastError();
        LogEvent(_T("Failed to launch debugger. Commandline %s, error %lx\n"), CommandLine, hr);
        return FALSE;
    }
    //
    // Notify Site monitor of debugger launch
    //
    NotifyDebuggerLaunch(pDbParams);
    return TRUE;
}


BOOL CServiceModule::PrepareForDebuggerLaunch()
{

    HANDLE              ProcessHandles[50];
    PROCESS_INFORMATION ProcessInfo;
    wchar_t             szFilePath[MAX_PATH];
    wchar_t             szSR[100];
    HRESULT             hr                      = 0;
    HANDLE              hStopEvent              = INVALID_HANDLE_VALUE;
    SVCPARAMS           ServiceParams;
    DWORD               dwIndex                 = 0;
    DWORD               FreeIndex               = 0;
    DWORD               dwWaitResult            = 0;
    BOOL                Done                    = FALSE;
    __time64_t          CurrentTime = 0;
    __time64_t          NextCheckTime = 0;
    wchar_t             szMessageLabel[255];
    BOOL                bUsePrimary             = FALSE;
    int                 Type                    = 1;
    DBADDCRASH_PARAMS   DbParams;

    ZeroMemory (ProcessHandles,sizeof ProcessHandles);
    ZeroMemory(&ServiceParams,sizeof SVCPARAMS);
    ZeroMemory (szMessageLabel, sizeof szMessageLabel);
    ZeroMemory (szFilePath, sizeof szFilePath);
    ZeroMemory(&DbParams, sizeof(DbParams));

    m_DebuggerCount = 0;
    hStopEvent = OpenEvent(
            EVENT_ALL_ACCESS,
            FALSE,
            s_cszStopEvent
            );

    if (hStopEvent == NULL)
    {
        LogFatalEvent(_T("Failed to open stop event. Terminating"));
        goto Done;
    }

        // get reg data


    // Insert the stop event into the ocakd queue
    ++ m_DebuggerCount;
    ProcessHandles[m_DebuggerCount -1] = hStopEvent;

    if (!Initialize(&ServiceParams))
    {
        goto Done;
    }
    // fill the ocakd queue
    Done = FALSE;


    while ( (m_DebuggerCount <= ServiceParams.dwMaxKdProcesses+1 ) && (!Done))
    {

        if (!ReceiveQueueMessage(&ServiceParams, szFilePath, szMessageLabel, &bUsePrimary, &Type, szSR))
        {

            Done = TRUE;
        }
        else
        {
            DbParams.Debugger   = ServiceParams.DebuggerName;
            DbParams.DumpPath   = szFilePath;
            DbParams.Guid       = szMessageLabel;
            DbParams.SrNumber   = szSR;
            DbParams.ResponseMQ = (bUsePrimary) ?
                ServiceParams.PrimaryResponseQueue : ServiceParams.SecondaryResponseQueue;
            DbParams.SymPath    = ServiceParams.Symsrv;
            DbParams.Source     = Type;
            DbParams.dwMaxDumpSize = ServiceParams.dwMaxDumpSize;

            if (LaunchDebugger(&DbParams, &ProcessInfo))
            {
            //  LogEvent(_T("Launched: %s for file: %s with guid:%s and source: %d with return queue =%s"),
            //  ServiceParams.DebuggerName,szFilePath, szMessageLabel, Type, (bUsePrimary) ? ServiceParams.PrimaryResponseQueue : ServiceParams.SecondaryResponseQueue);
                ++ m_DebuggerCount;
                ProcessHandles[m_DebuggerCount -1] = ProcessInfo.hProcess;
                CloseHandle( ProcessInfo.hThread );

            } // end else
        }// end else
    } // end while
    if (m_DebuggerCount > ServiceParams.dwMaxKdProcesses+1)
        m_DebuggerCount = ServiceParams.dwMaxKdProcesses+1;

    while (1)
    {

        _time64(&CurrentTime);
        if (CurrentTime > NextCheckTime)

        {
        //  LogEvent (_T("Checking for new ini file"));
            CheckForIni (&ServiceParams);
            NextCheckTime= CurrentTime + (ServiceParams.IniCheckWaitTime * 60);
        //  LogEvent (_T("Back from ini file check"));
        }


        // now wait for one of the processes to complete or hStopEvent to be signaled.
        dwWaitResult = WaitForMultipleObjects(m_DebuggerCount, (HANDLE *)ProcessHandles, FALSE, ServiceParams.dwDelay);
        if (dwWaitResult == WAIT_FAILED)
        {
            LogFatalEvent(_T("Failed while waiting for prcesses to complete error code: %d"), GetLastError());
            goto Cleanup;
        }

        else
        {
            if (dwWaitResult-WAIT_OBJECT_0 == 0)
            {
                LogEvent(_T("Stop request received terminating"));
                goto Cleanup;
            }
            else // we have an event we can take action on.
            {
                if ( dwWaitResult == WAIT_TIMEOUT)
                {
                    // no process completed so let's fill any empty slots in the
                    // Process array.
                    if (m_DebuggerCount <= ServiceParams.dwMaxKdProcesses)
                    {
                        // fill the queue until m_DebuggerCount == ServiceParams.dwMaxKdProcesses
                        Done = FALSE;
                        dwIndex = 1;
                        while ( (!Done) && (m_DebuggerCount <= ServiceParams.dwMaxKdProcesses) )
                        {
                            if (ProcessHandles[dwIndex] == NULL)
                            {
                                if (ReceiveQueueMessage(&ServiceParams, szFilePath, szMessageLabel,&bUsePrimary,&Type,szSR))
                                {

                                    DbParams.Debugger   = ServiceParams.DebuggerName;
                                    DbParams.DumpPath   = szFilePath;
                                    DbParams.Guid       = szMessageLabel;
                                    DbParams.SrNumber   = szSR;
                                    DbParams.ResponseMQ = (bUsePrimary) ?
                                        ServiceParams.PrimaryResponseQueue : ServiceParams.SecondaryResponseQueue;
                                    DbParams.SymPath    = ServiceParams.Symsrv;
                                    DbParams.Source     = Type;
                                    DbParams.dwMaxDumpSize = ServiceParams.dwMaxDumpSize;

                                    if (LaunchDebugger(&DbParams, &ProcessInfo))
                                    {

                                        ProcessHandles[dwIndex] = ProcessInfo.hProcess;
                                        CloseHandle( ProcessInfo.hThread );
                                        ++m_DebuggerCount;
                                    } // end else
                                }
                                else
                                {
                                    Done = TRUE;
                                }
                            }  // end if
                            ++dwIndex;
                        } // end while
                    }
                } // end if
                else // A kd process completed now lets clean it up and launch a new one.
                {
                    FreeIndex = (dwWaitResult - WAIT_OBJECT_0);
                    // check to make sure we are within our array range.
                    if ( (FreeIndex > ServiceParams.dwMaxKdProcesses))
                    {
                        LogFatalEvent( _T("Invalid array index returned by WaitForMultipleObjects. \n Index = %d, Count = %d"), FreeIndex,m_DebuggerCount);
                    }
                    else
                    {
                        CloseHandle(ProcessHandles[FreeIndex]);
                        ProcessHandles[FreeIndex] = NULL;


                        // if the queue is not now empty take the last Process handle and replace the current one.
                        if (m_DebuggerCount > 2)
                        {
                            // We have to do this because NULLs are not allowed in the HANDLE Array.
                            ProcessHandles[FreeIndex] = ProcessHandles[m_DebuggerCount-1];
                            ProcessHandles[m_DebuggerCount-1] = NULL;
                            -- m_DebuggerCount;
                        }
                        else
                        {
                            --m_DebuggerCount;
                        }
                        if (ReceiveQueueMessage(&ServiceParams, szFilePath, szMessageLabel,&bUsePrimary, &Type, szSR))
                        {
                            DbParams.Debugger   = ServiceParams.DebuggerName;
                            DbParams.DumpPath   = szFilePath;
                            DbParams.Guid       = szMessageLabel;
                            DbParams.SrNumber   = szSR;
                            DbParams.ResponseMQ = (bUsePrimary) ?
                                ServiceParams.PrimaryResponseQueue : ServiceParams.SecondaryResponseQueue;
                            DbParams.SymPath    = ServiceParams.Symsrv;
                            DbParams.Source     = Type;
                            DbParams.dwMaxDumpSize = ServiceParams.dwMaxDumpSize;

                            if (LaunchDebugger(&DbParams, &ProcessInfo))
                            {
                                ++m_DebuggerCount;
                                ProcessHandles[m_DebuggerCount-1] = ProcessInfo.hProcess;
                                CloseHandle( ProcessInfo.hThread );

                            } // end else
                        } // end if
                    } // end else
                } // end else
            } // end else
        } // end else
    }// end while(1)
Cleanup:
    //
    // Cleanup - Close handle to the queue
    //

Done:
    // set the service status to stopped and return.
    if (hStopEvent != INVALID_HANDLE_VALUE)
        CloseHandle(hStopEvent);


    return TRUE;

}













///////////////////////////////////////////////////////////////////////////////////////
// Routine to Log Fatal Errors to NT Event Log
void  CServiceModule::LogFatalEvent(LPCTSTR pFormat, ...)
{
    TCHAR    chMsg[256];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[1];
    va_list pArg;

    va_start(pArg, pFormat);
   // _vstprintf(chMsg, pFormat, pArg);
    if (StringCbVPrintf(chMsg,sizeof chMsg, pFormat, pArg)!= S_OK)
    {
        return;
    }
    va_end(pArg);

    lpszStrings[0] = chMsg;


    /* Get a handle to use with ReportEvent(). */
    hEventSource = RegisterEventSource(NULL, _T("DBGLauncher"));
    if (hEventSource != NULL)
    {
        /* Write to event log. */
        ReportEvent(hEventSource, EVENTLOG_ERROR_TYPE, 0, EVENT_ERROR, NULL, 1, 0, (LPCTSTR*) &lpszStrings[0], NULL);
        DeregisterEventSource(hEventSource);
    }

}

///////////////////////////////////////////////////////////////////////////////////////
// Routine to setup NT Event logging
HRESULT CServiceModule::SetupEventLog ( BOOL fSetup )
{
    CRegKey key;
    TCHAR szEventKey[MAX_PATH];
    LONG lRes = 0;

    if (StringCbCopy(szEventKey, sizeof szEventKey,s_cszEventLogKey)!= S_OK)
    {
        return E_FAIL;
    }
    if (StringCbCat(szEventKey,sizeof szEventKey, _T("\\")) != S_OK)
        return E_FAIL;
    if (StringCbCat(szEventKey, sizeof szEventKey,(LPTSTR)m_szServiceName) != S_OK)
        return E_FAIL;

    lRes = key.Create(HKEY_LOCAL_MACHINE, szEventKey);
    if (lRes != ERROR_SUCCESS)
    {
        goto done;
    }

    if( TRUE == fSetup )
    {
        TCHAR szMyName[MAX_PATH];
        GetModuleFileName(NULL, szMyName, (sizeof szMyName)/(sizeof szMyName[0]) );
        key.SetValue(szMyName, _T("EventMessageFile"));
        key.SetValue(EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE,
                     _T("TypesSupported"));
    }
    else
    {
        RegDeleteKey(HKEY_LOCAL_MACHINE, szEventKey);
    }

done:
    key.Close();
    return HRESULT_FROM_WIN32(GetLastError());
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\dbglauncher\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__5EF76719_1222_4555_A843_943BECCA8BDA__INCLUDED_)
#define AFX_STDAFX_H__5EF76719_1222_4555_A843_943BECCA8BDA__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>

#include <objbase.h>
#include <windows.h>
#include <stdio.h>
#define s_cszEventLogKey _T("System\\CurrentControlSet\\Services\\EventLog\\Application")       // Event Log
#include "resource.h"
#include <initguid.h>
#include <tchar.h>
#include <mqoai.h>
#include <mq.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

typedef struct strParams
{
    TCHAR DebuggerName[MAX_PATH];       // Path to debugger exe.
    TCHAR Symsrv[255];                  // Symbol server connection string
    TCHAR PrimaryQueue[255];            // Primary queue connection string
    TCHAR SecondaryQueue[255];          // Secondary queue connection string
    DWORD dwDelay;                      // Minimum delay between dbg processes
    DWORD dwPrimaryWait;                // Time to wait for a message to appear in the primary queue.
    DWORD dwSecondaryWait;              // Time to wait for a message to appear in the secondary queue.
    DWORD dwMaxKdProcesses;             // Maximum number of kd process to launch
    DWORD dwMaxDumpSize;                // Dump size limt for ocakd to process
    TCHAR IniInstallLocation[MAX_PATH]; // Place to pick up new kd ini files
    DWORD IniCheckWaitTime;             // Time to wait between checks for new INI files.
    TCHAR PrimaryResponseQueue[255];    // MSMQ connection string for kd to send responses
    TCHAR SecondaryResponseQueue[255];  // MSMQ connection string for kd to send responses if the primary
                                        // Queue is unreachable.
    QUEUEHANDLE hPrimaryQueue;          // Handle to the primary MSMQ
    QUEUEHANDLE hSecondaryQueue;        // Handle to the backup MSMQ

}SVCPARAMS, *PSVCPARAMS;


typedef struct _DBADDCRASH_PARAMS {
    PTCHAR Debugger;          // Full path to debugger which adds dump to database
    PTCHAR DumpPath;          // Full dump path which is being analyzed
    PTCHAR Guid;              // Guid for dump identification in database
    PTCHAR SrNumber;          // SR number to identify the PSS records for the dump
    PTCHAR ResponseMQ;        // MSM Queue where debugger sends the response after analysing the dump
    PTCHAR SymPath;           // Symbol / Image path for debugger
    ULONG  Source;            // Source where the dump came from
    DWORD dwMaxDumpSize;      // Dump size limt for ocakd to process
} DBADDCRASH_PARAMS, *PDBADDCRASH_PARAMS;

class CServiceModule : public CComModule
{
public:
    //BOOL ConnectToMessageQueue(TCHAR *QueueConnectionString,IMSMQQueue **pqReceive );
    HRESULT RegisterServer(BOOL bRegTypeLib, BOOL bService);
    HRESULT UnregisterServer();
    void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid = NULL);
    void Start();
    void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    void Handler(DWORD dwOpcode);
    void Run();
    BOOL IsInstalled();
    BOOL Install();
    BOOL Uninstall();
    LONG Unlock();
    void LogEvent(LPCTSTR pszFormat, ...);
    void SetServiceStatus(DWORD dwState);
    void SetupAsLocalServer();
    HRESULT SetupEventLog ( BOOL fSetup );
    VOID LogFatalEvent(LPCTSTR pFormat, ...);
    VOID NotifyDebuggerLaunch(PDBADDCRASH_PARAMS pDbParams);
    BOOL LaunchDebugger(PDBADDCRASH_PARAMS pDbParams, PPROCESS_INFORMATION pDbgProcess);
    ULONG64 GetFileSize(LPWSTR wszFile);
    BOOL PrepareForDebuggerLaunch();

    HRESULT ConnectToMSMQ(QUEUEHANDLE *hQueue, wchar_t *QueueConnectStr);
    BOOL ReceiveQueueMessage(PSVCPARAMS pParams,wchar_t *RecMessageBody, wchar_t *szMessageGuid, BOOL *UsePrimary, int* Type, wchar_t *szSR);

//  BOOL GetQueuedMessage(IMSMQQueue  **pPrimaryQueue, TCHAR *Message, TCHAR *MessageLabel);
    BOOL GetServiceParams(SVCPARAMS *ServiceParams);
    DWORD CheckForIni(SVCPARAMS *ServiceParams);
    BOOL Initialize(PSVCPARAMS pParams);
//Implementation
private:
    static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static void WINAPI _Handler(DWORD dwOpcode);
    TCHAR m_szComputerName[sizeof (TCHAR) * (MAX_COMPUTERNAME_LENGTH + 1)];

// data members
public:
    TCHAR m_szServiceName[256];
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
    DWORD dwThreadID;
    BOOL m_bService;
    HANDLE m_hMonNotifyPipe;
    ULONG m_DebuggerCount;
};


#define s_cszStopEvent   _T("DbgLauncherSvc_Event")



extern CServiceModule _Module;

#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__5EF76719_1222_4555_A843_943BECCA8BDA__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\kdmon\global.h ===
#pragma once

#include <stdio.h>
#include <windows.h>
#include <TCHAR.h>

// import the type library.
// compiler generates .tlh and .tli files from this.
// renaming of EOF is required since EOF is already in standard header files
// and it is also in .thl files. This redifinition causes a compilation error.
// Using no_namespace means you don't have to reference the namespace (ADODB) when 
// initializing or defining variables whose types are defined by what #import generates.
// #import "F:\Program Files\Common Files\System\ado\msado15.dll" no_namespace rename ( "EOF", "EndOfFile" )

// instead of importing, include the type library header file.
// This is required for a few things in cdosys.tlh like FieldsPtr etc.
#include "msado15.tlh"

// testing HRESULT
inline void TESTHR(HRESULT x) { if FAILED(x) _com_issue_error(x); };

// event logging functions
LONG SetupEventLog(BOOL bSetKey);
void LogEvent(_TCHAR pFormat[MAX_PATH * 4], ...);
void LogFatalEvent(_TCHAR pFormat[MAX_PATH * 4], ...);

// kdMon method
void kdMon();
// This method loads the INI file for kdMon
BOOL LoadINI();
// This method tells kdMon() whether it is been signaled to stop
// dwMilliSeconds is time to wait
BOOL IsSignaledToStop(const HANDLE hStopEvent, DWORD dwMilliSeconds);
// load values in the puiCounts and pulTimeStamps arrays from registry
BOOL ReadRegValues(_TCHAR **ppszNames, DWORD dwTotalNames, ULONG *puiCounts, ULONG *pulTimeStamps);
// write values in the puiCounts to registry. Timestamp is current one
BOOL WriteRegValues(_TCHAR **ppszNames, DWORD dwTotalNames, ULONG *puiCounts);
// scan the log file and get the count of number of lines
ULONG ScanLogFile(_TCHAR *szKDFailureLogFile);
// get the current TimeStamp value
ULONG GetCurrentTimeStamp();
// to add a specific time to a timestamp
ULONG AddTime(ULONG ulTimeStamp, ULONG ulMinutes);

// event ids and their messages.
// these are needed while reporting an event to SCM
#include "kdMonSvcMessages.h"

// This is key under HKEY_LOCAL_MACHINE
// Each service should have an entry as event source under this key
// Otherwise, the service can not do a ReportEvent
#define cszEventLogKey "SYSTEM\\CurrentControlSet\\Services\\EventLog\\Application"

// The stop event name
// used by kdMonSvc.cpp to create and signal a stop event
// used by kdMon.cpp to open and wait for stop event
#define cszStopEvent "kdMon_Stop_Event"

#define cszkdMonINIFile "kdMon.ini"

// log file used for debugging purpose
#define cszLogFile "C:\\kdMonservice.log"

// functions used for logging things
void AddServiceLog(_TCHAR pFormat[MAX_PATH * 4], ...);
void AppendToFile(_TCHAR szFileName[], _TCHAR szbuff[]);
void GetError(_TCHAR szError[]);


// constants used to recognize the file opening error
#define E_FILE_NOT_FOUND	-10
#define E_PATH_NOT_FOUND	-11
#define E_OTHER_FILE_ERROR	-12
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\kdmon\global.cpp ===
#include "kdMonSvcMessages.h"
#include <atlbase.h>
#include "global.h"

// The name of current service
_TCHAR szServiceName[MAX_PATH];

// whenever somebody uses GetError(), they use this variable 
_TCHAR szError[MAX_PATH];

///////////////////////////////////////////////////////////////////////////////////////
// Event Logging functions

// Setup the necessary registry keys in Event Log
// Without these registry keys, EventLog will not recognize this service as event source
LONG SetupEventLog(BOOL bSetKey)
{
	LONG lResult;

	_TCHAR szKey[MAX_PATH];
	_stprintf(szKey, _T("%s\\%s"), _T(cszEventLogKey), szServiceName);
	// we have to delete the key if bSetKey == FALSE
	if (bSetKey == FALSE) {
		lResult = RegDeleteKey(HKEY_LOCAL_MACHINE, szKey);
		return lResult;
	} else {
		CRegKey regKey;
		// try to open/create the key
		lResult = regKey.Create(HKEY_LOCAL_MACHINE, szKey);
		if (lResult != ERROR_SUCCESS) {
			return lResult;
		}

		//
		// create certain values under the key
		//

		// get path for the file containing the current process
		_TCHAR szModuleFileName[MAX_PATH];
		DWORD dwRetVal;
		dwRetVal = GetModuleFileName(	NULL, 
										szModuleFileName, 
										sizeof(szModuleFileName)/sizeof(_TCHAR)); // length in _TCHARs
		if ( dwRetVal == 0 ) {
			GetError(szError);
			AddServiceLog(_T("Error: SetupEventLog->GetModuleFileName: %s\r\n"), szError);
			LogEvent(_T("SetupEventLog: GetModuleFileName: %s"), szError);
			return (LONG) GetLastError();
		}

		lResult = regKey.SetValue(szModuleFileName, _T("EventMessageFile"));
		if (lResult != ERROR_SUCCESS) {
			return lResult;
		}

		lResult = regKey.SetValue(EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE,
								_T("TypesSupported"));
		if (lResult != ERROR_SUCCESS) {
			return lResult;
		}

		// close the key
		lResult = regKey.Close();
		if (lResult != ERROR_SUCCESS) {
			return lResult;
		}
	}
	return ERROR_SUCCESS;
}

// Log an event with EVENTLOG_INFORMATION_TYPE and eventID = EVENT_MESSAGE
void LogEvent(_TCHAR pFormat[MAX_PATH * 4], ...)
{
    _TCHAR    chMsg[4 * MAX_PATH];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[1];
    va_list pArg;

    va_start(pArg, pFormat);
    _vstprintf(chMsg, pFormat, pArg);
    va_end(pArg);

    lpszStrings[0] = chMsg;

    /* Get a handle to use with ReportEvent(). */
    hEventSource = RegisterEventSource(NULL, szServiceName);
    if (hEventSource != NULL)
    {
        /* Write to event log. */
        ReportEvent(hEventSource, EVENTLOG_INFORMATION_TYPE, 0, EVENT_MESSAGE, NULL, 1, 0, (LPCTSTR*) &lpszStrings[0], NULL);
        DeregisterEventSource(hEventSource);
    }
    else
    {
        // As we are not running as a service, just write the error to the console.
        _putts(chMsg);
    }
}

///////////////////////////////////////////////////////////////////////////////////////
// Log an event with EVENTLOG_ERROR_TYPE and eventID = EVENT_ERROR
void LogFatalEvent(_TCHAR pFormat[MAX_PATH * 4], ...)
{
    _TCHAR    chMsg[4 * MAX_PATH];
    HANDLE  hEventSource;
    LPTSTR  lpszStrings[1];
    va_list pArg;

    va_start(pArg, pFormat);
    _vstprintf(chMsg, pFormat, pArg);
    va_end(pArg);

    lpszStrings[0] = chMsg;

     
    /* Get a handle to use with ReportEvent(). */
    hEventSource = RegisterEventSource(NULL, szServiceName);
    if (hEventSource != NULL)
    {
        /* Write to event log. */
        ReportEvent(hEventSource, EVENTLOG_ERROR_TYPE, 0, EVENT_ERROR, NULL, 1, 0, (LPCTSTR*) &lpszStrings[0], NULL);
        DeregisterEventSource(hEventSource);
    }
 
}

///////////////////////////////////////////////////////////////////////////////////////
// Logging to file functions
// This logging is used for personal debugging

// Log the string to log file
void AddServiceLog(_TCHAR pFormat[MAX_PATH * 4], ...){

	va_list pArg;
	va_start(pArg, pFormat);
	_TCHAR chMsg[10 * MAX_PATH];
	_vstprintf(chMsg, pFormat, pArg);
	va_end(pArg);

	AppendToFile(_T(cszLogFile), chMsg);
}

// appends the specified string to the specified file
// here we reopen the file for writing everytime.
// so we can not directly use WriteFile() function.
// WriteFile() writes to file from current pointer position.
// So fisrt we have to reach to the file end. And then write there.
void AppendToFile(_TCHAR szFileName[], _TCHAR szbuff[]){

	HANDLE	hFile;
	hFile = CreateFile(	szFileName, 
						GENERIC_WRITE,              
						0,							// No sharing of file
						NULL,						// No security 
						OPEN_ALWAYS,				// Open if exist, else create and open
						FILE_ATTRIBUTE_NORMAL,		// Normal file 
						NULL);						// No attr. template 
 
	if (hFile == INVALID_HANDLE_VALUE) 
	{
		GetError(szError);
		LogEvent(_T("AppendToFile: CreateFile: %s"), szError);
		return;
	}

	DWORD	dwPos;
	// Reach the file end
	dwPos = SetFilePointer(	hFile, 
							0,						// Low 32 bits of distance to move
							NULL,					// High 32 bits of distance to move
							FILE_END);				// Starting point
	// If High Word is NULL, error meas dwPos = INVALID_SET_FILE_POINTER
	if(dwPos == INVALID_SET_FILE_POINTER){
		GetError(szError);
		LogEvent(_T("AppendToFile: SetFilePointer: %s"), szError);
		goto done;
	}

	// Lock the region in file to prevent another process from accessing 
	// it while writing to it. 

	// create an OVERLAPPED structure
	OVERLAPPED overlapRegion;
	overlapRegion.Offset = dwPos;				// Low order word of offset
	overlapRegion.OffsetHigh = 0;				// High order word of offset
	overlapRegion.hEvent = 0;

	BOOL	bRet;
	bRet = LockFileEx(	hFile,
						LOCKFILE_EXCLUSIVE_LOCK,		// dwFlags
						0,								// reserved
						_tcsclen(szbuff) * sizeof(_TCHAR),	// Low order word of length
						0,								// High order word of length
						&overlapRegion);
	if(bRet == 0){
		GetError(szError);
		LogEvent(_T("AppendToFile: LockFile: %s"), szError);
		goto done;
	}

	DWORD	dwBytesWritten;
	bRet = WriteFile(	hFile,
						szbuff,							// Buffer to write
						// 4 hours wasted for the following :-)
						_tcslen(szbuff) * sizeof(_TCHAR),	// Number of "bytes" to write
						&dwBytesWritten,				// Number of "bytes" written
						NULL);							// Pointer to OVERLAPPED structure
	if(bRet == 0){
		GetError(szError);
		LogEvent( _T("AppendToFile: WriteFile: %s"), szError);
		goto done;
	}	

	// Unlock the file if you have locked previously
	// Unlock the file when writing is finished. 
	bRet = UnlockFile(	hFile,	
						dwPos,							// Low order word of offset
						0,								// High order word of offset
						_tcsclen(szbuff) * sizeof(_TCHAR),	// Low order word of length
						0);								// High order word of length
	if(bRet == 0){
		GetError(szError);
		LogEvent(_T("AppendToFile: UnLockFile: %s"), szError);
		goto done;
	}

done:
	CloseHandle(hFile);
}

//
//This is valid to use only when the MSDN help suggests use of GetLastError() to get error 
//from that particular function.
//Some functions set the error system variable and only in that case, GetLastError() can be 
//used. Else it will show the error occured in a function that had set the error variable.
//
void GetError(_TCHAR szError[]){
	LPVOID lpMsgBuf;

	UINT uiRet;
	uiRet = FormatMessage(	FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | 
													FORMAT_MESSAGE_IGNORE_INSERTS,
							NULL,
							GetLastError(),
							MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),	// Default language
							(LPTSTR) &lpMsgBuf,
							// If FORMAT_MESSAGE_ALLOCATE_BUFFER is set, this parameter 
							// specifies the minimum number of _TCHARs to allocate for 
							// an output buffer
							0,
							NULL );
	if(uiRet == 0){
		LogEvent(_T("GetError->FormatMessage : %d"), GetLastError());
		_tcscpy(szError, _T(" "));
		return;
	}
	_tcscpy(szError, (LPTSTR)lpMsgBuf);
	// Free the buffer.
	LocalFree( lpMsgBuf );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\kdmon\ini.h ===
#pragma once

// for malloc/realloc functions
#include <malloc.h>

class CkdMonINI {
private:
	// seperate the Servers string got from INI file
	BOOL SeperateServerStrings();

public:
	// values in "Service" section of INI file
	_TCHAR szFromMailID[MAX_PATH];		// Mail ID from which the mail is send
	_TCHAR szToMailID[MAX_PATH];		// Mail ID to send alert mail to
    DWORD dwRepeatTime;				// Time after which logfile scanning is to be repeated. This is in minutes
	_TCHAR szDebuggerLogFile[MAX_PATH];	// Debugger log file
									// Contains the paths when KD fails
	_TCHAR szDebuggerLogArchiveDir[MAX_PATH];	// Debugger log file archive
    DWORD dwDebuggerThreshold;		// Threshold failures per server after which alert mail is to be sent out

	// values in "RPT Servers" section of INI file
	_TCHAR szServers[MAX_PATH];		// One string containing names of all RPT servers
	_TCHAR **ppszServerNameArray;	// Array containing individual ServerName strings
	DWORD dwServerCount;			// Total Number of Server Names

	// function to load these values from INI filename passed
	BOOL LoadValues(_TCHAR szINIFile[]);
	
	CkdMonINI();
	~CkdMonINI();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\kdmon\ini.cpp ===
#include "global.h"
#include "ini.h"

// constructor
CkdMonINI::CkdMonINI() {
	dwServerCount = 0;
	ppszServerNameArray = NULL;
}


BOOL CkdMonINI::LoadValues(_TCHAR szINIFile[])
{

	//
	//	Information in "Service" section of INI file
	//

	GetPrivateProfileString(	(LPCTSTR)(_T("Service")),
								(LPCTSTR)(_T("FromMailID")),
								(LPCTSTR)(_T("")),						// this parameter can not be NULL
								(LPTSTR) szFromMailID,
								sizeof(szFromMailID)/sizeof(_TCHAR),	// size in _TCHARs
								(LPCTSTR) szINIFile);
	// return if the MailID string is not there in INI file
	if ( _tcscmp(szFromMailID, _T("")) == 0 ) {
		AddServiceLog(_T("Error: From Mail ID is missing in INI file\r\n"));
		LogFatalEvent(_T("From Mail ID is missing in INI file"));
		return FALSE;
	}

	GetPrivateProfileString(	(LPCTSTR)(_T("Service")),
								(LPCTSTR)(_T("ToMailID")),
								(LPCTSTR)(_T("")),					// this parameter can not be NULL
								(LPTSTR) szToMailID,
								sizeof(szToMailID)/sizeof(_TCHAR),	// size in _TCHARs
								(LPCTSTR) szINIFile);
	// return if the MailID string is not there in INI file
	if ( _tcscmp(szToMailID, _T("")) == 0 ) {
		AddServiceLog(_T("Error: To Mail ID is missing in INI file\r\n"));
		LogFatalEvent(_T("To Mail ID is missing in INI file"));
		return FALSE;
	}

	// Time after which logfile scanning is to be repeated. This is in minutes
	dwRepeatTime = (DWORD)GetPrivateProfileInt(	(LPCTSTR)(_T("Service")),
												(LPCTSTR)(_T("RepeatTime")), 
												60,
												(LPCTSTR) szINIFile);
	// validate dwRepeatTime
	if ( dwRepeatTime < 1 ) dwRepeatTime = 60;

	// Debugger log file 
	// It will be something like C:\Debuggers\FailedAddCrash.log
	GetPrivateProfileString(	(LPCTSTR)(_T("Service")),
								(LPCTSTR)(_T("DebuggerLogFile")),
								(LPCTSTR)(_T("C$\\Debuggers\\FailedAddCrash.log")),
								(LPTSTR) szDebuggerLogFile,	
								sizeof(szDebuggerLogFile)/sizeof(_TCHAR),	// size in _TCHARs
								(LPCTSTR) szINIFile);

	// Log archive
	// Dir where the previous logs will be stored
	GetPrivateProfileString(	(LPCTSTR)(_T("Service")),
								(LPCTSTR)(_T("DebuggerLogArchiveDir")),
								(LPCTSTR)(_T("C:\\")),
								(LPTSTR) szDebuggerLogArchiveDir,	
								sizeof(szDebuggerLogArchiveDir)/sizeof(_TCHAR),	// size in _TCHARs
								(LPCTSTR) szINIFile);

	// Threshold failures per server after which alert mail is to be sent out
	// This Threshold is per server basis
	dwDebuggerThreshold = (DWORD)GetPrivateProfileInt(	(LPCTSTR)(_T("Service")),
														(LPCTSTR)(_T("DebuggerThreshold")), 
														10,
														(LPCTSTR) szINIFile);
	// validate dwDebuggerThreshold
	if ( dwDebuggerThreshold < 1 ) dwDebuggerThreshold = 10;

	GetPrivateProfileSection(	(LPCTSTR) (_T("RPT Servers")),
								(LPTSTR) szServers,
								sizeof(szServers)/sizeof(_TCHAR),
								(LPCTSTR) szINIFile);

	BOOL bRet;
	// seperate out the individual server names from szServers string
	bRet = SeperateServerStrings();
	if ( bRet == FALSE ) return FALSE;

	return TRUE;
}

// seperate the Servers string got from INI file
// the format of the string will be tkwucdrpta01'\0'tkwucdrpta02'\0'tkwucdrpta03'\0''\0'
BOOL CkdMonINI::SeperateServerStrings()
{

	// SeperateServerStrings gets called every time you read INI
	// and you read INI every dwRepeatTime
	// So we need to free the ppszServerNameArray out of previous execution of this
	// function
	for(DWORD i = 0; i < dwServerCount; i++) {
		free(ppszServerNameArray[i]);
	}
	if ( ppszServerNameArray != NULL )
		free(ppszServerNameArray);


	// temperory pointer to move through the szServers string
	_TCHAR* pszServers;
	pszServers = szServers;

	dwServerCount = 0;
	ppszServerNameArray = NULL;

	// the format of the szServers will be 
	// tkwucdrpta01'\0'tkwucdrpta02'\0'tkwucdrpta03'\0''\0'
	while(1) {
		if( *pszServers == _T('\0') )
			break;

		dwServerCount++;

		// allocate memory for ppszServerNameArray
		if ( ppszServerNameArray == NULL ) {
			ppszServerNameArray = (_TCHAR **) malloc (dwServerCount * sizeof(_TCHAR**));
			if ( ppszServerNameArray == NULL ) {
				AddServiceLog(_T("Error: SeperateServerStrings->malloc: Insufficient memory available\r\n"));
				LogFatalEvent(_T("SeperateServerStrings->malloc: Insufficient memory available"));
				return FALSE;
			}
		}
		else {
			ppszServerNameArray = (_TCHAR **) realloc (	ppszServerNameArray,
														dwServerCount * sizeof(_TCHAR**));
			if ( ppszServerNameArray == NULL ) {
				AddServiceLog(_T("Error: SeperateServerStrings->realloc: Insufficient memory available\r\n"));
				LogFatalEvent(_T("SeperateServerStrings->realloc: Insufficient memory available"));
				return FALSE;
			}
		}

		ppszServerNameArray[dwServerCount - 1] = 
			(_TCHAR *) malloc ( (_tcslen(pszServers) + 1) * sizeof(_TCHAR) );
		if ( ppszServerNameArray[dwServerCount - 1] == NULL ) {
			AddServiceLog(_T("Error: SeperateServerStrings->malloc: Insufficient memory available\r\n"));
			LogFatalEvent(_T("SeperateServerStrings->malloc: Insufficient memory available"));
			return FALSE;
		}

		_tcscpy(ppszServerNameArray[dwServerCount - 1], pszServers);
		
		// take pszServers one character beyond the end of the string
		pszServers += _tcslen(pszServers);

		// advance to the next string
		pszServers++;
	}

	return TRUE;
}

// destructor
CkdMonINI::~CkdMonINI()
{
	// free the whole ppszServerNameArray
	for(DWORD i = 0; i < dwServerCount; i++) {
		free(ppszServerNameArray[i]);
	}
	if ( ppszServerNameArray != NULL )
		free(ppszServerNameArray);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\kdmon\kdmonsvc.cpp ===
// kdMonSvc.cpp : Implementation of WinMain


// Note: Proxy/Stub Information
//      To build a separate proxy/stub DLL, 
//      run nmake -f kdMonSvcps.mk in the project directory.

#include "stdafx.h"
#include "resource.h"
#include <initguid.h>
#include "kdMonSvc.h"

#include "kdMonSvc_i.c"

#include "global.h"

// The name of current service
// This variable is declared in global.cpp
extern _TCHAR szServiceName[MAX_PATH];
// just to get any kind of error through GetError() routine
// This variable is declared in global.cpp
extern _TCHAR szError[MAX_PATH];

CServiceModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
END_OBJECT_MAP()

// worker thread function
DWORD WINAPI WorkerThread( LPVOID lpParam );


LPCTSTR FindOneOf(LPCTSTR p1, LPCTSTR p2)
{
    while (p1 != NULL && *p1 != NULL)
    {
        LPCTSTR p = p2;
        while (p != NULL && *p != NULL)
        {
            if (*p1 == *p)
                return CharNext(p1);
            p = CharNext(p);
        }
        p1 = CharNext(p1);
    }
    return NULL;
}

// Although some of these functions are big they are declared inline since they are only used once

inline HRESULT CServiceModule::RegisterServer(BOOL bRegTypeLib, BOOL bService)
{
    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;

	// -- Added code to default --
	// Setup event logging
	//
	LONG lResult;
	lResult = SetupEventLog(TRUE);
    if (lResult != ERROR_SUCCESS)
        return lResult;

	// -- Added code to default --
	// if the service is already installed then dont do anything.
	// RegisterServer(..) tries to Uninstall() a service before trying to 
	// Register it again. If you have already started a service, created a thread,
	// and waiting for that thread to finish and you issue command 
	// kdMonSvc /service then RegisterServer() tries to call Uninstall().
	// And you can not Uninstall() in this state since MainThread is waiting for
	// WorkerThread to finish. So just return back from here
	if(IsInstalled()){
		MessageBox(NULL, _T("Service is already installed.\n Please unregister the service useing: kdMonSvc /unregserver"), NULL, MB_OK|MB_ICONEXCLAMATION);
		return ERROR_SUCCESS;
	}

    // Remove any previous service since it may point to
    // the incorrect file
    Uninstall();

    // Add service entries
    UpdateRegistryFromResource(IDR_kdMonSvc, TRUE);

    // Adjust the AppID for Local Server or Service
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_WRITE);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    CRegKey key;
    lRes = key.Open(keyAppID, _T("{6961AED3-A5FA-46EE-862F-B50433EEF17E}"), KEY_WRITE);
    if (lRes != ERROR_SUCCESS)
        return lRes;
    key.DeleteValue(_T("LocalService"));
    
    if (bService)
    {
        key.SetValue(_T("kdMonSvc"), _T("LocalService"));
        key.SetValue(_T("-Service"), _T("ServiceParameters"));
        // Create service
        Install();
    }

    // Add object entries
    hr = CComModule::RegisterServer(bRegTypeLib);

    CoUninitialize();
    return hr;
}

inline HRESULT CServiceModule::UnregisterServer()
{

    HRESULT hr = CoInitialize(NULL);
    if (FAILED(hr))
        return hr;
	//
	// Remove eventlog stuff
	//
	SetupEventLog(FALSE);

    // Remove service entries
    UpdateRegistryFromResource(IDR_kdMonSvc, FALSE);
    // Remove service
    Uninstall();
    // Remove object entries
    CComModule::UnregisterServer(TRUE);
    CoUninitialize();
    return S_OK;
}

inline void CServiceModule::Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid)
{
    CComModule::Init(p, h, plibid);

    m_bService = TRUE;

    LoadString(h, nServiceNameID, m_szServiceName, sizeof(m_szServiceName) / sizeof(_TCHAR));

	// -- Added code to default --
	// copy the service name into szServiceName, a global variable
	_tcscpy(szServiceName, m_szServiceName);

    // set up the initial service status 
    m_hServiceStatus = NULL;
    m_status.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    m_status.dwCurrentState = SERVICE_STOPPED;
    m_status.dwControlsAccepted = SERVICE_ACCEPT_STOP;
    m_status.dwWin32ExitCode = 0;
    m_status.dwServiceSpecificExitCode = 0;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;
}

LONG CServiceModule::Unlock()
{
    LONG l = CComModule::Unlock();
    if (l == 0 && !m_bService)
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
    return l;
}

BOOL CServiceModule::IsInstalled()
{
    BOOL bResult = FALSE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM != NULL)
    {
        SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_QUERY_CONFIG);
        if (hService != NULL)
        {
            bResult = TRUE;
            ::CloseServiceHandle(hService);
        }
        ::CloseServiceHandle(hSCM);
    }
    return bResult;
}

inline BOOL CServiceModule::Install()
{
    if (IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);
    if (hSCM == NULL)
    {
        MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
    }

    // Get the executable file path
    _TCHAR szFilePath[_MAX_PATH];
    ::GetModuleFileName(NULL, szFilePath, _MAX_PATH);

    SC_HANDLE hService = ::CreateService(
        hSCM, m_szServiceName, m_szServiceName,
        SERVICE_ALL_ACCESS, SERVICE_WIN32_OWN_PROCESS,
        SERVICE_DEMAND_START, SERVICE_ERROR_NORMAL,
        szFilePath, NULL, NULL, _T("RPCSS\0"), NULL, NULL);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, _T("Couldn't create service"), m_szServiceName, MB_OK);
        return FALSE;
    }

    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);
    return TRUE;
}

inline BOOL CServiceModule::Uninstall()
{
    if (!IsInstalled())
        return TRUE;

    SC_HANDLE hSCM = ::OpenSCManager(NULL, NULL, SC_MANAGER_ALL_ACCESS);

    if (hSCM == NULL)
    {
        MessageBox(NULL, _T("Couldn't open service manager"), m_szServiceName, MB_OK);
        return FALSE;
    }

    SC_HANDLE hService = ::OpenService(hSCM, m_szServiceName, SERVICE_STOP | DELETE);

    if (hService == NULL)
    {
        ::CloseServiceHandle(hSCM);
        MessageBox(NULL, _T("Couldn't open service"), m_szServiceName, MB_OK);
        return FALSE;
    }
    SERVICE_STATUS status;
    ::ControlService(hService, SERVICE_CONTROL_STOP, &status);

    BOOL bDelete = ::DeleteService(hService);
    ::CloseServiceHandle(hService);
    ::CloseServiceHandle(hSCM);

    if (bDelete)
        return TRUE;

    MessageBox(NULL, _T("Service could not be deleted"), m_szServiceName, MB_OK);
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////////
// Service startup and registration
inline void CServiceModule::Start()
{
    SERVICE_TABLE_ENTRY st[] =
    {
        { m_szServiceName, _ServiceMain },
        { NULL, NULL }
    };
    if (m_bService && !::StartServiceCtrlDispatcher(st))
    {
        m_bService = FALSE;
    }
    if (m_bService == FALSE)
        Run();
}

inline void CServiceModule::ServiceMain(DWORD /* dwArgc */, LPTSTR* /* lpszArgv */)
{
    // Register the control request handler
    m_status.dwCurrentState = SERVICE_START_PENDING;
    m_hServiceStatus = RegisterServiceCtrlHandler(m_szServiceName, _Handler);
    if (m_hServiceStatus == NULL)
    {
        LogEvent(_T("Handler not installed"));
        return;
    }
    SetServiceStatus(SERVICE_START_PENDING);

    m_status.dwWin32ExitCode = S_OK;
    m_status.dwCheckPoint = 0;
    m_status.dwWaitHint = 0;

    // When the Run function returns, the service has stopped.
    Run();

    SetServiceStatus(SERVICE_STOPPED);
    LogEvent(_T("Service stopped"));
}

inline void CServiceModule::Handler(DWORD dwOpcode)
{
    switch (dwOpcode)
    {
    case SERVICE_CONTROL_STOP:
        SetServiceStatus(SERVICE_STOP_PENDING);
		// post WM_QUIT message to current thread 
		// the GetMessage() loop will get this message and terminate the service
        PostThreadMessage(dwThreadID, WM_QUIT, 0, 0);
        break;
    case SERVICE_CONTROL_PAUSE:
        break;
    case SERVICE_CONTROL_CONTINUE:
        break;
    case SERVICE_CONTROL_INTERROGATE:
        break;
    case SERVICE_CONTROL_SHUTDOWN:
        break;
    default:
        LogEvent(_T("Bad service request"));
    }
}

void WINAPI CServiceModule::_ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv)
{
    _Module.ServiceMain(dwArgc, lpszArgv);
}
void WINAPI CServiceModule::_Handler(DWORD dwOpcode)
{
    _Module.Handler(dwOpcode); 
}

void CServiceModule::SetServiceStatus(DWORD dwState)
{
    m_status.dwCurrentState = dwState;
    ::SetServiceStatus(m_hServiceStatus, &m_status);
}

void CServiceModule::Run()
{
    _Module.dwThreadID = GetCurrentThreadId();

    HRESULT hr = CoInitialize(NULL);
//  If you are running on NT 4.0 or higher you can use the following call
//  instead to make the EXE free threaded.
//  This means that calls come in on a random RPC thread
//  HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    _ASSERTE(SUCCEEDED(hr));

    // This provides a NULL DACL which will allow access to everyone.
    CSecurityDescriptor sd;
    sd.InitializeFromThreadToken();
    hr = CoInitializeSecurity(sd, -1, NULL, NULL,
        RPC_C_AUTHN_LEVEL_PKT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE, NULL);
    _ASSERTE(SUCCEEDED(hr));

    hr = _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER | CLSCTX_REMOTE_SERVER, REGCLS_MULTIPLEUSE);
    _ASSERTE(SUCCEEDED(hr));

	AddServiceLog(_T("kdMon service starting\r\n"));
    if (m_bService)
        SetServiceStatus(SERVICE_RUNNING);

	// create a named event which the thread will open and refer to
	// this event is used to signal "Stop" to WorkerThread
	HANDLE  hStopEvent = NULL;
	hStopEvent = CreateEvent(	NULL,	// security attributes
								FALSE,	// = Automatic reset of event by system
								FALSE,
								(LPCTSTR)_T(cszStopEvent));
								
	if ( hStopEvent == NULL ) {
		GetError(szError);
		LogFatalEvent(_T("Run->CreateEvent : %s"), szError);
		AddServiceLog(_T("Error: Run->CreateEvent : %s\r\n"), szError);
		goto done;
	}

	// -- Added code to default --
	//
	// Create worker thread here
	//

	LogEvent(_T("Creating worker thread"));
	AddServiceLog(_T("Creating worker thread\r\n"));

	DWORD dwWorkerThreadId;
	HANDLE hWorkerThread;

	hWorkerThread = CreateThread(	NULL,	// security descriptor
									0,		// initial stack size
									WorkerThread,	// thread start address
									&dwThreadID,	// thread arguments (current threadID)
									0,		// creation flags = run immediately
									&dwWorkerThreadId);

	if ( hWorkerThread == NULL ) {
		GetError(szError);
		LogFatalEvent(_T("Run->CreateThread : %s"), szError);
		AddServiceLog(_T("Error: Run->CreateThread : %s\r\n"), szError);
		goto done;
	}

    MSG msg;

	BOOL bRetVal;
	// GetMessage ():
	// If the function retrieves a message other than WM_QUIT, the return value is nonzero.
	// If the function retrieves the WM_QUIT message, the return value is zero.
	while ( (bRetVal = GetMessage(&msg, NULL, 0, 0)) != 0 ) {
		// send it to default dispatcher
		DispatchMessage(&msg);
	}

	AddServiceLog(_T("Main thread received WM_QUIT message\r\n"));

	AddServiceLog(_T("Terminating kdMon Service\r\n"));
	LogEvent(_T("Terminating kdMon Service"));

	// check if worker thread is still active.
	// i.e. check hWorkerThread for a signalled state
	DWORD dwRetVal;
	AddServiceLog(_T("Main thread checking if WorkerThread is still active\r\n"));
	dwRetVal = WaitForSingleObject( hWorkerThread, 0 );
	if ( dwRetVal == WAIT_FAILED ) {
		GetError(szError);
		LogFatalEvent(_T("Run->WaitForSingleObject : %s"), szError);
		AddServiceLog(_T("Error: Run->WaitForSingleObject : %s\r\n"), szError);
		goto done;
	}

	// if hWorkerThread is not in signalled state then try to signal it
	if ( dwRetVal != WAIT_OBJECT_0 ) {
		// Signal the Stop Event, so that the worker thread stops
		AddServiceLog(_T("Signalling Stop Event to Worker Thread\r\n"));
		bRetVal = SetEvent(hStopEvent);
		if ( bRetVal == 0 ) {
			GetError(szError);
			LogFatalEvent(_T("Run->SetEvent : %s"), szError);
			AddServiceLog(_T("Error: Run->SetEvent : %s\r\n"), szError);
			goto done;
		}

		// Now we have signalled the thread to end, wait till the thread ends gracefully
		// We can use WaitForSingleObject API for this purpose
		// CreateThread () : When a thread terminates, the thread object 
		// attains a signaled state, satisfying any threads that were waiting on the object. 
		// so we can make this main thread to wait for the WorkerThread to terminate
		AddServiceLog(_T("Main thread waiting for WorkerThread to exit\r\n"));
		dwRetVal = WaitForSingleObject( hWorkerThread, INFINITE );
		if ( dwRetVal == WAIT_FAILED ) {
			GetError(szError);
			LogFatalEvent(_T("Run->WaitForSingleObject : %s"), szError);
			AddServiceLog(_T("Error: Run->WaitForSingleObject : %s\r\n"), szError);
			goto done;
		}
	}

done:

	if ( hWorkerThread != NULL ) CloseHandle(hWorkerThread);
	if ( hStopEvent != NULL ) CloseHandle(hStopEvent);

    _Module.RevokeClassObjects();

    CoUninitialize();
}

/////////////////////////////////////////////////////////////////////////////
//
extern "C" int WINAPI _tWinMain(HINSTANCE hInstance, 
    HINSTANCE /*hPrevInstance*/, LPTSTR lpCmdLine, int /*nShowCmd*/)
{
    lpCmdLine = GetCommandLine(); //this line necessary for _ATL_MIN_CRT
    _Module.Init(ObjectMap, hInstance, IDS_SERVICENAME, &LIBID_KDMONSVCLib);
    _Module.m_bService = TRUE;

	AddServiceLog(_T("Command received : %s\r\n"), lpCmdLine);

	// tokenize on '-' or '/' characters
    _TCHAR szTokens[] = _T("-/");

    LPCTSTR lpszToken = FindOneOf(lpCmdLine, szTokens);
    while (lpszToken != NULL)
    {
        if (lstrcmpi(lpszToken, _T("UnregServer"))==0)
            return _Module.UnregisterServer();

        // Register as Local Server
        if (lstrcmpi(lpszToken, _T("RegServer"))==0)
            return _Module.RegisterServer(TRUE, FALSE);
        
        // Register as Service
        if (lstrcmpi(lpszToken, _T("Service"))==0)
            return _Module.RegisterServer(TRUE, TRUE);
        
        lpszToken = FindOneOf(lpszToken, szTokens);
    }

    // Are we Service or Local Server
    CRegKey keyAppID;
    LONG lRes = keyAppID.Open(HKEY_CLASSES_ROOT, _T("AppID"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    CRegKey key;
    lRes = key.Open(keyAppID, _T("{6961AED3-A5FA-46EE-862F-B50433EEF17E}"), KEY_READ);
    if (lRes != ERROR_SUCCESS)
        return lRes;

    _TCHAR szValue[_MAX_PATH];
    DWORD dwLen = _MAX_PATH;
    lRes = key.QueryValue(szValue, _T("LocalService"), &dwLen);

    _Module.m_bService = FALSE;
    if (lRes == ERROR_SUCCESS)
        _Module.m_bService = TRUE;

    _Module.Start();

    // When we get here, the service has been stopped
    return _Module.m_status.dwWin32ExitCode;
}

///////////////////////////////////////////////////////////////////////////////////////
// Worker thread. Main thread that does all the kdMon work
DWORD WINAPI WorkerThread(LPVOID lpParam)
{

	// get the parent thread ID
	// dwParentThreadID is the parent thread ID. This is used to signal
	// main thread that worker thread is ending due to some reason
	// and then main thread should also end and stop the service
	DWORD dwParentThreadID = *(DWORD*) lpParam;

	AddServiceLog(_T("Worker thread starting kdMon routine\r\n"));

	// main kdMon method which is a while(1) loop.
	kdMon();

	LogEvent(_T("Worker Thread ending"));
	AddServiceLog(_T("Worker Thread ending\r\n"));

	// signal the parent thread with WM_QUIT before exiting
	PostThreadMessage(dwParentThreadID, WM_QUIT, 0, 0);

	return GetLastError();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\kdmon\kdmonsvc.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Wed Jun 05 18:06:33 2002
 */
/* Compiler settings for C:\NT\privates\kdMon\kdMonSvc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 440
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __kdMonSvc_h__
#define __kdMonSvc_h__

/* Forward Declarations */ 

/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void __RPC_FAR * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void __RPC_FAR * ); 


#ifndef __KDMONSVCLib_LIBRARY_DEFINED__
#define __KDMONSVCLib_LIBRARY_DEFINED__

/* library KDMONSVCLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_KDMONSVCLib;
#endif /* __KDMONSVCLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\kdmon\kdmon.cpp ===
#include "stdafx.h"
#include "global.h"
// to include CkdMonINI class definition
#include "ini.h"
#include "SMTP.h"

// The name of current service
// This variable is declared in global.cpp
extern _TCHAR szServiceName[MAX_PATH];
// just to get any kind of error through GetError() routine
// This variable is declared in global.cpp
extern _TCHAR szError[MAX_PATH];

// this is used by LoadINI function also. So it is made global
CkdMonINI kdMonINI;

void kdMon() {

	// SMTP object
	CSMTP smtpObj;

	// This variable is used by IsSignaledToStop() function.
	// open the stop event which is created by kdMonSvc
	// For any event, the name of the event matters and the handle does not.
	HANDLE hStopEvent = NULL;

	// open the cszStopEvent which is meant to signal this thread to stop.
	// this signalling is done by main service thread when WM_QUIT is received
	hStopEvent = OpenEvent(	EVENT_ALL_ACCESS, 
							FALSE,			// = handle can not be inherited
							(LPCTSTR)_T(cszStopEvent));
	if ( hStopEvent == NULL ) {
		GetError(szError);
		LogFatalEvent(_T("kdMon->OpenEvent: %s"), szError);
		AddServiceLog(_T("Error: kdMon->OpenEvent: %s\r\n"), szError);
		goto endkdMon;
	}

	BOOL bLoop;
	bLoop = TRUE;

	while(bLoop) {

		AddServiceLog(_T("\r\n- - - - - - @ @ @ @ @ @ @ @ @ @ - - - - - - - - - - - @ @ @ @ @ @ @ @ @ @ @ - - - - - - - \r\n"));

		// temperory boolean to receive return values from functions
		BOOL bRet;
		
		// load the values from INI file
		// since INI file is read each time the loop gets executed, 
		// we can change the running parameters of the service on the fly
		// If values loading is not successful then close the service : bLoop = FALSE;
		bRet = LoadINI();
		if ( bRet == FALSE ) {
			bLoop = FALSE;
			goto closeandwait;
		}

		bRet = smtpObj.InitSMTP();
		// if SMTP can not be initiated, then do nothing. try in next database cycle.
		if ( bRet == FALSE ) {
			goto closeandwait;
		}

		// generate an array to store failure counts for each server
		ULONG *pulFailureCounts;
		pulFailureCounts = NULL;
		pulFailureCounts = (ULONG *) malloc (kdMonINI.dwServerCount * sizeof(ULONG));
		if ( pulFailureCounts == NULL ) {
			AddServiceLog(_T("Error: kdMon->malloc: Insufficient memory\r\n"));
			LogFatalEvent(_T("kdMon->malloc: Insufficient memory"));
			bLoop = FALSE;
			goto closeandwait;
		}

		// generate an array to store timestamp for count from each server
		ULONG *pulTimeStamps;
		pulTimeStamps = NULL;
		pulTimeStamps = (ULONG *) malloc (kdMonINI.dwServerCount * sizeof(ULONG));
		if ( pulTimeStamps == NULL ) {
			AddServiceLog(_T("Error: kdMon->malloc: Insufficient memory\r\n"));
			LogFatalEvent(_T("kdMon->malloc: Insufficient memory"));
			bLoop = FALSE;
			goto closeandwait;
		}

		// load the values from registry for the server to be monitored
		// since INI file is read each time the loop gets executed, 
		// we can change the server names on the fly
		// we get counts for each server in pulFailureCounts
		// we get corresponding TimeStamps in pulTimeStamps
		bRet = ReadRegValues(	kdMonINI.ppszServerNameArray,
								kdMonINI.dwServerCount,
								pulFailureCounts,
								pulTimeStamps);
		if ( bRet == FALSE )
			goto closeandwait;

		// counter to go through server names
		UINT uiServerCtr;
		for( uiServerCtr = 0; uiServerCtr < kdMonINI.dwServerCount; uiServerCtr++) {

			// prepare Log File Name on the server
			_TCHAR szKDFailureLogFile[MAX_PATH * 2];
			_stprintf(szKDFailureLogFile, _T("\\\\%s\\%s"),
					kdMonINI.ppszServerNameArray[uiServerCtr],
					kdMonINI.szDebuggerLogFile);

			ULONG ulRet;
			// scan the log file and get the count of number of lines
			ulRet = ScanLogFile(szKDFailureLogFile);

			// AddServiceLog(_T("ulRet = %ld\r\n"), ulRet);

			if ( ulRet == E_FILE_NOT_FOUND ) {
				// file not found means there are no Debugger errors
				// So put count = 0 and go on with next server
				pulFailureCounts[uiServerCtr] = 0;
				continue;
			}
			if ( ulRet == E_PATH_NOT_FOUND ) {
				// path not found means there is some network error
				// So put count = -1 so next time this count wont be valid
				// and go on with next server
				pulFailureCounts[uiServerCtr] = -1;
				continue;
			}
			// some other error occurred
			if ( ulRet == E_OTHER_FILE_ERROR ) {
				// So put count = -1 so next time this count wont be valid
				// and go on with next server
				pulFailureCounts[uiServerCtr] = -1;
				continue;
			}

			ULONG ulNumLines;
			ulNumLines = ulRet;

			// if previous count was -1 i.e. invalid, just put new count and move on
			// similar if previous TimeStamp was invalid
			if ( (pulFailureCounts[uiServerCtr] == -1) || 
					pulTimeStamps[uiServerCtr] == -1) {
				pulFailureCounts[uiServerCtr] = ulNumLines;
				continue;
			}

			// get the current system time
			// ulTimeStamp is like 200112171558
			ULONG ulCurrentTimeStamp;
			ulCurrentTimeStamp = GetCurrentTimeStamp();
			if ( ulCurrentTimeStamp == -1 ) {
				pulFailureCounts[uiServerCtr] = ulNumLines;
				continue;
			}

			// we have kdMonINI.dwRepeatTime in minutes (say 78)
			// take out hours and minutes (1 Hr 18 Min)
			// between 0112181608 and 0112181726 there is difference of 1 Hr 18 Min
			// but decimal difference is 118
			// between 0112181650 and 0112181808 there is difference of 1 Hr 18 Min
			// but decimal difference is 158
			// so we have some calculation here
			// what we will do is add the kdMonINI.dwRepeatTime to OldTS
			// modify the previous timestamp to do the comparison
			ULONG ulModifiedTS;
			ulModifiedTS = AddTime(pulTimeStamps[uiServerCtr], kdMonINI.dwRepeatTime);
			AddServiceLog(_T("Server: %s, OldTS: %ld, NewTS: %ld, OldCnt: %ld, NewCnt: %ld, ulModifiedTS = %ld\r\n"),
						kdMonINI.ppszServerNameArray[uiServerCtr],
						pulTimeStamps[uiServerCtr],
						ulCurrentTimeStamp,
						pulFailureCounts[uiServerCtr],
						ulNumLines, ulModifiedTS);

			// check the timestamp difference. Keep margin of 3
			// if the previous timestamp was > dwRepeatTime ago then dont do anything
			// just record the new count This case happens when there is a Servername in
			// INI, then it is removed for some time and then it is added again
			// this helps to send false mails out

			if ( ulCurrentTimeStamp > (ulModifiedTS + 3) ) {
				AddServiceLog(_T("Previous record invalid. ulCurrentTimeStamp: %ld, ulModifiedTS: %ld"),
						ulCurrentTimeStamp,	ulModifiedTS);
				pulFailureCounts[uiServerCtr] = ulNumLines;
				continue;
			}

			// check the difference between current and previous counts
			ULONG ulFailures;
			ulFailures = ulNumLines - pulFailureCounts[uiServerCtr];
			if ( ulFailures >= kdMonINI.dwDebuggerThreshold ) {
				AddServiceLog(_T("KD failed. %ld errors in %ld minutes\r\n"),
						ulFailures, kdMonINI.dwRepeatTime);
				
				// fill the mail parameters structure
				StructMailParams stMailParams;
				_tcscpy(stMailParams.szFrom, kdMonINI.szFromMailID);
				_tcscpy(stMailParams.szTo, kdMonINI.szToMailID);
				_tcscpy(stMailParams.szServerName, kdMonINI.ppszServerNameArray[uiServerCtr]);
				stMailParams.ulFailures = ulFailures;
				stMailParams.ulInterval = kdMonINI.dwRepeatTime;
				stMailParams.ulCurrentTimestamp = ulCurrentTimeStamp;

				BOOL bRet;
				bRet = smtpObj.SendMail(stMailParams);
				// dont care even if you were not able to send mail
				//if ( bRet == FALSE )
				//	goto nextserver;
			}

			// store new count in the array
			pulFailureCounts[uiServerCtr] = ulNumLines;

			// see if the date has changed, if yes then move the previous logfile to
			// new location
			// example of date change OldTS: 200112182348, NewTS: 200112190048
			// so divide timestamp by 10000 and you get 20011218 and 20011219 compare

			ULONG ulOldDate, ulNewDate;
			ulOldDate = pulTimeStamps[uiServerCtr]/10000;
			ulNewDate = ulCurrentTimeStamp/10000;
			if ( (ulNewDate - ulOldDate) >= 1 ) {
				AddServiceLog(_T("Day changed. Oldday: %ld, Newday: %ld\r\n"),
								ulOldDate, ulNewDate);

				// Log File Name 
				_TCHAR szKDFailureLogFile[MAX_PATH * 2];
				_stprintf(szKDFailureLogFile, _T("\\\\%s\\%s"),
						kdMonINI.ppszServerNameArray[uiServerCtr],
						kdMonINI.szDebuggerLogFile);

				// now since date has changed, prepare archive filename
				_TCHAR szTimeStamp[MAX_PATH];
				_ltot(ulOldDate, szTimeStamp, 10);
				// prepare Archive Log File Name on the server
				_TCHAR szKDFailureArchiveFile[MAX_PATH * 2];
				_stprintf(szKDFailureArchiveFile, _T("%s\\%s_FailedAddCrash%s.log"),
					kdMonINI.szDebuggerLogArchiveDir,
					kdMonINI.ppszServerNameArray[uiServerCtr],
					szTimeStamp);

				AddServiceLog(_T("Moving file (%s -> %s)\r\n"), 
					szKDFailureLogFile, szKDFailureArchiveFile);

				// copy file to destination
				if ( CopyFile(szKDFailureLogFile, szKDFailureArchiveFile, FALSE) ) {
					// try to delete the original kd failure log file
					if ( DeleteFile(szKDFailureLogFile) ) {
						// set new count to 0 since log has been moved successfully
						pulFailureCounts[uiServerCtr] = 0;
					}
					else {
						GetError(szError);
						AddServiceLog(_T("Error: kdMon->DeleteFile(%s): %s \r\n"), 
							szKDFailureLogFile, szError);
						LogEvent(_T("Error: kdMon->DeleteFile(%s): %s"),
							szKDFailureLogFile, szError);
						// try to delete the copied file
						if ( DeleteFile(szKDFailureArchiveFile) ) {
							;
						}
						else {
							GetError(szError);
							AddServiceLog(_T("Error: kdMon->DeleteFile(%s): %s \r\n"), 
								szKDFailureArchiveFile, szError);
							LogEvent(_T("Error: kdMon->DeleteFile(%s): %s"),
								szKDFailureArchiveFile, szError);
						}
					}
				}
				else {
					GetError(szError);
					AddServiceLog(_T("Error: kdMon->CopyFile(%s, %s): %s \r\n"), 
						szKDFailureLogFile, szKDFailureArchiveFile, szError);
					LogEvent(_T("Error: kdMon->CopyFile(%s, %s): %s"),
						szKDFailureLogFile, szKDFailureArchiveFile, szError);
				}
			}
		}

		// write the values to registry for the servers to be monitored
		// counts for each server are in pulFailureCounts
		// timestamp is current time
		bRet = WriteRegValues(	kdMonINI.ppszServerNameArray,
								kdMonINI.dwServerCount,
								pulFailureCounts);
		if ( bRet == FALSE )
			goto closeandwait;

closeandwait:

		// cleanup SMTP resources
		bRet = smtpObj.SMTPCleanup();
		if( bRet == FALSE ) {
			AddServiceLog(_T("Error: smtpObj.SMTPCleanup failed\r\n"));
			LogFatalEvent(_T("smtpObj.SMTPCleanup failed"));
		}

		// free uiFailureCounts
		if (pulFailureCounts != NULL)
			free(pulFailureCounts);

		// free pulTimeStamps
		if (pulTimeStamps != NULL)
			free(pulTimeStamps);

		// break the while loop if bLoop is false
		if (bLoop == FALSE) {
			goto endkdMon;
		}

		bRet = IsSignaledToStop(hStopEvent, kdMonINI.dwRepeatTime * 60 * 1000);
		if (bRet == TRUE) {
			goto endkdMon;
		}
	} // while(bLoop)

endkdMon:

	if (hStopEvent != NULL) CloseHandle(hStopEvent);
	return;
}

BOOL IsSignaledToStop(const HANDLE hStopEvent, DWORD dwMilliSeconds) 
{
	DWORD dwRetVal;
	dwRetVal = WaitForSingleObject( hStopEvent, dwMilliSeconds );
	if ( dwRetVal == WAIT_FAILED ) {
		GetError(szError);
		LogFatalEvent(_T("IsSignaledToStop->WaitForSingleObject: %s"), szError);
		AddServiceLog(_T("Error: IsSignaledToStop->WaitForSingleObject: %s\r\n"), szError);
		// thread is supposed to stop now since there is a fatal error
		return TRUE;
	}
	if ( dwRetVal == WAIT_OBJECT_0 ) {
		LogEvent(_T("Worker Thread received Stop Event."));
		AddServiceLog(_T("Worker Thread received Stop Event.\r\n"));
		// thread is supposed to stop now since there is a stop event occured
		return TRUE;
	}

	// thread is not yet signaled to stop
	return FALSE;
}

// this procedure loads the values from INI file
BOOL LoadINI() {

	DWORD dwRetVal;

	//
	// prepare INI file path
	//
	_TCHAR szCurrentDirectory[MAX_PATH];
	dwRetVal = GetCurrentDirectory(	sizeof(szCurrentDirectory) / sizeof(_TCHAR), 	
									(LPTSTR) szCurrentDirectory);
	if ( dwRetVal == 0 ) { 
		LogFatalEvent(_T("LoadINI->GetCurrentDirectory: %s"), szError);
		AddServiceLog(_T("Error: LoadINI->GetCurrentDirectory: %s\r\n"), szError);
		// return FALSE indicating some error has occurred
		return FALSE;
	}
	_TCHAR szINIFilePath[MAX_PATH];
	_stprintf(szINIFilePath, _T("%s\\%s"), szCurrentDirectory, _T(cszkdMonINIFile));

	// check if the kdMon INI file is there or not
	HANDLE hINIFile;
	WIN32_FIND_DATA w32FindData = {0};
	// try to get the handle to the file
	hINIFile = FindFirstFile(	(LPCTSTR) szINIFilePath, 
								&w32FindData);
	// if file is not there then the handle is invalid
	if(hINIFile == INVALID_HANDLE_VALUE){
		LogFatalEvent(_T("There is no kdMon INI file : %s"), szINIFilePath);
		AddServiceLog(_T("Error: There is no kdMon INI file : %s \r\n"), szINIFilePath);
		return FALSE;
	}
	else{
		FindClose(hINIFile);
	}

	BOOL bRetVal;
	bRetVal = kdMonINI.LoadValues(szINIFilePath);
	if ( bRetVal == FALSE ) return bRetVal;

	//
	// check if values are getting in properly from INI file
	//
	AddServiceLog(_T("\r\n============== I N I     V A L U E S ==============\r\n"));
	AddServiceLog(_T("szToMailID : %s \r\n"), kdMonINI.szToMailID);
	AddServiceLog(_T("szFromMailID : %s \r\n"), kdMonINI.szFromMailID);
	AddServiceLog(_T("dwRepeatTime : %ld \r\n"), kdMonINI.dwRepeatTime);
	AddServiceLog(_T("szDebuggerLogFile : %s \r\n"), kdMonINI.szDebuggerLogFile);
	AddServiceLog(_T("szDebuggerLogArchiveDir : %s \r\n"), kdMonINI.szDebuggerLogArchiveDir);
	AddServiceLog(_T("dwDebuggerThreshold : %ld \r\n"), kdMonINI.dwDebuggerThreshold);
	AddServiceLog(_T("szServers : %s \r\n"), kdMonINI.szServers);
	AddServiceLog(_T("dwServerCount : %ld \r\n"), kdMonINI.dwServerCount);
	for ( UINT i = 0; i < kdMonINI.dwServerCount; i++ ) {
		AddServiceLog(_T("kdMonINI.ppszServerNameArray[%ld] : %s \r\n"), i, kdMonINI.ppszServerNameArray[i]);
	}
	AddServiceLog(_T("\r\n===================================================\r\n"));

	// successfully loaded INI file
	return TRUE;
}

// each server name in ppszNames, get the count and corresponding timestamp
// store the count in the pulCounts array
// store the timestamp in the pulTimeStamps array
BOOL ReadRegValues(_TCHAR **ppszNames, DWORD dwTotalNames, ULONG *pulCounts, ULONG *pulTimeStamps)
{

	// open HKEY_LOCAL_MACHINE\Software\Microsoft\kdMon registry key
	CRegKey keyServerName;
	LONG lRes;
	_TCHAR szKeyName[MAX_PATH];
	_tcscpy(szKeyName, _T("Software\\Microsoft\\"));
	_tcscat(szKeyName, szServiceName);
	lRes = keyServerName.Create(HKEY_LOCAL_MACHINE, szKeyName);
	if ( lRes != ERROR_SUCCESS ) {
		AddServiceLog(_T("Error: ReadRegValues->keyServerName.Create: Unable to open the key\r\n"));
		LogFatalEvent(_T("ReadRegValues->keyServerName.Create: Unable to open the key"));
		return FALSE;
	}

	// for each server name, get the previous count and timestamp value from registry
	for (DWORD i = 0; i < dwTotalNames; i++){
		_TCHAR szValue[MAX_PATH];
		DWORD dwBufferSize;
		dwBufferSize = MAX_PATH;
		lRes = keyServerName.QueryValue(szValue, ppszNames[i], &dwBufferSize);
		if ( lRes != ERROR_SUCCESS ) {
		// means there is no such value 
			AddServiceLog(_T("ReadRegValues->keyServerName.QueryValue: Unable to query value %s\r\n"), ppszNames[i]);
			LogEvent(_T("ReadRegValues->keyServerName.QueryValue: Unable to query value %s"), ppszNames[i]);
			
			// There was no entry for server name in registry
			// set the count to -1
			pulCounts[i] = -1;
			// set timestamp to -1
			pulTimeStamps[i] = -1;
			// go on with the next server name
			continue;
		}

		// the value got is of the form <count>|<datetime>
		// # strtok returns pointer to the next token found in szValue
		// # while the pointer is returned, the '|' is replaced by '\0'
		// # so if u print strToken then it will print the characters till the null
		// # character
		// get the first token which is the previous count
		_TCHAR* pszToken;
		pszToken = NULL;
		pszToken = _tcstok(szValue, _T("|"));
		if(pszToken == NULL){
			AddServiceLog(_T("Error: ReadRegValues: Wrong value retrieved for %s\r\n"), ppszNames[i]);
			LogEvent(_T("ReadRegValues: Wrong value retrieved for %s"), ppszNames[i]);
			// Previous count was an invalid value
			// set the count to -1
			pulCounts[i] = -1;
			// set timestamp to -1
			pulTimeStamps[i] = -1;
			// go on with the next server name
			continue;
		}
		
		// set the count
		pulCounts[i] = _ttoi(pszToken);

		// get the second token which is the timestamp of the count
		pszToken = _tcstok(NULL, _T("|"));
		if(pszToken == NULL){
			AddServiceLog(_T("Error: ReadRegValues: No timestamp found for %s\r\n"), ppszNames[i]);
			LogEvent(_T("ReadRegValues: No timestamp found for %s"), ppszNames[i]);

			// no timestamp found
			// set timestamp to -1
			pulTimeStamps[i] = -1;
			// dont do timestamp validation, go on with the next server name
			continue;
		}

		// set the timestamp
		pulTimeStamps[i] = _ttol(pszToken);
		
	}

//	for (i = 0; i < dwTotalNames; i++){
//		AddServiceLog(_T("%s Value : %ld %ld\r\n"), ppszNames[i], pulCounts[i], pulTimeStamps[i]);
//	}

	return TRUE;
}

// write values in the pulCounts to registry. Timestamp is current timestamp
BOOL WriteRegValues(_TCHAR **ppszNames, DWORD dwTotalNames, ULONG *pulCounts) 
{
	// open HKEY_LOCAL_MACHINE\Software\Microsoft\kdMon registry key
	CRegKey keyServerName;
	LONG lRes;
	_TCHAR szKeyName[MAX_PATH];
	_tcscpy(szKeyName, _T("Software\\Microsoft\\"));
	_tcscat(szKeyName, szServiceName);
	lRes = keyServerName.Create(HKEY_LOCAL_MACHINE, szKeyName);
	if ( lRes != ERROR_SUCCESS ) {
		AddServiceLog(_T("Error: ReadRegValues->keyServerName.Create: Unable to open the key\r\n"));
		LogFatalEvent(_T("ReadRegValues->keyServerName.Create: Unable to open the key"));
		return FALSE;
	}

	// for each server name, write the current count and timestamp value in registry
	for (DWORD i = 0; i < dwTotalNames; i++){

		// prepare the value to write
		_TCHAR szValue[MAX_PATH];
		// get integer count in a string
		_itot(pulCounts[i], szValue, 10);		
		// put delemiter
		_tcscat(szValue, _T("|"));

		// prepare the timestamp
		// get the current system time
		// ulTimeStamp is like 200112171558
		ULONG ulTimeStamp;
		ulTimeStamp = GetCurrentTimeStamp();

		_TCHAR szTimeStamp[MAX_PATH];
		_ltot(ulTimeStamp, szTimeStamp, 10);

		// prepare final KeyValue
		_tcscat(szValue, szTimeStamp);

		lRes = keyServerName.SetValue(szValue, ppszNames[i]);
		if ( lRes != ERROR_SUCCESS ) {
		// means there is no value 
			AddServiceLog(_T("Error: WriteRegValues->keyServerName.SetValue: Unable to set value %s\r\n"), ppszNames[i]);
			LogFatalEvent(_T("WriteRegValues->keyServerName.SetValue: Unable to set value %s"), ppszNames[i]);
			return FALSE;
		}

	}

	return TRUE;
}

ULONG ScanLogFile(_TCHAR *pszFileName)
{

	ULONG ulRet = -1;
	HANDLE	hFile;
	hFile = CreateFile(	pszFileName, 
						GENERIC_READ,              
						0,							// No sharing of file
						NULL,						// No security 
						OPEN_EXISTING,				// Open if exist
						FILE_ATTRIBUTE_NORMAL,		// Normal file 
						NULL);						// No attr. template 
 	if (hFile == INVALID_HANDLE_VALUE) 
	{
		// DWORD to get an error
		DWORD dwError;
		dwError = GetLastError();

		GetError(szError);
		AddServiceLog(_T("Error: ScanLogFile->CreateFile(%s): %s"), pszFileName, szError);
		LogEvent(_T("ScanLogFile->CreateFile(%s): %s"), pszFileName, szError);

		// ERROR_PATH_NOT_FOUND is Win32 Error Code
		// E_PATH_NOT_FOUND is locally defined code
		if ( dwError == ERROR_PATH_NOT_FOUND ) {
			return (ULONG)E_PATH_NOT_FOUND;
		}
		if ( dwError == ERROR_FILE_NOT_FOUND ) {
			return (ULONG)E_FILE_NOT_FOUND;
		}
		return (ULONG)E_OTHER_FILE_ERROR;
	}

	DWORD	dwPos;
	// Reach the file start
	dwPos = SetFilePointer(	hFile, 
							0,						// Low 32 bits of distance to move
							NULL,					// High 32 bits of distance to move
							FILE_BEGIN);			// Starting point
	// If High Word is NULL, error meas dwPos = INVALID_SET_FILE_POINTER
	if(dwPos == INVALID_SET_FILE_POINTER){
		GetError(szError);
		AddServiceLog(_T("Error: ScanLogFile->SetFilePointer: %s\r\n"), szError);
		LogFatalEvent(_T("ScanLogFile->SetFilePointer: %s"), szError);
		goto endScanLogFile;
	}

	// to get status of the read operation
	// If the function succeeds and the number of bytes read is zero, 
	// the file pointer was beyond the current end of the file
	DWORD dwBytesRead;

	// buffer to read from file
	// **** THIS NEEDS TO BE char* since the file is in ASCII and not UNICODE
	char szBuffer[MAX_PATH * 2];

	// count for Number of lines
	ULONG ulNumberOfLines;
	ulNumberOfLines = 0;

	// loop till the fileend is reached
	while(1) {

		BOOL bRet;
		bRet = ReadFile(	hFile,
							szBuffer,
							sizeof(szBuffer) * sizeof(char),	// number of BYTES to read
							&dwBytesRead,						// BYTES read
							NULL);								// OVERLAPPED structure
		// return if read failed
		if ( bRet == FALSE ) {
			GetError(szError);
			AddServiceLog(_T("Error: ScanLogFile->ReadFile(%s): %s\r\n"), pszFileName, szError);
			LogFatalEvent(_T("ScanLogFile->ReadFile(%s): %s"), pszFileName, szError);
			goto endScanLogFile;
		}

		// means file end is reached
		if ( dwBytesRead == 0 ) {
			ulRet = ulNumberOfLines;
			break;
		}

		// **** THIS NEEDS TO BE char* since the file is in ASCII and not UNICODE
		char *pszBuffPtr;
		pszBuffPtr = szBuffer;

		// to denote that a line has started
		BOOL bLineStarted;
		bLineStarted = FALSE;

		// read buffer one by one till dwBytesRead bytes are read
		for ( ; dwBytesRead > 0; dwBytesRead-- ) {

			// **** _T('\n') not needed since the file is in ASCII and not UNICODE
			// if endof line is encountered and line has started then increase line number
			if ( (*pszBuffPtr == '\n') && (bLineStarted == TRUE) ) {
				ulNumberOfLines++;
				bLineStarted = FALSE;
			} else if ( (*pszBuffPtr != '\n') && 
						(*pszBuffPtr != '\t') && 
						(*pszBuffPtr != '\r') && 
						(*pszBuffPtr != ' ') )	{
				// if a non widespace character is encountered then line has started
				bLineStarted = TRUE;
			}

			// goto next character
			pszBuffPtr++;
		}
	}

endScanLogFile :		
	CloseHandle(hFile);
	return ulRet;
}

ULONG GetCurrentTimeStamp() {
	// prepare the timestamp
	// get the current system time
	SYSTEMTIME UniversalTime;
	GetSystemTime(&UniversalTime);

	SYSTEMTIME systime;
	BOOL bRet;
	bRet = SystemTimeToTzSpecificLocalTime (	NULL,		// current local settings
												&UniversalTime,
												&systime);
	if ( bRet == 0 ) {
		GetError(szError);
		AddServiceLog(_T("Error: GetCurrentTimeStamp->SystemTimeToTzSpecificLocalTime: %s \r\n"), 
						szError);
		LogFatalEvent(_T("GetCurrentTimeStamp->SystemTimeToTzSpecificLocalTime: %s"), 
						szError);
		return (ULONG) -1;
	}
	
	// ulTimeStamp is like 200112171558
	ULONG ulTimeStamp;
	ulTimeStamp = 0;
	ulTimeStamp += systime.wMinute;
	ulTimeStamp += systime.wHour * 100;
	ulTimeStamp += systime.wDay * 10000;
	ulTimeStamp += systime.wMonth * 1000000;
	ulTimeStamp += (systime.wYear - 2000) * 100000000;

	return ulTimeStamp;
}

// to add a specific time to a timestamp
ULONG AddTime(ULONG ulTimeStamp, ULONG ulMinutes){
	// we have kdMonINI.dwRepeatTime in minutes (say 78)
	// take out hours and minutes (1 Hr 18 Min)
	// between 0112181608 and 0112181726 there is difference of 1 Hr 18 Min
	// but decimal difference is 118
	// between 0112181650 and 0112181808 there is difference of 1 Hr 18 Min
	// but decimal difference is 158
	// so we have some calculation here
	// what we will do is add the kdMonINI.dwRepeatTime to OldTS
	ULONG ulTmpHr, ulTmpMin;
	ulTmpHr = (ULONG) (ulMinutes / 60);
	ulTmpMin = (ULONG) (ulMinutes % 60);

	ULONG ulPrevYr, ulPrevMon, ulPrevDate, ulPrevHr, ulPrevMin;
	ulPrevMin = ulTimeStamp % 100;
	ulTimeStamp = ulTimeStamp / 100;
	ulPrevHr = ulTimeStamp % 100;
	ulTimeStamp = ulTimeStamp / 100;
	ulPrevDate = ulTimeStamp % 100;
	ulTimeStamp = ulTimeStamp / 100;
	ulPrevMon = ulTimeStamp % 100;
	ulTimeStamp = ulTimeStamp / 100;
	ulPrevYr = ulTimeStamp % 100;

	ULONG ulNewYr, ulNewMon, ulNewDate, ulNewHr, ulNewMin;
	ulNewYr = ulNewMon = ulNewDate = ulNewHr = ulNewMin = 0;
	
	ulNewMin = ulPrevMin + ulTmpMin;
	ulNewHr = ulPrevHr + ulTmpHr;
	ulNewDate = ulPrevDate;
	ulNewMon = ulPrevMon;
	ulNewYr = ulPrevYr;

	if ( ulNewMin >= 60 ) {
		ulNewHr++;
		ulNewMin = ulNewMin - 60;
	}

	if ( ulNewHr >= 24 ) {
		ulNewDate++;
		ulNewHr = ulNewHr - 24;
	}

	if (	ulPrevMon == 1 || ulPrevMon == 3 || ulPrevMon == 5 || ulPrevMon == 7 || 
		ulPrevMon == 8 || ulPrevMon == 10 || ulPrevMon == 12 ) {
		if ( ulNewDate >= 32 ) {
			ulNewMon++;
			ulNewDate = 1;
		}
	} else if (	ulPrevMon == 4 || ulPrevMon == 6 || ulPrevMon == 9 || ulPrevMon == 11 ) {
		if ( ulNewDate >= 31 ) {
			ulNewMon++;
			ulNewDate = 1;
		}
	} else if ( ulPrevMon == 2 && (ulPrevYr % 4) == 0 ) {
		// leap year
		if ( ulNewDate >= 30 ) {
			ulNewMon++;
			ulNewDate = 1;
		}
	} else if ( ulPrevMon == 2 && (ulPrevYr % 4) != 0 ) {
		// not a leap year
		if ( ulNewDate >= 29 ) {
			ulNewMon++;
			ulNewDate = 1;
		}
	}

	if ( ulNewMon >= 13 ) {
		ulNewYr++;
		ulNewMon = 1;
	}

	ULONG ulModifiedTS;
	ulModifiedTS = ulNewYr;
	ulModifiedTS = ulModifiedTS * 100 + ulNewMon;
	ulModifiedTS = ulModifiedTS * 100 + ulNewDate;
	ulModifiedTS = ulModifiedTS * 100 + ulNewHr;
	ulModifiedTS = ulModifiedTS * 100 + ulNewMin;

	return ulModifiedTS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\kdmon\kdmonsvcmessages.h ===
//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// Define the severity codes
//
#define STATUS_SEVERITY_WARNING          0x2
#define STATUS_SEVERITY_SUCCESS          0x0
#define STATUS_SEVERITY_INFORMATIONAL    0x1
#define STATUS_SEVERITY_ERROR            0x3


//
// MessageId: EVENT_MESSAGE
//
// MessageText:
//
//  %1
//
#define EVENT_MESSAGE                    0xC00007D0L

//
// MessageId: EVENT_ERROR
//
// MessageText:
//
//  %1
//
#define EVENT_ERROR                      0xC00007D1L

//
// MessageId: EVENT_GENERAL
//
// MessageText:
//
//  %1
//
#define EVENT_GENERAL                    0xC00007D2L
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\kdmon\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\kdmon\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Visual C++ generated include file.
// Used by kdMonSvc.rc
//
#define IDS_SERVICENAME 100

#define IDR_kdMonSvc		100


// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        201
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         201
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\kdmon\smtp.h ===
#pragma once

#include "global.h"

// for CDO COM. IMessage etc.
// #import <cdosys.dll> no_namespace 

// instead of importing the type library, include the standard type library header
#include "cdosys.tlh"

typedef struct stMailParameters {
	_TCHAR szFrom[MAX_PATH];
	_TCHAR szTo[MAX_PATH];
	_TCHAR szServerName[MAX_PATH];
	ULONG ulFailures;
	ULONG ulInterval;
	ULONG ulCurrentTimestamp;
}StructMailParams;

class CSMTP {
private:
	// SMTP message pointer
	IMessagePtr pIMsg;
public:
	BOOL InitSMTP();
	// send mail to the customer
	BOOL SendMail(StructMailParams& stMailParams);
	// release all the associated resources
	BOOL SMTPCleanup();
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\kdmon\kdmonsvc_i.c ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Wed Jun 05 18:06:33 2002
 */
/* Compiler settings for C:\NT\privates\kdMon\kdMonSvc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win32 (32b run), ms_ext, c_ext
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if !defined(_M_IA64) && !defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_KDMONSVCLib,0x480B1435,0xC73D,0x47DE,0x82,0xD5,0x61,0x24,0x87,0x3B,0xBA,0x73);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* !defined(_M_IA64) && !defined(_M_AXP64)*/


#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the IIDs and CLSIDs */

/* link this file in with the server and any clients */


 /* File created by MIDL compiler version 5.03.0280 */
/* at Wed Jun 05 18:06:33 2002
 */
/* Compiler settings for C:\NT\privates\kdMon\kdMonSvc.idl:
    Oicf (OptLev=i2), W1, Zp8, env=Win64 (32b run,appending), ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )

#if defined(_M_IA64) || defined(_M_AXP64)

#ifdef __cplusplus
extern "C"{
#endif 


#include <rpc.h>
#include <rpcndr.h>

#ifdef _MIDL_USE_GUIDDEF_

#ifndef INITGUID
#define INITGUID
#include <guiddef.h>
#undef INITGUID
#else
#include <guiddef.h>
#endif

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        DEFINE_GUID(name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8)

#else // !_MIDL_USE_GUIDDEF_

#ifndef __IID_DEFINED__
#define __IID_DEFINED__

typedef struct _IID
{
    unsigned long x;
    unsigned short s1;
    unsigned short s2;
    unsigned char  c[8];
} IID;

#endif // __IID_DEFINED__

#ifndef CLSID_DEFINED
#define CLSID_DEFINED
typedef IID CLSID;
#endif // CLSID_DEFINED

#define MIDL_DEFINE_GUID(type,name,l,w1,w2,b1,b2,b3,b4,b5,b6,b7,b8) \
        const type name = {l,w1,w2,{b1,b2,b3,b4,b5,b6,b7,b8}}

#endif !_MIDL_USE_GUIDDEF_

MIDL_DEFINE_GUID(IID, LIBID_KDMONSVCLib,0x480B1435,0xC73D,0x47DE,0x82,0xD5,0x61,0x24,0x87,0x3B,0xBA,0x73);

#undef MIDL_DEFINE_GUID

#ifdef __cplusplus
}
#endif



#endif /* defined(_M_IA64) || defined(_M_AXP64)*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\test_tools\isapistress\isapistress.h ===
#include <windows.h>
#include <wininet.h>
#include <tchar.h>
#include <stdio.h>
#include <Malloc.h>
#include <shlwapi.h>
#include <strsafe.h>


//Prototypes

DWORD Upload(TCHAR *SourceFileName, TCHAR *VirtualDir, TCHAR *HostName, TCHAR *RemoteFileName);
DWORD GetResponseUrl(TCHAR * HostName, TCHAR *RemoteFileName, TCHAR *ResponseURL);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\kdmon\smtp.cpp ===
#include "SMTP.h"

BOOL CSMTP::InitSMTP(){

    HRESULT hr = CoInitialize(NULL);

	pIMsg = NULL;

	// create a SMTP message object. If fails then closeandwait and try next time
	HRESULT hrMsg;
	hrMsg = pIMsg.CreateInstance(__uuidof(Message));
	if(FAILED(hrMsg)) {
		AddServiceLog(_T("Error: Failed to create SMTP message object\r\n"));
		LogFatalEvent(_T("Failed to create SMTP message object"));
		return FALSE;
	}
	// we have to addref here and call release when we are done with pIMsg
	// pIMsg->AddRef();

	return TRUE;
}

BOOL CSMTP::SendMail(StructMailParams& stMailParams){

	// prepare the mail now
	_TCHAR szMailSubject[1024];
	_tcscpy(szMailSubject, _T("Multiple KD Failures"));

	_TCHAR szMailBody[1024];
	_stprintf(szMailBody, _T("KD Failed.\r\nServer: %s\r\nFailures: %ld\r\nInterval %ld\r\nTimestamp: %ld\r\n"),
			stMailParams.szServerName, stMailParams.ulFailures,
			stMailParams.ulInterval, stMailParams.ulCurrentTimestamp);

	pIMsg->From = stMailParams.szFrom;
	pIMsg->To = stMailParams.szTo;
	pIMsg->Subject = szMailSubject;
	pIMsg->TextBody = szMailBody;
	HRESULT hrSend;
	hrSend = pIMsg->Send();
	if ( FAILED(hrSend) ) {
		AddServiceLog(_T("Error: Failed to send the message.\r\n"));
		LogFatalEvent(_T("Failed to send the message."));
		return FALSE;
	}
	return TRUE;
}

// cleanup the message object
BOOL CSMTP::SMTPCleanup() {
	//if (pIMsg != NULL) pIMsg->Release();
	CoUninitialize();
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\test_tools\isapistress\isapistress.cpp ===
#include "IsapiStress.h"

// Globals
HANDLE hLogFile = INVALID_HANDLE_VALUE;


void Usage()
{
	_tprintf(_T("Usage:\n\r"));
	_tprintf(_T("IsapiStress /s:<IISServer> /v:<VirtualDirectory> /d:<Directory> /f:<FileName> /l:<LogFileName> /? <Usage>\r\n"));
	_tprintf(_T("Where:\r\n"));
	_tprintf(_T("\t<IISServer>   - Website to upload file to (ie. ocadeviis) \r\n"));
	_tprintf(_T("\t<VirualDirectory> - Location on Web server to upload the file(s) to.\r\n"));
	_tprintf(_T("\t<Directory>   - Path to a directory of .cab files to be uploaded\r\n"));
	_tprintf(_T("\t<FileName>    - Qualified path of a file to be uploaded.\r\n"));
	_tprintf(_T("\t<LogFileName> - Name of file to log OCA response url or errors.\r\n\r\n"));
	_tprintf(_T("\tNote: Default iisserver is ocatest. \r\n\t      Default VirtualDirectory is OCA"));

}


void 
LogMessage(TCHAR *pFormat,...)
{
	// Routine to Log Fatal Errors to NT Event Log
    TCHAR    chMsg[256];
	DWORD    dwBytesWritten;
    va_list  pArg;

    va_start(pArg, pFormat);
    StringCbVPrintf(chMsg, sizeof chMsg,pFormat, pArg);
    va_end(pArg);
	// add a cr\lf combination for file fomrating.
    StringCbCat(chMsg, sizeof chMsg,_T("\r\n"));
    if (hLogFile != INVALID_HANDLE_VALUE)
    {
        /* Write to event log. */
        WriteFile(hLogFile,
				  chMsg,
				  _tcslen(chMsg) * (DWORD)sizeof TCHAR,
				  &dwBytesWritten,
				  NULL);
     }
	else // write it to the console.
		_tprintf(chMsg);

}

DWORD  Upload(TCHAR *SourceFileName, TCHAR *VirtualDir, TCHAR *HostName, TCHAR *RemoteFileName)
{
	static		const TCHAR *pszAccept[]			= {_T("*.*"), 0};
	//TCHAR       RemoteFileName[MAX_PATH]; // Host/Virtualdirectory/filename
	TCHAR		*pUploadUrl				= NULL;
	BOOL		bRet				= FALSE;
	BOOL		UploadSuccess		= FALSE;
	DWORD		dwBytesRead;
	DWORD		dwBytesWritten;
	DWORD		ResponseCode		= 0;
	DWORD		ResLength = 255;
	DWORD		index = 0;
	DWORD		ErrorCode			= 0;
	HINTERNET   hSession			= NULL;
	HINTERNET	hConnect			= NULL;
	HINTERNET	hRequest			= NULL;
	INTERNET_BUFFERS	BufferIn	= {0};
	INTERNET_BUFFERS   BufferOut	= {0};
	HANDLE      hFile = INVALID_HANDLE_VALUE;
	BYTE		*pBuffer;
	BOOL		bOnce				= FALSE;
	GUID		guidNewGuid;
	TCHAR		*szGuidRaw			= NULL;
	HRESULT		hResult = S_OK;
	wchar_t		*wszGuidRaw = NULL;

	CoInitialize(NULL);
	hResult = CoCreateGuid(&guidNewGuid);
	if (FAILED(hResult))
	{
		//-------------What do we send here....
		//goto ERRORS;
		;
	}
	else
	{
		if (UuidToStringW(&guidNewGuid, &wszGuidRaw) == RPC_S_OK)
		{
			if ( (szGuidRaw = (TCHAR *) malloc ( wcslen(wszGuidRaw)*2 )) != NULL)
			{
				// clear the memory
				ZeroMemory(szGuidRaw, wcslen(wszGuidRaw) * 2);
				wcstombs( szGuidRaw, wszGuidRaw, wcslen(wszGuidRaw));
			}
			else
			{
				LogMessage(_T("Memory allocation failed: ErrorCode:%d"),GetLastError());
				if (wszGuidRaw)
				{
					RpcStringFreeW(&wszGuidRaw);
				}
					CoUninitialize();
				return GetLastError();
			}
		}
	}
	if (wszGuidRaw)
	{
		RpcStringFreeW(&wszGuidRaw);
	}

	
	StringCbPrintf(RemoteFileName, MAX_PATH * sizeof TCHAR, _T("\\%s\\%s%s"),VirtualDir,szGuidRaw + 19, PathFindFileName(SourceFileName));
	if (szGuidRaw)
			free (szGuidRaw);
	hSession = InternetOpen(	_T("IsapiStress"),
								INTERNET_OPEN_TYPE_PRECONFIG,
								NULL,
								NULL,
								0);
	if (!hSession)
	{
		LogMessage(_T("Failed to create an internet session."));
			CoUninitialize();
		return GetLastError();
	}

	hConnect = InternetConnect(hSession,
								HostName,
								INTERNET_DEFAULT_HTTP_PORT,
								NULL,
								NULL,
								INTERNET_SERVICE_HTTP,
								0,
								NULL);

	if (hConnect == INVALID_HANDLE_VALUE)
	{
		InternetCloseHandle(hSession);	
		LogMessage(_T("Failed to create an internet connection."));
		CoUninitialize();
		return GetLastError();
	}
	LogMessage(_T("Connecting to: %s"),HostName);
	LogMessage(_T("Uploading file: %s"),RemoteFileName);

	hRequest = HttpOpenRequest(	hConnect,
								_T("PUT"),
								RemoteFileName, 
								NULL,
								NULL,
								pszAccept,
								INTERNET_FLAG_NEED_FILE|INTERNET_FLAG_NO_CACHE_WRITE ,
								0);
	if (hRequest != INVALID_HANDLE_VALUE)
	{
		hFile = CreateFile( SourceFileName,
							GENERIC_READ,
							FILE_SHARE_READ,
							NULL,
							OPEN_EXISTING,
							FILE_ATTRIBUTE_NORMAL,
							NULL);
						
		if (hFile != INVALID_HANDLE_VALUE)
		{
		

			// Clear the buffer
			if ( (pBuffer = (BYTE *)malloc (70000)) != NULL)
			{
				BufferIn.dwStructSize = sizeof( INTERNET_BUFFERS );
				BufferIn.Next = NULL; 
				BufferIn.lpcszHeader = NULL;
				BufferIn.dwHeadersLength = 0;
				BufferIn.dwHeadersTotal = 0;
				BufferIn.lpvBuffer = NULL;                
				BufferIn.dwBufferLength = 0;
				BufferIn.dwOffsetLow = 0;
				BufferIn.dwOffsetHigh = 0;
				BufferIn.dwBufferTotal = GetFileSize (hFile, NULL);
				FillMemory(pBuffer, 70000,'/0'); // Fill buffer with data
				DWORD dwFlags;
				DWORD dwBuffLen = sizeof(dwFlags); 

				if(!HttpSendRequestEx(	hRequest,
										&BufferIn,
										NULL,
										HSR_INITIATE,
										0))
				{
					LogMessage(_T("HttpSendRequestEx Failed."));
				}
				else
				{
					do
					{
						dwBytesRead = 0;
						bRet = ReadFile(hFile,
										pBuffer, 
										70000,
										&dwBytesRead,
										NULL);
						if (bRet != 0)
						{
							bRet = InternetWriteFile(hRequest,
													pBuffer,
													dwBytesRead,
													&dwBytesWritten);

							if ( (!bRet) || (dwBytesWritten==0) )
							{
								LogMessage(_T("Error Writting File: %d"),ErrorCode = GetLastError());

							}

						
						}
					} while (dwBytesRead == sizeof (pBuffer));

					CloseHandle(hFile);
					hFile = INVALID_HANDLE_VALUE;
					bRet = HttpEndRequest(	hRequest,
											NULL, 
											0, 
											0);
					if (bRet)
					{
						ResponseCode = 0;
						HttpQueryInfo(hRequest,
									HTTP_QUERY_STATUS_CODE |HTTP_QUERY_FLAG_NUMBER,
									&ResponseCode,
									&ResLength,
									&index);
					
						if ( (ResponseCode != 200) && (ResponseCode != 201))
						{
							ErrorCode=ResponseCode;
							LogMessage(_T("IIS Response Code = %d"),ResponseCode);
							// Cleanup for retry
						}						
						else
						{
							ErrorCode = 0;
							LogMessage(_T("IIS Response Code = %d"),ResponseCode);
							UploadSuccess = TRUE;

						}
					}
					else
					{
						LogMessage(_T("HttpEndrequest Returned an Error"));
						ErrorCode = GetLastError();
					}
				}
				

			}
			else
			{
				LogMessage(_T("Failed to allocate buffer memory"));
				ErrorCode = GetLastError();
			}
		}
		else
		{
			LogMessage(_T("Failed to Open Source File"));
			ErrorCode = GetLastError();
		}
		
	}
	else
	{
		LogMessage(_T("Failed to Create Put Request"));
		ErrorCode = GetLastError();
	}

	// Clean up
	if (hFile!= INVALID_HANDLE_VALUE)
		CloseHandle (hFile);
	if (hRequest)
		if (!InternetCloseHandle(hRequest))
		{
			LogMessage(_T("Failed to close the hRequest handle: error: %d"), GetLastError);
		}
	if (hConnect)
		if (!InternetCloseHandle(hConnect))
		{
			LogMessage(_T("Failed to close the hRequest handle: error: %d"), GetLastError);
		}
		

	if (hSession)
		if (!InternetCloseHandle(hSession))
		{
			LogMessage(_T("Failed to close the hRequest handle: error: %d"), GetLastError);
		}
		
	if (pUploadUrl)
		free (pUploadUrl);
	CoUninitialize();
	return ErrorCode;
	
}

DWORD GetResponseUrl(TCHAR * HostName, TCHAR *RemoteFileName,TCHAR *ResponseURL)
{
	TCHAR		IsapiUrl[255];
	TCHAR		*pUploadUrl			= NULL;
	TCHAR       *temp				= NULL;
	BOOL		bRet				= FALSE;
	DWORD		dwUrlLength			= 0;
	DWORD		ErrorCode			= 0;
	DWORD		dwLastError			= 0;
	TCHAR 		NewState;
	HINTERNET	hSession;
	HINTERNET	hRedirUrl;
	BOOL		bOnce				= FALSE;
	DWORD		dwBuffLen			= 0;
	DWORD		dwFlags				= 0;
	TCHAR       LocalUrl[255];
	ZeroMemory (IsapiUrl, sizeof IsapiUrl);
	ZeroMemory (LocalUrl, sizeof LocalUrl);	
	HINTERNET hUrlFile = NULL;


	
	StringCbPrintf (IsapiUrl,sizeof IsapiUrl,  _T("http://%s/isapi/oca_extension.dll?id=%s&Type=5"),HostName, RemoteFileName);
	LogMessage(_T("Connecting to url: %s"),IsapiUrl);
	//StringCbPrintf (IsapiUrl,sizeof IsapiUrl,  _T("http://www.microsoft.com"));

	hSession = InternetOpen(_T("Isapi Stress"),
							 INTERNET_OPEN_TYPE_PRECONFIG,
                             NULL,
							 NULL,
							 0);
	if (hSession)
	{
		// Open the url we want to connect to.
		hUrlFile = InternetOpenUrl(hSession,
								   IsapiUrl, 
								   NULL,
								   0,
								   0,
								   0);

		// Read the page returned by the isapi dll.
		TCHAR buffer[255] ;
		ZeroMemory (buffer, sizeof buffer);
		DWORD dwBytesRead = 0;
		BOOL bRead = InternetReadFile(hUrlFile,
									  buffer,
									  sizeof(buffer),
									  &dwBytesRead);

		//buffer[sizeof (buffer) -1] = _T('\0');
		StringCbCopy (ResponseURL, sizeof buffer, buffer);
	}
	InternetCloseHandle(hUrlFile);
	InternetCloseHandle(hSession);

	return 0;
}



int __cdecl _tmain( int argc, TCHAR *argv[])
{
	
	TCHAR SourceFileName[MAX_PATH];
	TCHAR SourcePath[MAX_PATH];
	TCHAR HostName[MAX_PATH];
	TCHAR VirtualDir[MAX_PATH];
	TCHAR LogPath[MAX_PATH];
	TCHAR temp;
	TCHAR RemoteFileName[MAX_PATH];
	DWORD ErrorCode = 0;
	TCHAR		ResponseUrl[255];

	int i = 1;
	
	ZeroMemory (SourceFileName, sizeof SourceFileName);
	ZeroMemory (SourcePath,		sizeof SourcePath);
	ZeroMemory (HostName,		sizeof HostName);
	ZeroMemory (VirtualDir,		sizeof VirtualDir);
	ZeroMemory (LogPath,		sizeof LogPath);
	ZeroMemory (ResponseUrl,sizeof ResponseUrl);

	StringCbCopy (HostName,	  sizeof HostName,		_T("Ocatest"));
	StringCbCopy (VirtualDir, sizeof VirtualDir,	_T("OCA"));
	
	if ( (argc < 2) || (argc > 6))
	{
		Usage();
		return (1);
	}

	for (i = 1; i < argc; i++)
	{
		switch (*argv[i])
		{
		case _T('/'):
		case _T('-'): 
			{   
				temp = _toupper( *(argv[i]+1));
				switch (temp)
				{
				case _T('S'):					// IIS Sever- Override Default
					if(*(argv[i]+2) == _T(':'))
					{	
						StringCbCopy(HostName, sizeof HostName, argv[i]+3);
					}
					break;
				case _T('V'):					// Virtual Directory override default
					if(*(argv[i]+2) == _T(':'))
					{	
						StringCbCopy(VirtualDir, sizeof VirtualDir, argv[i]+3);
					}
					break;
				case _T('?'):
					Usage();
					break;
				case _T('D'):
					if(*(argv[i]+2) == _T(':'))
					{			
						StringCbCopy(SourcePath, sizeof SourcePath, argv[i]+3);
					}
                    break;

				case _T('F'):						// User specified an offset in days...
					if(*(argv[i]+2) == _T(':'))
					{
						StringCbCopy(SourceFileName, sizeof SourceFileName, argv[i]+3);
					}
					break;
				case _T('L'):
					if(*(argv[i]+2) == _T(':'))
					{
						StringCbCopy(LogPath, sizeof LogPath, argv[i]+3);
					}
					break;
				default:
					LogMessage(_T("Unknown option: %s"),argv[i]);
					Usage();
					return (1);
				} // end switch
			} // end case
			break;
		default:
			LogMessage(_T("Unknown option: %s\n"),argv[i]);
			Usage();
			return (1);
			break;
		}// end switch
	}// end for


	// Ok now the fun part. 
	// Create the log file if one was specified.
	if (LogPath[0] != _T('\0'))
	{
		hLogFile = CreateFile(LogPath,
							  GENERIC_WRITE,
							  FILE_SHARE_READ,
							  NULL,
							  OPEN_ALWAYS,
							  FILE_ATTRIBUTE_NORMAL,
	    					  NULL);
		if (hLogFile == INVALID_HANDLE_VALUE)
		{
			LogMessage(_T("Failed to open log file: %s, Logging disabled."), LogPath);
		}
	}




	// if we have a file name we just want to upload it.

	if (SourceFileName[0] != _T('\0'))
	{
		LogMessage(_T("Uploading file: %s"), SourceFileName);
		ErrorCode = Upload(SourceFileName, VirtualDir, HostName,RemoteFileName);
		if(ErrorCode != 0)
		{
			LogMessage(_T("Upload Failed: ErrorCode = %d"),ErrorCode);
		}
		else
		{
			LogMessage(_T("Upload Succeeded. "));
		}
		
		ErrorCode = GetResponseUrl(HostName,PathFindFileName(RemoteFileName),ResponseUrl);
		if (ErrorCode != 0)
		{
			LogMessage(_T("GetResponseUrl Failed ErrorCode=%d"),ErrorCode);
		}
		LogMessage(_T("ResponseUrl = %s"),ResponseUrl);
		
	}
	else
	{
		if (SourcePath[0] != _T('\0'))
		{
			// if we have a directory we want to walk the directory and submit all the cabs.
			;
		}
		else
		{
			// If we don't have either we just exit with usage
			Usage();
			if (hLogFile != INVALID_HANDLE_VALUE)
				CloseHandle (hLogFile);
			return (1);
		}
	}
	if (hLogFile != INVALID_HANDLE_VALUE)
		CloseHandle (hLogFile);


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\services\kdmon\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__843E2879_B549_4D68_BB30_1ED43D4D2651__INCLUDED_)
#define AFX_STDAFX_H__843E2879_B549_4D68_BB30_1ED43D4D2651__INCLUDED_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0400
#endif
#define _ATL_APARTMENT_THREADED

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module

class CServiceModule : public CComModule
{
public:
	HRESULT RegisterServer(BOOL bRegTypeLib, BOOL bService);
	HRESULT UnregisterServer();
	void Init(_ATL_OBJMAP_ENTRY* p, HINSTANCE h, UINT nServiceNameID, const GUID* plibid = NULL);
    void Start();
	void ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    void Handler(DWORD dwOpcode);
    void Run();
    BOOL IsInstalled();
    BOOL Install();
    BOOL Uninstall();
	LONG Unlock();
	// void LogEvent(LPCTSTR pszFormat, ...);
	// LogEvent() function removed and added to global.cpp since its used globally
    void SetServiceStatus(DWORD dwState);
    void SetupAsLocalServer();

//Implementation
private:
	static void WINAPI _ServiceMain(DWORD dwArgc, LPTSTR* lpszArgv);
    static void WINAPI _Handler(DWORD dwOpcode);

// data members
public:
    _TCHAR m_szServiceName[256];
    SERVICE_STATUS_HANDLE m_hServiceStatus;
    SERVICE_STATUS m_status;
	DWORD dwThreadID;
	BOOL m_bService;
};

extern CServiceModule _Module;
#include <atlcom.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__843E2879_B549_4D68_BB30_1ED43D4D2651__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\cobrandstrings.inc ===
<%
	Dim L_COBRAND_NEW_SIGNIN_TEXT
	Dim L_COBRAND_SIGNIN_THISWAY_TEXT
	Dim L_COBRAND_PROVIDED_BY_TEXT
	Dim L_COBRAND_SIGNIN_NAME_TEXT
	Dim L_COBRAND_TRY_OLD_TEXT
	Dim L_COBRAND_OR_OR_TEXT
	Dim L_COBRAND_WITH_PASSPORT_TEXT
	Dim L_COBRAND_ACCESS_YOUR_TEXT
	Dim L_COBRAND_PORTFOLIO_ANYWHERE_TEXT
	Dim L_COBRAND_GET_GET_TEXT
	Dim L_COBRAND_FREE_STOCKQUOTES_TEXT
	Dim L_COBRAND_CUSTOMIZE_MONEYCENTRAL_TEXT
	Dim L_COBRAND_FINANCIAL_HOMEPAGE_TEXT
	Dim L_COBRAND_LEARN_SHARE_TEXT
	Dim L_COBRAND_MONEYCENTRAL_COMMUNITY_TEXT
	Dim L_COBRAND_SIGNIN_ONCE_TEXT
	Dim L_COBRAND_PARTICIPATING_WEBSITES_TEXT

	'-------------------------crashinfo.asp Page Strings-------------------------
	L_COBRAND_NEW_SIGNIN_TEXT = "New sign-in... here&#180;s how"
	L_COBRAND_SIGNIN_THISWAY_TEXT = "If you used to sign in this way:"
	L_COBRAND_PROVIDED_BY_TEXT = "Provided by"
	L_COBRAND_SIGNIN_NAME_TEXT = "Sign-in name"
	L_COBRAND_TRY_OLD_TEXT = "If you&#180;re not sure try your old sign-in name followed by "
	L_COBRAND_OR_OR_TEXT = "or"
	L_COBRAND_WITH_PASSPORT_TEXT = "With Microsoft Passport you can"
	L_COBRAND_ACCESS_YOUR_TEXT = "Access your "
	L_COBRAND_PORTFOLIO_ANYWHERE_TEXT = "portfolio anywhere"
	L_COBRAND_GET_GET_TEXT = "Get "
	L_COBRAND_FREE_STOCKQUOTES_TEXT = "FREE real-time stock quotes and charts"
	L_COBRAND_CUSTOMIZE_MONEYCENTRAL_TEXT = "Customize My MoneyCentral "
	L_COBRAND_FINANCIAL_HOMEPAGE_TEXT = " to be your own financial homepage"
	L_COBRAND_LEARN_SHARE_TEXT = "Learn and share in the "
	L_COBRAND_MONEYCENTRAL_COMMUNITY_TEXT = "MoneyCentral Community"
	L_COBRAND_SIGNIN_ONCE_TEXT = "Sign in once"
	L_COBRAND_PARTICIPATING_WEBSITES_TEXT = "for all MSN and participating Web sites"
	
	'-------------------------End-------------------------
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\autostrings.inc ===
<%

	Dim L_AUTO_UNABLETO_PROCESS_TEXT
	Dim L_AUTO_UNABLETOPROCESS_COMMENT_TEXT
	Dim L_AUTO_RESUBMIT_FILE_TEXT
	Dim L_AUTO_ALREADYHAVE_FILE_TEXT
	Dim L_AUTO_ALREADYHAVE_FILEBODY_TEXT
	Dim L_AUTO_ALREADYHAVE_FILEBODYTWO_TEXT
	Dim L_AUTO_ALREADYHAVE_FILEBODYTHREE_TEXT
	Dim L_AUTO_ALREADYHAVE_NOCUSTOMERINFO_TEXT
	Dim L_AUTO_ALREADYHAVE_NOCUSTOMERINFOTWO_TEXT
	Dim L_AUTO_UPLOAD_COMPLETE_TEXT
	Dim L_AUTO_THANK_YOU_TEXT
	Dim L_AUTO_CLOSE_WELCOME_TEXT
	Dim L_AUTO_64BIT_DUMP_TEXT
	Dim L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE
	Dim L_COMMENTS_DATABASE_FAILED_TEXT
	Dim L_CUSTOMER_NEXT_LINK_TEXT
	Dim L_WELCOME_SCRIPT_TITLE_TEXT
	Dim L_WELCOME_SCRIPT_BODY_TEXT
	Dim L_WELCOME_GO_IMAGEALT_TEXT
	Dim L_RECEIVED_SUCCESS_PARTONE2_TEXT
	Dim L_RECEIVED_THANK_YOU_TEXT
	Dim L_RECEIVED_THANK_YOUTWO_TEXT
	Dim L_RECEIVED_NEWFILE_LINK_TEXT
	Dim L_RECEIVED_STATUS_LINK_TEXT
	
	'-------------------------auto.asp Page Strings-------------------------
	L_AUTO_64BIT_DUMP_TEXT = "Thank you for participating in the Windows Online Crash Analysis program. The error report you uploaded is a 64-bit file and cannot be processed by Windows Online Crash Analysis at this time. However, we are currently working to implement this functionality.  You now have the choice to remain anonymous or to enter contact information. If you enter contact information, you can track the status of this error report, and the Windows Online Crash Analysis team might be able to provide solutions for your Stop error. Solutions are sent by e-mail when available. To enter contact information, click Continue."
	L_AUTO_CLOSE_WELCOME_TEXT = "Remain anonymous"
	L_AUTO_UNABLETO_PROCESS_TEXT = "Unable to upload error report"
	L_AUTO_UNABLETOPROCESS_COMMENT_TEXT = "The selected error report cannot be uploaded to Windows Online Crash Analysis. Possible causes include network problems, corruption of the error report, and server error. To try to submit the error report again, click Resubmit the error report. "	
	L_AUTO_RESUBMIT_FILE_TEXT = "Resubmit the error report"
	L_AUTO_ALREADYHAVE_FILE_TEXT = "Error report previously submitted"
	L_AUTO_ALREADYHAVE_FILEBODY_TEXT = "We have determined that this error report has been previously submitted to Windows Online Crash Analysis."
	L_AUTO_ALREADYHAVE_FILEBODYTWO_TEXT = "If you submitted this error report from a corporation, your system administrator might have previously submitted this report to our Web site. You may want to contact your system administrator to confirm this."
	L_AUTO_ALREADYHAVE_FILEBODYTHREE_TEXT = "If you previously submitted this report to the Online Crash Analysis Web site or by using the Windows Error Reporting Client, click Error report status to view the status of this report."
	L_AUTO_ALREADYHAVE_NOCUSTOMERINFO_TEXT = "If you submitted this error report from a corporation, your system administrator might have previously submitted this report to our Web site. You may want to contact your system administrator to confirm this."
	L_AUTO_ALREADYHAVE_NOCUSTOMERINFOTWO_TEXT = "If you previously submitted this report to the Online Crash Analysis Web site or by using the Windows Error Reporting Client and you would like to receive analysis information by e-mail, click Continue to enter your contact information."
	L_AUTO_UPLOAD_COMPLETE_TEXT = "Error report submission complete"
	L_AUTO_THANK_YOU_TEXT = "Thank you for participating in the Windows Online Crash Analysis program. You now have the choice to remain anonymous or to enter contact information. If you enter contact information you can track the status of this error report, and the Windows Online Crash Analysis team may be able to send solutions for your Stop error by e-mail. To enter contact information, click Continue."
	L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE = "Database is not available"
	L_COMMENTS_DATABASE_FAILED_TEXT = "Windows Online Crash Analysis was unable to save your information to the database. Please try this task again."
	L_CUSTOMER_NEXT_LINK_TEXT = "Continue"
	L_RECEIVED_STATUS_LINK_TEXT = "Error report status"
	L_WELCOME_SCRIPT_TITLE_TEXT = "This site cannot be displayed with current security options"
	L_WELCOME_SCRIPT_BODY_TEXT = "Internet Explorer Internet security options are set to High or Custom. Windows Online Crash Analysis cannot be displayed. To reset the options for Internet Explorer, in the Tools menu, select Internet Options. On the Security tab, set the security level to Medium or lower, and then click OK."
	L_WELCOME_GO_IMAGEALT_TEXT = "Go"
	L_RECEIVED_SUCCESS_PARTONE2_TEXT = "Error report submission complete "
	L_RECEIVED_THANK_YOU_TEXT = "Thank you for submitting your report."
	L_RECEIVED_THANK_YOUTWO_TEXT = "Thank you for participating in the Windows Online Crash Analysis program. Your error report was successfully submitted anonymously."
	L_RECEIVED_NEWFILE_LINK_TEXT = "Home"

	
	'-----------------------------------------------------------------------------------------
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\cerintrotempstrings.inc ===
<%
	Dim L_CERINTROTEMP_INTRO_TITLE_TEXT
	Dim L_CERINTROTEMP_INTRO_BODY1_TEXT
	Dim L_CERINTROTEMP_INTRO_BODY2PERIOD_TEXT
	Dim L_CERINTROTEMP_WHATIS_SUBTITLE_TEXT
	Dim L_CERINTROTEMP_WHATIS_BODY_TEXT
	Dim L_CERINTROTEMP_BENEFIT_SUBTITLE_TEXT
	Dim L_CERINTROTEMP_BENEFIT_BODY1_TEXT	
	Dim L_CERINTROTEMP_BENEFIT_BODY2_TEXT	
	Dim L_CERINTROTEMP_INTRO_LINK_TEXT
	Dim L_CERINTROTEMP_INTRO_LINK_URL

	L_CERINTROTEMP_INTRO_TITLE_TEXT = "Welcome to the Corporate Error Reports Web site"
	L_CERINTROTEMP_INTRO_BODY1_TEXT = "Thank you for your interest in the Corporate Error Reporting Web site. This service is currently unavailable but will be available in the near future. Please check back regularly. If you would like to be notified when the service is available, please send an e-mail message to "
	L_CERINTROTEMP_INTRO_BODY2PERIOD_TEXT = "."
	L_CERINTROTEMP_WHATIS_SUBTITLE_TEXT = "What is the Corporate Error Reports Web site?"
	L_CERINTROTEMP_WHATIS_BODY_TEXT = "Microsoft<SUP>&#174;</SUP> is committed to making Windows XP Professional and Windows Server 2003 the most reliable operating systems available. New and enhanced features in Windows XP and Windows Server 2003 contribute to increased reliability, and additional resources, such as Windows Online Crash Analysis, provide information to help you optimize your system and increase stability. "
	L_CERINTROTEMP_BENEFIT_SUBTITLE_TEXT = "Benefits"
	L_CERINTROTEMP_BENEFIT_BODY1_TEXT = "The Corporate Error Reports Web site in conjunction with the Office XP Corporate Error Reporting client enables corporations to collect, manage, and analyze error reports. You can submit multiple error reports in a single transaction to the Corporate Error Reports site for an initial analysis. This information is then compiled and displayed on a status page, which you can use to track error trends, problem software, and other issues."
	L_CERINTROTEMP_BENEFIT_BODY1_TEXT = "This free service can help save valuable debugging and troubleshooting time while lowering the total cost of ownership."
	L_CERINTROTEMP_INTRO_LINK_TEXT = "oca@microsoft.com"
	L_CERINTROTEMP_INTRO_LINK_URL = "mailto:oca@microsoft.com?subject=Corporate Error Reports Web site availability"
	
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\browserinfostrings.inc ===
<%

	Dim L_BROWSERINFOH3_TEXT
	Dim L_WELCOME_REQUIREMENTS_INFO_TEXT
	Dim L_WELCOME_REQUIREMENTSINFO_TWO_TEXT
	Dim L_WELCOME_REQUIREMENTS_PASSPORT_TEXT
	Dim L_WELCOME_INTERNET_EXPLORER_TEXT
	Dim L_WELCOME_PASSPORT_LINK_TEXT
	Dim L_WELCOMELOGO_TEXT
	Dim L_WELCOME_LOGO_TWO_TEXT
	Dim L_BROWSERINFO_SUPPORT_LINK_TEXT
	Dim L_FAQ_MICROSOFT_LINK_TEXT
	Dim L_FAQ_PASSPORT_LINK_TEXT
	Dim L_HEADER_INC_TITLE_PAGETITLE
	
	
	'-------------------------browserinfo.asp Page Strings-------------------------
	L_BROWSERINFOH3_TEXT = "Windows Online Crash Analysis requirements"
	L_HEADER_INC_TITLE_PAGETITLE = "Windows Online Crash Analysis" 
	L_WELCOME_REQUIREMENTS_INFO_TEXT = "To submit an error report, you must be using Windows NT 4.0, Windows 2000, or Windows XP. Windows Online Crash Analysis requires Microsoft<sup>&#174;</sup> Internet Explorer 5 or later and a Microsoft Passport. To download the latest version of Internet Explorer, visit the "
	L_WELCOME_REQUIREMENTSINFO_TWO_TEXT = "To get a Passport, visit the&nbsp;"
	L_WELCOME_REQUIREMENTS_PASSPORT_TEXT = "For Windows 2000 event reports, a Premier account is required. For more information about Premier accounts, see Product Support Services on the "
	L_WELCOME_INTERNET_EXPLORER_TEXT = "Microsoft Web site."
	L_WELCOME_PASSPORT_LINK_TEXT = "Microsoft Passport Web site." 
	L_BROWSERINFO_SUPPORT_LINK_TEXT = "http://support.microsoft.com/isapi/gosupport.asp?target=/support/default.asp?VA=1"
	L_HEADER_INC_TITLE_PAGETITLE = "Windows Online Crash Analysis"
	L_WELCOMELOGO_TEXT = "Windows<sup>&#174;</sup>"
	L_WELCOME_LOGO_TWO_TEXT = " Online Crash Analysis Requirements"
	L_FAQ_MICROSOFT_LINK_TEXT = "http://www.microsoft.com"
	L_FAQ_PASSPORT_LINK_TEXT = "http://www.passport.com"
	'-------------------------End-------------------------




%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\browsertest.inc ===
<%

	'---------------Test for IE and Netscape browsers---------------
	dim ua
	dim iPosition
	dim iNetPosition
	dim iIEVer
	dim iNetVer
	dim bolNetscape
	dim bolIE
	dim strTempURL
	
	Err.Clear
	bolNetscape = false
	bolIE = false
	ua  = Request.ServerVariables("HTTP_USER_AGENT")	
	if InStr(ua, "Opera") > 0 then
		Response.Redirect("http://" & Request.ServerVariables("SERVER_NAME") & "/browserinfo.asp")
	end if
	
	strTempURL = Request.ServerVariables("URL")
	strURL = LCase(strURL)
	if instr(1, strURL, "status.asp") = 0 and instr(1, strURL, "state.asp") = 0 and instr(1, strURL, "comments.asp") = 0 _
	and instr(1, strURL, "resources.asp") = 0 and instr(1, strURL, "faq.asp") = 0 and instr(1, strURL, "welcome.asp") = 0 _
	and instr(1, strURL, "crashinfo.asp") = 0 and instr(1, strURL, "privacy.asp") = 0 and len(strURL) <> 0 then
	
		if InStr(ua,"Windows 95")  > 0 Or InStr(ua,"Windows 98") > 0 Or InStr(ua,"Millennium") > 0 Or InStr(ua,"Windows NT 4.0") > 0then
			Response.Redirect("http://" & Request.ServerVariables("SERVER_NAME") & "/browserinfo.asp")
		end if
	end if
  
	iPosition = 0
	
	iPosition = Instr(1, ua, "MSIE")
	
	if cint(iPosition) <> 0 then 
		if err.number <> 0 then 
			Response.Redirect("http://" & Request.ServerVariables("SERVER_NAME") & "/browserinfo.asp")
		end if
		iIEVer = Mid(ua, iPosition + 5, 1)
		if err.number <> 0 then Response.Redirect("http://" & Request.ServerVariables("SERVER_NAME") & "/browserinfo.asp")
		if cint(iIEVer) < 5 and iPosition > 0 then
			Response.Redirect("http://" & Request.ServerVariables("SERVER_NAME") & "/browserinfo.asp")
		end if
		if err.number <> 0 then Response.Redirect("http://" & Request.ServerVariables("SERVER_NAME") & "/browserinfo.asp")
		bolIE = true
	else
		Response.Redirect("http://" & Request.ServerVariables("SERVER_NAME") & "/browserinfo.asp")
	end if
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\commentstrings.inc ===
<%

	Dim L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE
	Dim L_COMMENTS_NO_RECORDS_MESSAGE
	Dim L_COMMENTS_EVENT_DESCRIPTION_TEXT
	Dim L_COMMENTS_EVENT_NAME_TEXT
	Dim L_COMMENTS_OPERATING_SYSTEM_TEXT
	Dim L_COMMENTS_OPTIONAL_COMMENTS_TEXT
	Dim L_COMMENTS_SAVE_INFO_TEXT
	Dim L_COMMENTS_OPERATING_SYSTEM_MESSAGE
	Dim L_COMMENTS_FILE_NAME_TEXT
	Dim L_COMMENTS_CONNECTION_FAILED_TEXT 
	Dim L_COMMENTS_DATABASE_FAILED_TEXT
	Dim L_COMMENTS_DATABASE_FAILURE_ERRORMESSAGE
	Dim L_COMMENTS_DATABASE_FAILUREBODY_ERRORMESSAGE
	Dim L_COMMENTS_REPORTSAVE_TITLE_TEXT
	Dim L_COMMENTS_REPORTSAVE_BODY_TEXT
	Dim L_COMMENTS_REPORTSAVE_BODYTWO_TEXT
	Dim L_COMMENTS_NOCHANGE_DESCRIPTION_TEXT

	Dim L_SUBMIT_SELECT_OPERATINGSYSTEM_GROUPBOX
	Dim L_DETAILS_STATUS_BODY_TEXT
	Dim L_RECEIVED_STATUS_LINK_TEXT
	Dim L_RECEIVED_NEWFILE_LINK_TEXT
	Dim L_SUBMIT_EVENT_MAINTITLE_TEXT
	Dim L_SUBMIT_EVENT_DESCRIPTION_TEXT
	Dim L_SUBMIT_OPERATING_SYSTEM_TEXT
	Dim L_SUBMIT_RE_PRODUCE_EDITBOX
	Dim L_SUBMIT_COMMENTS_INFO_EDITBOX
	Dim L_SUBMIT_MAX_LENGTH_MESSAGE

	Dim L_SUBMIT_SELECT_WINDOWS2000_PROFESSIONAL_GROUPBOX
	Dim L_SUBMIT_SELECT_WINDOWS2000_SERVER_GROUPBOX
	Dim L_SUBMIT_SELECT_WINDOWS2000_ADVANCEDSERVER_GROUPBOX
	Dim L_SUBMIT_SELECT_WINDOWS2000_DATACENTER_GROUPBOX
	Dim L_SUBMIT_SELECT_WINDOWSXP_PERSONAL_GROUPBOX
	Dim L_SUBMIT_SELECT_WINDOWSXP_PROFESSIONAL_GROUPBOX
	Dim L_SUBMIT_SELECT_WINDOWSXP_SERVER_GROUPBOX
	Dim L_SUBMIT_SELECT_WINDOWSXP_ADVANCEDSERVER_GROUPBOX
	Dim L_SUBMIT_SELECT_WINDOWSXP_DATACENTER_GROUPBOX
	Dim L_SUBMIT_SELECT_WINDOWSXP_64BIT_GROUPBOX





	'-------------------------comments.asp Page Strings-------------------------
	L_SUBMIT_EVENT_DESCRIPTION_TEXT = "Error report description"
	L_SUBMIT_OPERATING_SYSTEM_TEXT = "Operating system:"
	L_SUBMIT_RE_PRODUCE_EDITBOX = "Steps to reproduce the Stop error (optional):"
	L_SUBMIT_COMMENTS_INFO_EDITBOX = "Comments (optional):"
	L_DETAILS_STATUS_BODY_TEXT = "Return to error report status"
	L_SUBMIT_MAX_LENGTH_MESSAGE = "The maximum number of characters is 1024."
	L_SUBMIT_EVENT_MAINTITLE_TEXT = "Selected error report"
	L_RECEIVED_NEWFILE_LINK_TEXT = "Submit an error report"
	L_RECEIVED_STATUS_LINK_TEXT = "Error report status"
	L_COMMENTS_OPERATING_SYSTEM_MESSAGE = "Select the operating system type."
	L_COMMENTS_SAVE_INFO_TEXT = "Update error report"
	L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE = "Database is not available"
	L_COMMENTS_NO_RECORDS_MESSAGE = "No error reports were found. To submit an error report, click Submit Report."
	L_COMMENTS_EVENT_DESCRIPTION_TEXT = "Error report description"
	L_COMMENTS_EVENT_NAME_TEXT = "Description:"
	L_COMMENTS_FILE_NAME_TEXT = "Comments for error report: "
	L_COMMENTS_CONNECTION_FAILED_TEXT = "Windows Online Crash Analysis was unable to connect to the database. Please try this task again." 
	L_COMMENTS_DATABASE_FAILED_TEXT = "Windows Online Crash Analysis was unable to save your information to the database. Please try this task again."
	L_COMMENTS_DATABASE_FAILURE_ERRORMESSAGE = "Database is not available"
	L_COMMENTS_DATABASE_FAILUREBODY_ERRORMESSAGE = "Windows Online Crash Analysis was unable to save your information to the database. Please try this task again. "
	L_COMMENTS_REPORTSAVE_TITLE_TEXT = "Error report updated"
	L_COMMENTS_REPORTSAVE_BODY_TEXT = "Error report "
	L_COMMENTS_REPORTSAVE_BODYTWO_TEXT = " was successfully updated."
	L_COMMENTS_NOCHANGE_DESCRIPTION_TEXT = "You can change the settings and text for every field except Description."
	L_SUBMIT_SELECT_OPERATINGSYSTEM_GROUPBOX = "- Select system -"
	L_SUBMIT_SELECT_WINDOWS2000_PROFESSIONAL_GROUPBOX = "Windows 2000 Professional"
	L_SUBMIT_SELECT_WINDOWS2000_SERVER_GROUPBOX = "Windows 2000 Server"
	L_SUBMIT_SELECT_WINDOWS2000_ADVANCEDSERVER_GROUPBOX = "Windows 2000 Advanced Server"
	L_SUBMIT_SELECT_WINDOWS2000_DATACENTER_GROUPBOX = "Windows 2000 Datacenter Server"
	L_SUBMIT_SELECT_WINDOWSXP_PERSONAL_GROUPBOX = "Windows XP Home Edition"
	L_SUBMIT_SELECT_WINDOWSXP_PROFESSIONAL_GROUPBOX = "Windows XP Professional"
	L_SUBMIT_SELECT_WINDOWSXP_SERVER_GROUPBOX = "Windows Server 2003"
	L_SUBMIT_SELECT_WINDOWSXP_ADVANCEDSERVER_GROUPBOX = ""
	L_SUBMIT_SELECT_WINDOWSXP_DATACENTER_GROUPBOX = ""
	L_SUBMIT_SELECT_WINDOWSXP_64BIT_GROUPBOX = "Windows XP 64-Bit Edition"
	'-----------------------------------------------------------------------------------------




%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\appverifierstrings.inc ===
<%

Dim L_APP_VERIFIER_TITLE_TEXT
Dim L_APP_VERIFIER_TITLEBODY_TEXT
Dim L_APP_VERIFIER_SUBTITLEONE_TEXT
Dim L_APP_VERIFIER_SUBTITLEONEBODY_TEXT
Dim L_APP_VERIFIER_SUBTITLEONEBODYTWO_TEXT
Dim L_APP_VERIFIER_SUBTITLEONEBODYTWOBOLD_TEXT
Dim L_APP_VERIFIER_SUBTITLETWO_TEXT
Dim L_APP_VERIFIER_SUBTITLETWOBODY_TEXT
Dim L_APP_VERIFIER_SUBTITLETHREE_TEXT
Dim L_APP_VERIFIER_SUBTITLETHREEBODY_TEXT
Dim L_APP_VERIFIER_SUBTITLETHREEBODYTWO_TEXT
Dim L_APP_VERIFIER_SUBTITLETHREEBODYTHREE_TEXT
Dim L_APP_VERIFIER_SUBTITLETHREEBODYTHREEBOLD_TEXT
Dim L_APP_VERIFIER_SUBTITLETHREEBODYFOUR_TEXT
Dim L_APP_VERIFIER_SUBTITLETHREEBODYFOURBOLD_TEXT
Dim L_APP_VERIFIER_SUBTITLETHREEBODYFIVE_TEXT
Dim L_APP_VERIFIER_SUBTITLETHREEBODYSIX_TEXT
Dim L_APP_VERIFIER_SUBTITLETHREEBODYSIXBOLD_TEXT
Dim L_APP_VERIFIER_SUBTITLETHREEBODYSEVEN_TEXT
Dim L_APP_VERIFIER_SUBTITLETHREEBODYSEVENBOLD_TEXT
Dim L_APP_VERIFIER_SUBTITLETHREEBODYEIGHT_TEXT
Dim L_APP_VERIFIER_SUBTITLEFOUR_TEXT
Dim L_APP_VERIFIER_SUBTITLEFOURBODY_TEXT
Dim L_APP_VERIFIER_SUBTITLEFOURBODYLINK_TEXT
Dim L_APP_VERIFIER_SUBTITLEFOURBODYLINK_URL
Dim L_CERINTROTEMP_INTRO_BODY2PERIOD_TEXT
Dim L_APP_VERIFIER_SUBTITLEFIVE_TEXT
Dim L_APP_VERIFIER_SUBTITLEFIVEBODY_TEXT
Dim L_APP_VERIFIER_SUBTITLEFIVEBODYLINK_TEXT
Dim L_APP_VERIFIER_SUBTITLEFIVEBODYLINK_URL
Dim L_APP_VERIFIER_SUBTITLESIX_TEXT
Dim L_APP_VERIFIER_SUBTITLESIXBODY_TEXT


'-------------------------appverifierstrings.asp Page Strings-------------------------
L_APP_VERIFIER_TITLE_TEXT = "Windows<sup>&#174;</sup> XP Application Verifier"
L_APP_VERIFIER_TITLEBODY_TEXT = "The Windows XP team has developed a tool that analyzes applications while they are being run. This additional information can provide Microsoft<sup>&#174;</sup> with the details necessary to make Windows XP a more reliable system."
L_APP_VERIFIER_SUBTITLEONE_TEXT = "How it works"
L_APP_VERIFIER_SUBTITLEONEBODY_TEXT = "As part of Windows Online Crash Analysis, we are asking a number of users to help us gather additional information about a particular crash by running the Application Verifier on their problematic application."
L_APP_VERIFIER_SUBTITLEONEBODYTWO_TEXT = "The Application Verifier runs a set of tests on a running application and logs the results. "
L_APP_VERIFIER_SUBTITLEONEBODYTWOBOLD_TEXT = "Note: Using the Application Verifier is for advanced users who understand their applications, and can slow down your system while the tests are being run. If you do not feel comfortable with this, please close this window."
L_APP_VERIFIER_SUBTITLETWO_TEXT = "What to expect"
L_APP_VERIFIER_SUBTITLETWOBODY_TEXT = "The Application Verifier runs a large suite of tests on your application. As a consequence, two things may happen:  your application will run slower and you may encounter new problems with your application. Both of these behaviors are expected so please continue to report any new issues uncovered."
L_APP_VERIFIER_SUBTITLETHREE_TEXT = "How to enable the Aplication Verifier"
L_APP_VERIFIER_SUBTITLETHREEBODY_TEXT = "The Application Verifier is located on your Windows XP CD-Rom in the support tools directory as part of the Application Compatibility Toolkit. This is commonly in d:\support\tools\act.exe, where d: is the letter assigned to your CD-ROM drive."
L_APP_VERIFIER_SUBTITLETHREEBODYTWO_TEXT = "Double click on ACT.EXE and it will install the toolkit, a collection of tools and documents on how to make your Applications more compatible on Windows XP. Once it is installed, look in your programs folder for the Application Compatibility Toolkit 2.0 and select the Application Verifier."
L_APP_VERIFIER_SUBTITLETHREEBODYTHREE_TEXT = "On the AppVerifier, there is an "
L_APP_VERIFIER_SUBTITLETHREEBODYTHREEBOLD_TEXT = "Add "
L_APP_VERIFIER_SUBTITLETHREEBODYFOUR_TEXT = "button. Click on it and select the application that is having problems on your system. Then click on the "
L_APP_VERIFIER_SUBTITLETHREEBODYFOURBOLD_TEXT = "Run "
L_APP_VERIFIER_SUBTITLETHREEBODYFIVE_TEXT = "button and attempt to follow the same actions that caused your original crash.  Remember that the AppVerifier may make your application crash sooner if it finds a different problem. Report any errors you find through the Error Reporting Tool."
L_APP_VERIFIER_SUBTITLETHREEBODYSIX_TEXT = "When you are done testing your application, use the "
L_APP_VERIFIER_SUBTITLETHREEBODYSIXBOLD_TEXT = "Remove "
L_APP_VERIFIER_SUBTITLETHREEBODYSEVEN_TEXT = "button to remove your applications from the Application Verifier. "
L_APP_VERIFIER_SUBTITLETHREEBODYSEVENBOLD_TEXT = "This is extremely important! "
L_APP_VERIFIER_SUBTITLETHREEBODYEIGHT_TEXT = "If you do not remove it, the Application Verifier will continue testing your application even without the tool itself present or running."
L_APP_VERIFIER_SUBTITLEFOUR_TEXT = "Additional resources you may need"
L_APP_VERIFIER_SUBTITLEFOURBODY_TEXT = "The latest version of the Application Compatibility Toolkit is located at "
L_APP_VERIFIER_SUBTITLEFOURBODYLINK_TEXT = "http://msdn.microsoft.com/compatibility"
L_APP_VERIFIER_SUBTITLEFOURBODYLINK_URL = "http://msdn.microsoft.com/compatibility"
L_CERINTROTEMP_INTRO_BODY2PERIOD_TEXT = "."
L_APP_VERIFIER_SUBTITLEFIVE_TEXT = "Where to go for help"
L_APP_VERIFIER_SUBTITLEFIVEBODY_TEXT = "For additional help or comments on the Application Verifier, contact "
L_APP_VERIFIER_SUBTITLEFIVEBODYLINK_TEXT = "oca@microsoft.com"
L_APP_VERIFIER_SUBTITLEFIVEBODYLINK_URL = "mailto:oca@microsoft.com"
L_APP_VERIFIER_SUBTITLESIX_TEXT = "Thank you"
L_APP_VERIFIER_SUBTITLESIXBODY_TEXT = "Your use of the Application Verifier will help improve the stability of Windows and help your fellow users around the world."
'-------------------------------------------------------------------------------------
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\corplocatelogstrings.inc ===
<%


	Dim L_HEADER_INC_TITLE_PAGETITLE
	Dim L_LOCATE_FAQ_INFO_TEXT
	Dim L_CORPLOCATE_TRANSACTION_LOG_TEXT
	Dim L_CORPLOCATE_DESCRIPTION_BODY_TEXT
	Dim L_CORPLOCATE_DESCRIPTION_BOTTOM_TEXT
	Dim L_LOCATE_CANCEL_LINK_TEXT
	Dim L_LOCATE_BROWSE_BUTTONTEXT_TEXT
	Dim L_CORPLOCATE_OK_BUTTON_TEXT
	Dim L_CORPLOCATE_BROWSE_TITLE_TEXT
	Dim L_LOCATE_WARN_ING_ERRORMESSAGE
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSONE_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSTWO_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSTHREE_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSFOUR_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSFIVE_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSSIX_TEXT 

	L_LOCATE_WARN_ING_ERRORMESSAGE = "The ActiveX control was not installed"
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSONE_TEXT = "The installation of the ActiveX control might fail because:"
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSTWO_TEXT = "1. You do not have Administrator rights on the Windows NT 4.0, Windows 2000, Microsoft Windows XP Professional or Windows Server 2003 system you are using."
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSTHREE_TEXT = "2. Your Internet security options for Internet Explorer are set to High or Custom."
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSFOUR_TEXT = "To reset the options:"
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSFIVE_TEXT = "1. In the Tools menu, select Internet Options."
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSSIX_TEXT = "2. On the Security tab, set the security level to Medium or lower, and then click OK."
	L_CORPLOCATE_DESCRIPTION_BOTTOM_TEXT = "Please note that this information is not stored by Microsoft Corporation and is only used to help associate error reports with the transaction log file."
	L_CORPLOCATE_DESCRIPTION_BODY_TEXT = " The Corporate Error Reporting Transaction log file (.log) associates Stop errors with the computers that experienced the crash events. To display the associated computer information for the selected Stop errors, you must locate the directory that contains this file. This directory is on the computer that collects Stop errors. If you don't know the location of the transaction log file, contact your system administrator."
	L_CORPLOCATE_TRANSACTION_LOG_TEXT = "Locate Transaction Log"
	L_HEADER_INC_TITLE_PAGETITLE = "Windows Online Crash Analysis"
	L_LOCATE_FAQ_INFO_TEXT = "The ActiveX control was not installed. For more information, see the Frequently asked questions (FAQ) page."
	L_LOCATE_CANCEL_LINK_TEXT = "Cancel"
	L_LOCATE_BROWSE_BUTTONTEXT_TEXT = "Browse..."
	L_CORPLOCATE_OK_BUTTON_TEXT = "OK"
	L_CORPLOCATE_BROWSE_TITLE_TEXT = "Transaction log file directory:"

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\corpcustomerstrings.inc ===
<%
DIM L_CERCUST_CHECK_ALL_ALERT
DIM L_CERCUST_CHECK_DESC_ALERT
DIM L_CERCUST_CHECK_EMAIL_ALERT
DIM L_CERCUST_CONTACT_HEAD_TEXT
DIM L_CERCUST_CONTACT_INFO_TEXT
DIM L_CERCUST_CONTACT_TEXT_TEXT		
DIM L_CERCUST_INPUT_CONTACT_TEXT
DIM L_CERCUST_INPUT_EMAIL_TEXT
DIM L_CERCUST_INPUT_PHONE_TEXT
DIM L_CERCUST_TRANS_HEAD_TEXT 
DIM L_CERCUST_TRANS_INFO_TEXT 
DIM L_CERCUST_INPUT_TRANS_TEXT
DIM L_CERCUST_CAN_CEL_LINK 
DIM L_CERCUST_CON_TINUE_LINK
DIM L_CERCUST_PASS_PORT_TEXT
DIM L_CERCUST_PASSPORT_TITLE_TEXT
DIM L_FAQ_PASSPORT_LINK_TEXT
DIM L_WELCOME_PASSPORT_LINK_TEXT
DIM L_CERUP_NO_FILESTITLE_TEXT
DIM L_CERUP_NO_FILES_TEXT
DIM L_CERUP_UPLOADING_BLOCK_TEXT
DIM L_CER_UPLOAD_ERROR_ALERT
DIM L_CERUP_UPLOAD_STATUS_TEXT1
DIM L_CERUP_UPLOAD_STATUS_TEXT2
DIM L_CERUP_UPLOAD_SUMMARY_TEXT
DIM L_CERUP_COM_PLETE_TEXT
DIM L_CERUP_TIT_LE_TEXT
DIM L_CERUP_SUB_TITLE_TEXT
DIM L_CERUP_UPLOAD_ERROR_ALERT
DIM L_CERUP_UPLOAD_ERROR_ALERT2
DIM L_CERUP_COMPLETE_TITLE_TEXT
DIM L_RECEIVED_NEWFILE_LINK_TEXT
DIM L_WELCOME_GO_IMAGEALT_TEXT
DIM L_CERUP_NO_FILES0_TEXT
Dim L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE
Dim L_COMMENTS_DATABASE_FAILED_TEXT
Dim L_COMMENTS_CONNECTION_FAILED_TEXT
'Dim L_LOCATE_PREVIOUS_LINK_TEXT
Dim L_LOCATE_WARN_ING_ERRORMESSAGE
Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSONE_TEXT 
Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSTWO_TEXT 
Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSTHREE_TEXT 
Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSFOUR_TEXT 
Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSFIVE_TEXT 
Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSSIX_TEXT 

'L_LOCATE_PREVIOUS_LINK_TEXT = "Previous"
L_CERUP_NO_FILES0_TEXT = "Unable to locate error reports"	
L_CERUP_SUB_TITLE_TEXT = "Submitting transactions"
L_CERUP_TIT_LE_TEXT = "Uploading transaction"
L_CERUP_UPLOAD_SUMMARY_TEXT = "Please wait while we upload the selected transaction.  The upload time is dependent upon your connection speed, network traffic, and the number of files in the transaction. This can take several hours to complete this transaction."
L_CERUP_COMPLETE_TITLE_TEXT = "Transaction submitted"
L_CERUP_COM_PLETE_TEXT = "Thank you for submitting your report.  We will contact you by e-mail when we have information about your error report.  If you would like to check the status of your error report, return to the Windows Online Crash Analysis Web site and click Status."
L_CERUP_UPLOAD_STATUS_TEXT1 = "Uploading file"
L_CERUP_UPLOAD_STATUS_TEXT2 = "of"
L_CERUP_UPLOAD_ERROR_ALERT = "The upload for error report "
L_CERUP_UPLOAD_ERROR_ALERT2 = " was not successful."
L_CERUP_UPLOADING_BLOCK_TEXT = "Uploading transaction segment:"
L_CERUP_NO_FILESTITLE_TEXT = "Unable to upload transaction"
L_CERUP_NO_FILES_TEXT = "We were unable to locate any error reports in: "
L_CERCUST_CHECK_ALL_ALERT = "Please correct the following errors:\n\n"
L_CERCUST_CHECK_DESC_ALERT = "Please enter a description for this transaction."
L_CERCUST_CHECK_EMAIL_ALERT = "Please enter a valid e-mail address."
L_CERCUST_CONTACT_HEAD_TEXT = "Contact information"
L_CERCUST_CONTACT_INFO_TEXT = "Type the contact information we should use to send you questions, analysis results, and any solutions we discover. If you choose not to submit contact information, we cannot send you the results of your event report analysis."
L_CERCUST_CONTACT_TEXT_TEXT = "Contact information (optional):"		
L_CERCUST_INPUT_CONTACT_TEXT = "Name:"
L_CERCUST_INPUT_EMAIL_TEXT = "E-mail address:"
L_CERCUST_INPUT_PHONE_TEXT = "Telephone number:"
L_CERCUST_TRANS_HEAD_TEXT = "Transaction description"
L_CERCUST_TRANS_INFO_TEXT = "To identify this transaction in subsequent lists, type a description you can easily remember. After you type the description and complete the rest of the information, click Continue."
L_CERCUST_INPUT_TRANS_TEXT = "Description:"
L_CERCUST_CAN_CEL_LINK = "Cancel"
L_CERCUST_CON_TINUE_LINK = "Continue"
L_CERCUST_PASS_PORT_TEXT = "To submit a transaction, sign in using your Microsoft Passport. To get a Passport, visit the"
L_WELCOME_PASSPORT_LINK_TEXT = "Microsoft Passport Web site."
L_CERCUST_PASSPORT_TITLE_TEXT = "Passport sign-in"
L_FAQ_PASSPORT_LINK_TEXT = "http://www.passport.com"
L_RECEIVED_NEWFILE_LINK_TEXT = "Home"
L_WELCOME_GO_IMAGEALT_TEXT = "Go"
L_COMMENTS_CONNECTION_FAILED_TEXT = "Windows Online Crash Analysis was unable to connect to the database. Please try this task again." 
L_COMMENTS_DATABASE_FAILED_TEXT = "Windows Online Crash Analysis was unable to save your information to the database. Please try this task again."
L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE = "Database is not available"
L_LOCATE_WARN_ING_ERRORMESSAGE = "The ActiveX control was not installed"
L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSONE_TEXT = "The installation of the ActiveX control might fail because:"
L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSTWO_TEXT = "1. You do not have Administrator rights on the Windows NT 4.0, Windows 2000, Microsoft Windows XP Professional or Windows Server 2003 system you are using."
L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSTHREE_TEXT = "2. Your Internet security options for Internet Explorer are set to High or Custom."
L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSFOUR_TEXT = "To reset the options:"
L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSFIVE_TEXT = "1. In the Tools menu, select Internet Options."
L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSSIX_TEXT = "2. On the Security tab, set the security level to Medium or lower, and then click OK."

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\corpprocessfilesstrings.inc ===
<HTML>
<HEAD>
<META NAME="GENERATOR" Content="Microsoft Visual Studio 6.0">
<TITLE></TITLE>
</HEAD>
<BODY>

<P>&nbsp;</P>

</BODY>
</HTML>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\corpdonestrings.inc ===
<%

	Dim L_CERDONE_FILE_ONE_TEXT
	Dim L_CERDONE_FILE_TWO_TEXT
	Dim L_CERDONE_THANK_YOU_TEXT
	Dim L_CERDONE_STATUS_LINK_TEXT
	Dim L_CERDONE_HOME_LINK_TEXT
	Dim L_WELCOME_GO_IMAGEALT_TEXT
	Dim L_CERDONE_SUCCESS_PARTONE_TEXT
	Dim L_CERDONE_SUCCESS_PARTTWO_TEXT
	DIM L_CERDONE_SUCCESS_PARTTHREE_TEXT

	'-------------------------received.asp Page Strings-------------------------
	L_CERDONE_FILE_ONE_TEXT = "Transaction submitted"
	L_CERDONE_THANK_YOU_TEXT = "Thank you for submitting your report.  We will contact you by e-mail when we have information about your error report.  If you would like to check the status of your error report, return to the Windows Online Crash Analysis Web site and click Status."
	L_CERDONE_HOME_LINK_TEXT = "Home"
	L_CERDONE_STATUS_LINK_TEXT = "Transaction status"	
	L_WELCOME_GO_IMAGEALT_TEXT = "Go"
	L_CERDONE_SUCCESS_PARTONE_TEXT = "Thank you for submitting your transaction. Transaction "
	L_CERDONE_SUCCESS_PARTTWO_TEXT = " contained "
	L_CERDONE_SUCCESS_PARTTHREE_TEXT = " error reports and was successfully submitted. If you have more error reports you can use the Corporate Error Reporting client to create a new transaction for submission."	
	
	'-----------------------------------------------------------------------------------------




%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\corpprivacystrings.inc ===
<%

	Dim L_PRIVACY_TITLE_INFO_TEXT
	Dim L_PRIVACY_MD5_HASH_TEXT
	Dim L_SPRIVACY_MD5_HASH_TEXT
	Dim L_SPRIVACY_MD5_EMAILONE_TEXT
	Dim L_SPRIVACY_MD5_EMAILTWO_TEXT
	Dim L_FAQINFORMATION_TEXT
	Dim L_LOCATE_CANCEL_LINK_TEXT
	Dim L_CUSTOMER_NEXT_LINK_TEXT
	
	'-------------------------privacy.asp Page Strings-------------------------
	L_PRIVACY_TITLE_INFO_TEXT = "Privacy information"
	L_PRIVACY_MD5_HASH_TEXT = "Each error report is uniquely identified with a Message Digest 5 (MD5) hashing algorithm (commonly known as a &quot;fingerprint&quot;). This is done to keep duplicate error reports from being submitted. If an MD5 encryption key is not already present on your computer, we will generate one for you that will be installed on your computer. This encryption key is commonly used  to help secure data sent over the Internet and will not affect any other data."
	L_SPRIVACY_MD5_HASH_TEXT = "Once uploaded, error reports are stored on a secure Microsoft server where only those individuals involved in Stop error analysis can gain access to them. The information is kept only as long as it is useful in researching and analyzing Stop error. As necessary, Microsoft shares error report analyses with qualified hardware and software partners for assistance. "
	L_SPRIVACY_MD5_EMAILONE_TEXT = "Thank you for submitting this error report.  Error reports contain information about what your operating system was doing when the Stop error occurred. This "
	L_SPRIVACY_MD5_EMAILTWO_TEXT = " will be analyzed to determine possible causes of the Stop error. Your error report is still anonymous at this time. However, to receive possible solution information for Stop errors, you must provide an e-mail address, which you can enter by clicking Continue. This information is used only to contact you about the report and will not be used for any other purpose, including marketing."
	L_FAQINFORMATION_TEXT = "information"
	L_LOCATE_CANCEL_LINK_TEXT = "Cancel"
	L_CUSTOMER_NEXT_LINK_TEXT = "Continue"

	
	'-------------------------End-------------------------

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\corptransactionsstrings.inc ===
<%

	Dim L_FAQ_PASSPORT_LINK_TEXT
	Dim L_CUSTOMER_PASSPORT_TITLE_TEXT
	Dim L_CUSTOMER_PASSPORT_INFO_TEXT
	Dim L_WELCOME_PASSPORT_LINK_TEXT
	Dim L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE
	Dim L_COMMENTS_CONNECTION_FAILED_TEXT
	Dim L_CORPTRANSACTIONS_DATABASE_FAILED_TEXT
	Dim L_CORPTRANSACTIONS_CORPORATE_TITLE_TEXT
	Dim L_CORPTRANSAACTIONS_SUBTITLE_CHOOSE_TEXT
	Dim L_CORPTRANSACTIONS_TRANSACTION_NAME_TEXT
	Dim L_CORPTRANSACTIONS_TRANSACTION_DATE_TEXT
	Dim L_CORPTRANSACTIONS_STATUS_STATUS_TEXT
	Dim L_CORPTRANSACTIONS_TYPE_TYPE_TEXT
	Dim L_CORPTRANSACTIONS_FILE_COUNT_TEXT
	Dim L_CORPTRANSACTIONS_COMPLETE_COMPLETE_TEXT
	Dim L_CORPTRANSACTIONS_INCOMPLETE_INCOMPLETE_TEXT
	Dim L_CORPTRANSACTIONS_STARTUP_SHUTDOWN_TEXT
	Dim L_CORPTRANSACTIONS_SYSTEM_CRASH_TEXT
	Dim L_CORPTRANSACTIONS_VIEW_TRANSACTIONS_TEXT
	Dim L_STATUS_NO_RECORDS_MESSAGE
	
	L_STATUS_NO_RECORDS_MESSAGE = "No transactions reports were found."
	L_CORPTRANSACTIONS_VIEW_TRANSACTIONS_TEXT = "View Transaction"
	L_CORPTRANSACTIONS_SYSTEM_CRASH_TEXT = "System error report"
	L_CORPTRANSACTIONS_STARTUP_SHUTDOWN_TEXT = "Startup/Shutdown error report"
	L_CORPTRANSACTIONS_INCOMPLETE_INCOMPLETE_TEXT = "Incomplete"
	L_CORPTRANSACTIONS_COMPLETE_COMPLETE_TEXT = "Complete"
	L_CORPTRANSACTIONS_FILE_COUNT_TEXT = "Files Received"
	L_CORPTRANSACTIONS_TYPE_TYPE_TEXT = "Type"
	L_CORPTRANSACTIONS_STATUS_STATUS_TEXT = "Transaction ID"
	L_CORPTRANSACTIONS_TRANSACTION_DATE_TEXT = "Transaction Date"
	L_CORPTRANSACTIONS_TRANSACTION_NAME_TEXT = "Transaction Name"
	L_CORPTRANSACTIONS_CORPORATE_TITLE_TEXT = "View transactions"
	L_CORPTRANSACTIONS_DATABASE_FAILED_TEXT = "The database is currently unavailable!"
	L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE = "Database is not available"
	L_FAQ_PASSPORT_LINK_TEXT = "http://www.passport.com"
	L_CUSTOMER_PASSPORT_TITLE_TEXT = "Passport sign-in"
	L_CUSTOMER_PASSPORT_INFO_TEXT = "To submit an error report, sign in using your Microsoft Passport. To get a Passport, visit the "
	L_WELCOME_PASSPORT_LINK_TEXT = "Microsoft Passport Web site." 
	L_COMMENTS_CONNECTION_FAILED_TEXT = "Windows Online Crash Analysis was unable to connect to the database. Please try this task again." 
	L_CORPTRANSAACTIONS_SUBTITLE_CHOOSE_TEXT = "To view a transaction, find its name and click on its associated link in the View transaction column."


%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\footerstrings.inc ===
<%

	Dim L_FOOTERINC_TERMS_OFUSE_VERSION
	Dim L_FOOTER_INC_RIGHTS_VERSION
	Dim L_WAIT_MICROSOFT_LINK_TEXT



	'-------------------------footer.asp Page Strings-------------------------
	L_FOOTER_INC_RIGHTS_VERSION = "&#169; 2001 Microsoft Corporation. All rights reserved."
	L_FOOTERINC_TERMS_OFUSE_VERSION = "Terms of Use"
	L_WAIT_MICROSOFT_LINK_TEXT = "http://www.microsoft.com/isapi/gomscom.asp?target=/info/cpyright.htm"
	'-------------------------End-------------------------
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\corpviewstrings.inc ===
<%
	
	
	Dim L_STATUS_IN_PROGRESS_TEXT
	Dim L_STATUS_RESEARCHING_INFO_TEXT
	Dim L_STATUS_COMPLETE_INFO_TEXT
	Dim L_STATUS_UNABLE_TOPROCESS_TEXT
	Dim L_STATUS_NEED_FULLDUMP_TEXT
	Dim L_STATUS_RESEARCHING_MOREINFO_TEXT
	Dim L_STATUS_UN_KNOWN_TEXT
	Dim L_FAQ_PASSPORT_LINK_TEXT
	Dim L_COMMENTS_DATABASE_FAILED_TEXT
	Dim L_COMMENTS_CONNECTION_FAILED_TEXT
	Dim L_CORPVIEWDATABASE_FAILED_TEXT
	Dim L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE
	Dim L_CUSTOMER_PASSPORT_TITLE_TEXT
	Dim L_CUSTOMER_PASSPORT_INFO_TEXT
	Dim L_WELCOME_PASSPORT_LINK_TEXT
	Dim L_LOCATE_FAQ_INFO_TEXT
	Dim L_CORPVIEW_CORPORATE_SUBMISSION_TEXT
	Dim L_CORPVIEW_MAIN_BODY_TEXT
	Dim L_CORPVIEW_INSTANACES_BYSTATUS_TEXT
	Dim L_CORPVIEW_TYPE_TYPE_TEXT
	Dim L_CORPVIEW_STATUS_STATUS_TEXT
	Dim L_CORPVIEW_INSTANCES_INSTANCES_TEXT
	Dim L_CORPVIEW_SYSTEM_SYSTEM_TEXT
	Dim L_CORPVIEW_FILE_FILE_TEXT
	Dim L_CORPVIEW_DETAILS_DETAILS_TEXT
	Dim L_CORPVIEW_EVENTID_EVENTID_TEXT
	Dim L_CORPVIEW_NO_RECORDS_TEXT 
	Dim L_CORPVIEW_INSTACNCES_STOPCODE_TEXT
	Dim L_CORPVIEW_INSTANCES_TYPEID_TEXT
	Dim L_COPRVIEW_PREVIOUS_LINK_TEXT
	Dim L_CORPVIEW_INVALID_FILE_TEXT
	Dim L_LOCATE_WARN_ING_ERRORMESSAGE
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSONE_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSTWO_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSTHREE_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSFOUR_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSFIVE_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSSIX_TEXT 
	Dim L_STATUS_ALERT_CANNOTPROCESS_MESSAGE
	Dim L_STATUS_ALERT_ERROR_MESSAGE
	
	L_COPRVIEW_PREVIOUS_LINK_TEXT = "Return to corporate transaction status"
	L_CORPVIEW_INSTANCES_TYPEID_TEXT = "Top ten error reports by Type"
	L_CORPVIEW_INSTACNCES_STOPCODE_TEXT = "Top ten error reports by Stop code"
	L_CORPVIEW_NO_RECORDS_TEXT = "Corporate transaction analysis in progress."
	L_CORPVIEW_EVENTID_EVENTID_TEXT = "ErrorID"
	L_CORPVIEW_DETAILS_DETAILS_TEXT = "Details"
	L_CORPVIEW_FILE_FILE_TEXT = "File"
	L_CORPVIEW_SYSTEM_SYSTEM_TEXT = "System"
	L_CORPVIEW_INSTANCES_INSTANCES_TEXT = "Instances"
	L_CORPVIEW_STATUS_STATUS_TEXT = "Status"
	L_CORPVIEW_TYPE_TYPE_TEXT = "Type"
	L_CORPVIEW_INSTANACES_BYSTATUS_TEXT = "Error reports by Status"
	L_CORPVIEW_MAIN_BODY_TEXT = "This transaction contains the following error reports. To view the analysis status for an error report, click the associated link in the Status column. "
	L_CORPVIEW_CORPORATE_SUBMISSION_TEXT = "Corporate transaction status"
	L_LOCATE_FAQ_INFO_TEXT = "The ActiveX control was not installed. For more information, see the Frequently asked questions (FAQ) page."
	L_COMMENTS_CONNECTION_FAILED_TEXT = "Windows Online Crash Analysis was unable to connect to the database. Please try this task again." 
	L_COMMENTS_DATABASE_FAILED_TEXT = "Windows Online Crash Analysis was unable to save your information to the database. Please try this task again."
	L_CORPVIEWDATABASE_FAILED_TEXT = "Windows Online Crash Analysis was unable to connect to the database. Please try this task again."
	L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE = "Database is not available"
	L_FAQ_PASSPORT_LINK_TEXT = "http://www.passport.com"
	L_CUSTOMER_PASSPORT_TITLE_TEXT = "Passport sign-in"
	L_CUSTOMER_PASSPORT_INFO_TEXT = "To submit an error report, sign in using your Microsoft Passport. To get a Passport, visit the "
	L_WELCOME_PASSPORT_LINK_TEXT = "Microsoft Passport Web site." 
	L_STATUS_IN_PROGRESS_TEXT = "In progress"
	L_STATUS_RESEARCHING_INFO_TEXT = "Researching"
	L_STATUS_COMPLETE_INFO_TEXT = "Complete"
	L_STATUS_UNABLE_TOPROCESS_TEXT = "Cannot process"
	L_STATUS_NEED_FULLDUMP_TEXT = "Complete memory dump needed"
	L_STATUS_RESEARCHING_MOREINFO_TEXT = "Information available"
	L_STATUS_UN_KNOWN_TEXT = "Unknown"
	L_CORPVIEW_INVALID_FILE_TEXT = "Invalid File"
	L_LOCATE_WARN_ING_ERRORMESSAGE = "The ActiveX control was not installed"
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSONE_TEXT = "The installation of the ActiveX control might fail because:"
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSTWO_TEXT = "1. You do not have Administrator rights on the Windows NT 4.0, Windows 2000, Microsoft Windows XP Professional or Windows Server 2003 system you are using."
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSTHREE_TEXT = "2. Your Internet security options for Internet Explorer are set to High or Custom."
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSFOUR_TEXT = "To reset the options:"
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSFIVE_TEXT = "1. In the Tools menu, select Internet Options."
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSSIX_TEXT = "2. On the Security tab, set the security level to Medium or lower, and then click OK."
	L_STATUS_ALERT_CANNOTPROCESS_MESSAGE = "There are no details for this error report because we cannot process it."
	L_STATUS_ALERT_ERROR_MESSAGE = "There are no details for this error report because we are currently processing it."

	
	
	
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\corpwelcomestrings.inc ===
<%
	Dim L_CORPWELCOME_GO_IMAGEALT_TEXT
	Dim L_CORPWELCOME_INTRO_TITLE_TEXT
	Dim L_CORPWELCOME_INTRO_BODY1_TEXT
	Dim L_CORPWELCOME_INTRO_BODY2_TEXT
	Dim L_CORPWELCOME_INTRO_BODY3_TEXT
	Dim L_CORPWELCOME_INTRO_BODY2PERIOD_TEXT
	Dim L_CORPWELCOME_KERNELMODE_SUBTITLE_TEXT
	Dim L_CORPWELCOME_KERNELMODE_BODY1_TEXT
	Dim L_CORPWELCOME_KERNELMODE_BODY2_TEXT
	Dim L_CORPWELCOME_KERNELMODE_BODY3_TEXT
	Dim L_CORPWELCOME_SHUTDOWN_SUBTITLE_TEXT
	Dim L_CORPWELCOME_SHUTDOWN_BODY_TEXT
	Dim L_CORPWELCOME_PCW_SUBTITLE_TEXT
	Dim L_CORPWELCOME_PCW_BODY1_TEXT
	Dim L_CORPWELCOME_PCW_BODY2_TEXT
	Dim L_CORPWELCOME_BENEFIT_SUBTITLE_TEXT
	Dim L_CORPWELCOME_BENEFIT_BODY_TEXT
	Dim L_CORPWELCOME_TOP10STATUS_LINK_TEXT
	Dim L_CORPWELCOME_SUBMIT_LINK_TEXT
	Dim L_COPRWELCOME_WHATTOEXPECT_SUBTITLE_TEXT
	Dim L_COPRWELCOME_WHATTOEXPECT_BODY_TEXT
	Dim L_CORPWELCOME_CORPSETUP_SUBTITLE_TEXT
	Dim L_CORPWELCOME_CORPSETUP_BODY_TEXT
	Dim L_CORPWELCOME_CORPSETUP_LINK_TEXT
	Dim L_CORPWELCOME_CORPSETUP_LINK_URL
	Dim L_CORPWELCOME_CORPREQUIREMENTS_SUBTITLE_TEXT
	Dim L_CORPWELCOME_CORPREQUIREMENTS_BODY1_TEXT
	Dim L_CORPWELCOME_CORPREQUIREMENTS_LINK1_TEXT
	Dim L_CORPWELCOME_CORPREQUIREMENTS_LINK1_URL
	Dim L_CORPWELCOME_CORPREQUIREMENTS_BODY2_TEXT
	Dim L_CORPWELCOME_CORPREQUIREMENTS_LINK2_TEXT
	Dim L_CORPWELCOME_CORPREQUIREMENTS_LINK2_URL
	Dim L_CORPWELCOME_CORPREQUIREMENTS_BODY2A_TEXT
	Dim L_CORPWELCOME_CORPREQUIREMENTS_BODY3_TEXT
	

	L_CORPWELCOME_GO_IMAGEALT_TEXT = "Go"
	L_CORPWELCOME_INTRO_TITLE_TEXT = "Welcome to the Corporate Error Reporting Web site"
	L_CORPWELCOME_INTRO_BODY1_TEXT = "Microsoft is committed to making Windows XP Professional and Windows Server 2003 the most reliable operating systems available. New and enhanced features in Windows XP Professional and Windows Server 2003 contribute to increased reliability, and additional resources, such as Windows Online Crash Analysis, provide information to help you optimize your system and increase stability."
	L_CORPWELCOME_INTRO_BODY2_TEXT = "The Office XP Corporate Error Reporting client, in conjunction with Windows Online Crash Analysis, enables corporations to collect, manage, and analyze error reports.  This process enables you to submit multiple error reports in a single transaction to the Windows Online Crash Analysis Web site for initial analysis.  At any point during the analysis you can view the current status of your transaction."
	L_CORPWELCOME_INTRO_BODY3_TEXT = "Using the Corporate Error Reporting Web site in conjunction with the Office XP Corporate Error Reporting client enables corporations to collect, manage, and analyze error reports."
	L_CORPWELCOME_KERNELMODE_SUBTITLE_TEXT = "Kernel mode faults"
	L_CORPWELCOME_KERNELMODE_BODY1_TEXT = "You can submit multiple error reports in a single transaction to the Corporate Error Reports site for an initial analysis. This information is then compiled and displayed on a status page, which you can use to track error trends, problem software, and other issues."
	L_CORPWELCOME_KERNELMODE_BODY2_TEXT = "Microsoft actively analyzes all error reports and prioritizes them based on the number of customers affected by the Stop error covered in the error report. We will try to determine the cause of the Stop error you submit, categorize it according to the type of issue encountered, and send you relevent information when such information is identified. You can check the status of your error report at any time. However, because error reports do not always contain enough information to positively identify the source of the issue, we might need to collect a number of similar error reports from other customers before a pattern is discovered, or follow up with you further to gather additional information. Furthermore, some error reports might require additional resources (such as a hardware debugger or a live debugger session)  before a solution can be found. Although we might not be able to provide a solution for your particular Stop error, all information submitted is used to further improve the quality and reliability of Windows."
	L_CORPWELCOME_KERNELMODE_BODY3_TEXT = "This free service can help save valuable debugging and troubleshooting time while lowering the total cost of ownership."
	L_CORPWELCOME_SHUTDOWN_SUBTITLE_TEXT = "System State Data"
	L_CORPWELCOME_SHUTDOWN_BODY_TEXT = "You can submit multiple shutdown event reports in a single transaction to the Corporate Reports site.  We will actively analyze a subset of the unique transactions we receive.  At this time, Microsoft does not report any status on shutdown reports.  All information submitted is used to further improve the quality and reliability of Windows XP, Windows Server 2003 and other Microsoft products."
	L_CORPWELCOME_PCW_SUBTITLE_TEXT = "Program Compatibility Wizard reports"
	L_CORPWELCOME_PCW_BODY1_TEXT = "You can use the Program Compatibility Wizard to search for possible compatibility solutions that may help a program to run on Windows XP Professional or Windows Server 2003. The Program Compatibility Wizard enables you to submit a report to Microsoft of what steps were taken to help the program run. The report contains the name and version of both the program and the operating system, as well as any compatibility solutions that were used."
	L_CORPWELCOME_PCW_BODY2_TEXT = "Microsoft uses the report to make changes to Windows XP Professional and Windows Server 2003 that should prevent future incompatibilities with the program. By submitting this report to Microsoft, you are helping make Windows XP Professional and Windows Server 2003 better today and for the future."
	L_CORPWELCOME_TOP10STATUS_LINK_TEXT = "Identify your top issues"
	L_CORPWELCOME_SUBMIT_LINK_TEXT = "Submit a transaction"
	L_CORPWELCOME_CORPSETUP_SUBTITLE_TEXT = "Office XP Corporate Error Reporting client requirements"
	L_CORPWELCOME_CORPSETUP_BODY_TEXT = "Before you can use the Corporate Error Reporting Web site in conjunction with the Office XP Corporate Error Reporting client you must download and install the necessary software. To find out more about the Office XP Corporate Error Reporting client and its installation, go to the"
	L_CORPWELCOME_CORPSETUP_LINK_TEXT = "Office XP Corporate Error Reporting client Web site"
	L_CORPWELCOME_CORPSETUP_LINK_URL = "http://www.microsoft.com/office/ork/xp/two/adma05.htm"
	L_CORPWELCOME_INTRO_BODY2PERIOD_TEXT = "."
	L_CORPWELCOME_CORPREQUIREMENTS_SUBTITLE_TEXT = "Additional requirements"
	L_CORPWELCOME_CORPREQUIREMENTS_BODY1_TEXT = "To submit either an error report or a transaction, you must be using Windows NT 4.0, Windows 2000, Windows XP Professional, or Windows Server 2003. Windows Online Crash Analysis requires Microsoft Internet Explorer 5 or later and a Microsoft Passport. To download the latest version of Internet Explorer, visit the "
	L_CORPWELCOME_CORPREQUIREMENTS_LINK1_TEXT = "Microsoft Web site"
	L_CORPWELCOME_CORPREQUIREMENTS_LINK1_URL = "http://www.microsoft.com"
	L_CORPWELCOME_CORPREQUIREMENTS_BODY2_TEXT = " To get a Passport, visit the"
	L_CORPWELCOME_CORPREQUIREMENTS_LINK2_TEXT = "Microsoft Passport Web site"
	L_CORPWELCOME_CORPREQUIREMENTS_LINK2_URL = "http://www.passport.com"
	L_CORPWELCOME_CORPREQUIREMENTS_BODY2A_TEXT = "."
	L_CORPWELCOME_CORPREQUIREMENTS_BODY3_TEXT = "For Windows 2000 error reports, a Premier account is required. For more information about Premier accounts, see Product Support Services on the "
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\faqstrings.inc ===
<%

	Dim L_FAQ_WHAT_SHOULDI_TEXT
	Dim L_FAQ_WHO_CANI_TEXT
	Dim L_FAQ_WHAT_KINDOF_TEXT
	Dim L_FAQ_HOWDOI_CONFIGURE_TEXT
	Dim L_FAQ_WHYWAS_THESITE_TEXT
	Dim L_FAQ_WHYDO_IGETA_TEXT
	Dim L_FAQ_WHATIF_ICANTWAIT_TEXT
	Dim L_FAQ_WHATIF_CANNOTPROCESS_TEXT
	Dim L_FAQ_WHATIF_CANNOTPROCESSBODY_TEXT
	Dim L_FAQ_WHATIF_CANNOTPROCESSBODY1_TEXT
	Dim L_FAQ_WHATIF_CANNOTPROCESSBODY2_TEXT
	Dim L_FAQ_WHATIF_CANNOTPROCESSBODY3_TEXT
	Dim L_FAQ_WHATIF_CANNOTPROCESSBODY4_TEXT
	Dim L_FAQ_WHYDOES_THECONVERSION_TEXT
	Dim L_FAQ_WHYDOIGET_AMESSAGEBOX_TEXT
	Dim L_FAQ_ONTHEREPORT_STATUS_TEXT
	Dim L_FAQ_ONTHEREPORT_TYPECOLUMN_TEXT
	Dim L_FAQ_TOP_LINK_TEXT
	Dim L_FAQ_WHATSHOULD_IDETAILS_TEXT
	Dim L_FAQ_WHOCAN_IDETAILS_TEXT
	Dim L_FAQ_WHYDIDTHE_STATUSCHANGE_TEXT
	
	Dim L_FAQINFORMATION_TEXT
	Dim L_FAQ_HOWDOICONFIGURE_DETAILSONE_TEXT
	Dim L_FAQ_HOWDOICONFIGURE_DETAILSTWO_TEXT
	Dim L_FAQ_HOWDOICONFIGURE_DETAILSTHREE_TEXT
	Dim L_FAQ_HOWDOICONFIGURE_DETAILSFOUR_TEXT
	Dim L_FAQ_HOWDOICONFIGURE_DETAILSFIVE_TEXT
	Dim L_FAQ_HOWDOICONFIGURE_DETAILSSIX_TEXT
	Dim L_FAQ_HOWDOICONFIGURE_DETAILSSEVEN_TEXT
	Dim L_FAQ_HOWDOICONFIGURE_DETAILXPSONE_TEXT
	Dim L_FAQ_HOWDOICONFIGURE_DETAILXPSTWO_TEXT
	Dim L_FAQ_WHYWASTHESITE_DETAILSONE_TEXT
	Dim L_FAQ_WHYWASTHESITE_DETAILSTWO_TEXT
	Dim L_FAQ_WHYWASTHESITE_DETAILSTHREE_TEXT
	Dim L_FAQ_WHYWASTHESITE_DETAILSFOUR_TEXT
	Dim L_FAQ_WHYWASTHESITE_DETAILSFIVE_TEXT
	Dim L_FAQ_WHYWASTHESITE_DETAILSSIX_TEXT
	Dim L_FAQ_WHYWASTHESITE_DETAILSSEVEN_TEXT
	Dim L_FAQ_WHYDOIGETA_DETAILSONE_TEXT
	Dim L_FAQ_WHYDOIGETA_DETAILSTWO_TEXT
	Dim L_FAQ_WHYDOIGETA_DETAILSTHREE_TEXT
	Dim L_FAQ_WHYDOIGETA_DETAILSFOUR_TEXT
	Dim L_FAQ_WHYDOIGETA_DETAILSFIVE_TEXT
	Dim L_FAQ_WHATIFICANTWAIT_DETAILS_TEXT
	Dim L_FAQ_WHYDOESTHECONVERSION_DETAILSONE_TEXT 
	Dim L_FAQ_WHYDOESTHECONVERSION_DETAILSTWO_TEXT 
	Dim L_FAQ_WHYDOESTHECONVERSION_DETAILSTHREE_TEXT
	Dim L_FAQ_WHYDOESTHECONVERSION_DETAILSFOUR_TEXT 
	Dim L_FAQ_WHYDOESTHECONVERSION_DETAILSFIVE_TEXT 
	Dim L_FAQ_WHYDOESTHECONVERSION_DETAILSSIX_TEXT 
	Dim L_FAQ_WHYDOESTHECONVERSION_DETAILSSEVEN_TEXT
	Dim L_FAQ_WHYDOESTHECONVERSION_DETAILSEIGHT_TEXT
	Dim L_FAQ_WHYDOESTHECONVERSION_DETAILSNINE_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSONE_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSTWO_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSTHREE_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSFOUR_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSFIVE_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSSIX_TEXT 
	Dim L_FAQ_ONTHEREPORTSTATUS_DETAILS_TEXT
	Dim L_FAQ_ONTHEREPORTTYPE_COLUMNDETAILS_TEXT
	Dim L_FAQ_HOWDOICONFIGURE_FULLDUMP_TEXT
	Dim L_FAQ_HOWDOICONFIGURE_DETAILSFULLDUMPONE_TEXT
	Dim L_FAQ_HOWDOICONFIGURE_DETAILSFULLDUMPTWO_TEXT
	Dim L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPTHREE_TEXT
	Dim L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPFOUR_TEXT
	Dim L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPFIVE_TEXT
	Dim L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPSIX_TEXT
	Dim L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPSEVEN_TEXT
	Dim L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPEIGTH_TEXT
	Dim L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPNINE_TEXT
	Dim L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPXPONE_TEXT
	Dim L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPXPTWO_TEXT
	Dim L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPXPTHREE_TEXT
	Dim L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPXPFOUR_TEXT
	Dim L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPXPFIVE_TEXT
	Dim L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPXPSIX_TEXT
	Dim L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPXPSEVEN_TEXT
	Dim L_FAQ_ONTHEREPORT_REQUIREMENTS_TEXT
	Dim L_FAQ_RECORDING_FULLDUMP_TEXT
	Dim L_FAQ_64BIT_DUMPFILE_TEXT
	Dim L_FAQ_64BIT_DUMPFILEBODY_TEXT
	Dim L_FAQ_FREQUENTLY_ASKEDQUESTIONS_TEXT
	Dim L_PRIVACY_PARA_ONE_TEXT 
	Dim L_PRIVACY_PARA_TWO_TEXT 
	Dim L_PRIVACY_PARA_TWOA_TEXT
	Dim L_PRIVACY_PARA_THREE_TEXT
	Dim L_WELCOME_PASSPORT_LINK_TEXT
	Dim L_WELCOME_INTERNET_EXPLORER_TEXT 
	Dim L_WELCOME_REQUIREMENTS_INFO_TEXT 
	Dim L_WELCOME_REQUIREMENTSINFO_TWO_TEXT 
	Dim L_WELCOME_REQUIREMENTS_PASSPORT_TEXT
	Dim L_FAQ_MICROSOFT_LINK_TEXT
	Dim L_FAQ_PASSPORT_LINK_TEXT
	Dim L_FAQ_HOWDOI_DELETECOOKIES_TEXT
	Dim L_FAQ_HOWDOIDELETECOOKIES_BODY_TEXT
	Dim L_FAQ_HOWDOIDELETECOOKIES_W2K1_TEXT
	Dim L_FAQ_HOWDOIDELETECOOKIES_W2K2_TEXT
	Dim L_FAQ_HOWDOIDELETECOOKIES_W2K3_TEXT
	Dim L_FAQ_HOWDOIDELETECOOKIES_W2K4_TEXT
	Dim L_FAQ_HOWDOIDELETECOOKIES_XP1_TEXT
	Dim L_FAQ_HOWDOIDELETECOOKIES_XP2_TEXT
	Dim L_FAQ_HOWDOIDELETECOOKIES_XP3_TEXT
	Dim L_FAQ_HOWDOIDELETECOOKIES_XP4_TEXT
	Dim L_FAQ_WHYDIDTHESTATUS_CHANGEBODY_TEXT

	'-------------------------faq.asp Page Strings-------------------------
	L_FAQ_HOWDOI_DELETECOOKIES_TEXT = "Why can't I sign-in to Passport?"
	L_FAQ_HOWDOIDELETECOOKIES_BODY_TEXT = "Windows Online Crash Analysis has integrated Platform for Privacy Preferences (P3P) to provide further security for our services. As a result, cookies are no longer stored on your computer the same way. If you have visited this site before, these cookies may be out of date, and you will be unable to sign in until you delete these cookies."
	L_FAQ_HOWDOIDELETECOOKIES_W2K1_TEXT = "To delete cookies for Windows 2000:"
	L_FAQ_HOWDOIDELETECOOKIES_W2K2_TEXT = "1. In Internet Explorer, from the Tools menu, select Internet Options."
	L_FAQ_HOWDOIDELETECOOKIES_W2K3_TEXT = "2. On the General tab, under Temporary Internet Files, click Delete Files."
	L_FAQ_HOWDOIDELETECOOKIES_W2K4_TEXT = "3. In the Delete Files dialog box, click OK."
	L_FAQ_HOWDOIDELETECOOKIES_W2K5_TEXT = "4. In the Internet Options dialog box, click OK."
	L_FAQ_HOWDOIDELETECOOKIES_XP1_TEXT = "To delete cookies for Windows XP Professional and Windows Server 2003 - Standard Edition:"
	L_FAQ_HOWDOIDELETECOOKIES_XP2_TEXT = "1. In Internet Explorer, from the Tools menu, select Internet Options."
	L_FAQ_HOWDOIDELETECOOKIES_XP3_TEXT = "2. On the General tab, under Temporary Internet Files, click Delete Cookies."
	L_FAQ_HOWDOIDELETECOOKIES_XP4_TEXT = "3. In the Delete Cookies dialog box, click OK."
	L_FAQINFORMATION_TEXT = "information"
	L_FAQ_WHATSHOULD_IDETAILS_TEXT = "Microsoft actively analyzes all error reports and prioritizes them based on the number of customers affected by the Stop error covered in the error report. We will try to determine the cause of the Stop error you submit, categorize it according to the type of issue encountered, and send you relevent information when such information is identified. You can check the status of your error report at any time. However, because error reports do not always contain enough information to positively identify the source of the issue, we might need to collect a number of similar error reports from other customers before a pattern is discovered, or follow up with you further to gather additional information. Furthermore, some error reports might require additional resources (such as a hardware debugger or a live debugger session)  before a solution can be found. Although we might not be able to provide a solution for your particular Stop error, all information submitted is used to further improve the quality and reliability of Windows."
	L_FAQ_WHOCAN_IDETAILS_TEXT = "Send questions and comments to"
	L_FAQ_HOWDOICONFIGURE_DETAILSONE_TEXT = "To configure Windows 2000 to generate an error report in small memory dump file format:"
	L_FAQ_HOWDOICONFIGURE_DETAILSTWO_TEXT = "1. In Control Panel, double-click System."
	L_FAQ_HOWDOICONFIGURE_DETAILSTHREE_TEXT = "2. On the Advanced tab, click Startup and Recovery."
	L_FAQ_HOWDOICONFIGURE_DETAILSFOUR_TEXT = "3. Under Write Debugging Information, in the drop-down box, select Small Memory Dump (64 KB), and then click OK."
	L_FAQ_HOWDOICONFIGURE_DETAILSFIVE_TEXT = "4. In the dialog box that appears, click OK."
	L_FAQ_HOWDOICONFIGURE_DETAILSSIX_TEXT = "5. In the System Properties dialog box, click OK."
	L_FAQ_HOWDOICONFIGURE_DETAILSSEVEN_TEXT = "6. In the System Settings Change dialog box, click Yes if you want to restart your computer immediately. Click No if you want to restart it later."
	L_FAQ_HOWDOICONFIGURE_DETAILXPSONE_TEXT = "To configure Windows XP or Windows Server 2003 - Standard Edition to generate an error report in small memory dump file format:"
	L_FAQ_HOWDOICONFIGURE_DETAILXPSTWO_TEXT = "4. Under Write Debugging Information, select Small Memory Dump, and then click OK."
	
	L_FAQ_HOWDOICONFIGURE_FULLDUMP_TEXT = "How do I configure my computer to generate an error report in complete memory dump file format when a Stop error occurs?"
	L_FAQ_HOWDOICONFIGURE_DETAILSFULLDUMPONE_TEXT = "A complete memory dump might contain customer-specific information, such as data from open files. This information, if present in a complete memory dump, will not be used. Complete memory dumps are stored on a secure Microsoft server where only those individuals involved in Stop error analysis can gain access to them. The information is retained only as long as it is useful for researching possible causes of the Stop error. "
	L_FAQ_HOWDOICONFIGURE_DETAILSFULLDUMPTWO_TEXT = "Your computer might already be configured to record complete memory dumps. To locate complete memory dump files, search for files named Memory.dmp. If you cannot locate any complete memory dump files, you can configure your computer to record them for future use."
	L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPTHREE_TEXT = ""
	L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPFOUR_TEXT = "1. In Control Panel, double-click System."
	L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPFIVE_TEXT = "2. On the Advanced tab, click Startup and Recovery. For Windows Server 2003 - Standard Edition, on the Advanced tab, in the Startup and Recovery group box, click Settings."
	L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPSIX_TEXT = "3. Under Write Debugging Information, select Complete memory dump, and then click OK."
	L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPSEVEN_TEXT = "4. In the dialog box that appears, click OK."
	L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPEIGTH_TEXT = "5. In the System Properties dialog box, click OK."
	L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPNINE_TEXT = "6. In the System Settings Change dialog box, click Yes if you want to restart your computer immediately. Click No if you want to restart it later."
	L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPXPONE_TEXT = "To configure Windows XP Professional to generate an error report in complete memory dump file format:"
	L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPXPTWO_TEXT = "1. In Control Panel, click Performance and Maintenance."
	L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPXPTHREE_TEXT = "2. Under Performance and Maintenance, click System."
	L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPXPFOUR_TEXT = "3. On the Advanced tab, in the Startup and Recovery group box, click Settings."
	L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPXPFIVE_TEXT = "4. Under Write Debugging Information, select Complete memory dump, and then click OK."
	L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPXPSIX_TEXT = "Note that when your computer is configured for a complete memory dump, a small memory dump file will also be generated. If you submit an error report to Microsoft, only the small memory dump file will be sent."
	L_FAQ_HOWDOICONFIGUREDETAILS_FULLDUMPXPSEVEN_TEXT = "5. In the System Properties dialog box, click OK."
	
	
	
	L_FAQ_WHYWASTHESITE_DETAILSONE_TEXT = "Windows Online Crash Analysis might be unable to automatically locate an error report on your computer for several reasons.  For example:"
	L_FAQ_WHYWASTHESITE_DETAILSTWO_TEXT = "Your system is not configured to generate an error report in small or complete memory dump file format."
	L_FAQ_WHYWASTHESITE_DETAILSTHREE_TEXT = "There is not a page file, or a page file that is large enough, set up on your system drive."
	L_FAQ_WHYWASTHESITE_DETAILSFOUR_TEXT = "There is not a valid file on the system."
	L_FAQ_WHYWASTHESITE_DETAILSFIVE_TEXT = "There is not enough room to generate an error report on the system drive (usually drive C)."
	L_FAQ_WHYWASTHESITE_DETAILSSIX_TEXT = "The hard disk controller or hard disk driver was the cause of the Stop error."
	L_FAQ_WHYWASTHESITE_DETAILSSEVEN_TEXT = "The hard disk controller does not allow the creation of a Stop error."
	L_FAQ_WHYDOIGETA_DETAILSONE_TEXT = "If the Internet security options for Internet Explorer are set to High or Custom, Passport cannot verify the necessary information on your computer. For Passport to work properly, reset the Internet security options."
	L_FAQ_WHYDOIGETA_DETAILSTWO_TEXT = "To reset the options:"
	L_FAQ_WHYDOIGETA_DETAILSTHREE_TEXT = "1. In the Tools menu, select Internet Options."
	L_FAQ_WHYDOIGETA_DETAILSFOUR_TEXT = "2. On the Security tab, set the security level to Medium or lower, and then click OK."
	L_FAQ_WHYDOIGETA_DETAILSFIVE_TEXT = "For additional information, see the "
	L_FAQ_WHATIFICANTWAIT_DETAILS_TEXT = "If you cannot wait for analysis results or if there is no solution currently available for your Stop error, for additional assistance see Product Support Services on the "
	
	L_FAQ_WHYDOESTHECONVERSION_DETAILSONE_TEXT = "The conversion process for a complete memory dump might not be successful because:"
	L_FAQ_WHYDOESTHECONVERSION_DETAILSTWO_TEXT = "You are using Windows NT 4.0 or a pre-release version of Windows 2000."
	L_FAQ_WHYDOESTHECONVERSION_DETAILSTHREE_TEXT = "The creation of the complete memory dump was not completed correctly or the memory dump itself is corrupt."
	L_FAQ_WHYDOESTHECONVERSION_DETAILSFOUR_TEXT = "There is not enough room for the converted file on your system drive (usually drive C)."
	L_FAQ_WHYDOESTHECONVERSION_DETAILSFIVE_TEXT = "The SCSI controller was the cause of the Stop error."
	L_FAQ_WHYDOESTHECONVERSION_DETAILSSIX_TEXT = "The hard disk controller was unable to create the complete memory dump."
	L_FAQ_WHYDOESTHECONVERSION_DETAILSSEVEN_TEXT = "The hard disk controller does not allow the creation of the complete memory dump."
	L_FAQ_WHYDOESTHECONVERSION_DETAILSEIGHT_TEXT = "The system is set to load the PAE kernel and is configured to create a kernel memory dump."
	L_FAQ_WHYDOESTHECONVERSION_DETAILSNINE_TEXT = "DUMPCONV.EXE was not found.  Refresh the page to reinstall."
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSONE_TEXT = "The installation of the ActiveX control might fail because:"
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSTWO_TEXT = "1. You do not have Administrator rights on the Windows NT 4.0, Windows 2000, or Microsoft Windows XP Professional or Windows Server 2003 - Standard Edition system you are using."
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSTHREE_TEXT = "2. Your Internet security options for Internet Explorer are set to High or Custom."
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSFOUR_TEXT = "To reset the options:"
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSFIVE_TEXT = "1. In the Tools menu, select Internet Options."
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSSIX_TEXT = "2. On the Security tab, set the security level to Medium or lower, and then click OK."
	L_FAQ_FREQUENTLY_ASKEDQUESTIONS_TEXT = "Frequently Asked Questions"
	L_FAQ_ONTHEREPORTSTATUS_DETAILS_TEXT = "By clicking the icon in the Details column of the Report Status page, you can view specific technical information about the state of your operating system when the Stop error occurred."
	L_FAQ_ONTHEREPORTTYPE_COLUMNDETAILS_TEXT = "The number in the Type column identifies how we have classified the Stop error. If you submit an online support request to Product Support Services on the Microsoft Web site, include this number as well as the information from the Details page. This information might be useful to the engineer that researches your support request."
	L_FAQ_TOP_LINK_TEXT = "Top"
	L_FAQ_WHAT_SHOULDI_TEXT = "What should I expect from the analysis?"
	L_FAQ_WHO_CANI_TEXT = "Who can I contact with questions?"
	L_FAQ_WHAT_KINDOF_TEXT = "What kind of information does an error report contain?"
	L_FAQ_HOWDOI_CONFIGURE_TEXT = "How do I configure my computer to generate an error report in small memory dump file format when a Stop error occurs?"
	L_FAQ_WHYWAS_THESITE_TEXT = "Why was Windows Online Crash Analysis unable to locate my error report?" 
	L_FAQ_WHYDO_IGETA_TEXT = "Why do I get a Passport error while using the site?"
	L_FAQ_WHATIF_ICANTWAIT_TEXT = "What if I can't wait for the analysis?"
	L_FAQ_WHATIF_CANNOTPROCESS_TEXT = "Why was my error report unable to be processed?"
	L_FAQ_WHATIF_CANNOTPROCESSBODY_TEXT = "There are a number of reasons that the Windows Online Crash Analysis Web site may not be able to recognize your error report. "
	L_FAQ_WHATIF_CANNOTPROCESSBODY1_TEXT = "Our service was unable to retrieve debug symbols for your error report.  This case is usually seen when running a pre-release version of the operating system."
	L_FAQ_WHATIF_CANNOTPROCESSBODY2_TEXT = "The error report was corrupted while it was being created and is unreadable by our Web site."
	L_FAQ_WHATIF_CANNOTPROCESSBODY3_TEXT = "The contents of the dump file were corrupted while trying to upload or analyze the file."
	L_FAQ_WHATIF_CANNOTPROCESSBODY4_TEXT = "There was a problem while trying to update our database."
	L_FAQ_WHYDOES_THECONVERSION_TEXT = "Why is the conversion process not successful when I try to submit a complete memory dump?"
	L_FAQ_WHYDOIGET_AMESSAGEBOX_TEXT = "Why do I get a message that the ActiveX control was not installed?"
	L_FAQ_ONTHEREPORT_STATUS_TEXT = "On the Report Status page, what does the Details link mean?"
	L_FAQ_ONTHEREPORT_TYPECOLUMN_TEXT = "On the Report Status page, what does the number in the Type column mean?"
	L_FAQ_ONTHEREPORT_REQUIREMENTS_TEXT = "What is required to access the Windows Online Crash Analysis Web site?" 
	L_FAQ_RECORDING_FULLDUMP_TEXT = "To configure Microsoft Windows 2000 to generate an error report in complete memory dump file format:"
	L_FAQ_64BIT_DUMPFILE_TEXT = "What if my error report is a 64-bit file?"
	L_FAQ_64BIT_DUMPFILEBODY_TEXT = "Windows Online Crash Analysis cannot currently process 64-bit error report files. However, you can still upload the file and it will be analyzed when 64-bit file processing is available. If you provide contact information for the error report, you can track the status of the report, and the Windows Online Crash Analysis team might be able to provide solutions for your Stop error.  Solutions are sent by e-mail when available."
	
	
	
	L_PRIVACY_PARA_ONE_TEXT = "Before submitting your error report, review this privacy information. Error reports contain "
	L_PRIVACY_PARA_TWO_TEXT = "about what your operating system was doing when the Stop error occurred. This information will be analyzed to determine possible causes of the Stop error; it will not be used for any other purpose. If any customer-specific information, such as your computer's IP address, is present in the error report, it will not be used. Your error report is still anonymous at this time. If you choose, you can review the contents of your error report before submission."
	L_PRIVACY_PARA_TWOA_TEXT = "You can automatically locate error reports on your computer by using an ActiveX<sup>&#174;</sup> control on this site. These error reports are displayed in a list, and you decide which ones to upload. Once uploaded, error reports are stored on a secure Microsoft server where only those individuals involved in Stop error analysis can gain access to them. The information is kept only as long as it is useful for research and analysis. As necessary, Microsoft shares error report analyses with qualified hardware and software partners for assistance."
	L_PRIVACY_PARA_THREE_TEXT = "Depending on your computer settings, we might need to extract an error report, or small memory dump, from a complete memory dump.  This small memory dump is saved as a 64 KB file, named mini000000-00.dmp, in a temporary folder on your computer. A copy is then transferred to us by using Secure Sockets Layer (SSL) encryption.  You can delete this file from your computer at any time after submission."
	L_WELCOME_PASSPORT_LINK_TEXT = "Microsoft Passport Web site." 
	L_WELCOME_INTERNET_EXPLORER_TEXT = "Microsoft Web site."
	L_WELCOME_REQUIREMENTS_INFO_TEXT = "To submit an error report, you must be using Windows NT 4.0, Windows 2000, or Windows XP. Windows Online Crash Analysis requires Microsoft Internet Explorer 5 or later and a Microsoft Passport. To download the latest version of Internet Explorer, visit the "
	L_WELCOME_REQUIREMENTSINFO_TWO_TEXT = "To get a Passport, visit the&nbsp;"
	L_WELCOME_REQUIREMENTS_PASSPORT_TEXT = "For Windows 2000 error reports, a Premier account is required. For more information about Premier accounts, see Product Support Services on the "
	L_FAQ_MICROSOFT_LINK_TEXT = "http://www.microsoft.com"
	L_FAQ_PASSPORT_LINK_TEXT = "http://www.passport.com"

	L_FAQ_WHYDIDTHE_STATUSCHANGE_TEXT = "Why has my analysis status changed?"
	L_FAQ_WHYDIDTHESTATUS_CHANGEBODY_TEXT = "As we make improvements to our analysis tools and debugging processes, Windows Online Crash Analysis will periodically re-analyze (and possibly reclassify) error reports. This is done to provide information that will better help us troubleshoot and fix previously encountered Stop errors."
	'-----------------------------------------------------------------------------------------



%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\customerstrings.inc ===
<%
	Dim L_CUSTOMER_PASSPORT_TITLE_TEXT
	Dim L_CUSTOMER_PASSPORT_INFO_TEXT 
	Dim L_CUSTOMER_PASSPORT_SIGNIN_TEXT
	Dim L_CUSTOMER_IN_FORMATION_TEXT
	Dim L_CUSTOMER_CON_TACT_TEXT
	Dim L_CUSTOMER_NAME_INFO_EDITBOX
	Dim L_CUSTOMER_E_MAIL_EDITBOX
	Dim L_CUSTOMER_PH_ONE_EDITBOX
	Dim L_CUSTOMER_LO_CATE_TEXT
	Dim L_CUSTOMER_LOCATE_INFO_TEXT
	Dim L_CUSTOMER_NEXT_LINK_TEXT
	Dim L_CUSTOMER_SUBMIT_LINK_TEXT
	Dim L_CUSTOMER_SUBMIT_INFO_TEXT
	Dim L_CUSTOMER_NO_EMAIL_ERRORMESSAGE
	Dim L_CUSTOMER_NO_PHONE_ERRORMESSAGE
	Dim L_CUSTOMER_CONTACT_INFORMATION_TEXT

	Dim L_WELCOME_PASSPORT_LINK_TEXT
	Dim L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE
	Dim L_COMMENTS_CONNECTION_FAILED_TEXT
	Dim L_LOCATE_CANCEL_LINK_TEXT
	Dim L_LOCATE_PREVIOUS_LINK_TEXT
	Dim L_FAQ_PASSPORT_LINK_TEXT
	Dim L_CUSTOMER_QUOTE_INSTRING_ERRORMESSAGE


	'-------------------------customer.asp Page Strings-------------------------
	L_LOCATE_PREVIOUS_LINK_TEXT = "Previous"
	L_CUSTOMER_PASSPORT_TITLE_TEXT = "Passport sign-in"
	L_CUSTOMER_PASSPORT_INFO_TEXT = "To submit an error report, sign in using your Microsoft Passport. To get a Passport, visit the "
	L_CUSTOMER_PASSPORT_SIGNIN_TEXT = "Web site."
	L_CUSTOMER_IN_FORMATION_TEXT = "Contact information"
	L_CUSTOMER_CON_TACT_TEXT = "Type the contact information we should use to send you questions, analysis results, and any solutions we discover. If you choose not to submit contact information, we cannot send you the results of your error report analysis."  
	L_CUSTOMER_NAME_INFO_EDITBOX = "Name:"
	L_CUSTOMER_E_MAIL_EDITBOX = "E-mail address:"
	L_CUSTOMER_PH_ONE_EDITBOX = "Telephone number:"
	L_CUSTOMER_LO_CATE_TEXT = "Locate error reports"
	L_CUSTOMER_LOCATE_INFO_TEXT = "You can submit error reports by uploading them to this site. No other information is uploaded. To locate the error reports on your computer, click Continue."
	L_CUSTOMER_NEXT_LINK_TEXT = "Continue"
	L_CUSTOMER_SUBMIT_LINK_TEXT = "Enter user information"
	L_CUSTOMER_SUBMIT_INFO_TEXT = "The next step is to enter user information on the submit page"
	L_CUSTOMER_NO_EMAIL_ERRORMESSAGE = "Please enter a valid E-mail address."
	L_CUSTOMER_NO_PHONE_ERRORMESSAGE = "Please enter a valid Phone number, or leave the entry blank"
	L_CUSTOMER_CONTACT_INFORMATION_TEXT = "Contact information (optional):"
	
	L_WELCOME_PASSPORT_LINK_TEXT = "Microsoft Passport Web site." 
	L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE = "Database is not available"
	L_COMMENTS_CONNECTION_FAILED_TEXT = "Windows Online Crash Analysis was unable to connect to the database. Please try this task again." 
	L_LOCATE_CANCEL_LINK_TEXT = "Cancel"
	L_FAQ_PASSPORT_LINK_TEXT = "http://www.passport.com"
	L_CUSTOMER_QUOTE_INSTRING_ERRORMESSAGE = "Quotes are not allowed in this field."
	
	
	
	'-------------------------End-------------------------
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\crashstrings.inc ===
<%
	
	Dim L_CRASH_TITLE_MSG_TEXT
	Dim L_CRASH_TITLE_INFO_TEXT
	Dim L_CRASH_TITLE_SUBTITLE_TEXT
	Dim L_CRASH_BULLET_ONE_TEXT
	Dim L_CRASH_BULLET_TWO_TEXT
	Dim L_CRASH_BULLET_THREE_TEXT
	Dim L_CRASH_BULLET_FOUR_TEXT
	Dim L_CRASH_BULLET_FIVE_TEXT
	Dim L_CRASH_BULLET_SIX_TEXT
	Dim L_CRASH_BULLET_SEVEN_TEXT
	Dim L_CRASH_BULLET_EIGHT_TEXT
	Dim L_CRASH_BULLET_NINE_TEXT
	Dim L_CRASH_BULLET_TEN_TEXT
	Dim L_CRASH_FOOTER_LINK_TEXT
	Dim L_CRASH_MS_DN_TEXT
	Dim L_CRASH_PRIVACY_BUTTON_TEXT
	Dim L_CRASH_WHISTLER_SUBTITLE_TEXT
	Dim L_CRASH_WHISTLERBULLET_ONE_TEXT
	Dim L_CRASH_WHISTLERBULLET_TWO_TEXT
	Dim L_CRASH_WHISTLERBULLET_THREE_TEXT
	Dim L_CRASH_WHISTLERBULLET_FOUR_TEXT
	Dim L_CRASH_WHISTLERBULLET_FIVE_TEXT
	Dim L_CRASH_WHISTLERBULLET_SIX_TEXT
	Dim L_CRASH_WHISTLERBULLET_SEVEN_TEXT
	Dim L_CRASH_WHISTLERBULLET_EIGHT_TEXT
	Dim L_CRASH_WHISTLERBULLET_NINE_TEXT
	Dim L_CRASH_WHISTLERBULLET_TEN_TEXT
	Dim L_CRASH_WHISTLERSUBBULLET_ONE_TEXT
	Dim L_CRASH_WHISTLERSUBBULLET_TWO_TEXT
	Dim L_CRASH_WHISTLERSUBBULLET_THREE_TEXT
	Dim L_CRASH_WHISTLERSUBBULLET_FOUR_TEXT
	Dim L_CRASH_WHISTLERSUBBULLET_FIVE_TEXT
	Dim L_PRIVACY_CONTINUE_BUTTON_TEXT
	Dim L_CUSTOMER_NEXT_LINK_TEXT
	Dim L_CRASH_MSDN_LINK_TEXT
	

	'-------------------------crashinfo.asp Page Strings-------------------------
	
	
	
	L_CUSTOMER_NEXT_LINK_TEXT = "Continue"
	L_CRASH_PRIVACY_BUTTON_TEXT = "Home"
	L_CRASH_BULLET_ONE_TEXT = "Operating system version, including any system updates."
	L_CRASH_BULLET_TWO_TEXT = "Number of available processors."
	L_CRASH_BULLET_THREE_TEXT = "Amount of random access memory (RAM)."
	L_CRASH_BULLET_FOUR_TEXT = "Time stamp that indicates when the Stop error occurred."
	L_CRASH_BULLET_FIVE_TEXT = "Stop code or bug check messages and parameters that describe the Stop error."
	L_CRASH_BULLET_SIX_TEXT = "Loaded and recently unloaded drivers.  This identifies the modules used by the kernel when the Stop error occurred and those that were used recently."
	L_CRASH_BULLET_SEVEN_TEXT = "Processor context for the process that stopped. This includes the processor, hardware state, performance counters, multiprocessor packet information, deferred procedure call information, and interrupts (requests from software or devices for processor attention)."
	L_CRASH_BULLET_EIGHT_TEXT = "Process information and kernel context for the halted process. This includes the offset (location) of the directory table and the page frame number database that maintains the information about every physical page (block of memory) in the operating system."
	L_CRASH_BULLET_NINE_TEXT = "Process information and kernel context for the thread that stopped. This identifies registers (data-storage blocks of memory in the processor), interrupt request levels, and includes pointers to operating system data structures."
	L_CRASH_BULLET_TEN_TEXT = "Kernel-mode call stack for the interrupted thread.  This is a data structure that consists of a series of memory locations and includes a pointer to the initial location."
	L_CRASH_FOOTER_LINK_TEXT = "For the exact specifications of Stop error reports (in small memory dump file format), see the "
	L_CRASH_MS_DN_TEXT =  "Microsoft Developers Network Online Web site."
	L_CRASH_TITLE_MSG_TEXT = "Error report information"
	L_CRASH_TITLE_INFO_TEXT = "Each error report contains the minimum information needed to help identify the cause of the Stop error. "
	L_CRASH_TITLE_SUBTITLE_TEXT = "An error report identifies the following items: "
	L_CRASH_WHISTLER_SUBTITLE_TEXT = "For Microsoft Windows XP submissions the following information is also collected:"
	L_CRASH_WHISTLERBULLET_ONE_TEXT = "The operating system (OS) name (for example, Windows XP Professional)."
	L_CRASH_WHISTLERBULLET_TWO_TEXT = "The OS version (for example, 5.1.2426.0.0)."
	L_CRASH_WHISTLERBULLET_THREE_TEXT = "The OS language as represented by the locale identifier (LCID) (for example, 1033 for U.S. English). This is a standard international numeric abbreviation."
	L_CRASH_WHISTLERBULLET_FOUR_TEXT = "The list of drivers in the Drivers folder on your hard disk. The folder is usually located at C:\winnt\system32\drivers. "
	L_CRASH_WHISTLERBULLET_FIVE_TEXT = ""
	L_CRASH_WHISTLERBULLET_SIX_TEXT = ""
	L_CRASH_WHISTLERBULLET_SEVEN_TEXT = ""
	L_CRASH_WHISTLERBULLET_EIGHT_TEXT = ""
	L_CRASH_WHISTLERBULLET_NINE_TEXT = ""
	L_CRASH_WHISTLERBULLET_TEN_TEXT = "For each driver:"
	L_CRASH_WHISTLERSUBBULLET_ONE_TEXT = "File size"
	L_CRASH_WHISTLERSUBBULLET_TWO_TEXT = "Date created"
	L_CRASH_WHISTLERSUBBULLET_THREE_TEXT = "Version"
	L_CRASH_WHISTLERSUBBULLET_FOUR_TEXT = "Manufacturer"
	L_CRASH_WHISTLERSUBBULLET_FIVE_TEXT = "Full product name"
	L_PRIVACY_CONTINUE_BUTTON_TEXT = "Privacy information"
	L_CRASH_MSDN_LINK_TEXT = "http://msdn.microsoft.com/"
	'-------------------------End-------------------------

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\pcwstrings.inc ===
<%

Dim L_STATE_TITLE_INFO_TEXT
Dim L_STATE_PARAGRAPHONE_PARTONE_TEXT
Dim L_STATE_SUB_TITLE_TEXT
Dim L_STATE_PARAGRAPH_TWO_TEXT
Dim L_STATE_LINK_NAME_TEXT
Dim L_STATE_LINK_URL_TEXT
Dim L_CORPWELCOME_INTRO_BODY2PERIOD_TEXT

'-------------------------PCW.asp Page Strings-------------------------
L_STATE_TITLE_INFO_TEXT = "Program Compatibility Report"
L_STATE_PARAGRAPHONE_PARTONE_TEXT = "Thank you for submitting your compatibility report. Compatibility reports are generated by the Program Compatibility Wizard in the Windows XP Help and Support Center. By choosing to send this information to Microsoft you are helping to make Windows XP even better &#150; today and in the future."
L_STATE_SUB_TITLE_TEXT = "Why is this information important?"
L_STATE_PARAGRAPH_TWO_TEXT = "Microsoft uses this compatibility information to identify issues that some programs may have when running on Windows XP. This information is reviewed by the Windows Application Compatibility team so that wherever possible a resolution can be found. When compatibility fixes are made, they will be made available to all Windows XP users. For more information about the Windows Application Compatibility team and the tools and resources they provide, see the"
L_STATE_LINK_NAME_TEXT = "Application Compatibility Web site"
L_STATE_LINK_URL_TEXT = "http://msdn.microsoft.com/compatibility"
L_CORPWELCOME_INTRO_BODY2PERIOD_TEXT = "."
'---------------------------------------------------------------------------

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\privacystrings.inc ===
<%

	Dim L_PRIVACY_TITLE_INFO_TEXT
	Dim L_PRIVACY_PARA_ONE_TEXT
	Dim L_PRIVACY_PARA_TWO_TEXT
	Dim L_PRIVACY_PARA_TWOA_TEXT
	Dim L_PRIVACY_PARA_THREE_TEXT
	Dim L_PRIVACY_CONTINUE_BUTTON_TEXT
	Dim L_PRIVACY_CRASH_BUTTON_TOOLTIP
	Dim L_PRIVACY_CRASH_BUTTON_TEXT
	Dim L_PRIVACY_BACK_BUTTON_TEXT
	Dim L_PRIVACY_BACKBUTTON_TITLE_TOOLTIP
	Dim L_PRIVACY_MD5_HASH_TEXT
	Dim L_SPRIVACY_MD5_HASH_TEXT
	Dim L_SPRIVACY_MD5_EMAILONE_TEXT
	Dim L_SPRIVACY_MD5_EMAILTWO_TEXT
	Dim L_FAQINFORMATION_TEXT
	Dim L_PRIVACY_MD5_EMAIL_TEXT
	Dim L_LOCATE_CANCEL_LINK_TEXT
	Dim L_CUSTOMER_NEXT_LINK_TEXT
	
	'-------------------------privacy.asp Page Strings-------------------------
	L_PRIVACY_BACK_BUTTON_TEXT = "Back"
	L_PRIVACY_BACKBUTTON_TITLE_TOOLTIP = "Return to the previous page"
	L_PRIVACY_CRASH_BUTTON_TEXT = "Error report information"
	L_PRIVACY_CRASH_BUTTON_TOOLTIP = "View information contained within an error report."
	L_PRIVACY_CONTINUE_BUTTON_TEXT = "Privacy information"
	L_PRIVACY_TITLE_INFO_TEXT = "Privacy information"
	L_PRIVACY_PARA_ONE_TEXT = "Before submitting your error report, review this privacy information. Error reports contain "
	L_PRIVACY_PARA_TWO_TEXT = "about what your operating system was doing when the Stop error occurred. This information will be analyzed to determine possible causes of the Stop error; it will not be used for any other purpose. If any customer-specific information, such as your computer's IP address, is present in the error report, it will not be used. Your error report is still anonymous at this time. If you choose, you can review the contents of your error report before submission."
	L_PRIVACY_PARA_TWOA_TEXT = "You can automatically locate error reports on your computer by using an ActiveX<sup>&#174;</sup> control on this site. These error reports are displayed in a list, and you decide which ones to upload. Once uploaded, error reports are stored on a secure Microsoft server where only those individuals involved in Stop error analysis can gain access to them. The information is kept only as long as it is useful for research and analysis. As necessary, Microsoft shares error report analyses with qualified hardware and software partners for assistance."
	L_PRIVACY_PARA_THREE_TEXT = "Depending on your computer settings, we might need to extract an error report, or small memory dump, from a complete memory dump.  This small memory dump is saved as a 64 KB file, named mini000000-00.dmp, in a temporary folder on your computer. A copy is then transferred to us by using Secure Sockets Layer (SSL) encryption.  You can delete this file from your computer at any time after submission."
	L_PRIVACY_MD5_HASH_TEXT = "Each error report is uniquely identified with a Message Digest 5 (MD5) hashing algorithm (commonly known as a &quot;fingerprint&quot;). This is done to keep duplicate error reports from being submitted. If an MD5 encryption key is not already present on your computer, we will generate one for you that will be installed on your computer. This encryption key is commonly used  to help secure data sent over the Internet and will not affect any other data."
	L_SPRIVACY_MD5_HASH_TEXT = "Once uploaded, error reports are stored on a secure Microsoft server where only those individuals involved in Stop error analysis can gain access to them. The information is kept only as long as it is useful in researching and analyzing Stop errors. As necessary, Microsoft shares error report analyses with qualified hardware and software partners for assistance. "
	L_SPRIVACY_MD5_EMAILONE_TEXT = "Thank you for submitting this error report.  Error reports contain information about what your operating system was doing when the Stop error occurred. This "
	L_SPRIVACY_MD5_EMAILTWO_TEXT = " will be analyzed to determine possible causes of the Stop error. Your error report is still anonymous at this time. However, to receive possible solution information for Stop errors, you must provide an e-mail address, which you can enter by clicking Continue. This information is used only to contact you about the report and will not be used for any other purpose, including marketing."
	L_PRIVACY_MD5_EMAIL_TEXT = "To receive possible solution information for Stop errors, you must provide an e-mail address, which you can enter before the report is submitted. This information is used only to contact you about the report and will not be used for any other purpose, including marketing."
	L_FAQINFORMATION_TEXT = "information"
	L_LOCATE_CANCEL_LINK_TEXT = "Cancel"
	L_CUSTOMER_NEXT_LINK_TEXT = "Continue"

	
	'-------------------------End-------------------------
	



%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\locatestrings.inc ===
<%

	Dim L_LOCATE_EVENT_REPORTS_TEXT
	Dim L_LOCATE_EVENT_DETAILS_TEXT
	Dim L_LOCATE_SEARCH_RESULTS_TEXT
	Dim L_LOCATE_EVENT_DATE_TEXT
	Dim L_LOCATE_FILE_PATH_TEXT
	Dim L_LOCATE_SUB_MITTED_TEXT
	Dim L_LOCATE_CANCEL_LINK_TEXT
	Dim L_LOCATE_PREVIOUS_LINK_TEXT
	Dim L_LOCATE_DUMP_FILES_MESSAGE
	Dim L_LOCATE_DUMP_FILESBODY_MESSAGE
	Dim L_LOCATE_WARN_ING_ERRORMESSAGE
	Dim L_LOCATE_WARNING_MESSAGE_ERRORMESSAGE
	Dim L_LOCATE_REFRESH_LINK_TEXT
	Dim L_LOCATE_UNDEFINED_FILES_TEXT
	Dim L_LOCATE_MINI_DUMPS_TEXT
	Dim L_LOCATE_FULL_DUMP_TEXT
	Dim L_LOCATE_FILE_TOUPLOAD_TEXT
	Dim L_LOCATE_NO_FILESFOUND_TEXT
	Dim L_LOCATE_FILE_LISTED2_MESSAGE
	Dim L_LOCATE_FILE_LISTED1_MESSAGE
	Dim L_LOCATE_HASH_INFO_MESSAGE
	Dim L_LOCATE_SELECT_FILE_MESSAGE
	Dim L_LOCATE_BROWSE_BUTTONTEXT_TEXT
	Dim L_LOCATE_WARNING_MESSAGEONE_ERRORMESSAGE
	Dim L_LOCATE_WARNING_MESSAGETHREE_ERRORMESSAGE
	Dim L_LOCATE_WARNING_MESSAGETWO_ERRORMESSAGE
	Dim L_LOCATE_64BIT_UPLOAD_MESSAGE
	Dim L_LOCATE_FAQ_INFO_TEXT
	Dim L_SUBMIT_VIEW_CONTENTS_TEXT
	Dim L_CUSTOMER_NEXT_LINK_TEXT
	Dim L_SUBMIT_FILE_INVALID_ERRORMESSAGE
	Dim L_SUBMIT_CONVERSION_FAILED_ERRORMESSAGE
	Dim L_SUBMIT_ONLYPRIMIER_CUSTOMERS_ERRORMESSAGE
	Dim L_SUBMIT_64BIT_VIEWMESSAGE_ERRORMESSAGE
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSONE_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSTWO_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSTHREE_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSFOUR_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSFIVE_TEXT 
	Dim L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSSIX_TEXT 
	
	
	'-------------------------locate.asp Page Strings-------------------------
	L_SUBMIT_VIEW_CONTENTS_TEXT = "View the contents of the selected error report"
	L_CUSTOMER_NEXT_LINK_TEXT = "Continue"
	L_SUBMIT_FILE_INVALID_ERRORMESSAGE = "The selected error report is not valid. Select another error report."
	L_SUBMIT_CONVERSION_FAILED_ERRORMESSAGE = "The conversion process for this complete memory dump was not successful. For more information, see the Frequently asked questions (FAQ) page."
	L_SUBMIT_ONLYPRIMIER_CUSTOMERS_ERRORMESSAGE = "For Windows 2000 error reports, a Premier account is required. If you have a Premier account, sign out from Passport and sign on with your Premier credentials.  For more information about Premier accounts, see Product Support Services on the Microsoft Web site."
	L_LOCATE_FILE_LISTED2_MESSAGE = " is already listed in the table"
	L_LOCATE_FILE_LISTED1_MESSAGE = "The file "
	L_LOCATE_UNDEFINED_FILES_TEXT = "Undefined files"
	L_LOCATE_FILE_TOUPLOAD_TEXT = "File to upload"
	L_LOCATE_NO_FILESFOUND_TEXT = "We were unable to locate any error reports in the default folder on your computer. If your computer saves error reports in another folder, click Browse to locate them."
	L_LOCATE_EVENT_REPORTS_TEXT = "Error reports"
	L_LOCATE_EVENT_DETAILS_TEXT = "The following error reports were found in the default folder on your computer. Each error report contains information about one Stop error. Select an error report to submit and click Continue. If your computer is configured to save error reports in another folder, click Browse to locate them."
	L_LOCATE_SEARCH_RESULTS_TEXT = "Search results:"
	L_LOCATE_EVENT_DATE_TEXT = "Date of Error"
	L_LOCATE_FILE_PATH_TEXT = "File Path"
	L_LOCATE_SUB_MITTED_TEXT = "Submitted"
	L_LOCATE_CANCEL_LINK_TEXT = "Cancel"
	L_LOCATE_PREVIOUS_LINK_TEXT = "Previous"
	L_LOCATE_DUMP_FILES_MESSAGE = "Locating error reports"
	L_LOCATE_DUMP_FILESBODY_MESSAGE = 	"Please wait while the error reports are located. For error reports to be located and uploaded for analysis, an ActiveX control is required. If it is not already installed on your computer, it will be installed now."
	L_LOCATE_WARN_ING_ERRORMESSAGE = "The ActiveX control was not installed"
	L_LOCATE_WARNING_MESSAGE_ERRORMESSAGE = "For more information, see the Frequently asked questions (FAQ) page."
	L_LOCATE_REFRESH_LINK_TEXT = ""
	L_LOCATE_SELECT_FILE_MESSAGE = "Please select the browse button to find an error report."
	L_LOCATE_HASH_INFO_MESSAGE = "The selected error report contains an error and cannot be processed. Select another error report."
	L_LOCATE_BROWSE_BUTTONTEXT_TEXT = "Browse"
	L_LOCATE_WARNING_MESSAGEONE_ERRORMESSAGE = "Log on to this computer as an administrator."
	L_LOCATE_WARNING_MESSAGETHREE_ERRORMESSAGE = "Return to this site, and then click Refresh."
	L_LOCATE_WARNING_MESSAGETWO_ERRORMESSAGE = "Set the Internet security options for Internet Explorer to Medium or lower."
	L_LOCATE_64BIT_UPLOAD_MESSAGE = "The selected error report is a 64-bit file and cannot currently be processed by Online Crash Analysis. However, you can still upload this file and it will be analyzed when 64-bit file processing is available. For more information, see the Frequently asked questions (FAQ) page."
	L_LOCATE_FAQ_INFO_TEXT = "The ActiveX control was not installed. For more information, see the Frequently asked questions (FAQ) page."
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSONE_TEXT = "The installation of the ActiveX control might fail because:"
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSTWO_TEXT = "1. You do not have Administrator rights on the Windows NT 4.0, Windows 2000, Microsoft Windows XP Professional or Windows Server 2003 system you are using."
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSTHREE_TEXT = "2. Your Internet security options for Internet Explorer are set to High or Custom."
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSFOUR_TEXT = "To reset the options:"
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSFIVE_TEXT = "1. In the Tools menu, select Internet Options."
	L_FAQ_WHYDOIGETAMESSAGEBOX_DETAILSSIX_TEXT = "2. On the Security tab, set the security level to Medium or lower, and then click OK."
	L_SUBMIT_64BIT_VIEWMESSAGE_ERRORMESSAGE = "The selected error report is a 64-bit file and cannot currently be displayed by Online Crash Analysis. However, you can still upload this file and it will be analyzed when 64-bit file processing is available. For more information, see the Frequently asked questions (FAQ) page."
	'-------------------------End-------------------------
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\resourcestrings.inc ===
<%
	Dim L_RESOURCESTITLE_TEXT
	Dim L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE
	Dim L_COMMENTS_CONNECTION_FAILED_TEXT
	

	'-------------------------resources.asp Page Strings-------------------------
	L_RESOURCESTITLE_TEXT = "General Stop error resources"
	L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE = "Database is not available"
	L_COMMENTS_CONNECTION_FAILED_TEXT = "Windows Online Crash Analysis was unable to connect to the database. Please try this task again." 

	'-----------------------------------------------------------------------------------------


%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\language.inc ===
<%
	'Response.Write "<br>LCID: " &  session.LCID
	'Response.Write "<br>GetLocale Function: " & GetLocale
	'Response.Write "<Br>Hex: " & Hex(GetLocale)
	'Response.Write "<br> HTTP_ACCEPT_LANGUAGE: "  & Request.ServerVariables("HTTP_ACCEPT_LANGUAGE")

	Dim strAcceptLanguage
	Dim strLCID
	Dim strPos
	Dim strAbb
	  
	strAcceptLanguage = Request.ServerVariables("HTTP_ACCEPT_LANGUAGE")

	strPos = InStr(1, strAcceptLanguage, ",")
	If strPos > 0 Then
	strAcceptLanguage = Left(strAcceptLanguage, strPos - 1)
	End If
	'Response.Write "<br>Results: " & strAcceptLanguage
	Select Case LCase(strAcceptLanguage)
		Case "af"
		  strLCID = 1078  ' Afrikaans 
		  strAbb = "AFK"
		Case "sq"
		  strLCID = 1052  ' Albanian 
		  strAbb = "SQI"
		Case "ar-sa"
		  strLCID = 1025  ' Arabic(Saudi Arabia) 
		  strAbb = "ARA"
		Case "ar-iq"
		  strLCID = 2049  ' Arabic(Iraq) 
		  strAbb = "ARI"
		Case "ar-eg"
		  strLCID = 3073  ' Arabic(Egypt) 
		  strAbb = "ARE"
		Case "ar-ly"
		  strLCID = 4097  ' Arabic(Libya)
		   strAbb = "ARL"
		Case "ar-dz"
		  strLCID = 5121  ' Arabic(Algeria) 
		  strAbb = "ARG"
		Case "ar-ma"
		  strLCID = 6145  ' Arabic(Morocco) 
		  strAbb = "ARM"
		Case "ar-tn"
		  strLCID = 7169  ' Arabic(Tunisia) 
		  strAbb = "ART"
		Case "ar-om"
		  strLCID = 8193  ' Arabic(Oman) 
		  strAbb = "ARO"
		Case "ar-ye"
		  strLCID = 9217  ' Arabic(Yemen) 
		  strAbb = "ARY"
		Case "ar-sy"
		  strLCID = 10241 ' Arabic(Syria) 
		  strAbb = "ARS"
		Case "ar-jo"
		  strLCID = 11265 ' Arabic(Jordan) 
		  strAbb = "ARJ"
		Case "ar-lb"
		  strLCID = 12289 ' Arabic(Lebanon) 
		  strAbb = "ARB"
		Case "ar-kw"
		  strLCID = 13313 ' Arabic(Kuwait) 
		  strAbb = "ARK"
		Case "ar-ae"
		  strLCID = 14337 ' Arabic(U.A.E.) 
		  strAbb = "ARU"
		Case "ar-bh"
		  strLCID = 15361 ' Arabic(Bahrain) 
		  strAbb = "ARH"
		Case "ar-qa"
		  strLCID = 16385 ' Arabic(Qatar) 
		  strAbb = "ARQ"
		Case "eu"
		  strLCID = 1069  ' Basque 
		  strAbb = "EUQ"
		Case "bg"
		  strLCID = 1026  ' Bulgarian 
		  strAbb = "BGR"
		Case "be"
		  strLCID = 1059  ' Belarusian 
		  strAbb = "BEL"
		Case "ca"
		  strLCID = 1027  ' Catalan 
		  strAbb = "CAT"
		Case "zh-tw"
		  strLCID = 1028  ' Chinese(Taiwan) 
		  strAbb = "CHT"
		Case "zh-cn"
		  strLCID = 2052  ' Chinese(PRC) 
		  strAbb = "CHS"
		Case "zh-hk"
		  strLCID = 3076  ' Chinese(Hong Kong) 
		  strAbb = "ZHH"
		Case "zh-sg"
		  strLCID = 4100  ' Chinese(Singapore)
		  strAbb = "ZHI"
		Case "hr"
		  strLCID = 1050  ' Croatian 
		  strAbb = "HRV"
		Case "cs"
		  strLCID = 1029  ' Czech 
		  strAbb = "CSY"
		Case "da"
		  strLCID = 1030  ' Danish 
		  strAbb = "DAN"
		Case "n"
		  strLCID = 1043  ' Dutch(Standard) 
		  strAbb = "NLD"
		Case "nl-be"
		  strLCID = 2067  ' Dutch(Belgian) 
		  strAbb = "NLB"
		Case "en"
		  strLCID = 9     ' English 
		  strAbb = "USA"
		Case "en-us"
		  strLCID = 1033  ' English(United States) 
		  strAbb = "USA"
		Case "en-gb"
		  strLCID = 2057  ' English(British) 
		  strAbb = "ENG"
		Case "en-au"
		  strLCID = 3081  ' English(Australian) 
		  strAbb = "ENA"
		Case "en-ca"
		  strLCID = 4105  ' English(Canadian) 
		  strAbb = "ENC"
		Case "en-nz"
		  strLCID = 5129  ' English(New Zealand) 
		  strAbb = "ENZ"
		Case "en-ie"
		  strLCID = 6153  ' English(Ireland) 
		  strAbb = "ENI"
		Case "en-za"
		  strLCID = 7177  ' English(South Africa) 
		  strAbb = "ENS"
		Case "en-jm"
		  strLCID = 8201  ' English(Jamaica) 
		  strAbb = "ENJ"
		Case "en"
		  strLCID = 9225  ' English(Caribbean) 
		  strAbb = "ENB"
		Case "en-bz"
		  strLCID = 10249 ' English(Belize) 
		  strAbb = "ENL"
		Case "en-tt"
		  strLCID = 11273 ' English(Trinidad) 
		  strAbb = "ENT"
		Case "et"
		  strLCID = 1061  ' Estonian 
		  strAbb = "ETI"
		Case "fo"
		  strLCID = 1080  ' Faeroese 
		  strAbb = "FOS"
		Case "fa"
		  strLCID = 1065  ' Farsi 
		  strAbb = "FAR"
		Case "fi"
		  strLCID = 1035  ' Finnish 
		  strAbb = "FIN"
		Case "fr"
		  strLCID = 1036  ' French(Standard) 
		  strAbb = "FRA"
		Case "fr-be"
		  strLCID = 2060  ' French(Belgian) 
		  strAbb = "FRB"
		Case "fr-ca"
		  strLCID = 3084  ' French(Canadian) 
		  strAbb = "FRC"
		Case "fr-ch"
		  strLCID = 4108  ' French(Swiss) 
		  strAbb = "FRS"
		Case "fr-lu"
		  strLCID = 5132  ' French(Luxembourg) 
		  strAbb = "FRL"
		'Case "gd"
		  'strLCID = 1084  ' Gaelic(Scots) 
		  'strAbb = ""
		'Case "gd-ie"
		  'strLCID = 2108  ' Gaelic(Irish) 
		  'strAbb = ""
		Case "de"
		  strLCID = 1031  ' German(Standard) 
		  strAbb = "GER"
		Case "de-ch"
		  strLCID = 2055  ' German(Swiss) 
		  strAbb = "DES"
		Case "de-at"
		  strLCID = 3079  ' German(Austrian) 
		  strAbb = "DEA"
		Case "de-lu"
		  strLCID = 4103  ' German(Luxembourg) 
		  strAbb = "DEL"
		Case "de-li"
		  strLCID = 5127  ' German(Liechtenstein) 
		  strAbb = "DEC"
		Case "e"
		  strLCID = 1032  ' Greek 
		  strAbb = "ELL"
		Case "he"
		  strLCID = 1037  ' Hebrew 
		  strAbb = "HEB"
		Case "hi"
		  strLCID = 1081  ' Hindi 
		  strAbb = "HIN"
		Case "hu"
		  strLCID = 1038  ' Hungarian 
		  strAbb = "HUN"
		Case "is"
		  strLCID = 1039  ' Icelandic 
		  strAbb = "ISL"
		Case "in"
		  strLCID = 1057  ' Indonesian 
		  strAbb = "IND"
		Case "it"
		  strLCID = 1040  ' Italian(Standard) 
		  strAbb = "ITA"
		Case "it-ch"
		  strLCID = 2064  ' Italian(Swiss) 
		  strAbb = "ITS"
		Case "ja"
		  strLCID = 1041  ' Japanese 
		  strAbb = "JPN"
		Case "ko"
		  strLCID = 1042  ' Korean 
		  strAbb = "KOR"
		'Case "ko"
		  'strLCID = 2066  ' Korean(Johab) 
		  'strAbb = ""
		Case "lv"
		  strLCID = 1062  ' Latvian 
		  strAbb = "LVI"
		Case "lt"
		  strLCID = 1063  ' Lithuanian 
		  strAbb = "LTH"
		Case "mk"
		  strLCID = 1071  ' Macedonian 
		  strAbb = "MKD"
		Case "ms"
		  strLCID = 1086  ' Malaysian 
		  strAbb = "MSL"
		'Case "mt"
		 ' strLCID = 1082  ' Maltese 
		  'strAbb = ""
		Case "no"
		  strLCID = 1044  ' Norwegian(Bokmal) 
		  strAbb = "NOR"
		Case "no"
		  strLCID = 2068  ' Norwegian(Nynorsk) 
		  strAbb = "NON"
		Case "p"
		  strLCID = 1045  ' Polish 
		  strAbb = "PLK"
		Case "pt-br"
		  strLCID = 1046  ' Portuguese(Brazilian) 
		  strAbb = "PTB"
		Case "pt"
		  strLCID = 2070  ' Portuguese(Standard) 
		  strAbb = "PTG"
		'Case "rm"
		 ' strLCID = 1047  ' Rhaeto-Romanic 
		  'strAbb = ""
		Case "ro"
		  strLCID = 1048  ' Romanian 
		  strAbb = "ROM"
		'Case "ro-mo"
		  'strLCID = 2072  ' Romanian(Moldavia) 
		  'strAbb = ""
		Case "ru"
		  strLCID = 1049  ' Russian 
		  strAbb = "RUS"
		'Case "ru-mo"
		  'strLCID = 2073  ' Russian(Moldavia) 
		  'strAbb = ""
		'Case "sz"
		 ' strLCID = 1083  ' Sami(Lappish) 
		  'strAbb = ""
		Case "sr"
		  strLCID = 3098  ' Serbian(Cyrillic) 
		  strAbb = "SRB"
		Case "sr"
		  strLCID = 2074  ' Serbian(Latin) 
		  strAbb = "SRL"
		Case "sk"
		  strLCID = 1051  ' Slovak 
		  strAbb = "SKY"
		Case "s"
		  strLCID = 1060  ' Slovenian 
		  strAbb = "SLV"
		'Case "sb"
		  'strLCID = 1070  ' Sorbian 
		  'strAbb = ""
		Case "es"
		  strLCID = 1034  ' Spanish(Spain - Traditional Sort)
		   strAbb = "ESP"
		Case "es-mx"
		  strLCID = 2058  ' Spanish(Mexican) 
		  strAbb = "ESM"
		Case "es"
		  strLCID = 3082  ' Spanish(Spain - Modern Sort) 
		  strAbb = "ESN"
		Case "es-gt"
		  strLCID = 4106  ' Spanish(Guatemala) 
		  strAbb = "ESG"
		Case "es-cr"
		  strLCID = 5130  ' Spanish(Costa Rica)
		   strAbb = "ESC"
		Case "es-pa"
		  strLCID = 6154  ' Spanish(Panama) 
		  strAbb = "ESA"
		Case "es-do"
		  strLCID = 7178  ' Spanish(Dominican Republic) 
		  strAbb = "ESD"
		Case "es-ve"
		  strLCID = 8202  ' Spanish(Venezuela) 
		  strAbb = "ESV"
		Case "es-co"
		  strLCID = 9226  ' Spanish(Colombia) 
		  strAbb = "ESO"
		Case "es-pe"
		  strLCID = 10250 ' Spanish(Peru) 
		  strAbb = "ESR"
		Case "es-ar"
		  strLCID = 11274 ' Spanish(Argentina) 
		  strAbb = "ESS"
		Case "es-ec"
		  strLCID = 12298 ' Spanish(Ecuador) 
		  strAbb = "ESF"
		Case "es-c"
		  strLCID = 13322 ' Spanish(Chile)
		   strAbb = "ESL"
		Case "es-uy"
		  strLCID = 14346 ' Spanish(Uruguay) 
		  strAbb = "ESY"
		Case "es-py"
		  strLCID = 15370 ' Spanish(Paraguay) 
		  strAbb = "ESZ"
		Case "es-bo"
		  strLCID = 16394 ' Spanish(Bolivia) 
		  strAbb = "ESB"
		Case "es-sv"
		  strLCID = 17418 ' Spanish(El Salvador) 
		  strAbb = "ESE"
		Case "es-hn"
		  strLCID = 18442 ' Spanish(Honduras) 
		  strAbb = "ESH"
		Case "es-ni"
		  strLCID = 19466 ' Spanish(Nicaragua) 
		  strAbb = "ESI"
		Case "es-pr"
		  strLCID = 20490 ' Spanish(Puerto Rico) 
		  strAbb = "ESU"
		'Case "sx"
		 ' strLCID = 1072  ' Sutu 
		  'strAbb = ""
		Case "sv"
		  strLCID = 1053  ' Swedish 
		  strAbb = "SVE"
		Case "sv-fi"
		  strLCID = 2077  ' Swedish(Finland) 
		  strAbb = "SVF"
		Case "th"
		  strLCID = 1054  ' Thai 
		  strAbb = "THA"
		'Case "ts"
		 ' strLCID = 1073  ' Tsonga 
		  'strAbb = ""
		'Case "tn"
		'  strLCID = 1074  ' Tswana 
		'  strAbb = ""
		Case "tr"
		  strLCID = 1055  ' Turkish 
		  strAbb = "TRK"
		Case "uk"
		  strLCID = 1058  ' Ukrainian 
		  strAbb = "UKR"
		Case "ur"
		  strLCID = 1056  ' Urdu 
		  strAbb = "URD"
		'Case "ve"
		  'strLCID = 1075  ' Venda 
		  strAbb = ""
		Case "vi"
		  strLCID = 1066  ' Vietnamese 
		  strAbb = "VIT"
		'Case "xh"
		  'strLCID = 1076  ' Xhosa 
		  'strAbb = ""
		'Case "ji"
		  'strLCID = 1085  ' Yiddish 
		  'strAbb = ""
		'Case "zu"
		  'strLCID = 1077  ' Zulu 
		  'strAbb = ""
		Case Else
		  strLCID = 2048  ' default
		  strAbb = "USA"
	End Select 

	'Session.LCID = clng(strLCID)
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\receivedstrings.inc ===
<%

	Dim L_RECEIVED_FILE_ONE_TEXT
	Dim L_RECEIVED_FILE_TWO_TEXT
	Dim L_RECEIVED_THANK_YOU_TEXT
	Dim L_RECEIVED_STATUS_LINK_TEXT
	Dim L_RECEIVED_NEWFILE_LINK_TEXT
	Dim L_COMMENTS_DATABASE_FAILURE_ERRORMESSAGE
	Dim L_COMMENTS_DATABASE_FAILUREBODY_ERRORMESSAGE
	Dim L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE
	Dim L_COMMENTS_CONNECTION_FAILED_TEXT
	Dim L_WELCOME_GO_IMAGEALT_TEXT
	Dim L_RECEIVED_SUCCESS_PARTONE_TEXT
	Dim L_RECEIVED_SUCCESS_PARTTWO_TEXT

	'-------------------------received.asp Page Strings-------------------------
	L_RECEIVED_FILE_ONE_TEXT = "Error report submitted"
	L_RECEIVED_FILE_TWO_TEXT = ""
	L_RECEIVED_THANK_YOU_TEXT = "Thank you for submitting your report.  We will contact you by e-mail when we have information about your error report.  If you would like to check the status of your error report, return to the Windows Online Crash Analysis Web site and click Status."
	L_RECEIVED_STATUS_LINK_TEXT = "Error report status"
	L_RECEIVED_NEWFILE_LINK_TEXT = "Submit an error report"
	L_COMMENTS_DATABASE_FAILURE_ERRORMESSAGE = "Database is not available"
	L_COMMENTS_DATABASE_FAILUREBODY_ERRORMESSAGE = "Windows Online Crash Analysis was unable to save your information to the database. Please try this task again. "
	L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE = "Database is not available"
	L_COMMENTS_CONNECTION_FAILED_TEXT = "Windows Online Crash Analysis was unable to connect to the database. Please try this task again." 
	L_WELCOME_GO_IMAGEALT_TEXT = "Go"
	L_RECEIVED_SUCCESS_PARTONE_TEXT = "Error report "
	L_RECEIVED_SUCCESS_PARTTWO_TEXT = " was successfully submitted."
	
	
	
	
	
	'-----------------------------------------------------------------------------------------




%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\headerstrings.inc ===
<%

	Dim L_HEADER_INC_TITLE_PAGETITLE
	Dim L_HEADERINC_ALINK_HOME_MENUITEM
	Dim L_HEADERINC_ALINK_HOME2_MENUITEM
	Dim L_HEADERINC_ALINK_SUBMITREPORT_MENUITEM
	Dim L_HEADERINC_ALINK_CHECKSTATUS_MENUITEM
	Dim L_HEADERINC_ALINK_RESOURCES_MENUITEM
	Dim L_HEADERINC_ALINK_PRIVACY_MENUITEM
	Dim L_HEADERINC_ALINK_FEEDBACK_MENUITEM
	Dim L_HEADERINC_ALINK_FAQ_MENUITEM
	Dim L_HEADERINC_ALINK_SIGNIN
	Dim L_HEADERINC_ALINK_SIGNIN_MENUITEM
	Dim L_HEADERINC_IMAGE_ALT_TOOLTIP
	Dim L_HEADERINC_TOP10STATUS_LINK_TEXT
	Dim L_HEADERINC_ALINK_MICROSOFT_MENUITEM
	Dim L_HEADERINC_TITLE_OCAHOME_TOOLTIP
	Dim L_HEADERINC_TITLE_CERHOME_TOOLTIP
	Dim L_HEADERINC_IMAGES_BANNER_TEXT
	Dim L_HEADERINC_ISAPI_HOME_MENUITEM
	Dim L_HEADERINC_MICROSOFT_HOME_MENUITEM
	Dim L_HEADERINC_ALL_PRODUCTS_MENUITEM
	Dim L_HEADERINC_ALLPRODUCTS_LINK_TEXT
	Dim L_HEADERINC_DOWNLOADS_DOWNLOADS_MENUITEM
	Dim L_HEADERINC_DOWNLOADS_LINK_TEXT
	Dim L_HEADERINC_MSPRODUCT_CATALOG_MENUITEM
	Dim L_HEADERINC_MSPRODUCT_CATALOG_TEXT
	Dim L_HEADERINC_MICROSOFT_ACCESSIBILITY_MENUITEM
	Dim L_HEADERINC_MICROSOFT_ACCESSIBILITY_TEXT
	Dim L_HEADERINC_SERVER_PRODUCTS_MENUITEM
	Dim L_HEADERINC_SERVER_PRODUCTS_TEXT
	Dim L_HEADERINC_DEVELOPER_TOOLS_MENUITEM
	Dim L_HEADERINC_DEVELOPER_TOOLS_TEXT
	Dim L_HEADERINC_OFFICE_FAMILY_MENUITEM
	Dim L_HEADERINC_OFFICE_FAMILY_TEXT
	Dim L_HEADERINC_WINDOWS_FAMILY_MENUITEM
	Dim L_HEADERINC_WINDOWS_FAMILY_TEXT
	Dim L_HEADERINC_MSN_LINK_TEXT
	Dim L_HEADERINC_MSN_LINK_MENUITEM
	Dim L_HEADERINC_SUPPORT_LINK_TEXT
	Dim L_HEADERINC_SUPPORT_LINK_MENUITEM
	Dim L_HEADERINC_KNOWLEDGE_BASE_TEXT
	Dim L_HEADERINC_KNOWLEDGE_BASE_MENUITEM
	Dim L_HEADERINC_PRODUCTSUPPORT_OPTIONS_TEXT
	Dim L_HEADERINC_PRODUCTSUPPORT_OPTIONS_MENUITEM
	Dim L_HEADERINC_SERVICEPARTNER_REFERRALS_TEXT
	Dim L_HEADERINC_SERVICEPARTNER_REFERRALS_MENUITEM
	Dim L_HEADERINC_SEARCH_LINK_TEXT
	Dim L_HEADERINC_SEARCH_LINK_MENUITEM
	Dim L_HEADERINC_SEARCH_MICROSOFT_TEXT
	Dim L_HEADERINC_SEARCH_MICROSOFT_MENUITEM
	Dim L_HEADERINC_MSNWEB_SEARCH_TEXT
	Dim L_HEADERINC_MSNWEB_SEARCH_MENUITEM
	Dim L_HEADERINC_MICROSOFTCOM_GUIDE_TEXT
	Dim L_HEADERINC_MICROSOFTCOM_GUIDE_MENUITEM
	Dim L_HEADERINC_MICROSOFTCOM_HOME_TEXT
	Dim L_HEADERINC_MICROSOFTCOM_HOME_MENUITEM
	Dim L_HEADERINC_MSN_HOME_TEXT
	Dim L_HEADERINC_MSN_HOME_MENUITEM
	Dim L_HEADERINC_CONTACT_US_TEXT
	Dim L_HEADERINC_CONTACT_US_MENUITEM 
	Dim L_HEADERINC_EVENTS_LINK_TEXT
	Dim L_HEADERINC_EVENTS_LINK_MENUITEM
	Dim L_HEADERINC_NEWSLETTERS_LINK_TEXT
	Dim L_HEADERINC_NEWSLETTERS_LINK_MENUITEM
	Dim L_HEADERINC_PROFILE_CENTER_TEXT
	Dim L_HEADERINC_PROFILE_CENTER_MENUITEM
	Dim L_HEADERINC_TRAINING_CERTIFICATION_TEXT
	Dim L_HEADERINC_TRAINING_CERTIFICATION_MENUITEM
	Dim L_HEADERINC_FREEEMAIL_ACCOUNT_TEXT
	Dim L_HEADERINC_FREEEMAIL_ACCOUNT_MENUITEM
	Dim L_HEADERINC_MICROSOFT_RIGHTSRESERVED_TEXT
	Dim L_HEADERINC_TERMSOF_USE_TEXT
	Dim L_HEADERINC_TERMSOF_USE_MENUITEM
	Dim L_HEADERINC_PRIVACY_STATEMENT_TEXT
	Dim L_HEADERINC_PRIVACY_STATEMENT_MENUITEM
	Dim L_HEADERINC_ACCESSIBILITY_LINK_TEXT
	Dim L_HEADERINC_ACCESSIBILITY_LINK_MENUITEM
	Dim L_HEADERINC_ALINK_CER_MENUITEM 
	Dim L_HEADERINC_ALINK_WORLD_MENUITEM 
	Dim L_HEADERINC_TITLE_WORLDHOME_TOOLTIP
	Dim L_HEADERINC_LEFT_NAV_TEXT
	Dim L_HEADERCERINC_LEFT_NAV_TEXT
	
	'-------------------------header.asp Page Strings-------------------------
	L_HEADERCERINC_LEFT_NAV_TEXT = "Corporate reports"
	L_HEADERINC_LEFT_NAV_TEXT = "Online Crash Analysis"
	L_HEADERINC_ALINK_CER_MENUITEM = "Corporate Error Reporting"
	L_HEADERINC_ALINK_WORLD_MENUITEM = "Online Crash Analysis Worldwide"
	L_HEADERINC_ACCESSIBILITY_LINK_TEXT = "http://www.microsoft.com/enable/default.htm"
	L_HEADERINC_ACCESSIBILITY_LINK_MENUITEM = "Accessibility"
	L_HEADERINC_PRIVACY_STATEMENT_TEXT = "http://www.microsoft.com/isapi/gomscom.asp?target=/info/privacy.htm"
	L_HEADERINC_PRIVACY_STATEMENT_MENUITEM = "Privacy Statement"
	L_HEADERINC_TERMSOF_USE_TEXT = "http://www.microsoft.com/isapi/gomscom.asp?target=/info/cpyright.htm"
	L_HEADERINC_TERMSOF_USE_MENUITEM = "Terms of Use"
	L_HEADERINC_MICROSOFT_RIGHTSRESERVED_TEXT = "&#169; 2001 Microsoft Corporation. All rights reserved."
	L_HEADERINC_FREEEMAIL_ACCOUNT_TEXT = "http://www.hotmail.com/"
	L_HEADERINC_FREEEMAIL_ACCOUNT_MENUITEM = "Free E-mail Account"
	L_HEADERINC_TRAINING_CERTIFICATION_TEXT = "http://www.microsoft.com/isapi/gomscom.asp?target=/train_cert/"
	L_HEADERINC_TRAINING_CERTIFICATION_MENUITEM = "Training & Certification"
	L_HEADERINC_PROFILE_CENTER_TEXT = "http://www.microsoft.com/isapi/goregwiz.asp?target=/regsys/pic.asp"
	L_HEADERINC_PROFILE_CENTER_MENUITEM = "Profile Center"
	L_HEADERINC_NEWSLETTERS_LINK_TEXT = "http://www.microsoft.com/isapi/goregwiz.asp?target=/regsys/pic.asp?sec=0"
	L_HEADERINC_NEWSLETTERS_LINK_MENUITEM = "Newsletters"
	L_HEADERINC_EVENTS_LINK_TEXT = "http://www.microsoft.com/isapi/gomscom.asp?target=/usa/events/default.asp"
	L_HEADERINC_EVENTS_LINK_MENUITEM = "Events"
	L_HEADERINC_CONTACT_US_TEXT = "http://www.microsoft.com/isapi/goregwiz.asp?target=/regwiz/forms/contactus.asp"
	L_HEADERINC_CONTACT_US_MENUITEM = "Contact Us"
	L_HEADERINC_MSN_HOME_TEXT = "http://www.msn.com/"
	L_HEADERINC_MSN_HOME_MENUITEM = "MSN Home"
	L_HEADERINC_MICROSOFTCOM_HOME_TEXT = "http://www.microsoft.com/isapi/gomscom.asp?target=/"
	L_HEADERINC_MICROSOFTCOM_HOME_MENUITEM = "microsoft.com Home"
	L_HEADERINC_MICROSOFTCOM_GUIDE_TEXT = "http://www.microsoft.com/isapi/gomscom.asp?target=/"
	L_HEADERINC_MICROSOFTCOM_GUIDE_MENUITEM = "microsoft.com Guide"
	L_HEADERINC_MSNWEB_SEARCH_TEXT = "http://search.msn.com/"
	L_HEADERINC_MSNWEB_SEARCH_MENUITEM = "MSN Web Search"
	L_HEADERINC_SEARCH_MICROSOFT_TEXT = "http://www.microsoft.com/isapi/gosearch.asp?target=/us/default.asp"
	L_HEADERINC_SEARCH_MICROSOFT_MENUITEM = "Search microsoft.com"
	L_HEADERINC_SEARCH_LINK_TEXT = "http://www.microsoft.com/isapi/gosearch.asp?target=/us/default.asp"
	L_HEADERINC_SEARCH_LINK_MENUITEM = "Search"
	L_HEADERINC_SERVICEPARTNER_REFERRALS_TEXT = "http://mcspreferral.microsoft.com/"
	L_HEADERINC_SERVICEPARTNER_REFERRALS_MENUITEM = "Service Partner Referrals"
	L_HEADERINC_PRODUCTSUPPORT_OPTIONS_TEXT = "http://www.microsoft.com/isapi/gosupport.asp?target=/directory/"
	L_HEADERINC_PRODUCTSUPPORT_OPTIONS_MENUITEM = "Product Support Options"
	L_HEADERINC_KNOWLEDGE_BASE_TEXT = "http://support.microsoft.com/search/"
	L_HEADERINC_KNOWLEDGE_BASE_MENUITEM = "Knowledge Base"
	L_HEADERINC_SUPPORT_LINK_TEXT = "http://www.microsoft.com/isapi/gosupport.asp?target=/directory/"
	L_HEADERINC_SUPPORT_LINK_MENUITEM = "Support"
	L_HEADERINC_MSN_LINK_TEXT = "http://www.msn.com/"
	L_HEADERINC_MSN_LINK_MENUITEM = "MSN"
	L_HEADERINC_WINDOWS_FAMILY_TEXT = "http://www.microsoft.com/isapi/gomscom.asp?target=/windows/"
	L_HEADERINC_WINDOWS_FAMILY_MENUITEM = "Windows Family"
	L_HEADERINC_OFFICE_FAMILY_TEXT = "http://www.microsoft.com/isapi/gomscom.asp?target=/office/"
	L_HEADERINC_OFFICE_FAMILY_MENUITEM = "Office Family"
	L_HEADERINC_DEVELOPER_TOOLS_TEXT = "http://www.microsoft.com/isapi/gomsdn.asp?target=/vstudio/"
	L_HEADERINC_DEVELOPER_TOOLS_MENUITEM = "Developer Tools"
	L_HEADERINC_SERVER_PRODUCTS_TEXT = "http://www.microsoft.com/isapi/gomscom.asp?target=/servers/"
	L_HEADERINC_SERVER_PRODUCTS_MENUITEM = "Server Products"
	L_HEADERINC_MICROSOFT_ACCESSIBILITY_TEXT = "http://www.microsoft.com/isapi/gomscom.asp?target=/enable/"
	L_HEADERINC_MICROSOFT_ACCESSIBILITY_MENUITEM = "Microsoft Accessibility"
	L_HEADERINC_MSPRODUCT_CATALOG_TEXT = "http://www.microsoft.com/isapi/gomscom.asp?target=/catalog/default.asp?subid=22"
	L_HEADERINC_MSPRODUCT_CATALOG_MENUITEM = "MS Product Catalog"
	L_HEADERINC_DOWNLOADS_LINK_TEXT = "http://www.microsoft.com/isapi/gomscom.asp?target=/downloads/"
	L_HEADERINC_DOWNLOADS_DOWNLOADS_MENUITEM = "Downloads"
	L_HEADERINC_ALLPRODUCTS_LINK_TEXT = "http://www.microsoft.com/isapi/gomscom.asp?target=/catalog/default.asp?subid=22"
	L_HEADERINC_ALL_PRODUCTS_MENUITEM = "All Products"
	L_HEADERINC_TOP10STATUS_LINK_TEXT = "Transaction status"
	L_HEADER_INC_TITLE_PAGETITLE = "Windows Online Crash Analysis"
	L_HEADERINC_ALINK_HOME_MENUITEM = "Home"
	L_HEADERINC_ALINK_HOME2_MENUITEM = "Online Crash Analysis"
	L_HEADERINC_ALINK_SUBMITREPORT_MENUITEM = "Submit Report"
	L_HEADERINC_ALINK_CHECKSTATUS_MENUITEM = "Status"
	L_HEADERINC_ALINK_RESOURCES_MENUITEM = "Resources"
	L_HEADERINC_ALINK_PRIVACY_MENUITEM = "Privacy"
	L_HEADERINC_ALINK_FEEDBACK_MENUITEM = "Feedback"
	L_HEADERINC_ALINK_FAQ_MENUITEM = "FAQ"
	L_HEADERINC_ALINK_SIGNIN_MENUITEM = "Sign-in with your Passport"
	L_HEADERINC_IMAGE_ALT_TOOLTIP = "Windows Online Crash Analysis home page"
	L_HEADERINC_ALINK_MICROSOFT_MENUITEM = "http://www.microsoft.com"
	L_HEADERINC_TITLE_OCAHOME_TOOLTIP = "Windows Online Crash Analysis home page"
	L_HEADERINC_TITLE_CERHOME_TOOLTIP = "Corporate Error Reporting home page"
	L_HEADERINC_TITLE_WORLDHOME_TOOLTIP = "Windows Online Crash Analysis Worldwide home page"
	L_HEADERINC_IMAGES_BANNER_TEXT = "http://www.microsoft.com/library/toolbar/images/banner.gif"
	L_HEADERINC_ISAPI_HOME_MENUITEM = "/isapi/gomscom.asp?target=/"
	L_HEADERINC_MICROSOFT_HOME_MENUITEM = "Microsoft Home"
	
	
	'-------------------------End-------------------------

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\shutdownstrings.inc ===
<%

Dim L_SHUTDOWN_STATE_TITLE_INFO_TEXT
Dim L_SHUTDOWN_STATE_PARAGRAPHONE_PARTONE_TEXT
Dim L_SHUTDOWN_STATE_PARAGRAPH_ONEBOLD_TEXT
Dim L_SHUTDOWN_STATE_PARAGRAPHONE_PARTTWO_TEXT
Dim L_SHUTDOWN_STATE_SUB_TITLE_TEXT
Dim L_SHUTDOWN_STATE_PARAGRAPH_TWO_TEXT
Dim L_SHUTDOWN_STATE_LINK_NAME_TEXT
Dim L_SHUTDOWN_STATE_LINK_NAME_URL

'-------------------------shutdown.asp Page Strings-------------------------
L_SHUTDOWN_STATE_TITLE_INFO_TEXT = "System State Data"
L_SHUTDOWN_STATE_PARAGRAPHONE_PARTONE_TEXT = "Thank you for submitting your System State Data.  By default, this System State Data is taken when a user checks the "
L_SHUTDOWN_STATE_PARAGRAPH_ONEBOLD_TEXT = "unplanned "
L_SHUTDOWN_STATE_PARAGRAPHONE_PARTTWO_TEXT = "checkbox on the shutdown event tracker screen.  Depending on policy settings, these dumps may also be captured at other times."
L_SHUTDOWN_STATE_SUB_TITLE_TEXT = "Why is this information important?"
L_SHUTDOWN_STATE_PARAGRAPH_TWO_TEXT = "Microsoft uses this System State Data to identify common problems that lead customers to reboot their computers.  Microsoft is committed to continually improving our software, and this data helps us achieve this goal.  Thanks again for helping us make Windows a better product."
'---------------------------------------------------------------------------

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\statusstrings.inc ===
<%

	Dim L_STATUS_EVENT_REPORT_TEXT
	Dim L_STATUS_EVENT_INFO_TEXT
	Dim L_STATUS_CHECK_BOX_TOOLTIP
	Dim L_STATUS_DATE_DATE_TEXT
	Dim L_STATUS_COMPUTER_NAME_TEXT
	Dim L_STATUS_CLASS_CLASS_TEXT
	Dim L_STATUS_DESCRIPTION_BODY_TEXT
	Dim L_STATUS_FILE_NAME_TEXT
	Dim L_STATUS_STATUS_INFO_TEXT
	Dim L_STATUS_DETAILS_INFO_TEXT
	Dim L_STATUS_COMMENTS_INFO_TEXT
	Dim L_STATUS_UN_KNOWN_TEXT
	Dim L_STATUS_NEED_FULLDUMP_TEXT
	Dim L_STATUS_UNABLE_TOPROCESS_TEXT
	Dim L_STATUS_COMPLETE_INFO_TEXT
	Dim L_STATUS_RESEARCHING_INFO_TEXT
	Dim L_STATUS_IN_PROGRESS_TEXT
	Dim L_STATUS_NO_RECORDS_MESSAGE
	Dim L_STATUS_SHOW_REPORTS_TOOLTIP
	Dim L_STATUS_HIDE_REPORTS_TEXT
	Dim L_STATUS_ALERT_ERROR_MESSAGE
	Dim L_STATUS_ALERT_CANNOTPROCESS_MESSAGE
	Dim L_STATUS_RESEARCHING_MOREINFO_TEXT
	Dim L_STATUS_DETAILS_TITLE_TOOLTIP
	Dim L_STATUS_COMMENTS_TITLE_TOOLTIP
	Dim L_STATUS_ANALYSIS_COMPLETEDETAILS_TEXT
	Dim L_STATUS_TITLE_ID_TEXT
	Dim L_STATUS_SHOW_REPORTS_TEXT
	Dim L_STATUS_PASSPORT_LOGIN_MESSAGE

	Dim L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE
	Dim L_COMMENTS_DATABASE_FAILED_TEXT
	Dim L_COMMENTS_CONNECTION_FAILED_TEXT
	Dim L_CUSTOMER_PASSPORT_TITLE_TEXT
	Dim L_STATE_INPROGRESS_DETAILS_TEXT
	Dim L_STATE_RESEARCHING_DETAILS_TEXT
	Dim L_STATE_CANNOTPROCESS_DETAILS_TEXT
	Dim L_STATE_FULLDUMP_REQUIREDDETAILS_TEXT
	Dim L_STATE_RESEARCHINGMORE_INFOBODY_TEXT
	Dim L_STATE_STATUS_BODY_TEXT
	Dim L_STATUS_64BITDUMP_INFO_TEXT
	Dim L_STATE_64BITDUMP_INFOBODY_TEXT
	Dim L_WELCOME_PASSPORT_LINK_TEXT
	Dim L_FAQ_PASSPORT_LINK_TEXT
	Dim L_STATE_RESEARCHINGMOREGBUCKET_INFOBODY_TEXT


	'-------------------------status.asp Page Strings-------------------------

	L_STATE_INPROGRESS_DETAILS_TEXT = "We are currently processing this error report. When the error report is processed and the analysis is complete, we will contact you by using the e-mail address you provided."
	L_STATE_RESEARCHING_DETAILS_TEXT = "This error report has been processed and analyzed. We are unable to offer a solution at this time, but we will continue to research this error report. We will contact you with any solutions we discover by using the e-mail address you provided."
	L_STATE_CANNOTPROCESS_DETAILS_TEXT = "We cannot process this error report. There are a number of reasons that the Windows Online Crash Analysis Web site may not be able to recognize your error report. For more information, see the Frequently asked questions (FAQ) page."
	L_STATE_FULLDUMP_REQUIREDDETAILS_TEXT = "Thank you for submitting this error report to Windows  Online Crash Analysis. We have analyzed this error report and determined that additional information is needed before we can identify the cause of this Stop error. If you choose, you can send us a complete memory dump for analysis. A complete memory dump records the entire contents of your operating system memory when the Stop error occurred, and should contain the needed information. "
	L_STATE_RESEARCHINGMORE_INFOBODY_TEXT = "This error report has been processed and analyzed. We are unable to offer a solution at this time, but we will continue to research this error report. We have identified the following Knowledge Base articles which may help you troubleshoot your issue. We will contact you with any solutions we discover by using the e-mail address you provided."
	L_STATE_RESEARCHINGMOREGBUCKET_INFOBODY_TEXT = "This error report has been processed and analyzed. We are unable to offer a solution at this time, but we will continue to research this error report. We have identified the following information which may help you troubleshoot your issue. We will contact you with any solutions we discover by using the e-mail address you provided."
	L_STATE_STATUS_BODY_TEXT = "The status of your report cannot be determined."
	L_CUSTOMER_PASSPORT_TITLE_TEXT = "Passport sign-in"
	L_COMMENTS_CONNECTION_FAILED_TEXT = "Windows Online Crash Analysis was unable to connect to the database. Please try this task again." 
	L_COMMENTS_DATABASE_FAILED_TEXT = "Windows Online Crash Analysis was unable to save your information to the database. Please try this task again."
	L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE = "Database is not available"
	L_STATUS_ALERT_ERROR_MESSAGE = "There are no details for this error report because we are currently processing it."
	L_STATUS_HIDE_REPORTS_TEXT = "Hide selected error reports"
	L_STATUS_SHOW_REPORTS_TEXT = "Show all error reports"
	L_STATUS_SHOW_REPORTS_TOOLTIP = "Show all previously submitted error reports."
	L_STATUS_EVENT_INFO_TEXT = "The following error reports were found. To view the analysis status, click the image in the Analysis column. To view or change your previous error report comments, click the link listed in the Comments column."
	L_STATUS_CHECK_BOX_TOOLTIP = "Check or uncheck all check boxes"
	L_STATUS_DATE_DATE_TEXT = "Submitted"
	L_STATUS_COMPUTER_NAME_TEXT = "Computer name"
	L_STATUS_CLASS_CLASS_TEXT = "Type"
	L_STATUS_DESCRIPTION_BODY_TEXT = "Description"
	L_STATUS_FILE_NAME_TEXT = "Error File Name"
	L_STATUS_STATUS_INFO_TEXT = "Analysis"
	L_STATUS_DETAILS_INFO_TEXT = "Details"
	L_STATUS_COMMENTS_INFO_TEXT = "Comments"
	L_STATUS_IN_PROGRESS_TEXT = "In progress"
	L_STATUS_RESEARCHING_INFO_TEXT = "Researching"
	L_STATUS_COMPLETE_INFO_TEXT = "Complete"
	L_STATUS_UNABLE_TOPROCESS_TEXT = "Cannot process"
	L_STATUS_NEED_FULLDUMP_TEXT = "Complete memory dump needed"
	L_STATUS_UN_KNOWN_TEXT = "Unknown"
	L_STATUS_NO_RECORDS_MESSAGE = "No error reports were found."
	L_STATUS_RESEARCHING_MOREINFO_TEXT = "More information available"
	L_STATUS_DETAILS_TITLE_TOOLTIP = "Review the information that was uploaded from your computer"
	L_STATUS_COMMENTS_TITLE_TOOLTIP = "Review, change or add to the comments and reproduction notes"
	L_STATUS_ANALYSIS_COMPLETEDETAILS_TEXT = "We have discovered the cause of this Stop error.  To review the resources click on this link"
	L_STATUS_TITLE_ID_TEXT = "ErrorID"
	L_STATUS_EVENT_REPORT_TEXT = "Error reports"
	L_STATUS_ALERT_CANNOTPROCESS_MESSAGE = "There are no details for this error report because we cannot process it."
	L_STATUS_PASSPORT_LOGIN_MESSAGE =  "To check the status of reports that you submitted, sign in using your Microsoft Passport. To get a Passport, visit the "
	L_STATUS_64BITDUMP_INFO_TEXT = "64-bit error report"
	L_STATE_64BITDUMP_INFOBODY_TEXT = "The error report you uploaded is a 64-bit file and cannot be processed by Windows Online Crash Analysis at this time. We are currently working to implement this functionality."
	L_WELCOME_PASSPORT_LINK_TEXT = "Microsoft Passport Web site." 
	L_FAQ_PASSPORT_LINK_TEXT = "http://www.passport.com"
	
	'-----------------------------------------------------------------------------------------
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\statestrings.inc ===
<%
	Dim L_STATE_EVENT_NAME_MESSAGE
	Dim L_STATE_IN_PROGRESS_TEXT
	Dim L_STATE_INPROGRESS_DETAILS_TEXT
	Dim L_STATE_INPROGRESS_DETAILS2_TEXT
	Dim L_STATE_RESEARCHING_TITLE_TEXT
	Dim L_STATE_RESEARCHING_DETAILS_TEXT
	Dim L_STATE_ANALYSIS_COMPLETE_TEXT
	Dim L_STATE_ANALYSISCOMPLETE_DETAILS_TEXT
	Dim L_STATE_KNOWLEDGEBASED_ARTICLES_TEXT
	Dim L_STATE_ADDITONAL_HELP_TEXT
	Dim L_STATE_SPECIFIC_INFORMATION_TEXT
	Dim L_STATE_CANNOT_PROCESS_TEXT
	Dim L_STATE_CANNOTPROCESS_DETAILS_TEXT
	Dim L_FAQ_WHATIF_CANNOTPROCESSBODY1_TEXT
	Dim L_FAQ_WHATIF_CANNOTPROCESSBODY2_TEXT
	Dim L_FAQ_WHATIF_CANNOTPROCESSBODY3_TEXT
	Dim L_FAQ_WHATIF_CANNOTPROCESSBODY4_TEXT
	Dim L_STATE_FULLDUMP_REQUIRED_TEXT
	Dim L_STATE_FULLDUMP_REQUIREDDETAILS_TEXT
	Dim L_STATE_UNKNOWN_BODY_TEXT
	Dim L_STATE_STATUS_BODY_TEXT
	Dim L_STATE_KNOWLEDGE_BASE_TEXT
	Dim L_STATE_NOKNOWLEDGE_BASE_TEXT
	Dim L_STATE_NOADDITIONAL_INFO_TEXT
	Dim L_STATE_RESEARCHINGMORE_INFO_TEXT 
	Dim L_STATE_RESEARCHINGMORE_INFOBODY_TEXT 
	Dim L_STATE_COMPANYLIST_FORARRAY_TEXT
	Dim L_STATE_MANUFACTURERS_INFORMATION_TEXT
	Dim L_STATE_FULLDUMPPRIVACYTITLE_INFO_TEXT
	Dim L_STATE_FULLDUMPPRIVACYBODY_INFO_TEXT
	Dim L_STATE_FULLDUMPLOCATIONBODY_INFO_TEXT
	Dim L_STATE_FULLDUMPLOCATIONTITLE_INFO_TEXT
	Dim L_STATE_FULLDUMPLOCATIONBODY_INFOONE_TEXT
	Dim L_STATE_FULLDUMPLOCATIONBODY_INFOTWO_TEXT
	Dim L_STATE_FULLDUMPLOCATIONBODY_INFOTHREE_TEXT
	Dim L_STATE_FULLDUMPLOCATIONBODY_INFOFOUR_TEXT
	Dim L_STATE_FULLDUMPLOCATIONBODY_INFOFIVE_TEXT
	Dim L_STATE_FULLDUMPLOCATIONBODY_INFOSIX_TEXT
	Dim L_STATE_FULLDUMPSUBMITTALTITLE_INFO_TEXT
	Dim L_STATE_FULLDUMPSUBMITTALBODY_INFO_TEXT
	Dim L_STATE_FULLDUMPSUBMITTALBODY_INFOPARTA_TEXT
	Dim L_STATE_FULLDUMPSUBMITTALBODY_INFOONE_TEXT
	Dim L_STATE_FULLDUMPSUBMITTALBODY_INFOTWO_TEXT
	Dim L_STATE_FULLDUMPSUBMITTALBODY_INFOTHREE_TEXT
	Dim L_STATE_FULLDUMPSUBMITTALBODY_INFOFOUR_TEXT
	Dim L_STATE_FULLDUMPSUBMITTALBODY_INFOFIVE_TEXT
	Dim L_STATE_FULLDUMPSUBMITTALBODY_INFOFIVESUBONE_TEXT
	Dim L_STATE_FULLDUMPSUBMITTALBODY_INFOFIVESUBTWO_TEXT
	Dim L_STATE_FULLDUMPSUBMITTALBODY_INFOSIX_TEXT
	Dim L_STATE_FULLDUMPSUBMITTALBODY_INFOSIXSUBONE_TEXT
	Dim L_STATE_FULLDUMPSUBMITTALBODY_INFOSIXSUBTWO_TEXT
	Dim L_STATE_FULLDUMPSUBMITTALBODY_INFOSIXSUBTHREE_TEXT
	Dim L_STATE_FULLDUMPSUBMITTALBODY_INFOSIXSUBFOUR_TEXT
	Dim L_STATE_FULLDUMPSUBMITTALBODY_INFOSIXSUBFIVE_TEXT
	Dim L_STATE_NOCOMPANY_INFORMATIONAVAILABLE_TEXT
	Dim L_STATE_EVENTNAME_TITLE_TEXT
	Dim L_STATE_RESEARCHINGMORE_INFOGBUCKET_TEXT
	Dim L_STATE_RESEARCHINGMORE_INFOBODYGBUCKET_TEXT


	Dim L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE
	Dim L_COMMENTS_CONNECTION_FAILED_TEXT
	Dim L_WELCOME_INTERNET_EXPLORER_TEXT
	Dim L_DETAILS_STATUS_BODY_TEXT
	Dim L_FAQ_MICROSOFT_LINK_TEXT
	Dim L_STATE_KNOWLEDGEBASE_LINK_TEXT
	Dim L_STATE_64BITDUMP_FILE_TEXT
	Dim L_STATE_64BITDUMP_BODY_TEXT


	'-------------------------state.asp Page Strings-------------------------
	L_STATE_64BITDUMP_FILE_TEXT = "64-bit error report"
	L_STATE_64BITDUMP_BODY_TEXT = "The error report you uploaded is a 64-bit file and cannot be processed by Windows Online Crash Analysis at this time. We are currently working to implement this functionality."
	L_DETAILS_STATUS_BODY_TEXT = "Return to error report status"
	L_WELCOME_INTERNET_EXPLORER_TEXT = "Microsoft Web site."
	L_COMMENTS_CONNECTION_FAILED_TEXT = "Windows Online Crash Analysis was unable to connect to the database. Please try this task again." 
	L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE = "Database is not available"
	L_STATE_STATUS_BODY_TEXT = "The status of your report cannot be determined."
	L_STATE_UNKNOWN_BODY_TEXT = "Unknown"
	L_STATE_FULLDUMP_REQUIREDDETAILS_TEXT = "Thank you for submitting this error report to Windows  Online Crash Analysis. We have analyzed this error report and determined that additional information is needed before we can identify the cause of this Stop error. If you choose, you can send us a complete memory dump for analysis. A complete memory dump records the entire contents of your operating system memory when the Stop error occurred, and should contain the needed information. "
	L_STATE_FULLDUMP_REQUIRED_TEXT = "Complete memory dump needed"
	L_STATE_CANNOTPROCESS_DETAILS_TEXT = "We cannot process this error report. There are a number of reasons that the Windows Online Crash Analysis Web site may not be able to recognize your error report."
	L_STATE_CANNOT_PROCESS_TEXT = "Cannot process"
	L_FAQ_WHATIF_CANNOTPROCESSBODY1_TEXT = "Our service was unable to retrieve debug symbols for your error report.  This case is usually seen when running a pre-release version of the operating system."
	L_FAQ_WHATIF_CANNOTPROCESSBODY2_TEXT = "The error report was corrupted while it was being created and is unreadable by our Web site."
	L_FAQ_WHATIF_CANNOTPROCESSBODY3_TEXT = "The contents of the dump file were corrupted while trying to upload or analyze the file."
	L_FAQ_WHATIF_CANNOTPROCESSBODY4_TEXT = "There was a problem while trying to update our database. Try uploading the error report again."
	L_STATE_SPECIFIC_INFORMATION_TEXT = "Additional information"
	L_STATE_ADDITONAL_HELP_TEXT = "For more information, see Product Support Services on the  "
	L_STATE_KNOWLEDGEBASED_ARTICLES_TEXT = "Available Knowledge Based articles"
	L_STATE_ANALYSISCOMPLETE_DETAILS_TEXT = "We have discovered the cause of this Stop error.  Please review the resources listed below."
	L_STATE_ANALYSIS_COMPLETE_TEXT = "Analysis complete"
	L_STATE_RESEARCHING_TITLE_TEXT = "Researching"
	L_STATE_RESEARCHING_DETAILS_TEXT = "This error report has been processed and analyzed. We are unable to offer a solution at this time, but we will continue to research this error report. We will contact you with any solutions we discover by using the e-mail address you provided."
	L_STATE_RESEARCHINGMORE_INFOBODYGBUCKET_TEXT = "This error report has been processed and analyzed. We are unable to offer a solution at this time, but we will continue to research this error report. We have identified the following information which may help you troubleshoot your issue. We will contact you with any solutions we discover by using the e-mail address you provided."
	L_STATE_EVENT_NAME_MESSAGE = "Analysis status"
	L_STATE_IN_PROGRESS_TEXT = "In progress"
	L_STATE_INPROGRESS_DETAILS_TEXT = "We are currently processing this error report. When the error report is processed and the initial analysis is complete, we will contact you by using the e-mail address you provided."
	L_STATE_INPROGRESS_DETAILS2_TEXT = "We are currently processing one or more files within this transaction. When the error report is processed and the initial analysis is complete you can view the analysis status by clicking the link in the Analysis column on the Transaction status page."
	L_STATE_KNOWLEDGE_BASE_TEXT = "Knowledge Base articles"
	L_STATE_NOKNOWLEDGE_BASE_TEXT = "No Knowledge Base articles were found."
	L_STATE_NOADDITIONAL_INFO_TEXT = "No additional information is available."
	L_STATE_RESEARCHINGMORE_INFO_TEXT = "More information available"
	L_STATE_RESEARCHINGMORE_INFOGBUCKET_TEXT  = "More information available"
	L_STATE_RESEARCHINGMORE_INFOBODY_TEXT = "This error report has been processed and analyzed. We are unable to offer a solution at this time, but we will continue to research this error report. We have identified the following Knowledge Base articles which may help you troubleshoot your issue. We will contact you with any solutions we discover by using the e-mail address you provided."
	L_STATE_MANUFACTURERS_INFORMATION_TEXT = "Manufacturer information"
	L_STATE_FULLDUMPPRIVACYTITLE_INFO_TEXT = "Privacy information"
	L_STATE_FULLDUMPPRIVACYBODY_INFO_TEXT = "A complete memory dump might contain customer-specific information, such as data from any files open at the time of the Stop error. This information, if present in a complete memory dump, will not be used. Complete memory dumps are stored on a secure Microsoft server where only those individuals involved in Stop error analysis can gain access to them. The information is kept only as long as it is useful for researching possible causes of the Stop error."
	L_STATE_FULLDUMPLOCATIONTITLE_INFO_TEXT = "Complete memory dump location"
	L_STATE_FULLDUMPLOCATIONBODY_INFO_TEXT = "Your computer might already be configured to record complete memory dumps. To locate complete memory dump files, search for files named Memory.dmp on your computer."
	L_STATE_FULLDUMPLOCATIONBODY_INFOONE_TEXT = "In Control Panel, double-click System."
	L_STATE_FULLDUMPLOCATIONBODY_INFOTWO_TEXT = "On the Advanced tab, click Startup and Recovery."
	L_STATE_FULLDUMPLOCATIONBODY_INFOTHREE_TEXT = "Under Write Debugging Information, in the drop-down box, select Complete Memory Dump, and then click OK."
	L_STATE_FULLDUMPLOCATIONBODY_INFOFOUR_TEXT = "In the dialog box that appears, click OK."
	L_STATE_FULLDUMPLOCATIONBODY_INFOFIVE_TEXT = "In the System Properties dialog box, click OK."
	L_STATE_FULLDUMPLOCATIONBODY_INFOSIX_TEXT = "In the System Settings Change dialog box, click Yes if you want to restart your computer at that time. Click No if you want to restart it later."
	L_STATE_FULLDUMPSUBMITTALTITLE_INFO_TEXT = "Submitting a complete memory dump file"
	L_STATE_FULLDUMPSUBMITTALBODY_INFO_TEXT = "Because complete memory dumps are equivalent in size to the amount of random access memory (RAM) in your computer plus 1 MB, you must compress the file before submittal. You can print the following instructions for reference."
	L_STATE_FULLDUMPSUBMITTALBODY_INFOPARTA_TEXT = "To submit a complete memory dump file:"
	L_STATE_FULLDUMPSUBMITTALBODY_INFOONE_TEXT = "Rename Memory.dmp to match the error report name you originally submitted."
	L_STATE_FULLDUMPSUBMITTALBODY_INFOTWO_TEXT = "Compress the file by using a widely available compression tool such as PKZIP or WinZip."
	L_STATE_FULLDUMPSUBMITTALBODY_INFOTHREE_TEXT = "Rename the resulting file to the same name as the Event ID you originally submitted."
	L_STATE_FULLDUMPSUBMITTALBODY_INFOFOUR_TEXT = "Open your FTP program and connect to ftp://transfer.microsoft.com/oca_in."
	L_STATE_FULLDUMPSUBMITTALBODY_INFOFIVE_TEXT = "Log on to the server using the following credentials:"
	L_STATE_FULLDUMPSUBMITTALBODY_INFOFIVESUBONE_TEXT = "User name: oca"
	L_STATE_FULLDUMPSUBMITTALBODY_INFOFIVESUBTWO_TEXT = "Password: Sam$36pm"
	L_STATE_FULLDUMPSUBMITTALBODY_INFOSIX_TEXT = "Submit the zip file, and then send an e-mail message to oca@microsoft.com with the following information:"
	L_STATE_FULLDUMPSUBMITTALBODY_INFOSIXSUBONE_TEXT = "Name"
	L_STATE_FULLDUMPSUBMITTALBODY_INFOSIXSUBTWO_TEXT = "Telephone number"
	L_STATE_FULLDUMPSUBMITTALBODY_INFOSIXSUBTHREE_TEXT = "E-mail address"
	L_STATE_FULLDUMPSUBMITTALBODY_INFOSIXSUBFOUR_TEXT = "EventID"
	L_STATE_FULLDUMPSUBMITTALBODY_INFOSIXSUBFIVE_TEXT = "Type"
	L_STATE_NOCOMPANY_INFORMATIONAVAILABLE_TEXT = "No manufacturer information is available."
	L_STATE_EVENTNAME_TITLE_TEXT = "Error report description: "
	L_FAQ_MICROSOFT_LINK_TEXT = "http://www.microsoft.com"
	L_STATE_KNOWLEDGEBASE_LINK_TEXT = "http://support.microsoft.com/support/misc/kblookup.asp?ID="
	'****************************************************************************************
	'Please leave semi-colons in string and replace the text only for localization
	L_STATE_COMPANYLIST_FORARRAY_TEXT = "Company Name;Company Address;;City;State;Zip;Phone;Support Phone;Fax;Web site;"
	'****************************************************************************************
	
	'-----------------------------------------------------------------------------------------


%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\viewstrings.inc ===
<%

	Dim L_VIEW_VIEW_CONTENTS_TEXT
	Dim L_VIEW_VIEWCONTENTS_BODY_TEXT
	Dim L_VIEW_CONTENTS_OF_TEXT
	Dim L_VIEW_CONTENTS_INVALID_TEXT 
	Dim L_LOCATE_PREVIOUS_LINK_TEXT
	Dim L_CUSTOMER_NEXT_LINK_TEXT
	Dim L_LOCATE_WARN_ING_ERRORMESSAGE
	Dim L_LOCATE_WARNING_MESSAGE_ERRORMESSAGE
	Dim L_LOCATE_REFRESH_LINK_TEXT
	Dim L_LOCATE_HASH_INFO_MESSAGE

	'-------------------------view.asp Page Strings-------------------------
	L_VIEW_VIEW_CONTENTS_TEXT = "Error report contents"
	L_VIEW_VIEWCONTENTS_BODY_TEXT = "The contents of the selected error report are displayed below. This is done without sending any information to Windows Online Crash Analysis."
	L_VIEW_CONTENTS_OF_TEXT = "Contents of error report"
	L_VIEW_CONTENTS_INVALID_TEXT = "Contents of the file could not be retrieved."
	L_LOCATE_PREVIOUS_LINK_TEXT = "Previous"
	L_CUSTOMER_NEXT_LINK_TEXT = "Continue"
	L_LOCATE_WARN_ING_ERRORMESSAGE = "The ActiveX control was not installed"
	L_LOCATE_WARNING_MESSAGE_ERRORMESSAGE = "For more information, see the Frequently asked questions (FAQ) page."
	L_LOCATE_REFRESH_LINK_TEXT = ""
	L_LOCATE_HASH_INFO_MESSAGE = "The selected error report contains an error and cannot be processed. Select another error report."






	'-----------------------------------------------------------------------------------------


%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\waitstrings.inc ===
<%
	Dim L_WAIT_ONE_MSG1_MESSAGE
	Dim L_WAIT_ONE_MSG2_MESSAGE
	Dim L_WAIT_ONE_MSG3_MESSAGE
	Dim L_WAIT_TWO_MSG2_MESSAGE
	Dim L_WAIT_TWO_MSG4_MESSAGE
	Dim L_WAIT_TWO_MSG5_MESSAGE
	Dim L_WAIT_TWO_MSG6_MESSAGE
	
	
	
	
	
	'-------------------------wait.asp Page Strings-------------------------
	L_WAIT_ONE_MSG1_MESSAGE = "Please wait while we load the contents of the selected error report. This information is not sent to Windows Online Crash Analysis. This might take several seconds."
	L_WAIT_ONE_MSG2_MESSAGE = "Loading the Selected Error Report"
	L_WAIT_ONE_MSG3_MESSAGE = "This is done without sending any information to Microsoft."
	L_WAIT_TWO_MSG2_MESSAGE = "Uploading File"
	L_WAIT_TWO_MSG4_MESSAGE = "Please wait while we upload the selected error report.  This might take several seconds."
	L_WAIT_TWO_MSG5_MESSAGE = "Please wait while we upload the selected transaction.  The upload time is dependent upon your connection speed, network traffic, and the number of files in the transaction. This can take several hours to complete this transaction."
	L_WAIT_TWO_MSG6_MESSAGE = "Uploading Transaction"
	'-----------------------------------------------------------------------------------------

%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\isapi\errorcodes.h ===
// Isapi error codes returned with the response url
#define MESSAGE_RECEIVE_TIMEOUT		1
#define FAILED_TO_SEND_MESSAGE		2
#define FAILED_CONNECT_SEND			3
#define FAILED_CONNECT_RECEIVE		4
#define FILE_NOT_FOUND				5
#define EXCEEDED_MAX_THREAD_COUNT	6
#define FAILED_TO_IMPERSONATE_USER	7
#define FAILED_TO_PARSE_QUERYSTRING 8
#define INVALID_TYPE_SPECIFIED		9
#define FAILED_TO_COPY_FILE			10
#define INTERNAL_ERROR				11
#define FAILED_RECONNECT_RECEIVE	12
#define FAILED_TO_CREATE_CURSOR		13
#define FAILED_TO_CREATE_GUID		14
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\submitstrings.inc ===
<%
	Dim L_SUBMIT_HASH_EXIST_MESSAGE
	Dim L_SUBMIT_HASHEXIST_CHOOSEFILE_MESSAGE
	Dim L_SUBMIT_HASHEXIST_CHOOSEFILE2_MESSAGE
	Dim L_SUBMIT_HASHEXIST_CHOOSEFILE3_MESSAGE
	Dim L_SUBMIT_HASHEXIST_CHOOSEFILE4_MESSAGE
	Dim L_SUBMIT_EVENT_DESCRIPTION_TEXT
	Dim L_SUBMIT_EVENTDESCRIPTION_BODY_TEXT
	Dim L_SUBMIT_UPLOAD_FILE_TEXT
	Dim L_SUBMIT_FOR_PROCESSING_TEXT
	Dim L_SUBMIT_FOR_PROCESSINGAUTO_TEXT
	Dim L_SUBMIT_EVENT_NAME_TEXT
	Dim L_SUBMIT_OPERATING_SYSTEM_TEXT
	Dim L_SUBMIT_SELECT_OPERATINGSYSTEM_GROUPBOX
	Dim L_SUBMIT_RE_PRODUCE_EDITBOX
	Dim L_SUBMIT_COMMENTS_INFO_EDITBOX
	Dim L_SUBMIT_VIEW_CONTENTS_TEXT
	Dim L_SUBMIT_FINSIH_INFO_TEXT
	Dim L_SUBMIT_FILE_INVALID_ERRORMESSAGE
	Dim L_SUBMIT_FILENOT_FOUND_ERRORMESSAGE
	Dim L_SUBMIT_FILENOTUP_LOADED_ERRORMESSAGE
	Dim L_SUBMIT_CONVERSION_FAILED_ERRORMESSAGE
	Dim L_SUBMIT_UNKNOWN_ERROR_ERRORMESSAGE
	Dim L_SUBMIT_UPLOAD_FILEAUTO_TEXT
	Dim L_SUBMIT_ONLYPRIMIER_CUSTOMERS_ERRORMESSAGE
	Dim L_SUBMIT_ALERTEVENT_NAME_ERRORMESSAGE
	Dim L_SUBMIT_ALERTQUOTE_QUOTE_ERRORMESSAGE
	Dim L_SUBMIT_MAX_LENGTH_MESSAGE
	Dim L_SUBMIT_EVENT_MAINTITLE_TEXT
	Dim L_SUBMIT_EVENTDESCRIPTIONAUTO_BODY_TEXT

	Dim L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE
	Dim L_COMMENTS_EVENT_NAME_TEXT
	Dim L_COMMENTS_DATABASE_FAILED_TEXT
	Dim L_COMMENTS_CONNECTION_FAILED_TEXT
	Dim L_LOCATE_CANCEL_LINK_TEXT
	Dim L_LOCATE_PREVIOUS_LINK_TEXT
	Dim L_LOCATE_WARN_ING_ERRORMESSAGE
	Dim L_LOCATE_WARNING_MESSAGE_ERRORMESSAGE
	Dim L_LOCATE_REFRESH_LINK_TEXT

	Dim L_SUBMIT_SELECT_WINDOWS2000_PROFESSIONAL_GROUPBOX
	Dim L_SUBMIT_SELECT_WINDOWS2000_SERVER_GROUPBOX
	Dim L_SUBMIT_SELECT_WINDOWS2000_ADVANCEDSERVER_GROUPBOX
	Dim L_SUBMIT_SELECT_WINDOWS2000_DATACENTER_GROUPBOX
	Dim L_SUBMIT_SELECT_WINDOWSXP_PERSONAL_GROUPBOX
	Dim L_SUBMIT_SELECT_WINDOWSXP_PROFESSIONAL_GROUPBOX
	Dim L_SUBMIT_SELECT_WINDOWSXP_SERVER_GROUPBOX
	Dim L_SUBMIT_SELECT_WINDOWSXP_ADVANCEDSERVER_GROUPBOX
	Dim L_SUBMIT_SELECT_WINDOWSXP_DATACENTER_GROUPBOX
	Dim L_SUBMIT_SELECT_WINDOWSXP_64BIT_GROUPBOX
	Dim L_SUBMIT_ASSOCIATE_YES_TEXT
	Dim L_SUBMIT_ASSOCIATE_NO_TEXT
	Dim L_RECEIVED_STATUS_LINK_TEXT
	
	'-------------------------submit.asp Page Strings-------------------------
	L_SUBMIT_UNKNOWN_ERROR_ERRORMESSAGE = "The error report cannot be uploaded because of an unknown error. Please try to resubmit the error report."
	L_SUBMIT_CONVERSION_FAILED_ERRORMESSAGE = "The conversion process for this complete memory dump was not successful. For more information, see the Frequently asked questions (FAQ) page."
	L_SUBMIT_FILENOTUP_LOADED_ERRORMESSAGE = "The error report cannot be uploaded at this time. Please try to resubmit the error report later."
	L_SUBMIT_FILENOT_FOUND_ERRORMESSAGE = "The selected error report was not able to be located."
	L_SUBMIT_FILE_INVALID_ERRORMESSAGE = "The selected error report is not valid. Select another error report."
	L_SUBMIT_FINSIH_INFO_TEXT = "Finish"
	L_SUBMIT_VIEW_CONTENTS_TEXT = "View the contents of the selected error report"
	L_SUBMIT_COMMENTS_INFO_EDITBOX = "Comments (optional):"
	L_SUBMIT_RE_PRODUCE_EDITBOX = "Steps to reproduce the Stop error (optional):"
	L_SUBMIT_SELECT_OPERATINGSYSTEM_GROUPBOX = "- Select system -"
	L_SUBMIT_OPERATING_SYSTEM_TEXT = "Operating system:"
	L_SUBMIT_UPLOAD_FILE_TEXT = "You selected error report "
	L_SUBMIT_FOR_PROCESSING_TEXT = "  to be submitted for analysis."
	L_SUBMIT_FOR_PROCESSINGAUTO_TEXT = "  was submitted for analysis."
	L_SUBMIT_EVENTDESCRIPTION_BODY_TEXT = "To identify this error report in subsequent lists, type a descriptive name you can easily remember. After you type the name and complete the rest of the information, click Finish to upload the error report."
	L_SUBMIT_EVENTDESCRIPTIONAUTO_BODY_TEXT = "To identify this error report in subsequent lists, type a descriptive name you can easily remember. After you type the name and complete the rest of the information, click Finish."
	L_SUBMIT_EVENT_DESCRIPTION_TEXT = "Error report description"
	L_SUBMIT_HASH_EXIST_MESSAGE = "Report previously submitted"
	L_SUBMIT_HASHEXIST_CHOOSEFILE_MESSAGE = "We have determined that this error report has been previously submitted to Windows Online Crash Analysis."
	L_SUBMIT_HASHEXIST_CHOOSEFILE2_MESSAGE = "If you submitted this error report from a corporation, your system administrator might have previously submitted this report to our Web site. You may want to contact your system administrator to confirm this."
	L_SUBMIT_HASHEXIST_CHOOSEFILE3_MESSAGE = "If you previously submitted this report to the Online Crash Analysis Web site or by using the Windows Error Reporting Client and you would like to receive analysis information by e-mail, click Continue to enter your contact information."
	L_SUBMIT_HASHEXIST_CHOOSEFILE4_MESSAGE = "If you previously submitted this report to the Online Crash Analysis Web site or by using the Windows Error Reporting Client, click Error report status to view the status of your reports."
	L_SUBMIT_UPLOAD_FILEAUTO_TEXT = "Error report"
	L_SUBMIT_ONLYPRIMIER_CUSTOMERS_ERRORMESSAGE = "For Windows 2000 error reports, a Premier account is required. If you have a Premier account, sign out from Passport and sign on with your Premier credentials.  For more information about Premier accounts, see Product Support Services on the Microsoft Web site."
	L_SUBMIT_ALERTEVENT_NAME_ERRORMESSAGE = "Please enter a description for this error report."
	L_SUBMIT_ALERTQUOTE_QUOTE_ERRORMESSAGE = "Quotes are not allowed in the description."
	L_SUBMIT_MAX_LENGTH_MESSAGE = "The maximum number of characters is 1024."
	L_SUBMIT_EVENT_MAINTITLE_TEXT = "Selected error report"
	
	L_COMMENTS_UNABLE_TOCONNECT_ERRORMESSAGE = "Database is not available"
	L_COMMENTS_DATABASE_FAILED_TEXT = "Windows Online Crash Analysis was unable to save your information to the database. Please try this task again."
	L_COMMENTS_CONNECTION_FAILED_TEXT = "Windows Online Crash Analysis was unable to connect to the database. Please try this task again." 
	L_LOCATE_PREVIOUS_LINK_TEXT = "Previous"
	L_COMMENTS_EVENT_NAME_TEXT = "Description:"
	L_LOCATE_CANCEL_LINK_TEXT = "Cancel"
	L_LOCATE_WARN_ING_ERRORMESSAGE = "The ActiveX control was not installed"
	L_LOCATE_WARNING_MESSAGE_ERRORMESSAGE = "For more information, see the Frequently asked questions (FAQ) page."
	L_LOCATE_REFRESH_LINK_TEXT = ""

	L_SUBMIT_SELECT_OPERATINGSYSTEM_GROUPBOX = "- Select system -"
	L_SUBMIT_SELECT_WINDOWS2000_PROFESSIONAL_GROUPBOX = "Windows 2000 Professional"
	L_SUBMIT_SELECT_WINDOWS2000_SERVER_GROUPBOX = "Windows 2000 Server"
	L_SUBMIT_SELECT_WINDOWS2000_ADVANCEDSERVER_GROUPBOX = "Windows 2000 Advanced Server"
	L_SUBMIT_SELECT_WINDOWS2000_DATACENTER_GROUPBOX = "Windows 2000 Datacenter Server"
	L_SUBMIT_SELECT_WINDOWSXP_PERSONAL_GROUPBOX = "Windows XP Home Edition"
	L_SUBMIT_SELECT_WINDOWSXP_PROFESSIONAL_GROUPBOX = "Windows XP Professional"
	L_SUBMIT_SELECT_WINDOWSXP_SERVER_GROUPBOX = "Windows Server 2003"
	L_SUBMIT_SELECT_WINDOWSXP_ADVANCEDSERVER_GROUPBOX = ""
	L_SUBMIT_SELECT_WINDOWSXP_DATACENTER_GROUPBOX = ""
	L_SUBMIT_SELECT_WINDOWSXP_64BIT_GROUPBOX = "Windows XP 64-Bit Edition"
	L_SUBMIT_ASSOCIATE_YES_TEXT = "Continue"
	L_SUBMIT_ASSOCIATE_NO_TEXT = "Cancel"
	L_RECEIVED_STATUS_LINK_TEXT = "Error report status"
	
	'-----------------------------------------------------------------------------------------
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\worldwidestrings.inc ===
<%

	Dim L_OCA_WORLDWIDE_LOGO_TEXT
	Dim L_OCA_WORLDWIDE_BODY_TEXT
	Dim L_OCA_WORLDWIDE_BODY2_TEXT
	Dim L_OCA_WORLDWIDE_BODY3_TEXT
	Dim L_OCA_WORLDWIDE_LINK_TEXT
	Dim L_OCA_WORLDWIDE_LINK_URL
	Dim L_OCA_WORLDWIDE_GERMAN_TEXT
	Dim L_OCA_WORLDWIDE_FRENCH_TEXT
	Dim L_OCA_WORLDWIDE_JAPANESE_TEXT
	Dim L_OCA_WORLDWIDE_ENGLISH_TEXT
	
	'-------------------------auto.asp Page Strings-------------------------
	L_OCA_WORLDWIDE_LOGO_TEXT = "Windows Online Crash Analysis Worldwide"
	L_OCA_WORLDWIDE_BODY_TEXT = "To visit one of the worldwide Windows Online Crash Analysis sites, click the appropriate link below."
	L_OCA_WORLDWIDE_GERMAN_TEXT = "German"
	L_OCA_WORLDWIDE_FRENCH_TEXT = "French"
	L_OCA_WORLDWIDE_JAPANESE_TEXT = "Japanese"
	L_OCA_WORLDWIDE_ENGLISH_TEXT = "English"
	L_OCA_WORLDWIDE_BODY2_TEXT = "To find worldwide sites for other Microsoft products, visit the "
	L_OCA_WORLDWIDE_BODY3_TEXT = "Web site."
	L_OCA_WORLDWIDE_LINK_TEXT = "Microsoft Worldwide"
	L_OCA_WORLDWIDE_LINK_URL = "http://www.microsoft.com/worldwide/"
	
	'-----------------------------------------------------------------------------------------
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\inc\welcomestrings.inc ===
<%
	Dim L_WELCOMELOGO_TEXT
	Dim L_WELCOME_LOGO_TWO_TEXT
	Dim L_WELCOME_LOGO_INFO_TEXT
	Dim L_WELCOME_HOWIT_WORKS_TEXT
	Dim L_WELCOME_HOWITWORKS_INFO_TEXT
	Dim L_WELCOME_WHATTO_EXPECT_TEXT
	Dim L_WELCOME_WHATTOEXPECT_INFO_TEXT
	Dim L_WELCOME_REQUIRE_MENTS_TEXT
	Dim L_WELCOME_REQUIREMENTS_INFO_TEXT
	Dim L_WELCOME_REQUIREMENTSINFO_TWO_TEXT
	Dim L_WELCOME_REQUIREMENTS_PASSPORT_TEXT
	Dim L_WELCOME_INTERNET_EXPLORER_TEXT
	Dim L_WELCOME_SCRIPT_TITLE_TEXT
	Dim L_WELCOME_SCRIPT_BODY_TEXT
	Dim L_WELCOME_NOCOOKIES_BODY_TEXT
	Dim L_WELCOME_COOKIES_DISABLE_TEXT
	Dim L_WELCOME_COOKIES_BODY_TEXT
	Dim L_WELCOME_PASSPORT_LINK_TEXT
	Dim L_WELCOME_GO_IMAGEALT_TEXT
	Dim L_RECEIVED_NEWFILE_LINK_TEXT
	Dim L_RECEIVED_STATUS_LINK_TEXT
	Dim L_FAQ_MICROSOFT_LINK_TEXT
	Dim L_FAQ_PASSPORT_LINK_TEXT
	
	'-------------------------welcome.asp Page Strings-------------------------
	L_RECEIVED_STATUS_LINK_TEXT = "Error report status"

	L_RECEIVED_NEWFILE_LINK_TEXT = "Submit an error report"
	L_WELCOMELOGO_TEXT = "Windows<sup>&#174;</sup>"
	L_WELCOME_LOGO_TWO_TEXT = " Online Crash Analysis"
	L_WELCOME_LOGO_INFO_TEXT = "Microsoft<sup>&#174;</sup> is committed to making Windows the most reliable operating system available. New and enhanced features contribute to increased reliability, and additional resources, including Windows Online Crash Analysis, provide information to help you optimize your system."
	L_WELCOME_HOWIT_WORKS_TEXT = "How it works"
	L_WELCOME_HOWITWORKS_INFO_TEXT = "If you experience a blue screen crash event, or Stop error, while using Microsoft Windows XP, you can upload the error report to our site for analysis."
	L_WELCOME_WHATTO_EXPECT_TEXT = "What to expect"
	L_WELCOME_WHATTOEXPECT_INFO_TEXT = "Microsoft actively analyzes all error reports and prioritizes them based on the number of customers affected by the Stop error covered in the error report. We will try to determine the cause of the Stop error you submit, categorize it according to the type of issue encountered, and send you relevent information when such information is identified. You can check the status of your error report at any time. However, because error reports do not always contain enough information to positively identify the source of the issue, we might need to collect a number of similar error reports from other customers before a pattern is discovered, or follow up with you further to gather additional information. Furthermore, some error reports might require additional resources (such as a hardware debugger or a live debugger session)  before a solution can be found. Although we might not be able to provide a solution for your particular Stop error, all information submitted is used to further improve the quality and reliability of Windows."
	L_WELCOME_REQUIRE_MENTS_TEXT = "Requirements"
	L_WELCOME_REQUIREMENTS_INFO_TEXT = "To submit an error report, you must be using Windows NT 4.0, Windows 2000, or Windows XP. Windows Online Crash Analysis requires Microsoft Internet Explorer 5 or later and a Microsoft Passport. To download the latest version of Internet Explorer, visit the "
	L_WELCOME_REQUIREMENTSINFO_TWO_TEXT = "To get a Passport, visit the&nbsp;"
	L_WELCOME_REQUIREMENTS_PASSPORT_TEXT = "For Windows 2000 error reports, a Premier account is required. For more information about Premier accounts, see Product Support Services on the "
	L_WELCOME_INTERNET_EXPLORER_TEXT = "Microsoft Web site."
	L_WELCOME_SCRIPT_TITLE_TEXT = "This site cannot be displayed with current security options"
	L_WELCOME_SCRIPT_BODY_TEXT = "Internet Explorer Internet security options are set to High or Custom. Windows Online Crash Analysis cannot be displayed. To reset the options for Internet Explorer, in the Tools menu, select Internet Options. On the Security tab, set the security level to Medium or lower, and then click OK."
	L_WELCOME_COOKIES_DISABLE_TEXT = "This site cannot be displayed because browser cookies are not enabled"
	L_WELCOME_COOKIES_BODY_TEXT = "Internet Explorer must have cookies enabled to use Windows Online Crash Analysis. To enable cookies for Internet Explorer, in the Tools menu, select Internet Options. On the Security tab, set the security level to Medium or lower, and then click OK."
	L_WELCOME_PASSPORT_LINK_TEXT = "Microsoft Passport Web site." 
	L_WELCOME_GO_IMAGEALT_TEXT = "Go"
	L_FAQ_MICROSOFT_LINK_TEXT = "http://www.microsoft.com"
	L_FAQ_PASSPORT_LINK_TEXT = "http://www.passport.com"
	'-------------------------End-------------------------
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\isapi\main.cpp ===
/*++

Copyright (c) 2002  Microsoft Corporation

Module Name:    Oca_Extension

Abstract:       This Isapi extensions is used to provide a realtime interface
                from the OCA web site and the Analysis Servers.

*/

//
// Includes
//


#include <windows.h>
#include <httpext.h>
#include <stdio.h>
#include <malloc.h>
#include <objbase.h>
#include <mqoai.h>
#include <mq.h>
#include <TCHAR.h>
#include <Rpcdce.h>
#include <strsafe.h>
#include <process.h>
#include <time.h>
#include <dbgeng.h> // for crdb.h
#include "messages.h"
#include "ErrorCodes.h"
#include "..\..\..\..\exts\extdll\crdb.h" // for source type definitions


typedef struct Isapi_Params
{
    wchar_t     OutQueueConStr1[MAX_PATH];
    wchar_t     OutQueueConStr2[MAX_PATH];
    wchar_t     InQueueConStr1[MAX_PATH];
//  wchar_t     InQueueConStr2[MAX_PATH];
    TCHAR       WatsonBaseDir[MAX_PATH];    // Watson server to get file from
    TCHAR       LocalBaseDir[MAX_PATH];     // Local machine directory to store dump file.
    TCHAR       LocalShareName[MAX_PATH];
    TCHAR       ErrorUrl[MAX_PATH];
    TCHAR       ManualUploadPath[MAX_PATH]; // Upload location for manual submissions
    BOOL        bAllowSR;                   // Process request of type CiSrcManualPssSr
} ISAPI_PARAMS, * PISAPIPARAMS;

/*
winnt.h:#define EVENTLOG_SUCCESS                0x0000
winnt.h:#define EVENTLOG_ERROR_TYPE             0x0001
winnt.h:#define EVENTLOG_WARNING_TYPE           0x0002
winnt.h:#define EVENTLOG_INFORMATION_TYPE       0x0004
winnt.h:#define EVENTLOG_AUDIT_SUCCESS          0x0008
winnt.h:#define EVENTLOG_AUDIT_FAILURE          0x0010
*/
typedef enum _ISAPI_EVENT_TYPE {
    INFO    = EVENTLOG_INFORMATION_TYPE,
    WARN    = EVENTLOG_WARNING_TYPE,
    ERR     = EVENTLOG_ERROR_TYPE,
    SUCCESS = EVENTLOG_SUCCESS,
    AUDIT_SUCCESS = EVENTLOG_AUDIT_SUCCESS,
    AUDIT_FAIL = EVENTLOG_AUDIT_FAILURE
} ISAPI_EVENT_TYPE;

#define LOGLEVEL_ALWAYS 0x00001
#define LOGLEVEL_PERF   0x00100
#define LOGLEVEL_DEBUG  0x01000
#define LOGLEVEL_TRACE  0x10000

//
// Global Variables
//

TCHAR g_cszDefaultExtensionDll[] = _T("Oca_Extension.dll");

const int         NUMBEROFPROPERTIES = 5;
long              g_dwThreadCount    = 0;
BOOL              bInitialized       = FALSE;
long              MaxThreadCount     = 100;
CRITICAL_SECTION  SendCritSec;
ISAPI_PARAMS      g_IsapiParams;
DWORD             g_dwDebugMode       = LOGLEVEL_ALWAYS;
DWORD             g_dwProcessID = 0;
PSID              g_psidUser = NULL;
HANDLE            g_hEventSource = INVALID_HANDLE_VALUE;
HMODULE           g_hModule = NULL;
TCHAR             g_szAppName[MAX_PATH];

//
// Function Prototypes
//
unsigned int __stdcall WorkerFunction( void *vECB);
BOOL    SendHttpHeaders(EXTENSION_CONTROL_BLOCK *, LPCSTR , LPCSTR, BOOL );
//HRESULT ConnectToMSMQ(QUEUEHANDLE *hQueue, wchar_t *QueueConnectStr, BOOL bSendAccess);
int     GetRegData(PISAPIPARAMS pParams);
void    LogEvent(DWORD dwLevel, ISAPI_EVENT_TYPE emType, DWORD dwEventID, DWORD dwErrorID, ...);
void    LogEventWithString(DWORD dwLevel, ISAPI_EVENT_TYPE emType, DWORD dwEventID, LPCTSTR pFormat, ...);
DWORD   SetupEventLog ( BOOL fSetup );



//
// Function Implementations.
//

BOOL WINAPI
GetExtensionVersion(
    OUT HSE_VERSION_INFO *pVer
)
/*++

Purpose:

    This is required ISAPI Extension DLL entry point.

Arguments:

    pVer - points to extension version info structure

Returns:

    always returns TRUE

--*/
{
    HANDLE hToken;
    TOKEN_USER *puser;
    DWORD cb = 0;
    DWORD dwResult = 0;
    int *test = NULL;
    free (test);

    LogEventWithString(LOGLEVEL_TRACE, INFO, ISAPI_EVENT_DEBUG, "GetExtensionVersion()");

    //
    // tell the server our version number and extension description
    //
    ZeroMemory(&g_IsapiParams, sizeof ISAPI_PARAMS);
    if (GetRegData (&g_IsapiParams))
        bInitialized = TRUE;
    else
        bInitialized = FALSE;

    SetupEventLog(TRUE);
    InitializeCriticalSection(&SendCritSec);
    pVer->dwExtensionVersion =
        MAKELONG( HSE_VERSION_MINOR, HSE_VERSION_MAJOR );

    g_dwProcessID = GetCurrentProcessId();


/*
    LogEventWithString(LOGLEVEL_DEBUG, INFO, ISAPI_EVENT_DEBUG, "GetExtensionVersion() - getting user SID");
    if (OpenThreadToken(GetCurrentThread(), TOKEN_READ, TRUE, &hToken)
            || OpenProcessToken(GetCurrentProcess(), TOKEN_READ, &hToken))
    {
        LogEventWithString(LOGLEVEL_DEBUG, INFO, ISAPI_EVENT_DEBUG, "GetExtensionVersion() - opened token");
        GetTokenInformation(hToken, TokenUser, NULL, cb, &cb);
    //puser = (PTOKEN_USER)HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, cb);
        puser = (PTOKEN_USER)LocalAlloc(LPTR, cb);
        LogEventWithString(LOGLEVEL_DEBUG, INFO, ISAPI_EVENT_DEBUG, "GetExtensionVersion() - token requires %d bytes, puser = %08x", cb, (DWORD_PTR)puser);
        if (puser && GetTokenInformation(hToken, TokenUser, puser, cb, &cb))
        {
            g_psidUser = puser->User.Sid;
            //HeapFree(GetProcessHeap(), 0, (LPVOID)puser);
            LocalFree(puser);
        }
    }
LogEventWithString(LOGLEVEL_DEBUG, INFO, ISAPI_EVENT_DEBUG, "GetExtensionVersion() - got user SID");
*/

    lstrcpyn(
        pVer->lpszExtensionDesc,
        "OCA Extension",
        HSE_MAX_EXT_DLL_NAME_LEN
        );

    LogEvent(
        LOGLEVEL_ALWAYS,
        SUCCESS,
        ISAPI_EVENT_SUCCESS_INITIALIZED,
        ISAPI_M_SUCCESS_INITIALIZED
    );

    return TRUE;
}




BOOL ParseQueryString(
    EXTENSION_CONTROL_BLOCK *pECB ,
    TCHAR *FileName,
    ULONG cbFileName,
    int * piType,
    TCHAR *szType,
    ULONG cbType,
    TCHAR *szSR,
    ULONG cbSR
    )
{
    TCHAR *pFname = NULL;
    TCHAR *pQueryString = NULL;
    ULONG iCharCount = 0;
    TCHAR *pType = NULL;
    HRESULT hResult = S_OK;
    BOOL fRetVal = FALSE;

    LogEventWithString(
        LOGLEVEL_TRACE,
        INFO,
        ISAPI_EVENT_TRACE,
        "ParseQueryString(pECB, FileName=%s, *piType=%d, szType=%s)\r\n"
            "pECB->lpszQueryString: %s",
        FileName,
        *piType,
        szType,
        pECB->lpszQueryString
    );

    pFname = FileName;
    pQueryString = pECB->lpszQueryString;

    //--> Parse the string if it does not exactly match the following format dump the string
    //--> and send the client to the oca home page.

    // The url we are parsing must have the following format:
    /*
        id=3_20_2002\62018831_2.cab&
           Cab=/UploadBlue/62018831.cab&
           AutoLaunch=1&
           Client=BlueScreen&
           Old=1&
           BCCode=1000008e&
           BCP1=C0000005&
           BCP2=BFA00062&
           BCP3=EF8AEAFC&
           BCP4=00000000&
           OSVer=5_1_2600&
           SP=0_0&
           Product=256_1&
           LCID=1033
    */

    if (*pQueryString == _T('\0'))
    {
        LogEventWithString(
            LOGLEVEL_TRACE,
            INFO,
            ISAPI_EVENT_TRACE,
            "ParseQueryString() - pQueryString is empty string"
        );

        goto  ERRORS;
    }
    // first lets make sure the query string starts with id=
    if ( ( (*pQueryString == _T('i')) || (*pQueryString == _T('I')) ) && (*(pQueryString +2) == _T('=')) )
    {
        ULONG cchFileName = cbFileName / sizeof(TCHAR);

        // ok so far move past the = character.
        pQueryString += 3;

        //Now get the cab file name.
        iCharCount = 0;
        while ((*pQueryString != _T('&')) && (*pQueryString != _T('\0')) && (iCharCount < cchFileName -1 ))
        {
            *pFname = *pQueryString;
            ++pFname;
            ++pQueryString;
            ++ iCharCount;
            // Null Terminate the fileName

        }
        FileName[cchFileName -1] = _T('\0');
        if (*pQueryString != _T('\0'))
        {
            // now see what type of upload this is.
            // Type = 5 is manual
            // Type = 6 is stress
            // Default is no type parameter and then the type is set to 0.
            ++ pQueryString;

            if ( (*pQueryString == _T('T')) || (*pQueryString == _T('t')) )
            {
                while ( (*pQueryString != _T('\0')) && (*pQueryString != _T('e')) && (*pQueryString != _T('E'))  )
                {
                    ++pQueryString;
                }
                if (*pQueryString != _T('\0'))
                {
                    // We have the type parameter.
                    // now strip off the designator and save it in iType.
                    pType = szType;
                    *pType = _T(';');
                    ++pType;
                    pQueryString+=2; // skip the e and the =
                    iCharCount = 0;
                    while ( (*pQueryString != _T('\0')) && (*pQueryString != _T('&')) && (iCharCount <3))
                    {
                        ++iCharCount;
                        *pType = *pQueryString;
                        ++pType;
                        ++pQueryString;

                    }
                    // Null terminate the szType;
                    *pType = _T('\0');
                    pType = szType;
                    ++pType; // skip the ;
                    *piType = atoi(pType);
                }
                else
                {
                    // we ran into a problem set the type to 0
                    hResult = StringCbCopy(szType,cbType, _T(";1"));
                    *piType = 1;
                    if (FAILED (hResult))
                    {
                        goto ERRORS;
                    }
                }

            }
            else
            {
                *piType = 1;
                hResult = StringCbCopy(szType,cbType, _T(";1"));
                if (FAILED (hResult))
                {
                    goto ERRORS;
                }
            }
        }
        else
        {
            *piType = 1;
            hResult = StringCbCopy(szType,cbType, _T(";1"));
            if (FAILED (hResult))
            {
                goto ERRORS;
            }
        }
        if (*pQueryString == _T('&') && *piType == CiSrcManualPssSr)
        {
            // Check if we have a SR attached in query string
            if (!_tcsnicmp(pQueryString, _T("&SR="), 4))
            {
                // Copy the SR
                if (cbSR != 0)
                {
                    ++pQueryString;
                    cbSR -= sizeof(TCHAR);
                    *szSR = _T(';');
                }
                while (*pQueryString != _T('\0') && *pQueryString != _T('&') &&
                       cbSR > sizeof(TCHAR))
                {
                    *szSR = *pQueryString;
                    ++szSR; ++pQueryString;
                    cbSR -= sizeof(TCHAR);

                }
            }
        }
        if (cbSR != 0)
        {
            *szSR = _T('\0');
        }
        fRetVal = TRUE;
    }

ERRORS:

    LogEventWithString(
        LOGLEVEL_TRACE,
        INFO,
        ISAPI_EVENT_TRACE,
        "Exiting ParseQueryString(pECB, FileName=%s, *piType=%d, szType=%s)\r\n"
            "pQueryString: %s\r\n"
            "fRetVal: %d\r\n",
        FileName,
        *piType,
        szType,
        pQueryString,
        fRetVal
    );
    return fRetVal;
}

DWORD WINAPI
HttpExtensionProc(
    IN EXTENSION_CONTROL_BLOCK *pECB
)
/*++

Purpose:

    Create a thread to handle extended processing. It will be passed
    the address of a function ("WorkerFunction") to run, and the address
    of the ECB associated with this session.

Arguments:

    pECB - pointer to the extenstion control block

Returns:

    HSE_STATUS_PENDING to mark this request as pending

--*/
{
    UINT dwThreadID;
    HANDLE hThread;
    //HANDLE hToken;
    DWORD  dwSize = 0;
    TCHAR  FinalURL[MAX_PATH];
    TCHAR  FileName[MAX_PATH];
    int    iType =1;
    TCHAR  szType [20];
    TCHAR  szSR [50];
    char   szHeader[] =   "Content-type: text/html\r\n\r\n";
    TCHAR  ErrorText[255];

    LogEventWithString(LOGLEVEL_TRACE, INFO, ISAPI_EVENT_TRACE, "HttpExtensionProc()");

    ZeroMemory(ErrorText,sizeof ErrorText);
    if (bInitialized)
    {
        if (g_dwThreadCount < MaxThreadCount)
        {
            hThread = NULL;
            hThread = (HANDLE)_beginthreadex(NULL,    // Pointer to thread security attributes
                        0,                 // Initial thread stack size, in bytes
                        &WorkerFunction,   // Pointer to thread function
                        pECB,              // The ECB is the argument for the new thread
                        0,                 // Creation flags
                        &dwThreadID        // Pointer to returned thread identifier
                        );

            //
            // update global thread count
            //
            InterlockedIncrement( &g_dwThreadCount );

            LogEventWithString(
                LOGLEVEL_DEBUG,
                SUCCESS,
                ISAPI_EVENT_DEBUG,
                "HttpExtensionProc() - started thread #%ld",
                g_dwThreadCount
            );

            // Return HSE_STATUS_PENDING to release IIS pool thread without losing connection
            if ((hThread) && (INVALID_HANDLE_VALUE != hThread))
            {
                CloseHandle(hThread);
                return HSE_STATUS_PENDING;
            }
            else
            {
                LogEventWithString(
                    LOGLEVEL_ALWAYS,
                    ERR,
                    ISAPI_EVENT_ERROR,
                    "HttpExtensionProc() - thread creation for thread #%ld failed",
                    g_dwThreadCount
                );
            }
        }
        else
        {
            LogEventWithString(
                LOGLEVEL_ALWAYS,
                ERR,
                ISAPI_EVENT_PERF,
                "HttpExtensionProc() - exceeded max thread count #%ld",
                MaxThreadCount
            );
        }

        if ( (!ParseQueryString(pECB, FileName, sizeof(FileName), &iType,
                                szType, sizeof(szType),
                                szSR, sizeof(szSR))) && (iType == 1) )
        {
            ZeroMemory (FinalURL,sizeof FinalURL);
            if (StringCbPrintf(FinalURL, sizeof FinalURL, "%s&State=0&Code=%d", g_IsapiParams.ErrorUrl,EXCEEDED_MAX_THREAD_COUNT) == S_OK)
            {
                LogEventWithString(
                    LOGLEVEL_DEBUG,
                    WARN,
                    ISAPI_EVENT_WARNING,
                    "HttpExtensionProc() - ParseQueryString() failed or iType=0\r\n"
                      "FileName: %s\r\n"
                      "iType: %d\r\n"
                      "szType%s\r\n"
                      "URL: %s",
                    FileName,
                    iType,
                    szType,
                    FinalURL
                );

                dwSize = (DWORD)_tcslen(FinalURL);
                pECB->ServerSupportFunction(pECB->ConnID,
                                            HSE_REQ_SEND_URL_REDIRECT_RESP,
                                            FinalURL,
                                            &dwSize,
                                            NULL
                                            );

                // TODO: log event if error
            }
            else
            {
                LogEventWithString(
                    LOGLEVEL_ALWAYS,
                    ERR,
                    ISAPI_EVENT_ERROR,
                    "HttpExtensionProc() - StringCbPrintf() failed"
                );

                // There is nothing we can do
                return HSE_STATUS_ERROR;
            }
        }
        else // Parsing succeeded
        {
            // Write the data to the client
            if (StringCbPrintf(FinalURL, sizeof FinalURL, "%s&State=0&Code=%d", g_IsapiParams.ErrorUrl, EXCEEDED_MAX_THREAD_COUNT) == S_OK)
            {
                 LogEventWithString(
                    LOGLEVEL_TRACE,
                    SUCCESS,
                    ISAPI_EVENT_TRACE,
                    "HttpExtensionProc() - ParseQueryString() succeeded (debug), StringCbPrintf succeeded\r\n"
                      "FileName: %s\r\n"
                      "iType: %d\r\n"
                      "szType: %s\r\n"
                      "ErrorText: %s",
                    FileName,
                    iType,
                    szType,
                    ErrorText
                );
            }
            else
            {
                LogEventWithString(
                    LOGLEVEL_DEBUG,
                    ERR,
                    ISAPI_EVENT_ERROR,
                    "HttpExtensionProc() - ParseQueryString() succeeded (debug), StringCbPrintf failed\r\n"
                      "FileName: %s\r\n"
                      "iType: %d\r\n"
                      "szType: %s\r\n"
                      "ErrorText: %s",
                    FileName,
                    iType,
                    szType,
                    ErrorText
                );

                return HSE_STATUS_ERROR;
            }

            if (StringCbPrintf(FinalURL, sizeof FinalURL, "%s&State=0&Code=%d", g_IsapiParams.ErrorUrl, EXCEEDED_MAX_THREAD_COUNT) == S_OK)
            {
                if (StringCbCat(FinalURL, sizeof FinalURL, ErrorText) != S_OK)
                {
                    LogEventWithString(
                        LOGLEVEL_ALWAYS,
                        ERR,
                        ISAPI_EVENT_ERROR,
                        "HttpExtensionProc() - ParseQueryString() succeeded (debug), StringCbCat failed\r\n"
                          "FinalURL: %s\r\n"
                          "ErrorText: %s",
                        FinalURL,
                        ErrorText
                    );

                    return HSE_STATUS_ERROR;
                }

                LogEventWithString(
                    LOGLEVEL_DEBUG,
                    SUCCESS,
                    ISAPI_EVENT_DEBUG,
                    "HttpExtensionProc() - ParseQueryString() succeeded (debug), StringCbPrintf succeeded\r\n"
                      "URL: %s\r\n"
                      "iType: %d\r\n"
                      "szType: %s\r\n"
                      "ErrorText: %s",
                    FileName,
                    iType,
                    szType,
                    FinalURL
                );

                // We want to write the response url to the client
                SendHttpHeaders( pECB, "200 OK", szHeader, FALSE );
                dwSize = (DWORD)strlen( FinalURL );
                pECB->WriteClient( pECB->ConnID, FinalURL, &dwSize, 0 );

                // TODO: add event logging if error
            }
            else
            {
                LogEventWithString(
                    LOGLEVEL_ALWAYS,
                    ERR,
                    ISAPI_EVENT_ERROR,
                    "HttpExtensionProc() - ParseQueryString() succeeded, StringCbPrintf failed\r\n"
                      "FinalURL: %s\r\n",
                    FinalURL
                );

                return HSE_STATUS_ERROR;
            }
        }
    }
    return HSE_STATUS_SUCCESS;
}


BOOL WINAPI
TerminateExtension(
    IN DWORD dwFlags
)
/*++

Routine Description:

    This function is called when the WWW service is shutdown.

Arguments:

    dwFlags - HSE_TERM_ADVISORY_UNLOAD or HSE_TERM_MUST_UNLOAD

Return Value:

    TRUE when extension is ready to be unloaded,

--*/
{
    LogEventWithString(LOGLEVEL_TRACE, INFO, ISAPI_EVENT_TRACE, "TerminateExtension()");

    //
    // wait for all threads to terminate, sleeping for 1 sec
    //

    DWORD dwSize = 0;
    if (dwFlags)
    {
        ;
    }
    while( g_dwThreadCount > 0 )
    {
        SleepEx( 1000, FALSE );
    }

    // Delete the critical sections

    DeleteCriticalSection(&SendCritSec);

    //
    // make sure the last thread indeed exited
    //
    SleepEx( 1000, FALSE );

    LogEvent(LOGLEVEL_ALWAYS, SUCCESS, ISAPI_EVENT_SUCCESS_EXITING, ISAPI_M_SUCCESS_EXITING);

    if (INVALID_HANDLE_VALUE != g_hEventSource)
    {
        DeregisterEventSource(g_hEventSource);
    }

    SetupEventLog(FALSE);
    //Disconnect from queue's and db if necessary.

    return TRUE;
}

BOOL GetRegData(PISAPIPARAMS    pParams)
/*++

Routine Description:

    This function is called when the WWW service is shutdown.

Arguments:

    dwFlags - HSE_TERM_ADVISORY_UNLOAD or HSE_TERM_MUST_UNLOAD

Return Value:

    TRUE when extension is ready to be unloaded,

--*/
{

    HKEY hHKLM;
    HKEY hExtensionKey;
    BYTE Buffer[MAX_PATH * sizeof wchar_t];
    DWORD Type;
    DWORD BufferSize = MAX_PATH * sizeof wchar_t;    // Set for largest value

    LogEventWithString(LOGLEVEL_TRACE, INFO, ISAPI_EVENT_TRACE, "GetRegData()");

    BOOL  Status = FALSE;

    if(!RegConnectRegistry(NULL, HKEY_LOCAL_MACHINE, &hHKLM))
    {
        if(!RegOpenKeyEx(hHKLM,_T("Software\\Microsoft\\OCA_EXTENSION"), 0, KEY_ALL_ACCESS, &hExtensionKey))
        {
            // Get the input queue directory path
            if (RegQueryValueExW(hExtensionKey,L"OutgoingQueue1", 0, &Type, Buffer, &BufferSize) != ERROR_SUCCESS)
            {
            //    LogEvent(_T("Failed to get InputQueue value from registry. Useing c:\\ as the default"));
                Status = FALSE;
                goto ERROR1;
            }
            else
            {
                if (StringCbCopyW (pParams->OutQueueConStr1,sizeof pParams->OutQueueConStr1, (wchar_t *) Buffer) != S_OK)
                {
                    Status = FALSE;
                    goto ERROR1;
                }
                BufferSize = MAX_PATH * sizeof wchar_t;
                ZeroMemory(Buffer, BufferSize);
            }
            // Get the input queue for full dumps
            if (RegQueryValueExW(hExtensionKey,L"OutgoingQueue2", 0, &Type, Buffer, &BufferSize) != ERROR_SUCCESS)
            {
            //    LogEvent(_T("Failed to get InputQueue value from registry. Useing c:\\ as the default"));
                Status = FALSE;
                goto ERROR1;
            }
            else
            {
                if (StringCbCopyW (pParams->OutQueueConStr2,sizeof pParams->OutQueueConStr2, (wchar_t *) Buffer) != S_OK)
                {
                    Status = FALSE;
                    goto ERROR1;
                }
                BufferSize = MAX_PATH * sizeof wchar_t;
                ZeroMemory(Buffer, BufferSize);
            }

            // Now get the Win2kDSN
            if ( RegQueryValueExW(hExtensionKey,L"IncommingQueue1", 0, &Type, Buffer, &BufferSize) != ERROR_SUCCESS )
            {
                Status = FALSE;
                goto ERROR1;
            }
            else
            {
                if (StringCbCopyW(pParams->InQueueConStr1,sizeof pParams->InQueueConStr1, (wchar_t *) Buffer) != S_OK)
                {
                    Status = FALSE;
                    goto ERROR1;
                }
                BufferSize = MAX_PATH * sizeof wchar_t;
                ZeroMemory(Buffer, BufferSize);

            }
            // Now get the Win2kDSN
            if ( RegQueryValueEx(hExtensionKey,"ManualUploadPath", 0, &Type, Buffer, &BufferSize) != ERROR_SUCCESS )
            {
                Status = FALSE;
                goto ERROR1;
            }
            else
            {
                if (StringCbCopy(pParams->ManualUploadPath,sizeof pParams->ManualUploadPath, (TCHAR*) Buffer) != S_OK)
                {
                    Status = FALSE;
                    goto ERROR1;
                }
                BufferSize = MAX_PATH * sizeof wchar_t;
                ZeroMemory(Buffer, BufferSize);

            }
                // Get the input queue directory path
        /*    if (RegQueryValueExW(hExtensionKey,L"OutgoingQueue2", 0, &Type, Buffer, &BufferSize) != ERROR_SUCCESS)
            {
            //    LogEvent(_T("Failed to get InputQueue value from registry. Useing c:\\ as the default"));
                Status = FALSE;
                goto ERROR1;
            }
            else
            {
                if (StringCbCopyW (pParams->OutQueueConStr2,sizeof pParams->OutQueueConStr2, (wchar_t *) Buffer) != S_OK)
                {
                    Status = FALSE;
                    goto ERROR1;
                }
                BufferSize = MAX_PATH * sizeof wchar_t;
                ZeroMemory(Buffer, BufferSize);
            }
*/
            // Now get the Win2kDSN
/*            if ( RegQueryValueExW(hExtensionKey,L"IncommingQueue2", 0, &Type, Buffer, &BufferSize))
            {
                Status = FALSE;
                goto ERROR1;
            }
            else
            {
                if (StringCbCopyW(pParams->InQueueConStr2,sizeof pParams->InQueueConStr2, (wchar_t *) Buffer) != S_OK)
                {
                    Status = FALSE;
                    goto ERROR1;
                }
                BufferSize = MAX_PATH * sizeof wchar_t;
                ZeroMemory(Buffer, BufferSize);

            }
*/            // Now get the Win2kDSN
            if ( RegQueryValueEx(hExtensionKey,_T("WatsonBaseDir"), 0, &Type, Buffer, &BufferSize))
            {
                Status = FALSE;
                goto ERROR1;
            }
            else
            {
                if (StringCbCopy(pParams->WatsonBaseDir,sizeof pParams->WatsonBaseDir, (TCHAR *) Buffer) != S_OK)
                {
                    Status = FALSE;
                    goto ERROR1;
                }
                BufferSize = MAX_PATH * sizeof wchar_t;
                ZeroMemory(Buffer, BufferSize);

            }

            if ( RegQueryValueEx(hExtensionKey,_T("LocalBaseDir"), 0, &Type, Buffer, &BufferSize))
            {
                Status = FALSE;
                goto ERROR1;
            }
            else
            {
                if (StringCbCopy(pParams->LocalBaseDir,sizeof pParams->LocalBaseDir,(TCHAR *) Buffer) != S_OK)
                {
                    Status = FALSE;
                    goto ERROR1;
                }
                BufferSize = MAX_PATH * sizeof wchar_t;
                ZeroMemory(Buffer, BufferSize);

            }

            if ( RegQueryValueEx(hExtensionKey,_T("LocalShareName"), 0, &Type, Buffer, &BufferSize))
            {
                Status = FALSE;

                goto ERROR1;
            }
            else
            {
                if (StringCbCopy(pParams->LocalShareName,sizeof pParams->LocalShareName, (TCHAR *) Buffer) != S_OK)
                {
                    Status = FALSE;
                    goto ERROR1;
                }
                BufferSize = MAX_PATH * sizeof wchar_t;
                ZeroMemory(Buffer, BufferSize);

            }


            if ( RegQueryValueEx(hExtensionKey,_T("MaxThreadCount"), 0, &Type, Buffer, &BufferSize))
            {
                Status = FALSE;
                goto ERROR1;
            }
            else
            {
                MaxThreadCount = *((long*)Buffer);
                BufferSize = MAX_PATH * sizeof wchar_t;
                ZeroMemory(Buffer, BufferSize);

            }

            if ( RegQueryValueEx(hExtensionKey,_T("AllowSR"), 0, &Type, Buffer, &BufferSize))
            {
                pParams->bAllowSR = FALSE;
            }
            else
            {
                pParams->bAllowSR = *((BOOL*)Buffer);
                BufferSize = MAX_PATH * sizeof wchar_t;
                ZeroMemory(Buffer, BufferSize);

            }

            if ( RegQueryValueEx(hExtensionKey,_T("Debug"), 0, &Type, Buffer, &BufferSize))
            {
                Status = FALSE;
                goto ERROR1;
            }
            else
            {
                g_dwDebugMode  = *((DWORD*)Buffer);
                BufferSize = MAX_PATH * sizeof wchar_t;
                ZeroMemory(Buffer, BufferSize);

            }
            if ( RegQueryValueEx(hExtensionKey,_T("ErrorUrl"), 0, &Type, Buffer, &BufferSize))
            {
                Status = FALSE;
                goto ERROR1;
            }
            else
            {
                if (StringCbCopy(g_IsapiParams.ErrorUrl,sizeof g_IsapiParams.ErrorUrl, (TCHAR *) Buffer) != S_OK)
                {
                    Status = FALSE;
                    goto ERROR1;
                }
                BufferSize = MAX_PATH * sizeof wchar_t;
                ZeroMemory(Buffer, BufferSize);

            }
            RegCloseKey(hExtensionKey);
            RegCloseKey(hHKLM);


            return TRUE;

        }
        else
        {
            RegCloseKey(hHKLM);
            return FALSE;
        }
    }
    else
    {
        return FALSE;
    }

ERROR1:
    if (hExtensionKey)
        RegCloseKey(hExtensionKey);
    if (hHKLM)
        RegCloseKey(hHKLM);

    LogEventWithString(LOGLEVEL_TRACE, INFO, ISAPI_EVENT_TRACE, "Exiting GetRegData()\r\nreturn value: %d", (int)Status);

    return Status;

}

BOOL SendQueueMessage(QUEUEHANDLE hOutgoingQueue, wchar_t *MessageGuid, wchar_t *FilePath)
{
    MQMSGPROPS      msgProps;
    MSGPROPID       aMsgPropId[NUMBEROFPROPERTIES];
    MQPROPVARIANT   aMsgPropVar[NUMBEROFPROPERTIES];
    HRESULT         aMsgStatus[NUMBEROFPROPERTIES];
    DWORD           cPropId = 0;
    BOOL            Status = TRUE;
    HRESULT         hResult = S_OK;
    char            szGuid[512];
    char            szPath[512];


    LogEventWithString(LOGLEVEL_TRACE, INFO, ISAPI_EVENT_TRACE, "SendQueueMessage()");

    if ( (!MessageGuid ) || (!FilePath))
    {
        wcstombs( szGuid, MessageGuid, sizeof(MessageGuid)/sizeof(MessageGuid[0]) );
        wcstombs( szPath, FilePath, sizeof(FilePath)/sizeof(FilePath[0]) );

        LogEvent(
            LOGLEVEL_ALWAYS,
            ERR,
            ISAPI_EVENT_ERROR_INVALID_SEND_PARAMS,
            ISAPI_M_ERROR_INVALID_SEND_PARAMS,
            (MessageGuid != NULL) ? szGuid : _T(""),
            (FilePath != NULL) ? szPath : _T("")
        );

        Status = FALSE;
    }
    else
    {
        aMsgPropId [cPropId]         = PROPID_M_LABEL;   // Property ID.
        aMsgPropVar[cPropId].vt      = VT_LPWSTR;        // Type indicator.
        aMsgPropVar[cPropId].pwszVal =  MessageGuid;     // The message label.
        cPropId++;

        aMsgPropId [cPropId]         = PROPID_M_BODY;
        aMsgPropVar [cPropId].vt     = VT_VECTOR|VT_UI1;
        aMsgPropVar [cPropId].caub.pElems = (LPBYTE) FilePath;
        aMsgPropVar [cPropId].caub.cElems = (DWORD) wcslen(FilePath)* 2;
        cPropId++;

        aMsgPropId [cPropId]         = PROPID_M_BODY_TYPE;
        aMsgPropVar[cPropId].vt      = VT_UI4;
        aMsgPropVar[cPropId].ulVal   = (DWORD) VT_BSTR;

        cPropId++;

        // Initialize the MQMSGPROPS structure.
        msgProps.cProp      = cPropId;
        msgProps.aPropID    = aMsgPropId;
        msgProps.aPropVar   = aMsgPropVar;
        msgProps.aStatus    = aMsgStatus;

        //
        // Send it
        //
        hResult = MQSendMessage(
                         hOutgoingQueue,                  // Queue handle.
                         &msgProps,                       // Message property structure.
                         MQ_NO_TRANSACTION                // No transaction.
                         );

        if (FAILED(hResult))
        {
            wcstombs(szGuid,MessageGuid, wcslen(MessageGuid) *2);
            wcstombs(szPath,FilePath, wcslen(FilePath) *2);
            LogEvent(
                LOGLEVEL_ALWAYS,
                ERR,
                ISAPI_EVENT_ERROR_CANNOT_SEND,
                ISAPI_M_ERROR_CANNOT_SEND,
                szGuid,
                szPath,
                hResult
            );

            Status = FALSE;
        }
    }

    LogEventWithString(
        LOGLEVEL_TRACE,
        INFO,
        ISAPI_EVENT_TRACE,
        "Exiting SendQueueMessage()\r\n"
          "return value: %d",
        (int)Status
    );

    return Status;

}

unsigned int __stdcall
WorkerFunction(
    void *vECB
)
/*++

Purpose:

    This Function performs all of the Message queueing for realtime processing
    with out tying up the IIS process threads.

Arguments:

    vECB - points to current extension control block

Returns:

    returns 0

--*/
{

    char szHeader[] =   "Content-type: text/html\r\n\r\n";
    EXTENSION_CONTROL_BLOCK *pECB;
    HRESULT     hResult = S_OK;
    GUID        MessageGuid;
    TCHAR       DestinationDir[MAX_PATH];
    TCHAR      *pQueryString = NULL;
    TCHAR      *pFname = NULL;
    TCHAR       CurrentFileName[MAX_PATH];
    TCHAR       SourceDir[MAX_PATH];
    HANDLE      hToken = INVALID_HANDLE_VALUE;
    wchar_t     wszMessageGuid[100];
    TCHAR       szMessageGuid[200];
    wchar_t    *szTempMessageGuid = NULL;
    DWORD       dwSize = 0;
    wchar_t     DestinationPath[MAX_PATH];
    wchar_t     RecMessageBody[255];
    TCHAR       szRecMessageBody[255];
    UINT        RetryCount = 0;
    BOOL        Status = TRUE;
    BOOL        bReadFromPrimary = TRUE;
    int         ErrorCode = 0;
    TCHAR      *temp = NULL;
    TCHAR       RedirURL[MAX_PATH];
    DWORD       dwDestSize = 0;
    TCHAR       szType[10];
    TCHAR       szSR[50];
    int         iCharCount = 0;
    TCHAR      *pType = NULL;
    int         iType = 1;
    TCHAR       FinalURL[MAX_PATH];
    int         iState = 0;
    wchar_t    *temp2 = NULL;
    HANDLE      hManualFile = INVALID_HANDLE_VALUE;
    TCHAR       TestDestination[MAX_PATH];
    DWORD       CharCount = 0;
    TCHAR       ErrorText[255];
    TCHAR       PerfText[MAX_PATH];
    // Recieve message vars
    MSGPROPID      PropIds[5];
    MQPROPVARIANT  PropVariants[5];
    HRESULT        hrProps[5];
    MQMSGPROPS     MessageProps;
    DWORD          i = 0;
    wchar_t RecLabel[100];
    wchar_t LocalRecBody[255];
    DWORD   RecMessageBodySize = sizeof LocalRecBody;
    DWORD   RecLabelLength     = sizeof RecLabel;
    HANDLE  hCursor            = INVALID_HANDLE_VALUE;
    BOOL    MessageFound       = FALSE;
    time_t  Start;
    time_t  Stop;
    DWORD   StartSendQueue = 0, StopSendQueue = 0;
    DWORD   StartRecvQueue = 0, StopRecvQueue = 0;
    DWORD   StartThread= 0, StopThread = 0;
    DWORD   ElapsedTimeThread = 0, ElapsedTimeSendQueue = 0, ElapsedTimeRecvQueue;
    BOOL    CursorValid        = FALSE;
    BOOL    fFullDump          = FALSE;

    StartThread = GetTickCount();

    // Queue Handles
    QUEUEHANDLE hPrimaryInQueue = NULL;
    QUEUEHANDLE hPrimaryOutQueue = NULL;
//    QUEUEHANDLE hSecondaryInQueue = NULL;
//    QUEUEHANDLE hSecondaryOutQueue = NULL;


    LogEventWithString(
        LOGLEVEL_DEBUG,
        INFO,
        ISAPI_EVENT_DEBUG,
        "WorkerFunction()\r\n"
          "Last Error: %08x\r\n"
          "TID: %ld\r\n",
        GetLastError(),
        GetCurrentThreadId()
    );

    // Clear the strings
    ZeroMemory(DestinationPath, sizeof DestinationPath);
    ZeroMemory(RecMessageBody,  sizeof RecMessageBody);
    ZeroMemory(szMessageGuid,   sizeof szMessageGuid);
    ZeroMemory(RedirURL,        sizeof RedirURL);
    ZeroMemory(FinalURL,        sizeof FinalURL);
    ZeroMemory(wszMessageGuid,  sizeof wszMessageGuid);
    ZeroMemory(DestinationDir,  sizeof DestinationDir);
    ZeroMemory(TestDestination, sizeof TestDestination);
    ZeroMemory(ErrorText,       sizeof ErrorText);
    ZeroMemory(PerfText,        sizeof PerfText);
    ZeroMemory(CurrentFileName, sizeof CurrentFileName);
    ZeroMemory(SourceDir,       sizeof SourceDir);
    ZeroMemory(szRecMessageBody, sizeof szRecMessageBody);
    ZeroMemory(szType,          sizeof szType);

    //
    // Initialize local ECB pointer to void pointer passed to thread
    //


    LogEventWithString(
        LOGLEVEL_DEBUG,
        INFO,
        ISAPI_EVENT_DEBUG,
        "WorkerFunction()\r\n"
          "Calling pECB->ServerSupportFunction\r\n"
          "Last Error: %08lx",
        GetLastError()
    );

    pECB = (EXTENSION_CONTROL_BLOCK *)vECB;
    Status = pECB->ServerSupportFunction(
                                pECB->ConnID,
                                HSE_REQ_GET_IMPERSONATION_TOKEN,
                                &hToken,
                                NULL,
                                NULL
                                );

    LogEventWithString(
        LOGLEVEL_DEBUG,
        INFO,
        ISAPI_EVENT_DEBUG,
        "WorkerFunction()\r\n"
          "Called pECB->ServerSupportFunction\r\n"
          "Status: %d\r\n"
          "hToken: %08x\r\n"
          "Last Error: %08lx",
        Status,
        (DWORD_PTR)hToken,
        GetLastError()
    );

    // TODO: handle error if returned

    if ( !ImpersonateLoggedOnUser(hToken))
    {
        // We failed to impersonate the user. We Cannot continue.

        LogEvent(
            LOGLEVEL_ALWAYS,
            ERR,
            ISAPI_EVENT_ERROR_CANT_IMPERSONATE,
            ISAPI_M_ERROR_CANT_IMPERSONATE,
            GetLastError()
        );

        if (StringCbPrintf(ErrorText,sizeof ErrorText,_T("&Code=%d"), FAILED_TO_IMPERSONATE_USER) != S_OK)
        {
            LogEventWithString(
                LOGLEVEL_ALWAYS,
                ERR,
                ISAPI_EVENT_ERROR,
                "WorkerFunction() - StringCbPrintf() failed\r\n"
                  "hToken: %08x\r\n",
                (DWORD_PTR)hToken
            );
        }

        goto ERRORS;
    }


    //
    //Get filename from parameter list.
    //

    ZeroMemory (CurrentFileName,sizeof CurrentFileName);

    //
    // Get the file name from the query string.
    //

    if ( (!ParseQueryString(pECB, CurrentFileName, sizeof(CurrentFileName), &iType,
                            szType, sizeof(szType),
                            szSR, sizeof(szSR)) ))
    {
        LogEventWithString(
            LOGLEVEL_ALWAYS,
            WARN,
            ISAPI_EVENT_WARNING,
            "WorkerFunction() - ParseQueryString() failed\r\n"
              "CurrentFileName: %s\r\n"
              "iType: %d\r\n"
              "szType%s",
            CurrentFileName,
            iType,
            szType
        );

        if (StringCbPrintf(ErrorText,sizeof ErrorText,_T("&Code=%d"),FAILED_TO_PARSE_QUERYSTRING ) != S_OK)
        {
            LogEventWithString(
                LOGLEVEL_ALWAYS,
                ERR,
                ISAPI_EVENT_ERROR,
                "WorkerFunction() - StringCbPrintf() failed"
            );
        }

        goto ERRORS;
    }

    LogEventWithString(
        LOGLEVEL_DEBUG,
        INFO,
        ISAPI_EVENT_DEBUG,
        "WorkerFunction() - ParseQueryString() succeeded\r\n"
          "CurrentFileName: %s\r\n"
          "iType: %d\r\n"
          "szType%s",
        CurrentFileName,
        iType,
        szType
    );

    //
    // Copy File Localy
    // Note this needs to be removed when the client uploads the file
    //        Directly to our servers.
    //

    // build the source file name.

    switch (iType)
    {
    case CiSrcErClient:
        if (StringCbPrintf(SourceDir,sizeof SourceDir, _T("%s\\%s"), g_IsapiParams.WatsonBaseDir, CurrentFileName) != S_OK)
        {
            LogEventWithString(
                LOGLEVEL_ALWAYS,
                ERR,
                ISAPI_EVENT_ERROR,
                "WorkerFunction() - StringCbPrintf() failed"
            );

            Status = FALSE;
            goto  ERRORS;
        }
      /*  if (StringCbPrintf(DestinationDir,sizeof DestinationDir, _T("%s\\%s"), g_IsapiParams.LocalBaseDir,CurrentFileName) != S_OK)
        {
            LogEventWithString(
                LOGLEVEL_ALWAYS,
                ERR,
                ISAPI_EVENT_ERROR,
                "WorkerFunction() - StringCbPrintf() failed"
            );

            Status = FALSE;
            goto ERRORS;
        }
        */
        break;
    case CiSrcManualFullDump:

        fFullDump = TRUE;
        iType = CiSrcManual;
        if (StringCbPrintf(szType, sizeof(szType), _T(";%ld"), iType) != S_OK)
        {
            // Failure is harmless, debugger will consider these 2 types as the same
            iType = CiSrcManualFullDump;
        }
        // fall through

    case CiSrcCER:
    case CiSrcManual:
    case CiSrcStress:
        break;

    case CiSrcManualPssSr:
        fFullDump = TRUE; // we want to process these same way as fulldumps
        break;

    default: // invalid type specified
        if (StringCbPrintf(ErrorText,sizeof ErrorText,_T("&Code=%d"),INVALID_TYPE_SPECIFIED) != S_OK)
        {
            LogEventWithString(
                LOGLEVEL_ALWAYS,
                ERR,
                ISAPI_EVENT_ERROR,
                "WorkerFunction() - StringCbPrintf() failed"
            );
        }

        LogEventWithString(
            LOGLEVEL_DEBUG,
            ERR,
            ISAPI_EVENT_DEBUG,
            "WorkerFunction() - unknown iType specified\r\n"
              "iType: %d",
            iType
        );
        goto ERRORS;
    }


    // Now change the date file name \ to an _ note this only works for the date\filename format

   /* if ((iType != 5) && (iType != 6))
    {
        dwDestSize = (DWORD) _tcslen(DestinationDir);
        if (dwDestSize >0)
        {
            temp = DestinationDir + _tcslen(DestinationDir);
            while ((*temp != '\\') && (*temp != '/'))
                -- temp;
            if ((*temp == '\\') || (*temp == '/'))
                *temp = '_';
        }
        else
        {
            LogEventWithString(
                LOGLEVEL_DEBUG,
                ERR,
                ISAPI_EVENT_DEBUG,
                "WorkerFunction() - dwDestSize = 0"
            );

            Status = FALSE;
            goto ERRORS;
        }

        if (!CopyFile (SourceDir, DestinationDir, FALSE) )
        {
            if (StringCbPrintf(ErrorText,sizeof ErrorText,_T("&Code=%d"),FAILED_TO_COPY_FILE) != S_OK)
                {
                    LogEventWithString(
                        LOGLEVEL_ALWAYS,
                        ERR,
                        ISAPI_EVENT_ERROR,
                        "WorkerFunction() - StringCbPrintf() failed"
                    );
                }
            LogEvent(LOGLEVEL_ALWAYS, WARN, ISAPI_EVENT_WARNING_FILE_COPY_FAILED, ISAPI_M_WARNING_FILE_COPY_FAILED, SourceDir, DestinationDir, GetLastError());
            Status = FALSE;
            goto  ERRORS;
        }
    }
    */
    //ZeroMemory (DestinationDir, sizeof DestinationDir);
/*
    if ((iType != 5) && (iType != 6))
        {
        if (_tcslen(CurrentFileName) > 0)
        {
            temp = CurrentFileName + _tcslen(CurrentFileName);
            while ( (*temp != '\\') && (*temp != '/') && (temp!= CurrentFileName) )
                -- temp;

            if ((*temp == '\\') || (*temp == '/'))
                *temp = '_';
        }

        else
        {
            LogEventWithString(
                LOGLEVEL_DEBUG,
                ERR,
                ISAPI_EVENT_DEBUG,
                "WorkerFunction() - _tcslen(CurrentFileName) = 0"
            );

            Status = FALSE;
            goto ERRORS;
        }
    }
    */
    switch (iType)
    {
    case CiSrcErClient:


        if (StringCbPrintf(DestinationDir, sizeof DestinationDir, _T("%s\\%s%s"), g_IsapiParams.WatsonBaseDir, CurrentFileName,szType)!= S_OK)
        {
            LogEventWithString(
                LOGLEVEL_DEBUG,
                ERR,
                ISAPI_EVENT_DEBUG,
                "WorkerFunction() - StringCbPrintf failed"
            );

            Status = FALSE;
            goto  ERRORS;
        }

        break;
    case CiSrcManualFullDump: // Same as 5 but a full dump, send it off to a separate Q dedicated to fulldumps
        iType = CiSrcManual;
        // fall through
    case CiSrcManualPssSr:
        fFullDump = TRUE;
        // fall through
    case CiSrcCER:
    case CiSrcManual:
    case CiSrcStress:

        if ((iType == CiSrcManualPssSr) && g_IsapiParams.bAllowSR)
        {
            hResult = StringCbPrintf(DestinationDir, sizeof DestinationDir, _T("%s\\%s%s;%s"),
                                     g_IsapiParams.ManualUploadPath,CurrentFileName,szType,szSR);
        } else
        {
            hResult = StringCbPrintf(DestinationDir, sizeof DestinationDir, _T("%s\\%s%s"),
                                     g_IsapiParams.ManualUploadPath,CurrentFileName,szType);
        }
        if (hResult != S_OK)
        {
            LogEventWithString(
                LOGLEVEL_DEBUG,
                ERR,
                ISAPI_EVENT_DEBUG,
                "WorkerFunction() - StringCbPrintf failed"
            );

            Status = FALSE;
            goto  ERRORS;
        }
        else
        {
            // Check to see if the file exists
            //
            if (StringCbPrintf(TestDestination, sizeof TestDestination,_T("%s\\%s"), g_IsapiParams.ManualUploadPath,CurrentFileName)== S_OK)
            {
                hManualFile = CreateFile(TestDestination,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
                if (hManualFile == INVALID_HANDLE_VALUE)
                {
                    if (StringCbPrintf(ErrorText,sizeof ErrorText,_T("&Code=%d"),FILE_NOT_FOUND) != S_OK)
                    {
                        LogEventWithString(
                            LOGLEVEL_DEBUG,
                            ERR,
                            ISAPI_EVENT_DEBUG,
                            "WorkerFunction() - StringCbPrintf failed"
                        );
                    }
                    LogEvent(LOGLEVEL_ALWAYS, WARN, ISAPI_EVENT_WARNING_FILE_MISSING, ISAPI_M_WARNING_FILE_MISSING, TestDestination);
                    Status = FALSE;
                    goto ERRORS;
                }
                else
                {
                    CloseHandle(hManualFile);
                }
            }
            else
            {
                LogEventWithString(
                    LOGLEVEL_DEBUG,
                    ERR,
                    ISAPI_EVENT_DEBUG,
                    "WorkerFunction() - StringCbPrintf failed"
                );

                Status = FALSE;
                goto ERRORS;
            }
        }
        break;
#ifdef USE_OLD_STRESS_SOURCE
    case 6:
        if (StringCbPrintf(DestinationDir, sizeof DestinationDir, _T("%s%s"), CurrentFileName,szType)!= S_OK)
        {
            LogEventWithString(
                LOGLEVEL_DEBUG,
                ERR,
                ISAPI_EVENT_DEBUG,
                "WorkerFunction() - StringCbPrintf failed"
            );

            Status = FALSE;
            goto  ERRORS;
        }
        else
        {
            hManualFile = CreateFile(TestDestination,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);
            if (hManualFile == INVALID_HANDLE_VALUE)
            {
                if (StringCbPrintf(ErrorText,sizeof ErrorText,_T("&Code=%d"),FILE_NOT_FOUND) != S_OK)
                {
                    LogEventWithString(
                        LOGLEVEL_DEBUG,
                        ERR,
                        ISAPI_EVENT_DEBUG,
                        "WorkerFunction() - StringCbPrintf failed"
                    );
                }
                LogEvent(LOGLEVEL_ALWAYS, WARN, ISAPI_EVENT_WARNING_FILE_MISSING, ISAPI_M_WARNING_FILE_MISSING, TestDestination);
                Status = FALSE;
                goto ERRORS;
            }
            else
            {
                CloseHandle(hManualFile);
            }
        }
        break;
#endif // USE_OLD_STRESS_SOURCE
    default: // Invalid Type
        LogEventWithString(
            LOGLEVEL_DEBUG,
            ERR,
            ISAPI_EVENT_DEBUG,
            "WorkerFunction() - unknown iType specified\r\n"
              "iType: %d",
            iType
        );

        goto ERRORS;
    }
    ZeroMemory (DestinationPath, sizeof DestinationPath);
    mbstowcs(DestinationPath,DestinationDir,_tcslen(DestinationDir));


    //
    // Generate Guid for this message
    //
    hResult = CoCreateGuid(&MessageGuid);
    if (FAILED(hResult))
    {
        if (StringCbPrintf(ErrorText,sizeof ErrorText,_T("&Code=%d"),FAILED_TO_CREATE_GUID) != S_OK)
        {
            LogEventWithString(
                LOGLEVEL_ALWAYS,
                ERR,
                ISAPI_EVENT_ERROR,
                "WorkerFunction() - StringCbPrintf failed"
            );
        }

        LogEventWithString(
            LOGLEVEL_ALWAYS,
            ERR,
            ISAPI_EVENT_ERROR,
            "WorkerFunction() - CoCreateGuid failed\r\n"
              "hResult: %08x",
            hResult
        );

        goto ERRORS;
    }
    else
    {
        hResult = UuidToStringW(&MessageGuid, &szTempMessageGuid);
        if (hResult == RPC_S_OK)
        {
            // Make a copy of the string quid then release it.
            if (StringCbCopyW(wszMessageGuid,sizeof wszMessageGuid, szTempMessageGuid) != S_OK)
            {
                LogEvent(LOGLEVEL_ALWAYS, ERR, ISAPI_EVENT_ERROR_GUID_COPY, ISAPI_M_ERROR_GUID_COPY, szTempMessageGuid, wszMessageGuid, GetLastError());
                goto ERRORS;
            }

        }
        else
        {
            LogEventWithString(
                LOGLEVEL_ALWAYS,
                ERR,
                ISAPI_EVENT_ERROR,
                "WorkerFunction() - UuidToStringW failed\r\n"
                  "hResult: %08x\r\n"
                  "szTempMessageGuid: %s",
                hResult,
                szTempMessageGuid
            );

            // TODO: goto ERRORS?
        }

    }
    //EnterCriticalSection(&SendCritSec);

    StartSendQueue = GetTickCount();

    // if connect to primary Receive
    hResult =  MQOpenQueue(g_IsapiParams.InQueueConStr1,
                         MQ_RECEIVE_ACCESS,
                         MQ_DENY_NONE,
                         &hPrimaryInQueue);
    if (SUCCEEDED(hResult))
    {

        hResult = MQOpenQueue( (fFullDump ? g_IsapiParams.OutQueueConStr2 : g_IsapiParams.OutQueueConStr1),
                             MQ_SEND_ACCESS,
                             MQ_DENY_NONE,
                             &hPrimaryOutQueue);
        if (SUCCEEDED(hResult))
        {
            EnterCriticalSection(&SendCritSec);
            if( SendQueueMessage(hPrimaryOutQueue, wszMessageGuid, DestinationPath))
            {
                LogEventWithString(
                    LOGLEVEL_TRACE,
                    SUCCESS,
                    ISAPI_EVENT_TRACE,
                    "WorkerFunction() - SendQueueMessage() succeeded - using PrimaryOutQueue\r\n"
                      "hPrimaryOutQueue: %08x\r\n"
                      "wszMessageGuid: %s\r\n"
                      "DestinationPath: %s",
                    (DWORD_PTR)hPrimaryOutQueue,
                    wszMessageGuid,
                    DestinationPath
                );

                LeaveCriticalSection(&SendCritSec);
                bReadFromPrimary = TRUE;
                MQCloseQueue(hPrimaryOutQueue);
                hPrimaryOutQueue = NULL;
            }
            else
            {
                LeaveCriticalSection(&SendCritSec);

                LogEventWithString(
                    LOGLEVEL_DEBUG,
                    ERR,
                    ISAPI_EVENT_DEBUG,
                    "WorkerFunction() - SendQueueMessage() failed\r\n"
                      "hPrimaryOutQueue: %08x\r\n"
                      "wszMessageGuid: %s\r\n"
                      "DestinationPath: %s",
                    (DWORD_PTR)hPrimaryOutQueue,
                    wszMessageGuid,
                    DestinationPath
                );

                MQCloseQueue(hPrimaryInQueue);
                MQCloseQueue(hPrimaryOutQueue);
                goto ERRORS;

                // This block is commented out because each web server now only has 1 message queue

                /*
                hResult =  MQOpenQueue(g_IsapiParams.InQueueConStr2,
                                         MQ_RECEIVE_ACCESS,
                                         MQ_DENY_NONE,
                                         &hPrimaryInQueue);
                if (SUCCEEDED(hResult))
                {
                    hResult =  MQOpenQueue(g_IsapiParams.OutQueueConStr2,
                                             MQ_SEND_ACCESS,
                                             MQ_DENY_NONE,
                                             &hSecondaryInQueue);
                    if (SUCCEEDED(hResult))
                    {
                        EnterCriticalSection(&SendCritSec);
                        if( SendQueueMessage(hSecondaryOutQueue, wszMessageGuid, DestinationPath))
                        {
                            LeaveCriticalSection(&SendCritSec);
                            bReadFromPrimary = FALSE;
                            MQCloseQueue(hPrimaryOutQueue);
                            hPrimaryOutQueue = NULL;
                        }
                        else
                        {
                            LeaveCriticalSection(&SendCritSec);
                            MQCloseQueue(hSecondaryInQueue);
                            MQCloseQueue(hSecondaryOutQueue);
                            hSecondaryInQueue = NULL;
                            hSecondaryOutQueue = NULL;
                            goto ERRORS;
                        }

                    }
                    else
                    {
                        MQCloseQueue(hSecondaryInQueue);
                        hSecondaryInQueue = NULL;
                        goto ERRORS;
                    }
                }
                else
                {

                    goto ERRORS;
                }
                */
            }
        }
        else // MQOpenQueue(g_IsapiParams.OutQueueConStr1,
        {
            LogEventWithString(
                LOGLEVEL_ALWAYS,
                ERR,
                ISAPI_EVENT_ERROR,
                "WorkerFunction() - MQOpenQueue(g_IsapiParams.OutQueueConStr1 ...) failed"
                  "hResult: %08x",
                hResult
            );

            // This block is commented out because each web server now only has 1 message queue
        /*    MQCloseQueue(hPrimaryInQueue);
            hResult =  MQOpenQueue(g_IsapiParams.InQueueConStr2,
                                         MQ_RECEIVE_ACCESS,
                                         MQ_DENY_NONE,
                                         &hPrimaryInQueue);
            if (SUCCEEDED(hResult))
            {
                hResult =  MQOpenQueue(g_IsapiParams.OutQueueConStr2,
                                         MQ_SEND_ACCESS,
                                         MQ_DENY_NONE,
                                         &hSecondaryInQueue);
                if (SUCCEEDED(hResult))
                {
                    EnterCriticalSection(&SendCritSec);
                    if( SendQueueMessage(hSecondaryOutQueue, wszMessageGuid, DestinationPath))
                    {
                        LeaveCriticalSection(&SendCritSec);
                        bReadFromPrimary = FALSE;
                        MQCloseQueue(hPrimaryOutQueue);
                        hPrimaryOutQueue = NULL;
                    }
                    else
                    {
                        LeaveCriticalSection(&SendCritSec);
                        MQCloseQueue(hSecondaryInQueue);
                        MQCloseQueue(hSecondaryOutQueue);
                        hSecondaryInQueue = NULL;
                        hSecondaryOutQueue = NULL;
                        goto ERRORS;
                    }

                }
                else
                {
                    MQCloseQueue(hSecondaryInQueue);
                    hSecondaryInQueue = NULL;
                    goto ERRORS;
                }


            }
            else
            {

                goto ERRORS;
            }
            */
            goto ERRORS;
        }
    }
    else // MQOpenQueue(g_IsapiParams.InQueueConStr1,
    {
        LogEventWithString(
            LOGLEVEL_ALWAYS,
            ERR,
            ISAPI_EVENT_ERROR,
            "WorkerFunction() - MQOpenQueue(g_IsapiParams.InQueueConStr1 ...) failed"
              "hResult: %08x",
            hResult
        );

        // This block is commented out because each web server now only has 1 message queue

    /*    hResult =  MQOpenQueue(g_IsapiParams.InQueueConStr2,
                                         MQ_RECEIVE_ACCESS,
                                         MQ_DENY_NONE,
                                         &hPrimaryInQueue);
        if (SUCCEEDED(hResult))
        {
            hResult =  MQOpenQueue(g_IsapiParams.OutQueueConStr2,
                                     MQ_SEND_ACCESS,
                                     MQ_DENY_NONE,
                                     &hSecondaryInQueue);
            if (SUCCEEDED(hResult))
            {
                EnterCriticalSection(&SendCritSec);
                if( SendQueueMessage(hSecondaryOutQueue, wszMessageGuid, DestinationPath))
                {
                    LeaveCriticalSection(&SendCritSec);
                    bReadFromPrimary = FALSE;
                    MQCloseQueue(hPrimaryOutQueue);
                    hPrimaryOutQueue = NULL;
                }
                else
                {
                    LeaveCriticalSection(&SendCritSec);
                    MQCloseQueue(hSecondaryInQueue);
                    MQCloseQueue(hSecondaryOutQueue);
                    hSecondaryInQueue = NULL;
                    hSecondaryOutQueue = NULL;
                    goto ERRORS;
                }
            }
            else
            {
                MQCloseQueue(hSecondaryInQueue);
                hSecondaryInQueue = NULL;
                goto ERRORS;
            }
        }
        else
        {

            goto ERRORS;
        }
        */
        goto ERRORS;
    }

    StopSendQueue = GetTickCount();

//-------------------------------------------------------------------------------------------------
// Recieve the response from kd
//-------------------------------------------------------------------------------------------------

    Sleep(1000); // give kd a chance to process the message.
    Status = FALSE;

    ZeroMemory(LocalRecBody,sizeof LocalRecBody);
    ZeroMemory(RecLabel,sizeof RecLabel);

    i = 0;
    PropIds[i] = PROPID_M_LABEL_LEN;
    PropVariants[i].vt = VT_UI4;
    PropVariants[i].ulVal = RecLabelLength;
    i++;

    PropIds[i] = PROPID_M_LABEL;
    PropVariants[i].vt = VT_LPWSTR;
    PropVariants[i].pwszVal = RecLabel;
    i++;

    MessageProps.aPropID = PropIds;
    MessageProps.aPropVar = PropVariants;
    MessageProps.aStatus = hrProps;
    MessageProps.cProp = i;
    double TotalElapsedTime = 0.0;


    StartRecvQueue = GetTickCount();

    if ( (hResult = MQCreateCursor( /*(bReadFromPrimary == TRUE) ? */hPrimaryInQueue ,//: hSecondaryInQueue,
                                    &hCursor))
                                    != S_OK)
    {
        if (StringCbPrintf(ErrorText,sizeof ErrorText,_T("&Code=%d"), FAILED_TO_CREATE_CURSOR)!= S_OK)
        {
            LogEventWithString(
                LOGLEVEL_ALWAYS,
                ERR,
                ISAPI_EVENT_ERROR,
                "WorkerFunction() - StringCbPrintf failed"
            );
        }

        LogEvent(
            LOGLEVEL_ALWAYS,
            ERR,
            ISAPI_EVENT_ERROR_CANNOT_CREATE_RECEIVE_CURSOR,
            ISAPI_M_ERROR_CANNOT_CREATE_RECEIVE_CURSOR,
            hResult,
            (DWORD_PTR)hCursor
        );

        Status = FALSE;
    goto ERRORS;
    }
    else
    {

        do {
            CursorValid = TRUE;
        //    dwSize = _tcslen(_T("Starting Scan <BR>"));
        //    pECB->WriteClient(pECB->ConnID,_T("Starting Scan <BR>"),&dwSize,0);
                // Peak at each member of the queue and return the label.
            time(&Start);
            hResult = MQReceiveMessage(/*(bReadFromPrimary == TRUE) ? */hPrimaryInQueue,// : hSecondaryInQueue,       // Queue handle.
                                20000,                         // Maximum time (msec) to read the message.
                                MQ_ACTION_PEEK_CURRENT,       // Receive action.
                                &MessageProps,                // Message property structure.
                                NULL,                         // No OVERLAPPED structure.
                                NULL,                         // No callback function.
                                hCursor,                      // Cursor handle.
                                NULL                          // No transaction.
                            );


            time(&Stop);
            TotalElapsedTime+= difftime(Stop,Start);
            if (hResult == S_OK)
            {
                MessageFound = FALSE;

                // There is a message in the queue.
                // now see if it is the one we want.
                // if the message was found retrieve it.
                // Otherwise close the cursor and return false.
                do
                {
                    if (! _wcsicmp(RecLabel,wszMessageGuid))
                    {
                        MessageFound = TRUE;
                    }
                    else
                    {

                        // Not it Lets peek at the next one
                        time(&Start);
                        PropVariants[i].ulVal = RecLabelLength;           // Reset the label buffer size.
                        hResult = MQReceiveMessage(/*(bReadFromPrimary == TRUE) ?*/ hPrimaryInQueue,// : hSecondaryInQueue,            // Queue handle.
                                            ((DWORD)(20.0 - TotalElapsedTime)) * 1000,      // Maximum time (msec).
                                            MQ_ACTION_PEEK_NEXT,       // Receive action.
                                            &MessageProps,             // Message property structure.
                                            NULL,                      // No OVERLAPPED structure.
                                            NULL,                      // No callback function.
                                            hCursor,                   // Cursor handle.
                                            NULL                       // No transaction.
                                            );
                        time(&Stop);
                        TotalElapsedTime += difftime(Stop, Start);

                        LogEventWithString(
                            LOGLEVEL_DEBUG,
                            ERR,
                            ISAPI_EVENT_DEBUG,
                            "WorkerFunction() - MQReceiveMessage(hPrimaryInQueue ...) failed (peek)\r\n"
                              "hResult: %08x",
                            hResult
                        );

                    }

                } while ( (!MessageFound ) && (hResult == S_OK) && (TotalElapsedTime < 20.0));
                if (!MessageFound)
                {
                    Status = FALSE;
                }

                if (MessageFound)
                {
                    // retrieve the current message
                    i = 0;
                    PropIds[i] = PROPID_M_LABEL_LEN;
                    PropVariants[i].vt = VT_UI4;
                    PropVariants[i].ulVal = RecLabelLength;
                    i++;

                    PropIds[i] = PROPID_M_LABEL;
                    PropVariants[i].vt = VT_LPWSTR;
                    PropVariants[i].pwszVal = RecLabel;

                    i++;
                    PropIds[i] = PROPID_M_BODY_SIZE;
                    PropVariants[i].vt = VT_UI4;

                    i++;
                    PropIds[i] = PROPID_M_BODY_TYPE;
                    PropVariants[i].vt = VT_UI4;

                    i++;
                    PropIds[i] = PROPID_M_BODY;
                    PropVariants[i].vt = VT_VECTOR|VT_UI1;
                    PropVariants[i].caub.pElems = (LPBYTE) LocalRecBody;
                    PropVariants[i].caub.cElems = RecMessageBodySize;

                    i++;

                    MessageProps.aPropID = PropIds;
                    MessageProps.aPropVar = PropVariants;
                    MessageProps.aStatus = hrProps;
                    MessageProps.cProp = i;

                    hResult = MQReceiveMessage(/*(bReadFromPrimary == TRUE) ? */hPrimaryInQueue,// : hSecondaryInQueue,
                                                0,
                                                MQ_ACTION_RECEIVE,
                                                &MessageProps,
                                                NULL,
                                                NULL,
                                                hCursor,
                                                MQ_NO_TRANSACTION);

                    if (FAILED (hResult) )
                    {
                        LogEventWithString(
                            LOGLEVEL_DEBUG,
                            ERR,
                            ISAPI_EVENT_DEBUG,
                            "WorkerFunction() - MQReceiveMessage(hPrimaryInQueue ...) failed (receive)\r\n"
                              "hResult: %08x",
                            hResult
                        );

                        Status = FALSE;
                    }
                    else
                    {
                        hResult = StringCbCopyW(RecMessageBody,  RecMessageBodySize, LocalRecBody);
                        Status = TRUE;
                    }
                }
                else
                {
                    Status = FALSE;
                }
            }
            else
            {
                LogEventWithString(
                    LOGLEVEL_DEBUG,
                    ERR,
                    ISAPI_EVENT_DEBUG,
                    "WorkerFunction() - MQReceiveMessage(hSecondaryInQueue ...) failed\r\n"
                      "hResult: %08x",
                    hResult
                );

                if (hResult != MQ_ERROR_IO_TIMEOUT)
                {
                    LogEvent(LOGLEVEL_ALWAYS, WARN, ISAPI_EVENT_WARNING_PEEK, ISAPI_M_WARNING_PEEK, hResult);
                    // attemp to re-connect to the queueu
                /*    if (bReadFromPrimary == TRUE)
                    {
                    */
                        hResult =  MQOpenQueue(g_IsapiParams.InQueueConStr1,
                                                 MQ_RECEIVE_ACCESS,
                                                 MQ_DENY_NONE,
                                                 &hPrimaryInQueue);
                        if (FAILED(hResult))
                        {
                            if (StringCbPrintf(ErrorText,sizeof ErrorText,_T("&Code=%d"), FAILED_RECONNECT_RECEIVE)!= S_OK)
                            {
                                LogEventWithString(
                                    LOGLEVEL_ALWAYS,
                                    ERR,
                                    ISAPI_EVENT_ERROR,
                                    "WorkerFunction() - StringCbPrintf failed"
                                );
                            }
                            LogEvent(LOGLEVEL_ALWAYS, ERR, ISAPI_EVENT_ERROR_RECONNECT, ISAPI_M_ERROR_RECONNECT, "primary receive queue", hResult);
                            goto ERRORS;
                        }
                 /*
                    }
                    else
                    {
                        hResult =  MQOpenQueue(g_IsapiParams.InQueueConStr1,
                                                 MQ_RECEIVE_ACCESS,
                                                 MQ_DENY_NONE,
                                                 &hPrimaryInQueue);
                        if (FAILED(hResult))
                        {
                            LogEvent(LOGLEVEL_ALWAYS, ERR, ISAPI_EVENT_ERROR_RECONNECT, ISAPI_M_ERROR_RECONNECT, "secondary receive queue", hResult);
                            goto ERRORS;
                        }
                    }
                    */
                }
                else
                {
                    LogEvent(LOGLEVEL_ALWAYS, WARN, ISAPI_EVENT_WARNING_TIMEOUT_EXPIRED, ISAPI_M_WARNING_TIMEOUT_EXPIRED);
                }

            }
            // Close the cursor
            if (CursorValid)
                MQCloseCursor(hCursor);
        } while ((TotalElapsedTime < 20.0) && (!MessageFound));
    }


    StopRecvQueue = GetTickCount();

    StopThread = GetTickCount();

    ElapsedTimeSendQueue = StopSendQueue - StartSendQueue;
    ElapsedTimeRecvQueue = StopRecvQueue - StartRecvQueue;
    ElapsedTimeThread = StopThread - StartThread;

    if (g_dwDebugMode & LOGLEVEL_PERF)
    {
        if (StringCbPrintf(
                PerfText,
                sizeof(PerfText),
                _T("&PerfThread=%ld&PerfSendQueue=%ld&PerfRecvQueue=%ld"),
                ElapsedTimeThread,
                ElapsedTimeSendQueue,
                ElapsedTimeRecvQueue
            ) != S_OK)
        {
            LogEventWithString(
                LOGLEVEL_ALWAYS,
                ERR,
                ISAPI_EVENT_ERROR,
                "WorkerFunction() - StringCbPrintf failed"
            );
        }
    }

    // Send the response url to the client
    if (!Status)
    {
        if (StringCbPrintf(ErrorText,sizeof ErrorText,_T("&Code=%d"), MESSAGE_RECEIVE_TIMEOUT)!= S_OK)
        {
            LogEventWithString(
                LOGLEVEL_ALWAYS,
                ERR,
                ISAPI_EVENT_ERROR,
                "WorkerFunction() - StringCbPrintf failed"
            );
        }
        goto ERRORS;

    }
    else
    {
        // Close the Receive queue

        if (iType != 1)
        {
            SendHttpHeaders( pECB, "200 OK", szHeader, FALSE );
        }
        // convert the wchar message guid to a mbs string
        wcstombs(szMessageGuid,wszMessageGuid,wcslen(wszMessageGuid) * sizeof wchar_t);
        // Ok we have a message did we get a url ?
        if (! _wcsicmp(RecMessageBody, L"NO_SOLUTION"))
        {
            // This should never happen but just in case send the error url with
            // Tracking turned on Log the guid so we can followup later.
            LogEvent(LOGLEVEL_ALWAYS, WARN, ISAPI_EVENT_WARNING_NO_SOLUTION, ISAPI_M_WARNING_NO_SOLUTION, szMessageGuid);
            if (iType == 1)
            {
                // send the redirection command
                if (StringCbPrintf(FinalURL, sizeof FinalURL, "%s&State=1%s%s&ID=%s", g_IsapiParams.ErrorUrl,ErrorText,PerfText,szMessageGuid) == S_OK)
                {
                    dwSize = (DWORD)_tcslen(FinalURL);
                    pECB->ServerSupportFunction(
                                                pECB->ConnID,
                                                HSE_REQ_SEND_URL_REDIRECT_RESP,
                                                FinalURL,
                                                &dwSize,
                                                NULL
                                                );
                }
                else
                {
                    LogEventWithString(
                        LOGLEVEL_ALWAYS,
                        ERR,
                        ISAPI_EVENT_ERROR,
                        "WorkerFunction() - StringCbPrintf failed"
                    );

                    goto ERRORS;
                }
            }
            else
            {
                // Write the response to the wininet client
                if (StringCbPrintf(FinalURL, sizeof FinalURL, "%s&State=1%s%s&ID=%s", g_IsapiParams.ErrorUrl,ErrorText,PerfText,szMessageGuid) == S_OK)
                {
                        // We want to write the response url to the client
                    dwSize = (DWORD)strlen( FinalURL );
                    pECB->WriteClient( pECB->ConnID, FinalURL, &dwSize, 0 );
                }
                else
                {
                    LogEventWithString(
                        LOGLEVEL_ALWAYS,
                        ERR,
                        ISAPI_EVENT_ERROR,
                        "WorkerFunction() - StringCbPrintf failed"
                    );

                    goto ERRORS;
                }
            }

        }
        else
        {
            temp2 = RecMessageBody;
            temp2 += (wcslen(RecMessageBody)-1);
            while ( (*temp2 != L'=') && (temp2 != RecMessageBody))
                -- temp2;
            // ok Temp + 1 is our new state value.
            if (temp2 != RecMessageBody)
            {
                iState = _wtoi(temp2+1);
            }
            // Convert the message body to a TCHAR

            wcstombs(szRecMessageBody,RecMessageBody,((wcslen(RecMessageBody)+1) * sizeof wchar_t));


            if (iState == 1)
            {
                wcstombs(szMessageGuid,wszMessageGuid,((wcslen(wszMessageGuid)+1) * sizeof wchar_t));
                if (iType == 1) // Watson Client or other web browser
                {
                    // We want to send a redirection command to the client
                    if (StringCbPrintf(FinalURL, sizeof FinalURL, "%s&ID=%s%s", szRecMessageBody,szMessageGuid,PerfText) == S_OK)
                    {

                        dwSize = (DWORD)_tcslen(FinalURL);
                        pECB->ServerSupportFunction(
                                                pECB->ConnID,
                                                HSE_REQ_SEND_URL_REDIRECT_RESP,
                                                FinalURL,
                                                &dwSize,
                                                NULL
                                                );
                    }
                    else
                    {
                        LogEventWithString(
                            LOGLEVEL_ALWAYS,
                            ERR,
                            ISAPI_EVENT_ERROR,
                            "WorkerFunction() - StringCbPrintf failed"
                        );

                        goto ERRORS;
                    }

                }
                else // WinInet Client
                {
                    if (StringCbPrintf(FinalURL, sizeof FinalURL, "%s&ID=%s%s", szRecMessageBody,szMessageGuid,PerfText) == S_OK)
                    {
                        // We want to write the response url to the client
                        dwSize = (DWORD)strlen( FinalURL );
                        pECB->WriteClient( pECB->ConnID, FinalURL, &dwSize, 0 );
                    }
                    else
                    {
                        LogEventWithString(
                            LOGLEVEL_ALWAYS,
                            ERR,
                            ISAPI_EVENT_ERROR,
                            "WorkerFunction() - StringCbPrintf failed"
                        );

                        goto ERRORS;
                    }
                }
            }
            else // We have a real solution so DO NOT send the Guid
            {
                if (iType == 1)
                {
                    //wcstombs(szMessageGuid,wszMessageGuid,((wcslen(wszMessageGuid)+1) * sizeof wchar_t));
                    if (StringCbPrintf(FinalURL, sizeof FinalURL, "%s%s", szRecMessageBody,PerfText) == S_OK)
                    {

                        dwSize = (DWORD)_tcslen(FinalURL);
                        pECB->ServerSupportFunction(
                                                pECB->ConnID,
                                                HSE_REQ_SEND_URL_REDIRECT_RESP,
                                                FinalURL,
                                                &dwSize,
                                                NULL
                                                );
                    }
                    else
                    {
                        LogEventWithString(
                            LOGLEVEL_ALWAYS,
                            ERR,
                            ISAPI_EVENT_ERROR,
                            "WorkerFunction() - StringCbPrintf failed"
                        );

                        goto ERRORS;
                    }
                }
                else
                {
                    // write the response to the client
                    if (StringCbPrintf(FinalURL, sizeof FinalURL, "%s%s", szRecMessageBody,PerfText) == S_OK)
                    {
                        // We want to write the response url to the client
                        dwSize = (DWORD)strlen( FinalURL );
                        pECB->WriteClient( pECB->ConnID, FinalURL, &dwSize, 0 );
                    }
                    else
                    {
                        LogEventWithString(
                            LOGLEVEL_ALWAYS,
                            ERR,
                            ISAPI_EVENT_ERROR,
                            "WorkerFunction() - StringCbPrintf failed"
                        );

                        goto ERRORS;
                    }
                }
            }
        }
    }
    if (szTempMessageGuid)
    {
        RpcStringFreeW(&szTempMessageGuid);
    }
    pECB->ServerSupportFunction(pECB->ConnID,
                            HSE_REQ_DONE_WITH_SESSION,
                            NULL,
                            NULL,
                            NULL
                            );
    InterlockedDecrement(&g_dwThreadCount);
    if (hPrimaryInQueue)
        MQCloseQueue(hPrimaryInQueue);
//    if (hSecondaryInQueue)
//        MQCloseQueue(hSecondaryInQueue);
    if (hPrimaryOutQueue)
        MQCloseQueue(hPrimaryOutQueue);
//    if (hSecondaryOutQueue)
//        MQCloseQueue(hSecondaryOutQueue);

    LogEventWithString(LOGLEVEL_TRACE, SUCCESS, ISAPI_EVENT_TRACE, "Exiting WorkerFunction(), no errors!");

    _endthreadex(0);
    return TRUE;


ERRORS:

    if (0 == StartSendQueue)
        StopSendQueue = 0;
    else if (0 == StopSendQueue)
        StopSendQueue = GetTickCount();

    if (0 == StartRecvQueue)
        StopRecvQueue = 0;
    else if (0 == StopRecvQueue)
        StopRecvQueue = GetTickCount();

    StopThread = GetTickCount();

    ElapsedTimeSendQueue = StopSendQueue - StartSendQueue;
    ElapsedTimeRecvQueue = StopRecvQueue - StartRecvQueue;
    ElapsedTimeThread = StopThread - StartThread;

    if (g_dwDebugMode & LOGLEVEL_PERF)
    {
        if (StringCbPrintf(
                PerfText,
                sizeof(PerfText),
                _T("&PerfThread=%ld&PerfSendQueue=%ld&PerfRecvQueue=%ld"),
                ElapsedTimeThread,
                ElapsedTimeSendQueue,
                ElapsedTimeRecvQueue
            ) != S_OK)
        {
            LogEventWithString(
                LOGLEVEL_ALWAYS,
                ERR,
                ISAPI_EVENT_ERROR,
                "WorkerFunction() - StringCbPrintf failed"
            );
        }
    }

    if (szTempMessageGuid)
    {
        RpcStringFreeW(&szTempMessageGuid);
    }


    if (iType == 1)
    {
        // We want to send a redirection command to the client
        if (StringCbPrintf(FinalURL, sizeof FinalURL, "%s&State=0%s%s", g_IsapiParams.ErrorUrl, ErrorText, PerfText) == S_OK)
        {
            LogEventWithString(LOGLEVEL_DEBUG, INFO, ISAPI_EVENT_DEBUG, "WorkerFunction() - sending redirect\r\nFinalURL: %s", FinalURL);
            dwSize = (DWORD)_tcslen(FinalURL);
            pECB->ServerSupportFunction(
                                        pECB->ConnID,
                                        HSE_REQ_SEND_URL_REDIRECT_RESP,
                                        FinalURL,
                                        &dwSize,
                                        NULL
                                        );
        }
    }
    else
    {
        // We want to write the response url to the client
        // Write the response to the wininet client
        if (StringCbPrintf(FinalURL, sizeof FinalURL, "%s&State=0%s%s", g_IsapiParams.ErrorUrl, ErrorText, PerfText) == S_OK)
        {
            LogEventWithString(LOGLEVEL_DEBUG, INFO, ISAPI_EVENT_DEBUG, "WorkerFunction() - sending response\r\nFinalURL: %s", FinalURL);

            // We want to write the response url to the client
            SendHttpHeaders( pECB, "200 OK", szHeader, FALSE );
            dwSize = (DWORD)strlen( FinalURL );
            pECB->WriteClient( pECB->ConnID, FinalURL, &dwSize, 0 );
        }
    }
    pECB->ServerSupportFunction(pECB->ConnID,
                            HSE_REQ_DONE_WITH_SESSION,
                            NULL,
                            NULL,
                            NULL
                            );
    InterlockedDecrement(&g_dwThreadCount);

    if (hPrimaryInQueue)
        MQCloseQueue(hPrimaryInQueue);
//    if (hSecondaryInQueue)
//        MQCloseQueue(hSecondaryInQueue);
    if (hPrimaryOutQueue)
        MQCloseQueue(hPrimaryOutQueue);
//    if (hSecondaryOutQueue)
//        MQCloseQueue(hSecondaryOutQueue);

    LogEventWithString(LOGLEVEL_TRACE, ERR, ISAPI_EVENT_TRACE, "Exiting WorkerFunction(), error occurred");

    _endthreadex(0);
    return TRUE;
}






BOOL
SendHttpHeaders(
    EXTENSION_CONTROL_BLOCK *pECB,
    LPCSTR pszStatus,
    LPCSTR pszHeaders,
    BOOL fKeepConnection
)
/*++

Purpose:
    Send specified HTTP status string and any additional header strings
    using new ServerSupportFunction() request HSE_SEND_HEADER_EX_INFO

Arguments:

    pECB - pointer to the extension control block
    pszStatus - HTTP status string (e.g. "200 OK")
    pszHeaders - any additional headers, separated by CRLFs and
                 terminated by empty line

Returns:

--*/
{
    HSE_SEND_HEADER_EX_INFO header_ex_info;
    BOOL success;

// test
LogEventWithString(LOGLEVEL_DEBUG, INFO, ISAPI_EVENT_DEBUG, "SendHttpHeaders(pECB,\r\npszStatus=%s,\r\npszHeaders=%s,\r\nfKeepConnection=%d)", pszStatus, pszHeaders, (int)fKeepConnection);

    header_ex_info.pszStatus = pszStatus;
    header_ex_info.pszHeader = pszHeaders;
    header_ex_info.cchStatus = (DWORD)strlen( pszStatus );
    header_ex_info.cchHeader = (DWORD)strlen( pszHeaders );
    header_ex_info.fKeepConn = fKeepConnection;

SetLastError(0);
    success = pECB->ServerSupportFunction(
                  pECB->ConnID,
                  HSE_REQ_SEND_RESPONSE_HEADER_EX,
                  &header_ex_info,
                  NULL,
                  NULL
                  );

LogEventWithString(LOGLEVEL_DEBUG, INFO, ISAPI_EVENT_DEBUG, "Exiting SendHttpHeaders()\r\nReturn Value: %d\r\nLast Error: %08x", (int)success, GetLastError());

    return success;
}


HRESULT
WriteEvent(
    LPTSTR lpszSource,
    DWORD  dwEventType,
    DWORD  dwEventID,
    WORD   cStrings,
    TCHAR **apwszStrings
    )
{
    HANDLE hAppLog=NULL;
    BOOL bSuccess=FALSE;
    WORD wElogType;
    DWORD dwErr;
    wElogType = (WORD) dwEventType;

    if (INVALID_HANDLE_VALUE != g_hEventSource)
    {
        bSuccess = ReportEvent(
                       g_hEventSource,
                       wElogType,
                       0,
                       dwEventID,
                       g_psidUser,
                       cStrings,
                       0,
                       (const TCHAR **) apwszStrings,
                       NULL
                   );

        dwErr = GetLastError();
        LogEventWithString(
            LOGLEVEL_TRACE,
            INFO,
            ISAPI_EVENT_DEBUG,
            "WriteEvent() - ReportEvent()\r\n"
              "bSuccess: %d\r\n"
              "wELogType: %d\r\n"
              "dwEventID: %08x\r\n"
              "Error: %08lx\r\n"
              "Event Source: %s\r\n"
              "cStrings: %d\r\n"
              "apwszStrings: %08x",
            bSuccess,
            wElogType,
            dwEventID,
            GetLastError(),
            lpszSource,
            cStrings,
            (DWORD_PTR)apwszStrings
        );

    }
    else
    {
        dwErr = GetLastError();
        LogEventWithString(
            LOGLEVEL_DEBUG,
            INFO,
            ISAPI_EVENT_DEBUG,
            "WriteEvent() - RegisterEventSource() failed\r\n"
              "hAppLog: %08x\r\n"
              "Last Error: %08lx",
            (DWORD_PTR)hAppLog,
            dwErr
        );
    }

    return((bSuccess) ? ERROR_SUCCESS : dwErr);
}


void
LogEvent(
    IN DWORD dwLevel,
    IN ISAPI_EVENT_TYPE emType,
    IN DWORD dwEventID,
    IN DWORD dwErrorID,
    ...
    )
/*++

Purpose:
    Logs a specific event to the event log.

    Sample Usage:
    LogEvent(LOGLEVEL_ALWAYS, INFO, ISAPI_EVENT_ERROR_SEND, ISAPI_M_ERROR_SEND, szDestination);

Arguments:

    emType - event message type (INFO, WRN, ERR, SUCC, AUDITS, AUDITF)
    dwEventID - event id from messages.mc
    ... - variable argument list for any event message parameters

Returns:

--*/
{
    DWORD    dwResult;
    LPTSTR   lpszTemp = NULL;
    LPTSTR   szParams;
    LPTSTR*  pParams  = NULL;
    DWORD    dwParams = 0;
    int      i;

    va_list arglist;
    va_start( arglist, dwErrorID );

    if (!(dwLevel & g_dwDebugMode))
    {
        goto done;
    }

    LogEventWithString(
        LOGLEVEL_TRACE,
        INFO,
        ISAPI_EVENT_DEBUG,
        "LogEvent()\r\n"
          "emType: %ld\r\n"
          "dwEventID: %08x",
        emType,
        dwEventID
    );

    __try {

        dwResult = FormatMessage(
                       FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_HMODULE |
                         FORMAT_MESSAGE_FROM_SYSTEM,
                       g_hModule,
                       dwErrorID,
                       LANG_NEUTRAL,
                       (LPTSTR)&lpszTemp,
                       0,
                       &arglist
                   );

        if (dwResult != 0)
        {
            WriteEvent(_T("OCA_EXTENSION"), emType, dwEventID, 1, &lpszTemp);
            if(lpszTemp)
            {
                LocalFree((HLOCAL)lpszTemp);
            }
        }
        else
        {
            LogEventWithString(
                LOGLEVEL_DEBUG,
                INFO,
                ISAPI_EVENT_DEBUG,
                "LogEvent() - FormatMessage() failed\r\n"
                  "Last Error: %08x\r\n"
                  "EventID: %08x",
                GetLastError(),
                dwEventID
            );
        }

        ;

    }
    __except(EXCEPTION_EXECUTE_HANDLER) {
        // this is only for putting a break point here
        SetLastError(GetLastError());
    }

done:

    va_end( arglist );
    return;
}

void LogEventWithString(DWORD dwLevel, ISAPI_EVENT_TYPE emType, DWORD dwEventID, LPCTSTR pFormat, ...)
/*++

Purpose:
    Logs a generic event with a custom string to the event log.  Mostly intended
    to be used for debugging purposes.

    Sample Usage:
    LogEventWithString(LOGLEVEL_ALWAYS, ERR, ISAPI_EVENT_ERROR, "Failed to write %s (%d)", szFilename, dwLastErr);
    LogEventWithString(LOGLEVEL_DEBUG, INFO, ISAPI_EVENT_DEBUG, "Failed to write %s (%d)", szFilename, dwLastErr);

Arguments:

    emType - event message type (DBG, INFO, WARN, ERROR, SUCCESS, AUDIT_SUCCESS, AUDIT_FAIL)
    dwEventID - event id from messages.mc
    pFormat - format string to use for variable argument parameter list
    ... - variable argument list for any event message parameters

Returns:

--*/
{
    TCHAR   chMsg[256];
    LPTSTR  lpszStrings[1];
    va_list pArg;

    if (!(dwLevel & g_dwDebugMode))
    {
        goto done;
    }

    va_start(pArg, pFormat);
    if (StringCbVPrintf(chMsg,sizeof chMsg, pFormat, pArg) != S_OK)
        return;
    va_end(pArg);

    lpszStrings[0] = chMsg;

    if (INVALID_HANDLE_VALUE != g_hEventSource)
    {
        /* Write to event log. */
        ReportEvent(g_hEventSource, emType, 0, dwEventID, g_psidUser, 1, 0, (LPCTSTR*) &lpszStrings[0], NULL);
    }

done:
    ;
}

/*
///////////////////////////////////////////////////////////////////////////////////////
// Routine to Log Fatal Errors to NT Event Log
VOID LogFatalEvent(LPCTSTR pFormat, ...)
{
    TCHAR    chMsg[256];
    LPTSTR  lpszStrings[1];
    va_list pArg;

    va_start(pArg, pFormat);
    StringCbVPrintf(chMsg,sizeof chMsg, pFormat, pArg);
    va_end(pArg);

    lpszStrings[0] = chMsg;

    if (INVALID_HANDLE_VALUE != g_hEventSource)
    {
        //Write to event log.
        ReportEvent(g_hEventSource,
                    EVENTLOG_ERROR_TYPE,
                    0,
                    EVENT_ERROR,
                    NULL,
                    1,
                    0,
                    (LPCTSTR*) &lpszStrings[0],
                    NULL);
    }

}
*/
///////////////////////////////////////////////////////////////////////////////////////
// Routine to setup NT Event logging


DWORD SetupEventLog ( BOOL fSetup )
{
    TCHAR s_cszEventLogKey[] =  _T("System\\CurrentControlSet\\Services\\EventLog\\Application");       // Event Log
    HKEY hKey;
    HKEY hSubKey;
    TCHAR szEventKey[MAX_PATH];
    LONG lRes = 0;
    DWORD dwResult = 0;
    DWORD dwTypes = EVENTLOG_ERROR_TYPE | EVENTLOG_WARNING_TYPE | EVENTLOG_INFORMATION_TYPE;

    dwResult = StringCbCopy(szEventKey, sizeof szEventKey, s_cszEventLogKey);
    if (dwResult !=S_OK)
    {
        LogEvent(LOGLEVEL_ALWAYS, ERR, ISAPI_EVENT_ERROR_SETUP_EVENT_LOG, ISAPI_M_ERROR_SETUP_EVENT_LOG, dwResult);
        goto done;
    }
    else
    {
        dwResult = StringCbCat(szEventKey, sizeof szEventKey, _T("\\"));
        if (dwResult != S_OK)
        {
            LogEvent(LOGLEVEL_ALWAYS, ERR, ISAPI_EVENT_ERROR_SETUP_EVENT_LOG, ISAPI_M_ERROR_SETUP_EVENT_LOG, dwResult);
            goto done;
        }
        else
        {
            dwResult = StringCbCat(szEventKey, sizeof szEventKey, _T("OCA_EXTENSION"));
            if (dwResult != S_OK)
            {
                LogEvent(LOGLEVEL_ALWAYS, ERR, ISAPI_EVENT_ERROR_SETUP_EVENT_LOG, ISAPI_M_ERROR_SETUP_EVENT_LOG, dwResult);
                goto done;
            }
        }
    }


    lRes = RegCreateKeyEx(HKEY_LOCAL_MACHINE,
                          szEventKey,
                          0,
                          NULL,
                          REG_OPTION_NON_VOLATILE,
                          KEY_ALL_ACCESS,
                          NULL,
                          &hSubKey,
                          &dwResult);

    if (lRes != ERROR_SUCCESS)
    {
        goto done;
    }

    if( TRUE == fSetup )
    {
        g_hModule = GetModuleHandle(g_cszDefaultExtensionDll);
        dwResult = StringCbCopy(g_szAppName,sizeof(g_szAppName), g_cszDefaultExtensionDll);
        if (dwResult != S_OK)
        {
            LogEvent(LOGLEVEL_ALWAYS, ERR, ISAPI_EVENT_ERROR_SETUP_EVENT_LOG, ISAPI_M_ERROR_SETUP_EVENT_LOG, dwResult);
            goto done;
        }

        GetModuleFileName(g_hModule, g_szAppName, sizeof(g_szAppName)/sizeof(g_szAppName[0]) );

        RegSetValueEx(hSubKey,_T("EventMessageFile"),0,REG_EXPAND_SZ,(CONST BYTE *)g_szAppName,sizeof(g_szAppName)/sizeof(g_szAppName[0]));
        RegSetValueEx(hSubKey,_T("TypesSupported"),0,REG_DWORD, (LPBYTE) &dwTypes, sizeof DWORD);

    }
    else
    {
        //RegDeleteKey(HKEY_LOCAL_MACHINE, szEventKey);
    }
    RegCloseKey(hSubKey);

    // Get a handle to use with ReportEvent().
    g_hEventSource = RegisterEventSource(NULL, _T("OCA_EXTENSION"));

    goto done;


done:

    return GetLastError();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\include\root\footer.inc ===
<br>
<hr noshade color="#cccccc">

<div align="right" style="margin-left:12pt; margin=right:12pt; color:#999999">

Questions or comments should be directed to Gabriel Aul <a href="mailto:gabea">(gabea)</a><br>

<script language="VBScript">
<!--
	'Dim LastMod : LastMod = document.LastModified
	
	'If Len(LastMod) > 0 Then
	'	Document.Write("Last Updated: " + MonthName(DatePart("m", LastMod)) & " " & DatePart("d", LastMod) & ", " & DatePart("yyyy", LastMod))
	'End If

-->
</script>

</div>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\secure\beta\dataconnections.inc ===
<%
	dim strCustomer
	dim strGlobalLanguage
	dim strGlobalOptionCode
	dim strGlobalVersion
	Dim strOCAIISBox
	Dim strFileMoverBox
	Dim strFileOfficeWatson
	Dim strGlobalCommandTimeout
	Dim strGlobalConnectionTimeout
	
	strGlobalLanguage = "1033"
	strGlobalOptionCode = "2"
	strGlobalVersion = "4,6,0,0"
	strOCAIISBox = "c:\temp\"
	strFileMoverBox = "c:\filemover\"
	strFileOfficeWatson = "C:\WINNT\Minidump\"
	strGlobalConnectionTimeout = 60
	strGlobalCommandTimeout = 60

	strCustomer = "Provider=SQLOLEDB.1;Persist Security Info=False;User ID=dumpfiles;pwd=dumpfiles;Data Source=BSOD_DB1"
	'strCustomer = "Provider=SQLOLEDB.1;UID=sa;PWD=sa;Persist Security Info=False;Initial Catalog=KaCustomer;Data Source=OCATESTDB"
	'strCustomer = "Provider=SQLOLEDB.1;Persist Security Info=False;User ID=sa;PWD=sa;Initial Catalog=KaKnownIssue;Data Source=OCADEVDB"
	'strCustomer = "Provider=SQLOLEDB.1;PWD=billy;Persist Security Info=false;User ID=billy;Initial Catalog=OCA2;Data Source=TIMRAGAIN"
	'strCustomer = "Provider=SQLOLEDB.1;Password=sa;Persist Security Info=True;User ID=sa;PWD=sa;Data Source=OCATESTDB"
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\published\makefile.inc ===
$O\imagehlp.h: imagehlp.x minidump.x makefile.inc
    type << > $@
/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    imagehlp.h

Abstract:

    This module defines the prototypes and constants required for the image
    help routines.

Revision History:

--*/

#ifndef _IMAGEHLP_
#define _IMAGEHLP_

#if _MSC_VER > 1020
#pragma once
#endif

<<
    hextract -o $@ -xt hide_line -lt show_imagehlp -bt begin_imagehlp end_imagehlp imagehlp.x minidump.x
    type << >> $@

#endif // _IMAGEHLP_
<<

# dbghelp.h

$O\dbghelp.h: imagehlp.x minidump.x makefile.inc
    type << > $@
/*++ BUILD Version: ????     Increment this if a change has global effects

$(COPYRIGHT_STRING)

Module Name:

    dbghelp.h

Abstract:

    This module defines the prototypes and constants required for the image
    help routines.

    Contains debugging support routines that are redistributable.

Revision History:

--*/

#ifndef _DBGHELP_
#define _DBGHELP_

#if _MSC_VER > 1020
#pragma once
#endif

<<
    hextract -o $@ -xt hide_line -lt show_dbghelp -bt begin_dbghelp end_dbghelp imagehlp.x minidump.x
    type << >> $@

#endif // _DBGHELP_
<<
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\secure\prod\dataconnections.inc ===
<%
	dim strCustomer
	dim strGlobalLanguage
	dim strGlobalOptionCode
	dim strGlobalVersion
	Dim strOCAIISBox
	Dim strFileMoverBox
	Dim strFileOfficeWatson
	Dim IISServer1
	Dim IISServer2
	Dim IISServer3
	Dim IISServer4
	Dim fsoDest	
	Dim fsoDest64
	Dim strCharSet
	Dim strGlobalCommandTimeout
	Dim strGlobalConnectionTimeout
	DIM strSolutions

	strCharSet = "utf-8"
	'strCharSet = "SHIFT-JIS"
	strGlobalLanguage = "1033"
	strGlobalOptionCode = "2"
	strGlobalVersion = "2,0,0,34"
	strOCAIISBox = "c:\temp\"
	strFileMoverBox = "\\tkwucdrpta06\inqueue\"
	'strFileOfficeWatson = "C:\WINNT\Minidump\"
	strFileOfficeWatson = "\\officewatson1\archivebluescreen\"
	IISServer1 = "\\tkwucdwba01\OCA\"	
	IISServer2 = "\\tkwucdwba02\oca\"
	IISServer3 = "\\tkwucdwba03\oca\"
	IISServer4 = "\\tkwucdwba04\oca\"
	fsoDest	   = "\\tkwucdfsa02\Whistlerbeta\"
	fsoDest64  = "\\tkwucdfsa02\win64\"
	strGlobalConnectionTimeout = 60
	strGlobalCommandTimeout = 60

	strCustomer = "Provider=SQLOLEDB.1;Persist Security Info=False;User ID=publicWeb2;pwd=GoWin;Data Source=tkwucdsqla01"
	strSolutions = "Provider=SQLOLEDB.1;Persist Security Info=False;User ID=publicWeb2;pwd=GoWin;Data Source=tkwucdsqla01"
	'strCustomer = "Provider=SQLOLEDB.1;UID=sa;PWD=sa;Persist Security Info=False;Initial Catalog=KaCustomer;Data Source=OCATESTDB"
	'strCustomer = "Provider=SQLOLEDB.1;Persist Security Info=False;User ID=sa;PWD=sa;Initial Catalog=KaKnownIssue;Data Source=OCADEVDB"
	'strCustomer = "Provider=SQLOLEDB.1;PWD=billy;Persist Security Info=false;User ID=billy;Initial Catalog=OCA2;Data Source=TIMRAGAIN"
	'strCustomer = "Provider=SQLOLEDB.1;Password=sa;Persist Security Info=True;User ID=sa;PWD=sa;Data Source=OCATESTDB"
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\secure\test\jpndataconnections.inc ===
<%
	dim strCustomer
	dim strGlobalLanguage
	dim strGlobalOptionCode
	dim strGlobalVersion
	Dim strOCAIISBox
	Dim strFileMoverBox
	Dim strFileOfficeWatson
	Dim IISServer1
	Dim IISServer2
	Dim IISServer3
	Dim IISServer4
	Dim fsoDest	
	Dim fsoDest64
	Dim strCharSet
	Dim strCerVersion
	dim strGlobalEmail
	
	strCerVersion =  "2,1,0,50"
	strCharSet = "MS_KANJI"
	strGlobalLanguage = "1041"
	strGlobalOptionCode = "909"
	strGlobalVersion= "2,1,0,37"
	strOCAIISBox = "c:\temp\"
	strFileMoverBox = "\\ocafmtest\inqueue\"
	'strFileOfficeWatson = "C:\WINNT\Minidump\"
	strFileOfficeWatson = "\\officewatson1\archivebluescreen\"
	IISServer1 = "d:\OCA\"	
	IISServer2 = "d:\OCA\"
	IISServer3 = "d:\OCA\"
	IISServer4 = "d:\OCA\"
	fsoDest	   = "\\ocafmtest\inqueue\"
	fsoDest64  = "\\ocaarchive\win64\"
	strGlobalEmail = "ocaj@microsoft.com"

	strCustomer = "Provider=SQLOLEDB.1;Persist Security Info=False;User ID=dumpfiles;pwd=dumpfiles;Data Source=BSOD_DB1"
	'strCustomer = "Provider=SQLOLEDB.1;UID=sa;PWD=sa;Persist Security Info=False;Initial Catalog=KaCustomer;Data Source=OCATESTDB"
	'strCustomer = "Provider=SQLOLEDB.1;Persist Security Info=False;User ID=sa;PWD=sa;Initial Catalog=KaKnownIssue;Data Source=OCADEVDB"
	'strCustomer = "Provider=SQLOLEDB.1;PWD=billy;Persist Security Info=false;User ID=billy;Initial Catalog=OCA2;Data Source=TIMRAGAIN"
	'strCustomer = "Provider=SQLOLEDB.1;Password=sa;Persist Security Info=True;User ID=sa;PWD=sa;Data Source=OCATESTDB"
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\web\secure\test\dataconnections.inc ===
<%
	dim strCustomer
	dim strGlobalLanguage
	dim strGlobalOptionCode
	dim strGlobalVersion
	Dim strOCAIISBox
	Dim strFileMoverBox
	Dim strFileOfficeWatson
	Dim IISServer1
	Dim IISServer2
	Dim IISServer3
	Dim IISServer4
	Dim fsoDest	
	Dim fsoDest64
	Dim strCharSet
	Dim strCerVersion
	Dim strGlobalEmail
	Dim strGlobalCommandTimeout
	Dim strGlobalConnectionTimeout
	Dim strSolutions

	
	strCerVersion =  "2,5,0,4"
	strCharSet = "utf-8"
	'strCharSet = "SHIFT-JIS"
	strGlobalLanguage = "1033"
	strGlobalOptionCode = "909"
	strGlobalVersion= "2,5,0,10"
	strOCAIISBox = "c:\temp\"
	strFileMoverBox = "\\ocafmtest\inqueue\"
	'strFileOfficeWatson = "C:\WINNT\Minidump\"
	strFileOfficeWatson = "\\officewatson1\archivebluescreen\"
	IISServer1 = "d:\OCA\"	
	IISServer2 = "d:\OCA\"
	IISServer3 = "d:\OCA\"
	IISServer4 = "d:\OCA\"
	fsoDest	   = "\\ocafmtest\inqueue\"
	fsoDest64  = "\\ocaarchive\win64\"
	strGlobalEmail = "oca@microsoft.com"
	strGlobalConnectionTimeout = 60
	strGlobalCommandTimeout = 60

	strCustomer = "Provider=SQLOLEDB.1;Persist Security Info=False;User ID=dumpfiles;pwd=dumpfiles;Data Source=BSOD_DB1;initial catalog=KaCustomer2"
	strSolutions= "Provider=SQLOLEDB.1;Persist Security Info=False;User ID=dumpfiles;pwd=dumpfiles;Data Source=BSOD_DB1;initial catalog=Solutions"
	'strCustomer = "Provider=SQLOLEDB.1;UID=sa;PWD=sa;Persist Security Info=False;Initial Catalog=KaCustomer;Data Source=OCATESTDB"
	'strCustomer = "Provider=SQLOLEDB.1;Persist Security Info=False;User ID=sa;PWD=sa;Initial Catalog=KaKnownIssue;Data Source=OCADEVDB"
	'strCustomer = "Provider=SQLOLEDB.1;PWD=billy;Persist Security Info=false;User ID=billy;Initial Catalog=OCA2;Data Source=TIMRAGAIN"
	'strCustomer = "Provider=SQLOLEDB.1;Password=sa;Persist Security Info=True;User ID=sa;PWD=sa;Data Source=OCATESTDB"
%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\samples\adp_ext\adp_ext.cpp ===
//----------------------------------------------------------------------------
//
// AutoDump Plus support extension DLL.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#include "dbgexts.h"

#define STATUS_CPP_EH_EXCEPTION 0xe06d7363

#define MAX_NAME 64
#define MAX_MACHINE 64
#define MAX_COMMENT 256

char g_BaseDir[MAX_PATH - 1];
char g_Machine[MAX_MACHINE];

struct PARAM
{
    ULONG Len;
    PSTR Buf;
};

PARAM g_DirMachParams[2] =
{
    sizeof(g_BaseDir), g_BaseDir,
    sizeof(g_Machine), g_Machine,
};

union LAST_EVENT_INFO_ALL
{
    DEBUG_LAST_EVENT_INFO_BREAKPOINT Breakpoint;
    DEBUG_LAST_EVENT_INFO_EXCEPTION Exception;
    DEBUG_LAST_EVENT_INFO_EXIT_THREAD ExitThread;
    DEBUG_LAST_EVENT_INFO_EXIT_PROCESS ExitProcess;
    DEBUG_LAST_EVENT_INFO_LOAD_MODULE LoadModule;
    DEBUG_LAST_EVENT_INFO_UNLOAD_MODULE UnloadModule;
    DEBUG_LAST_EVENT_INFO_SYSTEM_ERROR SystemError;
};

ULONG g_LastEventType;
LAST_EVENT_INFO_ALL g_LastEventInfo;
PSTR g_LastExName;
char g_UnknownExceptionName[64];
PSTR g_LastExChanceStr;

ULONG g_ProcessId;
char g_ProcessName[MAX_NAME];

struct EXCEPTION_NAME
{
    PSTR Name;
    ULONG Code;
};

EXCEPTION_NAME g_ExceptionNames[] =
{
    "Access Violation", STATUS_ACCESS_VIOLATION,
    "C++ EH Exception", STATUS_CPP_EH_EXCEPTION,
    "Invalid Handle Exception", STATUS_INVALID_HANDLE,
    "Stack Overflow", STATUS_STACK_OVERFLOW,
    NULL, 0,
};

PCSTR
GetParams(PCSTR Args, ULONG Count, PARAM* Params)
{
    PCSTR Start;
    ULONG Len;
    ULONG Index = 0;
    
    while (Count-- > 0)
    {
        while (*Args == ' ' || *Args == '\t')
        {
            Args++;
        }
        Start = Args;
        while (*Args && *Args != ' ' && *Args != '\t')
        {
            Args++;
        }
        Len = (ULONG)(Args - Start);
        if ((Count > 0 && !*Args) || Len >= Params[Index].Len)
        {
            ExtErr("Invalid extension command arguments\n");
            return NULL;
        }
        memcpy(Params[Index].Buf, Start, Len);
        Params[Index].Buf[Len] = 0;

        Index++;
    }

    return Args;
}

HRESULT
GetProcessInfo(void)
{
    HRESULT Status;
    
    if ((Status = g_ExtSystem->
         GetCurrentProcessSystemId(&g_ProcessId)) != S_OK)
    {
        ExtErr("Unable to get current process ID\n");
        return Status;
    }
    
    if (FAILED(g_ExtClient->
               GetRunningProcessDescription(0, g_ProcessId,
                                            DEBUG_PROC_DESC_NO_PATHS,
                                            NULL, 0, NULL,
                                            g_ProcessName, MAX_NAME,
                                            NULL)))
    {
        g_ProcessName[0] = 0;
    }
    else
    {
        PSTR Scan;
        
        // Use the MTS package name as the name if it exists.
        Scan = strstr(g_ProcessName, "MTS Packages: ");
        if (Scan)
        {
            PSTR Start;
            ULONG Len;
            
            Scan += 14;
            Start = Scan;

            Scan = strchr(Start, ',');
            if (!Scan)
            {
                Scan = strchr(Start, ' ');
            }
            if (Scan)
            {
                *Scan = 0;
            }

            Len = strlen(Start) + 1;
            if (Len > 2)
            {
                memmove(g_ProcessName, Start, Len);
            }
            else
            {
                g_ProcessName[0] = 0;
            }
        }
        else
        {
            g_ProcessName[0] = 0;
        }
    }

    if (!g_ProcessName[0])
    {
        if (FAILED(g_ExtSystem->
                   GetCurrentProcessExecutableName(g_ProcessName, MAX_NAME,
                                                   NULL)))
        {
            // This can happen in some situations so handle it
            // rather than exiting.
            ExtErr("Unable to get current process name\n");
            strcpy(g_ProcessName, "UnknownProcess");
        }
    }

    return S_OK;
}

HRESULT
GetEventInfo(void)
{
    HRESULT Status;
    ULONG ProcessId, ThreadId;
    
    if ((Status = g_ExtControl->
         GetLastEventInformation(&g_LastEventType, &ProcessId, &ThreadId,
                                 &g_LastEventInfo, sizeof(g_LastEventInfo),
                                 NULL, NULL, 0, NULL)) != S_OK)
    {
        ExtErr("Unable to get event information\n");
        return Status;
    }
    
    if ((Status = GetProcessInfo()) != S_OK)
    {
        return Status;
    }

    switch(g_LastEventType)
    {
    case DEBUG_EVENT_EXCEPTION:
        {
            EXCEPTION_NAME* ExName = g_ExceptionNames;

            while (ExName->Name != NULL)
            {
                if (ExName->Code == g_LastEventInfo.Exception.
                    ExceptionRecord.ExceptionCode)
                {
                    break;
                }

                ExName++;
            }

            if (ExName->Name != NULL)
            {
                g_LastExName = ExName->Name;
            }
            else
            {
                sprintf(g_UnknownExceptionName, "Unknown Exception (%08X)",
                        g_LastEventInfo.Exception.
                        ExceptionRecord.ExceptionCode);
                g_LastExName = g_UnknownExceptionName;
            }

            if (g_LastEventInfo.Exception.FirstChance)
            {
                g_LastExChanceStr = "First";
            }
            else
            {
                g_LastExChanceStr = "Second";
            }
        }
        break;
    }
    
    return S_OK;
}

void
SanitizeFileName(PSTR FileName)
{
    while (*FileName)
    {
        switch(*FileName)
        {
        case ' ':
        case '\t':
        case '\n':
        case '\r':
            *FileName = '_';
            break;

        case '\\':
        case '/':
        case ':':
            *FileName = '-';
            break;
        }
        
        FileName++;
    }
}

void
GetDumpPath(PSTR NameQual, PSTR TypeStr, PSTR Path)
{
    SYSTEMTIME Time;
    PSTR FilePart;

    GetLocalTime(&Time);

    strcpy(Path, g_BaseDir);
    FilePart = Path + strlen(Path) - 1;
    if (*FilePart != '/' && *FilePart != '\\')
    {
        *++FilePart = '\\';
    }
    FilePart++;
    
    _snprintf(FilePart,
              MAX_PATH - (FilePart - Path),
              "PID-%d__%s__Date_%02d-%02d-%04d__Time_%02d-%02d-%02d__%s__%s.dmp",
              g_ProcessId,
              g_ProcessName,
              Time.wMonth,
              Time.wDay,
              Time.wYear,
              Time.wHour,
              Time.wMinute,
              Time.wSecond,
              NameQual,
              TypeStr);
    Path[MAX_PATH - 1] = 0;

    SanitizeFileName(FilePart);
}
            
void
WriteDump(PSTR NameQual, PSTR Comment,
          ULONG DumpQual, ULONG DumpFormat, PSTR TypeStr)
{
    char Path[MAX_PATH];
    ULONG Len;

    Len = strlen(Comment);
    _snprintf(Comment + Len, MAX_COMMENT - Len,
              " - %s dump from %s",
              TypeStr, g_Machine);
    Comment[MAX_COMMENT - 1] = 0;
    GetDumpPath(NameQual, TypeStr, Path);

    g_ExtClient->WriteDumpFile2(Path, DumpQual, DumpFormat, Comment);
}

extern "C" HRESULT
AdpEventControlC(PDEBUG_CLIENT Client, PCSTR Args)
{
    char Comment[MAX_COMMENT];
    
    INIT_API();

    //
    // Parameters: directory, machine name.
    //

    Args = GetParams(Args, 2, g_DirMachParams);
    if (Args == NULL)
    {
        goto Exit;
    }

    //
    // Retrieve standard information.
    //

    if ((Status = GetEventInfo()) != S_OK)
    {
        goto Exit;
    }
    
    //
    // Log information.
    //
    
    ExtOut("\n\n----------------------------------------------------------------------\n");
    ExtOut("CTRL-C was pressed to stop debugging this process!\n");
    ExtOut("----------------------------------------------------------------------\n");
    ExtOut("Exiting the debugger at:\n");
    ExtExec(".time");
    ExtOut("\n\n--- Listing all thread stacks: ---\n");
    ExtExec("~*kb250");
    ExtOut("\n--- Listing loaded modules: ---\n");
    ExtExec("lmv");
    ExtOut("\n--- Modules with matching symbols:\n");
    ExtExec("lml");
    ExtOut("\n--- Listing all locks: ---\n");
    ExtExec("!locks");

    //
    // Create a dump file.
    //
    
    strcpy(Comment, "CTRL-C was pressed to stop the debugger while running in crash mode");
    WriteDump("CTRL-C", Comment,
              DEBUG_DUMP_SMALL, DEBUG_FORMAT_DEFAULT, "mini");

 Exit:
    EXIT_API();
    return Status;
}

extern "C" HRESULT
AdpEventException(PDEBUG_CLIENT Client, PCSTR Args)
{
    char Comment[MAX_COMMENT];
    char Qual[MAX_COMMENT];
    ULONG Format;
    PSTR TypeStr;
    
    INIT_API();

    //
    // Parameters: directory, machine name.
    //

    Args = GetParams(Args, 2, g_DirMachParams);
    if (Args == NULL)
    {
        goto Exit;
    }

    //
    // Retrieve standard information.
    //

    if ((Status = GetEventInfo()) != S_OK)
    {
        goto Exit;
    }
    
    if (g_LastEventType != DEBUG_EVENT_EXCEPTION)
    {
        ExtErr("Last event was not an exception\n");
        goto Exit;
    }

    if (g_LastEventInfo.Exception.FirstChance)
    {
        Format = DEBUG_FORMAT_DEFAULT;
        TypeStr = "mini";
    }
    else
    {
        Format = DEBUG_FORMAT_USER_SMALL_FULL_MEMORY |
            DEBUG_FORMAT_USER_SMALL_HANDLE_DATA;
        TypeStr = "mini full handle";
    }
    
    //
    // Log information.
    //
    
    ExtOut("\n---- %s-chance %s - Exception stack below ----\n",
           g_LastExChanceStr, g_LastExName);
    ExtExec(".time");
    ExtOut("\n");
    ExtExec("kvn250");
    ExtOut("-----------------------------------\n");

    //
    // Create a dump file.
    //
    
    _snprintf(Comment, sizeof(Comment), "%s-chance %s in %s",
              g_LastExChanceStr, g_LastExName, g_ProcessName);
    Comment[sizeof(Comment) - 1] = 0;
    _snprintf(Qual, sizeof(Qual), "%s-chance %s",
              g_LastExChanceStr, g_LastExName);
    Qual[sizeof(Qual) - 1] = 0;

    WriteDump(Qual, Comment, DEBUG_DUMP_SMALL, Format, TypeStr);

    ExtOut("\n\n");
    
 Exit:
    EXIT_API();
    return Status;
}

extern "C" HRESULT
AdpEventExitProcess(PDEBUG_CLIENT Client, PCSTR Args)
{
    INIT_API();

    UNREFERENCED_PARAMETER(Args);
    
    //
    // Log information.
    //
    
    ExtOut("\n\n----------------------------------------------------------------------\n");
    ExtOut("This process is shutting down!\n");
    ExtOut("\nThis can happen for the following reasons:\n");
    ExtOut("1.) Someone killed the process with Task Manager or the kill command.\n");
    ExtOut("\n2.) If this process is an MTS or COM+ server package, it could be\n");
    ExtOut("*   exiting because an MTS/COM+ server package idle limit was reached.\n");
    ExtOut("\n3.) If this process is an MTS or COM+ server package,\n");
    ExtOut("*   someone may have shutdown the package via the MTS Explorer or\n");
    ExtOut("*   Component Services MMC snap-in.\n");
    ExtOut("\n4.) If this process is an MTS or COM+ server package,\n");
    ExtOut("*   MTS or COM+ could be shutting down the process because an internal\n");
    ExtOut("*   error was detected in the process (MTS/COM+ fail fast condition).\n");
    ExtOut("----------------------------------------------------------------------\n");
    ExtOut("\nThe process was shut down at:\n");
    ExtExec(".time");
    ExtOut("\n\n");

    EXIT_API();
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\rtlist\rtlist.cpp ===
//----------------------------------------------------------------------------
//
// Simple process list through the debug engine interface
// process enumeration methods.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#include <stdio.h>
#include <dbgeng.h>

PDEBUG_CLIENT g_Client;
PSTR g_ProcName;

void DECLSPEC_NORETURN
Panic(HRESULT Status, char* Format, ...)
{
    va_list Args;

    fprintf(stderr, "Error 0x%08X: ", Status);
    va_start(Args, Format);
    vfprintf(stderr, Format, Args);
    va_end(Args);

    exit(1);
}

void DECLSPEC_NORETURN
UsageExit(void)
{
    printf("Usage: rtlist <Options>\n");
    printf("Options are:\n");
    printf("    -premote <Options> - Connect to process server\n");
    printf("    -pn <Name>         - Look for process name\n");

    exit(2);
}

#define MAX_IDS 16384

void
List(ULONG64 Server)
{
    HRESULT Status;
    ULONG Ids[MAX_IDS];
    ULONG IdCount;
    ULONG i;

    if (g_ProcName != NULL)
    {
        if ((Status = g_Client->
             GetRunningProcessSystemIdByExecutableName
             (Server, g_ProcName, DEBUG_GET_PROC_ONLY_MATCH, &Ids[0])) != S_OK)
        {
            Panic(Status, "GetRunningProcessSystemIdByExecutableName\n");
        }

        IdCount = 1;
    }
    else
    {
        if ((Status = g_Client->
             GetRunningProcessSystemIds(Server, Ids, MAX_IDS,
                                        &IdCount)) != S_OK)
        {
            Panic(Status, "GetRunningProcessSystemIds\n");
        }

        if (IdCount > MAX_IDS)
        {
            fprintf(stderr, "Process list missing %d processes\n",
                    IdCount - MAX_IDS);
            IdCount = MAX_IDS;
        }
    }

    for (i = 0; i < IdCount; i++)
    {
        char ExeName[MAX_PATH];

        if ((Status = g_Client->
             GetRunningProcessDescription(Server, Ids[i],
                                          DEBUG_PROC_DESC_DEFAULT,
                                          ExeName, sizeof(ExeName), NULL,
                                          NULL, 0, NULL)) != S_OK)
        {
            sprintf(ExeName, "Error 0x%08X", Status);
        }

        if (Ids[i] >= 0x80000000)
        {
            printf("0x%x %s\n", Ids[i], ExeName);
        }
        else
        {
            printf("0n%d %s\n", Ids[i], ExeName);
        }
    }
}

void __cdecl
main(int Argc, char** Argv)
{
    HRESULT Status;

    if ((Status = DebugCreate(__uuidof(IDebugClient),
                              (void**)&g_Client)) != S_OK)
    {
        Panic(Status, "DebugCreate\n");
    }

    BOOL Usage = FALSE;
    ULONG64 Server = 0;
    
    while (--Argc > 0)
    {
        Argv++;

        if (!strcmp(*Argv, "-premote"))
        {
            if (Argc < 2 || Server != 0)
            {
                Usage = TRUE;
            }
            else
            {
                Argc--;
                Argv++;
                
                if ((Status = g_Client->
                     ConnectProcessServer(*Argv, &Server)) != S_OK)
                {
                    Panic(Status, "ConnectProcessServer\n");
                }
            }
        }
        else if (!strcmp(*Argv, "-pn"))
        {
            if (Argc < 2)
            {
                Usage = 2;
            }
            else
            {
                Argc--;
                Argv++;
                g_ProcName = *Argv;
            }
        }
        else
        {
            Usage = TRUE;
            break;
        }
    }

    if (Usage)
    {
        UsageExit();
    }

    List(Server);
    
    if (Server != 0)
    {
        g_Client->DisconnectProcessServer(Server);
    }
    g_Client->Release();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\samples\adp_ext\dbgexts.cpp ===
//----------------------------------------------------------------------------
//
// Generic routines and initialization code.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#include "dbgexts.h"

PDEBUG_CLIENT2         g_ExtClient;
PDEBUG_CONTROL2        g_ExtControl;
PDEBUG_DATA_SPACES2    g_ExtData;
PDEBUG_REGISTERS       g_ExtRegisters;
PDEBUG_SYMBOLS2        g_ExtSymbols;
PDEBUG_SYSTEM_OBJECTS2 g_ExtSystem;

// Queries for all debugger interfaces.
HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugClient2),
                                         (void **)&g_ExtClient)) != S_OK ||
        (Status = Client->QueryInterface(__uuidof(IDebugControl2),
                                         (void **)&g_ExtControl)) != S_OK ||
        (Status = Client->QueryInterface(__uuidof(IDebugDataSpaces2),
                                         (void **)&g_ExtData)) != S_OK ||
        (Status = Client->QueryInterface(__uuidof(IDebugRegisters),
                                         (void **)&g_ExtRegisters)) != S_OK ||
        (Status = Client->QueryInterface(__uuidof(IDebugSymbols2),
                                         (void **)&g_ExtSymbols)) != S_OK ||
        (Status = Client->QueryInterface(__uuidof(IDebugSystemObjects2),
                                         (void **)&g_ExtSystem)) != S_OK)
    {
        ExtRelease();
        return Status;
    }

    return S_OK;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    EXT_RELEASE(g_ExtClient);
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtData);
    EXT_RELEASE(g_ExtRegisters);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSystem);
}

void __cdecl
ExtOut(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_NORMAL, Format, Args);
    va_end(Args);
}

void __cdecl
ExtErr(PCSTR Format, ...)
{
    va_list Args;
    
    va_start(Args, Format);
    g_ExtControl->OutputVaList(DEBUG_OUTPUT_ERROR, Format, Args);
    va_end(Args);
}

void
ExtExec(PCSTR Command)
{
    g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS, Command,
                          DEBUG_EXECUTE_DEFAULT);
}

extern "C" HRESULT CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\samples\assert\out.hpp ===
//----------------------------------------------------------------------------
//
// stdio-based output callbacks class.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#ifndef __OUT_HPP__
#define __OUT_HPP__

class StdioOutputCallbacks : public IDebugOutputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugOutputCallbacks.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );
};

extern StdioOutputCallbacks g_OutputCb;

#endif // #ifndef __OUT_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\samples\adp_ext\dbgexts.h ===
//----------------------------------------------------------------------------
//
// Generic routines and initialization code.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#ifndef __DBGEXTS_H__
#define __DBGEXTS_H__

#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#include <windows.h>
#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif

#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status; 

#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

#define EXIT_API ExtRelease

// Global variables initialized by query.
extern PDEBUG_CLIENT2         g_ExtClient;
extern PDEBUG_CONTROL2        g_ExtControl;
extern PDEBUG_DATA_SPACES2    g_ExtData;
extern PDEBUG_REGISTERS       g_ExtRegisters;
extern PDEBUG_SYMBOLS2        g_ExtSymbols;
extern PDEBUG_SYSTEM_OBJECTS2 g_ExtSystem;

HRESULT ExtQuery(PDEBUG_CLIENT Client);
void ExtRelease(void);

void __cdecl ExtOut(PCSTR Format, ...);
void __cdecl ExtErr(PCSTR Format, ...);
void ExtExec(PCSTR Command);
    
#ifdef __cplusplus
}
#endif

#endif // #ifndef __DBGEXTS_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\samples\dumpstk\out.cpp ===
//----------------------------------------------------------------------------
//
// stdio-based output callbacks class.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>
#include <dbgeng.h>

#include "out.hpp"

StdioOutputCallbacks g_OutputCb;

STDMETHODIMP
StdioOutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, __uuidof(IUnknown)) ||
        IsEqualIID(InterfaceId, __uuidof(IDebugOutputCallbacks)))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
StdioOutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
StdioOutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
StdioOutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    UNREFERENCED_PARAMETER(Mask);
    fputs(Text, stdout);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\samples\assert\out.cpp ===
//----------------------------------------------------------------------------
//
// stdio-based output callbacks class.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>
#include <dbgeng.h>

#include "out.hpp"

StdioOutputCallbacks g_OutputCb;

STDMETHODIMP
StdioOutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (IsEqualIID(InterfaceId, __uuidof(IUnknown)) ||
        IsEqualIID(InterfaceId, __uuidof(IDebugOutputCallbacks)))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
StdioOutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
StdioOutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
StdioOutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    UNREFERENCED_PARAMETER(Mask);
    fputs(Text, stdout);
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\samples\dumpstk\out.hpp ===
//----------------------------------------------------------------------------
//
// stdio-based output callbacks class.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#ifndef __OUT_HPP__
#define __OUT_HPP__

class StdioOutputCallbacks : public IDebugOutputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugOutputCallbacks.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );
};

extern StdioOutputCallbacks g_OutputCb;

#endif // #ifndef __OUT_HPP__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\samples\assert\assert.cpp ===
//----------------------------------------------------------------------------
//
// Simple example of how to use non-invasive self-attach to get
// stack traces for assertion failures.
//
// Copyright (C) Microsoft Corporation, 2001.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <windows.h>
#include <dbgeng.h>

#include "out.hpp"

#define DE_ASSERT(Expr) \
    if (!(Expr)) AssertionFailed(__FILE__, __LINE__, #Expr); else 0

PSTR g_SymbolPath;
ULONG g_Pid;
BOOL g_Suspend;
BOOL g_NoDebuggerCheck;

IDebugClient* g_Client;
IDebugControl* g_Control;
IDebugSymbols* g_Symbols;

void
ReleaseInterfaces(void)
{
    if (g_Symbols != NULL)
    {
        g_Symbols->Release();
    }
    if (g_Control != NULL)
    {
        g_Control->Release();
    }
    if (g_Client != NULL)
    {
        //
        // Request a simple end to any current session.
        // This may or may not do anything but it isn't
        // harmful to call it.
        //

        // We don't want to see any output from the shutdown.
        g_Client->SetOutputCallbacks(NULL);
        
        g_Client->EndSession(DEBUG_END_ACTIVE_DETACH);
        
        g_Client->Release();
    }
}

void
Exit(int Code, PCSTR Format, ...)
{
    // Clean up any resources.
    ReleaseInterfaces();

    // Output an error message if given.
    if (Format != NULL)
    {
        va_list Args;

        va_start(Args, Format);
        vfprintf(stderr, Format, Args);
        va_end(Args);
    }
    
    exit(Code);
}

void
CreateInterfaces(void)
{
    HRESULT Status;

    // Start things off by getting an initial interface from
    // the engine.  This can be any engine interface but is
    // generally IDebugClient as the client interface is
    // where sessions are started.
    if ((Status = DebugCreate(__uuidof(IDebugClient),
                              (void**)&g_Client)) != S_OK)
    {
        Exit(1, "DebugCreate failed, 0x%X\n", Status);
    }

    // Query for some other interfaces that we'll need.
    if ((Status = g_Client->QueryInterface(__uuidof(IDebugControl),
                                           (void**)&g_Control)) != S_OK ||
        (Status = g_Client->QueryInterface(__uuidof(IDebugSymbols),
                                           (void**)&g_Symbols)) != S_OK)
    {
        Exit(1, "QueryInterface failed, 0x%X\n", Status);
    }
}

void
SelfAttach(void)
{
    HRESULT Status;

    // Don't set the output callbacks yet as we don't want
    // to see any of the initial debugger output.

    if (g_SymbolPath != NULL)
    {
        if ((Status = g_Symbols->SetSymbolPath(g_SymbolPath)) != S_OK)
        {
            Exit(1, "SetSymbolPath failed, 0x%X\n", Status);
        }
    }

    // Everything's set up so do the attach.
    if ((Status = g_Client->
         AttachProcess(0, g_Pid,
                       DEBUG_ATTACH_NONINVASIVE |
                       (g_Suspend ? 0 :
                        DEBUG_ATTACH_NONINVASIVE_NO_SUSPEND))) != S_OK)
    {
        Exit(1, "AttachProcess failed, 0x%X\n", Status);
    }

    // Finish initialization by waiting for the attach event.
    // This should return quickly as a non-invasive attach
    // can complete immediately.
    if ((Status = g_Control->WaitForEvent(DEBUG_WAIT_DEFAULT,
                                          INFINITE)) != S_OK)
    {
        Exit(1, "WaitForEvent failed, 0x%X\n", Status);
    }

    // Everything is now initialized and we can make any
    // queries we want.
}

void
DumpStack(PCONTEXT Context)
{
    HRESULT Status;
    int Count = 50;
    char CxrCommand[64];

    printf("\nFirst %d frames of the call stack:\n", Count);

    // Install output callbacks so we get the output from the stack dump.
    if ((Status = g_Client->SetOutputCallbacks(&g_OutputCb)) != S_OK)
    {
        Exit(1, "SetOutputCallbacks failed, 0x%X\n", Status);
    }

    sprintf(CxrCommand, ".cxr 0x%p", Context);
    
    // Print the call stack for the given context.
    if ((Status = g_Control->
         Execute(DEBUG_OUTCTL_IGNORE, CxrCommand,
                 DEBUG_EXECUTE_NOT_LOGGED)) != S_OK)
    {
        Exit(1, "Execute failed, 0x%X\n", Status);
    }
    
    // If the code is optimized at all it is important to have
    // accurate symbols to get the correct stack.
    if ((Status = g_Control->
         OutputStackTrace(DEBUG_OUTCTL_ALL_CLIENTS, NULL,
                          Count, DEBUG_STACK_SOURCE_LINE |
                          DEBUG_STACK_FRAME_ADDRESSES |
                          DEBUG_STACK_COLUMN_NAMES |
                          DEBUG_STACK_FRAME_NUMBERS)) != S_OK)
    {
        Exit(1, "OutputStackTrace failed, 0x%X\n", Status);
    }

    // Done with output.
    if ((Status = g_Client->SetOutputCallbacks(NULL)) != S_OK)
    {
        Exit(1, "SetOutputCallbacks failed, 0x%X\n", Status);
    }

    //
    // The full engine API is available so many other things
    // could be done here.
    //
    // A dump file could be written with WriteDumpFile.
    // The raw stack data could be collected with GetStackTrace and
    // saved along with or instead of the text.
    // An analysis of the current program state could be done
    // to automatically diagnose simple problems.
    //
    // The primary thing to watch out for is that context information
    // for running threads will be stale.  This could be avoided
    // by enumerating and suspending all other threads after the
    // attach completes and then resuming before the assert
    // returns controls.  Otherwise, switching between threads will
    // refresh the thread context and can be used to poll the context
    // state.
    //
}

DWORD
AssertionExceptionDump(PEXCEPTION_POINTERS Exception)
{
    CreateInterfaces();
    SelfAttach();
    DumpStack(Exception->ContextRecord);
    ReleaseInterfaces();
    return EXCEPTION_EXECUTE_HANDLER;
}

void
AssertionFailed(PSTR File, int Line, PSTR ExprText)
{
    printf("Assertion failed: %s(%d):\n    %s\n",
           File, Line, ExprText);

    if (!g_NoDebuggerCheck && IsDebuggerPresent())
    {
        // We're already running under a debugger so just break in.
        DebugBreak();
    }
    else
    {
        // No debugger, so just get a stack from the current
        // routine and then continue on.  We need a context
        // for the currently running code, so force an exception
        // to get an EXCEPTION_POINTERS structure with context
        // information that we can use to get a stack trace.
        __try
        {
            RaiseException(0x1234, 0, 0, NULL);
        }
        __except(AssertionExceptionDump(GetExceptionInformation()))
        {
            // Nothing to do.
        }
    }
}

void
ParseCommandLine(int Argc, char** Argv)
{
    g_Pid = GetCurrentProcessId();
    g_Suspend = FALSE;
    g_NoDebuggerCheck = FALSE;
    
    while (--Argc > 0)
    {
        Argv++;

        if (!strcmp(*Argv, "-d"))
        {
            g_NoDebuggerCheck = TRUE;
        }
        else if (!strcmp(*Argv, "-p"))
        {
            if (Argc < 2)
            {
                Exit(1, "-p missing argument\n");
            }

            Argv++;
            Argc--;

            g_Pid = atoi(*Argv);
        }
        else if (!strcmp(*Argv, "-s"))
        {
            g_Suspend = TRUE;
        }
        else if (!strcmp(*Argv, "-y"))
        {
            if (Argc < 2)
            {
                Exit(1, "-y missing argument\n");
            }

            Argv++;
            Argc--;

            g_SymbolPath = *Argv;
        }
        else
        {
            Exit(1, "Unknown command line argument '%s'\n", *Argv);
        }
    }
}

void __cdecl
main(int Argc, char** Argv)
{
    ParseCommandLine(Argc, Argv);

    DE_ASSERT(Argc == 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\samples\dumpstk\dumpstk.cpp ===
//----------------------------------------------------------------------------
//
// Simple example of how to open a dump file and get its stack.
//
// This is not a debugger extension.  It is a tool that can be used to replace
// the debugger.
//
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <windows.h>
#include <dbgeng.h>

#include "out.hpp"

PSTR g_DumpFile;
PSTR g_ImagePath;
PSTR g_SymbolPath;

ULONG64 g_TraceFrom[3];

IDebugClient* g_Client;
IDebugControl* g_Control;
IDebugSymbols* g_Symbols;

void
Exit(int Code, PCSTR Format, ...)
{
    // Clean up any resources.
    if (g_Symbols != NULL)
    {
        g_Symbols->Release();
    }
    if (g_Control != NULL)
    {
        g_Control->Release();
    }
    if (g_Client != NULL)
    {
        //
        // Request a simple end to any current session.
        // This may or may not do anything but it isn't
        // harmful to call it.
        //

        // We don't want to see any output from the shutdown.
        g_Client->SetOutputCallbacks(NULL);
        
        g_Client->EndSession(DEBUG_END_PASSIVE);
        
        g_Client->Release();
    }

    // Output an error message if given.
    if (Format != NULL)
    {
        va_list Args;

        va_start(Args, Format);
        vfprintf(stderr, Format, Args);
        va_end(Args);
    }
    
    exit(Code);
}

void
CreateInterfaces(void)
{
    HRESULT Status;

    // Start things off by getting an initial interface from
    // the engine.  This can be any engine interface but is
    // generally IDebugClient as the client interface is
    // where sessions are started.
    if ((Status = DebugCreate(__uuidof(IDebugClient),
                              (void**)&g_Client)) != S_OK)
    {
        Exit(1, "DebugCreate failed, 0x%X\n", Status);
    }

    // Query for some other interfaces that we'll need.
    if ((Status = g_Client->QueryInterface(__uuidof(IDebugControl),
                                           (void**)&g_Control)) != S_OK ||
        (Status = g_Client->QueryInterface(__uuidof(IDebugSymbols),
                                           (void**)&g_Symbols)) != S_OK)
    {
        Exit(1, "QueryInterface failed, 0x%X\n", Status);
    }
}

void
ParseCommandLine(int Argc, char** Argv)
{
    int i;
    
    while (--Argc > 0)
    {
        Argv++;

        if (!strcmp(*Argv, "-a32"))
        {
            if (Argc < 4)
            {
                Exit(1, "-a32 missing arguments\n");
            }

            for (i = 0; i < 3; i++)
            {
                int Addr;
                
                Argv++;
                Argc--;

                if (sscanf(*Argv, "%i", &Addr) == EOF)
                {
                    Exit(1, "-a32 illegal argument type\n");
                }

                g_TraceFrom[i] = (ULONG64)(LONG64)(LONG)Addr;
            }
        }
        else if (!strcmp(*Argv, "-a64"))
        {
            if (Argc < 4)
            {
                Exit(1, "-a64 missing arguments\n");
            }

            for (i = 0; i < 3; i++)
            {
                Argv++;
                Argc--;

                if (sscanf(*Argv, "%I64i", &g_TraceFrom[i]) == EOF)
                {
                    Exit(1, "-a64 illegal argument type\n");
                }
            }
        }
        else if (!strcmp(*Argv, "-i"))
        {
            if (Argc < 2)
            {
                Exit(1, "-i missing argument\n");
            }

            Argv++;
            Argc--;

            g_ImagePath = *Argv;
        }
        else if (!strcmp(*Argv, "-y"))
        {
            if (Argc < 2)
            {
                Exit(1, "-y missing argument\n");
            }

            Argv++;
            Argc--;

            g_SymbolPath = *Argv;
        }
        else if (!strcmp(*Argv, "-z"))
        {
            if (Argc < 2)
            {
                Exit(1, "-z missing argument\n");
            }

            Argv++;
            Argc--;

            g_DumpFile = *Argv;
        }
        else
        {
            Exit(1, "Unknown command line argument '%s'\n", *Argv);
        }
    }

    if (g_DumpFile == NULL)
    {
        Exit(1, "No dump file specified, use -z <file>\n");
    }
}

void
ApplyCommandLineArguments(void)
{
    HRESULT Status;

    // Install output callbacks so we get any output that the
    // later calls produce.
    if ((Status = g_Client->SetOutputCallbacks(&g_OutputCb)) != S_OK)
    {
        Exit(1, "SetOutputCallbacks failed, 0x%X\n", Status);
    }

    if (g_ImagePath != NULL)
    {
        if ((Status = g_Symbols->SetImagePath(g_ImagePath)) != S_OK)
        {
            Exit(1, "SetImagePath failed, 0x%X\n", Status);
        }
    }
    if (g_SymbolPath != NULL)
    {
        if ((Status = g_Symbols->SetSymbolPath(g_SymbolPath)) != S_OK)
        {
            Exit(1, "SetSymbolPath failed, 0x%X\n", Status);
        }
    }

    // Everything's set up so open the dump file.
    if ((Status = g_Client->OpenDumpFile(g_DumpFile)) != S_OK)
    {
        Exit(1, "OpenDumpFile failed, 0x%X\n", Status);
    }

    // Finish initialization by waiting for the event that
    // caused the dump.  This will return immediately as the
    // dump file is considered to be at its event.
    if ((Status = g_Control->WaitForEvent(DEBUG_WAIT_DEFAULT,
                                          INFINITE)) != S_OK)
    {
        Exit(1, "WaitForEvent failed, 0x%X\n", Status);
    }

    // Everything is now initialized and we can make any
    // queries we want.
}

void
DumpStack(void)
{
    HRESULT Status;
    PDEBUG_STACK_FRAME Frames = NULL;
    int Count = 50;

    printf("\nFirst %d frames of the call stack:\n", Count);

    if (g_TraceFrom[0] || g_TraceFrom[1] || g_TraceFrom[2])
    {
        ULONG Filled;
        
        Frames = new DEBUG_STACK_FRAME[Count];
        if (Frames == NULL)
        {
            Exit(1, "Unable to allocate stack frames\n");
        }
        
        if ((Status = g_Control->
             GetStackTrace(g_TraceFrom[0], g_TraceFrom[1], g_TraceFrom[2],
                           Frames, Count, &Filled)) != S_OK)
        {
            Exit(1, "GetStackTrace failed, 0x%X\n", Status);
        }

        Count = Filled;
    }
                           
    // Print the call stack.
    if ((Status = g_Control->
         OutputStackTrace(DEBUG_OUTCTL_ALL_CLIENTS, Frames,
                          Count, DEBUG_STACK_SOURCE_LINE |
                          DEBUG_STACK_FRAME_ADDRESSES |
                          DEBUG_STACK_COLUMN_NAMES |
                          DEBUG_STACK_FRAME_NUMBERS)) != S_OK)
    {
        Exit(1, "OutputStackTrace failed, 0x%X\n", Status);
    }

    delete[] Frames;
}

void __cdecl
main(int Argc, char** Argv)
{
    CreateInterfaces();
    
    ParseCommandLine(Argc, Argv);

    ApplyCommandLineArguments();
    
    DumpStack();

    Exit(0, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\samples\exts\dbgexts.h ===
/*++

    Copyright (c) 2000  Microsoft Corporation

Module Name:

    dbgexts.h

--*/

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define KDEXT_64BIT
#include <wdbgexts.h>
#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif


#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status; 

#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

#define EXIT_API     ExtRelease


// Global variables initialized by query.
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYMBOLS2       g_ExtSymbols2;

extern BOOL  Connected;
extern ULONG TargetMachine;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);

HRESULT 
NotifyOnTargetAccessible(PDEBUG_CONTROL Control);

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\samples\healer\healer.cpp ===
//----------------------------------------------------------------------------
//
// Sample of monitoring an application for compatibility problems
// and automatically correcting them.
//
// Copyright (C) Microsoft Corporation, 2000-2001.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <windows.h>
#include <dbgeng.h>

PSTR g_SymbolPath;
char g_CommandLine[8 * MAX_PATH];
BOOL g_Verbose;
BOOL g_NeedVersionBps;

IDebugClient* g_Client;
IDebugControl* g_Control;
IDebugDataSpaces* g_Data;
IDebugRegisters* g_Registers;
IDebugSymbols* g_Symbols;

struct BREAKPOINT
{
    IDebugBreakpoint* Bp;
    ULONG Id;
};

BREAKPOINT g_GetVersionBp;
BREAKPOINT g_GetVersionRetBp;
BREAKPOINT g_GetVersionExBp;
BREAKPOINT g_GetVersionExRetBp;

ULONG g_EaxIndex = DEBUG_ANY_ID;
OSVERSIONINFO g_OsVer;
DWORD g_VersionNumber;
ULONG64 g_OsVerOffset;

//----------------------------------------------------------------------------
//
// Utility routines.
//
//----------------------------------------------------------------------------

void
Exit(int Code, PCSTR Format, ...)
{
    // Clean up any resources.
    if (g_Control != NULL)
    {
        g_Control->Release();
    }
    if (g_Data != NULL)
    {
        g_Data->Release();
    }
    if (g_Registers != NULL)
    {
        g_Registers->Release();
    }
    if (g_Symbols != NULL)
    {
        g_Symbols->Release();
    }
    if (g_Client != NULL)
    {
        //
        // Request a simple end to any current session.
        // This may or may not do anything but it isn't
        // harmful to call it.
        //

        g_Client->EndSession(DEBUG_END_PASSIVE);
        
        g_Client->Release();
    }

    // Output an error message if given.
    if (Format != NULL)
    {
        va_list Args;

        va_start(Args, Format);
        vfprintf(stderr, Format, Args);
        va_end(Args);
    }
    
    exit(Code);
}

void
Print(PCSTR Format, ...)
{
    va_list Args;

    printf("HEALER: ");
    va_start(Args, Format);
    vprintf(Format, Args);
    va_end(Args);
}

HRESULT
AddBp(BREAKPOINT* Bp, PCSTR Expr)
{
    HRESULT Status;
    
    if ((Status = g_Control->AddBreakpoint(DEBUG_BREAKPOINT_CODE, DEBUG_ANY_ID,
                                           &Bp->Bp)) != S_OK)
    {
        Bp->Id = DEBUG_ANY_ID;
        return Status;
    }

    if ((Status = Bp->Bp->GetId(&Bp->Id)) != S_OK ||
        (Status = Bp->Bp->SetOffsetExpression(Expr)) != S_OK ||
        (Status = Bp->Bp->AddFlags(DEBUG_BREAKPOINT_ENABLED)) != S_OK)
    {
        Bp->Bp->Release();
        Bp->Id = DEBUG_ANY_ID;
        return Status;
    }

    return S_OK;
}

//----------------------------------------------------------------------------
//
// Healing routines.
//
//----------------------------------------------------------------------------

void
ApplyExePatches(PCSTR ImageName, ULONG64 BaseOffset)
{
    if (ImageName == NULL)
    {
        ImageName = "<Unknown>";
    }
    
    // This would be where any executable image patching would go.
    Print("Executable '%s' loaded at %I64x\n", ImageName, BaseOffset);
}

void
ApplyDllPatches(PCSTR ImageName, ULONG64 BaseOffset)
{
    if (ImageName == NULL)
    {
        ImageName = "<Unknown>";
    }
    
    // Any DLL-specific image patching goes here.
    Print("DLL '%s' loaded at %I64x\n", ImageName, BaseOffset);
}

void
AddVersionBps(void)
{
    //
    // Put breakpoints on GetVersion and GetVersionEx.
    //

    if (AddBp(&g_GetVersionBp, "kernel32!GetVersion") != S_OK ||
        AddBp(&g_GetVersionExBp, "kernel32!GetVersionEx") != S_OK)
    {
        Exit(1, "Unable to set version breakpoints\n");
    }

    //
    // Create the return breakpoints but leave them disabled
    // until they're needed.
    //
    
    if (g_Control->AddBreakpoint(DEBUG_BREAKPOINT_CODE, DEBUG_ANY_ID,
                                 &g_GetVersionRetBp.Bp) != S_OK ||
        g_GetVersionRetBp.Bp->GetId(&g_GetVersionRetBp.Id) != S_OK ||
        g_Control->AddBreakpoint(DEBUG_BREAKPOINT_CODE, DEBUG_ANY_ID,
                                 &g_GetVersionExRetBp.Bp) != S_OK ||
        g_GetVersionExRetBp.Bp->GetId(&g_GetVersionExRetBp.Id) != S_OK)
    {
        Exit(1, "Unable to set version breakpoints\n");
    }
}

//----------------------------------------------------------------------------
//
// Event callbacks.
//
//----------------------------------------------------------------------------

class EventCallbacks : public DebugBaseEventCallbacks
{
public:
    // IUnknown.
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugEventCallbacks.
    STDMETHOD(GetInterestMask)(
        THIS_
        OUT PULONG Mask
        );
    
    STDMETHOD(Breakpoint)(
        THIS_
        IN PDEBUG_BREAKPOINT Bp
        );
    STDMETHOD(Exception)(
        THIS_
        IN PEXCEPTION_RECORD64 Exception,
        IN ULONG FirstChance
        );
    STDMETHOD(CreateProcess)(
        THIS_
        IN ULONG64 ImageFileHandle,
        IN ULONG64 Handle,
        IN ULONG64 BaseOffset,
        IN ULONG ModuleSize,
        IN PCSTR ModuleName,
        IN PCSTR ImageName,
        IN ULONG CheckSum,
        IN ULONG TimeDateStamp,
        IN ULONG64 InitialThreadHandle,
        IN ULONG64 ThreadDataOffset,
        IN ULONG64 StartOffset
        );
    STDMETHOD(LoadModule)(
        THIS_
        IN ULONG64 ImageFileHandle,
        IN ULONG64 BaseOffset,
        IN ULONG ModuleSize,
        IN PCSTR ModuleName,
        IN PCSTR ImageName,
        IN ULONG CheckSum,
        IN ULONG TimeDateStamp
        );
    STDMETHOD(SessionStatus)(
        THIS_
        IN ULONG Status
        );
};

STDMETHODIMP_(ULONG)
EventCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
EventCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
EventCallbacks::GetInterestMask(
    THIS_
    OUT PULONG Mask
    )
{
    *Mask =
        DEBUG_EVENT_BREAKPOINT |
        DEBUG_EVENT_EXCEPTION |
        DEBUG_EVENT_CREATE_PROCESS |
        DEBUG_EVENT_LOAD_MODULE |
        DEBUG_EVENT_SESSION_STATUS;
    return S_OK;
}

STDMETHODIMP
EventCallbacks::Breakpoint(
    THIS_
    IN PDEBUG_BREAKPOINT Bp
    )
{
    ULONG Id;
    ULONG64 ReturnOffset;

    if (Bp->GetId(&Id) != S_OK)
    {
        return DEBUG_STATUS_BREAK;
    }

    if (Id == g_GetVersionBp.Id)
    {
        // Set a breakpoint on the return address of the call
        // so that we can patch up any returned information.
        if (g_Control->GetReturnOffset(&ReturnOffset) != S_OK ||
            g_GetVersionRetBp.Bp->SetOffset(ReturnOffset) != S_OK ||
            g_GetVersionRetBp.Bp->AddFlags(DEBUG_BREAKPOINT_ENABLED) != S_OK)
        {
            return DEBUG_STATUS_BREAK;
        }
    }
    else if (Id == g_GetVersionExBp.Id)
    {
        ULONG64 StackOffset;
        
        // Remember the OSVERSIONINFO structure pointer.
        if (g_Registers->GetStackOffset(&StackOffset) != S_OK ||
            g_Data->ReadPointersVirtual(1, StackOffset + 4,
                                        &g_OsVerOffset) != S_OK)
        {
            return DEBUG_STATUS_BREAK;
        }
        
        // Set a breakpoint on the return address of the call
        // so that we can patch up any returned information.
        if (g_Control->GetReturnOffset(&ReturnOffset) != S_OK ||
            g_GetVersionExRetBp.Bp->SetOffset(ReturnOffset) != S_OK ||
            g_GetVersionExRetBp.Bp->AddFlags(DEBUG_BREAKPOINT_ENABLED) != S_OK)
        {
            return DEBUG_STATUS_BREAK;
        }
    }
    else if (Id == g_GetVersionRetBp.Id)
    {
        // Turn off the breakpoint.
        if (g_GetVersionRetBp.Bp->
            RemoveFlags(DEBUG_BREAKPOINT_ENABLED) != S_OK)
        {
            return DEBUG_STATUS_BREAK;
        }
        
        DEBUG_VALUE Val;
        
        // Change eax to alter the returned version value.
        Val.Type = DEBUG_VALUE_INT32;
        Val.I32 = g_VersionNumber;
        if (g_Registers->SetValue(g_EaxIndex, &Val) != S_OK)
        {
            return DEBUG_STATUS_BREAK;
        }

        Print("GetVersion returns %08X\n", g_VersionNumber);
    }
    else if (Id == g_GetVersionExRetBp.Id)
    {
        ULONG Done;
        
        // Turn off the breakpoint.
        if (g_GetVersionExRetBp.Bp->
            RemoveFlags(DEBUG_BREAKPOINT_ENABLED) != S_OK)
        {
            return DEBUG_STATUS_BREAK;
        }
        
        // Change the returned OSVERSIONINFO structure.
        if (g_Data->WriteVirtual(g_OsVerOffset, &g_OsVer, sizeof(g_OsVer),
                                 &Done) != S_OK ||
            Done != sizeof(g_OsVer))
        {
            return DEBUG_STATUS_BREAK;
        }

        Print("GetVersionEx returns %08X\n", g_VersionNumber);
    }
    else
    {
        return DEBUG_STATUS_NO_CHANGE;
    }
    
    return DEBUG_STATUS_GO;
}

STDMETHODIMP
EventCallbacks::Exception(
    THIS_
    IN PEXCEPTION_RECORD64 Exception,
    IN ULONG FirstChance
    )
{
    // We want to handle these exceptions on the first
    // chance to make it look like no exception ever
    // happened.  Handling them on the second chance would
    // allow an exception handler somewhere in the app
    // to be hit on the first chance.
    if (!FirstChance)
    {
        return DEBUG_STATUS_NO_CHANGE;
    }

    //
    // Check and see if the instruction causing the exception
    // is a cli or sti.  These are not allowed in user-mode
    // programs on NT so if they're present just nop them.
    //

    // sti/cli will generate privileged instruction faults.
    if (Exception->ExceptionCode != STATUS_PRIVILEGED_INSTRUCTION)
    {
        return DEBUG_STATUS_NO_CHANGE;
    }

    UCHAR Instr;
    ULONG Done;
    
    // It's a privileged instruction, so check the code for sti/cli.
    if (g_Data->ReadVirtual(Exception->ExceptionAddress, &Instr,
                            sizeof(Instr), &Done) != S_OK ||
        Done != sizeof(Instr) ||
        (Instr != 0xfb && Instr != 0xfa))
    {
        return DEBUG_STATUS_NO_CHANGE;
    }

    // It's a sti/cli, so nop it out and continue.
    Instr = 0x90;
    if (g_Data->WriteVirtual(Exception->ExceptionAddress, &Instr,
                             sizeof(Instr), &Done) != S_OK ||
        Done != sizeof(Instr))
    {
        return DEBUG_STATUS_NO_CHANGE;
    }

    // Fixed.
    if (g_Verbose)
    {
        Print("Removed sti/cli at %I64x\n", Exception->ExceptionAddress);
    }
    
    return DEBUG_STATUS_GO_HANDLED;
}

STDMETHODIMP
EventCallbacks::CreateProcess(
    THIS_
    IN ULONG64 ImageFileHandle,
    IN ULONG64 Handle,
    IN ULONG64 BaseOffset,
    IN ULONG ModuleSize,
    IN PCSTR ModuleName,
    IN PCSTR ImageName,
    IN ULONG CheckSum,
    IN ULONG TimeDateStamp,
    IN ULONG64 InitialThreadHandle,
    IN ULONG64 ThreadDataOffset,
    IN ULONG64 StartOffset
    )
{
    UNREFERENCED_PARAMETER(ImageFileHandle);
    UNREFERENCED_PARAMETER(Handle);
    UNREFERENCED_PARAMETER(ModuleSize);
    UNREFERENCED_PARAMETER(ModuleName);
    UNREFERENCED_PARAMETER(CheckSum);
    UNREFERENCED_PARAMETER(TimeDateStamp);
    UNREFERENCED_PARAMETER(InitialThreadHandle);
    UNREFERENCED_PARAMETER(ThreadDataOffset);
    UNREFERENCED_PARAMETER(StartOffset);
    
    // The process is now available for manipulation.
    // Perform any initial code patches on the executable.
    ApplyExePatches(ImageName, BaseOffset);

    // If the user requested that version calls be fixed up
    // register breakpoints to do so.
    if (g_NeedVersionBps)
    {
        AddVersionBps();
    }
    
    return DEBUG_STATUS_GO;
}

STDMETHODIMP
EventCallbacks::LoadModule(
    THIS_
    IN ULONG64 ImageFileHandle,
    IN ULONG64 BaseOffset,
    IN ULONG ModuleSize,
    IN PCSTR ModuleName,
    IN PCSTR ImageName,
    IN ULONG CheckSum,
    IN ULONG TimeDateStamp
    )
{
    UNREFERENCED_PARAMETER(ImageFileHandle);
    UNREFERENCED_PARAMETER(ModuleSize);
    UNREFERENCED_PARAMETER(ModuleName);
    UNREFERENCED_PARAMETER(CheckSum);
    UNREFERENCED_PARAMETER(TimeDateStamp);
    
    ApplyDllPatches(ImageName, BaseOffset);
    return DEBUG_STATUS_GO;
}

STDMETHODIMP
EventCallbacks::SessionStatus(
    THIS_
    IN ULONG SessionStatus
    )
{
    // A session isn't fully active until WaitForEvent
    // has been called and has processed the initial
    // debug events.  We need to wait for activation
    // before we query information about the session
    // as not all information is available until the
    // session is fully active.  We could put these
    // queries into CreateProcess as that happens
    // early and when the session is fully active, but
    // for example purposes we'll wait for an
    // active SessionStatus callback.
    // In non-callback applications this work can just
    // be done after the first successful WaitForEvent.
    if (SessionStatus != DEBUG_SESSION_ACTIVE)
    {
        return S_OK;
    }
    
    HRESULT Status;
    
    //
    // Find the register index for eax as we'll need
    // to access eax.
    //

    if ((Status = g_Registers->GetIndexByName("eax", &g_EaxIndex)) != S_OK)
    {
        Exit(1, "GetIndexByName failed, 0x%X\n", Status);
    }

    return S_OK;
}

EventCallbacks g_EventCb;

//----------------------------------------------------------------------------
//
// Initialization and main event loop.
//
//----------------------------------------------------------------------------

void
CreateInterfaces(void)
{
    SYSTEM_INFO SysInfo;
    
    // For purposes of keeping this example simple the
    // code only works on x86 machines.  There's no reason
    // that it couldn't be made to work on all processors, though.
    GetSystemInfo(&SysInfo);
    if (SysInfo.wProcessorArchitecture != PROCESSOR_ARCHITECTURE_INTEL)
    {
        Exit(1, "This program only runs on x86 machines.\n");
    }

    // Get default version information.
    g_OsVer.dwOSVersionInfoSize = sizeof(g_OsVer);
    if (!GetVersionEx(&g_OsVer))
    {
        Exit(1, "GetVersionEx failed, %d\n", GetLastError());
    }

    HRESULT Status;

    // Start things off by getting an initial interface from
    // the engine.  This can be any engine interface but is
    // generally IDebugClient as the client interface is
    // where sessions are started.
    if ((Status = DebugCreate(__uuidof(IDebugClient),
                              (void**)&g_Client)) != S_OK)
    {
        Exit(1, "DebugCreate failed, 0x%X\n", Status);
    }

    // Query for some other interfaces that we'll need.
    if ((Status = g_Client->QueryInterface(__uuidof(IDebugControl),
                                           (void**)&g_Control)) != S_OK ||
        (Status = g_Client->QueryInterface(__uuidof(IDebugDataSpaces),
                                           (void**)&g_Data)) != S_OK ||
        (Status = g_Client->QueryInterface(__uuidof(IDebugRegisters),
                                           (void**)&g_Registers)) != S_OK ||
        (Status = g_Client->QueryInterface(__uuidof(IDebugSymbols),
                                           (void**)&g_Symbols)) != S_OK)
    {
        Exit(1, "QueryInterface failed, 0x%X\n", Status);
    }
}

void
ParseCommandLine(int Argc, char** Argv)
{
    while (--Argc > 0)
    {
        Argv++;

        if (!strcmp(*Argv, "-plat"))
        {
            if (Argc < 2)
            {
                Exit(1, "-plat missing argument\n");
            }

            Argv++;
            Argc--;

            sscanf(*Argv, "%i", &g_OsVer.dwPlatformId);
            g_NeedVersionBps = TRUE;
        }
        else if (!strcmp(*Argv, "-v"))
        {
            g_Verbose = TRUE;
        }
        else if (!strcmp(*Argv, "-ver"))
        {
            if (Argc < 2)
            {
                Exit(1, "-ver missing argument\n");
            }

            Argv++;
            Argc--;

            sscanf(*Argv, "%i.%i.%i",
                   &g_OsVer.dwMajorVersion, &g_OsVer.dwMinorVersion,
                   &g_OsVer.dwBuildNumber);
            g_NeedVersionBps = TRUE;
        }
        else if (!strcmp(*Argv, "-y"))
        {
            if (Argc < 2)
            {
                Exit(1, "-y missing argument\n");
            }

            Argv++;
            Argc--;

            g_SymbolPath = *Argv;
        }
        else
        {
            // Assume process arguments begin.
            break;
        }
    }
    
    //
    // Concatenate remaining arguments into a command line.
    //
    
    PSTR CmdLine = g_CommandLine;
    
    while (Argc > 0)
    {
        BOOL Quote = FALSE;
        ULONG Len;
        
        // Quote arguments with spaces.
        if (strchr(*Argv, ' ') != NULL || strchr(*Argv, '\t') != NULL)
        {
            *CmdLine++ = '"';
            Quote = TRUE;
        }

        Len = strlen(*Argv);
        if (Len + (CmdLine - g_CommandLine) >= sizeof(g_CommandLine))
        {
            Exit(1, "Command line too long\n");
        }
        memcpy(CmdLine, *Argv, Len + 1);
        CmdLine += Len;

        if (Quote)
        {
            *CmdLine++ = '"';
        }

        *CmdLine++ = ' ';
        
        Argv++;
        Argc--;
    }

    *CmdLine = 0;

    if (strlen(g_CommandLine) == 0)
    {
        Exit(1, "No application command line given\n");
    }
}

void
ApplyCommandLineArguments(void)
{
    HRESULT Status;

    if (g_SymbolPath != NULL)
    {
        if ((Status = g_Symbols->SetSymbolPath(g_SymbolPath)) != S_OK)
        {
            Exit(1, "SetSymbolPath failed, 0x%X\n", Status);
        }
    }

    // Register our event callbacks.
    if ((Status = g_Client->SetEventCallbacks(&g_EventCb)) != S_OK)
    {
        Exit(1, "SetEventCallbacks failed, 0x%X\n", Status);
    }
    
    // Everything's set up so start the app.
    if ((Status = g_Client->CreateProcess(0, g_CommandLine,
                                          DEBUG_ONLY_THIS_PROCESS)) != S_OK)
    {
        Exit(1, "CreateProcess failed, 0x%X\n", Status);
    }

    // Compute the GetVersion value from the OSVERSIONINFO.
    g_VersionNumber = (g_OsVer.dwMajorVersion & 0xff) |
        ((g_OsVer.dwMinorVersion & 0xff) << 8);
    if (g_OsVer.dwPlatformId == VER_PLATFORM_WIN32_NT)
    {
        g_VersionNumber |= (g_OsVer.dwBuildNumber & 0x7fff) << 16;
    }
    else
    {
        g_VersionNumber |= 0x80000000;
    }
}

void
EventLoop(void)
{
    HRESULT Status;

    for (;;)
    {
        if ((Status = g_Control->WaitForEvent(DEBUG_WAIT_DEFAULT,
                                              INFINITE)) != S_OK)
        {
            ULONG ExecStatus;
            
            // Check and see whether the session is running or not.
            if (g_Control->GetExecutionStatus(&ExecStatus) == S_OK &&
                ExecStatus == DEBUG_STATUS_NO_DEBUGGEE)
            {
                // The session ended so we can quit.
                break;
            }

            // There was a real error.
            Exit(1, "WaitForEvent failed, 0x%X\n", Status);
        }

        // Our event callbacks asked to break in.  This
        // only occurs in situations when the callback
        // couldn't handle the event.  See if the user cares.
        if (MessageBox(GetDesktopWindow(),
                       "An unusual event occurred.  Ignore it?",
                       "Unhandled Event", MB_YESNO) == IDNO)
        {
            Exit(1, "Unhandled event\n");
        }

        // User chose to ignore so restart things.
        if ((Status = g_Control->
             SetExecutionStatus(DEBUG_STATUS_GO_HANDLED)) != S_OK)
        {
            Exit(1, "SetExecutionStatus failed, 0x%X\n", Status);
        }
    }
}

void __cdecl
main(int Argc, char** Argv)
{
    CreateInterfaces();
    
    ParseCommandLine(Argc, Argv);

    ApplyCommandLineArguments();

    EventLoop();

    Exit(0, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\samples\exts\dbgexts.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dbgexts.cpp

Abstract:

    This file contains the generic routines and initialization code
    for the debugger extensions dll.

--*/

#include "dbgexts.h"


PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYMBOLS2       g_ExtSymbols2;

WINDBG_EXTENSION_APIS   ExtensionApis;

ULONG   TargetMachine;
BOOL    Connected;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                (void **)&g_ExtSymbols)) != S_OK)
    {
	goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols2),
                                (void **)&g_ExtSymbols2)) != S_OK)
    {
	goto Fail;
    }
    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSymbols2);
}

extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                  (void **)&DebugControl)) == S_OK)
    {

        //
        // Get the windbg-style extension APIS
        //
        ExtensionApis.nSize = sizeof (ExtensionApis);
        if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK)
            return Hr;
        
        DebugControl->Release();

    }
    DebugClient->Release();
    return S_OK;
}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    UNREFERENCED_PARAMETER(Argument);
    
    //
    // The first time we actually connect to a target
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        HRESULT Hr;
        PDEBUG_CONTROL DebugControl;

        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK)
        {
            //
            // Get the architecture type.
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                       (void **)&DebugControl)) == S_OK)
            {
                if ((Hr = DebugControl->GetActualProcessorType(
                                             &TargetMachine)) == S_OK)
                {
                    Connected = TRUE;
                }

                NotifyOnTargetAccessible(DebugControl);

                DebugControl->Release();
            }
 
            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\samples\healer\test\healtest.cpp ===
//----------------------------------------------------------------------------
//
// Test program for the healer sample.
//
// Copyright (C) Microsoft Corporation, 2000.
//
//----------------------------------------------------------------------------

#include <stdio.h>
#include <windows.h>

void __cdecl
main(int Argc, char** Argv)
{
    printf("GetVersion returns %08X\n", GetVersion());
    
    OSVERSIONINFO OsVer;

    OsVer.dwOSVersionInfoSize = sizeof(OsVer);
    if (GetVersionEx(&OsVer))
    {
        switch(OsVer.dwPlatformId)
        {
        case VER_PLATFORM_WIN32_NT:
            printf("Windows NT/2000 ");
            break;
        case VER_PLATFORM_WIN32_WINDOWS:
            printf("Windows 9x/ME ");
            break;
        default:
            printf("Platform %d ", OsVer.dwPlatformId);
            break;
        }

        printf("%d.%02d.%04d\n", OsVer.dwMajorVersion, OsVer.dwMinorVersion,
               OsVer.dwBuildNumber);
    }
    else
    {
        printf("GetVersionEx failed, %d\n", GetLastError());
    }
    
    int i;
    
    printf("\nUsing sti/cli\n");
    for (i = 0; i < 10; i++)
    {
        printf(" %d", i);
        __asm sti;
        __asm cli;
    }
    printf("\n");

    printf("\nSuccessful\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\samples\exts\exts.cpp ===
/*-----------------------------------------------------------------------------
   Copyright (c) 2000  Microsoft Corporation

Module:
  exts.cpp
  
  Sampe file showing couple of extension examples

-----------------------------------------------------------------------------*/
#include "dbgexts.h"


/*
   Sample extension to demonstrate executing debugger command
   
 */
HRESULT CALLBACK 
cmdsample(PDEBUG_CLIENT Client, PCSTR args)
{
    CHAR Input[256];
    INIT_API();

    UNREFERENCED_PARAMETER(args);

    //
    // Output a 10 frame stack
    //
    g_ExtControl->OutputStackTrace(DEBUG_OUTCTL_ALL_CLIENTS |   // Flags on what to do with output
                                   DEBUG_OUTCTL_OVERRIDE_MASK |
                                   DEBUG_OUTCTL_NOT_LOGGED, 
                                   NULL, 
                                   10,           // number of frames to display
                                   DEBUG_STACK_FUNCTION_INFO | DEBUG_STACK_COLUMN_NAMES |
                                   DEBUG_STACK_ARGUMENTS | DEBUG_STACK_FRAME_ADDRESSES);
    //
    // Engine interface for print 
    //
    g_ExtControl->Output(DEBUG_OUTCTL_ALL_CLIENTS, "\n\nDebugger module list\n");
    
    //
    // list all the modules by executing lm command
    //
    g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                          DEBUG_OUTCTL_OVERRIDE_MASK |
                          DEBUG_OUTCTL_NOT_LOGGED,
                          "lm", // Command to be executed
                          DEBUG_EXECUTE_DEFAULT );
    
    //
    // Ask for user input
    //
    g_ExtControl->Output(DEBUG_OUTCTL_ALL_CLIENTS, "\n\n***User Input sample\n\nEnter Command to run : ");
    GetInputLine(NULL, &Input[0], sizeof(Input));
    g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                          DEBUG_OUTCTL_OVERRIDE_MASK |
                          DEBUG_OUTCTL_NOT_LOGGED,
                          Input, // Command to be executed
                          DEBUG_EXECUTE_DEFAULT );
    
    EXIT_API();
    return S_OK;
}

/*
  Sample extension to read and dump a struct on target
    
  This reads the struct _EXCEPTION_RECORD which is defined as:
  
  typedef struct _EXCEPTION_RECORD {
    NTSTATUS ExceptionCode;
    ULONG ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    ULONG NumberParameters;
    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
    } EXCEPTION_RECORD;
*/
HRESULT CALLBACK 
structsample(PDEBUG_CLIENT Client, PCSTR args)
{
    ULONG64 Address;
    INIT_API();

    Address = GetExpression(args);
    
    DWORD Buffer[4], cb;

    // Read and display first 4 dwords at Address
    if (ReadMemory(Address, &Buffer, sizeof(Buffer), &cb) && cb == sizeof(Buffer)) {
        dprintf("%p: %08lx %08lx %08lx %08lx\n\n", Address,
                Buffer[0], Buffer[1], Buffer[2], Buffer[3]);
    }

    //
    // Method 1 to dump a struct
    //
    dprintf("Method 1:\n");
    // Inititalze type read from the Address
    if (InitTypeRead(Address, _EXCEPTION_RECORD) != 0) {
        dprintf("Error in reading _EXCEPTION_RECORD at %p", // Use %p to print pointer values
                Address);
    } else {
        // read and dump the fields
        dprintf("_EXCEPTION_RECORD @ %p\n", Address);
        dprintf("\tExceptionCode           : %lx\n", (ULONG) ReadField(ExceptionCode));
        dprintf("\tExceptionAddress        : %p\n", ReadField(ExceptionAddress));
        dprintf("\tExceptionInformation[1] : %I64lx\n", ReadField(ExceptionInformation[1]));
        // And so on...
    }

    //
    // Method 2 to read a struct
    //
    ULONG64 ExceptionInformation_1, ExceptionAddress, ExceptionCode;
    dprintf("\n\nMethod 2:\n");
    // Read and dump the fields by specifying type and address individually 
    if (GetFieldValue(Address, "_EXCEPTION_RECORD", "ExceptionCode", ExceptionCode)) {
        dprintf("Error in reading _EXCEPTION_RECORD at %p\n",
                Address);
    } else {
        // Pointers are read as ULONG64 values
        GetFieldValue(Address, "_EXCEPTION_RECORD", "ExceptionAddress", ExceptionAddress);
        GetFieldValue(Address, "_EXCEPTION_RECORD", "ExceptionInformation[1]", ExceptionInformation_1);
        // And so on..
        
        dprintf("_EXCEPTION_RECORD @ %p\n", Address);
        dprintf("\tExceptionCode           : %lx\n", ExceptionCode);
        dprintf("\tExceptionAddress        : %p\n", ExceptionAddress);
        dprintf("\tExceptionInformation[1] : %I64lx\n", ExceptionInformation_1);
    }

    ULONG64 Module;
    ULONG   i, TypeId;
    CHAR Name[MAX_PATH];
    //
    // To get/list field names
    //
    g_ExtSymbols->GetSymbolTypeId("_EXCEPTION_RECORD", &TypeId, &Module);
    dprintf("Fields of _EXCEPTION_RECORD\n");
    for (i=0; ;i++) {
    	HRESULT Hr;
    	ULONG Offset=0;
    
    	Hr = g_ExtSymbols2->GetFieldName(Module, TypeId, i, Name, MAX_PATH, NULL);
    	if (Hr == S_OK) {
    	    g_ExtSymbols->GetFieldOffset(Module, TypeId, Name, &Offset);
    	    dprintf("%lx (+%03lx) %s\n", i, Offset, Name);
    	} else if (Hr == E_INVALIDARG) {
    	    // All Fields done
    	    break;
    	} else {
    	    dprintf("GetFieldName Failed %lx\n", Hr);
    	    break;
    	}
    }

    //
    // Get name for an enumerate
    //
    //     typedef enum {
    //        Enum1,
    //	      Enum2,
    //        Enum3,
    //     } TEST_ENUM;
    //
    ULONG   ValueOfEnum = 0;
    g_ExtSymbols->GetSymbolTypeId("TEST_ENUM", &TypeId, &Module);
    g_ExtSymbols2->GetConstantName(Module, TypeId, ValueOfEnum, Name, MAX_PATH, NULL);
    dprintf("Testenum %I64lx == %s\n", ExceptionCode, Name);
    // This prints out, Testenum 0 == Enum1

    //
    // Read an array
    //
    //    typedef struct FOO_TYPE {
    //      ULONG Bar;
    //      ULONG Bar2;
    //    } FOO_TYPE;
    //
    //    FOO_TYPE sampleArray[20];
    ULONG Bar, Bar2;
    CHAR TypeName[100];
    for (i=0; i<20; i++) {
    	sprintf(TypeName, "sampleArray[%lx]", i);
    	if (GetFieldValue(0, TypeName, "Bar", Bar)) 
    	    break;
    	GetFieldValue(0, TypeName, "Bar2", Bar2);
    	dprintf("%16s -  Bar %2ld  Bar2 %ld\n", TypeName, Bar, Bar2);
    }

    EXIT_API();
    return S_OK;
}

/*
  This gets called (by DebugExtensionNotify whentarget is halted and is accessible
*/
HRESULT 
NotifyOnTargetAccessible(PDEBUG_CONTROL Control)
{
    dprintf("Extension dll detected a break");
    if (Connected) {
        dprintf(" connected to ");
        switch (TargetMachine) { 
        case IMAGE_FILE_MACHINE_I386:
            dprintf("X86");
            break;
        case IMAGE_FILE_MACHINE_IA64:
            dprintf("IA64");
            break;
        default:
            dprintf("Other");
            break;
        }
    }
    dprintf("\n");
    
    //
    // show the top frame and execute dv to dump the locals here and return
    //
    Control->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                     DEBUG_OUTCTL_OVERRIDE_MASK |
                     DEBUG_OUTCTL_NOT_LOGGED,
                     ".frame", // Command to be executed
                     DEBUG_EXECUTE_DEFAULT );
    Control->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                     DEBUG_OUTCTL_OVERRIDE_MASK |
                     DEBUG_OUTCTL_NOT_LOGGED,
                     "dv", // Command to be executed
                     DEBUG_EXECUTE_DEFAULT );
    return S_OK;
}

/*
  A built-in help for the extension dll
*/
HRESULT CALLBACK 
help(PDEBUG_CLIENT Client, PCSTR args)
{
    INIT_API();

    UNREFERENCED_PARAMETER(args);

    dprintf("Help for dbgexts.dll\n"
            "  cmdsample           - This does stacktrace and lists\n"
            "  help                = Shows this help\n"
            "  structsample <addr> - This dumps a struct at given address\n"
            );
    EXIT_API();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\samples\remmon\remmon.cpp ===
//----------------------------------------------------------------------------
//
// Example of how to connect to a debugger server and execute
// a command when the server is broken in.
//
// Copyright (C) Microsoft Corporation, 2002.
//
//----------------------------------------------------------------------------

#include <stdlib.h>
#include <stdio.h>
#include <stdarg.h>
#include <windows.h>
#include <dbgeng.h>

BOOL g_ForceBreak;
PSTR g_Connect;
PSTR g_Command = ".echo Broken in";

IDebugClient* g_Client;
IDebugClient* g_ExitDispatchClient;
IDebugControl* g_Control;
ULONG g_ExecStatus;

//----------------------------------------------------------------------------
//
// Event callbacks.
//
//----------------------------------------------------------------------------

class EventCallbacks : public DebugBaseEventCallbacks
{
public:
    // IUnknown.
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugEventCallbacks.
    STDMETHOD(GetInterestMask)(
        THIS_
        OUT PULONG Mask
        );
    
    STDMETHOD(ChangeEngineState)(
        THIS_
        IN ULONG Flags,
        IN ULONG64 Argument
        );
};

STDMETHODIMP_(ULONG)
EventCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
EventCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
EventCallbacks::GetInterestMask(
    THIS_
    OUT PULONG Mask
    )
{
    *Mask = DEBUG_EVENT_CHANGE_ENGINE_STATE;
    return S_OK;
}

STDMETHODIMP
EventCallbacks::ChangeEngineState(
    THIS_
    IN ULONG Flags,
    IN ULONG64 Argument
    )
{
    if (Flags & DEBUG_CES_EXECUTION_STATUS)
    {
        g_ExecStatus = (ULONG)Argument;

        // If this notification came from a wait completing
        // we want to wake up the input thread so that new
        // commands can be processed.  If it came from inside
        // a wait we don't want to ask for input as the engine
        // may go back to running at any time.
        if (!(Argument & DEBUG_STATUS_INSIDE_WAIT))
        {
            // Wake up the wait loop.
            g_ExitDispatchClient->ExitDispatch(g_Client);
        }
    }
    
    return S_OK;
}

EventCallbacks g_EventCb;

//----------------------------------------------------------------------------
//
// Functions.
//
//----------------------------------------------------------------------------

void
Exit(int Code, PCSTR Format, ...)
{
    // Clean up any resources.
    if (g_Control != NULL)
    {
        g_Control->Release();
    }
    if (g_ExitDispatchClient != NULL)
    {
        g_ExitDispatchClient->Release();
    }
    if (g_Client != NULL)
    {
        g_Client->EndSession(DEBUG_END_DISCONNECT);
        g_Client->Release();
    }

    // Output an error message if given.
    if (Format != NULL)
    {
        va_list Args;

        va_start(Args, Format);
        vfprintf(stderr, Format, Args);
        va_end(Args);
    }
    
    exit(Code);
}

void
CreateInterfaces(void)
{
    HRESULT Status;

    // Start things off by getting an initial interface from
    // the engine.  This can be any engine interface but is
    // generally IDebugClient as the client interface is
    // where sessions are started.
    if ((Status = DebugConnect(g_Connect,
                               __uuidof(IDebugClient),
                              (void**)&g_Client)) != S_OK)
    {
        Exit(1, "DebugConnect(%s) failed, 0x%X\n",
             g_Connect, Status);
    }

    // Query for some other interfaces that we'll need.
    if ((Status = g_Client->QueryInterface(__uuidof(IDebugControl),
                                           (void**)&g_Control)) != S_OK)
    {
        Exit(1, "QueryInterface failed, 0x%X\n", Status);
    }

    if ((Status = g_Client->SetEventCallbacks(&g_EventCb)) != S_OK)
    {
        Exit(1, "SetEventCallbacks failed, 0x%X\n", Status);
    }

    //
    // This app may wait inside of a DispatchCallbacks
    // while it's waiting for the server to break in.
    // We'll need to be able to exit that dispatch so
    // we need another connection to the server to
    // send the exit request.
    //
    // This could all be avoided by simply doing a polling
    // loop when waiting, but the intent of this sample
    // is to show some of the more advanced callback-driven
    // techniques.
    //

    if ((Status = DebugConnect(g_Connect,
                               __uuidof(IDebugClient),
                              (void**)&g_ExitDispatchClient)) != S_OK)
    {
        Exit(1, "DebugConnect(%s) failed, 0x%X\n",
             g_Connect, Status);
    }
}

void
ParseCommandLine(int Argc, char** Argv)
{
    while (--Argc > 0)
    {
        Argv++;

        if (!strcmp(*Argv, "-b"))
        {
            g_ForceBreak = TRUE;
        }
        else if (!strcmp(*Argv, "-cmd"))
        {
            if (Argc < 2)
            {
                Exit(1, "-cmd missing argument\n");
            }

            Argv++;
            Argc--;

            g_Command = *Argv;
        }
        else if (!strcmp(*Argv, "-remote"))
        {
            if (Argc < 2)
            {
                Exit(1, "-remote missing argument\n");
            }

            Argv++;
            Argc--;

            g_Connect = *Argv;
        }
        else
        {
            Exit(1, "Unknown command line argument '%s'\n", *Argv);
        }
    }

    if (!g_Connect)
    {
        Exit(1, "No connection string specified, use -remote <options>\n");
    }
}

void
WaitForBreakIn(void)
{
    HRESULT Status;

    // If we're forcing a break in request one.
    if (g_ForceBreak)
    {
        if ((Status = g_Control->SetInterrupt(DEBUG_INTERRUPT_ACTIVE)) != S_OK)
        {
            Exit(1, "SetInterrupt failed, 0x%X\n", Status);
        }
    }

    // Check on the current state as the server may be broken in.
    if ((Status = g_Control->GetExecutionStatus(&g_ExecStatus)) != S_OK)
    {
        Exit(1, "GetExecutionStatus failed, 0x%X\n", Status);
    }

    printf("Waiting for break-in...\n");
    
    while (g_ExecStatus != DEBUG_STATUS_BREAK)
    {
        // Wait for the server to enter the break-in state.
        // When this happens our event callbacks will get called
        // to update g_ExecStatus and wake up this wait.
        if ((Status = g_Client->DispatchCallbacks(INFINITE)) != S_OK)
        {
            Exit(1, "DispatchCallbacks failed, 0x%X\n", Status);
        }
    }

    // The server is broken in.  Another user can immediately resume
    // it but we'll assume that we're not competing with
    // other server users.
}

void __cdecl
main(int Argc, char** Argv)
{
    ParseCommandLine(Argc, Argv);

    CreateInterfaces();
    
    WaitForBreakIn();
    
    printf("Executing '%s' on server\n", g_Command);
    g_Control->Execute(DEBUG_OUTCTL_ALL_CLIENTS,
                       g_Command, DEBUG_EXECUTE_DEFAULT);

    Exit(0, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\samples\simplext\simple.h ===
/*++
   Copyright (c) 2000  Microsoft Corporation

Module:

    Simple.h
    
    
    Common header file for extensions

--*/

#include <windows.h>

#define KDEXT_64BIT
#include <wdbgexts.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\samples\simplext\simple.c ===
/*++

 Copyright (c) 2000  Microsoft Corporation

Module Name:

    simple.c

--*/

#include "simple.h"

#include <ntverp.h>

//
// globals
//
EXT_API_VERSION         ApiVersion = { (VER_PRODUCTVERSION_W >> 8), (VER_PRODUCTVERSION_W & 0xff), EXT_API_VERSION_NUMBER64, 0 };
WINDBG_EXTENSION_APIS   ExtensionApis;
ULONG SavedMajorVersion;
ULONG SavedMinorVersion;

DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

//
// Routine called by debugger after load
//
VOID
CheckVersion(
    VOID
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\samples\simplext\exts.c ===
/*-----------------------------------------------------------------------------
   Copyright (c) 2000  Microsoft Corporation

Module:
  exts.c

Sample old windbg style interface using extension 

------------------------------------------------------------------------------*/

#include "simple.h"


//
// Extension to read and dump dwords from target
//
DECLARE_API( read )
{
    ULONG cb;
    ULONG64 Address;
    ULONG   Buffer[4];

    Address = GetExpression(args);

    // Read and display first 4 dwords at Address
    if (ReadMemory(Address, &Buffer, sizeof(Buffer), &cb) && cb == sizeof(Buffer)) {
        dprintf("%I64lx: %08lx %08lx %08lx %08lx\n\n", Address,
                Buffer[0], Buffer[1], Buffer[2], Buffer[3]);
    }
}

//
// Extension to edit a dword on target
//  
//    !edit <address> <value>
//
DECLARE_API( edit )
{
    ULONG cb;
    ULONG64 Address;
    ULONG   Value;

    if (GetExpressionEx(args, &Address, &args)) {
        Value = (ULONG) GetExpression( args);
    } else {
        dprintf("Usage:   !edit <address> <value>\n");
        return;
    }

    // Read and display first 4 dwords at Address
    if (WriteMemory(Address, &Value, sizeof(Value), &cb) && cb == sizeof(Value)) {
        dprintf("%I64lx: %08lx\n", Address, Value);
    }
}


//
// Extension to dump stacktrace
//
DECLARE_API ( stack )
{
    EXTSTACKTRACE64 stk[20];
    ULONG frames, i;
    CHAR Buffer[256];
    ULONG64 displacement;


    // Get stacktrace for surrent thread 
    frames = StackTrace( 0, 0, 0, stk, 20 );

    if (!frames) {
        dprintf("Stacktrace failed\n");
    }

    for (i=0; i<frames; i++) {

        if (i==0) {
            dprintf( "ChildEBP RetAddr  Args to Child\n" );
        }

        Buffer[0] = '!';
        GetSymbol(stk[i].ProgramCounter, (PUCHAR)Buffer, &displacement);
        
        dprintf( "%08p %08p %08p %08p %08p %s",
                 stk[i].FramePointer,
                 stk[i].ReturnAddress,
                 stk[i].Args[0],
                 stk[i].Args[1],
                 stk[i].Args[2],
                 Buffer
                 );

        if (displacement) {
            dprintf( "+0x%p", displacement );
        }

        dprintf( "\n" );
    }
}

/*
  A built-in help for the extension dll
*/

DECLARE_API ( help ) 
{
    dprintf("Help for extension dll simple.dll\n"
            "   read  <addr>       - It reads and dumps 4 dwords at <addr>\n"
            "   edit  <addr> <val> - It modifies a dword value to <val> at <addr>\n"
            "   stack              - Printd current stack trace\n"
            "   help               - Shows this help\n"
            );

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\savedump\erdirty.cpp ===
/*++

Copyright (c) 1991-2002  Microsoft Corporation

Module Name:

    erdirty.cpp

Abstract:

    This module contains the code to report pending dirty shutdown
    events at logon after dirty reboot.

Author:

    Ian Service (ianserv) 29-May-2001

Environment:

    User mode at logon.

Revision History:

--*/

#include "savedump.h"

#define SHUTDOWN_STATE_SNAPSHOT_KEY L"ShutDownStateSnapShot"

HRESULT
DirtyShutdownEventHandler(BOOL NotifyPcHealth)

/*++

Routine Description:

    This is the boot time routine to handle pending dirty shutdown event.

Arguments:

    NotifyPcHealth - TRUE if we should report event to PC Health, FALSE otherwise.

--*/

{
    HKEY Key;
    HRESULT Status;
    WCHAR DumpName[MAX_PATH];
    ULONG Val;

    if (RegOpenKey(HKEY_LOCAL_MACHINE,
                   SUBKEY_RELIABILITY,
                   &Key) != ERROR_SUCCESS)
    {
        // No key so nothing to do.
        return S_OK;
    }

    //
    // Whenever we have had a blue screen event we are going to
    // post an unexpected restart shutdown event screen on startup
    // (assuming Server SKU or specially set Professional).
    // In order to make it easier on the user we attempt to prefill
    // the comment with the bugcheck data.
    //
    if (g_DumpBugCheckString[0] &&
        GetRegWord32(Key, L"DirtyShutDown", &Val, 0, FALSE) == S_OK)
    {
        RegSetValueEx(Key,
                      L"BugCheckString",
                      NULL,
                      REG_SZ,
                      (LPBYTE)g_DumpBugCheckString,
                      (wcslen(g_DumpBugCheckString) + 1) * sizeof(WCHAR));
    }

    if ((Status = GetRegStr(Key, SHUTDOWN_STATE_SNAPSHOT_KEY,
                            DumpName, RTL_NUMBER_OF(DumpName),
                            NULL)) == S_OK)
    {
        if (NotifyPcHealth)
        {
            Status = FrrvToStatus(ReportEREvent(eetShutdown, DumpName, NULL));
        }
        else
        {
            Status = S_OK;
        }

        RegDeleteValue(Key, SHUTDOWN_STATE_SNAPSHOT_KEY);
    }
    else
    {
        // No snapshot to report.
        Status = S_OK;
    }

    RegCloseKey(Key);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\savedump\erdirty.h ===
/*++

Copyright (c) 1991-2002  Microsoft Corporation

Module Name:

    erdirty.h

Abstract:

    This module contains the code to report pending dirty shutdown
    events at logon after dirty reboot.

Author:

    Ian Service (ianserv) 29-May-2001

Environment:

    User mode at logon.

Revision History:

--*/

#ifndef _ERDIRTY_H_
#define _ERDIRTY_H_

//
// Prototypes of routines supplied by erwatch.cpp.
//

HRESULT
DirtyShutdownEventHandler(BOOL NotifyPcHealth);

#endif  // _ERDIRTY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\savedump\erwatch.h ===
/*++

Copyright (c) 1991-2002  Microsoft Corporation

Module Name:

    erwatch.h

Abstract:

    This module contains the code to report pending watchdog timeout
    events at logon after dirty reboot.

Author:

    Michael Maciesowicz (mmacie) 29-May-2001

Environment:

    User mode at logon.

Revision History:

--*/

#ifndef _ERWATCH_H_
#define _ERWATCH_H_

//
// Localizable string IDs.
//

#define IDS_000                             100
#define IDS_001                             101
#define IDS_002                             102
#define IDS_003                             103
#define IDS_004                             104
#define IDS_005                             105

//
// Constants used by erwatch.cpp.
//

#define ER_WD_MAX_RETRY                     100
#define ER_WD_MAX_NAME_LENGTH               255
#define ER_WD_MAX_DATA_SIZE                 4096
#define ER_WD_MAX_STRING                    1024
#define ER_WD_MAX_FILE_INFO_LENGTH          255
#define ER_WD_MAX_URL_LENGTH                255
#define ER_WD_LANG_ENGLISH                  0x0409
#define ER_WD_DISABLE_BUGCHECK_FLAG         0x01
#define ER_WD_DEBUGGER_NOT_PRESENT_FLAG     0x02
#define ER_WD_BUGCHECK_TRIGGERED_FLAG       0x04

//
// Data types.
//

typedef struct _ER_WD_LANG_AND_CODE_PAGE
{
    USHORT Language;
    USHORT CodePage;
} ER_WD_LANG_AND_CODE_PAGE, *PER_WD_LANG_AND_CODE_PAGE;

typedef struct _ER_WD_DRIVER_INFO
{
    WCHAR DriverName[MAX_PATH];
    VS_FIXEDFILEINFO FixedFileInfo;
    WCHAR Comments[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR CompanyName[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR FileDescription[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR FileVersion[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR InternalName[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR LegalCopyright[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR LegalTrademarks[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR OriginalFilename[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR PrivateBuild[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR ProductName[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR ProductVersion[ER_WD_MAX_FILE_INFO_LENGTH + 1];
    WCHAR SpecialBuild[ER_WD_MAX_FILE_INFO_LENGTH + 1];
} ER_WD_DRIVER_INFO, *PER_WD_DRIVER_INFO;

//
// Prototypes of routines supplied by erwatch.cpp.
//

HRESULT
WatchdogEventHandler(
    IN BOOL NotifyPcHealth
    );

#endif  // _ERWATCH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\savedump\erwatch.cpp ===
/*++

Copyright (c) 1991-2002  Microsoft Corporation

Module Name:

    erwatch.cpp

Abstract:

    This module contains the code to report pending watchdog timeout
    events at logon after dirty reboot.

Author:

    Michael Maciesowicz (mmacie) 29-May-2001

Environment:

    User mode at logon.

Revision History:

--*/

#include "savedump.h"

#include <ntverp.h>

BOOL
WriteWatchdogEventFile(
    IN HANDLE FileHandle,
    IN PWSTR String
    );

BOOL
WriteWatchdogEventFileHeader(
    IN HANDLE FileHandle
    )
{
    WCHAR Buffer[256];
    BOOL Status;
    SYSTEMTIME Time;
    TIME_ZONE_INFORMATION TimeZone;

    Status = WriteWatchdogEventFile(FileHandle,
        L"//\r\n// Watchdog Event Log File\r\n//\r\n\r\n");

    if (TRUE == Status)
    {
        Status = WriteWatchdogEventFile(FileHandle, L"LogType: Watchdog\r\n");
    }

    if (TRUE == Status)
    {
        GetLocalTime(&Time);

        if (StringCchPrintf(Buffer,
                            RTL_NUMBER_OF(Buffer),
                            L"Created: %d-%2.2d-%2.2d %2.2d:%2.2d:%2.2d\r\n",
                            Time.wYear,
                            Time.wMonth,
                            Time.wDay,
                            Time.wHour,
                            Time.wMinute,
                            Time.wSecond) != S_OK)
        {
            Status = FALSE;
        }
        else
        {
            Status = WriteWatchdogEventFile(FileHandle, Buffer);
        }
    }

    if (TRUE == Status)
    {
        GetTimeZoneInformation(&TimeZone);

        if (StringCchPrintf(Buffer,
                            RTL_NUMBER_OF(Buffer),
                            L"TimeZone: %d - %s\r\n",
                            TimeZone.Bias,
                            TimeZone.StandardName) != S_OK)
        {
            Status = FALSE;
        }
        else
        {
            Status = WriteWatchdogEventFile(FileHandle, Buffer);
        }
    }

    if (TRUE == Status)
    {
        if (StringCchPrintf(Buffer, RTL_NUMBER_OF(Buffer),
                            L"WindowsVersion: " LVER_PRODUCTVERSION_STR
                            L"\r\n") != S_OK)
        {
            Status = FALSE;
        }
        else
        {
            Status = WriteWatchdogEventFile(FileHandle, Buffer);
        }
    }

    if (TRUE == Status)
    {
        Status = WriteWatchdogEventFile(FileHandle,
            L"EventType: 0xEA - Thread Stuck in Device Driver\r\n");
    }

    return Status;
}

HANDLE
CreateWatchdogEventFile(
    OUT PWSTR FileName
    )
{
    INT Retry;
    WCHAR DirName[MAX_PATH];
    SYSTEMTIME Time;
    HANDLE FileHandle;
    ULONG ReturnedSize;

    ASSERT(NULL != FileName);

    //
    // Create %SystemRoot%\LogFiles\Watchdog directory for event files.
    //

    ReturnedSize = GetWindowsDirectory(DirName, RTL_NUMBER_OF(DirName));
    if (ReturnedSize < 1 || ReturnedSize >= RTL_NUMBER_OF(DirName))
    {
        return INVALID_HANDLE_VALUE;
    }
    if (StringCchCat(DirName, RTL_NUMBER_OF(DirName), L"\\LogFiles") != S_OK)
    {
        return INVALID_HANDLE_VALUE;
    }

    CreateDirectory(DirName, NULL);

    if (StringCchCat(DirName, RTL_NUMBER_OF(DirName), L"\\WatchDog") != S_OK)
    {
        return INVALID_HANDLE_VALUE;
    }

    CreateDirectory(DirName, NULL);

    //
    // Create watchdog event file as YYMMDD_HHMM_NN.wdl.
    //

    GetLocalTime(&Time);

    for (Retry = 1; Retry < ER_WD_MAX_RETRY; Retry++)
    {
        if (StringCchPrintf(FileName,
                            MAX_PATH,
                            L"%s\\%2.2d%2.2d%2.2d_%2.2d%2.2d_%2.2d.wdl",
                            DirName,
                            Time.wYear % 100,
                            Time.wMonth,
                            Time.wDay,
                            Time.wHour,
                            Time.wMinute,
                            Retry) != S_OK)
        {
            return INVALID_HANDLE_VALUE;
        }

        FileHandle = CreateFile(FileName,
                                GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL,
                                CREATE_NEW,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
        if (INVALID_HANDLE_VALUE != FileHandle)
        {
            break;
        }
    }

    //
    // If we failed to create a suitable file name just fail.
    //

    if (Retry == ER_WD_MAX_RETRY)
    {
        return INVALID_HANDLE_VALUE;
    }

    if (!WriteWatchdogEventFileHeader(FileHandle))
    {
        CloseHandle(FileHandle);
        DeleteFile(FileName);
        FileHandle = INVALID_HANDLE_VALUE;
    }
    
    return FileHandle;
}

VOID
GetDriverInfo(
    IN HKEY Key,
    IN OPTIONAL PWCHAR Extension,
    OUT PER_WD_DRIVER_INFO DriverInfo
    )

/*++

Routine Description:

    This routine collects driver's version info.

Arguments:

    Key - Watchdog open key (device specific).

    Extension - Driver file name extension if one should be appended.

    DriverInfo - Storage for driver version info.

--*/

{
    PVOID VersionBuffer;
    PVOID VersionValue;
    LONG WinStatus;
    DWORD Handle;
    ULONG Index;
    USHORT CodePage;
    UINT Length;

    if (NULL == DriverInfo)
    {
        return;
    }

    ZeroMemory(DriverInfo, sizeof (ER_WD_DRIVER_INFO));

    //
    // Get driver file name from registry.
    //

    if (GetRegStr(Key, L"DriverName",
                  DriverInfo->DriverName,
                  RTL_NUMBER_OF(DriverInfo->DriverName),
                  NULL) != S_OK)
    {
        StringCchCopy(DriverInfo->DriverName,
                      RTL_NUMBER_OF(DriverInfo->DriverName),
                      L"Unknown");
        return;
    }

    if (Extension)
    {
        if ((wcslen(DriverInfo->DriverName) <= wcslen(Extension)) ||
            wcscmp(DriverInfo->DriverName + wcslen(DriverInfo->DriverName) -
                   wcslen(Extension), Extension))
        {
            if (StringCchCat(DriverInfo->DriverName,
                             RTL_NUMBER_OF(DriverInfo->DriverName),
                             Extension) != S_OK)
            {
                StringCchCopy(DriverInfo->DriverName,
                              RTL_NUMBER_OF(DriverInfo->DriverName),
                              L"Unknown");
                return;
            }
        }
    }

    Length = GetFileVersionInfoSize(DriverInfo->DriverName, &Handle);

    if (Length)
    {
        VersionBuffer = malloc(Length);

        if (NULL != VersionBuffer)
        {
            if (GetFileVersionInfo(DriverInfo->DriverName, Handle,
                                   Length, VersionBuffer))
            {
                //
                // Get fixed file info.
                //

                if (VerQueryValue(VersionBuffer,
                                  L"\\",
                                  &VersionValue,
                                  &Length) &&
                    Length == sizeof(DriverInfo->FixedFileInfo))
                {
                    CopyMemory(&(DriverInfo->FixedFileInfo),
                               VersionValue,
                               Length);
                }

                //
                // Try to locate English code page.
                //

                CodePage = 0;

                if (VerQueryValue(VersionBuffer,
                                  L"\\VarFileInfo\\Translation",
                                  &VersionValue,
                                  &Length))
                {
                    for (Index = 0;
                         Index < Length / sizeof (ER_WD_LANG_AND_CODE_PAGE);
                         Index++)
                    {
                        if (((PER_WD_LANG_AND_CODE_PAGE)VersionValue + Index)->
                            Language == ER_WD_LANG_ENGLISH)
                        {
                            CodePage = ((PER_WD_LANG_AND_CODE_PAGE)
                                        VersionValue + Index)->CodePage;
                            break;
                        }
                    }
                }

                if (CodePage)
                {
                    WCHAR ValueName[ER_WD_MAX_NAME_LENGTH + 1];
                    PWCHAR Destination[] =
                    {
                        DriverInfo->Comments,
                        DriverInfo->CompanyName,
                        DriverInfo->FileDescription,
                        DriverInfo->FileVersion,
                        DriverInfo->InternalName,
                        DriverInfo->LegalCopyright,
                        DriverInfo->LegalTrademarks,
                        DriverInfo->OriginalFilename,
                        DriverInfo->PrivateBuild,
                        DriverInfo->ProductName,
                        DriverInfo->ProductVersion,
                        DriverInfo->SpecialBuild,
                        NULL
                    };
                    PWCHAR Source[] =
                    {
                        L"Comments",
                        L"CompanyName",
                        L"FileDescription",
                        L"FileVersion",
                        L"InternalName",
                        L"LegalCopyright",
                        L"LegalTrademarks",
                        L"OriginalFilename",
                        L"PrivateBuild",
                        L"ProductName",
                        L"ProductVersion",
                        L"SpecialBuild",
                        NULL
                    };

                    //
                    // Read version properties.
                    //

                    for (Index = 0;
                         Source[Index] && Destination[Index];
                         Index++)
                    {
                        if (StringCchPrintf(ValueName,
                                            RTL_NUMBER_OF(ValueName),
                                            L"\\StringFileInfo\\%04X%04X\\%s",
                                            ER_WD_LANG_ENGLISH,
                                            CodePage,
                                            Source[Index]) == S_OK &&
                            VerQueryValue(VersionBuffer,
                                          ValueName,
                                          &VersionValue,
                                          &Length))
                        {
                            CopyMemory(Destination[Index],
                                       VersionValue,
                                       min(Length * sizeof (WCHAR),
                                           ER_WD_MAX_FILE_INFO_LENGTH *
                                           sizeof (WCHAR)));
                        }
                    }
                }
            }

            free(VersionBuffer);
        }
    }
}

#define MAX_DATA_CHARS (ER_WD_MAX_DATA_SIZE / sizeof(WCHAR))

BOOL
SaveWatchdogEventData(
    IN HANDLE FileHandle,
    IN HKEY Key,
    IN PER_WD_DRIVER_INFO DriverInfo
    )

/*++

Routine Description:

    This routine transfers watchdog event data from registry to
    the watchdog event report file.

Arguments:

    FileHandle - Handle of open watchdog event report file.

    Key - Watchdog open key (device specific).

Return Value:

    TRUE if successful, FALSE otherwise.

--*/

{
    LONG WinStatus;
    DWORD Index;
    DWORD NameLength;
    DWORD DataSize;
    DWORD ReturnedSize;
    DWORD Type;
    WCHAR Name[ER_WD_MAX_NAME_LENGTH + 1];
    WCHAR DwordBuffer[20];
    PBYTE Data;
    BOOL Status = TRUE;

    ASSERT(INVALID_HANDLE_VALUE != FileHandle);

    Data = (PBYTE)malloc(ER_WD_MAX_DATA_SIZE);
    if (NULL == Data)
    {
        return FALSE;
    }

    //
    // Pull watchdog data from registry and write it to report.
    //

    for (Index = 0;; Index++)
    {
        //
        // Read watchdog registry value.
        //

        NameLength = ER_WD_MAX_NAME_LENGTH;
        DataSize = ER_WD_MAX_DATA_SIZE;

        WinStatus = RegEnumValue(Key,
                                 Index,
                                 Name,
                                 &NameLength,
                                 NULL,
                                 &Type,
                                 Data,
                                 &DataSize);

        if (ERROR_NO_MORE_ITEMS == WinStatus)
        {
            break;
        }

        if (ERROR_SUCCESS != WinStatus)
        {
            continue;
        }

        //
        // Pick up strings and dwords only.
        //

        if ((REG_EXPAND_SZ == Type) || (REG_SZ == Type) ||
            (REG_MULTI_SZ == Type) || (REG_DWORD == Type))
        {
            //
            // Write registry entry to watchdog event file.
            //

            Status = WriteWatchdogEventFile(FileHandle, Name);
            if (TRUE != Status)
            {
                break;
            }

            Status = WriteWatchdogEventFile(FileHandle, L": ");
            if (TRUE != Status)
            {
                break;
            }

            if (REG_DWORD == Type)
            {
                if (StringCchPrintf(DwordBuffer, RTL_NUMBER_OF(DwordBuffer),
                                    L"%u", *(PULONG)Data) != S_OK)
                {
                    Status = FALSE;
                }
                else
                {
                    Status = WriteWatchdogEventFile(FileHandle, DwordBuffer);
                }
            }
            else
            {
                Status = WriteWatchdogEventFile(FileHandle, (PWSTR)Data);
            }

            if (TRUE != Status)
            {
                break;
            }

            Status = WriteWatchdogEventFile(FileHandle, L"\r\n");
            if (TRUE != Status)
            {
                break;
            }
        }
    }

    //
    // Write driver info to report.
    //

    if (NULL != DriverInfo)
    {
        if (TRUE == Status)
        {
            if (StringCchPrintf((PWCHAR)Data, MAX_DATA_CHARS,
                L"DriverFixedFileInfo: %08X %08X %08X %08X "
                L"%08X %08X %08X %08X %08X %08X %08X %08X %08X\r\n",
                DriverInfo->FixedFileInfo.dwSignature,
                DriverInfo->FixedFileInfo.dwStrucVersion,
                DriverInfo->FixedFileInfo.dwFileVersionMS,
                DriverInfo->FixedFileInfo.dwFileVersionLS,
                DriverInfo->FixedFileInfo.dwProductVersionMS,
                DriverInfo->FixedFileInfo.dwProductVersionLS,
                DriverInfo->FixedFileInfo.dwFileFlagsMask,
                DriverInfo->FixedFileInfo.dwFileFlags,
                DriverInfo->FixedFileInfo.dwFileOS,
                DriverInfo->FixedFileInfo.dwFileType,
                DriverInfo->FixedFileInfo.dwFileSubtype,
                DriverInfo->FixedFileInfo.dwFileDateMS,
                DriverInfo->FixedFileInfo.dwFileDateLS) != S_OK)
            {
                Status = FALSE;
            }
            else
            {
                Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
            }
        }

        if ((TRUE == Status) && DriverInfo->Comments[0])
        {
            if (StringCchPrintf((PWCHAR)Data, MAX_DATA_CHARS,
                                L"DriverComments: %s\r\n",
                                DriverInfo->Comments) != S_OK)
            {
                Status = FALSE;
            }
            else
            {
                Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
            }
        }

        if ((TRUE == Status) && DriverInfo->CompanyName[0])
        {
            if (StringCchPrintf((PWCHAR)Data, MAX_DATA_CHARS,
                                L"DriverCompanyName: %s\r\n",
                                DriverInfo->CompanyName) != S_OK)
            {
                Status = FALSE;
            }
            else
            {
                Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
            }
        }

        if ((TRUE == Status) && DriverInfo->FileDescription[0])
        {
            if (StringCchPrintf((PWCHAR)Data, MAX_DATA_CHARS,
                                L"DriverFileDescription: %s\r\n",
                                DriverInfo->FileDescription) != S_OK)
            {
                Status = FALSE;
            }
            else
            {
                Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
            }
        }

        if ((TRUE == Status) && DriverInfo->FileVersion[0])
        {
            if (StringCchPrintf((PWCHAR)Data, MAX_DATA_CHARS,
                                L"DriverFileVersion: %s\r\n",
                                DriverInfo->FileVersion) != S_OK)
            {
                Status = FALSE;
            }
            else
            {
                Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
            }
        }

        if ((TRUE == Status) && DriverInfo->InternalName[0])
        {
            if (StringCchPrintf((PWCHAR)Data, MAX_DATA_CHARS,
                                L"DriverInternalName: %s\r\n",
                                DriverInfo->InternalName) != S_OK)
            {
                Status = FALSE;
            }
            else
            {
                Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
            }
        }

        if ((TRUE == Status) && DriverInfo->LegalCopyright[0])
        {
            if (StringCchPrintf((PWCHAR)Data, MAX_DATA_CHARS,
                                L"DriverLegalCopyright: %s\r\n",
                                DriverInfo->LegalCopyright) != S_OK)
            {
                Status = FALSE;
            }
            else
            {
                Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
            }
        }

        if ((TRUE == Status) && DriverInfo->LegalTrademarks[0])
        {
            if (StringCchPrintf((PWCHAR)Data, MAX_DATA_CHARS,
                                L"DriverLegalTrademarks: %s\r\n",
                                DriverInfo->LegalTrademarks) != S_OK)
            {
                Status = FALSE;
            }
            else
            {
                Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
            }
        }

        if ((TRUE == Status) && DriverInfo->OriginalFilename[0])
        {
            if (StringCchPrintf((PWCHAR)Data, MAX_DATA_CHARS,
                                L"DriverOriginalFilename: %s\r\n",
                                DriverInfo->OriginalFilename) != S_OK)
            {
                Status = FALSE;
            }
            else
            {
                Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
            }
        }

        if ((TRUE == Status) && DriverInfo->PrivateBuild[0])
        {
            if (StringCchPrintf((PWCHAR)Data, MAX_DATA_CHARS,
                                L"DriverPrivateBuild: %s\r\n",
                                DriverInfo->PrivateBuild) != S_OK)
            {
                Status = FALSE;
            }
            else
            {
                Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
            }
        }

        if ((TRUE == Status) && DriverInfo->ProductName[0])
        {
            if (StringCchPrintf((PWCHAR)Data, MAX_DATA_CHARS,
                                L"DriverProductName: %s\r\n",
                                DriverInfo->ProductName) != S_OK)
            {
                Status = FALSE;
            }
            else
            {
                Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
            }
        }

        if ((TRUE == Status) && DriverInfo->ProductVersion[0])
        {
            if (StringCchPrintf((PWCHAR)Data, MAX_DATA_CHARS,
                                L"DriverProductVersion: %s\r\n",
                                DriverInfo->ProductVersion) != S_OK)
            {
                Status = FALSE;
            }
            else
            {
                Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
            }
        }

        if ((TRUE == Status) && DriverInfo->SpecialBuild[0])
        {
            if (StringCchPrintf((PWCHAR)Data, MAX_DATA_CHARS,
                                L"DriverSpecialBuild: %s\r\n",
                                DriverInfo->SpecialBuild) != S_OK)
            {
                Status = FALSE;
            }
            else
            {
                Status = WriteWatchdogEventFile(FileHandle, (PWCHAR)Data);
            }
        }
    }

    if (NULL != Data)
    {
        free(Data);
        Data = NULL;
    }

    return Status;
}

HRESULT
WatchdogEventHandler(
    IN BOOL NotifyPcHealth
    )

/*++

Routine Description:

    This is the boot time routine to handle pending watchdog events.

Arguments:

    NotifyPcHealth - TRUE if we should report event to PC Health, FALSE otherwise.

--*/

{
    HKEY Key;
    ULONG WinStatus;
    ULONG Type;
    ULONG Length;
    ULONG EventFlag;
    ULONG Index;
    SEventInfoW EventInfo;
    HANDLE FileHandle;
    WCHAR FileList[2 * MAX_PATH];
    PWSTR DeleteLog;
    PWSTR FinalFileList;
    WCHAR Stage2Url[ER_WD_MAX_URL_LENGTH + 1];
    PWCHAR MessageBuffer;
    PWCHAR DescriptionBuffer;
    PWCHAR DeviceDescription;
    PWCHAR String000;
    PWCHAR String001;
    PWCHAR String002;
    PWCHAR String003;
    PWCHAR String004;
    PWCHAR String005;
    BOOL LogStatus;
    HRESULT ReturnStatus;
    HINSTANCE Instance;
    PER_WD_DRIVER_INFO DriverInfo;
    OSVERSIONINFOEX OsVersion;

    Key = NULL;
    MessageBuffer = NULL;
    DescriptionBuffer = NULL;
    DeviceDescription = NULL;
    String000 = NULL;
    String001 = NULL;
    String002 = NULL;
    String003 = NULL;
    String004 = NULL;
    String005 = NULL;
    ReturnStatus = E_FAIL;
    Instance = (HINSTANCE)GetModuleHandle(NULL);
    DriverInfo = NULL;
    LogStatus = FALSE;
    DeleteLog = NULL;

    //
    // Check if Watchdog\Display key present.
    //

    WinStatus = RegOpenKey(HKEY_LOCAL_MACHINE,
                           SUBKEY_WATCHDOG_DISPLAY,
                           &Key);
    if (ERROR_SUCCESS != WinStatus)
    {
        return S_FALSE;
    }
    
    //
    // Check if watchdog display event captured.
    //

    GetRegWord32(Key, L"EventFlag", &EventFlag, 0, TRUE);
    
    if (!EventFlag)
    {
        ReturnStatus = S_FALSE;
        goto Exit;
    }
    
    //
    // Report watchdog event to PC Health if requested.
    //

    if (!NotifyPcHealth)
    {
        ReturnStatus = S_FALSE;
        goto Exit;
    }
    
    //
    // Allocate storage for localized strings.
    // Load localized strings from resources.
    //

    String000 = (PWCHAR)malloc(ER_WD_MAX_STRING * sizeof(WCHAR));
    String001 = (PWCHAR)malloc(ER_WD_MAX_STRING * sizeof(WCHAR));
    String002 = (PWCHAR)malloc(ER_WD_MAX_STRING * sizeof(WCHAR));
    String003 = (PWCHAR)malloc(ER_WD_MAX_STRING * sizeof(WCHAR));
    String004 = (PWCHAR)malloc(ER_WD_MAX_STRING * sizeof(WCHAR));
    String005 = (PWCHAR)malloc(ER_WD_MAX_STRING * sizeof(WCHAR));

    if (!String000 ||
        !LoadString(Instance, IDS_000, String000, ER_WD_MAX_STRING) ||
        !String001 ||
        !LoadString(Instance, IDS_001, String001, ER_WD_MAX_STRING) ||
        !String002 ||
        !LoadString(Instance, IDS_002, String002, ER_WD_MAX_STRING) ||
        !String003 ||
        !LoadString(Instance, IDS_003, String003, ER_WD_MAX_STRING) ||
        !String004 ||
        !LoadString(Instance, IDS_004, String004, ER_WD_MAX_STRING) ||
        !String005 ||
        !LoadString(Instance, IDS_005, String005, ER_WD_MAX_STRING))
    {
        ReturnStatus = E_OUTOFMEMORY;
        goto Exit;
    }

    //
    // Allocate and get DriverInfo data.
    // DriverInfo is not critical information so don't
    // quit on failure.
    //

    DriverInfo = (PER_WD_DRIVER_INFO)malloc(sizeof (ER_WD_DRIVER_INFO));

    if (NULL != DriverInfo)
    {
        GetDriverInfo(Key, L".dll", DriverInfo);
    }

    //
    // Create watchdog report file.
    //

    FileHandle = CreateWatchdogEventFile(FileList);
    if (INVALID_HANDLE_VALUE != FileHandle)
    {
        LogStatus = TRUE;
        DeleteLog = FileList + wcslen(FileList);
    }

    if (TRUE == LogStatus)
    {
        LogStatus = WriteWatchdogEventFile(
            FileHandle,
            L"\r\n//\r\n"
            L"// The driver for the display device got stuck in an infinite loop. This\r\n"
            L"// usually indicates a problem with the device itself or with the device\r\n"
            L"// driver programming the hardware incorrectly. Please check with your\r\n"
            L"// display device vendor for any driver updates.\r\n"
            L"//\r\n\r\n");
    }

    if (TRUE == LogStatus)
    {
        LogStatus = SaveWatchdogEventData(FileHandle, Key, DriverInfo);
    }

    if (INVALID_HANDLE_VALUE != FileHandle)
    {
        CloseHandle(FileHandle);
    }

    //
    // Append minidump file name if minidump available (server won't have it).
    //

    if (LogStatus)
    {
        if (g_MiniDumpFile[0])
        {
            if (StringCchCat(FileList, RTL_NUMBER_OF(FileList),
                             L"|") != S_OK ||
                StringCchCat(FileList, RTL_NUMBER_OF(FileList),
                             g_MiniDumpFile) != S_OK)
            {
                ReturnStatus = E_OUTOFMEMORY;
                goto Exit;
            }
        }

        FinalFileList = FileList;
    }
    else if (g_MiniDumpFile[0])
    {
        FinalFileList = g_MiniDumpFile;
    }
    else
    {
        // Nothing to report.
        ReturnStatus = S_FALSE;
        goto Exit;
    }

    //
    // Get device description.
    //

    DescriptionBuffer = NULL;
    DeviceDescription = NULL;
    Length = 0;

    WinStatus = RegQueryValueEx(Key,
                                L"DeviceDescription",
                                NULL,
                                &Type,
                                NULL,
                                &Length);
    if (ERROR_SUCCESS == WinStatus && Type == REG_SZ)
    {
        DescriptionBuffer = (PWCHAR)malloc(Length + sizeof(WCHAR));
        if (NULL != DescriptionBuffer)
        {
            WinStatus = RegQueryValueEx(Key,
                                        L"DeviceDescription",
                                        NULL,
                                        &Type,
                                        (LPBYTE)DescriptionBuffer,
                                        &Length);
            DescriptionBuffer[Length / sizeof(WCHAR)] = 0;
        }
        else
        {
            Length = 0;
        }
    }
    else
    {
        WinStatus = ERROR_INVALID_PARAMETER;
    }

    if ((ERROR_SUCCESS == WinStatus) && (0 != Length))
    {
        DeviceDescription = DescriptionBuffer;
    }
    else
    {
        DeviceDescription = String004;
        Length = (ER_WD_MAX_STRING + 1) * sizeof (WCHAR);
    }

    Length += 2 * ER_WD_MAX_STRING * sizeof (WCHAR);
    
    MessageBuffer = (PWCHAR)malloc(Length);

    if (NULL != MessageBuffer)
    {
        // This should never overflow as we allocated the right amount.
        StringCbPrintf(MessageBuffer,
                       Length,
                       L"%s%s%s",
                       String003,
                       DeviceDescription,
                       String005);
    }

    //
    // Create stage 2 URL and fill in EventInfo.
    //

    OsVersion.dwOSVersionInfoSize = sizeof (OSVERSIONINFOEX);
    if (!GetVersionEx((LPOSVERSIONINFOW)&OsVersion))
    {
        ReturnStatus = LAST_HR();
        goto Exit;
    }

    ZeroMemory(&EventInfo, sizeof (EventInfo));
    
    if (g_DumpHeader.Signature == DUMP_SIGNATURE &&
        (g_DumpHeader.BugCheckCode & 0xff) == 0xea)
    {
        //
        // We bluescreened with bugcheck EA - we have minidump and wdl.
        //

        if ((ReturnStatus =
             StringCchPrintf(Stage2Url,
                             RTL_NUMBER_OF(Stage2Url),
                             L"\r\nStage2URL=/dw/BlueTwo.asp?"
                             L"BCCode=%x&BCP1=%p&BCP2=%p&BCP3=%p&BCP4=%p&"
                             L"OSVer=%d_%d_%d&SP=%d_%d&Product=%d_%d",
                             g_DumpHeader.BugCheckCode,
                             (PVOID)(g_DumpHeader.BugCheckParameter1),
                             (PVOID)(g_DumpHeader.BugCheckParameter2),
                             (PVOID)(g_DumpHeader.BugCheckParameter3),
                             (PVOID)(g_DumpHeader.BugCheckParameter4),
                             OsVersion.dwMajorVersion,
                             OsVersion.dwMinorVersion,
                             OsVersion.dwBuildNumber,
                             OsVersion.wServicePackMajor,
                             OsVersion.wServicePackMinor,
                             OsVersion.wSuiteMask,
                             OsVersion.wProductType)) != S_OK)
        {
            goto Exit;
        }
        
        EventInfo.wszCorpPath = L"blue";
    }
    else if (g_DumpHeader.Signature == DUMP_SIGNATURE &&
             0 == g_DumpHeader.BugCheckCode)
    {
        //
        // User dirty rebooted with watchdog event trapped - we have only wdl.
        //
        
        if ((ReturnStatus =
             StringCchPrintf(Stage2Url,
                             RTL_NUMBER_OF(Stage2Url),
                             L"\r\nStage2URL=/dw/ShutdownTwo.asp?"
                             L"OSVer=%d_%d_%d&SP=%d_%d&Product=%d_%d",
                             OsVersion.dwMajorVersion,
                             OsVersion.dwMinorVersion,
                             OsVersion.dwBuildNumber,
                             OsVersion.wServicePackMajor,
                             OsVersion.wServicePackMinor,
                             OsVersion.wSuiteMask,
                             OsVersion.wProductType)) != S_OK)
        {
            goto Exit;
        }

        EventInfo.wszCorpPath = L"shutdown";
    }
    else
    {
        ReturnStatus = E_UNEXPECTED;
        goto Exit;
    }

    EventInfo.cbSEI = sizeof (EventInfo);
    EventInfo.wszEventName = L"Thread Stuck in Device Driver";
    EventInfo.wszErrMsg = String002;
    EventInfo.wszHdr = String001;
    EventInfo.wszTitle = String000;
    EventInfo.wszStage1 = NULL;
    EventInfo.wszStage2 = Stage2Url;
    EventInfo.wszFileList = FinalFileList;
    EventInfo.wszEventSrc = NULL;
    EventInfo.wszPlea = MessageBuffer;
    EventInfo.wszSendBtn = NULL;
    EventInfo.wszNoSendBtn = NULL;
    EventInfo.fUseLitePlea = FALSE;
    EventInfo.fUseIEForURLs = FALSE;
    EventInfo.fNoBucketLogs = TRUE;
    EventInfo.fNoDefCabLimit = TRUE;

    //
    // Notify PC Health.
    //

    ReturnStatus =
        FrrvToStatus(ReportEREvent(eetUseEventInfo, NULL, &EventInfo));

    // XXX drewb - Leave the log around for later use?  When does
    // this get deleted?  This is what previous code did.
    DeleteLog = NULL;

 Exit:
    
    //
    // Knock down watchdog's EventFlag. We do this after registering our
    // event with PC Health.
    //

    if (Key)
    {
        RegDeleteValue(Key, L"EventFlag");
        RegCloseKey(Key);
    }

    //
    // TODO: Handle additional device classes here when supported.
    //

    if (DeleteLog)
    {
        *DeleteLog = 0;
        DeleteFile(FileList);
    }
    
    free(DescriptionBuffer);
    free(MessageBuffer);
    free(String000);
    free(String001);
    free(String002);
    free(String003);
    free(String004);
    free(String005);
    free(DriverInfo);

    return ReturnStatus;
}

BOOL
WriteWatchdogEventFile(
    IN HANDLE FileHandle,
    IN PWSTR String
    )

/*++

Routine Description:

    This routine writes a string to watchdog event report file.

Arguments:

    FileHandle - Handle of open watchdog event report file.

    String - Points to the string to write.

Return Value:

    TRUE if successful, FALSE otherwise.

--*/

{
    DWORD Size;
    DWORD ReturnedSize;
    PCHAR MultiByte;
    BOOL Status;

    ASSERT(INVALID_HANDLE_VALUE != FileHandle);
    ASSERT(NULL != String);

    //
    // Get buffer size for translated string.
    //

    Size = WideCharToMultiByte(CP_ACP,
                               0,
                               String,
                               -1,
                               NULL,
                               0,
                               NULL,
                               NULL);
    if (Size <= 1)
    {
        return Size > 0;
    }

    MultiByte = (PCHAR)malloc(Size);

    if (NULL == MultiByte)
    {
        return FALSE;
    }

    Size = WideCharToMultiByte(CP_ACP,
                               0,
                               String,
                               -1,
                               MultiByte,
                               Size,
                               NULL,
                               NULL);

    if (Size > 0)
    {
        Status = WriteFile(FileHandle,
                           MultiByte,
                           Size - 1,
                           &ReturnedSize,
                           NULL);
    }
    else
    {
        ASSERT(FALSE);
        Status = FALSE;
    }

    free(MultiByte);
    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\sds\sdp.h ===
[CODE: No readable text]
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\savedump\savedump.cpp ===
/*++

Copyright (c) 1991-2002  Microsoft Corporation

Module Name:

    savedump.c

Abstract:

    This module contains the code to recover a dump from the system paging
    file.

Environment:

    Kernel mode

Revision History:

--*/

#include <savedump.h>

// Flag for testing behavior.
BOOL g_Test = FALSE;

// MachineCrash key information.
ULONG g_McTempDestination;
WCHAR g_McDumpFile[MAX_PATH];

// CrashControl key information.
ULONG g_CcLogEvent;
ULONG g_CcSendAlert;
ULONG g_CcOverwrite;
ULONG g_CcReportMachineDump;
WCHAR g_CcMiniDumpDir[MAX_PATH];
WCHAR g_CcDumpFile[MAX_PATH];

// Dump information.
DUMP_HEADER g_DumpHeader;
WCHAR g_DumpBugCheckString[256];
WCHAR g_MiniDumpFile[MAX_PATH];
PWSTR g_FinalDumpFile;

HRESULT
FrrvToStatus(EFaultRepRetVal Frrv)
{
    switch(Frrv)
    {
    case frrvOk:
    case frrvOkManifest:
    case frrvOkQueued:
    case frrvOkHeadless:
        return S_OK;
    default:
        return LAST_HR();
    }
}

HRESULT
GetRegStr(HKEY Key,
          PWSTR Value,
          PWSTR Buffer,
          ULONG BufferChars,
          PWSTR Default)
{
    ULONG Length;
    ULONG Error;
    ULONG Type;
    HRESULT Status;

    //
    // We want to only return valid, terminated strings
    // that fit in the given buffer.  If the registry value
    // is not a string, has a bad size or fills the buffer
    // without termination it can't be returned.
    //

    Length = BufferChars * sizeof(WCHAR);
    Error = RegQueryValueEx(Key, Value, NULL, &Type, (LPBYTE)Buffer, &Length);
    if (Error != ERROR_SUCCESS)
    {
        Status = HRESULT_FROM_WIN32(Error);
    }
    else if ((Type != REG_SZ && Type != REG_EXPAND_SZ) ||
             (Length & (sizeof(WCHAR) - 1)) ||
             (Length == BufferChars * sizeof(WCHAR) &&
              Buffer[Length / sizeof(WCHAR) - 1] != 0))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        if (Length < BufferChars * sizeof(WCHAR))
        {
            // Ensure that the string is terminated.
            Buffer[Length / sizeof(WCHAR)] = 0;
        }

        Status = S_OK;
    }

    if (Status != S_OK)
    {
        // Set to default.

        if (!Default || wcslen(Default) >= BufferChars)
        {
            return E_NOINTERFACE;
        }

        StringCchCopy(Buffer, BufferChars, Default);
        Status = S_OK;
    }

    return Status;
}

HRESULT
ExpandRegStr(HKEY Key,
             PWSTR Value,
             PWSTR Buffer,
             ULONG BufferChars,
             PWSTR Default,
             PWSTR ExpandBuffer,
             ULONG ExpandChars)
{
    HRESULT Status;
    ULONG Length;

    if ((Status = GetRegStr(Key, Value, Buffer, BufferChars, Default)) != S_OK)
    {
        return Status;
    }

    Length = ExpandEnvironmentStrings(Buffer, ExpandBuffer, ExpandChars);
    return Length > 0 && Length <= ExpandChars ? S_OK : E_INVALIDARG;
}

HRESULT
GetRegWord32(HKEY Key,
             PWSTR Value,
             PULONG Word,
             ULONG Default,
             BOOL CanDefault)
{
    ULONG Length;
    ULONG Error;
    ULONG Type;
    HRESULT Status;

    Length = sizeof(*Word);
    Error = RegQueryValueEx(Key, Value, NULL, &Type, (LPBYTE)Word, &Length);
    if (Error != ERROR_SUCCESS)
    {
        Status = HRESULT_FROM_WIN32(Error);
    }
    else if (Type != REG_DWORD ||
             Length != sizeof(*Word))
    {
        Status = E_INVALIDARG;
    }
    else
    {
        Status = S_OK;
    }

    if (Status != S_OK)
    {
        // Set to default.

        if (!CanDefault)
        {
            return E_NOINTERFACE;
        }

        *Word = Default;
        Status = S_OK;
    }

    return Status;
}

HRESULT
GetRegMachineCrash(void)
{
    ULONG Error;
    HKEY Key;

    Error = RegOpenKey(HKEY_LOCAL_MACHINE,
                       SUBKEY_CRASH_CONTROL L"\\MachineCrash",
                       &Key);
    if (Error != ERROR_SUCCESS)
    {
        // If the key doesn't exist we just go with the defaults.
        return S_OK;
    }

    GetRegWord32(Key, L"TempDestination", &g_McTempDestination, 0, TRUE);

    GetRegStr(Key, L"DumpFile",
              g_McDumpFile, RTL_NUMBER_OF(g_McDumpFile),
              L"");

    RegCloseKey(Key);
    return S_OK;
}

HRESULT
GetRegCrashControl(void)
{
    HRESULT Status;
    ULONG Error;
    HKEY Key;
    WCHAR TmpPath[MAX_PATH];
    PWSTR Scan;

    Error = RegOpenKey(HKEY_LOCAL_MACHINE,
                       SUBKEY_CRASH_CONTROL,
                       &Key);
    if (Error != ERROR_SUCCESS)
    {
        // If the key doesn't exist we just go with the defaults.
        return S_OK;
    }

    GetRegWord32(Key, L"LogEvent", &g_CcLogEvent, 0, TRUE);
    GetRegWord32(Key, L"SendAlert", &g_CcSendAlert, 0, TRUE);
    GetRegWord32(Key, L"Overwrite", &g_CcOverwrite, 0, TRUE);
    GetRegWord32(Key, L"ReportMachineDump", &g_CcReportMachineDump, 0, TRUE);

    if ((Status = ExpandRegStr(Key, L"MiniDumpDir",
                               TmpPath, RTL_NUMBER_OF(TmpPath),
                               L"%SystemRoot%\\Minidump",
                               g_CcMiniDumpDir,
                               RTL_NUMBER_OF(g_CcMiniDumpDir))) != S_OK)
    {
        g_CcMiniDumpDir[0] = 0;
        goto Exit;
    }

    // Remove any trailing slash on the directory name.
    Scan = g_CcMiniDumpDir + wcslen(g_CcMiniDumpDir);
    if (Scan > g_CcMiniDumpDir && *(Scan - 1) == L'\\')
    {
        *--Scan = 0;
    }

    if ((Status = ExpandRegStr(Key, L"DumpFile",
                               TmpPath, RTL_NUMBER_OF(TmpPath),
                               L"%SystemRoot%\\MEMORY.DMP",
                               g_CcDumpFile,
                               RTL_NUMBER_OF(g_CcDumpFile))) != S_OK)
    {
        g_CcDumpFile[0] = 0;
        goto Exit;
    }

    Status = S_OK;

 Exit:
    RegCloseKey(Key);
    return Status;
}

HRESULT
GetDumpInfo(void)
{
    HANDLE File;
    ULONG Bytes;
    BOOL Succ;
    HRESULT Status;

    if (!g_McDumpFile[0])
    {
        return E_NOINTERFACE;
    }

    File = CreateFile(g_McDumpFile,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      0,
                      NULL);
    if (File == INVALID_HANDLE_VALUE)
    {
        return E_NOINTERFACE;
    }

    Succ = ReadFile(File,
                    &g_DumpHeader,
                    sizeof(g_DumpHeader),
                    &Bytes,
                    NULL);

    CloseHandle(File);

    if (Succ &&
        Bytes == sizeof(g_DumpHeader) &&
        g_DumpHeader.Signature == DUMP_SIGNATURE &&
        g_DumpHeader.ValidDump == DUMP_VALID_DUMP)
    {
#ifdef _WIN64
        Status =
            StringCchPrintf(g_DumpBugCheckString,
                            RTL_NUMBER_OF(g_DumpBugCheckString),
                            L"0x%08x (0x%016I64x, 0x%016I64x, 0x%016I64x, 0x%016I64x)",
                            g_DumpHeader.BugCheckCode,
                            g_DumpHeader.BugCheckParameter1,
                            g_DumpHeader.BugCheckParameter2,
                            g_DumpHeader.BugCheckParameter3,
                            g_DumpHeader.BugCheckParameter4);
#else
        Status =
            StringCchPrintf(g_DumpBugCheckString,
                            RTL_NUMBER_OF(g_DumpBugCheckString),
                            L"0x%08x (0x%08x, 0x%08x, 0x%08x, 0x%08x)",
                            g_DumpHeader.BugCheckCode,
                            g_DumpHeader.BugCheckParameter1,
                            g_DumpHeader.BugCheckParameter2,
                            g_DumpHeader.BugCheckParameter3,
                            g_DumpHeader.BugCheckParameter4);
#endif

        // This check and message are here just to make
        // it easy to catch cases where the message outgrows
        // the buffer.  It is highly unlikely that this will happen.
        if (Status != S_OK)
        {
            KdPrint(("SAVEDUMP: g_DumpBugCheckString too small\n"));
            Status = S_OK;
        }
    }
    else
    {
        ZeroMemory(&g_DumpHeader, sizeof(g_DumpHeader));
        Status = E_NOINTERFACE;
    }

    return Status;
}

HRESULT
SetSecurity(HANDLE FileHandle)
{
    PSID LocalSystemSid = NULL;
    PSID AdminSid = NULL;
    SID_IDENTIFIER_AUTHORITY NtAuthority = SECURITY_NT_AUTHORITY;
    SID_IDENTIFIER_AUTHORITY WorldAuthority = SECURITY_WORLD_SID_AUTHORITY;
    PSECURITY_DESCRIPTOR SecurityDescriptor;
    BYTE SdBuffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PACL Acl;
    BYTE AclBuffer[1024];
    HANDLE Token = NULL;
    PTOKEN_OWNER TokOwner;
    ULONG TryLen = 256;
    ULONG RetLen;
    NTSTATUS NtStatus;

    NtStatus = RtlAllocateAndInitializeSid(&NtAuthority, 1,
                                           SECURITY_LOCAL_SYSTEM_RID,
                                           0, 0, 0, 0, 0, 0, 0,
                                           &LocalSystemSid);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Exit;
    }

    NtStatus = RtlAllocateAndInitializeSid(&NtAuthority, 2,
                                           SECURITY_BUILTIN_DOMAIN_RID,
                                           DOMAIN_ALIAS_RID_ADMINS,
                                           0, 0, 0, 0, 0, 0, &AdminSid);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Exit;
    }

    SecurityDescriptor = (PSECURITY_DESCRIPTOR)SdBuffer;

    //
    // You can be fancy and compute the exact size, but since the
    // security descriptor capture code has to do that anyway, why
    // do it twice?
    //

    Acl = (PACL)AclBuffer;

    NtStatus = RtlCreateSecurityDescriptor(SecurityDescriptor,
                                           SECURITY_DESCRIPTOR_REVISION);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Exit;
    }
    NtStatus = RtlCreateAcl(Acl, sizeof(AclBuffer), ACL_REVISION);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Exit;
    }

    //
    // Current user, Administrator and System have full control
    //

    if (!OpenThreadToken(GetCurrentThread(), TOKEN_QUERY, TRUE, &Token) &&
        !OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &Token))
    {
        NtStatus = STATUS_ACCESS_DENIED;
        goto Exit;
    }

    for (;;)
    {
        TokOwner = (PTOKEN_OWNER)malloc(TryLen);
        if (!TokOwner)
        {
            NtStatus = STATUS_NO_MEMORY;
            goto Exit;
        }

        if (GetTokenInformation(Token, TokenOwner, TokOwner, TryLen, &RetLen))
        {
            NtStatus = RtlAddAccessAllowedAce(Acl, ACL_REVISION,
                                              GENERIC_ALL | DELETE |
                                              WRITE_DAC | WRITE_OWNER,
                                              TokOwner->Owner);
            break;
        }
        else if (RetLen <= TryLen)
        {
            NtStatus = STATUS_ACCESS_DENIED;
            break;
        }

        free(TokOwner);
        TryLen = RetLen;
    }

    free(TokOwner);

    if (!NT_SUCCESS(NtStatus))
    {
        goto Exit;
    }

    NtStatus = RtlAddAccessAllowedAce(Acl, ACL_REVISION,
                                      GENERIC_ALL | DELETE |
                                      WRITE_DAC | WRITE_OWNER,
                                      AdminSid);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Exit;
    }

    NtStatus = RtlAddAccessAllowedAce(Acl, ACL_REVISION,
                                      GENERIC_ALL | DELETE |
                                      WRITE_DAC | WRITE_OWNER,
                                      LocalSystemSid);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Exit;
    }

    NtStatus = RtlSetDaclSecurityDescriptor(SecurityDescriptor, TRUE, Acl,
                                            FALSE);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Exit;
    }
    NtStatus = RtlSetOwnerSecurityDescriptor(SecurityDescriptor, AdminSid,
                                             FALSE);
    if (!NT_SUCCESS(NtStatus))
    {
        goto Exit;
    }

    NtStatus = NtSetSecurityObject(FileHandle,
                                   DACL_SECURITY_INFORMATION,
                                   SecurityDescriptor);

 Exit:
    if (AdminSid)
    {
        RtlFreeSid(AdminSid);
    }
    if (LocalSystemSid)
    {
        RtlFreeSid(LocalSystemSid);
    }
    if (Token)
    {
        CloseHandle(Token);
    }

    return NT_SUCCESS(NtStatus) ? S_OK : HRESULT_FROM_NT(NtStatus);
}

HRESULT
CreateMiniDumpFile(PHANDLE MiniFileHandle)
{
    INT i;
    SYSTEMTIME Time;
    HRESULT Status;
    HANDLE FileHandle;

    if (!g_CcMiniDumpDir[0])
    {
        // Bad minidump directory.
        return E_INVALIDARG;
    }

    //
    // If directory does not exist, create it. Ignore errors here because
    // they will be picked up later when we try to create the file.
    //

    CreateDirectory(g_CcMiniDumpDir, NULL);

    //
    // Format is: Mini-MM_DD_YY_HH_MM.dmp
    //

    GetLocalTime(&Time);

    for (i = 1; i < 100; i++)
    {
        if ((Status = StringCchPrintf(g_MiniDumpFile,
                                      RTL_NUMBER_OF(g_MiniDumpFile),
                                      L"%s\\Mini%2.2d%2.2d%2.2d-%2.2d.dmp",
                                      g_CcMiniDumpDir,
                                      (int)Time.wMonth,
                                      (int)Time.wDay,
                                      (int)Time.wYear % 100,
                                      (int)i)) != S_OK)
        {
            g_MiniDumpFile[0] = 0;
            return Status;
        }

        FileHandle = CreateFile(g_MiniDumpFile,
                                GENERIC_WRITE | WRITE_DAC,
                                0,
                                NULL,
                                CREATE_NEW,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
        if (FileHandle != INVALID_HANDLE_VALUE)
        {
            break;
        }
    }

    if (FileHandle == INVALID_HANDLE_VALUE)
    {
        // We failed to create a suitable file name.
        g_MiniDumpFile[0] = 0;
        return E_FAIL;
    }

    if ((Status = SetSecurity(FileHandle)) != S_OK)
    {
        CloseHandle(FileHandle);
        DeleteFile(g_MiniDumpFile);
        g_MiniDumpFile[0] = 0;
        return Status;
    }

    *MiniFileHandle = FileHandle;
    return S_OK;
}

#define COPY_CHUNK (1024 * 1024)

HRESULT
CopyAndSecureFile(PWSTR Source,
                  PWSTR Dest,
                  HANDLE DestHandle,
                  BOOL Overwrite,
                  BOOL DeleteDest)
{
    HRESULT Status;
    HANDLE SourceHandle = INVALID_HANDLE_VALUE;
    PUCHAR Buffer = NULL;

    Buffer = (PUCHAR)malloc(COPY_CHUNK);
    if (!Buffer)
    {
        Status = E_OUTOFMEMORY;
        goto Exit;
    }

    SourceHandle = CreateFile(Source,
                              GENERIC_READ,
                              0,
                              NULL,
                              OPEN_EXISTING,
                              FILE_ATTRIBUTE_NORMAL,
                              NULL);
    if (SourceHandle == INVALID_HANDLE_VALUE)
    {
        Status = LAST_HR();
        goto Exit;
    }

    if (DestHandle == INVALID_HANDLE_VALUE)
    {
        DestHandle = CreateFile(Dest,
                                GENERIC_WRITE | WRITE_DAC,
                                0,
                                NULL,
                                Overwrite ? CREATE_ALWAYS : CREATE_NEW,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL);
        if (DestHandle == INVALID_HANDLE_VALUE)
        {
            Status = LAST_HR();
            goto Exit;
        }

        DeleteDest = TRUE;

        if ((Status = SetSecurity(DestHandle)) != S_OK)
        {
            goto Exit;
        }
    }

    for (;;)
    {
        ULONG Req, Done;

        if (!ReadFile(SourceHandle, Buffer, COPY_CHUNK, &Done, NULL))
        {
            Status = LAST_HR();
            break;
        }
        else if (Done == 0)
        {
            // End-of-file.
            Status = S_OK;
            break;
        }

        Req = Done;
        if (!WriteFile(DestHandle, Buffer, Req, &Done, NULL))
        {
            Status = LAST_HR();
            break;
        }
        else if (Done < Req)
        {
            Status = HRESULT_FROM_WIN32(ERROR_HANDLE_DISK_FULL);
            break;
        }
    }

 Exit:
    if (DeleteDest)
    {
        CloseHandle(DestHandle);
        if (Status != S_OK)
        {
            DeleteFile(Dest);
        }
    }
    if (SourceHandle != INVALID_HANDLE_VALUE)
    {
        CloseHandle(SourceHandle);
    }
    free(Buffer);
    return Status;
}

HRESULT
MoveDumpFile(void)
{
    HRESULT Status;

    if (g_DumpHeader.Signature != DUMP_SIGNATURE)
    {
        // Dump file is not present or invalid, so there's nothing to do.
        return S_OK;
    }

    //
    // If the dump file needs to be copied, copy it now.
    //

    if (!g_McTempDestination)
    {
        g_FinalDumpFile = g_McDumpFile;
    }
    else
    {
        if (!g_Test)
        {
            //
            // Set the priority class of this application down to the Lowest
            // priority class to ensure that copying the file does not overload
            // everything else that is going on during system initialization.
            //
            // We do not lower the priority in test mode because it just
            // wastes time.
            //

            SetPriorityClass (GetCurrentProcess(), IDLE_PRIORITY_CLASS);
            SetThreadPriority (GetCurrentThread(), THREAD_PRIORITY_LOWEST);
        }

        if (g_DumpHeader.DumpType == DUMP_TYPE_FULL ||
            g_DumpHeader.DumpType == DUMP_TYPE_SUMMARY)
        {
            if (!g_CcDumpFile[0])
            {
                // Invalid dump file registry entry.
                return E_INVALIDARG;
            }

            if ((Status = CopyAndSecureFile(g_McDumpFile,
                                            g_CcDumpFile,
                                            INVALID_HANDLE_VALUE,
                                            g_CcOverwrite ? TRUE : FALSE,
                                            TRUE)) != S_OK)
            {
                return Status;
            }

            g_FinalDumpFile = g_CcDumpFile;
        }
        else if (g_DumpHeader.DumpType == DUMP_TYPE_TRIAGE)
        {
            HANDLE MiniFile;

            if ((Status = CreateMiniDumpFile(&MiniFile)) != S_OK)
            {
                return Status;
            }

            if ((Status = CopyAndSecureFile(g_McDumpFile,
                                            NULL,
                                            MiniFile,
                                            FALSE,
                                            TRUE)) != S_OK)
            {
                g_MiniDumpFile[0] = 0;
                return Status;
            }

            g_FinalDumpFile = g_MiniDumpFile;
        }

        DeleteFile(g_McDumpFile);
        g_McDumpFile[0] = 0;
    }

    return S_OK;
}

HRESULT
ConvertDumpFile(void)
{
    HRESULT Status;
    IDebugClient4 *DebugClient;
    IDebugControl *DebugControl;
    HANDLE MiniFile;

    //
    // Produce a minidump by conversion if necessary.
    //

    if (!g_FinalDumpFile ||
        (g_DumpHeader.DumpType != DUMP_TYPE_FULL &&
         g_DumpHeader.DumpType != DUMP_TYPE_SUMMARY))
    {
        // No dump or not a convertable dump.
        return S_OK;
    }

    if ((Status = CreateMiniDumpFile(&MiniFile)) != S_OK)
    {
        return Status;
    }

    if ((Status = DebugCreate(__uuidof(IDebugClient4),
                              (void **)&DebugClient)) != S_OK)
    {
        goto EH_File;
    }
    if ((Status = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                              (void **)&DebugControl)) != S_OK)
    {
        goto EH_Client;
    }

    if ((Status = DebugClient->OpenDumpFileWide(g_FinalDumpFile, 0)) != S_OK)
    {
        goto EH_Control;
    }

    if ((Status = DebugControl->
         WaitForEvent(DEBUG_WAIT_DEFAULT, INFINITE)) != S_OK)
    {
        goto EH_Control;
    }

    Status = DebugClient->
        WriteDumpFileWide(NULL, (ULONG_PTR)MiniFile, DEBUG_DUMP_SMALL,
                          DEBUG_FORMAT_DEFAULT, NULL);

 EH_Control:
    DebugControl->Release();
 EH_Client:
    DebugClient->EndSession(DEBUG_END_PASSIVE);
    DebugClient->Release();
 EH_File:
    CloseHandle(MiniFile);
    if (Status != S_OK)
    {
        DeleteFile(g_MiniDumpFile);
        g_MiniDumpFile[0] = 0;
    }
    return Status;
}

VOID
LogEvent(ULONG Id,
         WORD StringCount,
         PWSTR* Strings)
{
    HANDLE LogHandle;
    BOOL Retry;
    DWORD Retries;

    //
    // Attempt to register the event source.
    // Savedump runs early in the startup process so
    // it's possible that the event service hasn't started
    // yet.  If it appears that the service hasn't started,
    // wait a bit until it comes around.  If it hasn't
    // come around after a reasonable amount of time bail out.
    //

    Retries = 0;

    do
    {
        LogHandle = RegisterEventSource(NULL, L"Save Dump");

        //
        // Retry on specific failures that indicate the event
        // service hasn't started yet.
        //

        if (LogHandle == NULL &&
            Retries < 20 &&
            (GetLastError () == RPC_S_SERVER_UNAVAILABLE ||
             GetLastError () == RPC_S_UNKNOWN_IF))
        {
            Sleep(1500);
            Retry = TRUE;
        }
        else
        {
            Retry = FALSE;
        }

        Retries++;
    }
    while (LogHandle == NULL && Retry);

    if (!LogHandle)
    {
        KdPrint(("SAVEDUMP: Unable to register event source, %d\n",
                 GetLastError()));
        return;
    }

    if (!ReportEvent(LogHandle,
                     EVENTLOG_INFORMATION_TYPE,
                     0,
                     Id,
                     NULL,
                     StringCount,
                     0,
                     (LPCWSTR *)Strings,
                     NULL))
    {
        KdPrint(("SAVEDUMP: Unable to report event, %d\n", GetLastError()));
    }

    DeregisterEventSource(LogHandle);
}

void
LogCrashDumpEvent(void)
{
    LPWSTR StringArray[2];
    WORD StringCount;
    DWORD EventId;

    //
    // Set up the parameters based on how much information
    // is available.
    //

    StringCount = 0;

    if (g_DumpBugCheckString[0])
    {
        StringArray[StringCount++] = g_DumpBugCheckString;
    }
    if (g_FinalDumpFile)
    {
        StringArray[StringCount++] = g_FinalDumpFile;
    }

    //
    // Report the appropriate event.
    //

    if (g_FinalDumpFile)
    {
        EventId = EVENT_BUGCHECK_SAVED;
    }
    else if (g_DumpBugCheckString[0])
    {
        EventId = EVENT_BUGCHECK;
    }
    else
    {
        EventId = EVENT_UNKNOWN_BUGCHECK;
    }

    LogEvent(EventId, StringCount, StringArray);
}

void
SendCrashDumpAlert(void)
{
    PADMIN_OTHER_INFO AdminInfo;
    DWORD AdminInfoSize;
    DWORD Length;
    DWORD i;
    ULONG Error;
    UCHAR VariableInfo[4096];

    //
    // Set up the administrator information variables for processing the
    // buffer.
    //

    AdminInfo = (PADMIN_OTHER_INFO)VariableInfo;
    AdminInfo->alrtad_numstrings = 0;
    AdminInfoSize = sizeof(*AdminInfo);

    //
    // Format the bugcheck information into the appropriate message format.
    //

    if (g_DumpBugCheckString[0])
    {
        Length = (wcslen(g_DumpBugCheckString) + 1) * sizeof(WCHAR);
        if (AdminInfoSize + Length > sizeof(VariableInfo))
        {
            goto Error;
        }

        RtlCopyMemory((PCHAR)AdminInfo + AdminInfoSize,
                      g_DumpBugCheckString, Length);

        AdminInfo->alrtad_numstrings++;
        AdminInfoSize += Length;
    }


    //
    // Set up the administrator alert information according to the type of
    // dump that was taken.
    //

    if (g_FinalDumpFile)
    {
        Length = (wcslen(g_FinalDumpFile) + 1) * sizeof(WCHAR);

        if (AdminInfoSize + Length > sizeof(VariableInfo))
        {
            goto Error;
        }

        AdminInfo->alrtad_errcode = ALERT_BugCheckSaved;
        RtlCopyMemory((PCHAR)AdminInfo + AdminInfoSize,
                      g_FinalDumpFile, Length);
        AdminInfo->alrtad_numstrings++;
        AdminInfoSize += Length;
    }
    else
    {
        AdminInfo->alrtad_errcode = ALERT_BugCheck;
    }

    //
    // Get the name of the computer and insert it into the buffer.
    //

    Length = (sizeof(VariableInfo) - AdminInfoSize) / sizeof(WCHAR);
    if (!GetComputerName((LPWSTR)((PCHAR)AdminInfo + AdminInfoSize),
                         &Length))
    {
        goto Error;
    }

    Length = (Length + 1) * sizeof(WCHAR);
    AdminInfo->alrtad_numstrings++;
    AdminInfoSize += Length;

    //
    // Raise the alert.
    //

    i = 0;

    do
    {
        Error = NetAlertRaiseEx(ALERT_ADMIN_EVENT,
                                AdminInfo,
                                AdminInfoSize,
                                L"SAVEDUMP");
        if (Error)
        {
            if (Error == ERROR_FILE_NOT_FOUND)
            {
                if (i++ > 20)
                {
                    break;
                }
                if ((i & 3) == 0)
                {
                    KdPrint(("SAVEDUMP: Waiting for alerter...\n"));
                }

                Sleep(15000);
            }
        }
    } while (Error == ERROR_FILE_NOT_FOUND);

    if (Error != ERROR_SUCCESS)
    {
        goto Error;
    }

    return;

 Error:
    KdPrint(("SAVEDUMP: Unable to raise alert\n"));
}

VOID
__cdecl
wmain(int Argc,
      PWSTR Argv[])
{
    int Arg;
    BOOL Report = TRUE;

    for (Arg = 1; Arg < Argc; Arg++)
    {
        if (Argv[Arg][0] == L'-' || Argv[Arg][0] == L'/')
        {
            switch (Argv[Arg][1])
            {
            case L't':
            case L'T':
#if DBG
                g_Test = TRUE;
#endif
                break;

            default:
                break;
            }
        }
    }

    if (GetRegMachineCrash() != S_OK ||
        GetRegCrashControl() != S_OK)
    {
        LogEvent(EVENT_UNABLE_TO_READ_REGISTRY, 0, NULL);
    }

    GetDumpInfo();

    if (MoveDumpFile() != S_OK)
    {
        LogEvent(EVENT_UNABLE_TO_MOVE_DUMP_FILE, 0, NULL);
    }

    if (ConvertDumpFile() != S_OK)
    {
        LogEvent(EVENT_UNABLE_TO_CONVERT_DUMP_FILE, 0, NULL);
    }

    //if (WatchdogEventHandler(TRUE) == S_OK)
    //{
    //    // Note: Bugcheck EA will be reported in the watchdog code since
    //    // we need to send minidump and wdl files together and we want to have
    //    // a single pop-up only.
    //    Report = FALSE;
    //}

    if (Report)
    {
        // The default behavior is to report a minidump
        // even if the machine dump was not a minidump in
        // order to minimize the amount of data sent.
        // If the system is configured to report the
        // machine dump go ahead and send it regardless
        // of what kind of dump it is.
        PWSTR ReportDumpFile = g_CcReportMachineDump ?
            g_FinalDumpFile : g_MiniDumpFile;

        if (ReportDumpFile && ReportDumpFile[0])
        {
            // Report bugcheck to Microsoft Error Reporting.
            if (FrrvToStatus(ReportEREvent(eetKernelFault,
                                           ReportDumpFile,
                                           NULL)) != S_OK)
            {
                LogEvent(EVENT_UNABLE_TO_REPORT_BUGCHECK, 0, NULL);
            }
        }
    }

    //
    // Knock down reliability ShutdownEventPending flag. We must always try
    // to do this since somebody can set this flag and recover later on
    // (e.g. watchdog's EventFlag cleared). With this flag set savedump
    // will always run and we don't want that.
    //
    // Note: This flag is shared between multiple components.
    // Only savedump is allowed to clear this flag, all other
    // components are only allowed to set it to trigger
    // savedump run at next logon.
    //

    HKEY Key;

    if (RegOpenKey(HKEY_LOCAL_MACHINE,
                   SUBKEY_RELIABILITY,
                   &Key) == ERROR_SUCCESS)
    {
        RegDeleteValue(Key, L"ShutdownEventPending");
        RegCloseKey(Key);
    }

    //
    // If there was a dump produced we may need to log an event
    // and send an alert.
    // We delay these time consuming opertaions till the end. We had the
    // case where SendCrashDumpAlert delayed PC Health pop-ups few minutes.
    //

    BOOL HaveCrashData =
        g_McDumpFile[0] ||
        g_DumpBugCheckString[0] ||
        g_FinalDumpFile;
    
    if (HaveCrashData && g_CcLogEvent)
    {
        LogCrashDumpEvent();
    }

    //
    //  This function will fill the BugCheckString for DirtyShutdown UI based
    //  on the flag set by EventLog service during startup time, in some case
    //  Eventlog service might start after savedump, so we will need to run this
    //  function after the first event was logged by savedump.
    //  if g_CcLogEvent == FALSE, it is OK not set the string since the user
    //  are not interested about the BugCheck info at all.
    //
    if (DirtyShutdownEventHandler(TRUE) != S_OK)
    {
        LogEvent(EVENT_UNABLE_TO_REPORT_DIRTY_SHUTDOWN, 0, NULL);
    }

    if (HaveCrashData && g_CcSendAlert)
    {
        SendCrashDumpAlert();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\savedump\savedump.h ===
/*++

Copyright (c) 1991-2002  Microsoft Corporation

Module Name:

    savedump.h

Abstract:

    This module contains the code to recover a dump from the system paging
    file.

Environment:

    User mode.

Revision History:

--*/

#ifndef _SAVEDUMP_H_
#define _SAVEDUMP_H_

#ifndef UNICODE
#define UNICODE
#endif

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stdio.h>
#include <windows.h>
#include <lmcons.h>
#include <lmalert.h>
#include <ntiodump.h>
#include <strsafe.h>

#include <sdevents.h>
#include <alertmsg.h>
#include <dbgeng.h>
#include <faultrep.h>
#include <erdirty.h>
#include <erwatch.h>

#define SUBKEY_CRASH_CONTROL         L"SYSTEM\\CurrentControlSet\\Control\\CrashControl"
#define SUBKEY_WATCHDOG_DISPLAY      L"SYSTEM\\CurrentControlSet\\Control\\Watchdog\\Display"
#define SUBKEY_RELIABILITY           L"SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Reliability"

#define LAST_HR() HRESULT_FROM_WIN32(GetLastError())

extern DUMP_HEADER g_DumpHeader;
extern WCHAR g_DumpBugCheckString[256];
extern WCHAR g_MiniDumpFile[MAX_PATH];

HRESULT
FrrvToStatus(EFaultRepRetVal Frrv);

HRESULT
GetRegStr(HKEY Key,
          PWSTR Value,
          PWSTR Buffer,
          ULONG BufferChars,
          PWSTR Default);

HRESULT
GetRegWord32(HKEY Key,
             PWSTR Value,
             PULONG Word,
             ULONG Default,
             BOOL CanDefault);

#endif  // _SAVEDUMP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\sds\sdp.cpp ===
#include <windows.h>
#include <stdio.h>
#include <direct.h>
#include <assert.h>
#include <tchar.h>
#include <dbghelp.h>
#include <strsafe.h>
#include <str.h>

typedef enum {
    cmdIni,
    cmdInfo,
    cmdClient,
    cmdHave,
    cmdSync,
    cmdMax
};

typedef BOOL (*CMDPROC)(TCHAR *dir);

typedef struct _CMD {
    TCHAR *sz;
    CMDPROC cmdproc;
    PENUMDIRTREE_CALLBACK enumdirproc;
} CMD, *PCMD;

BOOL ini(TCHAR *path);
BOOL info(TCHAR *dir);
BOOL client(TCHAR *dir);
BOOL have(TCHAR *dir);
BOOL sync(TCHAR *dir);

BOOL CALLBACK cbIni(LPCSTR filepath, void *data);
BOOL CALLBACK cbInfo(LPCSTR filepath, void *data);
BOOL CALLBACK cbClient(LPCSTR filepath, void *data);
BOOL CALLBACK cbHave(LPCSTR filepath, void *data);
BOOL CALLBACK cbSync(LPCSTR filepath, void *data);

CMD gcmds[cmdMax] =
{
    {TEXT("ini"),    ini,    cbIni},
    {TEXT("info"),   info,   cbInfo},
    {TEXT("client"), client, cbClient},
    {TEXT("have"),   have,   cbHave},
    {TEXT("sync"),   sync,   cbSync},
};

bool  grecursive = false;
int   gcmd;
TCHAR gdir[SZ_SIZE];









bool init()
{
    grecursive = false;
    gcmd = cmdMax;
    _tgetcwd(gdir, SZ_SIZE);

    return true;
}


bool parsecmd(int argc, TCHAR *argv[])
{
    int i;

    for (i = 1; i < argc; i++)
    {
        if (!_tcscmp(argv[i], TEXT("...")))
        {
            grecursive = true;
        }
        else if (!_tcsicmp(argv[i], TEXT("ini")))
        {
            gcmd = cmdIni;
        }
        else if (!_tcsicmp(argv[i], TEXT("info")))
        {
            gcmd = cmdInfo;
        }
        else if (!_tcsicmp(argv[i], TEXT("client")))
        {
            gcmd = cmdClient;
        }
        else if (!_tcsicmp(argv[i], TEXT("have")))
        {
            gcmd = cmdHave;
        }
        else if (!_tcsicmp(argv[i], TEXT("sync")))
        {
            gcmd = cmdSync;
        }
        else
        {
            _tprintf(TEXT("SDP: \"%s\" is an unrecognized parameter.\n"), argv[i]);
            return false;
        }
    }

    return true;
}


BOOL
dumpfile(
    const TCHAR *path
    )
{
    BOOL   rc;
    HANDLE hf;
    DWORD  size;
    DWORD  cb;
    LPSTR  p;
    char   buf[SZ_SIZE];

    assert(path && *path);

    fflush(stdout);

    rc = FALSE;

    hf = CreateFile(path,
                      GENERIC_READ,
                      FILE_SHARE_READ,
                      NULL,
                      OPEN_EXISTING,
                      FILE_ATTRIBUTE_NORMAL,
                      NULL);

    if (hf == INVALID_HANDLE_VALUE)
        return FALSE;

    // test validity of file pointer

    size = GetFileSize(hf, NULL);
    if (!size || size > SZ_SIZE)
        goto cleanup;

    // read it

    ZeroMemory(buf, SZ_SIZE * sizeof(buf[0]));
    if (!ReadFile(hf, buf, size, &cb, 0))
        goto cleanup;

    if (cb != size)
        goto cleanup;

    rc = TRUE;

    printf("%s\n", buf);

cleanup:

    // done

    if (hf)
        CloseHandle(hf);

    fflush(stdout);

    return rc;
}


BOOL ini(TCHAR *path)
{
    TCHAR file[SZ_SIZE];

    StringCchCopy(file, DIMA(file), path);
    if (!_tcsstr(file, TEXT("sd.ini")))
    {
        EnsureTrailingBackslash(file);
        StringCchCat(file, DIMA(file), TEXT("sd.ini"));
    }
    _tprintf(TEXT("------- SDP INI: %s -------\n"), path);
    dumpfile(file);

    return false;
}


BOOL CALLBACK cbIni(LPCSTR filepath, void *data)
{
    TCHAR sz[SZ_SIZE];
    TCHAR path[SZ_SIZE];

    ansi2tchar(filepath, sz, SZ_SIZE);
    getpath(sz, path, DIMA(path));

    return ini(path);
}


BOOL process(TCHAR *dir, TCHAR *cmd)
{
    BOOL rc;
    DWORD err;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;
    TCHAR sz[SZ_SIZE];
    StringCchCopy(sz, DIMA(sz), cmd);

    fflush(stdout);

    GetStartupInfo(&si);
    ZeroMemory(&pi, sizeof(pi));
    rc = CreateProcess(NULL,            // LPCWSTR lpszImageName,
                       sz,              // LPCWSTR lpszCmdLine,
                       NULL,            // LPSECURITY_ATTRIBUTES lpsaProcess,
                       NULL,            // LPSECURITY_ATTRIBUTES lpsaThread,
                       true,            // BOOL fInheritHandles,
                       0,               // DWORD dwCreationFlags,
                       NULL,            // LPVOID lpvEnvironment,
                       dir,             // LPWSTR lpszCurDir,
                       &si,             // LPSTARTUPINFOW lpsiStartInfo,
                       &pi              // LPPROCESS_INFORMATION lppiProcInfo
                       );

    if (!rc || !pi.hProcess)
    {
        err = GetLastError();
        goto cleanup;
    }

    // Wait for command to complete ... Give it 20 minutes

    err = WaitForSingleObject(pi.hProcess, 1200000);

    if (err != WAIT_OBJECT_0)
    {
        rc = false;
        goto cleanup;
    }

    // Get the process exit code

    GetExitCodeProcess(pi.hProcess, &err);
    rc = (err == ERROR_SUCCESS) ? true : false;

cleanup:

    if (pi.hProcess)
        CloseHandle(pi.hProcess);

    fflush(stdout);

    return rc;
}


BOOL info(TCHAR *dir)
{
    _tprintf(TEXT("------- SDP INFO: %s -------\n"), dir);
    return process(dir, TEXT("sd.exe info"));
}


BOOL CALLBACK cbInfo(LPCSTR filepath, void *data)
{
    TCHAR sz[SZ_SIZE];
    TCHAR path[SZ_SIZE];

    ansi2tchar(filepath, sz, SZ_SIZE);
    getpath(sz, path, DIMA(path));

    info(path);

    return false;
}


BOOL client(TCHAR *dir)
{
    _tprintf(TEXT("------- SDP CLIENT: %s -------\n"), dir);
    if (!process(dir, TEXT("sd.exe info")))
        return false;
    return process(dir, TEXT("sd.exe client -o"));
}


BOOL CALLBACK cbClient(LPCSTR filepath, void *data)
{
    TCHAR sz[SZ_SIZE];
    TCHAR path[SZ_SIZE];

    ansi2tchar(filepath, sz, SZ_SIZE);
    getpath(sz, path, DIMA(path));

//  ini(sz);
    client(path);

    return false;
}


BOOL have(TCHAR *dir)
{
    _tprintf(TEXT("------- SDP HAVE: %s -------\n"), dir);
    return process(dir, TEXT("sd.exe have"));
}


BOOL CALLBACK cbHave(LPCSTR filepath, void *data)
{
    TCHAR sz[SZ_SIZE];
    TCHAR path[SZ_SIZE];

    ansi2tchar(filepath, sz, SZ_SIZE);
    getpath(sz, path, DIMA(path));

    have(path);

    return false;
}


BOOL sync(TCHAR *dir)
{
    return process(dir, TEXT("sd.exe sync"));
}


BOOL CALLBACK cbSync(LPCSTR filepath, void *data)
{
    TCHAR sz[SZ_SIZE];
    TCHAR path[SZ_SIZE];

    ansi2tchar(filepath, sz, SZ_SIZE);
    getpath(sz, path, DIMA(path));

    sync(path);
    fflush(stdout);

    return false;
}


bool cmd()
{
    char sz[SZ_SIZE];

    if (gcmd == cmdMax)
        return false;

    if (grecursive)
    {
        tchar2ansi(gdir, sz, SZ_SIZE);
        EnumDirTree(INVALID_HANDLE_VALUE, sz, "sd.ini", NULL, gcmds[gcmd].enumdirproc, NULL);
        return true;
    }

    gcmds[gcmd].cmdproc(gdir);
    return true;
}


extern "C" int __cdecl _tmain(int argc, _TCHAR **argv, _TCHAR **envp)
{
    if (!init())
        return -1;

    if (!parsecmd(argc, argv))
        return -1;

    if (!cmd())
        return -1;

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\sds\str.cpp ===
#include <windows.h>
#include <stdio.h>
#include <direct.h>
#include <assert.h>
#include <tchar.h>
#include <dbghelp.h>
#include <strsafe.h>
#include <str.h>

BOOL
wcs2ansi(
    const wchar_t *pwsz,
    char  *psz,
    DWORD pszlen
    )
{
    BOOL rc;
    int  len;

    assert(psz && pwsz);

    len = wcslen(pwsz);
    if (!len) {
        *psz = 0;
        return TRUE;
    }

    rc = WideCharToMultiByte(CP_ACP,
                             WC_SEPCHARS | WC_COMPOSITECHECK,
                             pwsz,
                             len,
                             psz,
                             pszlen,
                             NULL,
                             NULL);
    if (!rc)
        return FALSE;

    psz[len] = 0;

    return TRUE;
}


BOOL
ansi2wcs(
    const char *psz,
    wchar_t *pwsz,
    DWORD pwszlen
    )
{
    BOOL rc;
    int  len;

    assert(psz && pwsz);

    len = strlen(psz);
    if (!len) {
        *pwsz = 0L;
        return TRUE;
    }

    rc = MultiByteToWideChar(CP_ACP,
                             MB_COMPOSITE,
                             psz,
                             len,
                             pwsz,
                             pwszlen);
    if (!rc)
        return FALSE;

    pwsz[len] = 0;

    return TRUE;
}


BOOL
tchar2ansi(
    const TCHAR *tsz,
    char *psz,
    DWORD  pszlen
    )
{
#ifdef UNICODE
    return wcs2ansi(tsz, psz, pszlen);
#else
    strcpy(psz, tsz);
    return true;
#endif
}


BOOL
ansi2tchar(
    const char *psz,
    TCHAR *tsz,
    DWORD tszlen
    )
{
#ifdef UNICODE
    return ansi2wcs(psz, tsz, tszlen);
#else
    strcpy(tsz, psz);
    return true;
#endif
}


void EnsureTrailingBackslash(TCHAR *sz)
{
    int i;

    assert(sz);

    i = _tcslen(sz);
    if (!i)
        return;

    if (sz[i - 1] == TEXT('\\'))
        return;

    sz[i] = TEXT('\\');
    sz[i + 1] = TEXT('\0');
}


void RemoveTrailingBackslash(TCHAR *sz)
{
    int i;

    assert(sz);

    i = _tcslen(sz);
    if (!i)
        return;

    if (sz[i - 1] == TEXT('\\'))
        sz[i] = TEXT('\0');
}


void getpath(TCHAR *fullpath, TCHAR *path, DWORD size)
{
    static TCHAR drive[SZ_SIZE];
    static TCHAR dir[SZ_SIZE];

    assert(fullpath && *fullpath && path);

    _tsplitpath(fullpath, drive, dir, NULL, NULL);
    StringCchCopy(path, size, drive);
    StringCchCat(path, size, dir);
    path += _tcslen(path) - 1;
    if (*path == TEXT('\\'))
        *path = TEXT('\0');
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\sds\str.h ===
#define SZ_SIZE  MAX_PATH

BOOL
wcs2ansi(
    const wchar_t *pwsz,
    char  *psz,
    DWORD  pszlen
    );

BOOL
ansi2wcs(
    const char *psz,
    wchar_t *pwsz,
    DWORD pwszlen
    );

BOOL
tchar2ansi(
    const TCHAR *tsz,
    char *psz,
    DWORD  pszlen
    );

BOOL
ansi2tchar(
    const char *psz,
    TCHAR *tsz,
    DWORD tszlen
    );

void EnsureTrailingBackslash(TCHAR *sz);

void RemoveTrailingBackslash(TCHAR *sz);

void getpath(TCHAR *fullpath, TCHAR *path, DWORD size);

#ifndef DIMA
 #define DIMAT(Array, EltType) (sizeof(Array) / sizeof(EltType))
 #define DIMA(Array) DIMAT(Array, (Array)[0])
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\setup\resource.h ===
#define IDD_LICENSE         4000
#define IDC_EDIT_LICENSE    4002
#define IDC_UNUSED          -1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\oca_tools\ocawreports\head.inc ===
<!--#include file="../inc/headerstrings.inc"-->
<!--#INCLUDE file="../inc/language.inc"-->

<style>.userData { BEHAVIOR: url(#default#userdata)	} </style>
<title><% = L_HEADER_INC_TITLE_PAGETITLE %></title>

</head>
<body BGCOLOR="#ffffff" TOPMARGIN="0" LEFTMARGIN="0" MARGINHEIGHT="0" MARGINWIDTH="0">
<script LANGUAGE="javascript">
<!--
	var headerinctitleworldhometooltip = "<% = L_HEADERINC_TITLE_WORLDHOME_TOOLTIP %>";
	var headerincimagealttooltip = "<% = L_HEADERINC_IMAGE_ALT_TOOLTIP %>";
	var headerincalinkmicrosoftmenuitem = "<% = L_HEADERINC_ALINK_MICROSOFT_MENUITEM %>";
	var headerincalinkhomemenuitem = "<% = L_HEADERINC_ALINK_HOME2_MENUITEM %>";
	var headerincalinkcermenuitem = "<% = L_HEADERINC_ALINK_CER_MENUITEM %>";
	var headerincalinkworldmenuitem = "<% = L_HEADERINC_ALINK_WORLD_MENUITEM %>";
	var headertitleocahometooltip = "<% = L_HEADERINC_TITLE_OCAHOME_TOOLTIP %>";
	var headerinctitlecerhometooltip = "<% = L_HEADERINC_TITLE_CERHOME_TOOLTIP %>";
	var headerimagesbannertext = "<% = L_HEADERINC_IMAGES_BANNER_TEXT%>";
	var headerisapihomemenuitem = "<% = L_HEADERINC_ISAPI_HOME_MENUITEM %>";
	var headerincmicrosofthomemenuitem = "<% = L_HEADERINC_MICROSOFT_HOME_MENUITEM %>";
	var heaerincallproductsmenuitem = "<% = L_HEADERINC_ALL_PRODUCTS_MENUITEM %>";
	var headerincallproductslinktext = "<% = L_HEADERINC_ALLPRODUCTS_LINK_TEXT %>";
	var headerincdownloadsdownloadsmenuitem = "<% = L_HEADERINC_DOWNLOADS_DOWNLOADS_MENUITEM %>";
	var headerincdownloadslinktext = "<% = L_HEADERINC_DOWNLOADS_LINK_TEXT %>";
	var headerincmsproductcatalogmenuitem = "<% = L_HEADERINC_MSPRODUCT_CATALOG_MENUITEM %>";
	var headerincmsproductcatalogtext = "<% = L_HEADERINC_MSPRODUCT_CATALOG_TEXT %>";
	var headerincmicrosoftaccessibilitymenuitem = "<% = L_HEADERINC_MICROSOFT_ACCESSIBILITY_MENUITEM %>";
	var headerincmicrosoftaccessibilitytext = "<% = L_HEADERINC_MICROSOFT_ACCESSIBILITY_TEXT %>";
	var headerincserverproductsmenuitem = "<% = L_HEADERINC_SERVER_PRODUCTS_MENUITEM %>";
	var headerincserverproductstext = "<% = L_HEADERINC_SERVER_PRODUCTS_TEXT %>";
	var headerincdevelopertoolsmenuitem = "<% = L_HEADERINC_DEVELOPER_TOOLS_MENUITEM %>";
	var headerincdevelopertoolstext = "<% = L_HEADERINC_DEVELOPER_TOOLS_TEXT %>";
	var headerincofficefamilymenuitem = "<% = L_HEADERINC_OFFICE_FAMILY_MENUITEM %>";
	var headerincofficefamilytext = "<% = L_HEADERINC_OFFICE_FAMILY_TEXT %>";
	var headerincwindowsfamilymenuitem = "<% = L_HEADERINC_WINDOWS_FAMILY_MENUITEM %>";
	var headerincwindowsfamilytext = "<% = L_HEADERINC_WINDOWS_FAMILY_TEXT %>";
	var headerincmsnlinkmenuitem = "<% = L_HEADERINC_MSN_LINK_MENUITEM %>";
	var headerincmsnlinktext = "<% = L_HEADERINC_MSN_LINK_TEXT %>";
	var headerincsupportlinkmenuitem = "<% = L_HEADERINC_SUPPORT_LINK_MENUITEM %>";
	var headerincsupportlinktext = "<% = L_HEADERINC_SUPPORT_LINK_TEXT %>";
	var headerincknowledgebasemenuitem = "<% = L_HEADERINC_KNOWLEDGE_BASE_MENUITEM %>";
	var headerincknowledgebasetext = "<% = L_HEADERINC_KNOWLEDGE_BASE_TEXT %>";
	var headerincproductsupportoptionsmenuitem = "<% = L_HEADERINC_PRODUCTSUPPORT_OPTIONS_MENUITEM %>";
	var headerincproductsupportoptionstext = "<% = L_HEADERINC_PRODUCTSUPPORT_OPTIONS_TEXT %>";
	var headerincservicepartnerreferralsmenuitem = "<% = L_HEADERINC_SERVICEPARTNER_REFERRALS_MENUITEM %>";
	var headerincservicepartnerreferralstext = "<% = L_HEADERINC_SERVICEPARTNER_REFERRALS_TEXT %>";
	var headerincsearchlinkmenuitem = "<% = L_HEADERINC_SEARCH_LINK_MENUITEM %>";
	var headerincsearchlinktext = "<% = L_HEADERINC_SEARCH_LINK_TEXT %>";
	var headerincsearchmicrosoftmenuitem = "<% = L_HEADERINC_SEARCH_MICROSOFT_MENUITEM %>";
	var headerincsearchmicrosofttext = "<% = L_HEADERINC_SEARCH_MICROSOFT_TEXT %>";
	var headerincmsnwebsearchmenuitem = "<% = L_HEADERINC_MSNWEB_SEARCH_MENUITEM %>";
	var headerincmsnwebsearchtext = "<% = L_HEADERINC_MSNWEB_SEARCH_TEXT %>";
	var headerincmicrosoftcomguidemenuitem = "<% = L_HEADERINC_MICROSOFTCOM_GUIDE_MENUITEM %>";
	var headerincmicrosoftcomguidetext = "<% = L_HEADERINC_MICROSOFTCOM_GUIDE_TEXT %>";
	var headerincmicrosoftcomhomemenuitem = "<% = L_HEADERINC_MICROSOFTCOM_HOME_MENUITEM %>";
	var headerincmicrosoftcomhometext = "<% = L_HEADERINC_MICROSOFTCOM_HOME_TEXT %>";
	var headerincmsnhomemenuitem = "<% = L_HEADERINC_MSN_HOME_MENUITEM %>";
	var headerincmsnhometext = "<% = L_HEADERINC_MSN_HOME_TEXT %>";
	var headerinccontactusmenuitem = "<% = L_HEADERINC_CONTACT_US_MENUITEM %>";
	var headerinccontactustext = "<% = L_HEADERINC_CONTACT_US_TEXT %>";
	var headerinceventslinkmenuitem = "<% = L_HEADERINC_EVENTS_LINK_MENUITEM %>";
	var headerinceventslinktext = "<% = L_HEADERINC_EVENTS_LINK_TEXT %>";
	var headerincnewsletterslinkmenuitem = "<% = L_HEADERINC_NEWSLETTERS_LINK_MENUITEM %>";
	var headerincnewsletterslinktext = "<% = L_HEADERINC_NEWSLETTERS_LINK_TEXT %>";
	var headerincprofilecentermenuitem = "<% = L_HEADERINC_PROFILE_CENTER_MENUITEM %>";
	var headerincprofilecentertext = "<% = L_HEADERINC_PROFILE_CENTER_TEXT %>";
	var headerinctrainingcertificationmenuitem = "<% = L_HEADERINC_TRAINING_CERTIFICATION_MENUITEM %>";
	var headerinctrainingcertificationtext = "<% = L_HEADERINC_TRAINING_CERTIFICATION_TEXT %>";
	var headerincfreemailaccountmenuitem = "<% = L_HEADERINC_FREEEMAIL_ACCOUNT_MENUITEM %>";
	var headerincfreemailaccounttext = "<% = L_HEADERINC_FREEEMAIL_ACCOUNT_TEXT %>";
	var headerincmicrosoftrightsreservedtext = "<% = L_HEADERINC_MICROSOFT_RIGHTSRESERVED_TEXT %>";
	var headerinctermsofusemenuitem = "<% = L_HEADERINC_TERMSOF_USE_MENUITEM %>";
	var headerinctermsofusetext = "<% = L_HEADERINC_TERMSOF_USE_TEXT %>";
	var headerincprivacystatementmenuitem = "<% = L_HEADERINC_PRIVACY_STATEMENT_MENUITEM %>";
	var headerincprivacystatementtext = "<% = L_HEADERINC_PRIVACY_STATEMENT_TEXT %>";
	var headerincaccessibilitylinkmenuitem = "<% = L_HEADERINC_ACCESSIBILITY_LINK_MENUITEM %>";
	var headerincaccessibilitylinktext = "<% = L_HEADERINC_ACCESSIBILITY_LINK_TEXT %>";
//-->
</script>

		<script language="JavaScript" src="/include/asp/toolbar.js"></script>
		<script language="JavaScript" src="/include/asp/globalMNP.js"></script>
		<script language="JavaScript" src="/include/asp/localMNP.js"></script>
		<script language="JavaScript">drawToolbar();</script>
		
<%
	if instr(1, Request.ServerVariables("URL"), "auto") = 0 then
%>
								
<% 

	dim strReturnPassport
	strReturnPassport = oPassMgrObj.LogoTag2(cstr(Server.URLEncode(ThisPageURL)), cint(TimeWindow), CBool(ForceLogin), Cstr(CoBrandArgs), cint(strLCID), CBool(Secure))
	strReturnPassport = Replace(strReturnPassport, Chr(34), "'") 

%>
		<script language="JavaScript">
		idICPMenuPane.insertAdjacentHTML("beforeEnd", "<SPAN STYLE='font:" + cFont + ";color:" + cColor1 + "'>|&nbsp;</SPAN><Span style='position:absolute;top:0;right:5;height:20;width:100;'><center><span style='background-color:white'>" + "<% = strReturnPassport %>" + "</span></center></span>");
		</script>
								
<%
	End if
%>
<div CLASS="userData" ID="spnUserData" Name="spnUserData"></div>

			<table BORDER="0" height="100%" cellpadding="0" cellspacing="0" width="182">
				<tr valign="top">
					<td>	
<%
	if instr(1, Request.ServerVariables("URL"), "corp") > 0 or instr(1, Request.ServerVariables("URL"), "cer") > 0  or instr(1, Request.ServerVariables("URL"), "shut") > 0 or instr(1, Request.ServerVariables("URL"), "pcw") > 0 then
%>
					<table width="100%" cellpadding="0" cellspacing="0" border="0">
						<tr>
							<td class="sys-toppane-header">
								<% = L_HEADERCERINC_LEFT_NAV_TEXT %>
							</td>
						</tr>
					</table>

<%
	else
%>
					<table width="100%" cellpadding="0" cellspacing="0" border="0">
						<tr>
							<td class="sys-toppane-header">
								<% = L_HEADERINC_LEFT_NAV_TEXT %>
							</td>
						</tr>
					</table>
<%
	end if
%>
					<table width="100%" cellpadding="0" cellspacing="0" border="0" height="100%">
						<tr>
							<td rowspan="2" height="100%" class="flyoutMenu" valign="top">
<%
	if instr(1, Request.ServerVariables("URL"), "corp") > 0 or instr(1, Request.ServerVariables("URL"), "cer") > 0 or instr(1, Request.ServerVariables("URL"), "shut") > 0 or instr(1, Request.ServerVariables("URL"), "pcw") > 0 then
%>

						<table width="100%" cellpadding="0" cellspacing="0" border="0">
							<tr>
								<td class="flyoutLink" valign="middle">
									<img src="/include/images/endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;<a href="http://<% =Request.ServerVariables("SERVER_NAME") %>/cerintro.asp"><% = L_HEADERCERINC_LEFT_NAV_TEXT %></a>
								</td>
							</tr>
						</table>
						<table width="100%" cellpadding="0" cellspacing="0" border="0">
							<tr>
								<td class="flyoutLink">
									<img src="/include/images/endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;<a href="https://<% =Request.ServerVariables("SERVER_NAME") %>/secure/corptransactions.asp"><% = L_HEADERINC_TOP10STATUS_LINK_TEXT %></a>
								</td>
							</tr>
						</table>
						<table width="100%" cellpadding="0" cellspacing="0" border="0">
							<tr>
								<td class="flyoutLink">
									<img src="/include/images/endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;<a href="http://<% =Request.ServerVariables("SERVER_NAME") %>/cerpriv.asp"><% = L_HEADERINC_ALINK_PRIVACY_MENUITEM %></a>
								</td>
							</tr>
						</table>						
						<table width="100%" cellpadding="0" cellspacing="0" border="0">
							<tr>
								<td class="flyoutLink">
									<img src="/include/images/endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;<a href="http://<% =Request.ServerVariables("SERVER_NAME") %>/resources.asp"><% = L_HEADERINC_ALINK_RESOURCES_MENUITEM %></a>
								</td>
							</tr>
						</table>						
						<table width="100%" cellpadding="0" cellspacing="0" border="0">
							<tr>
								<td class="flyoutLink">
									<img src="/include/images/endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;<a href="http://<% =Request.ServerVariables("SERVER_NAME") %>/faq.asp"><% = L_HEADERINC_ALINK_FAQ_MENUITEM %></a>
								</td>
							</tr>
						</table>
						<table width="100%" cellpadding="0" cellspacing="0" border="0">
							<tr>
								<td class="flyoutLink">
									<img src="/include/images/endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;<a href="mailto:<% = strGlobalEmail %>"><% = L_HEADERINC_ALINK_FEEDBACK_MENUITEM %></a>
								</td>
							</tr>
						</table>
<%
	else
%>
						<table width="100%" cellpadding="0" cellspacing="0" border="0">
							<tr>
								<td class="flyoutLink">
									<img src="/include/images/endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;<a href="http://<% =Request.ServerVariables("SERVER_NAME") %>/welcome.asp"><% = L_HEADERINC_ALINK_HOME_MENUITEM %></a>
								</td>
							</tr>
						</table>
						<table width="100%" cellpadding="0" cellspacing="0" border="0">
							<tr>
								<td class="flyoutLink">
									<img src="/include/images/endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;<a href="https://<% =Request.ServerVariables("SERVER_NAME") %>/secure/sprivacy.asp"><% = L_HEADERINC_ALINK_SUBMITREPORT_MENUITEM %></a>
								</td>
							</tr>
						</table>
						<table width="100%" cellpadding="0" cellspacing="0" border="0">
							<tr>
								<td class="flyoutLink">
									<img src="/include/images/endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;<a href="https://<% =Request.ServerVariables("SERVER_NAME") %>/secure/status.asp"><% = L_HEADERINC_ALINK_CHECKSTATUS_MENUITEM %></a>
								</td>
							</tr>
						</table>
						<table width="100%" cellpadding="0" cellspacing="0" border="0">
							<tr>
								<td class="flyoutLink">
									<img src="/include/images/endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;<a href="http://<% =Request.ServerVariables("SERVER_NAME") %>/privacy.asp"><% = L_HEADERINC_ALINK_PRIVACY_MENUITEM %></a>
								</td>
							</tr>
						</table>
						<table width="100%" cellpadding="0" cellspacing="0" border="0">
							<tr>
								<td class="flyoutLink">
									<img src="/include/images/endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;<a href="http://<% =Request.ServerVariables("SERVER_NAME") %>/resources.asp"><% = L_HEADERINC_ALINK_RESOURCES_MENUITEM %></a>
								</td>
							</tr>
						</table>						
						<table width="100%" cellpadding="0" cellspacing="0" border="0">
							<tr>
								<td class="flyoutLink">
									<img src="/include/images/endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;<a href="http://<% =Request.ServerVariables("SERVER_NAME") %>/faq.asp"><% = L_HEADERINC_ALINK_FAQ_MENUITEM %></a>
								</td>
							</tr>
						</table>
						<table width="100%" cellpadding="0" cellspacing="0" border="0">
							<tr>
								<td class="flyoutLink">
									<img src="/include/images/endnode.gif" border="0" WIDTH="11" HEIGHT="11">&nbsp;&nbsp;<a href="mailto:<% = strGlobalEmail %>"><% = L_HEADERINC_ALINK_FEEDBACK_MENUITEM %></a>
								</td>
							</tr>
						</table>
<%
	End if
%>


						</td>
					</tr>
				</table>
			
				</td>
			</tr>
		</table>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\setup\msisetup.c ===
#include <windows.h> 
#include <stdio.h>
#include <stdlib.h>

#include "tchar.h"
#include "shlwapi.h"


LPTSTR pszTitle = _T("Microsoft Debugging Tools");

#define MSI_BUILD_VER_X86     1029  // Latest MSI version for Win2K x86
#define WIN2K_MIN_BUILD_X86   2183  // Win2K RC3 

typedef struct _CommandArgs {
    BOOL    QuietInstall;
    BOOL    StressInstall;
    BOOL    UIStressInstall;
    TCHAR   szInstDir[ _MAX_PATH*sizeof(TCHAR) ];
    TCHAR   szMsiName[ _MAX_PATH*sizeof(TCHAR) ];
    TCHAR   szProductRegKey[ _MAX_PATH*sizeof(TCHAR) ];
} COMMAND_ARGS, *PCOMMAND_ARGS;


// Function prototypes

BOOL
RunCommand(
    PTCHAR szCommandLine,
    HINSTANCE hInst
);

BOOL
GetCommandLineArgs(
    LPTSTR szCmdLine, 
    PCOMMAND_ARGS pComArgs
);


TCHAR szMSIInstFile[_MAX_PATH*sizeof(TCHAR)];
TCHAR szPkgInstFile[_MAX_PATH*sizeof(TCHAR)];
TCHAR szPkgInstCommand[_MAX_PATH*2*sizeof(TCHAR)];


// For stress installs, this command will be used to
// remove the current package but don't remove its
// files, if the current package with the same
// product ID is already installed.

TCHAR szPkgRemoveCommand[_MAX_PATH*2*sizeof(TCHAR)];
TCHAR szPkgRemoveCommand2[_MAX_PATH*2*sizeof(TCHAR)];

// If the first install fails, stress tries again without
// the quiet switch before giving a pop-up
TCHAR szPkgInstCommandNoQuiet[_MAX_PATH*2*sizeof(TCHAR)];

TCHAR szCommandFullPath[_MAX_PATH*sizeof(TCHAR)];


int WINAPI WinMain(
        HINSTANCE hInstance,
        HINSTANCE hPrevInstance,
        LPTSTR lpszCmdLine,
        int nCmdShow
) 

{
    OSVERSIONINFO VersionInfo;
    SYSTEM_INFO SystemInfo;
    BOOL rc;
    BOOL MSIIsInstalled;
    PTCHAR ch;
    TCHAR szBuf[1000];
    TCHAR szSystemDirectory[_MAX_PATH];

    COMMAND_ARGS ComArgs;
    HKEY hKey;
    DWORD dwrc;
    DWORD dwSizeValue;
    DWORD dwType;

    HANDLE hFile;
    WIN32_FIND_DATA FindFileData;

    MSIIsInstalled=FALSE;

    // Get this info for later use
    VersionInfo.dwOSVersionInfoSize = sizeof( OSVERSIONINFO );
    GetVersionEx( &VersionInfo );
    GetSystemInfo( &SystemInfo );

    // Parse through the command line for the various arguments

    rc = GetCommandLineArgs(lpszCmdLine, &ComArgs );

    if (!rc) {
        _stprintf( szBuf, _T("%s%s%s%s%s"),
                   _T(" Usage: \n\n"),
                   _T(" setup.exe [ /q [ /i <InstDir> ] ]\n\n"),
                   _T(" /q\tGive pop-ups only for errors\n\n"),
                   _T(" /i\tInstall to <Instdir>\n\n"),
                   _T(" /n\tInstall <msi package Name>\n\n")
                 );
        MessageBox( NULL, szBuf, pszTitle, 0 );
        return (1);
    } 

    //
    // Set the full path to this setup.exe
    //

    if (GetModuleFileName( NULL, szCommandFullPath, MAX_PATH ) == 0) {
        return(1);
    }

    // Put an end of string after the directory that this was
    // started from
   
    ch = szCommandFullPath + _tcslen(szCommandFullPath);
    while ( *ch != _T('\\') &&  ( ch > szCommandFullPath ) ) ch--; 
    *ch=_T('\0');

    // This will become the full path and name of the MSI file to install
    _tcscpy( szMSIInstFile, szCommandFullPath);

    // Set the full path and name of the msi package
    _tcscpy( szPkgInstFile, szCommandFullPath);
    _tcscat( szPkgInstFile, _T("\\") );
    _tcscat( szPkgInstFile, ComArgs.szMsiName );

    // See if the package exists
    hFile = FindFirstFile( szPkgInstFile, &FindFileData );
    if ( hFile == INVALID_HANDLE_VALUE ) {

        _stprintf( szBuf, _T("%s%s%s%s"),
                   _T("The Microsoft Debugging Tools package "),
                   szPkgInstFile,
                   _T(" does not exist.\n\nSetup cannot contine"),
                   _T(" for this platform.")
                 );
        MessageBox(NULL, szBuf, pszTitle, 0);

        return(1);
    }

    FindClose(hFile);

    // Set the command for installing the package
    _tcscpy( szPkgInstCommand, _T("msiexec /i ") );
    _tcscat( szPkgInstCommand, szPkgInstFile );

    // Set the command for removing the current package
    // that is installed.

    _tcscpy( szBuf, _T("") );
    dwrc = RegOpenKeyEx( HKEY_CURRENT_USER,
                       ComArgs.szProductRegKey,
                       0,
                       KEY_QUERY_VALUE,
                       &hKey
                     );

    if ( dwrc == ERROR_SUCCESS ) {

        _tcscpy( szBuf, _T("") );
        dwSizeValue=sizeof(szBuf);
        RegQueryValueEx ( hKey, 
                          _T("ProductCode"),
                          0,
                          &dwType,
                          (PBYTE)szBuf,
                          &dwSizeValue
                        );

        RegCloseKey(hKey);
    } 

    // Set the command to remove the current package
    // that has an Add/Remove link in the start menu
    _tcscpy(szPkgRemoveCommand2, _T("") );
    if ( _tcslen(szBuf) > 0 ) {
       _tcscpy(szPkgRemoveCommand2, _T("msiexec /x ") );
       _tcscat(szPkgRemoveCommand2, szBuf);
       _tcscat(szPkgRemoveCommand2, _T(" REMOVETHEFILES=0 /qn") );
    }

    // Set the command to remove the current package so that
    // this program works like it used to.
    _tcscpy(szPkgRemoveCommand, _T("msiexec /x ") );
    _tcscat(szPkgRemoveCommand, szPkgInstFile );
    _tcscat(szPkgRemoveCommand, _T(" REMOVETHEFILES=0 /qn") ); 

    // Add a user override installation directory
    if ( _tcslen(ComArgs.szInstDir) > 0 ) {
        _tcscat( szPkgInstCommand, _T(" INSTDIR=") );
        _tcscat( szPkgInstCommand, ComArgs.szInstDir );
    } else if ( ComArgs.UIStressInstall ) {
        GetSystemDirectory( szSystemDirectory, _MAX_PATH );
        _tcscat( szPkgInstCommand, _T(" INSTDIR=") );
        _tcscat( szPkgInstCommand, szSystemDirectory );
    }

    // If this is an "undocumented" stress install
    // don't remove the files of the previous install
    // when you upgrade
    // FEATURESTOREMOVE should never actually need to be used, unless
    // the user has something screwed up on his system where the registry
    // key and products installed don't agree, or MSI thinks there's more
    // products installed than the registry key we look at.

    if ( ComArgs.StressInstall ) {
        _tcscat( szPkgInstCommand, _T(" FEATURESTOREMOVE=\"\"") );
    }

    // If this is an "undocumented" UI stress install
    // only install the private extensions
    if ( ComArgs.UIStressInstall ) {
        _tcscat( szPkgInstCommand, 
                _T(" ADDLOCAL=DBG.DbgExts.Internal,DBG.NtsdFix.Internal") );
    }

    // Add the quiet switch
    // Save the command without a quiet switch
    _tcscpy( szPkgInstCommandNoQuiet, szPkgInstCommand);
    if ( ComArgs.QuietInstall ) {
        _tcscat( szPkgInstCommand, _T(" /qn") );
    } 

    // Do version checks for whether msi is already installed
    //
    // If this is Windows 2000 and build number is >=
    // WIN2K_MIN_BUILD_X86 then MSI is installed
    // Don't try to run instmsi.exe on Windows 2000 because
    // you will get file system protection pop-ups.
    //

    if ( (VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT) &&
         (VersionInfo.dwMajorVersion >= 5.0 ) ) {

        switch (SystemInfo.wProcessorArchitecture) {

        case PROCESSOR_ARCHITECTURE_INTEL:

          if (VersionInfo.dwBuildNumber < WIN2K_MIN_BUILD_X86 ) {

            // The version of MSI that is on early builds of Windows
            // 2000 shouldn't be trusted for installs.

            MessageBox(NULL,
                       _T("The Debugging Tools does not install on ")
                           _T("this version of Windows 2000.  Please upgrade ")
                           _T("your system to a retail version of Windows ")
                           _T("2000 before trying to install this package."),
                       pszTitle,
                       0);
            return(1);
          }
          break;

        case PROCESSOR_ARCHITECTURE_AMD64:
        case PROCESSOR_ARCHITECTURE_IA64:
            break;

        default:

            MessageBox(NULL, _T("Unknown computer architecture."), pszTitle ,0);
            return(1);
        }

        MSIIsInstalled = TRUE;

    } else if ( SystemInfo.wProcessorArchitecture == PROCESSOR_ARCHITECTURE_INTEL) {

        //
        // For Intel OS's prior to Windows 2000, run instmsi.exe
        //
    
        //
        // NT4 X86
        //
        if ( VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_NT ) {
            _tcscat( szMSIInstFile,
                     _T("\\setup\\winnt\\i386\\instmsi.exe /q") );
        } 

        //
        // Win9x
        //
        else if ( VersionInfo.dwPlatformId == VER_PLATFORM_WIN32_WINDOWS ) {
            _tcscat( szMSIInstFile,
                     _T("\\setup\\win9x\\instmsi.exe /q") );
        } else {

          MessageBox(NULL,
                     _T("The Microsoft Debugging Tools does not install")
                         _T(" on this system."),
                     pszTitle,
                     0);
          return(1);
        }

    } else {
        MessageBox(NULL,
                   _T("The Microsoft Debugging Tools cannot be installed")
                       _T(" on this system."),
                   pszTitle,
                   0);

        return(1);
    }


    // Install MSI if it is not already installed
 
    if ( !MSIIsInstalled ) {

        if ( RunCommand( szMSIInstFile, hInstance ) ) {
            MSIIsInstalled = TRUE;
        }
        if (!MSIIsInstalled) {

            MessageBox(NULL,
                       _T("The Windows Installer could not be installed on ")
                           _T("this system.  This is required before installing")
                           _T(" the Microsoft Debugging Tools package.  Try ")
                           _T("logging in as an administrator and try again."),
                       pszTitle,
                       0);
            return(1);
        } 
    } 

    //
    // Now, if this is a stress install,
    // Try to remove the current package in case it is installed
    //

    if ( ComArgs.StressInstall ) {
      if ( _tcslen(szPkgRemoveCommand2) > 0 ) {
          RunCommand( szPkgRemoveCommand2, hInstance);
      }
      RunCommand( szPkgRemoveCommand, hInstance );
      if ( !RunCommand( szPkgInstCommand, hInstance ) ) {

          // Try again without the quiet switch, so that the user will get 
          // a pop-up from dbg.msi and quit calling us

          MessageBox(NULL,
                     _T("There were errors when trying to install the ")
                         _T("debuggers.\nClick OK to attempt an install of the")
                         _T(" debuggers with\n the GUI and you will see the")
                         _T(" correct error message."),
                     pszTitle,
                     0);

          if ( !RunCommand( szPkgInstCommandNoQuiet, hInstance ) ) {
              MessageBox(NULL,
                         _T("There were still errors in the install.\n")
                             _T("Please see http://dbg/top10.html ")
                             _T("for more help."),
                         pszTitle,
                         0);
              return(1);
          }

      }
      return(0);
    } 

    //
    // Now, install the package dbg.msi
    //

    if ( !RunCommand( szPkgInstCommand, hInstance ) ) {
        if (ComArgs.QuietInstall) {
            _stprintf( szBuf, _T("%s %s %s %s"),
                   _T("There were errors in the Debugging Tools install."),
                   _T(" Please run "),
                   szPkgInstFile,
                   _T("to receive more detailed error information.")
                 );
            MessageBox( NULL, szBuf, pszTitle,0);
        }
        return(1);


    }
    
    return(0);
}


//
// RunCommand
//
// Purpose: Install MSI
//
// Return Values:
//    0  error
//    1  successful

BOOL 
RunCommand( PTCHAR szCommandLine,
            HINSTANCE  hInst)
{
BOOL rc;
DWORD dwRet;
PROCESS_INFORMATION ProcInfo = {0};
STARTUPINFO SI= {0};


// Spawn the command line specified by szCommandLine
rc = CreateProcess(NULL,            
                   szCommandLine,
                   NULL,
                   NULL,
                   FALSE,
                   CREATE_DEFAULT_ERROR_MODE | NORMAL_PRIORITY_CLASS, 
                   NULL,
                   NULL,
                   &SI,
                   &ProcInfo );

if ( (!rc) || (!ProcInfo.hProcess) ) {
        goto cleanup;
}

//
// Wait for command to complete ... Give it 20 minutes
//

dwRet = WaitForSingleObject(ProcInfo.hProcess, 1200000); 

if (dwRet != WAIT_OBJECT_0) {
    rc = FALSE;
    goto cleanup;

} 

// Get the process exit code

rc = GetExitCodeProcess( ProcInfo.hProcess, &dwRet); 

if (dwRet == ERROR_SUCCESS ) {
    rc = 1;
} else {
    rc = 0;
}

cleanup:

if (ProcInfo.hProcess)
    CloseHandle(ProcInfo.hProcess);            

return (rc);
}

BOOL
GetCommandLineArgs(
    LPTSTR szCmdLine, 
    PCOMMAND_ARGS pComArgs
) 
{

    ULONG  length;
    ULONG  i,cur;
    BOOL   SkippingSpaces=FALSE;
    BOOL   QuotedString=FALSE;
    BOOL   NeedSecond=FALSE;
    BOOL   rc=TRUE;
    LPTSTR *argv;
    ULONG  argc=0;
    LPTSTR szCmdLineTmp;
    TCHAR  c;

    ZeroMemory(pComArgs, sizeof(COMMAND_ARGS));


    // Create a line to use for temporary marking
    length=_tcslen(szCmdLine);

    szCmdLineTmp= (LPTSTR)malloc( (_tcslen(szCmdLine) + 1) * sizeof(TCHAR) );
    if (szCmdLineTmp==NULL) 
    {
        return FALSE;
    }
    _tcscpy(szCmdLineTmp, szCmdLine);

    // Count the number of arguments
    // Create a argv and argc

    SkippingSpaces=TRUE;
    QuotedString=FALSE;
    argc=0;
    for ( i=0; i<length; i++ ) 
    {
        c=szCmdLineTmp[i];
        switch (szCmdLineTmp[i]) {
        case _T(' '):
        case _T('\t'): if (QuotedString)
                       {
                           break;
                       } 
                       if (!SkippingSpaces)
                       {
                           SkippingSpaces=TRUE;
                       } 
                       break;

        case _T('\"'): if (QuotedString)
                       {
                           // This is the end of a quoted string
                           // The next character to read in is a space
                           QuotedString=FALSE;
                           SkippingSpaces=TRUE;
                           if ( i < (length-1) && 
                                szCmdLineTmp[i+1] != _T(' ') &&
                                szCmdLineTmp[i+1] != _T('\t') )
                           {
                               // This is the end of a quote and its not
                               // followed by a space
                               rc=FALSE;
                               goto CommandLineFinish;
                           }
                           break;
                       } 

                       if (SkippingSpaces) {

                           // This is the beginning of a quoted string
                           // Its a new argument and it follows spaces
                           argc++;
                           SkippingSpaces=FALSE;
                           QuotedString=TRUE;
                           break;
                       }

                       // This is an error -- This is a quote in the middle of a string
                       rc=FALSE;
                       goto CommandLineFinish;
                       break;

        default:       if (QuotedString) {
                           break;
                       } 
                       if (SkippingSpaces) {
                           argc++;
                           SkippingSpaces=FALSE;
                       }
                       break;
        }
    }

    if (QuotedString) 
    {
        // Make sure that all the quotes got a finished pair
        rc=FALSE;
        goto CommandLineFinish;
    }

    // Now, create argv with the correct number of entries
    
    argv=(LPTSTR*)malloc(argc * sizeof(LPTSTR) );
    if (argv==NULL)
    {
        free(szCmdLineTmp);
        return FALSE;
    }

    // Set argv to point to the correct place on szCmdLineTmp
    // and put '\0' after each token.

    SkippingSpaces=TRUE;
    QuotedString=FALSE;
    argc=0;
    for ( i=0; i<length; i++ ) 
    {
        c=szCmdLineTmp[i];
        switch (szCmdLineTmp[i]) {
        case _T(' '):
        case _T('\t'): if (QuotedString) 
                       {
                           break;
                       } 
                       if (!SkippingSpaces)
                       {
                           szCmdLineTmp[i]='\0';
                           SkippingSpaces=TRUE;
                       } 
                       break;
        
        case _T('\"'): if (QuotedString)
                       {
                           // This is the end of a quoted string
                           // The next character to read in is a space
                           QuotedString=FALSE;
                           SkippingSpaces=TRUE;
                           szCmdLineTmp[i+1]=_T('\0');
                           break;
                       } 

                       if (SkippingSpaces) {

                           // This is the beginning of a quoted string
                           // Its a new argument and it follows spaces

                           argv[argc]=szCmdLineTmp+i;
                           argc++;
                           SkippingSpaces=FALSE;
                           QuotedString=TRUE;
                           break;
                       }

                       // This is an error -- This is a quote in the middle of a string
                       rc=FALSE;
                       goto CommandLineFinish;
                       break;



        default:       if (QuotedString) 
                       {
                           break;
                       } 
                       if (SkippingSpaces) {
                           argv[argc]=szCmdLineTmp+i;
                           argc++;
                           SkippingSpaces=FALSE;
                       }
                       break;
        }
    }
   
    // Now, parse the arguments 

    NeedSecond=FALSE;

    for (i=0; i<argc; i++) {

      if (!NeedSecond) 
      {
          if ( (argv[i][0] != '/') && (argv[i][0] != '-') ) 
          {
              rc=FALSE;
              goto CommandLineFinish;
          }

          if ( _tcslen(argv[i]) != 2 )
          {
              rc=FALSE;
              goto CommandLineFinish;
          }
              
          c=argv[i][1];
          switch ( c ) 
          {
              case 'q':
              case 'Q': pComArgs->QuietInstall=TRUE;
                        break;
              case 'i':
              case 'I': NeedSecond=TRUE;;
                        break;
              case 'n':
              case 'N': NeedSecond=TRUE;
                        break;
              case 'z':
              case 'Z': pComArgs->StressInstall=TRUE;
                        break;
              case 'u':
              case 'U': pComArgs->UIStressInstall=TRUE;
                        pComArgs->StressInstall=TRUE;
                        break;
              default:  {
                            rc=FALSE;
                            goto CommandLineFinish;
                        }
          }

      } else {

           NeedSecond = FALSE;
           switch ( c ) 
           {
               case 'i':
               case 'I': _tcscpy(pComArgs->szInstDir,argv[i]);  
                         break;
               case 'n':
               case 'N': _tcscpy(pComArgs->szMsiName,argv[i]);
                         break;
               default:  {
                             rc=FALSE;
                             goto CommandLineFinish;
                         }
          }
      }

    }

    if (pComArgs->szMsiName[0] == 0) 
    {
#ifdef BUILD_X86
        _tcscpy(pComArgs->szMsiName, _T("dbg_x86.msi") );
        _tcscpy(pComArgs->szProductRegKey, _T("Software\\Microsoft\\DebuggingTools\\AddRemove") );
#elif defined(BUILD_IA64)
        _tcscpy(pComArgs->szMsiName, _T("dbg_ia64.msi") );
        _tcscpy(pComArgs->szProductRegKey, _T("Software\\Microsoft\\DebuggingTools64\\AddRemove") );
#elif defined(BUILD_AMD64)
        _tcscpy(pComArgs->szMsiName, _T("dbg_amd64.msi") );
        _tcscpy(pComArgs->szProductRegKey, _T("Software\\Microsoft\\DebuggingTools64\\AddRemove") );
#endif
    }

CommandLineFinish:

    free(szCmdLineTmp);
    free(argv);
    
    return (rc);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\sdsrv\inc\sdapi.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for sdapi.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __sdapi_h__
#define __sdapi_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __ISDVar_FWD_DEFINED__
#define __ISDVar_FWD_DEFINED__
typedef interface ISDVar ISDVar;
#endif 	/* __ISDVar_FWD_DEFINED__ */


#ifndef __ISDVars_FWD_DEFINED__
#define __ISDVars_FWD_DEFINED__
typedef interface ISDVars ISDVars;
#endif 	/* __ISDVars_FWD_DEFINED__ */


#ifndef __ISDVars2_FWD_DEFINED__
#define __ISDVars2_FWD_DEFINED__
typedef interface ISDVars2 ISDVars2;
#endif 	/* __ISDVars2_FWD_DEFINED__ */


#ifndef __ISDSpecForm_FWD_DEFINED__
#define __ISDSpecForm_FWD_DEFINED__
typedef interface ISDSpecForm ISDSpecForm;
#endif 	/* __ISDSpecForm_FWD_DEFINED__ */


#ifndef __ISDActionUser_FWD_DEFINED__
#define __ISDActionUser_FWD_DEFINED__
typedef interface ISDActionUser ISDActionUser;
#endif 	/* __ISDActionUser_FWD_DEFINED__ */


#ifndef __ISDInputUser_FWD_DEFINED__
#define __ISDInputUser_FWD_DEFINED__
typedef interface ISDInputUser ISDInputUser;
#endif 	/* __ISDInputUser_FWD_DEFINED__ */


#ifndef __ISDResolveUser_FWD_DEFINED__
#define __ISDResolveUser_FWD_DEFINED__
typedef interface ISDResolveUser ISDResolveUser;
#endif 	/* __ISDResolveUser_FWD_DEFINED__ */


#ifndef __ISDClientUser_FWD_DEFINED__
#define __ISDClientUser_FWD_DEFINED__
typedef interface ISDClientUser ISDClientUser;
#endif 	/* __ISDClientUser_FWD_DEFINED__ */


#ifndef __ISDClientApi_FWD_DEFINED__
#define __ISDClientApi_FWD_DEFINED__
typedef interface ISDClientApi ISDClientApi;
#endif 	/* __ISDClientApi_FWD_DEFINED__ */


#ifndef __ISDClientUtilities_FWD_DEFINED__
#define __ISDClientUtilities_FWD_DEFINED__
typedef interface ISDClientUtilities ISDClientUtilities;
#endif 	/* __ISDClientUtilities_FWD_DEFINED__ */


/* header files for imported files */
#include "unknwn.h"
#include "objidl.h"
#include "oaidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_sdapi_0000 */
/* [local] */ 

#ifndef DeclareInterfaceUtil
#define DeclareInterfaceUtil(iface)
#endif

#ifndef IMPL
#define IMPL
#endif

#undef SetPort // winspool.h defines this

#ifdef __cplusplus
    interface ISDVar;
    interface ISDVars;
    interface ISDVars2;
    interface ISDSpecForm;
    interface ISDActionUser;
    interface ISDInputUser;
    interface ISDResolveUser;
    interface ISDClientUser;
    interface ISDClientApi;
    interface ISDClientUtilities;
#else
    typedef interface ISDVar ISDVar;
    typedef interface ISDVars ISDVars;
    typedef interface ISDVars2 ISDVars2;
    typedef interface ISDSpecForm ISDSpecForm;
    typedef interface ISDActionUser ISDActionUser;
    typedef interface ISDInputUser ISDInputUser;
    typedef interface ISDResolveUser ISDResolveUser;
    typedef interface ISDClientUser ISDClientUser;
    typedef interface ISDClientApi ISDClientApi;
    typedef interface ISDClientUtilities ISDClientUtilities;
#endif

enum __MIDL___MIDL_itf_sdapi_0000_0001
    {	SDTT_NONTEXT	= 0,
	SDTT_TEXT	= SDTT_NONTEXT + 1,
	SDTT_UNICODE	= SDTT_TEXT + 1
    } ;


extern RPC_IF_HANDLE __MIDL_itf_sdapi_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0000_v0_0_s_ifspec;

#ifndef __ISDVar_INTERFACE_DEFINED__
#define __ISDVar_INTERFACE_DEFINED__

/* interface ISDVar */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ISDVar;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("054D6A99-6FD1-4AE5-AF57-D44A7C62ECE7")
    ISDVar : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetName( 
            /* [string][retval][out] */ const char **ppszVar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetByteString( 
            /* [string][retval][out] */ const char **ppszValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetByteCount( 
            /* [retval][out] */ ULONG *pcbValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsUnicode( 
            /* [retval][out] */ BOOL *pfUnicode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUnicodeString( 
            /* [string][retval][out] */ const WCHAR **ppwzValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVariant( 
            /* [out] */ VARIANT *pvarValue,
            /* [in] */ DWORD dwCodepage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISDVarVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISDVar * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISDVar * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISDVar * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetName )( 
            ISDVar * This,
            /* [string][retval][out] */ const char **ppszVar);
        
        HRESULT ( STDMETHODCALLTYPE *GetByteString )( 
            ISDVar * This,
            /* [string][retval][out] */ const char **ppszValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetByteCount )( 
            ISDVar * This,
            /* [retval][out] */ ULONG *pcbValue);
        
        HRESULT ( STDMETHODCALLTYPE *IsUnicode )( 
            ISDVar * This,
            /* [retval][out] */ BOOL *pfUnicode);
        
        HRESULT ( STDMETHODCALLTYPE *GetUnicodeString )( 
            ISDVar * This,
            /* [string][retval][out] */ const WCHAR **ppwzValue);
        
        HRESULT ( STDMETHODCALLTYPE *GetVariant )( 
            ISDVar * This,
            /* [out] */ VARIANT *pvarValue,
            /* [in] */ DWORD dwCodepage);
        
        END_INTERFACE
    } ISDVarVtbl;

    interface ISDVar
    {
        CONST_VTBL struct ISDVarVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISDVar_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISDVar_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISDVar_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISDVar_GetName(This,ppszVar)	\
    (This)->lpVtbl -> GetName(This,ppszVar)

#define ISDVar_GetByteString(This,ppszValue)	\
    (This)->lpVtbl -> GetByteString(This,ppszValue)

#define ISDVar_GetByteCount(This,pcbValue)	\
    (This)->lpVtbl -> GetByteCount(This,pcbValue)

#define ISDVar_IsUnicode(This,pfUnicode)	\
    (This)->lpVtbl -> IsUnicode(This,pfUnicode)

#define ISDVar_GetUnicodeString(This,ppwzValue)	\
    (This)->lpVtbl -> GetUnicodeString(This,ppwzValue)

#define ISDVar_GetVariant(This,pvarValue,dwCodepage)	\
    (This)->lpVtbl -> GetVariant(This,pvarValue,dwCodepage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISDVar_GetName_Proxy( 
    ISDVar * This,
    /* [string][retval][out] */ const char **ppszVar);


void __RPC_STUB ISDVar_GetName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVar_GetByteString_Proxy( 
    ISDVar * This,
    /* [string][retval][out] */ const char **ppszValue);


void __RPC_STUB ISDVar_GetByteString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVar_GetByteCount_Proxy( 
    ISDVar * This,
    /* [retval][out] */ ULONG *pcbValue);


void __RPC_STUB ISDVar_GetByteCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVar_IsUnicode_Proxy( 
    ISDVar * This,
    /* [retval][out] */ BOOL *pfUnicode);


void __RPC_STUB ISDVar_IsUnicode_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVar_GetUnicodeString_Proxy( 
    ISDVar * This,
    /* [string][retval][out] */ const WCHAR **ppwzValue);


void __RPC_STUB ISDVar_GetUnicodeString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVar_GetVariant_Proxy( 
    ISDVar * This,
    /* [out] */ VARIANT *pvarValue,
    /* [in] */ DWORD dwCodepage);


void __RPC_STUB ISDVar_GetVariant_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISDVar_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sdapi_0109 */
/* [local] */ 

#define DeclareISDVarMembers(IPURE) \
        STDMETHOD(GetName)(THIS_ const char** ppszVar) IPURE; \
        STDMETHOD(GetByteString)(THIS_ const char** ppszValue) IPURE; \
        STDMETHOD(GetByteCount)(THIS_ ULONG* pcbValue) IPURE; \
        STDMETHOD(IsUnicode)(THIS_ BOOL* pfUnicode) IPURE; \
        STDMETHOD(GetUnicodeString)(THIS_ const WCHAR** ppwzValue) IPURE; \
        STDMETHOD(GetVariant)(THIS_ VARIANT* pvarValue, DWORD dwCodepage) IPURE; \

DeclareInterfaceUtil(ISDVar)

#ifndef __building_SDAPI_DLL
// {054D6A99-6FD1-4AE5-AF57-D44A7C62ECE7}
DEFINE_GUID(IID_ISDVar, 0x54d6a99, 0x6fd1, 0x4ae5, 0xaf, 0x57, 0xd4, 0x4a, 0x7c, 0x62, 0xec, 0xe7);
#endif


extern RPC_IF_HANDLE __MIDL_itf_sdapi_0109_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0109_v0_0_s_ifspec;

#ifndef __ISDVars_INTERFACE_DEFINED__
#define __ISDVars_INTERFACE_DEFINED__

/* interface ISDVars */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ISDVars;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("44897D02-B326-43B9-803A-CE72B4FF7C26")
    ISDVars : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVar( 
            /* [string][in] */ const char *pszVar,
            /* [out] */ const char **ppszValue,
            /* [out] */ ULONG *pcbValue,
            /* [out] */ BOOL *pfIsUnicode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVarX( 
            /* [string][in] */ const char *pszVar,
            /* [in] */ int x,
            /* [out] */ const char **ppszValue,
            /* [out] */ ULONG *pcbValue,
            /* [out] */ BOOL *pfIsUnicode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVarXY( 
            /* [string][in] */ const char *pszVar,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [out] */ const char **ppszValue,
            /* [out] */ ULONG *pcbValue,
            /* [out] */ BOOL *pfIsUnicode) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVarByIndex( 
            /* [in] */ int i,
            /* [string][out] */ const char **ppszVar,
            /* [out] */ const char **ppszValue,
            /* [out] */ ULONG *pcbValue,
            /* [out] */ BOOL *pfIsUnicode) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISDVarsVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISDVars * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISDVars * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISDVars * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVar )( 
            ISDVars * This,
            /* [string][in] */ const char *pszVar,
            /* [out] */ const char **ppszValue,
            /* [out] */ ULONG *pcbValue,
            /* [out] */ BOOL *pfIsUnicode);
        
        HRESULT ( STDMETHODCALLTYPE *GetVarX )( 
            ISDVars * This,
            /* [string][in] */ const char *pszVar,
            /* [in] */ int x,
            /* [out] */ const char **ppszValue,
            /* [out] */ ULONG *pcbValue,
            /* [out] */ BOOL *pfIsUnicode);
        
        HRESULT ( STDMETHODCALLTYPE *GetVarXY )( 
            ISDVars * This,
            /* [string][in] */ const char *pszVar,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [out] */ const char **ppszValue,
            /* [out] */ ULONG *pcbValue,
            /* [out] */ BOOL *pfIsUnicode);
        
        HRESULT ( STDMETHODCALLTYPE *GetVarByIndex )( 
            ISDVars * This,
            /* [in] */ int i,
            /* [string][out] */ const char **ppszVar,
            /* [out] */ const char **ppszValue,
            /* [out] */ ULONG *pcbValue,
            /* [out] */ BOOL *pfIsUnicode);
        
        END_INTERFACE
    } ISDVarsVtbl;

    interface ISDVars
    {
        CONST_VTBL struct ISDVarsVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISDVars_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISDVars_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISDVars_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISDVars_GetVar(This,pszVar,ppszValue,pcbValue,pfIsUnicode)	\
    (This)->lpVtbl -> GetVar(This,pszVar,ppszValue,pcbValue,pfIsUnicode)

#define ISDVars_GetVarX(This,pszVar,x,ppszValue,pcbValue,pfIsUnicode)	\
    (This)->lpVtbl -> GetVarX(This,pszVar,x,ppszValue,pcbValue,pfIsUnicode)

#define ISDVars_GetVarXY(This,pszVar,x,y,ppszValue,pcbValue,pfIsUnicode)	\
    (This)->lpVtbl -> GetVarXY(This,pszVar,x,y,ppszValue,pcbValue,pfIsUnicode)

#define ISDVars_GetVarByIndex(This,i,ppszVar,ppszValue,pcbValue,pfIsUnicode)	\
    (This)->lpVtbl -> GetVarByIndex(This,i,ppszVar,ppszValue,pcbValue,pfIsUnicode)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISDVars_GetVar_Proxy( 
    ISDVars * This,
    /* [string][in] */ const char *pszVar,
    /* [out] */ const char **ppszValue,
    /* [out] */ ULONG *pcbValue,
    /* [out] */ BOOL *pfIsUnicode);


void __RPC_STUB ISDVars_GetVar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVars_GetVarX_Proxy( 
    ISDVars * This,
    /* [string][in] */ const char *pszVar,
    /* [in] */ int x,
    /* [out] */ const char **ppszValue,
    /* [out] */ ULONG *pcbValue,
    /* [out] */ BOOL *pfIsUnicode);


void __RPC_STUB ISDVars_GetVarX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVars_GetVarXY_Proxy( 
    ISDVars * This,
    /* [string][in] */ const char *pszVar,
    /* [in] */ int x,
    /* [in] */ int y,
    /* [out] */ const char **ppszValue,
    /* [out] */ ULONG *pcbValue,
    /* [out] */ BOOL *pfIsUnicode);


void __RPC_STUB ISDVars_GetVarXY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVars_GetVarByIndex_Proxy( 
    ISDVars * This,
    /* [in] */ int i,
    /* [string][out] */ const char **ppszVar,
    /* [out] */ const char **ppszValue,
    /* [out] */ ULONG *pcbValue,
    /* [out] */ BOOL *pfIsUnicode);


void __RPC_STUB ISDVars_GetVarByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISDVars_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sdapi_0112 */
/* [local] */ 

#define DeclareISDVarsMembers(IPURE) \
        STDMETHOD(GetVar)(THIS_ const char* pszVar, const char** ppszValue, ULONG* pcbValue, BOOL* pfIsUnicode) IPURE; \
        STDMETHOD(GetVarX)(THIS_ const char* pszVar, int x, const char** ppszValue, ULONG* pcbValue, BOOL* pfIsUnicode) IPURE; \
        STDMETHOD(GetVarXY)(THIS_ const char* pszVar, int x, int y, const char** ppszValue, ULONG* pcbValue, BOOL* pfIsUnicode) IPURE; \
        STDMETHOD(GetVarByIndex)(THIS_ int i, const char** ppszVar, const char** ppszValue, ULONG* pcbValue, BOOL* pfIsUnicode) IPURE; \

DeclareInterfaceUtil(ISDVars)

#ifndef __building_SDAPI_DLL
// {44897D02-B326-43B9-803A-CE72B4FF7C26}
DEFINE_GUID(IID_ISDVars, 0x44897d02, 0xb326, 0x43b9, 0x80, 0x3a, 0xce, 0x72, 0xb4, 0xff, 0x7c, 0x26);
#endif


extern RPC_IF_HANDLE __MIDL_itf_sdapi_0112_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0112_v0_0_s_ifspec;

#ifndef __ISDVars2_INTERFACE_DEFINED__
#define __ISDVars2_INTERFACE_DEFINED__

/* interface ISDVars2 */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ISDVars2;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("8E6B2697-EB34-4D23-8144-5844B0B5DBE3")
    ISDVars2 : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetVar( 
            /* [string][in] */ const char *pszVar,
            /* [retval][out] */ ISDVar **ppVar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVarX( 
            /* [string][in] */ const char *pszVar,
            /* [in] */ int x,
            /* [retval][out] */ ISDVar **ppVar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVarXY( 
            /* [string][in] */ const char *pszVar,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [retval][out] */ ISDVar **ppVar) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVarByIndex( 
            /* [in] */ int i,
            /* [retval][out] */ ISDVar **ppVar) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISDVars2Vtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISDVars2 * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISDVars2 * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISDVars2 * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetVar )( 
            ISDVars2 * This,
            /* [string][in] */ const char *pszVar,
            /* [retval][out] */ ISDVar **ppVar);
        
        HRESULT ( STDMETHODCALLTYPE *GetVarX )( 
            ISDVars2 * This,
            /* [string][in] */ const char *pszVar,
            /* [in] */ int x,
            /* [retval][out] */ ISDVar **ppVar);
        
        HRESULT ( STDMETHODCALLTYPE *GetVarXY )( 
            ISDVars2 * This,
            /* [string][in] */ const char *pszVar,
            /* [in] */ int x,
            /* [in] */ int y,
            /* [retval][out] */ ISDVar **ppVar);
        
        HRESULT ( STDMETHODCALLTYPE *GetVarByIndex )( 
            ISDVars2 * This,
            /* [in] */ int i,
            /* [retval][out] */ ISDVar **ppVar);
        
        END_INTERFACE
    } ISDVars2Vtbl;

    interface ISDVars2
    {
        CONST_VTBL struct ISDVars2Vtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISDVars2_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISDVars2_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISDVars2_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISDVars2_GetVar(This,pszVar,ppVar)	\
    (This)->lpVtbl -> GetVar(This,pszVar,ppVar)

#define ISDVars2_GetVarX(This,pszVar,x,ppVar)	\
    (This)->lpVtbl -> GetVarX(This,pszVar,x,ppVar)

#define ISDVars2_GetVarXY(This,pszVar,x,y,ppVar)	\
    (This)->lpVtbl -> GetVarXY(This,pszVar,x,y,ppVar)

#define ISDVars2_GetVarByIndex(This,i,ppVar)	\
    (This)->lpVtbl -> GetVarByIndex(This,i,ppVar)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISDVars2_GetVar_Proxy( 
    ISDVars2 * This,
    /* [string][in] */ const char *pszVar,
    /* [retval][out] */ ISDVar **ppVar);


void __RPC_STUB ISDVars2_GetVar_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVars2_GetVarX_Proxy( 
    ISDVars2 * This,
    /* [string][in] */ const char *pszVar,
    /* [in] */ int x,
    /* [retval][out] */ ISDVar **ppVar);


void __RPC_STUB ISDVars2_GetVarX_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVars2_GetVarXY_Proxy( 
    ISDVars2 * This,
    /* [string][in] */ const char *pszVar,
    /* [in] */ int x,
    /* [in] */ int y,
    /* [retval][out] */ ISDVar **ppVar);


void __RPC_STUB ISDVars2_GetVarXY_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDVars2_GetVarByIndex_Proxy( 
    ISDVars2 * This,
    /* [in] */ int i,
    /* [retval][out] */ ISDVar **ppVar);


void __RPC_STUB ISDVars2_GetVarByIndex_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISDVars2_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sdapi_0115 */
/* [local] */ 

#define DeclareISDVars2Members(IPURE) \
        STDMETHOD(GetVar)(THIS_ const char* pszVar, ISDVar** ppVar) IPURE; \
        STDMETHOD(GetVarX)(THIS_ const char* pszVar, int x, ISDVar** ppVar) IPURE; \
        STDMETHOD(GetVarXY)(THIS_ const char* pszVar, int x, int y, ISDVar** ppVar) IPURE; \
        STDMETHOD(GetVarByIndex)(THIS_ int i, ISDVar** ppVar) IPURE; \

DeclareInterfaceUtil(ISDVars2)

#ifndef __building_SDAPI_DLL
// {8E6B2697-EB34-4D23-8144-5844B0B5DBE3}
DEFINE_GUID(IID_ISDVars2, 0x8e6b2697, 0xeb34, 0x4d23, 0x81, 0x44, 0x58, 0x44, 0xb0, 0xb5, 0xdb, 0xe3);
#endif


extern RPC_IF_HANDLE __MIDL_itf_sdapi_0115_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0115_v0_0_s_ifspec;

#ifndef __ISDSpecForm_INTERFACE_DEFINED__
#define __ISDSpecForm_INTERFACE_DEFINED__

/* interface ISDSpecForm */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ISDSpecForm;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F01E61AE-FB1B-461C-A020-EB50412F1CC2")
    ISDSpecForm : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE GetSchema( 
            /* [retval][out] */ ISDVars **ppVars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ParseSpec( 
            /* [in] */ VARIANT *pvarSpec) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE FormatSpec( 
            /* [out] */ VARIANT *pvarSpec) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetValue( 
            /* [string][in] */ const char *pszName,
            /* [out] */ VARIANT *pvarValue) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetValue( 
            /* [string][in] */ const char *pszName,
            /* [in] */ VARIANT *pvarValue) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISDSpecFormVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISDSpecForm * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISDSpecForm * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISDSpecForm * This);
        
        HRESULT ( STDMETHODCALLTYPE *GetSchema )( 
            ISDSpecForm * This,
            /* [retval][out] */ ISDVars **ppVars);
        
        HRESULT ( STDMETHODCALLTYPE *ParseSpec )( 
            ISDSpecForm * This,
            /* [in] */ VARIANT *pvarSpec);
        
        HRESULT ( STDMETHODCALLTYPE *FormatSpec )( 
            ISDSpecForm * This,
            /* [out] */ VARIANT *pvarSpec);
        
        HRESULT ( STDMETHODCALLTYPE *GetValue )( 
            ISDSpecForm * This,
            /* [string][in] */ const char *pszName,
            /* [out] */ VARIANT *pvarValue);
        
        HRESULT ( STDMETHODCALLTYPE *SetValue )( 
            ISDSpecForm * This,
            /* [string][in] */ const char *pszName,
            /* [in] */ VARIANT *pvarValue);
        
        END_INTERFACE
    } ISDSpecFormVtbl;

    interface ISDSpecForm
    {
        CONST_VTBL struct ISDSpecFormVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISDSpecForm_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISDSpecForm_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISDSpecForm_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISDSpecForm_GetSchema(This,ppVars)	\
    (This)->lpVtbl -> GetSchema(This,ppVars)

#define ISDSpecForm_ParseSpec(This,pvarSpec)	\
    (This)->lpVtbl -> ParseSpec(This,pvarSpec)

#define ISDSpecForm_FormatSpec(This,pvarSpec)	\
    (This)->lpVtbl -> FormatSpec(This,pvarSpec)

#define ISDSpecForm_GetValue(This,pszName,pvarValue)	\
    (This)->lpVtbl -> GetValue(This,pszName,pvarValue)

#define ISDSpecForm_SetValue(This,pszName,pvarValue)	\
    (This)->lpVtbl -> SetValue(This,pszName,pvarValue)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISDSpecForm_GetSchema_Proxy( 
    ISDSpecForm * This,
    /* [retval][out] */ ISDVars **ppVars);


void __RPC_STUB ISDSpecForm_GetSchema_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDSpecForm_ParseSpec_Proxy( 
    ISDSpecForm * This,
    /* [in] */ VARIANT *pvarSpec);


void __RPC_STUB ISDSpecForm_ParseSpec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDSpecForm_FormatSpec_Proxy( 
    ISDSpecForm * This,
    /* [out] */ VARIANT *pvarSpec);


void __RPC_STUB ISDSpecForm_FormatSpec_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDSpecForm_GetValue_Proxy( 
    ISDSpecForm * This,
    /* [string][in] */ const char *pszName,
    /* [out] */ VARIANT *pvarValue);


void __RPC_STUB ISDSpecForm_GetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDSpecForm_SetValue_Proxy( 
    ISDSpecForm * This,
    /* [string][in] */ const char *pszName,
    /* [in] */ VARIANT *pvarValue);


void __RPC_STUB ISDSpecForm_SetValue_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISDSpecForm_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sdapi_0118 */
/* [local] */ 

#define DeclareISDSpecFormMembers(IPURE) \
        STDMETHOD(GetSchema)(THIS_ ISDVars** ppVars) IPURE; \
        STDMETHOD(ParseSpec)(THIS_ VARIANT* pvarSpec) IPURE; \
        STDMETHOD(FormatSpec)(THIS_ VARIANT* pvarSpec) IPURE; \
        STDMETHOD(GetValue)(THIS_ const char* pszName, VARIANT* pvarValue) IPURE; \
        STDMETHOD(SetValue)(THIS_ const char* pszName, VARIANT* pvarValue) IPURE; \

DeclareInterfaceUtil(ISDSpecForm)

#ifndef __building_SDAPI_DLL
// {F01E61AE-FB1B-461C-A020-EB50412F1CC2}
DEFINE_GUID(IID_ISDSpecForm, 0xf01e61ae, 0xfb1b, 0x461c, 0xa0, 0x20, 0xeb, 0x50, 0x41, 0x2f, 0x1c, 0xc2);
#endif


extern RPC_IF_HANDLE __MIDL_itf_sdapi_0118_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0118_v0_0_s_ifspec;

#ifndef __ISDActionUser_INTERFACE_DEFINED__
#define __ISDActionUser_INTERFACE_DEFINED__

/* interface ISDActionUser */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ISDActionUser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("21D212A9-C2B9-4441-B9A3-DFBA59821BCC")
    ISDActionUser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Diff( 
            /* [string][in] */ const char *pszDiffCmd,
            /* [string][in] */ const char *pszLeft,
            /* [string][in] */ const char *pszRight,
            /* [in] */ DWORD eTextual,
            /* [string][in] */ const char *pszFlags,
            /* [string][in] */ const char *pszPaginateCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EditForm( 
            /* [string][in] */ const char *pszEditCmd,
            /* [string][in] */ const char *pszFile) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE EditFile( 
            /* [string][in] */ const char *pszEditCmd,
            /* [string][in] */ const char *pszFile,
            /* [in] */ DWORD eTextual) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Merge( 
            /* [string][in] */ const char *pszMergeCmd,
            /* [string][in] */ const char *pszBase,
            /* [string][in] */ const char *pszTheirs,
            /* [string][in] */ const char *pszYours,
            /* [string][in] */ const char *pszResult,
            /* [in] */ DWORD eTextual) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISDActionUserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISDActionUser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISDActionUser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISDActionUser * This);
        
        HRESULT ( STDMETHODCALLTYPE *Diff )( 
            ISDActionUser * This,
            /* [string][in] */ const char *pszDiffCmd,
            /* [string][in] */ const char *pszLeft,
            /* [string][in] */ const char *pszRight,
            /* [in] */ DWORD eTextual,
            /* [string][in] */ const char *pszFlags,
            /* [string][in] */ const char *pszPaginateCmd);
        
        HRESULT ( STDMETHODCALLTYPE *EditForm )( 
            ISDActionUser * This,
            /* [string][in] */ const char *pszEditCmd,
            /* [string][in] */ const char *pszFile);
        
        HRESULT ( STDMETHODCALLTYPE *EditFile )( 
            ISDActionUser * This,
            /* [string][in] */ const char *pszEditCmd,
            /* [string][in] */ const char *pszFile,
            /* [in] */ DWORD eTextual);
        
        HRESULT ( STDMETHODCALLTYPE *Merge )( 
            ISDActionUser * This,
            /* [string][in] */ const char *pszMergeCmd,
            /* [string][in] */ const char *pszBase,
            /* [string][in] */ const char *pszTheirs,
            /* [string][in] */ const char *pszYours,
            /* [string][in] */ const char *pszResult,
            /* [in] */ DWORD eTextual);
        
        END_INTERFACE
    } ISDActionUserVtbl;

    interface ISDActionUser
    {
        CONST_VTBL struct ISDActionUserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISDActionUser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISDActionUser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISDActionUser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISDActionUser_Diff(This,pszDiffCmd,pszLeft,pszRight,eTextual,pszFlags,pszPaginateCmd)	\
    (This)->lpVtbl -> Diff(This,pszDiffCmd,pszLeft,pszRight,eTextual,pszFlags,pszPaginateCmd)

#define ISDActionUser_EditForm(This,pszEditCmd,pszFile)	\
    (This)->lpVtbl -> EditForm(This,pszEditCmd,pszFile)

#define ISDActionUser_EditFile(This,pszEditCmd,pszFile,eTextual)	\
    (This)->lpVtbl -> EditFile(This,pszEditCmd,pszFile,eTextual)

#define ISDActionUser_Merge(This,pszMergeCmd,pszBase,pszTheirs,pszYours,pszResult,eTextual)	\
    (This)->lpVtbl -> Merge(This,pszMergeCmd,pszBase,pszTheirs,pszYours,pszResult,eTextual)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISDActionUser_Diff_Proxy( 
    ISDActionUser * This,
    /* [string][in] */ const char *pszDiffCmd,
    /* [string][in] */ const char *pszLeft,
    /* [string][in] */ const char *pszRight,
    /* [in] */ DWORD eTextual,
    /* [string][in] */ const char *pszFlags,
    /* [string][in] */ const char *pszPaginateCmd);


void __RPC_STUB ISDActionUser_Diff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDActionUser_EditForm_Proxy( 
    ISDActionUser * This,
    /* [string][in] */ const char *pszEditCmd,
    /* [string][in] */ const char *pszFile);


void __RPC_STUB ISDActionUser_EditForm_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDActionUser_EditFile_Proxy( 
    ISDActionUser * This,
    /* [string][in] */ const char *pszEditCmd,
    /* [string][in] */ const char *pszFile,
    /* [in] */ DWORD eTextual);


void __RPC_STUB ISDActionUser_EditFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDActionUser_Merge_Proxy( 
    ISDActionUser * This,
    /* [string][in] */ const char *pszMergeCmd,
    /* [string][in] */ const char *pszBase,
    /* [string][in] */ const char *pszTheirs,
    /* [string][in] */ const char *pszYours,
    /* [string][in] */ const char *pszResult,
    /* [in] */ DWORD eTextual);


void __RPC_STUB ISDActionUser_Merge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISDActionUser_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sdapi_0121 */
/* [local] */ 

#define DeclareISDActionUserMembers(IPURE) \
        STDMETHOD(Diff)(THIS_ const char* pszDiffCmd, const char* pszLeft, const char* pszRight, DWORD eTextual, const char* pszFlags, const char* pszPaginateCmd) IPURE; \
        STDMETHOD(EditForm)(THIS_ const char* pszEditCmd, const char* pszFile) IPURE; \
        STDMETHOD(EditFile)(THIS_ const char* pszEditCmd, const char* pszFile, DWORD eTextual) IPURE; \
        STDMETHOD(Merge)(THIS_ const char* pszMergeCmd, const char* pszBase, const char* pszTheirs, const char* pszYours, const char* pszResult, DWORD eTextual) IPURE; \

DeclareInterfaceUtil(ISDActionUser)

#ifndef __building_SDAPI_DLL
// {21D212A9-C2B9-4441-B9A3-DFBA59821BCC}
DEFINE_GUID(IID_ISDActionUser, 0x21d212a9, 0xc2b9, 0x4441, 0xb9, 0xa3, 0xdf, 0xba, 0x59, 0x82, 0x1b, 0xcc);
#endif


extern RPC_IF_HANDLE __MIDL_itf_sdapi_0121_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0121_v0_0_s_ifspec;

#ifndef __ISDInputUser_INTERFACE_DEFINED__
#define __ISDInputUser_INTERFACE_DEFINED__

/* interface ISDInputUser */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ISDInputUser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3696BCC4-FDEB-49F9-9CED-12F4338C2669")
    ISDInputUser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE InputData( 
            /* [out][in] */ VARIANT *pvarInput) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Prompt( 
            /* [string][in] */ const char *pszPrompt,
            /* [out][in] */ VARIANT *pvarResponse,
            /* [in] */ BOOL fPassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE PromptYesNo( 
            /* [string][in] */ const char *pszPrompt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE ErrorPause( 
            /* [string][in] */ const char *pszError) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISDInputUserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISDInputUser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISDInputUser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISDInputUser * This);
        
        HRESULT ( STDMETHODCALLTYPE *InputData )( 
            ISDInputUser * This,
            /* [out][in] */ VARIANT *pvarInput);
        
        HRESULT ( STDMETHODCALLTYPE *Prompt )( 
            ISDInputUser * This,
            /* [string][in] */ const char *pszPrompt,
            /* [out][in] */ VARIANT *pvarResponse,
            /* [in] */ BOOL fPassword);
        
        HRESULT ( STDMETHODCALLTYPE *PromptYesNo )( 
            ISDInputUser * This,
            /* [string][in] */ const char *pszPrompt);
        
        HRESULT ( STDMETHODCALLTYPE *ErrorPause )( 
            ISDInputUser * This,
            /* [string][in] */ const char *pszError);
        
        END_INTERFACE
    } ISDInputUserVtbl;

    interface ISDInputUser
    {
        CONST_VTBL struct ISDInputUserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISDInputUser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISDInputUser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISDInputUser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISDInputUser_InputData(This,pvarInput)	\
    (This)->lpVtbl -> InputData(This,pvarInput)

#define ISDInputUser_Prompt(This,pszPrompt,pvarResponse,fPassword)	\
    (This)->lpVtbl -> Prompt(This,pszPrompt,pvarResponse,fPassword)

#define ISDInputUser_PromptYesNo(This,pszPrompt)	\
    (This)->lpVtbl -> PromptYesNo(This,pszPrompt)

#define ISDInputUser_ErrorPause(This,pszError)	\
    (This)->lpVtbl -> ErrorPause(This,pszError)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISDInputUser_InputData_Proxy( 
    ISDInputUser * This,
    /* [out][in] */ VARIANT *pvarInput);


void __RPC_STUB ISDInputUser_InputData_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDInputUser_Prompt_Proxy( 
    ISDInputUser * This,
    /* [string][in] */ const char *pszPrompt,
    /* [out][in] */ VARIANT *pvarResponse,
    /* [in] */ BOOL fPassword);


void __RPC_STUB ISDInputUser_Prompt_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDInputUser_PromptYesNo_Proxy( 
    ISDInputUser * This,
    /* [string][in] */ const char *pszPrompt);


void __RPC_STUB ISDInputUser_PromptYesNo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDInputUser_ErrorPause_Proxy( 
    ISDInputUser * This,
    /* [string][in] */ const char *pszError);


void __RPC_STUB ISDInputUser_ErrorPause_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISDInputUser_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sdapi_0124 */
/* [local] */ 

#define DeclareISDInputUserMembers(IPURE) \
        STDMETHOD(InputData)(THIS_ VARIANT* pvarInput) IPURE; \
        STDMETHOD(Prompt)(THIS_ const char* pszPrompt, VARIANT* pvarResponse, BOOL fPassword) IPURE; \
        STDMETHOD(PromptYesNo)(THIS_ const char* pszPrompt) IPURE; \
        STDMETHOD(ErrorPause)(THIS_ const char* pszError) IPURE; \

DeclareInterfaceUtil(ISDInputUser)

#ifndef __building_SDAPI_DLL
// {3696BCC4-FDEB-49F9-9CED-12F4338C2669}
DEFINE_GUID(IID_ISDInputUser, 0x3696bcc4, 0xfdeb, 0x49f9, 0x9c, 0xed, 0x12, 0xf4, 0x33, 0x8c, 0x26, 0x69);
#endif


extern RPC_IF_HANDLE __MIDL_itf_sdapi_0124_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0124_v0_0_s_ifspec;

#ifndef __ISDResolveUser_INTERFACE_DEFINED__
#define __ISDResolveUser_INTERFACE_DEFINED__

/* interface ISDResolveUser */
/* [local][unique][uuid][object] */ 


enum __MIDL_ISDResolveUser_0001
    {	MH_SKIP	= 0,
	MH_ACCEPTTHEIRFILE	= MH_SKIP + 1,
	MH_ACCEPTYOURFILE	= MH_ACCEPTTHEIRFILE + 1,
	MH_ACCEPTMERGEDFILE	= MH_ACCEPTYOURFILE + 1
    } ;

EXTERN_C const IID IID_ISDResolveUser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("F0051E40-DB07-4D12-92B5-832C55947039")
    ISDResolveUser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE AutoResolve( 
            /* [in] */ ISDVars *pVars,
            /* [out][in] */ DWORD *pdwMergeHint) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resolve( 
            /* [in] */ ISDVars *pVars,
            /* [out][in] */ DWORD *pdwMergeHint,
            /* [string][in] */ const char *pszDiffFlags) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISDResolveUserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISDResolveUser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISDResolveUser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISDResolveUser * This);
        
        HRESULT ( STDMETHODCALLTYPE *AutoResolve )( 
            ISDResolveUser * This,
            /* [in] */ ISDVars *pVars,
            /* [out][in] */ DWORD *pdwMergeHint);
        
        HRESULT ( STDMETHODCALLTYPE *Resolve )( 
            ISDResolveUser * This,
            /* [in] */ ISDVars *pVars,
            /* [out][in] */ DWORD *pdwMergeHint,
            /* [string][in] */ const char *pszDiffFlags);
        
        END_INTERFACE
    } ISDResolveUserVtbl;

    interface ISDResolveUser
    {
        CONST_VTBL struct ISDResolveUserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISDResolveUser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISDResolveUser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISDResolveUser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISDResolveUser_AutoResolve(This,pVars,pdwMergeHint)	\
    (This)->lpVtbl -> AutoResolve(This,pVars,pdwMergeHint)

#define ISDResolveUser_Resolve(This,pVars,pdwMergeHint,pszDiffFlags)	\
    (This)->lpVtbl -> Resolve(This,pVars,pdwMergeHint,pszDiffFlags)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISDResolveUser_AutoResolve_Proxy( 
    ISDResolveUser * This,
    /* [in] */ ISDVars *pVars,
    /* [out][in] */ DWORD *pdwMergeHint);


void __RPC_STUB ISDResolveUser_AutoResolve_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDResolveUser_Resolve_Proxy( 
    ISDResolveUser * This,
    /* [in] */ ISDVars *pVars,
    /* [out][in] */ DWORD *pdwMergeHint,
    /* [string][in] */ const char *pszDiffFlags);


void __RPC_STUB ISDResolveUser_Resolve_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISDResolveUser_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sdapi_0127 */
/* [local] */ 

#define DeclareISDResolveUserMembers(IPURE) \
        STDMETHOD(AutoResolve)(THIS_ ISDVars* pVars, DWORD* pdwMergeHint) IPURE; \
        STDMETHOD(Resolve)(THIS_ ISDVars* pVars, DWORD* pdwMergeHint, const char* pszDiffFlags) IPURE; \

DeclareInterfaceUtil(ISDResolveUser)

#ifndef __building_SDAPI_DLL
// {F0051E40-DB07-4D12-92B5-832C55947039}
DEFINE_GUID(IID_ISDResolveUser, 0xf0051e40, 0xdb07, 0x4d12, 0x92, 0xb5, 0x83, 0x2c, 0x55, 0x94, 0x70, 0x39);
#endif


extern RPC_IF_HANDLE __MIDL_itf_sdapi_0127_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0127_v0_0_s_ifspec;

#ifndef __ISDClientUser_INTERFACE_DEFINED__
#define __ISDClientUser_INTERFACE_DEFINED__

/* interface ISDClientUser */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ISDClientUser;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("1D0087D5-C8EB-42A0-AFC8-DFA8B453A9B9")
    ISDClientUser : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE OutputText( 
            /* [size_is][string][in] */ const char *pszText,
            /* [in] */ int cchText) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OutputBinary( 
            /* [size_is][string][in] */ const unsigned char *pbData,
            /* [in] */ int cbData) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OutputInfo( 
            /* [in] */ int cIndent,
            /* [string][in] */ const char *pszInfo) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OutputWarning( 
            /* [in] */ int cIndent,
            /* [string][in] */ const char *pszWarning,
            /* [in] */ BOOL fEmptyReason) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OutputError( 
            /* [string][in] */ const char *pszError) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE OutputStructured( 
            /* [in] */ ISDVars *pVars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Finished( void) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISDClientUserVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISDClientUser * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISDClientUser * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISDClientUser * This);
        
        HRESULT ( STDMETHODCALLTYPE *OutputText )( 
            ISDClientUser * This,
            /* [size_is][string][in] */ const char *pszText,
            /* [in] */ int cchText);
        
        HRESULT ( STDMETHODCALLTYPE *OutputBinary )( 
            ISDClientUser * This,
            /* [size_is][string][in] */ const unsigned char *pbData,
            /* [in] */ int cbData);
        
        HRESULT ( STDMETHODCALLTYPE *OutputInfo )( 
            ISDClientUser * This,
            /* [in] */ int cIndent,
            /* [string][in] */ const char *pszInfo);
        
        HRESULT ( STDMETHODCALLTYPE *OutputWarning )( 
            ISDClientUser * This,
            /* [in] */ int cIndent,
            /* [string][in] */ const char *pszWarning,
            /* [in] */ BOOL fEmptyReason);
        
        HRESULT ( STDMETHODCALLTYPE *OutputError )( 
            ISDClientUser * This,
            /* [string][in] */ const char *pszError);
        
        HRESULT ( STDMETHODCALLTYPE *OutputStructured )( 
            ISDClientUser * This,
            /* [in] */ ISDVars *pVars);
        
        HRESULT ( STDMETHODCALLTYPE *Finished )( 
            ISDClientUser * This);
        
        END_INTERFACE
    } ISDClientUserVtbl;

    interface ISDClientUser
    {
        CONST_VTBL struct ISDClientUserVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISDClientUser_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISDClientUser_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISDClientUser_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISDClientUser_OutputText(This,pszText,cchText)	\
    (This)->lpVtbl -> OutputText(This,pszText,cchText)

#define ISDClientUser_OutputBinary(This,pbData,cbData)	\
    (This)->lpVtbl -> OutputBinary(This,pbData,cbData)

#define ISDClientUser_OutputInfo(This,cIndent,pszInfo)	\
    (This)->lpVtbl -> OutputInfo(This,cIndent,pszInfo)

#define ISDClientUser_OutputWarning(This,cIndent,pszWarning,fEmptyReason)	\
    (This)->lpVtbl -> OutputWarning(This,cIndent,pszWarning,fEmptyReason)

#define ISDClientUser_OutputError(This,pszError)	\
    (This)->lpVtbl -> OutputError(This,pszError)

#define ISDClientUser_OutputStructured(This,pVars)	\
    (This)->lpVtbl -> OutputStructured(This,pVars)

#define ISDClientUser_Finished(This)	\
    (This)->lpVtbl -> Finished(This)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISDClientUser_OutputText_Proxy( 
    ISDClientUser * This,
    /* [size_is][string][in] */ const char *pszText,
    /* [in] */ int cchText);


void __RPC_STUB ISDClientUser_OutputText_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUser_OutputBinary_Proxy( 
    ISDClientUser * This,
    /* [size_is][string][in] */ const unsigned char *pbData,
    /* [in] */ int cbData);


void __RPC_STUB ISDClientUser_OutputBinary_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUser_OutputInfo_Proxy( 
    ISDClientUser * This,
    /* [in] */ int cIndent,
    /* [string][in] */ const char *pszInfo);


void __RPC_STUB ISDClientUser_OutputInfo_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUser_OutputWarning_Proxy( 
    ISDClientUser * This,
    /* [in] */ int cIndent,
    /* [string][in] */ const char *pszWarning,
    /* [in] */ BOOL fEmptyReason);


void __RPC_STUB ISDClientUser_OutputWarning_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUser_OutputError_Proxy( 
    ISDClientUser * This,
    /* [string][in] */ const char *pszError);


void __RPC_STUB ISDClientUser_OutputError_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUser_OutputStructured_Proxy( 
    ISDClientUser * This,
    /* [in] */ ISDVars *pVars);


void __RPC_STUB ISDClientUser_OutputStructured_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUser_Finished_Proxy( 
    ISDClientUser * This);


void __RPC_STUB ISDClientUser_Finished_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISDClientUser_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sdapi_0130 */
/* [local] */ 

#define DeclareISDClientUserMembers(IPURE) \
        STDMETHOD(OutputText)(THIS_ const char* pszText, int cchText) IPURE; \
        STDMETHOD(OutputBinary)(THIS_ const unsigned char* pbData, int cbData) IPURE; \
        STDMETHOD(OutputInfo)(THIS_ int cIndent, const char* pszInfo) IPURE; \
        STDMETHOD(OutputWarning)(THIS_ int cIndent, const char* pszWarning, BOOL fEmptyReason) IPURE; \
        STDMETHOD(OutputError)(THIS_ const char* pszError) IPURE; \
        STDMETHOD(OutputStructured)(THIS_ ISDVars* pVars) IPURE; \
        STDMETHOD(Finished)(THIS) IPURE; \

DeclareInterfaceUtil(ISDClientUser)

#ifndef __building_SDAPI_DLL
// {1D0087D5-C8EB-42A0-AFC8-DFA8B453A9B9}
DEFINE_GUID(IID_ISDClientUser, 0x1D0087D5, 0xc8eb, 0x42a0, 0xaf, 0xc8, 0xdf, 0xa8, 0xb4, 0x53, 0xa9, 0xb9);
#endif
typedef struct _SDVERINFO
    {
    DWORD dwSize;
    DWORD nApiMajor;
    DWORD nApiMinor;
    DWORD nApiBuild;
    DWORD nApiDot;
    DWORD nSrvMajor;
    DWORD nSrvMinor;
    DWORD nSrvBuild;
    DWORD nSrvDot;
    } 	SDVERINFO;



extern RPC_IF_HANDLE __MIDL_itf_sdapi_0130_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0130_v0_0_s_ifspec;

#ifndef __ISDClientApi_INTERFACE_DEFINED__
#define __ISDClientApi_INTERFACE_DEFINED__

/* interface ISDClientApi */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ISDClientApi;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("A81BB025-1174-4BC7-930E-C3158CF87237")
    ISDClientApi : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Init( 
            /* [in] */ ISDClientUser *pUI) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetVersion( 
            /* [out] */ SDVERINFO *pver) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetArg( 
            /* [string][in] */ const char *pszArg) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetArgv( 
            /* [in] */ int cArgs,
            /* [size_is][string][in] */ const char **ppArgv) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Run( 
            /* [string][in] */ const char *pszFunc,
            /* [in] */ ISDClientUser *pUI,
            /* [in] */ BOOL fStructured) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Final( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE IsDropped( 
            /* [retval][out] */ BOOL *pfDropped) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetErrorString( 
            /* [string][retval][out] */ const char **ppsz) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPort( 
            /* [string][in] */ const char *pszPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetUser( 
            /* [string][in] */ const char *pszUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetPassword( 
            /* [string][in] */ const char *pszPassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetClient( 
            /* [string][in] */ const char *pszClient) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetHost( 
            /* [string][in] */ const char *pszHost) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE SetAuth( 
            /* [string][in] */ const char *pszAuth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefinePort( 
            /* [string][in] */ const char *pszPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineUser( 
            /* [string][in] */ const char *pszUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefinePassword( 
            /* [string][in] */ const char *pszPassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineClient( 
            /* [string][in] */ const char *pszClient) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineHost( 
            /* [string][in] */ const char *pszHost) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DefineAuth( 
            /* [string][in] */ const char *pszAuth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPort( 
            /* [string][retval][out] */ const char **ppszPort) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetUser( 
            /* [string][retval][out] */ const char **ppszUser) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPassword( 
            /* [string][retval][out] */ const char **ppszPassword) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetClient( 
            /* [string][retval][out] */ const char **ppszClient) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetHost( 
            /* [string][retval][out] */ const char **ppszHost) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetAuth( 
            /* [string][retval][out] */ const char **ppszAuth) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetDiff( 
            /* [in] */ DWORD eTextual,
            /* [string][retval][out] */ const char **ppszDiffCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFileEditor( 
            /* [in] */ DWORD eTextual,
            /* [string][retval][out] */ const char **ppszEditorCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetFormEditor( 
            /* [string][retval][out] */ const char **ppszEditorCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetMerge( 
            /* [string][retval][out] */ const char **ppszMergeCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE GetPager( 
            /* [string][retval][out] */ const char **ppszPagerCmd) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE LoadIniFile( 
            /* [string][in] */ const char *pszPath,
            /* [in] */ BOOL fReset) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Break( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void **ppvObject) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISDClientApiVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISDClientApi * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISDClientApi * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISDClientApi * This);
        
        HRESULT ( STDMETHODCALLTYPE *Init )( 
            ISDClientApi * This,
            /* [in] */ ISDClientUser *pUI);
        
        HRESULT ( STDMETHODCALLTYPE *GetVersion )( 
            ISDClientApi * This,
            /* [out] */ SDVERINFO *pver);
        
        HRESULT ( STDMETHODCALLTYPE *SetArg )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszArg);
        
        HRESULT ( STDMETHODCALLTYPE *SetArgv )( 
            ISDClientApi * This,
            /* [in] */ int cArgs,
            /* [size_is][string][in] */ const char **ppArgv);
        
        HRESULT ( STDMETHODCALLTYPE *Run )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszFunc,
            /* [in] */ ISDClientUser *pUI,
            /* [in] */ BOOL fStructured);
        
        HRESULT ( STDMETHODCALLTYPE *Final )( 
            ISDClientApi * This);
        
        HRESULT ( STDMETHODCALLTYPE *IsDropped )( 
            ISDClientApi * This,
            /* [retval][out] */ BOOL *pfDropped);
        
        HRESULT ( STDMETHODCALLTYPE *GetErrorString )( 
            ISDClientApi * This,
            /* [string][retval][out] */ const char **ppsz);
        
        HRESULT ( STDMETHODCALLTYPE *SetPort )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszPort);
        
        HRESULT ( STDMETHODCALLTYPE *SetUser )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszUser);
        
        HRESULT ( STDMETHODCALLTYPE *SetPassword )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszPassword);
        
        HRESULT ( STDMETHODCALLTYPE *SetClient )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszClient);
        
        HRESULT ( STDMETHODCALLTYPE *SetHost )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszHost);
        
        HRESULT ( STDMETHODCALLTYPE *SetAuth )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszAuth);
        
        HRESULT ( STDMETHODCALLTYPE *DefinePort )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszPort);
        
        HRESULT ( STDMETHODCALLTYPE *DefineUser )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszUser);
        
        HRESULT ( STDMETHODCALLTYPE *DefinePassword )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszPassword);
        
        HRESULT ( STDMETHODCALLTYPE *DefineClient )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszClient);
        
        HRESULT ( STDMETHODCALLTYPE *DefineHost )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszHost);
        
        HRESULT ( STDMETHODCALLTYPE *DefineAuth )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszAuth);
        
        HRESULT ( STDMETHODCALLTYPE *GetPort )( 
            ISDClientApi * This,
            /* [string][retval][out] */ const char **ppszPort);
        
        HRESULT ( STDMETHODCALLTYPE *GetUser )( 
            ISDClientApi * This,
            /* [string][retval][out] */ const char **ppszUser);
        
        HRESULT ( STDMETHODCALLTYPE *GetPassword )( 
            ISDClientApi * This,
            /* [string][retval][out] */ const char **ppszPassword);
        
        HRESULT ( STDMETHODCALLTYPE *GetClient )( 
            ISDClientApi * This,
            /* [string][retval][out] */ const char **ppszClient);
        
        HRESULT ( STDMETHODCALLTYPE *GetHost )( 
            ISDClientApi * This,
            /* [string][retval][out] */ const char **ppszHost);
        
        HRESULT ( STDMETHODCALLTYPE *GetAuth )( 
            ISDClientApi * This,
            /* [string][retval][out] */ const char **ppszAuth);
        
        HRESULT ( STDMETHODCALLTYPE *GetDiff )( 
            ISDClientApi * This,
            /* [in] */ DWORD eTextual,
            /* [string][retval][out] */ const char **ppszDiffCmd);
        
        HRESULT ( STDMETHODCALLTYPE *GetFileEditor )( 
            ISDClientApi * This,
            /* [in] */ DWORD eTextual,
            /* [string][retval][out] */ const char **ppszEditorCmd);
        
        HRESULT ( STDMETHODCALLTYPE *GetFormEditor )( 
            ISDClientApi * This,
            /* [string][retval][out] */ const char **ppszEditorCmd);
        
        HRESULT ( STDMETHODCALLTYPE *GetMerge )( 
            ISDClientApi * This,
            /* [string][retval][out] */ const char **ppszMergeCmd);
        
        HRESULT ( STDMETHODCALLTYPE *GetPager )( 
            ISDClientApi * This,
            /* [string][retval][out] */ const char **ppszPagerCmd);
        
        HRESULT ( STDMETHODCALLTYPE *LoadIniFile )( 
            ISDClientApi * This,
            /* [string][in] */ const char *pszPath,
            /* [in] */ BOOL fReset);
        
        HRESULT ( STDMETHODCALLTYPE *Break )( 
            ISDClientApi * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            ISDClientApi * This,
            /* [in] */ REFIID riid,
            /* [iid_is][retval][out] */ void **ppvObject);
        
        END_INTERFACE
    } ISDClientApiVtbl;

    interface ISDClientApi
    {
        CONST_VTBL struct ISDClientApiVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISDClientApi_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISDClientApi_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISDClientApi_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISDClientApi_Init(This,pUI)	\
    (This)->lpVtbl -> Init(This,pUI)

#define ISDClientApi_GetVersion(This,pver)	\
    (This)->lpVtbl -> GetVersion(This,pver)

#define ISDClientApi_SetArg(This,pszArg)	\
    (This)->lpVtbl -> SetArg(This,pszArg)

#define ISDClientApi_SetArgv(This,cArgs,ppArgv)	\
    (This)->lpVtbl -> SetArgv(This,cArgs,ppArgv)

#define ISDClientApi_Run(This,pszFunc,pUI,fStructured)	\
    (This)->lpVtbl -> Run(This,pszFunc,pUI,fStructured)

#define ISDClientApi_Final(This)	\
    (This)->lpVtbl -> Final(This)

#define ISDClientApi_IsDropped(This,pfDropped)	\
    (This)->lpVtbl -> IsDropped(This,pfDropped)

#define ISDClientApi_GetErrorString(This,ppsz)	\
    (This)->lpVtbl -> GetErrorString(This,ppsz)

#define ISDClientApi_SetPort(This,pszPort)	\
    (This)->lpVtbl -> SetPort(This,pszPort)

#define ISDClientApi_SetUser(This,pszUser)	\
    (This)->lpVtbl -> SetUser(This,pszUser)

#define ISDClientApi_SetPassword(This,pszPassword)	\
    (This)->lpVtbl -> SetPassword(This,pszPassword)

#define ISDClientApi_SetClient(This,pszClient)	\
    (This)->lpVtbl -> SetClient(This,pszClient)

#define ISDClientApi_SetHost(This,pszHost)	\
    (This)->lpVtbl -> SetHost(This,pszHost)

#define ISDClientApi_SetAuth(This,pszAuth)	\
    (This)->lpVtbl -> SetAuth(This,pszAuth)

#define ISDClientApi_DefinePort(This,pszPort)	\
    (This)->lpVtbl -> DefinePort(This,pszPort)

#define ISDClientApi_DefineUser(This,pszUser)	\
    (This)->lpVtbl -> DefineUser(This,pszUser)

#define ISDClientApi_DefinePassword(This,pszPassword)	\
    (This)->lpVtbl -> DefinePassword(This,pszPassword)

#define ISDClientApi_DefineClient(This,pszClient)	\
    (This)->lpVtbl -> DefineClient(This,pszClient)

#define ISDClientApi_DefineHost(This,pszHost)	\
    (This)->lpVtbl -> DefineHost(This,pszHost)

#define ISDClientApi_DefineAuth(This,pszAuth)	\
    (This)->lpVtbl -> DefineAuth(This,pszAuth)

#define ISDClientApi_GetPort(This,ppszPort)	\
    (This)->lpVtbl -> GetPort(This,ppszPort)

#define ISDClientApi_GetUser(This,ppszUser)	\
    (This)->lpVtbl -> GetUser(This,ppszUser)

#define ISDClientApi_GetPassword(This,ppszPassword)	\
    (This)->lpVtbl -> GetPassword(This,ppszPassword)

#define ISDClientApi_GetClient(This,ppszClient)	\
    (This)->lpVtbl -> GetClient(This,ppszClient)

#define ISDClientApi_GetHost(This,ppszHost)	\
    (This)->lpVtbl -> GetHost(This,ppszHost)

#define ISDClientApi_GetAuth(This,ppszAuth)	\
    (This)->lpVtbl -> GetAuth(This,ppszAuth)

#define ISDClientApi_GetDiff(This,eTextual,ppszDiffCmd)	\
    (This)->lpVtbl -> GetDiff(This,eTextual,ppszDiffCmd)

#define ISDClientApi_GetFileEditor(This,eTextual,ppszEditorCmd)	\
    (This)->lpVtbl -> GetFileEditor(This,eTextual,ppszEditorCmd)

#define ISDClientApi_GetFormEditor(This,ppszEditorCmd)	\
    (This)->lpVtbl -> GetFormEditor(This,ppszEditorCmd)

#define ISDClientApi_GetMerge(This,ppszMergeCmd)	\
    (This)->lpVtbl -> GetMerge(This,ppszMergeCmd)

#define ISDClientApi_GetPager(This,ppszPagerCmd)	\
    (This)->lpVtbl -> GetPager(This,ppszPagerCmd)

#define ISDClientApi_LoadIniFile(This,pszPath,fReset)	\
    (This)->lpVtbl -> LoadIniFile(This,pszPath,fReset)

#define ISDClientApi_Break(This)	\
    (This)->lpVtbl -> Break(This)

#define ISDClientApi_Clone(This,riid,ppvObject)	\
    (This)->lpVtbl -> Clone(This,riid,ppvObject)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISDClientApi_Init_Proxy( 
    ISDClientApi * This,
    /* [in] */ ISDClientUser *pUI);


void __RPC_STUB ISDClientApi_Init_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetVersion_Proxy( 
    ISDClientApi * This,
    /* [out] */ SDVERINFO *pver);


void __RPC_STUB ISDClientApi_GetVersion_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_SetArg_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszArg);


void __RPC_STUB ISDClientApi_SetArg_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_SetArgv_Proxy( 
    ISDClientApi * This,
    /* [in] */ int cArgs,
    /* [size_is][string][in] */ const char **ppArgv);


void __RPC_STUB ISDClientApi_SetArgv_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_Run_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszFunc,
    /* [in] */ ISDClientUser *pUI,
    /* [in] */ BOOL fStructured);


void __RPC_STUB ISDClientApi_Run_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_Final_Proxy( 
    ISDClientApi * This);


void __RPC_STUB ISDClientApi_Final_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_IsDropped_Proxy( 
    ISDClientApi * This,
    /* [retval][out] */ BOOL *pfDropped);


void __RPC_STUB ISDClientApi_IsDropped_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetErrorString_Proxy( 
    ISDClientApi * This,
    /* [string][retval][out] */ const char **ppsz);


void __RPC_STUB ISDClientApi_GetErrorString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_SetPort_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszPort);


void __RPC_STUB ISDClientApi_SetPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_SetUser_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszUser);


void __RPC_STUB ISDClientApi_SetUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_SetPassword_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszPassword);


void __RPC_STUB ISDClientApi_SetPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_SetClient_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszClient);


void __RPC_STUB ISDClientApi_SetClient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_SetHost_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszHost);


void __RPC_STUB ISDClientApi_SetHost_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_SetAuth_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszAuth);


void __RPC_STUB ISDClientApi_SetAuth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_DefinePort_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszPort);


void __RPC_STUB ISDClientApi_DefinePort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_DefineUser_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszUser);


void __RPC_STUB ISDClientApi_DefineUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_DefinePassword_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszPassword);


void __RPC_STUB ISDClientApi_DefinePassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_DefineClient_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszClient);


void __RPC_STUB ISDClientApi_DefineClient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_DefineHost_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszHost);


void __RPC_STUB ISDClientApi_DefineHost_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_DefineAuth_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszAuth);


void __RPC_STUB ISDClientApi_DefineAuth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetPort_Proxy( 
    ISDClientApi * This,
    /* [string][retval][out] */ const char **ppszPort);


void __RPC_STUB ISDClientApi_GetPort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetUser_Proxy( 
    ISDClientApi * This,
    /* [string][retval][out] */ const char **ppszUser);


void __RPC_STUB ISDClientApi_GetUser_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetPassword_Proxy( 
    ISDClientApi * This,
    /* [string][retval][out] */ const char **ppszPassword);


void __RPC_STUB ISDClientApi_GetPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetClient_Proxy( 
    ISDClientApi * This,
    /* [string][retval][out] */ const char **ppszClient);


void __RPC_STUB ISDClientApi_GetClient_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetHost_Proxy( 
    ISDClientApi * This,
    /* [string][retval][out] */ const char **ppszHost);


void __RPC_STUB ISDClientApi_GetHost_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetAuth_Proxy( 
    ISDClientApi * This,
    /* [string][retval][out] */ const char **ppszAuth);


void __RPC_STUB ISDClientApi_GetAuth_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetDiff_Proxy( 
    ISDClientApi * This,
    /* [in] */ DWORD eTextual,
    /* [string][retval][out] */ const char **ppszDiffCmd);


void __RPC_STUB ISDClientApi_GetDiff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetFileEditor_Proxy( 
    ISDClientApi * This,
    /* [in] */ DWORD eTextual,
    /* [string][retval][out] */ const char **ppszEditorCmd);


void __RPC_STUB ISDClientApi_GetFileEditor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetFormEditor_Proxy( 
    ISDClientApi * This,
    /* [string][retval][out] */ const char **ppszEditorCmd);


void __RPC_STUB ISDClientApi_GetFormEditor_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetMerge_Proxy( 
    ISDClientApi * This,
    /* [string][retval][out] */ const char **ppszMergeCmd);


void __RPC_STUB ISDClientApi_GetMerge_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_GetPager_Proxy( 
    ISDClientApi * This,
    /* [string][retval][out] */ const char **ppszPagerCmd);


void __RPC_STUB ISDClientApi_GetPager_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_LoadIniFile_Proxy( 
    ISDClientApi * This,
    /* [string][in] */ const char *pszPath,
    /* [in] */ BOOL fReset);


void __RPC_STUB ISDClientApi_LoadIniFile_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_Break_Proxy( 
    ISDClientApi * This);


void __RPC_STUB ISDClientApi_Break_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientApi_Clone_Proxy( 
    ISDClientApi * This,
    /* [in] */ REFIID riid,
    /* [iid_is][retval][out] */ void **ppvObject);


void __RPC_STUB ISDClientApi_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISDClientApi_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sdapi_0133 */
/* [local] */ 

#define DeclareISDClientApiMembers(IPURE) \
        STDMETHOD(Init)(THIS_ ISDClientUser* pUI) IPURE; \
        STDMETHOD(GetVersion)(THIS_ SDVERINFO* pver) IPURE; \
        STDMETHOD(SetArg)(THIS_ const char* pszArg) IPURE; \
        STDMETHOD(SetArgv)(THIS_ int cArgs, const char** ppArgv) IPURE; \
        STDMETHOD(Run)(THIS_ const char* pszFunc, ISDClientUser* pUI, BOOL fStructured) IPURE; \
        STDMETHOD(Final)(THIS) IPURE; \
        STDMETHOD(IsDropped)(THIS_ BOOL* pfDropped) IPURE; \
        STDMETHOD(GetErrorString)(THIS_ const char** ppsz) IPURE; \
        STDMETHOD(SetPort)(THIS_ const char* pszPort) IPURE; \
        STDMETHOD(SetUser)(THIS_ const char* pszUser) IPURE; \
        STDMETHOD(SetPassword)(THIS_ const char* pszPassword) IPURE; \
        STDMETHOD(SetClient)(THIS_ const char* pszClient) IPURE; \
        STDMETHOD(SetHost)(THIS_ const char* pszHost) IPURE; \
        STDMETHOD(SetAuth)(THIS_ const char* pszAuth) IPURE; \
        STDMETHOD(DefinePort)(THIS_ const char* pszPort) IPURE; \
        STDMETHOD(DefineUser)(THIS_ const char* pszUser) IPURE; \
        STDMETHOD(DefinePassword)(THIS_ const char* pszPassword) IPURE; \
        STDMETHOD(DefineClient)(THIS_ const char* pszClient) IPURE; \
        STDMETHOD(DefineHost)(THIS_ const char* pszHost) IPURE; \
        STDMETHOD(DefineAuth)(THIS_ const char* pszAuth) IPURE; \
        STDMETHOD(GetPort)(THIS_ const char** ppszPort) IPURE; \
        STDMETHOD(GetUser)(THIS_ const char** ppszUser) IPURE; \
        STDMETHOD(GetPassword)(THIS_ const char** ppszPassword) IPURE; \
        STDMETHOD(GetClient)(THIS_ const char** ppszClient) IPURE; \
        STDMETHOD(GetHost)(THIS_ const char** ppszHost) IPURE; \
        STDMETHOD(GetAuth)(THIS_ const char** ppszAuth) IPURE; \
        STDMETHOD(GetDiff)(THIS_ DWORD eTextual, const char** ppszDiffCmd) IPURE; \
        STDMETHOD(GetFileEditor)(THIS_ DWORD eTextual, const char** ppszEditorCmd) IPURE; \
        STDMETHOD(GetFormEditor)(THIS_ const char** ppszEditorCmd) IPURE; \
        STDMETHOD(GetMerge)(THIS_ const char** ppszMergeCmd) IPURE; \
        STDMETHOD(GetPager)(THIS_ const char** ppszPagerCmd) IPURE; \
        STDMETHOD(LoadIniFile)(THIS_ const char* pszPath, BOOL fReset) IPURE; \
        STDMETHOD(Break)(THIS) IPURE; \
        STDMETHOD(Clone)(THIS_ REFIID riid, void** ppvObject) IPURE; \

DeclareInterfaceUtil(ISDClientApi)

#ifndef __building_SDAPI_DLL
// {A81BB025-1174-4BC7-930E-C3158CF87237}
DEFINE_GUID(IID_ISDClientApi, 0xa81bb025, 0x1174, 0x4bc7, 0x93, 0x0e, 0xc3, 0x15, 0x8c, 0xf8, 0x72, 0x37);
#endif


extern RPC_IF_HANDLE __MIDL_itf_sdapi_0133_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0133_v0_0_s_ifspec;

#ifndef __ISDClientUtilities_INTERFACE_DEFINED__
#define __ISDClientUtilities_INTERFACE_DEFINED__

/* interface ISDClientUtilities */
/* [local][unique][uuid][object] */ 


EXTERN_C const IID IID_ISDClientUtilities;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("EFC0F46D-C483-4A70-A7EE-A261D9592ED2")
    ISDClientUtilities : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE CheckMarkers( 
            /* [in] */ ISDVars *pVars,
            /* [retval][out] */ BOOL *pfHasMarkers) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Resolve3( 
            /* [in] */ ISDClientUser *pUI,
            /* [string][in] */ const char *aflags,
            /* [string][in] */ const char *dflags,
            /* [string][in] */ const char *pszBase,
            /* [string][in] */ const char *pszTheirs,
            /* [string][in] */ const char *pszYours,
            /* [string][in] */ const char *pszResult) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Diff( 
            /* [string][in] */ const char *pszLeft,
            /* [string][in] */ const char *pszRight,
            /* [string][in] */ const char *pszFlags,
            /* [in] */ DWORD eForceTextual,
            /* [retval][out] */ ISDVars **ppVars) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE DetectType( 
            /* [string][in] */ const char *pszFile,
            /* [out] */ DWORD *peTextual,
            /* [out] */ const char **ppszType,
            /* [in] */ BOOL fServer) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Set( 
            /* [in] */ const char *pszVar,
            /* [in] */ const char *pszValue,
            /* [in] */ BOOL fMachine,
            /* [in] */ const char *pszService) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE QuerySettings( 
            /* [in] */ const char *pszVar,
            /* [in] */ const char *pszService,
            /* [retval][out] */ ISDVars **ppVars) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct ISDClientUtilitiesVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            ISDClientUtilities * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            ISDClientUtilities * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            ISDClientUtilities * This);
        
        HRESULT ( STDMETHODCALLTYPE *CheckMarkers )( 
            ISDClientUtilities * This,
            /* [in] */ ISDVars *pVars,
            /* [retval][out] */ BOOL *pfHasMarkers);
        
        HRESULT ( STDMETHODCALLTYPE *Resolve3 )( 
            ISDClientUtilities * This,
            /* [in] */ ISDClientUser *pUI,
            /* [string][in] */ const char *aflags,
            /* [string][in] */ const char *dflags,
            /* [string][in] */ const char *pszBase,
            /* [string][in] */ const char *pszTheirs,
            /* [string][in] */ const char *pszYours,
            /* [string][in] */ const char *pszResult);
        
        HRESULT ( STDMETHODCALLTYPE *Diff )( 
            ISDClientUtilities * This,
            /* [string][in] */ const char *pszLeft,
            /* [string][in] */ const char *pszRight,
            /* [string][in] */ const char *pszFlags,
            /* [in] */ DWORD eForceTextual,
            /* [retval][out] */ ISDVars **ppVars);
        
        HRESULT ( STDMETHODCALLTYPE *DetectType )( 
            ISDClientUtilities * This,
            /* [string][in] */ const char *pszFile,
            /* [out] */ DWORD *peTextual,
            /* [out] */ const char **ppszType,
            /* [in] */ BOOL fServer);
        
        HRESULT ( STDMETHODCALLTYPE *Set )( 
            ISDClientUtilities * This,
            /* [in] */ const char *pszVar,
            /* [in] */ const char *pszValue,
            /* [in] */ BOOL fMachine,
            /* [in] */ const char *pszService);
        
        HRESULT ( STDMETHODCALLTYPE *QuerySettings )( 
            ISDClientUtilities * This,
            /* [in] */ const char *pszVar,
            /* [in] */ const char *pszService,
            /* [retval][out] */ ISDVars **ppVars);
        
        END_INTERFACE
    } ISDClientUtilitiesVtbl;

    interface ISDClientUtilities
    {
        CONST_VTBL struct ISDClientUtilitiesVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define ISDClientUtilities_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define ISDClientUtilities_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define ISDClientUtilities_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define ISDClientUtilities_CheckMarkers(This,pVars,pfHasMarkers)	\
    (This)->lpVtbl -> CheckMarkers(This,pVars,pfHasMarkers)

#define ISDClientUtilities_Resolve3(This,pUI,aflags,dflags,pszBase,pszTheirs,pszYours,pszResult)	\
    (This)->lpVtbl -> Resolve3(This,pUI,aflags,dflags,pszBase,pszTheirs,pszYours,pszResult)

#define ISDClientUtilities_Diff(This,pszLeft,pszRight,pszFlags,eForceTextual,ppVars)	\
    (This)->lpVtbl -> Diff(This,pszLeft,pszRight,pszFlags,eForceTextual,ppVars)

#define ISDClientUtilities_DetectType(This,pszFile,peTextual,ppszType,fServer)	\
    (This)->lpVtbl -> DetectType(This,pszFile,peTextual,ppszType,fServer)

#define ISDClientUtilities_Set(This,pszVar,pszValue,fMachine,pszService)	\
    (This)->lpVtbl -> Set(This,pszVar,pszValue,fMachine,pszService)

#define ISDClientUtilities_QuerySettings(This,pszVar,pszService,ppVars)	\
    (This)->lpVtbl -> QuerySettings(This,pszVar,pszService,ppVars)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE ISDClientUtilities_CheckMarkers_Proxy( 
    ISDClientUtilities * This,
    /* [in] */ ISDVars *pVars,
    /* [retval][out] */ BOOL *pfHasMarkers);


void __RPC_STUB ISDClientUtilities_CheckMarkers_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUtilities_Resolve3_Proxy( 
    ISDClientUtilities * This,
    /* [in] */ ISDClientUser *pUI,
    /* [string][in] */ const char *aflags,
    /* [string][in] */ const char *dflags,
    /* [string][in] */ const char *pszBase,
    /* [string][in] */ const char *pszTheirs,
    /* [string][in] */ const char *pszYours,
    /* [string][in] */ const char *pszResult);


void __RPC_STUB ISDClientUtilities_Resolve3_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUtilities_Diff_Proxy( 
    ISDClientUtilities * This,
    /* [string][in] */ const char *pszLeft,
    /* [string][in] */ const char *pszRight,
    /* [string][in] */ const char *pszFlags,
    /* [in] */ DWORD eForceTextual,
    /* [retval][out] */ ISDVars **ppVars);


void __RPC_STUB ISDClientUtilities_Diff_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUtilities_DetectType_Proxy( 
    ISDClientUtilities * This,
    /* [string][in] */ const char *pszFile,
    /* [out] */ DWORD *peTextual,
    /* [out] */ const char **ppszType,
    /* [in] */ BOOL fServer);


void __RPC_STUB ISDClientUtilities_DetectType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUtilities_Set_Proxy( 
    ISDClientUtilities * This,
    /* [in] */ const char *pszVar,
    /* [in] */ const char *pszValue,
    /* [in] */ BOOL fMachine,
    /* [in] */ const char *pszService);


void __RPC_STUB ISDClientUtilities_Set_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE ISDClientUtilities_QuerySettings_Proxy( 
    ISDClientUtilities * This,
    /* [in] */ const char *pszVar,
    /* [in] */ const char *pszService,
    /* [retval][out] */ ISDVars **ppVars);


void __RPC_STUB ISDClientUtilities_QuerySettings_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __ISDClientUtilities_INTERFACE_DEFINED__ */


/* interface __MIDL_itf_sdapi_0136 */
/* [local] */ 

#define DeclareISDClientUtilitiesMembers(IPURE) \
        STDMETHOD(CheckMarkers)(THIS_ ISDVars* pVars, BOOL* pfHasMarkers) IPURE; \
        STDMETHOD(Resolve3)(THIS_ ISDClientUser* pUI, const char* aflags, const char* dflags, const char* pszBase, const char* pszTheirs, const char* pszYours, const char* pszResult) IPURE; \
        STDMETHOD(Diff)(THIS_ const char* pszLeft, const char* pszRight, const char* pszFlags, DWORD eForceTextual, ISDVars** ppVars) IPURE; \
        STDMETHOD(DetectType)(THIS_ const char* pszFile, DWORD* peTextual, const char** ppszType, BOOL fServer) IPURE; \
        STDMETHOD(Set)(THIS_ const char* pszVar, const char* pszValue, BOOL fMachine, const char* pszService) IPURE; \
        STDMETHOD(QuerySettings)(THIS_ const char* pszVar, const char* pszService, ISDVars** ppVars) IPURE; \

DeclareInterfaceUtil(ISDClientUtilities)

#ifndef __building_SDAPI_DLL
// {EFC0F46D-C483-4A70-A7EE-A261D9592ED2}
DEFINE_GUID(IID_ISDClientUtilities, 0xefc0f46d, 0xc483, 0x4a70, 0xa7, 0xee, 0xa2, 0x61, 0xd9, 0x59, 0x2e, 0xd2);
#endif


STDAPI CreateSDAPIObject(REFCLSID clsid, void** ppvObj);


// {27A2571D-DDA1-4F58-B960-DE1023344C1C}
DEFINE_GUID(CLSID_SDAPI, 0x27a2571d, 0xdda1, 0x4f58, 0xb9, 0x60, 0xde, 0x10, 0x23, 0x34, 0x4c, 0x1c);


extern RPC_IF_HANDLE __MIDL_itf_sdapi_0136_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_sdapi_0136_v0_0_s_ifspec;

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\setup\sources.inc ===
TARGETPATH=obj
TARGETTYPE=PROGRAM
USE_MSVCRT=1

BINPLACE_PLACEFILE=..\..\placefil.txt

INCLUDES=

MSC_WARNING_LEVEL=/W3 /WX

SOURCES=..\msisetup.c  \
        ..\msisetup.rc

UMTYPE=windows
UMENTRY=winmain

MSC_WARNING_LEVEL=/W3 /WX

TARGETLIBS=
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\snapshot\test\testsnap.c ===
#define UNICODE
#define _UNICODE
#include <stdlib.h>
#include <stdio.h>
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>


#define MAX_SNAPSHOT_SIZE   2048
typedef BOOL (*SNAPSHOTFUNC)(DWORD Flags, LPCTSTR *lpStrings, PLONG MaxBuffSize, LPTSTR SnapShotBuff);

_cdecl main()
{
    HANDLE hEventLog;
    PSID pUserSid = NULL;
    PTOKEN_USER pTokenUser = NULL;
    DWORD dwSidSize = sizeof(SID), dwEventID;
    WCHAR szProcessName[MAX_PATH + 1], szReason[128];
    WCHAR szComputerName[MAX_COMPUTERNAME_LENGTH + 1];
    LPWSTR lpStrings[9];
    WORD wEventType, wStringCnt;
    WCHAR szShutdownType[32], szMinorReason[32];
    BOOL bRet = FALSE;  
    HMODULE hSnapShot;
    SNAPSHOTFUNC pSnapShotProc;
    struct {
        DWORD Reason ;
        WCHAR SnapShotBuf[MAX_SNAPSHOT_SIZE];
    } SnapShot ;
    LONG SnapShotSize = MAX_SNAPSHOT_SIZE ;
    WCHAR wszDll[MAX_PATH];
    INT sTicks, eTicks;

    wStringCnt = 7;
    lpStrings[0] = L"TestProcess";
    lpStrings[1] = L"TestComputer";
    lpStrings[2] = L"Planned Testing";
    lpStrings[3] = L"0x40002000";
    lpStrings[4] = L"Reboot";
    lpStrings[5] = L"This is a test comment";
    lpStrings[6] = L"tester_account";


    //take a snapshot if shutdown is unplanned.


    //GetWindowsDirectoryW(wszDll, sizeof(wszDll) / sizeof(WCHAR));
    //wcsncat(wszDll, L"\\system32\\snapshot.dll",MAX_PATH - wcslen(wszDll));
    wsprintf(wszDll,L"snapshot.dll");

    hSnapShot = LoadLibrary(wszDll);
    if (! hSnapShot) {
        printf("Load %S failed!\n",wszDll);
    } else {
        pSnapShotProc = (SNAPSHOTFUNC)GetProcAddress(hSnapShot, "LogSystemSnapshot");
        if (!pSnapShotProc) {
            printf("GetProcAddress for LogSystemSnapshot on snapshot.dll failed!\n");
        } else {
            SnapShotSize = MAX_SNAPSHOT_SIZE ;
            __try { // Assume the worst about the snapshot DLL!

                printf("Calling the snapshot DLL\n");

                sTicks = GetTickCount();
                (*pSnapShotProc)(wStringCnt,lpStrings,&SnapShotSize,&SnapShot.SnapShotBuf[0]);
                eTicks = GetTickCount();

            } __except(EXCEPTION_EXECUTE_HANDLER) {

                printf("Exception Occurred!\n");
                wsprintf(SnapShot.SnapShotBuf, L"State Snapshot took an exception\n");
                eTicks = sTicks = 0 ;

            }
            SnapShotSize = wcslen(SnapShot.SnapShotBuf) ;
        }
        FreeLibrary(hSnapShot);

        if (SnapShotSize > 0) {
           printf("Snapshot buffer is %d bytes\n%S\n",SnapShotSize,SnapShot.SnapShotBuf);
           printf("Time Taken %dms\n",eTicks-sTicks);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\oca\webv3\root\en\include\body.inc ===
<%
var L_PASSPORTLOGIN_TEXT	= "To use the Windows Online Crash Analysis Web site, sign in using your Microsoft Passport. To get a Passport, visit the <A class='clsALinkNormal' href='http://www.passport.com'>Microsoft Passport Web site</A>.";
var L_PASSPORTSIGNIN_TEXT	= "Passport sign-in";
var L_ONLINECRASH_TEXT		= "Online Crash Analysis";

fnPrint( "<body bgcolor='#ffffff' topmargin='0' leftmargin='0' marginheight='0' marginwidth='0' tabindex='0'>" );

%>

<!--#include file='NoScriptHeader.asp'-->

<script type="text/javascript" language="JavaScript">
		if ( ToolBar_Supported )
		{
			drawToolbar();
			
			<%
				var L_PASSPORTSIGNOUT_TEXT = "Sign out of .NET Passport sites";
				
				if ( Request.Cookies("OCAV3")("PPIN" ) == "1" )
					Response.Write( "idICPMenuPane.insertAdjacentHTML(\"beforeEnd\", \"<Span style='position:absolute;top:0;right:5;height:20;width:100;'><center><span style='background-color:white'><A HREF='/logoutgif.asp?Signout=1'><IMG alt='' SRC='https://www.passportimages.com/" + fnGetBrowserLCID() + "/signout.gif' CLASS='PassportSignOut' BORDER='0' ALT='" + L_PASSPORTSIGNOUT_TEXT + "'></A></span></center></span>\" ) " )
			%>
			
	
		}
		else
		{			
			<% 
				if ( Request.Cookies("OCAV3")("PPIN" ) == "1" )
					Response.Write( "var g_AddSignoutLogo = \"<SPAN ALIGN=right><A HREF='/Logoutgif.asp?Signout=1'><IMG alt='' SRC='https://www.passportimages.com/" + fnGetBrowserLCID() + "/signout.gif' CLASS='PassportSignOut' BORDER='0' ALT='" + L_PASSPORTSIGNOUT_TEXT + "'></A></SPAN>\";" );
				else
					Response.Write( "var g_AddSignoutLogo = \"\" " );
			%>

			drawDownlevelToolbar();
		}			

	
	</script>



<%

function fnPrintMenuOption( szOptionText, szOptionURL, szNameID )
{
	Response.Write("<table width='100%' cellpadding='0' cellspacing='0' border='0'>" );
	Response.Write("<tr><td class='flyoutLink'>" );
	Response.Write("<img alt='' src='/include/images/endnode.gif' border='0' WIDTH='11' HEIGHT='11'>&nbsp;&nbsp;" );
	Response.Write("<a id='" + szNameID + "' name='" + szNameID + "' href='" + szOptionURL + "'>" + szOptionText + "</a>" );
	Response.Write("</td></tr></table>");
}

function fnPrint ( szText )
{
	Response.Write( szText + "\n" );
}


var L_HOME_TEXT			= "Home";
var L_SUBMITREPORT_TEXT = "Submit Report";
var L_STATUS_TEXT		= "Status";
var L_PRIVACY_TEXT		= "Privacy";
var L_FAQ_TEXT			= "FAQ";





//fnPrint( "<table BORDER='0' cellpadding='10' cellspacing='0' height='73%'>");
fnPrint( "<table ID='tblMainBody' BORDER='0' cellpadding='10' cellspacing='0' height='100%'>");

fnPrint( "<tr valign='top'>" );
	fnPrint( "<td class='flyoutMenu2' HEIGHT='100%'>" );	//this is the left column of the main table

		//This is the inner table with the lighter background
		fnPrint( "<table BORDER='0' height='100%' cellpadding='0' cellspacing='0' width='182'>" );
			fnPrint( "<tr valign='top'>" );
				fnPrint( "<td height='100%'>" );

					// this is the Online crash header part of the menu
					fnPrint( "<table width='100%' cellpadding='0' cellspacing='0' border='0'>" );
					fnPrint( "<tr>" );
					fnPrint( "<td class='sys-toppane-header'>" );
					fnPrint( "<P CLASS='Flyouttext'>" + L_ONLINECRASH_TEXT + "</P>" );
					fnPrint( "</td>" );
					fnPrint( "</tr>" );
					fnPrint( "</table>" );
					// END TOP OF MENU HEADER

					fnPrint( "<table width='100%' cellpadding='0' cellspacing='0' border='0' height='100%' VALIGN='top'>" );
					fnPrint( "<tr>" );
						fnPrint( "<td rowspan='2' height='100%' class='flyoutMenu' valign='top'>" );
						

						fnPrintMenuOption( L_HOME_TEXT, "http://" + g_ThisServer + "/welcome.asp" );

						//if ( fnIsBrowserIE() )
						if( 0 )
							fnPrintMenuOption( L_SUBMITREPORT_TEXT	, "http://" + g_ThisServer + "/privacy.asp?t=1", "aSubmitLnk" );
							
						fnPrintMenuOption( L_STATUS_TEXT			, "https://" + g_ThisServer + "/secure/status.asp", "aStatusLnk" );
						fnPrintMenuOption( L_PRIVACY_TEXT			, "http://" + g_ThisServer + "/Privacy.asp?t=0", "aPrivacyLnk" );
						fnPrintMenuOption( L_FAQ_TEXT				, "http://" + g_ThisServer + "/FAQ.asp", "aFAQLnk" );

						fnPrint( "</td>" );
					fnPrint( "</tr>" );
					fnPrint( "</table>" );
				fnPrint( "</td>" );
			fnPrint( "</tr>" );
		fnPrint( "</table>" );
	fnPrint( "</td>" );
	
	fnPrint( "<td>" );
		fnPrint( "<br>" );




%>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\sdsrv\sdsrv.cpp ===
#ifndef _WINDOWS_H
#include "windows.h"
#endif

#include <stdio.h>
#include <stdlib.h>
#include <io.h>
#include <fcntl.h>
#include <assert.h>
#include <typeinfo.h>
#include <time.h>
#include <limits.h>
#include <strsafe.h>

#include "initguid.h"
#include "sdapi.h"

#ifndef DIMA
 #define DIMAT(Array, EltType) (sizeof(Array) / sizeof(EltType))
 #define DIMA(Array) DIMAT(Array, (Array)[0])
#endif

static const char usage[] = "sdapitest [-?] command [args]";

static const char long_usage[] =
"Usage:\n"
"\n"
"    sdapitest [options] command [args]\n"
"\n"
"	Roughly emulates the SD.EXE client, using the SDAPI.\n"
"\n"
"    Options:\n"
"	-?		Print this message.\n"
"	-!		Break into debugger.\n"
"\n"
"	-d		Debug/diagnostic/informational output mode.\n"
"	-v		Verbose mode (show type of output).\n"
"\n"
"	-c client	Set client name.\n"
"	-H host		Set host name.\n"
"	-p port		Set server port.\n"
"	-P password	Set user's password.\n"
"	-u user		Set username.\n"
"\n"
"	-i file		Read settings from file (same format as SD.INI).\n"
"			If file is a directory name, walk up the directory\n"
"			parent chain searching for an SD.INI file to read.\n"
"	-I file		Same as -i, but clears the current settings first.\n"
"\n"
"	-x file		Read commands from 'file'.  To read commands from\n"
"			stdin, use - as the file name.  This can even be used\n"
"			as a simplistic interactive SD shell.  Each command\n"
"			can be optionally preceded by an integer and a comma.\n"
"			The integer indicates the number of seconds to pause\n"
"			before running the command.\n"
"\n"
"	-T		Use the SDAPI structured mode.\n"
#if 0
"	-C		Use CreateSDAPIObject() instead of CoCreateInstance();\n"
"			(note, must come before any other options).\n"
#endif
"\n"
"    Special Commands:\n"
"	demo			Uses structured mode to run 'sd changes' and\n"
"				format the output specially.\n"
"	detect [-s] file	Uses ISDClientUtilities::DetectType to detect\n"
"				file's type the same way 'sd add file' does.\n"
"	set [-S service] var=[value]\n"
"				Uses ISDClientUtilities::Set to set variables\n"
"				similar to how 'sd set' does.\n"
"				** DOES NOT UPDATE THE SDAPI OBJECT, therefore\n"
"				the 'query' command (below) cannot report the\n"
"				new value.\n"
"	query [-S service] [var]\n"
"				Uses ISDClientUtilities::QuerySettings to\n"
"				report the current settings similar to how\n"
"				'sd set' does.\n"
"				** QUERIES THE SDAPI OBJECT, therefore cannot\n"
"				report a new value from 'set' (above).\n"
;


static BOOL s_fVerbose = FALSE;









BOOL
wcs2ansi(
    const WCHAR *pwsz,
    char *psz,
    DWORD pszlen
    )
{
    BOOL rc;
    int  len;

    assert(psz && pwsz);

    len = wcslen(pwsz);
    if (!len) {
        *psz = 0;
        return TRUE;
    }

    rc = WideCharToMultiByte(CP_ACP,
                             WC_SEPCHARS | WC_COMPOSITECHECK,
                             pwsz,
                             len,
                             psz,
                             pszlen,
                             NULL,
                             NULL);
    if (!rc)
        return FALSE;

    psz[len] = 0;

    return TRUE;
}


BOOL
ansi2wcs(
    const char  *psz,
    WCHAR *pwsz,
    DWORD pwszlen
    )
{
    BOOL rc;
    int  len;

    assert(psz && pwsz);

    len = strlen(psz);
    if (!len) {
        *pwsz = 0L;
        return TRUE;
    }

    rc = MultiByteToWideChar(CP_ACP,
                             MB_COMPOSITE,
                             psz,
                             len,
                             pwsz,
                             pwszlen);
    if (!rc)
        return FALSE;

    pwsz[len] = 0;

    return TRUE;
}




///////////////////////////////////////////////////////////////////////////
// Debugging Aids

// compile-time assert
#define CASSERT(expr) extern int cassert##__LINE__[(expr) ? 1 : 0]

// run-time assert
#ifdef DEBUG
#define AssertHelper \
	do { \
	    switch (MessageBox(NULL, "Assertion failed.", "SDAPITEST", MB_ABORTRETRYIGNORE)) { \
	    case IDABORT: exit(2); break; \
	    case IDRETRY: DebugBreak(); break; \
	    } \
	} while (0)
#define Assert(expr) \
	do { \
	    if (!(expr)) { \
		printf("%s\n", #expr); \
		AssertHelper; \
	    } \
	} while (0)
#define Assert1(expr, fmt, arg1) \
	do { \
	    if (!(expr)) { \
		printf(#fmt "\n", arg1); \
		AssertHelper; \
	    } \
	} while (0)
#define IfDebug(x) x
#else
#define Assert(expr) do {} while (0)
#define Assert1(expr, fmt, arg1) do {} while (0)
#define IfDebug(x)
#endif

#define Panic0(s) Assert1(FALSE, "%s", s)
#define PanicSz(s) Panic0(s)



///////////////////////////////////////////////////////////////////////////
// Embedded Interface Macros

#define OffsetOf(s,m)	    (size_t)( (char *)&(((s *)0)->m) - (char *)0 )
#define EmbeddorOf(C,m,p)   ((C *)(((char *)p) - OffsetOf(C,m)))


#define DeclareEmbeddedInterface(interface) \
	class E##interface : public interface \
	{ \
	public: \
	    STDMETHOD_(ULONG, AddRef)(); \
	    STDMETHOD_(ULONG, Release)(); \
	    STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppvObj); \
	    Declare##interface##Members(IMPL) \
	} m_##interface; \
	friend class E##interface;


#define ImplementEmbeddedUnknown(embeddor, interface) \
	STDMETHODIMP embeddor::E##interface::QueryInterface(REFIID iid,void **ppv)\
	{ \
	    return EmbeddorOf(embeddor,m_##interface,this)->QueryInterface(iid,ppv);\
	} \
	STDMETHODIMP_(ULONG) embeddor::E##interface::AddRef() \
	{ \
	    return EmbeddorOf(embeddor, m_##interface, this)->AddRef(); \
	} \
	STDMETHODIMP_(ULONG) embeddor::E##interface::Release() \
	{ \
	    return EmbeddorOf(embeddor, m_##interface, this)->Release(); \
	}


#define EMBEDDEDTHIS(embeddor, interface) \
	embeddor *pThis = EmbeddorOf(embeddor,m_##interface,this)



///////////////////////////////////////////////////////////////////////////
// dbgPrintF

static BOOL s_fDbg = FALSE;
static int s_cIndent = 0;


void dbgPrintF(const char *pszFmt, ...)
{
	if (s_fDbg)
	{
	    va_list args;
	    va_start(args, pszFmt);
	    for (int c = s_cIndent; c--;)
		printf("... ");
	    vprintf(pszFmt, args);
	    //printf("\n");
	    va_end(args);
	}
}


class DbgIndent
{
    public:
	DbgIndent() { s_cIndent++; }
	~DbgIndent() { s_cIndent--; }
};


#define DBGINDENT DbgIndent dbgindent;


class Ender
{
    public:
	~Ender() { dbgPrintF(""); dbgPrintF("---- end ----"); }
};



///////////////////////////////////////////////////////////////////////////
// VARIANT Helpers

inline int SzToWz(UINT CodePage, const char* pszFrom, int cchFrom, WCHAR* pwzTo, int cchMax)
{
	return MultiByteToWideChar(CodePage, 0, pszFrom, cchFrom, pwzTo, cchMax);
}


BSTR BstrFromSz(const char *psz, int cch = 0)
{
	BSTR bstr;
	int cchActual;

	if (!cch)
	    cch = strlen(psz);

	bstr = (BSTR)malloc((cch + 1) * sizeof(WCHAR));
	if (bstr)
	{
        ansi2wcs(psz, bstr, cch + 1);
	    cchActual = SzToWz(CP_OEMCP, psz, cch, bstr, cch);
	    bstr[cchActual] = 0;
	}

	return bstr;
}


HRESULT VariantSet(VARIANT *pvar, const char *psz, int cch = 0)
{
	if (pvar->vt != VT_EMPTY || !psz)
	    return E_INVALIDARG;

	V_BSTR(pvar) = BstrFromSz(psz, cch);
	V_VT(pvar) = VT_BSTR;

	if (!V_VT(pvar))
	    return E_OUTOFMEMORY;

	return S_OK;
}



///////////////////////////////////////////////////////////////////////////
// Smart Interface Pointer


void SetI(IUnknown * volatile *ppunkL, IUnknown *punkR)
{
	// addref right side first, in case punkR and *ppunkL are on the same
	// object (weak refs) or are the same variable.
	if (punkR)
	    punkR->AddRef();

	if (*ppunkL)
	{
	    IUnknown *punkRel = *ppunkL;
	    *ppunkL = 0;
	    punkRel->Release();
	}
	*ppunkL = punkR;
}


#ifdef DEBUG
void ReleaseI(IUnknown *punk)
{
	if (punk)
	{
	    if (IsBadReadPtr(punk,sizeof(void *)))
	    {
		Panic0("Bad Punk");
		return;
	    }
	    if (IsBadReadPtr(*((void**) punk),sizeof(void *) * 3))
	    {
		Panic0("Bad Vtable");
		return;
	    }
	    punk->Release();
	}
}
#else
inline void ReleaseI(IUnknown *punk)
{
	if (punk)
	    punk->Release();
}
#endif


template <class IFace> class PrivateRelease : public IFace
{
    private:
	// force Release to be private to prevent "spfoo->Release()"!!!
	STDMETHODIMP_(ULONG) Release();
};
template <class IFace, const GUID *piid>
class SPI
{
    public:
	SPI()				{ m_p = 0; }
	//SPI(IFace *p)			{ m_p = p; if (m_p) m_p->AddRef(); }
	~SPI()				{ ReleaseI(m_p); }
	operator IFace*() const		{ return m_p; }
	PrivateRelease<IFace> *operator->() const
					{ return (PrivateRelease<IFace>*)m_p; }
	IFace **operator &()		{ Assert1(!m_p, "Non-empty %s as out param.", typeid(SPI<IFace, piid>).name()); return &m_p; }
	IFace *operator=(IFace *p)	{ Assert1(!m_p, "Non-empty %s in assignment.", typeid(SPI<IFace, piid>).name()); return m_p = p; }
	IFace *Transfer()		{ IFace *p = m_p; m_p = 0; return p; }
	IFace *Copy()			{ if (m_p) m_p->AddRef(); return m_p; }
	void Release()			{ SetI((IUnknown **)&m_p, 0); }
	void Set(IFace *p)		{ SetI((IUnknown **)&m_p, p); }
	bool operator!()		{ return (m_p == NULL); }

	BOOL FQuery(IUnknown *punk)	{ return FHrSucceeded(HrQuery(punk)); }
	HRESULT HrQuery(IUnknown *punk)	{ Assert1(!m_p, "Non-empty %s in HrQuery().", typeid(SPI<IFace, piid>).name()); return HrQueryInterface(punk, *piid, (void**)&m_p); }

    protected:
	IFace *m_p;

    private:
	// disallow these methods from being called
	SPI<IFace, piid> &operator=(const SPI<IFace, piid>& sp)
					{ SetI((IUnknown **)&m_p, sp.m_p); return *this; }
};


#define DeclareSPI(TAG, IFace)\
	EXTERN_C const GUID CDECL IID_##IFace;\
	typedef SPI<IFace, &IID_##IFace> SP##TAG;


DeclareSPI(API, ISDClientApi)



///////////////////////////////////////////////////////////////////////////
// ClientUser

#define DeclareIUnknownMembers(IPURE) \
	STDMETHOD(QueryInterface) (THIS_ REFIID riid, LPVOID* ppvObj) IPURE; \
	STDMETHOD_(ULONG,AddRef) (THIS)  IPURE; \
	STDMETHOD_(ULONG,Release) (THIS) IPURE; \


class ClientUser : public ISDClientUser
{
    public:
	ClientUser() : m_cRef(1), m_fFresh(TRUE), m_fDemo(FALSE) {}
	virtual ~ClientUser() {}

	DeclareIUnknownMembers(IMPL);
	DeclareISDClientUserMembers(IMPL);

	DeclareEmbeddedInterface(ISDActionUser);
	DeclareEmbeddedInterface(ISDInputUser);

	void SetDemo(BOOL fDemo) { m_fDemo = fDemo; m_fFresh = TRUE; }

    private:
	ULONG m_cRef;
	BOOL m_fFresh;
	BOOL m_fDemo;
};


STDMETHODIMP_(ULONG) ClientUser::AddRef()
{
	return ++m_cRef;
}


STDMETHODIMP_(ULONG) ClientUser::Release()
{
	if (--m_cRef > 0)
	    return m_cRef;

	delete this;
	return 0;
}


STDMETHODIMP ClientUser::QueryInterface(REFIID iid, void** ppvObj)
{
	HRESULT hr = S_OK;

	if (iid == IID_IUnknown || iid == IID_ISDClientUser)
	    *ppvObj = (ISDClientUser*)this;
	else if (iid == IID_ISDActionUser)
	    *ppvObj = &m_ISDActionUser;
	else if (iid == IID_ISDInputUser)
	    *ppvObj = &m_ISDInputUser;
	else
	{
	    *ppvObj = 0;
	    return E_NOINTERFACE;
	}

	((IUnknown*)*ppvObj)->AddRef();
	return hr;
}


// ---- ISDClientUser -----------------------------------------------------

/*----------------------------------------------------------------------------
    ISDClientUser::OutputText
	Called for text data, generally the result of 'print textfile' or
	'spec-command -o' (where spec-command is branch, change, client,
	label, protect, user, etc).

    IMPORTANT NOTE:
	The implementation of this method must translate '\n' in the pszText
	string to '\r\n' on Windows platforms to ensure correct line
	termination.  This is particularly important when using 'print' to
	download the contents of a file.

    Args:
	pszText		- [in] text string (not null terminated, and may
			  contain embedded null characters that are part of
			  the data itself).
	cchText		- [in] number of bytes in pszText.

    Rets:
	The return value is ignored.  For future compatibility, the method
	should return E_NOTIMPL if it is not implemented, or S_OK for success.

----------------------------------------------------------------------------*/
STDMETHODIMP ClientUser::OutputText( const char *pszText,
				     int cchText )
{
	fwrite(pszText, cchText, 1, stdout);
	return S_OK;
}


/*----------------------------------------------------------------------------
    ISDClientUser::OutputBinary
	Called for binary data, generally the result of 'print nontextfile' or
	'print unicodefile'.

    Args:
	pbData		- [in] stream of bytes.
	cbData		- [in] number of bytes in pbData.

    Rets:
	The return value is ignored.  For future compatibility, the method
	should return E_NOTIMPL if it is not implemented, or S_OK for success.

----------------------------------------------------------------------------*/
STDMETHODIMP ClientUser::OutputBinary( const unsigned char *pbData,
				       int cbData )
{
	static BOOL s_fBinary = FALSE;

	// we rely on a trailing zero length buffer to
	// tell us to turn off binary output for stdout.

	if (s_fBinary == !cbData)
	{
	    // toggle
	    s_fBinary = !!cbData;
	    fflush(stdout);
	    _setmode(_fileno(stdout), s_fBinary ? O_BINARY : O_TEXT);
	}

	fwrite(pbData, cbData, 1, stdout);
	return S_OK;
}


/*----------------------------------------------------------------------------
    ISDClientUser::OutputInfo
	Called for tabular data, usually the results of commands that affect
	sets of files.

	Some commands also support structured output; see ISDClientApi::Init
	and ISDClientUser::OutputStructured for more information.

    Args:
	cIndent		- [in] indentation levels 0 - 2 (loosely implies
			  hierarchical relationship).  The SD.EXE client
			  program normally handles 1 by prepending "... " to
			  the string, and handles 2 by prepending "... ... ".
	pszInfo		- [in] informational message string.

    Rets:
	The return value is ignored.  For future compatibility, the method
	should return E_NOTIMPL if it is not implemented, or S_OK for success.

----------------------------------------------------------------------------*/
STDMETHODIMP ClientUser::OutputInfo( int cIndent,
				     const char *pszInfo )
{
	if (s_fVerbose)
	    printf(cIndent ? "info%d:\t" : "info:\t", cIndent);

	while (cIndent--)
	    printf("   ");

	printf("%s\n", pszInfo);
	return S_OK;
}


/*----------------------------------------------------------------------------
    ISDClientUser::OutputWarning
	Called for warning messages (any text normally displayed in yellow by
	the SD.EXE client program).

	As of this writing, there is no list of the possible warning messages.

    Args:
	cIndent		- [in] indentation levels 0 - 2 (loosely implies
			  hierarchical relationship).  The SD.EXE client
			  program normally handles 1 by prepending "... " to
			  the string, and handles 2 by prepending "... ... ".
	pszWarning	- [in] warning message string.
	fEmptyReason	- [in] the message is an "empty reason" message.

    Rets:
	The return value is ignored.  For future compatibility, the method
	should return E_NOTIMPL if it is not implemented, or S_OK for success.

----------------------------------------------------------------------------*/
STDMETHODIMP ClientUser::OutputWarning( int cIndent,
					const char *pszWarning,
					BOOL fEmptyReason )
{
	if (s_fVerbose)
	    printf(cIndent ? "%s%d:\t" : "%s:\t",
		   fEmptyReason ? "empty" : "warn", cIndent);

	while (cIndent--)
	    printf("   ");

	printf("%s\n", pszWarning);
	return S_OK;
}


/*----------------------------------------------------------------------------
    ISDClientUser::OutputError
	Called for error messages, failed commands (any text normally
	displayed in red by the SD.EXE client program).

	As of this writing, there is no list of the possible error messages.

    Args:
	pszError	- [in] error message string.

    Rets:
	The return value is ignored.  For future compatibility, the method
	should return E_NOTIMPL if it is not implemented, or S_OK for success.

----------------------------------------------------------------------------*/
STDMETHODIMP ClientUser::OutputError( const char *pszError )
{
	if (s_fVerbose)
	    fprintf(stderr, "error:\t");
	fprintf(stderr, "%s", pszError);
	return S_OK;
}


/*----------------------------------------------------------------------------
    ISDClientUser::OutputStructured
	Called for tabular data if the ISDClientApi::Init call requested
	structured output and the command being run supports structured
	output.

	See the ISDVars interface in SDAPI.H for more information.

    Args:
	pVars		- [in] pointer to object containing the data; use the
			  provided accessor methods to retrieve the data.

    Rets:
	The return value is ignored.  For future compatibility, the method
	should return E_NOTIMPL if it is not implemented, or S_OK for success.

----------------------------------------------------------------------------*/
STDMETHODIMP ClientUser::OutputStructured( ISDVars *pVars )
{
	// your code here

	if (m_fDemo)
	{
	    // sample implementation -- illustrates how to use structured mode.

	    const char *pszChange;
	    const char *pszTime;
	    const char *pszUser;
	    const char *pszDesc;
	    //const char *pszClient;
	    //const char *pszStatus;
	    int nChange;
	    time_t ttTime;
	    tm tmTime;
	    char szDesc[32];

	    if (m_fFresh)
	    {
		printf("CHANGE  DATE----  TIME----  "
		       "USER----------------  DESC------------------------\n");
		m_fFresh = FALSE;
	    }

	    pVars->GetVar("change", &pszChange, 0, 0);
	    pVars->GetVar("time", &pszTime, 0, 0);
	    pVars->GetVar("user", &pszUser, 0, 0);
	    pVars->GetVar("desc", &pszDesc, 0, 0);
	    //pVars->GetVar("client", &pszClient, 0, 0);
	    //pVars->GetVar("status", &pszStatus, 0, 0);

	    nChange = atoi(pszChange);
	    ttTime = atoi(pszTime);
	    tmTime = *gmtime(&ttTime);

	    StringCchCopy(szDesc, DIMA(szDesc), pszDesc);
	    szDesc[sizeof(szDesc) - 1] = 0;
	    for (char *psz = szDesc; *psz; ++psz)
		if (*psz == '\r' || *psz == '\n')
		    *psz = ' ';

	    printf("%6d  %2d/%02d/%02d  %2d:%02d:%02d  %-20s  %.28s\n",
		   nChange,
		   tmTime.tm_mon, tmTime.tm_mday, tmTime.tm_year % 100,
		   tmTime.tm_hour, tmTime.tm_min, tmTime.tm_sec,
		   pszUser,
		   szDesc);
	}
	else
	{
	    // sample implementation -- merely dumps the variables; useful only
	    // for inspecting the output and learning the possible variables.

	    HRESULT hr;
	    const char *pszVar;
	    const char *pszValue;
	    BOOL fUnicode;
	    int ii;

	    for (ii = 0; 1; ii++)
	    {
		hr = pVars->GetVarByIndex(ii, &pszVar, &pszValue, 0, &fUnicode);
		if (hr != S_OK)
		    break;

		// output the variable name and value

		printf(fUnicode ? "%s[unicode]=%S\n" : "%s=%s\n", pszVar, pszValue);
	    }
	}
	return S_OK;
}


/*----------------------------------------------------------------------------
    ISDClientUser::Finished
	Called by ISDClientUser::Run when a command has finished.  The command
	may or may not have completed successfully.

	For example, this is where SD.EXE displays the auto-summary (see the
	-Y option in 'sd -?' for more information).

    Rets:
	The return value is ignored.  For future compatibility, the method
	should return E_NOTIMPL if it is not implemented, or S_OK for success.

----------------------------------------------------------------------------*/
STDMETHODIMP ClientUser::Finished()
{
	// your code here
	return S_OK;
}



// ---- ISDInputUser ------------------------------------------------------

ImplementEmbeddedUnknown(ClientUser, ISDInputUser)


/*----------------------------------------------------------------------------
    ISDClientUser::InputData
	Called to provide data to 'spec-command -i', where spec-command is
	branch, change, client, label, protect, user, etc.

    Args:
	pvarInput	- [in] pointer to VARIANT to contain input data.
			  NOTE: SD will convert the BSTR from codepage 1200
			  (Unicode) to CP_OEMCP (the OEM codepage).

    Rets:
	HRESULT		- return S_OK to indicate strInput contains the data.
			  return an error HRESULT code to indicate an error
			  has occurred.

----------------------------------------------------------------------------*/
STDMETHODIMP ClientUser::EISDInputUser::InputData( VARIANT* pvarInput )
{
	return E_NOTIMPL;
}


/*----------------------------------------------------------------------------
    ISDInputUser::Prompt
	Called to prompt the user for a response.  Called by 'resolve', and
	also when prompting the user to enter a password.

    Args:
	pszPrompt	- [in] prompt string.
	pvarResponse	- [in] pointer to VARIANT to contain user's response.
			  NOTE: SD will convert the BSTR from codepage 1200
			  (Unicode) to CP_OEMCP (the OEM codepage).
	fPassword	- [in] prompting for a password (hide the input text).

    Rets:
	HRESULT		- return S_OK to indicate pvarResponse contains the
			  user's response.  return an error HRESULT code to
			  indicate an error has occurred.

----------------------------------------------------------------------------*/
STDMETHODIMP ClientUser::EISDInputUser::Prompt( const char* pszPrompt, VARIANT* pvarResponse, BOOL fPassword )
{
	char sz[1024];

	if (fPassword)
	    return E_NOTIMPL;

	if (s_fVerbose)
	    printf("prompt:\t");

	printf("%s", pszPrompt);

	fflush(stdout);
	fflush(stdin);

	fgets(sz, sizeof(sz), stdin);

	return VariantSet(pvarResponse, sz);
}


/*----------------------------------------------------------------------------
    ISDInputUser::PromptYesNo
	Called to prompt the user for a yes/no response.
	Currently only called by 'resolve'.

    Args:
	pszPrompt	- [in] prompt string.

    Rets:
	HRESULT		- return S_OK for Yes.  return S_FALSE for No.  return
			  E_NOTIMPL to allow the SDAPI to perform the default
			  behavior, which is to call ISDClientUser::Prompt and
			  loop until the user responds y/Y/n/N or an error
			  occurs.  return other error HRESULT codes to
			  indicate an error has occurred.

----------------------------------------------------------------------------*/
STDMETHODIMP ClientUser::EISDInputUser::PromptYesNo( const char* pszPrompt )
{
	return E_NOTIMPL;
}


/*----------------------------------------------------------------------------
    ISDInputUser::ErrorPause
	Called to display an error message and wait for the user before
	continuing.

    Args:
	pszError	- [in] message string.

    Rets:
	HRESULT		- return S_OK to continue.  return an error HRESULT
			  code to indicate an error has occurred.

----------------------------------------------------------------------------*/
STDMETHODIMP ClientUser::EISDInputUser::ErrorPause( const char* pszError )
{
	EMBEDDEDTHIS(ClientUser, ISDInputUser);

	char sz[1024];

	pThis->OutputError(pszError);

	printf("prompt:\tHit return to continue...");
	fgets(sz, sizeof(sz), stdin);

	return S_OK;
}



// ---- ISDActionUser -----------------------------------------------------

ImplementEmbeddedUnknown(ClientUser, ISDActionUser)


/*----------------------------------------------------------------------------
    ISDActionUser::Diff
	Called by 'resolve' when the user selects any of the 'd' (diff)
	actions.  Also called by 'diff'.

	In particular, this is not called by 'diff2' because the server
	computes the diff and sends the computed diff to the client.

    Args:
	pszDiffCmd	- [in] may be NULL.  user-defined command to launch
			  external diff engine, as defined by the SDDIFF or
			  SDUDIFF variables; see 'sd help variables' for more
			  information.
	pszLeft		- [in] name of Left file for the diff.
	pszRight	- [in] name of Right file for the diff.
	eTextual	- [in] indicates the lowest common denominator file
			  type for the 2 input files (non-textual, text, or
			  Unicode).
	pszFlags	- [in] flags for the diff engine (per the -d<flags>
			  option).
	pszPaginateCmd	- [in] may be NULL.  user-defined command to pipe the
			  diff output through, as defined by the SDPAGER
			  variable; see 'sd help variables' for more info.
			  For example, "more.exe".

    Rets:
	HRESULT		- return S_OK to indicate the diff has been performed
			  successfully.  return E_NOTIMPL to allow the SDAPI
			  to perform the default behavior, which is to launch
			  an external diff engine (if defined) or use use the
			  internal SD diff engine.  return other error HRESULT
			  codes to indicate an error has occurred.

----------------------------------------------------------------------------*/
STDMETHODIMP ClientUser::EISDActionUser::Diff( const char *pszDiffCmd,
					       const char *pszLeft,
					       const char *pszRight,
					       DWORD eTextual,
					       const char *pszFlags,
					       const char *pszPaginateCmd )
{
	return E_NOTIMPL;
}


/*----------------------------------------------------------------------------
    ISDActionUser::EditForm
	Called by all commands that launch a user form (e.g. 'branch',
	'change', 'client', etc).

    IMPORTANT NOTE:
	This command is synchronous in nature; if your implementation launches
	an editor, your code must not return until the user has finished
	editing the file.

    Args:
	pszEditCmd	- [in] may by NULL.  user-defined command to launch
			  external editor, as defined by the SDFORMEDITOR
			  variable; see 'sd help variables' for more
			  information.
	pszFile		- [in] name of file to edit.

    Rets:
	HRESULT		- return S_OK to indicate the user has finished
			  editing the file.  return E_NOTIMPL to allow the
			  SDAPI to perform the default behavior, which is to
			  launch an external editor engine (if defined) or to
			  launch notepad.exe.  return other error HRESULT
			  codes to indicate an error has occurred.

----------------------------------------------------------------------------*/
STDMETHODIMP ClientUser::EISDActionUser::EditForm( const char *pszEditCmd,
						   const char *pszFile )
{
	return E_NOTIMPL;
}


/*----------------------------------------------------------------------------
    ISDActionUser::EditFile
	Called by 'resolve' when the user selects any of the 'e' actions.

    IMPORTANT NOTE:
	This command is synchronous in nature; if your implementation launches
	an editor, your code must not return until the user has finished
	editing the file.

    Args:
	pszEditCmd	- [in] may by NULL.  user-defined command to launch
			  external editor, as defined by the SDEDITOR, or
			  SDUEDITOR variables; see 'sd help variables' for
			  more information.
	pszFile		- [in] name of file to edit.
	eTextual	- [in] indicates the file type (non-textual, text, or
			  Unicode).

    Rets:
	HRESULT		- return S_OK to indicate the user has finished
			  editing the file.  return E_NOTIMPL to allow the
			  SDAPI to perform the default behavior, which is to
			  launch an external editor engine (if defined) or to
			  launch notepad.exe.  return other error HRESULT
			  codes to indicate an error has occurred.

----------------------------------------------------------------------------*/
STDMETHODIMP ClientUser::EISDActionUser::EditFile( const char *pszEditCmd,
						   const char *pszFile,
						   DWORD eTextual )
{
	return E_NOTIMPL;
}


/*----------------------------------------------------------------------------
    ISDActionUser::Merge
	Called by the 'resolve' command when the user selects the 'm' action
	to invoke an external merge engine.

    Args:
	pszMergeCmd	- [in] may be NULL.  user-defined command to launch
			  external merge engine, as defined by the SDMERGE
			  variable; see 'sd help variables' for more info.
	pszBase		- [in] name of Base file for the 3-way merge.
	pszTheirs	- [in] name of Theirs file for the 3-way merge.
	pszYours	- [in] name of Yours file for the 3-way merge.
	pszResult	- [in] name of file where the resulting merged file
			  must be written.
	eTextual	- [in] indicates the lowest common denominator file
			  type for the 3 input files (non-textual, text, or
			  Unicode).

    Rets:
	HRESULT		- return S_OK to indicate the merge has been performed
			  successfully.  return E_NOTIMPL to allow the SDAPI
			  to perform the default behavior, which is to launch
			  the external merge engine (if defined).  return
			  other error HRESULT codes to indicate an error has
			  occurred.

----------------------------------------------------------------------------*/
STDMETHODIMP ClientUser::EISDActionUser::Merge( const char *pszMergeCmd,
						const char *pszBase,
						const char *pszTheirs,
						const char *pszYours,
						const char *pszResult,
						DWORD eTextual )
{
	return E_NOTIMPL;
}



///////////////////////////////////////////////////////////////////////////
// Console Mode

HANDLE g_hRestoreConsole = INVALID_HANDLE_VALUE;
DWORD g_dwResetConsoleMode;


void RestoreConsole_SetMode(DWORD dw)
{
	g_hRestoreConsole = GetStdHandle(STD_OUTPUT_HANDLE);
	g_dwResetConsoleMode = SetConsoleMode(g_hRestoreConsole, dw);
}


BOOL WINAPI RestoreConsole_BreakHandler(DWORD dwCtrlType)
{
	if (g_hRestoreConsole != INVALID_HANDLE_VALUE)
	    SetConsoleMode(g_hRestoreConsole, g_dwResetConsoleMode);
#if 0
	if (g_hRestoreConsole != INVALID_HANDLE_VALUE)
	    SetConsoleTextAttribute(g_hRestoreConsole, g_wRestoreAttr);
#endif
	return FALSE;
}



///////////////////////////////////////////////////////////////////////////
// Options (a dumbed-down option parsing class)

enum { c_cMaxOptions = 20 };


enum OptFlag
{
	// bitwise selectors
	OPT_ONE		= 0x01,		// exactly one
	OPT_TWO		= 0x02,		// exactly two
	OPT_THREE	= 0x04,		// exactly three
	OPT_MORE	= 0x10,		// more than three
	OPT_NONE	= 0x20,		// require none

	// combos of the above
	OPT_OPT		= OPT_NONE|OPT_ONE,
	OPT_ANY		= OPT_NONE|OPT_ONE|OPT_TWO|OPT_THREE|OPT_MORE,
	OPT_SOME	= OPT_ONE|OPT_TWO|OPT_THREE|OPT_MORE,
};


class Options
{
    public:
			Options() { m_cOpts = 0; m_pszError = 0; }
			~Options() { delete m_pszError; }

	BOOL		Parse(int &argc, const char **&argv, const char *pszOpts,
			      int flag, const char *pszUsage);
	const char*	GetErrorString() const { Assert(m_pszError); return m_pszError; }

	const char*	GetValue(char chOpt, int iSubOpt) const;
	const char*	operator[](char chOpt) const { return GetValue(chOpt, 0); }

    protected:
	void		ClearError() { delete m_pszError; m_pszError = 0; }
	void		SetError(const char *pszUsage, const char *pszFormat, ...);

    private:
	int		m_cOpts;
	char		m_rgchFlags[c_cMaxOptions];
	const char*	m_rgpszOpts[c_cMaxOptions];

	char*		m_pszError;
};


static const char *GetArg(const char *psz, int &argc, const char **&argv)
{
	psz++;

	if (*psz)
	    return psz;

	if (!argc)
	    return 0;

	argc--;
	argv++;
	return argv[0];
}


BOOL Options::Parse(int &argc, const char **&argv, const char *pszOpts,
		    int flag, const char *pszUsage)
{
	BOOL fSlash;			// allow both - and /
	const char *psz;
	const char *pszArg;

	Assert(pszOpts);
	Assert(pszUsage);

	ClearError();

	fSlash = (*pszOpts == '/');
	if (fSlash)
	    pszOpts++;

	// parse flags
	while (argc)
	{
	    if (argv[0][0] != '-' && (!fSlash || argv[0][0] != '/'))
		break;			// not a flag, so done parsing

	    if (argv[0][1] == '-')
	    {
		// '--' is special and means that subsequent arguments should
		// not be treated as flags even if they being with '-'.
		argc--;
		argv++;
		break;
	    }

	    pszArg = argv[0];

	    while (TRUE)
	    {
		pszArg++;		// skip the '-' or option character
		if (!*pszArg)
		    break;

#ifdef DEBUG
		if (*pszArg == '!')
		{
		    DebugBreak();
		    continue;
		}
#endif

		psz = pszOpts;
		while (*psz && *psz != *pszArg)
		    psz++;

		if (!*psz)
		{
		    SetError(pszUsage, "Invalid option: '%c'.", *pszArg);
		    return FALSE;
		}

		if (m_cOpts >= c_cMaxOptions)
		{
		    SetError(pszUsage, "Too many options.");
		    return FALSE;
		}

		m_rgchFlags[m_cOpts] = *pszArg;
		m_rgpszOpts[m_cOpts] = "true";

		if (psz[1] == '.')
		{
		    m_rgpszOpts[m_cOpts++] = pszArg + 1;
		    break;
		}
		else if (psz[1] == ':')
		{
		    psz = GetArg(pszArg, argc, argv);
		    if (!psz)
		    {
			SetError(pszUsage, "Option '%c' missing required argument.", *pszArg);
			return FALSE;
		    }
		    m_rgpszOpts[m_cOpts++] = psz;
		    break;
		}

		m_cOpts++;
	    }

	    argc--;
	    argv++;
	}

	// check number of arguments
	if (!((argc == 0 && (flag & OPT_NONE)) ||
	      (argc == 1 && (flag & OPT_ONE)) ||
	      (argc == 2 && (flag & OPT_TWO)) ||
	      (argc == 3 && (flag & OPT_THREE)) ||
	      (argc > 3 && (flag & OPT_MORE))))
	{
	    SetError(pszUsage, "Missing/wrong number of arguments.");
	    return FALSE;
	}

	return TRUE;
}


void Options::SetError(const char *pszUsage, const char *pszFormat, ...)
{
	int cch;

	va_list args;
	va_start(args, pszFormat);

	ClearError();
	m_pszError = new char[1024];	//$ todo: (chrisant) BUFFER OVERRUN
	StringCchPrintf(m_pszError, 1024, "Usage: %s\n", pszUsage);
    cch = strlen(m_pszError);
    StringCchVPrintfEx(m_pszError + cch,
                       1024 - cch,
                       NULL,
                       NULL,
                       0,
                       pszFormat,
                       args);

	va_end(args);
}


const char *Options::GetValue(char chOpt, int iSubOpt) const
{
	for (int ii = m_cOpts; ii--;)
	    if (chOpt == m_rgchFlags[ii])
		if (iSubOpt-- == 0)
		    return m_rgpszOpts[ii];
	return 0;
}



///////////////////////////////////////////////////////////////////////////
// RunCmd

static void PrintError(HRESULT hr)
{
	char sz[1024];
	int cch;

	cch = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM|FORMAT_MESSAGE_IGNORE_INSERTS,
			    0, hr, MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
			    sz, sizeof(sz), NULL);
	sz[cch] = 0;
	fprintf(stderr, "error:  (0x%08.8x)\n%s", hr, sz);
}


static BOOL FStrPrefixCut(const char *pszPrefix, const char **ppsz)
{
	int cch = strlen(pszPrefix);
	BOOL fPrefix = (strncmp(*ppsz, pszPrefix, cch) == 0 && (!(*ppsz)[cch] || isspace((*ppsz)[cch])));
	if (fPrefix)
	{
	    *ppsz += cch;
	    while (isspace(**ppsz))
		(*ppsz)++;
	}
	return fPrefix;
}


HRESULT Cmd_Detect(ISDClientApi *papi, const char *psz)
{
	HRESULT hr = S_OK;
	ISDClientUtilities *putil;
	BOOL fServer = FALSE;

	// check for -s flag, to detect based on the server's capabilities
	if (FStrPrefixCut("-s", &psz))
	    fServer = TRUE;

	// check for file argument
	if (*psz && *psz != '-')
	{
	    hr = papi->QueryInterface(IID_ISDClientUtilities, (void**)&putil);
	    if (SUCCEEDED(hr))
	    {
		DWORD tt;
		const char *pszType;

		// detect file type
		hr = putil->DetectType(psz, &tt, &pszType, fServer);

		if (SUCCEEDED(hr))
		{
		    if (pszType)
		    {
			const char *pszTT;
			switch (tt)
			{
			default:
			case SDTT_NONTEXT:	pszTT = "SDT_NONTEXT"; break;
			case SDTT_TEXT:		pszTT = "SDT_TEXT"; break;
			case SDTT_UNICODE:	pszTT = "SDT_UNICODE"; break;
			}
			printf("%s - %s (%s)\n", psz, pszType, pszTT);
		    }
		    else
		    {
			printf("%s - unable to determine file type.\n", psz);
		    }
		}
		else
		{
		    PrintError(hr);
		}

		putil->Release();
	    }
	}
	else
	{
	    fprintf(stderr, "Usage: detect [-s] file\n\n"
		    "The -s flag set the fServer parameter to TRUE in the DetectType call.\n"
		    "Please refer to the SDAPI documentation for more information.\n");
	}

	return hr;
}


HRESULT Cmd_Set(ISDClientApi *papi, const char *psz)
{
	HRESULT hr = S_OK;
	ISDClientUtilities *putil;
	char szVar[64];
	char szService[64];
	const char *pszValue;

	szVar[0] = 0;
	szService[0] = 0;

	// check for the "-S servicename" optional flag
	if (FStrPrefixCut("-S", &psz))
	{
	    pszValue = psz;
	    while (*pszValue && !isspace(*pszValue))
		pszValue++;

	    lstrcpyn(szService, psz, min(pszValue - psz + 1, sizeof(szService)));

	    psz = pszValue;
	    while (isspace(*psz))
		psz++;
	}

	// find the end of the variable name
	pszValue = strpbrk(psz, "= \t");
	if (*psz && *psz != '-' && pszValue && *pszValue == '=')
	{
	    // copy the variable name
	    lstrcpyn(szVar, psz, min(pszValue - psz + 1, sizeof(szVar)));
	    pszValue++;

	    hr = papi->QueryInterface(IID_ISDClientUtilities, (void**)&putil);
	    if (SUCCEEDED(hr))
	    {
		// set the variable and value
		hr = putil->Set(szVar, pszValue, FALSE, szService);

		if (FAILED(hr))
		{
		    PrintError(hr);
		}

		putil->Release();
	    }
	}
	else
	{
	    fprintf(stderr, "Usage: set [-S service] var=[value]\n");
	}

	return hr;
}


HRESULT Cmd_Query(ISDClientApi *papi, const char *psz)
{
	HRESULT hr = S_OK;
	ISDClientUtilities *putil;
	char szService[64];
	const char *pszValue;

	szService[0] = 0;

	// check for the "-S servicename" optional flag
	if (FStrPrefixCut("-S", &psz))
	{
	    pszValue = psz;
	    while (*pszValue && !isspace(*pszValue))
		pszValue++;

	    lstrcpyn(szService, psz, min(pszValue - psz + 1, sizeof(szService)));

	    psz = pszValue;
	    while (isspace(*psz))
		psz++;
	}

	// find the end of the (optional) variable name
	pszValue = strpbrk(psz, "= \t");
	if (*psz == '-' || pszValue)
	{
	    fprintf(stderr, "Usage: query [-S service] [var]\n");
	    return S_OK;
	}

	hr = papi->QueryInterface(IID_ISDClientUtilities, (void**)&putil);
	if (SUCCEEDED(hr))
	{
	    ISDVars *pVars;

	    hr = putil->QuerySettings(psz, szService, &pVars);

	    if (SUCCEEDED(hr))
	    {
		int ii;

		for (ii = 0; 1; ii++)
		{
		    const char *pszVar;
		    const char *pszValue;
		    const char *pszHow;
		    const char *pszType;

		    if (pVars->GetVarX("var", ii, &pszVar, 0, 0) != S_OK)
			break;
		    pVars->GetVarX("value", ii, &pszValue, 0, 0);
		    pVars->GetVarX("how", ii, &pszHow, 0, 0);
		    pVars->GetVarX("type", ii, &pszType, 0, 0);

		    printf("%s=%s (%s)", pszVar, pszValue, pszHow);
		    if (strcmp(pszType, "env") != 0)
			printf(" (%s)", pszType);
		    printf("\n");
		}

		pVars->Release();
	    }
	    else
	    {
		PrintError(hr);
	    }

	    putil->Release();
	}

	return hr;
}


HRESULT RunCmd(ISDClientApi *papi, const char *psz, int argc, const char **argv, ClientUser *pui, BOOL fStructured)
{
	BOOL fDemo = FALSE;
	DWORD dwTicks;
	HRESULT hr = S_OK;
	char *pszFree = 0;

	dbgPrintF("\nRUN:\t[%s]\n", psz);
	dwTicks = GetTickCount();

	if (FStrPrefixCut("detect", &psz))
	{
	    hr = Cmd_Detect(papi, psz);
	}
	else if (FStrPrefixCut("set", &psz))
	{
	    hr = Cmd_Set(papi, psz);
	}
	else if (FStrPrefixCut("query", &psz))
	{
	    hr = Cmd_Query(papi, psz);
	}
	else
	{
	    if (FStrPrefixCut("demo", &psz))
	    {
		// demo mode
		fDemo = TRUE;
		fStructured = TRUE;

		// alloc string (length of command string, plus "changes ")
		pszFree = (char*)malloc(lstrlen(psz) + 8 + 1);

		// format string
        StringCchPrintf(pszFree, lstrlen(psz) + 8 + 1, "changes %s", psz);

		// use the formatted string
		psz = pszFree;
	    }

	    pui->SetDemo(fDemo);

	    if (argc && argv)
		papi->SetArgv(argc, argv);

	    hr = papi->Run(psz, pui, fStructured);
	}

	dwTicks = GetTickCount() - dwTicks;
	dbgPrintF("[took %dms to run command]\n", dwTicks);

	free(pszFree);

	return hr;
}



///////////////////////////////////////////////////////////////////////////
// main

int __cdecl main(int argc, const char **argv)
{
	ClientUser *pui = 0;
	SPAPI spapi;
	const char *pszFile = 0;
#if 0
	BOOL fCreate = FALSE;
#endif
	BOOL fDemo = FALSE;
	BOOL fStructured = FALSE;
	BOOL fStdin = FALSE;
	int nRet = 0;
	DWORD dwTicks;
	HRESULT hr;

	SetConsoleCtrlHandler(RestoreConsole_BreakHandler, TRUE);

	if (argc)
	{
	    // skip app name
	    argc--;
	    argv++;

	    if (argc && !strcmp(argv[0], "-!"))
	    {
		argc--;
		argv++;
		DebugBreak();
	    }

#if 0
	    if (argc && !strcmp(argv[0], "-C"))
	    {
		argc--;
		argv++;
		fCreate = TRUE;
	    }
#endif
	}

#ifdef DEBUG
	{
	    int n = argc;
	    const char **pp = argv;

	    printf("argc = %d\n", n);
	    for (int i = 0; i < n; i++)
	    {
		printf("%d:\t[%s]\n", i, pp[0]);
		pp++;
	    }
	}
#endif

	// parse options

	Options opts;
	const char *s;

	if (!opts.Parse(argc, argv, "?p:u:P:c:H:i:I:x:dvT", OPT_OPT, usage))
	{
	    fprintf(stderr, "%s", opts.GetErrorString());
	    return 1;
	}

	if (opts['?'])
	{
	    // full usage text
	    printf("%s", long_usage);
	    return 0;
	}

	if (opts['d'])		s_fDbg = TRUE;
	if (opts['v'])		s_fVerbose = TRUE;
	if (opts['T'])		fStructured = TRUE;

	if (pszFile = opts['x'])
	{
	    fStdin = FALSE;
	    if (strcmp(pszFile, "-") == 0)
	    {
		pszFile = 0;
		fStdin = TRUE;
	    }
	}

	// create SDAPI object

#if 1
    hr = CreateSDAPIObject(CLSID_SDAPI, (void**)&spapi);
#else
	hr = CoInitialize(0);
	if (SUCCEEDED(hr))
	{
	    hr = CoCreateInstance(CLSID_SDAPI, NULL, CLSCTX_INPROC_SERVER,
				      IID_ISDClientApi, (void**)&spapi);
	}
#endif

	if (FAILED(hr))
	{
	    fprintf(stderr, "ERROR:\tunable to create SDAPI object (0x%08x).\n", hr);
	    return 1;
	}

	// initialize the SDAPI object based on the options

	if (s = opts['I'])	spapi->LoadIniFile(s, TRUE);
	if (s = opts['i'])	spapi->LoadIniFile(s, FALSE);

	if (s = opts['p'])	spapi->SetPort(s);
	if (s = opts['u'])	spapi->SetUser(s);
	if (s = opts['P'])	spapi->SetPassword(s);
	if (s = opts['c'])	spapi->SetClient(s);
	if (s = opts['H'])	spapi->SetHost(s);

	pui = new ClientUser;
	if (!pui)
	{
	    fprintf(stderr, "ERROR:\tunable to allocate ClientUser.\n");
	    return 1;
	}

	// connect to server

	dbgPrintF("\nINIT:\tconnect to server\n");
	dwTicks = GetTickCount();

	hr = spapi->Init(pui);

	dwTicks = GetTickCount() - dwTicks;
	dbgPrintF("[took %dms to connect and authenticate]\n\n", dwTicks);
	if (FAILED(hr))
	    goto LFatal;

	// detect server version

	SDVERINFO ver;
	ver.dwSize = sizeof(ver);
	if (spapi->GetVersion(&ver) == S_OK)
	{
	    dbgPrintF("SDAPI:\t[%d.%d.%d.%d]\n",
		      ver.nApiMajor, ver.nApiMinor, ver.nApiBuild, ver.nApiDot);

	    if (ver.nSrvMajor || ver.nSrvMinor || ver.nSrvBuild || ver.nSrvDot)
	    {
		dbgPrintF("SERVER:\t[%d.%d.%d.%d]\n",
			  ver.nSrvMajor, ver.nSrvMinor, ver.nSrvBuild, ver.nSrvDot);
	    }
	}
	else
	{
	    dbgPrintF("SDAPI:\t[unknown build]\n");
	    dbgPrintF("SERVER:\t[unknown build]\n");
	}

	// run commands from file

	if (pszFile || fStdin)
	{
	    FILE *pfile = 0;
	    FILE *pfileClose = 0;
	    char sz[4096];

	    if (pszFile)
	    {
		pfileClose = fopen(pszFile, "rt");
		pfile = pfileClose;
	    }
	    else
	    {
		pfile = stdin;
		RestoreConsole_SetMode(ENABLE_LINE_INPUT|ENABLE_ECHO_INPUT|ENABLE_PROCESSED_INPUT);
	    }

	    if (pfile)
	    {
		while (fgets(sz, sizeof(sz), pfile))
		{
		    int cch = strlen(sz);
		    if (!cch)
			continue;

		    // trim linefeeds
		    cch--;
		    while (sz[cch] == '\r' || sz[cch] == '\n')
		    {
			sz[cch] = 0;
			cch--;
		    }
		    cch++;

		    if (!cch)
			continue;

		    // sleep
		    int cSleep = atoi(sz);
		    if (cSleep >= 0)
			Sleep(cSleep * 1000);

		    // get command line
		    const char *psz = strchr(sz, ',');
		    if (psz)
			psz++;
		    else
			psz = sz;

		    // run command
		    hr = RunCmd(spapi, psz, 0, 0, pui, fStructured);
		    if (FAILED(hr))
		    {
			const char *pszError = 0;
			if (SUCCEEDED(spapi->GetErrorString(&pszError)) && pszError)
			    fprintf(stderr, "error:\n%s\n", pszError);
		    }
		}
	    }

	    if (pfileClose)
		fclose(pfileClose);
	}

	// run command from command line

	if (argc)
	{
	    hr = RunCmd(spapi, argv[0], argc - 1, argv + 1, pui, fStructured);
	    if (FAILED(hr))
		goto LFatal;
	}

	// final

LOut:
	pui->Release();
	if (spapi)
	    nRet = FAILED(spapi->Final()) || nRet;
	return nRet;

LFatal:
	if (spapi)
	{
	    const char *pszError = 0;
	    if (SUCCEEDED(spapi->GetErrorString(&pszError)) && pszError)
		fprintf(stderr, "error:\n%s\n", pszError);
	}
	nRet = 1;
	goto LOut;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\sdktools\debuggers\snapshot\snapshot.cpp ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    snapshot.cpp

Abstract:

    This module implements snapshot.dll which will be called
    by user32 at unplanned shutdown to take a snapshot of the
    system hardware, OS, and process information.

Author:

    Qingbo Zhao (qingboz) 01-Feb-2001

Revision History:

    JeffMeng    Dec-03-2001
    Swethan    Jul-31-2002      Added pool information

--*/
#define UNICODE
#define _UNICODE
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h> 
#include <wtypes.h>
#include <mountmgr.h>
#include <winioctl.h>
#include <ntddvol.h>
#include <ntddscsi.h>
#include <stdio.h>
#include <stdlib.h>
#include <stddef.h>
#include <tchar.h>
#include <rpcdce.h>

#define _stnprintf _snwprintf
#define _tsizeof(X) (sizeof(X) / sizeof(*X))
#define BUFFER_SIZE 64*1024*sizeof(TCHAR)
#define MIN_BUFFER_SIZE 1024*sizeof(TCHAR)
#define MAX_BUFFER_SIZE 10*1024*1024*sizeof(TCHAR)
#define MAXSTR 4*1024
#define DEFAULT_HISTORYFILES 10
#define MAX_HISTORYFILES 365
#define DEFAULT_TIMEOUT 30
#define MIN_TIMEOUT 2
#define MAX_TIMEOUT 10 * 60
#define NUM_OF_CHAR_IN_ULONG64      30
#define ReliabilityKey  L"\\Registry\\Machine\\Software\\Microsoft\\Windows\\CurrentVersion\\Reliability"

#define SCHEMA_VERSION_STRING   L"1.0"
//
// the amount of memory to increase the size
// of the buffer for NtQuerySystemInformation at each step
//
#define BUFFER_SIZE_STEP    65536


void 
WriteToLogFileW(
    HANDLE hFile,
    LPCWSTR lpwszInput
    );

void 
WriteToLogFileA(
    HANDLE hFile,
    LPCSTR lpszInput
    );

void 
WriteToLogFile(
    HANDLE hFile,
    LPCTSTR lpszInput
    );

//
//    Tag enum for XML output.
//
enum XMLTAG
{
    XMLTAG_SETSystemStateData = 0,
    XMLTAG_SETDataType_Header,
    XMLTAG_SETDataType_PageFiles,
    XMLTAG_SETDataType_Memory,
    XMLTAG_SETDataType_PoolInfo,

    XMLTAG_Memory_PhysicalMemory,
    XMLTAG_Memory_CommittedMemory,
    XMLTAG_Memory_KernelMemory,
    XMLTAG_Memory_Pool,
    XMLTAG_Memory_PageFiles,
    XMLTAG_Memory_memory,

    XMLTAG_SETDataType_ExtensionDLL,
    XMLTAG_SETDataType_ProcessSummaries,
    XMLTAG_SETDataType_ProcessStartInfo,
    XMLTAG_SETDataType_ProcessesThreadInfo,
    XMLTAG_SETDataType_ProcessesModuleInfo,
    XMLTAG_SETDataType_KernelModuleInfo,
    XMLTAG_SETDataType_OSInfo,
    XMLTAG_SETDataType_HardwareInfo,

    XMLTAG_HeaderType_ReliabilityGuid,
    XMLTAG_HeaderType_SystemName,
    XMLTAG_HeaderType_UserName,
    XMLTAG_HeaderType_ReasonTitle,
    XMLTAG_HeaderType_ReasonDescription,
    XMLTAG_HeaderType_InitiatingProcess,
    XMLTAG_HeaderType_RestartDate,
    XMLTAG_HeaderType_RestartTime,
    XMLTAG_HeaderType_ReasonCode,
    XMLTAG_HeaderType_RestartType,
    XMLTAG_HeaderType_Comment,
    XMLTAG_HeaderType_SystemUptime,
    XMLTAG_HeaderType_UserLanguageID,
    XMLTAG_HeaderType_SystemLanguageID,
    XMLTAG_HeaderType_SchemaVersion,

    XMLTAG_PageFileType_PageFile,
    XMLTAG_PageFileType_Path,
    XMLTAG_PageFileType_CurrentSize,
    XMLTAG_PageFileType_Total,
    XMLTAG_PageFileType_Peak,
    XMLTAG_PhysicalMemoryType_Total,
    XMLTAG_PhysicalMemoryType_Available,
    XMLTAG_WorkingSetType_WorkingSet,
    XMLTAG_CommittedMemoryType_Total,
    XMLTAG_CommittedMemoryType_UserMode,
    XMLTAG_CommittedMemoryType_Limit,
    XMLTAG_CommittedMemoryType_Peak,
    XMLTAG_KernelMemoryType_Nonpaged,
    XMLTAG_KernelMemoryType_Paged,
    XMLTAG_PoolType_Nonpaged,
    XMLTAG_PoolType_Paged,
    XMLTAG_PageFilesType_PageFile,
    XMLTAG_memoryType_PhysicalMemory,
    XMLTAG_memoryType_WorkingSet,
    XMLTAG_memoryType_KernelMemory,
    XMLTAG_memoryType_CommittedMemory,
    XMLTAG_memoryType_Pool,

    XMLTAG_PoolInfo_AllocInformation,
    XMLTAG_PoolInfo_TagEntry,
    XMLTAG_PoolInfo_TagEntry_PoolTag,
    XMLTAG_PoolInfo_TagEntry_PoolType,
    XMLTAG_PoolInfo_TagEntry_NumAllocs,
    XMLTAG_PoolInfo_TagEntry_NumFrees,
    XMLTAG_PoolInfo_TagEntry_NumBytes,
    XMLTAG_PoolInfo_TagEntry_SessionID,

    XMLTAG_ProcessSummaryType_Process,
    XMLTAG_ProcessSummaryType_PID,
    XMLTAG_ProcessSummaryType_Name,
    XMLTAG_ProcessSummaryType_UserTime,
    XMLTAG_ProcessSummaryType_KernelTime,
    XMLTAG_ProcessSummaryType_WorkingSet,
    XMLTAG_ProcessSummaryType_PageFaults,
    XMLTAG_ProcessSummaryType_CommittedBytes,
    XMLTAG_ProcessSummaryType_Priority,
    XMLTAG_ProcessSummaryType_HandleCount,
    XMLTAG_ProcessSummaryType_ThreadCount,

    XMLTAG_ProcessStartInfoType_Process,
    XMLTAG_ProcessStartInfoType_PID,
    XMLTAG_ProcessStartInfoType_ImageName,
    XMLTAG_ProcessStartInfoType_CmdLine,
    XMLTAG_ProcessStartInfoType_CurrentDir,

    XMLTAG_ProcessThreadInfoType_Process,
    XMLTAG_ProcessThreadInfoType_PID,
    XMLTAG_ProcessThreadInfoType_Thread,
    XMLTAG_ProcessThreadInfoType_TID,
    XMLTAG_ProcessThreadInfoType_Priority,
    XMLTAG_ProcessThreadInfoType_ContextSwitches,
    XMLTAG_ProcessThreadInfoType_StartAddress,
    XMLTAG_ProcessThreadInfoType_UserTime,
    XMLTAG_ProcessThreadInfoType_KernelTime,
    XMLTAG_ProcessThreadInfoType_State,

    XMLTAG_ProcessModuleInfoType_Process,
    XMLTAG_ProcessModuleInfoType_PID,
    XMLTAG_ProcessModuleInfoType_Module,
    XMLTAG_ProcessModuleInfoType_LoadAddr,
    XMLTAG_ProcessModuleInfoType_ImageSize,
    XMLTAG_ProcessModuleInfoType_EntryPoint,
    XMLTAG_ProcessModuleInfoType_FileName,

    XMLTAG_KernelModuleInfoType_Module,
    XMLTAG_KernelModuleInfoType_ModuleName,
    XMLTAG_KernelModuleInfoType_LoadAddress,
    XMLTAG_KernelModuleInfoType_Code,
    XMLTAG_KernelModuleInfoType_Data,
    XMLTAG_KernelModuleInfoType_Paged,
    XMLTAG_KernelModuleInfoType_Date,
    XMLTAG_KernelModuleInfoType_Time,

    XMLTAG_KernelModuleInfoType_TotalCode,
    XMLTAG_KernelModuleInfoType_TotalData,
    XMLTAG_KernelModuleInfoType_TotalPaged,

    XMLTAG_OSInfoType_CurrentBuild,
    XMLTAG_OSInfoType_CurrentType,
    XMLTAG_OSInfoType_CurrentVersion,
    XMLTAG_OSInfoType_Path,
    XMLTAG_OSInfoType_ProductName,
    XMLTAG_OSInfoType_SoftwareType,
    XMLTAG_OSInfoType_SourcePath,
    XMLTAG_OSInfoType_SystemRoot,
    XMLTAG_OSInfoType_CSDVersion,
    XMLTAG_OSInfoType_DebuggerEnabled,
    XMLTAG_OSInfoType_Hotfix,
    XMLTAG_HardwareInfoType_BiosInfo,
    XMLTAG_HardwareInfoType_ProcesorInfo,
    XMLTAG_HardwareInfoType_NICInfo,
    XMLTAG_HardwareInfoType_DiskInfo,
    XMLTAG_BiosInfoType_Identifier,
    XMLTAG_BiosInfoType_SystemBiosDate,
    XMLTAG_BiosInfoType_SystemBiosVersion,
    XMLTAG_BiosInfoType_VideoBiosDate,
    XMLTAG_BiosInfoType_VideoBiosVersion,
    XMLTAG_ProcessorInfoType_Processor,
    XMLTAG_ProcessorInfoType_Number,
    XMLTAG_ProcessorInfoType_Speed,
    XMLTAG_ProcessorInfoType_Identifier,
    XMLTAG_ProcessorInfoType_VendorIdent,
    XMLTAG_NICInfoType_NIC,
    XMLTAG_NICInfoType_Description,
    XMLTAG_NICInfoType_ServiceName,

    XMLTAG_DiskInfoType_PhysicalInfo,
    XMLTAG_DiskInfoType_PartitionByDiskInfo,
    XMLTAG_DiskInfoType_LogicalDrives,

    XMLTAG_PhysicalInfoType_Disk,                //physical
    XMLTAG_PhysicalInfoType_ID,
    XMLTAG_PhysicalInfoType_BytesPerSector,
    XMLTAG_PhysicalInfoType_SectorsPerTrack,
    XMLTAG_PhysicalInfoType_TracksPerCylinder,
    XMLTAG_PhysicalInfoType_NumberOfCylinders,
    XMLTAG_PhysicalInfoType_PortNumber,
    XMLTAG_PhysicalInfoType_PathID,
    XMLTAG_PhysicalInfoType_TargetID,
    XMLTAG_PhysicalInfoType_LUN,
    XMLTAG_PhysicalInfoType_Manufacturer,

    XMLTAG_PartitionByDiskInfoType_Disk,        //logical    
    XMLTAG_PartitionByDiskInfoType_DiskID,        
    XMLTAG_PartitionByDiskInfoType_Partitions,
    XMLTAG_PartitionByDiskInfoType_PartitionInfo,
    XMLTAG_PartitionInfoType_PartitionID,
    XMLTAG_PartitionInfoType_Extents,    
    XMLTAG_PartitionInfoType_ExtentInfo,
    XMLTAG_ExtentInfoType_ID,
    XMLTAG_ExtentInfoType_StartingOffset,
    XMLTAG_ExtentInfoType_PartitionSize,

    XMLTAG_LogicalDriveInfoType_LogicalDriveInfo,
    XMLTAG_LogicalDriveInfoType_DrivePath,
    XMLTAG_LogicalDriveInfoType_FreeSpaceBytes,
    XMLTAG_LogicalDriveInfoType_TotalSpaceBytes,
    XMLTAG_Timing,

    XMLTAG_END  //this is to do a check that the number of entries here is the same as the number of entries in XMLTagNames
                           //Any additions to this set of enums must be made before XMLTAG_END
};

//
//    Tag names and level for XML output.
//    Note: The number of XMLTagNames should be the same as the number of enum entries above
//

struct XMLTags
{
    LPCTSTR    szName;
    DWORD    dwLevel;
} XMLTagNames[] =
{
    {TEXT("SETSystemStateData"), 0},
    {TEXT("Header"), 1},
    {TEXT("PageFiles"), 1},
    {TEXT("Memory"), 1},
    {TEXT("PoolInfo"),1},

    {TEXT("PhysicalMemory"), 2},
    {TEXT("CommittedMemory"), 2},
    {TEXT("KernelMemory"), 2},
    {TEXT("Pool"), 2},
    {TEXT("PageFiles"), 2},
    {TEXT("Memory"), 2},
    
    {TEXT("Extension"), 1},
    {TEXT("ProcessSummaries"), 1},
    {TEXT("ProcessStartInfo"), 1},
    {TEXT("ProcessesThreadInfo"), 1},
    {TEXT("ProcessesModuleInfo"), 1},
    {TEXT("KernelModuleInfo"), 1},
    {TEXT("OSInfo"), 1},
    {TEXT("HardwareInfo"), 1},

    {TEXT("ReliabilityGuid"), 2},
    {TEXT("SystemName"), 2},
    {TEXT("UserName"),2},
    {TEXT("ReasonTitle"),2},
    {TEXT("ReasonDescription"),2},
    {TEXT("InitiatingProcess"), 2},
    {TEXT("RestartDate"), 2},
    {TEXT("RestartTime"), 2},
    {TEXT("ReasonCode"), 2},
    {TEXT("RestartType"), 2},
    {TEXT("Comment"), 2},
    {TEXT("SystemUptime"), 2},
    {TEXT("UserLanguageID"), 2},
    {TEXT("SystemLanguageID"), 2},
    {TEXT("SchemaVersion"),2},

    {TEXT("PageFile"), 2},
    {TEXT("Path"), 3},
    {TEXT("CurrentSize"), 3},
    {TEXT("Total"), 3},
    {TEXT("Peak"), 3},

    {TEXT("Total"), 3},
    {TEXT("Available"), 3},
    {TEXT("WorkingSet"),2},
    {TEXT("Total"), 3},
    {TEXT("UserMode"), 3},
    {TEXT("Limit"), 3},
    {TEXT("Peak"), 3},
    {TEXT("Nonpaged"), 3},
    {TEXT("Paged"), 3},
    {TEXT("Nonpaged"), 3},
    {TEXT("Paged"), 3},
    {TEXT("PageFile"), 3},
    {TEXT("PhysicalMemory"), 3},
    {TEXT("WorkingSet"), 3},
    {TEXT("KernelMemory"), 3},
    {TEXT("CommittedMemory"), 3},
    {TEXT("Pool"), 3},

    {TEXT("AllocationInformation"),2}, //Pool Info: This tag is here for future extensibility in case we need to add anything more to Pool Info
    {TEXT("TagEntry"),3},  // Pool Info
    {TEXT("PoolTag"),4},
    {TEXT("PoolType"),4},
    {TEXT("NumAllocs"),4},
    {TEXT("NumFrees"),4},
    {TEXT("NumBytes"),4},
    {TEXT("SessionID"),4},

    {TEXT("Process"), 2},        //Process Info
    {TEXT("PID"), 3},
    {TEXT("Name"),3},
    {TEXT("UserTime"),3},
    {TEXT("KernelTime"), 3},
    {TEXT("WorkingSet"),3},
    {TEXT("PageFaults"),3},
    {TEXT("CommittedBytes"), 3},
    {TEXT("Priority"),3},
    {TEXT("HandleCount"),3},
    {TEXT("ThreadCount"),3},
   
    {TEXT("Process"), 2},        // ProcessSummary
    {TEXT("PID"),3},
    {TEXT("ImageName"), 3},
    {TEXT("CmdLine"), 3},
    {TEXT("CurrentDir"), 3},

    {TEXT("Process"), 2},         //ProcessThreadInfo
    {TEXT("PID"), 3},
    {TEXT("Thread"), 3},
    {TEXT("TID"), 4},
    {TEXT("Priority"), 4},
    {TEXT("ContextSwitches"), 4},
    {TEXT("StartAddress"), 4},
    {TEXT("UserTime"), 4},
    {TEXT("KernelTime"), 4},
    {TEXT("State"), 4},

    {TEXT("Process"), 2},        //Process Module Info
    {TEXT("PID"), 3},
    {TEXT("Module"), 3},
    {TEXT("LoadAddr"), 4},
    {TEXT("ImageSize"), 4},
    {TEXT("EntryPoint"), 4},
    {TEXT("FileName"), 4},

    {TEXT("Module"), 2},        //kernel module
    {TEXT("ModuleName"), 3},
    {TEXT("LoadAddress"), 3},
    {TEXT("Code"),3},
    {TEXT("Data"),3},
    {TEXT("Paged"),3},
    {TEXT("Date"),3},
    {TEXT("Time"),3},

    {TEXT("TotalCode"), 2},
    {TEXT("TotalData"), 2},
    {TEXT("TotalPaged"), 2},


    {TEXT("CurrentBuild"), 2},    //os information
    {TEXT("CurrentType"), 2},
    {TEXT("CurrentVersion"), 2},
    {TEXT("Path"), 2},
    {TEXT("ProductName"), 2},
    {TEXT("SoftwareType"), 2},
    {TEXT("SourcePath"), 2},
    {TEXT("SystemRoot"), 2},
    {TEXT("CSDVersion"), 2},
    {TEXT("DebuggerEnabled"),2},
    {TEXT("Hotfix"), 2},
    {TEXT("BiosInfo"), 2},
    {TEXT("ProcessorInfo"), 2},
    {TEXT("NICInfo"), 2},
    {TEXT("DiskInfo"), 2},
    {TEXT("Identifier"), 3},
    {TEXT("SystemBiosDate"), 3},
    {TEXT("SystemBiosVersion"), 3},
    {TEXT("VideoBiosDate"), 3},
    {TEXT("VideoBiosVersion"), 3},

    {TEXT("Processor"), 3},
    {TEXT("Number"), 4},
    {TEXT("Speed"), 4},
    {TEXT("Identifier"), 4},
    {TEXT("VendorIdent"), 4},
    {TEXT("NIC"), 3},
    {TEXT("Description"), 4},
    {TEXT("ServiceName"), 4},
    {TEXT("PhysicalDisks"), 3},
    {TEXT("PartitionByDiskInfo"), 3},
    {TEXT("LogicalDrives"), 3},

    {TEXT("Disk"), 4},            //physical disk
    {TEXT("DiskID"), 5},
    {TEXT("BytesPerSector"), 5},
    {TEXT("SectorsPerTrack"), 5},
    {TEXT("TracksPerCylinder"), 5},
    {TEXT("NumberOfCylinders"), 5},
    {TEXT("PortNumber"), 5},
    {TEXT("PathID"), 5},
    {TEXT("TargetID"), 5},
    {TEXT("LUN"), 5},
    {TEXT("Manufacturer"), 5},

    {TEXT("Disk"), 4},        //partition
    {TEXT("DiskID"), 5},    
    {TEXT("Partitions"), 5},
    {TEXT("PartitionInfo"),6},
    {TEXT("PartitionID"), 7},
    {TEXT("Extents"), 7},
    {TEXT("ExtentInfo"), 8},
    {TEXT("ID"), 9},
    {TEXT("StartingOffset"), 9},
    {TEXT("PartitionSize"), 9},

    {TEXT("LogicalDriveInfo"), 4},
    {TEXT("DrivePath"), 5},
    {TEXT("FreeSpaceBytes"), 5},
    {TEXT("TotalSpaceBytes"), 5},
    {TEXT("Timing"), 1}
};

#define REQUIRED_NUM_OF_STRINGS     7

// Number of elements in XMLTagNames array.
DWORD dwXMLTags = sizeof(XMLTagNames) / sizeof(XMLTags);

//
//    Implements the output in XML format.
//    
class XMLOutput
{
    //
    //  Currently the max level we have is 9, but if anything changes to
    //  the XMLTagNames, change MAX_XML_LEVEL accordingly.
    //
    enum {MAX_XML_LEVEL = 20};
    LPCTSTR    szTags[MAX_XML_LEVEL];
    DWORD    dwCurLevel;
    HANDLE    hOutput;
    BOOL    bBareTag;
public:
    XMLOutput(LPCTSTR szHeader, HANDLE hFile) 
        : dwCurLevel(0), hOutput(hFile), bBareTag(FALSE)
    {
        WriteToLogFile(hOutput, szHeader);
        WriteToLogFile(hOutput, TEXT("\n"));
        for(DWORD i = 0; i < MAX_XML_LEVEL; i++)
            szTags[i] = NULL;
    }

    ~XMLOutput()
    {
        int nLevel = dwCurLevel;
        while (nLevel >= 0 && szTags[nLevel])
        {
            //
            //    Close the ones that are still open.
            //
            for(DWORD i = 0; i < (DWORD)nLevel; i++)
                WriteToLogFile(hOutput, TEXT("\t"));
            WriteToLogFile(hOutput, TEXT("</"));
            WriteToLogFile(hOutput, szTags[nLevel]);
            WriteToLogFile(hOutput, TEXT(">\n"));
            szTags[nLevel] = NULL;
            nLevel--;
        }
    }

    VOID Write(XMLTAG nTag, LPCSTR szStr)
    {
        DWORD dwLevel = XMLTagNames[nTag].dwLevel;

        while (dwLevel <= dwCurLevel && szTags[dwCurLevel])
        {
            //
            //    Close the previous one
            //
            for(DWORD i = 0; i < dwCurLevel; i++)
                WriteToLogFile(hOutput, TEXT("\t"));
            WriteToLogFile(hOutput, TEXT("</"));
            WriteToLogFile(hOutput, szTags[dwCurLevel]);
            WriteToLogFile(hOutput, TEXT(">\n"));
            szTags[dwCurLevel] = NULL;
            dwCurLevel--;
        }

        dwCurLevel = dwLevel;
        szTags[dwCurLevel] = XMLTagNames[nTag].szName;

        if(bBareTag)
            WriteToLogFile(hOutput, TEXT("\n"));
        for(DWORD i = 0; i < dwLevel; i++)
            WriteToLogFile(hOutput, TEXT("\t"));
        WriteToLogFile(hOutput, TEXT("<"));
        WriteToLogFile(hOutput, szTags[dwCurLevel]);
        WriteToLogFile(hOutput, TEXT(">"));
        if(szStr && *szStr)
        {
            WriteToLogFileA(hOutput, szStr);
            WriteToLogFile(hOutput, TEXT("\n"));
            bBareTag = FALSE;
        }
        else
            bBareTag = TRUE;
    }

    VOID Write(XMLTAG nTag, LPCWSTR szStr)
    {
        DWORD dwLevel = XMLTagNames[nTag].dwLevel;

        while (dwLevel <= dwCurLevel && szTags[dwCurLevel])
        {
            //
            //    Close the previous one
            //
            for(DWORD i = 0; i < dwCurLevel; i++)
                WriteToLogFile(hOutput, TEXT("\t"));
            WriteToLogFile(hOutput, TEXT("</"));
            WriteToLogFile(hOutput, szTags[dwCurLevel]);
            WriteToLogFile(hOutput, TEXT(">\n"));
            szTags[dwCurLevel] = NULL;
            dwCurLevel--;
        }

        dwCurLevel = dwLevel;
        szTags[dwCurLevel] = XMLTagNames[nTag].szName;

        if(bBareTag)
            WriteToLogFile(hOutput, TEXT("\n"));
        for(DWORD i = 0; i < dwLevel; i++)
            WriteToLogFile(hOutput, TEXT("\t"));
        WriteToLogFile(hOutput, TEXT("<"));
        WriteToLogFile(hOutput, szTags[dwCurLevel]);
        WriteToLogFile(hOutput, TEXT(">"));
        if(szStr && *szStr)
        {
            WriteToLogFileW(hOutput, szStr);
            WriteToLogFile(hOutput, TEXT("\n"));
            bBareTag = FALSE;
        }
        else
            bBareTag = TRUE;
    }

} *gXMLOutput = NULL;

VOID
PrintLoadedDrivers(
    HANDLE hFile
    );

ULONG
LogSystemSnapshot(
    LPCTSTR *lpStrings,
    PLONG BuffSize,
    LPTSTR lpszBuff
    );

UINT LogSystemSnapshotToFile(
    HANDLE hFile
    );


void 
LogPoolInfo(
     HANDLE hFile
    );

void 
LogLogicalDriveInfo(
     HANDLE hFile
    );

void 
LogHardwareInfo(
     HANDLE hFile
    );

void
LogPhysicalDiskInfo(
    HANDLE hFile
    );

void
LogHotfixes(
    HANDLE hFile
    );

void
LogOsInfo(
    HANDLE hFile
    );

void
LogBIOSInfo(
    HANDLE hFile
    );

NTSTATUS 
SnapshotRegOpenKey(
    IN LPCWSTR lpKeyName,
    IN ACCESS_MASK DesiredAccess,
    OUT PHANDLE KeyHandle
    );

NTSTATUS
SnapshotRegQueryValueKey(
    IN HANDLE KeyHandle,
    IN LPCWSTR lpValueName,
    IN ULONG  Length,
    OUT PVOID KeyValue,
    OUT PULONG ResultLength
    );

NTSTATUS
SnapshotRegEnumKey(
    IN HANDLE KeyHandle,
    IN ULONG Index,
    OUT LPWSTR lpKeyName,
    OUT PULONG  lpNameLength
    );

NTSTATUS
SnapshotRegSetValueKey(
    IN HANDLE   KeyHandle,
    IN LPCWSTR  lpValueName,
    IN DWORD    dwType,
    IN LPVOID   lpData,
    IN DWORD    cbData
    );

void
DeleteOldFiles(
    LPCTSTR lpPath
    );

void
LoadExtensionDlls(
    HANDLE hFile
    );

DWORD WINAPI 
_LogSystemSnapshot(
    void* pv
    );

DWORD WINAPI
GetTimeOut(
    void* pv
    );

typedef struct _MODULEINFO 
{
    LPVOID lpBaseOfDll;
    DWORD SizeOfImage;
    LPVOID EntryPoint;
} MODULEINFO, *LPMODULEINFO;

BOOL
WINAPI
SnapshotGetModuleInformation(
    HANDLE hProcess,
    HMODULE hModule,
    LPMODULEINFO lpmodinfo,
    DWORD cb
    );

DWORD
WINAPI
SnapshotGetModuleBaseNameW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    );

DWORD
WINAPI
SnapshotGetModuleFileNameExW(
    HANDLE hProcess,
    HMODULE hModule,
    LPWSTR lpFilename,
    DWORD nSize
    );

BOOL
WINAPI
SnapshotEnumProcessModules(
    HANDLE hProcess,
    HMODULE *lphModule,
    DWORD cb,
    LPDWORD lpcbNeeded
    );

BOOL
SnapshotFindModule(
    IN HANDLE hProcess,
    IN HMODULE hModule,
    OUT PLDR_DATA_TABLE_ENTRY LdrEntryData
    );

BOOL
AdjustAccess(
    LPCWSTR lpszDir
    );

ULONG CurrentBufferSize;

LPCTSTR StateTable[] = 
{
    TEXT("Initialized"),
    TEXT("Ready"),
    TEXT("Running"),
    TEXT("Standby"),
    TEXT("Terminated"),
    TEXT("Wait:"),
    TEXT("Transition"),
    TEXT("Unknown"),
    TEXT("Unknown"),
    TEXT("Unknown"),
    TEXT("Unknown"),
    TEXT("Unknown")
};

LPCTSTR WaitTable[] = 
{
    TEXT("Executive"),
    TEXT("FreePage"),
    TEXT("PageIn"),
    TEXT("PoolAllocation"),
    TEXT("DelayExecution"),
    TEXT("Suspended"),
    TEXT("UserRequest"),
    TEXT("Executive"),
    TEXT("FreePage"),
    TEXT("PageIn"),
    TEXT("PoolAllocation"),
    TEXT("DelayExecution"),
    TEXT("Suspended"),
    TEXT("UserRequest"),
    TEXT("EventPairHigh"),
    TEXT("EventPairLow"),
    TEXT("LpcReceive"),
    TEXT("LpcReply"),
    TEXT("VirtualMemory"),
    TEXT("PageOut"),
    TEXT("Spare1"),
    TEXT("Spare2"),
    TEXT("Spare3"),
    TEXT("Spare4"),
    TEXT("Spare5"),
    TEXT("Spare6"),
    TEXT("Spare7"),
    TEXT("Unknown"),
    TEXT("Unknown"),
    TEXT("Unknown")
};

LPCTSTR Empty = TEXT(" ");

BOOLEAN fUserOnly = TRUE;
BOOLEAN fSystemOnly = TRUE;
BOOLEAN fVerbose = FALSE;

#define STR_BUFFER_SIZE         512
TCHAR g_lpszBuffer[STR_BUFFER_SIZE];
TCHAR g_lpszFileName[2*MAX_PATH + 1] ;

//
//    struct for thread proc.
//
typedef struct _THREADPARAM
{
    DWORD    Flags;
    LPCTSTR *lpStrings;
    DWORD   NumOfStrings;
    PLONG    BuffSize;
    LPTSTR    lpszBuff;
    LONG    lCanOrphanThread;
}THREADPARAM, *PTHREADPARAM;

class Timing
{
    enum {MAX_TIMING_ENTRIES = 30};
    INT preTicks;
    INT cnt;
    HANDLE hFile;
    struct _XX{
        WCHAR sz[100];
        INT        ticks;
    };
    _XX sec[MAX_TIMING_ENTRIES];
public:
    Timing()
    {
        preTicks = GetTickCount();
        cnt = 0;
        hFile = NULL;
    }

    void Timeit(HANDLE h, LPCWSTR szSec)
    {
        if(wcslen(szSec) >= 100 || cnt >= MAX_TIMING_ENTRIES)
            return;
        wcscpy(sec[cnt].sz, szSec);
        sec[cnt].ticks = GetTickCount() - preTicks;
        preTicks = GetTickCount();
        hFile = h;
        cnt++;
    }

    ~Timing()
    {
        WCHAR buf[255];
        WriteToLogFile(hFile, TEXT("\n"));
        gXMLOutput->Write(XMLTAG_Timing, (LPCWSTR)NULL);
        WriteToLogFile(hFile, TEXT("\n"));
        for (INT i = 0; i < cnt; i++)
        {
            wsprintf(buf, L"\t\t<%s>%d</%s>\n", sec[i].sz, sec[i].ticks, sec[i].sz);
            WriteToLogFileW(hFile, buf);
        }
    }
    
} *g_pTime = NULL;

DWORD
GetReliabilityGUID(
    LPTSTR* ppszGuid
    )
/*++

Routine Description:

    Retrieve the reliablity GUID. It will check the registry value
        HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Reliability\ReliabilityGUID
    first, if it is not there. It will call UuidCreate create the GUID and set the value 
    there.

Arguments:

    ppszGUID    -   caller needs to free

Return Value:

    if failed, return the error code

Note:
    Caller needs to call LocalFree to free the GUID String.

--*/
{
    DWORD       dwResult = ERROR_SUCCESS;
    NTSTATUS    status   = STATUS_SUCCESS;
    HANDLE      hKey;

    LPCTSTR     GuidStrVal  = TEXT("ReliabilityGUID");
    LPTSTR      pszGuid     = NULL;
    DWORD       cbSize      = 0;
    
    //
    //  0FC4926A-992D-40d2-B609-32BFD10C5FBC
    //      32 GUID chars + 4 '-' + 1 '\0'
    //
    enum { MAX_GUID_STR_LEN = 37 };

    status = SnapshotRegOpenKey(ReliabilityKey, KEY_ALL_ACCESS, &hKey);
    if (!NT_SUCCESS(status) )
    {
        dwResult = RtlNtStatusToDosError(status);
        return dwResult;
    }
    
    cbSize = MAX_GUID_STR_LEN * sizeof(TCHAR);
    if (!(pszGuid = (LPWSTR)LocalAlloc(LPTR, cbSize)))
    {
        dwResult = GetLastError();
        goto error;
    }
   
    status = SnapshotRegQueryValueKey(hKey, GuidStrVal, cbSize, pszGuid, &cbSize);
    if (!NT_SUCCESS(status) || !(*pszGuid))
    {
        RPC_STATUS  rpcStatus = RPC_S_OK;
        UUID        Guid;
        LPTSTR      pszStringUuid = NULL;

        //
        //  We will regenerate the guid key if:
        //      1. value doesn't exist
        //      2. value has been modified to longer string (>MAX_GUID_STR_LEN).
        //      3. failed with other reasons. ???
        //  
        rpcStatus = UuidCreate(&Guid);
        if ( rpcStatus != RPC_S_OK && rpcStatus != RPC_S_UUID_LOCAL_ONLY )
        {
            dwResult = rpcStatus;
            goto error;
        }

        rpcStatus = UuidToStringW(&Guid, &pszStringUuid);
        if ( rpcStatus != RPC_S_OK || !pszStringUuid )
        {
            dwResult = (rpcStatus == RPC_S_OK)? RPC_S_OUT_OF_MEMORY : rpcStatus;
            goto error;
        }

        _tcsncpy( pszGuid, pszStringUuid, MAX_GUID_STR_LEN - 1);
        pszGuid[ MAX_GUID_STR_LEN - 1 ] = 0;

        RpcStringFree( &pszStringUuid );
        
        cbSize = MAX_GUID_STR_LEN * sizeof(TCHAR);
        status = SnapshotRegSetValueKey( hKey, GuidStrVal, REG_SZ, (LPVOID)pszGuid, cbSize);
        if (!NT_SUCCESS( status ))
        {
            dwResult = RtlNtStatusToDosError(status);
            goto error;
        }
    }
    else
    {
        //
        //  Success, make sure it is NULL terminated. and we will NOT
        //  do any format validation here.
        //
        pszGuid[ MAX_GUID_STR_LEN - 1 ] = 0;
    }

    //
    //  Now pszGuid contain the valid GUID, let's update the ppszGuid string.
    //  
    *ppszGuid = pszGuid;
    pszGuid   = NULL;
    
error:
