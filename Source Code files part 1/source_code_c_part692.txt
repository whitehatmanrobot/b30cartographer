EVENTMSG);
    msg.fnPostProcessProcHandle = 0;
    msg.Msg                = Msg;
    msg.Param1             = Param1;
    msg.Param2             = Param2;
    msg.Param3             = Param3;
    msg.Param4             = 0; // remotesp chks this on LINE_DEVSPEC(FEATURE)

    LOG((TL_INFO, "SendMsgToLineClients - number of Clients:%u", pClientList->dwNumUsedEntries));
    for (i = 0; i < pClientList->dwNumUsedEntries; i++)
    {
        try
        {
            PTCLIENT     ptClient;
            PTLINECLIENT ptLineClient = pClientList->aEntries[i];

            if (ptLineClient == ptLineClientToExclude)
            {
                continue;
            }
            LOG((TL_INFO, "SendMsgToLineClients: Msg:%x -- Param1:%x", Msg, Param1));
            if (FMsgDisabled (
                ptLineClient->ptLineApp->dwAPIVersion,
                ptLineClient->adwEventSubMasks,
                (DWORD) Msg,
                (DWORD) Param1
                ))
            {
                continue;
            }

            if (Msg == LINE_ADDRESSSTATE)
            {
                DWORD   addressStates = Param2;     // ULONG_PTR   addressStates = Param2;


                //
                // Munge the state flags so we don't pass
                // unexpected flags to old apps
                //

                switch (ptLineClient->dwAPIVersion)
                {
                case TAPI_VERSION1_0:

                    addressStates &= AllAddressStates1_0;
                    break;

                //case TAPI_VERSION1_4:
                //case TAPI_VERSION2_0:
                //case TAPI_VERSION2_1:
                //case TAPI_VERSION2_2:
                //case TAPI_VERSION_CURRENT:
                default:

                    addressStates &= AllAddressStates1_4;
                    break;
                }

                if ((addressStates &= ptLineClient->dwAddressStates))
                {
                    msg.Param2 = addressStates;
                }
                else
                {
                    continue;
                }

                if ((Param2 & LINEADDRESSSTATE_CAPSCHANGE))
                {
                }
            }
            else if (Msg == LINE_LINEDEVSTATE)
            {
                DWORD   lineStates = Param1;    // ULONG_PTR   lineStates = Param1;


                //
                // Munge the state flags so we don't pass unexpected flags
                // to old apps
                //

                switch (ptLineClient->dwAPIVersion)
                {
                case TAPI_VERSION1_0:

                    lineStates &= AllLineStates1_0;
                    break;

                default:    // case TAPI_VERSION1_4:
                            // case TAPI_VERSION_CURRENT:

                    lineStates &= AllLineStates1_4;
                    break;
                }

                if ((lineStates &= ptLineClient->dwLineStates))
                {
                    msg.Param1 = lineStates;
                }
                else
                {
                    continue;
                }

                if ((Param1 & (LINEDEVSTATE_CAPSCHANGE |
                        LINEDEVSTATE_TRANSLATECHANGE)))
                {
                }

            }
            else if (Msg == LINE_PROXYSTATUS)
            {
                //
                // Don't pass this message to older apps
                //

                if (ptLineClient->dwAPIVersion < TAPI_VERSION2_2)
                {
                    continue;
                }
            }

            msg.InitContext = ptLineClient->ptLineApp->InitContext;
            msg.hDevice     = ptLineClient->hRemoteLine;
            msg.OpenContext = ptLineClient->OpenContext;

            ptClient = ptLineClient->ptClient;

            if (ptLineClient->dwKey == TLINECLIENT_KEY)
            {
                WriteEventBuffer (ptClient, &msg);
            }
        }
        myexcept
        {
            // just continue
        }
    }

    if (pClientList != &clientList)
    {
        ServerFree (pClientList);
    }
}


LONG
PASCAL
GetCallIDs(
    PTCALL  ptCall
    )
{
    //
    // NOTE: Caller must already have exclusive access to the
    //       tCall when invoking this function.  On return they
    //       will still have exclusive access to the tCall.
    //
    //       Also, it is assumed that only the LINE_CALLSTATE
    //       msg handler & MakeCallPostProcess-style functions
    //       will call this function.  Otherwise, the code that
    //       resets the tCall's dwKey down below will need to
    //       be changed.
    //

    //
    // We don't want to hold the lock while we call the provider,
    // since this request might take a while (possible ring
    // transitions, etc). But we also don't want another thread
    // to destroy this tCall in the meantime (because we didn't
    // allow for that in NT 4.0, and because it makes life more
    // difficult for the calling function).  So, we'll reset the
    // tCall's dwKey value to ZOMBIE, thereby causing any other
    // thread(s) that is waiting to destroy this call to effectively
    // wait/spin, and we'll then restore the dwKey value down below
    // after we reacquire the lock. (Since this func is only called
    // by MakeCallPostProcess-style functions & the LINE_CALLSTATE
    // handler [on the first callstate msg received on an incoming
    // call], the only way another thread would be destroying this
    // call is if the line is being closed, either by an app or as
    // the result of a LINE_CLOSE, and DestroytLine spins until
    // it has destroyed all tCall's in the tLine's list.)

    DWORD       dwNumAddresses = ptCall->ptLine->dwNumAddresses, dwSavedKey;
    PTPROVIDER  ptProvider = ptCall->ptProvider;

    if (ptProvider->apfn[SP_LINEGETCALLINFO] == NULL)
    {
        return LINEERR_OPERATIONUNAVAIL;
    }

    dwSavedKey = ptCall->dwKey;
    ptCall->dwKey = TZOMBIECALL_KEY;

    UNLOCKTCALL (ptCall);

    if (ptProvider->apfn[SP_LINEGETCALLIDS])
    {
        CallSP4(
            ptProvider->apfn[SP_LINEGETCALLIDS],
            "lineGetCalIDs",
            SP_FUNC_SYNC,
            (ULONG_PTR) ptCall->hdCall,
            (ULONG_PTR) &ptCall->dwAddressID,
            (ULONG_PTR) &ptCall->dwCallID,
            (ULONG_PTR) &ptCall->dwRelatedCallID
            );
    }
    else
    {
        DWORD           dwSPIVersion, dwFixedSizeSP;
        LINECALLINFO    callInfo;


        //
        // Determine the fixed size of the structure expected by the SP
        //

        dwSPIVersion = ((PTLINE) ptCall->ptLine)->dwSPIVersion;

        switch (dwSPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeSP = 296;    // 69 * sizeof(DWORD) + sizeof (HLINE)
                                    //     + sizeof (LINEDIALPARAMS)
            break;

        case TAPI_VERSION2_0:
        case TAPI_VERSION2_1:
        case TAPI_VERSION2_2:

            dwFixedSizeSP = 324;    // 76 * sizeof(DWORD) + sizeof (HLINE)
                                    //     + sizeof (LINEDIALPARAMS)
            break;

        default: // (fix ppc build wrn) case TAPI_VERSION_CURRENT:

            dwFixedSizeSP = sizeof (LINECALLINFO);
            break;
        }

        InitTapiStruct (&callInfo, dwFixedSizeSP, dwFixedSizeSP, TRUE);

        CallSP2(
            ptProvider->apfn[SP_LINEGETCALLINFO],
            "lineGetCallInfo",
            SP_FUNC_SYNC,
            (ULONG_PTR) ptCall->hdCall,
            (ULONG_PTR) &callInfo
            );

        ptCall->dwAddressID     = callInfo.dwAddressID;
        ptCall->dwCallID        = callInfo.dwCallID;
        ptCall->dwRelatedCallID = callInfo.dwRelatedCallID;
    }


    //
    // Reacquire the call lock, restore the dwKey value, & fill
    // in the address id
    //

    LOCKTCALL (ptCall);
    ptCall->dwKey = dwSavedKey;

    return 0;
}


VOID
PASCAL
AcquireHashTableReaderLock(
    PTPROVIDER  ptProvider
    )
{
    EnterCriticalSection (&ptProvider->HashTableCritSec);
    InterlockedIncrement (&ptProvider->lHashTableReaderCount);
    LeaveCriticalSection (&ptProvider->HashTableCritSec);
}


VOID
PASCAL
AcquireHashTableWriterLock(
    PTPROVIDER  ptProvider
    )
{
    EnterCriticalSection (&ptProvider->HashTableCritSec);

    if (InterlockedDecrement (&ptProvider->lHashTableReaderCount) >= 0)
    {
        WaitForSingleObject (ptProvider->hHashTableReaderEvent, INFINITE);
    }
}


VOID
PASCAL
ReleaseHashTableReaderLock(
    PTPROVIDER  ptProvider
    )
{
    if (InterlockedDecrement (&ptProvider->lHashTableReaderCount) < 0)
    {
        SetEvent (ptProvider->hHashTableReaderEvent);
    }
}


VOID
PASCAL
ReleaseHashTableWriterLock(
    PTPROVIDER  ptProvider
    )
{
    InterlockedIncrement (&ptProvider->lHashTableReaderCount);
    LeaveCriticalSection (&ptProvider->HashTableCritSec);
}


PTHASHTABLEENTRY
PASCAL
AcquireHashTableEntryLock(
    PTPROVIDER  ptProvider,
    DWORD       dwCallHubID
    )
{
    LONG                lPreviousCookie;
    PTHASHTABLEENTRY    pEntry;


    AcquireHashTableReaderLock (ptProvider);

    pEntry = ptProvider->pHashTable +
        (dwCallHubID % ptProvider->dwNumHashTableEntries);

    do
    {
        lPreviousCookie = InterlockedExchange (&pEntry->lCookie, 1);

    } while (lPreviousCookie != 0);

    return pEntry;
}


VOID
PASCAL
ReleaseHashTableEntryLock(
    PTPROVIDER          ptProvider,
    PTHASHTABLEENTRY    pEntry
    )
{
    InterlockedExchange (&pEntry->lCookie, 0);

    ReleaseHashTableReaderLock (ptProvider);
}


VOID
PASCAL
FreeHashTable(
    PTHASHTABLEENTRY    pHashTable,
    DWORD               dwNumHashTableEntries,
    DWORD               dwNumDynamicHashTableEntries
    )
{
    //
    // Walk thru hash table to find any dynamic entries that need to
    // be freed.  We compare against both dwNumDynamicHashTableEntries
    // and dwNumHashTableEntries in case something went wrong somewhere.
    //
    // Then free the table itself & return
    //

    DWORD               i;
    PTHASHTABLEENTRY    pEntry, pEntry2;


    for(
        i = 0, pEntry = pHashTable;
        dwNumDynamicHashTableEntries  &&  i < dwNumHashTableEntries;
        i++, pEntry++
        )
    {
        while (pEntry->pNext)
        {
            dwNumDynamicHashTableEntries--;

            pEntry2 = pEntry->pNext->pNext;

            ServerFree (pEntry->pNext);

            pEntry->pNext = pEntry2;
        }
    }

    ServerFree (pHashTable);
}


PTHASHTABLEENTRY
PASCAL
FindDynamicHashTableEntry(
    PTHASHTABLEENTRY    pEntry,
    DWORD               dwCallHubID
    )
{
    //
    // Note that the pEntry passed to us is static, so no need to check that
    //

    while (pEntry->pNext)
    {
        if (pEntry->pNext->dwCallHubID == dwCallHubID)
        {
            break;
        }

        pEntry = pEntry->pNext;
    }

    return pEntry->pNext;
}


VOID
PASCAL
RemoveDynamicHashTableEntry(
    PTPROVIDER          ptProvider,
    PTHASHTABLEENTRY    pStaticEntry,
    PTHASHTABLEENTRY    pDynamicEntry
    )
{
    while (pStaticEntry->pNext != pDynamicEntry)
    {
        pStaticEntry = pStaticEntry->pNext;
    }

    pStaticEntry->pNext = pDynamicEntry->pNext;

    ServerFree (pDynamicEntry);

    InterlockedDecrement ((LPLONG) &ptProvider->dwNumDynamicHashTableEntries);
}


DWORD
PASCAL
GetNumDynamicHashTableEntries(
    PTHASHTABLEENTRY    pEntry
    )
{
    //
    // Note that the pEntry passed to us is static, so no need to count that
    //

    DWORD  i;


    for (i = 0; (pEntry = pEntry->pNext); i++);

    return i;
}


//
//  SendNewCallHubEvent
//
//  Utility function used by DoCallHubHashing & UpdateCallHubHashing
//  to send LINE_NEWCALLHUB event if not sent yet
//

LONG
PASCAL
SendNewCallHubEvent (
    PTCALL                  ptCall,
    PTHASHTABLEENTRY        pTargetEntry
    )
{
    //
    // For each tCallClient see if tLineClient has tracking
    // enabled, and if so then see if there is already an
    // associated (via common tLineApp) tCallHubClient - if
    // not then create one & notify the app
    //

    DWORD   i;
    BOOL    bExistingCallHubClients = 
        (pTargetEntry->ptCallHubClients != NULL);
    TPOINTERLIST        fastCallClientList, *ptCallClientList;

    if (ptCall->ptLine->dwNumCallHubTrackers != 0)
    {
        ptCallClientList = &fastCallClientList;
        if (GetCallClientListFromCall (ptCall, &ptCallClientList) != 0)
        {
            ptCallClientList = NULL;
        }
    }
    else
    {
        ptCallClientList = NULL;
    }

    if (ptCallClientList == NULL || pTargetEntry == NULL)
    {
        return 0;
    }

    for (i = 0; i < ptCallClientList->dwNumUsedEntries; i++)
    {
        PTLINEAPP       ptLineApp;
        PTCALLCLIENT    ptCallClient = ptCallClientList->aEntries[i];
        ASYNCEVENTMSG   msg;
        PTCALLHUBCLIENT ptCallHubClient;


        if (ptCallClient->ptLineClient->dwCurrentTracking ||
            bExistingCallHubClients)
        {
            ptLineApp = ptCallClient->ptLineClient->ptLineApp;
            ptCallHubClient = pTargetEntry->ptCallHubClients;

            while (ptCallHubClient)
            {
                if (ptCallHubClient->ptLineApp == ptLineApp)
                {
                    break;
                }

                ptCallHubClient = ptCallHubClient->pNext;
            }

            if (ptCallClient->ptLineClient->dwCurrentTracking  &&
                !ptCallHubClient &&
                (!FMsgDisabled (
                    ptCallClient->ptLineClient->ptLineApp->dwAPIVersion,
                    ptCallClient->adwEventSubMasks,
                    LINE_APPNEWCALLHUB,
                    0)))
            {
                DWORD hptClientHandle = 0;


                ptCallHubClient = ServerAlloc (sizeof(TCALLHUBCLIENT));

                if (!ptCallHubClient)
                {
                    i = ptCallClientList->dwNumUsedEntries;
                    continue;
                }

                ptCallHubClient->hCallHub = (DWORD) NewObject(
                    ghHandleTable,
                    ptCallHubClient,
                    NULL
                    );

                if (!ptCallHubClient->hCallHub)
                {
                    ServerFree(ptCallHubClient);
                    i = ptCallClientList->dwNumUsedEntries;
                    continue;
                }

                ptCallHubClient->dwKey = TCALLHUBCLIENT_KEY;
                ptCallHubClient->ptClient = ptCallClient->ptClient;
                ptCallHubClient->ptProvider = ptCall->ptProvider;
                ptCallHubClient->dwCallHubID = ptCall->dwCallID;
                ptCallHubClient->ptLineApp = ptLineApp;
                ptCallHubClient->pNext = pTargetEntry->ptCallHubClients;
                pTargetEntry->ptCallHubClients = ptCallHubClient;


                //
                // Queue a msg to alert the app of the new call
                // hub.  We do this rather than sending a msg
                // directly from here to make sure the app gets
                // the LINE_REPLY and/or APPNEWCALL msgs first
                // (i.e. before calling lineGetHubRelatedCalls
                // in response to LINE_APPNEWCALLHUB)
                //

                LineEventProcSP(
                    (HTAPILINE) 0,
                    (HTAPICALL) 0,
                    LINE_APPNEWCALLHUB,
                    ptCallHubClient->hCallHub,
                    ptLineApp->InitContext,
                    (ULONG_PTR)ptLineApp->ptClient
                    );
            }

            ptCallClient->ptCallHubClient = ptCallHubClient;
        }
    }

    return 0;
}

//
//  Per Bug 7591
//      There might be a owner ship transferring of a call after
//  it has been created. The new owner will not get the new call
//  hub event since such event is only generated while the call
//  is created. UpdateCallHubHashing goes through the call client
//  if any of the client did not receive the LINE_NEWCALLHUB event
//  it will send it one.
//

LONG
PASCAL
UpdateCallHubHashing (
    PTCALL      ptCall
    )
{
    if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
    {
        PTHASHTABLEENTRY    pStaticEntry, pTargetEntry;
        
        pStaticEntry = AcquireHashTableEntryLock(
            ptCall->ptProvider,
            ptCall->dwCallID
            );
        if (pStaticEntry->dwCallHubID == ptCall->dwCallID)
        {
            pTargetEntry = pStaticEntry;
        }
        else
        {
            pTargetEntry = FindDynamicHashTableEntry(
                pStaticEntry,
                ptCall->dwCallID
                );
        }
        if (pTargetEntry)
        {
            SendNewCallHubEvent (ptCall, pTargetEntry);
        }
        ReleaseHashTableEntryLock (ptCall->ptProvider, pStaticEntry);
        UNLOCKTCALL (ptCall);
    }

    return 0;
}

LONG
PASCAL
DoCallHubHashing(
    PTCALL  ptCall,
    DWORD   dwPreviousCallID
    )
{
    //
    // Assumes caller has exclusive access to the tCall
    //

    DWORD               i;
    PTPROVIDER          ptProvider = ptCall->ptProvider;
    PTHASHTABLEENTRY    pStaticEntry, pDynamicEntry;


    if (ptCall->dwCallID == dwPreviousCallID)
    {
        return 0;
    }

    if (dwPreviousCallID != 0)
    {
        //
        // Remove tCall from call hub hash table (based on
        // previous call id).  If this is the last tCall in
        // that hash table entry then destroy any associated
        // tCallHubClients and alert apps.
        //
        // Note that (when freeing tCallHubClients) we call
        // LineEventProcSP() to queue the CALLHUBCLOSE msgs
        // rather than sending them directly via
        // WriteEventBuffer() because we already own the
        // tCall lock and we don't want to entertain the
        // possibility of deadlock by grabbing other locks.
        //

        PTCALLHUBCLIENT ptCallHubClient = NULL,  pNext;


        pStaticEntry = AcquireHashTableEntryLock(
            ptProvider,
            dwPreviousCallID
            );

        if (pStaticEntry->dwCallHubID == dwPreviousCallID)
        {
            RemoveEntryList (&ptCall->CallHubList);

            ptCall->CallHubList.Flink = NULL;
            ptCall->CallHubList.Blink = NULL;

            if (IsListEmpty (&pStaticEntry->CallHubList))
            {
                ptCallHubClient = pStaticEntry->ptCallHubClients;
                pStaticEntry->ptCallHubClients = NULL;
                pStaticEntry->dwCallHubID = 0;
            }
        }
        else if ((pDynamicEntry = FindDynamicHashTableEntry(
                        pStaticEntry,
                        dwPreviousCallID
                        )))
        {
            RemoveEntryList (&ptCall->CallHubList);

            ptCall->CallHubList.Flink = NULL;
            ptCall->CallHubList.Blink = NULL;

            if (IsListEmpty (&pDynamicEntry->CallHubList))
            {
                ptCallHubClient = pDynamicEntry->ptCallHubClients;

                RemoveDynamicHashTableEntry(
                    ptProvider,
                    pStaticEntry,
                    pDynamicEntry
                    );
            }
        }
        else
        {
            // TODO assert
        }

        ReleaseHashTableEntryLock (ptProvider, pStaticEntry);

        if (ptCallHubClient)
        {
            while (ptCallHubClient)
            {
                BOOL        bSendMsg = FALSE;
                DWORD       param2 = 0;
                DWORD       param3 = 0; // ULONG_PTR   param2, param3;
                PTLINEAPP   ptLineApp;


                try
                {
                    ptLineApp = ptCallHubClient->ptLineApp;

                    param2 = ptLineApp->InitContext;
                    
                    if (ptLineApp->dwKey == TLINEAPP_KEY &&
                        (!FMsgDisabled(
                            ptLineApp->dwAPIVersion,
                            ptLineApp->adwEventSubMasks,
                            LINE_CALLHUBCLOSE,
                            0
                            )))
                    {
                        bSendMsg = TRUE;
                    }
                }
                except (EXCEPTION_EXECUTE_HANDLER)
                {
                    // tLineApp is gone, just fall through
                }

                if (bSendMsg)
                {
                    LineEventProcSP(
                        (HTAPILINE) UIntToPtr(ptCallHubClient->hCallHub), // "random" seed for MP
                        (HTAPICALL) 0,
                        LINE_CALLHUBCLOSE,
                        ptCallHubClient->hCallHub,
                        param2,
                        (ULONG_PTR)ptLineApp->ptClient
                        );
                }

                pNext = ptCallHubClient->pNext;
                ptCallHubClient->dwKey = INVAL_KEY;

                DereferenceObject(
                    ghHandleTable,
                    ptCallHubClient->hCallHub,
                    1
                    );

                ptCallHubClient = pNext;
            }
        }
    }

    if (ptCall->dwCallID != 0 &&
        ptCall->CallHubList.Flink == NULL &&
        ptCall->CallHubList.Blink == NULL)
    {
        //
        // If at least one tLineClient has call hub tracking enabled
        // then retrieve the list of tCallClients before we acquire
        // exclusive access to the hash table
        //

        DWORD               dwOldNumHashTableEntries,
                            dwOldNumDynamicHashTableEntries;
        PTHASHTABLEENTRY    pOldHashTable = NULL, pTargetEntry;


        //
        // Insert tCall in call hub hash table (based on current call ID).
        //
        // In the event of collision, first check to see if there's an
        // existing dynamic entry with corresponding to the call ID.
        // If so, party on the dynamic entry.  Otherwise, try to create
        // a dynamic entry if we're still within the dynamic entry
        // threshholds.
        //
        // Finally, failing all the above, attempt to grow the hash table.
        //

acquireTableEntryLock:

        pStaticEntry = AcquireHashTableEntryLock(
            ptProvider,
            ptCall->dwCallID
            );

        if (pStaticEntry->dwCallHubID == ptCall->dwCallID)
        {
            //
            // Add tCall to list (static entry)
            //

            InsertTailList (&pStaticEntry->CallHubList, &ptCall->CallHubList);

            pTargetEntry = pStaticEntry;
        }
        else if(pStaticEntry->dwCallHubID == 0)
        {
            //
            //  Check to see if there is already a dynamic entry for this dwCallID,
            //  if so, use it
            //
        
            pTargetEntry = pStaticEntry->pNext;
            
            while (pTargetEntry && pTargetEntry->dwCallHubID != ptCall->dwCallID)
            {
                pTargetEntry = pTargetEntry->pNext;
            }
            if (pTargetEntry == NULL)
            {
                pTargetEntry = pStaticEntry;
                pTargetEntry->dwCallHubID = ptCall->dwCallID;
            }
            
            InsertTailList (&pTargetEntry->CallHubList, &ptCall->CallHubList);
        }
        else if ((pTargetEntry = FindDynamicHashTableEntry(
                        pStaticEntry,
                        ptCall->dwCallID
                        )))
        {
            //
            // Add tCall to list (existing dynamic entry)
            //

            InsertTailList (&pTargetEntry->CallHubList, &ptCall->CallHubList);
        }
        else if (InterlockedIncrement(
                    (LPLONG) &ptProvider->dwNumDynamicHashTableEntries
                    )

                    <  (LONG) GetMaxDynamicHashTableEntries(
                                   ptProvider->dwNumHashTableEntries
                                   )                                   &&

                 GetNumDynamicHashTableEntries (pStaticEntry)

                    < MAX_DYNAMIC_HASH_ENTRIES_PER_SLOT)
        {
            //
            // Add tCall to list (new dynamic entry)
            //

            if (!(pTargetEntry = ServerAlloc (sizeof (*pTargetEntry))))
            {
                //
                // Failed to allocate memory, so we'll reset the call
                // hub id for this call to zero so as not to confuse
                // things later
                //

                InterlockedDecrement(
                    (LPLONG) &ptProvider->dwNumDynamicHashTableEntries
                    );

                ReleaseHashTableEntryLock (ptProvider, pStaticEntry);
                ptCall->dwCallID = 0;

                return 0;
            }

            pTargetEntry->dwCallHubID = ptCall->dwCallID;

            InitializeListHead (&pTargetEntry->CallHubList);

            InsertTailList (&pTargetEntry->CallHubList, &ptCall->CallHubList);

            pTargetEntry->pNext = pStaticEntry->pNext;

            pStaticEntry->pNext = pTargetEntry;
        }
        else
        {
            //
            // Grow table
            //

            DWORD               dwNewNumHashTableEntries, dwMaxDynamicEntries,
                                dwNewNumDynamicHashTableEntries;
            PTHASHTABLEENTRY    pNewHashTable, pNewEntry, pEntry2, pEndOfTable;


            //
            // Decrement to compensate for the failed check above
            //

            InterlockedDecrement(
                &ptProvider->dwNumDynamicHashTableEntries
                );


            //
            // Grab the current number of hash table entries before
            // we release the entry lock, so we can compare with
            // that after the table writer lock is acquired.  (Another
            // thread might have grown table in time it took to acquire
            // table writer lock, in which case we want to jump up
            // top again.)
            //
            // The chances of another thread having released the
            // entry we collided with (or freed up a related dynamic
            // entry, etc) are fairly slim, so we won't bother checking
            // for that
            //

            {
                DWORD   dwNumHashTableEntries =
                            ptProvider->dwNumHashTableEntries;


                ReleaseHashTableEntryLock (ptProvider, pStaticEntry);

                AcquireHashTableWriterLock (ptProvider);

                if (dwNumHashTableEntries < ptProvider->dwNumHashTableEntries)
                {
                    ReleaseHashTableWriterLock (ptProvider);

                    goto acquireTableEntryLock;
                }

                //
                //  Because we released the lock & reaquired a lock, if
                //  another call with the same dwCallID got hashed in, we
                //  would got two hash table entries with the same dwCallHubID
                //  that eventually leads to memory corruption when grow
                //  the table again. So check for it
                //
                pTargetEntry = ptProvider->pHashTable +
                    (ptCall->dwCallID % ptProvider->dwNumHashTableEntries);
                while (pTargetEntry && pTargetEntry->dwCallHubID != ptCall->dwCallID)
                {
                    pTargetEntry = pTargetEntry->pNext;
                }
                if (pTargetEntry)
                {
                    //
                    //  Found such entry, go back & retry
                    //
                    ReleaseHashTableWriterLock (ptProvider);

                    goto acquireTableEntryLock;
                }
            }


            //
            // Ok, we really do need to grow the table.  Find the next
            // larger number of entries.
            //

            for(
                i = 0;
                ptProvider->dwNumHashTableEntries >= TapiPrimes[i] &&
                    TapiPrimes[i];
                i++
                );

alloc_new_hash_table:

            if (!(dwNewNumHashTableEntries = TapiPrimes[i]))
            {
                //
                // We won't attempt to grow the hash table any further,
                // so we'll reset the call hub id for this call to zero
                // so as not to confuse things later
                //

                ptCall->dwCallID = 0;
                ReleaseHashTableWriterLock (ptProvider);
                return 0;
            }

            pNewHashTable = ServerAlloc(
                dwNewNumHashTableEntries * sizeof (THASHTABLEENTRY)
                );

            if (!pNewHashTable)
            {
                //
                // Failed to allocate a new hash table, so we'll reset the
                // call hub id for this call to zero so as not to confuse
                // things later
                //

                ptCall->dwCallID = 0;
                ReleaseHashTableWriterLock (ptProvider);
                return 0;
            }


            //
            // Move all existing hash table entries to new table
            //

            pEndOfTable = ptProvider->pHashTable +
                ptProvider->dwNumHashTableEntries;

            dwNewNumDynamicHashTableEntries = 0;

            dwMaxDynamicEntries = GetMaxDynamicHashTableEntries(
                dwNewNumHashTableEntries
                );

            for(
                pStaticEntry = ptProvider->pHashTable;
                pStaticEntry != pEndOfTable;
                pStaticEntry++
                )
            {
                //
                // If this entry is in use somehow, check to see
                // if we need to start walking at the static entry
                // or the dynamic entry.  Else, simply continue.
                //

                if (pStaticEntry->dwCallHubID == 0)
                {
                    if (!pStaticEntry->pNext)
                    {
                        continue;
                    }

                    pEntry2 = pStaticEntry->pNext;
                }
                else
                {
                    pEntry2 = pStaticEntry;
                }

                while (pEntry2)
                {
                    pNewEntry = pNewHashTable +
                        (pEntry2->dwCallHubID % dwNewNumHashTableEntries);

                    if (pNewEntry->dwCallHubID != 0)
                    {
                        //
                        // Collision, try to add a dynamic entry
                        //

                        if (dwNewNumDynamicHashTableEntries  <
                                dwMaxDynamicEntries  &&

                            GetNumDynamicHashTableEntries (pNewEntry)
                                < MAX_DYNAMIC_HASH_ENTRIES_PER_SLOT)
                        {
                            if (!(pDynamicEntry = ServerAlloc(
                                    sizeof (*pDynamicEntry)
                                    )))
                            {
                                //
                                // Failed to allocate a new dynamic entry,
                                // so we'll reset the call hub id for this
                                // call to zero so as not to confuse things
                                // later
                                //

                                ptCall->dwCallID = 0;
                                ReleaseHashTableWriterLock (ptProvider);

                                FreeHashTable(
                                    pNewHashTable,
                                    dwNewNumHashTableEntries,
                                    dwNewNumDynamicHashTableEntries
                                    );

                                return 0;
                            }

                            pDynamicEntry->pNext = pNewEntry->pNext;
                            pNewEntry->pNext = pDynamicEntry;

                            pNewEntry = pDynamicEntry;

                            dwNewNumDynamicHashTableEntries++;
                        }
                        else
                        {
                            //
                            // Free new table and try for a larger one
                            //

                            FreeHashTable(
                                pNewHashTable,
                                dwNewNumHashTableEntries,
                                dwNewNumDynamicHashTableEntries
                                );

                            i++;

                            goto alloc_new_hash_table;
                        }
                    }

                    pNewEntry->dwCallHubID       = pEntry2->dwCallHubID;
                    pNewEntry->CallHubList.Flink = pEntry2->CallHubList.Flink;
                    pNewEntry->CallHubList.Blink = pEntry2->CallHubList.Blink;
                    pNewEntry->ptCallHubClients  = pEntry2->ptCallHubClients;

                    pEntry2 = pEntry2->pNext;
                }
            }


            //
            // Now init the new entry
            //

            pNewEntry = pNewHashTable +
                (ptCall->dwCallID % dwNewNumHashTableEntries);

            if (pNewEntry->dwCallHubID != 0)
            {
                //
                // Collision, try to add a dynamic entry.
                //
                // We intentionally ignore the dyna entry threshhold
                // checks, as they'd be overkill here.
                //

                if ((pDynamicEntry = ServerAlloc (sizeof(*pDynamicEntry))))
                {
                    pDynamicEntry->pNext = pNewEntry->pNext;
                    pNewEntry->pNext = pDynamicEntry;

                    pNewEntry = pDynamicEntry;

                    dwNewNumDynamicHashTableEntries++;
                }
                else
                {
                    FreeHashTable(
                        pNewHashTable,
                        dwNewNumHashTableEntries,
                        dwNewNumDynamicHashTableEntries
                        );

                    i++;

                    goto alloc_new_hash_table;
                }
            }

            pNewEntry->dwCallHubID       = ptCall->dwCallID;
            pNewEntry->CallHubList.Flink =
            pNewEntry->CallHubList.Blink = &ptCall->CallHubList;


            //
            // Save the old table info (so we can free it & dyna
            // entries later when the lock is released), then save
            // the new table info
            //

            pOldHashTable = ptProvider->pHashTable;
            dwOldNumHashTableEntries = ptProvider->dwNumHashTableEntries;
            dwOldNumDynamicHashTableEntries =
                ptProvider->dwNumDynamicHashTableEntries;


            ptProvider->pHashTable = pNewHashTable;
            ptProvider->dwNumHashTableEntries = dwNewNumHashTableEntries;
            ptProvider->dwNumDynamicHashTableEntries =
                dwNewNumDynamicHashTableEntries;


            //
            // Init the unused table entries and the head & tail
            // list items in the used entries
            //

            pEndOfTable = ptProvider->pHashTable +
                ptProvider->dwNumHashTableEntries;

            for(
                pStaticEntry = ptProvider->pHashTable;
                pStaticEntry != pEndOfTable;
                pStaticEntry++
                )
            {
                if (pStaticEntry->dwCallHubID == 0)
                {
                    InitializeListHead (&pStaticEntry->CallHubList);
                }
                else
                {
                    pEntry2 = pStaticEntry;

                    while (pEntry2)
                    {
                        pEntry2->CallHubList.Flink->Blink =
                        pEntry2->CallHubList.Blink->Flink =
                            &pEntry2->CallHubList;

                        pEntry2 = pEntry2->pNext;
                    }
                }
            }


            //
            // Set pTargetEntry to point to the "new" entry (as expected below)
            //

            pTargetEntry = pNewEntry;
        }


        //
        // Check to see if we need to create any tCallHubClient objects
        //

        SendNewCallHubEvent (ptCall, pTargetEntry);

        //
        // Release the appropriate hash table lock, then if we grew
        // the table free the old table & dynamic table entries
        //

        if (!pOldHashTable)
        {
            ReleaseHashTableEntryLock (ptProvider, pStaticEntry);
        }
        else
        {
            ReleaseHashTableWriterLock (ptProvider);

            FreeHashTable(
                pOldHashTable,
                dwOldNumHashTableEntries,
                dwOldNumDynamicHashTableEntries
                );
        }
    }

    return 0;
}


LONG
PASCAL
CreatetCall(
    PTLINE              ptLine,
    BOOL                bIncoming,
    HDRVCALL            hdCall,
    PTCALL             *pptCall,
    LPLINECALLPARAMS    pCallParams,
    HCALL              *phCall,
    PTCALL              ptCallAssociate
    )
{
    BOOL    bDupedMutex;
    DWORD   dwExtraBytes;
    HANDLE  hMutex;
    PTCALL  ptCall;


    LOG((TL_TRACE,  "CreatetCall: enter, ptLine=%p", ptLine));


    //
    // If there's call params specified check to see if we need to alloc
    // any extra space for the CalledParty, DisplayableAddr, or Comment
    // fields.  Also, if any of these fields are non-NULL make sure to
    // get extra space to keep these fields 64-bit aligned.
    //

    dwExtraBytes = (pCallParams == NULL ? 0 : pCallParams->dwCalledPartySize +
        pCallParams->dwDisplayableAddressSize + pCallParams->dwCommentSize);

    if (dwExtraBytes != 0)
    {
        dwExtraBytes += (sizeof (TCALL) & 4) + 16;
    }


    //
    // Alloc necessary resources
    //

    if (!(ptCall = ServerAlloc (sizeof (TCALL) + dwExtraBytes)))
    {
        return LINEERR_NOMEM;
    }


    //
    // Init tCall & add to tLine's tCall list
    //

    if (bIncoming)
    {
        //
        // This is an incoming call (we're being called by the
        // LINE_NEWCALL handler)
        //

        ptCall->dwKey          = INVAL_KEY;
        ptCall->dwDrvCallFlags = DCF_SPIRETURNED | DCF_DRVCALLVALID;
        ptCall->bAlertApps     = TRUE;
        ptCall->dwCallState    = LINECALLSTATE_UNKNOWN;
        ptCall->hdCall         = hdCall;
    }
    else
    {
        //
        // This is an outgoing call (we're not being called by
        // the LINE_NEWCALL handler)
        //

        ptCall->dwKey = TINCOMPLETECALL_KEY;
    }

    if (pCallParams)
    {
        DWORD dwOffset = sizeof (TCALL) + (sizeof (TCALL) & 4);


        if (pCallParams->dwDisplayableAddressSize != 0)
        {
            CopyMemory(
                (ptCall->pszDisplayableAddress = (WCHAR *)
                    (((LPBYTE) ptCall) + dwOffset)),
                ((LPBYTE) pCallParams) +
                    pCallParams->dwDisplayableAddressOffset,
                (ptCall->dwDisplayableAddressSize =
                    pCallParams->dwDisplayableAddressSize)
                );

            dwOffset += ((ptCall->dwDisplayableAddressSize + 8) & 0xfffffff8);
        }

        if (pCallParams->dwCalledPartySize)
        {
            CopyMemory(
                (ptCall->pszCalledParty = (WCHAR *)
                    (((LPBYTE)ptCall) + dwOffset)),
                ((LPBYTE) pCallParams) + pCallParams->dwCalledPartyOffset,
                (ptCall->dwCalledPartySize = pCallParams->dwCalledPartySize)
                );

            dwOffset += ((ptCall->dwCalledPartySize + 8) & 0xfffffff8);
        }

        if (pCallParams->dwCommentSize)
        {
            CopyMemory(
                (ptCall->pszComment = (WCHAR *)
                    (((LPBYTE) ptCall) + dwOffset)),
                ((LPBYTE) pCallParams) + pCallParams->dwCommentOffset,
                (ptCall->dwCommentSize = pCallParams->dwCommentSize)
                );
        }
    }

    LOG((TL_INFO, "CreatetCall: calling NewObject ptCall %p", ptCall));

    ptCall->hCall = (HCALL) NewObject(
            ghHandleTable,
            ptCall,
            NULL
            );

    LOG((TL_TRACE, "CreatetCall: NewObject returned 0x%lx", ptCall->hCall));
        
    *phCall = ptCall->hCall;

    if (!ptCall->hCall)
    {
        ServerFree (ptCall);
        return LINEERR_NOMEM;
    }

    //
    // Add the new tCall to the tLine's list
    //

    if (WaitForExclusivetLineAccess(
            ptLine,
            &hMutex,
            &bDupedMutex,
            INFINITE
            ))
    {
        ptCall->ptLine     = ptLine;
        ptCall->ptProvider = ptLine->ptProvider;

        if ((ptCall->pNext = ptLine->ptCalls))
        {
           ptCall->pNext->pPrev = ptCall;
        }

        ptLine->ptCalls = ptCall;

        MyReleaseMutex (hMutex, bDupedMutex);
    }
    else
    {
        //
        // tLine was destroyed, so clean up. Note that we return
        // a generic OPFAILED error, since some calling routines
        // might no be spec'd to return INVALLINEHANDLE, etc.
        //

        DereferenceObject (ghHandleTable, ptCall->hCall, 1);
        return LINEERR_OPERATIONFAILED;
    }


    //
    // Fill in caller's pointer & return success
    //

    *pptCall = ptCall;

    PerfBlock.dwTotalOutgoingCalls++;
    PerfBlock.dwCurrentOutgoingCalls++;

    //
    //  For incoming call, the call is ready to be used
    //
    if (bIncoming)
    {
        ptCall->dwKey = TCALL_KEY;
    }

    LOG((TL_TRACE,  "CreatetCall: exit, new ptCall=%p", *pptCall));

    return 0;
}


LONG
PASCAL
CreatetCallClient(
    PTCALL          ptCall,
    PTLINECLIENT    ptLineClient,
    DWORD           dwPrivilege,
    BOOL            bValidate,
    BOOL            bSendCallInfoMsg,
    PTCALLCLIENT   *pptCallClient,
    BOOL            bIndicatePrivilege
    )
{
    BOOL            bFastCallClient, bValidLineClient;
    PTCALLCLIENT    ptCallClient;
    PTLINECLIENT    ptLineClient2 = NULL;


    LOG((TL_TRACE,  "CreatetCallClient: enter, ptCall=%p,", ptCall));

    if (WaitForExclusivetCallAccess(
            ptCall,
            (bValidate ? TCALL_KEY : TINCOMPLETECALL_KEY)
            ))
    {
        if (ptCall->lUsedFastCallClients < DEF_NUM_FAST_CALLCLIENTS)
        {
            ptCallClient = ptCall->aFastCallClients +
                ptCall->lUsedFastCallClients++;
            ptCall->lActiveFastCallClients++;
            bFastCallClient = TRUE;
        }
        else if ((ptCallClient = ServerAlloc (sizeof(TCALLCLIENT))))
        {
            bFastCallClient = FALSE;
        }
        else
        {
            UNLOCKTCALL(ptCall);
            return LINEERR_NOMEM;
        }

        LOG((TL_INFO, "CreatetCallClient: calling NewObject, ptCallClient = [%p]", ptCallClient));

        if (!(ptCallClient->hCall = (HCALL) NewObject(
                ghHandleTable,
                ptCallClient,
                (LPVOID) UIntToPtr(bFastCallClient)
                )))
        {
            if (bFastCallClient)
            {
                ptCall->lActiveFastCallClients--;
                ptCall->lUsedFastCallClients--;
            }
            else
            {
                ServerFree (ptCallClient);
            }

            UNLOCKTCALL(ptCall);
            return LINEERR_NOMEM;
        }

        if (dwPrivilege == LINECALLPRIVILEGE_OWNER)
        {
            ptCall->dwNumOwners++;
        }
        else
        {
            ptCall->dwNumMonitors++;
        }

        if ((ptCallClient->pNextSametCall = ptCall->ptCallClients))
        {
            ptCallClient->pNextSametCall->pPrevSametCall =
                ptCallClient;
        }

        ptCall->ptCallClients = ptCallClient;

        UNLOCKTCALL (ptCall);

        ptCallClient->ptLineClient = ptLineClient;
        ptCallClient->ptCall       = ptCall;
        ptCallClient->dwPrivilege  = dwPrivilege;
        ptCallClient->bIndicatePrivilege = (bIndicatePrivilege ? 1 : 0);
    }
    else
    {
        //
        // tCall was destroyed, so return error. Note that we return
        // a generic OPFAILED error, since some calling routines
        // might not be spec'd to return INVALCALLHANDLE, etc.
        //

        return LINEERR_OPERATIONFAILED;
    }


    //
    // Add to tLineClient's tCallClient list
    //

    LOCKTLINECLIENT (ptLineClient);

    try
    {
        bValidLineClient =
            (ptLineClient->dwKey == TLINECLIENT_KEY ? TRUE : FALSE);
        if (bValidLineClient)
        {
            ptLineClient2 = (PTLINECLIENT) ReferenceObject (
                ghHandleTable,
                ptLineClient->hLine,
                TLINECLIENT_KEY
                );
            if (ptLineClient2 == NULL || ptLineClient != ptLineClient2)
            {
                bValidLineClient = FALSE;
            }
        }
    }
    myexcept
    {
        bValidLineClient = FALSE;
    }

    if (bValidLineClient)
    {
        ptCallClient->ptClient = ptLineClient->ptClient;

        if ((ptCallClient->pNextSametLineClient = ptLineClient->ptCallClients))
        {
            ptCallClient->pNextSametLineClient->pPrevSametLineClient =
                ptCallClient;
        }

        ptLineClient->ptCallClients = ptCallClient;

        if (ptLineClient2)
        {
            DereferenceObject (
                ghHandleTable,
                ptLineClient2->hLine,
                1
                );
        }

        if (ptLineClient->ptLineApp->dwAPIVersion <= TAPI_VERSION3_0)
        {
            FillMemory (
                ptCallClient->adwEventSubMasks, 
                sizeof(DWORD) * EM_NUM_MASKS,
                (BYTE) 0xff
                );
        }
        else
        {
            CopyMemory (
                ptCallClient->adwEventSubMasks, 
                ptLineClient->adwEventSubMasks,
                sizeof(DWORD) * EM_NUM_MASKS
                );
        }

        UNLOCKTLINECLIENT (ptLineClient);
    }
    else
    {
        if (ptLineClient2)
        {
            DereferenceObject (
                ghHandleTable,
                ptLineClient2->hLine,
                1
                );
        }

        UNLOCKTLINECLIENT (ptLineClient);


        //
        // Couldn't add tCallClient to tLineClient's list, so safely
        // remove it from tCall's list, dec the owner or monitor count,
        // free the tCallClient, and return an appropriate error
        //
        // Note that no validation of tCall is necessary - it has to be
        // valid since we previously added a tCallClient to it's list,
        // and that tCallClient's key was not yet validated (so any
        // threads attempting to destroy the tCall would be spinning)
        //

        LOCKTCALL (ptCall);

        if (dwPrivilege == LINECALLPRIVILEGE_OWNER)
        {
            ptCall->dwNumOwners--;
        }
        else
        {
            ptCall->dwNumMonitors--;
        }

        if (ptCallClient->pNextSametCall)
        {
            ptCallClient->pNextSametCall->pPrevSametCall =
                ptCallClient->pPrevSametCall;
        }

        if (ptCallClient->pPrevSametCall)
        {
            ptCallClient->pPrevSametCall->pNextSametCall =
                ptCallClient->pNextSametCall;
        }
        else
        {
            ptCall->ptCallClients = ptCallClient->pNextSametCall;
        }

        if (bFastCallClient)
        {
            ptCall->lActiveFastCallClients--;
        }

        UNLOCKTCALL (ptCall);

        DereferenceObject (ghHandleTable, ptCallClient->hCall, 1);

        return LINEERR_INVALLINEHANDLE;
    }


    //
    // If here success, so mark tCallClient as valid (if another thread
    // was tearing down the corresponding tCall or tLineClient it will
    // have been spinning waiting for us to validate this tCallClient)
    //

    ptCallClient->dwKey = (bValidate ? TCALLCLIENT_KEY :
        TINCOMPLETECALLCLIENT_KEY);


    //
    // Send a call info msg other call clients if appropriate
    //

    if (bSendCallInfoMsg)
    {
        SendMsgToCallClients(
            ptCall,
            ptCallClient,
            LINE_CALLINFO,
            (dwPrivilege == LINECALLPRIVILEGE_OWNER ?
                LINECALLINFOSTATE_NUMOWNERINCR :
                LINECALLINFOSTATE_NUMMONITORS),
            0,
            0
            );
    }


    //
    // Fill in caller's pointer & return success
    //

    *pptCallClient = ptCallClient;

    LOG((TL_TRACE, 
        "CreatetCallClient: exit, new ptCallClient=%p",
        *pptCallClient
        ));

    return 0;
}


LONG
PASCAL
CreatetCallAndClient(
    PTLINECLIENT        ptLineClient,
    PTCALL             *pptCall,
    PTCALLCLIENT       *pptCallClient,
    LPLINECALLPARAMS    pCallParams,
    HCALL              *phCall,
    PTCALL              ptCallAssociate
    )
{
    LONG            lResult = 0;
    DWORD           dwAppNameSize;
    WCHAR          *pszAppName = NULL;
    PTCALL          ptCall = NULL;
    PTLINE          ptLine;

    LOG((TL_TRACE,  "CreatetCallAndClient: enter, ptLineClient=%p", ptLineClient));

    try
    {
        ptLine = ptLineClient->ptLine;

        dwAppNameSize = ptLineClient->ptLineApp->dwFriendlyNameSize;

        if (ptLineClient->dwKey != TLINECLIENT_KEY)
        {
            lResult = LINEERR_INVALLINEHANDLE;
        }
        else if ((pszAppName = ServerAlloc (dwAppNameSize)))
        {
            CopyMemory(
                pszAppName,
                ptLineClient->ptLineApp->pszFriendlyName,
                dwAppNameSize
                );
        }
        else
        {
            lResult = LINEERR_NOMEM;
        }
    }
    myexcept
    {
        ServerFree (pszAppName);
        lResult = LINEERR_INVALLINEHANDLE;
    }

    if (lResult != 0)
    {
        return lResult;
    }

    if ((lResult = CreatetCall(
            ptLine,
            FALSE,
            (HDRVCALL) 0,
            &ptCall,
            pCallParams,
            phCall,
            ptCallAssociate

            )) != 0)
    {
        ServerFree (pszAppName);

        return lResult;
    }

    if ((lResult = CreatetCallClient(
            ptCall,
            ptLineClient,
            LINECALLPRIVILEGE_OWNER,
            FALSE,
            FALSE,
            pptCallClient,
            FALSE

            )) != 0)
    {
        ServerFree (pszAppName);

        ptCall->dwDrvCallFlags = DCF_SPIRETURNED;

        DestroytCall (ptCall);

        *pptCall = (PTCALL) NULL;
        *phCall = 0;
        return lResult;
    }

    ptCall->dwAppNameSize = dwAppNameSize;
    ptCall->pszAppName    = pszAppName;

    *pptCall = ptCall;

    return lResult;
}


LONG
PASCAL
CreateCallMonitors(
    PTCALL  ptCall,
    BOOL    bIncoming
    )
{
    //
    // This func is called by post processing routines when
    // a call was successfully created, or on receiving the
    // first call state message for an incoming call, at
    // which times we want to create call handles for any
    // monitoring apps.
    //
    // Assumes tCall only has has either no clients at all
    // or a single (owner) client
    //
    // Returns the # of monitor call clients created (>=0) or
    // an error value (<0)
    //

    LONG            lResult;
    BOOL            bInitializedMsgs, bRemote, bConfParent = FALSE;
    DWORD           i, dwAddressID, dwCallID, dwRelatedCallID;
    TPOINTERLIST    lineClients, *pLineClients = &lineClients;
    PTLINE          ptLine;
    PTLINECLIENT    ptLineClientOwner;
    ASYNCEVENTMSG   newCallMsg[2], callStateUnkMsg[2];


    //
    // Determine if this call is conf parent and get a list of line clients
    //

    try
    {
        PTCONFERENCELIST    pConfList;

        if ((pConfList = ptCall->pConfList) &&
            (pConfList != (PTCONFERENCELIST) LongToPtr(0xffffffff)) &&
            (pConfList->aptCalls[0] == ptCall))
        {
            bConfParent = TRUE;
        }
        dwAddressID     = ptCall->dwAddressID;
        dwCallID        = ptCall->dwCallID;
        dwRelatedCallID = ptCall->dwRelatedCallID;

        ptLine = (PTLINE) ptCall->ptLine;

        ptLineClientOwner = (ptCall->ptCallClients ?
            ptCall->ptCallClients->ptLineClient : NULL);
    }
    myexcept
    {
        return LINEERR_OPERATIONFAILED;
    }

    if ((lResult = GetLineClientListFromLine (ptLine, &pLineClients)))
    {
        return lResult;
    }


    //
    // Look at each line client in the list, and if it has
    // monitor privileges and is not the one associated with
    // the existing owner call client then create a monitor
    // call client
    //
    //

    bInitializedMsgs = FALSE;

    for (i = 0; i < pLineClients->dwNumUsedEntries; i++)
    {
        PTCALLCLIENT    ptCallClientMonitor;
        PTLINECLIENT    ptLineClient = pLineClients->aEntries[i];
        BOOL            fContinue;


        try
        {
            if (!(ptLineClient->dwPrivileges & LINECALLPRIVILEGE_MONITOR) ||
                (ptLineClient == ptLineClientOwner))
            {
                fContinue = TRUE;
            }
            else
            {
                fContinue = FALSE;

                bRemote = IS_REMOTE_CLIENT (ptLineClient->ptClient);
            }
        }
        myexcept
        {
            //
            // If here the tLineClient or tCallClient was destroyed,
            // just continue
            //

            fContinue = TRUE;
        }


        if (fContinue)
        {
            continue;
        }


        //
        // NOTE: If client is remote(sp) then create the call client
        //       with OWNER privileges so client can still do everything.
        //       The remote tapisrv will deal with all the remote
        //       privilege issues.  We'll still send the appropriate
        //       MONITOR privilege flag so the remote tapisrv will know
        //       not to look for an owner app.
        //
        //       This scheme might end up confusing other apps since
        //       a LINE_CALLINFO\NUMOWNERINCR (not NUMMONITORS) msgs
        //       get sent, but it certainly beats what we had in tapi 2.1 -
        //       that is, if a remote client did not initially have owner
        //       privilege then it could *never* get owner privilege.
        //

        if (CreatetCallClient(
                ptCall,
                ptLineClient,
                (bRemote ? LINECALLPRIVILEGE_OWNER :LINECALLPRIVILEGE_MONITOR),
                TRUE,
                FALSE,
                &ptCallClientMonitor,
                bIncoming

                ) == 0)
        {
            //
            // If this is an incoming call simply increment the number of
            // monitor call clients created and continue.
            //
            // Else this is an outgoing call, so send the monitor app
            // LINE_APPNEWCALL & LINE_CALLSTATE\UNKNOWN messages to alert
            // it of new outgoing call
            //

            if (bIncoming)
            {
                lResult++;
                continue;
            }

            if (!bInitializedMsgs)
            {
                
                
                newCallMsg->TotalSize          = sizeof (ASYNCEVENTMSG) +
                                                    3 * sizeof (DWORD);
                newCallMsg->fnPostProcessProcHandle = 0;
                newCallMsg->Msg                = LINE_APPNEWCALL;
                newCallMsg->Param1             = dwAddressID;
                newCallMsg->Param3             = LINECALLPRIVILEGE_MONITOR;

                *(&newCallMsg->Param4 + 1)     = dwCallID;
                *(&newCallMsg->Param4 + 2)     = dwRelatedCallID;
                *(&newCallMsg->Param4 + 3)     = (DWORD)bConfParent;

                callStateUnkMsg->TotalSize     = sizeof(ASYNCEVENTMSG)
                                                    + sizeof (HCALLHUB);

                callStateUnkMsg->fnPostProcessProcHandle = 0;
                callStateUnkMsg->Msg                = LINE_CALLSTATE;
                callStateUnkMsg->Param1             = LINECALLSTATE_UNKNOWN;

                *((LPHCALLHUB)(callStateUnkMsg + 1)) = (HCALLHUB)0;

                bInitializedMsgs = TRUE;
            }

            try
            {
                //
                // We're presenting the app with a new call handle; for
                // 2.0 & newer apps we indicate this with an APPNEWCALL
                // msg, while older apps just get the privilege field
                // set in the call state msg.
                //

                if (ptLineClient->ptLineApp->dwAPIVersion >= TAPI_VERSION2_0)
                {
                    if (!FMsgDisabled(
                        ptLineClient->ptLineApp->dwAPIVersion,
                        ptLineClient->adwEventSubMasks,
                        LINE_APPNEWCALL,
                        0
                        ))
                    {
                        newCallMsg->InitContext =
                            ptLineClient->ptLineApp->InitContext;
                        newCallMsg->hDevice     = ptLineClient->hRemoteLine;
                        newCallMsg->OpenContext = ptLineClient->OpenContext;
                        newCallMsg->Param2      = ptCallClientMonitor->hCall;

                        WriteEventBuffer (ptLineClient->ptClient, newCallMsg);
                    }

                    callStateUnkMsg->Param3 = 0;
                }
                else
                {
                    callStateUnkMsg->Param3 = LINECALLPRIVILEGE_MONITOR;
                }

                if (FMsgDisabled (
                    ptLineClient->ptLineApp->dwAPIVersion,
                    ptLineClient->adwEventSubMasks,
                    LINE_CALLSTATE,
                    LINECALLSTATE_UNKNOWN
                    ))
                {
                    continue;
                }
                    

                callStateUnkMsg->InitContext =
                    ptLineClient->ptLineApp->InitContext;

                callStateUnkMsg->hDevice     = ptCallClientMonitor->hCall;
                callStateUnkMsg->OpenContext = ptLineClient->OpenContext;
                 
                //
                // Indicate hRemoteLine in p4 to make life easier for remotesp
                //

                callStateUnkMsg->Param4 = ptLineClient->hRemoteLine;


                //
                // REMOTESP HACK: See note in LINE_CALLSTATE msg handler
                //

                if (IS_REMOTE_CLIENT (ptLineClient->ptClient))
                {
                    callStateUnkMsg->Param2 = LINECALLPRIVILEGE_MONITOR;
                    callStateUnkMsg->Param3 = LINEMEDIAMODE_UNKNOWN;
                }
                else
                {
                    callStateUnkMsg->Param2 = 0;
                }

                WriteEventBuffer (ptLineClient->ptClient, callStateUnkMsg);

                lResult++;
            }
            myexcept
            {
                // just continue
            }
        }
    }

    if (pLineClients != &lineClients)
    {
        ServerFree (pLineClients);
    }


    //
    // Now safely set the flag that says it's ok for other routines like
    // lineGetNewCalls to create new call handles for apps for this call
    //

    {
        if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
        {
            //
            // Only do call hub hashing if there's >0 call clients,
            // since the (incoming) call will get destroyed otherwise
            //
            //  $$ Per bug 87355
            //  It is necessary to do DoCallHubHashing even if we do 
            //  not have a client now. So we removed the check for 
            //  ptCall->ptCallClients. For incoming call who has got
            //  an owner, we behave the same; for incoming call without
            //  an owner, we would hash the call for now and remove the
            //  call from hash table when destroying the call, so we 
            //  are safe either way.
            //

            DoCallHubHashing (ptCall, 0);

            ptCall->bCreatedInitialMonitors = TRUE;
            UNLOCKTCALL (ptCall);
        }
        else
        {
            lResult = LINEERR_OPERATIONFAILED;
        }
    }

    return lResult;

}


PTREQUESTRECIPIENT
PASCAL
GetHighestPriorityRequestRecipient(
    void
    )
{
    BOOL               bFoundRecipientInPriorityList = FALSE;
    WCHAR             *pszAppInPriorityList,
                      *pszAppInPriorityListPrev = (WCHAR *) LongToPtr(0xffffffff);
    PTREQUESTRECIPIENT pRequestRecipient,
                       pHighestPriorityRequestRecipient = NULL;


    EnterCriticalSection (&gPriorityListCritSec);

    pRequestRecipient = TapiGlobals.pRequestRecipients;

    while (pRequestRecipient)
    {
        if (TapiGlobals.pszReqMakeCallPriList &&

            (pszAppInPriorityList = wcsstr(
                TapiGlobals.pszReqMakeCallPriList,
                pRequestRecipient->ptLineApp->pszModuleName
                )))
        {
            if (pszAppInPriorityList <= pszAppInPriorityListPrev)
            {
                pHighestPriorityRequestRecipient = pRequestRecipient;
                pszAppInPriorityListPrev = pszAppInPriorityList;

                bFoundRecipientInPriorityList = TRUE;
            }
        }
        else if (!bFoundRecipientInPriorityList)
        {
            pHighestPriorityRequestRecipient = pRequestRecipient;
        }

        pRequestRecipient = pRequestRecipient->pNext;
    }

    LeaveCriticalSection (&gPriorityListCritSec);

    return pHighestPriorityRequestRecipient;
}


void
PASCAL
FreetCall(
    PTCALL  ptCall
    )
{
    if (ptCall->pszAppName)
    {
        ServerFree (ptCall->pszAppName);
    }

    if (ptCall->dwDrvCallFlags & DCF_INCOMINGCALL)
    {
        PerfBlock.dwCurrentIncomingCalls--;
    }
    else
    {
        PerfBlock.dwCurrentOutgoingCalls--;
    }

    DereferenceObject (ghHandleTable, ptCall->hCall, 1);
}


void
PASCAL
DestroytCall(
    PTCALL  ptCall
    )
{
    DWORD   dwKey;


    LOG((TL_TRACE, "DestroytCall: enter, ptCall=x%p", ptCall));


    //
    // Safely get the call's current key, then grab the call's lock.
    // The two waits allow us to deal with the case where the tCall's
    // key is either TINCOMPLETECALL_KEY or TCALL_KEY, or changing
    // from the former to the latter (the completion proc was called)
    //

    try
    {
        dwKey = (ptCall->dwKey == TCALL_KEY ? TCALL_KEY : TINCOMPLETECALL_KEY);
    }
    myexcept
    {
        LOG((TL_ERROR, "DestroytCall: excepted looking at key"));
        return;
    }

    if (WaitForExclusivetCallAccess (ptCall, dwKey) ||
        WaitForExclusivetCallAccess (ptCall, TCALL_KEY))

    {
        PTPROVIDER  ptProvider;
        PTCALL      ptCall2;

        ptCall2 = ReferenceObject (
            ghHandleTable,
            ptCall->hCall,
            dwKey
            );
        if (ptCall2)
        {
            DereferenceObject (
                ghHandleTable,
                ptCall2->hCall,
                1
                );
        }
        if (ptCall2 == NULL || ptCall != ptCall2)
        {
            UNLOCKTCALL (ptCall);
            return;
        }


        //
        // Invalidate the tCall
        //

        ptCall->dwKey = TZOMBIECALL_KEY;
        UNLOCKTCALL (ptCall);


        //
        // If the provider has not returned from it's call-creation
        // routine yet (i.e. TSPI_lineMakeCall) wait for it to do so
        //

        while (!(ptCall->dwDrvCallFlags & DCF_SPIRETURNED))
        {
            Sleep (0);
        }

        ptProvider = ptCall->ptProvider;


        //
        // Remove tCall from call hub list if appropriate
        //
        // Note that there's a window of time between which the call IDs
        // are retrieved and the call is inserted in a hash time, and so
        // we need to check for that case as well (CallHubList.Flink == 0)
        //

        if (ptCall->dwCallID != 0)
        {
            PTHASHTABLEENTRY    pStaticEntry, pEntry;


            pStaticEntry = AcquireHashTableEntryLock(
                ptCall->ptProvider,
                ptCall->dwCallID
                );

            if (ptCall->CallHubList.Flink == 0 ||
                ptCall->CallHubList.Blink == 0)
            {
                ReleaseHashTableEntryLock (ptCall->ptProvider, pStaticEntry);
                goto finished_callhubID;
            }

            RemoveEntryList (&ptCall->CallHubList);
            ptCall->CallHubList.Flink = NULL;
            ptCall->CallHubList.Blink = NULL;

            pEntry = (pStaticEntry->dwCallHubID == ptCall->dwCallID ?
                pStaticEntry :
                FindDynamicHashTableEntry (pStaticEntry, ptCall->dwCallID)
                );

            if (IsListEmpty (&pEntry->CallHubList))
            {
                PTCALLHUBCLIENT  ptCallHubClient, pNext;


                ptCallHubClient = pEntry->ptCallHubClients;

                if (pEntry == pStaticEntry)
                {
                    pStaticEntry->dwCallHubID = 0;
                    pStaticEntry->ptCallHubClients = NULL;
                }
                else
                {
                    RemoveDynamicHashTableEntry(
                        ptProvider,
                        pStaticEntry,
                        pEntry
                        );
                }

                ReleaseHashTableEntryLock (ptCall->ptProvider, pStaticEntry);

                if (ptCallHubClient)
                {
                    ASYNCEVENTMSG   msg;

                    msg.TotalSize          = sizeof (ASYNCEVENTMSG);
                    msg.Msg                = LINE_CALLHUBCLOSE;
                    msg.fnPostProcessProcHandle = 0;
                    msg.hDevice            = 0;
                    msg.OpenContext        = 0;
                    msg.Param2             = 0;
                    msg.Param3             = 0;

                    while (ptCallHubClient)
                    {
                        msg.Param1 = ptCallHubClient->hCallHub;

                        try
                        {
                            msg.InitContext =
                                ptCallHubClient->ptLineApp->InitContext;

                            if (ptCallHubClient->ptLineApp->dwKey ==
                                    TLINEAPP_KEY &&
                                (!FMsgDisabled(
                                    ptCallHubClient->ptLineApp->dwAPIVersion,
                                    ptCallHubClient->ptLineApp->adwEventSubMasks,
                                    LINE_CALLHUBCLOSE,
                                    0
                                    )))
                            {
                                WriteEventBuffer(
                                    ptCallHubClient->ptClient,
                                    &msg
                                    );
                            }
                        }
                        except (EXCEPTION_EXECUTE_HANDLER)
                        {
                            // tLineApp is gone, just fall through
                        }

                        pNext = ptCallHubClient->pNext;
                        ptCallHubClient->dwKey = INVAL_KEY;

                        DereferenceObject(
                            ghHandleTable, 
                            ptCallHubClient->hCallHub,
                            1
                            );

                        ptCallHubClient = pNext;
                    }
                }
            }
            else
            {
                ReleaseHashTableEntryLock (ptCall->ptProvider, pStaticEntry);
            }
        }
        
finished_callhubID:

        //
        // Destroy all the tCallClient's
        //

        if (ptCall->ptCallClients)
        {
            while (ptCall->ptCallClients)
            {
                DestroytCallClient (ptCall->ptCallClients);
            }
        }


        //
        // Tell the provider to close the call, but only if the hdCall
        // is valid (we might be destroying a call that
        // LMakeCall_PostProcess would normally destroy in the event
        // of a failed make-call request, and we wouldn't want to pass
        // an invalid hdCall to the driver)
        //

        if (ptCall->dwDrvCallFlags & DCF_DRVCALLVALID)
        {
            if (ptProvider->dwTSPIOptions & LINETSPIOPTION_NONREENTRANT)
            {
                WaitForSingleObject (ptProvider->hMutex, INFINITE);
            }

            if (ptProvider->apfn[SP_LINECLOSECALL])
            {
                CallSP1(
                    ptProvider->apfn[SP_LINECLOSECALL],
                    "lineCloseCall",
                    SP_FUNC_SYNC,
                    (ULONG_PTR) ptCall->hdCall
                    );
            }

            if (ptProvider->dwTSPIOptions & LINETSPIOPTION_NONREENTRANT)
            {
                ReleaseMutex (ptProvider->hMutex);
            }
        }


        //
        // Remove tCall from the tLine's tCall list
        //

        RemoveCallFromLineList (ptCall);


        //
        // Free the resources
        //

        {
            PTCONFERENCELIST    pConfList;


            if ((pConfList = ptCall->pConfList) &&
                (pConfList != (PTCONFERENCELIST) LongToPtr(0xffffffff)))
            {
                DWORD   i;

                if (pConfList->aptCalls[0] == ptCall)
                {
                    //
                    // We're destroying a conf parent so we want to zero
                    // out the pConfList field of all the conf children,
                    // essentially removing them from the conference.
                    //

                    TPOINTERLIST    confCallList,
                                    *pConfCallList = &confCallList;


                    if (GetConfCallListFromConf(
                            pConfList,
                            &pConfCallList

                            ) == 0)
                    {
                        for(
                            i = 1;
                            i < pConfCallList->dwNumUsedEntries;
                            i++
                            )
                        {
                            SetCallConfList(
                                pConfCallList->aEntries[i],
                                NULL,
                                FALSE
                                );
                        }

                        if (pConfCallList != &confCallList)
                        {
                            ServerFree (pConfCallList);
                        }
                    }

                    while (pConfList)
                    {
                        PTCONFERENCELIST    pNextConfList =
                                                pConfList->pNext;


                        ServerFree (pConfList);
                        pConfList = pNextConfList;
                    }
                }
                else
                {
                }
            }
        }

        while (ptCall->lActiveFastCallClients != 0)
        {
            Sleep (5);
        }

        FreetCall (ptCall);
    }
    else
    {
        LOG((TL_ERROR, "DestroytCall: two waits failed!"));
    }

}


void
PASCAL
DestroytCallClient(
    PTCALLCLIENT    ptCallClient
    )
{
    BOOL            bUnlock = FALSE,
                    bExit = TRUE,
                    bDestroytCall,
                    bSendCallInfoMsgs,
                    bFastCallClient;
    HCALL           hCall;
    PTCALL          ptCall;
    PTCALLCLIENT    ptCallClient2;


    LOG((TL_TRACE, "DestroytCallClient: enter, ptCallCli=x%p", ptCallClient));

    //
    // Check that this is a valid tCallClient, & if so lock the
    // corresponding tCall (and recheck)
    //

    try
    {
        if (ptCallClient->dwKey == TINCOMPLETECALLCLIENT_KEY ||
            ptCallClient->dwKey == TCALLCLIENT_KEY)
        {
            ptCall = ptCallClient->ptCall;

            LOCKTCALL (ptCall);

            bUnlock = TRUE;

            //
            //  Check to be sure we are working on a valid memory
            //
            
            ptCallClient2 = ReferenceObject (
                ghHandleTable,
                ptCallClient->hCall,
                ptCallClient->dwKey
                );
            if (ptCallClient2 != NULL)
            {
                DereferenceObject (
                    ghHandleTable,
                    ptCallClient2->hCall,
                    1
                    );
            }

            if ((ptCallClient->dwKey == TINCOMPLETECALLCLIENT_KEY ||
                ptCallClient->dwKey == TCALLCLIENT_KEY) &&
                ptCall == ptCallClient->ptCall &&
                ptCallClient2 == ptCallClient)

            {
                //
                // We can continue detroying this tCallClient
                //
                bExit = FALSE;
            }
        }
    }
    myexcept
    {
        LOG((TL_ERROR, "DestroytCallClient: %lx faulted looking at key",
                     ptCallClient ));
    }

    if (bExit)
    {
        if (bUnlock)
        {
            UNLOCKTCALL (ptCall);
        }

        return;
    }


    //
    // Mark tCallClient as bad
    //

    ptCallClient->dwKey = INVAL_KEY;


    //
    // Munge tCall's num owners/monitors fields
    //

    if (ptCallClient->dwPrivilege == LINECALLPRIVILEGE_OWNER)
    {
        ptCall->dwNumOwners--;

        //
        // NOTE: per bug #20545 we're no longer auto-dropping
        //       non-IDLE calls; figured this would be the
        //       wrong thing to do in a distributed system
        //
        //       dankn 02/15/96
        //
    }
    else
    {
        ptCall->dwNumMonitors--;

        //
        // NOTE: per bug #20545 we're no longer auto-dropping
        //       non-IDLE calls; figured this would be the
        //       wrong thing to do in a distributed system
        //
        //       dankn 02/15/96
        //
    }


    //
    // Remove it from the tCall's tCallClient list
    //

    bDestroytCall = FALSE;
    bSendCallInfoMsgs = (ptCall->dwKey == TCALL_KEY ? TRUE : FALSE);

    if (ptCallClient->pNextSametCall)
    {
        ptCallClient->pNextSametCall->pPrevSametCall =
            ptCallClient->pPrevSametCall;
    }

    if (ptCallClient->pPrevSametCall)
    {
        ptCallClient->pPrevSametCall->pNextSametCall =
            ptCallClient->pNextSametCall;
    }
    else if (ptCallClient->pNextSametCall)
    {
        ptCall->ptCallClients = ptCallClient->pNextSametCall;
    }
    else // last call client so destroy the tCall too
    {
        ptCall->ptCallClients = NULL;
        bDestroytCall = TRUE;
    }

    UNLOCKTCALL (ptCall);


    //
    // Remove tCallClient from the tLineClient's tCallClient list
    //

    RemoveCallClientFromLineClientList (ptCallClient);


    //
    // Save the hCall in a local because it won't be safe to access
    // ptCallClient->hCall once we've decremented
    // ptCall->lActiveFastCallClients below
    //

    hCall = ptCallClient->hCall;


    //
    // If this is a fast call client decrement the number of active
    // fast call clients prior to calling DestroytCall
    //

    bFastCallClient = (ptCallClient >= ptCall->aFastCallClients &&
        ptCallClient < (ptCall->aFastCallClients + DEF_NUM_FAST_CALLCLIENTS));

    if (bFastCallClient)
    {
        InterlockedDecrement (&ptCall->lActiveFastCallClients);
    }

    if (bDestroytCall)
    {
        DestroytCall (ptCall);
        bSendCallInfoMsgs = FALSE;
    }


    //
    // Send call info msgs as appropriate
    //

    if (bSendCallInfoMsgs)
    {
        SendMsgToCallClients(
            ptCall,
            NULL,
            LINE_CALLINFO,
            (ptCallClient->dwPrivilege ==
                LINECALLPRIVILEGE_OWNER ?
                LINECALLINFOSTATE_NUMOWNERDECR :
                LINECALLINFOSTATE_NUMMONITORS),
            0,
            0
            );
    }


    //
    // Decrement reference count remove the initial (creation) reference
    //

    DereferenceObject (ghHandleTable, hCall, 1);
}


void
PASCAL
DestroytLine(
    PTLINE  ptLine,
    BOOL    bUnconditional
    )
{
    BOOL    bCloseMutex;
    HANDLE  hMutex;


    LOG((TL_TRACE, 
        "DestroytLine: enter, ptLine=x%p, bUnconditional=%d",
        ptLine,
        bUnconditional
        ));

    if (WaitForExclusivetLineAccess(
            ptLine,
            &hMutex,
            &bCloseMutex,
            INFINITE
            ))
    {
        //
        // If the key is bad another thread is in the process of
        // destroying this widget, so just release the mutex &
        // return. Otherwise, if this is a conditional destroy
        // & there are existing clients (which can happen when
        // one app is closing the last client just as another app
        // is creating one) just release the mutex & return.
        // Otherwise, mark the widget as bad and proceed with
        // the destroy; also, send CLOSE msgs to all the clients
        // (note that we have to do this manually rather than via
        // SendMsgToLineClients since 1) we don't want to hold the
        // mutex when sending msgs [deadlock], and 2) we mark the
        // dwKey as invalid)
        //

        {
            BOOL            bExit;
            TPOINTERLIST    fastClientList, *pClientList = &fastClientList;


            if (ptLine->dwKey == TLINE_KEY &&
                (bUnconditional == TRUE  ||  ptLine->ptLineClients == NULL))
            {
                if (GetLineClientListFromLine (ptLine, &pClientList) != 0)
                {
                    //
                    // If here we know there's at least a few entries
                    // in the fastClientList (DEF_NUM_PTR_LIST_ENTRIES
                    // to be exact), so we'll just work with that list
                    // and at least get msgs out to a few clients
                    //

                    pClientList = &fastClientList;

                    fastClientList.dwNumUsedEntries =
                        DEF_NUM_PTR_LIST_ENTRIES;
                }

                ptLine->dwKey = INVAL_KEY;
                bExit = FALSE;
            }
            else
            {
                bExit = TRUE;
            }

            MyReleaseMutex (hMutex, bCloseMutex);

            if (bExit)
            {
                LOG((TL_TRACE, 
                    "DestroytLine: exit, didn't destroy tLine=x%p",
                    ptLine
                    ));

                return;
            }

            if (pClientList->dwNumUsedEntries)
            {
                DWORD           i;
                PTCLIENT        ptClient;
                PTLINECLIENT    ptLineClient;
                ASYNCEVENTMSG   msg;


                ZeroMemory (&msg, sizeof (msg));

                msg.TotalSize = sizeof (ASYNCEVENTMSG);
                msg.Msg       = LINE_CLOSE;

                for (i = 0; i < pClientList->dwNumUsedEntries; i++)
                {
                    ptLineClient = (PTLINECLIENT) pClientList->aEntries[i];

                    try
                    {
                        msg.InitContext = ptLineClient->ptLineApp->InitContext;
                        msg.hDevice     = ptLineClient->hRemoteLine;
                        msg.OpenContext = ptLineClient->OpenContext;

                        ptClient = ptLineClient->ptClient;

                        if (ptLineClient->dwKey == TLINECLIENT_KEY &&
                            (!FMsgDisabled(
                                ptLineClient->ptLineApp->dwAPIVersion,
                                ptLineClient->adwEventSubMasks,
                                LINE_CLOSE,
                                0
                                )))
                        {
                            WriteEventBuffer (ptClient, &msg);
                        }
                    }
                    myexcept
                    {
                        // do nothing
                    }
                }
            }

            if (pClientList != &fastClientList)
            {
                ServerFree (pClientList);
            }
        }


        //
        // Destroy all the widget's clients.  Note that we want to
        // grab the mutex (and we don't have to dup it, since this
        // thread will be the one to close it) each time we reference
        // the list of clients, since another thread might be
        // destroying a client too.
        //

        {
            HLINE   hLine;


            hMutex = ptLine->hMutex;

destroy_tLineClients:

            WaitForSingleObject (hMutex, INFINITE);

            hLine = (ptLine->ptLineClients ?
                ptLine->ptLineClients->hLine : (HLINE) 0);

            ReleaseMutex (hMutex);

            if (hLine)
            {
                DestroytLineClient (hLine);
                goto destroy_tLineClients;
            }
        }


        //
        // There may yet be some tCall's hanging around, i.e. incoming
        // calls that we have not processed the 1st call state msg for
        // and hence have no associated owner/monitor that would have
        // been destroyed in the loop above, so destroy any of these
        // before proceeding
        //
        //

        {
            PTCALL  ptCall;


destroy_UnownedtCalls:

            WaitForSingleObject (hMutex, INFINITE);

            ptCall = ptLine->ptCalls;

            ReleaseMutex (hMutex);

            if (ptCall)
            {
                DestroytCall (ptCall);
                goto destroy_UnownedtCalls;
            }
        }


        //
        // Tell the provider to close the widget
        //

        {
            PTPROVIDER          ptProvider = ptLine->ptProvider;

            if (ptProvider->dwTSPIOptions & LINETSPIOPTION_NONREENTRANT)
            {
                WaitForSingleObject (ptProvider->hMutex, INFINITE);
            }

            if ( ptProvider->apfn[SP_LINECLOSE] )
            {
                CallSP1(
                    ptProvider->apfn[SP_LINECLOSE],
                    "lineClose",
                    SP_FUNC_SYNC,
                    (ULONG_PTR) ptLine->hdLine
                    );
            }

            if (ptProvider->dwTSPIOptions & LINETSPIOPTION_NONREENTRANT)
            {
                ReleaseMutex (ptProvider->hMutex);
            }
        }


        //
        // NULLify the ptLine field in the lookup entry, so LOpen will
        // know it has to open the SP's line on the next open request
        //

        {
            PTLINELOOKUPENTRY   pEntry;


            pEntry = GetLineLookupEntry (ptLine->dwDeviceID);
            if (NULL != pEntry)
            {
                pEntry->ptLine = NULL;
            }
        }

        DereferenceObject (ghHandleTable, ptLine->hLine, 1);
    }
    else
    {
        LOG((TL_ERROR, 
        "DestroytLine: WaitForExclusivetLineAccess failed"
        ));
    }

    // PERF

    if (PerfBlock.dwLinesInUse)
    {
        PerfBlock.dwLinesInUse--;
    }
    else
    {
        LOG((TL_INFO, "PERF: dwNumLinesInUse below 0"));
    }

    LOG((TL_TRACE,  "DestroytLine: exit, destroyed line=x%p", ptLine));
}


void
PASCAL
DestroytLineClient(
    HLINE   hLine
    )
{
    BOOL            bDupedMutex;
    HANDLE          hMutex;
    PTLINECLIENT    ptLineClient;


    LOG((TL_TRACE,  "DestroytLineClient: enter, hLine=x%x", hLine));

    if (!(ptLineClient = ReferenceObject (ghHandleTable, hLine, 0)))
    {
        return;
    }


    //
    // If we can get exclusive access to this tLineClient then mark
    // it (the dwKey) as bad & continue with teardown.  Else, another
    // thread is already in the process of destrying this tLineClient
    //
    //

    if (WaitForExclusiveLineClientAccess (ptLineClient))
    {
        BOOL    bSendDevStateCloseMsg = FALSE;
        DWORD   dwProxyCloseMsgs = 0;
        PTLINE  ptLine;
        PTPROVIDER ptProvider = ptLineClient->ptLine->ptProvider;
        HANDLE  hProviderMutex = NULL;


        if (ptProvider->dwTSPIOptions & LINETSPIOPTION_NONREENTRANT)
        {
            hProviderMutex = ptProvider->hMutex;
        }

        ptLineClient->dwKey = INVAL_KEY;

        //
        //  Remove the proxy server publishing if any
        //
        if (ptLineClient->szProxyClsid)
        {
            OnProxyLineClose (ptLineClient->szProxyClsid);
            ServerFree (ptLineClient->szProxyClsid);
        }

        //
        // Destroy all the tCallClients.  Note that we want to grab the
        // lock each time we reference the list of tCallClient's, since
        // another thread might be destroying a tCallClient too.
        //

        {
            PTCALLCLIENT    ptCallClient;


destroy_tCallClients:

            ptCallClient = ptLineClient->ptCallClients;

            UNLOCKTLINECLIENT (ptLineClient);

            if (ptCallClient)
            {
                DestroytCallClient (ptCallClient);
                LOCKTLINECLIENT (ptLineClient);
                goto destroy_tCallClients;
            }
        }


        //
        // Remove tLineClient from tLineApp's list.  Note that we don't
        // have to worry validating the tLineApp here, since we know
        // it's valid (another thread trying to destroy the tLineApp
        // will be spinning until the tLineClient we're destroying here
        // is removed from the tLineApp's list)
        //

        {
            PTLINEAPP   ptLineApp = (PTLINEAPP) ptLineClient->ptLineApp;


            LOCKTLINEAPP (ptLineApp);

            if (ptLineClient->pNextSametLineApp)
            {
                ptLineClient->pNextSametLineApp->pPrevSametLineApp =
                    ptLineClient->pPrevSametLineApp;
            }

            if (ptLineClient->pPrevSametLineApp)
            {
                ptLineClient->pPrevSametLineApp->pNextSametLineApp =
                    ptLineClient->pNextSametLineApp;
            }
            else
            {
                ptLineApp->ptLineClients = ptLineClient->pNextSametLineApp;
            }

            UNLOCKTLINEAPP (ptLineApp);
        }


        //
        // Grab the tLine's mutex & start munging.  Note that we don't
        // have to worry about dup-ing the mutex here because we know
        // it's valid & won't get closed before we release it.
        //

        ptLine = ptLineClient->ptLine;
        hMutex = ptLine->hMutex;
        WaitForSingleObject (hMutex, INFINITE);


        //
        // If client had call hub tracking enabled then adjust tLine
        //

        if (ptLineClient->dwCurrentTracking)
        {
            --ptLine->dwNumCallHubTrackers;

            if ((ptLineClient->dwCurrentTracking &
                    LINECALLHUBTRACKING_PROVIDERLEVEL) &&
                (--ptLine->dwNumCallHubTrackersSPLevel == 0))
            {
                const LINECALLHUBTRACKINGINFO trackingInfo =
                {
                    sizeof (LINECALLHUBTRACKINGINFO),
                    sizeof (LINECALLHUBTRACKINGINFO),
                    sizeof (LINECALLHUBTRACKINGINFO),
                    0,
                    LINECALLHUBTRACKING_NONE
                };


                if (hProviderMutex)
                {
                    WaitForSingleObject (hProviderMutex, INFINITE);
                }
                if (ptLine->ptProvider->apfn[SP_LINESETCALLHUBTRACKING])
                {
                    CallSP2(
                        ptLine->ptProvider->apfn[SP_LINESETCALLHUBTRACKING],
                        "lineSetCallHubTracking",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) ptLine->hdLine,
                        (ULONG_PTR) &trackingInfo
                        );
                }
                if (hProviderMutex)
                {
                    ReleaseMutex (hProviderMutex);
                }
            }
        }


        //
        // If client registered as a proxy then unregister it
        //

        if (ptLineClient->dwPrivileges & LINEOPENOPTION_PROXY)
        {
            DWORD i;

            for(
                i = LINEPROXYREQUEST_SETAGENTGROUP;
                i <= LINEPROXYREQUEST_LASTVALUE;
                i++
                )
            {
                if (ptLine->apProxys[i] == ptLineClient)
                {
                    //
                    // Alert other clients that a proxy close has occured
                    //

                    LOG((TL_INFO, "tell clients proxy %02X closed", i));

                    dwProxyCloseMsgs |= (1 << (i - 1));

                    ptLine->apProxys[i] = NULL;
                }
            }
        }


        //
        //
        //

        if (ptLineClient->dwExtVersion)
        {
            if ((--ptLine->dwExtVersionCount) == 0)
            {
                if (hProviderMutex)
                {
                    WaitForSingleObject (hProviderMutex, INFINITE);
                }
                if (ptLine->ptProvider->apfn[SP_LINESELECTEXTVERSION])
                {
                    CallSP2(
                        ptLine->ptProvider->apfn[SP_LINESELECTEXTVERSION],
                        "lineSelectExtVersion",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) ptLine->hdLine,
                        (DWORD) 0
                        );
                }
                if (hProviderMutex)
                {
                    ReleaseMutex (hProviderMutex);
                }

                ptLine->dwExtVersion = 0;
            }
        }


        //
        // Remove the tLineClient from the tLine's list & decrement
        // the number of opens
        //

        if (ptLineClient->pNextSametLine)
        {
            ptLineClient->pNextSametLine->pPrevSametLine =
                ptLineClient->pPrevSametLine;
        }

        if (ptLineClient->pPrevSametLine)
        {
            ptLineClient->pPrevSametLine->pNextSametLine =
                ptLineClient->pNextSametLine;
        }
        else
        {
            ptLine->ptLineClients = ptLineClient->pNextSametLine;
        }

        ptLine->dwNumOpens--;


        //
        // See if we need to reset the monitored media modes or close
        // the tLine (still hanging on the the mutex)
        //

        if (ptLine->dwKey == TLINE_KEY)
        {
            LOG((TL_INFO, "It's a line_key"));
            if (ptLine->ptLineClients)
            {
                LOG((TL_INFO, "...and there are still clients"));
                if (ptLine->dwOpenMediaModes && ptLineClient->dwMediaModes)
                {
                    DWORD           dwUnionMediaModes = 0;
                    PTLINECLIENT    ptLineClientTmp =
                                        ptLine->ptLineClients;


                    while (ptLineClientTmp)
                    {
                        if (ptLineClientTmp->dwPrivileges &
                                LINECALLPRIVILEGE_OWNER)
                        {
                            dwUnionMediaModes |=
                                ptLineClientTmp->dwMediaModes;
                        }

                        ptLineClientTmp = ptLineClientTmp->pNextSametLine;
                    }

                    if (dwUnionMediaModes != ptLine->dwOpenMediaModes)
                    {
                        LONG        lResult;

                        if (hProviderMutex)
                        {
                            WaitForSingleObject (hProviderMutex, INFINITE);
                        }
                        if (ptLine->ptProvider->apfn
                                [SP_LINESETDEFAULTMEDIADETECTION])
                        {
                            lResult = CallSP2(
                                ptLine->ptProvider->apfn
                                    [SP_LINESETDEFAULTMEDIADETECTION],
                                "lineSetDefaultMediaDetection",
                                SP_FUNC_SYNC,
                                (ULONG_PTR) ptLine->hdLine,
                                (DWORD) dwUnionMediaModes
                                );
                        }
                        else
                        {
                            lResult = LINEERR_OPERATIONUNAVAIL;
                        }
                        if (hProviderMutex)
                        {
                            ReleaseMutex (hProviderMutex);
                        }

                        ptLine->dwOpenMediaModes = dwUnionMediaModes;
                    }
                }

                bSendDevStateCloseMsg = TRUE;


                //
                // See if we need to reset the status msgs (if so, make
                // sure to check/set the busy flag & not to hold the
                // mutex while calling down to provider - see comments
                // in LSetStatusMessages)
                //

                if ((ptLineClient->dwLineStates & ~LINEDEVSTATE_REINIT) ||
                    ptLineClient->dwAddressStates)
                {
                    DWORD           dwUnionLineStates = 0,
                                    dwUnionAddressStates = 0;
                    PTLINECLIENT    ptLC;


                    while (ptLine->dwBusy)
                    {
                        BOOL    bClosed = TRUE;


                        ReleaseMutex (hMutex);
                        Sleep (50);
                        WaitForSingleObject (hMutex, INFINITE);

                        try
                        {
                            if (ptLine->dwKey == TLINE_KEY)
                            {
                                bClosed = FALSE;
                            }
                        }
                        myexcept
                        {
                            // do nothing
                        }

                        if (bClosed)
                        {
                            goto releasMutex;
                        }
                    }

                    for(
                        ptLC = ptLine->ptLineClients;
                        ptLC;
                        ptLC = ptLC->pNextSametLine
                        )
                    {
                        dwUnionLineStates    |= ptLC->dwLineStates;
                        dwUnionAddressStates |= ptLC->dwAddressStates;
                    }

                    if ((dwUnionLineStates != ptLine->dwUnionLineStates)  ||
                        (dwUnionAddressStates != ptLine->dwUnionAddressStates))
                    {
                        if (ptLine->ptProvider->apfn[SP_LINESETSTATUSMESSAGES])
                        {
                            LONG        lResult;
                            TSPIPROC    pfn;
                            HDRVLINE    hdLine = ptLine->hdLine;


                            pfn = ptLine->ptProvider->
                                apfn[SP_LINESETSTATUSMESSAGES];

                            ptLine->dwBusy = 1;

                            ReleaseMutex (hMutex);

                            if (hProviderMutex)
                            {
                                WaitForSingleObject (hProviderMutex, INFINITE);
                            }
                            lResult = CallSP3(
                                pfn,
                                "lineSetStatusMessages",
                                SP_FUNC_SYNC,
                                (ULONG_PTR) hdLine,
                                (DWORD) dwUnionLineStates,
                                (DWORD) dwUnionAddressStates
                                );
                                if (hProviderMutex)
                                {
                                    ReleaseMutex (hProviderMutex);
                                }

                            WaitForSingleObject (hMutex, INFINITE);

                            try
                            {
                                if (ptLine->dwKey == TLINE_KEY)
                                {
                                    ptLine->dwBusy = 0;

                                    if (lResult == 0)
                                    {
                                        ptLine->dwUnionLineStates =
                                            dwUnionLineStates;
                                        ptLine->dwUnionAddressStates =
                                            dwUnionAddressStates;
                                    }
                                }
                            }
                            myexcept
                            {
                                // do nothing
                            }
                        }
                    }
                }
            }
            else
            {
                //
                // This was the last client so destroy the tLine too
                //

                LOG((TL_INFO, "...and it's the last one out"));

                ReleaseMutex (hMutex);
                hMutex = NULL;
                DestroytLine (ptLine, FALSE); // conditional destroy
            }
        }

releasMutex:

        if (hMutex)
        {
            ReleaseMutex (hMutex);
        }


        //
        // Now that the mutex is released send any necessary msgs
        //

        if (bSendDevStateCloseMsg)
        {
            DWORD   dwOrdinal, dwBitFlag;


            SendMsgToLineClients(
                ptLine,
                NULL,
                LINE_LINEDEVSTATE,
                LINEDEVSTATE_CLOSE,
                0,
                0
                );

            for(
                dwOrdinal = LINEPROXYREQUEST_SETAGENTGROUP, dwBitFlag = 1;
                dwProxyCloseMsgs != 0;
                dwOrdinal++, dwBitFlag <<= 1)
            {
                if (dwProxyCloseMsgs & dwBitFlag)
                {
                    SendMsgToLineClients(
                        ptLine,
                        NULL,
                        LINE_PROXYSTATUS,
                        LINEPROXYSTATUS_CLOSE,
                        dwOrdinal,              // LINEPROXYREQUEST_xx
                        0
                        );

                    dwProxyCloseMsgs ^= dwBitFlag;
                }
            }
        }


        //
        // Complete any remaining
        // proxy requests
        //

        if (ptLineClient->dwPrivileges & LINEOPENOPTION_PROXY)
        {
            PASYNCREQUESTINFO   pAsyncRequestInfo =
                                    ptLineClient->pPendingProxyRequests,
                                pNextAsyncRequestInfo;


            while (pAsyncRequestInfo)
            {
                pNextAsyncRequestInfo = (PASYNCREQUESTINFO)
                    pAsyncRequestInfo->dwParam5;

                pAsyncRequestInfo->dwKey = TASYNC_KEY;

                CompletionProc (pAsyncRequestInfo, LINEERR_OPERATIONUNAVAIL);

                DereferenceObject(
                    ghHandleTable,
                    pAsyncRequestInfo->dwLocalRequestID,
                    1
                    );

                pAsyncRequestInfo = pNextAsyncRequestInfo;
            }
        }


        //
        // Free resources
        //

        if (ptLineClient->aNumRings)
        {
            ServerFree (ptLineClient->aNumRings);
        }


        //
        // Decrement reference count by two to remove the initial
        // reference & the reference above
        //

        DereferenceObject (ghHandleTable, hLine, 2);
    }
    else
    {
        DereferenceObject (ghHandleTable, hLine, 1);

        LOG((TL_ERROR, "DestroytLineClient: WaitForExclLineClientAccess failed!"));
    }

}


LONG
PASCAL
DestroytLineApp(
    HLINEAPP    hLineApp
    )
{
    PTCLIENT    ptClient;
    PTLINEAPP   ptLineApp;


    LOG((TL_TRACE,  "DestroytLineApp: enter, hLineApp=x%x", hLineApp));


    if (!(ptLineApp = ReferenceObject (ghHandleTable, hLineApp, TLINEAPP_KEY)))
    {
        return (TapiGlobals.dwNumLineInits ?
                    LINEERR_INVALAPPHANDLE : LINEERR_UNINITIALIZED);
    }


    //
    // See if this this is a valid tLineApp, & if so grab the lock
    // and mark it as bad, then continue teardown.  Else, another
    // thread is in the processing of tearing down this tLineApp,
    // so return.
    //

    LOCKTLINEAPP (ptLineApp);

    if (ptLineApp->dwKey != TLINEAPP_KEY)
    {
        UNLOCKTLINEAPP (ptLineApp);
        DereferenceObject (ghHandleTable, hLineApp, 1);
        return (TapiGlobals.dwNumPhoneInits ?
                    LINEERR_INVALAPPHANDLE : LINEERR_UNINITIALIZED);
    }

    ptLineApp->dwKey = INVAL_KEY;
    ptClient = (PTCLIENT) ptLineApp->ptClient;


    //
    // Destroy all the tLineClients.  Note that we want to grab the
    // lock each time we reference the list of tLineClient's, since
    // another thread might be destroying a tLineClient too.
    //

    {
        HLINE   hLine;


destroy_tLineClients:

        hLine = (ptLineApp->ptLineClients ?
            ptLineApp->ptLineClients->hLine : (HLINE) 0);

        UNLOCKTLINEAPP (ptLineApp);

        if (hLine)
        {
            DestroytLineClient (hLine);
            LOCKTLINEAPP (ptLineApp);
            goto destroy_tLineClients;
        }
    }


    //
    // Remove tLineApp from tClient's list. Note that we don't
    // have to worry about dup-ing the mutex here because we know
    // it's valid & won't get closed before we release it.
    //

    LOCKTCLIENT (ptClient);

    if (ptLineApp->pNext)
    {
        ptLineApp->pNext->pPrev = ptLineApp->pPrev;
    }

    if (ptLineApp->pPrev)
    {
        ptLineApp->pPrev->pNext = ptLineApp->pNext;
    }
    else
    {
        ptClient->ptLineApps = ptLineApp->pNext;
    }


    //
    // Clean up any existing generic dialog instances if this is the
    // last tLineApp on this tClient
    //

    if (ptClient->pGenericDlgInsts && ptClient->ptLineApps == NULL)
    {
        PTAPIDIALOGINSTANCE         pGenericDlgInst =
                                        ptClient->pGenericDlgInsts,
                                    pNextGenericDlgInst;

        TAPI32_MSG                  params;

        while (pGenericDlgInst)
        {
            pNextGenericDlgInst = pGenericDlgInst->pNext;
            params.u.Req_Func = 0;
            params.Params[0] = pGenericDlgInst->htDlgInst;
            params.Params[1] = LINEERR_OPERATIONFAILED;

            FreeDialogInstance(
                ptClient,
                (PFREEDIALOGINSTANCE_PARAMS) &params,
                sizeof (params),
                NULL,
                NULL
                );

            pGenericDlgInst = pNextGenericDlgInst;
        }
    }

    UNLOCKTCLIENT (ptClient);


    //
    // Decrement total num inits & see if we need to go thru shutdown
    //

    TapiEnterCriticalSection (&TapiGlobals.CritSec);

    //assert(TapiGlobals.dwNumLineInits != 0);

    TapiGlobals.dwNumLineInits--;


    if ((TapiGlobals.dwNumLineInits == 0) &&
        (TapiGlobals.dwNumPhoneInits == 0) &&
        !(TapiGlobals.dwFlags & TAPIGLOBALS_SERVER))
    {
        ServerShutdown();
        gbServerInited = FALSE;
    }

    TapiLeaveCriticalSection (&TapiGlobals.CritSec);


    //
    // Check to see if this tLineApp is a registered request
    // recipient, and if so do the appropriate munging
    //

    {
        BOOL               bResetHighestPriorityRequestRecipient;
        PTREQUESTRECIPIENT pRequestRecipient;


        if ((pRequestRecipient = ptLineApp->pRequestRecipient))
        {
            EnterCriticalSection (&gPriorityListCritSec);

            bResetHighestPriorityRequestRecipient =
                (TapiGlobals.pHighestPriorityRequestRecipient ==
                    pRequestRecipient ? TRUE : FALSE);

            if (pRequestRecipient->pNext)
            {
                pRequestRecipient->pNext->pPrev = pRequestRecipient->pPrev;
            }

            if (pRequestRecipient->pPrev)
            {
                pRequestRecipient->pPrev->pNext = pRequestRecipient->pNext;
            }
            else
            {
                TapiGlobals.pRequestRecipients = pRequestRecipient->pNext;
            }

            if (bResetHighestPriorityRequestRecipient)
            {
                TapiGlobals.pHighestPriorityRequestRecipient =
                    GetHighestPriorityRequestRecipient();

                if (TapiGlobals.pRequestMakeCallList)
                {
                    if (TapiGlobals.pHighestPriorityRequestRecipient)
                    {
                        NotifyHighestPriorityRequestRecipient();
                    }

                     else
                    {
                        //
                        // We couldn't start a request recipient so
                        // nuke all pending request make calls
                        //

                        PTREQUESTMAKECALL   pRequestMakeCall,
                                            pNextRequestMakeCall;


                        pRequestMakeCall =
                            TapiGlobals.pRequestMakeCallList;

                        TapiGlobals.pRequestMakeCallList    =
                        TapiGlobals.pRequestMakeCallListEnd = NULL;

                        while (pRequestMakeCall)
                        {
                            pNextRequestMakeCall =
                                pRequestMakeCall->pNext;
                            ServerFree (pRequestMakeCall);
                            pRequestMakeCall =  pNextRequestMakeCall;
                        }

                        LOG((TL_INFO,
                            "DestroytLineApp: deleting pending " \
                                "MakeCall requests"
                            ));
                    }
                }
            }

            LeaveCriticalSection (&gPriorityListCritSec);
            ServerFree (pRequestRecipient);
        }
    }


    //
    // Decrement reference count by two to remove the initial
    // reference & the reference above
    //

    DereferenceObject (ghHandleTable, hLineApp, 2);

    return 0;
}


BOOL
FillupACountryEntry(
    HKEY                hKey,
    PBYTE               pcl,
    LPLINECOUNTRYENTRY  pce,
    PBYTE               *ppVarOffset
    )
{
    PBYTE  pVarOffset = *ppVarOffset;
    DWORD  dwSize;
    DWORD  dwType;
    LONG   lTemp;


    dwSize = sizeof(pce->dwCountryCode);

    lTemp = RegQueryValueEx(
                          hKey,
                          TEXT("CountryCode"),
                          NULL,
                          &dwType,
                          (LPBYTE)&(pce->dwCountryCode),
                          &dwSize
                        );

    //
    // If we failed to get the country code, the rest of this work
    // is meaningless...
    //
    if ( ERROR_SUCCESS == lTemp )
    {
        //
        // Read the country name string resource ID
        //
        dwSize = sizeof(DWORD);
        lTemp = RegQueryValueEx(
                          hKey,
                          gszNameResW,
                          NULL,
                          &dwType,
                          pVarOffset,
                          &dwSize
                        );


        if ( ERROR_SUCCESS == lTemp )
        {
            pce->dwCountryNameOffset = (DWORD) (pVarOffset - pcl);
            pce->dwCountryNameSize = dwSize;

            pVarOffset += dwSize;
        }

        dwSize = MAXLEN_RULE * sizeof(WCHAR);
        // Here we need to read a wide string because this is our packed structure
        // that will eventually get returned to the client and these are WCHAR always.
        lTemp = TAPIRegQueryValueExW(
                          hKey,
                          gszSameAreaRuleW,
                          NULL,
                          &dwType,
                          pVarOffset,
                          &dwSize
                        );

        if ( ERROR_SUCCESS == lTemp )
        {
            pce->dwSameAreaRuleOffset = (DWORD) (pVarOffset - pcl);
            pce->dwSameAreaRuleSize = dwSize;

            pVarOffset += dwSize;
        }


        dwSize = MAXLEN_RULE * sizeof(WCHAR);
        // Here we need to read a wide string because this is our packed structure
        // that will eventually get returned to the client and these are WCHAR always.
        lTemp = TAPIRegQueryValueExW(
                          hKey,
                          gszLongDistanceRuleW,
                          NULL,
                          &dwType,
                          pVarOffset,
                          &dwSize
                        );

        if ( ERROR_SUCCESS == lTemp )
        {
            pce->dwLongDistanceRuleOffset = (DWORD) (pVarOffset - pcl);
            pce->dwLongDistanceRuleSize = dwSize;

            pVarOffset += dwSize;
        }


        dwSize = MAXLEN_RULE * sizeof(WCHAR);
        // Here we need to read a wide string because this is our packed structure
        // that will eventually get returned to the client and these are WCHAR always.
        lTemp = TAPIRegQueryValueExW(
                          hKey,
                          gszInternationalRuleW,
                          NULL,
                          &dwType,
                          pVarOffset,
                          &dwSize
                        );

        if ( ERROR_SUCCESS == lTemp )
        {
            pce->dwInternationalRuleOffset =  (DWORD) (pVarOffset - pcl);
            pce->dwInternationalRuleSize = dwSize;

            pVarOffset += dwSize;
        }


        *ppVarOffset = pVarOffset;
    }

    return TRUE;
}


BOOL
BuildCountryRegistryListFromRCW(
    void
    )
{
    HKEY        hKey = NULL, hKey2;
    DWORD       dwDisposition, dwNextCountryID, dw, dwNextCountryGroup, dwCountryGroupID;
    TCHAR       sz[256];
    TCHAR       sz1[256];
    LONG        err;


    if (RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        gszRegKeyTelephony,
        0,
        KEY_READ,
        &hKey2
        ) != ERROR_SUCCESS)
    {
        goto ExitHere;
    }

    err = RegCreateKeyEx(
        hKey2,
        TEXT("Country List"),
        0,
        NULL,
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        NULL,
        &hKey,
        &dwDisposition
        );


    RegCloseKey (hKey2);

    if (err != ERROR_SUCCESS)
    {
        goto ExitHere;
    }

    dwNextCountryID = 1;

    while (dwNextCountryID)
    {
        if (LoadString(
                ghInstance,
                RC_COUNTRY_ID_BASE + dwNextCountryID,
                sz,
                ARRAYSIZE(sz)
                )  > 0 &&

            LoadString(
                ghInstance,
                RC_COUNTRY_NAME_BASE + dwNextCountryID,
                sz1,
                ARRAYSIZE(sz1) 
                ) > 0
             )
        {
            TCHAR szCountryKey[20];
            PTSTR p;
            PTSTR p2;


            wsprintf( szCountryKey, TEXT("%ld"), dwNextCountryID );

            if (RegCreateKeyEx(
                hKey,
                szCountryKey,
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hKey2,
                &dwDisposition
                ) != ERROR_SUCCESS)
            {
                goto ExitHere;
            }

            //
            // Set the country name and resource ID in registry
            //
            RegSetValueEx(
                hKey2,
                gszNameW,
                0,
                REG_SZ,
                (LPBYTE) sz1,
                (DWORD) ( (_tcslen(sz1) + 1) * sizeof(TCHAR) )
                );


            dw = RC_COUNTRY_NAME_BASE + dwNextCountryID;
            RegSetValueEx(
                hKey2,
                gszNameResW,
                0,
                REG_DWORD,
                (LPBYTE) &dw,
                sizeof(DWORD)
                );

//RC_COUNTRY_ID_BASE + 1 "1,101,""G"","" 1FG"",""011EFG"""


            p = sz;

            //
            // Get the countryID
            //

            dw = _ttol (p);

            RegSetValueEx(
                hKey2,
                TEXT("CountryCode"),
                0,
                REG_DWORD,
                (LPBYTE)&dw,
                sizeof(DWORD)
                );


            p = _tcschr( p, TEXT(',') ) + 1;
            dwNextCountryID = _ttol( p );

            p  = _tcschr( p, TEXT('"') ) + 1;  // Point to start of rule
            p2 = _tcschr( p, TEXT('"') );           // Point to end of rule
            *p2 = TEXT('\0');

            RegSetValueEx(
                hKey2,
                gszSameAreaRuleW,
                0,
                REG_SZ,
                (LPBYTE) p,
                (DWORD) ((PBYTE) p2 - (PBYTE) p) + sizeof(TCHAR)
                );

            p  = _tcschr( p2 + 1, TEXT('"') ) + 1;  // Point to start of rule
            p2 = _tcschr( p, TEXT('"') );           // Point to end of rule
            *p2 = TEXT('\0');

            RegSetValueEx(
                hKey2,
                gszLongDistanceRuleW,
                0,
                REG_SZ,
                (LPBYTE) p,
                (DWORD) ((PBYTE) p2 - (PBYTE) p) + sizeof(TCHAR)
                );

            p  = _tcschr( p2 + 1, TEXT('"') ) + 1;  // Point to start of rule
            p2 = _tcschr( p, TEXT('"') );           // Point to end of rule
            *p2 = TEXT('\0');

            RegSetValueEx(
                hKey2,
                gszInternationalRuleW,
                0,
                REG_SZ,
                (LPBYTE) p,
                (DWORD) ((PBYTE) p2 - (PBYTE) p) + sizeof(TCHAR)
                );


            RegCloseKey(hKey2);
        }
        else
        {
            dwNextCountryID = 0;
        }

    }

    //
    // Get the Country Groups
    // 

//RC_COUNTRY_GROUP_BASE + 1 "1,0,""594,590,596,262,33"""

    dwNextCountryGroup = 1;
    while (dwNextCountryGroup)
    {
        if (LoadString(
                ghInstance,
                RC_COUNTRY_GROUP_BASE + dwNextCountryGroup,
                sz,
                ARRAYSIZE(sz)

                )  > 0)
        {
            TCHAR szCountryKey[20];
            PTSTR p;
            PTSTR p2;

            p = sz;

            //
            // Get the country group ID
            //

            dwCountryGroupID = _ttol (p);

            p = _tcschr( p, TEXT(',') ) + 1;
            dwNextCountryGroup = _ttol( p );


            p = _tcschr( p, TEXT('"') );
            p2 = _tcschr( p+1, TEXT('"') );
            *p2 = TEXT('\0');

            while( NULL != p && p+1 < p2)
            {
                wsprintf( szCountryKey, TEXT("%ld"), _ttol (p+1) );

                if (RegOpenKeyEx(
                    hKey,
                    szCountryKey,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey2
                    ) != ERROR_SUCCESS)
                {
                    goto ExitHere;
                }


                RegSetValueEx(
                    hKey2,
                    gszCountryGroupW,
                    0,
                    REG_DWORD,
                    (LPBYTE)&dwCountryGroupID,
                    sizeof(DWORD)
                    );

                RegCloseKey(hKey2);
                
                p = _tcschr( p+1, TEXT(',') );
            }
        }
        else
        {
            dwNextCountryGroup = 0;
        }
    }

    //
    // Write the country list version to the registry
    //

    {
        DWORD dwCountryListVersion = TAPI_CURRENT_COUNTRY_LIST_VERSION;

        RegSetValueEx(
            hKey,
            gszCountryListVersionW,
            0,
            REG_DWORD,
            (LPBYTE) &dwCountryListVersion,
            (DWORD) sizeof (dwCountryListVersion)
            );
    }

ExitHere:
    if (hKey)
    {
        RegCloseKey (hKey);
    }

    return TRUE;
}


BOOL
DeleteAllSubkeys(
    HKEY    hKey,
    DWORD   dwRecursionCount
    )
{
    //
    // Build a MULTISZ-style list of all the subkey names,
    // then delete them all.  This is because NT won't
    // let us (do it the easy way and) delete the parent key
    // while subkeys still exist.  Note also that we're not
    // allowed to delete subkeys while enumerating them.
    //

    HKEY    hSubkey;
    DWORD   i, dwTotalChars = 2048, dwUsedChars = 0;
    TCHAR   *p, *p2;


    //
    // If we're nested more than a few levels deep then someone
    // is probably doing some malicious registry munging to
    // see if we blow up - don't recurse any further.
    //

    if (dwRecursionCount > 5)
    {
        return TRUE;
    }


    //
    // Alloc a buffer to store subkey names
    //

    if (!(p = ServerAlloc (dwTotalChars * sizeof (TCHAR))))
    {
        return FALSE;
    }


    //
    // Build the list
    //

    for (i = 0;; i++)
    {
        DWORD       dwNumChars = dwTotalChars - dwUsedChars;
        FILETIME    fileTime;


        //
        // See if we need to grow the buffer first
        //

        if (dwNumChars < 256)
        {
            dwTotalChars *= 2;

            if (!(p2 = LocalAlloc (LPTR, dwTotalChars * sizeof (TCHAR))))
            {
                ServerFree (p);
                return FALSE;
            }

            CopyMemory (p2, p, dwUsedChars * sizeof (TCHAR));

            ServerFree (p);

            p = p2;
        }

        if (RegEnumKeyEx(
                hKey,
                i,
                p + dwUsedChars,
                &dwNumChars,
                NULL,
                NULL,
                NULL,
                &fileTime

                ) != ERROR_SUCCESS)
        {
            p[dwUsedChars] = TEXT('\0');    // the final (double) NULL
            break;
        }


        //
        // Append a terminating NULL if there wasn't one
        //

        if (p[dwUsedChars + dwNumChars - 1] != TEXT('\0'))
        {
            p[dwUsedChars + dwNumChars] = TEXT('\0');
            dwNumChars++;
        }

        dwUsedChars += dwNumChars;
    }


    //
    // Now nuke all the subkeys in the list (make sure to nuke
    // any sub-subkeys first)
    //

    for (p2 = p; *p2 != TEXT('\0'); p2 += lstrlen (p2) + 1)
    {
        if (RegOpenKeyEx(
                hKey,
                p2,
                0,
                KEY_ALL_ACCESS,
                &hSubkey

                ) == ERROR_SUCCESS)
        {
            DeleteAllSubkeys (hSubkey, dwRecursionCount + 1);

            RegCloseKey (hSubkey);
        }

        RegDeleteKey (hKey, p2);
    }

    ServerFree (p);

    return TRUE;
}


BOOL
BuildCountryListCache(
    void
    )
{
    //
    // The following is our "last resort" country list, i.e. the one we
    // use of we get errors trying to build the country list below
    //

    static LINECOUNTRYLIST defCountryList =
    {
        sizeof(LINECOUNTRYLIST),    // dwTotalSize
        sizeof(LINECOUNTRYLIST),    // dwNeededSize
        sizeof(LINECOUNTRYLIST),    // dwUsedSize
        0,                          // dwNumCountries
        0,                          // dwCountryListSize
        0                           // dwCountryListOffset
    };
    BOOL bResult = TRUE;
    UINT i;


    if (!gpCountryList)
    {
        TCHAR sz[256];
        DWORD dwSize;
        DWORD dwListSize;
        DWORD dwCountryId, dwCountryListVersion, dwType;
        PBYTE pTempCountryList;
        LPLINECOUNTRYENTRY pce;
        LPLINECOUNTRYENTRY pcePrev = NULL;
        HKEY hKey;
        HKEY hKeyTemp;
        UINT uNumCountries;
        PBYTE pVarOffset;


        #define INITIAL_COUNTRY_COUNT 256

        dwListSize = sizeof(LINECOUNTRYLIST) +
               INITIAL_COUNTRY_COUNT * (sizeof(LINECOUNTRYENTRY) + 64);

        if ( NULL == (pTempCountryList = ServerAlloc(dwListSize)) )
        {
            bResult = FALSE;
            LOG((TL_ERROR, "Mem alloc failed for country list!1 (0x%lx", dwListSize));
            goto BuildCountryListCache_return;
        }


        //
        // Make sure the list is more-or-less there first
        //

        if (RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                gszRegKeyTelephony,
                0,
                KEY_READ,
                &hKey

                ) != ERROR_SUCCESS)
        {
            bResult = FALSE;
            ServerFree (pTempCountryList);
            goto BuildCountryListCache_return;
        }

        dwCountryListVersion = 0;

        if (RegOpenKeyEx(
                hKey,
                TEXT("Country List"),
                0,
                KEY_READ,
                &hKeyTemp

                ) == ERROR_SUCCESS)
        {
            dwSize = sizeof(DWORD);
            TAPIRegQueryValueExW(
                hKeyTemp,
                gszCountryListVersionW,
                NULL,
                &dwType,
                (LPBYTE) &dwCountryListVersion,
                &dwSize
                );

             RegCloseKey (hKeyTemp);
        }


        //
        // If the country list version is < the version in our resource
        // file  OR
        // if a read on the key for country code 1 (these united states)
        // fails, we'll assume the country list in the registry is toasted
        //

        if ((dwCountryListVersion < TAPI_CURRENT_COUNTRY_LIST_VERSION) ||

             RegOpenKeyEx(
                 hKey,
                 TEXT("Country List\\1"),
                 0,
                 KEY_READ,
                 &hKeyTemp
                 ))
        {
            //
            // Nuke any existing subkeys & (re)create it
            //

            if (RegOpenKeyEx(
                    hKey,
                    TEXT("Country List"),
                    0,
                    KEY_ALL_ACCESS,
                    &hKeyTemp

                    ) == ERROR_SUCCESS)
            {
                 DeleteAllSubkeys (hKeyTemp, 0);

                 RegCloseKey (hKeyTemp);
            }

            BuildCountryRegistryListFromRCW();
        }
        else
        {
            RegCloseKey( hKeyTemp );
        }

        RegCloseKey( hKey );


        //
        // In any case, the list is now good
        //

        if (RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                gszRegKeyTelephony,
                0,
                KEY_READ,
                &hKeyTemp

                ) != ERROR_SUCCESS)
        {
            bResult = FALSE;
            ServerFree (pTempCountryList);
            goto BuildCountryListCache_return;
        }

        if (RegOpenKeyEx(
                hKeyTemp,
                TEXT("Country List"),
                0,
                KEY_READ,
                &hKey

                ) != ERROR_SUCCESS)
        {
            RegCloseKey( hKeyTemp );
            bResult = FALSE;
            ServerFree (pTempCountryList);
            goto BuildCountryListCache_return;
        }

        RegCloseKey( hKeyTemp );


        //
        // Enum through the country keys and make sure there's enough room
        // for all of the LINECOUNTRYENTRYs
        //

        pce = (LPLINECOUNTRYENTRY)(pTempCountryList +
                                     sizeof(LINECOUNTRYLIST));

        //
        // Make pretend we already have a previous linecountryentry so we
        // don't have to do an 'if' in the loop every time just for the
        // special case of the first time.  (The correct number gets put
        // into the field the second time through the loop.)
        //

        pcePrev = pce;

        dwSize = ARRAYSIZE(sz);

        uNumCountries = 0;

        while (RegEnumKeyEx(
                    hKey,
                    uNumCountries,
                    sz,
                    &dwSize,
                    NULL,
                    NULL,
                    NULL,
                    NULL

                    ) == 0)
        {
           if ((sizeof(LINECOUNTRYLIST) +
                   (sizeof(LINECOUNTRYENTRY) * uNumCountries))  >  dwListSize)
           {
               PBYTE p;
               UINT uOldSize;


               uOldSize = dwListSize;

               //
               // alloc a new space
               //

               dwListSize = sizeof(LINECOUNTRYLIST) +
                                (
                                   (sizeof(LINECOUNTRYENTRY) + 64)
                                     * (uNumCountries + 25)
                                );

               p = ServerAlloc( dwListSize );

               if ( NULL == p )
               {
                   bResult = FALSE;
                   LOG((TL_ERROR, "Mem alloc failed for country list!2 (0x%lx", dwListSize));
                   ServerFree( pTempCountryList );
                   RegCloseKey (hKey);
                   goto BuildCountryListCache_return;
               }

               CopyMemory(
                   p,
                   pTempCountryList,
                   (LPBYTE)pce - pTempCountryList
                   );

               ServerFree( pTempCountryList );

               pTempCountryList = p;

               pce = (LPLINECOUNTRYENTRY)((LPBYTE)p + uOldSize);
           }

           dwCountryId = _ttol( sz );

           pce->dwCountryID = dwCountryId;

           pcePrev->dwNextCountryID = dwCountryId;


           // Prepare for next trip through the loop

           pcePrev = pce;

           pce++;

           uNumCountries++;

           dwSize = ARRAYSIZE(sz);  // need to set every time :-(
        }

        // Allocate the country groups global
        gpCountryGroups = (LPDWORD) ServerAlloc( uNumCountries * sizeof (DWORD) );
        if (gpCountryGroups)
            memset(gpCountryGroups, 0, uNumCountries * sizeof (DWORD));

        pcePrev->dwNextCountryID = 0;

        
        //
        // Now go through and get all of the associated strings
        //

        pce = (LPLINECOUNTRYENTRY)
                (pTempCountryList + sizeof(LINECOUNTRYLIST));

        pVarOffset = pTempCountryList +
                                 sizeof(LINECOUNTRYLIST) +
                                 (sizeof(LINECOUNTRYENTRY) * uNumCountries);

        i = 0;

        while ( i < uNumCountries )
        {
            HKEY hKey2;


//-->      if it can't fix MAX_SPACE, realloc it
            if ( ((DWORD)(pVarOffset - pTempCountryList) +
                         ((MAXLEN_NAME +
                         MAXLEN_RULE +
                         MAXLEN_RULE +
                         MAXLEN_RULE +
                         100) * sizeof(WCHAR)))    // mmmm... fudge...
                    > dwListSize )
            {
               PBYTE p;

               //
               // alloc a new space
               //

               dwListSize += 1024;

               p = ServerAlloc( dwListSize );

               if ( NULL == p )
               {
                   bResult = FALSE;
                   LOG((TL_ERROR, "Mem alloc failed for country list!3 (0x%lx", dwListSize));
                   ServerFree( pTempCountryList );
                   RegCloseKey (hKey);
                   goto BuildCountryListCache_return;
               }

               CopyMemory(
                   p,
                   pTempCountryList,
                   (LPBYTE)pce - pTempCountryList
                   );

               pVarOffset = (LPVOID)(p +
                               (UINT)( pVarOffset - pTempCountryList));

               ServerFree( pTempCountryList );

               pTempCountryList = p;

               pce = (LPLINECOUNTRYENTRY)
                     (pTempCountryList + sizeof(LINECOUNTRYLIST) +
                                 ( sizeof(LINECOUNTRYENTRY) * i ));
            }

            wsprintf( sz, TEXT("%ld"), pce->dwCountryID);

            if (RegOpenKeyEx (hKey, sz, 0, KEY_READ, &hKey2) == ERROR_SUCCESS)
            {
                FillupACountryEntry(
                    hKey2,
                    pTempCountryList,
                    pce,
                    &pVarOffset
                    );

                // fill the country group

                if (gpCountryGroups)
                {
                    DWORD dwType;
                    DWORD dwSize = sizeof (DWORD);

                    if (ERROR_SUCCESS != RegQueryValueEx(
                            hKey2,
                            gszCountryGroupW,
                            NULL,
                            &dwType,
                            (LPBYTE)(gpCountryGroups + i),
                            &dwSize
                            )                           ||
                         dwType != REG_DWORD
                        )
                    {
                        gpCountryGroups[ i ] = 0;
                    }
                }


                RegCloseKey (hKey2);
            }
            
            pce++;
            i++;
        }

        RegCloseKey( hKey );

        ((LPLINECOUNTRYLIST)pTempCountryList)->dwTotalSize =
                      (DWORD)(pVarOffset - pTempCountryList);

        ((LPLINECOUNTRYLIST)pTempCountryList)->dwNeededSize =
                      (DWORD)(pVarOffset - pTempCountryList);

        ((LPLINECOUNTRYLIST)pTempCountryList)->dwUsedSize =
                      (DWORD)(pVarOffset - pTempCountryList);

        ((LPLINECOUNTRYLIST)pTempCountryList)->dwNumCountries = uNumCountries;

        ((LPLINECOUNTRYLIST)pTempCountryList)->dwCountryListSize =
                                 uNumCountries * sizeof(LINECOUNTRYENTRY);

        ((LPLINECOUNTRYLIST)pTempCountryList)->dwCountryListOffset =
                                          sizeof(LINECOUNTRYLIST);

        gpCountryList = (LPLINECOUNTRYLIST)pTempCountryList;
    }

BuildCountryListCache_return:

    if (bResult == FALSE)
    {
        gpCountryList = &defCountryList;
        ServerFree( gpCountryGroups );
        gpCountryGroups = NULL;
    }

    return bResult;
}


LPLINECOUNTRYLIST
BuildCountryList(
    void
    )
{
    LPLINECOUNTRYENTRY  pCtryEntry, pCtryEntryGlobal;
    LPLINECOUNTRYLIST   pCtryList;
    DWORD               dwListSize;
    DWORD               dwIdx;
    DWORD               dwResourceId;
    DWORD               dwNameSize;
    DWORD               dwNeededSize;
    DWORD               dwTotalSize;
    LPBYTE              pVarOffset;
    BOOL                bResult = TRUE;
    WCHAR               sz[MAXLEN_NAME];

    if (!gpCountryList)
    {
        return NULL;
    }

    //
    // Allocate memory, make room for country names
    //
    dwTotalSize = gpCountryList->dwUsedSize + 
                  gpCountryList->dwNumCountries * 
                           ( MAXLEN_NAME * sizeof(WCHAR) - sizeof(DWORD) );
    pCtryList = ServerAlloc (dwTotalSize);

    if (!pCtryList)
    {
        return NULL;
    }

    //
    // Fill the buffer
    // 
    pCtryEntry = (LPLINECOUNTRYENTRY)((LPBYTE) pCtryList + sizeof(LINECOUNTRYLIST));
    pCtryEntryGlobal = (LPLINECOUNTRYENTRY)((LPBYTE) gpCountryList + sizeof(LINECOUNTRYLIST));
    pVarOffset = (LPBYTE)pCtryList + sizeof(LINECOUNTRYLIST) + 
                    sizeof(LINECOUNTRYENTRY) * gpCountryList->dwNumCountries;
    dwNeededSize = sizeof(LINECOUNTRYLIST) + 
                    sizeof(LINECOUNTRYENTRY) * gpCountryList->dwNumCountries;

    for( dwIdx = 0; dwIdx < gpCountryList->dwNumCountries; 
            dwIdx++, pCtryEntry++, pCtryEntryGlobal++ )
    {
        pCtryEntry->dwCountryCode = pCtryEntryGlobal->dwCountryCode;
        pCtryEntry->dwCountryID = pCtryEntryGlobal->dwCountryID;
        pCtryEntry->dwNextCountryID = pCtryEntryGlobal->dwNextCountryID;


        //
        // The name field has the resource string ID
        // Need to load the actual string 
        //
            
        CopyMemory(
            &dwResourceId,
            (LPBYTE)gpCountryList + pCtryEntryGlobal->dwCountryNameOffset,
            sizeof(DWORD)
            );

        if (0 == LoadStringW(
                            ghInstance,
                            dwResourceId,
                            sz,
                            ARRAYSIZE(sz)
                            )  
           )
        {
            bResult = FALSE;
            break;
        }
                        
        dwNameSize = (wcslen(sz) + 1) * sizeof(WCHAR);
        CopyMemory(
            pVarOffset,
            (LPBYTE)sz,
            dwNameSize
            );

        pCtryEntry->dwCountryNameSize = dwNameSize;

        pCtryEntry->dwCountryNameOffset = (DWORD)(pVarOffset - (LPBYTE)pCtryList);
        pVarOffset += dwNameSize;
        dwNeededSize += dwNameSize;


        CopyMemory(
            pVarOffset,
            (LPBYTE)gpCountryList + pCtryEntryGlobal->dwSameAreaRuleOffset,
            pCtryEntryGlobal->dwSameAreaRuleSize
            );

        pCtryEntry->dwSameAreaRuleSize = pCtryEntryGlobal->dwSameAreaRuleSize;
        pCtryEntry->dwSameAreaRuleOffset = (DWORD)(pVarOffset - (LPBYTE)pCtryList);
        pVarOffset += pCtryEntryGlobal->dwSameAreaRuleSize;
        dwNeededSize += pCtryEntryGlobal->dwSameAreaRuleSize;


        CopyMemory(
            pVarOffset,
            (LPBYTE)gpCountryList + pCtryEntryGlobal->dwLongDistanceRuleOffset,
            pCtryEntryGlobal->dwLongDistanceRuleSize
            );

        pCtryEntry->dwLongDistanceRuleSize = pCtryEntryGlobal->dwLongDistanceRuleSize;
        pCtryEntry->dwLongDistanceRuleOffset = (DWORD)(pVarOffset - (LPBYTE)pCtryList);
        pVarOffset += pCtryEntryGlobal->dwLongDistanceRuleSize;
        dwNeededSize += pCtryEntryGlobal->dwLongDistanceRuleSize;


        CopyMemory(
            pVarOffset,
            (LPBYTE)gpCountryList + pCtryEntryGlobal->dwInternationalRuleOffset,
            pCtryEntryGlobal->dwInternationalRuleSize
            );

        pCtryEntry->dwInternationalRuleSize = pCtryEntryGlobal->dwInternationalRuleSize;
        pCtryEntry->dwInternationalRuleOffset = (DWORD)(pVarOffset - (LPBYTE)pCtryList);
        pVarOffset += pCtryEntryGlobal->dwInternationalRuleSize;
        dwNeededSize += pCtryEntryGlobal->dwInternationalRuleSize;
        
    }
    
    if (!bResult)
    {
        ServerFree(pCtryList);
        pCtryList = NULL;
    }
    else
    {
        pCtryList->dwNeededSize = dwNeededSize;
        pCtryList->dwTotalSize = dwTotalSize;
        pCtryList->dwUsedSize = dwNeededSize;
        pCtryList->dwNumCountries = gpCountryList->dwNumCountries;
        pCtryList->dwCountryListSize = sizeof(LINECOUNTRYENTRY) * gpCountryList->dwNumCountries;
        pCtryList->dwCountryListOffset = sizeof(LINECOUNTRYLIST);
    }

    return pCtryList;
}

PTLINECLIENT
PASCAL
xxxGetHighestPriorityLineClient(
    TPOINTERLIST    *pLineClientList,
    DWORD           dwMediaModes,
    DWORD           dwAddressID,
    WCHAR          *pszPriorityList
    )
{
    BOOL            bFoundOwnerInPriorityList = FALSE;
    DWORD           i;
    WCHAR           *pszAppInPriorityList = NULL;
    WCHAR           *pszAppInPriorityListPrev = (WCHAR *) LongToPtr(0xffffffff);
    PTLINECLIENT    ptHiPriLineClient = (PTLINECLIENT) NULL;


    for (i = 0; i < pLineClientList->dwNumUsedEntries; i++)
    {
        PTLINECLIENT    ptLineClient = (PTLINECLIENT)
                            pLineClientList->aEntries[i];

        try
        {
            if (ptLineClient->dwPrivileges & LINECALLPRIVILEGE_OWNER)
            {
                BOOL            bMatch;


                bMatch = ((ptLineClient->dwMediaModes & dwMediaModes)
                    == dwMediaModes);

                if ( bMatch &&

                    // most common case, line opened for all addrs

                    ((ptLineClient->dwAddressID == 0xffffffff) ||


                    // line opened for single addr, check if match

                    (ptLineClient->dwAddressID == dwAddressID) ||


                    // called from lineHandoff, addr ID irrelevent

                    (dwAddressID == 0xffffffff)))
                {
                    if (pszPriorityList &&

                        (pszAppInPriorityList = wcsstr(
                            pszPriorityList,
                            ptLineClient->ptLineApp->pszModuleName
                            )))
                    {
                        //
                        // See if this app has higher pri
                        // than the previous app we found,
                        // and if so save the info
                        //

                        if (pszAppInPriorityList <= pszAppInPriorityListPrev)
                        {
                            ptHiPriLineClient = ptLineClient;

                            pszAppInPriorityListPrev  =
                                pszAppInPriorityList;

                            bFoundOwnerInPriorityList = TRUE;
                        }
                    }
                    else if (!bFoundOwnerInPriorityList)
                    {
                        ptHiPriLineClient = ptLineClient;
                    }
                }
            }
        }
        myexcept
        {
            // just continue
        }
    }

    return ptHiPriLineClient;
}


WCHAR *
GetPriorityListForMediaModes(
    DWORD   dwMediaModes
    )
{
    DWORD   dwCount;
    WCHAR   *pszPriorityList = NULL;


    if (TapiGlobals.dwUsedPriorityLists != 0)
    {
        //
        // Safely get a copy of the priority list (if any)
        // for this media mode
        //

        EnterCriticalSection (&gPriorityListCritSec);

        for(
            dwCount = 0;
            dwCount < TapiGlobals.dwUsedPriorityLists;
            dwCount++
            )
        {
            PRILISTSTRUCT PriList = TapiGlobals.pPriLists[dwCount];


            if ((dwMediaModes & PriList.dwMediaModes) == dwMediaModes)
            {
                if (PriList.pszPriList)
                {
                    if ((pszPriorityList = ServerAlloc( sizeof(WCHAR) *
                            (1 + lstrlenW(PriList.pszPriList))
                            )))
                    {
                        wcscpy (pszPriorityList, PriList.pszPriList);
                    }
                }

                break;
            }
        }

        LeaveCriticalSection (&gPriorityListCritSec);
    }

    return pszPriorityList;
}


PTLINECLIENT
PASCAL
GetHighestPriorityLineClient(
    PTLINE  ptLine,
    DWORD   dwMediaModes,
    DWORD   dwAddressID
    )
{
    WCHAR          *pszPriorityList = NULL;
    TPOINTERLIST    lineClientList, *pLineClientList = &lineClientList;
    PTLINECLIENT    ptHiPriLineClient = (PTLINECLIENT) NULL;
    DWORD           dwCount = 0, dwMask;


    if (GetLineClientListFromLine (ptLine, &pLineClientList) != 0)
    {
        return NULL;
    }


    //
    // If >1 media mode is specifed without the UNKNOWN bit being set
    // then we first want to see if there's any exact matches available,
    // that is, if there's an app which has opened the line with OWNER
    // privileges for all the specfied media modes. If so, then we'll
    // give privilege to that app immediately, rather than walking
    // through the media mode bits one-by-one as done below (the original
    // TAPI 1.x priority determination scheme).
    //

    if (!IsOnlyOneBitSetInDWORD (dwMediaModes) &&
        !(dwMediaModes & LINEMEDIAMODE_UNKNOWN))
    {
        pszPriorityList = GetPriorityListForMediaModes (dwMediaModes);

        ptHiPriLineClient = xxxGetHighestPriorityLineClient(
            pLineClientList,
            dwMediaModes,
            dwAddressID,
            pszPriorityList
            );

        if (pszPriorityList)
        {
            ServerFree (pszPriorityList);
        }
    }


    //
    // Step thru the list of line clients (youngest client at head
    // of list, oldest at tail) and look for the oldest & highest
    // priority owner.  Position in pri list takes precedence
    // over "age" of line client.
    //
    // To be considered for ownership a line client must have owner
    // privileges and be registered for (one of) the call's media
    // mode(s).  In addition, if the line client was opened with
    // the SINGLEADDRESS option and the calling function specified
    // a valid address ID (not 0xffffffff), the line client's single
    // address ID must match that which was passed in.
    //

    dwMask = LINEMEDIAMODE_UNKNOWN; // 0x00000002, smallest valid bit

    while (!ptHiPriLineClient  &&  dwMediaModes)
    {
        if (dwMask & dwMediaModes)
        {
            pszPriorityList = GetPriorityListForMediaModes (dwMask);

            ptHiPriLineClient = xxxGetHighestPriorityLineClient(
                pLineClientList,
                dwMask,
                dwAddressID,
                pszPriorityList
                );

            if (pszPriorityList)
            {
                ServerFree (pszPriorityList);
            }
        }

        dwMediaModes &= ~dwMask;
        dwMask <<= 1;
    }


    //
    // Free line client list iff appropriate
    //

    if (pLineClientList != &lineClientList)
    {
        ServerFree (pLineClientList);
    }

    return ptHiPriLineClient;
}


LONG
PASCAL
LineProlog(
    PTCLIENT    ptClient,
    DWORD       dwArgType,
    DWORD       dwArg,
    LPVOID      phdXxx,
    DWORD       dwPrivilege, // can be privilege or device id
    HANDLE     *phMutex,
    BOOL       *pbDupedMutex,
    DWORD       dwTSPIFuncIndex,
    TSPIPROC   *ppfnTSPI_lineXxx,
    PASYNCREQUESTINFO  *ppAsyncRequestInfo,
    DWORD       dwRemoteRequestID,
    DWORD      *pObjectToDereference,
    LPVOID     *pContext
#if DBG
    ,char      *pszFuncName
#endif
    )
{
    LONG        lResult = 0;
    DWORD       initContext;
    DWORD       openContext;
    ULONG_PTR   htXxx;
    PTPROVIDER  ptProvider;

#if DBG
    LOG((TL_TRACE,  "LineProlog: (line%s) enter", pszFuncName));
#else
    LOG((TL_TRACE, "LineProlog:  -- enter"));
#endif

    LOG((TL_INFO, "LineProlog: dwArg %lx", dwArg));

    if (phMutex)
    {
        *phMutex = NULL;
        *pbDupedMutex = FALSE;
    }

    *pObjectToDereference = 0;

    if (ppAsyncRequestInfo)
    {
        *ppAsyncRequestInfo = (PASYNCREQUESTINFO) NULL;
    }

    if (TapiGlobals.dwNumLineInits == 0)
    {
        lResult = LINEERR_UNINITIALIZED;
        goto LineProlog_exit;
    }

    if (ptClient->phContext == (HANDLE) -1)
    {
        lResult = LINEERR_REINIT;
        goto LineProlog_exit;
    }

    switch (dwArgType)
    {
    case ANY_RT_HCALL:
    {
        PTCALLCLIENT    ptCallClient;

        LOG((TL_INFO, "LineProlog: ANY_RT_HCALL "));

        if ((ptCallClient = ReferenceObject(
                ghHandleTable,
                dwArg,
                TCALLCLIENT_KEY
                )))
        {
            LOG((TL_INFO, "LineProlog: ReferenceObject returned ptCallClient %p", ptCallClient));

            if (ptCallClient->ptClient != ptClient)
            {
                lResult = LINEERR_INVALCALLHANDLE;
            }
            else if (ptCallClient->dwPrivilege < dwPrivilege)
            {
                lResult = LINEERR_NOTOWNER;
            }
            else
            {
                *pObjectToDereference = dwArg;
                *pContext = ptCallClient;

                try
                {
                    ptProvider = ptCallClient->ptCall->ptProvider;
                    *((HDRVCALL *) phdXxx) = ptCallClient->ptCall->hdCall;

                    if (ppAsyncRequestInfo)
                    {
                        PTLINECLIENT    ptLineClient =
                                            ptCallClient->ptLineClient;


                        initContext = ptLineClient->ptLineApp->InitContext;
                        openContext = ptLineClient->OpenContext;
                        htXxx       = (ULONG_PTR)ptLineClient->ptLine->hLine;
                    }
                }
                myexcept
                {
                    
                    LOG((TL_ERROR, "LineProlog: exception"));
                    lResult = LINEERR_INVALCALLHANDLE;
                }

                if (lResult  ||  ptCallClient->dwKey != TCALLCLIENT_KEY)
                {
                    lResult = LINEERR_INVALCALLHANDLE;
                }
                else if (phMutex &&
                         (ptProvider->dwTSPIOptions &
                            LINETSPIOPTION_NONREENTRANT))
                {
                    if (!WaitForMutex(
                            ptProvider->hMutex,
                            phMutex,
                            pbDupedMutex,
                            ptProvider,
                            TPROVIDER_KEY,
                            INFINITE
                            ))
                    {
                        lResult = LINEERR_OPERATIONFAILED;
                    }
                }
            }
        }
        else
        {
            lResult = LINEERR_INVALCALLHANDLE;
        }

        break;
    }
    case ANY_RT_HLINE:
    {
        PTLINECLIENT    ptLineClient;

        LOG((TL_INFO, "LineProlog: ANY_RT_HLINE"));

        if ((ptLineClient = ReferenceObject(
                ghHandleTable,
                dwArg,
                TLINECLIENT_KEY
                )))
        {
            LOG((TL_INFO, "LineProlog: ReferenceObject returned ptLineClient %p", ptLineClient));

            if (ptLineClient->ptClient != ptClient)
            {

                lResult = LINEERR_INVALLINEHANDLE;
            }
            else
            {
                *pObjectToDereference = dwArg;
                *pContext = ptLineClient;

                try
                {
                    ptProvider = ptLineClient->ptLine->ptProvider;
                    *((HDRVLINE *) phdXxx) = ptLineClient->ptLine->hdLine;

                    if (ppAsyncRequestInfo)
                    {
                        initContext = ptLineClient->ptLineApp->InitContext;
                        openContext = ptLineClient->OpenContext;
                        htXxx       = (ULONG_PTR)ptLineClient->ptLine->hLine;
                    }
                }
                myexcept
                {
                    LOG((TL_ERROR, "LineProlog: exception"));

                    lResult = LINEERR_INVALLINEHANDLE;
                }

                if (lResult  ||  ptLineClient->dwKey != TLINECLIENT_KEY)
                {
                    lResult = LINEERR_INVALLINEHANDLE;
                }
                else if (phMutex &&
                         (ptProvider->dwTSPIOptions &
                            LINETSPIOPTION_NONREENTRANT))
                {
                    if (!WaitForMutex(
                            ptProvider->hMutex,
                            phMutex,
                            pbDupedMutex,
                            ptProvider,
                            TPROVIDER_KEY,
                            INFINITE
                            ))
                    {
                        LOG((TL_ERROR, "LineProlog: waitformutex failed"));

                        lResult = LINEERR_OPERATIONFAILED;
                    }
                }
            }
        }
        else
        {
            LOG((TL_ERROR, "LineProlog: ReferenceObject returned NULL"));

            lResult = LINEERR_INVALLINEHANDLE;
        }

        break;
    }
    case DEVICE_ID:
    {
        PTLINEAPP           ptLineApp = NULL;
        PTLINELOOKUPENTRY   pLineLookupEntry;


#if TELE_SERVER

        //
        // If it's a server, map the device id
        //

        if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
            !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
        {
            try
            {
                if ((dwPrivilege >= ptClient->dwLineDevices) ||
                    (ptClient->pLineDevices[dwPrivilege] == 0xffffffff))
                {
                    lResult = LINEERR_BADDEVICEID;
                    goto LineProlog_exit;
                }

                *((LPDWORD) phdXxx) = ptClient->pLineDevices[dwPrivilege];
            }
            myexcept
            {
                lResult = LINEERR_INVALLINEHANDLE;
                goto LineProlog_exit;
            }
        }
        else
#endif
        {
            *((LPDWORD)phdXxx) = dwPrivilege;
        }


        if (dwArg  &&
            !(ptLineApp = IsValidLineApp ((HLINEAPP) dwArg, ptClient)))
        {
            lResult = LINEERR_INVALAPPHANDLE;
        }

        if (ppAsyncRequestInfo)
        {
            try
            {
                initContext = ptLineApp->InitContext;
                openContext = 0;

                if (ptLineApp->dwKey != TLINEAPP_KEY)
                {
                    lResult = LINEERR_INVALAPPHANDLE;
                }
            }
            myexcept
            {
                lResult = LINEERR_INVALAPPHANDLE;
            }
        }

        if (lResult != 0)
        {
            // do nothing
        }
        else if (!(pLineLookupEntry = GetLineLookupEntry (*(LPDWORD)phdXxx)))
        {
            lResult = LINEERR_BADDEVICEID;
        }
        else if (pLineLookupEntry->bRemoved)
        {
            lResult = LINEERR_NODEVICE;
        }
        else if (!(ptProvider = pLineLookupEntry->ptProvider))
        {
            lResult = LINEERR_NODRIVER;
        }
        else
        {
            *pContext = pLineLookupEntry;

            if (phMutex &&
                (ptProvider->dwTSPIOptions &
                    LINETSPIOPTION_NONREENTRANT))
            {
                if (!WaitForMutex(
                        ptProvider->hMutex,
                        phMutex,
                        pbDupedMutex,
                        ptProvider,
                        TPROVIDER_KEY,
                        INFINITE
                        ))
                {
                    lResult = LINEERR_OPERATIONFAILED;
                }
            }
        }

        break;
    }
    } // switch

    if (lResult)
    {
        goto LineProlog_exit;
    }


    //
    // Make sure that if caller wants a pointer to a TSPI proc that the
    // func is exported by the provider
    //

    if (ppfnTSPI_lineXxx &&
        !(*ppfnTSPI_lineXxx = ptProvider->apfn[dwTSPIFuncIndex]))
    {
        lResult = LINEERR_OPERATIONUNAVAIL;
        goto LineProlog_exit;
    }


    //
    // See if we need to alloc & init an ASYNCREQUESTINFO struct
    //

    if (ppAsyncRequestInfo)
    {
        PASYNCREQUESTINFO   pAsyncRequestInfo;


        if (!(pAsyncRequestInfo = ServerAlloc (sizeof(ASYNCREQUESTINFO))))
        {
            lResult = LINEERR_NOMEM;
            goto LineProlog_exit;
        }

        pAsyncRequestInfo->dwLocalRequestID = (DWORD) NewObject(
            ghHandleTable,
            pAsyncRequestInfo,
            NULL
            );

        if (pAsyncRequestInfo->dwLocalRequestID == 0)
        {
            ServerFree (pAsyncRequestInfo);
            lResult = LINEERR_NOMEM;
            goto LineProlog_exit;
        }

        pAsyncRequestInfo->dwKey    = TASYNC_KEY;
        pAsyncRequestInfo->ptClient = ptClient;

        pAsyncRequestInfo->InitContext = initContext;
        pAsyncRequestInfo->OpenContext = openContext;
        pAsyncRequestInfo->htXxx       = (dwArgType != DEVICE_ID ? htXxx :
            pAsyncRequestInfo->dwLocalRequestID);       // a +/- random #

        LOG((TL_INFO, "LineProlog: OpenContext %p", openContext));

        pAsyncRequestInfo->dwLineFlags = 1;

        if (dwRemoteRequestID)
        {
            lResult = pAsyncRequestInfo->dwRemoteRequestID = dwRemoteRequestID;
        }
        else
        {
            lResult = pAsyncRequestInfo->dwRemoteRequestID =
                pAsyncRequestInfo->dwLocalRequestID;
        }

        *ppAsyncRequestInfo = pAsyncRequestInfo;
    }

LineProlog_exit:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "LineProlog: (line%s) exit, result=%s",
            pszFuncName,
            MapResultCodeToText (lResult, szResult)
            ));
    }
#else
    LOG((TL_TRACE,
        "LienProlog: exit, result = x%lx",
        lResult
        ));
#endif

    return lResult;
}


void
PASCAL
LineEpilogSync(
    LONG       *plResult,
    HANDLE      hMutex,
    BOOL        bCloseMutex,
    DWORD       ObjectToDereference
#if DBG
    ,char *pszFuncName
#endif
    )
{
    DereferenceObject (ghHandleTable, ObjectToDereference, 1);

    if (hMutex)
    {
        MyReleaseMutex (hMutex, bCloseMutex);
    }

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "LineEpilogSync: (line%s) exit, result=%s",
            pszFuncName,
            MapResultCodeToText (*plResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "LineEpilogSync: exit, result=x%x",
            *plResult
            ));
#endif
}


void
PASCAL
LineEpilogAsync(
    LONG               *plResult,
    LONG                lRequestID,
    HANDLE              hMutex,
    BOOL                bCloseMutex,
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    DWORD               ObjectToDereference
#if DBG
    ,char *pszFuncName
#endif
    )
{
    DereferenceObject (ghHandleTable, ObjectToDereference, 1);

    MyReleaseMutex (hMutex, bCloseMutex);

    if (lRequestID > 0)
    {
        if (*plResult <= 0)
        {
            if (*plResult == 0)
            {
                LOG((TL_ERROR, "Error: SP returned 0, not request ID"));
            }

            //
            // If here the service provider returned an error (or 0,
            // which it never should for async requests), so call
            // CompletionProcSP like the service provider normally
            // would, & the worker thread will take care of sending
            // the client a REPLY msg with the request result (we'll
            // return an async request id)
            //

            CompletionProcSP(
                pAsyncRequestInfo->dwLocalRequestID,
                *plResult
                );
        }
    }
    else if (pAsyncRequestInfo != NULL)
    {
        //
        // If here an error occured before we even called the service
        // provider, so just free the async request (the error will
        // be returned to the client synchronously)
        //

        DereferenceObject(
            ghHandleTable,
            pAsyncRequestInfo->dwLocalRequestID,
            1
            );
    }

    *plResult = lRequestID;

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "LineEpilogAsync: (line%s) exit, result=%s",
            pszFuncName,
            MapResultCodeToText (lRequestID, szResult)
            ));
    }
#else
        LOG((TL_TRACE,
            "LineEpilogAsyc: exit, result=x%lx",
            lRequestID
            ));
#endif
}


void
PASCAL
LineEventProc(
    HTAPILINE   htLine,
    HTAPICALL   htCall,
    DWORD       dwMsg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    )
{
    LOG((TL_TRACE,  "LineEventProc"));

    switch (dwMsg)
    {
    case LINE_ADDRESSSTATE:
    case LINE_LINEDEVSTATE:
    case LINE_DEVSPECIFIC:
    case LINE_DEVSPECIFICFEATURE:
    case LINE_PROXYSTATUS:
    case LINE_AGENTSTATUS:
    {
        PTLINE  ptLine;

        if (!(ptLine = ReferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, TLINE_KEY)))
        {
            return;
        }

        if (dwMsg == LINE_LINEDEVSTATE  &&
                 htLine == 0  &&
                 Param1 & LINEDEVSTATE_REINIT)
        {
            SendReinitMsgToAllXxxApps();
        }
        else
        {
            SendMsgToLineClients(
                ptLine,
                NULL,
                dwMsg,
                DWORD_CAST(Param1,__FILE__,__LINE__),
                DWORD_CAST(Param2,__FILE__,__LINE__),
                DWORD_CAST(Param3,__FILE__,__LINE__)
                );
        }

        DereferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, 1);

        break;
    }
    case LINE_AGENTSPECIFIC:

        if (htCall)
        {
            PTCALL ptCall;

            if (ptCall = ReferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, TCALL_KEY))
            {
                SendMsgToCallClients(
                    ptCall,
                    NULL,
                    LINE_AGENTSPECIFIC,
                    DWORD_CAST(Param1,__FILE__,__LINE__),
                    DWORD_CAST(Param2,__FILE__,__LINE__),
                    DWORD_CAST(Param3,__FILE__,__LINE__)
                    );

                DereferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, 1);
            }
        }
        else
        {
            PTLINE  ptLine;

            if(ptLine = ReferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, TLINE_KEY))
            {
                SendMsgToLineClients(
                    ptLine,
                    NULL,
                    LINE_AGENTSPECIFIC,
                    DWORD_CAST(Param1,__FILE__,__LINE__),
                    DWORD_CAST(Param2,__FILE__,__LINE__),
                    DWORD_CAST(Param3,__FILE__,__LINE__)
                    );

                DereferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, 1);
            }
        }

        break;

    case LINE_CLOSE:
    {
        PTLINE  ptLine;
 
        if (!(ptLine = ReferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, TLINE_KEY)))
        {
            break;
        }

        if (ptLine->dwKey == TINCOMPLETELINE_KEY)
        {
            //
            // The device is in the process of getting opened but
            // the key has not been set & the Open() func still owns
            // the mutex and has stuff to do, so repost the msg
            // and try again later. (Set Param3 to special value
            // to indicate this repost, so EventProcSP doesn't recurse)
            //

            LineEventProcSP (htLine, 0, LINE_CLOSE, 0, 0, 0xdeadbeef);
        }
        else if (ptLine->dwKey == TLINE_KEY)
        {
            DestroytLine (ptLine, TRUE); // unconditional destroy
        }

        DereferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, 1);

        break;
    }
    case LINE_CALLDEVSPECIFIC:
    case LINE_CALLDEVSPECIFICFEATURE:
    case LINE_CALLINFO:
    {
        PTCALL  ptCall;
        
        if (ptCall = ReferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, TCALL_KEY))
        {


            switch (dwMsg)
            {
                case LINE_CALLDEVSPECIFIC:

                    dwMsg = LINE_DEVSPECIFIC;
                    break;

                case LINE_CALLDEVSPECIFICFEATURE:

                    dwMsg = LINE_DEVSPECIFICFEATURE;
                    break;

                case LINE_CALLINFO:
                {
                    Param2 =
                    Param3 = 0;

                    if ((Param1 == LINECALLINFOSTATE_CALLID)  ||
                        (Param1 == LINECALLINFOSTATE_RELATEDCALLID))
                    {
                        if ((WaitForExclusivetCallAccess (ptCall, TCALL_KEY)))
                        {
                            DWORD dwPreviousCallID = ptCall->dwCallID;


                            GetCallIDs (ptCall);

                            DoCallHubHashing (ptCall, dwPreviousCallID);

                            UNLOCKTCALL(ptCall);
                        }
                    }
                    break;
                }
            }

            SendMsgToCallClients(
                ptCall,
                NULL,
                dwMsg,
                DWORD_CAST(Param1,__FILE__,__LINE__),
                DWORD_CAST(Param2,__FILE__,__LINE__),
                DWORD_CAST(Param3,__FILE__,__LINE__)
                );

            DereferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, 1);
        }

        break;
    }
    case LINE_MONITORDIGITS:
    case LINE_MONITORMEDIA:
    {
        PTCALL  ptCall;

        if (NULL == htCall)
        {
            return;
        }

        if (ptCall = ReferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, TCALL_KEY))
        {
            SendMsgToCallClients(
                ptCall,
                NULL,
                dwMsg,
                DWORD_CAST(Param1,__FILE__,__LINE__),
                DWORD_CAST(Param2,__FILE__,__LINE__),
                (Param3 ? DWORD_CAST(Param3,__FILE__,__LINE__) : GetTickCount())
                );

            DereferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, 1);
        }
        break;
    }
    case LINE_CALLSTATE:
    {
        BOOL            fastPrivilegeList[DEF_NUM_PTR_LIST_ENTRIES],
                        *pPrivilegeList = fastPrivilegeList;
        DWORD           i, j, dwNumUsedEntries = 0,
                        dwNumTotalEntries= DEF_NUM_PTR_LIST_ENTRIES;
        PTCALL          ptCall;
        TPOINTERLIST    fastCallClientList,
                        *pCallClientList = &fastCallClientList;
        TPOINTERLIST    fastConfCallClientList,
                        *pConfCallClientList = NULL;

        LOG((TL_EVENT,  "LineEventProc: LINE_CALLSTATE event x%lx", Param1));

        if(!(ptCall = ReferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, TCALL_KEY)))
        {
            break;
        }

        if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
        {
            PTCALLCLIENT    ptCallClient = ptCall->ptCallClients;
            ASYNCEVENTMSG   msg[2];


            if (Param1 == LINECALLSTATE_OFFERING)
            {
                ptCall->dwDrvCallFlags |= DCF_INCOMINGCALL;
                PerfBlock.dwCurrentIncomingCalls++;
                PerfBlock.dwTotalIncomingCalls++;
                PerfBlock.dwCurrentOutgoingCalls--;
                PerfBlock.dwTotalOutgoingCalls--;
            }

            if (ptCall->bAlertApps)
            {
                //
                // This is the first state msg we've received for an incoming
                // call.  We need to determine who owns & who monitors it,
                // and create the appropriate tCallClients
                //

                BOOL            bFindOwner;
                DWORD           dwMediaModes = (DWORD) Param3,
                                dwSPIVersion = ptCall->ptLine->dwSPIVersion,
                                dwAddressID;
                PTLINECLIENT    ptLineClientOwner;


                ptCall->bAlertApps = FALSE;


                //
                // If this is a remotesp call then Param2 points at a
                // DWORD array, the 1st entry of which is the "real"
                // Param2 for this message (i.e. the call state mode),
                // the 2nd entry of which is the original privilege for
                // this call, and the 3rd entry of which is htCall
                // (which we use for call verification purposes)
                //

                if (ptCall->ptProvider != pRemoteSP)
                {
                    bFindOwner = TRUE;
                }
                else
                {
                    BOOL        bBreak = FALSE;
                    PULONG_PTR  pdwRealParam2 = (PULONG_PTR) Param2,
                                pdwPrivilege = (((PULONG_PTR) Param2) + 1);
                    LPHTAPICALL phtCall = (LPHTAPICALL)
                                    (((LPDWORD) Param2) + 2);


                    try
                    {
                        Param2 = *pdwRealParam2;

                        bFindOwner = (*pdwPrivilege & LINECALLPRIVILEGE_OWNER ?
                            TRUE : FALSE);

                        bBreak = (*phtCall != htCall ? TRUE : FALSE);
                    }
                    myexcept
                    {
                        bBreak = TRUE;
                    }

                    if (bBreak)
                    {
                        UNLOCKTCALL(ptCall);
                        goto LINE_CALLSTATE_break;
                    }
                }


                //
                // Retrieve call's address id, etc
                //

                GetCallIDs (ptCall);

                dwAddressID = ptCall->dwAddressID;

                UNLOCKTCALL(ptCall);


                //
                // Add the UNKNOWN bit if >1 bit set
                // if version is <= 2.1

                if ( ( (dwSPIVersion <= TAPI_VERSION2_1) &&
                    !IsOnlyOneBitSetInDWORD (dwMediaModes) ) ||
                    dwMediaModes == 0)
                {
                    dwMediaModes |= LINEMEDIAMODE_UNKNOWN;
                }


                //
                // Try to find an owner.  If no owner found then destroy
                // the tCall.
                //

                if (bFindOwner)
                {
                    PTLINE  ptLine;

                    ptLine = ReferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, TLINE_KEY);

                    if (!ptLine)
                    {
                        //
                        // Line closed
                        //

                        DestroytCall (ptCall);
                        goto LINE_CALLSTATE_break;
                    }

LINE_CALLSTATE_findOwner:

                    if ((ptLineClientOwner = GetHighestPriorityLineClient(
                            ptLine,
                            dwMediaModes,
                            dwAddressID
                            )))
                    {
                        LONG         lResult;
                        PTCALLCLIENT ptCallClientOwner;


                        if ((lResult = CreatetCallClient(
                                ptCall,
                                ptLineClientOwner,
                                LINECALLPRIVILEGE_OWNER,
                                TRUE,
                                FALSE,
                                &ptCallClientOwner,
                                TRUE

                            )) != 0)
                        {
                            if (lResult == LINEERR_INVALLINEHANDLE)
                            {
                                //
                                // The tLineClient was just closed, so jump
                                // up top & try to find another owner
                                //

                                goto LINE_CALLSTATE_findOwner;
                            }
                            else
                            {
                                //
                                // No mem, line closed, etc
                                //

                                DestroytCall (ptCall);
                                DereferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, 1);
                                goto LINE_CALLSTATE_break;
                            }
                        }
                    }

                    DereferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, 1);
                }
                else if (Param1 == LINECALLSTATE_UNKNOWN  &&
                         Param2 == 0xa5a5a5a5)
                {
                    //
                    // If here we're being called directly from
                    // remotesp!TSPI_lineGetID, who's being called
                    // by LGetNewCalls.  We're not going to look
                    // for an owner of this call, but if we don't
                    // find any monitors we still don't want to
                    // tear the call down, because we want to give
                    // a handle to the app doing the lineGetNewCalls
                    // (which may not have MONITOR privileges).
                    //
                    // So we do the following to prevent the call
                    // from getting destroyed.
                    //

                    ptLineClientOwner = (PTLINECLIENT) 1;
                    Param2 = 0;
                }
                else
                {
                    //
                    // Set ptLineClientOwner == NULL, becaue if there
                    // aren't any monitors we'll want to destroy this
                    // calls.
                    //

                    ptLineClientOwner = (PTLINECLIENT) NULL;
                }

                if (CreateCallMonitors (ptCall, TRUE) <= 0 &&
                    !ptLineClientOwner)
                {
                    DestroytCall (ptCall);
                    goto LINE_CALLSTATE_break;
                }

                if (!WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
                {
                    goto LINE_CALLSTATE_break;
                }
            }


            //
            // NOTE: per bug #20545 we're no longer auto-dropping
            //       non-IDLE calls; figured this would be the wrong
            //       thing to do in a distributed system
            //
            //       dankn 02/15/96
            //


            //
            // SP-initiated conference
            //

            if (Param1 == LINECALLSTATE_CONFERENCED)
            {
                PTCALL              ptConfCall;

                if (!ptCall->pConfList)
                {
                    PTCONFERENCELIST    pConfList;

                    ptCall->pConfList = (LPVOID) LongToPtr(0xffffffff);

                    UNLOCKTCALL(ptCall);
                    
                    if ((ptConfCall = (PTCALL) ReferenceObject(
                        ghHandleTable,
                        (HCALL)(ULONG_PTR)Param2,
                        TCALL_KEY
                        )))
                    {
                        if (WaitForExclusivetCallAccess(
                                ptConfCall,
                                TCALL_KEY
                                ))
                        {
                            if (!ptConfCall->pConfList)
                            {
                                if ((pConfList = ServerAlloc(
                                        sizeof (TCONFERENCELIST) +
                                            sizeof(PTCALL) *
                                            (DEF_NUM_CONF_LIST_ENTRIES - 1)
                                        )))
                                {
                                    pConfList->dwKey = TCONFLIST_KEY;
                                    pConfList->dwNumTotalEntries =
                                        DEF_NUM_CONF_LIST_ENTRIES;
                                    pConfList->dwNumUsedEntries  = 1;

                                    pConfList->aptCalls[0] = ptConfCall;

                                    ptConfCall->pConfList = pConfList;
                                }
                            }

                            pConfList = ptConfCall->pConfList;

                            pConfCallClientList = &fastConfCallClientList;

                            if (GetCallClientListFromCall(
                                    ptConfCall,
                                    &pConfCallClientList

                                    ) != 0)
                            {
                                pConfCallClientList = NULL;
                            }

                            UNLOCKTCALL(ptConfCall);
                        }
                        else
                        {
                            pConfList = NULL;
                        }

                        DereferenceObject (ghHandleTable, (HCALL)(ULONG_PTR)Param2, 1);
                    }
                    else
                    {
                         pConfList = NULL;
                    }


                    SetCallConfList (ptCall, pConfList, TRUE);

                }
                else
                {
                    // Just get the existing call client list 
                    
                    UNLOCKTCALL(ptCall);
                    
                    if ((ptConfCall = (PTCALL) ReferenceObject(
                        ghHandleTable,
                        (HCALL)(ULONG_PTR)Param2,
                        TCALL_KEY
                        )))
                    {
                        if (WaitForExclusivetCallAccess(
                                ptConfCall,
                                TCALL_KEY
                                ))
                        {
                            pConfCallClientList = &fastConfCallClientList;

                            if (GetCallClientListFromCall(
                                    ptConfCall,
                                    &pConfCallClientList

                                    ) != 0)
                            {
                                pConfCallClientList = NULL;
                            }

                            UNLOCKTCALL(ptConfCall);

                        }

                        DereferenceObject (ghHandleTable, (HCALL)(ULONG_PTR)Param2, 1);

                    }
                }

                if (!WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
                {
                    if (pConfCallClientList  &&
                        pConfCallClientList != &fastConfCallClientList)
                    {
                        ServerFree (pConfCallClientList);
                    }

                    goto LINE_CALLSTATE_break;
                }
            }


            //
            // If call is a conference child and the call state has
            // changed then remove it from the conference
            //

            else if (ptCall->pConfList  &&
                     ptCall->pConfList != (PTCONFERENCELIST) LongToPtr(0xffffffff))
            {
                try
                {
                    if ( ptCall->pConfList->aptCalls[0] != ptCall)
                    {
                        SetCallConfList (ptCall, NULL, FALSE);
                    }
                }
                myexcept
                {
                }
            }


            //
            // Record the call state & mode
            //

            ptCall->dwCallState     = DWORD_CAST(Param1,__FILE__,__LINE__);
            ptCall->dwCallStateMode = (LINECALLSTATE_CONFERENCED==Param1?0:DWORD_CAST(Param2,__FILE__,__LINE__));


            //
            // Build a list of call clients & their bIndicatePrivilege
            // settings
            //

            if (GetCallClientListFromCall (ptCall, &pCallClientList) != 0)
            {
                //
                // If here we know there's at least a few entries
                // in the fastCallClientList (DEF_NUM_PTR_LIST_ENTRIES
                // to be exact), so we'll just work with that list
                // and at least get msgs out to a few clients
                //

                pCallClientList = &fastCallClientList;

                fastCallClientList.dwNumUsedEntries = DEF_NUM_PTR_LIST_ENTRIES;
            }

            dwNumUsedEntries = pCallClientList->dwNumUsedEntries;

            pPrivilegeList = (dwNumUsedEntries <= DEF_NUM_PTR_LIST_ENTRIES ?
                fastPrivilegeList :
                ServerAlloc (pCallClientList->dwNumUsedEntries * sizeof (BOOL))
                );

            if (!pPrivilegeList)
            {
                //
                // Same as above - make due with the stack bufs
                //

                pPrivilegeList = fastPrivilegeList;

                dwNumUsedEntries = DEF_NUM_PTR_LIST_ENTRIES;
            }

            for (i = 0; i < dwNumUsedEntries; i++)
            {
                ptCallClient = (PTCALLCLIENT) pCallClientList->aEntries[i];

                if ((pPrivilegeList[i] =
                        (BOOL) ptCallClient->bIndicatePrivilege))
                {
                    ptCallClient->bIndicatePrivilege = 0;
                }
            }


            //
            // It's now ok to unlock the tCall
            //

            UNLOCKTCALL(ptCall);


            //
            // Send the CALLSTATE msg to all the clients
            //

            msg->TotalSize = sizeof (ASYNCEVENTMSG) + sizeof(HCALLHUB);
            msg->Msg       = dwMsg;
            msg->Param1    = DWORD_CAST(Param1,__FILE__,__LINE__);

            for (i = 0; i < dwNumUsedEntries; i++)
            {
                ptCallClient = (PTCALLCLIENT) pCallClientList->aEntries[i];

                LOG((TL_INFO, "LineEventProc: i = [%d] corresponding ptCallClient [%p]", i, ptCallClient));

                try
                {
                    PTLINECLIENT    ptLineClient;
                    PTLINEAPP       ptLineApp;


                    LOG((TL_INFO, "LineEventProc: ptCallClient->ptLineClient[%p]", ptCallClient->ptLineClient));
                    ptLineClient = ptCallClient->ptLineClient;

                    LOG((TL_INFO, "LineEventProc: ptLineClient->ptLineApp[%p]", ptLineClient->ptLineApp));
                    ptLineApp    = ptLineClient->ptLineApp;

                    LOG((TL_INFO, "LineEventProc: setting msg->InitContext to ptLineApp[%p]->InitContext of [%p]", ptLineApp, ptLineApp->InitContext));
                    msg->InitContext = ptLineApp->InitContext;

                    msg->hDevice     = ptCallClient->hCall;

                    LOG((TL_INFO, "LineEventProc: setting msg->OpenContext to [%p]", ptLineClient->OpenContext));

                    msg->OpenContext = ptLineClient->OpenContext;

                    //
                    // REMOTESP HACK: indicate the hRemoteLine in p4
                    //

                    msg->Param4 = ptLineClient->hRemoteLine;

                    *((LPHCALLHUB)(&msg->Param4 + 1)) = 
                        (ptCallClient->ptCallHubClient)?
                            ptCallClient->ptCallHubClient->hCallHub : 
                            (HCALLHUB)0;

                    if (pPrivilegeList[i])
                    {
                        //
                        // We're presenting the app with a new call handle;
                        // for 2.0 & newer apps we indicate this with an
                        // APPNEWCALL msg, while older apps just get the
                        // privilege field set in the call state msg.
                        //

                        if (ptLineApp->dwAPIVersion >= TAPI_VERSION2_0)
                        {
                            ASYNCEVENTMSG   newCallMsg[2],
                                            *pNewCallMsg = newCallMsg;
                            PTCONFERENCELIST    pConfList;
                            BOOL                bConfParent = FALSE;

                            if (!FMsgDisabled(
                                ptCallClient->ptLineClient->ptLineApp->dwAPIVersion,
                                ptCallClient->adwEventSubMasks,
                                LINE_APPNEWCALL,
                                0
                                ))
                            {
                                pNewCallMsg->TotalSize   =
                                    sizeof (ASYNCEVENTMSG) + 3 * sizeof (DWORD);
                                pNewCallMsg->InitContext = msg->InitContext;
                                pNewCallMsg->hDevice     =
                                    ptLineClient->hRemoteLine;
                                pNewCallMsg->OpenContext = msg->OpenContext;
                                pNewCallMsg->fnPostProcessProcHandle = 0;
                                pNewCallMsg->Msg    = LINE_APPNEWCALL;
                                pNewCallMsg->Param1 = ptCall->dwAddressID;
                                pNewCallMsg->Param2 = ptCallClient->hCall;
                                pNewCallMsg->Param3 = ptCallClient->dwPrivilege;
                                *(&pNewCallMsg->Param4 + 1) = ptCall->dwCallID;
                                *(&pNewCallMsg->Param4 + 2) =
                                    ptCall->dwRelatedCallID;
                                if ((pConfList = ptCall->pConfList) &&
                                    (pConfList != (PTCONFERENCELIST) LongToPtr(0xffffffff)) &&
                                    (pConfList->aptCalls[0] == ptCall))
                                {
                                    bConfParent = TRUE;
                                }
                                *(&pNewCallMsg->Param4 + 3) = (DWORD) bConfParent;

                                if (ptCallClient->dwKey == TCALLCLIENT_KEY)
                                {
                                    LOG((TL_INFO, "LineEventProc: sending LINE_APPNEWCALL, ptClient[%p]", ptCallClient->ptClient));
                                    WriteEventBuffer(
                                        ptCallClient->ptClient,
                                        pNewCallMsg
                                        );
                                }
                            }

                            msg->Param3 = 0;
                        }
                        else
                        {
                            msg->Param3 = ptCallClient->dwPrivilege;
                        }
                    }
                    else
                    {
                        msg->Param3 = 0;
                    }

                    if (FMsgDisabled (
                        ptCallClient->ptLineClient->ptLineApp->dwAPIVersion,
                        ptCallClient->adwEventSubMasks,
                        (DWORD) msg->Msg,
                        (DWORD) msg->Param1
                        ))
                    {
                        continue;
                    }

                    //
                    // Another special case for LINECALLSTATE_CONFERENCED -
                    // try to find the corresponding hConfCall (on same
                    // tLineClient) so we can set Param2 per spec
                    //

                    if (Param1 == LINECALLSTATE_CONFERENCED)
                    {
                        BOOL    bDone = (pConfCallClientList ? FALSE : TRUE);


                        Param2 = 0;

                        while (!bDone)
                        {
                            try
                            {
                                for(
                                    j = 0;
                                    j < pConfCallClientList->dwNumUsedEntries;
                                    j++
                                    )
                                {
                                    PTCALLCLIENT    pConfCallClient;


                                    pConfCallClient = (PTCALLCLIENT)
                                        pConfCallClientList->aEntries[j];

                                    if (pConfCallClient  &&
                                        pConfCallClient->ptLineClient ==
                                            ptLineClient)
                                    {
                                        pConfCallClientList->aEntries[j] =
                                            NULL;

                                        Param2 = pConfCallClient->hCall;

                                        break;
                                    }
                                }

                                bDone = TRUE;
                            }
                            myexcept
                            {
                                //
                                // If here we presumbly blew up because
                                // an entry in the confCallClientList was
                                // bad.  So we'll zero this entry & try
                                // again.
                                //

                                pConfCallClientList->aEntries[j] = NULL;
                            }
                        }
                    }


                    //
                    // REMOTESP HACK: If the client is remote(sp), then pass
                    //                on the media mode the SP passed us in p3
                    //                We also need the privilege - in p2
                    //
                    //                Should have originally put the privilege
                    //                in msg.pfnPostProcess (since it's not
                    //                used for this msg in rmeotesp), because
                    //                in tapi 2.1 we ended up losing Param2
                    //                (the call state mode).  So now we stick
                    //                the original Param2 (the call state
                    //                mode) in msg.pfnPostProcess to maintain
                    //                compatibility.
                    //

                    if (IS_REMOTE_CLIENT (ptLineApp->ptClient))
                    {
                        msg->Param2 = ptCallClient->dwPrivilege;
                        msg->Param3 = DWORD_CAST(Param3,__FILE__,__LINE__);

                        msg->fnPostProcessProcHandle = DWORD_CAST(Param2,__FILE__,__LINE__);
                    }
                    else
                    {
                        msg->Param2 = DWORD_CAST(Param2,__FILE__,__LINE__);

                        msg->fnPostProcessProcHandle = 0;
                    }

                    if (ptCallClient->dwKey == TCALLCLIENT_KEY)
                    {
                        WriteEventBuffer (ptCallClient->ptClient, msg);
                    }
                }
                myexcept
                {
                    // do nothing, just fall thru
                }
            }

            if (pCallClientList != &fastCallClientList)
            {
                ServerFree (pCallClientList);
            }

            if (pPrivilegeList != fastPrivilegeList)
            {
                ServerFree (pPrivilegeList);
            }


            if (pConfCallClientList  &&
                pConfCallClientList != &fastConfCallClientList)
            {
                ServerFree (pConfCallClientList);
            }

        } // if ((ptCall = WaitForExclusivetCallAccess(
        else
        {
           LOG((TL_ERROR,
               "LINECALLSTATE: Failed call access for call= x%p",
               ptCall
               ));

           LOG((TL_INFO,
               "  Line=x%lx  p1=x%lx p2=x%lx p3=x%lx",
               htLine,
               Param1,
               Param2,
               Param3
               ));
        }

LINE_CALLSTATE_break:
    
        DereferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, 1);

        break;
    }
    case LINE_GATHERDIGITS:
    {
        PASYNCREQUESTINFO pAsyncRequestInfo;


        if (Param2 == 0) // dwEndToEndID
        {
            //
            // The SP is notifying us of the completion of a cancel
            // request (not a _canceled_ request), so we can just blow
            // this off and not bother passing it on to the client
            //

            break;
        }

        if ((pAsyncRequestInfo = ReferenceObject(
                ghHandleTable,
                DWORD_CAST(Param2,__FILE__,__LINE__),
                TASYNC_KEY
                )))
        {
            LPWSTR          lpsDigitsSrv = (LPWSTR)
                                (((LPBYTE) pAsyncRequestInfo) +
                                    pAsyncRequestInfo->dwParam1);

            DWORD           hpsDigitsCli = DWORD_CAST(pAsyncRequestInfo->dwParam2,__FILE__,__LINE__);

            DWORD           dwNumDigits = DWORD_CAST(pAsyncRequestInfo->dwParam3,__FILE__,__LINE__),
                            dwNumDigitsTmp;
            HCALL           hCall = (HCALL) pAsyncRequestInfo->dwParam4;
            DWORD           dwEndToEndIDRemote = DWORD_CAST(
                                pAsyncRequestInfo->dwParam5,__FILE__,__LINE__);
            PTCALLCLIENT    ptCallClient;
            ASYNCEVENTMSG   *pMsg;


            if (!(ptCallClient = (PTCALLCLIENT) ReferenceObject(
                    ghHandleTable,
                    hCall,
                    TCALLCLIENT_KEY
                    )))
            {
                goto LINE_GATHERDIGITS_dereferenceAsyncReqInfo;
                break;
            }


            //
            // 2 * sizeof ULONG_PTR is adding space to include the
            // dwEndToEndID and hRemoteLine, both for remotesp
            //

            if (!(pMsg = ServerAlloc(
                    sizeof (ASYNCEVENTMSG) + (2 * sizeof(DWORD)) +
                        (dwNumDigits + 1) * sizeof (WCHAR) + TALIGN_COUNT
                    )))
            {
                goto LINE_GATHERDIGITS_dereferenceCall;
                break;
            }


            //
            // Note: We either have < dwNumDigits digits in the buffer,
            //       and they are null-terminated, or we have dwNumDigits
            //       digits in the buffer and they are NOT null-terminated
            //       (such is the implementation given the spec)
            //

            {
                DWORD   *pDW = (DWORD *) (pMsg + 1);
                WCHAR   *pBuf = (WCHAR *) (pDW + 2);


                pDW[0] = dwEndToEndIDRemote;

                try
                {
                    pDW[1] = ptCallClient->ptLineClient->hRemoteLine;
                }
                myexcept
                {
                }

                wcsncpy (pBuf, lpsDigitsSrv, dwNumDigits);

                if ((dwNumDigitsTmp = lstrlenW (pBuf)) < dwNumDigits)
                {
                    dwNumDigits = dwNumDigitsTmp + 1;
                }
            }


            //
            // Make sure total size is DWORD-aligned so client side doesn't
            // incur an alignment fault
            //
            //  sizeof(ULONG_PTR) is added to put the dwEndToEndID in the buf
            //

            pMsg->TotalSize        = (sizeof (ASYNCEVENTMSG) +
                2 * sizeof(DWORD) +
                dwNumDigits * sizeof (WCHAR) + TALIGN_COUNT) & TALIGN_MASK;
            pMsg->InitContext        = pAsyncRequestInfo->InitContext;
            
            pMsg->fnPostProcessProcHandle = 
                pAsyncRequestInfo->hfnClientPostProcessProc;
            
            pMsg->hDevice            = hCall;
            pMsg->Msg                = LINE_GATHERDIGITS;
            pMsg->OpenContext        = pAsyncRequestInfo->OpenContext;
            pMsg->Param1             = DWORD_CAST(Param1,__FILE__,__LINE__);
            
            pMsg->Param2             = hpsDigitsCli;

            pMsg->Param3             = (Param3 ? DWORD_CAST(Param3,__FILE__,__LINE__) : GetTickCount());
            pMsg->Param4             = dwNumDigits;

            WriteEventBuffer (pAsyncRequestInfo->ptClient, pMsg);

            ServerFree (pMsg);

LINE_GATHERDIGITS_dereferenceCall:

            DereferenceObject (ghHandleTable, hCall, 1);

LINE_GATHERDIGITS_dereferenceAsyncReqInfo:

            DereferenceObject (ghHandleTable, DWORD_CAST(Param2,__FILE__,__LINE__), 2); // by 2 to free
        }
        else
        {
           LOG((TL_ERROR,
               "Bad Param2=x%lx in LINE_GATHERDIGITS msg!",
               Param2
               ));
        }

        break;
    }
    case LINE_MONITORTONE:
    {
        //
        // Note: Param2 (the dwToneListID) is really a ptCallClient
        //
        // Hack Alert!! : In the case of remotesp we'll get a special
        //                bogus Param2, in which case we really don't
        //                know who the appropriate call client is.  So
        //                we'll call SendMsgtoCallClients() and let it
        //                figure out which apps have done tone monitoring
        //                on this call, and we'll forward to all of them.
        //                It's cheesey, but the alternative is keeping a
        //                bunch of context around in the client/server
        //                case, and i really don't want to deal with that.
        //                (Plus, i doubt there will be many, if any, cases
        //                of >1 app doing remote monitor on the same call.)
        //
        //                DanKn, 06/06/98
        //

        PTCALLCLIENT    ptCallClient;


        if (Param2 == 0) // special remotesp hack
        {
            PTCALL  ptCall;

            if(ptCall = ReferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, TCALL_KEY))
            {
                SendMsgToCallClients(
                    ptCall,
                    NULL,
                    dwMsg,
                    DWORD_CAST(Param1,__FILE__,__LINE__),
                    0,
                    DWORD_CAST(Param3,__FILE__,__LINE__)
                    );

                DereferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, 1);
            }

            break;
        }

        if (!(ptCallClient = (PTCALLCLIENT) ReferenceObject(
                ghHandleTable,
                DWORD_CAST(Param2,__FILE__,__LINE__),         // dwToneListID == hCall
                TCALLCLIENT_KEY
                )))
        {
            break;
        }

        try
        {
            ASYNCEVENTMSG   msg[2];
            PTLINECLIENT    ptLineClient = ptCallClient->ptLineClient;


            ptLineClient = ptCallClient->ptLineClient;

            msg->TotalSize          = sizeof (ASYNCEVENTMSG) +
                sizeof (HCALLHUB);
            msg->InitContext        = ptLineClient->ptLineApp->InitContext;
            msg->fnPostProcessProcHandle = 0;
            msg->hDevice            = ptCallClient->hCall;
            msg->Msg                = dwMsg;
            msg->OpenContext        = ptLineClient->OpenContext;
            msg->Param1             = DWORD_CAST(Param1,__FILE__,__LINE__);
            msg->Param2             = 0;
            msg->Param3             = (Param3 ? DWORD_CAST(Param3,__FILE__,__LINE__) : GetTickCount());

            msg->Param4 = ptLineClient->hRemoteLine; // for RemoteSP

            *((LPHCALLHUB)(&msg->Param4 + 1)) = 
                        (ptCallClient->ptCallHubClient)?
                            ptCallClient->ptCallHubClient->hCallHub : 
                            (HCALLHUB)0;


            //
            // Now a final check to make sure all the
            // params are valid before sending the msg
            //

            {
                PTCLIENT    ptClient = ptCallClient->ptClient;


                if (ptCallClient->dwKey == TCALLCLIENT_KEY)
                {
                    WriteEventBuffer (ptClient, msg);
                }
            }
        }
        myexcept
        {
            // do nothing
        }

        DereferenceObject (ghHandleTable, DWORD_CAST(Param2,__FILE__,__LINE__), 1);

        break;
    }
    case LINE_GENERATE:
    {
        //
        // Note: Param2 id really a pointer to instance data containing
        //       ([0]) the hCall & ([1]) the dwEndToEndID or dwToneListID,
        //       the latter of which is only useful to remotesp
        //

        HCALL           hCall;
        DWORD           dwEndToEndID;
        LPDWORD         pInstData;
        PTCALLCLIENT    ptCallClient;


        if (!(pInstData = (LPDWORD) ReferenceObject(
                ghHandleTable,
                DWORD_CAST(Param2,__FILE__,__LINE__),
                TASYNC_KEY
                )))
        {
            break;
        }

        hCall = pInstData[1];
        dwEndToEndID = pInstData[2];

        DereferenceObject (ghHandleTable, DWORD_CAST(Param2,__FILE__,__LINE__), 2); // by 2 to free it

        if (!(ptCallClient = (PTCALLCLIENT) ReferenceObject(
                ghHandleTable,
                hCall,
                TCALLCLIENT_KEY
                )))
        {
            break;
        }

        try
        {
            ASYNCEVENTMSG   msg[2];
            PTLINECLIENT    ptLineClient = ptCallClient->ptLineClient;


            msg->TotalSize          = sizeof (ASYNCEVENTMSG) +
                sizeof (HCALLHUB);
            msg->InitContext        = ptLineClient->ptLineApp->InitContext;
            msg->fnPostProcessProcHandle = 0;
            msg->hDevice            = hCall;
            msg->Msg                = dwMsg;
            msg->OpenContext        = ptLineClient->OpenContext;
            msg->Param1             = DWORD_CAST(Param1,__FILE__,__LINE__);

            LOG((TL_INFO,
                "LineEventProc: LINE_GENERATE  OpenContext %p InitContext %p",
                msg->OpenContext, msg->InitContext ));


            //
            // Indicate the endToEndID/toneListID for remotesp, and the
            // hRemoteLine in p4 to make life easier for remotesp
            //

            msg->Param2 = dwEndToEndID;
            msg->Param3 = (Param3 ? DWORD_CAST(Param3,__FILE__,__LINE__) : GetTickCount());

            msg->Param4 = ptLineClient->hRemoteLine;

            *((LPHCALLHUB)(&msg->Param4 + 1)) = 
                        (ptCallClient->ptCallHubClient)?
                            ptCallClient->ptCallHubClient->hCallHub : 
                            (HCALLHUB)0;


            //
            // Now a final check to make sure all the
            // params are valid before sending the msg
            //

            {
                PTCLIENT    ptClient = ptCallClient->ptClient;


                if (ptCallClient->dwKey == TCALLCLIENT_KEY)
                {
                    WriteEventBuffer (ptClient, msg);
                }
            }
        }
        myexcept
        {
            // do nothing
        }

        DereferenceObject (ghHandleTable, hCall, 1);

        break;
    }
    case LINE_NEWCALL:
    {
        //
        // Create a tCall & set the bAlertApps field so we create the
        // appropriate tCallClients on the first call state msg
        //

        PTCALL      ptCall;
        PTLINE      ptLine;
        HCALL       hCall;

        ptLine = ReferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, TLINE_KEY);
        if (NULL != ptLine)
        {
            if (CreatetCall(
                    ptLine,
                    TRUE,
                    (HDRVCALL) Param1,
                    &ptCall,
                    NULL,
                    &hCall,
                    NULL

                    ) != 0)
            {
                hCall = 0;
            }

            DereferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, 1);
        }
        else
        {
            hCall = 0;
        }

        *((LPHTAPICALL) Param2) = (HTAPICALL)(ULONG_PTR)hCall;

        break;
    }
    case LINE_CREATE:
    {
        LONG                lResult;
        DWORD               dwDeviceID;
        TSPIPROC            pfnTSPI_providerCreateLineDevice;
        PTPROVIDER          ptProvider = (PTPROVIDER) Param1;
        PTLINELOOKUPTABLE   pTable, pPrevTable;
        PTLINELOOKUPENTRY   pEntry;
        PTPROVIDER          ptProvider2;


        TapiEnterCriticalSection (&TapiGlobals.CritSec);

        //
        //  Check to see if ptProvider(Param1) is still valid, LINE_CREATE
        //  might got processed after the TSP has been removed
        //
        if (NULL == ptProvider)
        {
            TapiLeaveCriticalSection (&TapiGlobals.CritSec);
            return;
        }

        ptProvider2 = TapiGlobals.ptProviders;
        while (ptProvider2 && ptProvider2 != ptProvider)
        {
            ptProvider2 = ptProvider2->pNext;
        }

        if (ptProvider2 != ptProvider)
        {
            TapiLeaveCriticalSection (&TapiGlobals.CritSec);
            return;
        }

        pfnTSPI_providerCreateLineDevice =
            ptProvider->apfn[SP_PROVIDERCREATELINEDEVICE];

        assert (pfnTSPI_providerCreateLineDevice != NULL);


        //
        // Search for a table entry (create a new table if we can't find
        // a free entry in an existing table)
        //

        if (!gbQueueSPEvents)
        {
            //
            // We're shutting down, so bail out
            //

            TapiLeaveCriticalSection (&TapiGlobals.CritSec);

            return;
        }

        pTable = TapiGlobals.pLineLookup;

        while (pTable &&
               !(pTable->dwNumUsedEntries < pTable->dwNumTotalEntries))
        {
            pPrevTable = pTable;

            pTable = pTable->pNext;
        }

        if (!pTable)
        {
            if (!(pTable = ServerAlloc(
                    sizeof (TLINELOOKUPTABLE) +
                        (2 * pPrevTable->dwNumTotalEntries - 1) *
                        sizeof (TLINELOOKUPENTRY)
                    )))
            {
                TapiLeaveCriticalSection (&TapiGlobals.CritSec);
                break;
            }

            pPrevTable->pNext = pTable;

            pTable->dwNumTotalEntries = 2 * pPrevTable->dwNumTotalEntries;
        }


        //
        // Initialize the table entry
        //

        pEntry = pTable->aEntries + pTable->dwNumUsedEntries;

        dwDeviceID = TapiGlobals.dwNumLines;

        if ((pEntry->hMutex = MyCreateMutex()))
        {
            pEntry->ptProvider = (PTPROVIDER) Param1;


            //
            // Now call the creation & negotiation entrypoints, and if all
            // goes well increment the counts & send msgs to the clients
            //

            if ((lResult = CallSP2(
                    pfnTSPI_providerCreateLineDevice,
                    "providerCreateLineDevice",
                    SP_FUNC_SYNC,
                    (ULONG_PTR) Param2,
                    (DWORD) dwDeviceID

                    )) == 0)
            {
                TSPIPROC    pfnTSPI_lineNegotiateTSPIVersion =
                                ptProvider->apfn[SP_LINENEGOTIATETSPIVERSION];
                TPOINTERLIST    clientList, *pClientList = &clientList;


                if ((lResult = CallSP4(
                        pfnTSPI_lineNegotiateTSPIVersion,
                        "",
                        SP_FUNC_SYNC,
                        (DWORD) dwDeviceID,
                        (DWORD) TAPI_VERSION1_0,
                        (DWORD) TAPI_VERSION_CURRENT,
                        (ULONG_PTR) &pEntry->dwSPIVersion

                        )) == 0)
                {
                    PTCLIENT        ptClient;
                    ASYNCEVENTMSG   msg;


                    GetPermLineIDAndInsertInTable(
                        ptProvider,
                        dwDeviceID,
                        pEntry->dwSPIVersion
                        );

                    pTable->dwNumUsedEntries++;

                    TapiGlobals.dwNumLines++;

                    TapiLeaveCriticalSection (&TapiGlobals.CritSec);
                    AppendNewDeviceInfo (TRUE, dwDeviceID);
                    TapiEnterCriticalSection (&TapiGlobals.CritSec);

                    // PERF ** Number of lines
                    PerfBlock.dwLines = TapiGlobals.dwNumLines;

                    msg.TotalSize          = sizeof (ASYNCEVENTMSG);
                    msg.fnPostProcessProcHandle = 0;
                    msg.hDevice            = 0;
                    msg.OpenContext        = 0;
                    msg.Param2             = 0;
                    msg.Param3             = 0;

                    //
                    // Only send the message if the client is an
                    // admin or we're not a telephony server
                    // we don't want to send the message to non-admin
                    // clients, because their lines have not changed.
                    //
                    if (TapiGlobals.dwFlags & TAPIGLOBALS_SERVER)
                    {
                        lResult = GetClientList (TRUE, &pClientList);
                    }
                    else
                    {
                        lResult = GetClientList (FALSE, &pClientList);
                    }
                    if (lResult == S_OK)
                    {
                        DWORD           i;
                        PTLINEAPP       ptLineApp;
                    
                        for (i = 0; i < pClientList->dwNumUsedEntries; ++i)
                        {
                            ptClient = (PTCLIENT) pClientList->aEntries[i];
                            if (!WaitForExclusiveClientAccess (ptClient))
                            {
                                continue;
                            }

                            ptLineApp = ptClient->ptLineApps;

                            while (ptLineApp)
                            {
                                if (ptLineApp->dwAPIVersion == TAPI_VERSION1_0)
                                {
                                    msg.Msg    = LINE_LINEDEVSTATE;
                                    msg.Param1 = LINEDEVSTATE_REINIT;
                                }
                                else
                                {
                                    msg.Msg    = LINE_CREATE;
                                    msg.Param1 = dwDeviceID;
                                }

                                msg.InitContext = ptLineApp->InitContext;

                                if (!FMsgDisabled (
                                    ptLineApp->dwAPIVersion,
                                    ptLineApp->adwEventSubMasks,
                                    (DWORD) msg.Msg,
                                    (DWORD) msg.Param1
                                    ))
                                {
                                    WriteEventBuffer (ptClient, &msg);
                                }

                                ptLineApp = ptLineApp->pNext;
                            }

                            UNLOCKTCLIENT (ptClient);
                        }
                    }
                }
                
                if (pClientList != &clientList)
                {
                    ServerFree (pClientList);
                }
            }

            if (lResult)
            {
                MyCloseMutex (pEntry->hMutex);
            }
        }

        TapiLeaveCriticalSection (&TapiGlobals.CritSec);
        break;
    }
    case LINE_CREATEDIALOGINSTANCE:
    {
        DWORD                               dwDataSize, dwAlignedDataSize,
                                            dwAlignedUIDllNameSize,
                                            dwTotalSize;
        PTCLIENT                            ptClient;
        PASYNCEVENTMSG                      pMsg;
        PASYNCREQUESTINFO                   pAsyncReqInfo;
        PTAPIDIALOGINSTANCE                 ptDlgInst;
        LPTUISPICREATEDIALOGINSTANCEPARAMS  pParams;


        pParams = (LPTUISPICREATEDIALOGINSTANCEPARAMS) Param1;


        //
        // Verify the async request info struct
        //

        if (!(pAsyncReqInfo = (PASYNCREQUESTINFO) ReferenceObject(
                ghHandleTable,
                pParams->dwRequestID,
                TASYNC_KEY
                )))
        {
            pParams->htDlgInst = 0;
            return;
        }

        ptClient = pAsyncReqInfo->ptClient;

        DereferenceObject (ghHandleTable, pParams->dwRequestID, 1);


        //
        // Alloc bufs for the msg & dlg instance, careful to keep offsets
        // & total msg size on 64-bit boundaries
        //

        dwDataSize             = pParams->dwSize;
        dwAlignedDataSize      = (dwDataSize + 7) & 0xfffffff8;
        dwAlignedUIDllNameSize = 0xfffffff8 & (7 +
            ((lstrlenW ((PWSTR) pParams->lpszUIDLLName) + 1)*sizeof (WCHAR)));

        dwTotalSize = sizeof (ASYNCEVENTMSG) + dwAlignedDataSize +
            dwAlignedUIDllNameSize;

        if (!(pMsg = ServerAlloc (dwTotalSize)))
        {
            pParams->htDlgInst = 0;
            return;
        }

        if (!(ptDlgInst = ServerAlloc (sizeof (TAPIDIALOGINSTANCE))))
        {
            ServerFree (pMsg);
            pParams->htDlgInst = 0;
            return;
        }
        ptDlgInst->htDlgInst  = NewObject(ghHandleTable, ptDlgInst, NULL);
        if (0 == ptDlgInst->htDlgInst)
        {
            ServerFree (pMsg);
            ServerFree (ptDlgInst);
            pParams->htDlgInst = 0;
            return;
        }


        //
        // Add the dlg inst to the tClient's list
        //

        LOCKTCLIENT (ptClient);
        if ((ptDlgInst->pNext = ptClient->pGenericDlgInsts))
        {
            ptDlgInst->pNext->pPrev = ptDlgInst;
        }

        ptClient->pGenericDlgInsts = ptDlgInst;
        UNLOCKTCLIENT (ptClient);


        //
        // Init dlg inst struct & send msg to client
        //
        ptDlgInst->dwKey      = TDLGINST_KEY;
        ptDlgInst->hdDlgInst  = pParams->hdDlgInst;
        ptDlgInst->ptClient   = ptClient;
        ptDlgInst->ptProvider = (PTPROVIDER) htLine;

        pMsg->TotalSize = dwTotalSize;
        pMsg->hDevice   = ptDlgInst->htDlgInst;
        try
        {
            if (ptClient->ptLineApps)
            {
                pMsg->InitContext = ptClient->ptLineApps->InitContext;
            }
        }
        myexcept
        {
            pMsg->InitContext = 0;
        }
        pMsg->Msg       = LINE_CREATEDIALOGINSTANCE;
        pMsg->Param1    = sizeof (ASYNCEVENTMSG);           // data offset
        pMsg->Param2    = dwDataSize;                       // data size
        pMsg->Param3    = sizeof (ASYNCEVENTMSG) + dwAlignedDataSize;
                                                            // name offset

        CopyMemory ((LPBYTE)(pMsg + 1), pParams->lpParams, dwDataSize);

        wcscpy(
            (PWSTR) ((LPBYTE)(pMsg + 1) + dwAlignedDataSize),
            (PWSTR) pParams->lpszUIDLLName
            );

        pParams->htDlgInst = ptDlgInst->htDlgInst;

        WriteEventBuffer (ptClient, pMsg);

        ServerFree (pMsg);

        break;
    }
    case LINE_SENDDIALOGINSTANCEDATA:
    {
        DWORD               dwDataSize, dwAlignedDataSize, dwTotalSize;
        PTCLIENT            ptClient;
        PASYNCEVENTMSG      pMsg;
        PTAPIDIALOGINSTANCE ptDlgInst = ReferenceObject (ghHandleTable, DWORD_CAST((ULONG_PTR)htLine,__FILE__,__LINE__), TDLGINST_KEY);


        //
        // Verify the dlg inst
        //

        try
        {
            ptClient = ptDlgInst->ptClient;

            if (ptDlgInst->dwKey != TDLGINST_KEY)
            {
                return;
            }
        }
        myexcept
        {
            return;
        }


        DereferenceObject (ghHandleTable, DWORD_CAST((ULONG_PTR)htLine,__FILE__,__LINE__), 1);

        //
        // Careful to keep offsets & total msg size on 64-bit boundaries
        //

        dwDataSize        = (DWORD) Param2;
        dwAlignedDataSize = (dwDataSize + 7) & 0xfffffff8;
        dwTotalSize       = sizeof (ASYNCEVENTMSG) + dwAlignedDataSize;

        if (!(pMsg = ServerAlloc (dwTotalSize)))
        {
            return;
        }


        //
        // Send the msg to the client
        //

        pMsg->TotalSize = dwTotalSize;
        pMsg->hDevice   = ptDlgInst->htDlgInst;
        try
        {
            if (ptClient->ptLineApps)
            {
                pMsg->InitContext = ptClient->ptLineApps->InitContext;
            }
        }
        myexcept
        {
            pMsg->InitContext = 0;
        }
        pMsg->Msg       = LINE_SENDDIALOGINSTANCEDATA;
        pMsg->Param1    = sizeof (ASYNCEVENTMSG); // data offset
        pMsg->Param2    = dwDataSize;             // data size

        CopyMemory ((LPBYTE)(pMsg + 1), (LPBYTE) Param1, dwDataSize);

        WriteEventBuffer (ptClient, pMsg);

        ServerFree (pMsg);

        break;
    }
    case LINE_REMOVE:
    {
        PTLINELOOKUPENTRY   pLookupEntry;
        HANDLE              hLookupEntryMutex = NULL;
        BOOL                bOK = FALSE;

        TapiEnterCriticalSection (&TapiGlobals.CritSec);

        if (!(pLookupEntry = GetLineLookupEntry ((DWORD) Param1)) || 
            pLookupEntry->bRemoved)
        {
            TapiLeaveCriticalSection(&TapiGlobals.CritSec);
            return;
        }

        if ( pLookupEntry->hMutex )
        {
            bOK = DuplicateHandle(
                        TapiGlobals.hProcess,
                        pLookupEntry->hMutex,
                        TapiGlobals.hProcess,
                        &hLookupEntryMutex,
                        0,
                        FALSE,
                        DUPLICATE_SAME_ACCESS
                        );
        }

        TapiLeaveCriticalSection(&TapiGlobals.CritSec); 

        if ( !bOK )
        {
            return;
        }

        //
        // Wait for the LookupEntry's mutex on the duplicate handle
        //
        if (WaitForSingleObject (hLookupEntryMutex, INFINITE)
                    != WAIT_OBJECT_0)
        {
            return;
        }

        //
        // Mark the lookup table entry as removed
        //

        pLookupEntry->bRemoved = 1;

        //
        // Release the mutex and close the duplicate handle
        //
        ReleaseMutex (hLookupEntryMutex);
        CloseHandle (hLookupEntryMutex);
        hLookupEntryMutex = NULL;

        if (pLookupEntry->ptLine)
        {
            DestroytLine (pLookupEntry->ptLine, TRUE); // unconditional destroy
        }

        TapiEnterCriticalSection (&TapiGlobals.CritSec);

        //
        // Close the mutex to reduce overall handle count
        //
        MyCloseMutex (pLookupEntry->hMutex);
        pLookupEntry->hMutex = NULL;

        RemoveDeviceInfoEntry (TRUE, (DWORD)Param1);

        TapiLeaveCriticalSection(&TapiGlobals.CritSec); 

        SendAMsgToAllLineApps(
            TAPI_VERSION2_0 | 0x80000000,
            LINE_REMOVE,
            DWORD_CAST(Param1,__FILE__,__LINE__),
            0,
            0
            );

        break;
    }
    case LINE_APPNEWCALLHUB:
    case LINE_CALLHUBCLOSE:
    {
        //
        // This msg gets queued/sent by our own internal
        // DoCallHubHashing func.  See comments there for
        // more info.
        //

        ASYNCEVENTMSG   msg;
        
        PTCLIENT ptClient = NULL;

        msg.TotalSize          = sizeof (ASYNCEVENTMSG);
        
        msg.InitContext        = DWORD_CAST(Param2,__FILE__,__LINE__);
        msg.fnPostProcessProcHandle = 0;
        msg.hDevice            = 0;
        msg.Msg                = dwMsg;
        msg.OpenContext        = 0;
        msg.Param1             = DWORD_CAST(Param1,__FILE__,__LINE__);
        msg.Param2             =
        msg.Param3             = 0;

        
        //
        // try to recover the pointer to tClient from the 32-bit handle value
        // 

        ptClient = (PTCLIENT) Param3;

        if (NULL != ptClient)
        {
            WriteEventBuffer (ptClient, &msg);
        }
        else
        {
            LOG((TL_ERROR, "LineEventProc: LINE_APPNEWCALLHUB/LINE_CALLHUBCLOSE failed to recover ptClient"));
        }

        break;
    }

    case LINE_SENDMSPDATA:
    {
        PASYNCEVENTMSG          pmsg;
        PTLINECLIENT            ptLineClient = NULL;
        PTCALLCLIENT            ptCallClient = NULL;
        DWORD                   dwSize = (sizeof (ASYNCEVENTMSG) +
                                    DWORD_CAST(Param3,__FILE__,__LINE__) + TALIGN_COUNT) &
                                    TALIGN_MASK;
        DWORD                   initContext;
        PTCLIENT                ptClient = NULL;
        DWORD                   dwCount;
        BOOL                    bFound = FALSE;
        TPOINTERLIST            clientList, *pClientList = &clientList;
        PTCALL                  ptCall;
        DWORD                   hLine = 0, hCall = 0;


        if ( (0 == Param1) && (0 == htCall) )
        {
            return;
        }
        
        if ( 0 != Param1 )
        {
            if (!(ptLineClient = (PTLINECLIENT) ReferenceObject(
                    ghHandleTable,
                    DWORD_CAST(Param1,__FILE__,__LINE__),
                    TLINECLIENT_KEY
                    )))
            {
                return;
            }

            ptClient = ptLineClient->ptClient;
            
            initContext = ptLineClient->ptLineApp->InitContext;
        }


        //
        // If ptCall isn't NULL, try to find the call client
        // corresponding to this line client
        //

        if (0 != htCall)
        {
            if (ptCall = ReferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, TCALL_KEY))
            {
                if ( NULL == ptLineClient )
                {
                    SendBufferMsgToCallClients(
                        ptCall,
                        NULL,
                        LINE_SENDMSPDATA,
                        0,
                        DWORD_CAST(Param3,__FILE__,__LINE__),
                        (LPBYTE)Param2
                        );

                    DereferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, 1);

                    return;
                }

                if (GetCallClientListFromCall (ptCall, &pClientList) == 0)
                {
                    for(
                        dwCount = 0;
                        dwCount < pClientList->dwNumUsedEntries;
                        dwCount++
                        )
                    {
                        ptCallClient = pClientList->aEntries[dwCount];

                        try
                        {
                            if ( ptCallClient->ptLineClient == ptLineClient )
                            {
                                bFound = TRUE;
                                break;
                            }
                        }
                        myexcept
                        {
                            // do nothing
                        }
                    }

                    if ( pClientList != &clientList )
                    {
                        ServerFree( pClientList );
                    }
                }

                DereferenceObject( ghHandleTable, (HCALL)(ULONG_PTR)htCall, 1);
            }

            if ( !bFound )
            {
                //
                // Didn't find it for some reason
                //

                DereferenceObject( ghHandleTable, DWORD_CAST(Param1,__FILE__,__LINE__), 1 );
                return;
            }
        }

        if ( NULL != ptLineClient )
        {
            hLine = ptLineClient->hLine;
            DereferenceObject( ghHandleTable, DWORD_CAST(Param1,__FILE__,__LINE__), 1 );
        }

        if ( NULL != ptCallClient )
        {
            hCall = ptCallClient->hCall;
        }

        pmsg = ( PASYNCEVENTMSG )ServerAlloc( dwSize );

        if (NULL == pmsg)
        {
            LOG((TL_ERROR, "Alloc failed in LINE_SENDMSPDATA"));

            return;
        }

        CopyMemory ((LPBYTE) (pmsg+1), (LPBYTE) Param2, Param3);

        pmsg->TotalSize             = dwSize;
        pmsg->InitContext           = initContext;
        pmsg->fnPostProcessProcHandle    = 0;
        pmsg->hDevice               = hLine;
        pmsg->Msg                   = LINE_SENDMSPDATA;
        pmsg->OpenContext           = 0;
        pmsg->Param1                = hCall;
        pmsg->Param2                = DWORD_CAST(Param3,__FILE__,__LINE__);
        pmsg->Param3                = 0;

        WriteEventBuffer ( ptClient, pmsg );

        ServerFree( pmsg );

        break;
    }

    case LINE_QOSINFO:
    {
        ASYNCEVENTMSG   msg;
        PTCALL          ptCall;
        TPOINTERLIST    clientList, *pclientList = &clientList;
        int             i;

        ptCall = ReferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, TCALL_KEY);
        if (0 == ptCall)
        {
            break;
        }

        clientList.dwNumUsedEntries = 0;
        if (GetCallClientListFromCall (ptCall, &pclientList) == 0)
        {
            PTCALLCLIENT    ptCallClient;
            
            msg.TotalSize          = sizeof (ASYNCEVENTMSG);
            msg.fnPostProcessProcHandle = 0;
            msg.Msg                = dwMsg;
            msg.OpenContext        = 0;
            msg.Param1             = DWORD_CAST(Param1,__FILE__,__LINE__);
            msg.Param2             = DWORD_CAST(Param2,__FILE__,__LINE__);
            msg.Param3             = 0;

            for (i = 0; i < (int)pclientList->dwNumUsedEntries; ++ i)
            {
                ptCallClient = (PTCALLCLIENT) pclientList->aEntries[i];
                if (WaitForExclusivetCallAccess (ptCallClient->ptCall, TCALL_KEY))
                {
                    BOOL    b = FMsgDisabled(
                        ptCallClient->ptLineClient->ptLineApp->dwAPIVersion,
                        ptCallClient->adwEventSubMasks,
                        LINE_QOSINFO,
                        0
                        );
                    UNLOCKTCALL (ptCallClient->ptCall);
                    if (b)
                    {
                        continue;
                    }
                }
                msg.InitContext        = 
                    ptCallClient->ptLineClient->ptLineApp->InitContext;
                msg.hDevice = ptCallClient->hCall;
                WriteEventBuffer (ptCallClient->ptClient, &msg);
            }

            if (pclientList && (pclientList != &clientList))
            {
                ServerFree (pclientList);
            }
        }
        
        DereferenceObject(ghHandleTable, (HCALL)(ULONG_PTR)htCall, 1);

        break;
    }

    case LINE_DEVSPECIFICEX:
    {
        PTLINE  ptLine;

        ptLine = ReferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, TLINE_KEY);

        if(ptLine)
        {
            SendBufferMsgToLineClients(
                ptLine,
                NULL,
                LINE_DEVSPECIFICEX,
                DWORD_CAST(Param1,__FILE__,__LINE__),
                DWORD_CAST(Param2,__FILE__,__LINE__),
                (LPBYTE) Param3
                );

            DereferenceObject(ghHandleTable, (HLINE)(ULONG_PTR)htLine, 1);
        }
        break;
    }
    default:

        // if DBG assert (unrecognized dwMsg)

        break;
    }
}


void
CALLBACK
LineEventProcSP(
    HTAPILINE   htLine,
    HTAPICALL   htCall,
    DWORD       dwMsg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    )
{
    PSPEVENT    pSPEvent;


#if DBG
    if (gdwDebugLevel >= 3)
    {
        char           *pszMsg;
        static char     szInvalMsgVal[] = "<inval msg value>";
        static char    *aszMsgs[] =
        {
            "LINE_ADDRESSSTATE",
            "LINE_CALLINFO",
            "LINE_CALLSTATE",
            "LINE_CLOSE",
            "LINE_DEVSPECIFIC",
            "LINE_DEVSPECIFICFEATURE",
            "LINE_GATHERDIGITS",
            "LINE_GENERATE",
            "LINE_LINEDEVSTATE",
            "LINE_MONITORDIGITS",
            "LINE_MONITORMEDIA",
            "LINE_MONITORTONE",
            szInvalMsgVal,              // LINE_REPLY
            szInvalMsgVal,              // LINE_REQUEST
            szInvalMsgVal,              // PHONE_BUTTON
            szInvalMsgVal,              // PHONE_CLOSE
            szInvalMsgVal,              // PHONE_DEVSPECIFIC
            szInvalMsgVal,              // PHONE_REPLY
            szInvalMsgVal,              // PHONE_STATE
            "LINE_CREATE",
            szInvalMsgVal,              // PHONE_CREATE
            "LINE_AGENTSPECIFIC",
            "LINE_AGENTSTATUS",
            szInvalMsgVal,              // LINE_APPNEWCALL
            "LINE_PROXYREQUEST",
            "LINE_REMOVE",
            szInvalMsgVal,              // PHONE_REMOVE

            "LINE_NEWCALL",
            "LINE_CALLDEVSPECIFIC",
            "LINE_CALLDEVSPECIFICFEATURE",
            "LINE_CREATEDIALOGINSTANCE",
            "LINE_SENDDIALOGINSTANCEDATA"
        };


        if (dwMsg <= PHONE_REMOVE)
        {
            pszMsg = aszMsgs[dwMsg];
        }
        else if (dwMsg >= LINE_NEWCALL && dwMsg <= LINE_SENDDIALOGINSTANCEDATA)
        {
            pszMsg = aszMsgs[27 + dwMsg - TSPI_MESSAGE_BASE];
        }
        else
        {
            pszMsg = szInvalMsgVal;
        }

        LOG((TL_TRACE, 
            "LineEventProcSP: enter\n" \
                "\t   Msg=%s (x%x), htLine=x%x, htCall=x%x",
            pszMsg,
            dwMsg,
            htLine,
            htCall
            ));

        if (dwMsg == LINE_CALLSTATE)
        {
            char           *pszCallState;
            static char     szInvalCallStateVal[] = "<inval callstate value>";
            static char    *aszCallStates[] =
            {
                "IDLE",
                "OFFERING",
                "ACCEPTED",
                "DIALTONE",
                "DIALING",
                "RINGBACK",
                "BUSY",
                "SPECIALINFO",
                "CONNECTED",
                "PROCEEDING",
                "ONHOLD",
                "CONFERENCED",
                "ONHOLDPENDCONF",
                "ONHOLDPENDTRANSFER",
                "DISCONNECTED",
                "UNKNOWN"
            };


            if (!IsOnlyOneBitSetInDWORD(Param1) ||
                Param1 > LINECALLSTATE_UNKNOWN)
            {
                pszCallState = szInvalCallStateVal;
            }
            else
            {
                DWORD   i, dwBitMask;

                for(
                    i = 0, dwBitMask = 1;
                    Param1 != dwBitMask;
                    i++, dwBitMask <<= 1
                    );


                pszCallState = aszCallStates[i];
            }

            LOG((TL_INFO,
                "  P1=%s (x%x), P2=x%x, P3=x%x",
                pszCallState,
                Param1,
                Param2,
                Param3
                ));
        }
        else
        {
            LOG((TL_INFO,
                "  P1=x%x, P2=x%x, P3=x%x",
                Param1,
                Param2,
                Param3
                ));
        }
    }
#endif

    LOG((TL_INFO, 
        "LineEventProcSP: HTapiLine=%p, HTapiCall=%p, msg=%lx, P1=x%x, P2=x%x, P3=x%x",
        htLine,
        htCall,
        dwMsg,
        Param1,
        Param2,
        Param3
    ));

    switch (dwMsg)
    {
    case LINE_NEWCALL:
    case LINE_CREATEDIALOGINSTANCE:
    case LINE_SENDDIALOGINSTANCEDATA:
    case LINE_DEVSPECIFICEX:
        //
        // These msgs need immediate attention, since they contain
        // pointers that we need to play with which may not be
        // available during async processing later
        //

        LineEventProc (htLine, htCall, dwMsg, Param1, Param2, Param3);
        break;

    case LINE_SENDMSPDATA:
        if ((pSPEvent = (PSPEVENT) ServerAlloc ( sizeof (SPEVENT) + (DWORD)Param3)))
        {
            CopyMemory(
                       (LPBYTE)(pSPEvent+1),
                       (LPBYTE)Param2,
                       Param3
                      );
            
            pSPEvent->dwType   = SP_LINE_EVENT;
            pSPEvent->htLine   = htLine;
            pSPEvent->htCall   = htCall;
            pSPEvent->dwMsg    = dwMsg;
            pSPEvent->dwParam1 = Param1;
            pSPEvent->dwParam2 = (ULONG_PTR)(LPBYTE)(pSPEvent+1);
            pSPEvent->dwParam3 = Param3;

            if (!QueueSPEvent (pSPEvent))
            {
                ServerFree (pSPEvent);
            }

            break;
        }

    default:

        if ((pSPEvent = (PSPEVENT) ServerAlloc (sizeof (SPEVENT))))
        {
            pSPEvent->dwType   = SP_LINE_EVENT;
            pSPEvent->htLine   = htLine;
            pSPEvent->htCall   = htCall;
            pSPEvent->dwMsg    = dwMsg;
            pSPEvent->dwParam1 = Param1;
            pSPEvent->dwParam2 = Param2;
            pSPEvent->dwParam3 = Param3;

            if (!QueueSPEvent (pSPEvent))
            {
                ServerFree (pSPEvent);
            }
        }
        else if (dwMsg != LINE_CLOSE  ||  Param3 != 0xdeadbeef)
        {
            //
            // Alloc failed, so call the event proc within the SP's context
            // (but not if it's  CLOSE msg and Param3 == 0xdeadbeef,
            // which means the real EventProc() is calling us directly &
            // we don't want to recurse)
            //

            LOG((TL_ERROR,
                "LineEventProcSP: alloc failed, calling EventProc inline"
                ));

            LineEventProc (htLine, htCall, dwMsg, Param1, Param2, Param3);
        }

        break;
    }

}


void
WINAPI
LAccept(
	PTCLIENT			ptClient,
    PLINEACCEPT_PARAMS  pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;
    TSPIPROC            pfnTSPI_lineAccept;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if ((pParams->dwUserUserInfoOffset != TAPI_NO_DATA)  &&

        ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwSize,
            pParams->dwUserUserInfoOffset,
            sizeof(DWORD),
            "LAccept",
            "pParams->UserUserInfo"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEACCEPT,              // provider func index
            &pfnTSPI_lineAccept,        // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "Accept"                    // func name

            )) > 0)
    {
        DWORD   dwAppNameSize;
        LPVOID  pszAppName = NULL;
        PTCALL  ptCall;


        //
        // Safely check to see if the app name associated with this call is
        // NULL (meaning this is the first client to accept/answer the call),
        // and if so save the app name
        //

        try
        {
            ptCall = (PTCALL) ptCallClient->ptCall;

            if (ptCall->pszAppName == NULL)
            {
                PTLINEAPP   ptLineApp;


                ptLineApp = ptCallClient->ptLineClient->ptLineApp;

                dwAppNameSize = ptLineApp->dwFriendlyNameSize;

                if (ptLineApp->dwKey != TLINEAPP_KEY)
                {
                    lRequestID = LINEERR_INVALCALLHANDLE;
                    goto LAccept_epilog;
                }

                if ((pszAppName = ServerAlloc (dwAppNameSize)))
                {
                    CopyMemory(
                        pszAppName,
                        ptLineApp->pszFriendlyName,
                        dwAppNameSize
                        );
                }
            }
        }
        myexcept
        {
            ServerFree (pszAppName);

            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LAccept_epilog;
        }


        if (pszAppName)
        {
            if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
            {
                if (!ptCall->pszAppName)
                {
                    ptCall->pszAppName = pszAppName;
                    ptCall->dwAppNameSize = dwAppNameSize;

                    pszAppName = NULL;
                }

                UNLOCKTCALL (ptCall);

                ServerFree (pszAppName);
            }
            else
            {
                ServerFree (pszAppName);

                lRequestID = LINEERR_INVALCALLHANDLE;
                goto LAccept_epilog;
            }
        }

        pParams->lResult = CallSP4(
            pfnTSPI_lineAccept,
            "lineAccept",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) (pParams->dwUserUserInfoOffset == TAPI_NO_DATA ? NULL :
                pDataBuf + pParams->dwUserUserInfoOffset),
            (DWORD) (pParams->dwUserUserInfoOffset == TAPI_NO_DATA ? 0 :
                pParams->dwSize)
                );
    }

LAccept_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Accept"
        );
}


void
LAddToConference_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
    PTCALL  ptConsultCall = (PTCALL) pAsyncRequestInfo->dwParam1;


    if (pAsyncEventMsg->Param2 == 0)
    {
        PTCONFERENCELIST    pConfList = (PTCONFERENCELIST)
                                pAsyncRequestInfo->dwParam2;


        SetCallConfList (ptConsultCall, pConfList, TRUE);
    }
    else
    {
        SetCallConfList (ptConsultCall, NULL, TRUE);
    }
}


void
WINAPI
LAddToConference(
	PTCLIENT					ptClient,
    PLINEADDTOCONFERENCE_PARAMS pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdConfCall;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptConsultCallClient, ptConfCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;
    TSPIPROC            pfnTSPI_lineAddToConference;


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hConfCall, // client widget handle
            (LPVOID) &hdConfCall,       // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEADDTOCONFERENCE,     // provider func index
            &pfnTSPI_lineAddToConference,   // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptConfCallClient,          // context
            "AddToConference"           // func name

            )) > 0)
    {
        PTCALL              ptConfCall, ptConsultCall;
        HDRVCALL            hdConsultCall;
        PTCONFERENCELIST    pConfList;


        //
        // Safely make sure that the conf call is really a conf parent
        //

        try
        {
            ptConfCall = ptConfCallClient->ptCall;

            if (!(pConfList = ptConfCall->pConfList) ||
                (pConfList->aptCalls[0] != ptConfCall))
            {
                lRequestID = LINEERR_INVALCONFCALLHANDLE;
                goto LAddToConference_return;
            }
        }
        myexcept
        {
            lRequestID = LINEERR_INVALCONFCALLHANDLE;
            goto LAddToConference_return;
        }

        //
        // Verify hConsultCall
        //

        if (!(ptConsultCallClient = ReferenceCall(
                pParams->hConsultCall,
                ptClient
                )))
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LAddToConference_return;
        }


        //
        // Safely make sure calls are on same tLineClient, that client has
        // owner privilege for consult call, and that the consult call
        // is neither a conf parent or child (call SetCallConfList
        // with an inval list to temporarily mark the call as conf'd)
        //

        try
        {
            ptConsultCall = ptConsultCallClient->ptCall;

            if (ptConsultCallClient->ptLineClient !=
                    ptConfCallClient->ptLineClient)
            {
                lRequestID = LINEERR_INVALCALLHANDLE;
                goto LAddToConference_dereference;
            }

            if (!(ptConsultCallClient->dwPrivilege & LINECALLPRIVILEGE_OWNER))
            {
                lRequestID = LINEERR_NOTOWNER;
                goto LAddToConference_dereference;
            }

            if (SetCallConfList(
                    ptConsultCall,
                    (PTCONFERENCELIST) LongToPtr(0xffffffff),
                    FALSE
                    ))
            {
                lRequestID = (pConfList->aptCalls[0] == ptConsultCall ?
                     LINEERR_INVALCALLHANDLE : LINEERR_INVALCALLSTATE);

                goto LAddToConference_dereference;
            }

            hdConsultCall = ptConsultCall->hdCall;
        }
        myexcept
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LAddToConference_dereference;
        }


        //
        // Set up the async request struct & call the SP
        //

        pAsyncRequestInfo->pfnPostProcess = LAddToConference_PostProcess;
        pAsyncRequestInfo->dwParam1       = (ULONG_PTR) ptConsultCall;
        pAsyncRequestInfo->dwParam2       = (ULONG_PTR) pConfList;

        pParams->lResult = CallSP3(
            pfnTSPI_lineAddToConference,
            "lineAddToConference",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdConfCall,
            (ULONG_PTR) hdConsultCall
            );

LAddToConference_dereference:

        DereferenceObject (ghHandleTable, pParams->hConsultCall, 1);

    }


LAddToConference_return:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "AddToConference"
        );
}


void
WINAPI
LAgentSpecific(
	PTCLIENT					ptClient,
    PLINEAGENTSPECIFIC_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwParamsSize,
            pParams->dwParamsOffset,
            sizeof(DWORD),
            "LAgentSpecific",
            "pParams->Params"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "AgentSpecific"             // func name

            )) > 0)
    {
        LONG            lResult;
        DWORD           dwDeviceID, dwParamsSize = pParams->dwParamsSize;
        PTLINECLIENT    pProxy;


        if ((lResult = FindProxy(
                ptLineClient,
                pParams->dwAddressID,
                LINEPROXYREQUEST_AGENTSPECIFIC,
                &pProxy,
                &dwDeviceID,
                0               // API ver wasn't checked in 2.0
                )))
        {
            lRequestID = lResult;
            goto LAgentSpecific_epilog;
        }


        //
        // Save the client's buf ptr & post processing proc ptr
        //

        pAsyncRequestInfo->dwParam1 = pParams->hpParams;
        pAsyncRequestInfo->dwParam2 = dwParamsSize;
        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;


        //
        // First check to see if there's a (local) proxy registered
        // for this type of request on this line.  If so, build a
        // request & send it to the proxy.
        //

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_AGENTSPECIFIC,
                    3 * sizeof (DWORD) + dwParamsSize,
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LAgentSpecific_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.AgentSpecific.dwAddressID  =
                pParams->dwAddressID;
            pProxyRequestWrapper->ProxyRequest.AgentSpecific.
                dwAgentExtensionIDIndex  = pParams->dwAgentExtensionIDIndex;
            pProxyRequestWrapper->ProxyRequest.AgentSpecific.dwSize  =
                dwParamsSize;

            CopyMemory(
                pProxyRequestWrapper->ProxyRequest.AgentSpecific.Params,
                pDataBuf + pParams->dwParamsOffset,
                dwParamsSize
                );

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LAgentSpecific_epilog;
            }
            else // success
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


        //
        // There's no proxy, so check to see if line is remote and
        // call remotesp if so
        //

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            LPBYTE  pBuf;


            //
            // Alloc a shadow buf that the SP can use until it completes this
            // request.  Make sure there's enough extra space in the buf for
            // an ASYNCEVENTMSG header so we don't have to alloc yet another
            // buf in the post processing proc when preparing the completion
            // msg to send to the client, and that the msg is 64-bit aligned.
            //

            if (!(pBuf = ServerAlloc(
                    sizeof (ASYNCEVENTMSG) + ((dwParamsSize + 7) & 0xfffffff8)
                    )))
            {
                lRequestID = LINEERR_NOMEM;
                goto LAgentSpecific_epilog;
            }

            pAsyncRequestInfo->pfnPostProcess = LDevSpecific_PostProcess;

            pAsyncRequestInfo->dwParam3 = (ULONG_PTR) pBuf;

            CopyMemory(
                pBuf + sizeof (ASYNCEVENTMSG),
                pDataBuf + pParams->dwParamsOffset,
                dwParamsSize
                );

            pParams->lResult = CallSP6(
                pRemoteSP->apfn[SP_LINEAGENTSPECIFIC],
                "lineAgentSpecific",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->dwAddressID,
                (DWORD) pParams->dwAgentExtensionIDIndex,
                (ULONG_PTR) (pBuf + sizeof (ASYNCEVENTMSG)),
                (DWORD) dwParamsSize
                );
        }


        //
        // There's no registered proxy & line is not remote, so fail
        //

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LAgentSpecific_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "AgentSpecific"
        );
}

void
WINAPI
LAnswer(
	PTCLIENT			ptClient,
    PLINEANSWER_PARAMS  pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineAnswer;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if ((pParams->dwUserUserInfoOffset != TAPI_NO_DATA)  &&

        ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwUserUserInfoSize,
            pParams->dwUserUserInfoOffset,
            sizeof(DWORD),
            "LAnswerReal",
            "pParams->UserUserInfo"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }

    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEANSWER,              // provider func index
            &pfnTSPI_lineAnswer,        // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "Answer"                    // func name

            )) > 0)
    {
        DWORD           dwAppNameSize;
        LPVOID          pszAppName = NULL;
        PTCALL          ptCall;


        //
        // Safely check to see if the app name associated with this call is
        // NULL (meaning this is the first client to accept/answer the call),
        // and if so save the app name
        //

        try
        {
            ptCall = (PTCALL) ptCallClient->ptCall;

            if (ptCall->pszAppName == NULL)
            {
                PTLINEAPP   ptLineApp;


                ptLineApp = ptCallClient->ptLineClient->ptLineApp;

                dwAppNameSize = ptLineApp->dwFriendlyNameSize;

                if (ptLineApp->dwKey != TLINEAPP_KEY)
                {
                    lRequestID = LINEERR_INVALCALLHANDLE;
                    goto LAnswer_epilog;
                }

                if ((pszAppName = ServerAlloc (dwAppNameSize)))
                {
                    CopyMemory(
                        pszAppName,
                        ptLineApp->pszFriendlyName,
                        dwAppNameSize
                        );
                }
            }
        }
        myexcept
        {
            ServerFree (pszAppName);

            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LAnswer_epilog;
        }


        if (pszAppName)
        {
            if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
            {
                if (!ptCall->pszAppName)
                {
                    ptCall->pszAppName = pszAppName;
                    ptCall->dwAppNameSize = dwAppNameSize;

                    pszAppName = NULL;
                }

                UNLOCKTCALL (ptCall);

                ServerFree (pszAppName);
            }
            else
            {
                ServerFree (pszAppName);

                lRequestID = LINEERR_INVALCALLHANDLE;
                goto LAnswer_epilog;
            }
        }

        pParams->lResult = CallSP4(
                pfnTSPI_lineAnswer,
                "lineAnswer",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdCall,
                (ULONG_PTR) (pParams->dwUserUserInfoOffset == TAPI_NO_DATA ?
                    NULL : pDataBuf + pParams->dwUserUserInfoOffset),
                (DWORD) (pParams->dwUserUserInfoOffset == TAPI_NO_DATA ?
                    0 : pParams->dwUserUserInfoSize)
                );
    }

LAnswer_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Answer"
        );
}


void
WINAPI
LBlindTransfer(
    PTCLIENT                    ptClient,
    PLINEBLINDTRANSFER_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineBlindTransfer;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDestAddressOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEBLINDTRANSFER,       // provider func index
            &pfnTSPI_lineBlindTransfer, // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "BlindTransfer"             // func name

            )) > 0)
    {
        pParams->lResult = CallSP4(
            pfnTSPI_lineBlindTransfer,
            "lineBlindTransfer",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) (pDataBuf + pParams->dwDestAddressOffset),
            (DWORD) pParams->dwCountryCode
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "BlindTransfer"
        );
}


void
WINAPI
LClose(
    PTCLIENT            ptClient,
    PLINECLOSE_PARAMS   pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            NULL,                       // mutex handle
            NULL,                       // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "Close"                     // func name

            )) == 0)
    {
        if (NULL != ptLineClient)
        {
            pParams->dwCallbackInstance = ptLineClient->OpenContext;
        }
        DestroytLineClient ((HLINE) pParams->hLine);
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        NULL,
        FALSE,
        objectToDereference,
        "Close"
        );

    LOG((TL_TRACE,  "Leaving lineClose"));
}


void
WINAPI
LCloseMSPInstance(
    PTCLIENT                        ptClient,
    PLINECLOSEMSPINSTANCE_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineCloseMSPInstance;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    

    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINECLOSEMSPINSTANCE,    // provider func index
            &pfnTSPI_lineCloseMSPInstance,  // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID,
            &objectToDereference,
            &ptLineClient,
            "CloseMSPInstance"         // func name

            )) == 0)
    {
        pParams->lResult = CallSP1(
            pfnTSPI_lineCloseMSPInstance,
            "lineCloseMSPInstance",
            SP_FUNC_SYNC,
            (ULONG_PTR) (ptLineClient->hdMSPLine)
            );
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "CloseMSPInstance"
        );
}


void
LCompleteCall_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
    pAsyncEventMsg->Param3 = DWORD_CAST(pAsyncRequestInfo->dwParam1,__FILE__,__LINE__);
    pAsyncEventMsg->Param4 = DWORD_CAST(pAsyncRequestInfo->dwParam2,__FILE__,__LINE__);
}


void
WINAPI
LCompleteCall(
    PTCLIENT                    ptClient,
    PLINECOMPLETECALL_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineCompleteCall;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,                   // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINECOMPLETECALL,        // provider func index
            &pfnTSPI_lineCompleteCall,  // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "CompleteCall"              // func name

            )) > 0)
    {
        if (!IsOnlyOneBitSetInDWORD (pParams->dwCompletionMode) ||
            (pParams->dwCompletionMode & ~AllCallComplModes)
            )
        {
            lRequestID = LINEERR_INVALCALLCOMPLMODE;
            goto LCompleteCall_epilog;
        }

        
        pAsyncRequestInfo->pfnPostProcess = LCompleteCall_PostProcess;
        pAsyncRequestInfo->dwParam2       = pParams->hpdwCompletionID;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP5(
            pfnTSPI_lineCompleteCall,
            "lineCompleteCall",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) &pAsyncRequestInfo->dwParam1,
            (DWORD) pParams->dwCompletionMode,
            (DWORD) pParams->dwMessageID
            );
    }

LCompleteCall_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "CompleteCall"
        );
}


void
LCompleteTransfer_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
    PTCALL          ptConfCall = (PTCALL) pAsyncRequestInfo->dwParam1;
    DWORD           hpConfCallHandle = DWORD_CAST(pAsyncRequestInfo->dwParam2,__FILE__,__LINE__);
    PTCALLCLIENT    ptConfCallClient;


    if (WaitForExclusivetCallAccess (ptConfCall, TINCOMPLETECALL_KEY))
    {
        PTCALL      ptCall = (PTCALL) pAsyncRequestInfo->dwParam3,
                    ptCallThen,
                    ptConsultCall = (PTCALL) pAsyncRequestInfo->dwParam4;
        HCALL       hCallThen = (HCALL)pAsyncRequestInfo->dwParam5;

        //
        // Check to make sure this is the call we think it is (that the
        // pointer wasn't freed by a previous call to lineClose/Shutdown
        // and realloc'd for use as a ptCall again)
        //

        if (ptConfCall->hCall != hCallThen)
        {
            UNLOCKTCALL(ptConfCall);
            goto LCompleteTransfer_PostProcess_bad_ptConfCall;
        }

        ptConfCallClient = ptConfCall->ptCallClients;

        if (pAsyncEventMsg->Param2 == 0)  // success
        {
            //
            // Check to see if the app closed the line & left us with
            // 0 call clients (in which case it'll also be taking care of
            // cleaning up this tCall too)
            //

            if (ptConfCall->ptCallClients == NULL)
            {
                UNLOCKTCALL(ptConfCall);

                ptConfCallClient = (PTCALLCLIENT) NULL;

                if (pAsyncEventMsg->Param2 == 0)
                {
                    pAsyncEventMsg->Param2 = LINEERR_INVALLINEHANDLE;
                }

                goto LCompleteTransfer_PostProcess_initMsgParams;
            }


            //
            // Retrieve the various call IDs, then check if call
            // client was destroyed by another thread (due to
            // lineClose/Shutdown) while we were getting the call ID.
            // If so, we'll need to clean up the tCall, since we know
            // the other thread didn't do it because GetCallIDs marks
            // the call as a zombie.
            //

            GetCallIDs (ptConfCall);

            if (ptConfCall->ptCallClients == NULL)
            {
                goto LCompleteTransfer_PostProcess_cleanupCalls;
            }


            //
            // Stuff the various call IDs in the var data section
            // of the ASYNCEVENTMSG.
            //
            // Make sure to increment the dwTotalSize of the ASYNCEVENTMSG
            // as appropriate.  We rely on the fact that CompletionProc()
            // calls us with a AsyncEventMsg buffer which is big enough to
            // handle a few extra DWORDs.
            //

            pAsyncEventMsg->Param3 = ptConfCallClient->hCall;

            pAsyncEventMsg->TotalSize += 3 * sizeof (pAsyncEventMsg->Param4);

            *(&pAsyncEventMsg->Param4 + 1) = ptConfCall->dwAddressID;
            *(&pAsyncEventMsg->Param4 + 2) = ptConfCall->dwCallID;
            *(&pAsyncEventMsg->Param4 + 3) = ptConfCall->dwRelatedCallID;


            //
            // Mark the calls & conf list as valid, the release the mutex.
            //

            ptConfCall->dwKey       = TCALL_KEY;
            ptConfCallClient->dwKey = TCALLCLIENT_KEY;

            ptConfCall->pConfList->dwKey = TCONFLIST_KEY;

            UNLOCKTCALL(ptConfCall);


            //
            // Create monitor tCallClients
            //

            if(ptCallThen = ReferenceObject(ghHandleTable, hCallThen, TCALL_KEY))
            {
                if (ptCallThen == ptConfCall)
                {
                    CreateCallMonitors (ptConfCall, FALSE);
                }

                DereferenceObject(ghHandleTable, hCallThen, 1);
            }
        }
        else    // error
        {

LCompleteTransfer_PostProcess_cleanupCalls:

            //
            // Invalidate the tCall, & if there's still a tCallClient
            // (might have already been destroyed by a lineClose/Shutdown
            // in another thread) invalidate it too. Then unlock the
            // tCall & remove the object(s) from the list(s).
            //

            ptConfCall->dwKey =
                ptConfCall->pConfList->dwKey = INVAL_KEY;

            if (ptConfCall->ptCallClients)
            {
                ptConfCallClient->dwKey = INVAL_KEY;
                ptConfCall->lActiveFastCallClients--;
            }
            else
            {
                ptConfCallClient = NULL;
            }

            UNLOCKTCALL(ptConfCall);

            RemoveCallFromLineList (ptConfCall);

            if (ptConfCallClient)
            {
                DereferenceObject (ghHandleTable, ptConfCallClient->hCall, 1);
                RemoveCallClientFromLineClientList (ptConfCallClient);
            }

            SetCallConfList (ptCall, NULL, FALSE);
            SetCallConfList (ptConsultCall, NULL, FALSE);


            //
            // Make sure all fast call clients cleaned up before free tCall
            //

            while (ptConfCall->lActiveFastCallClients != 0)
            {
                Sleep (5);
            }

            ServerFree  (ptConfCall->pConfList);
            FreetCall  (ptConfCall);
        }
    }
    else
    {
        //
        // If here we can assume that the call was already destroyed
        // and just fail the request
        //

LCompleteTransfer_PostProcess_bad_ptConfCall:

        ptConfCallClient = (PTCALLCLIENT) NULL;

        if (pAsyncEventMsg->Param2 == 0)
        {
            pAsyncEventMsg->Param2 = LINEERR_OPERATIONFAILED;
        }
    }


    //
    // Fill in the params to pass to client (important to remotesp in both
    // the success & fail cases so it can either init or clean up drvCall)
    //

LCompleteTransfer_PostProcess_initMsgParams:

    pAsyncEventMsg->Param4 = hpConfCallHandle;
}


void
WINAPI
LCompleteTransfer(
    PTCLIENT                        ptClient,
    PLINECOMPLETETRANSFER_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex, bDereferenceConsultCall = FALSE;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineCompleteTransfer;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,                   // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINECOMPLETETRANSFER,    // provider func index
            &pfnTSPI_lineCompleteTransfer,  // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "CompleteTransfer"          // func name

            )) > 0)
    {
        PTCALL          ptConfCall = (PTCALL) NULL, ptCall, ptConsultCall;
        HCALL           hConfCall = 0;
        PTCALLCLIENT    ptConfCallClient, ptConsultCallClient;


        //
        // Validate the hConsultCall
        //

        if (!(ptConsultCallClient = ReferenceObject(
                ghHandleTable,
                pParams->hConsultCall,
                TCALLCLIENT_KEY
                )))
        {
            lRequestID = LINEERR_INVALCONSULTCALLHANDLE;
            goto LCompleteTransfer_return;
        }

        bDereferenceConsultCall = TRUE;

        if (ptConsultCallClient->ptClient != ptClient)
        {
            lRequestID = LINEERR_INVALCONSULTCALLHANDLE;
            goto LCompleteTransfer_return;
        }


        //
        // Verify that app has owner privilege for hConsultCall
        //

        if (ptConsultCallClient->dwPrivilege != LINECALLPRIVILEGE_OWNER)
        {
            lRequestID = LINEERR_NOTOWNER;
            goto LCompleteTransfer_return;
        }


        //
        // Safely verify hCall & hConsultCall are not the same call,
        // and that they are on the same tLine
        //

        try
        {
            ptCall        = ptCallClient->ptCall;
            ptConsultCall = ptConsultCallClient->ptCall;

            if ((ptCall == ptConsultCall) ||

                (ptCallClient->ptLineClient->ptLine !=
                    ptConsultCallClient->ptLineClient->ptLine))
            {
                lRequestID = LINEERR_INVALCALLHANDLE;
                goto LCompleteTransfer_return;
            }
        }
        myexcept
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LCompleteTransfer_return;
        }


        if (pParams->dwTransferMode == LINETRANSFERMODE_CONFERENCE)
        {
            LONG                lResult;
            PTCONFERENCELIST    pConfList;


            //
            // Create & init a conf list
            //

            if (!(pConfList = ServerAlloc(
                    sizeof (TCONFERENCELIST) + DEF_NUM_CONF_LIST_ENTRIES *
                        sizeof (PTCALL)
                    )))
            {
                lRequestID = LINEERR_NOMEM;
                goto LCompleteTransfer_return;
            }

            pConfList->dwNumTotalEntries = DEF_NUM_CONF_LIST_ENTRIES + 1;
            pConfList->dwNumUsedEntries = 1;


            //
            // Set the tCall & tConsultCall conf list, then create
            // the tConfCall & tConfCallClient
            //

            if ((lResult = SetCallConfList (ptCall, pConfList, FALSE)) == 0)
            {
                if ((lResult = SetCallConfList(
                        ptConsultCall,
                        pConfList,
                        FALSE

                        )) == 0)
                {
                    if ((lResult = CreatetCallAndClient(
                            ptCallClient->ptLineClient,
                            &ptConfCall,
                            &ptConfCallClient,
                            NULL,
                            &hConfCall,
                            NULL

                            )) == 0)
                    {
                        pAsyncRequestInfo->dwParam5 = (ULONG_PTR)hConfCall;

                        ptConfCall->pConfList = pConfList;

                        pConfList->aptCalls[0] = ptConfCall;

                        pAsyncRequestInfo->htXxx    = (ULONG_PTR) ptConfCallClient->ptLineClient->ptLine->hLine;
                        pAsyncRequestInfo->dwParam1 = (ULONG_PTR) ptConfCall;
                        pAsyncRequestInfo->dwParam2 = (ULONG_PTR) pParams->hpConfCallHandle;
                        pAsyncRequestInfo->dwParam3 = (ULONG_PTR) ptCall;
                        pAsyncRequestInfo->dwParam4 = (ULONG_PTR) ptConsultCall;

                        pAsyncRequestInfo->pfnPostProcess =
                            LCompleteTransfer_PostProcess;

                        goto LCompleteTransfer_callSP;
                    }

                    SetCallConfList (ptConsultCall, NULL, FALSE);
                }

                SetCallConfList (ptCall, NULL, FALSE);
            }


            //
            // If here an error occured
            //

            ServerFree (pConfList);
            lRequestID = lResult;
            goto LCompleteTransfer_return;
        }
        else if (pParams->dwTransferMode != LINETRANSFERMODE_TRANSFER)
        {
            lRequestID = LINEERR_INVALTRANSFERMODE;
            goto LCompleteTransfer_return;
        }

LCompleteTransfer_callSP:

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP6(
            pfnTSPI_lineCompleteTransfer,
            "lineCompleteTransfer",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) ptConsultCallClient->ptCall->hdCall,
            (ULONG_PTR) hConfCall,
            (ULONG_PTR) (ptConfCall ? &ptConfCall->hdCall : 0),
            (DWORD) pParams->dwTransferMode
            );

        if (ptConfCall)
        {
            SetDrvCallFlags(
                hConfCall,
                DCF_SPIRETURNED | (IS_LRESULT_NOTERROR(pParams->lResult) ?
                    DCF_DRVCALLVALID : 0)
                );
        }
    }

LCompleteTransfer_return:

    if (bDereferenceConsultCall)
    {
        DereferenceObject (ghHandleTable, pParams->hConsultCall, 1);
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "CompleteTransfer"
        );
}


void
WINAPI
LConditionalMediaDetection(
    PTCLIENT                                ptClient,
    PLINECONDITIONALMEDIADETECTION_PARAMS   pParams,
    DWORD                                   dwParamsBufferSize,
    LPBYTE                                  pDataBuf,
    LPDWORD                                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineConditionalMediaDetection;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (IsBadStructParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwCallParamsOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINECONDITIONALMEDIADETECTION,        // provider func index
            &pfnTSPI_lineConditionalMediaDetection,  // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "ConditionalMediaDetection"            // func name
            )) == 0)
    {
        DWORD               dwAPIVersion, dwSPIVersion;
        LPLINECALLPARAMS    pCallParams;


        //
        // This func only gets called by RemoteSP.  Since RemoteSP
        // might be down-level, we need to compare API/SPI vers
        // to see if we need to munge call params (and it's good
        // to validate them anyway).
        //

        pCallParams = (LPLINECALLPARAMS)
            (pDataBuf + pParams->dwCallParamsOffset);

        try
        {
            dwAPIVersion = ptLineClient->dwAPIVersion;
            dwSPIVersion = ptLineClient->ptLine-> dwSPIVersion;

            if (ptLineClient->dwKey != TLINECLIENT_KEY)
            {
                pParams->lResult = LINEERR_INVALLINEHANDLE;
                goto LConditionalMediaDetection_epilog;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
            goto LConditionalMediaDetection_epilog;
        }

        if ((pParams->lResult = ValidateCallParams(
                pCallParams,
                &pCallParams,
                dwAPIVersion,
                dwSPIVersion,
                pParams->dwAsciiCallParamsCodePage

                )) == 0)
        {
            pParams->lResult = CallSP3(
                pfnTSPI_lineConditionalMediaDetection,
                "lineConditionalMediaDetection",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->dwMediaModes,
                (ULONG_PTR) pCallParams
                );

            if (pCallParams != (LPLINECALLPARAMS)
                    (pDataBuf + pParams->dwCallParamsOffset))
            {
                ServerFree (pCallParams);
            }
        }
    }

LConditionalMediaDetection_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "ConditionalMediaDetection"
        );
}


void
LCreateAgent_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
    PASYNCEVENTMSG          pNewAsyncEventMsg = (PASYNCEVENTMSG)
                                pAsyncRequestInfo->dwParam3;


    CopyMemory (pNewAsyncEventMsg, pAsyncEventMsg, sizeof (ASYNCEVENTMSG));

    *ppBuf = pNewAsyncEventMsg;

    if (pAsyncEventMsg->Param2 == 0)  // success
    {
        pNewAsyncEventMsg->TotalSize += ((sizeof(HAGENT) + 7) & 0xFFFFFFF8);


        //
        // param1 must not exceed 32 bits. use DWORD_CAST to enforce this at
        // least in runtime.
        //

        pNewAsyncEventMsg->Param3 = DWORD_CAST(pAsyncRequestInfo->dwParam1,__FILE__,__LINE__);
        pNewAsyncEventMsg->Param4 = sizeof(HAGENT);
    }
}


void
WINAPI
LCreateAgent(
    PTCLIENT                    ptClient,
    PLINECREATEAGENT_PARAMS     pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (((pParams->dwAgentIDOffset != TAPI_NO_DATA)  &&

            IsBadStringParam(
                dwParamsBufferSize,
                pDataBuf,
                pParams->dwAgentIDOffset
                ))  ||

        ((pParams->dwAgentPINOffset != TAPI_NO_DATA)  &&

            IsBadStringParam(
                dwParamsBufferSize,
                pDataBuf,
                pParams->dwAgentPINOffset
                )))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "CreateAgent"               // func name

            )) > 0)

    {
        LONG            lResult;
        DWORD           dwDeviceID;
        PTLINECLIENT    pProxy;


        if ((lResult = FindProxy(
                ptLineClient,
                0,
                LINEPROXYREQUEST_CREATEAGENT,
                &pProxy,
                &dwDeviceID,
                TAPI_VERSION2_2
                )))
        {
            lRequestID = lResult;
            goto LCreateAgent_epilog;
        }


        //
        // Save client's buffer pointer and post processing proc
        //

        pAsyncRequestInfo->dwParam1 = pParams->hpAgent;
        pAsyncRequestInfo->dwParam2 = sizeof(HAGENT);
        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;


        //
        // First check to see if there's a (local) proxy registered
        // for this type of request on this line.  If so, build a
        // request & send it to the proxy.
        //

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;
            DWORD                   dwAgentIDSize = 0;
            DWORD                   dwAgentPINSize = 0;
            DWORD                   dwTotalSize = 0;
            DWORD                   dwOffset = 0;


            //
            // Figure out the total size of info we are passing to the proxy
            //

            if (TAPI_NO_DATA != pParams->dwAgentIDOffset)
            {
                dwAgentIDSize =
                    (lstrlenW ((PWSTR)(pDataBuf + pParams->dwAgentIDOffset))
                        + 1) * sizeof(WCHAR);

                dwTotalSize += dwAgentIDSize;
            }

            if (TAPI_NO_DATA != pParams->dwAgentPINOffset)
            {
                dwAgentPINSize =
                    (lstrlenW ((PWSTR)(pDataBuf + pParams->dwAgentPINOffset))
                        + 1) *  sizeof(WCHAR);

                dwTotalSize += dwAgentPINSize;
            }


            //
            // Fixed part of union part of structure
            //

            dwTotalSize += 4 * sizeof(DWORD) + sizeof(HAGENT);

            if (lResult = CreateProxyRequest(
                   pProxy,
                   LINEPROXYREQUEST_CREATEAGENT,
                   dwTotalSize,
                   pAsyncRequestInfo,
                   &pProxyRequestWrapper
                   ))
            {
                lRequestID = lResult;
                goto LCreateAgent_epilog;
            }


            //
            // Save the info in the proxy request
            //

            //
            // The offset is after the fixed size of the CreateAgent
            // struct which has 4 dwords and an hAgent.
            //
            // This will require no extra alloc on the client side
            // as the thing to be returned is the hAgent
            //

            dwOffset = 4 * sizeof(DWORD) + sizeof(HAGENT);


            //
            // Copy the id if exists
            //

            if (0 != dwAgentIDSize)
            {
                pProxyRequestWrapper->ProxyRequest.CreateAgent.
                    dwAgentIDSize = dwAgentIDSize;

                pProxyRequestWrapper->ProxyRequest.CreateAgent.
                    dwAgentIDOffset = dwOffset;

                wcscpy(
                    (PWSTR)((LPBYTE)(&(pProxyRequestWrapper->
                        ProxyRequest.CreateAgent)) + dwOffset),
                    (PWSTR)(pDataBuf + pParams->dwAgentIDOffset)
                    );

                dwOffset += dwAgentIDSize;
            }


            //
            // Copy the pin if exists
            //

            if (0 != dwAgentPINSize)
            {
                pProxyRequestWrapper->ProxyRequest.CreateAgent.
                    dwAgentPINSize = dwAgentPINSize;

                pProxyRequestWrapper->ProxyRequest.CreateAgent.
                    dwAgentPINOffset = dwOffset;

                wcscpy(
                    (PWSTR)((LPBYTE)(&(pProxyRequestWrapper->
                        ProxyRequest.CreateAgent)) + dwOffset),
                    (PWSTR)(pDataBuf + pParams->dwAgentPINOffset)
                    );
            }

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LCreateAgent_epilog;
            }
            else // success
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }

        }

        //
        // There's no proxy, so check to see if line is remote and
        // call remotesp if so
        //

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            LPBYTE  pBuf;

            pBuf = ServerAlloc (sizeof (ASYNCEVENTMSG) + sizeof (HAGENT));

            if (!pBuf)
            {
                lRequestID = LINEERR_NOMEM;
                goto LCreateAgent_epilog;
            }

            pAsyncRequestInfo->pfnPostProcess =
                LCreateAgent_PostProcess;
            pAsyncRequestInfo->dwParam3 = (ULONG_PTR) pBuf;

            pParams->lResult = CallSP5(
                pRemoteSP->apfn[SP_LINECREATEAGENT],
                "CreateAgent",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (ULONG_PTR) ((pParams->dwAgentIDOffset) == TAPI_NO_DATA ?
                    NULL : (pDataBuf + pParams->dwAgentIDOffset)),
                (ULONG_PTR) ((pParams->dwAgentPINOffset) == TAPI_NO_DATA ?
                    NULL : (pDataBuf + pParams->dwAgentPINOffset)),
                (ULONG_PTR) (pBuf + sizeof (ASYNCEVENTMSG))
                );
        }


        //
        // No proxy and not remote
        //

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LCreateAgent_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "CreateAgent"
        );
}


void
WINAPI
LCreateAgentSession(
    PTCLIENT                        ptClient,
    PLINECREATEAGENTSESSION_PARAMS  pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (((pParams->dwAgentPINOffset != TAPI_NO_DATA)  &&

            IsBadStringParam(
                dwParamsBufferSize,
                pDataBuf,
                pParams->dwAgentPINOffset
                ))  ||

        ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwGroupIDSize,
            pParams->dwGroupIDOffset,
            sizeof(DWORD),
            "LCreateAgentSession",
            "pParams->GroupID"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "CreateAgentSession"        // func name

            )) > 0)

    {
        LONG            lResult;
        DWORD           dwDeviceID;
        PTLINECLIENT    pProxy;


        if ((lResult = FindProxy(
                ptLineClient,
                pParams->dwWorkingAddressID,
                LINEPROXYREQUEST_CREATEAGENTSESSION,
                &pProxy,
                &dwDeviceID,
                TAPI_VERSION2_2
                )))
        {
            lRequestID = lResult;
            goto LCreateAgentSession_epilog;
        }


        //
        // save client's buffer pointer and
        // post processing proc
        //

        pAsyncRequestInfo->dwParam1 = pParams->hpAgentSessionHandle;
        pAsyncRequestInfo->dwParam2 = sizeof(HAGENTSESSION);
        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;


        //
        // First check to see if there's a (local) proxy registered
        // for this type of request on this line.  If so, build a
        // request & send it to the proxy.
        //

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;
            DWORD                   dwAgentPINSize = 0;
            DWORD                   dwTotalSize = 0;
            DWORD                   dwOffset = 0;


            //
            // figure out the total size of information
            // we are passing to the proxy
            //

            if (TAPI_NO_DATA != pParams->dwAgentPINOffset)
            {
                dwAgentPINSize =
                    (lstrlenW( (PWSTR)(pDataBuf + pParams->dwAgentPINOffset))
                        + 1 ) * sizeof(WCHAR);
            }


            //
            // Add the union part of the CreateAgentSession request
            // which looks like:
            //
            // struct
            // {
            //    HAGENTSESSION           hAgentSession;
            //    DWORD                   dwAgentPINSize;
            //    DWORD                   dwAgentPINOffset;
            //    HAGENT                  hAgent;
            //    GUID                    GroupID;
            //    DWORD                   dwWorkingAddressID;
            //
            // } CreateAgentSession;
            //

            dwOffset = ( 3 * sizeof(DWORD) ) + sizeof(GUID) +
                           sizeof(HAGENTSESSION) + sizeof(HAGENT);

            dwTotalSize = dwOffset + dwAgentPINSize;


            if (lResult = CreateProxyRequest(
                   pProxy,
                   LINEPROXYREQUEST_CREATEAGENTSESSION,
                   dwTotalSize,
                   pAsyncRequestInfo,
                   &pProxyRequestWrapper
                   ))
            {
                lRequestID = lResult;
                goto LCreateAgentSession_epilog;
            }


            //
            // Save the info in the proxy request - copy the pin if exists
            //

            if ( 0 != dwAgentPINSize )
            {
                pProxyRequestWrapper->ProxyRequest.CreateAgentSession.
                         dwAgentPINSize = dwAgentPINSize;

                pProxyRequestWrapper->ProxyRequest.CreateAgentSession.
                        dwAgentPINOffset = dwOffset;

                wcscpy(
                    (PWSTR)((LPBYTE)(&(pProxyRequestWrapper->
                        ProxyRequest.CreateAgentSession)) + dwOffset),
                    (PWSTR)(pDataBuf + pParams->dwAgentPINOffset)
                    );
            }

            CopyMemory(
                &(pProxyRequestWrapper->
                    ProxyRequest.CreateAgentSession.GroupID),
                pDataBuf + pParams->dwGroupIDOffset,
                sizeof( GUID )
                );

            pProxyRequestWrapper->ProxyRequest.CreateAgentSession.
                dwWorkingAddressID = pParams->dwWorkingAddressID;

            pProxyRequestWrapper->ProxyRequest.CreateAgentSession.
                hAgent = pParams->hAgent;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LCreateAgentSession_epilog;
            }
            else // success
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


        //
        // There's no proxy, so check to see if line is remote and
        // call remotesp if so
        //

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            LPBYTE  pBuf;


            pBuf = ServerAlloc(sizeof(ASYNCEVENTMSG) + sizeof (HAGENTSESSION));

            if ( NULL == pBuf )
            {
                lRequestID = LINEERR_NOMEM;
                goto LCreateAgentSession_epilog;
            }

            pAsyncRequestInfo->pfnPostProcess =
                LCreateAgent_PostProcess;
            pAsyncRequestInfo->dwParam3 = (ULONG_PTR) pBuf;

            pParams->lResult = CallSP7(
                pRemoteSP->apfn[SP_LINECREATEAGENTSESSION],
                "CreateAgentSession",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->hAgent,
                (ULONG_PTR) ((pParams->dwAgentPINOffset) == TAPI_NO_DATA ?
                    NULL : (pDataBuf + pParams->dwAgentPINOffset)),
                (DWORD) pParams->dwWorkingAddressID,
                (ULONG_PTR) (pDataBuf + pParams->dwGroupIDOffset),
                (ULONG_PTR) (pBuf + sizeof (ASYNCEVENTMSG))
                );
        }


        //
        // no proxy and not remote
        //

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LCreateAgentSession_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "CreateAgentSession"
        );
}

void
WINAPI
LCreateMSPInstance(
    PTCLIENT                        ptClient,
    PLINECREATEMSPINSTANCE_PARAMS   pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineCreateMSPInstance;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINECREATEMSPINSTANCE,   // provider func index
            &pfnTSPI_lineCreateMSPInstance,  // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,
            &ptLineClient,
            "CreateMSPInstance"         // func name

            )) == 0)
    {
        pParams->lResult = CallSP4(
            pfnTSPI_lineCreateMSPInstance,
            "lineCreateMSPInstance",
            SP_FUNC_SYNC,
            (ULONG_PTR) hdLine,
            (DWORD) pParams->dwAddressID,
            (DWORD) ptLineClient->hLine,
            (ULONG_PTR) &ptLineClient->hdMSPLine
            );

        if ( 0 == pParams->lResult )
        {
            *pdwNumBytesReturned = sizeof( LINECREATEMSPINSTANCE_PARAMS );
        }
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "CreateMSPInstance"
        );
}


void
WINAPI
LDeallocateCall(
    PTCLIENT                    ptClient,
    PLINEDEALLOCATECALL_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_MONITOR,  // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            NULL,                       // async request info
            0,                           // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "DeallocateCall"            // func name

            )) == 0)
    {
        //
        // Per nt bug #20546 we're now allowing the last owner to dealloc
        // a non-IDLE call.  Decided to do this based on distributed call
        // ownership issues.  dankn 02/13/96
        //

        DestroytCallClient (ptCallClient);
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "DeallocateCall"
        );
}


void
LDevSpecific_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
    PASYNCEVENTMSG  pNewAsyncEventMsg = (PASYNCEVENTMSG)
                        pAsyncRequestInfo->dwParam3;


    CopyMemory (pNewAsyncEventMsg, pAsyncEventMsg, sizeof (ASYNCEVENTMSG));

    *ppBuf = pNewAsyncEventMsg;

    if (pAsyncEventMsg->Param2 == 0)  // success
    {
        //
        // Make sure to keep the total size 64-bit aligned
        //

        pNewAsyncEventMsg->TotalSize +=
            (DWORD_CAST(pAsyncRequestInfo->dwParam2,__FILE__,__LINE__) + 7) & 0xfffffff8;

        //
        // need to be at most 32-bit. use dword_cast to ensure this in 
        // runtime
        //

        pNewAsyncEventMsg->Param3 = DWORD_CAST(pAsyncRequestInfo->dwParam1,__FILE__,__LINE__); // lpParams
        pNewAsyncEventMsg->Param4 = DWORD_CAST(pAsyncRequestInfo->dwParam2,__FILE__,__LINE__); // dwSize
    }
}


void
WINAPI
LDevSpecific(
    PTCLIENT                ptClient,
    PLINEDEVSPECIFIC_PARAMS pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex, bDereferenceLineClient = FALSE;
    LONG                lRequestID;
    DWORD               dwWidgetType, hWidget;
    DWORD               dwPrivilege = LINECALLPRIVILEGE_MONITOR;
    HANDLE              hMutex;
    TSPIPROC            pfnTSPI_lineDevSpecific;
    DWORD               objectToDereference;
    ULONG_PTR           hdWidget;
    PTCALLCLIENT        ptXxxClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwParamsSize,
            pParams->dwParamsOffset,
            sizeof(DWORD),
            "LDevSpecific",
            "pParams->Params"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if (pParams->hCall)
    {
        dwWidgetType = ANY_RT_HCALL;
        hWidget = (DWORD) pParams->hCall;
    }
    else
    {
        dwWidgetType = ANY_RT_HLINE;
        hWidget = (DWORD) pParams->hLine;
    }

    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            dwWidgetType,               // widget type
            hWidget,                    // client widget handle
            (LPVOID) &hdWidget,         // provider widget handle
            (pParams->hCall ? (dwPrivilege) : 0),
                                        // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEDEVSPECIFIC,         // provider func index
            &pfnTSPI_lineDevSpecific,   // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptXxxClient,               // context
            "DevSpecific"               // func name

            )) > 0)
    {
        LPBYTE      pBuf;
        HDRVCALL    hdCall;
        HDRVLINE    hdLine;


        //
        // If an hCall was specified verify the hLine &
        // make sure the call is on the specified hLine
        //

        if (dwWidgetType == ANY_RT_HCALL)
        {
            LONG            lResult;
            PTLINECLIENT    ptLineClient;


            if (!(ptLineClient = ReferenceObject(
                    ghHandleTable,
                    pParams->hLine,
                    TLINECLIENT_KEY
                    )))
            {
                lRequestID = LINEERR_INVALLINEHANDLE;
                goto LDevSpecific_epilog;
            }

            bDereferenceLineClient = TRUE;

            if (ptLineClient->ptClient != ptClient)
            {
                lRequestID = LINEERR_INVALLINEHANDLE;
                goto LDevSpecific_epilog;
            }

            try
            {
                lResult = LINEERR_INVALLINEHANDLE;

                hdLine = ptLineClient->ptLine->hdLine;

                lResult = LINEERR_INVALCALLHANDLE;

                if (ptLineClient != ptXxxClient->ptLineClient)
                {
                    LOG((TL_ERROR,
                        "LDevSpecific: error, hCall=x%x not related " \
                            "to hLine=x%x",
                        pParams->hCall,
                        pParams->hLine
                        ));

                    lRequestID = LINEERR_INVALCALLHANDLE;
                    goto LDevSpecific_epilog;
                }
            }
            myexcept
            {
                lRequestID = lResult;
                goto LDevSpecific_epilog;
            }

            hdCall = (HDRVCALL) hdWidget;
        }
        else
        {
            hdLine = (HDRVLINE) hdWidget;
            hdCall = 0;
        }


        //
        // Alloc a shadow buf that the SP can use until it completes this
        // request.  Make sure there's enough extra space in the buf for
        // an ASYNCEVENTMSG header so we don't have to alloc yet another
        // buf in the post processing proc when preparing the completion
        // msg to send to the client, and that the msg is 64-bit aligned.
        //

        if (!(pBuf = ServerAlloc(
                ((pParams->dwParamsSize + 7) & 0xfffffff8) +
                    sizeof (ASYNCEVENTMSG)
                )))
        {
            lRequestID = LINEERR_NOMEM;
            goto LDevSpecific_epilog;
        }

        CopyMemory(
            pBuf + sizeof (ASYNCEVENTMSG),
            pDataBuf + pParams->dwParamsOffset,
            pParams->dwParamsSize
            );

        pAsyncRequestInfo->pfnPostProcess = LDevSpecific_PostProcess;
        pAsyncRequestInfo->dwParam1       = pParams->hpParams;
        pAsyncRequestInfo->dwParam2       = pParams->dwParamsSize;
        pAsyncRequestInfo->dwParam3       = (ULONG_PTR) pBuf;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP6(
            pfnTSPI_lineDevSpecific,
            "lineDevSpecific",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdLine,
            (DWORD) pParams->dwAddressID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) (pParams->dwParamsSize ?
                pBuf + sizeof (ASYNCEVENTMSG) : NULL),
            (DWORD) pParams->dwParamsSize
            );
    }

LDevSpecific_epilog:

    if (bDereferenceLineClient)
    {
        DereferenceObject (ghHandleTable, pParams->hLine, 1);
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "DevSpecific"
        );
}


void
WINAPI
LDevSpecificEx(
    PTCLIENT                    ptClient,
    PLINEDEVSPECIFICEX_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    DWORD               dwWidgetType, hWidget;
    DWORD               dwPrivilege = LINECALLPRIVILEGE_MONITOR;
    DWORD               dwCallHubID = 0;
    HANDLE              hMutex;
    LPVOID              context;
    TSPIPROC            pfnTSPI_lineDevSpecificEx;
    DWORD               objectToDereference;
    ULONG_PTR           hdWidget;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwParamsSize,
            pParams->dwParamsOffset,
            sizeof(DWORD),
            "LDevSpecificEx",
            "pParams->Params"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    switch (pParams->dwSelect)
    {
    case LINECALLSELECT_DEVICEID:
    case LINECALLSELECT_ADDRESS:

        dwWidgetType = DEVICE_ID;
        hWidget = pParams->dwDeviceID;
        break;

    case LINECALLSELECT_CALLID:
    {
        PTCALLHUBCLIENT     ptCallHubClient;

        if (ptCallHubClient = IsValidCallHub(
                pParams->hCallHub,
                ptClient
                ))
        {
            try
            {
                dwCallHubID = ptCallHubClient->dwCallHubID;

                if (ptCallHubClient->dwKey != TCALLHUBCLIENT_KEY)
                {
                    pParams->lResult = LINEERR_INVALCALLHANDLE;
                    return;
                }
            }
            myexcept
            {
                pParams->lResult = LINEERR_INVALCALLSELECT;
                return;
            }
        }
    }
    // fall through
    case LINECALLSELECT_CALL:

        dwWidgetType = ANY_RT_HCALL;
        hWidget = (DWORD) pParams->hCall;
        break;

    case LINECALLSELECT_LINE:
    default:

        pParams->lResult = LINEERR_INVALCALLSELECT;
        return;
    }

    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            dwWidgetType,               // widget type
            hWidget,                    // client widget handle
            (LPVOID) &hdWidget,         // provider widget handle
            (pParams->hCall ? (dwPrivilege) : 0),
                                        // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEDEVSPECIFICEX,       // provider func index
            &pfnTSPI_lineDevSpecificEx, // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &context,                   // context
            "DevSpecificEx"             // func name

            )) > 0)

    {
        DWORD       dwDeviceID = 0;
        LPBYTE      pBuf;
        HDRVCALL    hdCall = 0;


        switch (pParams->dwSelect)
        {
        case LINECALLSELECT_DEVICEID:
        case LINECALLSELECT_ADDRESS:

            dwDeviceID = (DWORD) hdWidget;
            break;

        case LINECALLSELECT_CALLID:
        case LINECALLSELECT_CALL:

            hdCall = (HDRVCALL) hdWidget;
            break;

        default:

            lRequestID = LINEERR_INVALCALLSELECT;
            goto LDevSpecificEx_epilog;
        }

        //
        // Alloc a shadow buf that the SP can use until it completes this
        // request.  Make sure there's enough extra space in the buf for
        // an ASYNCEVENTMSG header so we don't have to alloc yet another
        // buf in the post processing proc when preparing the completion
        // msg to send to the client, and that the msg is 64-bit aligned.
        //

        if (!(pBuf = ServerAlloc(
                ((pParams->dwParamsSize + 7) & 0xfffffff8) +
                    sizeof (ASYNCEVENTMSG)
                )))
        {
            lRequestID = LINEERR_NOMEM;
            goto LDevSpecificEx_epilog;
        }

        CopyMemory(
            pBuf + sizeof (ASYNCEVENTMSG),
            pDataBuf + pParams->dwParamsOffset,
            pParams->dwParamsSize
            );

        pAsyncRequestInfo->pfnPostProcess = LDevSpecific_PostProcess;
        pAsyncRequestInfo->dwParam1       = pParams->hpParams;
        pAsyncRequestInfo->dwParam2       = pParams->dwParamsSize;
        pAsyncRequestInfo->dwParam3       = (ULONG_PTR) pBuf;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP8(
            pfnTSPI_lineDevSpecificEx,
            "lineDevSpecificEx",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (DWORD) dwDeviceID,
            (DWORD) pParams->dwAddressID,
            (ULONG_PTR) hdCall,
            (DWORD) dwCallHubID,
            (DWORD) pParams->dwSelect,
            (ULONG_PTR) (pParams->dwParamsSize ?
                pBuf + sizeof (ASYNCEVENTMSG) : NULL),
            (DWORD) pParams->dwParamsSize
            );
    }

LDevSpecificEx_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "DevSpecific"
        );
}


void
WINAPI
LDevSpecificFeature(
    PTCLIENT                        ptClient,
    PLINEDEVSPECIFICFEATURE_PARAMS  pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineDevSpecificFeature;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwParamsSize,
            pParams->dwParamsOffset,
            sizeof(DWORD),
            "LDevSpecificFeature",
            "pParams->Params"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEDEVSPECIFICFEATURE,  // provider func index
            &pfnTSPI_lineDevSpecificFeature,// provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "DevSpecificFeature"        // func name

            )) > 0)
    {
        LPBYTE pBuf;


        if (pParams->dwFeature > PHONEBUTTONFUNCTION_NONE  &&
            (pParams->dwFeature & 0x80000000) == 0)
        {
            lRequestID = LINEERR_INVALFEATURE;
            goto LDevSpecificFeature_epilog;
        }


        //
        // Alloc a shadow buf that the SP can use until it completes this
        // request.  Make sure there's enough extra space in the buf for
        // an ASYNCEVENTMSG header so we don't have to alloc yet another
        // buf in the post processing proc when preparing the completion
        // msg to send to the client, and that the msg is 64-bit aligned.
        //

        if (!(pBuf = ServerAlloc(
                ((pParams->dwParamsSize + 7) & 0xfffffff8) +
                    sizeof (ASYNCEVENTMSG)
                )))
        {
            lRequestID = LINEERR_NOMEM;
            goto LDevSpecificFeature_epilog;
        }

        CopyMemory(
            pBuf + sizeof (ASYNCEVENTMSG),
            pDataBuf + pParams->dwParamsOffset,
            pParams->dwParamsSize
            );

        pAsyncRequestInfo->pfnPostProcess = LDevSpecific_PostProcess;
        pAsyncRequestInfo->dwParam1       = pParams->hpParams;
        pAsyncRequestInfo->dwParam2       = pParams->dwParamsSize;
        pAsyncRequestInfo->dwParam3       = (ULONG_PTR) pBuf;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP5(
            pfnTSPI_lineDevSpecificFeature,
            "lineDevSpecificFeature",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdLine,
            (DWORD) pParams->dwFeature,
            (ULONG_PTR) (pParams->dwParamsSize ?
                pBuf + sizeof (ASYNCEVENTMSG) : NULL),
            (DWORD) pParams->dwParamsSize
            );
    }

LDevSpecificFeature_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "DevSpecificFeature"
        );
}


void
WINAPI
LDial(
    PTCLIENT            ptClient,
    PLINEDIAL_PARAMS    pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineDial;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDestAddressOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEDIAL,                // provider func index
            &pfnTSPI_lineDial,          // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "Dial"                      // func name

            )) > 0)
    {
        pParams->lResult = CallSP4(
            pfnTSPI_lineDial,
            "lineDial",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) (pDataBuf + pParams->dwDestAddressOffset),
            (DWORD) pParams->dwCountryCode
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Dial"
        );
}


void
WINAPI
LDrop(
    PTCLIENT            ptClient,
    PLINEDROP_PARAMS    pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineDrop;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if ((pParams->dwUserUserInfoOffset != TAPI_NO_DATA)  &&

        ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwSize,
            pParams->dwUserUserInfoOffset,
            sizeof(DWORD),
            "LDrop",
            "pParams->UserUserInfo"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEDROP,                // provider func index
            &pfnTSPI_lineDrop,          // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "Drop"                      // func name

            )) > 0)
    {
        pParams->lResult = CallSP4(
            pfnTSPI_lineDrop,
            "lineDrop",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) (pParams->dwUserUserInfoOffset == TAPI_NO_DATA ? NULL :
                pDataBuf + pParams->dwUserUserInfoOffset),
            (DWORD) (pParams->dwUserUserInfoOffset == TAPI_NO_DATA ? 0 :
                pParams->dwSize)
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Drop"
        );
}

LPBYTE 
NewToOldLineforwardlist( 
    LPLINEFORWARDLIST pFwdList3_1 
    );

LPLINEFORWARDLIST
OldToNewLineforwardlist( 
    LPLINEFORWARDLIST pFwdList3_0 
    );

void
WINAPI
LForward(
    PTCLIENT            ptClient,
    PLINEFORWARD_PARAMS pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineForward;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;
    DWORD               dwSizeofLFwdList = sizeof (LINEFORWARDLIST);
    DWORD               dwSizeofLFwd = sizeof (LINEFORWARD);


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEFORWARD,             // provider func index
            &pfnTSPI_lineForward,       // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "Forward"                   // func name

            )) > 0)
    {
        LONG                lResult;
        DWORD               dwAPIVersion, dwSPIVersion;
        PTCALL              ptConsultCall;
        HCALL               hConsultCall = 0;
        PTCALLCLIENT        ptConsultCallClient;
        LPLINECALLPARAMS    pCallParamsApp, pCallParamsSP;
        LPLINEFORWARDLIST   pFwdList = (LPLINEFORWARDLIST)
                                (pParams->dwForwardListOffset == TAPI_NO_DATA ?
                                NULL :pDataBuf + pParams->dwForwardListOffset),
                            pTmpFwdList = NULL,
                            pTmpFwdList1 = NULL;


        //
        // Verify size/offset/string params given our input buffer/size
        //

        if (((pParams->dwForwardListOffset != TAPI_NO_DATA)  &&

                IsBadStructParam(
                    dwParamsBufferSize,
                    pDataBuf,
                    pParams->dwForwardListOffset
                    ))  ||

            ((pParams->dwCallParamsOffset != TAPI_NO_DATA)  &&

                IsBadStructParam(
                    dwParamsBufferSize,
                    pDataBuf,
                    pParams->dwCallParamsOffset
                    )))
        {
            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LForward_epilog;
        }


        //
        // Validate the params
        //

        if (GetLineVersions (ptLineClient, &dwAPIVersion, &dwSPIVersion) != 0)
        {
            lRequestID = LINEERR_INVALLINEHANDLE;
            goto LForward_epilog;
        }

        //
        // Check if the client app. is < 3.1 ===> uses old LINEFORWARD structure
        //
        if ( ptLineClient->ptLineApp->dwAPIVersion < TAPI_VERSION3_1 )
        {
            dwSizeofLFwdList -= 2 * sizeof (DWORD);
            dwSizeofLFwd -= 2 * sizeof (DWORD);
        }

        if (pFwdList)
        {
            DWORD           dwTotalSize  = pFwdList->dwTotalSize, dwFixedSize,
                            dwNumEntries, i, dwInvalidForwardModes;
            LPLINEFORWARD   pFwdEntry = pFwdList->ForwardList;


            if (dwTotalSize < dwSizeofLFwdList)
            {
                lRequestID = LINEERR_STRUCTURETOOSMALL;
                goto LForward_epilog;
            }


            //
            // Note: dwNumEntries == 0 is the same as pFwdList == NULL
            //

            dwNumEntries = pFwdList->dwNumEntries;

            if (dwNumEntries & 0xffff0000)
            {
                lRequestID = LINEERR_INVALPARAM;
                goto LForward_epilog;
            }

            dwFixedSize = dwSizeofLFwdList + dwSizeofLFwd *
                (dwNumEntries == 0 ? 0 : dwNumEntries - 1);

            if (dwFixedSize > dwTotalSize)
            {
                lRequestID = LINEERR_INVALPARAM;
                goto LForward_epilog;
            }

            dwInvalidForwardModes = (dwAPIVersion < TAPI_VERSION1_4 ?
                ~AllForwardModes1_0 : ~AllForwardModes1_4);

            for (i = 0; i < dwNumEntries; i++)
            {
                if (!IsOnlyOneBitSetInDWORD (pFwdEntry->dwForwardMode) ||
                    pFwdEntry->dwForwardMode & dwInvalidForwardModes)
                {
                    LOG((TL_ERROR,
                        "LFoward: bad dwForwardMode, x%x",
                        pFwdEntry->dwForwardMode
                        ));

                    lRequestID = LINEERR_INVALPARAM;
                    goto LForward_epilog;
                }

                if (ISBADSIZEOFFSET(
                        dwTotalSize,
                        dwFixedSize,
                        pFwdEntry->dwCallerAddressSize,
                        pFwdEntry->dwCallerAddressOffset,
                        0,
                        "LFoward",
                        "CallerAddress"
                        ) ||

                    ISBADSIZEOFFSET(
                        dwTotalSize,
                        dwFixedSize,
                        pFwdEntry->dwDestAddressSize,
                        pFwdEntry->dwDestAddressOffset,
                        0,
                        "LFoward",
                        "CallerAddress"
                        ))
                {
                    lRequestID = LINEERR_INVALPARAM;
                    goto LForward_epilog;
                }

                // don't bother validating country code right now

                pFwdEntry = (LPLINEFORWARD) ((LPBYTE)pFwdEntry + dwSizeofLFwd);
            }


            //
            // See if we need to convert an ascii fwd list to unicode
            //

            if (pParams->dwAsciiCallParamsCodePage != 0xffffffff  &&
                dwNumEntries != 0)
            {
                DWORD dwXxxOffset;


                //
                // Alloc a temporary buffer for storing the converted
                // data (sizeof(WCHAR) * dwTotalSize to insure buffer
                // is large enough for all ascii->unicode conversions)
                //

                if (!(pTmpFwdList = ServerAlloc (sizeof(WCHAR) * dwTotalSize)))
                {
                    lRequestID = LINEERR_NOMEM;
                    goto LForward_epilog;
                }

                dwXxxOffset = dwSizeofLFwdList +
                    (dwNumEntries - 1) * dwSizeofLFwd;

                pFwdEntry = pTmpFwdList->ForwardList;

                CopyMemory (pTmpFwdList, pFwdList, dwXxxOffset);

                pTmpFwdList->dwTotalSize *= sizeof (WCHAR);

                for (i = 0; i < dwNumEntries; i++)
                {
                    if (pFwdEntry->dwCallerAddressSize)
                    {
                        MultiByteToWideChar(
                            pParams->dwAsciiCallParamsCodePage,
                            MB_PRECOMPOSED,
                            (LPCSTR) (((LPBYTE) pFwdList) +
                                pFwdEntry->dwCallerAddressOffset),
                            pFwdEntry->dwCallerAddressSize,
                            (LPWSTR) (((LPBYTE) pTmpFwdList) + dwXxxOffset),
                            pFwdEntry->dwCallerAddressSize
                            );

                        pFwdEntry->dwCallerAddressOffset = dwXxxOffset;
                        dwXxxOffset += (pFwdEntry->dwCallerAddressSize *=
                            sizeof (WCHAR));
                    }

                    if (pFwdEntry->dwDestAddressSize)
                    {
                        MultiByteToWideChar(
                            pParams->dwAsciiCallParamsCodePage,
                            MB_PRECOMPOSED,
                            (LPCSTR) (((LPBYTE) pFwdList) +
                                pFwdEntry->dwDestAddressOffset),
                            pFwdEntry->dwDestAddressSize,
                            (LPWSTR) (((LPBYTE) pTmpFwdList) + dwXxxOffset),
                            pFwdEntry->dwDestAddressSize
                            );

                        pFwdEntry->dwDestAddressOffset = dwXxxOffset;
                        dwXxxOffset += (pFwdEntry->dwDestAddressSize *=
                            sizeof (WCHAR));
                    }

                    pFwdEntry = (LPLINEFORWARD) ((LPBYTE)pFwdEntry + dwSizeofLFwd);
                
                }

                pFwdList = pTmpFwdList;
            }
        }

        //
        // Check if we need LINEFORWARDLIST conversion new to old
        //    if the TSP is < 3.1 ===> expects old LINEFORWARDLIST structure
        //    and the App is >= 3.1 ===> sent over new LINEFORWARDLIST structure
        //
        if ( pFwdList && 
             dwSPIVersion < TAPI_VERSION3_1 &&
             ptLineClient->ptLineApp->dwAPIVersion >= TAPI_VERSION3_1 )
        {
            if (!(pTmpFwdList1 = ( LPLINEFORWARDLIST ) NewToOldLineforwardlist (pFwdList)))
            {
                lRequestID = LINEERR_NOMEM;
                goto LForward_freeFwdList;
            }
            pFwdList = pTmpFwdList1;
        }

        //
        // Check if we need LINEFORWARDLIST conversion old to new
        //    if the TSP is >= 3.1 ===> expects new LINEFORWARDLIST structure
        //    and the App is < 3.1 ===> sent over old LINEFORWARDLIST structure
        //
        if ( pFwdList && 
             dwSPIVersion >= TAPI_VERSION3_1 &&
             ptLineClient->ptLineApp->dwAPIVersion < TAPI_VERSION3_1 )
        {
            if (!(pTmpFwdList1 = OldToNewLineforwardlist (pFwdList)))
            {
                lRequestID = LINEERR_NOMEM;
                goto LForward_freeFwdList;
            }
            pFwdList = pTmpFwdList1;
        }

        pCallParamsApp = (LPLINECALLPARAMS)
            (pParams->dwCallParamsOffset == TAPI_NO_DATA ? NULL :
            pDataBuf + pParams->dwCallParamsOffset);

        if (pCallParamsApp)
        {
            if ((lResult = ValidateCallParams(
                    pCallParamsApp,
                    &pCallParamsSP,
                    dwAPIVersion,
                    dwSPIVersion,
                    pParams->dwAsciiCallParamsCodePage

                    )) != 0)
            {
                lRequestID = lResult;
                goto LForward_freeFwdList1;
            }
        }
        else
        {
            pCallParamsSP = (LPLINECALLPARAMS) NULL;
        }

        if (CreatetCallAndClient(
                ptLineClient,
                &ptConsultCall,
                &ptConsultCallClient,
                pCallParamsSP,
                &hConsultCall,
                NULL

                ) != 0)
        {
            lRequestID = LINEERR_NOMEM;
            goto LForward_freeCallParams;
        }

        //htConsultCall = ptConsultCall->htCall;

        pAsyncRequestInfo->pfnPostProcess = LMakeCall_PostProcess;
        pAsyncRequestInfo->htXxx    = (ULONG_PTR)ptConsultCallClient->ptLineClient->ptLine->hLine;
        pAsyncRequestInfo->dwParam1 = (ULONG_PTR) ptConsultCall;
        pAsyncRequestInfo->dwParam2 = pParams->hpConsultCall;
        pAsyncRequestInfo->dwParam3 = 1; // special case for post-process proc
        pAsyncRequestInfo->dwParam5 = (ULONG_PTR)hConsultCall;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP9(
            pfnTSPI_lineForward,
            "lineForward",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdLine,
            (DWORD) pParams->bAllAddresses,
            (DWORD) pParams->dwAddressID,
            (ULONG_PTR) pFwdList,
            (DWORD) pParams->dwNumRingsNoAnswer,
            (ULONG_PTR) hConsultCall,
            (ULONG_PTR) &ptConsultCall->hdCall,
            (ULONG_PTR) pCallParamsSP
            );

        SetDrvCallFlags(
            hConsultCall,
            DCF_SPIRETURNED | (IS_LRESULT_NOTERROR(pParams->lResult) ?
                DCF_DRVCALLVALID : 0)
            );

LForward_freeCallParams:

        if (pCallParamsSP != pCallParamsApp)
        {
            ServerFree (pCallParamsSP);
        }

LForward_freeFwdList1:

        if (pTmpFwdList1)
        {
            ServerFree (pTmpFwdList1);
        }

LForward_freeFwdList:

        if (pTmpFwdList)
        {
            ServerFree (pTmpFwdList);
        }
    }

LForward_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Forward"
        );
}


void
WINAPI
LGatherDigits(
    PTCLIENT                    ptClient,
    PLINEGATHERDIGITS_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVCALL        hdCall;
    TSPIPROC        pfnTSPI_lineGatherDigits;
    DWORD               objectToDereference;
    PTCALLCLIENT    ptCallClient;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if ((pParams->dwTerminationDigitsOffset != TAPI_NO_DATA)  &&

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwTerminationDigitsOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEGATHERDIGITS,        // provider func index
            &pfnTSPI_lineGatherDigits,  // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "GatherDigits"              // func name

            )) == 0)
    {
        DWORD               dwDigitModes = pParams->dwDigitModes;
        LPWSTR              lpsDigits;
        PASYNCREQUESTINFO   pAsyncRequestInfo;


        #define AllGatherDigitsModes (LINEDIGITMODE_PULSE | LINEDIGITMODE_DTMF)

        if (!(dwDigitModes & AllGatherDigitsModes) ||
            (dwDigitModes & ~AllGatherDigitsModes))
        {
            pParams->lResult = LINEERR_INVALDIGITMODE;
            goto LGatherDigits_epilog;
        }

        if (pParams->hpsDigits)
        {
            //
            // The client passed us a non-null digits buffer so we'll
            // alloc an async request info buf with extra space at the
            // end for the temporary digits buf for use by the sp
            // (faster than two two allocs & two frees for separate
            // async request & digits bufs).  Use the pointer as the
            // dwEndToEndID we pass to the sp.
            //

            PTLINECLIENT    ptLineClient;


            if (pParams->dwNumDigits == 0)
            {
                pParams->lResult = LINEERR_INVALPARAM;
                goto LGatherDigits_epilog;
            }

            if (!(pAsyncRequestInfo = ServerAlloc(
                    sizeof (ASYNCREQUESTINFO) +
                        (pParams->dwNumDigits * sizeof (WCHAR))
                    )))
            {
                pParams->lResult = LINEERR_NOMEM;
                goto LGatherDigits_epilog;
            }

            lpsDigits = (LPWSTR) (pAsyncRequestInfo + 1);

            ptLineClient = ptCallClient->ptLineClient;

            pAsyncRequestInfo->dwKey    = TASYNC_KEY;
            pAsyncRequestInfo->ptClient = ptClient;

            try
            {
                pAsyncRequestInfo->InitContext =
                    ptLineClient->ptLineApp->InitContext;
                pAsyncRequestInfo->OpenContext = ptLineClient->OpenContext;
            }
            myexcept
            {
                ServerFree (pAsyncRequestInfo);
                pParams->lResult = LINEERR_INVALCALLHANDLE;
                goto LGatherDigits_epilog;
            }

            pAsyncRequestInfo->dwParam1 = sizeof (ASYNCREQUESTINFO);
            pAsyncRequestInfo->dwParam2 = DWORD_CAST(pParams->hpsDigits,__FILE__,__LINE__);
            pAsyncRequestInfo->dwParam3 = pParams->dwNumDigits;
            pAsyncRequestInfo->dwParam4 = pParams->hCall;
            pAsyncRequestInfo->dwParam5 = (ULONG_PTR)pParams->dwEndToEndID;

            pAsyncRequestInfo->hfnClientPostProcessProc =
                pParams->hfnPostProcessProc;

            pAsyncRequestInfo->dwLocalRequestID = (DWORD) NewObject(
                ghHandleTable,
                pAsyncRequestInfo,
                NULL
                );
        }
        else
        {
            //
            // Client wants to cancel gathering, so just set these two to null
            //

            lpsDigits = NULL;
            pAsyncRequestInfo = NULL;
        }

        if ((pParams->lResult = CallSP8(
                pfnTSPI_lineGatherDigits,
                "lineGatherDigits",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdCall,
                (DWORD) (pAsyncRequestInfo ?
                    pAsyncRequestInfo->dwLocalRequestID : 0),
                (DWORD) dwDigitModes,
                (ULONG_PTR) lpsDigits,
                (DWORD) pParams->dwNumDigits,
                (ULONG_PTR) (pParams->dwTerminationDigitsOffset ==TAPI_NO_DATA?
                    0 : (pDataBuf + pParams->dwTerminationDigitsOffset)),
                (DWORD) pParams->dwFirstDigitTimeout,
                (DWORD) pParams->dwInterDigitTimeout

                )) != 0)
        {
            if (pAsyncRequestInfo)
            {
                DereferenceObject(
                    ghHandleTable,
                    pAsyncRequestInfo->dwLocalRequestID,
                    1
                    );
            }
        }
    }

LGatherDigits_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GatherDigits"
        );
}


void
WINAPI
LGenerateDigits(
    PTCLIENT                    ptClient,
    PLINEGENERATEDIGITS_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVCALL        hdCall;
    TSPIPROC        pfnTSPI_lineGenerateDigits;
    DWORD               objectToDereference;
    PTCALLCLIENT    ptCallClient;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if ((pParams->dwDigitsOffset != TAPI_NO_DATA)  &&

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDigitsOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEGENERATEDIGITS,      // provider func index
            &pfnTSPI_lineGenerateDigits,// provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "GenerateDigits"            // func name

            )) == 0)
    {
        DWORD   dwDigitMode = pParams->dwDigitMode, *pInstData, dwEndToEndID = 0;


        if (dwDigitMode != LINEDIGITMODE_PULSE  &&
            dwDigitMode != LINEDIGITMODE_DTMF)
        {
            pParams->lResult = LINEERR_INVALDIGITMODE;
            goto LGenerateDigits_epilog;
        }

        if (pParams->dwDigitsOffset != TAPI_NO_DATA)
        {
            if (!(pInstData = ServerAlloc (3 * sizeof (DWORD))))
            {
                pParams->lResult = LINEERR_NOMEM;
                goto LGenerateDigits_epilog;
            }

            pInstData[0] = TASYNC_KEY;
            pInstData[1] = (DWORD) pParams->hCall;
            pInstData[2] = pParams->dwEndToEndID;

            dwEndToEndID = (DWORD) NewObject (ghHandleTable, pInstData, 0);
        }

        pParams->lResult = CallSP5(
            pfnTSPI_lineGenerateDigits,
            "lineGenerateDigits",
            SP_FUNC_SYNC,
            (ULONG_PTR) hdCall,
            (DWORD) dwEndToEndID,
            (DWORD) dwDigitMode,
            (ULONG_PTR) (pParams->dwDigitsOffset == TAPI_NO_DATA ?
                NULL : pDataBuf + pParams->dwDigitsOffset),
            (DWORD) pParams->dwDuration
            );

        if (pParams->lResult != 0  &&  dwEndToEndID != 0)
        {
            DereferenceObject (ghHandleTable, dwEndToEndID, 1);
        }
    }

LGenerateDigits_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GenerateDigits"
        );
}


void
WINAPI
LGenerateTone(
    PTCLIENT                    ptClient,
    PLINEGENERATETONE_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVCALL        hdCall;
    TSPIPROC        pfnTSPI_lineGenerateTone;
    DWORD               objectToDereference;
    PTCALLCLIENT    ptCallClient;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if ((pParams->dwToneMode == LINETONEMODE_CUSTOM)  &&

        ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwNumTones * sizeof (LINEGENERATETONE),
            pParams->dwTonesOffset,
            sizeof(DWORD),
            "LGenerateTone",
            "pParams->Tones"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEGENERATETONE,        // provider func index
            &pfnTSPI_lineGenerateTone,  // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "GenerateTone"              // func name

            )) == 0)
    {
        DWORD   dwToneMode = pParams->dwToneMode, *pInstData, dwEndToEndID;


        if (dwToneMode != 0)
        {
            if (!(dwToneMode & AllToneModes) ||
                !IsOnlyOneBitSetInDWORD (dwToneMode))
            {
                pParams->lResult = LINEERR_INVALTONEMODE;
                goto LGenerateTone_epilog;
            }
            else if (!(pInstData = ServerAlloc (3 * sizeof (DWORD))))
            {
                pParams->lResult = LINEERR_NOMEM;
                goto LGenerateTone_epilog;
            }

            pInstData[0] = TASYNC_KEY;
            pInstData[1] = (DWORD) pParams->hCall;
            pInstData[2] = pParams->dwEndToEndID;

            dwEndToEndID = (DWORD) NewObject (ghHandleTable, pInstData, 0);
        }
        else
        {
            dwEndToEndID = 0;
        }

        pParams->lResult = CallSP6(
            pfnTSPI_lineGenerateTone,
            "lineGenerateTone",
            SP_FUNC_SYNC,
            (ULONG_PTR) hdCall,
            (DWORD) dwEndToEndID,
            (DWORD) pParams->dwToneMode,
            (DWORD) pParams->dwDuration,
            (DWORD) pParams->dwNumTones,
            (ULONG_PTR) (pDataBuf + pParams->dwTonesOffset)
            );

        if (pParams->lResult != 0  &&  dwEndToEndID != 0)
        {
            DereferenceObject (ghHandleTable, dwEndToEndID, 1);
        }
    }

LGenerateTone_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GenerateTone"
        );
}


void
WINAPI
LGetAddressCaps(
    PTCLIENT                    ptClient,
    PLINEGETADDRESSCAPS_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    DWORD               dwDeviceID;
    HANDLE              hMutex;
    TSPIPROC            pfnTSPI_lineGetAddressCaps;
    DWORD               objectToDereference;
    PTLINELOOKUPENTRY   pLookupEntry;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwAddressCapsTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            DEVICE_ID,                  // widget type
            (DWORD) pParams->hLineApp,  // client widget handle
            &dwDeviceID,                // provider widget handle
            pParams->dwDeviceID,        // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEGETADDRESSCAPS,      // provider func index
            &pfnTSPI_lineGetAddressCaps,// provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &pLookupEntry,              // context
            "GetAddressCaps"            // func name

            )) == 0)
    {
        DWORD               dwAPIVersion, dwSPIVersion, dwTotalSize,
                            dwFixedSizeClient, dwFixedSizeSP;
        LPLINEADDRESSCAPS   pAddrCaps = (LPLINEADDRESSCAPS) pDataBuf,
                            pAddrCaps2 = (LPLINEADDRESSCAPS) NULL;


        //
        // Verify API & SPI version compatibility
        //

        dwAPIVersion = pParams->dwAPIVersion;

        dwSPIVersion = pLookupEntry->dwSPIVersion;

        if (!IsAPIVersionInRange (dwAPIVersion, dwSPIVersion))
        {
            pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
            goto LGetAddressCaps_epilog;
        }


        //
        // Verify Ext version compatibility
        //

        if (!IsValidLineExtVersion (dwDeviceID, pParams->dwExtVersion))
        {
            pParams->lResult = LINEERR_INCOMPATIBLEEXTVERSION;
            goto LGetAddressCaps_epilog;
        }


        //
        // Determine the fixed siize of the structure for the specified API
        // version, verify client's buffer is big enough
        //

        dwTotalSize = pParams->dwAddressCapsTotalSize;

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:

            dwFixedSizeClient = 176;    // 44 * sizeof (DWORD);
            break;

        case TAPI_VERSION1_4:

            dwFixedSizeClient = 180;    // 45 * sizeof (DWORD);
            break;

        default: // (fix ppc build wrn) case TAPI_VERSION_CURRENT:

            dwFixedSizeClient = sizeof (LINEADDRESSCAPS);
            break;
        }

        if (dwTotalSize < dwFixedSizeClient)
        {
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
            goto LGetAddressCaps_epilog;
        }


        //
        // Determine the fixed size of the structure expected by the SP
        //

        switch (dwSPIVersion)
        {
        case TAPI_VERSION1_0:

            dwFixedSizeSP = 176;        // 44 * sizeof (DWORD);
            break;

        case TAPI_VERSION1_4:

            dwFixedSizeSP = 180;        // 45 * sizeof (DWORD);
            break;

        default: // (fix ppc build wrn) case TAPI_VERSION_CURRENT:

            dwFixedSizeSP = sizeof (LINEADDRESSCAPS);
            break;
        }


        //
        // If the client's buffer is < the fixed size of that expected by
        // the SP (client is lower version than SP) then allocate an
        // intermediate buffer
        //

        if (dwTotalSize < dwFixedSizeSP)
        {
            if (!(pAddrCaps2 = ServerAlloc (dwFixedSizeSP)))
            {
                pParams->lResult = LINEERR_NOMEM;
                goto LGetAddressCaps_epilog;
            }

            pAddrCaps   = pAddrCaps2;
            dwTotalSize = dwFixedSizeSP;
        }


        InitTapiStruct(
            pAddrCaps,
            dwTotalSize,
            dwFixedSizeSP,
            (pAddrCaps2 == NULL ? TRUE : FALSE)
            );

        if ((pParams->lResult = CallSP5(
                pfnTSPI_lineGetAddressCaps,
                "lineGetAddressCaps",
                SP_FUNC_SYNC,
                (DWORD) dwDeviceID,
                (DWORD) pParams->dwAddressID,
                (DWORD) dwSPIVersion,
                (DWORD) pParams->dwExtVersion,
                (ULONG_PTR) pAddrCaps

                )) == 0)
        {
#if DBG
            //
            // Verify the info returned by the provider
            //

#endif


            //
            // Add the fields we're responsible for
            //

            pAddrCaps->dwCallInfoStates |= LINECALLINFOSTATE_NUMOWNERINCR |
                                           LINECALLINFOSTATE_NUMOWNERDECR |
                                           LINECALLINFOSTATE_NUMMONITORS;

            pAddrCaps->dwCallStates |= LINECALLSTATE_UNKNOWN;

            pAddrCaps->dwLineDeviceID = pParams->dwDeviceID;


            //
            // Munge fields where appropriate for old apps (don't want to
            // pass back flags that they won't understand)
            //

            if ((dwAPIVersion == TAPI_VERSION1_0) &&
                (pAddrCaps->dwForwardModes &
                    (LINEFORWARDMODE_UNKNOWN | LINEFORWARDMODE_UNAVAIL)))
            {
                pAddrCaps->dwForwardModes &=
                            ~(LINEFORWARDMODE_UNKNOWN |
                            LINEFORWARDMODE_UNAVAIL);

                pAddrCaps->dwForwardModes |= LINEFORWARDMODE_UNCOND;
            }

            if ((dwAPIVersion == TAPI_VERSION2_0)  &&
                (pAddrCaps->dwAvailableMediaModes & LINEMEDIAMODE_VIDEO))
            {
                pAddrCaps->dwAvailableMediaModes = LINEMEDIAMODE_UNKNOWN |
                    (pAddrCaps->dwAvailableMediaModes & ~LINEMEDIAMODE_VIDEO);
            }


            //
            // If an intermediate buffer was used then copy the bits back
            // to the the original buffer, & free the intermediate buffer.
            // Also reset the dwUsedSize field to the fixed size of the
            // structure for the specifed version, since any data in the
            // variable portion is garbage as far as the client is concerned.
            //

            if (pAddrCaps == pAddrCaps2)
            {
                pAddrCaps = (LPLINEADDRESSCAPS) pDataBuf;

                CopyMemory (pAddrCaps, pAddrCaps2, dwFixedSizeClient);

                ServerFree (pAddrCaps2);

                pAddrCaps->dwTotalSize = pParams->dwAddressCapsTotalSize;
                pAddrCaps->dwUsedSize  = dwFixedSizeClient;
            }


            //
            // Indicate the offset & how many bytes of data we're passing back
            //

            pParams->dwAddressCapsOffset = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                pAddrCaps->dwUsedSize;
         }
    }

LGetAddressCaps_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetAddressCaps"
        );
}


void
WINAPI
LGetAddressID(
    PTCLIENT                    ptClient,
    PLINEGETADDRESSID_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVLINE        hdLine;
    TSPIPROC        pfnTSPI_lineGetAddressID;
    DWORD               objectToDereference;
    PTLINECLIENT    ptLineClient;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwSize,
            pParams->dwAddressOffset,
            sizeof(DWORD),
            "LGetAddressID",
            "pParams->Address"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEGETADDRESSID,        // provider func index
            &pfnTSPI_lineGetAddressID,  // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "GetAddressID"              // func name

            )) == 0)
    {
        if (pParams->dwAddressMode == LINEADDRESSMODE_DIALABLEADDR)
        {
            pParams->lResult = CallSP5(
                pfnTSPI_lineGetAddressID,
                "lineGetAddressID",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdLine,
                (ULONG_PTR) &pParams->dwAddressID,
                (DWORD) pParams->dwAddressMode,
                (ULONG_PTR) (pDataBuf + pParams->dwAddressOffset),
                (DWORD) pParams->dwSize
                );

            *pdwNumBytesReturned = sizeof (LINEGETADDRESSID_PARAMS);
        }
        else
        {
            pParams->lResult = LINEERR_INVALADDRESSMODE;
        }
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetAddressID"
        );
}


void
WINAPI
LGetAddressStatus(
    PTCLIENT                        ptClient,
    PLINEGETADDRESSSTATUS_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVLINE        hdLine;
    TSPIPROC        pfnTSPI_lineGetAddressStatus;
    DWORD               objectToDereference;
    PTLINECLIENT    ptLineClient;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwAddressStatusTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEGETADDRESSSTATUS,    // provider func index
            &pfnTSPI_lineGetAddressStatus,  // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "GetAddressStatus"          // func name

            )) == 0)
    {
        DWORD               dwAPIVersion, dwSPIVersion, dwTotalSize,
                            dwFixedSizeClient, dwFixedSizeSP;
        LPLINEADDRESSSTATUS pAddrStatus = (LPLINEADDRESSSTATUS) pDataBuf,
                            pAddrStatus2 = (LPLINEADDRESSSTATUS) NULL;


        //
        // Safely retrieve the API & SPI versions
        //

        if (GetLineVersions (ptLineClient, &dwAPIVersion, &dwSPIVersion) != 0)
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
            goto LGetAddressStatus_epilog;
        }


        //
        // Determine the fixed size of the structure for the specified API
        // version, verify client's buffer is big enough
        //

        dwTotalSize = pParams->dwAddressStatusTotalSize;

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeClient = 64;     // 16 * sizeof (DWORD)
            break;

        default: // (fix ppc build wrn) case TAPI_VERSION_CURRENT:

            dwFixedSizeClient = sizeof (LINEADDRESSSTATUS);
            break;
        }

        if (dwTotalSize < dwFixedSizeClient)
        {
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
            goto LGetAddressStatus_epilog;
        }


        //
        // Determine the fixed size of the structure expected by the SP
        //

        switch (dwSPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeSP = 64;         // 16 * sizeof (DWORD)
            break;

        default: // (fix ppc build wrn) case TAPI_VERSION_CURRENT:

            dwFixedSizeSP = sizeof (LINEADDRESSSTATUS);
            break;
        }


        //
        // If the client's buffer is < the fixed size of that expected by
        // the SP (client is lower version than SP) then allocate an
        // intermediate buffer
        //

        if (dwTotalSize < dwFixedSizeSP)
        {
            if (!(pAddrStatus2 = ServerAlloc (dwFixedSizeSP)))
            {
                pParams->lResult = LINEERR_NOMEM;
                goto LGetAddressStatus_epilog;
            }

            pAddrStatus = pAddrStatus2;
            dwTotalSize = dwFixedSizeSP;
        }


        InitTapiStruct(
            pAddrStatus,
            dwTotalSize,
            dwFixedSizeSP,
            (pAddrStatus2 == NULL ? TRUE : FALSE)
            );

        if ((pParams->lResult = CallSP3(
                pfnTSPI_lineGetAddressStatus,
                "lineGetAddressStatus",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->dwAddressID,
                (ULONG_PTR) pAddrStatus

                )) == 0)
        {
            DWORD   dwForwardNumEntries;


#if DBG
            //
            // Verify the info returned by the provider
            //

#endif


            //
            // Add the fields we're responsible for
            //


            //
            // Munge fields where appropriate for old apps (don't want to
            // pass back flags that they won't understand)
            //

            if ((dwAPIVersion == TAPI_VERSION1_0) &&
                (dwForwardNumEntries = pAddrStatus->dwForwardNumEntries))
            {
                DWORD           i;
                LPLINEFORWARD   pLineForward;


                pLineForward = (LPLINEFORWARD) (((LPBYTE) pAddrStatus) +
                    pAddrStatus->dwForwardOffset);

                for (i = 0; i < dwForwardNumEntries; i++, pLineForward++)
                {
                    if (pLineForward->dwForwardMode &
                        (LINEFORWARDMODE_UNKNOWN | LINEFORWARDMODE_UNAVAIL))
                    {
                        pLineForward->dwForwardMode &=
                            ~(LINEFORWARDMODE_UNKNOWN |
                            LINEFORWARDMODE_UNAVAIL);

                        pLineForward->dwForwardMode |= LINEFORWARDMODE_UNCOND;
                    }
                }
            }


            //
            // If an intermediate buffer was used then copy the bits back
            // to the the original buffer, & free the intermediate buffer.
            // Also reset the dwUsedSize field to the fixed size of the
            // structure for the specifed version, since any data in the
            // variable portion is garbage as far as the client is concerned.
            //

            if (pAddrStatus == pAddrStatus2)
            {
                pAddrStatus = (LPLINEADDRESSSTATUS) pDataBuf;

                CopyMemory (pAddrStatus, pAddrStatus2, dwFixedSizeClient);

                ServerFree (pAddrStatus2);

                pAddrStatus->dwTotalSize =
                    pParams->dwAddressStatusTotalSize;
                pAddrStatus->dwUsedSize  = dwFixedSizeClient;
            }


            //
            // Indicate the offset & how many bytes of data we're passing back
            //

            pParams->dwAddressStatusOffset = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                pAddrStatus->dwUsedSize;
        }
    }

LGetAddressStatus_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetAddressStatus"
        );
}


void
LGetAgentXxx_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
    PASYNCEVENTMSG          pNewAsyncEventMsg = (PASYNCEVENTMSG)
                                pAsyncRequestInfo->dwParam3;


    CopyMemory (pNewAsyncEventMsg, pAsyncEventMsg, sizeof (ASYNCEVENTMSG));

    *ppBuf = pNewAsyncEventMsg;

    if (pAsyncEventMsg->Param2 == 0)  // success
    {
        LPLINEAGENTACTIVITYLIST pActivityList = (LPLINEAGENTACTIVITYLIST)
                                    (pNewAsyncEventMsg + 1);


        pNewAsyncEventMsg->TotalSize +=
            ((pActivityList->dwUsedSize + 7) & 0xFFFFFFF8);


        //
        // param 1 must not exceed 32-bits. use DWORD_CAST to insure this in 
        // runtime
        //

        pNewAsyncEventMsg->Param3 = DWORD_CAST(pAsyncRequestInfo->dwParam1,__FILE__,__LINE__);
        pNewAsyncEventMsg->Param4 = DWORD_CAST(pActivityList->dwUsedSize,__FILE__,__LINE__);
    }
}


#if DBG
void
PASCAL
LGetAgentXxx(
    PTCLIENT                            ptClient,
    PLINEGETAGENTACTIVITYLIST_PARAMS    pParams,
    DWORD                               dwParamsBufferSize,
    DWORD                               dwRequestType,
    DWORD                               dwSPIOrdinal,
    DWORD                               dwFixedStructSize,
    char                               *pszFuncName
    )
#else
void
PASCAL
LGetAgentXxx(
    PTCLIENT                            ptClient,
    PLINEGETAGENTACTIVITYLIST_PARAMS    pParams,
    DWORD                               dwParamsBufferSize,
    DWORD                               dwRequestType,
    DWORD                               dwSPIOrdinal,
    DWORD                               dwFixedStructSize
    )
#endif
{
    //
    // Since LGetAgentActivityList, LGetAgentGroupList, and LGetAgentStatus
    // all do the same thing (& the params are more or less identical) we
    // can safely condense all the functionality into this one procedure
    //

    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwActivityListTotalSize > 0x40000)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            pszFuncName                 // func name

            )) > 0)
    {
        LONG            lResult;
        DWORD           dwDeviceID,
                        dwTotalSize = pParams->dwActivityListTotalSize;
        PTLINECLIENT    pProxy;


        if (dwTotalSize < dwFixedStructSize)
        {
            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LGetAgentXxx_epilog;
        }

        if ((lResult = FindProxy(
                ptLineClient,
                pParams->dwAddressID,
                dwRequestType,
                &pProxy,
                &dwDeviceID,
                0               // API ver wasn't checked in 2.0
                )))
        {
            lRequestID = lResult;
            goto LGetAgentXxx_epilog;
        }


        //
        // Save the client's buf ptr & post processing proc ptr
        //

        pAsyncRequestInfo->dwParam1 = pParams->hpAgentActivityList;
        pAsyncRequestInfo->dwParam2 = dwTotalSize;
        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;


        //
        // First check to see if there's a (local) proxy registered
        // for this type of request on this line.  If so, build a
        // request & send it to the proxy.
        //

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    dwRequestType,
                    2 * sizeof (DWORD),
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LGetAgentXxx_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.GetAgentActivityList.
                dwAddressID = pParams->dwAddressID;
            pProxyRequestWrapper->ProxyRequest.GetAgentActivityList.
                ActivityList.dwTotalSize = dwTotalSize;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LGetAgentXxx_epilog;
            }
            else // success
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


        //
        // There's no proxy, so check to see if line is remote and
        // call remotesp if so
        //

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            LPBYTE                  pBuf;
            LPLINEAGENTACTIVITYLIST pActivityList;


            //
            // Alloc a shadow buf that the SP can use until it completes this
            // request.  Make sure there's enough extra space in the buf for
            // an ASYNCEVENTMSG header so we don't have to alloc yet another
            // buf in the post processing proc when preparing the completion
            // msg to send to the client, and that the msg is 64-bit aligned.
            //

            if (!(pBuf = ServerAlloc(
                    sizeof (ASYNCEVENTMSG) + ((dwTotalSize + 7) & 0xfffffff8)
                    )))
            {
                lRequestID = LINEERR_NOMEM;
                goto LGetAgentXxx_epilog;
            }

            pAsyncRequestInfo->pfnPostProcess =
                LGetAgentXxx_PostProcess;

            pAsyncRequestInfo->dwParam3 = (ULONG_PTR) pBuf;

            pActivityList = (LPLINEAGENTACTIVITYLIST)
                (pBuf + sizeof (ASYNCEVENTMSG));

            pActivityList->dwTotalSize = dwTotalSize;

            pParams->lResult = CallSP4(
                pRemoteSP->apfn[dwSPIOrdinal],
                pszFuncName,
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->dwAddressID,
                (ULONG_PTR) pActivityList
                );
        }


        //
        // There's no registered proxy & line is not remote, so fail
        //

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LGetAgentXxx_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        pszFuncName
        );
}

#if DBG
void
PASCAL
LGetAgentWithoutAddressIDXxx(
    PTCLIENT                            ptClient,
    PLINEGETAGENTINFO_PARAMS            pParams,
    DWORD                               dwParamsBufferSize,
    DWORD                               dwRequestType,
    DWORD                               dwSPIOrdinal,
    DWORD                               dwFixedStructSize,
    char                               *pszFuncName
    )
#else
void
PASCAL
LGetAgentWithoutAddressIDXxx(
    PTCLIENT                            ptClient,
    PLINEGETAGENTINFO_PARAMS            pParams,
    DWORD                               dwParamsBufferSize,
    DWORD                               dwRequestType,
    DWORD                               dwSPIOrdinal,
    DWORD                               dwFixedStructSize
    )
#endif
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwAgentInfoTotalSize > 0x40000)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            pszFuncName                 // func name

            )) > 0)
    {
        LONG            lResult;
        DWORD           dwDeviceID,
                        dwTotalSize = pParams->dwAgentInfoTotalSize;
        PTLINECLIENT    pProxy;


        if (dwTotalSize < dwFixedStructSize)
        {
            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LGetAgentWithoutAddressIDXxx_epilog;
        }

        if ((lResult = FindProxy(
                ptLineClient,
                0,
                dwRequestType,
                &pProxy,
                &dwDeviceID,
                TAPI_VERSION2_2
                )))
        {
            lRequestID = lResult;
            goto LGetAgentWithoutAddressIDXxx_epilog;
        }


        //
        // Save the client's buf ptr & post processing proc ptr
        //

        pAsyncRequestInfo->dwParam1 = pParams->hpAgentInfo;
        pAsyncRequestInfo->dwParam2 = dwTotalSize;
        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;


        //
        // First check to see if there's a (local) proxy registered
        // for this type of request on this line.  If so, build a
        // request & send it to the proxy.
        //

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    dwRequestType,
                    2 * sizeof (DWORD),
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LGetAgentWithoutAddressIDXxx_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.GetAgentInfo.
                hAgent = pParams->hAgent;
            pProxyRequestWrapper->ProxyRequest.GetAgentInfo.
                AgentInfo.dwTotalSize = dwTotalSize;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LGetAgentWithoutAddressIDXxx_epilog;
            }
            else // success
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


        //
        // There's no proxy, so check to see if line is remote and
        // call remotesp if so
        //

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            LPBYTE                  pBuf;
            LPLINEAGENTINFO         pAgentInfo;


            //
            // Alloc a shadow buf that the SP can use until it completes this
            // request.  Make sure there's enough extra space in the buf for
            // an ASYNCEVENTMSG header so we don't have to alloc yet another
            // buf in the post processing proc when preparing the completion
            // msg to send to the client, and that the msg is 64-bit aligned.
            //

            if (!(pBuf = ServerAlloc(
                    sizeof (ASYNCEVENTMSG) + ((dwTotalSize + 7) & 0xfffffff8)
                    )))
            {
                lRequestID = LINEERR_NOMEM;
                goto LGetAgentWithoutAddressIDXxx_epilog;
            }

            pAsyncRequestInfo->pfnPostProcess =
                LGetAgentXxx_PostProcess;

            pAsyncRequestInfo->dwParam3 = (ULONG_PTR) pBuf;

            pAgentInfo = (LPLINEAGENTINFO)
                (pBuf + sizeof (ASYNCEVENTMSG));

            pAgentInfo->dwTotalSize = dwTotalSize;

            pParams->lResult = CallSP4(
                pRemoteSP->apfn[dwSPIOrdinal],
                pszFuncName,
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->hAgent,
                (ULONG_PTR) pAgentInfo
                );
        }


        //
        // There's no registered proxy & line is not remote, so fail
        //

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LGetAgentWithoutAddressIDXxx_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        pszFuncName
        );
}



void
WINAPI
LGetAgentActivityList(
    PTCLIENT                            ptClient,
    PLINEGETAGENTACTIVITYLIST_PARAMS    pParams,
    DWORD                               dwParamsBufferSize,
    LPBYTE                              pDataBuf,
    LPDWORD                             pdwNumBytesReturned
    )
{
    LGetAgentXxx(
        ptClient,
        pParams,
        dwParamsBufferSize,
        LINEPROXYREQUEST_GETAGENTACTIVITYLIST,
        SP_LINEGETAGENTACTIVITYLIST,
        sizeof (LINEAGENTACTIVITYLIST)
#if DBG
        ,
        "GetAgentActivityList"
#endif
        );
}


void
WINAPI
LGetAgentCaps(
    PTCLIENT                    ptClient,
    PLINEGETAGENTCAPS_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex, bProxy = FALSE;
    LONG                lRequestID;
    DWORD               dwDeviceID;
    HANDLE              hMutex;
    DWORD               objectToDereference;
    PTLINELOOKUPENTRY   pLookupEntry;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwAgentCapsTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            DEVICE_ID,                  // widget type
            (DWORD) pParams->hLineApp,  // client widget handle
            &dwDeviceID,                // provider widget handle
            pParams->dwDeviceID,        // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &pLookupEntry,              // context
            "GetAgentCaps"              // func name

            )) > 0)
    {
        DWORD               dwTotalSize = pParams->dwAgentCapsTotalSize;
        PTLINE              ptLine;
        PTLINECLIENT        pProxy = NULL;
        DWORD               dwFixedSize = 0;


        switch (pParams->dwAppAPIVersion)
        {
        case TAPI_VERSION2_0:
        case TAPI_VERSION2_1:

            dwFixedSize = 14 * sizeof(DWORD);
            break;

        case TAPI_VERSION2_2:
        case TAPI_VERSION3_0:
        case TAPI_VERSION3_1:

            dwFixedSize = sizeof(LINEAGENTCAPS);
            break;

        default:

            //
            // Any other version is too low or invalid
            //

            lRequestID = LINEERR_INCOMPATIBLEAPIVERSION;
            goto LGetAgentCaps_epilog;
        }

        if (dwTotalSize < dwFixedSize)
        {
            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LGetAgentCaps_epilog;
        }


        //
        // Save the client's buf ptr & post processing proc ptr
        //

        pAsyncRequestInfo->dwParam1 = pParams->hpAgentCaps;
        pAsyncRequestInfo->dwParam2 = dwTotalSize;
        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;


        try
        {
            if (!(ptLine = pLookupEntry->ptLine))
            {
                // If ptLine is NULL, the line has not been
                // open by any app on the local machine; this means
                // that there's no proxy on the local machine; however,
                // if the line is a remote one (i.e., exposed by remotesp),
                // there could be a proxy on another machine. So get out
                // of this try block and continue to check for remote line
                // (pProxy is already initialized to NULL).
                leave;
            }
            pProxy = ptLine->apProxys[LINEPROXYREQUEST_GETAGENTCAPS];
            if (pParams->dwAddressID >= ptLine->dwNumAddresses)
            {
            lRequestID = LINEERR_INVALADDRESSID;
            goto LGetAgentCaps_epilog;
            }

            if (ptLine->dwKey != TLINE_KEY)
            {
                lRequestID = LINEERR_INVALLINEHANDLE;
                goto LGetAgentCaps_epilog;
            }
        }
        myexcept
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
            goto LGetAgentCaps_epilog;
        }

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;

            bProxy = TRUE;

            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_GETAGENTCAPS,
                    2 * sizeof(DWORD),
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LGetAgentCaps_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.GetAgentCaps.dwAddressID =
                pParams->dwAddressID;
            pProxyRequestWrapper->ProxyRequest.GetAgentCaps.
                AgentCaps.dwTotalSize = dwTotalSize;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LGetAgentCaps_epilog;
            }
            else // success
            {
                pParams->lResult = (LONG)
                    pAsyncRequestInfo->dwLocalRequestID;
            }
        }
        else if (pLookupEntry->bRemote)
        {
            LPBYTE          pBuf;
            LPLINEAGENTCAPS pCaps;


            bProxy = TRUE;

            //
            // Alloc a shadow buf that the SP can use until it completes this
            // request.  Make sure there's enough extra space in the buf for
            // an ASYNCEVENTMSG header so we don't have to alloc yet another
            // buf in the post processing proc when preparing the completion
            // msg to send to the client, and that the msg is 64-bit aligned.
            //

            if (!(pBuf = ServerAlloc(
                    sizeof (ASYNCEVENTMSG) + ((dwTotalSize + 7) & 0xfffffff8)
                    )))
            {
                lRequestID = LINEERR_NOMEM;
                goto LGetAgentCaps_epilog;
            }

            pAsyncRequestInfo->pfnPostProcess =
                LGetAgentXxx_PostProcess;

            pAsyncRequestInfo->dwParam3 = (ULONG_PTR) pBuf;

            pCaps = (LPLINEAGENTCAPS) (pBuf + sizeof (ASYNCEVENTMSG));

            pCaps->dwTotalSize = dwTotalSize;

            // Note: RemoteSP comes up with it's own hLineApp

            pParams->lResult = CallSP5(
                pRemoteSP->apfn[SP_LINEGETAGENTCAPS],
                "lineGetAgentCaps",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (DWORD) dwDeviceID,
                (DWORD) pParams->dwAddressID,
                (DWORD) pParams->dwAppAPIVersion,
                (ULONG_PTR) pCaps
                );
        }


        //
        // There's no registered proxy & line is not remote, so fail
        //

        if (!bProxy)
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LGetAgentCaps_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "GetAgentCaps"
        );
}


void
WINAPI
LGetAgentGroupList(
    PTCLIENT                        ptClient,
    PLINEGETAGENTGROUPLIST_PARAMS   pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    LGetAgentXxx(
        ptClient,
        (PLINEGETAGENTACTIVITYLIST_PARAMS) pParams,
        dwParamsBufferSize,
        LINEPROXYREQUEST_GETAGENTGROUPLIST,
        SP_LINEGETAGENTGROUPLIST,
        sizeof (LINEAGENTGROUPLIST)
#if DBG
        ,
        "GetAgentGroupList"
#endif
        );
}

void
WINAPI
LGetAgentInfo(
    PTCLIENT                    ptClient,
    PLINEGETAGENTINFO_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    LGetAgentWithoutAddressIDXxx(
        ptClient,
        pParams,
        dwParamsBufferSize,
        LINEPROXYREQUEST_GETAGENTINFO,
        SP_LINEGETAGENTINFO,
        sizeof (LINEAGENTINFO)
#if DBG
        ,
        "GetAgentInfo"
#endif
        );
}


void
WINAPI
LGetAgentSessionInfo(
    PTCLIENT                        ptClient,
    PLINEGETAGENTSESSIONINFO_PARAMS pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    LGetAgentWithoutAddressIDXxx(
        ptClient,
        (PLINEGETAGENTINFO_PARAMS) pParams,
        dwParamsBufferSize,
        LINEPROXYREQUEST_GETAGENTSESSIONINFO,
        SP_LINEGETAGENTSESSIONINFO,
        sizeof (LINEAGENTSESSIONINFO)
#if DBG
        ,
        "GetAgentSessionInfo"
#endif
        );
}


void
WINAPI
LGetAgentSessionList(
    PTCLIENT                        ptClient,
    PLINEGETAGENTSESSIONLIST_PARAMS pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    LGetAgentWithoutAddressIDXxx(
        ptClient,
        (PLINEGETAGENTINFO_PARAMS) pParams,
        dwParamsBufferSize,
        LINEPROXYREQUEST_GETAGENTSESSIONLIST,
        SP_LINEGETAGENTSESSIONLIST,
        sizeof (LINEAGENTSESSIONLIST)
#if DBG
        ,
        "GetAgentSessionList"
#endif
        );
}


void
WINAPI
LGetAgentStatus(
    PTCLIENT                    ptClient,
    PLINEGETAGENTSTATUS_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    LGetAgentXxx(
        ptClient,
        (PLINEGETAGENTACTIVITYLIST_PARAMS) pParams,
        dwParamsBufferSize,
        LINEPROXYREQUEST_GETAGENTSTATUS,
        SP_LINEGETAGENTSTATUS,
        sizeof (LINEAGENTSTATUS)
#if DBG
        ,
        "GetAgentStatus"
#endif
        );
}


void
WINAPI
LGetAppPriority(
    PTCLIENT                    ptClient,
    PLINEGETAPPPRIORITY_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    DWORD   dwMediaMode = pParams->dwMediaMode,
            dwRequestMode = pParams->dwRequestMode;
    DWORD   dwCount;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwAppNameOffset
            )  ||

        ((pParams->dwExtensionIDOffset != TAPI_NO_DATA)  &&

            ((pParams->dwExtensionIDOffset + sizeof (LINEEXTENSIONID)) >
                dwParamsBufferSize))  ||

        ((pParams->dwExtensionNameTotalSize != TAPI_NO_DATA)  &&

            (pParams->dwExtensionNameTotalSize  > dwParamsBufferSize)))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }

    if (dwMediaMode == 0)
    {
        if ((dwRequestMode != LINEREQUESTMODE_MAKECALL) &&
            (dwRequestMode != LINEREQUESTMODE_MEDIACALL))
        {
            pParams->lResult = LINEERR_INVALREQUESTMODE;
            goto LGetAppPriority_return;
        }
    }
    else if ( 0xFF000000 & dwMediaMode )
    {
        // ignore
    }
    else if ( dwMediaMode & ~AllMediaModes2_1 )
    {
        pParams->lResult = LINEERR_INVALMEDIAMODE;
        goto LGetAppPriority_return;
    }

    if ((dwMediaMode & 0x00ffffff) || (dwMediaMode == 0))
    {
        WCHAR   szModuleName[MAX_PATH];
        WCHAR  *pszCurrentPriorityList = NULL;
        WCHAR  *pszLocationInPriorityList;


        szModuleName[0] = '"';

        wcsncpy(szModuleName + 1, 
                (PWSTR)(pDataBuf + pParams->dwAppNameOffset), 
                MAX_PATH - 2);

        szModuleName[MAX_PATH - 1] = '\0';

        _wcsupr( szModuleName + 1 );


        //
        // Enter the pri list critical section before we start looking
        //

        EnterCriticalSection (&gPriorityListCritSec);


        //
        // Determine which of the priority lists we want to look at
        //

        if (dwMediaMode)
        {
            for(
                dwCount = 0;
                dwCount < TapiGlobals.dwUsedPriorityLists;
                dwCount++
                )
            {
                if (dwMediaMode == TapiGlobals.pPriLists[dwCount].dwMediaModes)
                {
                    pszCurrentPriorityList =
                        TapiGlobals.pPriLists[dwCount].pszPriList;
                    break;
                }
            }
        }
        else
        {
            pszCurrentPriorityList = (dwRequestMode == LINEREQUESTMODE_MAKECALL
                ? TapiGlobals.pszReqMakeCallPriList :
                TapiGlobals.pszReqMediaCallPriList);
        }


        if (pszCurrentPriorityList &&

            (pszLocationInPriorityList = wcsstr(
                pszCurrentPriorityList,
                szModuleName
                )))
        {
            //
            // App is in pri list, determine it's position
            //

            WCHAR  *p = pszCurrentPriorityList + 1; // skip first '"'
            DWORD   i;


            for (i = 1; pszLocationInPriorityList > p; i++)
            {
                p = wcschr(p, '"');
                p++;
            }

            pParams->dwPriority = i;
        }
        else
        {
            //
            // App not listed in formal priority list, so just return 0
            //
            // Note: TAPI 1.4 said that if app was in soft pri list
            //       (i.e. had line open with OWNER priv for specified
            //       media mode) then we'd return -1 instead of 0.
            //       But that's a pain to figure out, & we figured no
            //       one was going to use that info anyway, so we settled
            //       for always returning 0.
            //

            pParams->dwPriority = 0;
        }


        //
        // Leave list critical section now that we're done
        //

        LeaveCriticalSection (&gPriorityListCritSec);

        *pdwNumBytesReturned = sizeof (LINEGETAPPPRIORITY_PARAMS);
    }

LGetAppPriority_return:

    LOG((TL_TRACE, 
        "LineEpilogSync (lineGetAppPriority) exit, returning x%x",
        pParams->lResult
        ));
}


void
WINAPI
LGetCallAddressID(
    PTCLIENT                        ptClient,
    PLINEGETCALLADDRESSID_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    PTCALLCLIENT    ptCallClient;


    if (TapiGlobals.dwNumLineInits == 0)
    {
        pParams->lResult = LINEERR_UNINITIALIZED;
        goto LGetCallAddressID_exit;
    }

    if (!(ptCallClient = ReferenceCall (pParams->hCall, ptClient)))
    {
        pParams->lResult = LINEERR_INVALCALLHANDLE;
        goto LGetCallAddressID_exit;
    }

    try
    {
        pParams->dwAddressID = ptCallClient->ptCall->dwAddressID;

        if (ptCallClient->dwKey != TCALLCLIENT_KEY)
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        pParams->lResult = LINEERR_INVALCALLHANDLE;
    }

    DereferenceObject (ghHandleTable, pParams->hCall, 1);

    if (pParams->lResult == 0)
    {
        *pdwNumBytesReturned = sizeof (LINEGETCALLADDRESSID_PARAMS);
    }

LGetCallAddressID_exit:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineGetCallAddressID: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
    LOG((TL_TRACE,
        "lineGetCallAddressID: exit, result=x%x",
        pParams->lResult
        ));
#endif

    return;
}


void
WINAPI
LGetCallHubTracking(
    PTCLIENT                        ptClient,
    PLINEGETCALLHUBTRACKING_PARAMS  pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVLINE        hdLine;
    TSPIPROC        pfnTSPI_lineGetCallHubTracking;
    DWORD               objectToDereference;
    PTLINECLIENT    ptLineClient;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwTrackingInfoTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEGETCALLHUBTRACKING,  // provider func index
            &pfnTSPI_lineGetCallHubTracking,// provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "GetCallHubTracking"        // func name

            )) == 0  ||

        (pParams->lResult == LINEERR_OPERATIONUNAVAIL))
    {
        LPLINECALLHUBTRACKINGINFO  pTrackingInfo =
                                       (LPLINECALLHUBTRACKINGINFO) pDataBuf;


        if (pParams->lResult == LINEERR_OPERATIONUNAVAIL)
        {
            pParams->lResult = 0;
            pfnTSPI_lineGetCallHubTracking = (TSPIPROC) NULL;
        }

        if (pParams->dwTrackingInfoTotalSize <
                sizeof (LINECALLHUBTRACKINGINFO))
        {
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
            goto LGetCallHubTracking_epilog;
        }

        InitTapiStruct(
            pTrackingInfo,
            pParams->dwTrackingInfoTotalSize,
            sizeof (LINECALLHUBTRACKINGINFO),
            TRUE
            );

        if (!pfnTSPI_lineGetCallHubTracking ||

            (pParams->lResult = CallSP2(
                pfnTSPI_lineGetCallHubTracking,
                "lineGetCallHubTracking",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdLine,
                (ULONG_PTR) pTrackingInfo

                )) == 0)
        {
            try
            {
                pTrackingInfo->dwCurrentTracking =
                    ptLineClient->dwCurrentTracking;
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                pParams->lResult = LINEERR_INVALLINEHANDLE;
                goto LGetCallHubTracking_epilog;
            }

            pTrackingInfo->dwAvailableTracking |=
                LINECALLHUBTRACKING_ALLCALLS;

            pParams->dwTrackingInfoOffset = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                pTrackingInfo->dwUsedSize;
        }
    }

LGetCallHubTracking_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetCallHubTracking"
        );
}


void
WINAPI
LGetCallIDs(
    PTCLIENT                ptClient,
    PLINEGETCALLIDS_PARAMS  pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    PTCALLCLIENT    ptCallClient;


    if (TapiGlobals.dwNumLineInits == 0)
    {
        pParams->lResult = LINEERR_UNINITIALIZED;
        goto LGetCallIDs_exit;
    }

    if (!(ptCallClient = ReferenceCall (pParams->hCall, ptClient)))
    {
        pParams->lResult = LINEERR_INVALCALLHANDLE;
        goto LGetCallIDs_exit;
    }

    try
    {
        pParams->dwAddressID     = ptCallClient->ptCall->dwAddressID;
        pParams->dwCallID        = ptCallClient->ptCall->dwCallID;
        pParams->dwRelatedCallID = ptCallClient->ptCall->dwRelatedCallID;

        if (ptCallClient->dwKey != TCALLCLIENT_KEY)
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        pParams->lResult = LINEERR_INVALCALLHANDLE;
    }

    DereferenceObject (ghHandleTable, pParams->hCall, 1);

    if (pParams->lResult == 0)
    {
        *pdwNumBytesReturned = sizeof (LINEGETCALLIDS_PARAMS);
    }

LGetCallIDs_exit:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineGetCallIDs: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
    LOG((TL_TRACE,
        "lineGetCallIDs: exit, result=x%x",
        pParams->lResult
        ));
#endif

    return;
}


void
WINAPI
LGetCallInfo(
    PTCLIENT                ptClient,
    PLINEGETCALLINFO_PARAMS pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVCALL        hdCall;
    TSPIPROC        pfnTSPI_lineGetCallInfo;
    DWORD               objectToDereference;
    PTCALLCLIENT    ptCallClient;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwCallInfoTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_MONITOR,  // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEGETCALLINFO,         // provider func index
            &pfnTSPI_lineGetCallInfo,   // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "GetCallInfo"               // func name

            )) == 0)
    {
        DWORD           dwAPIVersion, dwSPIVersion, dwTotalSize,
                        dwFixedSizeClient, dwFixedSizeSP;
        PTCALL          ptCall;
        LPLINECALLINFO  pCallInfo = (LPLINECALLINFO) pDataBuf,
                        pCallInfo2 = (LPLINECALLINFO) NULL;


        //
        // Safely retrieve the API & SPI versions, etc
        //

        try
        {
            ptCall = ptCallClient->ptCall;

            dwAPIVersion = ptCallClient->ptLineClient->dwAPIVersion;
            dwSPIVersion = ((PTLINE) ptCallClient->ptLineClient->ptLine)
                ->dwSPIVersion;

            if (ptCallClient->dwKey != TCALLCLIENT_KEY)
            {
                pParams->lResult = LINEERR_INVALCALLHANDLE;
                goto LGetCallInfo_epilog;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LGetCallInfo_epilog;
        }


        //
        // Determine the fixed size of the structure for the specified API
        // version, verify client's buffer is big enough
        //

        dwTotalSize = pParams->dwCallInfoTotalSize;

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeClient = 296;    // 69 * sizeof(DWORD) + sizeof (HLINE)
                                        //     + sizeof (LINEDIALPARAMS)
            break;

        case TAPI_VERSION2_0:
        case TAPI_VERSION2_1:
        case TAPI_VERSION2_2:

            dwFixedSizeClient = 324;    // 76 * sizeof(DWORD) + sizeof (HLINE)
                                        //     + sizeof (LINEDIALPARAMS)
            break;

        default: // (fix ppc build wrn) case TAPI_VERSION_CURRENT:

            dwFixedSizeClient = sizeof (LINECALLINFO);
            break;
        }

        if (dwTotalSize < dwFixedSizeClient)
        {
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
            goto LGetCallInfo_epilog;
        }


        //
        // Determine the fixed size of the structure expected by the SP
        //

        switch (dwSPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeSP = 296;        // 69 * sizeof(DWORD) + sizeof (HLINE)
                                        //     + sizeof (LINEDIALPARAMS)
            break;

        case TAPI_VERSION2_0:
        case TAPI_VERSION2_1:
        case TAPI_VERSION2_2:

            dwFixedSizeSP = 324;        // 76 * sizeof(DWORD) + sizeof (HLINE)
                                        //     + sizeof (LINEDIALPARAMS)
            break;

        default: // (fix ppc build wrn) case TAPI_VERSION_CURRENT:

            dwFixedSizeSP = sizeof (LINECALLINFO);
            break;
        }


        //
        // If the client's buffer is < the fixed size of that expected by
        // the SP (client is lower version than SP) then allocate an
        // intermediate buffer
        //

        if (dwTotalSize < dwFixedSizeSP)
        {
            if (!(pCallInfo2 = ServerAlloc (dwFixedSizeSP)))
            {
                pParams->lResult = LINEERR_NOMEM;
                goto LGetCallInfo_epilog;
            }

            pCallInfo   = pCallInfo2;
            dwTotalSize = dwFixedSizeSP;
        }


        InitTapiStruct(
            pCallInfo,
            dwTotalSize,
            dwFixedSizeSP,
            (pCallInfo2 == NULL ? TRUE : FALSE)
            );

        if ((pParams->lResult = CallSP2(
                pfnTSPI_lineGetCallInfo,
                "lineGetCallInfo",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdCall,
                (ULONG_PTR) pCallInfo

                )) == 0)
        {
            //
            // Safely add the fields we're responsible for
            //

            try
            {
                pCallInfo->hLine = (HLINE) ptCallClient->ptLineClient->hLine;

                pCallInfo->dwMonitorDigitModes =
                    ptCallClient->dwMonitorDigitModes;
                pCallInfo->dwMonitorMediaModes =
                    ptCallClient->dwMonitorMediaModes;

                pCallInfo->dwNumOwners   = ptCall->dwNumOwners;
                pCallInfo->dwNumMonitors = ptCall->dwNumMonitors;

                InsertVarData(
                    pCallInfo,
                    &pCallInfo->dwAppNameSize,
                    ptCall->pszAppName,
                    ptCall->dwAppNameSize
                    );

                InsertVarData(
                    pCallInfo,
                    &pCallInfo->dwDisplayableAddressSize,
                    ptCall->pszDisplayableAddress,
                    ptCall->dwDisplayableAddressSize
                    );

                InsertVarData(
                    pCallInfo,
                    &pCallInfo->dwCalledPartySize,
                    ptCall->pszCalledParty,
                    ptCall->dwCalledPartySize
                    );

                InsertVarData(
                    pCallInfo,
                    &pCallInfo->dwCommentSize,
                    ptCall->pszComment,
                    ptCall->dwCommentSize
                    );

                if (ptCallClient->dwKey != TCALLCLIENT_KEY)
                {
                    pParams->lResult = LINEERR_INVALCALLHANDLE;
                }
            }
            myexcept
            {
                pParams->lResult = LINEERR_INVALCALLHANDLE;
            }

            pCallInfo->dwCallStates |= LINECALLSTATE_UNKNOWN;


#if TELE_SERVER
            // if it's a server, map the device id
            if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
               !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
            {
                DWORD dwCount;

                // if we fall out of this for loop, the id just
                // doesn't get updated

                for(
                    dwCount = 0;
                    dwCount < ptClient->dwLineDevices;
                    dwCount++
                    )
                {
                    if (ptClient->pLineDevices[dwCount] ==
                            pCallInfo->dwLineDeviceID)
                    {
                        pCallInfo->dwLineDeviceID = dwCount;
                        break;
                    }
                }
            }
#endif

            //
            // Munge fields where appropriate for old apps (don't want to
            // pass back flags that they won't understand)
            //

            if (dwAPIVersion == TAPI_VERSION1_0)
            {
                if (pCallInfo->dwOrigin & LINECALLORIGIN_INBOUND)
                {
                    pCallInfo->dwOrigin = LINECALLORIGIN_UNAVAIL;
                }

                if ((pCallInfo->dwReason &
                    (LINECALLREASON_INTRUDE | LINECALLREASON_PARKED)))
                {
                    pCallInfo->dwReason = LINECALLREASON_UNAVAIL;
                }
            }


            //
            // If an intermediate buffer was used then copy the bits back
            // to the the original buffer, & free the intermediate buffer.
            // Also reset the dwUsedSize field to the fixed size of the
            // structure for the specifed version, since any data in the
            // variable portion is garbage as far as the client is concerned.
            //

            if (pCallInfo == pCallInfo2)
            {
                pCallInfo = (LPLINECALLINFO) pDataBuf;

                CopyMemory (pCallInfo, pCallInfo2, dwFixedSizeClient);

                ServerFree (pCallInfo2);

                pCallInfo->dwTotalSize = pParams->dwCallInfoTotalSize;
                pCallInfo->dwUsedSize  = dwFixedSizeClient;
            }


            //
            // Indicate the offset & how many bytes of data we're passing back
            //

            if (pParams->lResult == 0)
            {
                pParams->dwCallInfoOffset = 0;

                *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                    pCallInfo->dwUsedSize;
            }
        }
    }

LGetCallInfo_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetCallInfo"
        );
}


void
WINAPI
LGetCallStatus(
    PTCLIENT                    ptClient,
    PLINEGETCALLSTATUS_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVCALL        hdCall;
    TSPIPROC        pfnTSPI_lineGetCallStatus;
    DWORD               objectToDereference;
    PTCALLCLIENT    ptCallClient;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwCallStatusTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_MONITOR,  // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEGETCALLSTATUS,       // provider func index
            &pfnTSPI_lineGetCallStatus, // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "GetCallStatus"             // func name

            )) == 0)
    {
        DWORD               dwAPIVersion, dwSPIVersion, dwTotalSize,
                            dwFixedSizeClient, dwFixedSizeSP, dwPrivilege;
        LPLINECALLSTATUS    pCallStatus = (LPLINECALLSTATUS) pDataBuf,
                            pCallStatus2 = (LPLINECALLSTATUS) NULL;


        //
        // Safely retrieve the API & SPI versions
        //

        try
        {
            dwAPIVersion = ptCallClient->ptLineClient->dwAPIVersion;
            dwSPIVersion = ((PTLINE) ptCallClient->ptLineClient->ptLine)
                ->dwSPIVersion;

            dwPrivilege = ptCallClient->dwPrivilege;

            if (ptCallClient->dwKey != TCALLCLIENT_KEY)
            {
                pParams->lResult = LINEERR_INVALCALLHANDLE;
                goto LGetCallStatus_epilog;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LGetCallStatus_epilog;
        }


        //
        // Determine the fixed siize of the structure for the specified API
        // version, verify client's buffer is big enough
        //

        dwTotalSize = pParams->dwCallStatusTotalSize;

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeClient = 36;     // 9 * sizeof (DWORD)
            break;

        default: // (fix ppc build wrn) case TAPI_VERSION_CURRENT:

            dwFixedSizeClient = sizeof (LINECALLSTATUS);
            break;
        }

        if (dwTotalSize < dwFixedSizeClient)
        {
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
            goto LGetCallStatus_epilog;
        }


        //
        // Determine the fixed size of the structure expected by the SP
        //

        switch (dwSPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeSP = 36;         // 9 * sizeof (DWORD)
            break;

        default: // (fix ppc build wrn) case TAPI_VERSION_CURRENT:

            dwFixedSizeSP = sizeof (LINECALLSTATUS);
            break;
        }


        //
        // If the client's buffer is < the fixed size of that expected by
        // the SP (client is lower version than SP) then allocate an
        // intermediate buffer
        //

        if (dwTotalSize < dwFixedSizeSP)
        {
            if (!(pCallStatus2 = ServerAlloc (dwFixedSizeSP)))
            {
                pParams->lResult = LINEERR_NOMEM;
                goto LGetCallStatus_epilog;
            }

            pCallStatus = pCallStatus2;
            dwTotalSize = dwFixedSizeSP;
        }


        InitTapiStruct(
            pCallStatus,
            dwTotalSize,
            dwFixedSizeSP,
            (pCallStatus2 == NULL ? TRUE : FALSE)
            );

        if ((pParams->lResult = CallSP2(
                pfnTSPI_lineGetCallStatus,
                "lineGetCallStatus",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdCall,
                (ULONG_PTR) pCallStatus

                )) == 0)
        {
#if DBG
            //
            // Verify the info returned by the provider
            //

#endif

            //
            // Add the fields we're responsible for
            //

            pCallStatus->dwCallPrivilege = dwPrivilege;

            if (dwSPIVersion < TAPI_VERSION2_0 &&
                dwAPIVersion >= TAPI_VERSION2_0)
            {
                GetSystemTime (&pCallStatus->tStateEntryTime);
            }

            //
            // Munge fields where appropriate for old apps (don't want to
            // pass back flags that they won't understand)
            //


            //
            // If an intermediate buffer was used then copy the bits back
            // to the the original buffer, & free the intermediate buffer.
            // Also reset the dwUsedSize field to the fixed size of the
            // structure for the specifed version, since any data in the
            // variable portion is garbage as far as the client is concerned.
            //

            if (pCallStatus == pCallStatus2)
            {
                pCallStatus = (LPLINECALLSTATUS) pDataBuf;

                CopyMemory (pCallStatus, pCallStatus2, dwFixedSizeClient);

                ServerFree (pCallStatus2);

                pCallStatus->dwTotalSize = pParams->dwCallStatusTotalSize;
                pCallStatus->dwUsedSize  = dwFixedSizeClient;
            }


            //
            // Indicate the offset & how many bytes of data we're passing back
            //

            pParams->dwCallStatusOffset = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                pCallStatus->dwUsedSize;

        }
    }

LGetCallStatus_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetCallStatus"
        );
}


void
WINAPI
LGetConfRelatedCalls(
    PTCLIENT                        ptClient,
    PLINEGETCONFRELATEDCALLS_PARAMS pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    DWORD               dwTotalSize = pParams->dwCallListTotalSize;
    PTCALLCLIENT        ptCallClient;
    PTLINECLIENT        ptLineClient;
    LPLINECALLLIST      pCallList = (LPLINECALLLIST) pDataBuf;
    TPOINTERLIST        confCallList, *pConfCallList = &confCallList;
    PTCONFERENCELIST    pConfList;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwCallListTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }

    if (TapiGlobals.dwNumLineInits == 0)
    {
        pParams->lResult = LINEERR_UNINITIALIZED;
        return;
    }

    if (dwTotalSize < sizeof (LINECALLLIST))
    {
        pParams->lResult = LINEERR_STRUCTURETOOSMALL;
        return;
    }

    if (!(ptCallClient = ReferenceCall (pParams->hCall, ptClient)))
    {
        pParams->lResult = LINEERR_INVALCALLHANDLE;
        return;
    }

    try
    {
        ptLineClient = ptCallClient->ptLineClient;

        if (!(pConfList = ptCallClient->ptCall->pConfList) ||
            (pConfList == (PTCONFERENCELIST) LongToPtr(0xffffffff)))
        {
            pParams->lResult = LINEERR_NOCONFERENCE;
        }
    }
    myexcept
    {
        pParams->lResult = LINEERR_INVALCALLHANDLE;
    }

    DereferenceObject (ghHandleTable, pParams->hCall, 1);

    if (pParams->lResult != 0)
    {
        return;
    }

    if ((pParams->lResult = GetConfCallListFromConf(
            pConfList,
            &pConfCallList

            )) != 0)
    {
        return;
    }

    {
        DWORD   dwNeededSize = sizeof (LINECALLLIST) +
                    pConfCallList->dwNumUsedEntries * sizeof (HCALL);


        if (dwTotalSize < dwNeededSize)
        {
            pCallList->dwNeededSize = dwNeededSize;
            pCallList->dwUsedSize = sizeof (LINECALLLIST);

            FillMemory (&pCallList->dwCallsNumEntries, 3 * sizeof (DWORD), 0);

            goto LGetConfRelatedCalls_fillInList;
        }
    }


    //
    // For each call in the conf list see if the app has a
    // call client (if not create one w/ monitor privileges)
    // and add it to the list
    //

    {
        DWORD   dwNumCallsInList = 0, i;
        LPHCALL lphCallsInList = (LPHCALL) (pCallList + 1);


        for (i = 0; i < pConfCallList->dwNumUsedEntries; i++)
        {
            PTCALL  ptCall = pConfCallList->aEntries[i];


            if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
            {
                ptCallClient = ptCall->ptCallClients;

                while (ptCallClient &&
                        (ptCallClient->ptLineClient != ptLineClient))
                {
                    ptCallClient = ptCallClient->pNextSametCall;
                }

                if (!ptCallClient)
                {
                    LONG    lResult;

                    if ((lResult = CreatetCallClient(
                            ptCall,
                            ptLineClient,
                            LINECALLPRIVILEGE_MONITOR,
                            TRUE,
                            TRUE,
                            &ptCallClient,
                            FALSE
                            )))
                    {
                        // Skip...
                        UNLOCKTCALL(ptCall);
                        continue;
                    }
                }

                *(lphCallsInList++) = ptCallClient->hCall;
                dwNumCallsInList++;

                UNLOCKTCALL(ptCall);
            }
        }

        pCallList->dwUsedSize        =
        pCallList->dwNeededSize      = sizeof (LINECALLLIST) +
                                           dwNumCallsInList * sizeof (HCALL);

        pCallList->dwCallsNumEntries = dwNumCallsInList;
        pCallList->dwCallsSize       = dwNumCallsInList * sizeof (HCALL);
        pCallList->dwCallsOffset     = sizeof (LINECALLLIST);
    }


LGetConfRelatedCalls_fillInList:

    if (pConfCallList != &confCallList)
    {
        ServerFree (pConfCallList);
    }

    pCallList->dwTotalSize = dwTotalSize;

    pParams->dwCallListOffset = 0;

    *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pCallList->dwUsedSize;

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineGetConfRelatedCalls: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "lineGetConfRelatedCalls: exit, result=x%x",
            pParams->lResult
            ));
#endif
}


void
WINAPI
LGetCountry(
    PTCLIENT                ptClient,
    PLINEGETCOUNTRY_PARAMS  pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    LPLINECOUNTRYLIST pCountryList = (LPLINECOUNTRYLIST) pDataBuf;
    LPLINECOUNTRYLIST pCountries = NULL;

    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwCountryListTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if (pParams->dwCountryListTotalSize < sizeof (LINECOUNTRYLIST))
    {
        pParams->lResult = LINEERR_STRUCTURETOOSMALL;
    }
    else
    {

        BuildCountryListCache();

        if (pParams->dwCountryID == 0)
        {
            //
            // Client wants entire country list
            //

            if (RPC_S_OK != RpcImpersonateClient(0))
            {
                pParams->lResult = LINEERR_OPERATIONFAILED;
                return;
            }
            pCountries = BuildCountryList();
            RpcRevertToSelf();

            if (NULL == pCountries)
            {
                pParams->lResult = LINEERR_OPERATIONFAILED;
                return;
            }

            if (pParams->dwCountryListTotalSize >= pCountries->dwNeededSize)
            {
                CopyMemory(
                    pCountryList,
                    pCountries,
                    pCountries->dwUsedSize
                    );
            }
            else
            {
                pCountryList->dwNeededSize = pCountries->dwNeededSize;
                pCountryList->dwUsedSize   = sizeof(LINECOUNTRYLIST);
                pCountryList->dwNumCountries      = 0;
                pCountryList->dwCountryListSize   = 0;
                pCountryList->dwCountryListOffset = 0;
            }

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                 pCountryList->dwUsedSize;

            pCountryList->dwTotalSize = pParams->dwCountryListTotalSize;

            ServerFree(pCountries);
        }
        else
        {
            //
            // Caller wants single country
            //

            LPLINECOUNTRYLIST   pBuildCountryList;


            if ( NULL == ( pBuildCountryList = ServerAlloc( sizeof(LINECOUNTRYLIST) +
                                                       sizeof(LINECOUNTRYENTRY) +
                                                       ((MAXLEN_NAME +
                                                         MAXLEN_RULE +
                                                         MAXLEN_RULE +
                                                         MAXLEN_RULE +
                                                         100) * sizeof(WCHAR))
                                                     ) ) )
            {
                LOG((TL_ERROR, "Alloc failed for countrylist"));
                pParams->lResult = LINEERR_NOMEM;
            }
            else
            {
                LPLINECOUNTRYENTRY  pCountryEntrySource;
                LPLINECOUNTRYENTRY  pCountryEntryDest;


                pCountryEntryDest = (LPLINECOUNTRYENTRY)((PBYTE)pBuildCountryList +
                                            sizeof(LINECOUNTRYLIST));

                //
                // search through the gpCountryList looking for the entry
                //

                pCountryEntrySource = (LPLINECOUNTRYENTRY)((PBYTE)gpCountryList +
                                            sizeof(LINECOUNTRYLIST));

                while (
                         (pCountryEntrySource->dwCountryID != pParams->dwCountryID )
                       &&
                         (pCountryEntrySource->dwNextCountryID)
                      )
                {
                    pCountryEntrySource++;
                }


                if ( pCountryEntrySource->dwCountryID != pParams->dwCountryID )
                {
                    LOG((TL_ERROR, "Invalid Countrycode (%ld) in lineGetCountry",
                                    pParams->dwCountryID));
                    pParams->lResult = LINEERR_INVALCOUNTRYCODE;
                }
                else
                {
                    PBYTE pCountryListToUse;
                    PBYTE pVarOffset;
                    PBYTE pOverrideList = NULL;
                    DWORD dwNeededSize;
                    DWORD dwResourceId;
                    DWORD dwNameSize;
                    WCHAR sz[MAXLEN_NAME];

                    //
                    // Is the caller calling a specific country that there might be
                    // an override for?
                    //

                    if ( pParams->dwDestCountryID != 0 )
                    {
                        HKEY hKey;
                        HKEY hKey2;
                        TCHAR p[256];
                        
                        wsprintf(
                            p,
                            TEXT("Country List\\%ld\\Exceptions\\%ld"),
                            pParams->dwCountryID,
                            pParams->dwDestCountryID
                            );

                        //
                        // Is there an exception?
                        //

                        if (0 == RegOpenKeyEx (HKEY_LOCAL_MACHINE, gszRegKeyTelephony, 0, KEY_READ, &hKey2) &&
                            0 == RegOpenKeyEx (hKey2, p, 0, KEY_READ, &hKey))
                        {
                            PBYTE pVarOffset;

                            pOverrideList = ServerAlloc(
                                sizeof(LINECOUNTRYLIST) +
                                sizeof(LINECOUNTRYENTRY) +
                                ((MAXLEN_NAME +
                                     MAXLEN_RULE +
                                     MAXLEN_RULE +
                                     MAXLEN_RULE +
                                     100) * sizeof(WCHAR))
                                );
                            if (!pOverrideList)
                            {
                                ServerFree (pBuildCountryList);
                                RegCloseKey (hKey2);
                                RegCloseKey (hKey);
                                pParams->lResult = LINEERR_NOMEM;
                                return;
                            }

                            pCountryListToUse = pOverrideList;

                            pCountryEntrySource = (LPLINECOUNTRYENTRY)
                                (pOverrideList +
                                sizeof(LINECOUNTRYLIST));

                            pVarOffset = pOverrideList +
                                sizeof(LINECOUNTRYLIST) +
                                sizeof(LINECOUNTRYENTRY);

                            FillupACountryEntry(
                                hKey,
                                pCountryListToUse,
                                pCountryEntrySource,
                                &pVarOffset
                                );

                            RegCloseKey( hKey );
                        }
                        else
                        {
                            //
                            // No, we tried, but there was no exception.
                            //

                            pCountryListToUse = (PBYTE)gpCountryList;
                        }

                        RegCloseKey( hKey2);
                    }
                    else
                    {
                        pCountryListToUse = (PBYTE)gpCountryList;
                    }


                    //
                    // Fill in the buffer
                    //

                    dwNeededSize = sizeof(LINECOUNTRYLIST) +
                                   sizeof(LINECOUNTRYENTRY);

                    pVarOffset = (LPBYTE)pCountryEntryDest +
                                      sizeof(LINECOUNTRYENTRY);

                    //
                    // The name field has the resource string ID
                    // Need to load the actual string based on current user's language
                    //
                    
                    CopyMemory(
                        &dwResourceId,
                        pCountryListToUse + pCountryEntrySource->dwCountryNameOffset,
                        sizeof(DWORD)
                        );

                    if (RPC_S_OK != RpcImpersonateClient(0))
                    {
                        ServerFree (pBuildCountryList);
                        pParams->lResult = LINEERR_OPERATIONFAILED;
                        return;
                    }
                    if (0 == LoadStringW(
                            ghInstance,
                            dwResourceId,
                            sz,
                            ARRAYSIZE(sz)
                            ) 
                        )
                    {
                        RpcRevertToSelf();
                        ServerFree (pBuildCountryList);
                        pParams->lResult = LINEERR_OPERATIONFAILED;
                        return;
                    }
                        
                    RpcRevertToSelf();

                    dwNameSize = (wcslen(sz) + 1) * sizeof(WCHAR);
                    CopyMemory(
                        pVarOffset,
                        (LPBYTE)sz,
                        dwNameSize
                        );

                    pCountryEntryDest->dwCountryNameSize = dwNameSize;

                    pCountryEntryDest->dwCountryNameOffset =
                                 (DWORD) (pVarOffset - (LPBYTE) pBuildCountryList);
                    pVarOffset += dwNameSize;
                    dwNeededSize += dwNameSize;


                    CopyMemory(
                        pVarOffset,
                        pCountryListToUse +
                            pCountryEntrySource->dwSameAreaRuleOffset,
                        pCountryEntrySource->dwSameAreaRuleSize
                        );

                    pCountryEntryDest->dwSameAreaRuleSize =
                               pCountryEntrySource->dwSameAreaRuleSize;
                    pCountryEntryDest->dwSameAreaRuleOffset =
                                 (DWORD) (pVarOffset - (LPBYTE) pBuildCountryList);
                    pVarOffset += pCountryEntrySource->dwSameAreaRuleSize;
                    dwNeededSize += pCountryEntrySource->dwSameAreaRuleSize;


                    CopyMemory(
                        pVarOffset,
                        pCountryListToUse +
                            pCountryEntrySource->dwLongDistanceRuleOffset,
                        pCountryEntrySource->dwLongDistanceRuleSize
                        );

                    pCountryEntryDest->dwLongDistanceRuleSize =
                               pCountryEntrySource->dwLongDistanceRuleSize;
                    pCountryEntryDest->dwLongDistanceRuleOffset =
                                 (DWORD) (pVarOffset - (LPBYTE) pBuildCountryList);
                    pVarOffset += pCountryEntrySource->dwLongDistanceRuleSize;
                    dwNeededSize += pCountryEntrySource->dwLongDistanceRuleSize;


                    CopyMemory(
                        pVarOffset,
                        pCountryListToUse +
                            pCountryEntrySource->dwInternationalRuleOffset,
                        pCountryEntrySource->dwInternationalRuleSize
                        );

                    pCountryEntryDest->dwInternationalRuleSize =
                               pCountryEntrySource->dwInternationalRuleSize;
                    pCountryEntryDest->dwInternationalRuleOffset =
                                 (DWORD) (pVarOffset - (LPBYTE) pBuildCountryList);
                    pVarOffset += pCountryEntrySource->dwInternationalRuleSize;
                    dwNeededSize += pCountryEntrySource->dwInternationalRuleSize;


                    //
                    // Is there room to put this country's info?
                    //
                    if (pParams->dwCountryListTotalSize >= dwNeededSize)
                    {
                        pCountryList->dwUsedSize          = dwNeededSize;
                        pCountryList->dwNumCountries      = 1;
                        pCountryList->dwCountryListSize   = sizeof(LINECOUNTRYENTRY);
                        pCountryList->dwCountryListOffset = sizeof(LINECOUNTRYLIST);

                        pCountryEntryDest->dwCountryID     = pParams->dwCountryID;
                        pCountryEntryDest->dwCountryCode   =
                                 pCountryEntrySource->dwCountryCode;
                        pCountryEntryDest->dwNextCountryID  =
                                 pCountryEntrySource->dwNextCountryID;

                        CopyMemory(
                            (LPBYTE)pCountryList + sizeof(LINECOUNTRYLIST),
                            (LPBYTE)pBuildCountryList + sizeof(LINECOUNTRYLIST),
                            pCountryList->dwUsedSize - sizeof(LINECOUNTRYLIST)
                            );
                    }
                    else
                    {
                        //
                        // Buffer not large enough
                        //

                        pCountryList->dwUsedSize          = sizeof(LINECOUNTRYLIST);
                        pCountryList->dwNumCountries      = 0;
                        pCountryList->dwCountryListSize   = 0;
                        pCountryList->dwCountryListOffset = 0;
                    }

                    pCountryList->dwNeededSize = dwNeededSize;
                    pCountryList->dwTotalSize = pParams->dwCountryListTotalSize;

                    *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                        pCountryList->dwUsedSize;


                    //
                    // Did we have a "special" case?
                    //
                    if ( pOverrideList )
                    {
                        ServerFree( pOverrideList );
                    }

                }

                ServerFree( pBuildCountryList );
            }
        }
    }
    pParams->dwCountryListOffset = 0;

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineGetCountry: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "lineGetCountry: exit, result=x%x",
            pParams->lResult
            ));
#endif
}

void
WINAPI
LGetCountryGroups(
    PTCLIENT                ptClient,
    PLINEGETCOUNTRYGROUP_PARAMS  pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    DWORD           dwCount, dwIdx, dwIdx1;
    BOOL            bFoundAll = TRUE;
    DWORD *         pCountryGroups = NULL;
    DWORD *         pCountryID;
    LPLINECOUNTRYENTRY  pCountryEntry;

    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwCountryIdSize > dwParamsBufferSize   ||
        0 == pParams->dwCountryIdSize                   ||
        pParams->dwCountryIdSize > pParams->dwCountryGroupSize
       )
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }

    dwCount = pParams->dwCountryIdSize / sizeof(DWORD);
    
    BuildCountryListCache();

    if (NULL == gpCountryGroups)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }

    ASSERT( NULL != gpCountryList );

    pCountryGroups = ServerAlloc (pParams->dwCountryIdSize);
    if (NULL == pCountryGroups)
    {
        pParams->lResult = LINEERR_NOMEM;
        return;
    }


        
    pCountryID = (DWORD*)(pDataBuf + pParams->dwCountryIdOffset);
    for( dwIdx = 0; dwIdx < dwCount; dwIdx++, pCountryID++ )
    {
        // find the country 
        pCountryEntry = (LPLINECOUNTRYENTRY)
            ((LPBYTE) gpCountryList + gpCountryList->dwCountryListOffset);

        for( dwIdx1 = 0; dwIdx1 < gpCountryList->dwNumCountries; dwIdx1++, pCountryEntry++ )
        {
            if (pCountryEntry->dwCountryID == *pCountryID)
            {
                pCountryGroups[ dwIdx ] = gpCountryGroups[ dwIdx1 ];
                break;
            }
        }
        if (dwIdx1 == gpCountryList->dwNumCountries)
        {
            LOG((TL_ERROR, "Invalid CountryID (%ld) in lineGetCountryGroup",
                                pCountryEntry->dwCountryID));

            bFoundAll = FALSE;
            break;
        }
    }

    if (bFoundAll)
    {
        pParams->dwCountryGroupOffset = pParams->dwCountryIdOffset;
        pParams->dwCountryGroupSize = pParams->dwCountryIdSize;
        memset( pDataBuf + pParams->dwCountryGroupOffset, 0, pParams->dwCountryGroupSize );
        CopyMemory(
                    pDataBuf + pParams->dwCountryGroupOffset,
                    pCountryGroups,
                    pParams->dwCountryIdSize
                    );

        *pdwNumBytesReturned = sizeof (TAPI32_MSG) + 
            pParams->dwCountryGroupOffset +
            pParams->dwCountryGroupSize;
    }
    else
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
    }

    ServerFree (pCountryGroups);

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "LGetCountryGroups: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "LGetCountryGroups: exit, result=x%x",
            pParams->lResult
            ));
#endif
}


void
WINAPI
LGetDevCaps(
    PTCLIENT                ptClient,
    PLINEGETDEVCAPS_PARAMS  pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    DWORD               dwDeviceID;
    HANDLE              hMutex;
    TSPIPROC            pfnTSPI_lineGetDevCaps;
    DWORD               objectToDereference;
    PTLINELOOKUPENTRY   pLookupEntry;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwDevCapsTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            DEVICE_ID,                  // widget type
            (DWORD) pParams->hLineApp,  // client widget handle
            &dwDeviceID,                // provider widget handle
            pParams->dwDeviceID,        // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEGETDEVCAPS,          // provider func index
            &pfnTSPI_lineGetDevCaps,    // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &pLookupEntry,              // context
            "GetDevCaps"                // func name

            )) == 0)
    {
        DWORD           dwAPIVersion, dwSPIVersion, dwTotalSize,
                        dwFixedSizeClient, dwFixedSizeSP;
        LPLINEDEVCAPS   pDevCaps = (LPLINEDEVCAPS) pDataBuf,
                        pDevCaps2 = (LPLINEDEVCAPS) NULL;


        //
        // Verify API & SPI version compatibility
        //

        dwAPIVersion = pParams->dwAPIVersion;

        dwSPIVersion = pLookupEntry->dwSPIVersion;

        if (!IsAPIVersionInRange (dwAPIVersion, dwSPIVersion))
        {
            pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
            goto LGetDevCaps_epilog;
        }


        //
        // Verify Ext version compatibility
        //

        if (!IsValidLineExtVersion (dwDeviceID, pParams->dwExtVersion))
        {
            pParams->lResult = LINEERR_INCOMPATIBLEEXTVERSION;
            goto LGetDevCaps_epilog;
        }


        //
        // Determine the fixed size of the structure for the specified API
        // version, verify client's buffer is big enough
        //

        dwTotalSize = pParams->dwDevCapsTotalSize;

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:

            dwFixedSizeClient = 236;    // 47 * sizeof (DWORD) +
                                        //     3 * sizeof (LINEDIALPARAMS)
            break;

        case TAPI_VERSION1_4:

            dwFixedSizeClient = 240;    // 48 * sizeof (DWORD) +
                                        //     3 * sizeof (LINEDIALPARAMS)
            break;

        case TAPI_VERSION2_0:
        case TAPI_VERSION2_1:

            dwFixedSizeClient = 252;    // 51 * sizeof (DWORD) +
                                        //     3 * sizeof (LINEDIALPARAMS)
            break;

        case TAPI_VERSION2_2:

            dwFixedSizeClient = 268;    // 51 * sizeof (DWORD) +
                                        //     3 * sizeof (LINEDIALPARAMS) +
                                        //     sizeof (GUID)
            break;

        default: // (fix ppc build wrn) case TAPI_VERSION_CURRENT:

            dwFixedSizeClient = sizeof (LINEDEVCAPS);
            break;
        }

        if (dwTotalSize < dwFixedSizeClient)
        {
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
            goto LGetDevCaps_epilog;
        }


        //
        // Determine the fixed size of the structure expected by the SP
        //

        switch (dwSPIVersion)
        {
        case TAPI_VERSION1_0:

            dwFixedSizeSP = 236;        // 47 * sizeof (DWORD) +
                                        //     3 * sizeof (LINEDIALPARAMS)
            break;

        case TAPI_VERSION1_4:

            dwFixedSizeSP = 240;        // 48 * sizeof (DWORD) +
                                        //     3 * sizeof (LINEDIALPARAMS)
            break;

        case TAPI_VERSION2_0:
        case TAPI_VERSION2_1:

            dwFixedSizeSP = 252;        // 51 * sizeof (DWORD) +
                                        //     3 * sizeof (LINEDIALPARAMS)
            break;

        case TAPI_VERSION2_2:

            dwFixedSizeSP = 268;        // 51 * sizeof (DWORD) +
                                        //     3 * sizeof (LINEDIALPARAMS) +
                                        //     sizeof (GUID)
            break;

        default: // (fix ppc build wrn) case TAPI_VERSION_CURRENT:

            dwFixedSizeSP = sizeof (LINEDEVCAPS);
            break;
        }


        //
        // If the client's buffer is < the fixed size of that expected by
        // the SP (client is lower version than SP) then allocate an
        // intermediate buffer
        //

        if (dwTotalSize < dwFixedSizeSP)
        {
            if (!(pDevCaps2 = ServerAlloc (dwFixedSizeSP)))
            {
                pParams->lResult = LINEERR_NOMEM;
                goto LGetDevCaps_epilog;
            }

            pDevCaps    = pDevCaps2;
            dwTotalSize = dwFixedSizeSP;
        }


        InitTapiStruct(
            pDevCaps,
            dwTotalSize,
            dwFixedSizeSP,
            (pDevCaps2 == NULL ? TRUE : FALSE)
            );

        if (pLookupEntry->bRemoved)
        {
            ServerFree (pDevCaps2);
            pParams->lResult = LINEERR_NODEVICE;
        }
        else if ((pParams->lResult = CallSP4(
                pfnTSPI_lineGetDevCaps,
                "lineGetDevCaps",
                SP_FUNC_SYNC,
                (DWORD) dwDeviceID,
                (DWORD) dwSPIVersion,
                (DWORD) pParams->dwExtVersion,
                (ULONG_PTR) pDevCaps

                )) == 0)
        {
#if DBG
            //
            // Verify the info returned by the provider
            //

#endif


            //
            // Add the fields we're responsible for
            //

            pDevCaps->dwLineStates |= LINEDEVSTATE_OPEN |
                                      LINEDEVSTATE_CLOSE |
                                      LINEDEVSTATE_REINIT |
                                      LINEDEVSTATE_TRANSLATECHANGE;


            if (dwAPIVersion >= TAPI_VERSION3_0)
            {
                pDevCaps->dwAvailableTracking |=
                    LINECALLHUBTRACKING_ALLCALLS;
            }


            //
            // Munge fields where appropriate for old apps (don't want to
            // pass back flags that they won't understand)
            //

            if ((dwAPIVersion == TAPI_VERSION1_0) &&
                (pDevCaps->dwMediaModes & LINEMEDIAMODE_VOICEVIEW))
            {
                pDevCaps->dwMediaModes = LINEMEDIAMODE_UNKNOWN |
                    (pDevCaps->dwMediaModes & ~LINEMEDIAMODE_VOICEVIEW);
            }

            if ((dwAPIVersion < TAPI_VERSION2_1) &&
                (pDevCaps->dwMediaModes & LINEMEDIAMODE_VIDEO))
            {
                pDevCaps->dwMediaModes = LINEMEDIAMODE_UNKNOWN |
                    (pDevCaps->dwMediaModes & ~LINEMEDIAMODE_VIDEO);
            }


            //
            // If an intermediate buffer was used then copy the bits back
            // to the the original buffer, & free the intermediate buffer.
            // Also reset the dwUsedSize field to the fixed size of the
            // structure for the specifed version, since any data in the
            // variable portion is garbage as far as the client is concerned.
            //

            if (pDevCaps == pDevCaps2)
            {
                pDevCaps = (LPLINEDEVCAPS) pDataBuf;

                CopyMemory (pDevCaps, pDevCaps2, dwFixedSizeClient);

                ServerFree (pDevCaps2);

                pDevCaps->dwTotalSize = pParams->dwDevCapsTotalSize;
                pDevCaps->dwUsedSize  = dwFixedSizeClient;
            }


            //
            // Indicate the offset & how many bytes of data we're passing back
            //

            pParams->dwDevCapsOffset = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                pDevCaps->dwUsedSize;
        }
        else
        {
            ServerFree (pDevCaps2);
        }
    }

LGetDevCaps_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetDevCaps"
        );
}


void
WINAPI
LGetDevConfig(
    PTCLIENT                    ptClient,
    PLINEGETDEVCONFIG_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    DWORD               dwDeviceID;
    HANDLE              hMutex;
    TSPIPROC            pfnTSPI_lineGetDevConfig;
    DWORD               objectToDereference;
    PTLINELOOKUPENTRY   pLookupEntry;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if ((pParams->dwDeviceConfigTotalSize > dwParamsBufferSize) ||

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDeviceClassOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            DEVICE_ID,                  // widget type
            0,                          // client widget handle
            &dwDeviceID,                // provider widget handle
            pParams->dwDeviceID,       // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEGETDEVCONFIG,        // provider func index
            &pfnTSPI_lineGetDevConfig,  // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &pLookupEntry,              // context
            "GetDevConfig"              // func name

            )) == 0)
    {
        WCHAR      *pszDeviceClass;
        LPVARSTRING pConfig = (LPVARSTRING) pDataBuf;


        //
        // Alloc a temporary buf for the dev class, since we'll be using
        // the existing buffer for output
        //

        if (!(pszDeviceClass = (WCHAR *) ServerAlloc( sizeof(WCHAR) * ( 1 +
                lstrlenW((PWSTR)(pDataBuf + pParams->dwDeviceClassOffset)))
                )))
        {
            pParams->lResult = LINEERR_NOMEM;
            goto LGetDevConfig_epilog;
        }

        wcscpy(
            pszDeviceClass,
            (PWSTR)(pDataBuf + pParams->dwDeviceClassOffset)
            );

        if (!InitTapiStruct(
                pConfig,
                pParams->dwDeviceConfigTotalSize,
                sizeof (VARSTRING),
                TRUE
                ))
        {
            ServerFree (pszDeviceClass);
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
            goto LGetDevConfig_epilog;
        }

        if (pLookupEntry->bRemoved)
        {
            ServerFree (pszDeviceClass);
            pParams->lResult = LINEERR_NODEVICE;
            goto LGetDevConfig_epilog;
        }

        if ((pParams->lResult = CallSP3(
                pfnTSPI_lineGetDevConfig,
                "lineGetDevConfig",
                SP_FUNC_SYNC,
                (DWORD) dwDeviceID,
                (ULONG_PTR) pConfig,
                (ULONG_PTR) pszDeviceClass

                )) == 0)
        {
            //
            // Indicate how many bytes of data we're passing back
            //

            pParams->dwDeviceConfigOffset = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                pConfig->dwUsedSize;
        }

        ServerFree (pszDeviceClass);
    }

LGetDevConfig_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetDevConfig"
        );
}


void
WINAPI
LGetGroupList(
    PTCLIENT                    ptClient,
    PLINEGETGROUPLIST_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    //
    // note: can't use lgetagentxxx because
    // pparams don't match
    //

    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "GetGroupList"              // func name

            )) > 0)
    {
        LONG            lResult;
        DWORD           dwDeviceID, dwTotalSize =pParams->dwGroupListTotalSize;
        PTLINECLIENT    pProxy;


        if (dwTotalSize < sizeof(LINEAGENTGROUPLIST))
        {
            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LGetGroupList_epilog;
        }

        if ((lResult = FindProxy(
                ptLineClient,
                0,
                LINEPROXYREQUEST_GETGROUPLIST,
                &pProxy,
                &dwDeviceID,
                TAPI_VERSION2_2
                )))
        {
            lRequestID = lResult;
            goto LGetGroupList_epilog;
        }


        //
        // Save the client's buf ptr & post processing proc ptr
        //

        pAsyncRequestInfo->dwParam1 = pParams->hpGroupList;
        pAsyncRequestInfo->dwParam2 = dwTotalSize;
        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;


        //
        // First check to see if there's a (local) proxy registered
        // for this type of request on this line.  If so, build a
        // request & send it to the proxy.
        //

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_GETGROUPLIST,
                    dwTotalSize,
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LGetGroupList_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.GetGroupList.
                GroupList.dwTotalSize = dwTotalSize;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LGetGroupList_epilog;
            }
            else // success
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


        //
        // There's no proxy, so check to see if line is remote and
        // call remotesp if so
        //

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            LPBYTE                  pBuf;
            LPLINEAGENTGROUPLIST    pGroupList;


            //
            // Alloc a shadow buf that the SP can use until it completes this
            // request.  Make sure there's enough extra space in the buf for
            // an ASYNCEVENTMSG header so we don't have to alloc yet another
            // buf in the post processing proc when preparing the completion
            // msg to send to the client, and that the msg is 64-bit aligned.
            //

            if (!(pBuf = ServerAlloc(
                    sizeof (ASYNCEVENTMSG) + ((dwTotalSize + 7) & 0xfffffff8)
                    )))
            {
                lRequestID = LINEERR_NOMEM;
                goto LGetGroupList_epilog;
            }

            pAsyncRequestInfo->pfnPostProcess =
                LGetAgentXxx_PostProcess;

            pAsyncRequestInfo->dwParam3 = (ULONG_PTR) pBuf;

            pGroupList = (LPLINEAGENTGROUPLIST)
                (pBuf + sizeof (ASYNCEVENTMSG));

            pGroupList->dwTotalSize = dwTotalSize;

            pParams->lResult = CallSP3(
                pRemoteSP->apfn[SP_LINEGETGROUPLIST],
                "GetGroupList",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (ULONG_PTR) pGroupList
                );
        }


        //
        // There's no registered proxy & line is not remote, so fail
        //

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LGetGroupList_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "GetGroupList"
        );

}

void
WINAPI
LGetHubRelatedCalls(
    PTCLIENT                        ptClient,
    PLINEGETHUBRELATEDCALLS_PARAMS  pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    DWORD               dwTotalSize = pParams->dwCallListTotalSize,
                        dwNeededSize, dwUsedSize, dwCallHubID, i, j;
    PTCALL              ptCall;
    PTLINEAPP           ptLineApp;
    PTPROVIDER          ptProvider;
    TPOINTERLIST        fastCallList = {0}, *pCallList = &fastCallList;
    PTCALLCLIENT        ptCallClient;
    PTCALLHUBCLIENT     ptCallHubClient;
    PTHASHTABLEENTRY    pEntry;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwCallListTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    //
    // State/param validation
    //

    if (TapiGlobals.dwNumLineInits == 0)
    {
        pParams->lResult = LINEERR_UNINITIALIZED;
        goto LGetHubRelatedCalls_exit;
    }

    if (dwTotalSize < sizeof (LINECALLLIST))
    {
        pParams->lResult = LINEERR_STRUCTURETOOSMALL;
        goto LGetHubRelatedCalls_exit;
    }


    //
    // Determine the associated tProvider, call hub id, & tLineApp
    // (assume failure, resetting lResult to 0 only when we're sure
    // we're ok)
    //

    pParams->lResult = LINEERR_INVALCALLHANDLE;

    if (pParams->hCallHub)
    {
        if (!pParams->hCall  &&

            (ptCallHubClient = IsValidCallHub(
                pParams->hCallHub,
                ptClient
                )))
        {
            try
            {
                ptProvider = ptCallHubClient->ptProvider;
                dwCallHubID = ptCallHubClient->dwCallHubID;
                ptLineApp = ptCallHubClient->ptLineApp;

                if (ptCallHubClient->dwKey == TCALLHUBCLIENT_KEY)
                {
                    pParams->lResult = 0;
                }
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                // do nothing, error handled below
            }
        }
    }
    else
    {
        if ((ptCallClient = ReferenceCall(
                pParams->hCall,
                ptClient
                )))
        {
            try
            {
                if ((dwCallHubID = ptCallClient->ptCall->dwCallID))
                {
                    ptProvider = ptCallClient->ptCall->ptProvider;
                    ptLineApp = ptCallClient->ptLineClient->ptLineApp;

                    if (ptCallClient->dwKey == TCALLCLIENT_KEY)
                    {
                        pParams->lResult = 0;
                        ptCallHubClient = NULL;
                    }
                }
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                // do nothing, error handled below
            }

            DereferenceObject (ghHandleTable, pParams->hCall, 1);
        }
    }

    if (pParams->lResult != 0)
    {
        goto LGetHubRelatedCalls_exit;
    }


    //
    // Get the list of tCall's for this tProvider/CallHubID.  Also, if
    // the tCallHubClient is not already known then try to find it.
    //

    pEntry = AcquireHashTableEntryLock (ptProvider, dwCallHubID);

    if (!pEntry)
    {
        pParams->lResult = LINEERR_INVALCALLHANDLE;
        goto LGetHubRelatedCalls_exit;
    }

    if (pEntry->dwCallHubID != dwCallHubID)
    {
        ReleaseHashTableEntryLock (ptProvider, pEntry);
        pParams->lResult = LINEERR_INVALCALLHANDLE;
        goto LGetHubRelatedCalls_exit;
    }

    if (!ptCallHubClient)
    {
        ptCallHubClient = pEntry->ptCallHubClients;

        while (ptCallHubClient  &&  ptCallHubClient->ptLineApp != ptLineApp)
        {
            ptCallHubClient = ptCallHubClient->pNext;
        }


        //
        // If there's no tCallHubClient then there's no call hub as far
        // as this app is concerned
        //

        if (!ptCallHubClient)
        {
            ReleaseHashTableEntryLock (ptProvider, pEntry);
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LGetHubRelatedCalls_exit;
        }
    }

    GetList (&pEntry->CallHubList, &pCallList);

    ReleaseHashTableEntryLock (ptProvider, pEntry);


    //
    // Insert the hCallHub at the front of the call list
    //

    dwNeededSize = sizeof (LINECALLLIST) + sizeof (HCALLHUB);

    if (dwNeededSize <= dwTotalSize)
    {
        *((LPHCALLHUB)(pDataBuf + sizeof (LINECALLLIST))) = 
                                            ptCallHubClient->hCallHub;

        dwUsedSize = dwNeededSize;
    }
    else
    {
        dwUsedSize = sizeof (LINECALLLIST);
    }

    //
    // For each of the tCall in the list get the list of tCallClients,
    // then for each tCallClient see if it's on the same tLineApp
    // as the specified call/hub, & if so add it to the list
    //

    for (i = 0; i < pCallList->dwNumUsedEntries; i++)
    {
        TPOINTERLIST    fastCallClientList,
                       *pCallClientList = &fastCallClientList;


        ptCall = CONTAINING_RECORD(
            pCallList->aEntries[i],
            TCALL,
            CallHubList
            );

        if (GetCallClientListFromCall (ptCall, &pCallClientList) != 0)
        {
            continue;
        }

        for (j = 0; j < pCallClientList->dwNumUsedEntries; j++)
        {
            PTCALLCLIENT    ptCallClient = pCallClientList->aEntries[j];

            try
            {
                if ((ptCallClient->ptLineClient->ptLineApp == ptLineApp)  &&
                    (ptCallClient->dwKey == TCALLCLIENT_KEY))
                {
                    if (!ptCallClient->ptCallHubClient)
                    {
                        ptCallClient->ptCallHubClient = ptCallHubClient;
                    }

                    if ((dwUsedSize + sizeof(HCALL)) <= dwTotalSize)
                    {
                        *((LPHCALL)(pDataBuf + dwUsedSize)) =
                            ptCallClient->hCall;

                        dwUsedSize += sizeof(HCALL);
                    }

                    dwNeededSize += sizeof(HCALL);
                }
            }
            except (EXCEPTION_EXECUTE_HANDLER)
            {
                // do nothing, this call not included in list
            }
        }

        if (pCallClientList != &fastCallClientList)
        {
            ServerFree (pCallClientList);
        }
    }

    if (pCallList != &fastCallList)
    {
        ServerFree (pCallList);
    }

    ((LPLINECALLLIST) pDataBuf)->dwTotalSize  = dwTotalSize;
    ((LPLINECALLLIST) pDataBuf)->dwNeededSize = dwNeededSize;
    ((LPLINECALLLIST) pDataBuf)->dwUsedSize   = dwUsedSize;
    ((LPLINECALLLIST) pDataBuf)->dwCallsSize  = dwUsedSize -
        sizeof (LINECALLLIST);
    ((LPLINECALLLIST) pDataBuf)->dwCallsNumEntries =
        ((LPLINECALLLIST) pDataBuf)->dwCallsSize / sizeof (HCALL);
    ((LPLINECALLLIST) pDataBuf)->dwCallsOffset     = sizeof (LINECALLLIST);

    pParams->dwCallListOffset = 0;

    *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
        ((LPLINECALLLIST) pDataBuf)->dwUsedSize;

LGetHubRelatedCalls_exit:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineGetHubRelatedCalls: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "lineGetHubRelatedCalls: exit, result=x%x",
            pParams->lResult
            ));
#endif

    return;
}


void
WINAPI
LGetIcon(
    PTCLIENT            ptClient,
    PLINEGETICON_PARAMS pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    //
    // Note: Icons are Windows NT User Objects, so. HICONs are public to
    //       all processes, and do not need to be dup'd.
    //

    BOOL                bCloseMutex;
    WCHAR              *pszDeviceClass;
    DWORD               dwDeviceID;
    HANDLE              hMutex;
    TSPIPROC            pfnTSPI_lineGetIcon;
    DWORD               objectToDereference;
    PTLINELOOKUPENTRY   pLookupEntry;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if ((pParams->dwDeviceClassOffset != TAPI_NO_DATA)  &&

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDeviceClassOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    pszDeviceClass = (WCHAR *) (pParams->dwDeviceClassOffset == TAPI_NO_DATA ?
        NULL : pDataBuf + pParams->dwDeviceClassOffset);

    if ((pParams->lResult = LINEPROLOG(
            ptClient,                   // tClient
            DEVICE_ID,                  // widget type
            0,                          // client widget handle
            &dwDeviceID,                // provider widget handle
            pParams->dwDeviceID,        // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEGETICON,             // provider func index
            &pfnTSPI_lineGetIcon,       // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &pLookupEntry,              // context
            "GetIcon"                   // func name

            )) == 0)
    {
        if ((pParams->lResult = CallSP3(
                pfnTSPI_lineGetIcon,
                "lineGetIcon",
                SP_FUNC_SYNC,
                (DWORD) dwDeviceID,
                (ULONG_PTR) pszDeviceClass,
                (ULONG_PTR) &pParams->hIcon

                )) == 0)
        {
            *pdwNumBytesReturned = sizeof (LINEGETICON_PARAMS);
        }
    }
    else if (pParams->lResult == LINEERR_OPERATIONUNAVAIL)
    {
        if ((pszDeviceClass == NULL) ||
            (_wcsicmp(pszDeviceClass, L"tapi/line") == 0))
        {
            pParams->hIcon = TapiGlobals.hLineIcon;
            pParams->lResult = 0;
            *pdwNumBytesReturned = sizeof (LINEGETICON_PARAMS);
        }
        else
        {
            pParams->lResult = LINEERR_INVALDEVICECLASS;
        }
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetIcon"
        );
}

void
WINAPI
LGetIDEx(
    PTCLIENT            ptClient,
    PLINEGETID_PARAMS   pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{

    LPBYTE pDeviceClass = pDataBuf + pParams->dwDeviceClassOffset;
    LPWSTR pDeviceClassCopy = NULL;
    LPWSTR szStringId1 = NULL;
    LPWSTR szStringId2 = NULL;
    LPVARSTRING pID = (LPVARSTRING) pDataBuf;
    DWORD  dwAvailSize;

    //
    // Make a copy of the device class
    //
    pDeviceClassCopy = (LPWSTR) ServerAlloc( (1 + wcslen( (LPWSTR)pDeviceClass )) * sizeof(WCHAR));
    if (!pDeviceClassCopy)
    {
        LOG((TL_ERROR, "LGetIDEx: failed to allocate DeviceClassCopy"));
        pParams->lResult = LINEERR_NOMEM;
    }

    wcscpy(pDeviceClassCopy, (LPWSTR)pDeviceClass);

    //
    // First call LGetID
    //
    LGetID( ptClient,
            pParams,
            dwParamsBufferSize,
            pDataBuf,
            pdwNumBytesReturned);

    //
    // if LGetID was successful and the request was for a wave device, 
    // translate the device ID into a string ID 
    //
    if (    (pParams->lResult == 0) &&
            !(pID->dwNeededSize > pID->dwTotalSize)
       ) 
    {
        if (!_wcsicmp((LPWSTR)pDeviceClassCopy, L"wave/in")  ||
            !_wcsicmp((LPWSTR)pDeviceClassCopy, L"wave/out") ||
            !_wcsicmp((LPWSTR)pDeviceClassCopy, L"midi/in")  ||
            !_wcsicmp((LPWSTR)pDeviceClassCopy, L"midi/out") 
           )
        {
            szStringId1 = WaveDeviceIdToStringId (
                            *(DWORD*)((LPBYTE)pID + pID->dwStringOffset), 
                            (LPWSTR)pDeviceClassCopy);
            if ( szStringId1 )
            {
                dwAvailSize = pID->dwTotalSize - pID->dwUsedSize + sizeof(DWORD);
                if ( dwAvailSize >= (wcslen(szStringId1) + 1) * sizeof(WCHAR) )
                {
                    wcscpy( (LPWSTR)((LPBYTE)pID + pID->dwStringOffset), szStringId1 );
                    pID->dwStringSize = (wcslen(szStringId1) + 1) * sizeof(WCHAR);
                    pID->dwUsedSize = pID->dwNeededSize = pID->dwUsedSize + pID->dwStringSize - sizeof(DWORD);
                    *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pID->dwUsedSize;
                }
                else
                {
                    pID->dwNeededSize = (wcslen(szStringId1) + 1) * sizeof(WCHAR);
                }

                ServerFree(szStringId1);
            }
            else
            {
                LOG((TL_ERROR, "LGetIDEx:  WaveDeviceIdToStringId failed"));
                pParams->lResult = LINEERR_OPERATIONFAILED;
            }
        } else if (!_wcsicmp((LPWSTR)pDeviceClassCopy, L"wave/in/out"))
        {
            szStringId1 = WaveDeviceIdToStringId (
                            *(DWORD*)((LPBYTE)pID + pID->dwStringOffset), 
                            L"wave/in");
            szStringId2 = WaveDeviceIdToStringId (
                            *( (DWORD*)((LPBYTE)pID + pID->dwStringOffset) + 1 ), 
                            L"wave/out");
            if ( szStringId1 && szStringId2 )
            {
                dwAvailSize = pID->dwTotalSize - pID->dwUsedSize + 2 * sizeof(DWORD);
                if ( dwAvailSize >= (wcslen(szStringId1) + wcslen(szStringId2) + 2) * sizeof(WCHAR) )
                {
                    wcscpy( (LPWSTR)((LPBYTE)pID + pID->dwStringOffset), szStringId1 );
                    wcscpy( (LPWSTR)
                        ((LPBYTE)pID + pID->dwStringOffset + 
                                      (wcslen(szStringId1) + 1) * sizeof(WCHAR)),
                        szStringId2
                        );
                    pID->dwStringSize = (wcslen(szStringId1) + wcslen(szStringId2) + 2) * sizeof(WCHAR);
                    pID->dwUsedSize = pID->dwNeededSize = pID->dwUsedSize + pID->dwStringSize - 2 * sizeof(DWORD);
                    *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pID->dwUsedSize;
                }
                else
                {
                    pID->dwNeededSize = (wcslen(szStringId1) + wcslen(szStringId2) + 2) * sizeof(WCHAR);
                }

            }
            else
            {
                LOG((TL_ERROR, "LGetIDEx:  WaveDeviceIdToStringId failed"));
                pParams->lResult = LINEERR_OPERATIONFAILED;
            }
            
            ServerFree(szStringId1);
            ServerFree(szStringId2);
        }
    }

    ServerFree(pDeviceClassCopy);
}

void
WINAPI
LGetID(
    PTCLIENT            ptClient,
    PLINEGETID_PARAMS   pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL        bCloseMutex, bSPITooLow = FALSE;
    DWORD       dwWidgetType, hWidget, dwPrivilege;
    HANDLE      hMutex;
    ULONG_PTR   hdWidget;
    LPVOID      context;
    TSPIPROC    pfnTSPI_lineGetID;
    DWORD       objectToDereference;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if ((pParams->dwDeviceIDTotalSize > dwParamsBufferSize)  ||

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDeviceClassOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    switch ( pParams->dwSelect )
    {
    case LINECALLSELECT_CALL:
    {
        dwWidgetType = ANY_RT_HCALL;
        hWidget      = pParams->hCall;
        dwPrivilege  = LINECALLPRIVILEGE_MONITOR;

        break;
    }
    case LINECALLSELECT_DEVICEID:
    {
        PTLINEAPP           ptLineApp;
        BOOL                bVersion = FALSE;
        PTLINELOOKUPENTRY   ptLineLookup;

        LOG((TL_INFO, "lineGetID:  LINECALLSELECT_DEVICEID. ptClient %p", ptClient));

        if (WaitForExclusiveClientAccess (ptClient))
        {
            ptLineApp = ptClient->ptLineApps;

            // see if any line app is > version 2.0

            while (ptLineApp)
            {
                LOG((TL_INFO, "lineGetID:  ptLineApp->dwAPIVersion %lx, TAPI_VERSION2_0 %lx", ptLineApp->dwAPIVersion, TAPI_VERSION2_0));

                if (ptLineApp->dwAPIVersion > TAPI_VERSION2_0)
                {
                    bVersion = TRUE;
                    break;
                }

                ptLineApp = ptLineApp->pNext;
            }

            UNLOCKTCLIENT (ptClient);
        }
        else
        {
            pParams->lResult = LINEERR_OPERATIONFAILED;
            return;
        }

        if (!bVersion)
        {
            LOG((TL_ERROR, "lineGetID failed with invalid call select"));
            pParams->lResult = LINEERR_INVALCALLSELECT;
            return;
        }

        // check the spi version

        ptLineLookup = GetLineLookupEntry (pParams->dwAddressID);

        if (!ptLineLookup)
        {
            LOG((TL_ERROR, "lineGetID failed with invalid device id"));

            pParams->lResult = LINEERR_BADDEVICEID;

            return;
        }

        if (ptLineLookup->ptProvider->dwSPIVersion <= TAPI_VERSION2_0)
        {
            bSPITooLow = TRUE;
        }

        dwWidgetType = DEVICE_ID;
        hWidget      = 0;
        dwPrivilege  = pParams->dwAddressID;

        break;
    }
    case LINECALLSELECT_ADDRESS:
    case LINECALLSELECT_LINE:
    {
        dwWidgetType = ANY_RT_HLINE;
        hWidget      = pParams->hLine;
        dwPrivilege  = 0;

        break;
    }
    default:

        LOG((TL_ERROR, "lineGetID failed with invalid call select"));

        pParams->lResult = LINEERR_INVALCALLSELECT;

        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            dwWidgetType,               // widget type
            hWidget,                    // client widget handle
            &hdWidget,                  // provider widget handle
            dwPrivilege,                // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEGETID,               // provider func index
            &pfnTSPI_lineGetID,         // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &context,                   // context
            "GetID"                     // func name

            )) == 0  ||  pParams->lResult == LINEERR_OPERATIONUNAVAIL)
    {
        WCHAR       *pszDeviceClass;
        LPVARSTRING pID = (LPVARSTRING) pDataBuf;


        //
        // We'll handle the "tapi/line" class right here rather than
        // burden every single driver with having to support it
        //

        if (_wcsicmp(
                (PWSTR)(pDataBuf + pParams->dwDeviceClassOffset),
                L"tapi/line"

                ) == 0)
        {
            if (!InitTapiStruct(
                    pID,
                    pParams->dwDeviceIDTotalSize,
                    sizeof (VARSTRING),
                    TRUE
                    ))
            {
                pParams->lResult = LINEERR_STRUCTURETOOSMALL;
                goto LGetID_epilog;
            }

            pID->dwNeededSize += sizeof (DWORD);

            if (pID->dwTotalSize >= pID->dwNeededSize)
            {
                try
                {
                    switch (pParams->dwSelect)
                    {
                    case LINECALLSELECT_ADDRESS:
                    {
                        if (pParams->dwAddressID >= ((PTLINECLIENT)
                                context)->ptLine->dwNumAddresses)
                        {
                            pParams->lResult = LINEERR_INVALADDRESSID;
                            goto LGetID_epilog;
                        }

                        *((LPDWORD)(pID + 1)) = ((PTLINECLIENT)
                            context)->ptLine->dwDeviceID;

                        break;
                    }

                    case LINECALLSELECT_CALL:
                    {
                        *((LPDWORD)(pID + 1)) = ((PTCALLCLIENT)
                            context)->ptCall->ptLine->dwDeviceID;

                        break;
                    }

                    case LINECALLSELECT_LINE:
                    {
                        *((LPDWORD)(pID + 1)) = ((PTLINECLIENT)
                            context)->ptLine->dwDeviceID;

                        break;
                    }

                    case LINECALLSELECT_DEVICEID:
                    {
                        *((LPDWORD)(pID + 1)) = pParams->dwAddressID;

                        break;
                    }
                    } // switch
                }
                myexcept
                {
                    switch (pParams->dwSelect)
                    {
                    case LINECALLSELECT_CALL:

                        pParams->lResult = LINEERR_INVALCALLHANDLE;
                        break;

                    case LINECALLSELECT_LINE:
                    case LINECALLSELECT_ADDRESS:

                        pParams->lResult = LINEERR_INVALLINEHANDLE;
                        break;

                    case LINECALLSELECT_DEVICEID:

                        pParams->lResult = LINEERR_BADDEVICEID;
                        break;
                    }

                    goto LGetID_epilog;
                }

                pID->dwUsedSize     += sizeof (DWORD);
                pID->dwStringFormat = STRINGFORMAT_BINARY;
                pID->dwStringSize   = sizeof (DWORD);
                pID->dwStringOffset = sizeof (VARSTRING);
            }


            //
            // Indicate offset & how many bytes of data we're passing back
            //

            pParams->lResult = 0;
            pParams->dwDeviceIDOffset = 0;
            *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pID->dwUsedSize;
            goto LGetID_epilog;
        }

        // see if they want the provider id
        if (_wcsicmp(
                (PWSTR)(pDataBuf + pParams->dwDeviceClassOffset),
                L"tapi/providerid"

                ) == 0)
        {
            if (!InitTapiStruct(
                    pID,
                    pParams->dwDeviceIDTotalSize,
                    sizeof (VARSTRING),
                    TRUE
                    ))
            {
                pParams->lResult = LINEERR_STRUCTURETOOSMALL;
                goto LGetID_epilog;
            }

            pID->dwNeededSize += sizeof (DWORD);

            if (pID->dwTotalSize >= pID->dwNeededSize)
            {
                try
                {
                    switch (pParams->dwSelect)
                    {
                    case LINECALLSELECT_ADDRESS:
                    {
                        if (pParams->dwAddressID >= ((PTLINECLIENT)
                                context)->ptLine->dwNumAddresses)
                        {
                            pParams->lResult = LINEERR_INVALADDRESSID;
                            goto LGetID_epilog;
                        }

                        *((LPDWORD)(pID + 1)) = ((PTLINECLIENT)
                            context)->ptLine->ptProvider->
                                dwPermanentProviderID;

                        break;
                    }
                    case LINECALLSELECT_DEVICEID:
                    {
                        *((LPDWORD)(pID + 1)) = ((PTLINELOOKUPENTRY)
                            context)->ptProvider->dwPermanentProviderID;

                        break;
                    }
                    case LINECALLSELECT_CALL:
                    {
                        PTCALLCLIENT    ptCallClient = (PTCALLCLIENT)
                                            context;

                        *((LPDWORD)(pID + 1)) = ptCallClient->ptLineClient->
                            ptLine->ptProvider->dwPermanentProviderID;

                        break;
                    }
                    case LINECALLSELECT_LINE:
                    {
                        *((LPDWORD)(pID + 1)) = ((PTLINECLIENT)
                            context)->ptLine->ptProvider->
                                dwPermanentProviderID;

                        break;
                    }
                    default:

                        // we've already verified the call select flags above.
                        break;
                    }
                }
                myexcept
                {
                    switch (pParams->dwSelect)
                    {
                    case LINECALLSELECT_CALL:

                        pParams->lResult = LINEERR_INVALCALLHANDLE;
                        break;

                    case LINECALLSELECT_LINE:
                    case LINECALLSELECT_ADDRESS:

                        pParams->lResult = LINEERR_INVALLINEHANDLE;
                        break;

                    case LINECALLSELECT_DEVICEID:

                        pParams->lResult = LINEERR_BADDEVICEID;
                        break;
                    }

                    goto LGetID_epilog;
                }

                pID->dwUsedSize     += sizeof (DWORD);
                pID->dwStringFormat = STRINGFORMAT_BINARY;
                pID->dwStringSize   = sizeof (DWORD);
                pID->dwStringOffset = sizeof (VARSTRING);
            }


            //
            // Indicate offset & how many bytes of data we're passing back
            //

            pParams->lResult = 0;
            pParams->dwDeviceIDOffset = 0;
            *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pID->dwUsedSize;
            goto LGetID_epilog;
        }


        if (pParams->lResult ==  LINEERR_OPERATIONUNAVAIL)
        {
            goto LGetID_epilog;
        }


        if (bSPITooLow)
        {
            pParams->lResult = LINEERR_INVALCALLSELECT;
            goto LGetID_epilog;
        }

        //
        // Alloc a temporary buf for the dev class, since we'll be using
        // the existing buffer for output
        //

        {
            UINT nStringSize;

            nStringSize = sizeof(WCHAR) * (1 + wcslen((PWSTR)(pDataBuf +
                                  pParams->dwDeviceClassOffset)));

            if (0 == nStringSize)
            {
                LOG((TL_ERROR, "Bad string size (0) in lineGetID!"));
                pParams->lResult = LINEERR_INVALPARAM;
                goto LGetID_epilog;
            }

            if (!(pszDeviceClass = (WCHAR *) ServerAlloc (nStringSize)))
            {
                LOG((TL_ERROR, "Mem failed in lineGetID!"));
                pParams->lResult = LINEERR_NOMEM;
                goto LGetID_epilog;
            }
        }

        wcscpy(
            pszDeviceClass,
            (PWSTR)(pDataBuf + pParams->dwDeviceClassOffset)
            );

        if (!InitTapiStruct(
                pID,
                pParams->dwDeviceIDTotalSize,
                sizeof (VARSTRING),
                TRUE
                ))
        {
            ServerFree (pszDeviceClass);
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
            goto LGetID_epilog;
        }


        {
            ULONG_PTR   dwCallWidgetHold = 0,
                        dwLineWidgetHold = 0;
            DWORD       dwDeviceIDHold = 0;


            switch (pParams->dwSelect)
            {
            case LINECALLSELECT_ADDRESS:

                dwDeviceIDHold = pParams->dwAddressID;
                //fall through

            case LINECALLSELECT_LINE:

                dwLineWidgetHold = hdWidget;
                break;

            case LINECALLSELECT_DEVICEID:

                // this is the mapped id.
                dwDeviceIDHold = DWORD_CAST(hdWidget,__FILE__,__LINE__);
                break;

            case LINECALLSELECT_CALL:

                dwCallWidgetHold = hdWidget;
                break;

            default:

                break;
            }

            if ((pParams->lResult = CallSP7(
                     pfnTSPI_lineGetID,
                     "lineGetID",
                     SP_FUNC_SYNC,
                     (ULONG_PTR) dwLineWidgetHold,
                     (DWORD) dwDeviceIDHold,
                     (ULONG_PTR) dwCallWidgetHold,
                     (DWORD) pParams->dwSelect,
                     (ULONG_PTR) pID,
                     (ULONG_PTR) pszDeviceClass,
                     (ULONG_PTR) (IS_REMOTE_CLIENT (ptClient) ?
                         (HANDLE) -1 : ptClient->hProcess)

                     )) == 0)
            {

#if TELE_SERVER
                //
                // If
                //     this is a server &
                //     client doesn't have admin privileges &
                //     the specified device class == "tapi/phone" &
                //     the dwUsedSize indicates that a phone id was
                //         (likely) copied to the buffer
                // then
                //     try to map the retrieved phone device id back
                //     to one that makes sense to the client (and
                //     fail the request if there's no mapping)
                //

                if (IS_REMOTE_CLIENT(ptClient)  &&
                    (_wcsicmp (pszDeviceClass, L"tapi/phone") == 0) &&
                    !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR) &&
                    (pID->dwUsedSize >= (sizeof (*pID) + sizeof (DWORD))))
                {
                    DWORD   i;
                    LPDWORD pdwPhoneID = (LPDWORD)
                                (((LPBYTE) pID) + pID->dwStringOffset);


                    for (i = 0; i < ptClient->dwPhoneDevices; i++)
                    {
                        if (*pdwPhoneID == ptClient->pPhoneDevices[i])
                        {
                            *pdwPhoneID = i;
                            break;
                        }
                    }

                    if (i >= ptClient->dwPhoneDevices)
                    {
                        pParams->lResult = LINEERR_OPERATIONFAILED;
                    }
                }
#endif

                //
                // Indicate offset & how many bytes of data we're passing back
                //

                pParams->dwDeviceIDOffset = 0;

                *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pID->dwUsedSize;
            }

        }

        ServerFree (pszDeviceClass);
    }

LGetID_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetID"
        );
}


void
WINAPI
LGetLineDevStatus(
    PTCLIENT                        ptClient,
    PLINEGETLINEDEVSTATUS_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVLINE        hdLine;
    TSPIPROC        pfnTSPI_lineGetLineDevStatus;
    DWORD               objectToDereference;
    PTLINECLIENT    ptLineClient;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwLineDevStatusTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            pParams->hLine,             // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEGETLINEDEVSTATUS,    // provider func index
            &pfnTSPI_lineGetLineDevStatus,  // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "GetLineDevStatus"          // func name

            )) == 0)
    {
        DWORD           dwAPIVersion, dwSPIVersion, dwTotalSize,
                        dwFixedSizeClient, dwFixedSizeSP, dwNumOpens,
                        dwOpenMediaModes;
        PTLINE          ptLine;
        LPLINEDEVSTATUS pDevStatus = (LPLINEDEVSTATUS) pDataBuf,
                        pDevStatus2 = (LPLINEDEVSTATUS) NULL;


        //
        // Safely retrieve the API & SPI versions, also some other info
        //

        try
        {
            dwAPIVersion = ptLineClient->dwAPIVersion;

            ptLine = ptLineClient->ptLine;

            dwSPIVersion = ptLine->dwSPIVersion;

            dwNumOpens       = ptLine->dwNumOpens;
            dwOpenMediaModes = ptLine->dwOpenMediaModes;

            if (ptLineClient->dwKey != TLINECLIENT_KEY)
            {
                pParams->lResult = LINEERR_INVALLINEHANDLE;
                goto LGetLineDevStatus_epilog;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
            goto LGetLineDevStatus_epilog;
        }


        //
        // Determine the fixed size of the structure for the specified API
        // version, verify client's buffer is big enough
        //

        dwTotalSize = pParams->dwLineDevStatusTotalSize;

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeClient = 76;   // 19 * sizeof (DWORD)
            break;


        default: // (fix ppc build wrn) case TAPI_VERSION_CURRENT:

            dwFixedSizeClient = sizeof (LINEDEVSTATUS);
            break;
        }

        if (dwTotalSize < dwFixedSizeClient)
        {
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
            goto LGetLineDevStatus_epilog;
        }


        //
        // Determine the fixed size of the structure expected by the SP
        //

        switch (dwSPIVersion)
        {
        case TAPI_VERSION1_0:
        case TAPI_VERSION1_4:

            dwFixedSizeSP = 76;   // 19 * sizeof (DWORD)
            break;

        default: // (fix ppc build wrn) case TAPI_VERSION_CURRENT:

            dwFixedSizeSP = sizeof (LINEDEVSTATUS);
            break;
        }


        //
        // If the client's buffer is < the fixed size of that expected by
        // the SP (client is lower version than SP) then allocate an
        // intermediate buffer
        //

        if (dwTotalSize < dwFixedSizeSP)
        {
            if (!(pDevStatus2 = ServerAlloc (dwFixedSizeSP)))
            {
                pParams->lResult = LINEERR_NOMEM;
                goto LGetLineDevStatus_epilog;
            }

            pDevStatus  = pDevStatus2;
            dwTotalSize = dwFixedSizeSP;
        }


        InitTapiStruct(
            pDevStatus,
            dwTotalSize,
            dwFixedSizeSP,
            (pDevStatus2 == NULL ? TRUE : FALSE)
            );

        if ((pParams->lResult = CallSP2(
                pfnTSPI_lineGetLineDevStatus,
                "lineGetLineDevStatus",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdLine,
                (ULONG_PTR) pDevStatus

                )) == 0)
        {
            //
            // Add the fields we're responsible for
            //

            pDevStatus->dwNumOpens       = dwNumOpens;
            pDevStatus->dwOpenMediaModes = dwOpenMediaModes;


            if (dwAPIVersion >= TAPI_VERSION2_0)
            {
                DWORD           dwAppInfoTotalSize, dwNumOpens, dwXxxOffset, i;
                TPOINTERLIST    clientList, *pClientList = &clientList;
                LPLINEAPPINFO   pAppInfo;


                //
                // Reset the num opens to 0 in case we return prior to
                // filling in the app info list (so tapi32.dll doesn't
                // blow up trying to do unicode->ascii conversion on
                // bad data)
                //

                pDevStatus->dwNumOpens = 0;


                //
                // Retrieve the list of line clients & determine how big
                // of a buffer we need to hold all the related app info
                // data.  Do it safely in case one of the widgets is
                // destroyed while we're reading it's data.
                //

                if (GetLineClientListFromLine (ptLine, &pClientList) != 0)
                {
                    goto LGetLineDevStatus_copyTmpBuffer;
                }

                dwAppInfoTotalSize = pClientList->dwNumUsedEntries *
                    sizeof (LINEAPPINFO);

                for (i = 0; i < pClientList->dwNumUsedEntries; i++)
                {
                    PTLINECLIENT    ptLineClient = (PTLINECLIENT)
                                        pClientList->aEntries[i];

                    try
                    {
                        DWORD   d;


                        d = ptLineClient->ptClient->dwComputerNameSize;

                        d += ptLineClient->ptClient->dwUserNameSize;

                        // don't include preceding '"'

                        d += ptLineClient->ptLineApp->dwModuleNameSize -
                                sizeof (WCHAR);

                        d += ptLineClient->ptLineApp->dwFriendlyNameSize;

                        if (ptLineClient->dwKey == TLINECLIENT_KEY)
                        {
                            dwAppInfoTotalSize += d;
                        }
                        else
                        {
                            pClientList->aEntries[i] = 0;
                        }
                    }
                    myexcept
                    {
                        pClientList->aEntries[i] = 0;
                    }
                }

                dwAppInfoTotalSize += 3; // add 3 to guarantee DWORD alignment

                pDevStatus->dwNeededSize += dwAppInfoTotalSize;


                //
                // Check to see if there's enough room in the app buffer
                // for all the app info data
                //

                if ((pDevStatus->dwTotalSize - pDevStatus->dwUsedSize) <
                        dwAppInfoTotalSize)
                {
                    goto LGetLineDevStatus_freeClientList;
                }

                //
                // Now figure out where the app info goes & safely fill
                // it in
                //

                pDevStatus->dwAppInfoSize = pClientList->dwNumUsedEntries *
                    sizeof (LINEAPPINFO);

                pDevStatus->dwAppInfoOffset = (pDevStatus->dwUsedSize + 3) &
                    0xfffffffc;

                pDevStatus->dwUsedSize += dwAppInfoTotalSize;

                pAppInfo = (LPLINEAPPINFO) (((LPBYTE) pDevStatus) +
                    pDevStatus->dwAppInfoOffset);

                dwXxxOffset = pDevStatus->dwAppInfoSize +
                    pDevStatus->dwAppInfoOffset;

                dwNumOpens = 0;

                for (i = 0; i < pClientList->dwNumUsedEntries; i++)
                {
                    PTLINECLIENT    ptLineClient = (PTLINECLIENT)
                                        pClientList->aEntries[i];


                    if (ptLineClient == NULL)
                    {
                        continue;
                    }

                    try
                    {
                        DWORD       d = dwXxxOffset;
                        PTCLIENT    ptClient  = ptLineClient->ptClient;
                        PTLINEAPP   ptLineApp = ptLineClient->ptLineApp;


                        pAppInfo->dwMachineNameSize =
                            ptClient->dwComputerNameSize;
                        pAppInfo->dwUserNameSize =
                            ptClient->dwUserNameSize;

                        if (ptClient->dwKey != TCLIENT_KEY)
                        {
                            continue;
                        }

                        pAppInfo->dwModuleFilenameSize =
                            ptLineApp->dwModuleNameSize - sizeof (WCHAR);
                        pAppInfo->dwFriendlyNameSize =
                            ptLineApp->dwFriendlyNameSize;

                        if (ptLineApp->dwKey != TLINEAPP_KEY)
                        {
                            continue;
                        }

                        pAppInfo->dwMachineNameOffset = d;

                        if (pAppInfo->dwMachineNameSize)
                        {
                            wcsncpy(
                                (LPWSTR) (((LPBYTE) pDevStatus) + d),
                                ptClient->pszComputerName,
                                pAppInfo->dwMachineNameSize / sizeof (WCHAR)
                                );

                            d += pAppInfo->dwMachineNameSize;
                        }

                        pAppInfo->dwUserNameOffset = d;

                        if (pAppInfo->dwUserNameSize)
                        {
                            wcsncpy(
                                (LPWSTR) (((LPBYTE) pDevStatus) + d),
                                ptClient->pszUserName,
                                pAppInfo->dwUserNameSize / sizeof (WCHAR)
                                );

                            d += pAppInfo->dwUserNameSize;
                        }

                        pAppInfo->dwModuleFilenameOffset = d;

                        if (pAppInfo->dwModuleFilenameSize)
                        {
                            // don't include preceding '"'

                            wcsncpy(
                                (LPWSTR) (((LPBYTE) pDevStatus) + d),
                                &ptLineApp->pszModuleName[1],
                                pAppInfo->dwModuleFilenameSize / sizeof (WCHAR)
                                );

                            d += pAppInfo->dwModuleFilenameSize;
                        }

                        pAppInfo->dwFriendlyNameOffset = d;

                        if (pAppInfo->dwFriendlyNameSize)
                        {
                            wcsncpy(
                                (LPWSTR) (((LPBYTE) pDevStatus) + d),
                                ptLineApp->pszFriendlyName,
                                pAppInfo->dwFriendlyNameSize / sizeof (WCHAR)
                                );

                            d += pAppInfo->dwFriendlyNameSize;
                        }

                        pAppInfo->dwMediaModes = ptLineClient->dwMediaModes;
                        pAppInfo->dwAddressID  = ptLineClient->dwAddressID;


                        //
                        // Finally, make sure the tLineClient is still good
                        // so we know all the info above  is kosher, &
                        // if so inc the appropriate vars
                        //

                        if (ptLineClient->dwKey == TLINECLIENT_KEY)
                        {
                            pAppInfo++;
                            dwNumOpens++;
                            dwXxxOffset = d;
                        }
                    }
                    myexcept
                    {
                        // do nothing, just continue to loop
                    }
                }

                pDevStatus->dwNumOpens    = dwNumOpens;
                pDevStatus->dwAppInfoSize = dwNumOpens * sizeof (LINEAPPINFO);

LGetLineDevStatus_freeClientList:

                if (pClientList !=  &clientList)
                {
                    ServerFree (pClientList);
                }
            }


            //
            // Munge fields where appropriate for old apps (don't want to
            // pass back flags that they won't understand)
            //


            //
            // If an intermediate buffer was used then copy the bits back
            // to the the original buffer, & free the intermediate buffer.
            // Also reset the dwUsedSize field to the fixed size of the
            // structure for the specifed version, since any data in the
            // variable portion is garbage as far as the client is concerned.
            //

LGetLineDevStatus_copyTmpBuffer:

            if (pDevStatus == pDevStatus2)
            {
                pDevStatus = (LPLINEDEVSTATUS) pDataBuf;

                CopyMemory (pDevStatus, pDevStatus2, dwFixedSizeClient);

                ServerFree (pDevStatus2);

                pDevStatus->dwTotalSize = pParams->dwLineDevStatusTotalSize;
                pDevStatus->dwUsedSize  = dwFixedSizeClient;
            }


            //
            // Indicate the API version of the hLine so tapi32.dll knows
            // which strings to munge from ascii to unicode
            //

            pParams->dwAPIVersion = dwAPIVersion;


            //
            // Indicate the offset & how many bytes of data we're passing back
            //

            pParams->dwLineDevStatusOffset = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                pDevStatus->dwUsedSize;
        }
    }

LGetLineDevStatus_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetLineDevStatus"
        );
}


void
WINAPI
LGetNewCalls(
    PTCLIENT                ptClient,
    PLINEGETNEWCALLS_PARAMS pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    LONG            lResult = 0;
    DWORD           dwTotalSize = pParams->dwCallListTotalSize, dwAddressID,
                    dwNumNewCalls, i, j, dwSelect = pParams->dwSelect;
    PTLINE          ptLine;
    HDRVLINE        hdLine;
    PTLINECLIENT    ptLineClient;
    TPOINTERLIST    callList, *pCallList = &callList;
    LPLINECALLLIST  pAppCallList = (LPLINECALLLIST) pDataBuf;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwCallListTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    //
    // Verify params
    //

    if (TapiGlobals.dwNumLineInits == 0)
    {
        pParams->lResult = LINEERR_UNINITIALIZED;
        goto LGetNewCalls_return;
    }

    if (dwSelect == LINECALLSELECT_ADDRESS)
    {
        dwAddressID = pParams->dwAddressID;
    }
    else if (dwSelect != LINECALLSELECT_LINE)
    {
        pParams->lResult = LINEERR_INVALCALLSELECT;
        goto LGetNewCalls_return;
    }

    if (dwTotalSize < sizeof (LINECALLLIST))
    {
        pParams->lResult = LINEERR_STRUCTURETOOSMALL;
        goto LGetNewCalls_return;
    }

    if (!(ptLineClient = ReferenceObject(
            ghHandleTable,
            pParams->hLine,
            TLINECLIENT_KEY
            )))
    {
        pParams->lResult = LINEERR_INVALLINEHANDLE;
        goto LGetNewCalls_return;
    }

    if (ptLineClient->ptClient != ptClient)
    {
        pParams->lResult = LINEERR_INVALLINEHANDLE;
        goto LGetNewCalls_dereference;
    }

    ptLine = ptLineClient->ptLine;


    //
    // HACK ALERT!
    //
    // GetNewCalls did not work on remote lines in tapi 2.1,
    // win98 gold, or nt4sp4.
    //
    // The way we get it to work here for remote lines is to do a
    // TSPI_lineGetID down to remotesp, specifying the device class
    // of "GetNewCalls", and passing it the pointer to our real
    // LineEventProc, not the LineEventProcSP which queues msgs,
    // so it can process LINE_CALLSTATE msgs inline (this allows
    // the initial/requisite monitor handles to be created, etc,
    // before we might do so below).
    //

    try
    {
        hdLine = (ptLine->ptProvider == pRemoteSP ? ptLine->hdLine : 0);

        if (ptLine->dwKey != TLINE_KEY)
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
            goto LGetNewCalls_dereference;
        }
    }
    myexcept
    {
        pParams->lResult = LINEERR_INVALLINEHANDLE;
        goto LGetNewCalls_dereference;
    }

    if (hdLine  &&  pRemoteSP->apfn[SP_LINEGETID])
    {
        CallSP7(
            pRemoteSP->apfn[SP_LINEGETID],
            "lineGetID(GetNewCalls)",
            SP_FUNC_SYNC,
            (ULONG_PTR) hdLine,
            (DWORD) dwAddressID,
            (ULONG_PTR) 0,              // hdCall
            (DWORD) dwSelect,
            (ULONG_PTR) 0,              // lpDeviceID
            (ULONG_PTR) L"GetNewCalls", // lpszDeviceClass
            (ULONG_PTR) LineEventProc   // hTargetProcess
            );
    }


    //
    // Get list of tCalls on the tLine
    //

    if ((lResult = GetCallListFromLine (ptLine, &pCallList)) != 0)
    {
        pParams->lResult = lResult;
        goto LGetNewCalls_dereference;
    }


    //
    // Assume worst case scenario- that we have to create a new call
    // client for each tCall on the tLine- and make sure the app's call
    // list is large enough to hold them all
    //

    pAppCallList->dwTotalSize = dwTotalSize;

    if (dwTotalSize < (sizeof (LINECALLLIST) +
            pCallList->dwNumUsedEntries * sizeof(HCALL)))
    {
        pAppCallList->dwNeededSize = sizeof (LINECALLLIST) +
            pCallList->dwNumUsedEntries * sizeof(HCALL);

        pAppCallList->dwUsedSize = sizeof (LINECALLLIST);

        FillMemory (&pAppCallList->dwCallsNumEntries, 3 * sizeof (DWORD), 0);

        goto LGetNewCalls_cleanup;
    }


    //
    // Check to see if there's a call client for the specified
    // line client for each of the calls on the line/address,
    // create one with monitor privilege if not
    //

    dwNumNewCalls = 0;

    for (i = 0; i < pCallList->dwNumUsedEntries; i++)
    {
        BOOL            bContinue = FALSE;
        PTCALL          ptCall = (PTCALL) pCallList->aEntries[i];
        TPOINTERLIST    callClientList, *pCallClientList = &callClientList;


        //
        // Check to see if the post-processing routine (for outgoing calls)
        // or the CALLSTATE msg handler in the LineEventProc (for incoming
        // calls) has already created the list of monitors for this tCall.
        //

        try
        {
            if (ptCall->bCreatedInitialMonitors == FALSE)
            {
                bContinue = TRUE;
            }
        }
        myexcept
        {
            bContinue = TRUE;
        }

        if (dwSelect == LINECALLSELECT_ADDRESS)
        {
            try
            {
                if (dwAddressID != ptCall->dwAddressID)
                {
                    bContinue = TRUE;
                }
            }
            myexcept
            {
                bContinue = TRUE;
            }
        }

        if (bContinue)
        {
            continue;
        }

        if (GetCallClientListFromCall (ptCall, &pCallClientList) != 0)
        {
            continue;
        }

        for (j = 0; j < pCallClientList->dwNumUsedEntries; j++)
        {
            try
            {
                if (((PTCALLCLIENT)(pCallClientList->aEntries[j]))
                        ->ptLineClient == ptLineClient)
                {
                    break;
                }
            }
            myexcept
            {
                // just continue
            }
         }

         if (j == pCallClientList->dwNumUsedEntries)
         {
            PTCALLCLIENT    pNewCallClient;


            //
            // (Similar remotesp hack in CreateCallMonitors)
            //
            // NOTE: If client is remote(sp) then create the call client
            //       with OWNER privileges so client can still do everything.
            //       The remote tapisrv will deal with all the remote
            //       privilege issues.
            //
            //       This scheme might end up confusing other apps since
            //       a LINE_CALLINFO\NUMOWNERINCR (not NUMMONITORS) msgs
            //       get sent, but it certainly beats what we had in tapi 2.1 -
            //       that is, if a remote client did not initially have owner
            //       privilege then it could *never* get owner privilege.
            //

            if ((lResult = CreatetCallClient(
                    ptCall,
                    ptLineClient,
                    (IS_REMOTE_CLIENT (ptClient) ?
                        LINECALLPRIVILEGE_OWNER : LINECALLPRIVILEGE_MONITOR),
                    TRUE,
                    TRUE,
                    &pNewCallClient,
                    FALSE

                    )) == 0)
            {
                try
                {
                    *(((LPHCALL)(pAppCallList + 1)) + dwNumNewCalls) =
                        pNewCallClient->hCall;
                }
                myexcept
                {
                    //
                    // If here the call got torn down, meaning the line
                    // is going down too
                    //

                    pParams->lResult = LINEERR_INVALLINEHANDLE;
                    i = 0xfffffffe;
                    break;
                }

                dwNumNewCalls++;
            }
            else
            {
                // specfied tCall might have been closed, not a fatal error
            }
        }

        if (pCallClientList != &callClientList)
        {
            ServerFree (pCallClientList);
        }
    }

    {
        DWORD   dwCallsSize = dwNumNewCalls * sizeof (HCALL);


        pAppCallList->dwUsedSize        =
        pAppCallList->dwNeededSize      = sizeof (LINECALLLIST) + dwCallsSize;

        pAppCallList->dwCallsNumEntries = dwNumNewCalls;
        pAppCallList->dwCallsSize       = dwCallsSize;
        pAppCallList->dwCallsOffset     = sizeof (LINECALLLIST);
    }

LGetNewCalls_cleanup:

    if (pCallList != &callList)
    {
        ServerFree (pCallList);
    }

    pParams->dwCallListOffset = 0;

    *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pAppCallList->dwUsedSize;

LGetNewCalls_dereference:

    DereferenceObject (ghHandleTable, pParams->hLine, 1);

LGetNewCalls_return:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineGetNewCalls: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "lineGetNewCalls: exit, result=x%x",
            pParams->lResult
            ));
#endif

    return;
}


void
WINAPI
LGetNumAddressIDs(
    PTCLIENT                        ptClient,
    PLINEGETNUMADDRESSIDS_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVLINE        hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT    ptLineClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "GetNumAddressIDs"          // func name

            )) == 0)
    {
        try
        {
            pParams->dwNumAddresses = ptLineClient->ptLine->dwNumAddresses;

            *pdwNumBytesReturned = sizeof (LINEGETNUMADDRESSIDS_PARAMS);
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
        }
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetNumAddressIDs"
        );
}


void
WINAPI
LGetNumRings(
    PTCLIENT                ptClient,
    PLINEGETNUMRINGS_PARAMS pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVLINE        hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT    ptLineClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_NONE,                    // provider func index
            NULL,                       // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "GetNumRings"               // func name

            )) == 0)
    {
        DWORD           i, dwNumRings = 0xffffffff,
                        dwAddressID = pParams->dwAddressID;
        PTLINE          ptLine;
        TPOINTERLIST    lineClientList, *pLineClientList = &lineClientList;


        try
        {
            ptLine = ptLineClient->ptLine;

            if (dwAddressID >= ptLine->dwNumAddresses)
            {
                pParams->lResult = LINEERR_INVALADDRESSID;
                goto LGetNumRings_epilog;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
            goto LGetNumRings_epilog;
        }

        {
            LONG    lResult;


            if ((lResult = GetLineClientListFromLine(
                    ptLine,
                    &pLineClientList

                    )) != 0)
            {
                pParams->lResult = LINEERR_INVALLINEHANDLE;
                goto LGetNumRings_epilog;
            }
        }

        for (i = 0; i < pLineClientList->dwNumUsedEntries; i++)
        {
            ptLineClient = (PTLINECLIENT) pLineClientList->aEntries[i];

            try
            {
               if (ptLineClient->aNumRings == NULL)
               {
                   continue;
               }
               else if (ptLineClient->aNumRings[dwAddressID] < dwNumRings)
               {
                   DWORD    dwNumRingsTmp =
                                ptLineClient->aNumRings[dwAddressID];


                   if (ptLineClient->dwKey == TLINECLIENT_KEY)
                   {
                       dwNumRings = dwNumRingsTmp;
                   }
               }
            }
            myexcept
            {
                // just continue
            }
        }

        if (pLineClientList != &lineClientList)
        {
            ServerFree (pLineClientList);
        }

        pParams->dwNumRings = dwNumRings;

        *pdwNumBytesReturned = sizeof (LINEGETNUMRINGS_PARAMS);
    }

LGetNumRings_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetNumRings"
        );
}


void
WINAPI
LGetProviderList(
    PTCLIENT                    ptClient,
    PLINEGETPROVIDERLIST_PARAMS pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    DWORD   iNumProviders = 0, i;
    WCHAR   *bufw;
    DWORD   dwFixedSizeClient, dwTotalSize, dwNeededSize;
    LPBYTE  pVarData;
    LPLINEPROVIDERLIST  pProviderList;
    LPLINEPROVIDERENTRY pProviderEntry;

    HKEY hKey;
    DWORD dwDataSize;
    DWORD dwDataType;

    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwProviderListTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    switch (pParams->dwAPIVersion)
    {
    case TAPI_VERSION1_0:
    case TAPI_VERSION1_4:
    case TAPI_VERSION2_0:
    case TAPI_VERSION2_1:
    case TAPI_VERSION2_2:
    case TAPI_VERSION3_0:
    case TAPI_VERSION_CURRENT:

        dwFixedSizeClient = sizeof (LINEPROVIDERLIST);
        break;

    default:

        pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
        goto LGetProviderList_epilog;
    }

    if ((dwTotalSize = pParams->dwProviderListTotalSize) < dwFixedSizeClient)
    {
        pParams->lResult = LINEERR_STRUCTURETOOSMALL;
        goto LGetProviderList_epilog;
    }

    if (ERROR_SUCCESS ==
        RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        gszRegKeyProviders,
        0,
        KEY_ALL_ACCESS,
        &hKey
        ))
    {
        dwDataSize = sizeof(iNumProviders);
        iNumProviders = 0;
        RegQueryValueEx(
            hKey,
            gszNumProviders,
            0,
            &dwDataType,
            (LPBYTE)&iNumProviders,
            &dwDataSize
            );
    }

    dwNeededSize = dwFixedSizeClient +
        (iNumProviders * sizeof (LINEPROVIDERENTRY));

    pProviderList = (LPLINEPROVIDERLIST) pDataBuf;

    pProviderEntry = (LPLINEPROVIDERENTRY) (pDataBuf + dwFixedSizeClient);

    pVarData = pDataBuf + dwNeededSize;

    bufw = ServerAlloc (MAX_PATH*sizeof(WCHAR));  // enough for complete path

    if ( !bufw )
    {
        pParams->lResult = LINEERR_NOMEM;
        goto LGetProviderList_epilog;
    }

    for (i = 0; i < iNumProviders; i++)
    {
        TCHAR   szProviderXxxN[32];
        DWORD   dwNameLen;
        DWORD   dwNewSize;

        wsprintf (szProviderXxxN, TEXT("%s%d"), gszProviderFilename, i);

        dwNameLen = MAX_PATH*sizeof(WCHAR);

        if (TAPIRegQueryValueExW(
                hKey,
                szProviderXxxN,
                0,
                &dwDataType,
                (LPBYTE)bufw,
                &dwNameLen

                ) != ERROR_SUCCESS)
        {
            bufw[0] = 0;
        }

        dwNewSize = (lstrlenW(bufw)+1) * sizeof(WCHAR);

        dwNeededSize += dwNewSize;

        if (dwTotalSize >= dwNeededSize)
        {
            wsprintf(szProviderXxxN, TEXT("%s%d"), gszProviderID, i);

            dwDataSize = sizeof(pProviderEntry->dwPermanentProviderID);

            pProviderEntry->dwPermanentProviderID = 0;

            RegQueryValueEx(
                hKey,
                szProviderXxxN,
                0,
                &dwDataType,
                (LPBYTE)&(pProviderEntry->dwPermanentProviderID),
                &dwDataSize
                );

            pProviderEntry->dwProviderFilenameSize   = dwNewSize;
            pProviderEntry->dwProviderFilenameOffset =
                  (DWORD) (pVarData - ((LPBYTE) pProviderList));

            CopyMemory (pVarData, bufw, dwNewSize);

            pVarData += dwNewSize;

            pProviderEntry++;
        }
    }

    ServerFree (bufw);

    pProviderList->dwTotalSize  = dwTotalSize;
    pProviderList->dwNeededSize = dwNeededSize;

    if (dwTotalSize >= dwNeededSize)
    {
        pProviderList->dwUsedSize           = dwNeededSize;
        pProviderList->dwNumProviders       = (DWORD) iNumProviders;
        pProviderList->dwProviderListSize   =
            (DWORD) (iNumProviders * sizeof (LINEPROVIDERENTRY));
        pProviderList->dwProviderListOffset = dwFixedSizeClient;
    }
    else
    {
        pProviderList->dwUsedSize           = dwFixedSizeClient;
        pProviderList->dwNumProviders       =
        pProviderList->dwProviderListSize   =
        pProviderList->dwProviderListOffset = 0;
    }

    pParams->dwProviderListOffset = 0;

    *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pProviderList->dwUsedSize;

    RegCloseKey (hKey);


LGetProviderList_epilog:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineGetProviderList: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "lineGetProviderList: exit, result=x%x",
            pParams->lResult
            ));
#endif

    return;
}


void
WINAPI
LGetProxyStatus(
    PTCLIENT                        ptClient,
    PLINEGETPROXYSTATUS_PARAMS      pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    DWORD               dwDeviceID;
    HANDLE              hMutex;
    DWORD               objectToDereference;
    PTLINELOOKUPENTRY   pLookupEntry;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwProxyStatusTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }

    switch (pParams->dwAppAPIVersion)
    {
    case TAPI_VERSION1_0:
    case TAPI_VERSION1_4:
    case TAPI_VERSION2_0:
    case TAPI_VERSION2_1:
    case TAPI_VERSION2_2:
    case TAPI_VERSION3_0:
    case TAPI_VERSION_CURRENT:
        break;

    default:

        pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
        return;
    }

    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            DEVICE_ID,                  // widget type
            (DWORD) pParams->hLineApp,  // client widget handle
            (LPVOID) &dwDeviceID,       // provider widget handle
            pParams->dwDeviceID,        // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &pLookupEntry,              // context
            "GetProxyStatus"            // func name

            )) == 0)
    {
        DWORD     dwAPIVersion = 0;
        DWORD     dwTotalSize = 0;
        DWORD     dwFixedSizeClient = 0;


        //
        // Determine the fixed size of the structure for the
        // specified API version
        //

        dwAPIVersion = pParams->dwAppAPIVersion;

        dwFixedSizeClient = sizeof (LINEPROXYREQUESTLIST);


        //
        // Will it fit ?
        //

        dwTotalSize = pParams->dwProxyStatusTotalSize;

        if (dwTotalSize >= dwFixedSizeClient)
        {
            //
            // OK, buffer's large enough for fixed part.
            //
            // Is this line remote ?
            //

            if (pLookupEntry->bRemote)
            {
                LPLINEPROXYREQUESTLIST  pProxyReqList =
                                            (LPLINEPROXYREQUESTLIST) pDataBuf;

                InitTapiStruct(
                    pProxyReqList,
                    dwTotalSize,
                    dwFixedSizeClient,
                    TRUE
                    );

                pParams->lResult = CallSP3(
                    pRemoteSP->apfn[SP_LINEGETPROXYSTATUS],
                    "LineGetProxyStatus",
                    SP_FUNC_SYNC,
                    (DWORD) dwDeviceID,
                    (DWORD) dwAPIVersion,
                    (ULONG_PTR) pProxyReqList
                    );


                //
                // Set the return values
                //

                pParams->dwAPIVersion = dwAPIVersion;
                pParams->dwProxyStatusOffset = 0;
                *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                    pProxyReqList->dwUsedSize;
            }
            else  // it's a local line
            {
                DWORD                   i;
                DWORD                   dwNeededSize;
                LPDWORD                 pListEntry;
                PTLINE                  ptLine = pLookupEntry->ptLine;
                LPLINEPROXYREQUESTLIST  pProxyReqList =
                                            (LPLINEPROXYREQUESTLIST) pDataBuf;


                if (ptLine != NULL)
                {
                    //
                    // how much space is needed for the list ?
                    //

                    dwNeededSize = sizeof (LINEPROXYREQUESTLIST);
                    pProxyReqList->dwNumEntries = 0;

                    for(
                        i = LINEPROXYREQUEST_SETAGENTGROUP;
                        i <= LINEPROXYREQUEST_LASTVALUE;
                        i++
                        )
                    {
                        try  // Just in case the line gets closed
                        {
                            if (ptLine->apProxys[i] != NULL)
                            {
                                //
                                // So there's a proxy associated with
                                // this proxy request type, add on space
                                // requirement for it's list entry
                                //

                                dwNeededSize += sizeof(DWORD);
                            }
                        }
                        myexcept
                        {
                            pParams->lResult = LINEERR_OPERATIONUNAVAIL;
                            goto LGetProxyStatus_epilog;
                        }
                    }


                    //
                    // Will it fit ?
                    //

                    if (dwTotalSize >= dwNeededSize)
                    {
                        //
                        // enough room , so fill in list
                        //

                        pProxyReqList->dwListSize = 0;
                        pProxyReqList->dwNumEntries = 0;

                        pProxyReqList->dwListOffset =
                            sizeof(LINEPROXYREQUESTLIST);

                        pListEntry = (LPDWORD) ((BYTE *) pProxyReqList +
                            sizeof (LINEPROXYREQUESTLIST));

                        for(
                            i = LINEPROXYREQUEST_SETAGENTGROUP;
                            i <= LINEPROXYREQUEST_LASTVALUE;
                            i++
                            )
                        {
                            try  // Just in case the line gets closed
                            {
                                if (ptLine->apProxys[i] != NULL)
                                {
                                    //
                                    // So there's a proxy associated with
                                    // this proxy request type, add on space
                                    // requirement for entry to list size
                                    //

                                    pProxyReqList->dwListSize += sizeof(DWORD);


                                    //
                                    // Incr number of entries in the list
                                    //

                                    pProxyReqList->dwNumEntries++;


                                    //
                                    // Proxy reqest type is ..
                                    //

                                    *pListEntry++ = i;
                                }
                            }
                            myexcept
                            {
                                pParams->lResult = LINEERR_OPERATIONUNAVAIL;
                                goto LGetProxyStatus_epilog;
                            }
                        }


                        //
                        // set the total, used & need sizes
                        //

                        pProxyReqList->dwTotalSize  = dwTotalSize;
                        pProxyReqList->dwUsedSize   = dwNeededSize;
                        pProxyReqList->dwNeededSize = dwNeededSize;


                        //
                        // Set the return values
                        //

                        pParams->dwAPIVersion = dwAPIVersion;
                        pParams->dwProxyStatusOffset = 0;
                        *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                            pProxyReqList->dwUsedSize;
                    }
                    else // Buffer too small for the list, so return an error
                    {
                        pParams->lResult = LINEERR_STRUCTURETOOSMALL;
                    }
                }
                else // (ptLine == NULL) - No line open, so no proxies !
                {
                    pParams->lResult = LINEERR_OPERATIONFAILED;
                    LOG((TL_ERROR, "lineGetProxyStatus - no line open"));
                }
            } // endif bRemote
        }
        else // Buffer too small
        {
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
        }

    } // endif LINEPROLOG

LGetProxyStatus_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "GetLineProxyStatus"
        );
}


void
WINAPI
LGetQueueInfo(
    PTCLIENT                    ptClient,
    PLINEGETQUEUEINFO_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    LGetAgentWithoutAddressIDXxx(
        ptClient,
        (PLINEGETAGENTINFO_PARAMS) pParams,
        dwParamsBufferSize,
        LINEPROXYREQUEST_GETQUEUEINFO,
        SP_LINEGETQUEUEINFO,
        sizeof (LINEQUEUEINFO)
#if DBG
        ,
        "GetQueueInfo"
#endif
        );
}

void
WINAPI
LGetQueueList(
    PTCLIENT                    ptClient,
    PLINEGETQUEUELIST_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwGroupIDSize,
            pParams->dwGroupIDOffset,
            sizeof(DWORD),
            "LGetQueueList",
            "pParams->GroupID"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "GetQueueList"          // func name

            )) > 0)
    {
        LONG            lResult;
        DWORD           dwDeviceID,
                        dwTotalSize = pParams->dwQueueListTotalSize;
        PTLINECLIENT    pProxy;


        if (dwTotalSize < sizeof( LINEQUEUELIST ) )
        {
            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LGetQueueList_epilog;
        }

        if ((lResult = FindProxy(
                ptLineClient,
                0,
                LINEPROXYREQUEST_GETQUEUELIST,
                &pProxy,
                &dwDeviceID,
                TAPI_VERSION2_2
                )))
        {
            lRequestID = lResult;
            goto LGetQueueList_epilog;
        }


        //
        // Save the client's buf ptr & post processing proc ptr
        //

        pAsyncRequestInfo->dwParam1 = pParams->hpQueueList;
        pAsyncRequestInfo->dwParam2 = dwTotalSize;
        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;


        //
        // First check to see if there's a (local) proxy registered
        // for this type of request on this line.  If so, build a
        // request & send it to the proxy.
        //

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_GETQUEUELIST,
                    sizeof(GUID) + sizeof(DWORD),
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LGetQueueList_epilog;
            }

            CopyMemory(
                &(pProxyRequestWrapper->ProxyRequest.GetQueueList.GroupID),
                pDataBuf + pParams->dwGroupIDOffset,
                sizeof(GUID)
                );

            pProxyRequestWrapper->ProxyRequest.GetQueueList.
                QueueList.dwTotalSize = dwTotalSize;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LGetQueueList_epilog;
            }
            else // success
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


        //
        // There's no proxy, so check to see if line is remote and
        // call remotesp if so
        //

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            LPBYTE                  pBuf;
            LPLINEAGENTINFO         pAgentInfo;


            //
            // Alloc a shadow buf that the SP can use until it completes this
            // request.  Make sure there's enough extra space in the buf for
            // an ASYNCEVENTMSG header so we don't have to alloc yet another
            // buf in the post processing proc when preparing the completion
            // msg to send to the client, and that the msg is 64-bit aligned.
            //

            if (!(pBuf = ServerAlloc(
                    sizeof (ASYNCEVENTMSG) + ((dwTotalSize + 7) & 0xfffffff8)
                    )))
            {
                lRequestID = LINEERR_NOMEM;
                goto LGetQueueList_epilog;
            }

            pAsyncRequestInfo->pfnPostProcess =
                LGetAgentXxx_PostProcess;

            pAsyncRequestInfo->dwParam3 = (ULONG_PTR) pBuf;

            pAgentInfo = (LPLINEAGENTINFO)
                (pBuf + sizeof (ASYNCEVENTMSG));

            pAgentInfo->dwTotalSize = dwTotalSize;

            pParams->lResult = CallSP4(
                pRemoteSP->apfn[SP_LINEGETQUEUELIST],
                "LineGetQueueList",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (ULONG_PTR) (pDataBuf + pParams->dwGroupIDOffset),
                (ULONG_PTR) pAgentInfo
                );
        }


        //
        // There's no registered proxy & line is not remote, so fail
        //

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LGetQueueList_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "GetQueueList"
        );
}


void
WINAPI
LGetRequest(
    PTCLIENT                ptClient,
    PLINEGETREQUEST_PARAMS  pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    PTLINEAPP           ptLineApp;
    PTREQUESTMAKECALL   pRequestMakeCall;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (dwParamsBufferSize < sizeof (LINEREQMAKECALLW))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((ptLineApp = WaitForExclusiveLineAppAccess(
            pParams->hLineApp,
            ptClient
            )))
    {
        if (pParams->dwRequestMode == LINEREQUESTMODE_MAKECALL)
        {
            if (!ptLineApp->pRequestRecipient)
            {
                pParams->lResult = LINEERR_NOTREGISTERED;
                goto LGetRequest_releaseMutex;
            }

            EnterCriticalSection (&gPriorityListCritSec);

            // note: if here guaranteed to be >=1 reqRecip obj in global list

            if (_wcsicmp(
                    ptLineApp->pszModuleName,
                    TapiGlobals.pHighestPriorityRequestRecipient->
                        ptLineApp->pszModuleName

                    ) == 0)
            {
                if ((pRequestMakeCall = TapiGlobals.pRequestMakeCallList))
                {
                    CopyMemory(
                        pDataBuf,
                        &pRequestMakeCall->LineReqMakeCall,
                        sizeof (LINEREQMAKECALLW)
                        );

                    LOG((TL_INFO, "Getting request:  0x%p", pRequestMakeCall));

                    LOG((TL_INFO, "   DestAddress: [%ls]",
                          pRequestMakeCall->LineReqMakeCall.szDestAddress));

                    LOG((TL_INFO, "   AppName: [%ls]",
                          pRequestMakeCall->LineReqMakeCall.szAppName));

                    LOG((TL_INFO, "   CalledParty: [%ls]",
                          pRequestMakeCall->LineReqMakeCall.szCalledParty));

                    LOG((TL_INFO, "   Comment: [%ls]",
                          pRequestMakeCall->LineReqMakeCall.szComment));

                    pParams->dwRequestBufferOffset = 0;
                    pParams->dwSize = sizeof (LINEREQMAKECALLW);

                    *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                        sizeof (LINEREQMAKECALLW);

                    if (!(TapiGlobals.pRequestMakeCallList =
                            pRequestMakeCall->pNext))
                    {
                        TapiGlobals.pRequestMakeCallListEnd = NULL;
                    }

                    ServerFree (pRequestMakeCall);
                }
                else
                {
                    pParams->lResult = LINEERR_NOREQUEST;
                }
            }
            else
            {
                pParams->lResult = LINEERR_NOREQUEST;
            }

            LeaveCriticalSection (&gPriorityListCritSec);
        }
        else if (pParams->dwRequestMode == LINEREQUESTMODE_MEDIACALL)
        {
            pParams->lResult = (ptLineApp->bReqMediaCallRecipient ?
                LINEERR_NOREQUEST : LINEERR_NOTREGISTERED);
        }
        else
        {
            pParams->lResult = LINEERR_INVALREQUESTMODE;
        }

LGetRequest_releaseMutex:

        UNLOCKTLINEAPP(ptLineApp);
    }
    else
    {
        pParams->lResult = (TapiGlobals.dwNumLineInits == 0 ?
            LINEERR_UNINITIALIZED : LINEERR_INVALAPPHANDLE);
    }

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineGetRequest: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "lineGetRequest: exit, result=x%x",
            pParams->lResult
            ));
#endif

    return;
}


void
WINAPI
LGetStatusMessages(
    PTCLIENT                        ptClient,
    PLINEGETSTATUSMESSAGES_PARAMS   pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    PTLINECLIENT    ptLineClient;


    if ((ptLineClient = ReferenceObject(
            ghHandleTable,
            pParams->hLine,
            TLINECLIENT_KEY
            )))
    {
        if (ptLineClient->ptClient == ptClient)
        {
            pParams->dwLineStates    = ptLineClient->dwLineStates;
            pParams->dwAddressStates = ptLineClient->dwAddressStates;

            *pdwNumBytesReturned = sizeof (LINEGETSTATUSMESSAGES_PARAMS);
        }
        else
        {
            pParams->lResult = (TapiGlobals.dwNumLineInits ?
                LINEERR_INVALLINEHANDLE : LINEERR_UNINITIALIZED);
        }

        DereferenceObject (ghHandleTable, pParams->hLine, 1);
    }
    else
    {
        pParams->lResult = (TapiGlobals.dwNumLineInits ?
            LINEERR_INVALLINEHANDLE : LINEERR_UNINITIALIZED);
    }

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineGetStatusMessages: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "lineGetStatusMessages: exit, result=x%x",
            pParams->lResult
            ));
#endif
}


void
WINAPI
LHandoff(
    PTCLIENT            ptClient,
    PLINEHANDOFF_PARAMS pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVCALL        hdCall;
    DWORD           objectToDereference;
    PTCALLCLIENT    ptCallClientApp;
    TPOINTERLIST    xxxClientList, *pXxxClientList = &xxxClientList;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if ((pParams->dwFileNameOffset != TAPI_NO_DATA)  &&

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwFileNameOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClientApp,           // context
            "Handoff"                   // func name

            )) == 0)
    {
        LONG            lResult;
        DWORD           dwAPIVersion, dwValidMediaModes, i,
                        dwMediaMode = pParams->dwMediaMode;
        WCHAR          *pszFileName = (pParams->dwFileNameOffset==TAPI_NO_DATA
                            ? NULL :
                            (PWSTR)(pDataBuf + pParams->dwFileNameOffset));
        PTLINE          ptLine;
        PTCALL          ptCall;
        PTLINECLIENT    ptLineClientApp, ptLineClientTarget, ptLineClientTmp;
        HCALL           hCall;
        HLINE           hLine;


        //
        // Safely retrieve all the object pointers needed below, then get
        // a list of line clients
        //

        try
        {
            ptCall          = ptCallClientApp->ptCall;
            ptLineClientApp = ptCallClientApp->ptLineClient;
            ptLine          = ptLineClientApp->ptLine;
            dwAPIVersion    = ptLineClientApp->dwAPIVersion;
            hCall           = ptCall->hCall;
            hLine           = ptLine->hLine;
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LHandoff_epilog;
        }

        if ((lResult = GetLineClientListFromLine (ptLine, &pXxxClientList)))
        {
            pParams->lResult = lResult;
            goto LHandoff_epilog;
        }

        if (pszFileName)
        {
            //
            // "Directed" handoff
            //
            // Walk thru the list of clients on this line & find the oldest
            // one (that's an owner) with an app name that matches the
            // specified app name
            //
            // Note: It's possible that a target app who opened the line
            // with OWNER privilege for only DATAMODEM calls will be a
            // target of a directed handoff for calls of a different media
            // mode, i.e. G3FAX.  TNixon decided that it was desirable
            // to maintain this behavior for existing apps which may rely
            // on it.  (10/24/95)
            //

            _wcsupr(pszFileName);

            ptLineClientTarget = NULL;

            for (i = 0; i < pXxxClientList->dwNumUsedEntries; i++)
            {
                ptLineClientTmp = (PTLINECLIENT) pXxxClientList->aEntries[i];

                try
                {
                    //
                    // Recall that all app names start with '"'
                    //

                    LOG((TL_INFO,
                        "LHandoff: Looking for [%ls] list entry [%ls]",
                        pszFileName,
                        ptLineClientTmp->ptLineApp->pszModuleName
                        ));

                    if ((_wcsicmp(
                            pszFileName,
                            ptLineClientTmp->ptLineApp->pszModuleName + 1
                            ) == 0) &&

                        (ptLineClientTmp->dwPrivileges &
                            LINECALLPRIVILEGE_OWNER))
                    {
                        ptLineClientTarget = ptLineClientTmp;
                    }
                }
                myexcept
                {
                    // just continue
                }
            }

            if (ptLineClientTarget == NULL)
            {
                pParams->lResult = LINEERR_TARGETNOTFOUND;
                goto LHandoff_freeXxxClientList;
            }
            else if (ptLineClientTarget == ptLineClientApp)
            {
                pParams->lResult = LINEERR_TARGETSELF;
                goto LHandoff_freeXxxClientList;
            }
        }
        else
        {
            //
            // "Non-directed" handoff
            //
            // Validate the media mode, then walk thru the list of line
            // clients and find the highest pri one with owner privileges
            // that wants calls of the specified media mode
            //

            switch (dwAPIVersion)
            {
            case TAPI_VERSION1_0:

                dwValidMediaModes = AllMediaModes1_0;
                break;

            case TAPI_VERSION1_4:
            case TAPI_VERSION2_0:

                dwValidMediaModes = AllMediaModes1_4;
                break;

            //case TAPI_VERSION2_1:
            //case TAPI_VERSION2_2:
            default: //case TAPI_VERSION_CURRENT:

                dwValidMediaModes = AllMediaModes2_1;
                break;
            }

            if ((dwMediaMode == 0) ||
                (dwAPIVersion <= TAPI_VERSION2_1 ) &&
                    !IsOnlyOneBitSetInDWORD(dwMediaMode) ||
                (dwMediaMode & (dwValidMediaModes ^ 0x00ffffff)))
            {
                pParams->lResult = LINEERR_INVALMEDIAMODE;
                goto LHandoff_freeXxxClientList;
            }

            if ((ptLineClientTarget = GetHighestPriorityLineClient(
                    ptLine,
                    dwMediaMode,
                    0xffffffff

                    )) == NULL)
            {
                pParams->lResult = LINEERR_TARGETNOTFOUND;
                goto LHandoff_freeXxxClientList;
            }
            else if (ptLineClientTarget == ptLineClientApp)
            {
                pParams->lResult = LINEERR_TARGETSELF;
                goto LHandoff_freeXxxClientList;
            }

        }


        //
        // We've found a target tLineClient. See if it already has a
        // tCallClient for this call, and if not create one.  Then set
        // the privilege on the target's tCallClient to OWNER & send
        // the appropriate msgs.
        //

        if (pXxxClientList != &xxxClientList)
        {
            ServerFree (pXxxClientList);
        }

        if ((lResult = GetCallClientListFromCall(
                ptCall,
                &pXxxClientList
                )))
        {
            pParams->lResult = lResult;
            goto LHandoff_epilog;
        }

        {
            BOOL            bCreatedtCallClient,
                            bTargetAlreadyOwner = FALSE;
            HANDLE          hMutex;
            PTCALLCLIENT    ptCallClientTarget = NULL, ptCallClientTmp;


            for (i = 0; i < pXxxClientList->dwNumUsedEntries; i++)
            {
                ptCallClientTmp = (PTCALLCLIENT) pXxxClientList->aEntries[i];

                try
                {
                    if (ptCallClientTmp->ptLineClient == ptLineClientTarget)
                    {
                        ptCallClientTarget = ptCallClientTmp;
                        break;
                    }
                }
                myexcept
                {
                    // just continue
                }
            }

            if (!ptCallClientTarget)
            {
                if ((lResult = CreatetCallClient(
                        ptCall,
                        ptLineClientTarget,
                        LINECALLPRIVILEGE_OWNER,
                        TRUE,
                        TRUE,
                        &ptCallClientTarget,
                        FALSE

                        )) != 0)
                {
                    pParams->lResult = lResult;
                    goto LHandoff_freeXxxClientList;
                }

                bCreatedtCallClient = TRUE;
            }
            else
            {
                bCreatedtCallClient = FALSE;
            }

            if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
            {
                DWORD dwCallInfoState, dwCallState, dwCallStateMode;


                if (bCreatedtCallClient)
                {
                    //
                    // CreatetCallClient will have already sent out the
                    // appropriate CALLINFO msgs & updated NumOwners field
                    //

                    dwCallInfoState = 0;
                }
                else if (ptCallClientTarget->dwPrivilege ==
                            LINECALLPRIVILEGE_MONITOR)
                {
                    ptCallClientTarget->dwPrivilege = LINECALLPRIVILEGE_OWNER;

                    ptCall->dwNumOwners++;
                    ptCall->dwNumMonitors--;

                    dwCallInfoState = LINECALLINFOSTATE_NUMOWNERINCR |
                        LINECALLINFOSTATE_NUMMONITORS;
                }
                else
                {
                    //
                    // Ideally we should just be able to exit at this point.
                    // However, TAPI 1.x will send a CALLSTATE msg with
                    // dwParam3 == OWNER to the target app even though it
                    // already is an OWNER.  Some Intel app relies on this
                    // behavior, so we'll preserve it for now...
                    //

                    bTargetAlreadyOwner = TRUE;
                    dwCallInfoState = 0;
                }

                dwCallState     = ptCall->dwCallState;
                dwCallStateMode = ptCall->dwCallStateMode;

                UNLOCKTCALL(ptCall);

                if (dwCallInfoState ||
                    bCreatedtCallClient ||
                    bTargetAlreadyOwner)
                {
                    BOOL            bIndicatePrivilege = TRUE;
                    PTCLIENT        ptClientTarget;
                    ASYNCEVENTMSG   msg[2];


                    if (bCreatedtCallClient)
                    {
                        try
                        {
                            if (ptLineClientTarget->dwAPIVersion >=
                                    TAPI_VERSION2_0 &&
                                !FMsgDisabled(
                                    ptLineClientTarget->ptLineApp->dwAPIVersion,
                                    ptLineClientTarget->adwEventSubMasks,
                                    LINE_APPNEWCALL,
                                    0
                                    ))
                            {
                                ASYNCEVENTMSG   newCallMsg[2],
                                                *pNewCallMsg = newCallMsg;
                                PTCONFERENCELIST    pConfList;
                                BOOL                bConfParent = FALSE;


                                pNewCallMsg->TotalSize  =
                                    sizeof (ASYNCEVENTMSG) + 3*sizeof (DWORD);
                                pNewCallMsg->fnPostProcessProcHandle = 0;
                                pNewCallMsg->hDevice      =
                                    ptLineClientTarget->hRemoteLine;

                                pNewCallMsg->Msg        = LINE_APPNEWCALL;
                                pNewCallMsg->Param1     =
                                    ptCall->dwAddressID;
                                pNewCallMsg->Param2     =
                                    ptCallClientTarget->hCall;
                                pNewCallMsg->Param3     =
                                    LINECALLPRIVILEGE_OWNER;

                                *(&pNewCallMsg->Param4 + 1) =
                                    ptCall->dwCallID;
                                *(&pNewCallMsg->Param4 + 2) =
                                    ptCall->dwRelatedCallID;
                                if ((pConfList = ptCall->pConfList) &&
                                    (pConfList != (PTCONFERENCELIST) LongToPtr(0xffffffff)) &&
                                    (pConfList->aptCalls[0] == ptCall))
                                {
                                    bConfParent = TRUE;
                                }
                                *(&pNewCallMsg->Param4 + 3) = (DWORD) bConfParent;

                                pNewCallMsg->InitContext =
                                    ptLineClientTarget->ptLineApp->
                                        InitContext;

                                pNewCallMsg->OpenContext =
                                    ptLineClientTarget->OpenContext;

                                ptClientTarget = ptCallClientTarget->ptClient;

                                if (ptCallClientTarget->dwKey ==
                                        TCALLCLIENT_KEY)
                                {
                                    bIndicatePrivilege = FALSE;
                                    WriteEventBuffer(
                                        ptClientTarget,
                                        pNewCallMsg
                                        );
                                }
                            }
                        }
                        myexcept
                        {
                        }

                    }

                    msg->TotalSize = sizeof (ASYNCEVENTMSG) +
                        sizeof (HCALLHUB);

                    msg->fnPostProcessProcHandle = 0;

                    msg->Msg     = LINE_CALLSTATE;
                    msg->Param1  = dwCallState;
                    msg->Param2  = dwCallStateMode;
                    msg->Param3  = (bIndicatePrivilege ?
                        LINECALLPRIVILEGE_OWNER : 0);

                    try
                    {
                        msg->hDevice = ptCallClientTarget->hCall;

                        msg->InitContext =
                            ptLineClientTarget->ptLineApp->InitContext;

                        msg->OpenContext =
                            ptLineClientTarget->OpenContext;

                        *((LPHCALLHUB)(&msg->Param4 + 1)) = 
                            (ptCallClientTarget->ptCallHubClient)?
                                ptCallClientTarget->ptCallHubClient->hCallHub : 
                                (HCALLHUB)(ULONG_PTR)NULL;

                        ptClientTarget = ptCallClientTarget->ptClient;

                        if (ptCallClientTarget->dwKey == TCALLCLIENT_KEY &&
                            !FMsgDisabled (
                                ptCallClientTarget->ptLineClient->ptLineApp->dwAPIVersion,
                                ptCallClientTarget->adwEventSubMasks,
                                LINE_CALLSTATE,
                                dwCallState
                                ))
                        {
                            WriteEventBuffer (ptClientTarget, msg);
                        }
                    }
                    myexcept
                    {
                    }

                    if (dwCallInfoState != 0)
                    {
                        LineEventProc(
                            (HTAPILINE)(ULONG_PTR)hLine,
                            (HTAPICALL)(ULONG_PTR)hCall,
                            LINE_CALLINFO,
                            dwCallInfoState,
                            0,
                            0
                            );
                    }

                    if (bCreatedtCallClient)
                    {
                        UpdateCallHubHashing(ptCall);
                    }
                }
            }
        }

LHandoff_freeXxxClientList:

        if (pXxxClientList != &xxxClientList)
        {
            ServerFree (pXxxClientList);
        }
    }

LHandoff_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "Handoff"
        );
}


void
WINAPI
LHold(
    PTCLIENT            ptClient,
    PLINEHOLD_PARAMS    pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineHold;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            pParams->hCall,             // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEHOLD,                // provider func index
            &pfnTSPI_lineHold,          // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "Hold"                      // func name

            )) > 0)
    {
        pParams->lResult = CallSP2(
            pfnTSPI_lineHold,
            "lineHold",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Hold"
        );
}


void
WINAPI
LInitialize(
    PTCLIENT                ptClient,
    PLINEINITIALIZE_PARAMS  pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL        bInitClient = FALSE;
    DWORD       dwFriendlyNameSize, dwModuleNameSize;
    PTLINEAPP   ptLineApp;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwFriendlyNameOffset
            ) ||

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwModuleNameOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    //
    // Alloc & init a new tLineApp
    //

    dwFriendlyNameSize = sizeof(WCHAR) * (1 + lstrlenW(
        (PWSTR)(pDataBuf + pParams->dwFriendlyNameOffset))
        );

    dwModuleNameSize = sizeof(WCHAR) * (2 + lstrlenW(
        (PWSTR)(pDataBuf + pParams->dwModuleNameOffset))
        );

    if (!(ptLineApp = ServerAlloc(
            sizeof(TLINEAPP) +
            dwFriendlyNameSize +
            dwModuleNameSize
            )))
    {
        pParams->lResult = LINEERR_NOMEM;
        goto LInitialize_return;
    }

    LOG((TL_INFO, "LInitialize: calling NewObject ptLineApp %p, pParams->InitContext %lx", ptLineApp, pParams->InitContext));

    if (!(ptLineApp->hLineApp = (HLINEAPP) NewObject(
            ghHandleTable,
            ptLineApp,
            NULL
            )))
    {
        pParams->lResult = LINEERR_NOMEM;
        ServerFree (ptLineApp);
        goto LInitialize_return;
    }

    LOG((TL_INFO, "LInitialize: NewObject returned hLineApp %lx", ptLineApp->hLineApp));

    ptLineApp->dwKey        = TLINEAPP_KEY;
    ptLineApp->ptClient     = ptClient;

    LOG((TL_INFO, "LInitialize: initializing ptLineApp->InitContext with %lx", pParams->InitContext));

    ptLineApp->InitContext  = pParams->InitContext;
    ptLineApp->dwAPIVersion = pParams->dwAPIVersion;
    
    LOG((TL_INFO, "LInitialize: initialized ptLineApp->dwAPIVersion with %lx", pParams->dwAPIVersion));

    ptLineApp->dwFriendlyNameSize = dwFriendlyNameSize;
    ptLineApp->pszFriendlyName    = (WCHAR *) (ptLineApp + 1);

    wcscpy(
        ptLineApp->pszFriendlyName,
        (PWSTR)(pDataBuf + pParams->dwFriendlyNameOffset)
        );

    //
    // Note: we prepend the '"' char to the saved module name to aid in
    //       priority determination for incoming calls
    //

    ptLineApp->dwModuleNameSize = dwModuleNameSize;
    ptLineApp->pszModuleName = (WCHAR *)((LPBYTE)(ptLineApp + 1) +
                                         dwFriendlyNameSize);

    ptLineApp->pszModuleName[0] = '"';

    wcscpy(
        &ptLineApp->pszModuleName[1],
        (WCHAR *)(pDataBuf + pParams->dwModuleNameOffset)
        );

    _wcsupr (&ptLineApp->pszModuleName[1]);


    //
    // Safely insert new tLineApp at front of tClient's tLineApp list
    //

    if (ptClient->ptLineApps == NULL)
    {
        bInitClient = TRUE;
    }

    if (WaitForExclusiveClientAccess (ptClient))
    {
        if (ptLineApp->dwAPIVersion <= TAPI_VERSION3_0)
        {
            FillMemory (
                ptLineApp->adwEventSubMasks, 
                sizeof(DWORD) * EM_NUM_MASKS,
                (BYTE) 0xff
                );
        }
        else
        {
            CopyMemory (
                ptLineApp->adwEventSubMasks, 
                ptClient->adwEventSubMasks,
                sizeof(DWORD) * EM_NUM_MASKS
                );
        }
        
        if ((ptLineApp->pNext = ptClient->ptLineApps))
        {
            ptLineApp->pNext->pPrev = ptLineApp;
        }

        ptClient->ptLineApps = ptLineApp;

        UNLOCKTCLIENT (ptClient);
    }
    else
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        goto LInitialize_error1;
    }


    //
    // Check if global reinit flag set
    //

    if (TapiGlobals.dwFlags & TAPIGLOBALS_REINIT)
    {
        pParams->lResult = LINEERR_REINIT;
        goto LInitialize_error2;
    }


    //
    // See if we need to go thru init
    //

    TapiEnterCriticalSection (&TapiGlobals.CritSec);

    if ((TapiGlobals.dwNumLineInits == 0) &&
        (TapiGlobals.dwNumPhoneInits == 0) &&
        !gbServerInited)
    {

        if ((pParams->lResult = ServerInit(FALSE)) != 0)
        {
            TapiLeaveCriticalSection (&TapiGlobals.CritSec);
            goto LInitialize_error2;
        }
        gbServerInited = TRUE;
    }

#if TELE_SERVER
    if (bInitClient)
    {
        if (pParams->lResult = InitializeClient(ptClient))
        {
            TapiLeaveCriticalSection (&TapiGlobals.CritSec);
            goto LInitialize_error2;
        }
    }
#else
    pParams->lResult = 0; // That's what happens if it's not a tele_server...
#endif


    //
    // Fill in the return values
    //


    pParams->hLineApp  = ptLineApp->hLineApp;

    LOG((TL_INFO, "LInitialize: returning pParams->hLineApp %p", pParams->hLineApp));

    pParams->dwNumDevs = TapiGlobals.dwNumLines;

    LOG((TL_INFO, "LInitialize: returning pParams->dwNumDevs %p", pParams->dwNumDevs));

#if TELE_SERVER
    if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
        !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
    {
        pParams->dwNumDevs = ptClient->dwLineDevices;
        LOG((TL_TRACE,  "LInitialize: returning pParams->dwNumDevs %p (again)", pParams->dwNumDevs));
    }
#endif


    //
    // Increment total num line inits
    //

    TapiGlobals.dwNumLineInits++;

    *pdwNumBytesReturned = sizeof (LINEINITIALIZE_PARAMS);

    TapiLeaveCriticalSection (&TapiGlobals.CritSec);

    goto LInitialize_return;


LInitialize_error2:

    if (WaitForExclusiveClientAccess (ptClient))
    {
        if (ptLineApp->pNext)
        {
            ptLineApp->pNext->pPrev = ptLineApp->pPrev;
        }

        if (ptLineApp->pPrev)
        {
            ptLineApp->pPrev->pNext = ptLineApp->pNext;
        }
        else
        {
            ptClient->ptLineApps = ptLineApp->pNext;
        }

        UNLOCKTCLIENT (ptClient);

    }

LInitialize_error1:

    DereferenceObject (ghHandleTable, ptLineApp->hLineApp, 1);

LInitialize_return:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineInitialize: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE,
            "lineInitialize: exit, result=x%x",
            pParams->lResult
            ));
#endif

    return;
}


void
LMakeCall_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
    PTCALL          ptCall = (PTCALL) pAsyncRequestInfo->dwParam1;
    DWORD           hpCallHandle = DWORD_CAST(pAsyncRequestInfo->dwParam2,__FILE__,__LINE__);

    PTCALLCLIENT    ptCallClient;


    if (WaitForExclusivetCallAccess (ptCall, TINCOMPLETECALL_KEY))
    {
        PTCALL      ptCallThen;
        HCALL       hCallThen = (HCALL)pAsyncRequestInfo->dwParam5;


        //
        // Check to make sure this is the call we think it is (that the
        // pointer wasn't freed by a previous call to lineClose/Shutdown
        // and realloc'd for use as a ptCall again)
        //

        if (ptCall->hCall != hCallThen)
        {
            UNLOCKTCALL(ptCall);
            goto LMakeCall_PostProcess_bad_ptCall;
        }

        ptCallClient = ptCall->ptCallClients;

        if (pAsyncEventMsg->Param2 == 0)  // success
        {
            //
            // In general it's ok with us if service providers want to
            // specify NULL as their hdCall (could be an index in an
            // array).  But in the TSPI_lineForward case, the spec says
            // that a NULL hdCall value following successful completion
            // indicates that no call was created, so in that case we
            // want to nuke the tCall & tCallClient we created, and
            // indicate a NULL call handle to the client. A non-zero
            // pAsyncRequestInfo->dwParam3 tells us that we are
            // post-processing a lineForward request, otherwise it's a
            // make call or similar (non-Forward) request.
            //

            if (pAsyncRequestInfo->dwParam3 && !ptCall->hdCall)
            {
                goto LMakeCall_PostProcess_cleanupCalls;
            }


            //
            // Check to see if the app closed the line & left us with
            // 0 call clients (in which case it'll also be taking care of
            // cleaning up this tCall too)
            //

            if (ptCall->ptCallClients == NULL)
            {
                UNLOCKTCALL(ptCall);

                ptCallClient = (PTCALLCLIENT) NULL;

                if (pAsyncEventMsg->Param2 == 0)
                {
                    pAsyncEventMsg->Param2 = LINEERR_INVALLINEHANDLE;
                }

                goto LMakeCall_PostProcess_initMsgParams;
            }


            //
            // Retrieve the various call IDs, then check if call
            // client was destroyed by another thread (due to
            // lineClose/Shutdown) while we were getting the call ID.
            // If so, we'll need to clean up the tCall, since we know
            // the other thread didn't do it because GetCallIDs marks
            // the call as a zombie.
            //

            GetCallIDs (ptCall);

            if (ptCall->ptCallClients == NULL)
            {
                goto LMakeCall_PostProcess_cleanupCalls;
            }


            //
            // Stuff the various call IDs in the var data section
            // of the ASYNCEVENTMSG.
            //
            // Make sure to increment the dwTotalSize of the ASYNCEVENTMSG
            // as appropriate.  We rely on the fact that CompletionProc()
            // calls us with a AsyncEventMsg buffer which is big enough to
            // handle a few extra DWORDs.
            //

            pAsyncEventMsg->Param3 = ptCallClient->hCall;

            pAsyncEventMsg->TotalSize +=
                3 * sizeof (pAsyncEventMsg->Param1);

            *(&pAsyncEventMsg->Param4 + 1) = ptCall->dwAddressID;
            *(&pAsyncEventMsg->Param4 + 2) = ptCall->dwCallID;
            *(&pAsyncEventMsg->Param4 + 3) = ptCall->dwRelatedCallID;


            //
            // Mark the calls as valid, the release the mutex.
            //

            ptCall->dwKey       = TCALL_KEY;
            ptCallClient->dwKey = TCALLCLIENT_KEY;

            UNLOCKTCALL(ptCall);


            //
            // Create monitor tCallClients
            //

            if (ptCallThen = ReferenceObject(ghHandleTable, hCallThen, TCALL_KEY))
            {
                if (ptCallThen == ptCall)
                {
                    CreateCallMonitors (ptCall, FALSE);
                }

                DereferenceObject(ghHandleTable, hCallThen, 1);
            }
        }
        else    // error
        {

LMakeCall_PostProcess_cleanupCalls:

            //
            // Invalidate the tCall, & if there's still a tCallClient
            // (might have already been destroyed by a lineClose/Shutdown
            // in another thread) invalidate it too. Then unlock the
            // tCall & remove the object(s) from the list(s).
            //

            ptCall->dwKey = INVAL_KEY;

            if (ptCall->ptCallClients)
            {
                ptCallClient->dwKey = INVAL_KEY;
                ptCall->lActiveFastCallClients--;
            }
            else
            {
                ptCallClient = NULL;
            }

            UNLOCKTCALL(ptCall);

            RemoveCallFromLineList (ptCall);

            if (ptCallClient)
            {
                DereferenceObject (ghHandleTable, ptCallClient->hCall, 1);
                RemoveCallClientFromLineClientList (ptCallClient);
            }


            //
            // Make sure all fast call clients cleaned up before free tCall
            //

            while (ptCall->lActiveFastCallClients != 0)
            {
                Sleep (5);
            }

            FreetCall  (ptCall);

            ptCallClient = NULL;
        }
    }
    else
    {
        //
        // If here we can assume that the call was already destroyed
        // and just fail the request
        //

LMakeCall_PostProcess_bad_ptCall:

        ptCallClient = (PTCALLCLIENT) NULL;

        if (pAsyncEventMsg->Param2 == 0)
        {
            pAsyncEventMsg->Param2 = LINEERR_OPERATIONFAILED;
        }
    }


LMakeCall_PostProcess_initMsgParams:

    //
    // Fill in the params to pass to client (important to remotesp in both
    // the success & fail cases so it can either init or clean up drvCall)
    //

    pAsyncEventMsg->Param4 = hpCallHandle;
}


void
WINAPI
LMakeCall(
    PTCLIENT                ptClient,
    PLINEMAKECALL_PARAMS    pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineMakeCall;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;

    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEMAKECALL,            // provider func index
            &pfnTSPI_lineMakeCall,      // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "MakeCall"                  // func name

            )) > 0)
    {
        LONG                lResult;
        PTCALL              ptCall;
        LPWSTR              lpszDestAddress;
        HCALL               hCall;
        PTCALLCLIENT        ptCallClient;
        LPLINECALLPARAMS    pCallParamsApp, pCallParamsSP;

        LOG((TL_INFO, "LMakeCall: LINEPROLOG succeeded ."));

        //
        // Verify size/offset/string params given our input buffer/size
        //

        if (((pParams->dwDestAddressOffset != TAPI_NO_DATA)  &&

                IsBadStringParam(
                    dwParamsBufferSize,
                    pDataBuf,
                    pParams->dwDestAddressOffset
                    ))  ||

            ((pParams->dwCallParamsOffset != TAPI_NO_DATA)  &&

                IsBadStructParam(
                    dwParamsBufferSize,
                    pDataBuf,
                    pParams->dwCallParamsOffset
                    )))

        {
            LOG((TL_INFO, "LMakeCall: LINEERR_STRUCTURETOOSMALL."));

            //
            // Note: Passing back ERR_STRUCTURETOOSMALL handles the case
            //       where app has passed in a bad size in the callparams,
            //       and does so in a spec-friendly manner.  The only
            //       other reason we'd end up here would be an rpc attack,
            //       and in that case it's just important that we fail.
            //

            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LMakeCall_return;
        }


        pCallParamsApp = (LPLINECALLPARAMS)
            (pParams->dwCallParamsOffset == TAPI_NO_DATA ?
                0 : (pDataBuf + pParams->dwCallParamsOffset));

        LOG((TL_INFO, "LMakeCall: pCallParamsApp %p.", pCallParamsApp));

        if (pCallParamsApp)
        {
            DWORD           dwAPIVersion, dwSPIVersion;


            if (GetLineVersions(
                    ptLineClient,
                    &dwAPIVersion,
                    &dwSPIVersion

                    ) != 0)
            {
                LOG((TL_ERROR, "LMakeCall: GetLineVersions failed. LINEERR_INVALLINEHANDLE"));

                lRequestID = LINEERR_INVALLINEHANDLE;
                goto LMakeCall_return;
            }

            if ((lResult = ValidateCallParams(
                    pCallParamsApp,
                    &pCallParamsSP,
                    dwAPIVersion,
                    dwSPIVersion,
                    pParams->dwAsciiCallParamsCodePage

                    )) != 0)
            {
                LOG((TL_ERROR, "LMakeCall: ValidateCallParams failed. %lx", lResult));
                lRequestID = lResult;
                goto LMakeCall_return;
            }
        }
        else
        {
            pCallParamsSP = (LPLINECALLPARAMS) NULL;
        }

        if (CreatetCallAndClient(
                ptLineClient,
                &ptCall,
                &ptCallClient,
                pCallParamsSP,
                &hCall,
                NULL

                ) != 0)
        {
            LOG((TL_ERROR, "LMakeCall: CreatetCallAndClient failed. LINEERR_NOMEM"));

            lRequestID = LINEERR_NOMEM;
            goto LMakeCall_freeCallParams;
        }

        pAsyncRequestInfo->pfnPostProcess = LMakeCall_PostProcess;
        pAsyncRequestInfo->htXxx    = (ULONG_PTR)ptCallClient->ptLineClient->ptLine->hLine;
        pAsyncRequestInfo->dwParam1 = (ULONG_PTR) ptCall;
        pAsyncRequestInfo->dwParam2 = pParams->hpCall;
        pAsyncRequestInfo->dwParam5 = (ULONG_PTR)hCall;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        if (pParams->dwDestAddressOffset == TAPI_NO_DATA)
        {
            LOG((TL_ERROR, "LMakeCall: pParams->dwDestAddressOffset == TAPI_NO_DATA"));

            lpszDestAddress = NULL;
        }
        else
        {
            lpszDestAddress = (LPWSTR)(pDataBuf +pParams->dwDestAddressOffset);
        }

        LOG((TL_TRACE,  "LMakeCall: calling CallSP7"));

        pParams->lResult = CallSP7(
                pfnTSPI_lineMakeCall,
                "lineMakeCall",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (ULONG_PTR) hCall,
                (ULONG_PTR) &ptCall->hdCall,
                (ULONG_PTR) lpszDestAddress,
                (DWORD) pParams->dwCountryCode,
                (ULONG_PTR) pCallParamsSP
                );

        LOG((TL_INFO, "LMakeCall: CallSP7 returnded %lx", pParams->lResult));


        SetDrvCallFlags(
            hCall,
            DCF_SPIRETURNED | (IS_LRESULT_NOTERROR(pParams->lResult) ?
                DCF_DRVCALLVALID : 0)
            );

LMakeCall_freeCallParams:

        if (pCallParamsSP != pCallParamsApp)
        {
            ServerFree (pCallParamsSP);
        }
    }

LMakeCall_return:

    LOG((TL_TRACE,  "LMakeCall: calling LINEEPILOGASYNC"));

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "MakeCall"
        );

    LOG((TL_TRACE,  "LMakeCall: LINEEPILOGASYNC returned"));

}

void
WINAPI
LMonitorDigits(
    PTCLIENT                    ptClient,
    PLINEMONITORDIGITS_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVCALL        hdCall;
    TSPIPROC        pfnTSPI_lineMonitorDigits;
    DWORD               objectToDereference;
    PTCALLCLIENT    ptCallClient, ptCallClient2;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_MONITOR,  // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEMONITORDIGITS,       // provider func index
            &pfnTSPI_lineMonitorDigits, // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "MonitorDigits"             // func name

            )) == 0)
    {
        DWORD           dwUnionDigitModes;
        PTCALL          ptCall;


        if ((pParams->dwDigitModes & (~AllDigitModes)))
        {
            pParams->lResult = LINEERR_INVALDIGITMODE;
            goto LMonitorDigits_epilog;
        }


        //
        // Determine the new union of modes
        //

        dwUnionDigitModes = pParams->dwDigitModes;

        try
        {
            ptCall = ptCallClient->ptCall;
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LMonitorDigits_epilog;
        }

        if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
        {
            ptCallClient2 = ptCall->ptCallClients;

            while (ptCallClient2)
            {
                if (ptCallClient2 != ptCallClient)
                {
                    dwUnionDigitModes |=
                        ptCallClient2->dwMonitorDigitModes;
                }

                ptCallClient2 = ptCallClient2->pNextSametCall;
            }

            UNLOCKTCALL (ptCall);
        }
        else
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LMonitorDigits_epilog;
        }

        if ((pParams->lResult = CallSP2(
                pfnTSPI_lineMonitorDigits,
                "lineMonitorDigits",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdCall,
                (DWORD) dwUnionDigitModes

                )) == 0)
        {
            ptCallClient->dwMonitorDigitModes = pParams->dwDigitModes;
        }
    }

LMonitorDigits_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "MonitorDigits"
        );
}


void
WINAPI
LMonitorMedia(
    PTCLIENT                    ptClient,
    PLINEMONITORMEDIA_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVCALL        hdCall;
    TSPIPROC        pfnTSPI_lineMonitorMedia;
    DWORD               objectToDereference;
    PTCALLCLIENT    ptCallClient, ptCallClient2;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_MONITOR,  // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEMONITORMEDIA,        // provider func index
            &pfnTSPI_lineMonitorMedia,  // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "MonitorMedia"              // func name

            )) == 0)
    {
        DWORD           dwAPIVersion, dwValidMediaModes, dwUnionMediaModes;
        PTCALL          ptCall;


        //
        // Validate the specified modes
        //

        try
        {
            ptCall = ptCallClient->ptCall;
            dwAPIVersion = ptCallClient->ptLineClient->dwAPIVersion;

            if (ptCallClient->dwKey != TCALLCLIENT_KEY)
            {
                pParams->lResult = LINEERR_INVALCALLHANDLE;
                goto LMonitorMedia_epilog;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LMonitorMedia_epilog;
        }

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:

            dwValidMediaModes = AllMediaModes1_0;
            break;

        case TAPI_VERSION1_4:
        case TAPI_VERSION2_0:

            dwValidMediaModes = AllMediaModes1_4;
            break;

        //case TAPI_VERSION2_1:
        //case TAPI_VERSION2_2:
        //case TAPI_VERSION_CURRENT:
        default:

            dwValidMediaModes = AllMediaModes2_1;
            break;
        }

        if (pParams->dwMediaModes & (~dwValidMediaModes & 0x00FFFFFF))
        {
            pParams->lResult = LINEERR_INVALMEDIAMODE;
            goto LMonitorMedia_epilog;
        }


        //
        // Determine the new union of modes
        //

        dwUnionMediaModes = pParams->dwMediaModes;

        if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
        {
            ptCallClient2 = ptCall->ptCallClients;

            while (ptCallClient2)
            {
                if (ptCallClient2 != ptCallClient)
                {
                    dwUnionMediaModes |=
                        ptCallClient2->dwMonitorMediaModes;
                }

                ptCallClient2 = ptCallClient2->pNextSametCall;
            }

            UNLOCKTCALL (ptCall);
        }
        else
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LMonitorMedia_epilog;
        }

        if ((pParams->lResult = CallSP2(
                pfnTSPI_lineMonitorMedia,
                "lineMonitorMedia",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdCall,
                (DWORD) dwUnionMediaModes

                )) == 0)
        {
            ptCallClient->dwMonitorMediaModes = pParams->dwMediaModes;
        }
    }

LMonitorMedia_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "MonitorMedia"
        );
}


void
WINAPI
LMonitorTones(
    PTCLIENT                    ptClient,
    PLINEMONITORTONES_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVCALL        hdCall;
    TSPIPROC        pfnTSPI_lineMonitorTones;
    DWORD               objectToDereference;
    PTCALLCLIENT    ptCallClient, ptCallClient2;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if ((pParams->dwTonesOffset != TAPI_NO_DATA)  &&

        ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwNumEntries,      // really dwNumEntries *
                                        //     sizeof(LINEMONITORTONE)
            pParams->dwTonesOffset,
            sizeof(DWORD),
            "LMonitorTones",
            "pParams->MSPBuffer"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_MONITOR,  // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEMONITORTONES,        // provider func index
            &pfnTSPI_lineMonitorTones,  // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "MonitorTones"              // func name

            )) == 0)
    {
        //
        // If this is a remotesp call then we want to mark the
        // tCallClient as being interested in LINE_MONITORTONES
        // messages (due to our kludgy handling of this msg, see
        // comments in the msg handler in LineEventProc()).
        //

        PTCALL          ptCall;


        try
        {
            ptCall = ptCallClient->ptCall;

            if (ptCall->ptProvider != pRemoteSP)
            {
                ptCall = NULL;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LMonitorTones_epilog;
        }

        if (ptCall)
        {
            if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
            {
                for(
                    ptCallClient2 = ptCall->ptCallClients;
                    (ptCallClient2  &&  (ptCallClient2 != ptCallClient));
                    ptCallClient2 = ptCallClient2->pNextSametCall
                    );

                if (ptCallClient2 == ptCallClient)
                {
                    ptCallClient->bMonitoringTones =
                        (pParams->dwTonesOffset == TAPI_NO_DATA ? 0 : 1);
                }

                UNLOCKTCALL (ptCall);

                if (!ptCallClient2)
                {
                    pParams->lResult = LINEERR_INVALCALLHANDLE;
                    goto LMonitorTones_epilog;
                }
            }
            else
            {
                pParams->lResult = LINEERR_INVALCALLHANDLE;
                goto LMonitorTones_epilog;
            }
        }

        pParams->lResult = CallSP4(
            pfnTSPI_lineMonitorTones,
            "lineMonitorTones",
            SP_FUNC_SYNC,
            (ULONG_PTR) hdCall,
            (DWORD) pParams->hCall,
            (ULONG_PTR) (pParams->dwTonesOffset == TAPI_NO_DATA ? 0 :
                pDataBuf + pParams->dwTonesOffset),
            (DWORD) pParams->dwNumEntries / sizeof (LINEMONITORTONE)
            );
    }

LMonitorTones_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "MonitorTones"
        );
}


void
WINAPI
LNegotiateAPIVersion(
    PTCLIENT                        ptClient,
    PLINENEGOTIATEAPIVERSION_PARAMS pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{

    //
    // Note: TAPI_VERSION1_0 <= dwNegotiatedAPIVersion <= dwSPIVersion
    //

    DWORD   dwDeviceID = pParams->dwDeviceID;

    LOG((TL_TRACE,  "LNegotiateAPIVersion: started. dwDeviceID %lx, dwAPILowVersion %lx dwAPIHighVersion %lx", 
        pParams->dwDeviceID, pParams->dwAPILowVersion, pParams->dwAPIHighVersion));

    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (dwParamsBufferSize < sizeof (LINEEXTENSIONID))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if (TapiGlobals.dwNumLineInits == 0)
    {
        pParams->lResult = LINEERR_UNINITIALIZED;
        goto LNegotiateAPIVersion_exit;
    }


#if TELE_SERVER
    if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
        !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
    {
        try
        {
            if (dwDeviceID >= ptClient->dwLineDevices)
            {
                pParams->lResult = LINEERR_BADDEVICEID;
                goto LNegotiateAPIVersion_exit;
            }
            dwDeviceID = ptClient->pLineDevices[dwDeviceID];
        }
        myexcept
        {
            LOG((TL_ERROR, "ptClient excepted in LineNegotiateAPIVersion"));
            pParams->lResult = LINEERR_INVALLINEHANDLE;
            goto LNegotiateAPIVersion_exit;
        }
    }
#endif


    if (dwDeviceID < TapiGlobals.dwNumLines)
    {
        DWORD       dwAPIHighVersion = pParams->dwAPIHighVersion,
                    dwAPILowVersion  = pParams->dwAPILowVersion,
                    dwHighestValidAPIVersion;
        PTLINEAPP   ptLineApp;


        //
        // Do a minimax test on the specified lo/hi values
        //

        if ((dwAPILowVersion > dwAPIHighVersion) ||
            (dwAPILowVersion > TAPI_VERSION_CURRENT) ||
            (dwAPIHighVersion < TAPI_VERSION1_0))
        {
            LOG((TL_ERROR, "LNegotiateAPIVersion: LINEERR_INCOMPATIBLEAPIVERSION1"));

            pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
            goto LNegotiateAPIVersion_exit;
        }


        //
        // HACKALERT! Some dumb apps like SmarTerm negotiate specifying
        // a dwHighVersion of 0x7fffffff or higher, which can really
        // cause them problems (like when they try to pass down structures
        // of a size that was fine in the TAPI version under which the app
        // was built, but which were enlarged in subsequent versions of
        // TAPI, and the result is lots of LINEERR_STRUCTURETOOSMALL
        // errors).
        //
        // Since we're nice, accomodating people we'll try to munge the
        // dwHighVersion in these cases to be a value that makes sense, so
        // we don't end up negotiating a version that the app can't handle.
        //

        if (dwAPIHighVersion & 0xc0000000)
        {
            dwAPIHighVersion = (dwAPILowVersion > TAPI_VERSION1_0 ?
                dwAPILowVersion : TAPI_VERSION1_0);
        }


        //
        // Find the highest valid API version given the lo/hi values.
        // Since valid vers aren't consecutive we need to check for
        // errors that our minimax test missed.
        //

        if (dwAPIHighVersion < TAPI_VERSION_CURRENT)
        {
            if ((dwAPIHighVersion >= TAPI_VERSION3_0) &&
                (dwAPILowVersion <= TAPI_VERSION3_0))
            {
                dwHighestValidAPIVersion = TAPI_VERSION3_0;
            }
            else if ((dwAPIHighVersion >= TAPI_VERSION2_2) &&
                (dwAPILowVersion <= TAPI_VERSION2_2))
            {
                dwHighestValidAPIVersion = TAPI_VERSION2_2;
            }
            else if ((dwAPIHighVersion >= TAPI_VERSION2_1) &&
                (dwAPILowVersion <= TAPI_VERSION2_1))
            {
                dwHighestValidAPIVersion = TAPI_VERSION2_1;
            }
            else if ((dwAPIHighVersion >= TAPI_VERSION2_0) &&
                (dwAPILowVersion <= TAPI_VERSION2_0))
            {
                dwHighestValidAPIVersion = TAPI_VERSION2_0;
            }
            else if ((dwAPIHighVersion >= TAPI_VERSION1_4) &&
                (dwAPILowVersion <= TAPI_VERSION1_4))
            {
                dwHighestValidAPIVersion = TAPI_VERSION1_4;
            }
            else if ((dwAPIHighVersion >= TAPI_VERSION1_0) &&
                (dwAPILowVersion <= TAPI_VERSION1_0))
            {
                dwHighestValidAPIVersion = TAPI_VERSION1_0;
            }
            else
            {
                LOG((TL_ERROR, "LNegotiateAPIVersion: LINEERR_INCOMPATIBLEAPIVERSION2"));

                pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
                goto LNegotiateAPIVersion_exit;
            }
        }
        else
        {
            dwHighestValidAPIVersion = TAPI_VERSION_CURRENT;
        }


        //
        // WARNING!!! WARNING!!! WARNING!!! WARNING!!!
        // This code overwrites ptLineApp and later invalidates it.
        // Do NOT use ptLineApp after the MyReleaseMutex call.
        //
        if ((ptLineApp = WaitForExclusiveLineAppAccess(
                pParams->hLineApp,
                ptClient
                )))
        {

            LOG((TL_INFO, 
                "LNegotiateAPIVersion WaitForExclusiveLineAppAccess succeeded returned ptLineApp %p for hLineApp %p",
                ptLineApp, pParams->hLineApp));


            //
            // Is this app trying to negotiate something valid?
            //
            // If an app has called lineInitalize (as opposed to
            // lineInitializeEx), we'll clamp the max APIVersion they can
            // negotiate to 1.4.
            //

            if ( ptLineApp->dwAPIVersion < TAPI_VERSION2_0 )
            {
                dwHighestValidAPIVersion =
                    (dwHighestValidAPIVersion >= TAPI_VERSION1_4) ?
                    TAPI_VERSION1_4 : TAPI_VERSION1_0;
            }


            //
            // Save the highest valid API version the client says it supports
            // (we need this for determining which msgs to send to it)
            //

            if (dwHighestValidAPIVersion > ptLineApp->dwAPIVersion)
            {
                ptLineApp->dwAPIVersion = dwHighestValidAPIVersion;
            }

            UNLOCKTLINEAPP(ptLineApp);
        }
        else
        {
            LOG((TL_ERROR, "LNegotiateAPIVersion WaitForExclusiveLineAppAccess returned NULL"));

            pParams->lResult = LINEERR_INVALAPPHANDLE;
            goto LNegotiateAPIVersion_exit;
        }


        //
        // See if there's a valid match with the SPI ver
        //

        {
            DWORD               dwSPIVersion;
            PTLINELOOKUPENTRY   pLookupEntry;


            pLookupEntry = GetLineLookupEntry (dwDeviceID);
            if (NULL == pLookupEntry)
            {
                pParams->lResult = LINEERR_INVALAPPHANDLE;
                goto LNegotiateAPIVersion_exit;
            }

            dwSPIVersion = pLookupEntry->dwSPIVersion;

            if (pLookupEntry->bRemoved)
            {
                pParams->lResult = LINEERR_NODEVICE;
                goto LNegotiateAPIVersion_exit;
            }

            if (pLookupEntry->ptProvider == NULL)
            {
                pParams->lResult = LINEERR_NODRIVER;
                goto LNegotiateAPIVersion_exit;
            }

            if (dwAPILowVersion <= dwSPIVersion)
            {
                pParams->dwAPIVersion =
                    (dwHighestValidAPIVersion > dwSPIVersion ?
                    dwSPIVersion : dwHighestValidAPIVersion);


                //
                // Retrieve ext id (indicate no exts if GetExtID not exported)
                //

                if ((pLookupEntry->ptProvider->apfn[SP_LINEGETEXTENSIONID]))
                {
                    pParams->lResult = CallSP3(
                        pLookupEntry->ptProvider->
                        apfn[SP_LINEGETEXTENSIONID],
                        "lineGetExtensionID",
                        SP_FUNC_SYNC,
                        (DWORD) dwDeviceID,
                        (DWORD) dwSPIVersion,
                        (ULONG_PTR) pDataBuf
                        );

                    // the sp returned operationunavail.  we don't want
                    // to return that, so we just indicate that
                    // there are no extensions

                    if (pParams->lResult == LINEERR_OPERATIONUNAVAIL)
                    {
                        pParams->lResult = 0;
                        FillMemory (pDataBuf, sizeof (LINEEXTENSIONID), 0);
                    }
                }
                else
                {
                    // doesn't export it, so fill in with zeros
                    pParams->lResult = 0;
                    FillMemory (pDataBuf, sizeof (LINEEXTENSIONID), 0);
                }
            }
            else
            {

                LOG((TL_ERROR, "LNegotiateAPIVersion: LINEERR_INCOMPATIBLEAPIVERSION3"));
                pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
                goto LNegotiateAPIVersion_exit;
            }
        }

        pParams->dwExtensionIDOffset = 0;
        

        pParams->dwSize              = sizeof (LINEEXTENSIONID);

        
        *pdwNumBytesReturned = sizeof (LINEEXTENSIONID) + sizeof (TAPI32_MSG);
    }
    else
    {
        pParams->lResult = LINEERR_BADDEVICEID;
    }

LNegotiateAPIVersion_exit:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineNegotiateAPIVersion: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "lineNegotiateAPIVersion: exit, result=x%x",
            pParams->lResult
            ));
#endif

    return;
}


void
WINAPI
NegotiateAPIVersionForAllDevices(
    PTCLIENT                                    ptClient,
    PNEGOTIATEAPIVERSIONFORALLDEVICES_PARAMS    pParams,
    DWORD                                       dwParamsBufferSize,
    LPBYTE                                      pDataBuf,
    LPDWORD                                     pdwNumBytesReturned
    )
{
#if TELE_SERVER
    //
    // Note: TAPI_VERSION1_0 <= dwNegotiatedAPIVersion <= dwSPIVersion
    //

    DWORD               i,
                        dwNumLineDevices = pParams->dwNumLineDevices,
                        dwNumPhoneDevices = pParams->dwNumPhoneDevices,
                        dwAPIHighVersion = pParams->dwAPIHighVersion,
                        dwAPILowVersion  = TAPI_VERSION1_0,
                        dwHighestValidAPIVersion, *pdwAPIVersion;
    LPLINEEXTENSIONID   pExtID;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    i = pParams->dwLineAPIVersionListSize +
        pParams->dwLineExtensionIDListSize +
        pParams->dwPhoneAPIVersionListSize +
        pParams->dwPhoneExtensionIDListSize;

    if ((pParams->dwLineAPIVersionListSize & 0xc0000000) ||
        (pParams->dwLineExtensionIDListSize & 0xc0000000) ||
        (pParams->dwPhoneAPIVersionListSize & 0xc0000000) ||
        (pParams->dwPhoneExtensionIDListSize & 0xc0000000) ||
        (i > dwParamsBufferSize))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    //
    // Verify the specified dwNumLine/PhonesDevices
    //

    if (IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
    {
        if ((pParams->dwNumLineDevices > TapiGlobals.dwNumLines)  ||
            (pParams->dwNumPhoneDevices > TapiGlobals.dwNumPhones))
        {
            pParams->lResult = LINEERR_OPERATIONFAILED;
            return;
        }
    }
    else
    {
        if ((pParams->dwNumLineDevices > ptClient->dwLineDevices)  ||
            (pParams->dwNumPhoneDevices > ptClient->dwPhoneDevices))
        {
            pParams->lResult = LINEERR_OPERATIONFAILED;
            return;
        }
    }


    //
    //
    //

    if (TapiGlobals.dwNumLineInits == 0)
    {
        pParams->lResult = LINEERR_UNINITIALIZED;
        goto NegotiateAPIVersionForAllDevices_exit;
    }


    //
    // Do a minimax test on the specified lo/hi values
    //

    if ((dwAPILowVersion > dwAPIHighVersion) ||
        (dwAPILowVersion > TAPI_VERSION_CURRENT) ||
        (dwAPIHighVersion < TAPI_VERSION1_0))
    {
        pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
        goto NegotiateAPIVersionForAllDevices_exit;
    }


    //
    // Find the highest valid API version given the lo/hi values.
    // Since valid vers aren't consecutive we need to check for
    // errors that our minimax test missed.
    //

    if (dwAPIHighVersion < TAPI_VERSION_CURRENT)
    {
        if ((dwAPIHighVersion >= TAPI_VERSION3_0) &&
            (dwAPILowVersion <= TAPI_VERSION3_0))
        {
            dwHighestValidAPIVersion = TAPI_VERSION3_0;
        }
        else if ((dwAPIHighVersion >= TAPI_VERSION2_2) &&
            (dwAPILowVersion <= TAPI_VERSION2_2))
        {
            dwHighestValidAPIVersion = TAPI_VERSION2_2;
        }
        else if ((dwAPIHighVersion >= TAPI_VERSION2_1) &&
            (dwAPILowVersion <= TAPI_VERSION2_1))
        {
            dwHighestValidAPIVersion = TAPI_VERSION2_1;
        }
        else if ((dwAPIHighVersion >= TAPI_VERSION2_0) &&
            (dwAPILowVersion <= TAPI_VERSION2_0))
        {
            dwHighestValidAPIVersion = TAPI_VERSION2_0;
        }
        else if ((dwAPIHighVersion >= TAPI_VERSION1_4) &&
            (dwAPILowVersion <= TAPI_VERSION1_4))
        {
            dwHighestValidAPIVersion = TAPI_VERSION1_4;
        }
        else if ((dwAPIHighVersion >= TAPI_VERSION1_0) &&
            (dwAPILowVersion <= TAPI_VERSION1_0))
        {
            dwHighestValidAPIVersion = TAPI_VERSION1_0;
        }
        else
        {
            pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
            goto NegotiateAPIVersionForAllDevices_exit;
        }
    }
    else
    {
        dwHighestValidAPIVersion = TAPI_VERSION_CURRENT;
    }


    //
    // Now for each line device do negotiation
    //

    pdwAPIVersion = (LPDWORD) pDataBuf;

    pExtID = (LPLINEEXTENSIONID)
        (pDataBuf + pParams->dwLineAPIVersionListSize);

    for (i = 0; i < dwNumLineDevices; i++, pdwAPIVersion++, pExtID++)
    {
        DWORD               dwDeviceID, dwSPIVersion;
        PTLINELOOKUPENTRY   pLookupEntry;


        if (!IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
        {
            dwDeviceID = ptClient->pLineDevices[i];
        }
        else
        {
            dwDeviceID = i;
        }

        pLookupEntry = GetLineLookupEntry (dwDeviceID);
        if (NULL == pLookupEntry)
        {
            // Something is wrong with this device ID;
            // skip it.
            continue;
        }

        dwSPIVersion = pLookupEntry->dwSPIVersion;

        if ((dwAPILowVersion <= dwSPIVersion)  &&
            !pLookupEntry->bRemoved  &&
            (pLookupEntry->ptProvider != NULL))
        {
            *pdwAPIVersion =
                (dwHighestValidAPIVersion > dwSPIVersion ?
                dwSPIVersion : dwHighestValidAPIVersion);


            //
            // Retrieve ext id (indicate no exts if GetExtID not exported)
            //

            if (!(pLookupEntry->ptProvider->apfn[SP_LINEGETEXTENSIONID]) ||

                CallSP3(
                    pLookupEntry->ptProvider->apfn[SP_LINEGETEXTENSIONID],
                    "lineGetExtensionID",
                    SP_FUNC_SYNC,
                    (DWORD) dwDeviceID,
                    (DWORD) dwSPIVersion,
                    (ULONG_PTR) pExtID

                    ) != 0)
            {
                ZeroMemory (pExtID, sizeof (LINEEXTENSIONID));
            }
        }
        else
        {
            *pdwAPIVersion = 0;
        }
    }


    //
    // Now for each phone device do negotiation
    //

    pdwAPIVersion = (LPDWORD) (pDataBuf +
        pParams->dwLineAPIVersionListSize +
        pParams->dwLineExtensionIDListSize);

    pExtID = (LPLINEEXTENSIONID) (pDataBuf +
        pParams->dwLineAPIVersionListSize +
        pParams->dwLineExtensionIDListSize +
        pParams->dwPhoneAPIVersionListSize);

    for (i = 0; i < dwNumPhoneDevices; i++, pdwAPIVersion++, pExtID++)
    {
        DWORD               dwDeviceID, dwSPIVersion;
        PTPHONELOOKUPENTRY  pLookupEntry;


        if (!IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
        {
            dwDeviceID = ptClient->pPhoneDevices[i];
        }
        else
        {
            dwDeviceID = i;
        }

        pLookupEntry = GetPhoneLookupEntry (dwDeviceID);
        if (NULL == pLookupEntry)
        {
            // Something wrong with this device;
            // skip it.
            continue;
        }

        dwSPIVersion = pLookupEntry->dwSPIVersion;

        if ((dwAPILowVersion <= dwSPIVersion)  &&
            !pLookupEntry->bRemoved  &&
            (pLookupEntry->ptProvider != NULL))
        {
            *pdwAPIVersion =
                (dwHighestValidAPIVersion > dwSPIVersion ?
                dwSPIVersion : dwHighestValidAPIVersion);


            //
            // Retrieve ext id (indicate no exts if GetExtID not exported)
            //

            if (!(pLookupEntry->ptProvider->apfn[SP_PHONEGETEXTENSIONID]) ||

                CallSP3(
                    pLookupEntry->ptProvider->apfn[SP_PHONEGETEXTENSIONID],
                    "phoneGetExtensionID",
                    SP_FUNC_SYNC,
                    (DWORD) dwDeviceID,
                    (DWORD) dwSPIVersion,
                    (ULONG_PTR) pExtID

                    ) != 0)
            {
                ZeroMemory (pExtID, sizeof (LINEEXTENSIONID));
            }
        }
        else
        {
            *pdwAPIVersion = 0;
        }
    }

    pParams->dwLineAPIVersionListOffset = 0;

    pParams->dwLineExtensionIDListOffset =
        pParams->dwLineAPIVersionListSize;

    pParams->dwPhoneAPIVersionListOffset =
        pParams->dwLineAPIVersionListSize +
        pParams->dwLineExtensionIDListSize;

    pParams->dwPhoneExtensionIDListOffset =
        pParams->dwLineAPIVersionListSize +
        pParams->dwLineExtensionIDListSize +
        pParams->dwPhoneAPIVersionListSize;

    *pdwNumBytesReturned =
        sizeof (TAPI32_MSG) +
        pParams->dwLineAPIVersionListSize +
        pParams->dwLineExtensionIDListSize +
        pParams->dwPhoneAPIVersionListSize +
        pParams->dwPhoneExtensionIDListSize;


NegotiateAPIVersionForAllDevices_exit:

#endif

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "NegotiateAPIVersionForAllDevices: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "NegotiateAPIVersionForAllDevices: exit, result=x%x",
            pParams->lResult
            ));
#endif

    return;
}


void
WINAPI
LNegotiateExtVersion(
    PTCLIENT                        ptClient,
    PLINENEGOTIATEEXTVERSION_PARAMS pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    DWORD               dwDeviceID;
    HANDLE              hMutex;
    TSPIPROC            pfnTSPI_lineNegotiateExtVersion;
    DWORD               objectToDereference;
    PTLINELOOKUPENTRY   pLookupEntry;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            DEVICE_ID,                  // widget type
            (DWORD) pParams->hLineApp,  // client widget handle
            &dwDeviceID,                // provider widget handle
            pParams->dwDeviceID,        // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINENEGOTIATEEXTVERSION, // provider func index
            &pfnTSPI_lineNegotiateExtVersion,   // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &pLookupEntry,              // context
            "NegotiateExtVersion"       // func name

            )) == 0)
    {
        DWORD   dwSPIVersion = pLookupEntry->dwSPIVersion;


        if (!IsAPIVersionInRange(
                pParams->dwAPIVersion,
                dwSPIVersion
                ))
        {
            pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
            goto LNegotiateExtVersion_epilog;
        }

        if ((pParams->lResult = CallSP5(
                pfnTSPI_lineNegotiateExtVersion,
                "lineNegotiateExtVersion",
                SP_FUNC_SYNC,
                (DWORD) dwDeviceID,
                (DWORD) dwSPIVersion,
                (DWORD) pParams->dwExtLowVersion,
                (DWORD) pParams->dwExtHighVersion,
                (ULONG_PTR) &pParams->dwExtVersion

                )) == 0)
        {
            if (pParams->dwExtVersion == 0)
            {
                pParams->lResult = LINEERR_INCOMPATIBLEEXTVERSION;
            }
            else
            {
                *pdwNumBytesReturned = sizeof (LINENEGOTIATEEXTVERSION_PARAMS);
            }
        }
    }

LNegotiateExtVersion_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "NegotiateExtVersion"
        );
}



VOID
PASCAL
xxxLOpen(
    PTCLIENT            ptClient,
    PLINEOPEN_PARAMS    pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned,
    BOOL                bLineMapper
    )
{
    BOOL                bCloseMutex,
                        bOpenedtLine = FALSE,
                        bDecrExtVerCountOnError = FALSE,
                        bReleasetLineMutex = FALSE,
                        bFreeCallParams = FALSE;
    LONG                lResult;
    HLINE               hLine;
    DWORD               dwDeviceID;
    HANDLE              hMutex;
    PTLINE              ptLine = NULL;
    DWORD               objectToDereference;
    PTPROVIDER          ptProvider = NULL;
    PTLINECLIENT        ptLineClient = NULL;
    PTLINELOOKUPENTRY   pLookupEntry;
    LPLINECALLPARAMS    pCallParams = NULL;
    TCHAR               szClsid[40];
    HANDLE              hLookupEntryMutex = NULL;

    szClsid[0] = 0;
    if ((lResult = LINEPROLOG(
            ptClient,          // tClient
            DEVICE_ID,                  // widget type
            (DWORD) pParams->hLineApp,  // client widget handle
            &dwDeviceID,                // provider widget handle
            pParams->dwDeviceID,        // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &pLookupEntry,              // context
            (bLineMapper ? "Open(LINEMAPPER)" : "Open")
                                        // func name

            )) == 0)
    {
        DWORD               dwPrivileges = pParams->dwPrivileges,
                            dwAPIVersion = pParams->dwAPIVersion,
                            dwExtVersion = pParams->dwExtVersion,
                            dwMediaModes, dwNumProxyRequestTypes,
                            dwRegisteredProxys,
                           *pdwProxyRequestTypes,
                            i;
        PTLINEAPP           ptLineApp;
        BOOL                bDuplicateOK = FALSE;


        //
        // Check if the global reinit flag is set
        //

        if (TapiGlobals.dwFlags & TAPIGLOBALS_REINIT)
        {
            lResult = LINEERR_REINIT;
            goto xxxLOpen_cleanup;
        }


        //
        // Validate params
        //
        if (!IsAPIVersionInRange(
                dwAPIVersion,
                pLookupEntry->dwSPIVersion
                ))
        {
            lResult = LINEERR_INCOMPATIBLEAPIVERSION;
            goto xxxLOpen_cleanup;
        }

        ptProvider = pLookupEntry->ptProvider;


        #define VALID_LOPEN_BITS (LINECALLPRIVILEGE_NONE       | \
                                  LINECALLPRIVILEGE_MONITOR    | \
                                  LINECALLPRIVILEGE_OWNER      | \
                                  LINEOPENOPTION_SINGLEADDRESS | \
                                  LINEOPENOPTION_PROXY)

        #define VALID_PRIV_BITS  (LINECALLPRIVILEGE_NONE       | \
                                  LINECALLPRIVILEGE_MONITOR    | \
                                  LINECALLPRIVILEGE_OWNER)

        if (!(dwPrivileges & VALID_PRIV_BITS) ||

            (dwPrivileges & ~VALID_LOPEN_BITS) ||

            ((dwPrivileges & LINECALLPRIVILEGE_NONE) &&
                (dwPrivileges & (LINECALLPRIVILEGE_MONITOR |
                    LINECALLPRIVILEGE_OWNER))))
        {
            lResult = LINEERR_INVALPRIVSELECT;
            goto xxxLOpen_cleanup;
        }

        if (dwPrivileges & (LINEOPENOPTION_SINGLEADDRESS |
                LINEOPENOPTION_PROXY)  ||
            bLineMapper)
        {
            pCallParams = (LPLINECALLPARAMS)
                (pParams->dwCallParamsOffset == TAPI_NO_DATA ?
                    NULL : pDataBuf + pParams->dwCallParamsOffset);

            if (!pCallParams)
            {
                lResult = LINEERR_INVALPOINTER;
                goto xxxLOpen_cleanup;
            }


            //
            // Verify size/offset/string params given our input buffer/size
            //

            if (IsBadStructParam(
                    dwParamsBufferSize,
                    pDataBuf,
                    pParams->dwCallParamsOffset
                    ))
            {
                pParams->lResult = LINEERR_OPERATIONFAILED;
                goto xxxLOpen_cleanup;
            }

            if ((lResult = ValidateCallParams(
                    pCallParams,
                    &pCallParams,
                    dwAPIVersion,
                    pLookupEntry->dwSPIVersion,
                    pParams->dwAsciiCallParamsCodePage
                    )))
            {
                lResult = LINEERR_INVALPOINTER;
                goto xxxLOpen_cleanup;
            }

            if (pCallParams != (LPLINECALLPARAMS)
                    (pDataBuf + pParams->dwCallParamsOffset))
            {
                bFreeCallParams = TRUE;
            }

            if ((dwPrivileges & LINEOPENOPTION_SINGLEADDRESS) &&

                (pCallParams->dwAddressMode != LINEADDRESSMODE_ADDRESSID))
            {
                LOG((TL_ERROR,
                    "lineOpen(SINGLEADDRESS): callParams.dwAddressMode" \
                        "!= ADDRESSID"
                    ));

                lResult = LINEERR_INVALCALLPARAMS;
                goto xxxLOpen_cleanup;
            }

            if (dwPrivileges & LINEOPENOPTION_PROXY)
            {
                //
                // Verify the array of DWORDs (request types) in the
                // DevSpecific var field
                //

                dwNumProxyRequestTypes =
                    (pCallParams->dwDevSpecificSize & 0xfffc) /
                        sizeof (DWORD);

                if (dwNumProxyRequestTypes == 0 ||
                    dwNumProxyRequestTypes > LINEPROXYREQUEST_LASTVALUE)
                {
                    LOG((TL_ERROR,
                        "lineOpen(PROXY): inval proxy request type array "\
                            "size (callParams.dwDevSpecificSize=x%x)",
                        pCallParams->dwDevSpecificSize
                        ));

                    lResult = LINEERR_INVALCALLPARAMS;
                    goto xxxLOpen_cleanup;
                }

                //
                //  Per the TAPI (Proxy) server publishing:
                //
                //  If the HIWORD of dwDevSpecificSize is non-zero
                //  immediately after the dwDevSpecificSize/Offset
                //  field, there is a zero terminated CLSID field
                //  of the proxy server
                //
                if (HIWORD(pCallParams->dwDevSpecificSize))
                {
                    LPTSTR      lpsz;

                    lpsz = (LPTSTR) (((LPBYTE) pCallParams) +
                        pCallParams->dwDevSpecificOffset +
                        LOWORD(pCallParams->dwDevSpecificSize));
                    pCallParams->dwDevSpecificSize = 
                        LOWORD(pCallParams->dwDevSpecificSize);
                    if (_tcslen (lpsz) > sizeof(szClsid) / sizeof(TCHAR))
                    {
                        lResult = LINEERR_INVALCALLPARAMS;
                        goto xxxLOpen_cleanup;
                    }
                    _tcscpy (szClsid, lpsz);
                }

                pdwProxyRequestTypes = (LPDWORD) (((LPBYTE) pCallParams) +
                    pCallParams->dwDevSpecificOffset);

                for (i = 0; i < dwNumProxyRequestTypes; i++)
                {
                    if (*(pdwProxyRequestTypes + i) == 0 ||
                        *(pdwProxyRequestTypes + i) >
                            LINEPROXYREQUEST_LASTVALUE)
                    {
                        LOG((TL_ERROR,
                            "lineOpen(PROXY): inval proxy request type "\
                                "(x%x)",
                            *(pdwProxyRequestTypes + i)
                            ));

                        lResult = LINEERR_INVALCALLPARAMS;
                        goto xxxLOpen_cleanup;
                    }
                }
            }
        }

        if ((dwPrivileges & LINECALLPRIVILEGE_OWNER))
        {
            DWORD dwAllMediaModes;


            dwMediaModes = pParams->dwMediaModes;

            switch (dwAPIVersion)
            {
            case TAPI_VERSION1_0:

                dwAllMediaModes = AllMediaModes1_0;
                break;

            case TAPI_VERSION1_4:
            case TAPI_VERSION2_0:

                dwAllMediaModes = AllMediaModes1_4;
                break;

            //case TAPI_VERSION2_1:
            //case TAPI_VERSION2_2:
            default: //case TAPI_VERSION_CURRENT:

                dwAllMediaModes = AllMediaModes2_1;
                break;
            }

            if ((dwMediaModes == 0) ||
                (dwMediaModes & (0x00ffffff & ~dwAllMediaModes)))
            {
                lResult = LINEERR_INVALMEDIAMODE;
                goto xxxLOpen_cleanup;
            }
        }
        else
        {
            dwMediaModes = 0;
        }


        //
        // Create & init a tLineClient & associated resources
        //

        if (!(ptLineClient = ServerAlloc (sizeof(TLINECLIENT))))
        {
            lResult = LINEERR_NOMEM;
            goto xxxLOpen_cleanup;
        }

        LOG((TL_TRACE,  "lineOpen: calling NewObject. ptLineClient %p", ptLineClient));

        if (!(ptLineClient->hLine = (HLINE) NewObject(
                ghHandleTable,
                ptLineClient,
                0
                )))
        {
            ptLineClient = NULL;
            ServerFree (ptLineClient);
            lResult = LINEERR_NOMEM;
            goto xxxLOpen_cleanup;
        }

        LOG((TL_TRACE,  "lineOpen: NewObject returned %p", ptLineClient->hLine));

        ptLineClient->ptClient     = ptClient;
        ptLineClient->hRemoteLine  = (pParams->hRemoteLine ?
            (DWORD) pParams->hRemoteLine : ptLineClient->hLine);
        ptLineClient->dwAPIVersion = dwAPIVersion;
        ptLineClient->dwPrivileges = dwPrivileges;
        ptLineClient->dwMediaModes = dwMediaModes;
        ptLineClient->OpenContext  = pParams->OpenContext;
        ptLineClient->dwAddressID  =
            (dwPrivileges & LINEOPENOPTION_SINGLEADDRESS ?
                pCallParams->dwAddressID : 0xffffffff);

        LOG((TL_INFO, "lineOpen: OpenContext %p", pParams->OpenContext));

        //
        // Duplicate the handle to tLine's mutex
        // Grab the mutex using the duplicate handle then start doing the open
        //

        TapiEnterCriticalSection (&TapiGlobals.CritSec);

        if ( pLookupEntry->hMutex )
        {
            bDuplicateOK = DuplicateHandle(
                TapiGlobals.hProcess,
                pLookupEntry->hMutex,
                TapiGlobals.hProcess,
                &hLookupEntryMutex,
                0,
                FALSE,
                DUPLICATE_SAME_ACCESS
                );
        }

        TapiLeaveCriticalSection(&TapiGlobals.CritSec);

        if ( !bDuplicateOK )
        {
            bReleasetLineMutex = FALSE;
            lResult = LINEERR_OPERATIONFAILED;
            goto xxxLOpen_cleanup;
        }

xxxLOpen_waitForMutex:

        if (WaitForSingleObject (hLookupEntryMutex, INFINITE)
                != WAIT_OBJECT_0)
        {
            bReleasetLineMutex = FALSE;
            lResult = LINEERR_OPERATIONFAILED;
            goto xxxLOpen_cleanup;
        }

        bReleasetLineMutex = TRUE;


        //
        // If the tLine is in the process of being destroyed then spin
        // until it's been completely destroyed (DestroytLine() will
        // NULLify pLookupEntry->ptLine when it's finished). Make sure
        // to release the mutex while sleeping so we don't block
        // DestroytLine.
        //

        try
        {
            while (pLookupEntry->ptLine &&
                   pLookupEntry->ptLine->dwKey != TLINE_KEY)
            {
                ReleaseMutex (hLookupEntryMutex);
                Sleep (0);
                goto xxxLOpen_waitForMutex;
            }
        }
        myexcept
        {
            // If here pLookupEntry->ptLine was NULLified, safe to continue
        }

        //
        //  Check if the line has been removed
        //
        if (pLookupEntry->bRemoved)
        {
            lResult = LINEERR_BADDEVICEID;
            goto xxxLOpen_cleanup;
        }

        //
        // Validate ext ver as appropriate
        //

        if (dwExtVersion != 0 &&
            (!IsValidLineExtVersion (dwDeviceID, dwExtVersion) ||
            ptProvider->apfn[SP_LINESELECTEXTVERSION] == NULL))
        {

            if ( ptProvider->apfn[SP_LINESELECTEXTVERSION] == NULL)
            {
                LOG((TL_ERROR,
                    "The provider does not support TSPI_lineSelectExtVersion" \
                        " - that's a problem"
                    ));
            }
            else
            {
                LOG((TL_ERROR,
                    "Bad ExtVersion was passed in - that's a problem"
                    ));
            }

            lResult = LINEERR_INCOMPATIBLEEXTVERSION;
            goto xxxLOpen_cleanup;
        }


        //
        // If line isn't open already then try to open it
        //

        if (!(ptLine = pLookupEntry->ptLine))
        {
            if (!(ptLine = ServerAlloc (sizeof(TLINE))))
            {
                lResult = LINEERR_NOMEM;
                goto xxxLOpen_cleanup;
            }

            LOG((TL_TRACE,  "xxxLOpen: calling NewObject ptLine %p", ptLine));

            if (!(ptLine->hLine = (HLINE) NewObject(
                    ghHandleTable,
                    (LPVOID) ptLine,
                    NULL
                    )))
            {
                ServerFree (ptLine);
                lResult = LINEERR_NOMEM;
                goto xxxLOpen_cleanup;
            }

            ptLine->dwKey        = TINCOMPLETELINE_KEY;
            ptLine->hMutex       = pLookupEntry->hMutex;
            ptLine->ptProvider   = ptProvider;
            ptLine->dwDeviceID   = dwDeviceID;
            ptLine->dwSPIVersion = pLookupEntry->dwSPIVersion;

            {
                //
                // Hack Alert!
                //
                // We need to pass the privileges,etc through to
                // remote sp, so we make this a special case
                //

                ULONG_PTR   aParams[5];
                ULONG_PTR   param;


                if (ptProvider == pRemoteSP)
                {
                    aParams[0] = (ULONG_PTR) ptLine->hLine;
                    aParams[1] = pParams->dwPrivileges;
                    aParams[2] = pParams->dwMediaModes;
                    aParams[3] = (ULONG_PTR) pCallParams;
                    aParams[4] = dwExtVersion;

                    param = (ULONG_PTR) aParams;
                }
                else
                {
                    param = (ULONG_PTR) ptLine->hLine;
                }

                if (ptProvider->apfn[SP_LINEOPEN] == NULL)
                {
                    lResult = LINEERR_OPERATIONUNAVAIL;
                }
                if (lResult != S_OK ||
                    (lResult = CallSP5(
                        ptProvider->apfn[SP_LINEOPEN],
                        "lineOpen",
                        SP_FUNC_SYNC,
                        (DWORD) dwDeviceID,
                        (ULONG_PTR) param,
                        (ULONG_PTR) &ptLine->hdLine,
                        (DWORD) pLookupEntry->dwSPIVersion,
                        (ULONG_PTR) LineEventProcSP

                        )) != 0)
                {
                    DereferenceObject(
                        ghHandleTable,
                        ptLine->hLine,
                        1
                        );

                    lResult = (bLineMapper ? LINEERR_OPERATIONFAILED :
                        lResult);
                    goto xxxLOpen_cleanup;
                }

                bOpenedtLine = TRUE;
            }

            if (ptProvider->apfn[SP_LINEGETNUMADDRESSIDS] == NULL)
            {
                lResult = LINEERR_OPERATIONUNAVAIL;
                goto xxxLOpen_cleanup;
            }
            CallSP2(
                ptProvider->apfn[SP_LINEGETNUMADDRESSIDS],
                "lineGetNumAddressIDs",
                SP_FUNC_SYNC,
                (ULONG_PTR) ptLine->hdLine,
                (ULONG_PTR) &ptLine->dwNumAddresses
                );

            // PERF
            PerfBlock.dwLinesInUse++;
        }


        //
        // If line is already opened & client is trying to register
        // as a proxy then see if there's any conflicts with existing
        // proxys
        //

        else if (dwPrivileges & LINEOPENOPTION_PROXY)
        {
            for (i = 0; i < dwNumProxyRequestTypes; i++)
            {
                DWORD dwProxyRequestType = *(pdwProxyRequestTypes + i);


                if (ptLine->apProxys[dwProxyRequestType] != NULL)
                {
                    lResult = LINEERR_NOTREGISTERED;
                    goto xxxLOpen_cleanup;
                }
            }
        }

        ptLineClient->ptLine = ptLine;


        //
        // Verify the specified addr if appropriate
        //

        if ((dwPrivileges & LINEOPENOPTION_SINGLEADDRESS) &&

            (ptLineClient->dwAddressID >= ptLine->dwNumAddresses))
        {
            lResult = LINEERR_INVALADDRESSID;
            goto xxxLOpen_cleanup;
        }


        //
        // If the client has specified a non-zero ext version then
        // ask the driver to enable it and/or increment the ext
        // version count. If this fails, and we're processing a
        // LINEMAPPER request, then return a generic error so the
        // caller will try the next device.
        //

        if (dwExtVersion)
        {
            if (ptLine->dwExtVersionCount == 0)
            {
                if (ptProvider != pRemoteSP &&
                    ptProvider->apfn[SP_LINESELECTEXTVERSION] == NULL)
                {
                    lResult = LINEERR_OPERATIONUNAVAIL;
                    goto xxxLOpen_cleanup;
                }
                if (ptProvider != pRemoteSP  &&

                    (lResult = CallSP2(
                        ptProvider->apfn[SP_LINESELECTEXTVERSION],
                        "lineSelectExtVersion",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) ptLine->hdLine,
                        (DWORD) dwExtVersion

                        )) != 0)
                {
                    lResult = (bLineMapper ? LINEERR_OPERATIONFAILED :
                        lResult);
                    goto xxxLOpen_cleanup;
                }

                ptLine->dwExtVersion = dwExtVersion;
            }

            ptLineClient->dwExtVersion = dwExtVersion;
            ptLine->dwExtVersionCount++;
            bDecrExtVerCountOnError = TRUE;
        }


        //
        // If we're processing a LINEMAPPER request, check to see if the
        // device supports capabilities requested by client.  If not,
        // return a generic error so the caller will try the next device.
        //

        if (bLineMapper)
        {
            if (ptProvider->apfn[SP_LINECONDITIONALMEDIADETECTION] == NULL ||
                CallSP3(
                    ptProvider->apfn[SP_LINECONDITIONALMEDIADETECTION],
                    "lineConditionalMediaDetection",
                    SP_FUNC_SYNC,
                    (ULONG_PTR) ptLine->hdLine,
                    (DWORD) dwMediaModes | ptLine->dwOpenMediaModes,
                    (ULONG_PTR) pCallParams

                    ) != 0)
            {
                PerfBlock.dwLinesInUse--;
                lResult = LINEERR_OPERATIONFAILED;
                goto xxxLOpen_cleanup;
            }
        }


        //
        // If the client is requesting OWNER privileges (it's interested
        // in incoming calls of the specified media mode(s)), then check
        // to see if it wants incoming calls of a media mode(s) other
        // than that the device has already agreed to indicate, and ask
        // the driver if it can support looking for all of them at the
        // same time. If this fails, and we're processing a LINEMAPPER
        // request, then return a generic error so the caller will try
        // the next device.
        //

        if (pParams->dwPrivileges & LINECALLPRIVILEGE_OWNER)
        {
            if ((dwMediaModes & ptLine->dwOpenMediaModes) != dwMediaModes)
            {
                DWORD   dwUnionMediaModes = dwMediaModes |
                                            ptLine->dwOpenMediaModes;


                if (ptProvider->apfn[SP_LINESETDEFAULTMEDIADETECTION])
                {
                    if ((lResult  = CallSP2(
                            ptProvider->apfn[SP_LINESETDEFAULTMEDIADETECTION],
                            "lineSetDefaultMediaDetection",
                            SP_FUNC_SYNC,
                            (ULONG_PTR) ptLine->hdLine,
                            (DWORD) dwUnionMediaModes

                            )) != 0)
                    {
                        lResult = (bLineMapper ? LINEERR_OPERATIONFAILED :
                                   lResult);
                        PerfBlock.dwLinesInUse--;
                        goto xxxLOpen_cleanup;
                    }
                }
                else
                {
                    lResult = LINEERR_OPERATIONUNAVAIL;
                    PerfBlock.dwLinesInUse--;
                    goto xxxLOpen_cleanup;
                }

                ptLine->dwOpenMediaModes = dwUnionMediaModes;
            }
        }


        //
        // Set the proxy ptrs if appropriate
        //

        if (dwPrivileges & LINEOPENOPTION_PROXY)
        {
            for (i = 0; i < dwNumProxyRequestTypes; i++)
            {
                ptLine->apProxys[*(pdwProxyRequestTypes + i)] =
                    ptLineClient;
            }
        }


        //
        // What proxys have opened now ?
        //

        for(
            i = LINEPROXYREQUEST_SETAGENTGROUP, dwRegisteredProxys = 0;
            i <= LINEPROXYREQUEST_LASTVALUE;
            i++
            )
        {
            if (ptLine->apProxys[i] != NULL)
            {
                //
                // Munge them all into a DWORD (if we ever
                // get more that 32 we'll have to do an
                // additional test)
                //

                dwRegisteredProxys |=  ( 1<<i );
            }
        }


        //
        // Add the tLineClient to the tLine's list & increment the
        // number of opens
        //

        if ((ptLineClient->pNextSametLine = ptLine->ptLineClients))
        {
            ptLineClient->pNextSametLine->pPrevSametLine = ptLineClient;
        }

        ptLine->ptLineClients = ptLineClient;
        ptLine->dwNumOpens++;

        if (bOpenedtLine)
        {
            pLookupEntry->ptLine = ptLine;
            ptLine->dwKey = TLINE_KEY;
        }

        ReleaseMutex (hLookupEntryMutex);

        bReleasetLineMutex = FALSE;


        //
        // Safely add the new tLineClient to the tLineApp's list.
        //

        {
            LOG((TL_TRACE,  "xxxLOpen: adding ptLineClient [%p] to tLineApp's [%p] list", ptLineClient, pParams->hLineApp));

            if ((ptLineApp = WaitForExclusiveLineAppAccess(
                    pParams->hLineApp,
                    ptClient
                    )))
            {
                if (ptLineApp->dwAPIVersion <= TAPI_VERSION3_0)
                {
                    FillMemory (
                        ptLineClient->adwEventSubMasks, 
                        sizeof(DWORD) * EM_NUM_MASKS,
                        (BYTE) 0xff
                        );
                }
                else
                {
                    CopyMemory (
                        ptLineClient->adwEventSubMasks, 
                        ptLineApp->adwEventSubMasks,
                        sizeof(DWORD) * EM_NUM_MASKS
                        );
                }
                if ((ptLineClient->pNextSametLineApp =
                        ptLineApp->ptLineClients))
                {
                    ptLineClient->pNextSametLineApp->pPrevSametLineApp =
                        ptLineClient;
                }

                ptLineApp->ptLineClients = ptLineClient;


                //
                // Note: it's important to mark the newtLineClient as
                // valid way down here because another thread could be
                // simultaneously trying to do an unconditional
                // DestroytLine (due to receiving a LINE_CLOSE, etc.)
                // and we want to make sure the tLineClient is in both
                // tLine's & tLineApp's lists before DestroytLine calls
                // DestroytLineClient which'll try to yank the tLineClient
                // out of these lists.
                //

                hLine = ptLineClient->hLine;

                ptLineClient->ptLineApp = ptLineApp;
                ptLineClient->dwKey     = TLINECLIENT_KEY;

                UNLOCKTLINEAPP(ptLineApp);


                //
                // Alert other clients that another open has occured
                //

                SendMsgToLineClients(
                    ptLine,
                    ptLineClient,
                    LINE_LINEDEVSTATE,
                    LINEDEVSTATE_OPEN,
                    0,
                    0
                    );


                //
                // Alert other clients that a proxy open has occured
                //

                if (dwPrivileges & LINEOPENOPTION_PROXY)
                {
                    // One message per LINEPROXYREQUEST_ type

                    for (i = 0; i < dwNumProxyRequestTypes; i++)
                    {
                        LOG((TL_INFO,
                            "tell clients proxy %02X opened",
                            *(pdwProxyRequestTypes + i)
                            ));

                        SendMsgToLineClients(
                            ptLine,
                            ptLineClient,
                            LINE_PROXYSTATUS,
                            LINEPROXYSTATUS_OPEN,
                            *(pdwProxyRequestTypes + i),// LINEPROXYREQUEST_xx
                            0
                            );
                    }


                    //
                    // Now see if we have all the ones required by
                    // TAPI3.0 for an ACD proxy
                    //

                    if ((dwRegisteredProxys & AllRequiredACDProxyRequests3_0)
                            == AllRequiredACDProxyRequests3_0)
                    {
                        LOG((TL_INFO,
                            "tell clients that all proxys needed " \
                                "for TAPI3.0 ACD are open"
                            ));

                        SendMsgToLineClients(
                            ptLine,
                            ptLineClient,
                            LINE_PROXYSTATUS,
                            LINEPROXYSTATUS_ALLOPENFORACD,
                            0,
                            0
                            );
                    }

                    //
                    //  If we are given a proxy server CLSID, register
                    //  the proxy server in DS, error not considered
                    //  critical here
                    //
                    if (*szClsid != 0)
                    {
                        ptLineClient->szProxyClsid = ServerAlloc (
                            (_tcslen (szClsid) + 1) * sizeof(TCHAR)
                            );
                        if (ptLineClient->szProxyClsid)
                        {
                            _tcscpy (ptLineClient->szProxyClsid, szClsid);
                            OnProxyLineOpen (szClsid);
                        }
                    }
                }


                //
                // Fill in the return values
                //

                LOG((TL_TRACE,  "xxxLOpen returning hLine of %p", hLine));

                pParams->hLine = hLine;
                *pdwNumBytesReturned = sizeof (LINEOPEN_PARAMS);


                //
                // (Now we need to return the call params if this
                // is a remote client)
                //
                // This was for some 2.1 kludge which didn't make
                // any sense, so i've chg'd to indicate NO_DATA
                // so nothing gets copied back on the client side.
                //
                // DanKn, Aug 6 '98
                //

                if (IS_REMOTE_CLIENT (ptClient))
                {
                    pParams->dwCallParamsReturnOffset = TAPI_NO_DATA;
                }
            }
            else
            {
                //
                // If here the app handle is bad, & we've some special
                // case cleanup to do.  Since the tLineClient is not
                // in the tLineApp's list, we can't simply call
                // DestroytLine(Client) to clean things up, since the
                // pointer-resetting code will blow up.  So we'll
                // grab the tLine's mutex and explicitly remove the
                // new tLineClient from it's list, then do a conditional
                // shutdown on the tLine (in case any other clients
                // have come along & opened it). Also deselect the
                // ext version and/or decrement the ext version count
                // as appropriate.
                //
                // Note: keep in mind that a LINE_CLOSE might be being
                //       processed by another thread (if so, it will be
                //       spinning on trying to destroy the tLineClient
                //       which isn't valid at this point)
                //

                lResult = LINEERR_INVALAPPHANDLE;

                WaitForSingleObject (hLookupEntryMutex, INFINITE);

                if (ptLineClient->pNextSametLine)
                {
                    ptLineClient->pNextSametLine->pPrevSametLine =
                        ptLineClient->pPrevSametLine;
                }

                if (ptLineClient->pPrevSametLine)
                {
                    ptLineClient->pPrevSametLine->pNextSametLine =
                        ptLineClient->pNextSametLine;
                }
                else
                {
                    ptLine->ptLineClients = ptLineClient->pNextSametLine;
                }

                ptLine->dwNumOpens--;

                if (bDecrExtVerCountOnError == TRUE)
                {
                    ptLine->dwExtVersionCount--;

                    if (ptLine->dwExtVersionCount == 0)
                    {
                        ptLine->dwExtVersion = 0;

                        if (ptProvider->apfn[SP_LINESELECTEXTVERSION])
                        {
                            CallSP2(
                                ptProvider->apfn[SP_LINESELECTEXTVERSION],
                                "lineSelectExtVersion",
                                SP_FUNC_SYNC,
                                (ULONG_PTR) ptLine->hdLine,
                                (DWORD) 0
                                );
                        }
                    }
                }

                ReleaseMutex (hLookupEntryMutex);

                DestroytLine (ptLine, FALSE); // conditional destroy

                bOpenedtLine = FALSE; // so we don't do err handling below
            }
        }

        CloseHandle  (hLookupEntryMutex);

    }

xxxLOpen_cleanup:

    if (bReleasetLineMutex)
    {
        if (lResult != 0)
        {
            if (bDecrExtVerCountOnError == TRUE)
            {
                ptLine->dwExtVersionCount--;

                if (ptLine->dwExtVersionCount == 0)
                {
                    ptLine->dwExtVersion = 0;

                    if (ptProvider->apfn[SP_LINESELECTEXTVERSION])
                    {
                        CallSP2(
                            ptProvider->apfn[SP_LINESELECTEXTVERSION],
                            "lineSelectExtVersion",
                            SP_FUNC_SYNC,
                            (ULONG_PTR) ptLine->hdLine,
                            (DWORD) 0
                            );
                    }
                }
            }

            if (bOpenedtLine == TRUE && ptProvider->apfn[SP_LINECLOSE])
            {
                CallSP1(
                    ptProvider->apfn[SP_LINECLOSE],
                    "lineClose",
                    SP_FUNC_SYNC,
                    (ULONG_PTR) ptLine->hdLine
                    );
            }
        }

        ReleaseMutex (hLookupEntryMutex);
        CloseHandle  (hLookupEntryMutex);
    }

    if ((pParams->lResult = lResult) != 0)
    {
        if (ptLineClient)
        {
            DereferenceObject (ghHandleTable, ptLineClient->hLine, 1);
        }

        if (bOpenedtLine)
        {
            DereferenceObject (ghHandleTable, ptLine->hLine, 1);
        }
    }

    if (bFreeCallParams)
    {
        ServerFree (pCallParams);
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        (bLineMapper ? "Open(LINEMAPPER)" : "Open")
        );
}



void
WINAPI
LOpen(
    PTCLIENT            ptClient,
    PLINEOPEN_PARAMS    pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    if (pParams->dwDeviceID != LINEMAPPER)
    {
        xxxLOpen(
            ptClient,
            pParams,
            dwParamsBufferSize,
            pDataBuf,
            pdwNumBytesReturned,
            FALSE
            );
    }
    else
    {
        //
        // Try to open each line device, starting with device 0, until
        // either we find a device that'll handle the capabilities
        // requested by the client or we run out of devices. If we
        // encounter a certain subset of parameter errors the first time
        // we call xxxLOpen we want to return these back to the app
        // immediately to aid debugging (rather than always returning
        // LINEMAPPERFAILED).
        //

        for(
            pParams->dwDeviceID = 0;
            pParams->dwDeviceID < TapiGlobals.dwNumLines;
            pParams->dwDeviceID++
            )
        {
            xxxLOpen(
                ptClient,
                pParams,
                dwParamsBufferSize,
                pDataBuf,
                pdwNumBytesReturned,
                TRUE
                );

            if (pParams->dwDeviceID == 0)
            {
                switch (pParams->lResult)
                {
                case LINEERR_BADDEVICEID:       // 0 line devices
                case LINEERR_INVALAPPHANDLE:
                case LINEERR_INVALCALLPARAMS:
                case LINEERR_INVALMEDIAMODE:
                case LINEERR_INVALPOINTER:      // no call params, etc
                case LINEERR_INVALPRIVSELECT:
                case LINEERR_REINIT:
                case LINEERR_UNINITIALIZED:

                    return;

                default:

                    break;
                }
            }

            if (pParams->lResult == 0)
            {
                break;
            }
        }

        if (pParams->dwDeviceID >= TapiGlobals.dwNumLines)
        {
            pParams->lResult = LINEERR_LINEMAPPERFAILED;
        }
    }

}


void
LPark_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
    //
    // Note: pAsyncEventMsg->dwParam1 & dwParam2 are reserved for
    //       the request ID and result, respectively
    //

    PASYNCEVENTMSG      pNewAsyncEventMsg = (PASYNCEVENTMSG)
                            pAsyncRequestInfo->dwParam1;
    LPVARSTRING         pNonDirAddress = (LPVARSTRING) (pNewAsyncEventMsg + 1);


    CopyMemory (pNewAsyncEventMsg, pAsyncEventMsg, sizeof (ASYNCEVENTMSG));

    *ppBuf = (LPVOID) pNewAsyncEventMsg;

    if (pAsyncEventMsg->Param2 == 0)  // success
    {
        //
        // Add the used size of the non-dir addr, & keep the total
        // length of the msg DWORD-aligned
        //

        pNewAsyncEventMsg->TotalSize +=
            ((pNonDirAddress->dwUsedSize + TALIGN_COUNT) & TALIGN_MASK);

        pNewAsyncEventMsg->Param3 = 
            DWORD_CAST(pAsyncRequestInfo->dwParam2,__FILE__,__LINE__); // hpNonDirAddr

        pNewAsyncEventMsg->Param4 = pNonDirAddress->dwUsedSize;

    }
}


void
WINAPI
LPark(
    PTCLIENT            ptClient,
    PLINEPARK_PARAMS    pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_linePark;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if ((pParams->dwParkMode == LINEPARKMODE_DIRECTED)  &&

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDirAddressOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEPARK,                // provider func index
            &pfnTSPI_linePark,          // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "Park"                      // func name

            )) > 0)
    {
        LPBYTE      pBuf;
        LPVARSTRING pNonDirAddress;


        if (pParams->dwParkMode == LINEPARKMODE_NONDIRECTED)
        {
            if (pParams->dwNonDirAddressTotalSize < sizeof (VARSTRING))
            {
                lRequestID = LINEERR_STRUCTURETOOSMALL;
                goto LPark_return;
            }

            if (!(pBuf = ServerAlloc(
                    (pParams->dwNonDirAddressTotalSize +
                        sizeof (ASYNCEVENTMSG) + TALIGN_COUNT) & TALIGN_MASK
                    )))
            {
                lRequestID = LINEERR_NOMEM;
                goto LPark_return;
            }

            pNonDirAddress = (LPVARSTRING) (pBuf + sizeof (ASYNCEVENTMSG));

            pNonDirAddress->dwTotalSize  = pParams->dwNonDirAddressTotalSize;
            pNonDirAddress->dwNeededSize =
            pNonDirAddress->dwUsedSize   = sizeof (VARSTRING);

            pAsyncRequestInfo->pfnPostProcess = LPark_PostProcess;
            pAsyncRequestInfo->dwParam1 = (ULONG_PTR) pBuf;
            pAsyncRequestInfo->dwParam2 = pParams->hpNonDirAddress;

            pAsyncRequestInfo->hfnClientPostProcessProc =
                pParams->hfnPostProcessProc;
        }
        else if (pParams->dwParkMode == LINEPARKMODE_DIRECTED)
        {
            pNonDirAddress = (LPVARSTRING) NULL;
        }
        else
        {
            lRequestID = LINEERR_INVALPARKMODE;
            goto LPark_return;
        }

        pParams->lResult = CallSP5(
            pfnTSPI_linePark,
            "linePark",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (DWORD) pParams->dwParkMode,
            (ULONG_PTR) (pParams->dwParkMode == LINEPARKMODE_NONDIRECTED ?
                NULL : pDataBuf + pParams->dwDirAddressOffset),
            (ULONG_PTR) pNonDirAddress
            );
    }

LPark_return:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Park"
        );
}


void
WINAPI
LPickup(
    PTCLIENT            ptClient,
    PLINEPICKUP_PARAMS  pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_linePickup;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (((pParams->dwDestAddressOffset != TAPI_NO_DATA)  &&

            IsBadStringParam(
                dwParamsBufferSize,
                pDataBuf,
                pParams->dwDestAddressOffset
                ))  ||

        ((pParams->dwGroupIDOffset != TAPI_NO_DATA)  &&

            IsBadStringParam(
                dwParamsBufferSize,
                pDataBuf,
                pParams->dwGroupIDOffset
                )))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEPICKUP,              // provider func index
            &pfnTSPI_linePickup,        // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "Pickup"                    // func name

            )) > 0)
    {
        PTCALL          ptCall;
        HCALL           hCall = 0;
        PTCALLCLIENT    ptCallClient;


        if (CreatetCallAndClient(
                ptLineClient,
                &ptCall,
                &ptCallClient,
                NULL,
                &hCall,
                NULL

                ) != 0)
        {
            lRequestID = LINEERR_NOMEM;
            goto LPickup_return;
        }

        pAsyncRequestInfo->pfnPostProcess = LMakeCall_PostProcess;
        pAsyncRequestInfo->htXxx    = (ULONG_PTR)ptCallClient->ptLineClient->ptLine->hLine;
        pAsyncRequestInfo->dwParam1 = (ULONG_PTR) ptCall;
        pAsyncRequestInfo->dwParam2 = pParams->hpCall;
        pAsyncRequestInfo->dwParam5 = (ULONG_PTR)hCall;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP7(
            pfnTSPI_linePickup,
            "linePickup",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdLine,
            (DWORD) pParams->dwAddressID,
            (ULONG_PTR) hCall,
            (ULONG_PTR) &ptCall->hdCall,
            (ULONG_PTR) (pParams->dwDestAddressOffset == TAPI_NO_DATA ? 0 :
                pDataBuf + pParams->dwDestAddressOffset),
            (ULONG_PTR) (pParams->dwGroupIDOffset == TAPI_NO_DATA ? 0 :
                pDataBuf + pParams->dwGroupIDOffset)
            );

        SetDrvCallFlags(
            hCall,
            DCF_SPIRETURNED | (IS_LRESULT_NOTERROR(pParams->lResult) ?
                DCF_DRVCALLVALID : 0)
            );
    }

LPickup_return:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Pickup"
        );
}


void
WINAPI
LPrepareAddToConference(
    PTCLIENT                            ptClient,
    PLINEPREPAREADDTOCONFERENCE_PARAMS  pParams,
    DWORD                               dwParamsBufferSize,
    LPBYTE                              pDataBuf,
    LPDWORD                             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdConfCall;
    TSPIPROC            pfnTSPI_linePrepareAddToConference;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptConfCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hConfCall, // client widget handle
            (LPVOID) &hdConfCall,       // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEPREPAREADDTOCONFERENCE,  // provider func index
            &pfnTSPI_linePrepareAddToConference,// provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptConfCallClient,          // context
            "PrepareAddToConference"    // func name

            )) > 0)
    {
        LONG                lResult;
        PTCALL              ptConsultCall;
        HCALL               hConsultCall;
        PTCALLCLIENT        ptConsultCallClient;
        PTLINECLIENT        ptLineClient;
        LPLINECALLPARAMS    pCallParamsApp, pCallParamsSP;


        //
        // Verify size/offset/string params given our input buffer/size
        //

        if ((pParams->dwCallParamsOffset != TAPI_NO_DATA)  &&

            IsBadStructParam(
                dwParamsBufferSize,
                pDataBuf,
                pParams->dwCallParamsOffset
                ))
        {
            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LPrepareAddToConference_return;
        }


        pCallParamsApp = (LPLINECALLPARAMS)
            (pParams->dwCallParamsOffset == TAPI_NO_DATA ?
                0 : pDataBuf + pParams->dwCallParamsOffset);

        try
        {
            //
            // Safely get the ptLineClient
            //

            ptLineClient = ptConfCallClient->ptLineClient;


            //
            // Make sure the hConfCall is really a conf parent
            //

            {
                PTCALL  ptCall;


                ptCall = (PTCALL) ptConfCallClient->ptCall;

                if ((ptCall->pConfList)->aptCalls[0] != ptCall)
                {
                    lRequestID = LINEERR_INVALCONFCALLHANDLE;
                    goto LPrepareAddToConference_return;
                }
            }
        }
        myexcept
        {
            //
            // If here the conf call was destroyed
            //

            lRequestID = LINEERR_INVALCONFCALLHANDLE;
            goto LPrepareAddToConference_return;
        }

        if (pCallParamsApp)
        {
            DWORD   dwAPIVersion, dwSPIVersion;


            if (GetLineVersions(
                    ptLineClient,
                    &dwAPIVersion,
                    &dwSPIVersion

                    ) != 0)
            {
                lRequestID = LINEERR_INVALCONFCALLHANDLE;
                goto LPrepareAddToConference_return;
            }

            if ((lResult = ValidateCallParams(
                    pCallParamsApp,
                    &pCallParamsSP,
                    dwAPIVersion,
                    dwSPIVersion,
                    pParams->dwAsciiCallParamsCodePage

                    )) != 0)
            {
                lRequestID = lResult;
                goto LPrepareAddToConference_return;
            }
        }
        else
        {
            pCallParamsSP = (LPLINECALLPARAMS) NULL;
        }

        if (CreatetCallAndClient(
                ptLineClient,
                &ptConsultCall,
                &ptConsultCallClient,
                pCallParamsSP,
                &hConsultCall,
                NULL

                ) != 0)
        {
            lRequestID = LINEERR_NOMEM;
            goto LPrepareAddToConference_freeCallParams;
        }

        pAsyncRequestInfo->pfnPostProcess = LMakeCall_PostProcess;
        pAsyncRequestInfo->htXxx    = (ULONG_PTR)ptConsultCallClient->ptLineClient->ptLine->hLine;
        pAsyncRequestInfo->dwParam1 = (ULONG_PTR) ptConsultCall;
        pAsyncRequestInfo->dwParam2 = pParams->hpConsultCall;
        pAsyncRequestInfo->dwParam5 = (ULONG_PTR)hConsultCall;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP5(
            pfnTSPI_linePrepareAddToConference,
            "linePrepareAddToConference",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdConfCall,
            (ULONG_PTR) hConsultCall,
            (ULONG_PTR) &ptConsultCall->hdCall,
            (ULONG_PTR) pCallParamsSP
            );

        SetDrvCallFlags(
            hConsultCall,
            DCF_SPIRETURNED | (IS_LRESULT_NOTERROR(pParams->lResult) ?
                DCF_DRVCALLVALID : 0)
            );

LPrepareAddToConference_freeCallParams:

        if (pCallParamsSP != pCallParamsApp)
        {
            ServerFree (pCallParamsSP);
        }
    }

LPrepareAddToConference_return:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "PrepareAddToConference"
        );
}


void
WINAPI
LProxyMessage(
    PTCLIENT                    ptClient,
    PLINEPROXYMESSAGE_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVLINE        hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT    ptLineClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_NONE,                    // provider func index
            NULL,                       // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "ProxyMessage"              // func name

            )) == 0)
    {
        DWORD           dwMsg = pParams->dwMsg, i;
        PTCALL          ptCall;
        PTLINE          ptLine;
        TPOINTERLIST    clientList, *pClientList = &clientList;
        ASYNCEVENTMSG   msg[2];


        //
        // Verify params
        //

        try
        {
            ptLine = ptLineClient->ptLine;

            if (!(ptLineClient->dwPrivileges & LINEOPENOPTION_PROXY))
            {
                pParams->lResult = LINEERR_NOTREGISTERED;
                goto LProxyMessage_epilog;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
            goto LProxyMessage_epilog;
        }

        switch (dwMsg)
        {
        case LINE_AGENTSTATUS:

            // ignore the hCall param

            if (pParams->dwParam1 >= ptLine->dwNumAddresses)
            {
                LOG((TL_ERROR,
                    "ERROR: lineProxyMessage (AGENTSTATUS): dwParam1 " \
                        "bad addr ID (=x%x, num addrs=x%x)",
                    pParams->dwParam1,
                    ptLine->dwNumAddresses
                    ));

                pParams->lResult = LINEERR_INVALPARAM;
                goto LProxyMessage_epilog;
            }
            else if (pParams->dwParam2 == 0 ||
                    pParams->dwParam2 & ~AllAgentStatus)
            {
                LOG((TL_ERROR,
                    "ERROR: lineProxyMessage (AGENTSTATUS): dwParam2 " \
                        "(=x%x) bad LINEAGENTSTATUS_ flags",
                    pParams->dwParam2
                    ));

                pParams->lResult = LINEERR_INVALPARAM;
                goto LProxyMessage_epilog;
            }
            else if (pParams->dwParam2 & LINEAGENTSTATUS_STATE)
            {
                if (!IsOnlyOneBitSetInDWORD (pParams->dwParam3) ||
                    pParams->dwParam3 & ~AllAgentStates)
                {
                    LOG((TL_ERROR,
                        "ERROR: lineProxyMessage (AGENTSTATUS): " \
                            "dwParam3 (=x%x) bad LINEAGENTSTATE_ flags",
                        pParams->dwParam3
                        ));

                    pParams->lResult = LINEERR_INVALPARAM;
                    goto LProxyMessage_epilog;
                }
            }
            else if (pParams->dwParam3 != 0)
            {
                // don't bother complaining about a non-zero dwParam3

                pParams->dwParam3 = 0;
            }

            break;

        case LINE_AGENTSPECIFIC:

            // ignore dwParam1, dwParam2, & dwParam3 (app-specific)

            if (pParams->hCall)
            {
                PTCALLCLIENT    ptCallClient;


                if (!(ptCallClient = ReferenceCall(
                        pParams->hCall,
                        ptClient
                        )))
                {
                    pParams->lResult = LINEERR_INVALCALLHANDLE;
                    goto LProxyMessage_epilog;
                }

                ptCall = ptCallClient->ptCall;

                DereferenceObject (ghHandleTable, pParams->hCall, 1);

                goto LProxyMessage_fwdMsgToCallClients;
            }

            break;

        case LINE_AGENTSESSIONSTATUS:
            // ignore the hCall param

            // ignore the dwParam1 , it's the agent handle

            if (pParams->dwParam2 == 0 ||
                    pParams->dwParam2 & ~AllAgentSessionStatus)
            {
                LOG((TL_ERROR,
                    "ERROR: lineProxyMessage (AGENTSESSIONSTATUS): dwParam2 " \
                        "(=x%x) bad LINEAGENTSESSIONSTATUS_ flags",
                    pParams->dwParam2
                    ));

                pParams->lResult = LINEERR_INVALPARAM;
                goto LProxyMessage_epilog;
            }
            else if (pParams->dwParam2 & LINEAGENTSESSIONSTATUS_STATE)
            {
                if (!IsOnlyOneBitSetInDWORD (pParams->dwParam3) ||
                    pParams->dwParam3 & ~AllAgentSessionStates)
                {
                    LOG((TL_ERROR,
                        "ERROR: lineProxyMessage (AGENTSESSIONSTATUS): " \
                            "dwParam3 (=x%x) bad LINEAGENTSESSIONSTATE_ flags",
                        pParams->dwParam3
                        ));

                    pParams->lResult = LINEERR_INVALPARAM;
                    goto LProxyMessage_epilog;
                }
            }
            else if (pParams->dwParam3 != 0)
            {
                // don't bother complaining about a non-zero dwParam3

                pParams->dwParam3 = 0;
            }

            break;

        case LINE_AGENTSTATUSEX:
            // ignore the hCall param

            // ignore the dwParam1 , it's the agent handle

            if (pParams->dwParam2 == 0 ||
                    pParams->dwParam2 & ~AllAgentStatusEx)
            {
                LOG((TL_ERROR,
                    "ERROR: lineProxyMessage (AGENTSTATUSEX): dwParam2 " \
                        "(=x%x) bad LINEAGENTSTATUSEX_ flags",
                    pParams->dwParam2
                    ));

                pParams->lResult = LINEERR_INVALPARAM;
                goto LProxyMessage_epilog;
            }
            else if (pParams->dwParam2 & LINEAGENTSESSIONSTATUS_STATE)
            {
                if (!IsOnlyOneBitSetInDWORD (pParams->dwParam3) ||
                    pParams->dwParam3 & ~AllAgentStatesEx)
                {
                    LOG((TL_ERROR,
                        "ERROR: lineProxyMessage (AGENTSTATUSEX): " \
                            "dwParam3 (=x%x) bad LINEAGENTSTATEEX_ flags",
                        pParams->dwParam3
                        ));

                    pParams->lResult = LINEERR_INVALPARAM;
                    goto LProxyMessage_epilog;
                }
            }
            else if (pParams->dwParam3 != 0)
            {
                // don't bother complaining about a non-zero dwParam3

                pParams->dwParam3 = 0;
            }

            break;

        case LINE_QUEUESTATUS:
            // ignore the hCall param

            // ignore the dwParam1 , it's the queue handle

            if (pParams->dwParam2 == 0 ||
                    pParams->dwParam2 & ~AllQueueStatus)
            {
                LOG((TL_ERROR,
                    "ERROR: lineProxyMessage (QUEUESTATUS): dwParam2 " \
                        "(=x%x) bad LINEQUEUESTATUS_ flags",
                    pParams->dwParam2
                    ));

                pParams->lResult = LINEERR_INVALPARAM;
                goto LProxyMessage_epilog;
            }
            else if (pParams->dwParam3 != 0)
            {
                // don't bother complaining about a non-zero dwParam3

                pParams->dwParam3 = 0;
            }

            break;

        case LINE_GROUPSTATUS:
            // ignore the hCall param

            if (pParams->dwParam1 == 0 ||
                    pParams->dwParam1 & ~AllGroupStatus)
            {
                LOG((TL_ERROR,
                    "ERROR: lineProxyMessage (GROUPSTATUS): dwParam1 " \
                        "(=x%x) bad LINEQUEUESTATUS_ flags",
                    pParams->dwParam1
                    ));

                pParams->lResult = LINEERR_INVALPARAM;
                goto LProxyMessage_epilog;
            }
            else if (pParams->dwParam2 != 0)
            {
                // don't bother complaining about a non-zero dwParam2

                pParams->dwParam2 = 0;
            }
            else if (pParams->dwParam3 != 0)
            {
                // don't bother complaining about a non-zero dwParam3

                pParams->dwParam3 = 0;
            }

            break;

        default:

            LOG((TL_ERROR,
                "ERROR : lineProxyMessage: inval dwMsg (=x%x)",
                pParams->dwMsg
                ));

            pParams->lResult = LINEERR_INVALPARAM;
            goto LProxyMessage_epilog;

        } // switch (dwMsg)


        //
        // Fwd this msg on to all line's clients who say they support
        // >= TAPI_VERSION2_0 (not including the proxy's line client)
        //

        if ((pParams->lResult = GetLineClientListFromLine(
                ptLine,
                &pClientList

                )) != 0)
        {
            goto LProxyMessage_epilog;
        }

        msg->TotalSize          = sizeof (ASYNCEVENTMSG);
        msg->fnPostProcessProcHandle = 0;
        msg->Msg                = dwMsg;
        msg->Param1             = pParams->dwParam1;
        msg->Param2             = pParams->dwParam2;
        msg->Param3             = pParams->dwParam3;
        msg->Param4             = 0;

        for (i = 0; i < pClientList->dwNumUsedEntries; i++)
        {
            PTLINECLIENT    ptLineClient2 = (PTLINECLIENT)
                                pClientList->aEntries[i];


            if (ptLineClient2 != ptLineClient)
            {
                try
                {
                    if (ptLineClient2->ptLineApp->dwAPIVersion >=
                            TAPI_VERSION2_0)
                    {
                        if (FMsgDisabled (
                            ptLineClient2->ptLineApp->dwAPIVersion,
                            ptLineClient2->adwEventSubMasks,
                            dwMsg,
                            pParams->dwParam1
                            ))
                        {
                            continue;
                        }
                    
                        msg->InitContext =
                            ptLineClient2->ptLineApp->InitContext;
                        msg->hDevice     = ptLineClient2->hRemoteLine;
                        msg->OpenContext = ptLineClient2->OpenContext;


                        //
                        // Now a final check to make sure all the
                        // params are valid before sending the msg
                        //

                        {
                            PTCLIENT ptClient = ptLineClient2->ptClient;


                            if (ptLineClient2->dwKey == TLINECLIENT_KEY)
                            {
                                WriteEventBuffer (ptClient, msg);
                            }
                        }
                    }
                }
                myexcept
                {
                    // just continue
                }
            }
        }

        goto LProxyMessage_freeClientList;


        //
        // Fwd this msg on to all call's clients who say they support
        // >= TAPI_VERSION2_0 (not including the proxy's line client)
        //

LProxyMessage_fwdMsgToCallClients:

        if ((pParams->lResult = GetCallClientListFromCall(
                ptCall,
                &pClientList

                )) != 0)
        {
            goto LProxyMessage_epilog;
        }

        msg->TotalSize          = sizeof (ASYNCEVENTMSG) + sizeof (HCALLHUB);
        msg->fnPostProcessProcHandle = 0;
        msg->Msg                = dwMsg;
        msg->Param1             = pParams->dwParam1;
        msg->Param2             = pParams->dwParam2;
        msg->Param3             = pParams->dwParam3;

        for (i = 0; i < pClientList->dwNumUsedEntries; i++)
        {
            PTCALLCLIENT    ptCallClient = (PTCALLCLIENT)
                                pClientList->aEntries[i];


            try
            {
                if (ptCallClient->hCall != pParams->hCall)
                {
                        PTLINEAPP   ptLineApp;


                        ptLineApp = ptCallClient->ptLineClient->ptLineApp;

                        if (ptLineApp->dwAPIVersion >= TAPI_VERSION2_0)
                        {
                            if (FMsgDisabled (
                                ptCallClient->ptLineClient->ptLineApp->dwAPIVersion,
                                ptCallClient->adwEventSubMasks,
                                dwMsg,
                                pParams->dwParam1
                                ))
                            {
                                continue;
                            }
                            
                            msg->InitContext = ptLineApp->InitContext;
                            msg->hDevice     = ptCallClient->hCall;
                            msg->OpenContext =
                                ptCallClient->ptLineClient->OpenContext;
                            msg->Param4       =
                                ptCallClient->ptLineClient->hRemoteLine;


                            *((LPHCALLHUB)(&msg->Param4 + 1)) = 
                                    (ptCallClient->ptCallHubClient)?
                                        ptCallClient->ptCallHubClient->hCallHub : 
                                        (HCALLHUB)(ULONG_PTR)NULL;

                            //
                            // Now a final check to make sure all the
                            // params are valid before sending the msg
                            //

                            {
                                PTCLIENT ptClient = ptCallClient->ptClient;


                                if (ptCallClient->dwKey == TCALLCLIENT_KEY)
                                {
                                    WriteEventBuffer (ptClient, msg);
                                }
                            }
                        }
                }
            }
            myexcept
            {
                // just continue
            }
        }

LProxyMessage_freeClientList:

        if (pClientList != &clientList)
        {
            ServerFree (pClientList);
        }


    }

LProxyMessage_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "ProxyMessage"
        );
}


void
WINAPI
LProxyResponse(
    PTCLIENT                    ptClient,
    PLINEPROXYRESPONSE_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVLINE        hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT    pProxy;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            pParams->hLine,             // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_NONE,                    // provider func index
            NULL,                       // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &pProxy,                    // context
            "ProxyResponse"             // func name

            )) == 0)
    {
        PASYNCREQUESTINFO   pAsyncRequestInfo;


        //
        // The dwInstance param is the dwLocalRequestID for the
        // AsyncRequestInfo struct.  Note that the dwKey value of
        // this struct was reset to == pProxy->hLine in
        // CreateProxyRequest().
        //

        if (!(pAsyncRequestInfo = ReferenceObject(
                ghHandleTable,
                pParams->dwInstance,
                pParams->hLine
                )))
        {
                pParams->dwResult = LINEERR_OPERATIONFAILED;
                goto LProxyResponse_Epilog;
        }


        //
        // Safely remove the proxy request from the list of pending requests
        //

        if (WaitForExclusiveLineClientAccess (pProxy))
        {
            if (pAsyncRequestInfo->dwKey == pParams->hLine)
            {
                pAsyncRequestInfo->dwKey = TASYNC_KEY;

                if (pAsyncRequestInfo->dwParam5)
                {
                    ((PASYNCREQUESTINFO) pAsyncRequestInfo->dwParam5)->dwParam4 =
                        pAsyncRequestInfo->dwParam4;
                }

                if (pAsyncRequestInfo->dwParam4)
                {
                    ((PASYNCREQUESTINFO) pAsyncRequestInfo->dwParam4)->dwParam5 =
                        pAsyncRequestInfo->dwParam5;
                }
                else
                {
                    pProxy->pPendingProxyRequests = (PASYNCREQUESTINFO)
                        pAsyncRequestInfo->dwParam5;
                }

                UNLOCKTLINECLIENT(pProxy);
            }
            else
            {
                //
                // Another thread must have simultaneously been
                // completing this request, so fail gracefully
                //

                UNLOCKTLINECLIENT(pProxy);
                DereferenceObject (ghHandleTable, pParams->dwInstance, 1);
                pParams->dwResult = LINEERR_OPERATIONFAILED;
                goto LProxyResponse_Epilog;
            }
        }
        else
        {
            DereferenceObject (ghHandleTable, pParams->dwInstance, 1);
            pParams->dwResult = LINEERR_INVALLINEHANDLE;
            goto LProxyResponse_Epilog;
        }


        //
        // If this is a proxy request where there's data to be returned
        // to the client (aside from the result) then we want to alloc
        // a buffer & fill it with the data.  We'll make it look like a
        // DevSpecific request that just completed, and have the DevSpecfic
        // post process routine deal with it.
        //
        // Make sure buffers are 64-bit aligned
        //

        if (pParams->dwProxyResponseOffset != TAPI_NO_DATA &&
            pParams->dwResult == 0)
        {
            DWORD               dwSize;
            LPBYTE              pBuf;
            LPLINEPROXYREQUEST  pProxyRequest = (LPLINEPROXYREQUEST)
                                    ( pDataBuf + pParams->dwProxyResponseOffset );

            switch (pProxyRequest->dwRequestType)
            {
            case LINEPROXYREQUEST_AGENTSPECIFIC:
            {
                dwSize = pProxyRequest->AgentSpecific.dwSize;

                if (!(pBuf = ServerAlloc(
                        sizeof (ASYNCEVENTMSG) + ((dwSize + 7) & 0xfffffff8)
                        )))
                {
                    pParams->dwResult = LINEERR_NOMEM;
                    goto LProxyResponse_completeRequest;
                }

                CopyMemory(
                    pBuf + sizeof (ASYNCEVENTMSG),
                    pProxyRequest->AgentSpecific.Params,
                    dwSize
                    );

                break;
            }
            case LINEPROXYREQUEST_CREATEAGENT:
            case LINEPROXYREQUEST_CREATEAGENTSESSION:
            {
                //
                // Proces both of these together.  the handle is
                // the first member of both structures
                //

                dwSize = sizeof (HAGENT);

                pBuf = ServerAlloc(
                    sizeof(ASYNCEVENTMSG) + ((dwSize + 7) & 0xfffffff8)
                    );

                if ( NULL == pBuf )
                {
                    pParams->dwResult = LINEERR_NOMEM;
                    goto LProxyResponse_completeRequest;
                }

                CopyMemory(
                    pBuf + sizeof(ASYNCEVENTMSG),
                    &(pProxyRequest->CreateAgent.hAgent),
                    dwSize
                    );

                break;
            }
            case LINEPROXYREQUEST_GETQUEUELIST:
            {
                dwSize = pProxyRequest->GetQueueList.QueueList.dwUsedSize;

                pBuf = ServerAlloc(
                    sizeof(ASYNCEVENTMSG) + ((dwSize + 7) & 0xfffffff8)
                    );

                if ( NULL == pBuf )
                {
                    pParams->dwResult = LINEERR_NOMEM;
                    goto LProxyResponse_completeRequest;
                }

                CopyMemory(
                    pBuf + sizeof(ASYNCEVENTMSG),
                    &(pProxyRequest->GetQueueList.QueueList),
                    dwSize
                    );

                break;
            }
            case LINEPROXYREQUEST_GETGROUPLIST:
            {
                dwSize = pProxyRequest->GetGroupList.GroupList.dwUsedSize;

                pBuf = ServerAlloc(
                    sizeof(ASYNCEVENTMSG) + ((dwSize + 7) & 0xfffffff8)
                    );

                if ( NULL == pBuf )
                {
                    pParams->dwResult = LINEERR_NOMEM;
                    goto LProxyResponse_completeRequest;
                }

                CopyMemory(
                    pBuf + sizeof(ASYNCEVENTMSG),
                    &(pProxyRequest->GetGroupList.GroupList),
                    dwSize
                    );

                break;
            }
            case LINEPROXYREQUEST_GETAGENTCAPS:
            case LINEPROXYREQUEST_GETAGENTSTATUS:
            case LINEPROXYREQUEST_GETAGENTACTIVITYLIST:
            case LINEPROXYREQUEST_GETAGENTGROUPLIST:
            case LINEPROXYREQUEST_GETAGENTINFO:
            case LINEPROXYREQUEST_GETAGENTSESSIONLIST:
            case LINEPROXYREQUEST_SETAGENTSESSIONSTATE:
            case LINEPROXYREQUEST_GETAGENTSESSIONINFO:
            case LINEPROXYREQUEST_GETQUEUEINFO:
            {
                dwSize = pProxyRequest->GetAgentCaps.AgentCaps.dwUsedSize;

                if (!(pBuf = ServerAlloc(
                        sizeof (ASYNCEVENTMSG) + ((dwSize + 7) & 0xfffffff8)
                        )))
                {
                    pParams->dwResult = LINEERR_NOMEM;
                    goto LProxyResponse_completeRequest;
                }

                CopyMemory(
                    pBuf + sizeof (ASYNCEVENTMSG),
                    &pProxyRequest->GetAgentCaps.AgentCaps,
                    dwSize
                    );

                break;
            }
            default:

                LOG((TL_ERROR,
                    "LProxyResponse: unrecognized proxy request type (x%x)",
                    pProxyRequest->dwRequestType
                    ));

                pParams->dwResult = LINEERR_OPERATIONFAILED;
                goto LProxyResponse_completeRequest;
            }

            //
            // Check to see if the size of the data we're copying back is
            // larger than the size of client's buffer
            //

            if (dwSize > pAsyncRequestInfo->dwParam2)
            {
                LOG((TL_ERROR,
                    "LProxyResponse: data size too large (exp<=x%x,act=x%x)",
                    pAsyncRequestInfo->dwParam2,
                    dwSize
                    ));

                ServerFree (pBuf);
                pParams->dwResult = LINEERR_OPERATIONFAILED;
                goto LProxyResponse_completeRequest;
            }


            pAsyncRequestInfo->pfnPostProcess = LDevSpecific_PostProcess;
            pAsyncRequestInfo->dwParam2       = dwSize;
            pAsyncRequestInfo->dwParam3       = (ULONG_PTR) pBuf;
        }


        //
        // Now call the deferred completion proc with the "request id"
        // & result, just like a provider would
        //

LProxyResponse_completeRequest:

        CompletionProcSP(
            pAsyncRequestInfo->dwLocalRequestID,
            pParams->dwResult
            );

        DereferenceObject (ghHandleTable, pParams->dwInstance, 1);
    }

LProxyResponse_Epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "ProxyResponse"
        );

}


void
WINAPI
LRedirect(
    PTCLIENT                ptClient,
    PLINEREDIRECT_PARAMS    pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineRedirect;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDestAddressOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEREDIRECT,            // provider func index
            &pfnTSPI_lineRedirect,      // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "Redirect"                  // func name

            )) > 0)
    {
        pParams->lResult = CallSP4(
            pfnTSPI_lineRedirect,
            "lineRedirect",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) (pDataBuf + pParams->dwDestAddressOffset),
            (DWORD) pParams->dwCountryCode
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Redirect"
        );
}


void
WINAPI
LRegisterRequestRecipient(
    PTCLIENT                                ptClient,
    PLINEREGISTERREQUESTRECIPIENT_PARAMS    pParams,
    DWORD                                   dwParamsBufferSize,
    LPBYTE                                  pDataBuf,
    LPDWORD                                 pdwNumBytesReturned
    )
{
    PTLINEAPP   ptLineApp;


    if ((ptLineApp = WaitForExclusiveLineAppAccess(
            pParams->hLineApp,
            ptClient
            )))
    {
        DWORD   dwRequestMode = pParams->dwRequestMode;


        if (!(dwRequestMode &
                (LINEREQUESTMODE_MAKECALL | LINEREQUESTMODE_MEDIACALL)) ||
            (dwRequestMode &
                (~(LINEREQUESTMODE_MAKECALL | LINEREQUESTMODE_MEDIACALL))))
        {
            pParams->lResult = LINEERR_INVALREQUESTMODE;
            goto LRegisterRequestRecipient_myReleaseMutex;
        }

        if (pParams->bEnable)
        {
            //
            // If app wants MEDIACALL requests see if already registered
            //

            if ((dwRequestMode & LINEREQUESTMODE_MEDIACALL) &&
                ptLineApp->bReqMediaCallRecipient)
            {
                LOG((TL_ERROR, "App is already registered for mediacall"));
                pParams->lResult = LINEERR_OPERATIONFAILED;
                goto LRegisterRequestRecipient_myReleaseMutex;
            }


            //
            // If app wants MAKECALL requests see if already registered,
            // then prepare a request recipient object & add it to the
            // global list
            //

            if (dwRequestMode & LINEREQUESTMODE_MAKECALL)
            {
                if (!ptLineApp->pRequestRecipient)
                {
                    //
                    // Add to request recipient list
                    //

                    PTREQUESTRECIPIENT  pRequestRecipient;


                    if (!(pRequestRecipient= (PTREQUESTRECIPIENT) ServerAlloc(
                            sizeof (TREQUESTRECIPIENT)
                            )))
                    {
                        LOG((TL_ERROR, "Failed alloc for requestrecip struct"));
                        pParams->lResult = LINEERR_NOMEM;
                        goto LRegisterRequestRecipient_myReleaseMutex;
                    }

                    pRequestRecipient->ptLineApp = ptLineApp;
                    pRequestRecipient->dwRegistrationInstance =
                        pParams->dwRegistrationInstance;

                    EnterCriticalSection (&gPriorityListCritSec);

                    if ((pRequestRecipient->pNext =
                            TapiGlobals.pRequestRecipients))
                    {
                        pRequestRecipient->pNext->pPrev = pRequestRecipient;
                    }

                    TapiGlobals.pRequestRecipients = pRequestRecipient;

                    LeaveCriticalSection (&gPriorityListCritSec);

                    ptLineApp->pRequestRecipient = pRequestRecipient;

                    TapiGlobals.pHighestPriorityRequestRecipient =
                         GetHighestPriorityRequestRecipient();

                    if (TapiGlobals.pRequestMakeCallList)
                    {
                        NotifyHighestPriorityRequestRecipient();
                    }
                }
                else // already registered
                {
                    LOG((TL_ERROR, "App is already registered for makecall"));
                    pParams->lResult = LINEERR_OPERATIONFAILED;
                    goto LRegisterRequestRecipient_myReleaseMutex;
                }
            }


            //
            // Now register app for MEDIACALL reqs as appropriate
            //

            ptLineApp->bReqMediaCallRecipient =
                (dwRequestMode & LINEREQUESTMODE_MEDIACALL ?
                1 : ptLineApp->bReqMediaCallRecipient);
        }
        else
        {
            //
            // If apps doesn't want MEDIACALL requests see if not registered
            //

            if ((dwRequestMode & LINEREQUESTMODE_MEDIACALL) &&
                !ptLineApp->bReqMediaCallRecipient)
            {
                LOG((TL_ERROR, "App is not registered for mediacall"));
                pParams->lResult = LINEERR_OPERATIONFAILED;
                goto LRegisterRequestRecipient_myReleaseMutex;
            }


            //
            // If app doesn't want MAKECALL requests see if already
            // registered, then remove it's request recipient object
            // from the global list
            //

            if (dwRequestMode & LINEREQUESTMODE_MAKECALL)
            {
                if (ptLineApp->pRequestRecipient)
                {
                    //
                    // Remove from request recipient list
                    //

                    PTREQUESTRECIPIENT  pRequestRecipient =
                                            ptLineApp->pRequestRecipient;


                    EnterCriticalSection (&gPriorityListCritSec);

                    if (pRequestRecipient->pNext)
                    {
                        pRequestRecipient->pNext->pPrev =
                            pRequestRecipient->pPrev;
                    }

                    if (pRequestRecipient->pPrev)
                    {
                        pRequestRecipient->pPrev->pNext =
                            pRequestRecipient->pNext;
                    }
                    else
                    {
                        TapiGlobals.pRequestRecipients =
                            pRequestRecipient->pNext;
                    }

                    LeaveCriticalSection (&gPriorityListCritSec);

                    ServerFree (pRequestRecipient);

                    ptLineApp->pRequestRecipient = NULL;


                    //
                    // Reset the highest priority request recipient, then check
                    // to see if there's any pending request make calls
                    //

                    TapiGlobals.pHighestPriorityRequestRecipient =
                        GetHighestPriorityRequestRecipient();

                    if (TapiGlobals.pRequestMakeCallList)
                    {
                        if (TapiGlobals.pHighestPriorityRequestRecipient)
                        {
                            NotifyHighestPriorityRequestRecipient();
                        }

                        else
                        {
                            //
                            // We couldn't start a request recipient so
                            // nuke all pending request make calls
                            //

                            PTREQUESTMAKECALL   pRequestMakeCall,
                                                pNextRequestMakeCall;


                            pRequestMakeCall =
                                TapiGlobals.pRequestMakeCallList;

                            TapiGlobals.pRequestMakeCallList    =
                            TapiGlobals.pRequestMakeCallListEnd = NULL;

                            while (pRequestMakeCall)
                            {
                                pNextRequestMakeCall = pRequestMakeCall->pNext;
                                ServerFree (pRequestMakeCall);
                                pRequestMakeCall =  pNextRequestMakeCall;
                            }

                            LOG((TL_INFO,
                                "LRegisterRequestRecipient: deleting " \
                                    "pending MakeCall requests"
                                ));
                        }
                    }
                }
                else // not registered
                {
                    LOG((TL_ERROR, "App is not registered for makecall"));
                    pParams->lResult = LINEERR_OPERATIONFAILED;
                }
            }


            //
            // Now deregister app for MEDIACALL reqs as appropriate
            //

            ptLineApp->bReqMediaCallRecipient =
                (dwRequestMode & LINEREQUESTMODE_MEDIACALL ?
                0 : ptLineApp->bReqMediaCallRecipient);
        }

LRegisterRequestRecipient_myReleaseMutex:

        UNLOCKTLINEAPP(ptLineApp);
    }
    else
    {
        pParams->lResult = (TapiGlobals.dwNumLineInits == 0 ?
            LINEERR_UNINITIALIZED : LINEERR_INVALAPPHANDLE);
    }

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
			"lineRegisterRequestRecipient: exit, returning %s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
			"lineRegisterRequestRecipient: exit, returning x%x",
            pParams->lResult
            ));
#endif

    return;
}


void
WINAPI
LReleaseUserUserInfo(
    PTCLIENT            ptClient,
    PLINEDIAL_PARAMS    pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineReleaseUserUserInfo;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINERELEASEUSERUSERINFO, // provider func index
            &pfnTSPI_lineReleaseUserUserInfo,   // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "ReleaseUserUserInfo"       // func name

            )) > 0)
    {
        pParams->lResult = CallSP2(
            pfnTSPI_lineReleaseUserUserInfo,
            "lineReleaseUserUserInfo",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "ReleaseUserUserInfo"
        );
}


void
LRemoveFromConference_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
    if (pAsyncEventMsg->Param2 == 0)
    {
        PTCALL ptCall = (PTCALL) pAsyncRequestInfo->dwParam1;


        SetCallConfList (ptCall, (PTCONFERENCELIST) NULL, FALSE);
    }
}


void
WINAPI
LRemoveFromConference(
    PTCLIENT                            ptClient,
    PLINEREMOVEFROMCONFERENCE_PARAMS    pParams,
    DWORD                               dwParamsBufferSize,
    LPBYTE                              pDataBuf,
    LPDWORD                             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineRemoveFromConference;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEREMOVEFROMCONFERENCE,// provider func index
            &pfnTSPI_lineRemoveFromConference,  // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "RemoveFromConference"      // func name

            )) > 0)
    {
        PTCALL ptCall;


        //
        // Safely make sure the call is currently conferenced &
        // that it's not a conf parent
        //

        try
        {
            PTCONFERENCELIST pConfList;


            ptCall = ptCallClient->ptCall;

            pConfList = ptCall->pConfList;

            if (!pConfList ||
                (pConfList == (LPVOID) LongToPtr(0xffffffff)) ||
                (pConfList->aptCalls[0] == ptCall))
            {
                lRequestID = LINEERR_INVALCALLSTATE;
                goto LRemoveFromConference_return;
            }
        }
        myexcept
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LRemoveFromConference_return;
        }

        //
        // Set up the async request struct & call the SP
        //

        pAsyncRequestInfo->pfnPostProcess = LRemoveFromConference_PostProcess;
        pAsyncRequestInfo->dwParam1       = (ULONG_PTR) ptCall;

        pParams->lResult = CallSP2(
            pfnTSPI_lineRemoveFromConference,
            "lineRemoveFromConference",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall
            );
    }

LRemoveFromConference_return:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "RemoveFromConference"
        );
}


void
WINAPI
LSecureCall(
    PTCLIENT                ptClient,
    PLINESECURECALL_PARAMS  pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    DWORD               objectToDereference;
    TSPIPROC            pfnTSPI_lineSecureCall;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINESECURECALL,          // provider func index
            &pfnTSPI_lineSecureCall,    // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "SecureCall"                // func name

            )) > 0)
    {
        pParams->lResult = CallSP2(
            pfnTSPI_lineSecureCall,
            "lineSecureCall",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SecureCall"
        );
}


void
WINAPI
LSelectExtVersion(
    PTCLIENT                        ptClient,
    PLINESELECTEXTVERSION_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex, bCloseMutex2;
    HANDLE              hMutex, hMutex2;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineSelectExtVersion;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            pParams->hLine,             // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINESELECTEXTVERSION,    // provider func index
            &pfnTSPI_lineSelectExtVersion,  // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "SelectExtVersion"          // func name

            )) == 0)
    {
        if (WaitForExclusivetLineAccess(
                ptLineClient->ptLine,
                &hMutex2,
                &bCloseMutex2,
                INFINITE
                ))
        {
            if (IsValidLineExtVersion(
                    ptLineClient->ptLine->dwDeviceID,
                    pParams->dwExtVersion
                    ))
            {
                if (pParams->dwExtVersion)
                {
                    if (ptLineClient->ptLine->dwExtVersionCount  ||

                        (pParams->lResult = CallSP2(
                            pfnTSPI_lineSelectExtVersion,
                            "lineSelectExtVersion",
                            SP_FUNC_SYNC,
                            (ULONG_PTR) hdLine,
                            (DWORD) pParams->dwExtVersion

                            )) == 0)
                    {
                        ptLineClient->dwExtVersion =
                        ptLineClient->ptLine->dwExtVersion =
                            pParams->dwExtVersion;
                        ptLineClient->ptLine->dwExtVersionCount++;

                    }
                }
                else if (ptLineClient->ptLine->dwExtVersionCount)
                {
                    if (--ptLineClient->ptLine->dwExtVersionCount == 0)
                    {
                        CallSP2(
                            pfnTSPI_lineSelectExtVersion,
                            "lineSelectExtVersion",
                            SP_FUNC_SYNC,
                            (ULONG_PTR) hdLine,
                            (DWORD) 0
                            );

                        ptLineClient->ptLine->dwExtVersion = 0;
                    }

                    ptLineClient->dwExtVersion = 0;
                }
            }
            else
            {
                pParams->lResult = LINEERR_INCOMPATIBLEEXTVERSION;
            }

            MyReleaseMutex (hMutex2, bCloseMutex2);
        }
        else
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
        }
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "SetDefaultMediaDetection"
        );

}


void
WINAPI
LSendUserUserInfo(
    PTCLIENT                        ptClient,
    PLINESENDUSERUSERINFO_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineSendUserUserInfo;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if ((pParams->dwUserUserInfoOffset != TAPI_NO_DATA)  &&

        ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwSize,
            pParams->dwUserUserInfoOffset,
            sizeof(DWORD),
            "LSendUserUserInfo",
            "pParams->UserUserInfo"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINESENDUSERUSERINFO,    // provider func index
            &pfnTSPI_lineSendUserUserInfo,  // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "SendUserUserInfo"          // func name

            )) > 0)
    {
        pParams->lResult = CallSP4(
            pfnTSPI_lineSendUserUserInfo,
            "lineSendUserUserInfo",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) (pParams->dwUserUserInfoOffset == TAPI_NO_DATA ? NULL :
                pDataBuf + pParams->dwUserUserInfoOffset),
            (DWORD) (pParams->dwUserUserInfoOffset == TAPI_NO_DATA ? 0 :
                pParams->dwSize)
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SendUserUserInfo"
        );
}


void
WINAPI
LSetAppPriority(
    PTCLIENT                    ptClient,
    PLINESETAPPPRIORITY_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    DWORD   dwMediaMode   = pParams->dwMediaMode,
            dwRequestMode = pParams->dwRequestMode,
            dwPriority    = pParams->dwPriority;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwAppNameOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if (dwMediaMode == 0)
    {
        if ((dwRequestMode != LINEREQUESTMODE_MAKECALL) &&
            (dwRequestMode != LINEREQUESTMODE_MEDIACALL))
        {
            pParams->lResult = LINEERR_INVALREQUESTMODE;
            goto LSetAppPriority_return;
        }
    }
    else if ( dwMediaMode & ~AllMediaModes2_1 )
    {
        pParams->lResult = LINEERR_INVALMEDIAMODE;
        goto LSetAppPriority_return;
    }



    if ((dwPriority & 0xfffffffe))
    {
        pParams->lResult = LINEERR_INVALPARAM;
        goto LSetAppPriority_return;
    }


    if ((dwMediaMode & 0x00ffffff) || (dwMediaMode == 0))
    {
        WCHAR   szModuleName[MAX_PATH];
        WCHAR  *pszCurrentPriorityList, **ppszCurrentPriorityList;
        WCHAR  *pszLocationInPriorityList;
        DWORD   dwAppNameLength;
        DWORD   dwCount;


        szModuleName[0] = '"';
        
        wcsncpy(szModuleName + 1, 
                (PWSTR)(pDataBuf + pParams->dwAppNameOffset), 
                MAX_PATH - 2);

        szModuleName[MAX_PATH - 1] = '\0';

        _wcsupr(szModuleName + 1);
        dwAppNameLength = (DWORD) lstrlenW(szModuleName);


        //
        // Enter the pri list critical section before we start munging
        //

        EnterCriticalSection (&gPriorityListCritSec);


        //
        // Determine which of the priority lists we want to look at
        //

        if  (dwMediaMode & 0x00ffffff)
        {
            pszCurrentPriorityList = NULL;
            ppszCurrentPriorityList = NULL;
            for(
                dwCount = 0;
                dwCount < TapiGlobals.dwUsedPriorityLists;
                dwCount++
                )
            {
                // did we find it?
                if (dwMediaMode == TapiGlobals.pPriLists[dwCount].dwMediaModes)
                {
                    ppszCurrentPriorityList =
                        &(TapiGlobals.pPriLists[dwCount].pszPriList);
                    pszCurrentPriorityList = *ppszCurrentPriorityList;
                    break;
                }
            }

            // did we find it?
            if (NULL == ppszCurrentPriorityList)
            {
                // are we setting
                if (pParams->dwPriority != 0)
                {
                    // do we need to alloc more space?
                    if (TapiGlobals.dwUsedPriorityLists ==
                            TapiGlobals.dwTotalPriorityLists)
                    {
                        PRILISTSTRUCT * pNewList;

                        pNewList = (PRILISTSTRUCT *)ServerAlloc(
                            sizeof (PRILISTSTRUCT) *
                                TapiGlobals.dwTotalPriorityLists * 2
                            );

                        if (NULL == pNewList)
                        {
                            LOG((TL_ERROR, "Alloc failed in LineSetAppPriority"));
                            pParams->lResult = LINEERR_NOMEM;

                            goto LSetAppPriority_return;
                        }

                        CopyMemory(
                            pNewList,
                            TapiGlobals.pPriLists,
                            sizeof( PRILISTSTRUCT ) *
                                TapiGlobals.dwUsedPriorityLists
                            );

                        ServerFree(TapiGlobals.pPriLists);

                        TapiGlobals.pPriLists = pNewList;
                        TapiGlobals.dwTotalPriorityLists *= 2;
                    }

                    TapiGlobals.pPriLists[TapiGlobals.dwUsedPriorityLists].
                        dwMediaModes = dwMediaMode;
                    ppszCurrentPriorityList = &(TapiGlobals.pPriLists
                        [TapiGlobals.dwUsedPriorityLists].pszPriList);
                    pszCurrentPriorityList = *ppszCurrentPriorityList;
                    TapiGlobals.dwUsedPriorityLists++;
                }

            }
        }
        else
        {
            ppszCurrentPriorityList = (dwRequestMode==LINEREQUESTMODE_MAKECALL
                ? &TapiGlobals.pszReqMakeCallPriList :
                &TapiGlobals.pszReqMediaCallPriList);

            pszCurrentPriorityList = *ppszCurrentPriorityList;
        }


        LOG((TL_INFO,
            "LSetAppPri: priList=%ls",
            (pszCurrentPriorityList ? pszCurrentPriorityList : L"<empty>")
            ));


        //
        // Add app to priority list
        //

        if (pParams->dwPriority)
        {
            if (pszCurrentPriorityList &&

                (pszLocationInPriorityList = wcsstr(
                    pszCurrentPriorityList,
                    szModuleName
                    )))
            {
                //
                // App already in list. If app not currently at front of
                // list then move it to front.
                //

                if (pszLocationInPriorityList != pszCurrentPriorityList)
                {
                    MoveMemory(
                        pszCurrentPriorityList + dwAppNameLength,
                        pszCurrentPriorityList,
                        (pszLocationInPriorityList - pszCurrentPriorityList) *
                            sizeof(WCHAR)
                        );

                    wcscpy(pszCurrentPriorityList, szModuleName);

                    pszCurrentPriorityList[dwAppNameLength] = '"';
                }
            }
            else
            {
                //
                // App not in list, so create a new list
                //

                WCHAR *pszNewPriorityList;


                if (!(pszNewPriorityList = ServerAlloc(
                      sizeof(WCHAR) *
                         (dwAppNameLength + (pszCurrentPriorityList ?
                            lstrlenW(pszCurrentPriorityList) : 0) +
                            1)   // for terminating NULL
                        )))
                {
                    pParams->lResult = LINEERR_NOMEM;
                }
                else
                {
                    wcscpy(pszNewPriorityList, szModuleName);

                    if (pszCurrentPriorityList)
                    {
                        wcscat(pszNewPriorityList, pszCurrentPriorityList);
                        ServerFree (pszCurrentPriorityList);
                    }

                    *ppszCurrentPriorityList = pszNewPriorityList;
                }
            }
        }


        //
        // Remove app from priority list for specified media mode
        //
        // Note: We currently do not alloc a smaller buffer to store
        //       the new list in, we just use the existing one.
        //

        else
        {
            if (pszCurrentPriorityList &&

                (pszLocationInPriorityList = wcsstr(
                    pszCurrentPriorityList,
                    szModuleName
                    )))
            {
                if (*(pszLocationInPriorityList + dwAppNameLength) != 0)
                {
                    //
                    // This is not the last app in the list, so move
                    // following apps up one notch in the list
                    //

                    wcscpy(
                        pszLocationInPriorityList,
                        pszLocationInPriorityList + dwAppNameLength
                        );
                }
                else if (pszLocationInPriorityList == pszCurrentPriorityList)
                {
                    //
                    // This is the only app in the list, so free the buffer
                    // & set the global pointer to NULL
                    //

                    ServerFree (pszCurrentPriorityList);
                    *ppszCurrentPriorityList = NULL;
                }
                else
                {
                    //
                    // This is the last app in the list, so just mark this as
                    // the end of the list
                    //

                    *pszLocationInPriorityList = 0;
                }
            }
        }


        //
        // We're done munging, so leave the pri list crit sec
        //

        LeaveCriticalSection (&gPriorityListCritSec);
    }

LSetAppPriority_return:


    LOG((TL_TRACE, 
		"LineEpilogSync (lineSetAppPriority) exit, returning x%x",
        pParams->lResult
        ));
}


void
WINAPI
LSetAgentActivity(
    PTCLIENT                        ptClient,
    PLINESETAGENTACTIVITY_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            pParams->hLine,             // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "SetAgentActivity"          // func name

            )) > 0)
    {
       LONG            lResult;
       DWORD           dwDeviceID;
       PTLINECLIENT    pProxy;


        if ((lResult = FindProxy(
                ptLineClient,
                pParams->dwAddressID,
                LINEPROXYREQUEST_SETAGENTACTIVITY,
                &pProxy,
                &dwDeviceID,
                0               // API ver wasn't checked in 2.0
                )))
        {
            lRequestID = lResult;
            goto LSetAgentActivity_epilog;
        }


        //
        // First check to see if there's a (local) proxy registered
        // for this type of request on this line.  If so, build a
        // request & send it to the proxy.
        //

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_SETAGENTACTIVITY,
                    2 * sizeof (DWORD),
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentActivity_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.SetAgentActivity.dwAddressID  =
                pParams->dwAddressID;
            pProxyRequestWrapper->ProxyRequest.SetAgentActivity.dwActivityID =
                pParams->dwActivityID;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentActivity_epilog;
            }
            else // success
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


        //
        // There's no proxy, so check to see if line is remote and
        // call remotesp if so
        //

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            pParams->lResult = CallSP4(
                pRemoteSP->apfn[SP_LINESETAGENTACTIVITY],
                "lineSetAgentActivity",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->dwAddressID,
                (DWORD) pParams->dwActivityID
                );
        }


        //
        // There's no registered proxy & line is not remote, so fail
        //

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LSetAgentActivity_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetAgentActivity"
        );
}


void
WINAPI
LSetAgentGroup(
    PTCLIENT                    ptClient,
    PLINESETAGENTGROUP_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            pParams->hLine,             // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "SetAgentGroup"             // func name

            )) > 0)
    {
        LONG                    lResult;
        DWORD                   dwDeviceID;
        PTLINECLIENT            pProxy;
        LPLINEAGENTGROUPLIST    pGroupList = (LPLINEAGENTGROUPLIST)
                                    (pDataBuf + pParams->dwAgentGroupListOffset);


        //
        // Verify size/offset/string params given our input buffer/size
        //

        if (IsBadStructParam(
                dwParamsBufferSize,
                pDataBuf,
                pParams->dwAgentGroupListOffset
                ))
        {
            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LSetAgentGroup_epilog;
        }


        //
        // Param verification...
        //

        {
            DWORD                   dwTotalSize = pGroupList->dwTotalSize;


            if (dwTotalSize < sizeof (LINEAGENTGROUPLIST))
            {
                lRequestID = LINEERR_STRUCTURETOOSMALL;
                goto LSetAgentGroup_epilog;
            }

            if (ISBADSIZEOFFSET(
                    dwTotalSize,
                    sizeof (LINEAGENTGROUPLIST),
                    pGroupList->dwListSize,
                    pGroupList->dwListOffset,
                    guiAlignmentFaultEnabled? sizeof(DWORD) : 0,
                    "lineSetAgentGroup",
                    "List"
                    ))
            {
                lRequestID = LINEERR_INVALAGENTGROUP;
                goto LSetAgentGroup_epilog;
            }

            if (pGroupList->dwNumEntries >
                    ((dwTotalSize - sizeof (LINEAGENTGROUPLIST)) /
                        sizeof (LINEAGENTGROUPENTRY)))
            {
                lRequestID = LINEERR_INVALAGENTGROUP;
                goto LSetAgentGroup_epilog;
            }
        }

        if ((lResult = FindProxy(
                ptLineClient,
                pParams->dwAddressID,
                LINEPROXYREQUEST_SETAGENTGROUP,
                &pProxy,
                &dwDeviceID,
                0               // API ver wasn't checked in 2.0
                )))
        {
            lRequestID = lResult;
            goto LSetAgentGroup_epilog;
        }


        //
        // First check to see if there's a (local) proxy registered
        // for this type of request on this line.  If so, build a
        // request & send it to the proxy.
        //

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_SETAGENTGROUP,
                    sizeof (DWORD) + pGroupList->dwTotalSize,
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentGroup_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.SetAgentGroup.dwAddressID  =
                pParams->dwAddressID;

            CopyMemory(
                &pProxyRequestWrapper->ProxyRequest.SetAgentGroup.GroupList,
                pGroupList,
                pGroupList->dwTotalSize
                );

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentGroup_epilog;
            }
            else // success
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


        //
        // There's no proxy, so check to see if line is remote and
        // call remotesp if so
        //

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            pParams->lResult = CallSP4(
                pRemoteSP->apfn[SP_LINESETAGENTGROUP],
                "lineSetAgentGroup",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->dwAddressID,
                (ULONG_PTR) pGroupList
                );
        }


        //
        // There's no registered proxy & line is not remote, so fail
        //

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LSetAgentGroup_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetAgentGroup"
        );
}


void
WINAPI
LSetAgentMeasurementPeriod(
    PTCLIENT                                ptClient,
    PLINESETAGENTMEASUREMENTPERIOD_PARAMS   pParams,
    DWORD                                   dwParamsBufferSize,
    LPBYTE                                  pDataBuf,
    LPDWORD                                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            pParams->hLine,             // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "SetAgentMeasurementPeriod" // func name

            )) > 0)
    {
        LONG            lResult;
        DWORD           dwDeviceID;
        PTLINECLIENT    pProxy;


        if ((lResult = FindProxy(
                ptLineClient,
                0,
                LINEPROXYREQUEST_SETAGENTMEASUREMENTPERIOD,
                &pProxy,
                &dwDeviceID,
                TAPI_VERSION2_2
                )))
        {
            lRequestID = lResult;
            goto LSetAgentMeasurementPeriod_epilog;
        }


        // Measurement period must be > 0
        if (pParams->dwMeasurementPeriod == 0)
        {
            lRequestID = LINEERR_INVALPARAM;
            goto LSetAgentMeasurementPeriod_epilog;
        }


        //
        // First check to see if there's a (local) proxy registered
        // for this type of request on this line.  If so, build a
        // request & send it to the proxy.
        //

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_SETAGENTMEASUREMENTPERIOD,
                    sizeof (DWORD) + sizeof (HAGENT),
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentMeasurementPeriod_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.
                SetAgentMeasurementPeriod.hAgent = pParams->hAgent;

            pProxyRequestWrapper->ProxyRequest.
                SetAgentMeasurementPeriod.dwMeasurementPeriod =
                pParams->dwMeasurementPeriod;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentMeasurementPeriod_epilog;
            }
            else // success
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


        //
        // There's no proxy, so check to see if line is remote and
        // call remotesp if so
        //

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            pParams->lResult = CallSP4(
                pRemoteSP->apfn[SP_LINESETAGENTMEASUREMENTPERIOD],
                "lineSetAgentMeasurementPeriod",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->hAgent,
                (DWORD) pParams->dwMeasurementPeriod
                );
        }


        //
        // There's no registered proxy & line is not remote, so fail
        //

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LSetAgentMeasurementPeriod_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetAgentMeasurementPeriod"
        );
}


void
WINAPI
LSetAgentSessionState(
    PTCLIENT                            ptClient,
    PLINESETAGENTSESSIONSTATE_PARAMS    pParams,
    DWORD                               dwParamsBufferSize,
    LPBYTE                              pDataBuf,
    LPDWORD                             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            pParams->hLine,             // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "SetAgentSessionState"      // func name

            )) > 0)
    {
        LONG            lResult;
        DWORD           dwDeviceID;
        DWORD           dwAgentState     = pParams->dwAgentState;
        DWORD           dwNextAgentState = pParams->dwNextAgentState;
        PTLINECLIENT    pProxy;


        //
        // Param verification...
        //

        if (dwAgentState == 0  &&  dwNextAgentState == 0)
        {
            lRequestID = LINEERR_INVALAGENTSESSIONSTATE;
            goto LSetAgentSessionState_epilog;
        }

        if (dwAgentState != 0 &&
            (!IsOnlyOneBitSetInDWORD (dwAgentState) ||
            dwAgentState & ~AllAgentSessionStates))
        {
            lRequestID = LINEERR_INVALAGENTSESSIONSTATE;
            goto LSetAgentSessionState_epilog;
        }

        if (dwNextAgentState != 0 &&
            (!IsOnlyOneBitSetInDWORD (dwNextAgentState) ||
            dwNextAgentState & ~AllAgentSessionStates))
        {
            lRequestID = LINEERR_INVALAGENTSESSIONSTATE;
            goto LSetAgentSessionState_epilog;
        }


        if ((lResult = FindProxy(
                ptLineClient,
                0,
                LINEPROXYREQUEST_SETAGENTSESSIONSTATE,
                &pProxy,
                &dwDeviceID,
                TAPI_VERSION2_2
                )))
        {
            lRequestID = lResult;
            goto LSetAgentSessionState_epilog;
        }


        //
        // First check to see if there's a (local) proxy registered
        // for this type of request on this line.  If so, build a
        // request & send it to the proxy.
        //

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_SETAGENTSESSIONSTATE,
                    2 * sizeof (DWORD) + sizeof (HAGENT),
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentSessionState_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.
                SetAgentSessionState.hAgentSession = pParams->hAgentSession;

            pProxyRequestWrapper->ProxyRequest.
                SetAgentSessionState.dwAgentSessionState = dwAgentState;

            pProxyRequestWrapper->ProxyRequest.
                SetAgentSessionState.dwNextAgentSessionState = dwNextAgentState;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentSessionState_epilog;
            }
            else // success
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


        //
        // There's no proxy, so check to see if line is remote and
        // call remotesp if so
        //

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            pParams->lResult = CallSP5(
                pRemoteSP->apfn[SP_LINESETAGENTSESSIONSTATE],
                "lineSetAgentSessionState",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->hAgentSession,
                (DWORD) pParams->dwAgentState,
                (DWORD) pParams->dwNextAgentState
                );
        }


        //
        // There's no registered proxy & line is not remote, so fail
        //

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LSetAgentSessionState_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetAgentSessionState"
        );
}


void
WINAPI
LSetAgentState(
    PTCLIENT                    ptClient,
    PLINESETAGENTSTATE_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;

    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            pParams->hLine,             // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "SetAgentState"             // func name

            )) > 0)
    {
        LONG            lResult;
        DWORD           dwDeviceID,
                        dwAddressID      = pParams->dwAddressID,
                        dwAgentState     = pParams->dwAgentState,
                        dwNextAgentState = pParams->dwNextAgentState;
        PTLINECLIENT    pProxy;


        //
        // Param verification...
        //

        if (dwAgentState == 0  &&  dwNextAgentState == 0)
        {
            lRequestID = LINEERR_INVALAGENTSTATE;
            goto LSetAgentState_epilog;
        }

        if (dwAgentState != 0 &&
            (!IsOnlyOneBitSetInDWORD (dwAgentState) ||
            dwAgentState & ~AllAgentStates))
        {
            lRequestID = LINEERR_INVALAGENTSTATE;
            goto LSetAgentState_epilog;
        }

        if (dwNextAgentState != 0 &&
            (!IsOnlyOneBitSetInDWORD (dwNextAgentState) ||
            dwNextAgentState & ~AllAgentStates))
        {
            lRequestID = LINEERR_INVALAGENTSTATE;
            goto LSetAgentState_epilog;
        }

        if ((lResult = FindProxy(
                ptLineClient,
                dwAddressID,
                LINEPROXYREQUEST_SETAGENTSTATE,
                &pProxy,
                &dwDeviceID,
                0               // API ver wasn't checked in 2.0
                )))
        {
            lRequestID = lResult;
            goto LSetAgentState_epilog;
        }


        //
        // First check to see if there's a (local) proxy registered
        // for this type of request on this line.  If so, build a
        // request & send it to the proxy.
        //

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_SETAGENTSTATE,
                    3 * sizeof (DWORD),
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentState_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.SetAgentState.dwAddressID =
                dwAddressID;
            pProxyRequestWrapper->ProxyRequest.SetAgentState.dwAgentState =
                dwAgentState;
            pProxyRequestWrapper->ProxyRequest.SetAgentState.dwNextAgentState =
                dwNextAgentState;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentState_epilog;
            }
            else // success
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


        //
        // There's no proxy, so check to see if line is remote and
        // call remotesp if so
        //

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            pParams->lResult = CallSP5(
                pRemoteSP->apfn[SP_LINESETAGENTSTATE],
                "lineSetAgentState",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) dwAddressID,
                (DWORD) dwAgentState,
                (DWORD) dwNextAgentState
                );
        }


        //
        // There's no registered proxy & line is not remote, so fail
        //

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LSetAgentState_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetAgentState"
        );

}


void
WINAPI
LSetAgentStateEx(
    PTCLIENT                            ptClient,
    PLINESETAGENTSTATEEX_PARAMS         pParams,
    DWORD                               dwParamsBufferSize,
    LPBYTE                              pDataBuf,
    LPDWORD                             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


   if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            pParams->hLine,             // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "SetAgentStateEx"           // func name

            )) > 0)
    {
        LONG            lResult;
        DWORD           dwDeviceID;
        DWORD           dwAgentState     = pParams->dwAgentState;
        DWORD           dwNextAgentState = pParams->dwNextAgentState;
        PTLINECLIENT    pProxy;


        //
        // Param verification...
        //

        if (dwAgentState == 0  &&  dwNextAgentState == 0)
        {
            lRequestID = LINEERR_INVALAGENTSTATE;
            goto LSetAgentStateEx_epilog;
        }

        if (dwAgentState != 0 &&
            (!IsOnlyOneBitSetInDWORD (dwAgentState) ||
            dwAgentState & ~AllAgentStatesEx))
        {
            lRequestID = LINEERR_INVALAGENTSTATE;
            goto LSetAgentStateEx_epilog;
        }

        if (dwNextAgentState != 0 &&
            (!IsOnlyOneBitSetInDWORD (dwNextAgentState) ||
            dwNextAgentState & ~AllAgentStatesEx))
        {
            lRequestID = LINEERR_INVALAGENTSTATE;
            goto LSetAgentStateEx_epilog;
        }


        //
        // Find Proxy
        //

        if ((lResult = FindProxy(
                ptLineClient,
                0,
                LINEPROXYREQUEST_SETAGENTSTATEEX,
                &pProxy,
                &dwDeviceID,
                TAPI_VERSION2_2
                )))
        {
            lRequestID = lResult;
            goto LSetAgentStateEx_epilog;
        }


        //
        // First check to see if there's a (local) proxy registered
        // for this type of request on this line.  If so, build a
        // request & send it to the proxy.
        //

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_SETAGENTSTATEEX,
                    2 * sizeof (DWORD) + sizeof (HAGENT),
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentStateEx_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.SetAgentStateEx.hAgent = pParams->hAgent;
            pProxyRequestWrapper->ProxyRequest.SetAgentStateEx.dwAgentState = dwAgentState;
            pProxyRequestWrapper->ProxyRequest.SetAgentStateEx.dwNextAgentState = dwNextAgentState;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LSetAgentStateEx_epilog;
            }
            else // success
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


        //
        // There's no proxy, so check to see if line is remote and
        // call remotesp if so
        //

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            pParams->lResult = CallSP5(
                pRemoteSP->apfn[SP_LINESETAGENTSTATEEX],
                "lineSetAgentStateEx",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->hAgent,
                (DWORD) dwAgentState,
                (DWORD) dwNextAgentState
                );
        }


        //
        // There's no registered proxy & line is not remote, so fail
        //

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LSetAgentStateEx_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetAgentStateEx"
        );
}


void
WINAPI
LSetAppSpecific(
    PTCLIENT                    ptClient,
    PLINESETAPPSPECIFIC_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineSetAppSpecific;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            pParams->hCall,             // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINESETAPPSPECIFIC,      // provider func index
            &pfnTSPI_lineSetAppSpecific,// provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "SetAppSpecific"            // func name

            )) == 0)
    {
        pParams->lResult = CallSP2(
            pfnTSPI_lineSetAppSpecific,
            "lineSetAppSpecific",
            SP_FUNC_SYNC,
            (ULONG_PTR) hdCall,
            (DWORD) pParams->dwAppSpecific
            );
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "SetAppSpecific"
        );
}


void
WINAPI
LSetCallData(
    PTCLIENT                ptClient,
    PLINESETCALLDATA_PARAMS pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineSetCallData;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwCallDataSize,
            pParams->dwCallDataOffset,
            sizeof(DWORD),
            "LSetCallData",
            "pParams->CallData"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
                ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            pParams->hCall,             // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINESETCALLDATA,         // provider func index
            &pfnTSPI_lineSetCallData,   // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "SetCallData"               // func name

            )) > 0)
    {
        pParams->lResult = CallSP4(
            pfnTSPI_lineSetCallData,
            "lineSetCallData",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) (pParams->dwCallDataSize ?
                pDataBuf + pParams->dwCallDataOffset : NULL),
            (DWORD) pParams->dwCallDataSize
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetCallData"
        );
}


void
WINAPI
LSetCallHubTracking(
    PTCLIENT                        ptClient,
    PLINESETCALLHUBTRACKING_PARAMS  pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVLINE        hdLine;
    TSPIPROC        pfnTSPI_lineSetCallHubTracking;
    DWORD               objectToDereference;
    PTLINECLIENT    ptLineClient;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (IsBadStructParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwTrackingInfoOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult =LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            pParams->hLine,             // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINESETCALLHUBTRACKING,  // provider func index
            &pfnTSPI_lineSetCallHubTracking,// provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "SetCallHubTracking"        // func name

            )) == 0  ||

        (pParams->lResult == LINEERR_OPERATIONUNAVAIL))
    {
        BOOL                       bOwnMutex, bSetSPTracking;
        DWORD                      dwNewSPTracking;
        PTLINE                     ptLine;
        PTLINELOOKUPENTRY          pLookupEntry;
        LPLINECALLHUBTRACKINGINFO  pTrackingInfo;


        if (pParams->lResult == LINEERR_OPERATIONUNAVAIL)
        {
            pParams->lResult = 0;
            pfnTSPI_lineSetCallHubTracking = (TSPIPROC) NULL;
        }


        //
        // Check validity of tracking info structure
        //

        pTrackingInfo = (LPLINECALLHUBTRACKINGINFO)
            (pDataBuf + pParams->dwTrackingInfoOffset);

        if (pTrackingInfo->dwTotalSize < sizeof (LINECALLHUBTRACKINGINFO))
        {
            pParams->lResult = LINEERR_STRUCTURETOOSMALL;
            goto LSetCallHubTracking_epilog;
        }


        //
        // Check for invalid options
        //

        switch (pTrackingInfo->dwCurrentTracking)
        {
        case LINECALLHUBTRACKING_NONE:
        case LINECALLHUBTRACKING_ALLCALLS:

            break;

        case (LINECALLHUBTRACKING_ALLCALLS |LINECALLHUBTRACKING_PROVIDERLEVEL):

            if (!pfnTSPI_lineSetCallHubTracking)
            {
                pParams->lResult = LINEERR_INVALPARAM;
                goto LSetCallHubTracking_epilog;
            }
            break;

        default:

            pParams->lResult = LINEERR_INVALPARAM;
            goto LSetCallHubTracking_epilog;
        }


        //
        // Safely get exclusive access to the tLine, then check if:
        //
        //   * new tLineClient tracking state equals current tLineClient
        //     tracking state, in which case we can simply return success, or
        //
        //   * new tLineClient tracking state has no net effect on the
        //     driver's line tracking state due to the existing number
        //     of trackers, in which case we can simply adjust the current
        //     number of trackers and return success, or
        //
        //   * (otherwise) we need to inform driver of new tracking state
        //

        bOwnMutex = FALSE;

        try
        {
            pLookupEntry = GetLineLookupEntry(
                ptLineClient->ptLine->dwDeviceID
                );

            if (!pLookupEntry)
            {
                pParams->lResult = LINEERR_INVALLINEHANDLE;
                goto LSetCallHubTracking_epilog;
            }

            WaitForSingleObject (pLookupEntry->hMutex, INFINITE);

            bOwnMutex = TRUE;

            if ((ptLineClient->dwKey != TLINECLIENT_KEY)  ||
                !(ptLine = pLookupEntry->ptLine))
            {
                ReleaseMutex (pLookupEntry->hMutex);
                pParams->lResult = LINEERR_INVALLINEHANDLE;
                goto LSetCallHubTracking_epilog;
            }
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            if (bOwnMutex)
            {
                ReleaseMutex (pLookupEntry->hMutex);
            }

            pParams->lResult = LINEERR_INVALLINEHANDLE;
            goto LSetCallHubTracking_epilog;
        }

        if (pTrackingInfo->dwCurrentTracking ==
                ptLineClient->dwCurrentTracking)
        {
             goto LSetCallHubTracking_releaseMutex;
        }


        bSetSPTracking = FALSE;

        switch (pTrackingInfo->dwCurrentTracking)
        {
        case LINECALLHUBTRACKING_NONE:
        case LINECALLHUBTRACKING_ALLCALLS:

            if (ptLineClient->dwCurrentTracking &
                    LINECALLHUBTRACKING_PROVIDERLEVEL)
            {
                if (ptLine->dwNumCallHubTrackersSPLevel == 1)
                {
                    //
                    // We're the only one with SP-level tracking
                    // currently enabled, so call SP to turn OFF
                    // tracking
                    //

                    bSetSPTracking  = TRUE;
                    dwNewSPTracking = LINECALLHUBTRACKING_NONE;
                }
            }

            break;

        default : // CALLHUBTRACKING_ALLCALLS | CALLHUBTRACKING_PROVIDERLEVEL

            if (ptLine->dwNumCallHubTrackersSPLevel > 0)
            {
                //
                // We're the only one with SP-level tracking
                // currently enabled, so call SP to turn ON
                // tracking
                //

                bSetSPTracking  = TRUE;
                dwNewSPTracking = LINECALLHUBTRACKING_ALLCALLS |
                    LINECALLHUBTRACKING_PROVIDERLEVEL;
            }

            break;
        }

        if (bSetSPTracking  &&  pfnTSPI_lineSetCallHubTracking)
        {
            LINECALLHUBTRACKINGINFO info;


            info.dwTotalSize         =
            info.dwNeededSize        =
            info.dwUsedSize          = sizeof (info);
            info.dwAvailableTracking = 0;
            info.dwCurrentTracking   = dwNewSPTracking;

            pParams->lResult = CallSP2(
                pfnTSPI_lineSetCallHubTracking,
                "lineSetCallHubTracking",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdLine,
                (ULONG_PTR) &info
                );
        }

        if (pParams->lResult == 0)
        {
            switch (pTrackingInfo->dwCurrentTracking)
            {
            case LINECALLHUBTRACKING_NONE:

                ptLine->dwNumCallHubTrackers--;

                if (ptLineClient->dwCurrentTracking &
                        LINECALLHUBTRACKING_PROVIDERLEVEL)
                {
                    ptLine->dwNumCallHubTrackersSPLevel--;
                }

                break;

            case LINECALLHUBTRACKING_ALLCALLS:

                if (ptLineClient->dwCurrentTracking ==
                        LINECALLHUBTRACKING_NONE)
                {
                    ptLine->dwNumCallHubTrackers++;
                }
                else
                {
                    ptLine->dwNumCallHubTrackersSPLevel--;
                }

                break;

            default: // CALLHUBTRACKING_ALLCALLS |CALLHUBTRACKING_PROVIDERLEVEL

                if (ptLineClient->dwCurrentTracking ==
                        LINECALLHUBTRACKING_NONE)
                {
                    ptLine->dwNumCallHubTrackers++;
                }

                ptLine->dwNumCallHubTrackersSPLevel++;

                break;
            }

            ptLineClient->dwCurrentTracking = pTrackingInfo->dwCurrentTracking;
        }

LSetCallHubTracking_releaseMutex:

        ReleaseMutex (ptLine->hMutex);
    }

LSetCallHubTracking_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "SetCallHubTracking"
        );
}


void
WINAPI
LSetCallParams(
    PTCLIENT                    ptClient,
    PLINESETCALLPARAMS_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineSetCallParams;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if ((pParams->dwDialParamsOffset != TAPI_NO_DATA)  &&

        ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            sizeof (LINEDIALPARAMS),
            pParams->dwDialParamsOffset,
            sizeof(DWORD),
            "LSetCallParams",
            "pParams->DialParams"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            pParams->hCall,             // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINESETCALLPARAMS,       // provider func index
            &pfnTSPI_lineSetCallParams, // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "SetCallParams"             // func name

            )) > 0)
    {
        DWORD   dwAPIVersion, dwAllBearerModes,
                dwBearerMode = pParams->dwBearerMode;


        //
        // Safely get the API ver associated with this call & make sure
        // no invalid bearer modes are specified (high 16 bearer mode
        // bits are extensions)
        //

        try
        {
            dwAPIVersion = ptCallClient->ptLineClient->dwAPIVersion;
        }
        myexcept
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LSetCallParams_epilog;
        }

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:

            dwAllBearerModes = AllBearerModes1_0;
            break;

        case TAPI_VERSION1_4:

            dwAllBearerModes = AllBearerModes1_4;
            break;

        case TAPI_VERSION2_0:
        case TAPI_VERSION2_1:
        case TAPI_VERSION2_2:
        case TAPI_VERSION3_0:
        case TAPI_VERSION_CURRENT:

            dwAllBearerModes = AllBearerModes2_0;
            break;

        default:

            lRequestID = LINEERR_INVALBEARERMODE;
            goto LSetCallParams_epilog;
        }

        if (!IsOnlyOneBitSetInDWORD(dwBearerMode) ||
            (dwBearerMode & ~(dwAllBearerModes | 0xffff0000)))
        {
            lRequestID = LINEERR_INVALBEARERMODE;
            goto LSetCallParams_epilog;
        }

        pParams->lResult = CallSP6(
            pfnTSPI_lineSetCallParams,
            "lineSetCallParams",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (DWORD) pParams->dwBearerMode,
            (DWORD) pParams->dwMinRate,
            (DWORD) pParams->dwMaxRate,
            (ULONG_PTR) (pParams->dwDialParamsOffset == TAPI_NO_DATA ? NULL :
                pDataBuf + pParams->dwDialParamsOffset)
            );
    }

LSetCallParams_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetCallParams"
        );
}


void
WINAPI
LSetCallPrivilege(
    PTCLIENT                        ptClient,
    PLINESETCALLPRIVILEGE_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    PTCALL          ptCall;
    PTCALLCLIENT    ptCallClient;


    if (!(ptCallClient = ReferenceObject(
            ghHandleTable,
            pParams->hCall,
            TCALLCLIENT_KEY
            )))
    {
        pParams->lResult = (TapiGlobals.dwNumLineInits ?
            LINEERR_INVALCALLHANDLE : LINEERR_UNINITIALIZED);
        goto LSetCallPrivilege_epilog;
    }


    //
    // Don't both with LineProlog, since we need a try/except
    // to get the ptCall anyway
    //

    try
    {
        ptCall = ptCallClient->ptCall;

        if (ptCallClient->dwKey != TCALLCLIENT_KEY  ||
            ptCallClient->ptClient != ptClient)
        {
            pParams->lResult = (TapiGlobals.dwNumLineInits ?
                LINEERR_INVALCALLHANDLE : LINEERR_UNINITIALIZED);
            goto LSetCallPrivilege_Dereference;
        }
    }
    myexcept
    {
        pParams->lResult = (TapiGlobals.dwNumLineInits ?
            LINEERR_INVALCALLHANDLE : LINEERR_UNINITIALIZED);
        goto LSetCallPrivilege_Dereference;
    }

    if ((pParams->dwPrivilege != LINECALLPRIVILEGE_MONITOR) &&
        (pParams->dwPrivilege != LINECALLPRIVILEGE_OWNER))
    {
        pParams->lResult = LINEERR_INVALCALLPRIVILEGE;
        goto LSetCallPrivilege_Dereference;
    }

    if (WaitForExclusivetCallAccess (ptCall, TCALL_KEY))
    {
        //
        // Make sure the tCallClient is still valid
        //

        try
        {
            if (ptCallClient->dwKey != TCALLCLIENT_KEY)
            {
                pParams->lResult = LINEERR_INVALCALLHANDLE;
                goto LSetCallPrivilege_UnlocktCall;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LSetCallPrivilege_UnlocktCall;
        }

        if (pParams->dwPrivilege != ptCallClient->dwPrivilege)
        {
//            if (ptCallClient->dwPrivilege == LINECALLPRIVILEGE_OWNER &&
//                ptCall->dwNumOwners == 1 &&
//                ptCall->dwCallState != LINECALLSTATE_IDLE)
//            {
//                pParams->lResult = LINEERR_INVALCALLSTATE;
//                goto LSetCallPrivilege_releaseMutex;
//            }

            if (pParams->dwPrivilege == LINECALLPRIVILEGE_OWNER)
            {
                ptCall->dwNumOwners++;
                ptCall->dwNumMonitors--;
            }
            else
            {
                ptCall->dwNumOwners--;
                ptCall->dwNumMonitors++;
            }

            ptCallClient->dwPrivilege = pParams->dwPrivilege;

            UNLOCKTCALL(ptCall);

            SendMsgToCallClients(
                ptCall,
                ptCallClient,
                LINE_CALLINFO,
                LINECALLINFOSTATE_NUMMONITORS |
                    (pParams->dwPrivilege == LINECALLPRIVILEGE_OWNER ?
                        LINECALLINFOSTATE_NUMOWNERINCR :
                        LINECALLINFOSTATE_NUMOWNERDECR),
                0,
                0
                );

        }
        else
        {

LSetCallPrivilege_UnlocktCall:

            UNLOCKTCALL(ptCall);
        }
    }
    else
    {
        pParams->lResult = LINEERR_INVALCALLHANDLE;
    }
LSetCallPrivilege_Dereference:

    DereferenceObject (ghHandleTable, pParams->hCall, 1);

LSetCallPrivilege_epilog:

#if DBG

    {
        char szResult[32];

        LOG((TL_TRACE, 
            "LineEpilogSync: (lineSetCallPrivilege) exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }

#else
        LOG((TL_TRACE, 
            "LineEpilogSync: (lineSetCallPrivilege) exit, result=x%x",
            pParams->lResult
            ));
#endif

    return;
}


void
WINAPI
LSetCallQualityOfService(
    PTCLIENT                            ptClient,
    PLINESETCALLQUALITYOFSERVICE_PARAMS pParams,
    DWORD                               dwParamsBufferSize,
    LPBYTE                              pDataBuf,
    LPDWORD                             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineSetCallQualityOfService;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwSendingFlowspecSize,
            pParams->dwSendingFlowspecOffset,
            sizeof(DWORD),
            "LSetCallQualityOfService",
            "pParams->SendingFlowspec"
            )  ||

        ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwReceivingFlowspecSize,
            pParams->dwReceivingFlowspecOffset,
            sizeof(DWORD),
            "LSetCallQualityOfService",
            "pParams->ReceivingFlowspec"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            pParams->hCall,             // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINESETCALLQUALITYOFSERVICE,         // provider func index
            &pfnTSPI_lineSetCallQualityOfService,   // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "SetCallQualityOfService"   // func name

            )) > 0)
    {
        pParams->lResult = CallSP6(
            pfnTSPI_lineSetCallQualityOfService,
            "lineSetCallQualityOfService",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) (pDataBuf + pParams->dwSendingFlowspecOffset),
            (DWORD) pParams->dwSendingFlowspecSize,
            (ULONG_PTR) (pDataBuf + pParams->dwReceivingFlowspecOffset),
            (DWORD) pParams->dwReceivingFlowspecSize
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetCallQualityOfService"
        );
}


void
WINAPI
LSetCallTreatment(
    PTCLIENT                        ptClient,
    PLINESETCALLTREATMENT_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineSetCallTreatment;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            pParams->hCall,             // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINESETCALLTREATMENT,    // provider func index
            &pfnTSPI_lineSetCallTreatment,  // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "SetCallTreatment"          // func name

            )) > 0)
    {
        if (pParams->dwTreatment == 0  ||
            (pParams->dwTreatment > LINECALLTREATMENT_MUSIC &&
            pParams->dwTreatment < 0x100))
        {
            lRequestID = LINEERR_INVALPARAM;
            goto LSetCallTreatment_epilog;
        }

        pParams->lResult = CallSP3(
            pfnTSPI_lineSetCallTreatment,
            "lineSetCallTreatment",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (DWORD) pParams->dwTreatment
            );
    }

LSetCallTreatment_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetCallTreatment"
        );
}


void
WINAPI
LSetDefaultMediaDetection(
    PTCLIENT                                ptClient,
    PLINESETDEFAULTMEDIADETECTION_PARAMS    pParams,
    DWORD                                   dwParamsBufferSize,
    LPBYTE                                  pDataBuf,
    LPDWORD                                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineSetDefaultMediaDetection;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            pParams->hLine,             // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINESETDEFAULTMEDIADETECTION,        // provider func index
            &pfnTSPI_lineSetDefaultMediaDetection,  // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "SetDefaultMediaDetection"  // func name

            )) == 0)
    {
        DWORD         dwMediaModes = pParams->dwMediaModes;
        PTLINE        ptLine;


        ptLine = ptLineClient->ptLine;

        if ((dwMediaModes & ptLine->dwOpenMediaModes) != dwMediaModes)
        {
            DWORD dwUnionMediaModes = dwMediaModes |
                ptLine->dwOpenMediaModes;


            if ((pParams->lResult = CallSP2(
                    pfnTSPI_lineSetDefaultMediaDetection,
                    "lineSetDefaultMediaDetection",
                    SP_FUNC_SYNC,
                    (ULONG_PTR) hdLine,
                    (DWORD) dwUnionMediaModes

                    )) == 0)
            {
                ptLine->dwOpenMediaModes = dwUnionMediaModes;
            }

        }

        if (pParams->lResult == 0)
        {
            //
            // For remote clients, give the monitor privilege.  It doesn't
            // matter if we do with (except for increased network traffic),
            // because tapisrv on the client will filter out anything
            // the client clients don't want.
            //

            if (IS_REMOTE_CLIENT (ptClient))
            {
                ptLineClient->dwPrivileges = (dwMediaModes ?
                    LINECALLPRIVILEGE_MONITOR | LINECALLPRIVILEGE_OWNER :
                    LINECALLPRIVILEGE_NONE);
            }
            else
            {
                ptLineClient->dwPrivileges = (dwMediaModes ?
                    LINECALLPRIVILEGE_OWNER : LINECALLPRIVILEGE_NONE);
            }

            ptLineClient->dwMediaModes = dwMediaModes;
        }
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "SetDefaultMediaDetection"
        );
}


void
WINAPI
LSetDevConfig(
    PTCLIENT                    ptClient,
    PLINESETDEVCONFIG_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    DWORD               dwDeviceID;
    HANDLE              hMutex;
    TSPIPROC            pfnTSPI_lineSetDevConfig;
    DWORD               objectToDereference;
    PTLINELOOKUPENTRY   pLookupEntry;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwSize,
            pParams->dwDeviceConfigOffset,
            sizeof(DWORD),
            "LSetDevConfig",
            "pParams->DeviceConfig"
            )  ||

        IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDeviceClassOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            DEVICE_ID,                  // widget type
            0,                          // client widget handle
            &dwDeviceID,                // provider widget handle
            pParams->dwDeviceID,        // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINESETDEVCONFIG,        // provider func index
            &pfnTSPI_lineSetDevConfig,  // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &pLookupEntry,              // context
            "SetDevConfig"              // func name

            )) == 0)
    {
        pParams->lResult = CallSP4(
            pfnTSPI_lineSetDevConfig,
            "lineSetDevConfig",
            SP_FUNC_SYNC,
            (DWORD) dwDeviceID,
            (ULONG_PTR) (pParams->dwSize ?
                pDataBuf + pParams->dwDeviceConfigOffset : NULL),
            (DWORD) pParams->dwSize,
            (ULONG_PTR) (pDataBuf + pParams->dwDeviceClassOffset)
            );
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "SetDevConfig"
        );
}


void
WINAPI
LSetLineDevStatus(
    PTCLIENT                        ptClient,
    PLINESETLINEDEVSTATUS_PARAMS    pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineSetLineDevStatus;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            pParams->hLine,             // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINESETLINEDEVSTATUS,    // provider func index
            &pfnTSPI_lineSetLineDevStatus,  // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "SetLineDevStatus"          // func name

            )) > 0)
    {
        #define AllLineDevStatusFlags         \
            (LINEDEVSTATUSFLAGS_CONNECTED   | \
            LINEDEVSTATUSFLAGS_MSGWAIT      | \
            LINEDEVSTATUSFLAGS_INSERVICE    | \
            LINEDEVSTATUSFLAGS_LOCKED)

        if (pParams->dwStatusToChange == 0 ||
            (pParams->dwStatusToChange & ~AllLineDevStatusFlags) != 0)
        {
            lRequestID = LINEERR_INVALLINESTATE;
        }
        else
        {
            pParams->lResult = CallSP4(
                pfnTSPI_lineSetLineDevStatus,
                "lineSetLineDevStatus",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->dwStatusToChange,
                (DWORD) pParams->fStatus
                );
        }

    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetLineDevStatus"
        );
}


void
WINAPI
LSetMediaControl(
    PTCLIENT                    ptClient,
    PLINESETMEDIACONTROL_PARAMS pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL        bCloseMutex;
    DWORD       dwWidgetType, hWidget, dwPrivilege;
    HANDLE      hMutex;
    LPVOID      context;
    TSPIPROC    pfnTSPI_lineSetMediaControl;
    DWORD       objectToDereference;
    ULONG_PTR   hdWidget;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (((pParams->dwDigitListOffset != TAPI_NO_DATA)  &&

            ISBADSIZEOFFSET(
                dwParamsBufferSize,
                0,
                pParams->dwDigitListNumEntries,
                    // actually dwNumEntries * sizeof(LINEMEDIACONTROLDIGIT)
                pParams->dwDigitListOffset,
                sizeof(DWORD),
                "LSetMediaControl",
                "pParams->DigitList"
                ))  ||

        ((pParams->dwMediaListOffset != TAPI_NO_DATA)  &&

            ISBADSIZEOFFSET(
                dwParamsBufferSize,
                0,
                pParams->dwMediaListNumEntries,
                    // actually dwNumEntries * sizeof(LINEMEDIACONTROLMEDIA)
                pParams->dwMediaListOffset,
                sizeof(DWORD),
                "LSetMediaControl",
                "pParams->MediaList"
                ))  ||

        ((pParams->dwToneListOffset != TAPI_NO_DATA)  &&

            ISBADSIZEOFFSET(
                dwParamsBufferSize,
                0,
                pParams->dwToneListNumEntries,
                    // actually dwNumEntries * sizeof(LINEMEDIACONTROLTONE)
                pParams->dwToneListOffset,
                sizeof(DWORD),
                "LSetMediaControl",
                "pParams->ToneList"
                ))  ||

         ((pParams->dwCallStateListOffset != TAPI_NO_DATA)  &&

            ISBADSIZEOFFSET(
                dwParamsBufferSize,
                0,
                pParams->dwCallStateListNumEntries,
                    // actually dwNumEntries *sizeof(LINEMEDIACONTROLCALLSTATE)
                pParams->dwCallStateListOffset,
                sizeof(DWORD),
                "LSetMediaControl",
                "pParams->CallStateList"
                )))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if (pParams->dwSelect == LINECALLSELECT_CALL)
    {
        dwWidgetType = ANY_RT_HCALL;
        hWidget      = (DWORD) pParams->hCall;
        dwPrivilege  = LINECALLPRIVILEGE_OWNER;
    }
    else
    {
        dwWidgetType = ANY_RT_HLINE;
        hWidget      = (DWORD) pParams->hLine;
        dwPrivilege  = 0;
    }

    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            dwWidgetType,               // widget type
            (DWORD) hWidget,            // client widget handle
            (LPVOID) &hdWidget,          // provider widget handle
            dwPrivilege,                // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINESETMEDIACONTROL,     // provider func index
            &pfnTSPI_lineSetMediaControl,   // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &context,                   // context
            "SetMediaControl"           // func name

            )) == 0)
    {
        if (!IsOnlyOneBitSetInDWORD (pParams->dwSelect) ||
            (pParams->dwSelect & ~AllCallSelect))
        {
            pParams->lResult = LINEERR_INVALCALLSELECT;
            goto LSetMediaControl_epilog;
        }

        pParams->lResult = CallSP12(
            pfnTSPI_lineSetMediaControl,
            "lineSetMediaControl",
            SP_FUNC_SYNC,
            (ULONG_PTR) (pParams->dwSelect == LINECALLSELECT_CALL ?
                0 : hdWidget),
            (DWORD) pParams->dwAddressID,
            (ULONG_PTR) (pParams->dwSelect == LINECALLSELECT_CALL ?
                hdWidget : 0),
            (DWORD) pParams->dwSelect,
            (ULONG_PTR) (pParams->dwDigitListOffset == TAPI_NO_DATA ? NULL :
               pDataBuf + pParams->dwDigitListOffset),
            (DWORD) pParams->dwDigitListNumEntries /
                sizeof(LINEMEDIACONTROLDIGIT),
            (ULONG_PTR) (pParams->dwMediaListOffset == TAPI_NO_DATA ? NULL :
                pDataBuf + pParams->dwMediaListOffset),
            (DWORD) pParams->dwMediaListNumEntries /
                sizeof(LINEMEDIACONTROLMEDIA),
            (ULONG_PTR) (pParams->dwToneListOffset == TAPI_NO_DATA ? NULL :
                pDataBuf + pParams->dwToneListOffset),
            (DWORD) pParams->dwToneListNumEntries /
                sizeof(LINEMEDIACONTROLTONE),
            (ULONG_PTR) (pParams->dwCallStateListOffset == TAPI_NO_DATA ? NULL :
                pDataBuf + pParams->dwCallStateListOffset),
            (DWORD) pParams->dwCallStateListNumEntries /
                sizeof(LINEMEDIACONTROLCALLSTATE)
            );
    }

LSetMediaControl_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "SetMediaControl"
        );
}


void
WINAPI
LSetMediaMode(
    PTCLIENT                    ptClient,
    PLINESETMEDIAMODE_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    DWORD               dwAPIVersion, dwSPIVersion, dwAllMediaModes;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineSetMediaMode;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINESETMEDIAMODE,        // provider func index
            &pfnTSPI_lineSetMediaMode,  // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "SetMediaMode"              // func name

            )) == 0)
    {
        try
        {
            dwAPIVersion = ptCallClient->ptLineClient->dwAPIVersion;
            dwSPIVersion = ptCallClient->ptLineClient->ptLine->dwSPIVersion;

            if (ptCallClient->dwKey != TCALLCLIENT_KEY)
            {
                pParams->lResult = LINEERR_INVALCALLHANDLE;
                goto LSetMediaMode_epilog;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            goto LSetMediaMode_epilog;
        }


        //
        // Check for 0 media mode, and if > 1 bit set without UNKNOWN bit
        //

        if ( (dwAPIVersion <= TAPI_VERSION2_1 ) &&
             !IsOnlyOneBitSetInDWORD (pParams->dwMediaModes) &&
             !(pParams->dwMediaModes & LINEMEDIAMODE_UNKNOWN))
        {

            LOG((TL_ERROR,
                "LSetMediaMode: error, >1 media mode selected without " \
                    "UNKNOWN flag (APIVer=x%x)",
                dwAPIVersion
                ));

            pParams->lResult = LINEERR_INVALMEDIAMODE;
            goto LSetMediaMode_epilog;
        }


        //
        // Now the harder checks
        //

        switch (dwAPIVersion)
        {
        case TAPI_VERSION1_0:

            dwAllMediaModes = AllMediaModes1_0;
            break;


        case TAPI_VERSION1_4:
        case TAPI_VERSION2_0:

            dwAllMediaModes = AllMediaModes1_4;
            break;


        //case TAPI_VERSION2_1:
        //case TAPI_VERSION2_2:
        default: //case TAPI_VERSION_CURRENT:

            dwAllMediaModes = AllMediaModes2_1;
            break;
        }

        if ((pParams->dwMediaModes & (dwAllMediaModes ^ 0x00ffffff)) ||
            (pParams->dwMediaModes == 0))
        {
            pParams->lResult = LINEERR_INVALMEDIAMODE;
            goto LSetMediaMode_epilog;
        }

        pParams->lResult = CallSP2(
            pfnTSPI_lineSetMediaMode,
            "lineSetMediaMode",
            SP_FUNC_SYNC,
            (ULONG_PTR) hdCall,
            (DWORD) pParams->dwMediaModes
            );
    }

LSetMediaMode_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "SetMediaMode"
        );
}


void
WINAPI
LSetNumRings(
    PTCLIENT                ptClient,
    PLINESETNUMRINGS_PARAMS pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex;
    HANDLE          hMutex;
    HDRVLINE        hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT    ptLineClient;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_NONE,                    // provider func index
            NULL,                       // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "SetNumRings"               // func name

            )) == 0)
    {
        if (WaitForExclusiveLineClientAccess (ptLineClient))
        {
            DWORD dwNumAddresses = ptLineClient->ptLine->dwNumAddresses;


            if (pParams->dwAddressID >= dwNumAddresses)
            {
                pParams->lResult = LINEERR_INVALADDRESSID;
                goto LSetNumRings_releaseMutex;
            }

            if (ptLineClient->aNumRings == NULL)
            {
                if (!(ptLineClient->aNumRings = ServerAlloc(
                        dwNumAddresses * sizeof (DWORD)
                        )))
                {
                    pParams->lResult = LINEERR_NOMEM;
                    goto LSetNumRings_releaseMutex;
                }

                FillMemory(
                    ptLineClient->aNumRings,
                    dwNumAddresses * sizeof (DWORD),
                    0xff
                    );
            }

            ptLineClient->aNumRings[pParams->dwAddressID] =
                pParams->dwNumRings;

LSetNumRings_releaseMutex:

            UNLOCKTLINECLIENT(ptLineClient);
        }
        else
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
        }
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "SetNumRings"
        );
}

void
WINAPI
LSetQueueMeasurementPeriod(
    PTCLIENT                                ptClient,
    PLINESETQUEUEMEASUREMENTPERIOD_PARAMS   pParams,
    DWORD                                   dwParamsBufferSize,
    LPBYTE                                  pDataBuf,
    LPDWORD                                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            0,                          // provider func index
            NULL,                       // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "SetQueueMeasurementPeriod" // func name

            )) > 0)
    {
        LONG            lResult;
        DWORD           dwDeviceID;
        PTLINECLIENT    pProxy;


        if ((lResult = FindProxy(
                ptLineClient,
                0,
                LINEPROXYREQUEST_SETQUEUEMEASUREMENTPERIOD,
                &pProxy,
                &dwDeviceID,
                TAPI_VERSION2_2
                )))
        {
            lRequestID = lResult;
            goto LSetQueueMeasurementPeriod_epilog;
        }


        // Measurement period must be > 0
        if (pParams->dwMeasurementPeriod == 0)
        {
            lRequestID = LINEERR_INVALPARAM;
            goto LSetQueueMeasurementPeriod_epilog;
        }


        //
        // First check to see if there's a (local) proxy registered
        // for this type of request on this line.  If so, build a
        // request & send it to the proxy.
        //

        if (pProxy)
        {
            LONG                    lResult;
            PPROXYREQUESTWRAPPER    pProxyRequestWrapper;


            if ((lResult = CreateProxyRequest(
                    pProxy,
                    LINEPROXYREQUEST_SETQUEUEMEASUREMENTPERIOD,
                    2 * sizeof (DWORD),
                    pAsyncRequestInfo,
                    &pProxyRequestWrapper
                    )))
            {
                lRequestID = lResult;
                goto LSetQueueMeasurementPeriod_epilog;
            }

            pProxyRequestWrapper->ProxyRequest.
                    SetQueueMeasurementPeriod.dwQueueID = pParams->dwQueueID;

            pProxyRequestWrapper->ProxyRequest.
                    SetQueueMeasurementPeriod.dwMeasurementPeriod =
                    pParams->dwMeasurementPeriod;

            if ((lResult = SendProxyRequest(
                    pProxy,
                    pProxyRequestWrapper,
                    pAsyncRequestInfo
                    )))
            {
                lRequestID = lResult;
                goto LSetQueueMeasurementPeriod_epilog;
            }
            else // success
            {
                pParams->lResult = (LONG) pAsyncRequestInfo->dwLocalRequestID;
            }
        }


        //
        // There's no proxy, so check to see if line is remote and
        // call remotesp if so
        //

        else if ((GetLineLookupEntry (dwDeviceID))->bRemote)
        {
            pParams->lResult = CallSP4(
                pRemoteSP->apfn[SP_LINESETQUEUEMEASUREMENTPERIOD],
                "lineSetQueueMeasurementPeriod",
                SP_FUNC_ASYNC,
                (DWORD) pAsyncRequestInfo->dwLocalRequestID,
                (ULONG_PTR) hdLine,
                (DWORD) pParams->dwQueueID,
                (DWORD) pParams->dwMeasurementPeriod
                );
        }


        //
        // There's no registered proxy & line is not remote, so fail
        //

        else
        {
            lRequestID = LINEERR_OPERATIONUNAVAIL;
        }
    }

LSetQueueMeasurementPeriod_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetQueueManagementPeriod"
        );
}


void
WINAPI
LSetStatusMessages(
    PTCLIENT                        ptClient,
    PLINESETSTATUSMESSAGES_PARAMS   pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL            bCloseMutex, bCloseMutex2;
    HANDLE          hMutex, hMutex2;
    HDRVLINE        hdLine;
    TSPIPROC        pfnTSPI_lineSetStatusMessages;
    DWORD           objectToDereference;
    PTLINECLIENT    ptLineClient, ptLineClient2;


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINESETSTATUSMESSAGES,   // provider func index
            &pfnTSPI_lineSetStatusMessages, // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "SetStatusMessages"         // func name

            )) == 0)
    {
        DWORD   dwAPIVersion, dwUnionLineStates, dwUnionAddressStates;
        PTLINE  ptLine;


        //
        // Safely get the ptLine & api version
        //

        try
        {
            ptLine = ptLineClient->ptLine;

            dwAPIVersion = ptLineClient->dwAPIVersion;

            if (ptLineClient->dwKey != TLINECLIENT_KEY)
            {
                pParams->lResult = LINEERR_INVALLINEHANDLE;
                goto LSetStatusMessages_epilog;
            }
        }
        myexcept
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
            goto LSetStatusMessages_epilog;
        }


        //
        // Validate the params
        //

        {
            DWORD   dwValidLineStates, dwValidAddressStates;


            switch (dwAPIVersion)
            {
            case TAPI_VERSION1_0:

                dwValidLineStates    = AllLineStates1_0;
                dwValidAddressStates = AllAddressStates1_0;
                break;

            default:

                dwValidLineStates    = AllLineStates1_4;
                dwValidAddressStates = AllAddressStates1_4;
                break;
            }

            if (pParams->dwLineStates & ~dwValidLineStates)
            {
                pParams->lResult = LINEERR_INVALLINESTATE;
                goto LSetStatusMessages_epilog;
            }

            if (pParams->dwAddressStates & ~dwValidAddressStates)
            {
                pParams->lResult = LINEERR_INVALADDRESSSTATE;
                goto LSetStatusMessages_epilog;
            }
        }


        //
        // Make sure the REINIT bit is always set
        //

        pParams->dwLineStates |= LINEDEVSTATE_REINIT;


        //
        // Get exclusive access to the device, determine the
        // new union of all the client's status message settings
        // and call down to the SP as appropriate
        //

        dwUnionLineStates    = pParams->dwLineStates;
        dwUnionAddressStates = pParams->dwAddressStates;

waitForExclAccess:

        if (WaitForExclusivetLineAccess(
                ptLine,
                &hMutex2,
                &bCloseMutex2,
                INFINITE
                ))
        {
            if (ptLine->dwBusy)
            {
                MyReleaseMutex (hMutex2, bCloseMutex2);
                Sleep (50);
                goto waitForExclAccess;
            }

            for(
                ptLineClient2 = ptLine->ptLineClients;
                ptLineClient2;
                ptLineClient2 = ptLineClient2->pNextSametLine
                )
            {
                if (ptLineClient2 != ptLineClient)
                {
                    dwUnionLineStates    |= ptLineClient2->dwLineStates;
                    dwUnionAddressStates |= ptLineClient2->dwAddressStates;
                }
            }

            if ((dwUnionLineStates != ptLine->dwUnionLineStates)  ||
                (dwUnionAddressStates != ptLine->dwUnionAddressStates))
            {
                ptLine->dwBusy = 1;

                MyReleaseMutex (hMutex2, bCloseMutex2);

                pParams->lResult = CallSP3(
                        pfnTSPI_lineSetStatusMessages,
                        "lineSetStatusMessages",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) hdLine,
                        (DWORD) dwUnionLineStates,
                        (DWORD) dwUnionAddressStates
                        );

                if (WaitForExclusivetLineAccess(
                        ptLine,
                        &hMutex2,
                        &bCloseMutex2,
                        INFINITE
                        ))
                {
                    ptLine->dwBusy = 0;

                    if (pParams->lResult == 0)
                    {
                        ptLine->dwUnionLineStates    = dwUnionLineStates;
                        ptLine->dwUnionAddressStates = dwUnionAddressStates;
                    }

                    MyReleaseMutex (hMutex2, bCloseMutex2);
                }
                else
                {
                    pParams->lResult = LINEERR_INVALLINEHANDLE;
                }
            }
            else
            {
                MyReleaseMutex (hMutex2, bCloseMutex2);
            }

            if (pParams->lResult == 0)
            {
                if (WaitForExclusiveLineClientAccess (ptLineClient))
                {
                    ptLineClient->dwLineStates    = pParams->dwLineStates;
                    ptLineClient->dwAddressStates = pParams->dwAddressStates;

                    UNLOCKTLINECLIENT (ptLineClient);
                }
                else
                {
                    //
                    // The client is invalid now, but don't bother
                    // restoring the status msg states (will eventually
                    // get reset correctly & worse case is that SP just
                    // sends some extra msgs that get discarded)
                    //

                    pParams->lResult = LINEERR_INVALLINEHANDLE;
                }
            }
        }
        else
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
        }
    }

LSetStatusMessages_epilog:

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "SetStatusMessages"
        );
}


void
WINAPI
LSetTerminal(
    PTCLIENT                ptClient,
    PLINESETTERMINAL_PARAMS pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    DWORD               dwWidgetType, hWidget, dwPrivilege,
                        dwSelect = pParams->dwSelect;
    HANDLE              hMutex;
    LPVOID              context;
    TSPIPROC            pfnTSPI_lineSetTerminal;
    DWORD               objectToDereference;
    ULONG_PTR           hdWidget;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if (dwSelect == LINECALLSELECT_CALL)
    {
        dwWidgetType = ANY_RT_HCALL;
        hWidget      = (DWORD) pParams->hCall;
        dwPrivilege  = LINECALLPRIVILEGE_MONITOR;
    }
    else
    {
        dwWidgetType = ANY_RT_HLINE;
        hWidget      = (DWORD) pParams->hLine;
        dwPrivilege  = 0;
    }

    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            dwWidgetType,               // widget type
            hWidget,                    // client widget handle
            &hdWidget,                  // provider widget handle
            dwPrivilege,                // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINESETTERMINAL,         // provider func index
            &pfnTSPI_lineSetTerminal,   // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &context,                   // context
            "SetTerminal"               // func name

            )) > 0)
    {
        DWORD   dwTerminalModes = pParams->dwTerminalModes;


        if (!IsOnlyOneBitSetInDWORD (dwSelect) ||
            (dwSelect & ~AllCallSelects))
        {
            lRequestID = LINEERR_INVALCALLSELECT;
            goto LSetTerminal_epilog;
        }

        if (dwTerminalModes == 0 ||
            (dwTerminalModes & (~AllTerminalModes)))
        {
            lRequestID = LINEERR_INVALTERMINALMODE;
            goto LSetTerminal_epilog;
        }

        pParams->lResult = CallSP8(
            pfnTSPI_lineSetTerminal,
            "lineSetTerminal",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) (dwWidgetType == ANY_RT_HLINE ? hdWidget : 0),
            (DWORD) pParams->dwAddressID,
            (ULONG_PTR) (dwWidgetType == ANY_RT_HCALL ? hdWidget : 0),
            (DWORD) dwSelect,
            (DWORD) dwTerminalModes,
            (DWORD) pParams->dwTerminalID,
            (DWORD) pParams->bEnable
            );
    }

LSetTerminal_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetTerminal"
        );
}


void
LSetupConference_PostProcess(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    PASYNCEVENTMSG      pAsyncEventMsg,
    LPVOID             *ppBuf
    )
{
    PTCALL          ptConfCall    = (PTCALL) pAsyncRequestInfo->dwParam1,
                    ptConsultCall = (PTCALL) pAsyncRequestInfo->dwParam3,
                    ptCall        = (PTCALL) pAsyncRequestInfo->dwParam5;
    HCALL           hpConfCall    = DWORD_CAST(pAsyncRequestInfo->dwParam2,__FILE__,__LINE__);
    HCALL           hpConsultCall = DWORD_CAST(pAsyncRequestInfo->dwParam4,__FILE__,__LINE__);

    PTCALLCLIENT    ptConfCallClient, ptConsultCallClient;


//         LSetupConference_PostProcess: mutex on confCall too?
//
//         Actually, this may be ok as is- the consult call is
//         positioned before the conf call in the tline's list,
//         so if we can safely access the former we ought to be
//         able to safely access the latter too

    if (WaitForExclusivetCallAccess (ptConsultCall, TINCOMPLETECALL_KEY))
    {
        HCALL   hConsultCallThen = (HCALL)*(&pAsyncRequestInfo->dwParam5 + 2);
        PTCALL  ptConsultCallThen;

        //
        // Check to make sure this is the call we think it is (that the
        // pointer wasn't freed by a previous call to lineClose/Shutdown
        // and realloc'd for use as a ptCall again)
        //

        if (ptConsultCall->hCall != hConsultCallThen)
        {
            UNLOCKTCALL(ptConsultCall);
            goto LSetupConference_PostProcess_bad_ptConsultCall;
        }

        ptConfCallClient    = ptConfCall->ptCallClients;
        ptConsultCallClient = ptConsultCall->ptCallClients;

        if (pAsyncEventMsg->Param2 == 0)  // success
        {
            PTCONFERENCELIST    pConfList = ptConfCall->pConfList;


            //
            // Check to see if the app closed the line & left us with
            // 0 call clients (in which case it'll also be taking care of
            // cleaning up this tCall too)
            //

            if (ptConsultCall->ptCallClients == NULL)
            {
                UNLOCKTCALL(ptConsultCall);

                ptConfCallClient = (PTCALLCLIENT) NULL;
                ptConsultCallClient = (PTCALLCLIENT) NULL;

                if (pAsyncEventMsg->Param2 == 0)
                {
                    pAsyncEventMsg->Param2 = LINEERR_INVALLINEHANDLE;
                }

                goto LSetupConference_PostProcess_initMsgParams;
            }


            //
            // Retrieve the various call IDs, then check if call
            // client was destroyed by another thread (due to
            // lineClose/Shutdown) while we were getting the call ID.
            // If so, we'll need to clean up the tCall, since we know
            // the other thread didn't do it because GetCallIDs marks
            // the call as a zombie.
            //
            // Note that we can't use GetCallIDs() because we need
            // to get id's for two calls at once
            //

            {
                PTPROVIDER  ptProvider = ptConfCall->ptProvider;


                ptConfCall->dwKey =
                ptConsultCall->dwKey = TZOMBIECALL_KEY;

                UNLOCKTCALL (ptConsultCall);

                if (ptProvider->apfn[SP_LINEGETCALLIDS])
                {
                    CallSP4(
                        ptProvider->apfn[SP_LINEGETCALLIDS],
                        "lineGetCalIDs",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) ptConfCall->hdCall,
                        (ULONG_PTR) &ptConfCall->dwAddressID,
                        (ULONG_PTR) &ptConfCall->dwCallID,
                        (ULONG_PTR) &ptConfCall->dwRelatedCallID
                        );

                    CallSP4(
                        ptProvider->apfn[SP_LINEGETCALLIDS],
                        "lineGetCalIDs",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) ptConsultCall->hdCall,
                        (ULONG_PTR) &ptConsultCall->dwAddressID,
                        (ULONG_PTR) &ptConsultCall->dwCallID,
                        (ULONG_PTR) &ptConsultCall->dwRelatedCallID
                        );
                }
                else
                {
                    DWORD           dwSPIVersion, dwFixedSizeSP;
                    LINECALLINFO    callInfo;


                    //
                    // Determine the fixed size of the structure expected
                    // by the SP
                    //

                    dwSPIVersion = ((PTLINE) ptConfCall->ptLine)->dwSPIVersion;

                    switch (dwSPIVersion)
                    {
                    case TAPI_VERSION1_0:
                    case TAPI_VERSION1_4:

                        dwFixedSizeSP = 296;    // 69 * sizeof(DWORD)
                                                //    + sizeof (HLINE)
                                                //    + sizeof (LINEDIALPARAMS)
                        break;

                    case TAPI_VERSION2_0:
                    case TAPI_VERSION2_1:
                    case TAPI_VERSION2_2:

                        dwFixedSizeSP = 324;    // 76 * sizeof(DWORD)
                                                //    + sizeof (HLINE)
                                                //    + sizeof (LINEDIALPARAMS)
                        break;

                    default: // (fix ppc build wrn) case TAPI_VERSION_CURRENT:

                        dwFixedSizeSP = sizeof (LINECALLINFO);
                        break;
                    }

                    InitTapiStruct(
                        &callInfo,
                        dwFixedSizeSP,
                        dwFixedSizeSP,
                        TRUE
                        );

                    if (ptProvider->apfn[SP_LINEGETCALLINFO] == NULL)
                    {
                        LOCKTCALL (ptConsultCall);
                        goto LSetupConference_PostProcess_cleanupCalls;
                    }

                    CallSP2(
                        ptProvider->apfn[SP_LINEGETCALLINFO],
                        "lineGetCallInfo",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) ptConfCall->hdCall,
                        (ULONG_PTR) &callInfo
                        );

                    ptConfCall->dwAddressID     = callInfo.dwAddressID;
                    ptConfCall->dwCallID        = callInfo.dwCallID;
                    ptConfCall->dwRelatedCallID = callInfo.dwRelatedCallID;

                    InitTapiStruct(
                        &callInfo,
                        dwFixedSizeSP,
                        dwFixedSizeSP,
                        TRUE
                        );

                    CallSP2(
                        ptProvider->apfn[SP_LINEGETCALLINFO],
                        "lineGetCallInfo",
                        SP_FUNC_SYNC,
                        (ULONG_PTR) ptConsultCall->hdCall,
                        (ULONG_PTR) &callInfo
                        );

                    ptConsultCall->dwAddressID     = callInfo.dwAddressID;
                    ptConsultCall->dwCallID        = callInfo.dwCallID;
                    ptConsultCall->dwRelatedCallID = callInfo.dwRelatedCallID;
                }

                LOCKTCALL (ptConsultCall);
            }

            if (!ptConsultCall->ptCallClients)
            {
                goto LSetupConference_PostProcess_cleanupCalls;
            }


            //
            // Indicate the various call IDs in the adwParams[] field of
            // the ASYNCEVENTMSG.
            //
            // Make sure to increment the dwTotalSize of the ASYNCEVENTMSG
            // as appropriate.  We rely on the fact that CompletionProc()
            // calls us with an AsyncEventMsg buffer that is big enough to
            // handle a few extra DWORDs.
            //

            pAsyncEventMsg->Param3 = ptConfCallClient->hCall;

            *(&pAsyncEventMsg->Param4 + 1) = ptConsultCallClient->hCall;

            pAsyncEventMsg->TotalSize +=
                6 * sizeof (pAsyncEventMsg->Param1);

            *(&pAsyncEventMsg->Param4 + 3) = ptConfCall->dwAddressID;
            *(&pAsyncEventMsg->Param4 + 4) = ptConfCall->dwCallID;
            *(&pAsyncEventMsg->Param4 + 5) = ptConfCall->dwRelatedCallID;
            *(&pAsyncEventMsg->Param4 + 6) = ptConsultCall->dwAddressID;
            *(&pAsyncEventMsg->Param4 + 7) = ptConsultCall->dwCallID;
            *(&pAsyncEventMsg->Param4 + 8) = ptConsultCall->dwRelatedCallID;


            //
            // Mark the calls as valid, the release the mutex
            //

            ptConfCall->dwKey =
            ptConsultCall->dwKey = TCALL_KEY;
            ptConfCallClient->dwKey =
            ptConsultCallClient->dwKey = TCALLCLIENT_KEY;
            pConfList->dwKey = TCONFLIST_KEY;

            UNLOCKTCALL(ptConsultCall);


            //
            // Create monitor tCallClients
            //

            if (ptConsultCallThen = ReferenceObject(ghHandleTable, hConsultCallThen, TCALL_KEY))
            {
                if (ptConsultCallThen == ptConsultCall)
                {
                    CreateCallMonitors (ptConfCall, FALSE);
                    CreateCallMonitors (ptConsultCall, FALSE);
                }

                DereferenceObject(ghHandleTable, hConsultCallThen, 1);
            }
        }
        else    // error
        {

LSetupConference_PostProcess_cleanupCalls:

            //
            // Invalidate the tCalls, & if there's still tCallClients
            // (might have already been destroyed by a lineClose/Shutdown
            // in another thread) invalidate them too. Then unlock the
            // tCalls & remove the object(s) from the list(s).
            //

            ptConfCall->dwKey = ptConsultCall->dwKey = INVAL_KEY;

            if (ptConfCall->ptCallClients)
            {
                ptConfCallClient->dwKey = INVAL_KEY;
                ptConfCall->lActiveFastCallClients--;
            }
            else
            {
                ptConfCallClient = NULL;
            }

            if (ptConsultCall->ptCallClients)
            {
                ptConsultCallClient->dwKey = INVAL_KEY;
                ptConsultCall->lActiveFastCallClients--;
            }
            else
            {
                ptConsultCallClient = NULL;
            }

            UNLOCKTCALL(ptConsultCall);

            RemoveCallFromLineList (ptConfCall);
            RemoveCallFromLineList (ptConsultCall);

            if (ptConfCallClient)
            {
                DereferenceObject (ghHandleTable, ptConfCallClient->hCall, 1);
                RemoveCallClientFromLineClientList (ptConfCallClient);
            }

            if (ptConsultCallClient)
            {
                DereferenceObject (ghHandleTable,ptConsultCallClient->hCall,1);
                RemoveCallClientFromLineClientList (ptConsultCallClient);
            }


            //
            // Make sure all fast call clients cleaned up before free tCalls
            //

            while ((ptConfCall->lActiveFastCallClients != 0)  ||
                   (ptConsultCall->lActiveFastCallClients != 0))
            {
                Sleep (5);
            }

            FreetCall  (ptConsultCall);

            if (ptCall)
            {
                SetCallConfList (ptCall, NULL, FALSE);
            }

            ServerFree  (ptConfCall->pConfList);
            FreetCall  (ptConfCall);
        }
    }
    else
    {
        //
        // If here we can assume that the call was already destroyed
        // and just fail the request
        //

LSetupConference_PostProcess_bad_ptConsultCall:

        if (pAsyncEventMsg->Param2 == 0)
        {
            pAsyncEventMsg->Param2 = LINEERR_OPERATIONFAILED;
        }
    }


LSetupConference_PostProcess_initMsgParams:

    //
    // Fill in the params to pass to client (important to remotesp in both
    // the success & fail cases so it can either init or clean up drvCall)
    //
    // Make sure to increment the dwTotalSize of the ASYNCEVENTMSG
    // as appropriate.  We rely on the fact that CompletionProc()
    // calls us with an AsyncEventMsg buffer that is big enough to
    // handle a few extra DWORDs.
    //

    pAsyncEventMsg->Param4 = hpConfCall;

    pAsyncEventMsg->TotalSize += 2 * sizeof (pAsyncEventMsg->Param1);

    *(&pAsyncEventMsg->Param4 + 2) = hpConsultCall;
}


void
WINAPI
LSetupConference(
    PTCLIENT                    ptClient,
    PLINESETUPCONFERENCE_PARAMS pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    DWORD               dwPrivilege = LINECALLPRIVILEGE_OWNER;
    HCALL               hCall = pParams->hCall;
    HLINE               hLine = pParams->hLine;
    HANDLE              hMutex;
    LPVOID              context;
    TSPIPROC            pfnTSPI_lineSetupConference;
    DWORD               objectToDereference;
    ULONG_PTR           hdXxx;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,                      // tClient
            (hCall ? ANY_RT_HCALL : ANY_RT_HLINE),  // widget type
            (hCall ? (DWORD) hCall : (DWORD) hLine),// client widget handle
            (LPVOID) &hdXxx,                        // provider widget handle
            (hCall ? dwPrivilege : 0),              // privileges or device ID
            &hMutex,                                // mutex handle
            &bCloseMutex,                           // close hMutex when done
            SP_LINESETUPCONFERENCE,                 // provider func index
            &pfnTSPI_lineSetupConference,           // provider func pointer
            &pAsyncRequestInfo,                     // async request info
            pParams->dwRemoteRequestID,             // client async request ID
            &objectToDereference,                   // object to dereference
            &context,                               // context
            "SetupConference"                       // func name

            )) > 0)
    {
        LONG                lResult;
        DWORD               dwNumParties;
        PTCALL              ptCall, ptConfCall, ptConsultCall;
        HCALL               hConfCall, hConsultCall;
        PTCALLCLIENT        ptConfCallClient, ptConsultCallClient;
        PTLINECLIENT        ptLineClient;
        LPLINECALLPARAMS    pCallParamsApp, pCallParamsSP;
        PTCONFERENCELIST    pConfList;


        //
        // Verify size/offset/string params given our input buffer/size
        //

        if ((pParams->dwCallParamsOffset != TAPI_NO_DATA)  &&

            IsBadStructParam(
                dwParamsBufferSize,
                pDataBuf,
                pParams->dwCallParamsOffset
                ))
        {
            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LSetupConference_return;
        }


        //
        // We need two more async request info params than are available,
        // so we'll realloc a larger buf & work with it
        //

        {
            PASYNCREQUESTINFO   pAsyncRequestInfo2;


            if (!(pAsyncRequestInfo2 = ServerAlloc(
                    sizeof (ASYNCREQUESTINFO) + 2 * sizeof (ULONG_PTR)
                    )))
            {
                lRequestID = LINEERR_NOMEM;
                goto LSetupConference_return;
            }

            CopyMemory(
                pAsyncRequestInfo2,
                pAsyncRequestInfo,
                sizeof (ASYNCREQUESTINFO)
                );

            pAsyncRequestInfo2->dwLocalRequestID = (DWORD)NewObject(
                ghHandleTable,
                pAsyncRequestInfo2,
                NULL
                );

            // The following lines are to be removed for BUG 258501(xzhang).
            // When called from RemoteSP, dwRemoteRequestID is used by the RemoteSP
            // to identify the async request, if set to dwLocalRequestID, RemoteSP
            // will get an invalid request ID and discard the call event notification.
            
/*            if (lRequestID != (LONG) pAsyncRequestInfo->dwLocalRequestID)
            {
                lRequestID = (LONG)
                (pAsyncRequestInfo2->dwRemoteRequestID =
                    pAsyncRequestInfo2->dwLocalRequestID);
            }
*/

            DereferenceObject(
                ghHandleTable,
                pAsyncRequestInfo->dwLocalRequestID,
                1
                );

            pAsyncRequestInfo = pAsyncRequestInfo2;

        }

        pCallParamsApp = (LPLINECALLPARAMS)
            (pParams->dwCallParamsOffset == TAPI_NO_DATA ?
                0 : (pDataBuf + pParams->dwCallParamsOffset));


        //
        // Reference the tLineClient if not already
        //

        if (hCall)
        {
            try
            {
                hLine = ((PTCALLCLIENT) context)->ptLineClient->hLine;
            }
            myexcept
            {
                lRequestID = LINEERR_OPERATIONFAILED;
                goto LSetupConference_return;
            }

            if (!(ptLineClient = ReferenceObject(
                    ghHandleTable,
                    hLine,
                    TLINECLIENT_KEY
                    )))
            {
                lRequestID = LINEERR_INVALCALLHANDLE;
                goto LSetupConference_return;
            }
        }
        else
        {
            ptLineClient = (PTLINECLIENT) context;
        }

        if (pCallParamsApp)
        {
            DWORD         dwAPIVersion, dwSPIVersion;


            try
            {
                dwAPIVersion = ptLineClient->dwAPIVersion;
                dwSPIVersion = ptLineClient->ptLine->dwSPIVersion;
            }
            myexcept
            {
                lRequestID = LINEERR_OPERATIONFAILED;
                goto LSetupConference_Dereference;
            }


            if ((lResult = ValidateCallParams(
                    pCallParamsApp,
                    &pCallParamsSP,
                    dwAPIVersion,
                    dwSPIVersion,
                    pParams->dwAsciiCallParamsCodePage

                    )) != 0)
            {
                lRequestID = lResult;
                goto LSetupConference_Dereference;
            }
        }
        else
        {
            pCallParamsSP = (LPLINECALLPARAMS) NULL;
        }

        dwNumParties = (pParams->dwNumParties > DEF_NUM_CONF_LIST_ENTRIES ?
            pParams->dwNumParties : DEF_NUM_CONF_LIST_ENTRIES);

        if (!(pConfList = (PTCONFERENCELIST) ServerAlloc(
                sizeof (TCONFERENCELIST) + dwNumParties * sizeof(PTCALL)
                )))
        {
            lRequestID = LINEERR_NOMEM;
            goto LSetupConference_freeCallParams;
        }

        pConfList->dwNumTotalEntries = dwNumParties + 1;
        pConfList->dwNumUsedEntries  = 1;

        if (hCall)
        {
            try
            {
                ptCall = ((PTCALLCLIENT) context)->ptCall;
            }
            myexcept
            {
                lResult = LINEERR_INVALCALLHANDLE;
                goto LSetupConference_freeConfList;
            }

            if ((lResult = SetCallConfList (ptCall, pConfList, FALSE)) != 0)
            {
                goto LSetupConference_freeConfList;
            }
        }
        else
        {
            ptCall = NULL;
        }

        if ((lResult = CreatetCallAndClient(
                ptLineClient,
                &ptConfCall,
                &ptConfCallClient,
                pCallParamsSP,
                &hConfCall,
                NULL

                )) == 0)
        {
            pConfList->aptCalls[0] = ptConfCall;

            if ((lResult = CreatetCallAndClient(
                    ptLineClient,
                    &ptConsultCall,
                    &ptConsultCallClient,
                    NULL,
                    &hConsultCall,
                    ptConfCall

                    ) == 0))
            {
                ptConfCall->pConfList = pConfList;

                pAsyncRequestInfo->pfnPostProcess =
                    LSetupConference_PostProcess;
                pAsyncRequestInfo->htXxx    = (ULONG_PTR)ptConfCallClient->ptLineClient->ptLine->hLine;
                pAsyncRequestInfo->dwParam1 = (ULONG_PTR) ptConfCall;
                pAsyncRequestInfo->dwParam2 = pParams->hpConfCall;
                
                pAsyncRequestInfo->dwParam3 = (ULONG_PTR) ptConsultCall;
                pAsyncRequestInfo->dwParam4 = pParams->hpConsultCall;
                pAsyncRequestInfo->dwParam5 = (ULONG_PTR) ptCall;

                *(&pAsyncRequestInfo->dwParam5 + 1) = (ULONG_PTR)hConfCall;
                *(&pAsyncRequestInfo->dwParam5 + 2) = (ULONG_PTR)hConsultCall;

                pAsyncRequestInfo->hfnClientPostProcessProc =
                    pParams->hfnPostProcessProc;

                goto LSetupConference_callSP;
            }

            SetDrvCallFlags (hConfCall, DCF_SPIRETURNED);
            DestroytCall (ptConfCall);
        }

LSetupConference_freeConfList:

        ServerFree (pConfList);
        lRequestID = lResult;
        goto LSetupConference_freeCallParams;

LSetupConference_callSP:

        pParams->lResult = CallSP9(
            pfnTSPI_lineSetupConference,
            "lineSetupConference",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) (hCall ? hdXxx : 0),    // hdCall
            (ULONG_PTR) (hCall ? 0 : hdXxx),    // hdLine
            (ULONG_PTR) hConfCall,
            (ULONG_PTR) &ptConfCall->hdCall,
            (ULONG_PTR) hConsultCall,
            (ULONG_PTR) &ptConsultCall->hdCall,
            (DWORD) pParams->dwNumParties,
            (ULONG_PTR) pCallParamsSP
            );

        SetDrvCallFlags(
            hConfCall,
            DCF_SPIRETURNED | (IS_LRESULT_NOTERROR(pParams->lResult) ?
                DCF_DRVCALLVALID : 0)
            );

        SetDrvCallFlags(
            hConsultCall,
            DCF_SPIRETURNED | (IS_LRESULT_NOTERROR(pParams->lResult) ?
                DCF_DRVCALLVALID : 0)
            );

LSetupConference_freeCallParams:

        if (pCallParamsSP != pCallParamsApp)
        {
            ServerFree (pCallParamsSP);
        }

LSetupConference_Dereference:

        if (hCall)
        {
            DereferenceObject (ghHandleTable, hLine, 1);
        }
    }

LSetupConference_return:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetupConference"
        );
}


void
WINAPI
LSetupTransfer(
    PTCLIENT                    ptClient,
    PLINESETUPTRANSFER_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineSetupTransfer;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINESETUPTRANSFER,       // provider func index
            &pfnTSPI_lineSetupTransfer, // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "SetupTransfer"             // func name

            )) > 0)
    {
        LONG                lResult;
        HLINE               hLine;
        PTCALL              ptConsultCall;
        HCALL               hConsultCall;
        PTCALLCLIENT        ptConsultCallClient;
        PTLINECLIENT        ptLineClient;
        LPLINECALLPARAMS    pCallParamsApp, pCallParamsSP;


        //
        // Verify size/offset/string params given our input buffer/size
        //

        if ((pParams->dwCallParamsOffset != TAPI_NO_DATA)  &&

            IsBadStructParam(
                dwParamsBufferSize,
                pDataBuf,
                pParams->dwCallParamsOffset
                ))
        {
            lRequestID = LINEERR_STRUCTURETOOSMALL;
            goto LSetupTransfer_return;
        }


        //
        // Reference the tLineClient
        //

        try
        {
            hLine = ptCallClient->ptLineClient->hLine;
        }
        myexcept
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LSetupTransfer_return;
        }

        if (!(ptLineClient = ReferenceObject(
                ghHandleTable,
                hLine,
                TLINECLIENT_KEY
                )))
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LSetupTransfer_return;
        }

        pCallParamsApp = (LPLINECALLPARAMS)
            (pParams->dwCallParamsOffset == TAPI_NO_DATA ?
                0 : (pDataBuf + pParams->dwCallParamsOffset));

        if (pCallParamsApp)
        {
            DWORD         dwAPIVersion, dwSPIVersion;


            dwAPIVersion = ptLineClient->dwAPIVersion;

            try
            {
                dwSPIVersion = ptLineClient->ptLine->dwSPIVersion;
            }
            myexcept
            {
                lRequestID = LINEERR_OPERATIONFAILED;
                goto LSetupTransfer_Dereference;
            }

            if ((lResult = ValidateCallParams(
                    pCallParamsApp,
                    &pCallParamsSP,
                    dwAPIVersion,
                    dwSPIVersion,
                    pParams->dwAsciiCallParamsCodePage

                    )) != 0)
            {
                lRequestID = lResult;
                goto LSetupTransfer_Dereference;
            }
        }
        else
        {
            pCallParamsSP = (LPLINECALLPARAMS) NULL;
        }

        if (CreatetCallAndClient(
                ptLineClient,
                &ptConsultCall,
                &ptConsultCallClient,
                NULL,
                &hConsultCall,
                NULL

                ) != 0)
        {
            lRequestID = LINEERR_NOMEM;
            goto LSetupTransfer_freeCallParams;
        }

        pAsyncRequestInfo->pfnPostProcess = LMakeCall_PostProcess;
        pAsyncRequestInfo->htXxx    = (ULONG_PTR)ptConsultCallClient->ptLineClient->ptLine->hLine;
        pAsyncRequestInfo->dwParam1 = (ULONG_PTR) ptConsultCall;
        pAsyncRequestInfo->dwParam2 = pParams->hpConsultCall;
        pAsyncRequestInfo->dwParam5 = (ULONG_PTR)hConsultCall;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP5(
            pfnTSPI_lineSetupTransfer,
            "lineSetupTransfer",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall,
            (ULONG_PTR) hConsultCall,
            (ULONG_PTR) &ptConsultCall->hdCall,
            (ULONG_PTR) pCallParamsSP
            );

        SetDrvCallFlags(
            hConsultCall,
            DCF_SPIRETURNED | (IS_LRESULT_NOTERROR(pParams->lResult) ?
                DCF_DRVCALLVALID : 0)
            );

LSetupTransfer_freeCallParams:

        if (pCallParamsSP != pCallParamsApp)
        {
            ServerFree (pCallParamsSP);
        }

LSetupTransfer_Dereference:

        DereferenceObject (ghHandleTable, hLine, 1);
    }

LSetupTransfer_return:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SetupTransfer"
        );
}


void
WINAPI
LShutdown(
    PTCLIENT                ptClient,
    PLINESHUTDOWN_PARAMS    pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    pParams->lResult = DestroytLineApp ((HLINEAPP) pParams->hLineApp);

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "lineShutdown: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "lineShutdown: exit, result=x%x",
            pParams->lResult
            ));
#endif
}


void
WINAPI
LSwapHold(
    PTCLIENT                ptClient,
    PLINESWAPHOLD_PARAMS    pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdActiveCall;
    TSPIPROC            pfnTSPI_lineSwapHold;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptActiveCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            pParams->hActiveCall,       // client widget handle
            (LPVOID) &hdActiveCall,     // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINESWAPHOLD,            // provider func index
            &pfnTSPI_lineSwapHold,      // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptActiveCallClient,        // context
            "SwapHold"                  // func name

            )) > 0)
    {
        HDRVCALL        hdHeldCall;
        PTCALLCLIENT    ptHeldCallClient;


        //
        // Verify held call
        //

        if (!(ptHeldCallClient = ReferenceObject(
                ghHandleTable,
                pParams->hHeldCall,
                TCALLCLIENT_KEY
                )))
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LSwapHold_epilog;
        }

        if (ptHeldCallClient->ptClient != ptClient)
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LSwapHold_Dereference;
        }


        //
        // Safely verify that client has owner privilege to held call,
        // and that calls are on same tLine
        //

        try
        {
            if (!(ptHeldCallClient->dwPrivilege & LINECALLPRIVILEGE_OWNER))
            {
                lRequestID = LINEERR_NOTOWNER;
                goto LSwapHold_Dereference;
            }

            if (ptHeldCallClient->ptCall->ptLine !=
                    ptActiveCallClient->ptCall->ptLine)
            {
                lRequestID = LINEERR_INVALCALLHANDLE;
                goto LSwapHold_Dereference;
            }

            hdHeldCall = ptHeldCallClient->ptCall->hdCall;
        }
        myexcept
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LSwapHold_Dereference;
        }


        //
        // Are they the same call?
        //

        if (hdActiveCall == hdHeldCall)
        {
            lRequestID = LINEERR_INVALCALLHANDLE;
            goto LSwapHold_Dereference;
        }

        pParams->lResult = CallSP3(
            pfnTSPI_lineSwapHold,
            "lineSwapHold",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdActiveCall,
            (ULONG_PTR) hdHeldCall
            );

LSwapHold_Dereference:

        DereferenceObject (ghHandleTable, pParams->hHeldCall, 1);

    }

LSwapHold_epilog:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "SwapHold"
        );
}



void
WINAPI
LUncompleteCall(
    PTCLIENT                    ptClient,
    PLINEUNCOMPLETECALL_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineUncompleteCall;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEUNCOMPLETECALL,      // provider func index
            &pfnTSPI_lineUncompleteCall,// provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "UncompleteCall"            // func name

            )) > 0)
    {
        pParams->lResult = CallSP3(
            pfnTSPI_lineUncompleteCall,
            "lineUncompleteCall",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdLine,
            (DWORD) pParams->dwCompletionID
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "UncompleteCall"
        );
}


void
WINAPI
LUnhold(
    PTCLIENT            ptClient,
    PLINEUNHOLD_PARAMS  pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVCALL            hdCall;
    TSPIPROC            pfnTSPI_lineUnhold;
    DWORD               objectToDereference;
    PTCALLCLIENT        ptCallClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HCALL,               // widget type
            (DWORD) pParams->hCall,     // client widget handle
            (LPVOID) &hdCall,           // provider widget handle
            LINECALLPRIVILEGE_OWNER,    // req'd privileges (call only)
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEUNHOLD,              // provider func index
            &pfnTSPI_lineUnhold,        // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptCallClient,              // context
            "Unhold"                    // func name

            )) > 0)
    {
        pParams->lResult = CallSP2(
            pfnTSPI_lineUnhold,
            "lineUnhold",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdCall
            );
    }

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Unhold"
        );
}


void
WINAPI
LUnpark(
    PTCLIENT            ptClient,
    PLINEUNPARK_PARAMS  pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    LONG                lRequestID;
    HANDLE              hMutex;
    HDRVLINE            hdLine;
    TSPIPROC            pfnTSPI_lineUnpark;
    DWORD               objectToDereference;
    PTLINECLIENT        ptLineClient;
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (IsBadStringParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDestAddressOffset
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((lRequestID = LINEPROLOG(
            ptClient,          // tClient
            ANY_RT_HLINE,               // widget type
            (DWORD) pParams->hLine,     // client widget handle
            (LPVOID) &hdLine,           // provider widget handle
            0,                          // privileges or device ID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEUNPARK,              // provider func index
            &pfnTSPI_lineUnpark,        // provider func pointer
            &pAsyncRequestInfo,         // async request info
            pParams->dwRemoteRequestID, // client async request ID
            &objectToDereference,       // object to dereference
            &ptLineClient,              // context
            "Unpark"                    // func name

            )) > 0)
    {
        PTCALL          ptCall;
        HCALL           hCall;
        PTCALLCLIENT    ptCallClient;


        if (CreatetCallAndClient(
                ptLineClient,
                &ptCall,
                &ptCallClient,
                NULL,
                &hCall,
                NULL

                ) != 0)
        {
            lRequestID = LINEERR_NOMEM;
            goto LUnpark_return;
        }

        pAsyncRequestInfo->pfnPostProcess = LMakeCall_PostProcess;
        pAsyncRequestInfo->htXxx    = (ULONG_PTR)ptCallClient->ptLineClient->ptLine->hLine;
        pAsyncRequestInfo->dwParam1 = (ULONG_PTR) ptCall;
        pAsyncRequestInfo->dwParam2 = pParams->hpCall;
        pAsyncRequestInfo->dwParam5 = (ULONG_PTR)hCall;

        pAsyncRequestInfo->hfnClientPostProcessProc =
            pParams->hfnPostProcessProc;

        pParams->lResult = CallSP6(
            pfnTSPI_lineUnpark,
            "lineUnpark",
            SP_FUNC_ASYNC,
            (DWORD) pAsyncRequestInfo->dwLocalRequestID,
            (ULONG_PTR) hdLine,
            (DWORD) pParams->dwAddressID,
            (ULONG_PTR) hCall,
            (ULONG_PTR) &ptCall->hdCall,
            (ULONG_PTR) (pDataBuf + pParams->dwDestAddressOffset)
            );

        SetDrvCallFlags(
            hCall,
            DCF_SPIRETURNED | (IS_LRESULT_NOTERROR(pParams->lResult) ? DCF_DRVCALLVALID : 0)
            );
    }

LUnpark_return:

    LINEEPILOGASYNC(
        &pParams->lResult,
        lRequestID,
        hMutex,
        bCloseMutex,
        pAsyncRequestInfo,
        objectToDereference,
        "Unpark"
        );
}


void
WINAPI
TAllocNewID(
    PTCLIENT            ptClient,
    P_ALLOCNEWID_PARAMS pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    HKEY     hKey;
    HKEY     hKey2;
    DWORD    dwDataSize;
    DWORD    dwDataType;
    DWORD    dwNewID;
    DWORD    dwDisposition;


    RegCreateKeyEx(
        HKEY_LOCAL_MACHINE,
        gszRegKeyTelephony,
        0,
        TEXT(""),
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        0,
        &hKey2,
        &dwDisposition
        );

    RegCreateKeyEx(
        hKey2,
        gszLocations,
        0,
        TEXT(""),
        REG_OPTION_NON_VOLATILE,
        KEY_ALL_ACCESS,
        0,
        &hKey,
        &dwDisposition
        );

    dwDataSize = sizeof(DWORD);

    //
    // Use 1 as the first ID.
    //

    pParams->dwNewID = 1;
    RegQueryValueEx(
        hKey,
        gszNextID,
        0,
        &dwDataType,
        (LPBYTE)&pParams->dwNewID,
        &dwDataSize
        );


    dwNewID = pParams->dwNewID + 1;

    RegSetValueEx(
        hKey,
        gszNextID,
        0,
        REG_DWORD,
        (LPBYTE)&dwNewID,
        sizeof(DWORD)
        );

    RegCloseKey( hKey );
    RegCloseKey( hKey2);

    *pdwNumBytesReturned = sizeof(ALLOCNEWID_PARAMS);

    return;
}


#define MAX_KEY_LENGTH 256
DWORD RegDeleteKeyNT(HKEY hStartKey , LPCTSTR pKeyName )
{
  DWORD   dwRtn, dwSubKeyLength;
  LPTSTR  pSubKey = NULL;
  TCHAR   szSubKey[MAX_KEY_LENGTH]; // (256) this should be dynamic.
  HKEY    hKey;

  // Do not allow NULL or empty key name
  if ( pKeyName &&  lstrlen(pKeyName))
  {
     if( (dwRtn=RegOpenKeyEx(hStartKey,pKeyName,
        0, KEY_ENUMERATE_SUB_KEYS | DELETE, &hKey )) == ERROR_SUCCESS)
     {
        while (dwRtn == ERROR_SUCCESS )
        {
           dwSubKeyLength = MAX_KEY_LENGTH;
           dwRtn=RegEnumKeyEx(
                          hKey,
                          0,       // always index zero
                          szSubKey,
                          &dwSubKeyLength,
                          NULL,
                          NULL,
                          NULL,
                          NULL
                        );

           if(dwRtn == ERROR_NO_MORE_ITEMS)
           {
              dwRtn = RegDeleteKey(hStartKey, pKeyName);
              break;
           }
           else if(dwRtn == ERROR_SUCCESS)
              dwRtn=RegDeleteKeyNT(hKey, szSubKey);
        }
        RegCloseKey(hKey);
        // Do not save return code because error
        // has already occurred
     }
  }
  else
     dwRtn = ERROR_BADKEY;

  return dwRtn;
}



void
WINAPI
TWriteLocations(
    PTCLIENT            ptClient,
    PW_LOCATIONS_PARAMS pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    DWORD           dwLocationID;
    DWORD           dwCount,dwCount2,dwError;
    DWORD           dwDisposition;
    DWORD           dwNumEntries,dwNumRules;
    DWORD           dwVersion;

    TCHAR           szCurrentLocationKey[256];
    TCHAR           szCurrentRuleKey[256];

    HKEY            hAllLocationsKey = NULL;
    HKEY            hLocationKey;
    HKEY            hAllAreaCodeRulesKey;
    HKEY            hAreaCodeRuleKey;
    HKEY            hTelephonyKey;
    HKEY            hUTelephonyKey;
    HKEY            hUAllLocationsKey = NULL;
    HANDLE          CurrentUserKey;
   
    PLOCATIONLIST   pLocationList = NULL;
    PLOCATION       pLocation = NULL;
    PAREACODERULE   pAreaCodeRule = NULL; 

    BOOL            bRelMutex = FALSE;
    HANDLE          hProvidersMutex;

    LOG((TL_TRACE, "TWriteLocations: enter"));

    hProvidersMutex = CreateMutex (
        NULL,
        FALSE,
        TEXT("TapisrvProviderListMutex")
        );
    if (NULL == hProvidersMutex)
    {
        LOG((TL_ERROR,
            "WriteLocation: CreateMutex failed, err=%d",
            GetLastError()
            ));
        goto ExitHere;
    }
    
    WaitForSingleObject (hProvidersMutex, INFINITE);
    bRelMutex = TRUE;
    

    dwVersion = TAPI_LOCATION_LIST_VERSION;

    if (RegCreateKeyEx(
                   HKEY_LOCAL_MACHINE,
                   gszRegKeyTelephony,
                   0,
                   TEXT(""),
                   REG_OPTION_NON_VOLATILE,
                   KEY_ALL_ACCESS,
                   0,
                   &hTelephonyKey,
                   &dwDisposition
                  ) != ERROR_SUCCESS)
    {
        goto ExitHere;
    }
    
    if (RegCreateKeyEx(
                   hTelephonyKey,
                   gszLocations,
                   0,
                   TEXT(""),
                   REG_OPTION_NON_VOLATILE,
                   KEY_ALL_ACCESS,
                   0,
                   &hAllLocationsKey,
                   &dwDisposition
                  ) != ERROR_SUCCESS)
    {
        RegCloseKey(hTelephonyKey);
        goto ExitHere;
    }

    RegSetValueEx( hAllLocationsKey,
                   gszLocationListVersion,
                   0,
                   REG_DWORD,
                   (BYTE *)&dwVersion,
                   sizeof(dwVersion)
                   );

    RegCloseKey( hTelephonyKey );
   
    /////////////////////////////////////////////////////
    // Now open clients key
    //
    if ((dwError=RpcImpersonateClient (0)) != RPC_S_OK)
    {
        LOG((TL_ERROR,
            "WriteLocation: RpcImpersonateClient failed, err=%d",
            dwError
            ));
        goto ExitHere;
    }
    else
    {

        if (RtlOpenCurrentUser(KEY_ALL_ACCESS, &CurrentUserKey) 
            != ERROR_SUCCESS)
        {
            RpcRevertToSelf();
            goto ExitHere;
        }

        dwError = RegCreateKeyEx(
                      CurrentUserKey,
                      gszRegKeyTelephony,
                      0,
                      TEXT(""),
                      REG_OPTION_NON_VOLATILE,
                      KEY_ALL_ACCESS,
                      0,
                      &hUTelephonyKey,
                      &dwDisposition
                    );
        if ( dwError != ERROR_SUCCESS )
        {
    
            LOG((TL_ERROR, "Registry can't create/open Users telephony key"));
            NtClose(CurrentUserKey);
            RpcRevertToSelf();
            goto ExitHere;
        }
    
        NtClose(CurrentUserKey);
        
        dwError = RegCreateKeyEx(
                      hUTelephonyKey,
                      gszLocations,
                      0,
                      TEXT(""),
                      REG_OPTION_NON_VOLATILE,
                      KEY_ALL_ACCESS,
                      0,
                      &hUAllLocationsKey,
                      &dwDisposition
                    );
        if ( dwError != ERROR_SUCCESS )
        {
    
            LOG((TL_ERROR, "Registry can't create/open Users Locations key"));
            RegCloseKey( hUTelephonyKey );
            RpcRevertToSelf();
            goto ExitHere;
        }
        RegSetValueEx(  hUAllLocationsKey,
                        gszLocationListVersion,
                        0,
                        REG_DWORD,
                        (BYTE *)&dwVersion,
                        sizeof(dwVersion)
                        );
        RegCloseKey( hUTelephonyKey );
    
        RpcRevertToSelf();
    }



    pLocationList = (PLOCATIONLIST)(pDataBuf + pParams->dwLocationListOffset);


    if ( pParams->dwChangedFlags & CHANGEDFLAGS_CURLOCATIONCHANGED )
    {
        RegSetValueEx(
                       hAllLocationsKey,
                       gszCurrentID,
                       0,
                       REG_DWORD,
                       (LPBYTE)&pLocationList->dwCurrentLocationID,
                       sizeof(DWORD)
                     );
    }     
    
    // Find position of 1st LOCATION structure in the LOCATIONLIST structure 
    pLocation = (PLOCATION) ((BYTE*)(pLocationList) + pLocationList->dwLocationListOffset );           

    // Number of locations ?
    dwNumEntries =  pLocationList->dwNumLocationsInList;

    for (dwCount = 0; dwCount < dwNumEntries ; dwCount++)
    {
        //Form key name for this location
        dwLocationID = pLocation->dwPermanentLocationID;
        wsprintf(szCurrentLocationKey, TEXT("Location%d"), dwLocationID);
    
        // Is Entry to be deleted from reg ?
        if(pLocation->dwLocationNameSize > sizeof(WCHAR) &&
            *(WCHAR *)((BYTE*)(pLocation) + 
                pLocation->dwLocationNameOffset) != 0) // not just NULL
        {
            LOG((TL_INFO, "Location - write %s",szCurrentLocationKey));
            
            // Create or open key for this location
            dwError = RegCreateKeyEx(
                            hAllLocationsKey,
                            szCurrentLocationKey,
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            0,
                            &hLocationKey,
                            &dwDisposition
                          );
            if (dwError == ERROR_SUCCESS)
            {
                // Country ID
                if(RegSetValueEx(
                                 hLocationKey,
                                 gszCountry,
                                 0,
                                 REG_DWORD,
                                 (LPBYTE)&pLocation->dwCountryID,
                                 sizeof(DWORD)
                                ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "Location - can't write country"));
                }
        
                // Options (flags)
                if(RegSetValueEx(
                                 hLocationKey,
                                 gszFlags,
                                 0,
                                 REG_DWORD,
                                 (LPBYTE)&pLocation->dwOptions,
                                 sizeof(DWORD)
                                ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "Location - can't write Flags"));
                }
                
    
                // Name
                if(TAPIRegSetValueExW(
                                 hLocationKey,
                                 gszNameW,
                                 0,
                                 REG_SZ,
                                 (BYTE*)(pLocation) + pLocation->dwLocationNameOffset,
                                 pLocation->dwLocationNameSize
                                ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "Location - can't write Name"));
                }
                
                // AreaCode
                if(TAPIRegSetValueExW(
                                hLocationKey,
                                gszAreaCodeW,
                                0,
                                REG_SZ,
                                (BYTE*)(pLocation) + pLocation->dwAreaCodeOffset,
                                pLocation->dwAreaCodeSize
                                ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "Location - can't write area code"));
                }
    
                // CallWaiting
                if(TAPIRegSetValueExW(
                                hLocationKey,
                                gszDisableCallWaitingW,
                                0,
                                REG_SZ,
                                (BYTE*)(pLocation) + pLocation->dwCancelCallWaitingOffset,
                                pLocation->dwCancelCallWaitingSize
                                ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "Location - can't write call waiting"));
                }

                // LD Carrier Code
                if(TAPIRegSetValueExW(
                                hLocationKey,
                                gszLongDistanceCarrierCodeW,
                                0,
                                REG_SZ,
                                (BYTE*)(pLocation) + pLocation->dwLongDistanceCarrierCodeOffset,
                                pLocation->dwLongDistanceCarrierCodeSize
                                ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "Location - can't write LD carrier code"));
                }

                // International Carrier Code
                if(TAPIRegSetValueExW(
                                hLocationKey,
                                gszInternationalCarrierCodeW,
                                0,
                                REG_SZ,
                                (BYTE*)(pLocation) + pLocation->dwInternationalCarrierCodeOffset,
                                pLocation->dwInternationalCarrierCodeSize
                                ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "Location - can't write International carrier code"));
                }

                // LD Access
                if(TAPIRegSetValueExW(
                                hLocationKey,
                                gszLongDistanceAccessW,
                                0,
                                REG_SZ,
                                (BYTE*)(pLocation) + pLocation->dwLongDistanceAccessCodeOffset,
                                pLocation->dwLongDistanceAccessCodeSize
                                ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "Location - can't write LD access code"));
                }

                // Local Access
                if(TAPIRegSetValueExW(
                                hLocationKey,
                                gszOutsideAccessW,
                                0,
                                REG_SZ,
                                (BYTE*)(pLocation) + pLocation->dwLocalAccessCodeOffset,
                                pLocation->dwLocalAccessCodeSize
                                ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "Location - can't write Local access code"));
                }
                
               // if this is an existing key then delete all the subkeys
               RegDeleteKeyNT(hLocationKey, gszAreaCodeRules );
    
               // create or open the AreaCodeRules key
               dwError = RegCreateKeyEx(
                                         hLocationKey,
                                         gszAreaCodeRules,
                                         0,
                                         TEXT(""),
                                         REG_OPTION_NON_VOLATILE,
                                         KEY_ALL_ACCESS,
                                         0,
                                         &hAllAreaCodeRulesKey,
                                         &dwDisposition
                                        );
                if (dwError == ERROR_SUCCESS)
                {
                    // Find position of 1st AREACODERULE structure in the LOCATION structure 
                    pAreaCodeRule = (PAREACODERULE) ((BYTE*)(pLocation) 
                                                     + pLocation->dwAreaCodeRulesListOffset );           
                   
                    dwNumRules = pLocation->dwNumAreaCodeRules;           
                
                    for (dwCount2 = 0; dwCount2 != dwNumRules; dwCount2++)
                    {
                        //Form key name for this aea code rule
                        wsprintf(szCurrentRuleKey, TEXT("Rule%d"),dwCount2);
        
                        // create or open this Area Code Rule Key
                        dwError = RegCreateKeyEx(
                                                 hAllAreaCodeRulesKey,
                                                 szCurrentRuleKey,
                                                 0,
                                                 TEXT(""),
                                                 REG_OPTION_NON_VOLATILE,
                                                 KEY_ALL_ACCESS,
                                                 0,
                                                 &hAreaCodeRuleKey,
                                                 &dwDisposition
                                                );
                        if (dwError == ERROR_SUCCESS)
                        {
                            // Pull Dataout of AREACODERULE structure
            
                            // Options (flags)
                            if(RegSetValueEx(
                                       hAreaCodeRuleKey,
                                       gszFlags,
                                       0,
                                       REG_DWORD,
                                       (LPBYTE)&pAreaCodeRule->dwOptions,
                                       sizeof(DWORD)
                                           ) != ERROR_SUCCESS)
                            {
                                LOG((TL_ERROR, "Area code rule - can't write Flags"));
                            }
                            
                            // AreaCode to call
                            if(TAPIRegSetValueExW(
                                                 hAreaCodeRuleKey,
                                                 gszAreaCodeToCallW,
                                                 0,
                                                 REG_SZ,
                                                 (BYTE*)(pLocation) + pAreaCodeRule->dwAreaCodeOffset,
                                                 pAreaCodeRule->dwAreaCodeSize
                                                 ) != ERROR_SUCCESS)
                            {
                                LOG((TL_ERROR, "Area code rule - can't write Area code to call"));
                            }
            
                            //Number to Dial
                            if(TAPIRegSetValueExW(
                                                 hAreaCodeRuleKey,
                                                 gszNumberToDialW,
                                                 0,
                                                 REG_SZ,
                                                 (BYTE*)(pLocation) + pAreaCodeRule->dwNumberToDialOffset,
                                                 pAreaCodeRule->dwNumberToDialSize
                                                  ) != ERROR_SUCCESS)
                            {
                                LOG((TL_ERROR, "Area code rule - can't write Number to dial"));
                            }
            
                            //Prefixes List
                            if(TAPIRegSetValueExW(
                                                 hAreaCodeRuleKey,
                                                 gszPrefixesW,
                                                 0,
                                                 REG_MULTI_SZ,
                                                 (BYTE*)(pLocation) + pAreaCodeRule->dwPrefixesListOffset,
                                                 pAreaCodeRule->dwPrefixesListSize
                                                  ) != ERROR_SUCCESS)
                            {
                                LOG((TL_ERROR, "Area code rule - can't write Prefixes"));
                            }
            
                            RegCloseKey( hAreaCodeRuleKey );   // Don't need this key anymore...
            
                        }
                        else
                        {
                            LOG((TL_ERROR, "can't create/open hAreaCodeRuleKey"));
                        }
    
                        pAreaCodeRule++;
                    }
                    RegCloseKey(hAllAreaCodeRulesKey);
                }
                else
                {
                    LOG((TL_ERROR, "can't create/open hAllAreaCodeRulesKey"));
                }
            
                RegCloseKey(hLocationKey);


                /////////////////////////////////////////////////////
                // Now do clients location entry
                //

                // Create or open key for this location
                dwError = RegCreateKeyEx(
                                hUAllLocationsKey,
                                szCurrentLocationKey,
                                0,
                                TEXT(""),
                                REG_OPTION_NON_VOLATILE,
                                KEY_ALL_ACCESS,
                                0,
                                &hLocationKey,
                                &dwDisposition
                              );
                if (dwError == ERROR_SUCCESS)
                {
                    // CallingCard
                    if(RegSetValueEx(
                                     hLocationKey,
                                     gszCallingCard,
                                     0,
                                     REG_DWORD,
                                     (LPBYTE)&pLocation->dwPreferredCardID,
                                     sizeof(DWORD)
                                    ) != ERROR_SUCCESS)
                    {
                        LOG((TL_ERROR, "location - can't user preferred card"));
                    }
        
                    RegCloseKey( hLocationKey );   // Don't need this key anymore...
                }

            }
            else
            {
                LOG((TL_ERROR, "can't create/open hLocationKey"));
            }
        }
        else   //Delete this location entry 
        {

            LOG((TL_ERROR, "Location - delete %s",szCurrentLocationKey));
            RegDeleteKeyNT( hAllLocationsKey, szCurrentLocationKey );

            /////////////////////////////////////////////////////
            // Now do clients location entry
            //
            RegDeleteKey(hUAllLocationsKey, szCurrentLocationKey);

        }

        // Try next location in list
        //pEntry++;
        pLocation = (PLOCATION) ((BYTE*)(pLocation) + pLocation->dwUsedSize);           

    }

       //
       // We're inside "if (dwChangedFlags)", so we know _something_ changed...
       //

		LOG((TL_TRACE,  "Sending LINE_LINEDEVSTATE/LINEDEVSTATE_TRANSLATECHANGE msg"));

       SendAMsgToAllLineApps(
               0x80010004,     // (OR with 0x80000000 for >= version)
               LINE_LINEDEVSTATE,
               LINEDEVSTATE_TRANSLATECHANGE,
               0,
               0
             );

       SendAMsgToAllLineApps(
               0x00010003,
               LINE_LINEDEVSTATE,
               LINEDEVSTATE_REINIT,
               LINE_LINEDEVSTATE,
               LINEDEVSTATE_TRANSLATECHANGE
             );


    LOG((TL_TRACE, "TWriteLocations: exit"));

ExitHere:             
    if (hAllLocationsKey != NULL)
    {
        RegCloseKey(hAllLocationsKey);
    }
    if (hUAllLocationsKey != NULL)
    {
        RegCloseKey(hUAllLocationsKey);
    }
    if (bRelMutex && hProvidersMutex)
    {
        ReleaseMutex (hProvidersMutex);
        CloseHandle (hProvidersMutex);
    }
    return;

}



void
WINAPI
TReadLocations(
    PTCLIENT            ptClient,
    PR_LOCATIONS_PARAMS pParams,
    DWORD               dwParamsBufferSize,
    LPBYTE              pDataBuf,
    LPDWORD             pdwNumBytesReturned
    )
{
    PLOCATIONLIST pLocationList = (PLOCATIONLIST)(pDataBuf);

    UINT    n;
    UINT    nNumLocations;
    UINT    nCurrentLocationID;

    TCHAR   szCurrentLocationKey[256]; // Holds "LOCATIONxx" during reads
    TCHAR   szAreaCodeRuleKey[256];    // Holds "Rulexx" during reads
    DWORD   dwDataSize,dwKeySize;

    DWORD   dwNumLocationKeys=0;
    DWORD   dwMaxLocationKeyLength=0;
    DWORD   dwNumAreaCodeKeys=0;
    DWORD   dwMaxAreaCodeKeyLength=0;

    DWORD   dwDataType;
    DWORD   dwNeededSize = 0;
    
    DWORD   dwCount, dwCount2;
    DWORD   dwError;

    HKEY    hAllLocationsKey;
    HKEY    hLocationKey;
    HKEY    hAllAreaCodeRulesKey;
    HKEY    hAreaCodeRuleKey;
    HKEY    hTelephonyKey;
    HKEY    hUTelephonyKey;
    HKEY    hUserAllLocationsKey;
    HANDLE  CurrentUserKey;

    BOOL    bRelMutex = FALSE;
    HANDLE  hProvidersMutex;

    LOG((TL_TRACE, "TReadLocations: enter"));

    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwLocationsTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ( pParams->dwParmsToCheckFlags & CHECKPARMS_DWHLINEAPP )
    {
        if ( 0 == pParams->dwhLineApp )
        {
            //
            // NULL is valid for these functions...
            //
        }
        else
        {
            if ( !IsValidLineApp((HLINEAPP)pParams->dwhLineApp, ptClient) )
            {
                 LOG((TL_ERROR, "0x%lx is not a valid hLineApp", pParams->dwhLineApp));
                 pParams->lResult = LINEERR_INVALAPPHANDLE;
                 goto CLEANUP_ERROR;
            }
        }
    }


    if ( pParams->dwParmsToCheckFlags & CHECKPARMS_DWDEVICEID )
    {
        if (  pParams->dwhLineApp
            &&
              (pParams->dwDeviceID != 0)
            &&
              (pParams->dwDeviceID >= TapiGlobals.dwNumLines)
           )
        {
             LOG((TL_ERROR, "%ld is not a valid dwDeviceID", pParams->dwDeviceID));
             pParams->lResult = LINEERR_BADDEVICEID;
             goto CLEANUP_ERROR;
        }
    }


    if ( pParams->dwParmsToCheckFlags & CHECKPARMS_DWAPIVERSION )
    {
        switch (pParams->dwAPIVersion)
        {
        case TAPI_VERSION_CURRENT:
        case TAPI_VERSION3_0:
        case TAPI_VERSION2_2:
        case TAPI_VERSION2_1:
        case TAPI_VERSION2_0:
        case TAPI_VERSION1_4:
        case TAPI_VERSION1_0:

            break;

        default:

            LOG((TL_ERROR,
                "TReadLocations: invalid API version x%x",
                pParams->dwAPIVersion
                ));

            pParams->lResult = LINEERR_INCOMPATIBLEAPIVERSION;
            goto CLEANUP_ERROR;
        }
    }

    if ( pParams->dwParmsToCheckFlags & CHECKPARMS_ONLY )
    {

        LOG((TL_INFO, "TReadLocations: Check only, no data transfer"));

        pParams->lResult = 0;

        if (pParams->dwLocationsTotalSize >= 3 * sizeof(DWORD))
        {
            pLocationList->dwTotalSize = pParams->dwLocationsTotalSize;
            pLocationList->dwNeededSize =
            pLocationList->dwUsedSize = 3 * sizeof(DWORD);
            *pdwNumBytesReturned = sizeof (TAPI32_MSG) + (3 * sizeof(DWORD));
        }
        else
        {
            *pdwNumBytesReturned = sizeof (TAPI32_MSG);
        }

        pParams->dwLocationsOffset = 0;

        goto CLEANUP_ERROR;
    }

    hProvidersMutex = CreateMutex (
        NULL,
        FALSE,
        TEXT("TapisrvProviderListMutex")
        );
    if (NULL == hProvidersMutex)
    {
        LOG((TL_ERROR,
                "TReadLocations: CreateMutex failed, err=%d",
                GetLastError()
                ));

        pParams->lResult = LINEERR_OPERATIONFAILED;
        goto CLEANUP_ERROR;
    }

    WaitForSingleObject (hProvidersMutex, INFINITE);
    bRelMutex = TRUE;

    dwError = RegOpenKeyEx(
                  HKEY_LOCAL_MACHINE,
                  gszRegKeyTelephony,
                  0,
                  KEY_READ,
                  &hTelephonyKey
                );

    if (dwError == ERROR_SUCCESS)
    {
        dwError =  RegOpenKeyEx(
                            hTelephonyKey,
                            gszLocations,
                            0,
                            KEY_READ,
                            &hAllLocationsKey
                           );
        RegCloseKey( hTelephonyKey );   // Don't need this key anymore...
    }

    if ( dwError != ERROR_SUCCESS )
    {
        LOG((TL_ERROR, "ReadLocation: Registry can't open Locations key"));
        pParams->lResult = LINEERR_INIFILECORRUPT;
        goto CLEANUP_ERROR;
    }

    

    // Test the version of the Machine Locations key. Upgrade if necessary.
    if(IsLocationListInOldFormat(hAllLocationsKey))
    {
        LOG((TL_INFO, "ReadLocation: Upgrade the Machine Locations key"));
        dwError = ConvertLocations();

        if(dwError != ERROR_SUCCESS)
        {
            LOG((TL_ERROR, "ReadLocation: Cannot convert the Machine Locations key"));
        }
    }



    /////////////////////////////////////////////////////
    // Now open clients key
    //
    if ((dwError=RpcImpersonateClient (0)) != RPC_S_OK)
    {
        LOG((TL_ERROR,
            "ReadLocation: RpcImpersonateClient failed, err=%d",
            dwError
            ));
        pParams->lResult = LINEERR_OPERATIONFAILED;
        goto CLEANUP_ERROR;
    }
    else
    {
        RtlOpenCurrentUser(KEY_ALL_ACCESS, &CurrentUserKey);
    
        dwError = RegOpenKeyEx(
                      CurrentUserKey,
                      gszRegKeyTelephony,
                      0,
                      KEY_READ,
                      &hUTelephonyKey
                    );

        if ( dwError != ERROR_SUCCESS )
        {
            LOG((TL_ERROR, "  Registry can't open Users Locations key"));
            
            RpcRevertToSelf();
            RegCloseKey( hAllLocationsKey );
            NtClose(CurrentUserKey);
            pParams->lResult = LINEERR_OPERATIONFAILED;
            goto CLEANUP_ERROR;
        }
    
        if (RegOpenKeyEx(
            hUTelephonyKey,
            gszLocations,
            0,
            KEY_READ,
            &hUserAllLocationsKey
            ) != ERROR_SUCCESS)
        {
            hUserAllLocationsKey = NULL;
        }
        
        RegCloseKey( hUTelephonyKey );   // Don't need this key anymore...
    
        RpcRevertToSelf();

        // Test the version of the User Locations key. Upgrade if necessary.
        if(hUserAllLocationsKey && IsLocationListInOldFormat(hUserAllLocationsKey))
        {
            dwError = ConvertUserLocations(CurrentUserKey);

            if(dwError != ERROR_SUCCESS)
            {
                LOG((TL_ERROR, "  Cannot convert the User Locations key"));
            }
        }

        NtClose(CurrentUserKey);
    }



    dwDataSize = sizeof(nCurrentLocationID);
    nCurrentLocationID = 0;
    RegQueryValueEx(
                   hAllLocationsKey,
                   gszCurrentID,
                   0,
                   &dwDataType,
                   (LPBYTE)&nCurrentLocationID,
                   &dwDataSize
                 );



    // query some info about the Locations key in order to allocate memory
    RegQueryInfoKey(hAllLocationsKey,
                    NULL,
                    NULL,
                    NULL,
                    &dwNumLocationKeys,
                    &dwMaxLocationKeyLength,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL,
                    NULL
                   );

    //
    // It's _REALLY_ bad if NumLocations is zero for any
    // reason.  Should probably fail the function on the spot...
    //
    if ( 0 == dwNumLocationKeys )
    {
        LOG((TL_ERROR, "  Registry says there are 0 locations"));
        pParams->lResult = LINEERR_INIFILECORRUPT;
        RegCloseKey( hAllLocationsKey );
        if (hUserAllLocationsKey)
        {
            RegCloseKey(hUserAllLocationsKey);
        }

        goto CLEANUP_ERROR;
    }




    // Need to work out need size, so start with static part of list
    dwNeededSize = ALIGN(sizeof(LOCATIONLIST));

    // go though locations to work out needed size
    for (dwCount=0; dwCount < dwNumLocationKeys ; dwCount++)
    {
        dwKeySize = sizeof(szCurrentLocationKey)/sizeof(TCHAR);
        dwError =  RegEnumKeyEx( hAllLocationsKey,
                                 dwCount,
                                 szCurrentLocationKey,
                                 &dwKeySize,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL
                               );

        if(dwError == ERROR_NO_MORE_ITEMS)
        {
            break;
        }
        if (dwError != ERROR_SUCCESS )
        {
            continue;
        }

        // Open this Location Key
        dwError = RegOpenKeyEx(
                                hAllLocationsKey,
                                szCurrentLocationKey,
                                0,
                                KEY_ALL_ACCESS,
                                &hLocationKey
                               );
        if (dwError == ERROR_SUCCESS)
        {
            //Static part then strings
            dwNeededSize += ALIGN(sizeof(LOCATION));

            // Name
            if (TAPIRegQueryValueExW(
                             hLocationKey,
                             gszNameW,
                             NULL,
                             NULL,
                             NULL,
                             &dwDataSize
                           ) != ERROR_SUCCESS)
            {
                dwDataSize = sizeof(WCHAR);
            }
            dwNeededSize +=  ALIGN(dwDataSize);

            // AreaCode
            if (TAPIRegQueryValueExW(
                             hLocationKey,
                             gszAreaCodeW,
                             NULL,
                             NULL,
                             NULL,
                             &dwDataSize
                           ) != ERROR_SUCCESS)
            {
                dwDataSize = sizeof(WCHAR);
            }
            dwNeededSize +=  ALIGN(dwDataSize);

            //CallWaiting
            if (TAPIRegQueryValueExW(
                             hLocationKey,
                             gszDisableCallWaitingW,
                             NULL,
                             NULL,
                             NULL,
                             &dwDataSize
                           ) != ERROR_SUCCESS)
            {
                dwDataSize = sizeof(WCHAR);
            }
            dwNeededSize +=  ALIGN(dwDataSize);
            
            //LD Carrier
            if (TAPIRegQueryValueExW(
                             hLocationKey,
                             gszLongDistanceCarrierCodeW,
                             NULL,
                             NULL,
                             NULL,
                             &dwDataSize
                           ) != ERROR_SUCCESS)
            {
                dwDataSize = sizeof(WCHAR);
            }
            dwNeededSize +=  ALIGN(dwDataSize);                            
            
            //International Carrier
            if (TAPIRegQueryValueExW(
                             hLocationKey,
                             gszInternationalCarrierCodeW,
                             NULL,
                             NULL,
                             NULL,
                             &dwDataSize
                           ) != ERROR_SUCCESS)
            {
                dwDataSize = sizeof(WCHAR);
            }
            dwNeededSize +=  ALIGN(dwDataSize);                            
            
            //LD Access
            if (TAPIRegQueryValueExW(
                             hLocationKey,
                             gszLongDistanceAccessW,
                             NULL,
                             NULL,
                             NULL,
                             &dwDataSize
                           ) != ERROR_SUCCESS)
            {
                dwDataSize = sizeof(WCHAR);
            }
            dwNeededSize +=  ALIGN(dwDataSize);                            

            //Local Access
            if (TAPIRegQueryValueExW(
                             hLocationKey,
                             gszOutsideAccessW,
                             NULL,
                             NULL,
                             NULL,
                             &dwDataSize
                           ) != ERROR_SUCCESS)
            {
                dwDataSize = sizeof(WCHAR);
            }
            dwNeededSize +=  ALIGN(dwDataSize);
        

            dwError =  RegOpenKeyEx( hLocationKey,
                                     gszAreaCodeRules,
                                     0,
                                     KEY_READ,
                                     &hAllAreaCodeRulesKey
                                   );
            if (dwError == ERROR_SUCCESS)
            {
            // query info about the AreaCodeRules key 
            RegQueryInfoKey(hAllAreaCodeRulesKey,
                            NULL,
                            NULL,
                            NULL,
                            &dwNumAreaCodeKeys,
                            &dwMaxAreaCodeKeyLength,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL,
                            NULL
                           );


                // go though this location's area code rules
                for (dwCount2=0; dwCount2 < dwNumAreaCodeKeys; dwCount2++)
                {
                    dwKeySize = sizeof(szAreaCodeRuleKey)/sizeof(TCHAR);
                    dwError =  RegEnumKeyEx( hAllAreaCodeRulesKey,
                                             dwCount2,
                                             szAreaCodeRuleKey,
                                             &dwKeySize,
                                             NULL,
                                             NULL,
                                             NULL,
                                             NULL
                                            );
                    if(dwError == ERROR_NO_MORE_ITEMS)
                    {
                        break;
                    }
                    if (dwError != ERROR_SUCCESS )
                    {
                        continue;
                    }
            
                    // Open this Aeea Code Rule Key
                    dwError = RegOpenKeyEx(
                                            hAllAreaCodeRulesKey,
                                            szAreaCodeRuleKey,
                                            0,
                                            KEY_ALL_ACCESS,
                                            &hAreaCodeRuleKey
                                           );
                    if (dwError == ERROR_SUCCESS)
                    {
                        //Static part then strings
                        dwNeededSize += ALIGN(sizeof(AREACODERULE));
                        
                        // AreaCode to call
                        TAPIRegQueryValueExW(
                                         hAreaCodeRuleKey,
                                         gszAreaCodeToCallW,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &dwDataSize
                                       );
                        dwNeededSize +=  ALIGN(dwDataSize);
            
                        //Number to Dial
                        TAPIRegQueryValueExW(
                                         hAreaCodeRuleKey,
                                         gszNumberToDialW,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &dwDataSize
                                       );
                        dwNeededSize +=  ALIGN(dwDataSize);
    
                        //Number to Dial
                        TAPIRegQueryValueExW(
                                         hAreaCodeRuleKey,
                                         gszPrefixesW,
                                         NULL,
                                         NULL,
                                         NULL,
                                         &dwDataSize
                                       );
                        dwNeededSize +=  ALIGN(dwDataSize);

                        RegCloseKey( hAreaCodeRuleKey );   // Don't need this key anymore...
                    }
                }
                
                RegCloseKey( hAllAreaCodeRulesKey );   // Don't need this key anymore...
            }
        }
        RegCloseKey( hLocationKey );   // Don't need this key anymore...
    }

    //
    // Do we have enough space?
    //
    if ( pParams->dwLocationsTotalSize <  dwNeededSize )
    {

        LOG((TL_ERROR, "(0x%08lx) is not enough room for sizeof( 0x%08lx )",
                   pParams->dwLocationsTotalSize, dwNeededSize ));

        //
        // Buffer not large enough
        //

        pLocationList->dwTotalSize          = pParams->dwLocationsTotalSize;
        pLocationList->dwNeededSize         = dwNeededSize;
        pLocationList->dwUsedSize           = sizeof(LOCATIONLIST);
        pLocationList->dwNumLocationsInList = 0;
        pLocationList->dwLocationListSize   = 0;
        pLocationList->dwLocationListOffset = 0;

        pParams->lResult = 0;
        pParams->dwLocationsOffset = 0;
    }
    else  // Big enough buffer, now fill it
    {
        DWORD           dwLocationOffset, dwOffset;
        PLOCATION       pLocation;
        PAREACODERULE   pAreaCodeRule;
        DWORD           dwMaxValueLength;

        // buffer size 
        pLocationList->dwTotalSize  = pParams->dwLocationsTotalSize;
        pLocationList->dwNeededSize = dwNeededSize;
        pLocationList->dwUsedSize   = dwNeededSize;

        // Results
        pParams->lResult = 0;
        pParams->dwLocationsOffset = 0;

        pLocationList->dwCurrentLocationID     = nCurrentLocationID;
        pLocationList->dwNumLocationsAvailable = dwNumLocationKeys;
        
        //list size & offset
        dwLocationOffset   = ALIGN(sizeof(LOCATIONLIST));

        pLocationList->dwNumLocationsInList = dwNumLocationKeys;
        pLocationList->dwLocationListSize   = dwNeededSize - sizeof(LOCATIONLIST);
        pLocationList->dwLocationListOffset = dwLocationOffset;



        
        // go through locations 
        for (dwCount=0; dwCount < dwNumLocationKeys ; dwCount++)
        {
            dwKeySize = dwMaxLocationKeyLength + 1;
            dwError =  RegEnumKeyEx( hAllLocationsKey,
                                     dwCount,
                                     szCurrentLocationKey,
                                     &dwKeySize,
                                     NULL,
                                     NULL,
                                     NULL,
                                     NULL
                                   );
    
            if(dwError == ERROR_NO_MORE_ITEMS)
            {
                break;
            }
            
            
            pLocation = (PLOCATION)(((LPBYTE)pLocationList) + dwLocationOffset);
    
            // Open this Location Key
            dwError = RegOpenKeyEx(
                                    hAllLocationsKey,
                                    szCurrentLocationKey,
                                    0,
                                    KEY_ALL_ACCESS,
                                    &hLocationKey
                                   );
            if (dwError == ERROR_SUCCESS)
            {
                LOG((TL_INFO, "Location - read %S",szCurrentLocationKey));

                // Find out how big is our biggest value
                dwMaxValueLength = 256;
                RegQueryInfoKey(hLocationKey,0,0,0,0,0,0,0,0,&dwMaxValueLength,0,0);
    
    
                /////////////////////////////////////////////////////////////////////
                // Process fized part of Location info
                dwOffset = ALIGN(sizeof(LOCATION));
            
                //pLocation->dwPreferredCardID = m_dwPreferredCardID;
    
    
                // Location ID (is included in the key name)
                pLocation->dwPermanentLocationID = 0;
                if(dwKeySize >= ARRAYSIZE(gszLocation)) // minimum a Location_ key
                {
                    pLocation->dwPermanentLocationID = (DWORD)_ttol(szCurrentLocationKey + (ARRAYSIZE(gszLocation))-1);
                }
                else
                {
                    LOG((TL_ERROR, "location - can't determine ID"));
                }
    
                // Country ID
                dwDataSize = sizeof(DWORD);
                pLocation->dwCountryID = 1;
                if(RegQueryValueEx(
                                 hLocationKey,
                                 gszCountry,
                                 0,
                                 &dwDataType,
                                 (LPBYTE)&pLocation->dwCountryID,
                                 &dwDataSize
                                 ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "location - can't read CountryID"));
                }
    
                // Options (flags)
                dwDataSize = sizeof(DWORD);
                pLocation->dwOptions = 0;
                if(RegQueryValueEx(
                                 hLocationKey,
                                 gszFlags,
                                 0,
                                 &dwDataType,
                                 (LPBYTE)&pLocation->dwOptions,
                                 &dwDataSize
                                 ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "location - can't read Flags"));
                }
            
                // Name
                pLocation->dwLocationNameSize = dwMaxValueLength;          
                if(TAPIRegQueryValueExW(     
                                 hLocationKey,
                                 gszNameW,
                                 NULL,              
                                 NULL,                         
                                 (LPBYTE)pLocation + dwOffset, 
                                 &pLocation->dwLocationNameSize                  
                                 ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "location - can't read Name"));
                    *(LPWSTR)((LPBYTE)pLocation + dwOffset) = 0;
                    pLocation->dwLocationNameSize = sizeof(WCHAR);
                }
                pLocation->dwLocationNameOffset = dwOffset;                             
                dwOffset += ALIGN(pLocation->dwLocationNameSize);
                
                // AreaCode
                pLocation->dwAreaCodeSize = dwMaxValueLength;          
                if(TAPIRegQueryValueExW(     
                                 hLocationKey,
                                 gszAreaCodeW,
                                 NULL,              
                                 NULL,                         
                                 (LPBYTE)pLocation + dwOffset, 
                                 &pLocation->dwAreaCodeSize                  
                                 ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "location - can't read Area code"));
                    *(LPWSTR)((LPBYTE)pLocation + dwOffset) = 0;
                    pLocation->dwAreaCodeSize = sizeof(WCHAR);
                }
                pLocation->dwAreaCodeOffset = dwOffset;                             
                dwOffset += ALIGN(pLocation->dwAreaCodeSize);
    
                // CallWaiting
                pLocation->dwCancelCallWaitingSize = dwMaxValueLength;          
                if(TAPIRegQueryValueExW(     
                                 hLocationKey,
                                 gszDisableCallWaitingW,
                                 NULL,              
                                 NULL,                         
                                 (LPBYTE)pLocation + dwOffset, 
                                 &pLocation->dwCancelCallWaitingSize                  
                                 ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "location - can't read Callwaiting"));
                    *(LPWSTR)((LPBYTE)pLocation + dwOffset) = 0;
                    pLocation->dwCancelCallWaitingSize = sizeof(WCHAR);
                }
                pLocation->dwCancelCallWaitingOffset = dwOffset;                             
                dwOffset += ALIGN(pLocation->dwCancelCallWaitingSize);

                // LD Carrier
                pLocation->dwLongDistanceCarrierCodeSize = dwMaxValueLength;          
                if(TAPIRegQueryValueExW(     
                                 hLocationKey,
                                 gszLongDistanceCarrierCodeW,
                                 NULL,              
                                 NULL,                         
                                 (LPBYTE)pLocation + dwOffset, 
                                 &pLocation->dwLongDistanceCarrierCodeSize                  
                                 ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "location - can't read LD carrier code"));
                    *(LPWSTR)((LPBYTE)pLocation + dwOffset) = 0;
                    pLocation->dwLongDistanceCarrierCodeSize = sizeof(WCHAR);
                }
                pLocation->dwLongDistanceCarrierCodeOffset = dwOffset;                             
                dwOffset += ALIGN(pLocation->dwLongDistanceCarrierCodeSize);
                
                // International Carrier
                pLocation->dwInternationalCarrierCodeSize = dwMaxValueLength;          
                if(TAPIRegQueryValueExW(     
                                 hLocationKey,
                                 gszInternationalCarrierCodeW,
                                 NULL,              
                                 NULL,                         
                                 (LPBYTE)pLocation + dwOffset, 
                                 &pLocation->dwInternationalCarrierCodeSize                  
                                 ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "location - can't read International carrier code"));
                    *(LPWSTR)((LPBYTE)pLocation + dwOffset) = 0;
                    pLocation->dwInternationalCarrierCodeSize = sizeof(WCHAR);
                }
                pLocation->dwInternationalCarrierCodeOffset = dwOffset;                             
                dwOffset += ALIGN(pLocation->dwInternationalCarrierCodeSize);
                
                // LD Access
                pLocation->dwLongDistanceAccessCodeSize = dwMaxValueLength;          
                if(TAPIRegQueryValueExW(     
                                 hLocationKey,
                                 gszLongDistanceAccessW,
                                 NULL,              
                                 NULL,                         
                                 (LPBYTE)pLocation + dwOffset, 
                                 &pLocation->dwLongDistanceAccessCodeSize                  
                                 ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "location - can't read LD access code"));
                    *(LPWSTR)((LPBYTE)pLocation + dwOffset) = 0;
                    pLocation->dwLongDistanceAccessCodeSize = sizeof(WCHAR);
                }
                pLocation->dwLongDistanceAccessCodeOffset = dwOffset;                             
                dwOffset += ALIGN(pLocation->dwLongDistanceAccessCodeSize);
    
                // Local Access
                pLocation->dwLocalAccessCodeSize = dwMaxValueLength;          
                if(TAPIRegQueryValueExW(     
                                 hLocationKey,
                                 gszOutsideAccessW,
                                 NULL,              
                                 NULL,                         
                                 (LPBYTE)pLocation + dwOffset, 
                                 &pLocation->dwLocalAccessCodeSize                  
                                 ) != ERROR_SUCCESS)
                {
                    LOG((TL_ERROR, "location - can't read local access code"));
                    *(LPWSTR)((LPBYTE)pLocation + dwOffset) = 0;
                    pLocation->dwLocalAccessCodeSize = sizeof(WCHAR);
                }
                pLocation->dwLocalAccessCodeOffset = dwOffset;                             
                dwOffset += ALIGN(pLocation->dwLocalAccessCodeSize);
    
            
                ///////////////////////////////////////////////////////////////////
                // Do the Area Code Rules
    
                dwError =  RegOpenKeyEx( hLocationKey,
                                         gszAreaCodeRules,
                                         0,
                                         KEY_READ,
                                         &hAllAreaCodeRulesKey
                                       );
                if (dwError == ERROR_SUCCESS)
                {
                    // Find out how many keys & how long is a key
                    RegQueryInfoKey(hAllAreaCodeRulesKey,0,0,0,&dwNumAreaCodeKeys,&dwMaxAreaCodeKeyLength,0,0,0,0,0,0);
                    
                    pLocation->dwNumAreaCodeRules = dwNumAreaCodeKeys;
                    // pLocation->dwAreaCodeRulesListSize;
                    pLocation->dwAreaCodeRulesListOffset = dwOffset;  
        
                    // point to the 1st rule
                    pAreaCodeRule = (PAREACODERULE)(((LPBYTE)pLocation) + dwOffset);
            
    
                    //point strings past rule area
                    dwOffset += ALIGN(( sizeof(AREACODERULE) * dwNumAreaCodeKeys ));
        
    
                    // go though this location's area code rules
                    for (dwCount2=0; dwCount2 < dwNumAreaCodeKeys; dwCount2++)
                    {
                        dwKeySize = dwMaxAreaCodeKeyLength + 1;
      
                        dwError =  RegEnumKeyEx( hAllAreaCodeRulesKey,
                                                 dwCount2,
                                                 szAreaCodeRuleKey,
                                                 &dwKeySize,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 NULL
                                                );
                        if(dwError == ERROR_NO_MORE_ITEMS)
                        {
                            break;
                        }
                        if(dwError != ERROR_SUCCESS)
                        {
                            continue;
                        }

                        // Open this Area Code Rule Key
                        dwError = RegOpenKeyEx(
                                                hAllAreaCodeRulesKey,
                                                szAreaCodeRuleKey,
                                                0,
                                                KEY_ALL_ACCESS,
                                                &hAreaCodeRuleKey
                                               );
                        if (dwError == ERROR_SUCCESS)
                        {
                            LOG((TL_ERROR, "ReadLocation - areacode %s",szAreaCodeRuleKey));
                            // Find out how big is our biggest value
                            RegQueryInfoKey(hAreaCodeRuleKey,0,0,0,0,0,0,0,0,&dwMaxValueLength,0,0);
    
                            //Static part then strings
                            dwDataSize = sizeof(DWORD);
                            pAreaCodeRule->dwOptions = 0;
                            if(RegQueryValueEx(
                                             hAreaCodeRuleKey,
                                             gszFlags,
                                             0,
                                             &dwDataType,
                                             (LPBYTE)&pAreaCodeRule->dwOptions,
                                             &dwDataSize
                                             ) != ERROR_SUCCESS)
                            {
                                LOG((TL_ERROR, "Area code rule - can't read Flags"));
                            }
                            
                            // AreaCode to call
                            pAreaCodeRule->dwAreaCodeSize = dwMaxValueLength;          
                            if(TAPIRegQueryValueExW(     
                                             hAreaCodeRuleKey,
                                             gszAreaCodeToCallW,
                                             NULL,              
                                             NULL,                         
                                             (LPBYTE)pLocation + dwOffset, 
                                             &pAreaCodeRule->dwAreaCodeSize                  
                                             ) != ERROR_SUCCESS)
                            {
                                LOG((TL_ERROR, "Area code rule - can't read Area code to call"));
                            }
                            pAreaCodeRule->dwAreaCodeOffset = dwOffset;                             
                            dwOffset += ALIGN(pAreaCodeRule->dwAreaCodeSize);
    
                            //Number to Dial
                            pAreaCodeRule->dwNumberToDialSize = dwMaxValueLength;          
                            if(TAPIRegQueryValueExW(     
                                             hAreaCodeRuleKey,
                                             gszNumberToDialW,
                                             NULL,              
                                             NULL,                         
                                             (LPBYTE)pLocation + dwOffset, 
                                             &pAreaCodeRule->dwNumberToDialSize                  
                                             ) != ERROR_SUCCESS)
                            {
                                LOG((TL_ERROR, "Area code rule - can't read number to dial"));
                            }
                            pAreaCodeRule->dwNumberToDialOffset = dwOffset;                             
                            dwOffset += ALIGN(pAreaCodeRule->dwNumberToDialSize);
        
                            //Prefixes List
                            pAreaCodeRule->dwPrefixesListSize = dwMaxValueLength;          
                            if(TAPIRegQueryValueExW(     
                                             hAreaCodeRuleKey,
                                             gszPrefixesW,
                                             NULL,              
                                             NULL,                         
                                             (LPBYTE)pLocation + dwOffset, 
                                             &pAreaCodeRule->dwPrefixesListSize                  
                                             ) != ERROR_SUCCESS)
                            {
                                LOG((TL_ERROR, "Area code rule - can't read prefixes"));
                            }
                            pAreaCodeRule->dwPrefixesListOffset = dwOffset;                             
                            dwOffset += ALIGN(pAreaCodeRule->dwPrefixesListSize);
    
                            RegCloseKey( hAreaCodeRuleKey );   // Don't need this key anymore...
                            pAreaCodeRule++;
                        }
                    
                    }
                    
                    RegCloseKey( hAllAreaCodeRulesKey );   // Don't need this key anymore...
                }
                // offset gives how many bytes we used
                pLocation->dwUsedSize = dwOffset;
                dwLocationOffset += dwOffset;
     
            }
            RegCloseKey( hLocationKey );   

            /////////////////////////////////////////////////////
            // Now do clients location entry
            //

            pLocation->dwPreferredCardID = 0;
            if (hUserAllLocationsKey)
            {
                // Open this Location Key
                dwError = RegOpenKeyEx(
                                    hUserAllLocationsKey,
                                    szCurrentLocationKey,
                                    0,
                                    KEY_ALL_ACCESS,
                                    &hLocationKey
                                   );
                if (dwError == ERROR_SUCCESS)
                {
                    // Preferred Card ID
                    dwDataSize = sizeof(DWORD);
                    if(RegQueryValueEx(
                                   hLocationKey,
                                   gszCallingCard,
                                   0,
                                   &dwDataType,
                                   (LPBYTE)&pLocation->dwPreferredCardID,
                                   &dwDataSize
                                 ) != ERROR_SUCCESS)
                    {
                        LOG((TL_ERROR, "location - can't read users PreferredCardID"));
                    }
    
                    RegCloseKey( hLocationKey );   // Don't need this key anymore...
                }
                else
                {
        
                    LOG((TL_ERROR, "location - can't read users location key"));
                }
            }
        }
    }

    *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pLocationList->dwUsedSize;

    RegCloseKey(hAllLocationsKey);
    if (hUserAllLocationsKey)
    {
        RegCloseKey(hUserAllLocationsKey);
    }

CLEANUP_ERROR:

#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "TReadLocations: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "TReadLocations: exit, result=x%x",
            pParams->lResult
            ));
#endif

    if (bRelMutex && hProvidersMutex)
    {
        ReleaseMutex (hProvidersMutex);
        CloseHandle (hProvidersMutex);
    }

    return;
}


void
WINAPI
LReceiveMSPData(
    PTCLIENT                    ptClient,
    PLINERECEIVEMSPDATA_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    TSPIPROC        pfnTSPI_lineReceiveMSPData;
    PTPROVIDER      ptProvider;
    PTLINECLIENT    ptLineClient;
    PTCALLCLIENT    ptCallClient = NULL;
    HDRVMSPLINE     hdMSPLine;
    HDRVCALL        hdCall;
    HDRVLINE        hdLine;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwBufferSize,
            pParams->dwBufferOffset,
            sizeof(DWORD),
            "LReceiveMSPData",
            "pParams->Buffer"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }

    if (!(ptLineClient = ReferenceObject(
            ghHandleTable,
            pParams->hLine,
            TLINECLIENT_KEY
            )))
    {
        pParams->lResult = LINEERR_INVALLINEHANDLE;
        return;
    }

    if (pParams->hCall)
    {
        if (!(ptCallClient = ReferenceObject(
                ghHandleTable,
                pParams->hCall,
                TCALLCLIENT_KEY
                )))
        {
            DereferenceObject (ghHandleTable, pParams->hLine, 1);
            pParams->lResult = LINEERR_INVALCALLHANDLE;
            return;
        }
    }
    
    hdMSPLine = ptLineClient->hdMSPLine;

    try
    {
        hdLine = ptLineClient->ptLine->hdLine;
        ptProvider = ptLineClient->ptLine->ptProvider;

        hdCall = (ptCallClient ? ptCallClient->ptCall->hdCall : 0);

        if (ptLineClient->dwKey != TLINECLIENT_KEY)
        {
            pParams->lResult = LINEERR_INVALLINEHANDLE;
        }
    }
    myexcept
    {
        pParams->lResult = LINEERR_INVALCALLHANDLE;
    }

    DereferenceObject (ghHandleTable, pParams->hLine, 1);
    
    if (ptCallClient)
    {
        DereferenceObject (ghHandleTable, pParams->hCall, 1);
    }

    if (pParams->lResult == 0)
    {
        if ((pfnTSPI_lineReceiveMSPData =
                ptProvider->apfn[SP_LINERECEIVEMSPDATA]))
        {
         PBYTE pTemp = pDataBuf + pParams->dwBufferOffset;
#ifdef _WIN64
            if (!(ALIGNED (pTemp)))
            {
                pTemp = ServerAlloc (pParams->dwBufferSize);
                if (NULL == pTemp)
                {
                    pParams->lResult = LINEERR_NOMEM;
                    goto LReceiveMSPData_Return;
                }

                CopyMemory (pTemp, pDataBuf + pParams->dwBufferOffset, pParams->dwBufferSize);
            }
#endif //_WIN64
            pParams->lResult = CallSP5(
                pfnTSPI_lineReceiveMSPData,
                "lineReceiveMSPData",
                SP_FUNC_SYNC,
                (ULONG_PTR) hdLine,
                (ULONG_PTR) hdCall,
                (ULONG_PTR) hdMSPLine,
                (ULONG_PTR) pTemp,
                (DWORD) pParams->dwBufferSize
                );
#ifdef _WIN64
            if (pTemp != pDataBuf + pParams->dwBufferOffset)
            {
                ServerFree (pTemp);
            }
#endif //_WIN64
        }
        else
        {
            pParams->lResult = LINEERR_OPERATIONUNAVAIL;
        }
    }

#ifdef _WIN64
LReceiveMSPData_Return:
#endif //_WIN64
    {
        char szResult[32];

#if DBG
        LOG((TL_TRACE, 
            "ReceiveMSPData: exit, result=%s",
            MapResultCodeToText (pParams->lResult, szResult)
            ));
#else
        LOG((TL_TRACE, 
            "ReceiveMSPData: exit, result=x%x",
            pParams->lResult
            ));
#endif //DBG
    }
}

void
WINAPI
LMSPIdentify(
    PTCLIENT                ptClient,
    PLINEMSPIDENTIFY_PARAMS pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    DWORD               dwDeviceID = pParams->dwDeviceID;
    HANDLE              hMutex;
    TSPIPROC            pfnTSPI_lineMSPIdentify;
    DWORD               objectToDereference;
    PTLINELOOKUPENTRY   pLookupEntry;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (dwParamsBufferSize < sizeof (GUID))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            DEVICE_ID,                  // widget type
            0,                          // client widget handle
            (LPVOID) &dwDeviceID,       // provider widget handle
            pParams->dwDeviceID,        // privileges or deviceID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_LINEMSPIDENTIFY,         // provider func index
            &pfnTSPI_lineMSPIdentify,   // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &pLookupEntry,              // context
            "MSPIdentify"               // func name

            )) == 0)
    {
        if ((pParams->lResult = CallSP2(
                pfnTSPI_lineMSPIdentify,
                "lineMSPIdentify",
                SP_FUNC_SYNC,
                (DWORD) dwDeviceID,
                (ULONG_PTR) pDataBuf

                )) == 0)
        {
            
            
            pParams->dwCLSIDOffset = 0;

            pParams->dwCLSIDSize = sizeof (GUID);

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pParams->dwCLSIDSize;
        }
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "MSPIdentify"
        );
}


void
WINAPI
PrivateFactoryIdentify(
    PTCLIENT                        ptClient,
    PPRIVATEFACTORYIDENTIFY_PARAMS  pParams,
    DWORD                           dwParamsBufferSize,
    LPBYTE                          pDataBuf,
    LPDWORD                         pdwNumBytesReturned
    )
{
    BOOL                bCloseMutex;
    DWORD               dwDeviceID = pParams->dwDeviceID;
    HANDLE              hMutex;
    TSPIPROC            pfnTSPI_providerPrivateFactoryIdentify;
    DWORD               objectToDereference;
    PTLINELOOKUPENTRY   pLookupEntry;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (dwParamsBufferSize < sizeof (GUID))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if ((pParams->lResult = LINEPROLOG(
            ptClient,          // tClient
            DEVICE_ID,                  // widget type
            0,                          // client widget handle
            (LPVOID) &dwDeviceID,       // provider widget handle
            pParams->dwDeviceID,        // privileges or deviceID
            &hMutex,                    // mutex handle
            &bCloseMutex,               // close hMutex when finished
            SP_PROVIDERPRIVATEFACTORYIDENTIFY,          // provider func index
            &pfnTSPI_providerPrivateFactoryIdentify,    // provider func pointer
            NULL,                       // async request info
            0,                          // client async request ID
            &objectToDereference,       // object to dereference
            &pLookupEntry,              // context
            "PrivateFactoryIdentify"    // func name

            )) == 0)
    {
        if ((pParams->lResult = CallSP2(
                pfnTSPI_providerPrivateFactoryIdentify,
                "providerPrivateFactoryIdentify",
                SP_FUNC_SYNC,
                (DWORD) dwDeviceID,
                (ULONG_PTR) pDataBuf

                )) == 0)
        {
            pParams->dwCLSIDOffset = 0;

            pParams->dwCLSIDSize = sizeof (GUID);

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pParams->dwCLSIDSize;
        }
    }

    LINEEPILOGSYNC(
        &pParams->lResult,
        hMutex,
        bCloseMutex,
        objectToDereference,
        "PrivateFactoryIdentify"
        );
}

LPBYTE 
NewToOldLineforwardlist( 
    LPLINEFORWARDLIST pFwdList3_1 
    )
{

    DWORD           dwOffset3_0, dwOffset3_1, i;
    DWORD           dwTotalSize;
    DWORD           dwSizeofLFwdList3_0 = sizeof (LINEFORWARDLIST) - 2 * sizeof(DWORD);
    DWORD           dwSizeofLFwd3_0     = sizeof (LINEFORWARD) - 2 * sizeof(DWORD);
    LPLINEFORWARD   pFwdEntry3_1        = NULL;
    LPBYTE          pFwdEntry3_0        = NULL;
    LPBYTE          pFwdList3_0         = NULL;

    //
    // Alloc a buffer for storing the converted FORWARDLIST
    //

    dwTotalSize = pFwdList3_1->dwTotalSize - 2 * sizeof(DWORD) * pFwdList3_1->dwNumEntries;
    pFwdList3_0 = ServerAlloc (dwTotalSize);
    if (!pFwdList3_0)
        return NULL;
    memset (pFwdList3_0, 0, dwTotalSize);


    ((LPLINEFORWARDLIST)pFwdList3_0)->dwTotalSize = dwTotalSize;
    ((LPLINEFORWARDLIST)pFwdList3_0)->dwNumEntries = pFwdList3_1->dwNumEntries;


    dwOffset3_1 = sizeof (LINEFORWARDLIST) +
                    (pFwdList3_1->dwNumEntries - 1) * sizeof (LINEFORWARD);

    dwOffset3_0 = dwSizeofLFwdList3_0 + 
                    (pFwdList3_1->dwNumEntries - 1) * dwSizeofLFwd3_0;


    CopyMemory (pFwdList3_0 + dwOffset3_0, (LPBYTE)pFwdList3_1 + dwOffset3_1, 
                    pFwdList3_1->dwTotalSize - dwOffset3_1);

    pFwdEntry3_1 = pFwdList3_1->ForwardList;
    pFwdEntry3_0 = (LPBYTE)((LPLINEFORWARDLIST)pFwdList3_0)->ForwardList;

    for (i = 0; i < pFwdList3_1->dwNumEntries; i++, pFwdEntry3_1++)
    {
        CopyMemory (pFwdEntry3_0, pFwdEntry3_1, dwSizeofLFwd3_0);

        if (pFwdEntry3_1->dwCallerAddressSize)
        {
            ((LPLINEFORWARD)pFwdEntry3_0)->dwCallerAddressOffset = 
                pFwdEntry3_1->dwCallerAddressOffset - 2 * sizeof(DWORD) * pFwdList3_1->dwNumEntries;
        }

        if (pFwdEntry3_1->dwDestAddressSize)
        {
            ((LPLINEFORWARD)pFwdEntry3_0)->dwDestAddressOffset = 
                pFwdEntry3_1->dwDestAddressOffset - 2 * sizeof(DWORD) * pFwdList3_1->dwNumEntries;
        }

        pFwdEntry3_0 += dwSizeofLFwd3_0;
                
    }

    return pFwdList3_0;
  
}

LPLINEFORWARDLIST 
OldToNewLineforwardlist( 
    LPLINEFORWARDLIST pFwdList3_0 
    )
{

    DWORD               dwOffset3_0, dwOffset3_1, i;
    DWORD               dwSizeofLFwdList3_0 = sizeof (LINEFORWARDLIST) - 2 * sizeof(DWORD);
    DWORD               dwSizeofLFwd3_0     = sizeof (LINEFORWARD) - 2 * sizeof(DWORD);
    DWORD               dwTotalSize;
    LPLINEFORWARD       pFwdEntry3_1        = NULL;
    LPBYTE              pFwdEntry3_0        = NULL;
    LPLINEFORWARDLIST   pFwdList3_1         = NULL;

    //
    // Alloc a buffer for storing the converted FORWARDLIST
    //

    dwTotalSize = pFwdList3_0->dwTotalSize + 2 * sizeof(DWORD) * pFwdList3_0->dwNumEntries;
    pFwdList3_1 = ServerAlloc (dwTotalSize);
    if (!pFwdList3_1)
        return NULL;
    memset (pFwdList3_1, 0, dwTotalSize);


    pFwdList3_1->dwTotalSize = dwTotalSize;
    pFwdList3_1->dwNumEntries = pFwdList3_0->dwNumEntries;


    dwOffset3_1 = sizeof (LINEFORWARDLIST) +
                    (pFwdList3_0->dwNumEntries - 1) * sizeof (LINEFORWARD);

    dwOffset3_0 = dwSizeofLFwdList3_0 + 
                    (pFwdList3_0->dwNumEntries - 1) * dwSizeofLFwd3_0;


    CopyMemory ((LPBYTE)pFwdList3_1 + dwOffset3_1, (LPBYTE)pFwdList3_0 + dwOffset3_0, 
                    pFwdList3_0->dwTotalSize - dwOffset3_0);

    pFwdEntry3_1 = pFwdList3_1->ForwardList;
    pFwdEntry3_0 = (LPBYTE)(pFwdList3_0->ForwardList);

    for (i = 0; i < pFwdList3_0->dwNumEntries; i++, pFwdEntry3_1++)
    {
        CopyMemory (pFwdEntry3_1, pFwdEntry3_0, dwSizeofLFwd3_0);

        if ( ((LPLINEFORWARD)pFwdEntry3_0)->dwCallerAddressSize )
        {
            pFwdEntry3_1->dwCallerAddressOffset = 
                ((LPLINEFORWARD)pFwdEntry3_0)->dwCallerAddressOffset + 
                2 * sizeof(DWORD) * pFwdList3_0->dwNumEntries;
        }

        if ( ((LPLINEFORWARD)pFwdEntry3_0)->dwDestAddressSize )
        {
            pFwdEntry3_1->dwDestAddressOffset = 
                ((LPLINEFORWARD)pFwdEntry3_0)->dwDestAddressOffset +
                2 * sizeof(DWORD) * pFwdList3_0->dwNumEntries;
        }

        pFwdEntry3_0 += dwSizeofLFwd3_0;
    }

    return pFwdList3_1;
  
}


LPWSTR WaveDeviceIdToStringId(DWORD dwDeviceId, LPWSTR pwszDeviceType)
{
    LPWSTR pwszStringID = NULL;
    DWORD       dwSize;
    DWORD_PTR   dwParam;

    if (!pwszDeviceType)
        return NULL;

    do 
    {
        if ( !_wcsicmp(pwszDeviceType, L"wave/in") )
        {
            HWAVEIN     hWaveIn;

            *(DWORD_PTR*)&hWaveIn = dwDeviceId;

            // get the needed size
            if (MMSYSERR_NOERROR != waveInMessage(
                                    hWaveIn,
                                    DRV_QUERYSTRINGIDSIZE,
                                    (DWORD_PTR)&dwSize,
                                    0))
                break;

            assert (dwSize != 0);
            pwszStringID = ServerAlloc (dwSize);
            if(!pwszStringID)
                break;

            dwParam = dwSize;
            // get the wave string ID
            if (MMSYSERR_NOERROR != waveInMessage(
                                    hWaveIn,
                                    DRV_QUERYSTRINGID,
                                    (DWORD_PTR)pwszStringID,
                                    dwParam))
            {
                ServerFree(pwszStringID);
                pwszStringID = NULL;
            }

        } else if (!_wcsicmp(pwszDeviceType, L"wave/out"))
        {
            HWAVEOUT     hWaveOut;
            *(DWORD_PTR*)&hWaveOut = dwDeviceId;

            // get the needed size
            if (MMSYSERR_NOERROR != waveOutMessage(
                                    hWaveOut,
                                    DRV_QUERYSTRINGIDSIZE,
                                    (DWORD_PTR)&dwSize,
                                    0))
                break;

            assert (dwSize != 0);
            pwszStringID = ServerAlloc (dwSize);
            if(!pwszStringID)
                break;

            dwParam = dwSize;
            // get the wave string ID
            if (MMSYSERR_NOERROR != waveOutMessage(
                                    hWaveOut,
                                    DRV_QUERYSTRINGID,
                                    (DWORD_PTR)pwszStringID,
                                    dwParam))
            {
                ServerFree(pwszStringID);
                pwszStringID = NULL;
            }
        } else if (!_wcsicmp(pwszDeviceType, L"midi/in"))
        {
            HMIDIIN     hMidiIn;
            *(DWORD_PTR*)&hMidiIn = dwDeviceId;

            // get the needed size
            if (MMSYSERR_NOERROR != midiInMessage(
                                    hMidiIn,
                                    DRV_QUERYSTRINGIDSIZE,
                                    (DWORD_PTR)&dwSize,
                                    0))
                break;

            assert (dwSize != 0);
            pwszStringID = ServerAlloc (dwSize);
            if(!pwszStringID)
                break;

            dwParam = dwSize;
            // get the wave string ID
            if (MMSYSERR_NOERROR != midiInMessage(
                                    hMidiIn,
                                    DRV_QUERYSTRINGID,
                                    (DWORD_PTR)pwszStringID,
                                    dwParam))
            {
                ServerFree(pwszStringID);
                pwszStringID = NULL;
            }
        }  else if (!_wcsicmp(pwszDeviceType, L"midi/out"))
        {
            HMIDIOUT     hMidiOut;
            *(DWORD_PTR*)&hMidiOut = dwDeviceId;

            // get the needed size
            if (MMSYSERR_NOERROR != midiOutMessage(
                                    hMidiOut,
                                    DRV_QUERYSTRINGIDSIZE,
                                    (DWORD_PTR)&dwSize,
                                    0))
                break;

            assert (dwSize != 0);
            pwszStringID = ServerAlloc (dwSize);
            if(!pwszStringID)
                break;

            dwParam = dwSize;
            // get the wave string ID
            if (MMSYSERR_NOERROR != midiOutMessage(
                                    hMidiOut,
                                    DRV_QUERYSTRINGID,
                                    (DWORD_PTR)pwszStringID,
                                    dwParam))
            {
                ServerFree(pwszStringID);
                pwszStringID = NULL;
            }
        } 

    } while (0);

    return pwszStringID;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\server\server.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1995-1998  Microsoft Corporation

Module Name:

    server.c

Abstract:

    Src module for tapi server

Author:

    Dan Knudson (DanKn)    01-Apr-1995

Revision History:

--*/

#include "windows.h"
#include "stdio.h"
#include "stdlib.h"
#include "tchar.h"
#include "assert.h"
#include "process.h"
#include "winsvcp.h"
#include "tapi.h"
#include "tspi.h"
#include "utils.h"
#include "client.h"
#include "server.h"

#define INIT_FUNCTABLE
#include "private.h"
#undef  INIT_FUNCTABLE

#include "tapsrv.h"
#include "tapiperf.h"
#include "winnetwk.h"
#include "buffer.h"
#include "line.h"
#include "tapihndl.h"
#include <tchar.h>
#include "loc_comn.h"
#include "tapimmc.h"
#include "resource.h"


// 
// Bit flags to tell ServiceShutdown how much of the service has been initialized
//
#define SERVICE_INIT_TRACELOG               0x00000001
#define SERVICE_INIT_SCM_REGISTERED         0x00000002
#define SERVICE_INIT_LOCKTABLE              0x00000004

#define SERVICE_INIT_CRITSEC_SAFEMUTEX      0x00000008
#define SERVICE_INIT_CRITSEC_REMOTECLI      0x00000010
#define SERVICE_INIT_CRITSEC_PRILIST        0x00000020
#define SERVICE_INIT_CRITSEC_MGMTDLLS       0x00000040
#define SERVICE_INIT_CRITSEC_DLLLIST        0x00000080
#define SERVICE_INIT_CRITSEC_CLIENTHND      0x00000100
#define SERVICE_INIT_CRITSEC_CNCLIENTMSG    0x00000200
#define SERVICE_INIT_CRITSEC_DGCLIENTMSG    0x00000400
#define SERVICE_INIT_CRITSEC_GLOB_CRITSEC   0x00000800
#define SERVICE_INIT_CRITSEC_GLOB_REMOTESP  0x00001000
#define SERVICE_INIT_CRITSEC_MGMT           0x00002000

#define SERVICE_INIT_SPEVENT_HANDLER        0x00004000
#define SERVICE_INIT_MANAGEMENT_DLL         0x00008000
#define SERVICE_INIT_EVENT_NOTIFICATION     0x00010000
#define SERVICE_INIT_RPC                    0x00020000

#define SERVICE_INIT_CRITSEC_SCP            0x00040000

#if DBG

BOOL    gbBreakOnLeak = FALSE;
BOOL    gfBreakOnSeriousProblems = FALSE;

void
DumpHandleList();
#endif

extern const DWORD TapiPrimes[];
const TCHAR gszRegTapisrvSCPGuid[] = TEXT("TAPISRVSCPGUID");

// PERF
PERFBLOCK   PerfBlock;
BOOL InitPerf();

TAPIGLOBALS TapiGlobals;

HANDLE ghTapisrvHeap = NULL, ghHandleTable = NULL;

HANDLE ghEventService;

HANDLE ghSCMAutostartEvent = NULL;

HANDLE ghProvRegistryMutex = NULL;

BOOL    gbPriorityListsInitialized;
BOOL    gbQueueSPEvents;
BOOL    gfWeHadAtLeastOneClient;
BOOL    gbSPEventHandlerThreadExit;
BOOL    gbNTServer;
BOOL    gbServerInited;
BOOL    gbAutostartDone = FALSE;
BOOL    gbHighSecurity = TRUE;

HINSTANCE ghInstance;

CRITICAL_SECTION    gSafeMutexCritSec,
                    gRemoteCliEventBufCritSec,
                    gPriorityListCritSec,
                    gManagementDllsCritSec,
                    gDllListCritSec,
                    gClientHandleCritSec,
                    gCnClientMsgPendingCritSec,
                    gDgClientMsgPendingCritSec,
                    gLockTableCritSecs[2],
                    gSCPCritSec;

#define MIN_WAIT_HINT 60000

DWORD   gdwServiceState = SERVICE_START_PENDING,
        gdwWaitHint = MIN_WAIT_HINT,
        gdwCheckPoint = 0,
        gdwDllIDs = 0,
        gdwRpcTimeout = 30000,
        gdwRpcRetryCount = 5,
        gdwTotalAsyncThreads = 0,
        gdwThreadsPerProcessor = 4,
        guiAlignmentFaultEnabled = FALSE,
        gdwTapiSCPTTL = 60 * 24;
        gdwServiceInitFlags = 0;
        

DWORD            gdwPointerToLockTableIndexBits;
CRITICAL_SECTION *gLockTable;
DWORD             gdwNumLockTableEntries;
BOOL             (WINAPI * pfnInitializeCriticalSectionAndSpinCount)
                     (LPCRITICAL_SECTION, DWORD);

LIST_ENTRY  CnClientMsgPendingListHead;
LIST_ENTRY  DgClientMsgPendingListHead;

SPEVENTHANDLERTHREADINFO    gSPEventHandlerThreadInfo;
PSPEVENTHANDLERTHREADINFO   aSPEventHandlerThreadInfo;
DWORD                       gdwNumSPEventHandlerThreads;
LONG                        glNumActiveSPEventHandlerThreads;

#if DBG
const TCHAR gszTapisrvDebugLevel[] = TEXT("TapiSrvDebugLevel");
const TCHAR gszBreakOnLeak[] = TEXT("BreakOnLeak");
#endif
const TCHAR gszProvider[] = TEXT("Provider");
const TCHAR gszNumLines[] = TEXT("NumLines");
const TCHAR gszUIDllName[] = TEXT("UIDllName");
const TCHAR gszNumPhones[] = TEXT("NumPhones");
const TCHAR gszSyncLevel[] = TEXT("SyncLevel");
const TCHAR gszProductType[] = TEXT("ProductType");
const TCHAR gszProductTypeServer[] = TEXT("ServerNT");
const TCHAR gszProductTypeLanmanNt[] = TEXT("LANMANNT");

const TCHAR gszProviderID[] = TEXT("ProviderID");
const TCHAR gszNumProviders[] = TEXT("NumProviders");
const TCHAR gszNextProviderID[] = TEXT("NextProviderID");
const TCHAR gszRequestMakeCallW[] = TEXT("RequestMakeCall");
const TCHAR gszRequestMediaCallW[] = TEXT("RequestMediaCall");
const TCHAR gszProviderFilename[] = TEXT("ProviderFilename");

const WCHAR gszMapperDll[] = L"MapperDll";
const WCHAR gszManagementDlls[] = L"ManagementDlls";
const WCHAR gszHighSecurity[] = L"HighSecurity";

const TCHAR gszDomainName[] = TEXT("DomainName");
const TCHAR gszRegKeyHandoffPriorities[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\HandoffPriorities");

const TCHAR gszRegKeyHandoffPrioritiesMediaModes[] = TEXT("MediaModes");

const TCHAR gszRegKeyTelephony[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony");

const TCHAR gszRegKeyProviders[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Providers");

const TCHAR gszRegKeyServer[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Server");

const TCHAR gszRegKeyNTServer[] = TEXT("System\\CurrentControlSet\\Control\\ProductOptions");


const TCHAR
    *gaszMediaModes[] =
{
    TEXT(""),
    TEXT("unknown"),
    TEXT("interactivevoice"),
    TEXT("automatedvoice"),
    TEXT("datamodem"),
    TEXT("g3fax"),
    TEXT("tdd"),
    TEXT("g4fax"),
    TEXT("digitaldata"),
    TEXT("teletex"),
    TEXT("videotex"),
    TEXT("telex"),
    TEXT("mixed"),
    TEXT("adsi"),
    TEXT("voiceview"),
    TEXT("video"),
    NULL
};

// used for GetProcAddress calls, remain as ANSI
const char *gaszTSPIFuncNames[] =
{
    "TSPI_lineAccept",
    "TSPI_lineAddToConference",
    "TSPI_lineAgentSpecific",
    "TSPI_lineAnswer",
    "TSPI_lineBlindTransfer",
    "TSPI_lineClose",
    "TSPI_lineCloseCall",
    "TSPI_lineCompleteCall",
    "TSPI_lineCompleteTransfer",
    "TSPI_lineConditionalMediaDetection",
    "TSPI_lineDevSpecific",
    "TSPI_lineDevSpecificFeature",
    "TSPI_lineDial",
    "TSPI_lineDrop",
    "TSPI_lineForward",
    "TSPI_lineGatherDigits",
    "TSPI_lineGenerateDigits",
    "TSPI_lineGenerateTone",
    "TSPI_lineGetAddressCaps",
    "TSPI_lineGetAddressID",
    "TSPI_lineGetAddressStatus",
    "TSPI_lineGetAgentActivityList",
    "TSPI_lineGetAgentCaps",
    "TSPI_lineGetAgentGroupList",
    "TSPI_lineGetAgentStatus",
    "TSPI_lineGetCallAddressID",
    "TSPI_lineGetCallInfo",
    "TSPI_lineGetCallStatus",
    "TSPI_lineGetDevCaps",
    "TSPI_lineGetDevConfig",
    "TSPI_lineGetExtensionID",
    "TSPI_lineGetIcon",
    "TSPI_lineGetID",
    "TSPI_lineGetLineDevStatus",
    "TSPI_lineGetNumAddressIDs",
    "TSPI_lineHold",
    "TSPI_lineMakeCall",
    "TSPI_lineMonitorDigits",
    "TSPI_lineMonitorMedia",
    "TSPI_lineMonitorTones",
    "TSPI_lineNegotiateExtVersion",
    "TSPI_lineNegotiateTSPIVersion",
    "TSPI_lineOpen",
    "TSPI_linePark",
    "TSPI_linePickup",
    "TSPI_linePrepareAddToConference",
    "TSPI_lineRedirect",
    "TSPI_lineReleaseUserUserInfo",
    "TSPI_lineRemoveFromConference",
    "TSPI_lineSecureCall",
    "TSPI_lineSelectExtVersion",
    "TSPI_lineSendUserUserInfo",
    "TSPI_lineSetAgentActivity",
    "TSPI_lineSetAgentGroup",
    "TSPI_lineSetAgentState",
    "TSPI_lineSetAppSpecific",
    "TSPI_lineSetCallData",
    "TSPI_lineSetCallParams",
    "TSPI_lineSetCallQualityOfService",
    "TSPI_lineSetCallTreatment",
    "TSPI_lineSetCurrentLocation",
    "TSPI_lineSetDefaultMediaDetection",
    "TSPI_lineSetDevConfig",
    "TSPI_lineSetLineDevStatus",
    "TSPI_lineSetMediaControl",
    "TSPI_lineSetMediaMode",
    "TSPI_lineSetStatusMessages",
    "TSPI_lineSetTerminal",
    "TSPI_lineSetupConference",
    "TSPI_lineSetupTransfer",
    "TSPI_lineSwapHold",
    "TSPI_lineUncompleteCall",
    "TSPI_lineUnhold",
    "TSPI_lineUnpark",
    "TSPI_phoneClose",
    "TSPI_phoneDevSpecific",
    "TSPI_phoneGetButtonInfo",
    "TSPI_phoneGetData",
    "TSPI_phoneGetDevCaps",
    "TSPI_phoneGetDisplay",
    "TSPI_phoneGetExtensionID",
    "TSPI_phoneGetGain",
    "TSPI_phoneGetHookSwitch",
    "TSPI_phoneGetIcon",
    "TSPI_phoneGetID",
    "TSPI_phoneGetLamp",
    "TSPI_phoneGetRing",
    "TSPI_phoneGetStatus",
    "TSPI_phoneGetVolume",
    "TSPI_phoneNegotiateExtVersion",
    "TSPI_phoneNegotiateTSPIVersion",
    "TSPI_phoneOpen",
    "TSPI_phoneSelectExtVersion",
    "TSPI_phoneSetButtonInfo",
    "TSPI_phoneSetData",
    "TSPI_phoneSetDisplay",
    "TSPI_phoneSetGain",
    "TSPI_phoneSetHookSwitch",
    "TSPI_phoneSetLamp",
    "TSPI_phoneSetRing",
    "TSPI_phoneSetStatusMessages",
    "TSPI_phoneSetVolume",
    "TSPI_providerCreateLineDevice",
    "TSPI_providerCreatePhoneDevice",
    "TSPI_providerEnumDevices",
    "TSPI_providerFreeDialogInstance",
    "TSPI_providerGenericDialogData",
    "TSPI_providerInit",
    "TSPI_providerShutdown",
    "TSPI_providerUIIdentify",
    "TSPI_lineMSPIdentify",
    "TSPI_lineReceiveMSPData",
    "TSPI_providerCheckForNewUser",
    "TSPI_lineGetCallIDs",
    "TSPI_lineGetCallHubTracking",
    "TSPI_lineSetCallHubTracking",
    "TSPI_providerPrivateFactoryIdentify",
    "TSPI_lineDevSpecificEx",
    "TSPI_lineCreateAgent",
    "TSPI_lineCreateAgentSession",
    "TSPI_lineGetAgentInfo",
    "TSPI_lineGetAgentSessionInfo",
    "TSPI_lineGetAgentSessionList",
    "TSPI_lineGetQueueInfo",
    "TSPI_lineGetGroupList",
    "TSPI_lineGetQueueList",
    "TSPI_lineSetAgentMeasurementPeriod",
    "TSPI_lineSetAgentSessionState",
    "TSPI_lineSetQueueMeasurementPeriod",
    "TSPI_lineSetAgentStateEx",
    "TSPI_lineGetProxyStatus",
    "TSPI_lineCreateMSPInstance",
    "TSPI_lineCloseMSPInstance",
    NULL
};

// used for GetProcAddress calls, remain as ANSI
const char *gaszTCFuncNames[] =
{
    "TAPICLIENT_Load",
    "TAPICLIENT_Free",
    "TAPICLIENT_ClientInitialize",
    "TAPICLIENT_ClientShutdown",
    "TAPICLIENT_GetDeviceAccess",
    "TAPICLIENT_LineAddToConference",
    "TAPICLIENT_LineBlindTransfer",
    "TAPICLIENT_LineConfigDialog",
    "TAPICLIENT_LineDial",
    "TAPICLIENT_LineForward",
    "TAPICLIENT_LineGenerateDigits",
    "TAPICLIENT_LineMakeCall",
    "TAPICLIENT_LineOpen",
    "TAPICLIENT_LineRedirect",
    "TAPICLIENT_LineSetCallData",
    "TAPICLIENT_LineSetCallParams",
    "TAPICLIENT_LineSetCallPrivilege",
    "TAPICLIENT_LineSetCallTreatment",
    "TAPICLIENT_LineSetCurrentLocation",
    "TAPICLIENT_LineSetDevConfig",
    "TAPICLIENT_LineSetLineDevStatus",
    "TAPICLIENT_LineSetMediaControl",
    "TAPICLIENT_LineSetMediaMode",
    "TAPICLIENT_LineSetTerminal",
    "TAPICLIENT_LineSetTollList",
    "TAPICLIENT_PhoneConfigDialog",
    "TAPICLIENT_PhoneOpen",
    NULL
};

PTPROVIDER pRemoteSP;

extern WCHAR gszTapiAdministrators[];
extern WCHAR gszFileName[];
extern WCHAR gszLines[];
extern WCHAR gszPhones[];
extern WCHAR gszEmptyString[];
extern LPLINECOUNTRYLIST    gpCountryList;
extern LPDEVICEINFOLIST     gpLineInfoList;
extern LPDEVICEINFOLIST     gpPhoneInfoList;
extern LPDWORD              gpLineDevFlags;
extern DWORD                gdwNumFlags;
extern FILETIME             gftLineLastWrite;
extern FILETIME             gftPhoneLastWrite;
extern CRITICAL_SECTION     gMgmtCritSec;
extern BOOL                 gbLockMMCWrite;


#define POINTERTOTABLEINDEX(p) \
            ((((ULONG_PTR) p) >> 4) & gdwPointerToLockTableIndexBits)

#define LOCKTCLIENT(p) \
            EnterCriticalSection(&gLockTable[POINTERTOTABLEINDEX(p)])

#define UNLOCKTCLIENT(p) \
            LeaveCriticalSection(&gLockTable[POINTERTOTABLEINDEX(p)])

#if DBG
DWORD   gdwDebugLevel;
DWORD   gdwQueueDebugLevel = 0;
#endif

typedef struct
{
    DWORD           dwTickCount;

    PTCLIENT        ptClient;

} WATCHDOGSTRUCT, *PWATCHDOGSTRUCT;

struct
{
    PHANDLE         phThreads;

    DWORD           dwNumThreads;

    PWATCHDOGSTRUCT pWatchDogStruct;

    HANDLE          hEvent;

    BOOL            bExit;

} gEventNotificationThreadParams;

struct
{
    LONG    lCookie;

    LONG    lNumRundowns;

    BOOL    bIgnoreRundowns;

} gRundownLock;

BOOL VerifyDomainName (HKEY hKey);

void
EventNotificationThread(
    LPVOID  pParams
    );

VOID
WINAPI
ServiceMain (
    DWORD   dwArgc,
    PWSTR*  lpszArgv
    );

void
PASCAL
LineEventProc(
    HTAPILINE   htLine,
    HTAPICALL   htCall,
    DWORD       dwMsg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    );

void
CALLBACK
LineEventProcSP(
    HTAPILINE   htLine,
    HTAPICALL   htCall,
    DWORD       dwMsg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    );

void
PASCAL
PhoneEventProc(
    HTAPIPHONE  htPhone,
    DWORD       dwMsg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    );

void
CALLBACK
PhoneEventProcSP(
    HTAPIPHONE  htPhone,
    DWORD       dwMsg,
    ULONG_PTR   Param1,
    ULONG_PTR   Param2,
    ULONG_PTR   Param3
    );

PTLINELOOKUPENTRY
GetLineLookupEntry(
    DWORD   dwDeviceID
    );

PTPHONELOOKUPENTRY
GetPhoneLookupEntry(
    DWORD   dwDeviceID
    );

char *
PASCAL
MapResultCodeToText(
    LONG    lResult,
    char   *pszResult
    );

DWORD
InitSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID * ppSid,
    PACL * ppDacl
    );

void
PASCAL
GetMediaModesPriorityLists(
    HKEY hKeyHandoffPriorities,
    PRILISTSTRUCT ** ppList
    );

void
PASCAL
GetPriorityList(
    HKEY    hKeyHandoffPriorities,
    const TCHAR  *pszListName,
    WCHAR **ppszPriorityList
    );

void
PASCAL
SetMediaModesPriorityList(
    HKEY hKeyPri,
    PRILISTSTRUCT * pPriListStruct
    );

void
PASCAL
SetPriorityList(
    HKEY    hKeyHandoffPriorities,
    const   TCHAR  *pszListName,
    WCHAR  *pszPriorityList
    );

void
SPEventHandlerThread(
    PSPEVENTHANDLERTHREADINFO   pInfo
    );

PTCLIENT
PASCAL
WaitForExclusiveClientAccess(
    PTCLIENT    ptClient
    );

BOOL
IsNTServer(
    void
    );

void
CleanUpManagementMemory(
    );

#if TELE_SERVER

void
ReadAndInitMapper();

void
ReadAndInitManagementDlls();

void
ManagementProc(
    LONG l
    );

void
GetManageDllListPointer(
    PTMANAGEDLLLISTHEADER * ppDllList
    );

void
FreeManageDllListPointer(
    PTMANAGEDLLLISTHEADER pDllList
    );

BOOL
GetTCClient(
    PTMANAGEDLLINFO       pDll,
    PTCLIENT              ptClient,
    DWORD                 dwAPI,
    HMANAGEMENTCLIENT    *phClient
    );
#endif

LRESULT
UpdateLastWriteTime (
    BOOL                        bLine
    );

LRESULT
BuildDeviceInfoList(
    BOOL                        bLine
    );

BOOL
CleanUpClient(
    PTCLIENT ptClient,
    BOOL     bRundown
    );

void
PASCAL
SendReinitMsgToAllXxxApps(
    void
    );

LONG
AppendNewDeviceInfo (
    BOOL                        bLine,
    DWORD                       dwDeviceID
    );

DWORD
PASCAL
MyInitializeCriticalSection(
    LPCRITICAL_SECTION  pCriticalSection,
    DWORD               dwSpinCount
    )
{
    DWORD dwRet = 0;

    __try
    {
        if (pfnInitializeCriticalSectionAndSpinCount)
        {
            (*pfnInitializeCriticalSectionAndSpinCount)(
                pCriticalSection,
                dwSpinCount
                );
        }
        else
        {
            InitializeCriticalSection (pCriticalSection);
        }
    }
    __except (EXCEPTION_EXECUTE_HANDLER)
    {
        dwRet = GetExceptionCode();
    }

    return dwRet;
}

BOOL
WINAPI
DllMain (
    HINSTANCE   hinst,
    DWORD       dwReason,
    LPVOID      pvReserved)
{
	switch (dwReason) {
		case DLL_PROCESS_ATTACH:
		{
			ghInstance = hinst;
			DisableThreadLibraryCalls (hinst);
			break;
		}
		case DLL_PROCESS_DETACH:
		{
			break;
		}
	}
    return TRUE;
}

BOOL
ReportStatusToSCMgr(
    DWORD dwCurrentState,
    DWORD dwWin32ExitCode,
    DWORD dwCheckPoint,
    DWORD dwWaitHint
    )
{
    SERVICE_STATUS  ssStatus;

    if (!TapiGlobals.sshStatusHandle)
    {
        LOG((TL_ERROR, "sshStatusHandle is NULL in ReportStatusToSCMgr"));
        return FALSE;
    }

    ssStatus.dwServiceType             = SERVICE_WIN32_SHARE_PROCESS;
    ssStatus.dwCurrentState            = dwCurrentState;
    ssStatus.dwControlsAccepted        = SERVICE_ACCEPT_STOP |
                                         SERVICE_ACCEPT_PAUSE_CONTINUE;
    ssStatus.dwWin32ExitCode           = dwWin32ExitCode;
    ssStatus.dwServiceSpecificExitCode = 0;
    ssStatus.dwCheckPoint              = dwCheckPoint;
    ssStatus.dwWaitHint                = dwWaitHint;

    SetServiceStatus (TapiGlobals.sshStatusHandle, &ssStatus);

    return TRUE;
}

VOID
ServiceControl(
    DWORD dwCtrlCode
    )
{
    LOG((TL_INFO, "Service control code=%ld", dwCtrlCode ));

    if ( SERVICE_CONTROL_STOP == dwCtrlCode ||
         SERVICE_CONTROL_SHUTDOWN == dwCtrlCode )
    {
        //
        // This service was stopped - alert any active apps, allowing
        // a little extra time for msg processing
        //

        LOG((TL_TRACE,  "Somebody did a 'NET STOP TAPISRV'... exiting..."));

        SendReinitMsgToAllXxxApps();

        ReportStatusToSCMgr(
            gdwServiceState = SERVICE_STOP_PENDING,
            NO_ERROR,
            (gdwCheckPoint = 0),
            4000
            );

        Sleep (4000);

        LOG((TL_TRACE,  "ServiceControl: calling RpcServerUnregisterIf"));
        RpcServerUnregisterIf (tapsrv_ServerIfHandle, NULL, TRUE);
        if (ghEventService)
        {
            SetEvent (ghEventService);
        }

        return;
    }


    if ( SERVICE_CONTROL_PAUSE == dwCtrlCode )
    {
        LOG((TL_TRACE, 
			"Somebody did a 'NET PAUSE TAPISRV'... not allowing new clients..."
            ));

        TapiGlobals.dwFlags |= TAPIGLOBALS_PAUSED;

        ReportStatusToSCMgr(
            gdwServiceState = SERVICE_PAUSED,
            NO_ERROR,
            (gdwCheckPoint = 0),
            0
            );

        return;
    }


    if ( SERVICE_CONTROL_CONTINUE == dwCtrlCode )
    {
        LOG((TL_TRACE, 
            "Somebody did a 'NET CONTINUE TAPISRV'... allowing new clients..."
            ));

        TapiGlobals.dwFlags &= ~(TAPIGLOBALS_PAUSED);

        ReportStatusToSCMgr(
            gdwServiceState = SERVICE_RUNNING,
            NO_ERROR,
            (gdwCheckPoint = 0),
            0
            );

        return;
    }


    switch (gdwServiceState)
    {
    case SERVICE_START_PENDING:
    case SERVICE_STOP_PENDING:

        ReportStatusToSCMgr(
            gdwServiceState,
            NO_ERROR,
            ++gdwCheckPoint,
            gdwWaitHint
            );

        break;

    default:

        ReportStatusToSCMgr(
            gdwServiceState,
            NO_ERROR,
            0,
            0
            );

        break;
    }
}


VOID
CALLBACK
FreeContextCallback(
    LPVOID      Context,
    LPVOID      Context2
    )
{
    if (Context2)
    {
        //
        // Special case: Context is a "fast" ptCallClient, that is
        // a TCALLCLIENT embedded within a TCALL structure, so don't
        // free it
        //
    }
    else
    {
        //
        // The general case, Context is the pointer to free
        //

        ServerFree (Context);
    }
}

#define DEFAULTRPCMINCALLS         1
#define DEFAULTRPCMAXCALLS         500
#define RPCMAXMAX                  20000
#define RPCMINMAX                  1000

typedef struct _SERVICE_SHUTDOWN_PARAMS {
    HANDLE              hThreadMgmt;
    PSID                psid;
    PACL                pdacl;
} SERVICE_SHUTDOWN_PARAMS;

VOID CALLBACK ServiceShutdown (
    PVOID       lpParam,
    BOOLEAN     fTimeOut
    );


VOID
WINAPI
ServiceMain (
    DWORD   dwArgc,
    PWSTR*  lpszArgv
    )
{
    DWORD   dwMinCalls, dwMaxCalls, i;
    HANDLE  hThreadMgmt = NULL;
    BOOL    bFatalError = FALSE;

    assert(gdwServiceInitFlags == 0);

    gdwServiceInitFlags = 0;

    TRACELOGREGISTER(_T("tapisrv"));
    gdwServiceInitFlags |= SERVICE_INIT_TRACELOG ;

    //
    // Initialize globals
    //

    ZeroMemory (&TapiGlobals, sizeof (TAPIGLOBALS));
    TapiGlobals.ulPermMasks = EM_ALL;
    TapiGlobals.hProcess = GetCurrentProcess();
    TapiGlobals.hLineIcon = LoadIcon (ghInstance, MAKEINTRESOURCE(IDI_LINE_ICON));
    TapiGlobals.hPhoneIcon = LoadIcon (ghInstance, MAKEINTRESOURCE(IDI_PHONE_ICON));
    gbPriorityListsInitialized = FALSE;
    gbQueueSPEvents = FALSE;
    gfWeHadAtLeastOneClient = FALSE;
    CnClientMsgPendingListHead.Flink =
    CnClientMsgPendingListHead.Blink = &CnClientMsgPendingListHead;
    DgClientMsgPendingListHead.Flink =
    DgClientMsgPendingListHead.Blink = &DgClientMsgPendingListHead;
    gdwNumSPEventHandlerThreads = 0;
    glNumActiveSPEventHandlerThreads = 0;
    pRemoteSP = (PTPROVIDER) NULL;
    gbSPEventHandlerThreadExit = FALSE;
    gRundownLock.lCookie = 0;
    gRundownLock.lNumRundowns = 0;
    gLockTable = NULL;
    gdwNumLockTableEntries = 0;
    gpCountryList = NULL;
    gpLineInfoList = NULL;
    gpPhoneInfoList = NULL;
    gpLineDevFlags = NULL;
    gdwNumFlags = 0;
    gbLockMMCWrite = FALSE;
    gdwServiceState = SERVICE_START_PENDING,
    gdwWaitHint = MIN_WAIT_HINT,
    gdwCheckPoint = 0,
    gdwDllIDs = 0,
    gdwRpcRetryCount = 5,
    gdwTotalAsyncThreads = 0,
    gdwThreadsPerProcessor = 4;
    gbNTServer = IsNTServer();
    ghEventService = CreateEvent(NULL, TRUE, FALSE, NULL);
    gbAutostartDone = FALSE;
#if defined(_ALPHA_)
    guiAlignmentFaultEnabled = SetErrorMode(0);
    SetErrorMode(guiAlignmentFaultEnabled);
    guiAlignmentFaultEnabled = !(guiAlignmentFaultEnabled 
        & SEM_NOALIGNMENTFAULTEXCEPT);
#else
    guiAlignmentFaultEnabled = 0;
#endif

    //
    // Register the service control handler & report status to sc mgr
    //

    TapiGlobals.sshStatusHandle = RegisterServiceCtrlHandler(
        TEXT("tapisrv"),
        ServiceControl
        );
    if (NULL == TapiGlobals.sshStatusHandle)
    {
        LOG((TL_TRACE,  "ServiceMain: RegisterServiceCtrlHandler failed, error x%x", 
            GetLastError() ));
        bFatalError = TRUE;
    }
    else
    {
        gdwServiceInitFlags |= SERVICE_INIT_SCM_REGISTERED;
    }

    if (!bFatalError)
    {
        ReportStatusToSCMgr(
            (gdwServiceState = SERVICE_START_PENDING),
                                   // service state
            NO_ERROR,              // exit code
            (gdwCheckPoint = 0),   // checkpoint
            gdwWaitHint            // wait hint
            );

        if (!(ghTapisrvHeap = HeapCreate (0, 0x10000, 0)))
        {
            ghTapisrvHeap = GetProcessHeap();
        }

        ghHandleTable = CreateHandleTable(
            ghTapisrvHeap,
            FreeContextCallback,
            0x10000,
            0x7fffffff
            );

        if (NULL == ghHandleTable)
        {
            LOG((TL_ERROR, "ServiceMain: CreateHandleTable failed"));
            bFatalError = TRUE;
        }
        else
        {
            InitPerf();

            (FARPROC) pfnInitializeCriticalSectionAndSpinCount = GetProcAddress(
                GetModuleHandle (TEXT("kernel32.dll")),
                "InitializeCriticalSectionAndSpinCount"
                );
    
            ghSCMAutostartEvent = OpenEvent(
                                        SYNCHRONIZE, 
                                        FALSE,
                                        SC_AUTOSTART_EVENT_NAME 
                                        );
            if (NULL == ghSCMAutostartEvent)
            {
                    LOG((TL_ERROR,
                        "OpenEvent ('%s') failed, err=%d",
                        SC_AUTOSTART_EVENT_NAME,
                        GetLastError()
                        ));
            }

            if (gbNTServer && !SecureTsecIni())
            {
                LOG((TL_ERROR,
                    "Failed to set security on the ini file"
                    ));
                bFatalError = TRUE;
            }
        }
    }

    //
    // Grab relevent values from the registry
    //

    if (!bFatalError)
    {
        HKEY    hKey;
        const TCHAR   szRPCMinCalls[] = TEXT("Min");
        const TCHAR   szRPCMaxCalls[] = TEXT("Max");
        const TCHAR   szTapisrvWaitHint[] = TEXT("TapisrvWaitHint");
        const TCHAR   szRPCTimeout[]  = TEXT("RPCTimeout");

#if DBG
        gdwDebugLevel = 0;
#endif

        if (RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                gszRegKeyTelephony,
                0,
                KEY_QUERY_VALUE | KEY_SET_VALUE,
                &hKey

                ) == ERROR_SUCCESS)
        {
            DWORD   dwDataSize = sizeof (DWORD), dwDataType;

#if DBG
            RegQueryValueEx(
                hKey,
                gszTapisrvDebugLevel,
                0,
                &dwDataType,
                (LPBYTE) &gdwDebugLevel,
                &dwDataSize
                );

            dwDataSize = sizeof (DWORD);

            RegQueryValueEx(
                hKey,
                gszBreakOnLeak,
                0,
                &dwDataType,
                (LPBYTE)&gbBreakOnLeak,
                &dwDataSize
                );

            dwDataSize = sizeof (DWORD);

            RegQueryValueEx(
                hKey,
                TEXT("BreakOnSeriousProblems"),
                0,
                &dwDataType,
                (LPBYTE) &gfBreakOnSeriousProblems,
                &dwDataSize
                );

            dwDataSize = sizeof(DWORD);

#endif
            RegQueryValueEx(
                hKey,
                szTapisrvWaitHint,
                0,
                &dwDataType,
                (LPBYTE) &gdwWaitHint,
                &dwDataSize
                );

            gdwWaitHint = (gdwWaitHint < MIN_WAIT_HINT ?
                MIN_WAIT_HINT : gdwWaitHint);

            dwDataSize = sizeof (DWORD);

            if (RegQueryValueEx(
                    hKey,
                    szRPCMinCalls,
                    NULL,
                    &dwDataType,
                    (LPBYTE) &dwMinCalls,
                    &dwDataSize

                    ) != ERROR_SUCCESS)
            {
                dwMinCalls = DEFAULTRPCMINCALLS;
            }


            dwDataSize = sizeof (DWORD);

            if (RegQueryValueEx(
                    hKey,
                    TEXT("TapiScpTTL"),
                    NULL,
                    &dwDataType,
                    (LPBYTE) &gdwTapiSCPTTL,
                    &dwDataSize

                    ) != ERROR_SUCCESS)
            {
                gdwTapiSCPTTL = 60 * 24;    // default to 24 hours
            }
            if (gdwTapiSCPTTL < 60)
            {
                gdwTapiSCPTTL = 60; // 60 minute TTL as the minimum
            }

            dwDataSize = sizeof (DWORD);

            if (RegQueryValueEx(
                    hKey,
                    szRPCMaxCalls,
                    NULL,
                    &dwDataType,
                    (LPBYTE) &dwMaxCalls,
                    &dwDataSize

                    ) != ERROR_SUCCESS)
            {
                dwMaxCalls = DEFAULTRPCMAXCALLS;
            }

            LOG((TL_INFO,
                "RPC min calls %lu RPC max calls %lu",
                dwMinCalls,
                dwMaxCalls
                ));

            // check values
            if (dwMaxCalls == 0)
            {
                LOG((TL_INFO,
                    "RPC max at 0.  Changed to %lu",
                    DEFAULTRPCMAXCALLS
                    ));

                dwMaxCalls = DEFAULTRPCMAXCALLS;
            }

            if (dwMinCalls == 0)
            {
                LOG((TL_INFO,
                    "RPC min at 0. Changed to %lu",
                    DEFAULTRPCMINCALLS
                    ));

                dwMinCalls = DEFAULTRPCMINCALLS;
            }

            if (dwMaxCalls > RPCMAXMAX)
            {
                LOG((TL_INFO,
                    "RPC max too high at %lu.  Changed to %lu",
                    dwMaxCalls,
                    RPCMAXMAX
                    ));

                dwMaxCalls = RPCMAXMAX;
            }

            if (dwMinCalls > dwMaxCalls)
            {
                LOG((TL_INFO,
                    "RPC min greater than RPC max.  Changed to %lu",
                    dwMaxCalls
                    ));

                dwMinCalls = dwMaxCalls;
            }

            if (dwMinCalls > RPCMINMAX)
            {
                LOG((TL_INFO,
                    "RPC min greater than allowed at %lu.  Changed to %lu",
                    dwMinCalls, RPCMINMAX
                    ));

                dwMinCalls = RPCMINMAX;
            }

            dwDataSize = sizeof (DWORD);

            if (RegQueryValueEx(
                    hKey,
                    szRPCTimeout,
                    NULL,
                    &dwDataType,
                    (LPBYTE) &gdwRpcTimeout,
                    &dwDataSize

                    ) != ERROR_SUCCESS)
            {
                gdwRpcTimeout = 30000;
            }

            VerifyDomainName (hKey);

            RegCloseKey (hKey);
        }
    }

    LOG((TL_TRACE,  "ServiceMain: enter"));

    //
    // More server-only reg stuff
    //

#if TELE_SERVER

    if (!bFatalError)
    {

        HKEY    hKey;
        DWORD   dwDataSize;
        DWORD   dwDataType;
        DWORD   dwTemp;
        DWORD   dwHighSecurity;
        TCHAR   szProductType[64];


        //
        // Get the "Server" reg settings
        //
        // It would have made more sense if this reg value were named
        // "EnableSharing", but we have to support what's out there
        // already...
        //

        if (RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                gszRegKeyServer,
                0,
                KEY_QUERY_VALUE,
                &hKey

                ) == ERROR_SUCCESS)
        {
            dwDataSize = sizeof (dwTemp);

            dwTemp = 1; // default is sharing == disabled

            if (RegQueryValueEx(
                    hKey,
                    TEXT("DisableSharing"),
                    0,
                    &dwDataType,
                    (LPBYTE) &dwTemp,
                    &dwDataSize

                    ) == ERROR_SUCCESS)
            {
                if (dwTemp == 0)
                {
                    TapiGlobals.dwFlags |= TAPIGLOBALS_SERVER;
                }

            }

            gdwTotalAsyncThreads = 0;
            dwDataSize = sizeof (DWORD);

            RegQueryValueEx(
                hKey,
                TEXT("TotalAsyncThreads"),
                0,
                &dwDataType,
                (LPBYTE) &gdwTotalAsyncThreads,
                &dwDataSize
                );

            if (gdwTotalAsyncThreads)
            {
                LOG((TL_INFO,
                    "Setting total async threads to %d", gdwTotalAsyncThreads
                    ));
            }

            gdwThreadsPerProcessor = 4;
            dwDataSize = sizeof (DWORD);

            RegQueryValueEx(
                hKey,
                TEXT("ThreadsPerProcessor"),
                0,
                &dwDataType,
                (LPBYTE) &gdwThreadsPerProcessor,
                &dwDataSize
                );

            LOG((TL_INFO, "Threads per processor is %d", gdwThreadsPerProcessor));

            dwHighSecurity = 1;
            dwDataSize = sizeof (DWORD);

            if (ERROR_SUCCESS == RegQueryValueEx(
                hKey,
                gszHighSecurity,
                0,
                &dwDataType,
                (LPBYTE) &dwHighSecurity,
                &dwDataSize
                ) &&
                0 == dwHighSecurity
               )
            {
                LOG((TL_INFO, "Setting High Security to FALSE"));
                gbHighSecurity = FALSE;
            }

            RegCloseKey( hKey );
        }


        //
        // Now check to see if this is really running on NT Server.
        // If not, then, turn off the SERVER bit in dwFlags.
        //
        if (!gbNTServer)
        {
            TapiGlobals.dwFlags &= ~(TAPIGLOBALS_SERVER);
        }
    }

#endif


    //
    // Init the lock table
    //
    if (!bFatalError)
    {
        HKEY    hKey;
        DWORD   i,
                dwLockTableNumEntries,
                dwDataSize = sizeof(DWORD),
                dwDataType,
                dwBitMask;
        BOOL    bException = FALSE;


        #define MIN_HANDLE_BUCKETS 8
        #define MAX_HANDLE_BUCKETS 128

        dwLockTableNumEntries = (TapiGlobals.dwFlags & TAPIGLOBALS_SERVER ?
            32 : MIN_HANDLE_BUCKETS);


        //
        // Retrieve registry override settings, if any
        //

        if (RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                gszRegKeyTelephony,
                0,
                KEY_QUERY_VALUE,
                &hKey

                ) == ERROR_SUCCESS)
        {
            RegQueryValueExW(
                hKey,
                L"TapisrvNumHandleBuckets",
                0,
                &dwDataType,
                (LPBYTE) &dwLockTableNumEntries,
                &dwDataSize
                );

            //RegQueryValueExW(
            //    hKey,
            //    L"TapisrvSpinCount",
            //    0,
            //    &dwDataType,
            //    (LPBYTE) &gdwSpinCount,
            //    &dwDataSize
            //    );

            RegCloseKey (hKey);
        }


        //
        // Determine a reasonable number of lock table entries, which
        // is some number == 2**N within min/max possible values
        //

        if (dwLockTableNumEntries > MAX_HANDLE_BUCKETS)
        {
            dwLockTableNumEntries = MAX_HANDLE_BUCKETS;
        }
        else if (dwLockTableNumEntries < MIN_HANDLE_BUCKETS)
        {
            dwLockTableNumEntries = MIN_HANDLE_BUCKETS;
        }

        for(
            dwBitMask = MAX_HANDLE_BUCKETS;
            (dwBitMask & dwLockTableNumEntries) == 0;
            dwBitMask >>= 1
            );

        dwLockTableNumEntries = dwBitMask;


        //
        // Calculate pointer-to-lock-table-index conversion value
        // (significant bits)
        //

        gdwPointerToLockTableIndexBits = dwLockTableNumEntries - 1;

        //gdwSpinCount = ( gdwSpinCount > MAX_SPIN_COUNT ?
        //    MAX_SPIN_COUNT : gdwSpinCount );


        //
        // Alloc & init the lock table
        //

        if (!(gLockTable = ServerAlloc(
                dwLockTableNumEntries * sizeof (CRITICAL_SECTION)
                )))
        {
            gLockTable = gLockTableCritSecs;
            dwLockTableNumEntries = sizeof(gLockTableCritSecs) 
                                / sizeof(CRITICAL_SECTION);
            gdwPointerToLockTableIndexBits = dwLockTableNumEntries - 1;
        }

        for (i = 0; i < dwLockTableNumEntries; i++)
        {
            if ( NO_ERROR != MyInitializeCriticalSection (&gLockTable[i], 1000) )
            {   
                bException = TRUE;
                break;
            }
        }

        if (bException)
        {
            bFatalError = TRUE;

            LOG((TL_ERROR, "Exception in InitializeCriticalSection" ));

            for (; i > 0; i--)
            {
                DeleteCriticalSection (&gLockTable[i-1]);
            }

            if (gLockTable != gLockTableCritSecs)
            {
                ServerFree (gLockTable);
            }
            gLockTable = NULL;
        }
        else
        {
            gdwNumLockTableEntries = dwLockTableNumEntries;
            gdwServiceInitFlags |= SERVICE_INIT_LOCKTABLE;
        }
    }

    bFatalError = bFatalError || MyInitializeCriticalSection (&gSafeMutexCritSec, 200);
    if(!bFatalError)
        gdwServiceInitFlags |= SERVICE_INIT_CRITSEC_SAFEMUTEX;

    bFatalError = bFatalError || MyInitializeCriticalSection (&gRemoteCliEventBufCritSec, 200);
    if(!bFatalError)
        gdwServiceInitFlags |= SERVICE_INIT_CRITSEC_REMOTECLI;

    bFatalError = bFatalError || MyInitializeCriticalSection (&gPriorityListCritSec, 200);
    if(!bFatalError)
        gdwServiceInitFlags |= SERVICE_INIT_CRITSEC_PRILIST;

    bFatalError = bFatalError || MyInitializeCriticalSection (&gManagementDllsCritSec, 200);
    if(!bFatalError)
        gdwServiceInitFlags |= SERVICE_INIT_CRITSEC_MGMTDLLS;

    bFatalError = bFatalError || MyInitializeCriticalSection (&gDllListCritSec, 200);
    if(!bFatalError)
        gdwServiceInitFlags |= SERVICE_INIT_CRITSEC_DLLLIST;

    bFatalError = bFatalError || MyInitializeCriticalSection (&gClientHandleCritSec, 200);
    if(!bFatalError)
        gdwServiceInitFlags |= SERVICE_INIT_CRITSEC_CLIENTHND;


    bFatalError = bFatalError || MyInitializeCriticalSection (&gCnClientMsgPendingCritSec, 200);
    if(!bFatalError)
        gdwServiceInitFlags |= SERVICE_INIT_CRITSEC_CNCLIENTMSG;

    bFatalError = bFatalError || MyInitializeCriticalSection (&gDgClientMsgPendingCritSec, 200);
    if(!bFatalError)
        gdwServiceInitFlags |= SERVICE_INIT_CRITSEC_DGCLIENTMSG;


    bFatalError = bFatalError || TapiMyInitializeCriticalSection (&TapiGlobals.CritSec, 200);
    if(!bFatalError)
        gdwServiceInitFlags |= SERVICE_INIT_CRITSEC_GLOB_CRITSEC;

    bFatalError = bFatalError || MyInitializeCriticalSection (&TapiGlobals.RemoteSPCritSec, 200);
    if(!bFatalError)
        gdwServiceInitFlags |= SERVICE_INIT_CRITSEC_GLOB_REMOTESP;

    bFatalError = bFatalError || MyInitializeCriticalSection (&gMgmtCritSec, 200);
    if(!bFatalError)
        gdwServiceInitFlags |= SERVICE_INIT_CRITSEC_MGMT;

    bFatalError = bFatalError || MyInitializeCriticalSection (&gSCPCritSec, 200);
    if(!bFatalError)
        gdwServiceInitFlags |= SERVICE_INIT_CRITSEC_SCP;

    ghProvRegistryMutex = CreateMutex (NULL, FALSE, NULL);
    bFatalError = bFatalError || (NULL == ghProvRegistryMutex);

    if (!bFatalError)
    {
        DWORD   dwTID, i;
        HANDLE  hThread;
        SYSTEM_INFO SystemInfo;
        BOOL    bError = FALSE;

        //
        // Start a thread for as many processors there are
        //
        SystemInfo.dwNumberOfProcessors = 1;
        GetSystemInfo( &SystemInfo );

        aSPEventHandlerThreadInfo = ServerAlloc(
            SystemInfo.dwNumberOfProcessors * sizeof (SPEVENTHANDLERTHREADINFO)
            );

        if (!aSPEventHandlerThreadInfo)
        {
            aSPEventHandlerThreadInfo = &gSPEventHandlerThreadInfo;
            SystemInfo.dwNumberOfProcessors = 1;
        }

        for (i = 0; i < SystemInfo.dwNumberOfProcessors; i++)
        {
            if ( NO_ERROR != MyInitializeCriticalSection(
                                    &aSPEventHandlerThreadInfo[i].CritSec,
                                    1000
                                    )
                )
            {
                bError = TRUE;
                LOG((TL_ERROR, "Exception in InitializeCriticalSection"));
                break;
            }

            InitializeListHead (&aSPEventHandlerThreadInfo[i].ListHead);

            aSPEventHandlerThreadInfo[i].hEvent = CreateEvent(
               (LPSECURITY_ATTRIBUTES) NULL,
               TRUE,   // manual reset
               FALSE,  // non-signaled
               NULL    // unnamed
               );
            if (aSPEventHandlerThreadInfo[i].hEvent == NULL)
            {
                bError = TRUE;
                LOG((TL_ERROR,
                    "CreateEvent('SPEventHandlerThread') " \
                        "(Proc%d)failed, err=%d",
                    SystemInfo.dwNumberOfProcessors,
                    GetLastError()
                    ));
                DeleteCriticalSection(&aSPEventHandlerThreadInfo[i].CritSec);
                break;
            }

            if ((hThread = CreateThread(
                    (LPSECURITY_ATTRIBUTES) NULL,
                    0,
                    (LPTHREAD_START_ROUTINE) SPEventHandlerThread,
                    (LPVOID) (aSPEventHandlerThreadInfo +
                        gdwNumSPEventHandlerThreads),
                    0,
                    &dwTID
                    )))
            {
                gdwNumSPEventHandlerThreads++;
                CloseHandle (hThread);
            }
            else
            {
                LOG((TL_ERROR,
                    "CreateThread('SPEventHandlerThread') " \
                        "(Proc%d)failed, err=%d",
                    SystemInfo.dwNumberOfProcessors,
                    GetLastError()
                    ));
            }
        }

        if (bError && i == 0)
        {
            bFatalError = TRUE;
        }
        else
        {
            glNumActiveSPEventHandlerThreads = (LONG) gdwNumSPEventHandlerThreads;
            gdwServiceInitFlags |= SERVICE_INIT_SPEVENT_HANDLER;
        }
    }


    //
    // Init some globals
    //

#if TELE_SERVER
    TapiGlobals.pIDArrays = NULL;
#endif

    if (!bFatalError)
    {
        DWORD   dwSize = (MAX_COMPUTERNAME_LENGTH + 1) * sizeof(WCHAR);


        TapiGlobals.pszComputerName = ServerAlloc (dwSize);
        if (TapiGlobals.pszComputerName)
        {
#ifdef PARTIAL_UNICODE
            {
            CHAR buf[MAX_COMPUTERNAME_LENGTH + 1];

            GetComputerName (buf, &dwSize);

            MultiByteToWideChar(
                GetACP(),
                MB_PRECOMPOSED,
                buf,
                dwSize,
                TapiGlobals.pszComputerName,
                dwSize
                );
           }
#else
            GetComputerNameW(TapiGlobals.pszComputerName, &dwSize);
#endif

            TapiGlobals.dwComputerNameSize = (1 +
                lstrlenW(TapiGlobals.pszComputerName)) * sizeof(WCHAR);

        }

        // Allocate the priority lists
        TapiGlobals.dwTotalPriorityLists = 0;
        TapiGlobals.dwUsedPriorityLists = 0;
        TapiGlobals.pPriLists = ( PRILISTSTRUCT * ) ServerAlloc( (sizeof(PRILISTSTRUCT)) * 5);

        if (NULL == TapiGlobals.pPriLists)
        {
            LOG((TL_ERROR, "ServerAlloc pPriLists failed."));
            bFatalError = TRUE;
        }
        else
        {
            TapiGlobals.dwTotalPriorityLists = 5;
        }
    }


#if TELE_SERVER

    if (!bFatalError)
    {
        ReadAndInitMapper();
        ReadAndInitManagementDlls();
        gdwServiceInitFlags |= SERVICE_INIT_MANAGEMENT_DLL;
    }

    //
    // Alloc the EventNotificationThread resources and start the thread
    //

    if ( !bFatalError && (TapiGlobals.dwFlags & TAPIGLOBALS_SERVER))
    {
        DWORD       dwID;

        // now start a thread to wait for changes to the managementdll key

        hThreadMgmt = CreateThread(
            NULL,
            0,
            (LPTHREAD_START_ROUTINE)ManagementProc,
            0,
            0,
            &dwID
            );

        if (!(gEventNotificationThreadParams.hEvent = CreateEvent(
                (LPSECURITY_ATTRIBUTES) NULL,   // no security attrs
                TRUE,                           // manual reset
                FALSE,                          // initially non-signaled
                NULL                            // unnamed
                )))
        {
        }

        gEventNotificationThreadParams.bExit = FALSE;

        {
            DWORD   dwTID, dwCount;

            SYSTEM_INFO SystemInfo;

            //
            // Start a thread for as many processors there are
            //

            GetSystemInfo( &SystemInfo );

            if (gdwTotalAsyncThreads)
            {
                dwCount = gdwTotalAsyncThreads;
            }
            else
            {
                dwCount = SystemInfo.dwNumberOfProcessors *
                    gdwThreadsPerProcessor;
            }

            if (dwCount <= 0)
            {
                dwCount = 1;
            }
            while (dwCount > 0)
            {
                gEventNotificationThreadParams.phThreads =
                    ServerAlloc( sizeof (HANDLE) * dwCount );
                if (!gEventNotificationThreadParams.phThreads)
                {
                    --dwCount;
                    continue;
                }

                gEventNotificationThreadParams.pWatchDogStruct =
                    ServerAlloc( sizeof (WATCHDOGSTRUCT) * dwCount );
                if (!gEventNotificationThreadParams.pWatchDogStruct)
                {
                    ServerFree (gEventNotificationThreadParams.phThreads);
                    --dwCount;
                    continue;
                }
                break;
            }
            gEventNotificationThreadParams.dwNumThreads = dwCount;

            for (i = 0; i < gEventNotificationThreadParams.dwNumThreads;)
            {
                if ((gEventNotificationThreadParams.phThreads[i] =
                        CreateThread(
                            (LPSECURITY_ATTRIBUTES) NULL,
                            0,
                            (LPTHREAD_START_ROUTINE) EventNotificationThread,
                            (LPVOID) ULongToPtr(i),
                            0,
                            &dwTID
                            )))
                {
                    i++;
                }
                else
                {
                    LOG((TL_ERROR,
                        "CreateThread('EventNotificationThread') failed, " \
                            "err=%d",
                        GetLastError()
                        ));

                    gEventNotificationThreadParams.dwNumThreads--;
                }
            }
        }

        gdwServiceInitFlags |= SERVICE_INIT_EVENT_NOTIFICATION;
    }
#endif


    //
    // Init Rpc server
    //


    gRundownLock.bIgnoreRundowns = FALSE;

    {
        RPC_STATUS status;
        unsigned int    fDontWait           = FALSE;
        BOOL            fInited             = FALSE;

        SECURITY_DESCRIPTOR  sd;
        PSID                 psid = NULL;
        PACL                 pdacl = NULL;
        static SERVICE_SHUTDOWN_PARAMS      s_ssp;
        HANDLE                              hWait;
        DWORD                dwNumRetries = 0;

        s_ssp.psid = NULL;
        s_ssp.pdacl = NULL;
        s_ssp.hThreadMgmt = hThreadMgmt;

        if (!bFatalError)
        {
            InitSecurityDescriptor (&sd, &psid, &pdacl);
            s_ssp.psid = psid;
            s_ssp.pdacl = pdacl;

            // 
            // The RPC endpoints are static => they will exist as long as the service 
            // process has not exited => stop and restart on client machines will hit 
            // error 1740 RPC_NT_DUPLICATE_ENDPOINT, but this is ok.
            //
            // On server machines, if we get error 1740 RPC_S_DUPLICATE_ENDPOINT, 
            // it means that the previous tapisrv process instance has not completely 
            // gone away, and when it will, it will also remove the RPC endpoint.
            // In this case we need to wait a bit and retry publishing the endpoint.
            //

            
            dwNumRetries = 0;
RpcEp_retry:

            status = RpcServerUseProtseqEp(
                TEXT("ncacn_np"),
                (unsigned int) dwMaxCalls,
                TEXT("\\pipe\\tapsrv"),
                NULL
                );

            if (status)
            {
                LOG((TL_TRACE,  "RpcServerUseProtseqEp(np) ret'd %d", status));
                if (RPC_S_DUPLICATE_ENDPOINT == status && gbNTServer)
                {
                    // retry
                    if (dwNumRetries++ < gdwRpcRetryCount)
                    {
                        Sleep (1000);
                        goto RpcEp_retry;
                    }
                }
            }

            dwNumRetries = 0;
LpcEp_retry:
            status = RpcServerUseProtseqEp(
                TEXT("ncalrpc"),
                (unsigned int) dwMaxCalls,
                TEXT("tapsrvlpc"),
                &sd
                );

            if (status)
            {
                LOG((TL_TRACE,  "RpcServerUseProtseqEp(lrpc) ret'd %d", status));
                if (RPC_S_DUPLICATE_ENDPOINT == status && gbNTServer)
                {
                    // retry
                    if (dwNumRetries++ < gdwRpcRetryCount)
                    {
                        Sleep (1000);
                        goto LpcEp_retry;
                    }
                }
            }

            LOG((TL_TRACE,  "calling RpcServerRegisterAuthInfo"));
            status = RpcServerRegisterAuthInfo(
                NULL,
                RPC_C_AUTHN_WINNT,
                NULL,
                NULL
                );

            if (status)
            {
                LOG((TL_TRACE,  "RpcServerRegisterAuthInfo ret'd %d", status));
            }
        
            ReportStatusToSCMgr(
                (gdwServiceState = SERVICE_RUNNING),
                                 // service state
                NO_ERROR,        // exit code
                0,               // checkpoint
                0                // wait hint
                );
            LOG((TL_TRACE,  "calling RpcServerListen"));
            status = RpcServerListen(
                (unsigned int)dwMinCalls,
                (unsigned int)dwMaxCalls,
                TRUE
                );

            if (status)
            {
                LOG((TL_TRACE,  "RpcServerListen ret'd %d", status));
            }

            LOG((TL_TRACE,  "calling RpcServerRegisterIfEx"));
        
            status = RpcServerRegisterIfEx(
                tapsrv_ServerIfHandle,  // interface to register
                NULL,                   // MgrTypeUuid
                NULL,                   // MgrEpv; null means use default
                RPC_IF_AUTOLISTEN | RPC_IF_ALLOW_SECURE_ONLY,
                dwMaxCalls,
                NULL
                );

            if (status)
            {
                LOG((TL_TRACE,  "RpcServerRegisterIfEx ret'd %d", status));
            }

            //
            //  In TAPI server machine with a few thousands of lines or more,
            //  ServerInit will take considerable amount of time, the
            //  first user who does a lineInitialize will be hit with this
            //  delay. Also the first person who does MMC management will also
            //  hit a delay waiting for the server to collect information. Both
            //  affects people's perception of TAPI performance.
            //
            //  Solution:
            //      1. We put ServerInit to be done immediately after the server 
            //  is up. This way, as long as user does not come too fast, he won't
            //  be penalized for being the first.
            //      2. We now try to build the management cache immediately
            //  instead of waiting until MMC is used. This way, when MMC is started
            //  the user do not have to wait.
            //
            //  Of course, in both of the above cases, if a user tries to use
            //  TAPI server before all the dusts settle down. He will have to
            //  wait.
            //

            gbServerInited = FALSE;
            if (TapiGlobals.dwFlags & TAPIGLOBALS_SERVER)
            {
                TapiEnterCriticalSection (&TapiGlobals.CritSec);
                if (TapiGlobals.dwNumLineInits == 0 && 
                    TapiGlobals.dwNumPhoneInits == 0)
                {
                    if (ServerInit(FALSE) == S_OK)
                    {
                        gbServerInited = TRUE;
                    }
                    else
                    {
                        LOG((TL_ERROR,  "ServiceMain: ServerInit failed"));
                    }
                }
                //  Holde a reference here to prevent ServerShutdown
                TapiLeaveCriticalSection (&TapiGlobals.CritSec);

                UpdateTapiSCP (TRUE, NULL, NULL);

                EnterCriticalSection (&gMgmtCritSec);
                UpdateLastWriteTime(TRUE);
                BuildDeviceInfoList(TRUE);
                UpdateLastWriteTime(FALSE);
                BuildDeviceInfoList(FALSE);
                LeaveCriticalSection (&gMgmtCritSec);
            }

            gdwServiceInitFlags |= SERVICE_INIT_RPC;
            
            if (ghEventService == NULL ||
                !RegisterWaitForSingleObject(
                    &hWait,
                    ghEventService, 
                    ServiceShutdown,
                    (PVOID)&s_ssp,
                    INFINITE,
                    WT_EXECUTEONLYONCE 
                    )
                )
            {
                ServiceShutdown ((PVOID) &s_ssp, FALSE);
            }
        }
        
        if (bFatalError)
        {
            ServiceShutdown ((PVOID) &s_ssp, FALSE);
        }
    }
}

VOID CALLBACK ServiceShutdown (
    PVOID       lpParam,
    BOOLEAN     fTimeOut
    )
{
    SERVICE_SHUTDOWN_PARAMS     *pssp = (SERVICE_SHUTDOWN_PARAMS *)lpParam;
    HANDLE                      hThreadMgmt;
    PSID                        psid;
    PACL                        pdacl;
    DWORD                       i;

    if (pssp == NULL)
    {
        return;
    }
    hThreadMgmt = pssp->hThreadMgmt;
    psid = pssp->psid;
    pdacl = pssp->pdacl;

    //  Mark Tapi server to be inactive for service stop

    //  Wait max 20 seconds for Management thread to terminate
    if (hThreadMgmt)
    {
        WaitForSingleObject (hThreadMgmt, INFINITE);
        CloseHandle (hThreadMgmt);
    }
        
    if (gbNTServer && (gdwServiceInitFlags & SERVICE_INIT_CRITSEC_GLOB_CRITSEC) )
    {
        TapiEnterCriticalSection (&TapiGlobals.CritSec);
        if (TapiGlobals.dwNumLineInits == 0 &&
            TapiGlobals.dwNumPhoneInits == 0 &&
            gbServerInited
            )
        {
            ServerShutdown();
        }
        TapiLeaveCriticalSection (&TapiGlobals.CritSec);
    }
    ServerFree (psid);
    ServerFree (pdacl);

    gbSPEventHandlerThreadExit = TRUE;

    //
    // If there are any clients left then tear them down.  This will
    // cause any existing service providers to get unloaded, etc.
    //

    {
        PTCLIENT    ptClient;


        while ((ptClient = TapiGlobals.ptClients) != NULL)
        {
            if (!CleanUpClient (ptClient, TRUE))
            {
                //
                // CleanUpClient will only return FALSE if another
                // thread is cleaning up the specified tClient, or
                // if the pointer is really bad.
                //
                // So, we'll spin for a little while waiting to see
                // if the tClient gets removed from the list, & if
                // not assume that we're experiencing heap
                // corruption or some such, and manually shutdown.
                //

                for (i = 0; ptClient == TapiGlobals.ptClients  &&  i < 10; i++)
                {
                    Sleep (100);
                }

                if (i >= 10)
                {
                    TapiEnterCriticalSection (&TapiGlobals.CritSec);

                    if (TapiGlobals.dwNumLineInits  ||
                        TapiGlobals.dwNumPhoneInits)
                    {
                        ServerShutdown ();
                    }

                    TapiLeaveCriticalSection (&TapiGlobals.CritSec);

                    break;
                }
            }
        }
    }


    //
    // Tell the SPEventHandlerThread(s) to terminate
    //
    
    for (i = 0; i < gdwNumSPEventHandlerThreads; i++)
    {
        EnterCriticalSection (&aSPEventHandlerThreadInfo[i].CritSec);
        SetEvent (aSPEventHandlerThreadInfo[i].hEvent);
        LeaveCriticalSection (&aSPEventHandlerThreadInfo[i].CritSec);
    }


    //
    // Disable rundowns & wait for any active rundowns to complete
    //

    while (InterlockedExchange (&gRundownLock.lCookie, 1) == 1)
    {
        Sleep (50);
    }

    gRundownLock.bIgnoreRundowns = TRUE;

    InterlockedExchange (&gRundownLock.lCookie, 0);

    while (gRundownLock.lNumRundowns != 0)
    {
        Sleep (50);
    }

#if TELE_SERVER

    //
    // Wait for the EventNotificationThread's to terminate,
    // then clean up the related resources
    //

    if ( (TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) && 
         (gdwServiceInitFlags & SERVICE_INIT_EVENT_NOTIFICATION)
       )
    {
        gEventNotificationThreadParams.bExit = TRUE;

        while (gEventNotificationThreadParams.dwNumThreads)
        {
            SetEvent (gEventNotificationThreadParams.hEvent);
            Sleep (100);
        }

        CloseHandle (gEventNotificationThreadParams.hEvent);
        
        ServerFree (gEventNotificationThreadParams.phThreads);
        ServerFree (gEventNotificationThreadParams.pWatchDogStruct);
    }

    if (gdwServiceInitFlags & SERVICE_INIT_MANAGEMENT_DLL)
    {
        CleanUpManagementMemory();
    }

#endif

    ServerFree (TapiGlobals.pszComputerName);

    //
    // Wait for the SPEVentHandlerThread(s) to terminate
    //

    while (glNumActiveSPEventHandlerThreads)
    {
        Sleep (100);
    }

    for (i = 0; i < gdwNumSPEventHandlerThreads; i++)
    {
        CloseHandle (aSPEventHandlerThreadInfo[i].hEvent);
        DeleteCriticalSection (&aSPEventHandlerThreadInfo[i].CritSec);
    }
    if (aSPEventHandlerThreadInfo != (&gSPEventHandlerThreadInfo))
    {
        ServerFree (aSPEventHandlerThreadInfo);
    }

    //
    // Free up resources
    //

    if (gdwServiceInitFlags & SERVICE_INIT_CRITSEC_MGMT)
        DeleteCriticalSection (&gMgmtCritSec);

    if (gdwServiceInitFlags & SERVICE_INIT_CRITSEC_GLOB_CRITSEC)
        TapiDeleteCriticalSection (&TapiGlobals.CritSec);

    if (gdwServiceInitFlags & SERVICE_INIT_CRITSEC_GLOB_REMOTESP)
        DeleteCriticalSection (&TapiGlobals.RemoteSPCritSec);

    
    if (gdwServiceInitFlags & SERVICE_INIT_CRITSEC_CNCLIENTMSG)
        DeleteCriticalSection (&gCnClientMsgPendingCritSec);
    
    if (gdwServiceInitFlags & SERVICE_INIT_CRITSEC_DGCLIENTMSG)
        DeleteCriticalSection (&gDgClientMsgPendingCritSec);

    
    if (gdwServiceInitFlags & SERVICE_INIT_CRITSEC_SAFEMUTEX)
        DeleteCriticalSection (&gSafeMutexCritSec);
    
    if (gdwServiceInitFlags & SERVICE_INIT_CRITSEC_REMOTECLI)
        DeleteCriticalSection (&gRemoteCliEventBufCritSec);
    
    if (gdwServiceInitFlags & SERVICE_INIT_CRITSEC_PRILIST)
        DeleteCriticalSection (&gPriorityListCritSec);
    
    if (gdwServiceInitFlags & SERVICE_INIT_CRITSEC_MGMTDLLS)
        DeleteCriticalSection (&gManagementDllsCritSec);
    
    if (gdwServiceInitFlags & SERVICE_INIT_CRITSEC_DLLLIST)
        DeleteCriticalSection (&gDllListCritSec);
    
    if (gdwServiceInitFlags & SERVICE_INIT_CRITSEC_SCP)
        DeleteCriticalSection (&gSCPCritSec);

    if (gdwServiceInitFlags & SERVICE_INIT_CRITSEC_CLIENTHND)
        DeleteCriticalSection (&gClientHandleCritSec);

    if (ghProvRegistryMutex)
        CloseHandle (ghProvRegistryMutex);

    //
    //  Free ICON resources
    //
    if (TapiGlobals.hLineIcon)
    {
        DestroyIcon (TapiGlobals.hLineIcon);
        TapiGlobals.hLineIcon = NULL;
    }
    if (TapiGlobals.hPhoneIcon)
    {
        DestroyIcon (TapiGlobals.hPhoneIcon);
        TapiGlobals.hPhoneIcon = NULL;
    }

    if (gdwServiceInitFlags & SERVICE_INIT_LOCKTABLE)
    {
        for (i = 0; i < gdwNumLockTableEntries; i++)
        {
            DeleteCriticalSection (&gLockTable[i]);
        }
        if (gLockTable != gLockTableCritSecs)
        {
            ServerFree (gLockTable);
        }
    }

    if (TapiGlobals.pPriLists)
    {
        ServerFree(TapiGlobals.pPriLists);
    }

    if (ghHandleTable)
    {
        DeleteHandleTable (ghHandleTable);
        ghHandleTable = NULL;
    }

    if (ghTapisrvHeap != GetProcessHeap())
    {
        HeapDestroy (ghTapisrvHeap);
    }

    if (ghEventService)
    {
        CloseHandle (ghEventService);
        ghEventService = NULL;
    }

    //
    // Report the stopped status to the service control manager.
    //
    if (NULL != ghSCMAutostartEvent)
    {
        CloseHandle (ghSCMAutostartEvent);
    }

    if (gdwServiceInitFlags & SERVICE_INIT_SCM_REGISTERED)
    {
        ReportStatusToSCMgr ((gdwServiceState = SERVICE_STOPPED), 0, 0, 0);
    }

    gdwServiceInitFlags = 0;

    //
    // When SERVICE MAIN FUNCTION returns in a single service
    // process, the StartServiceCtrlDispatcher function in
    // the main thread returns, terminating the process.
    //

    LOG((TL_TRACE,  "ServiceMain: exit"));

    TRACELOGDEREGISTER();


    return;
}


BOOL
PASCAL
QueueSPEvent(
    PSPEVENT    pSPEvent
    )
{
    //
    // If there are multiple SPEventHandlerThread's running then make
    // sure to always queue events for a particular object to the same
    // SPEventHandlerThread so that we can preserve message ordering.
    // Without doing this call state messages might be received out of
    // order (or discarded altogether, if processed before a MakeCall
    // completion routine run, etc), etc.
    //

    BOOL                        bSetEvent;
    ULONG_PTR                   htXxx;
    PSPEVENTHANDLERTHREADINFO   pInfo;


    switch (pSPEvent->dwType)
    {
    case SP_LINE_EVENT:
    case SP_PHONE_EVENT:

        htXxx = (ULONG_PTR)pSPEvent->htLine;

        break;

    case TASYNC_KEY:

        htXxx = ((PASYNCREQUESTINFO) pSPEvent)->htXxx;
        break;

    default:

        LOG((TL_ERROR, "QueueSPEvent: bad pSPEvent=x%p", pSPEvent));
#if DBG
        if (gfBreakOnSeriousProblems)
        {
            DebugBreak();
        }
#endif
        return FALSE;
    }

    pInfo = (gdwNumSPEventHandlerThreads > 1 ?
        aSPEventHandlerThreadInfo + MAP_HANDLE_TO_SP_EVENT_QUEUE_ID (htXxx) :
        aSPEventHandlerThreadInfo
        );

    if (gbQueueSPEvents)
    {
        EnterCriticalSection (&pInfo->CritSec);

        bSetEvent = IsListEmpty (&pInfo->ListHead);

        InsertTailList (&pInfo->ListHead, &pSPEvent->ListEntry);

        LeaveCriticalSection (&pInfo->CritSec);

        if (bSetEvent)
        {
            SetEvent (pInfo->hEvent);
        }

        return TRUE;
    }

    return FALSE;
}


BOOL
PASCAL
DequeueSPEvent(
    PSPEVENTHANDLERTHREADINFO   pInfo,
    PSPEVENT                    *ppSPEvent
    )
{
    BOOL        bResult;
    LIST_ENTRY  *pEntry;


    EnterCriticalSection (&pInfo->CritSec);

    if ((bResult = !IsListEmpty (&pInfo->ListHead)))
    {
        pEntry = RemoveHeadList (&pInfo->ListHead);

        *ppSPEvent = CONTAINING_RECORD (pEntry, SPEVENT, ListEntry);
    }

    if (IsListEmpty (&pInfo->ListHead))
    {
        ResetEvent (pInfo->hEvent);
    }

    LeaveCriticalSection (&pInfo->CritSec);

    return bResult;
}


void
SPEventHandlerThread(
    PSPEVENTHANDLERTHREADINFO   pInfo
    )
{
    //
    // This thread processes the events & completion notifications
    // indicated to us by an SP at a previous time/thread context.
    // There are a couple of reasons for doing this in a separate
    // thread rather than within the SP's thread context:
    //
    //   1. for some msgs (i.e. XXX_CLOSE) TAPI will call back
    //      into the SP, which it may not be expecting
    //
    //   2. we don't want to block the SP's thread by processing
    //      the msg, forwarding it on to the appropriate clients,
    //      etc
    //


    LOG((TL_INFO,
        "SPEventHandlerThread: enter (tid=%d)",
        GetCurrentThreadId()
        ));

    if (!SetThreadPriority(
            GetCurrentThread(),
            THREAD_PRIORITY_ABOVE_NORMAL
            ))
    {
        LOG((TL_ERROR, "Could not raise priority of SPEventHandlerThread"));
    }

    while (1)
    {
        PSPEVENT    pSPEvent;


#if TELE_SERVER

        //
        // Timeout no more than gdwRpcTimeout to check on threads...
        //
        {
#if DBG
            DWORD dwReturnValue;


            dwReturnValue =
#endif
            WaitForSingleObject (pInfo->hEvent, gdwRpcTimeout);


#if DBG
            if ( WAIT_TIMEOUT == dwReturnValue )
               LOG((TL_INFO, "Timed out waiting for an sp event..."));
            else
               LOG((TL_INFO, "Found an sp event..."));
#endif
        }

#else
        WaitForSingleObject (pInfo->hEvent, INFINITE);
#endif

        while (DequeueSPEvent (pInfo, &pSPEvent))
        {
            switch (pSPEvent->dwType)
            {
            case SP_LINE_EVENT:

                LOG((TL_INFO, "Got a line spevent, htLine = 0x%x, htCall = 0x%x, dwMsg = 0x%x",
                    pSPEvent->htLine,pSPEvent->htCall,pSPEvent->dwMsg));

                LineEventProc(
                    pSPEvent->htLine,
                    pSPEvent->htCall,
                    pSPEvent->dwMsg,
                    pSPEvent->dwParam1,
                    pSPEvent->dwParam2,
                    pSPEvent->dwParam3
                    );

                ServerFree (pSPEvent);

                break;

            case TASYNC_KEY:

            LOG((TL_INFO, "Got an async completion event, requestID = 0x%x, htXxx = 0x%x, lResult = 0x%x",
                ((PASYNCREQUESTINFO) pSPEvent)->dwLocalRequestID,
                ((PASYNCREQUESTINFO) pSPEvent)->htXxx,
                ((PASYNCREQUESTINFO) pSPEvent)->lResult));

                CompletionProc(
                    (PASYNCREQUESTINFO) pSPEvent,
                    ((PASYNCREQUESTINFO) pSPEvent)->lResult
                    );

                DereferenceObject(
                    ghHandleTable,
                    ((PASYNCREQUESTINFO) pSPEvent)->dwLocalRequestID,
                    1
                    );

                break;

            case SP_PHONE_EVENT:

            LOG((TL_INFO, "Got a phone spevent, htPhone = 0x%x, dwMsg = 0x%x",
                pSPEvent->htPhone,pSPEvent->dwMsg));

                PhoneEventProc(
                    pSPEvent->htPhone,
                    pSPEvent->dwMsg,
                    pSPEvent->dwParam1,
                    pSPEvent->dwParam2,
                    pSPEvent->dwParam3
                    );

                ServerFree (pSPEvent);

                break;
            }
        }


#if TELE_SERVER

        //
        // Check the remotesp event threads to make sure no
        // one is hung in an RPC call
        //

        if (TapiGlobals.dwFlags & TAPIGLOBALS_SERVER)
        {
            DWORD       dwCount = gEventNotificationThreadParams.dwNumThreads;
            DWORD       dwTickCount = GetTickCount();
            DWORD       dwStartCount, dwDiff;
            RPC_STATUS  status;


            while (dwCount)
            {
                dwCount--;

                dwStartCount = gEventNotificationThreadParams.
                    pWatchDogStruct[dwCount].dwTickCount;

                if ( gEventNotificationThreadParams.
                        pWatchDogStruct[dwCount].ptClient &&
                     ( ( dwTickCount - dwStartCount ) > gdwRpcTimeout ) )
                {
                    // did it wrap?

                    if ((((LONG)dwStartCount) < 0) && ((LONG)dwTickCount) > 0)
                    {
                        dwDiff = dwTickCount + (0 - ((LONG)dwStartCount));

                        if (dwDiff <= gdwRpcTimeout)
                        {
                            continue;
                        }
                    }

                    // Kill the chicken!

                    LOG((TL_INFO,
                        "Calling RpcCancelThread on thread #%lx",
                        gEventNotificationThreadParams.phThreads[dwCount]
                        ));

                    gEventNotificationThreadParams.
                        pWatchDogStruct[dwCount].ptClient = NULL;

                    status = RpcCancelThread(
                        gEventNotificationThreadParams.phThreads[dwCount]
                        );
                }
            }
        }

#endif
        if (gbSPEventHandlerThreadExit)
        {
            //
            // ServiceMain has stopped listening, so we want to exit NOW
            //

            break;
        }


        //
        // Check to see if all the clients are gone, and if so wait a
        // while to see if anyone else attaches.  If no one else attaches
        // in the specified amount of time then shut down.
        //

        // don't quit if we're a server

        //
        // don't quit if we've not yet ever had anyone attach (like a service
        // that has a dependency on us, but has not yet done a lineInit)
        //

        //
        // don't quit if SCM didn't finish to start the automatic services;
        // there may be services that depend on us to start
        //
        
       
        if ( !gbAutostartDone &&
             ghSCMAutostartEvent &&
             WAIT_OBJECT_0 == WaitForSingleObject(ghSCMAutostartEvent, 0)
           )
        {
            gbAutostartDone = TRUE;
        }

        if (TapiGlobals.ptClients == NULL &&
            !(TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
            gfWeHadAtLeastOneClient &&
            gbAutostartDone)
        {
            DWORD       dwDeferredShutdownTimeout, dwSleepInterval,
                        dwLoopCount, i;
            RPC_STATUS  status;
            HKEY        hKey;

            dwDeferredShutdownTimeout = 120; // 120 seconds
            dwSleepInterval = 250;          // 250 milliseconds

            if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    gszRegKeyTelephony,
                    0,
                    KEY_ALL_ACCESS,
                    &hKey

                    ) == ERROR_SUCCESS)
            {
                DWORD   dwDataSize = sizeof (DWORD), dwDataType;

                if (RegQueryValueEx(
                        hKey,
                        TEXT("DeferredShutdownTimeout"),
                        0,
                        &dwDataType,
                        (LPBYTE) &dwDeferredShutdownTimeout,
                        &dwDataSize

                        ) == ERROR_SUCCESS )
                {
                   LOG((TL_ERROR,
                       "Overriding Shutdown Timeout: %lu",
                       dwDeferredShutdownTimeout
                       ));
                }

                RegCloseKey (hKey);
            }


            dwLoopCount = dwDeferredShutdownTimeout * 1000 / dwSleepInterval;


            for (i = 0; i < dwLoopCount; i++)
            {
                if (gbSPEventHandlerThreadExit)
                {
                    i = dwLoopCount;
                    break;
                }

                Sleep (dwSleepInterval);

                if (TapiGlobals.ptClients != NULL)
                {
                    break;
                }
            }

            if (i == dwLoopCount)
            {
                //
                // The 1st SPEVentHandlerThread instance is in charge of
                // tearing down the rpc server listen
                //

                if (pInfo == aSPEventHandlerThreadInfo)
                {
                    ReportStatusToSCMgr(
                        (gdwServiceState = SERVICE_STOP_PENDING),
                        0,
                        (gdwCheckPoint = 0),
                        gdwWaitHint
                        );
                    LOG((TL_TRACE,  "SPEventHandlerThread: calling RpcServerUnregisterIf"));

                    RpcServerUnregisterIf (tapsrv_ServerIfHandle, NULL, TRUE);
                    if (ghEventService)
                    {
                        SetEvent (ghEventService);
                    }

#if DBG
                    DumpHandleList();
#endif
                }

                break;
            }
        }
    }

    InterlockedDecrement (&glNumActiveSPEventHandlerThreads);

    LOG((TL_TRACE,  "SPEventHandlerThread: exit (pid=%d)", GetCurrentThreadId()));

    ExitThread (0);
}


DWORD
InitSecurityDescriptor(
    PSECURITY_DESCRIPTOR pSecurityDescriptor,
    PSID * ppSid,
    PACL * ppDacl
    )
{
    //
    // Note: this code was borrowed from Steve Cobb, who borrowed from RASMAN
    //

    DWORD        dwResult;
    DWORD        cbDaclSize;
    PULONG       pSubAuthority;
    PSID         pObjSid    = NULL;
    PACL         pDacl      = NULL;
    SID_IDENTIFIER_AUTHORITY    SidIdentifierWorldAuth =
                                    SECURITY_WORLD_SID_AUTHORITY;

    //
    // The do - while(FALSE) statement is used so that the break statement
    // maybe used insted of the goto statement, to execute a clean up and
    // and exit action.
    //

    do
    {
        dwResult = 0;


        //
        // Set up the SID for the admins that will be allowed to have
        // access. This SID will have 1 sub-authorities
        // SECURITY_BUILTIN_DOMAIN_RID.
        //

        if (!(pObjSid = (PSID) ServerAlloc (GetSidLengthRequired (1))))
        {
            dwResult = GetLastError();
            LOG((TL_ERROR, "GetSidLengthRequired() failed, err=%d", dwResult));
            break;
        }

        if (!InitializeSid (pObjSid, &SidIdentifierWorldAuth, 1))
        {
            dwResult = GetLastError();
            LOG((TL_ERROR, "InitializeSid() failed, err=%d", dwResult));
            break;
        }


        //
        // Set the sub-authorities
        //

        pSubAuthority = GetSidSubAuthority (pObjSid, 0);
        *pSubAuthority = SECURITY_WORLD_RID;


        //
        // Set up the DACL that will allow all processeswith the above
        // SID all access. It should be large enough to hold all ACEs.
        //

        cbDaclSize = sizeof(ACCESS_ALLOWED_ACE) +
            GetLengthSid (pObjSid) +
            sizeof(ACL);

        if (!(pDacl = (PACL) ServerAlloc (cbDaclSize)))
        {
            dwResult = GetLastError ();
            break;
        }

        if (!InitializeAcl (pDacl, cbDaclSize, ACL_REVISION2))
        {
            dwResult = GetLastError();
            LOG((TL_ERROR, "InitializeAcl() failed, err=%d", dwResult));
            break;
        }


        //
        // Add the ACE to the DACL
        //

        if (!AddAccessAllowedAce(
                pDacl,
                ACL_REVISION2,
                STANDARD_RIGHTS_ALL | SPECIFIC_RIGHTS_ALL,
                pObjSid
                ))
        {
            dwResult = GetLastError();
            LOG((TL_ERROR, "AddAccessAllowedAce() failed, err=%d", dwResult));
            break;
        }


        //
        // Create the security descriptor an put the DACL in it.
        //

        if (!InitializeSecurityDescriptor (pSecurityDescriptor, 1))
        {
            dwResult = GetLastError();
            LOG((TL_ERROR,
                "InitializeSecurityDescriptor() failed, err=%d",
                dwResult
                ));

            break;
        }

        if (!SetSecurityDescriptorDacl(
                pSecurityDescriptor,
                TRUE,
                pDacl,
                FALSE
                ))
        {
            dwResult = GetLastError();
            LOG((TL_ERROR, "SetSecurityDescriptorDacl() failed, err=%d",dwResult));
            break;
        }


        //
        // Set owner for the descriptor
        //

        if (!SetSecurityDescriptorOwner(
                pSecurityDescriptor,
                NULL,
                FALSE
                ))
        {
            dwResult = GetLastError();
            LOG((TL_ERROR, "SetSecurityDescriptorOwnr() failed, err=%d",dwResult));
            break;
        }


        //
        // Set group for the descriptor
        //

        if (!SetSecurityDescriptorGroup(
                pSecurityDescriptor,
                NULL,
                FALSE
                ))
        {
            dwResult = GetLastError();
            LOG((TL_ERROR,"SetSecurityDescriptorGroup() failed, err=%d",dwResult));
            break;
        }

    } while (FALSE);

    *ppSid = pObjSid;
    *ppDacl = pDacl;
    return dwResult;
}

void
EventNotificationThread(
    LPVOID  pParams
    )
{
    struct
    {
        HANDLE  hMailslot;

        DWORD   dwData;

    } *pBuf;

    DWORD           dwID =  PtrToUlong (pParams),
                    dwBufSize = 512,
                    dwTimeout = INFINITE;
    PTCLIENT        ptClient;
    LIST_ENTRY      *pEntry;


    LOG((TL_TRACE,  "EventNotificationThread: enter"));

    if (!SetThreadPriority(
            GetCurrentThread(),
            THREAD_PRIORITY_ABOVE_NORMAL
            ))
    {
        LOG((TL_ERROR, "Could not raise priority of EventNotificationThread"));
    }


    //
    // The following will make control return to the thread as soon
    // as RpcCancelThread() is called
    //

    if ( RpcMgmtSetCancelTimeout (0) != RPC_S_OK )
    {
        LOG((TL_ERROR, "Could not set the RPC cancel timeout"));
    }

    pBuf = ServerAlloc (dwBufSize);
    if (!pBuf)
    {
        goto ExitHere;
    }

    while (1)
    {
        //
        // Wait for someone to tell us there's clients to notify
        //

        if (dwID == 0)
        {
            Sleep (DGCLIENT_TIMEOUT);

walkDgClient_list:

            if (gEventNotificationThreadParams.bExit)
            {
                break;
            }


            //
            // Check to see if there are any connectionless clients
            // that we should notify.
            //

            if (!IsListEmpty (&DgClientMsgPendingListHead))
            {

                DWORD   i, j, dwTickCount, dwBytesWritten, dwNeededSize;


                //
                // Build a list of connectionless clients that we should
                // notify of pending events
                //
                // Note: the fact that we're in the critical section & the
                // tClient is in the list means that we can safely access
                // the tClient.
                //

                dwTickCount = GetTickCount();

                EnterCriticalSection (&gDgClientMsgPendingCritSec);

                pEntry = DgClientMsgPendingListHead.Flink;

                for(
                    i = 0, dwNeededSize = sizeof (*pBuf);
                    pEntry != &DgClientMsgPendingListHead;
                    dwNeededSize += sizeof (*pBuf)
                    )
                {
                    do
                    {
                        ptClient = CONTAINING_RECORD(
                            pEntry,
                            TCLIENT,
                            MsgPendingListEntry
                            );

                        pEntry = pEntry->Flink;

                        if ((ptClient->dwDgRetryTimeoutTickCount - dwTickCount)
                                & 0x80000000)
                        {
                            //
                            // Check the last time the client retrieved
                            // events, & if it's been too long then nuke
                            // them.
                            //
                            // Ideally, RPC should notify us of a
                            // disconnected client via our rundown routine.
                            // But we have seen in rstress that this is not
                            // always the case (in fact, we wind up with 2
                            // or more active instances of the same client
                            // machine!), and so we use this watchdog scheme
                            // for backup.  Otherwise, a stale client might
                            // have lines open w/ owner or monitor privs
                            // and it's event queue would grow & grow.
                            //

                            if ((dwTickCount -
                                    ptClient->dwDgEventsRetrievedTickCount) >
                                        gdwRpcTimeout)
                            {
                                LOG((TL_ERROR,
                                    "EventNotificationThread: timeout, " \
                                        "cleaning up Dg client=x%p",
                                    ptClient
                                    ));

                                LeaveCriticalSection(
                                    &gDgClientMsgPendingCritSec
                                    );

                                CleanUpClient (ptClient, FALSE);

                                goto walkDgClient_list;
                            }

                            //
                            // Grow the buffer if necessary
                            //

                            if (dwNeededSize > dwBufSize)
                            {
                                LPVOID  p;


                                if ((p = ServerAlloc (dwBufSize + 512)))
                                {
                                    CopyMemory (p, pBuf, dwBufSize);

                                    ServerFree (pBuf);

                                    (LPVOID) pBuf = p;

                                    dwBufSize += 512;
                                }
                                else
                                {
                                    pEntry = &DgClientMsgPendingListHead;

                                    break;
                                }
                            }

                            ptClient->dwDgRetryTimeoutTickCount = dwTickCount +
                                DGCLIENT_TIMEOUT;

                            pBuf[i].hMailslot =
                                ptClient->hValidEventBufferDataEvent;

                            try
                            {
                                if (ptClient->ptLineApps)
                                {
                                    pBuf[i].dwData = (DWORD)
                                        ptClient->ptLineApps->InitContext;
                                }
                                else
                                {
                                    pBuf[i].dwData = 0;
                                }
                            }
                            myexcept
                            {
                                pBuf[i].dwData = 0;
                            }

                            i++;

                            break;
                        }

                    } while (pEntry != &DgClientMsgPendingListHead);
                }

                LeaveCriticalSection (&gDgClientMsgPendingCritSec);


                //
                // Notify those clients
                //

                for (j = 0; j < i; j++)
                {
                    if (!WriteFile(
                            pBuf[j].hMailslot,
                            &pBuf[j].dwData,
                            sizeof (DWORD),
                            &dwBytesWritten,
                            (LPOVERLAPPED) NULL
                            ))
                    {
                        LOG((TL_ERROR,
                            "EventNotificationThread: Writefile(mailslot) " \
                                "failed, err=%d",
                            GetLastError()
                            ));
                    }
                }
            }

            continue;
        }
        else
        {
            WaitForSingleObject(
                gEventNotificationThreadParams.hEvent,
                INFINITE
                );
        }


        if (gEventNotificationThreadParams.bExit)
        {
            break;
        }


        if (!IsListEmpty (&CnClientMsgPendingListHead))
        {
            //
            // Try to find a remote client with pending messages that no
            // other EventNotificationThread is currently servicing.
            // If we find one, then mark it busy, remove it from the
            // list, & then break out of the loop.
            //
            // Note: the fact that we're in the critical section & the
            // tClient is in the list means that we can safely access
            // the tClient.
            //

findCnClientMsgPending:

            EnterCriticalSection (&gCnClientMsgPendingCritSec);

            for(
                pEntry = CnClientMsgPendingListHead.Flink;
                pEntry != &CnClientMsgPendingListHead;
                pEntry = pEntry->Flink
                )
            {
                ptClient = CONTAINING_RECORD(
                    pEntry,
                    TCLIENT,
                    MsgPendingListEntry
                    );

                if (!ptClient->dwCnBusy)
                {
                    ptClient->dwCnBusy = 1;
                    RemoveEntryList (pEntry);
                    ptClient->MsgPendingListEntry.Flink =
                    ptClient->MsgPendingListEntry.Blink = NULL;
                    break;
                }
            }

            LeaveCriticalSection (&gCnClientMsgPendingCritSec);


            //
            // If a remote client was found then copy all it's event
            // data over to our local buffer & send it off
            //

            if (pEntry != &CnClientMsgPendingListHead)
            {
                if (WaitForExclusiveClientAccess (ptClient))
                {
                    DWORD                   dwMoveSize,
                                            dwMoveSizeWrapped,
                                            dwRetryCount;
                    PCONTEXT_HANDLE_TYPE2   phContext;


                    //
                    // We want to copy all the events in the tClient's
                    // buffer to our local buffer in one shot, so see
                    // if we need to grow our buffer first
                    //

                    if (ptClient->dwEventBufferUsedSize > dwBufSize)
                    {
                        LPVOID  p;


                        if (!(p = ServerAlloc(
                                ptClient->dwEventBufferUsedSize
                                )))
                        {
                            UNLOCKTCLIENT (ptClient);
                            break;
                        }

                        ServerFree (pBuf);

                        (LPVOID) pBuf = p;

                        dwBufSize = ptClient->dwEventBufferUsedSize;
                    }

                    if (ptClient->pDataOut < ptClient->pDataIn)
                    {
                        dwMoveSize = (DWORD)
                            (ptClient->pDataIn - ptClient->pDataOut);

                        dwMoveSizeWrapped = 0;
                    }
                    else
                    {
                        dwMoveSize = ptClient->dwEventBufferTotalSize - (DWORD)
                            (ptClient->pDataOut - ptClient->pEventBuffer);

                        dwMoveSizeWrapped = (DWORD) (ptClient->pDataIn -
                            ptClient->pEventBuffer);
                    }

                    CopyMemory (pBuf, ptClient->pDataOut, dwMoveSize);

                    if (dwMoveSizeWrapped)
                    {
                        CopyMemory(
                            pBuf + dwMoveSize,
                            ptClient->pEventBuffer,
                            dwMoveSizeWrapped
                            );
                    }

                    ptClient->dwEventBufferUsedSize = 0;

                    ptClient->pDataIn  =
                    ptClient->pDataOut = ptClient->pEventBuffer;

                    phContext = ptClient->phContext;

                    UNLOCKTCLIENT (ptClient);


                    //
                    // Set the watchdog entry for this thread indicating
                    // what client we're talking to & when we started
                    //

                    gEventNotificationThreadParams.pWatchDogStruct[dwID].
                        dwTickCount = GetTickCount();
                    gEventNotificationThreadParams.pWatchDogStruct[dwID].
                        ptClient = ptClient;


                    //
                    // Send the data
                    //

                    dwRetryCount = gdwRpcRetryCount;

                    while (dwRetryCount)
                    {
                        RpcTryExcept
                        {
                            RemoteSPEventProc(
                                phContext,
                                (unsigned char *) pBuf,
                                dwMoveSize + dwMoveSizeWrapped
                                );

                            dwRetryCount = 0;
                        }
                        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
                        {
                            unsigned long ulResult = RpcExceptionCode();


                            LOG((TL_ERROR,
                                "EventNotificationThread: exception #%d",
                                ulResult
                                ));

                            if ((ulResult == RPC_S_CALL_CANCELLED) ||
                                (ulResult == ERROR_INVALID_HANDLE))
                            {
                                LOG((TL_ERROR,
                                    "EventNotificationThread: rpc timeout " \
                                        "(ptClient=x%p)",
                                    ptClient
                                    ));


                                //
                                // The canceled because of a timeout.
                                // Flag the context, so we don't try
                                // to call it again!
                                //

                                CleanUpClient (ptClient, FALSE);


                                //
                                // When using TCP, or SPX, RPC will probably
                                // toast the session context, so we'll not
                                // be able to call to the client again.
                                //
                                // (If RpcCancelThread() is called and the
                                // server ACKs within the time set int
                                // RpcMgmtSetCancelTimeout(), RPC
                                // (well, the underlying transport) _won't_
                                // kill the context, but how likely is that...)
                                //

                                dwRetryCount = 1; // so it'll go to 0 after --
                            }

                            dwRetryCount--;
                        }
                        RpcEndExcept
                    }


                    gEventNotificationThreadParams.pWatchDogStruct[dwID].
                        ptClient = NULL;


                    //
                    // Safely reset the tClient.dwCnBusy flag
                    //

                    if (WaitForExclusiveClientAccess (ptClient))
                    {
                        ptClient->dwCnBusy = 0;

                        UNLOCKTCLIENT (ptClient);
                    }
                }

                goto findCnClientMsgPending;
            }
        }

        dwTimeout = INFINITE;

        ResetEvent (gEventNotificationThreadParams.hEvent);
    }

ExitHere:
    ServerFree (pBuf);

    CloseHandle (gEventNotificationThreadParams.phThreads[dwID]);

    InterlockedDecrement(
        (LPLONG) &gEventNotificationThreadParams.dwNumThreads
        );

    LOG((TL_TRACE,  "EventNotificationThread: exit"));

    ExitThread (0);
}


void
__RPC_FAR *
__RPC_API
midl_user_allocate(
    size_t len
    )
{
    return (ServerAlloc(len));
}


void
__RPC_API
midl_user_free(
    void __RPC_FAR * ptr
    )
{
    ServerFree (ptr);
}


#if TELE_SERVER

// implement these functions!
void
ManagementAddLineProc(
    PTCLIENT    ptClient,
    DWORD       dwReserved
    )
{
    ASYNCEVENTMSG        msg;

    // this should sent linedevstate_reinit message to remotesp

    msg.TotalSize          = sizeof(msg);
    msg.InitContext        = ptClient->ptLineApps->InitContext;
    msg.fnPostProcessProcHandle = 0;
    msg.hDevice            = 0;
    msg.Msg                = LINE_LINEDEVSTATE;
    msg.OpenContext        = 0;
    msg.Param1             = LINEDEVSTATE_REINIT;
    msg.Param2             = RSP_MSG;
    msg.Param3             = 0;
    msg.Param4             = 0;

    WriteEventBuffer (ptClient, &msg);
}


void
ManagementAddPhoneProc(
    PTCLIENT    ptClient,
    DWORD       dwReserved
    )
{
    ASYNCEVENTMSG        msg;

    // this should sent linedevstate_reinit message to remotesp

    msg.TotalSize          = sizeof(msg);
    msg.InitContext        = ptClient->ptLineApps->InitContext;
    msg.fnPostProcessProcHandle = 0;
    msg.hDevice            = 0;
    msg.Msg                = LINE_LINEDEVSTATE;
    msg.OpenContext        = 0;
    msg.Param1             = LINEDEVSTATE_REINIT;
    msg.Param2             = RSP_MSG;
    msg.Param3             = 0;
    msg.Param4             = 0;

    WriteEventBuffer (ptClient, &msg);
}


void
CleanUpManagementMemory(
    )
{
    PTMANAGEDLLINFO             pDll, pDllHold;
    PPERMANENTIDARRAYHEADER     pIDArray, pArrayHold;

    if (!(TapiGlobals.dwFlags & TAPIGLOBALS_SERVER))
    {
        return;
    }

    (TapiGlobals.pMapperDll->aProcs[TC_FREE])();

    FreeLibrary(TapiGlobals.pMapperDll->hDll);
    ServerFree (TapiGlobals.pMapperDll->pszName);
    ServerFree (TapiGlobals.pMapperDll);

    TapiGlobals.pMapperDll = NULL;

    if (TapiGlobals.pManageDllList)
    {
        pDll = TapiGlobals.pManageDllList->pFirst;

        while (pDll)
        {
            (pDll->aProcs[TC_FREE])();

            FreeLibrary (pDll->hDll);
            ServerFree (pDll->pszName);

            pDllHold = pDll->pNext;
            ServerFree (pDll);
            pDll = pDllHold;
        }

        ServerFree (TapiGlobals.pManageDllList);

        TapiGlobals.pManageDllList = NULL;
    }

    pIDArray = TapiGlobals.pIDArrays;

    while (pIDArray)
    {
        ServerFree (pIDArray->pLineElements);
        ServerFree (pIDArray->pPhoneElements);

        pArrayHold = pIDArray->pNext;

        ServerFree (pIDArray);

        pIDArray = pArrayHold;
    }

}


void
GetProviderSortedArray(
    DWORD                   dwProviderID,
    PPERMANENTIDARRAYHEADER *ppArrayHeader
    )
{
    *ppArrayHeader = TapiGlobals.pIDArrays;

    // look for the provider in the list
    while (*ppArrayHeader)
    {
        if ((*ppArrayHeader)->dwPermanentProviderID == dwProviderID)
        {
            return;
        }

        *ppArrayHeader = (*ppArrayHeader)->pNext;
    }

    LOG((TL_ERROR,
		"Couldn't find Provider - id %d pIDArrays %p",
        dwProviderID,
        TapiGlobals.pIDArrays
        ));

    *ppArrayHeader = NULL;

    return;
}


BOOL
GetLinePermanentIdFromDeviceID(
    PTCLIENT            ptClient,
    DWORD               dwDeviceID,
    LPTAPIPERMANENTID   pID
    )
{
    LPDWORD                 pDevices = ptClient->pLineDevices;
    DWORD                   dwCount = ptClient->dwLineDevices;

    while (dwCount)
    {
        dwCount--;
        if (pDevices[dwCount] == dwDeviceID)
        {
            pID->dwProviderID = ptClient->pLineMap[dwCount].dwProviderID;
            pID->dwDeviceID = ptClient->pLineMap[dwCount].dwDeviceID;

            return TRUE;
        }
    }

    LOG((TL_INFO,
        "GetLinePermanentIdFromDeviceID failed for %d device",
        dwDeviceID
        ));

    return FALSE;

}


BOOL
GetPhonePermanentIdFromDeviceID(
    PTCLIENT            ptClient,
    DWORD               dwDeviceID,
    LPTAPIPERMANENTID   pID
    )
{
    LPDWORD                 pDevices = ptClient->pPhoneDevices;
    DWORD                   dwCount = ptClient->dwPhoneDevices;

    while (dwCount)
    {
        dwCount--;
        if (pDevices[dwCount] == dwDeviceID)
        {
            pID->dwProviderID = ptClient->pPhoneMap[dwCount].dwProviderID;
            pID->dwDeviceID = ptClient->pPhoneMap[dwCount].dwDeviceID;

            return TRUE;
        }
    }

    LOG((TL_INFO,
        "GetPhonePermanentIdFromDeviceID failed for %d device",
        dwDeviceID
        ));

    return FALSE;

}


DWORD
GetDeviceIDFromPermanentID(
    TAPIPERMANENTID ID,
    BOOL  bLine
    )
/*++

    Gets the regulare tapi device ID from the permanent ID

--*/
{
    PPERMANENTIDARRAYHEADER     pArrayHeader;
    PPERMANENTIDELEMENT         pArray;
    LONG                        lLow, lHigh, lMid;
    DWORD                       dwTotalElements;
    DWORD                       dwPermanentID;


    dwPermanentID = ID.dwDeviceID;

    // get the array corresponding to this provider ID

    GetProviderSortedArray (ID.dwProviderID, &pArrayHeader);

    if (!pArrayHeader)
    {
        LOG((TL_ERROR, "Couldn't find the provider in the permanent array list!"));
        return 0xFFFFFFFF;
    }


    //
    // Serialize access to the device array
    //

    while (InterlockedExchange (&pArrayHeader->lCookie, 1) == 1)
    {
        Sleep (10);
    }

    // set up stuff for search
    // dwCurrent is a total - subtract one to make it an index into array.

    if (bLine)
    {
        lHigh = (LONG)(pArrayHeader->dwCurrentLines - 1);
        pArray = pArrayHeader->pLineElements;
        dwTotalElements = pArrayHeader->dwNumLines;
    }
    else
    {
        lHigh = (LONG)(pArrayHeader->dwCurrentPhones - 1);
        pArray = pArrayHeader->pPhoneElements;
        dwTotalElements = pArrayHeader->dwNumPhones;
    }

    lLow = 0;

    // binary search through the provider's id array

    // this search is from a book, so it must be right.
    while (lHigh >= lLow)
    {
        lMid = (lHigh + lLow) / 2;

        if (dwPermanentID == pArray[lMid].dwPermanentID)
        {
            InterlockedExchange (&pArrayHeader->lCookie, 0);

            return pArray[lMid].dwDeviceID;
        }

        if (dwPermanentID < pArray[lMid].dwPermanentID)
        {
            lHigh = lMid-1;
        }
        else
        {
            lLow = lMid+1;
        }
    }

    InterlockedExchange (&pArrayHeader->lCookie, 0);

    return 0xFFFFFFFF;
}


void
InsertIntoTable(
    BOOL        bLine,
    DWORD       dwDeviceID,
    PTPROVIDER  ptProvider,
    DWORD       dwPermanentID
    )
{
    PPERMANENTIDARRAYHEADER     pArrayHeader;
    PPERMANENTIDELEMENT         pArray;
    LONG                        lLow, lHigh, lMid;
    DWORD                       dwTotalElements, dwCurrentElements;


    GetProviderSortedArray (ptProvider->dwPermanentProviderID, &pArrayHeader);

    if (!pArrayHeader)
    {
        LOG((TL_ERROR, "Couldn't find the provider in the permanent array list!"));
        return;
    }

    //
    // Serialize access to the device array
    //

    while (InterlockedExchange (&pArrayHeader->lCookie, 1) == 1)
    {
        Sleep (10);
    }


    //
    // set up stuff for search
    // dwCurrent is a total - subtract one to make it an index into array.
    //

    if (bLine)
    {
        dwCurrentElements = pArrayHeader->dwCurrentLines;
        pArray = pArrayHeader->pLineElements;
        dwTotalElements = pArrayHeader->dwNumLines;
    }
    else
    {
        dwCurrentElements = pArrayHeader->dwCurrentPhones;
        pArray = pArrayHeader->pPhoneElements;
        dwTotalElements = pArrayHeader->dwNumPhones;
    }


    lLow = 0;
    lHigh = dwCurrentElements-1;

    // binary search

    if (dwCurrentElements > 0)
    {
        while (TRUE)
        {
            lMid = ( lHigh + lLow ) / 2 + ( lHigh + lLow ) % 2;

            if (lHigh < lLow)
            {
                break;
            }

            if (pArray[lMid].dwPermanentID == dwPermanentID)
            {
                LOG((TL_ERROR,
                    "Trying to insert an item already in the perm ID array"
                    ));

                LOG((TL_ERROR,
                    "Provider %s, %s array, ID 0x%lu",
                    ptProvider->szFileName,
                    (bLine ? "Line" : "Phone"),
                    dwPermanentID
                    ));
            }

            if (pArray[lMid].dwPermanentID > dwPermanentID)
            {
                lHigh = lMid-1;
            }
            else
            {
                lLow = lMid+1;
            }
        }
    }

    //
    //  Grow the table if necessary
    //

    if (dwCurrentElements >= dwTotalElements)
    {
        PPERMANENTIDELEMENT      pNewArray;

        // realloc array by doubling it

        if (!(pNewArray = ServerAlloc(
                dwTotalElements * 2 * sizeof(PERMANENTIDELEMENT)
                )))
        {
            InterlockedExchange (&pArrayHeader->lCookie, 0);

            return;
        }

        // copy old stuff over

        CopyMemory(
            pNewArray,
            pArray,
            dwTotalElements * sizeof(PERMANENTIDELEMENT)
            );

        // free old array

        ServerFree (pArray);

        // save new array

        if (bLine)
        {
            pArrayHeader->dwNumLines = dwTotalElements * 2;
            pArray = pArrayHeader->pLineElements = pNewArray;
        }
        else
        {
            pArrayHeader->dwNumPhones = dwTotalElements * 2;
            pArray = pArrayHeader->pPhoneElements = pNewArray;
        }
    }

    // dwCurrentElements is a count (1 based), lLow is an index (0 based)
    // if lLow is < dwcurrent, then it's getting inserted somewhere in the
    // middle of the array, so scootch all the other elements out.

    if (lLow < (LONG)dwCurrentElements)
    {
        MoveMemory(
            &(pArray[lLow+1]),
            &(pArray[lLow]),
            sizeof(PERMANENTIDELEMENT) * (dwCurrentElements - lLow)
            );
    }

    if (lLow > (LONG)dwCurrentElements)
    {
        LOG((TL_INFO,
            "InsertIntoTable: lLow %d > dwCurrentElements %d",
            lLow,
            dwCurrentElements
            ));
    }

    pArray[lLow].dwPermanentID = dwPermanentID;
    pArray[lLow].dwDeviceID = dwDeviceID;

    if (bLine)
    {
        pArrayHeader->dwCurrentLines++;
    }
    else
    {
        pArrayHeader->dwCurrentPhones++;
    }

    InterlockedExchange (&pArrayHeader->lCookie, 0);
}


void
FreeDll(
    PTMANAGEDLLINFO pDll
    )
{
}


LONG
AddProviderToIdArrayList(
    PTPROVIDER ptProvider,
    DWORD dwNumLines,
    DWORD dwNumPhones
    )
/*++

    Adds a new provider corresponding array to the list of
    permanent device ID arrays

--*/
{
    PPERMANENTIDARRAYHEADER       pNewArray;


    //
    // Alloc a header & arrays for this provider (make sure at least
    // 1 entry in each array)
    //

    if (!(pNewArray = ServerAlloc(sizeof(PERMANENTIDARRAYHEADER))))
    {
        return LINEERR_NOMEM;
    }

    dwNumLines = (dwNumLines ? dwNumLines : 1);
    dwNumPhones = (dwNumPhones ? dwNumPhones : 1);

    pNewArray->pLineElements = ServerAlloc(
        sizeof(PERMANENTIDELEMENT) * dwNumLines
        );

    pNewArray->pPhoneElements = ServerAlloc(
        sizeof(PERMANENTIDELEMENT) * dwNumPhones
        );

    if ((!pNewArray->pLineElements) || (!pNewArray->pPhoneElements))
    {
        ServerFree (pNewArray->pLineElements);
        ServerFree (pNewArray->pPhoneElements);
        ServerFree (pNewArray);
        return LINEERR_NOMEM;
    }


    //
    // Initialize elements
    //

    pNewArray->dwNumLines = dwNumLines;
    pNewArray->dwNumPhones = dwNumPhones;

    pNewArray->dwCurrentLines = 0;
    pNewArray->dwCurrentPhones = 0;

    pNewArray->dwPermanentProviderID = ptProvider->dwPermanentProviderID;


    //
    // Insert at the beginning of the list
    //

    pNewArray->pNext = TapiGlobals.pIDArrays;
    TapiGlobals.pIDArrays = pNewArray;

    return 0;
}


LONG
GetDeviceAccess(
    PTMANAGEDLLINFO     pDll,
    PTCLIENT            ptClient,
    HMANAGEMENTCLIENT   hClient
    )
/*++

    Calls the mapper DLL to get the access map arrays for a client

--*/
{
    LONG                        lResult;
    DWORD                       dwLineDevs, dwPhoneDevs, dwCount;
    DWORD                       dwNumLinesHold, dwNumPhonesHold, dwRealDevs;
    LPTAPIPERMANENTID           pLineMap = NULL, pPhoneMap = NULL;


#define DEFAULTACCESSDEVS       3

    dwLineDevs = DEFAULTACCESSDEVS;
    dwPhoneDevs = DEFAULTACCESSDEVS;

    // alloc an default array size
    if (!(pLineMap = ServerAlloc (dwLineDevs * sizeof (TAPIPERMANENTID))))
    {
        goto GetDeviceAccess_MemoryError;
    }

    if (!(pPhoneMap = ServerAlloc (dwPhoneDevs * sizeof (TAPIPERMANENTID))))
    {
        goto GetDeviceAccess_MemoryError;
    }

    // call the mapper dll
//    LOG((TL_INFO, "Calling GetDeviceAccess in mapper DLL"));

    while (TRUE)
    {
        dwNumLinesHold = dwLineDevs;
        dwNumPhonesHold = dwPhoneDevs;

        lResult = (pDll->aProcs[TC_GETDEVICEACCESS])(
            hClient,
            ptClient,
            pLineMap,
            &dwLineDevs,
            pPhoneMap,
            &dwPhoneDevs
            );

        if (lResult == LINEERR_STRUCTURETOOSMALL)
        {
            if (dwLineDevs < dwNumLinesHold)
            {
                LOG((TL_ERROR,
                    "Returned STRUCTURETOOSMALL, but specified less " \
                        "line devs in TAPICLINET_GETDEVICEACCESS"
                    ));
            }

            if (dwPhoneDevs < dwNumPhonesHold)
            {
                LOG((TL_ERROR,
                    "Returned STRUCTURETOOSMALL, but specified less " \
                        "phone devs in TAPICLINET_GETDEVICEACCESS"
                    ));
            }

            // realloc
            ServerFree (pLineMap);

            if (!(pLineMap = ServerAlloc(
                    dwLineDevs * sizeof (TAPIPERMANENTID)
                    )))
            {
                goto GetDeviceAccess_MemoryError;
            }

            ServerFree (pPhoneMap);
            
            if (!(pPhoneMap = ServerAlloc(
                    dwPhoneDevs * sizeof ( TAPIPERMANENTID)
                    )))
            {
                goto GetDeviceAccess_MemoryError;
            }

        }
        else
        {
            break;
        }
    }

    // if still an error
    if (lResult)
    {
        LOG((TL_ERROR, "GetDeviceAccess failed - error %lu", lResult));

        ServerFree (pLineMap);
        ServerFree (pPhoneMap);

        return lResult;
    }

    if (dwLineDevs > dwNumLinesHold)
    {
        LOG((TL_ERROR, "Returned dwLineDevs greater that the buffer specified in TAPICLIENT_GETDEVICEACCESS"));
        LOG((TL_ERROR, "   Will only use the number the buffer can hold"));

        dwLineDevs = dwNumLinesHold;
    }

    if (dwPhoneDevs > dwNumPhonesHold)
    {
        LOG((TL_ERROR, "Returned dwPhoneDevs greater that the buffer specified in TAPICLIENT_GETDEVICEACCESS"));
        LOG((TL_ERROR, "   Will only use the number the buffer can hold"));

        dwPhoneDevs = dwNumPhonesHold;
    }

    // alloc another array for regular tapi device IDs
    if (!(ptClient->pLineDevices = ServerAlloc( dwLineDevs * sizeof (DWORD) ) ) )
    {
        goto GetDeviceAccess_MemoryError;
    }

    // alloc a permanent ID array
    if (!(ptClient->pLineMap = ServerAlloc( dwLineDevs * sizeof (TAPIPERMANENTID) ) ) )
    {
        goto GetDeviceAccess_MemoryError;
    }

    // loop through all the mapped elements and get the regular
    // tapi device ID
    dwRealDevs = 0;
    for (dwCount = 0; dwCount < dwLineDevs; dwCount++)
    {
        DWORD dwID;

        dwID = GetDeviceIDFromPermanentID(
                                          pLineMap[dwCount],
                                          TRUE
                                         );

        // make sure it's a good id
        if ( dwID != 0xffffffff )
        {
            // save it
            ptClient->pLineDevices[dwRealDevs] = dwID;
            ptClient->pLineMap[dwRealDevs].dwProviderID = pLineMap[dwCount].dwProviderID;
            ptClient->pLineMap[dwRealDevs].dwDeviceID = pLineMap[dwCount].dwDeviceID;

            // inc real devs
            dwRealDevs++;
        }

    }

    // save the real number of devices
    ptClient->dwLineDevices = dwRealDevs;

    // free the line map
    ServerFree (pLineMap);

    // now do phone devices
    if (!(ptClient->pPhoneDevices = ServerAlloc( dwPhoneDevs * sizeof (DWORD) ) ) )
    {
        goto GetDeviceAccess_MemoryError;
    }

    if (!(ptClient->pPhoneMap = ServerAlloc( dwPhoneDevs * sizeof (TAPIPERMANENTID) ) ) )
    {
        goto GetDeviceAccess_MemoryError;
    }

    dwRealDevs = 0;
    for (dwCount = 0; dwCount < dwPhoneDevs; dwCount++)
    {
        DWORD       dwID;

        dwID = GetDeviceIDFromPermanentID(
                                          pPhoneMap[dwCount],
                                          FALSE
                                         );

        if ( 0xffffffff != dwID )
        {
            ptClient->pPhoneDevices[dwRealDevs] = dwID;
            ptClient->pPhoneMap[dwRealDevs].dwProviderID = pPhoneMap[dwCount].dwProviderID;
            ptClient->pPhoneMap[dwRealDevs].dwDeviceID = pPhoneMap[dwCount].dwDeviceID;

            dwRealDevs++;
        }
    }

    // save the real number of devices
    ptClient->dwPhoneDevices = dwRealDevs;

    // free the original map
    ServerFree (pPhoneMap);

    return 0;

GetDeviceAccess_MemoryError:

    if (pLineMap != NULL)
        ServerFree (pLineMap);

    if (pPhoneMap != NULL)
        ServerFree (pPhoneMap);

    if (ptClient->pLineMap != NULL)
        ServerFree (ptClient->pLineMap);

    if (ptClient->pPhoneMap != NULL)
        ServerFree (ptClient->pPhoneMap);

    return LINEERR_NOMEM;

}


LONG
InitializeClient(
    PTCLIENT ptClient
    )
{
    PTMANAGEDLLINFO         pDll;
    PTMANAGEDLLLISTHEADER   pDllList;
    PTCLIENTHANDLE          pClientHandle = NULL;

    LONG                    lResult = 0;


    if (!(TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) ||
        IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
    {
        return 0;
    }

    // call the mapper DLL

    pDll = TapiGlobals.pMapperDll;

    lResult = (pDll->aProcs[TC_CLIENTINITIALIZE])(
        ptClient->pszDomainName,
        ptClient->pszUserName,
        ptClient->pszComputerName,
        &ptClient->hMapper
        );

    if (lResult != 0)
    {
        // error on init
        LOG((TL_ERROR, "ClientInitialize internal failure - error %lu", lResult));
        //LOG((TL_ERROR, "Disabling the Telephony server! (2)"));

        //TapiGlobals.bServer = FALSE;

        //CleanUpManagementMemory();

        return lResult;
    }

    if (lResult = GetDeviceAccess(
                         pDll,
                         ptClient,
                         ptClient->hMapper
                        ))
    {
        LOG((TL_ERROR, "GetDeviceAccess failed - error x%lx", lResult));
        //LOG((TL_ERROR, "Disabling the Telephony server! (3)"));

        //TapiGlobals.bServer = FALSE;

        //CleanUpManagementMemory();

        return lResult;
    }

    // get the manage dll list
    GetManageDllListPointer(&pDllList);

    if (pDllList && (pDll = pDllList->pFirst))
    {
        if (!(pClientHandle = ServerAlloc(sizeof(TCLIENTHANDLE))))
        {
            lResult = LINEERR_NOMEM;

            goto clientinit_exit;
        }

        ptClient->pClientHandles = pClientHandle;

        while (pDll)
        {
            // walk the list and call init for this client

            pClientHandle->dwID = pDll->dwID;
            pClientHandle->fValid = TRUE;

            // call init
            if (lResult = (pDll->aProcs[TC_CLIENTINITIALIZE])(
                ptClient->pszDomainName,
                ptClient->pszUserName,
                ptClient->pszComputerName,
                &pClientHandle->hClient
                ))
            {
                // failed client init
                LOG((TL_ERROR, "ClientInitialize failed for %ls, result x%lx", pDll->pszName, lResult));

                pClientHandle->fValid = FALSE;
            }

            lResult = 0;

            // if there's another DLL, setup another structure
            if (pDll = pDll->pNext)
            {
                if (!(pClientHandle->pNext = ServerAlloc(sizeof(TCLIENTHANDLE))))
                {
                    lResult = LINEERR_NOMEM;

                    goto clientinit_exit;
                }

                pClientHandle = pClientHandle->pNext;
            }

        }
    }

clientinit_exit:

    FreeManageDllListPointer(pDllList);

    return lResult;

}

#endif

BOOL ValidClientAttachParams(
    long                    lProcessID,
    wchar_t                *pszDomainUser,
    wchar_t                *pszMachineIn
    )
{
    wchar_t *   pBinding;
    wchar_t *   pPlaceHolder;
    wchar_t *   pProtocolSequence;
    int         idxPair;

    if (NULL == pszDomainUser || NULL == pszMachineIn)
    {
        return FALSE;
    }

    if (lProcessID == 0xffffffff)
    {
        // This is a remote client
        // pszMachineIn should have the format:
        //      machinename"binding0"endpoint0" ... bindingN"endpointN"   (new style) or
        //      machinename"binding"endpoint   (old style)

        pPlaceHolder = wcschr( pszMachineIn, L'\"' );
        if (NULL == pPlaceHolder || pPlaceHolder == pszMachineIn)
        {
            return FALSE;
        }

        // validate binding/endpoint pairs
        idxPair = 0;
        do 
        {
            idxPair++;
            pBinding = pPlaceHolder + 1;
            pPlaceHolder = wcschr( pBinding, L'\"' );
            if (NULL == pPlaceHolder || pPlaceHolder == pBinding)
            {
                return FALSE;
            }

            pProtocolSequence = pPlaceHolder + 1;
            pPlaceHolder = wcschr( pProtocolSequence, L'\"' );
            if (NULL == pPlaceHolder)
            {
                if (idxPair >1)
                {
                    return FALSE;
                }
            }
            else
            {
                if (pPlaceHolder == pProtocolSequence)
                {
                    return FALSE;
                }

                if (*(pPlaceHolder + 1) == '\0')
                {
                    pPlaceHolder = NULL;
                }
            }
        } while (NULL != pPlaceHolder);
    }

    return TRUE;
}

LONG
ClientAttach(
    PCONTEXT_HANDLE_TYPE   *pphContext,
    long                    lProcessID,
    long                   *phAsyncEventsEvent,
    wchar_t                *pszDomainUser,
    wchar_t                *pszMachineIn
    )
{
    PTCLIENT            ptClient;
    wchar_t             *pszMachine;
    wchar_t             *pProtocolSequence;
    wchar_t             *pProtocolEndpoint;
    wchar_t             *pPlaceHolder;
    LONG                lResult = 0;

    #define NAMEBUFSIZE 96

    WCHAR                   szAccountName[NAMEBUFSIZE],
                            szDomainName[NAMEBUFSIZE];
    DWORD                   dwInfoBufferSize, dwSize,
                            dwAccountNameSize = NAMEBUFSIZE *sizeof(WCHAR),
                            dwDomainNameSize = NAMEBUFSIZE *sizeof(WCHAR);
    HANDLE                  hThread, hAccessToken;
    LPWSTR                  InfoBuffer = NULL;
    PSID                    psidAdministrators;
    SID_IDENTIFIER_AUTHORITY siaNtAuthority = SECURITY_NT_AUTHORITY;
    UINT                    x;
    PTOKEN_USER             ptuUser;
    SID_NAME_USE            use;
    RPC_STATUS              status;
    DWORD                   dwException = 0; 

#if TELE_SERVER
    RPC_CALL_ATTRIBUTES     RPCAttributes;
#endif

    if (!ValidClientAttachParams(lProcessID, pszDomainUser, pszMachineIn))
    {
        lResult = LINEERR_INVALPARAM;
        goto ClientAttach_error0;
    }

    LOG((TL_TRACE, 
        "ClientAttach: enter, pid=x%x, user='%ls', machine='%ls'",
        lProcessID,
        pszDomainUser,
        pszMachineIn
        ));


    //
    // The new remotesp will send in pszMachine thus:
    //     machinename"binding0"endpoint0" ... bindingN"endpointN"
    //

    pszMachine = pszMachineIn;

    if ( pPlaceHolder = wcschr( pszMachineIn, L'\"' ) )
    {
        *pPlaceHolder = L'\0';
        pProtocolSequence = pPlaceHolder + 1;
    }


    //
    // Alloc & init a tClient struct
    //

    if (!(ptClient = ServerAlloc (sizeof(TCLIENT))))
    {
        goto ClientAttach_error0;
    }
    ptClient->htClient = NewObject(
                            ghHandleTable, ptClient, NULL);
    if (ptClient->htClient == 0)
    {
        ServerFree(ptClient);
        goto ClientAttach_error0;
    }

    if (!(ptClient->pEventBuffer = ServerAlloc(
            INITIAL_EVENT_BUFFER_SIZE
            )))
    {
        goto ClientAttach_error1;
    }

    ptClient->dwEventBufferTotalSize = INITIAL_EVENT_BUFFER_SIZE;
    ptClient->dwEventBufferUsedSize  = 0;

    ptClient->pDataIn = ptClient->pDataOut = ptClient->pEventBuffer;

    ptClient->pClientHandles = NULL;

#if TELE_SERVER

    //
    // If an authorized user did a NET PAUSE TAPISRV, don't allow new
    // remote clients.
    //

    if ( TapiGlobals.dwFlags & TAPIGLOBALS_PAUSED )
    {
        if ((lProcessID == 0xffffffff) || (lProcessID == 0xfffffffd))
        {
            LOG((TL_ERROR, "A client tried to attach, but TAPISRV is PAUSED"));
            goto Admin_error;
        }
    }

    if ((status = RpcImpersonateClient (0)) != RPC_S_OK)
    {
        LOG((TL_ERROR,
            "ClientAttach: RpcImpersonateClient failed, err=%d",
            status
            ));
        goto Admin_error;
    }

    hThread = GetCurrentThread(); // Note: no need to close this handle

    if (!OpenThreadToken (hThread, TOKEN_READ, FALSE, &hAccessToken))
    {
        LOG((TL_ERROR,
            "ClientAttach: OpenThreadToken failed, err=%d",
            GetLastError()
            ));

        RpcRevertToSelf();
        goto Admin_error;
    }

    dwSize = 2048;

alloc_infobuffer:

    dwInfoBufferSize = 0;

    if (!(InfoBuffer = (LPWSTR) ServerAlloc (dwSize)))
    {
        CloseHandle (hAccessToken);
        RpcRevertToSelf();

        goto  ClientAttach_error2;
    }

    // first get the user name and domain name

    ptuUser = (PTOKEN_USER) InfoBuffer;

    if (!GetTokenInformation(
            hAccessToken,
            TokenUser,
            InfoBuffer,
            dwSize,
            &dwInfoBufferSize
            ))
    {
        LOG((TL_ERROR,
            "ClientAttach: GetTokenInformation failed, err=%d",
            GetLastError()
            ));

        ServerFree (InfoBuffer);

        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            dwSize *= 2;
            goto alloc_infobuffer;
        }

        CloseHandle (hAccessToken);
        RpcRevertToSelf();

        goto Admin_error;
    }

    if (!LookupAccountSidW(
            NULL,
            ptuUser->User.Sid,
            szAccountName,
            &dwAccountNameSize,
            szDomainName,
            &dwDomainNameSize,
            &use
            ))
    {
        LOG((TL_ERROR,
            "ClientAttach: LookupAccountSidW failed, err=%d",
            GetLastError()
            ));

        ServerFree (InfoBuffer);
        CloseHandle (hAccessToken);
        RpcRevertToSelf();

        goto Admin_error;
    }

    LOG((TL_INFO,
        "ClientAttach: LookupAccountSidW: User name %ls Domain name %ls",
        szAccountName,
        szDomainName
        ));


    //
    // Get administrator status
    //

    if (AllocateAndInitializeSid(
            &siaNtAuthority,
            2,
            SECURITY_BUILTIN_DOMAIN_RID,
            DOMAIN_ALIAS_RID_ADMINS,
            0, 0, 0, 0, 0, 0,
            &psidAdministrators
            )
        )
    {
        BOOL bAdmin = FALSE;
        RESET_FLAG(ptClient->dwFlags,PTCLIENT_FLAG_ADMINISTRATOR);

        if (!CheckTokenMembership(
                hAccessToken,
                psidAdministrators,
                &bAdmin
                ))
        {
            LOG((TL_ERROR,
                "ClientAttach: CheckTokenMembership failed, err=%d",
                GetLastError()
                ));
        }

        //
        //  If both the client & server machine has blank
        //  password for local administrator account, and if
        //  remotesp runs in local admin account on remote machine
        //  NTLM will actually think RPC request is from
        //  server_machine\administrator, thus falsely set
        //  bAdmin to be true.
        //
        
        if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) && bAdmin && lProcessID == 0xffffffff)
        {
            WCHAR       szLocalComp[NAMEBUFSIZE];

            dwSize = sizeof(szLocalComp) / sizeof(WCHAR);
            if (GetComputerNameW (
                szLocalComp,
                &dwSize
                ) &&
                _wcsicmp (szLocalComp, szDomainName) == 0
                )
            {
                bAdmin = FALSE;
                wcsncpy (
                    szDomainName, 
                    pszMachine,
                    sizeof(szLocalComp) / sizeof(WCHAR)
                    );
                szDomainName[sizeof(szLocalComp) / sizeof(WCHAR) - 1] = 0;
            }
        }

        if (bAdmin || S_OK == IsLocalSystem(hAccessToken))
        {
            SET_FLAG(ptClient->dwFlags,PTCLIENT_FLAG_ADMINISTRATOR);
        }

        FreeSid (psidAdministrators);

        if (gbNTServer && !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
        {
            //
            // Check to see if client is a TAPI admin, as
            // specified in the TAPI MMC Snapin.  This is
            // determined simply by looking for a
            // <Domain>\<User>=1 value under the TapiAdministrators
            // section in tsec.ini.
            //

            wcscpy ((WCHAR *) InfoBuffer, szDomainName);
            wcscat ((WCHAR *) InfoBuffer, L"\\");
            wcscat ((WCHAR *) InfoBuffer, szAccountName);

            if (GetPrivateProfileIntW(
                    gszTapiAdministrators,
                    (LPCWSTR) InfoBuffer,
                    0,
                    gszFileName

                    ) == 1)
            {
                SET_FLAG(ptClient->dwFlags,PTCLIENT_FLAG_ADMINISTRATOR);
            }
        }
    }
    else
    {
        LOG((TL_ERROR,
            "ClientAttach: AllocateAndInitializeSid failed, err=%d",
            GetLastError()
            ));

        ServerFree (InfoBuffer);
        CloseHandle (hAccessToken);
        RpcRevertToSelf();

        goto Admin_error;
    }


    ServerFree (InfoBuffer);
    CloseHandle (hAccessToken);
    RpcRevertToSelf();


    //
    // Save the user, domain, & machine names
    //

    ptClient->dwUserNameSize =
        (lstrlenW (szAccountName) + 1) * sizeof (WCHAR);

    if (!(ptClient->pszUserName = ServerAlloc (ptClient->dwUserNameSize)))
    {
        goto ClientAttach_error2;
    }

    wcscpy (ptClient->pszUserName, szAccountName);


    if (!(ptClient->pszDomainName = ServerAlloc(
            (lstrlenW (szDomainName) + 1) * sizeof(WCHAR)
            )))
    {
        goto ClientAttach_error3;
    }

    wcscpy (ptClient->pszDomainName, szDomainName);


    if ((lProcessID == 0xffffffff) || (lProcessID == 0xfffffffd))
    {
        ptClient->dwComputerNameSize =
            (1 + lstrlenW (pszMachine)) * sizeof(WCHAR);

        if (!(ptClient->pszComputerName = ServerAlloc(
                ptClient->dwComputerNameSize
                )))
        {
            goto ClientAttach_error4;
        }

        wcscpy (ptClient->pszComputerName, pszMachine);
    }

    // Get the RPC call attributes
    ZeroMemory(&RPCAttributes, sizeof(RPCAttributes));
    RPCAttributes.Version = RPC_CALL_ATTRIBUTES_VERSION;
    RPCAttributes.Flags = 0;

    status = RpcServerInqCallAttributes (NULL, &RPCAttributes);
    if (status)
    {
        LOG((TL_ERROR, "ClientAttach: Failed to retrieve the RPC call attributes, error 0x%x", status));
        lResult = LINEERR_OPERATIONFAILED;
        goto ClientAttach_error5;
    }
    LOG((TL_INFO, "ClientAttach(%S): Auth level = 0x%x", ptClient->pszUserName, RPCAttributes.AuthenticationLevel));

#else

    ptClient->dwUserNameSize = (lstrlenW (pszDomainUser) + 1) * sizeof(WCHAR);

    if (!(ptClient->pszUserName = ServerAlloc (ptClient->dwUserNameSize)))
    {
        goto ClientAttach_error2;
    }

    wcscpy (ptClient->pszUserName, pszDomainUser);

#endif

    if (lProcessID == 0xffffffff)
    {
#if TELE_SERVER
        ULONG RPCAuthLevel = RPC_C_AUTHN_LEVEL_PKT_PRIVACY;
#endif
        //
        // This is a remote client
        //

#if TELE_SERVER
        if (0 == (TapiGlobals.dwFlags & TAPIGLOBALS_SERVER))
#endif
        {
            //
            // This machine has been set up to _not_ be a server so fail
            //

            ServerFree (ptClient->pszUserName);

            LOG((TL_ERROR,
                "ClientAttach: attach request received, but this is " \
                    "not a telephony svr!"
                ));

            goto Admin_error;
        }

#if TELE_SERVER

        if (RPCAttributes.AuthenticationLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
        {
            // Is this call secure enough ?
            if (gbHighSecurity)
            {
                // We are in high security mode
                // Reject calls that don't have packet privacy
                LOG((TL_ERROR, "ClientAttach: unsecure call, AuthLevel=0x%x", 
                    RPCAttributes.AuthenticationLevel));
                lResult = LINEERR_OPERATIONFAILED;
                goto ClientAttach_error5;
            }
            else
            {
                RPCAuthLevel = RPC_C_AUTHN_LEVEL_DEFAULT;
            }
        }

        //
        // Special hack introduced because in SP4 beta I nullified the
        // entry in gaFuncs[] corresponding to the old-lOpenInt /
        // new-xNegotiateAPIVersionForAllDevices.  So if a newer
        // remotesp tries to send a NegoAllDevices request to an
        // SP4 beta then tapisrv on the server will blow up.
        //
        // By setting *phAsyncEventsEvent = to a secret value remotesp
        // knows whether or not it's ok to send a NegoAllDevices request.
        //

        *phAsyncEventsEvent = 0xa5c369a5;


        //
        // If pszDomainUser is non-empty then it contains the
        // name of a mailslot that we can open & write to to
        // indicate when async events are pending for this client.
        //

        if (wcslen (pszDomainUser) > 0)
        {
            ptClient->hProcess = (HANDLE) DG_CLIENT;

            if ((ptClient->hMailslot = CreateFileW(
                    pszDomainUser,
                    GENERIC_WRITE,
                    FILE_SHARE_READ,
                    (LPSECURITY_ATTRIBUTES) NULL,
                    OPEN_EXISTING,
                    FILE_ATTRIBUTE_NORMAL,
                    (HANDLE) NULL

                    )) != INVALID_HANDLE_VALUE)
            {
                goto ClientAttach_AddClientToList;
            }

            LOG((TL_ERROR,
                "ClientAttach: CreateFile(%ws) failed, err=%d",
                pszDomainUser,
                GetLastError()
                ));

            LOG((TL_ERROR,
                "ClientAttach: trying connection-oriented approach...",
                pszDomainUser,
                GetLastError()
                ));
        }

        ptClient->hProcess = (HANDLE) CN_CLIENT;


        //
        //
        //

        {
            RPC_STATUS              status;
            PCONTEXT_HANDLE_TYPE2   phContext = NULL;
            WCHAR                  *pszStringBinding = NULL;
            WCHAR                  *pszMachineName;
            BOOL                    bError;

            // Allocate enough incase we have to prepend...

            pszMachineName = ServerAlloc(
                (lstrlenW(pszMachine) + 3) * sizeof(WCHAR)
                );

            if (!pszMachineName)
            {
                goto ClientAttach_error5;
            }


            //
            // Should we prepend whackwhack?
            //

            if (!_wcsicmp (L"ncacn_np", pProtocolSequence))
            {
                //
                // Yes.  It's needed for named pipes
                //

                pszMachineName[0] = '\\';
                pszMachineName[1] = '\\';

                wcscpy (pszMachineName + 2, pszMachine);
            }
            else
            {
                //
                // Don't prepend \\
                //

                wcscpy (pszMachineName, pszMachine);
            }

            //
            // Serialize access to hRemoteSP
            //

            EnterCriticalSection (&TapiGlobals.RemoteSPCritSec);


            //
            // Try to find a protseq/endpoint pair in the list passed
            // to us by the client that works ok
            //

find_protocol_sequence:

            do
            {
                //
                // New strings look like: prot1"ep1"prot2"ep2"\0
                // ...where there's one or more protseq/enpoint combos,
                // each members of which is followed by a dbl-quote char
                //
                // Old strings look like: prot"ep\0
                // ...where there's only one protseq/endpoint combo,
                // and the endpoint member is followed by a \0 (no dbl-quote)
                //

                pPlaceHolder = wcschr (pProtocolSequence, L'\"');
                *pPlaceHolder = L'\0';
                pProtocolEndpoint = pPlaceHolder + 1;

                if ((pPlaceHolder = wcschr (pProtocolEndpoint, L'\"')))
                {
                    *pPlaceHolder = L'\0';
                }
                else
                {
                    //
                    // If this is an old-style string then munge
                    // pPlaceHolder such that the error handling
                    // code down below doesn't jump back up here
                    // to get the next protseq/endpoint combo
                    //

                    pPlaceHolder = pProtocolEndpoint +
                        wcslen (pProtocolEndpoint) - 1;
                }

                RpcTryExcept
                {
                    status = RpcStringBindingComposeW(
                        NULL,               // uuid
                        pProtocolSequence,
                        pszMachineName,     // server name
                        pProtocolEndpoint,
                        NULL,               // options
                        &pszStringBinding
                        );

                    if (status != 0)
                    {
                        LOG((TL_ERROR,
                            "ClientAttach: RpcStringBindingComposeW " \
                                "failed, err=%d",
                            status
                            ));
                    }

                    status = RpcBindingFromStringBindingW(
                        pszStringBinding,
                        &hRemoteSP
                        );

                    if (status != 0)
                    {
                        LOG((TL_ERROR,
                            "ClientAttach: RpcBindingFromStringBinding " \
                                "failed, err=%d",
                            status
                            ));

                        LOG((TL_INFO,
                            "\t szMachine=%ws, protseq=%ws endpoint=%ws",
                            pszMachine,
                            pProtocolSequence,
                            pProtocolEndpoint
                            ));
                    }
                }
                RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
                {
                    //
                    // Set status != 0 so our error handler below executes
                    //

                    status = 1;
                }
                RpcEndExcept

                if (status != 0)
                {
                    RpcStringFreeW (&pszStringBinding);

                    pProtocolSequence = pPlaceHolder + 1;
                }

            } while (status != 0  &&  *pProtocolSequence);

            if (status != 0)
            {
                LOG((TL_ERROR,
                    "ClientAttach: error, can't find a usable protseq"
                    ));

                LeaveCriticalSection (&TapiGlobals.RemoteSPCritSec);
                ServerFree (pszMachineName);
                lResult = LINEERR_OPERATIONFAILED;
                goto ClientAttach_error5;
            }

            LOG((TL_TRACE, 
                "ClientAttach: szMachine=%ws trying protseq=%ws endpoint=%ws",
                pszMachine,
                pProtocolSequence,
                pProtocolEndpoint
                ));


            RpcTryExcept
            {
                status = RpcBindingSetAuthInfo(
                    hRemoteSP,
                    NULL,
                    RPCAuthLevel,
                    RPC_C_AUTHN_WINNT, 
                    NULL,
                    0
                    );

                RemoteSPAttach ((PCONTEXT_HANDLE_TYPE2 *) &phContext);
                bError = FALSE;
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
            {
                dwException = RpcExceptionCode();
                LOG((TL_ERROR,
                    "ClientAttach: RemoteSPAttach failed.  Exception %d",
                    dwException
                    ));

                bError = TRUE;
            }
            RpcEndExcept

            RpcTryExcept
            {
                RpcBindingFree (&hRemoteSP);

                RpcStringFreeW (&pszStringBinding);
            }
            RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
            {
                // do nothing
            }
            RpcEndExcept


            LeaveCriticalSection (&TapiGlobals.RemoteSPCritSec);

            if (bError)
            {
                //
                // If there's at least one other protocol we can try
                // then go for it, otherwise jump to error handler
                //

                pProtocolSequence = pPlaceHolder + 1;

                if (*pProtocolSequence)
                {
                    EnterCriticalSection (&TapiGlobals.RemoteSPCritSec);
                    goto find_protocol_sequence;
                }

                ServerFree (pszMachineName);

                lResult = LINEERR_OPERATIONFAILED;
                goto ClientAttach_error5;
            }

            ServerFree (pszMachineName);

            // RevertToSelf();

            ptClient->phContext = phContext;
        }

#endif // TELE_SERVER

    }
    else if (lProcessID == 0xfffffffd)
    {
        if (!gbNTServer)
        {
            lResult = LINEERR_OPERATIONFAILED;
            goto ClientAttach_error5;
        }

#if TELE_SERVER

        // Is this call secure enough ?
        if (gbHighSecurity && RPCAttributes.AuthenticationLevel != RPC_C_AUTHN_LEVEL_PKT_PRIVACY)
        {
            // We are in high security mode
            // Reject calls that don't have packet privacy
            LOG((TL_ERROR, "ClientAttach: unsecure call, AuthLevel=0x%x", 
                RPCAttributes.AuthenticationLevel));
            lResult = LINEERR_OPERATIONFAILED;
            goto ClientAttach_error5;
        }
#endif

        //
        //  Deny the access if not the admin
        //
        if (!IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
        {
            lResult = TAPIERR_NOTADMIN;
            goto ClientAttach_error5;
        }

        ptClient->hProcess = (HANDLE) MMC_CLIENT;
#ifdef _WIN64
        *phAsyncEventsEvent = 0x64646464;
#else
        *phAsyncEventsEvent = 0x32323232;
#endif
    }
    else
    {
     RPC_STATUS rpcStatus;
        //
        // Open a handle to the client process. We will use this to duplicate an
        // event handle into that process.
        //
        rpcStatus = RpcImpersonateClient (NULL);
        if (RPC_S_OK != rpcStatus)
        {
            LOG((TL_ERROR,
                "RpcImpersonateClient failed, err=%d",
                rpcStatus));
            lResult = LINEERR_OPERATIONFAILED;
            goto ClientAttach_error5;
        }


        if (!(ptClient->hProcess = OpenProcess(
                PROCESS_DUP_HANDLE,
                FALSE,
                lProcessID
                )))
        {
            LOG((TL_ERROR,
                "OpenProcess(pid=x%x) failed, err=%d",
                lProcessID,
                GetLastError()
                ));

            RpcRevertToSelf ();
            goto ClientAttach_error5;
        }

        //
        // This is a local client, so set up all the event buffer stuff
        //

        ptClient->dwComputerNameSize = TapiGlobals.dwComputerNameSize;
        ptClient->pszComputerName    = TapiGlobals.pszComputerName;

        if (!(ptClient->hValidEventBufferDataEvent = CreateEvent(
                (LPSECURITY_ATTRIBUTES) NULL,
                TRUE,   // manual-reset
                FALSE,  // nonsignaled
                NULL    // unnamed
                )))
        {
            RpcRevertToSelf ();
            lResult = LINEERR_OPERATIONFAILED;
            goto ClientAttach_error5;
        }

        if (!DuplicateHandle(
                TapiGlobals.hProcess,
                ptClient->hValidEventBufferDataEvent,
                ptClient->hProcess,
                (HANDLE *) phAsyncEventsEvent,
                0,
                FALSE,
                DUPLICATE_SAME_ACCESS
                ))
        {
            LOG((TL_ERROR,
                "ClientAttach: DupHandle failed, err=%d",
                GetLastError()
                ));
        }

        RpcRevertToSelf ();

        //
        // Load the priority lists if we haven't already done so
        //

        if (gbPriorityListsInitialized == FALSE)
        {
            RPC_STATUS  status;

            if ((status = RpcImpersonateClient (0)) != RPC_S_OK)
            {
                LOG((TL_ERROR,
                    "ClientAttach: RpcImpersonateClient failed, err=%d",
                    status
                    ));
                lResult = LINEERR_OPERATIONFAILED;
                goto ClientAttach_error5;
            }

            EnterCriticalSection (&gPriorityListCritSec);

            if (gbPriorityListsInitialized == FALSE)
            {
                HKEY    hKeyHandoffPriorities, hKeyCurrentUser;
                LONG    lResult;


                gbPriorityListsInitialized = TRUE;

                if (ERROR_SUCCESS ==
                    (lResult = RegOpenCurrentUser (KEY_ALL_ACCESS, &hKeyCurrentUser)))
                {
                    if ((lResult = RegOpenKeyEx(
                            hKeyCurrentUser,
                            gszRegKeyHandoffPriorities,
                            0,
                            KEY_READ,
                            &hKeyHandoffPriorities

                            )) == ERROR_SUCCESS)
                    {

                        HKEY        hKeyMediaModes;
                        DWORD       dwDisp;

                        if ((lResult = RegCreateKeyEx(
                            hKeyHandoffPriorities,
                            gszRegKeyHandoffPrioritiesMediaModes,
                            0,
                            TEXT(""),
                            REG_OPTION_NON_VOLATILE,
                            KEY_ALL_ACCESS,
                            NULL,
                            &hKeyMediaModes,
                            &dwDisp
                            )) == ERROR_SUCCESS)
                        {
                            GetMediaModesPriorityLists(
                                hKeyMediaModes,
                                &(TapiGlobals.pPriLists)
                                );

                            RegCloseKey( hKeyMediaModes );
                        }

                        GetPriorityList(
                            hKeyHandoffPriorities,
                            gszRequestMakeCallW,
                            &TapiGlobals.pszReqMakeCallPriList
                            );

                        GetPriorityList(
                            hKeyHandoffPriorities,
                            gszRequestMediaCallW,
                            &TapiGlobals.pszReqMediaCallPriList
                            );


                        RegCloseKey (hKeyHandoffPriorities);

                    }
                    else
                    {
                        LOG((TL_ERROR,
                            "RegOpenKey('\\HandoffPri') failed, err=%ld",
                            lResult
                            ));
                    }

                    RegCloseKey (hKeyCurrentUser);
                }
                else
                {
                    LOG((TL_ERROR,
                        "RegOpenCurrentUser failed, err=%ld",
                        lResult
                        ));
                }
            }

            LeaveCriticalSection (&gPriorityListCritSec);

            if (status == RPC_S_OK)
            {
                RpcRevertToSelf ();
            }
        }
    }


    //
    // Add tClient to global list
    //

ClientAttach_AddClientToList:

    TapiEnterCriticalSection (&TapiGlobals.CritSec);

    if ((ptClient->pNext = TapiGlobals.ptClients))
    {
        ptClient->pNext->pPrev = ptClient;
    }

    TapiGlobals.ptClients = ptClient;
    gfWeHadAtLeastOneClient = TRUE;

    ptClient->dwKey = TCLIENT_KEY;

    {
        PTPROVIDER      ptProvider;

        ptProvider = TapiGlobals.ptProviders;

        while (NULL != ptProvider)
        {
            if (NULL != ptProvider->apfn[SP_PROVIDERCHECKFORNEWUSER])
            {
                CallSP1(
                    ptProvider->apfn[SP_PROVIDERCHECKFORNEWUSER],
                    "providerCheckForNewUser",
                    SP_FUNC_SYNC,
                    (DWORD)ptProvider->dwPermanentProviderID
                    );
            }

            ptProvider = ptProvider->pNext;
        }
    }

    TapiLeaveCriticalSection (&TapiGlobals.CritSec);


    //
    // Fill in return values
    //

    *pphContext = (PCONTEXT_HANDLE_TYPE) UIntToPtr(ptClient->htClient);

    PerfBlock.dwClientApps++;

    return 0;


    //
    // Error cleanup
    //

Admin_error:

    ServerFree (ptClient->pEventBuffer);
    DereferenceObject (ghHandleTable, 
                       ptClient->htClient, 1);

    return LINEERR_OPERATIONFAILED;


ClientAttach_error5:

    if (ptClient->pszComputerName != TapiGlobals.pszComputerName)
    {
        ServerFree (ptClient->pszComputerName);
    }

#if TELE_SERVER
ClientAttach_error4:
#endif
    ServerFree (ptClient->pszDomainName);


#if TELE_SERVER
ClientAttach_error3:
#endif

    ServerFree (ptClient->pszUserName);

ClientAttach_error2:

    ServerFree (ptClient->pEventBuffer);

ClientAttach_error1:

    DereferenceObject (ghHandleTable, 
                       ptClient->htClient, 1);

ClientAttach_error0:

    if (lResult == 0)
    {
        lResult = LINEERR_NOMEM;
    }
    return lResult;
}


void
ClientRequest(
    PCONTEXT_HANDLE_TYPE   phContext,
    unsigned char  *pBuffer,
    long            lNeededSize,
    long           *plUsedSize
    )
{
    PTAPI32_MSG     pMsg = (PTAPI32_MSG) pBuffer;
    DWORD           dwFuncIndex;
    PTCLIENT        ptClient = NULL;
    DWORD           objectToDereference = DWORD_CAST((ULONG_PTR)phContext,__FILE__,__LINE__);

    if (lNeededSize < sizeof (TAPI32_MSG) ||
        *plUsedSize < sizeof (ULONG_PTR))       // sizeof (pMsg->u.Req_Func)
    {
        pMsg->u.Ack_ReturnValue = LINEERR_INVALPARAM;
        goto ExitHere;
    }

    dwFuncIndex = pMsg->u.Req_Func;
    
    ptClient = ReferenceObject(
                    ghHandleTable,
                    objectToDereference,
                    TCLIENT_KEY);
    if (ptClient == NULL)
    {
        pMsg->u.Ack_ReturnValue = TAPIERR_INVALRPCCONTEXT;
        goto ExitHere;
    }

    //
    // Old (nt4sp4, win98) clients pass across a usedSize
    // == 3 * sizeof(DWORD) for the xgetAsyncEvents request,
    // so we have to special case them when checking buf size
    //

    if (*plUsedSize < (long) (dwFuncIndex == xGetAsyncEvents ?
            3 * sizeof (ULONG_PTR) : sizeof (TAPI32_MSG)))
    {
        goto ExitHere;
    }

    *plUsedSize = sizeof (LONG_PTR);

    if (dwFuncIndex >= xLastFunc)
    {
        pMsg->u.Ack_ReturnValue = LINEERR_OPERATIONUNAVAIL;
    }
    else if (ptClient->dwKey == TCLIENT_KEY)
    {
        pMsg->u.Ack_ReturnValue = TAPI_SUCCESS;

        (*gaFuncs[dwFuncIndex])(
			ptClient,
            pMsg,
            lNeededSize - sizeof(TAPI32_MSG),
            pBuffer + sizeof(TAPI32_MSG),
            plUsedSize
            );
    }
    else
    {
        pMsg->u.Ack_ReturnValue = LINEERR_REINIT;
    }

ExitHere:
    if (ptClient)
    {
        DereferenceObject(
                ghHandleTable,
                ptClient->htClient,
                1);
    }
    return;
}


void
ClientDetach(
    PCONTEXT_HANDLE_TYPE   *pphContext
    )
{
    PTCLIENT ptClient;
    DWORD    objectToDereference = DWORD_CAST((ULONG_PTR)(*pphContext),__FILE__,__LINE__);

    LOG((TL_TRACE,  "ClientDetach: enter"));

    ptClient = ReferenceObject(
                    ghHandleTable,
                    objectToDereference,
                    TCLIENT_KEY);
    if (ptClient == NULL)
    {
        goto ExitHere;
    }

    {
        if (!IS_REMOTE_CLIENT (ptClient))
        {
            //
            // Write the pri lists to the registry when a local client
            // detaches.
            //

            {
                HKEY    hKeyHandoffPriorities, hKeyCurrentUser;
                LONG    lResult;
                DWORD   dwDisposition;
                RPC_STATUS  status;


                if ((status = RpcImpersonateClient (0)) == RPC_S_OK)
                {
                    if (ERROR_SUCCESS ==
                        (lResult = RegOpenCurrentUser (KEY_ALL_ACCESS, &hKeyCurrentUser)))
                    {
                        if ((lResult = RegCreateKeyEx(
                                hKeyCurrentUser,
                                gszRegKeyHandoffPriorities,
                                0,
                                TEXT(""),
                                REG_OPTION_NON_VOLATILE,
                                KEY_SET_VALUE,
                                (LPSECURITY_ATTRIBUTES) NULL,
                                &hKeyHandoffPriorities,
                                &dwDisposition

                                )) == ERROR_SUCCESS)
                        {
                            HKEY        hKeyHandoffPrioritiesMediaModes;

                            EnterCriticalSection (&gPriorityListCritSec);

                            RegDeleteKey(
                                         hKeyHandoffPriorities,
                                         gszRegKeyHandoffPrioritiesMediaModes
                                        );

                            if ((lResult = RegCreateKeyEx(
                                hKeyHandoffPriorities,
                                gszRegKeyHandoffPrioritiesMediaModes,
                                0,
                                TEXT(""),
                                REG_OPTION_NON_VOLATILE,
                                KEY_SET_VALUE,
                                (LPSECURITY_ATTRIBUTES) NULL,
                                &hKeyHandoffPrioritiesMediaModes,
                                &dwDisposition

                                )) == ERROR_SUCCESS)
                            {
                                SetMediaModesPriorityList(
                                    hKeyHandoffPrioritiesMediaModes,
                                    TapiGlobals.pPriLists
                                    );

                                RegCloseKey( hKeyHandoffPrioritiesMediaModes );
                            }

                            SetPriorityList(
                                hKeyHandoffPriorities,
                                gszRequestMakeCallW,
                                TapiGlobals.pszReqMakeCallPriList
                                );

                            SetPriorityList(
                                hKeyHandoffPriorities,
                                gszRequestMediaCallW,
                                TapiGlobals.pszReqMediaCallPriList
                                );

                            LeaveCriticalSection (&gPriorityListCritSec);

                            RegCloseKey (hKeyHandoffPriorities);
                        }
                        else
                        {
                            LOG((TL_ERROR,
                                "RegCreateKeyEx('\\HandoffPri') failed, err=%ld",
                                lResult
                                ));
                        }

                        RegCloseKey (hKeyCurrentUser);
                    }
                    else
                    {
                        LOG((TL_ERROR,
                            "RegOpenCurrentUser failed, err=%ld",
                            lResult
                            ));
                    }

                    RpcRevertToSelf ();
                }
                else
                {
                    LOG((TL_ERROR, "ClientDetach: RpcImpersonateClient failed, err=%d", status));
                }
            }
        }
    }

    PCONTEXT_HANDLE_TYPE_rundown (*pphContext);

    *pphContext = (PCONTEXT_HANDLE_TYPE) NULL;

    PerfBlock.dwClientApps--;

    LOG((TL_TRACE,  "ClientDetach: exit"));
    
ExitHere:
    if (ptClient)
    {
        DereferenceObject( ghHandleTable, 
                           ptClient->htClient, 1);
    }
    return;
}


BOOL
CleanUpClient(
    PTCLIENT    ptClient,
    BOOL        bRundown
    )
/*++

    This function separates out the freeing of client resources
    and removing it from the client list from actually freeing
    the client.  For the case where the client timed out we want to
    clean up all the client's resources.  However, the client can
    potentially still call in to tapisrv, so we can't free the
    client handle (or it will fault in lineprolog / phoneprolog).

--*/
{
    BOOL    bResult, bExit;


CleanUpClient_lockClient:

    try
    {
        LOCKTCLIENT (ptClient);
    }
    myexcept
    {
        // do nothing
    }

    try
    {
        if (bRundown)
        {
            switch (ptClient->dwKey)
            {
            case TCLIENT_KEY:

                //
                // Invalidate the key & proceed with clean up
                //

                ptClient->dwKey = INVAL_KEY;
                bExit = FALSE;
                break;

            case TZOMBIECLIENT_KEY:

                //
                // An EventNotificationThread already cleaned up this client,
                // so invalidate the key, exit & return TRUE
                //

                ptClient->dwKey = INVAL_KEY;
                bResult = bExit = TRUE;
                break;

            case TCLIENTCLEANUP_KEY:

                //
                // An EventNotificationThread is cleaning up this client.
                // Release the lock, wait a little while, then try again.
                //

                UNLOCKTCLIENT (ptClient);
                Sleep (50);
                goto CleanUpClient_lockClient;

            default:

                //
                // This is not a valid tClient, so exit & return FALSE
                //

                bResult = FALSE;
                bExit = TRUE;
                break;
            }
        }
        else // called by EventNotificationThread on timeout
        {
            if (ptClient->dwKey == TCLIENT_KEY)
            {
                //
                // Mark the key as "doing cleanup", then proceed
                //

                bExit = FALSE;
                ptClient->dwKey = TCLIENTCLEANUP_KEY;
            }
            else
            {
                //
                // Either the tClient is invalid or it's being cleaned
                // up by someone else, so exit & return FALSE
                //

                bResult = FALSE;
                bExit = TRUE;
            }
        }
    }
    myexcept
    {
        bResult = FALSE;
        bExit = TRUE;
    }

    try
    {
        UNLOCKTCLIENT (ptClient);
    }
    myexcept
    {
        // do nothing
    }

    if (bExit)
    {
        return bResult;
    }

    //  Clear the MMC write lock if any
    if (IS_FLAG_SET (ptClient->dwFlags, PTCLIENT_FLAG_LOCKEDMMCWRITE))
    {
        EnterCriticalSection (&gMgmtCritSec);
        gbLockMMCWrite = FALSE;
        LeaveCriticalSection (&gMgmtCritSec);
    }

#if TELE_SERVER

    if (IS_REMOTE_CLIENT (ptClient)  &&
        ptClient->MsgPendingListEntry.Flink)
    {
        CRITICAL_SECTION    *pCS = (IS_REMOTE_CN_CLIENT (ptClient) ?
                                &gCnClientMsgPendingCritSec :
                                &gDgClientMsgPendingCritSec);


        EnterCriticalSection (pCS);

        if (ptClient->MsgPendingListEntry.Flink)
        {
            RemoveEntryList (&ptClient->MsgPendingListEntry);
        }

        LeaveCriticalSection (pCS);
    }

#endif

    TapiEnterCriticalSection (&TapiGlobals.CritSec);

    try
    {
        if (ptClient->pNext)
        {
            ptClient->pNext->pPrev = ptClient->pPrev;
        }

        if (ptClient->pPrev)
        {
            ptClient->pPrev->pNext = ptClient->pNext;
        }
        else
        {
            TapiGlobals.ptClients = ptClient->pNext;
        }
    }
    myexcept
    {
        //  simply continue
    }

    TapiLeaveCriticalSection (&TapiGlobals.CritSec);


#if TELE_SERVER

    if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER)  &&
        !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
    {
        HMANAGEMENTCLIENT         htClient;
        PTMANAGEDLLINFO     pDll;


        (TapiGlobals.pMapperDll->aProcs[TC_CLIENTSHUTDOWN])(ptClient->hMapper);

        if (TapiGlobals.pManageDllList)
        {
            pDll = TapiGlobals.pManageDllList->pFirst;

            while (pDll)
            {
                if (GetTCClient (pDll, ptClient, TC_CLIENTSHUTDOWN, &htClient))
                {
                    try
                    {
                        (pDll->aProcs[TC_CLIENTSHUTDOWN])(htClient);
                    }
                    myexcept
                    {
                        LOG((TL_ERROR, "CLIENT DLL had a problem: x%p",ptClient));
                        break;
                    }
                }

                pDll = pDll->pNext;
            }
        }
    }

    //
    // If client was remote then detach
    //

    if (IS_REMOTE_CN_CLIENT (ptClient)  &&  bRundown)
    {
        RpcTryExcept
        {
            RemoteSPDetach (&ptClient->phContext);
        }
        RpcExcept (I_RpcExceptionFilter(RpcExceptionCode()))
        {
            unsigned long ulResult = RpcExceptionCode();


            LOG((TL_ERROR,
                "rundown: exception #%d detaching from remotesp",
                ulResult
                ));

            if (ulResult == RPC_S_SERVER_TOO_BUSY)
            {
            }
            else
            {
            }
        }
        RpcEndExcept
    }

#endif


    //
    // Close all XxxApps
    //

    while (ptClient->ptLineApps)
    {
        DestroytLineApp (ptClient->ptLineApps->hLineApp);
    }

    while (ptClient->ptPhoneApps)
    {
        DestroytPhoneApp (ptClient->ptPhoneApps->hPhoneApp);
    }


    //
    // Clean up any existing ProviderXxx dialog instances
    //

    {
        PTAPIDIALOGINSTANCE pProviderXxxDlgInst =
                                ptClient->pProviderXxxDlgInsts,
                            pNextProviderXxxDlgInst;


        while (pProviderXxxDlgInst)
        {
            
            TAPI32_MSG  params;

            params.u.Req_Func = 0;
            params.Params[0] = pProviderXxxDlgInst->htDlgInst;
            params.Params[1] = LINEERR_OPERATIONFAILED;



            pNextProviderXxxDlgInst = pProviderXxxDlgInst->pNext;

            FreeDialogInstance(
                ptClient,
                (PFREEDIALOGINSTANCE_PARAMS) &params,
                sizeof (params),
                NULL,
                NULL
                );

            pProviderXxxDlgInst = pNextProviderXxxDlgInst;
        }
    }


    //
    // Clean up associated resources
    //

    if (!IS_REMOTE_CLIENT (ptClient))
    {
        CloseHandle (ptClient->hProcess);
    }

    if (!IS_REMOTE_CN_CLIENT (ptClient))
    {
        CloseHandle  (ptClient->hValidEventBufferDataEvent);
    }

    ServerFree (ptClient->pEventBuffer);

    ServerFree (ptClient->pszUserName);

    if (ptClient->pszComputerName != TapiGlobals.pszComputerName)
    {
        ServerFree (ptClient->pszComputerName);
    }

#if TELE_SERVER

    if (TapiGlobals.dwFlags & TAPIGLOBALS_SERVER)
    {
        ServerFree (ptClient->pszDomainName);

        if (!IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
            // security DLL handles
        {
            ServerFree (ptClient->pClientHandles);
            ServerFree (ptClient->pLineMap);
            ServerFree (ptClient->pLineDevices);
            ServerFree (ptClient->pPhoneMap);
            ServerFree (ptClient->pPhoneDevices);
        }
    }

#endif


    //
    // If we're called due to timeout then reset key to == ZOMBIE
    // so that another thread doing rundown knows that it's ok
    // to free the tClient object
    //

    if (!bRundown)
    {
        ptClient->dwKey = TZOMBIECLIENT_KEY;
    }

    return TRUE;
}


void
__RPC_USER
PCONTEXT_HANDLE_TYPE_rundown(
    PCONTEXT_HANDLE_TYPE    phContext
    )
{
    DWORD       i;
    PTCLIENT    ptClient;
    DWORD       objectToDereference = DWORD_CAST((ULONG_PTR)phContext,__FILE__,__LINE__);

    ptClient = ReferenceObject (
                    ghHandleTable,
                    objectToDereference,
                    TCLIENT_KEY);
    if (ptClient == NULL)
    {
        goto ExitHere;
    }

    LOG((TL_TRACE,  "PCONTEXT_HANDLE_TYPE_rundown: enter (ptClient=x%p)",ptClient));

    while (InterlockedExchange (&gRundownLock.lCookie, 1) == 1)
    {
        Sleep (50);
    }

    if (!gRundownLock.bIgnoreRundowns)
    {
        InterlockedIncrement (&gRundownLock.lNumRundowns);

        InterlockedExchange (&gRundownLock.lCookie, 0);


        //
        // Wrap the following in a try/except because we definitely
        // want to make sure we decrement gRundownLock.lRundownCount
        //

        try
        {
            if (CleanUpClient (ptClient, TRUE))
            {
                DereferenceObject (
                            ghHandleTable,
                            ptClient->htClient,
                            1);

                //
                // If this was the last client then alert the
                // SPEventHandlerThread(s) that it should begin
                // it's deferred shutdown countdown
                //

                if (!TapiGlobals.ptClients)
                {
                    for (i = 0; i < gdwNumSPEventHandlerThreads; i++)
                    {
                        EnterCriticalSection(
                            &aSPEventHandlerThreadInfo[i].CritSec
                            );

                        SetEvent (aSPEventHandlerThreadInfo[i].hEvent);

                        LeaveCriticalSection(
                            &aSPEventHandlerThreadInfo[i].CritSec
                            );
                    }
                }
            }
        }
        myexcept
        {
        }

        InterlockedDecrement (&gRundownLock.lNumRundowns);
    }
    else
    {
        InterlockedExchange (&gRundownLock.lCookie, 0);
    }

ExitHere:
    if (ptClient)
    {
        DereferenceObject(ghHandleTable, 
                          ptClient->htClient, 1);
    }
    LOG((TL_TRACE,  "PCONTEXT_HANDLE_TYPE_rundown: exit"));
    return;
}


#if DBG
LPVOID
WINAPI
ServerAllocReal(
    DWORD   dwSize,
    DWORD   dwLine,
    PSTR    pszFile
    )
#else
LPVOID
WINAPI
ServerAllocReal(
    DWORD   dwSize
    )
#endif
{
    LPVOID  p;


#if DBG
    dwSize += sizeof (MYMEMINFO);
#endif

    p = HeapAlloc (ghTapisrvHeap, HEAP_ZERO_MEMORY, dwSize);

#if DBG
    if (p)
    {
        ((PMYMEMINFO) p)->dwLine  = dwLine;
        ((PMYMEMINFO) p)->pszFile = pszFile;

        p = (LPVOID) (((PMYMEMINFO) p) + 1);
    }
    else
    {
        static BOOL fBeenThereDoneThat = FALSE;
        static DWORD fBreakOnAllocFailed = 0;


        if ( !fBeenThereDoneThat )
        {
           HKEY    hKey;
           TCHAR   szTapisrvDebugBreak[] = TEXT("TapisrvDebugBreak");


           fBeenThereDoneThat = TRUE;

           if (RegOpenKeyEx(
                   HKEY_LOCAL_MACHINE,
                   gszRegKeyTelephony,
                   0,
                   KEY_ALL_ACCESS,
                   &hKey
                   ) == ERROR_SUCCESS)
           {
               DWORD   dwDataSize = sizeof (DWORD), dwDataType;

               RegQueryValueEx(
                   hKey,
                   szTapisrvDebugBreak,
                   0,
                   &dwDataType,
                   (LPBYTE) &fBreakOnAllocFailed,
                   &dwDataSize
                   );

               dwDataSize = sizeof (DWORD);

               RegCloseKey (hKey);


               LOG((TL_ERROR, "BreakOnAllocFailed=%ld", fBreakOnAllocFailed));
           }

        }

        if ( fBreakOnAllocFailed )
        {
           DebugBreak();
        }
    }
#endif

    return p;
}


VOID
WINAPI
ServerFree(
    LPVOID  p
    )
{
    if (!p)
    {
        return;
    }

#if DBG

    //
    // Fill the buffer (but not the MYMEMINFO header) with 0xa1's
    // to facilitate debugging
    //

    {
        LPVOID  p2 = p;
        DWORD   dwSize;


        p = (LPVOID) (((PMYMEMINFO) p) - 1);

        dwSize = (DWORD) HeapSize (ghTapisrvHeap, 0, p);
        if ((dwSize != 0xFFFFFFFF) && (dwSize > sizeof (MYMEMINFO)))
        {
            FillMemory(
                p2,
                dwSize - sizeof (MYMEMINFO),
                0xa1
                );
        }
    }

#endif

    HeapFree (ghTapisrvHeap, 0, p);
}


#if DBG
void
DumpHandleList()
{
#ifdef INTERNALBUILD
    PMYHANDLEINFO       pHold;

    if (gpHandleFirst == NULL)
    {
        LOG((TL_ERROR, "All mutexes deallocated"));

        return;
    }

    pHold = gpHandleFirst;

    while (pHold)
    {
        LOG((TL_INFO, "DumpHandleList - MUTEX %lx, FILE %s, LINE %d", pHold->hMutex, pHold->pszFile, pHold->dwLine));

        pHold = pHold->pNext;
    }

    if (gbBreakOnLeak)
    {
        DebugBreak();
    }
#endif
}
#endif


BOOL
PASCAL
MyDuplicateHandle(
    HANDLE      hSource,
    LPHANDLE    phTarget
    )
{
    if (!DuplicateHandle(
            TapiGlobals.hProcess,
            hSource,
            TapiGlobals.hProcess,
            phTarget,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS
            ))
    {
        LOG((TL_ERROR,
            "MyDuplicateHandle: DuplicateHandle failed, err=%ld",
            GetLastError()
            ));

        return FALSE;
    }

    return TRUE;
}

#if DBG
HANDLE
MyRealCreateMutex(
    PSTR    pFile,
    DWORD   dwLine
    )
#else
HANDLE
MyRealCreateMutex(
    void
    )
#endif
{
    HANDLE hMutex;

    hMutex = CreateMutex(
        NULL,               // no security attrs
        FALSE,              // unowned
        NULL                // unnamed
        );

    return (hMutex);
}


BOOL
WaitForMutex(
    HANDLE      hMutex,
    HANDLE     *phMutex,
    BOOL       *pbDupedMutex,
    LPVOID      pWidget,
    DWORD       dwKey,
    DWORD       dwTimeout
    )
{
    DWORD dwResult;


    // note that waitformutex and code that uses the mutex must be
    // wrapped in a try except because the object could possibly
    // go away even though the thread has the mutex
    //
    // First try to instantaneously grab the specified mutex.  We wrap
    // this in a critical section and preface it with widget validation
    // to make sure that we don't happen grab a pWidget->hMutex right
    // after it is released and right before it is closed by some other
    // thread "T2" in a DestroyWidget routine.  This scenario could cause
    // deadlock, since there could be thread "T3" waiting on this mutex
    // (or a dup'd handle), and this thread "T1" would have no way to
    // release the mutex (the handle having been subsequently closed by
    // thread "T2" calling DestroyWidget above).
    //

    EnterCriticalSection (&gSafeMutexCritSec);

    if (pWidget)
    {
        try
        {
            if (*((LPDWORD) pWidget) != dwKey)
            {
                LeaveCriticalSection (&gSafeMutexCritSec);
                return FALSE;
            }
        }
        myexcept
        {
            LeaveCriticalSection (&gSafeMutexCritSec);
            return FALSE;
        }
    }

    switch ((dwResult = WaitForSingleObject (hMutex, 0)))
    {
    case WAIT_OBJECT_0:

        LeaveCriticalSection (&gSafeMutexCritSec);
        *phMutex = hMutex;
        *pbDupedMutex = FALSE;
        return TRUE;

    //case WAIT_ABANDONED:

        //assert: no calling thread should ever be terminated!

    default:

        break;
    }

    LeaveCriticalSection (&gSafeMutexCritSec);


    //
    // If here we failed to instantaneously grab the specified mutex.
    // Try to dup it, and then wait on the dup'd handle. We do this so
    // that each thread which grabs a mutex is guaranteed to have a valid
    // handle to release at some future time, as the original hMutex might
    // get closed by some other thread calling a DestroyWidget routine.
    //

    if (!DuplicateHandle(
            TapiGlobals.hProcess,
            hMutex,
            TapiGlobals.hProcess,
            phMutex,
            0,
            FALSE,
            DUPLICATE_SAME_ACCESS
            ))
    {
        return FALSE;
    }

WaitForMutex_wait:

    switch ((dwResult = WaitForSingleObject (*phMutex, dwTimeout)))
    {
    case WAIT_OBJECT_0:

        *pbDupedMutex = TRUE;
        return TRUE;

    case WAIT_TIMEOUT:

        try
        {
            if (*((LPDWORD) pWidget) == dwKey)
            {
                goto WaitForMutex_wait;
            }
        }
        myexcept
        {
            // just fall thru without blowing up
        }

        MyCloseMutex (*phMutex);
        break;

    //case WAIT_ABANDONED:

        //assert: no calling thread should ever be terminated!

    default:

        break;
    }

    return FALSE;
}


void
MyReleaseMutex(
    HANDLE  hMutex,
    BOOL    bCloseMutex
    )
{
    if (hMutex)
    {
        ReleaseMutex (hMutex);

        if (bCloseMutex)
        {
            MyCloseMutex (hMutex);
        }
    }
}


void
MyCloseMutex(
    HANDLE  hMutex
    )
{
    if (hMutex)
    {
        CloseHandle (hMutex);
    }
}


void
CALLBACK
CompletionProcSP(
    DWORD   dwRequestID,
    LONG    lResult
    )
{
    PASYNCREQUESTINFO   pAsyncRequestInfo;


    if ((pAsyncRequestInfo = ReferenceObject(
            ghHandleTable,
            dwRequestID,
            TASYNC_KEY
            )))
    {
#if DBG
         char szResult[32];

        LOG((TL_TRACE, 
            "CompletionProcSP: enter, dwReqID=x%x, lResult=%s",
            dwRequestID,
            MapResultCodeToText (lResult, szResult)
            ));
#else
        LOG((TL_TRACE, 
            "CompletionProcSP: enter, dwReqID=x%x, lResult=x%x",
            dwRequestID,
            lResult
            ));
#endif
        pAsyncRequestInfo->lResult = lResult;

        DereferenceObject (ghHandleTable, dwRequestID, 1);
    }
    else
    {
        LOG((TL_ERROR, "CompletionProcSP: bad dwRequestID=x%x", dwRequestID));
#if DBG

        if (gfBreakOnSeriousProblems)
        {
            DebugBreak();
        }
#endif
        return;
    }


    if (!QueueSPEvent ((PSPEVENT) pAsyncRequestInfo))
    {
        //
        // If here we're going thru shutdown & service provider
        // is completing any outstanding events, so process this
        // inline so it gets cleaned up right now.
        //

        CompletionProc (pAsyncRequestInfo, lResult);

        DereferenceObject (ghHandleTable, dwRequestID, 1);
    }
}


VOID
PASCAL
CompletionProc(
    PASYNCREQUESTINFO   pAsyncRequestInfo,
    LONG                lResult
    )
{
    //
    // Assumes pAsyncRequestInfo has been verified upon entry.
    //
    // If the tClient is bad WriteEventBuffer should handle it ok,
    // as should any post-processing routine.
    //

    ASYNCEVENTMSG   msg[2], *pMsg = msg;


#if DBG
    {
        char szResult[32];


        LOG((TL_TRACE, 
            "CompletionProc: enter, dwReqID=x%x, lResult=%s",
            pAsyncRequestInfo->dwLocalRequestID,
            MapResultCodeToText (lResult, szResult)
            ));
    }
#else
        LOG((TL_TRACE, 
            "CompletionProc: enter, dwReqID=x%x, lResult=x%x",
            pAsyncRequestInfo->dwLocalRequestID,
            lResult
            ));
#endif

    pAsyncRequestInfo->dwKey = INVAL_KEY;


    //
    // Init the msg we'll send to client
    //

    pMsg->TotalSize          = sizeof (ASYNCEVENTMSG);
    pMsg->InitContext        = pAsyncRequestInfo->InitContext;

   
    pMsg->fnPostProcessProcHandle = pAsyncRequestInfo->hfnClientPostProcessProc;

    pMsg->hDevice            = 0;
    pMsg->Msg                = ((pAsyncRequestInfo->dwLineFlags & 1) ?
                                   LINE_REPLY : PHONE_REPLY);
    pMsg->OpenContext        = pAsyncRequestInfo->OpenContext;
    pMsg->Param1             = pAsyncRequestInfo->dwRemoteRequestID;
    pMsg->Param2             = lResult;
    pMsg->Param3             = 0;


    //
    // If there's a post processing proc call it.  Note that ppprocs can
    // create their own msg to pass, so we need to check for this case.
    // Finally, write the msg to the client's event buffer.
    //

    if (pAsyncRequestInfo->pfnPostProcess)
    {
        LPVOID  pBuf = NULL;


        (*pAsyncRequestInfo->pfnPostProcess)(pAsyncRequestInfo, pMsg, &pBuf);

        WriteEventBuffer (pAsyncRequestInfo->ptClient, (pBuf ? pBuf : pMsg));

        if (pBuf)
        {
            ServerFree (pBuf);
        }
    }
    else
    {
        WriteEventBuffer (pAsyncRequestInfo->ptClient, pMsg);
    }

    // caller will free pAsyncRequestInfo
}


void
WriteEventBuffer(
    PTCLIENT        ptClient,
    PASYNCEVENTMSG  pMsg
    )
{
    BOOL    bSignalRemote = FALSE;
    DWORD   dwMoveSize = (DWORD) pMsg->TotalSize,
            dwMoveSizeWrapped = 0,
            dwPreviousUsedSize,
            dwData;
    HANDLE  hMailslot;


#if DBG

   if (dwMoveSize & 0x3)
   {
       LOG((TL_ERROR,
           "WriteEventBuffer: ERROR! bad MsgSize=x%x (Msg=x%x, pCli=x%p)",
           dwMoveSize,
           pMsg->Msg,
           ptClient
           ));
   }

#endif

    LOG((TL_TRACE, "WriteEventBuffer - enter"));
    if (WaitForExclusiveClientAccess (ptClient))
    {
        //
        // Check to see if we need to grow the event buffer
        //

        if (dwMoveSize > (ptClient->dwEventBufferTotalSize -
                          ptClient->dwEventBufferUsedSize))
        {
            DWORD   dwMoveSize2, dwMoveSizeWrapped2,
                    dwNewEventBufferTotalSize;
            LPBYTE  pNewEventBuffer;


            //
            // Do some math to have the total be a multiple
            // of sizeof(ASYNCEVENTMSG)
            //

            dwNewEventBufferTotalSize =
                ptClient->dwEventBufferTotalSize +
                ( (( dwMoveSize / sizeof(ASYNCEVENTMSG) ) + 20 )
                       * sizeof(ASYNCEVENTMSG));

            if (!(pNewEventBuffer = ServerAlloc(
                    dwNewEventBufferTotalSize
                    )))
            {
                UNLOCKTCLIENT (ptClient);
                return;
            }

            if (ptClient->dwEventBufferUsedSize != 0)
            {
                if (ptClient->pDataIn > ptClient->pDataOut)
                {
                    dwMoveSize2 = (DWORD) (ptClient->pDataIn -
                        ptClient->pDataOut);

                    dwMoveSizeWrapped2 = 0;
                }
                else
                {
                    dwMoveSize2 = (DWORD)
                        ((ptClient->pEventBuffer +
                        ptClient->dwEventBufferTotalSize) -
                        ptClient->pDataOut);

                    dwMoveSizeWrapped2 = (DWORD)
                        (ptClient->pDataIn -
                        ptClient->pEventBuffer);
                }

                CopyMemory(
                    pNewEventBuffer,
                    ptClient->pDataOut,
                    dwMoveSize2
                    );

                if (dwMoveSizeWrapped2)
                {
                    CopyMemory(
                        pNewEventBuffer + dwMoveSize2,
                        ptClient->pEventBuffer,
                        dwMoveSizeWrapped2
                        );
                }

                ptClient->pDataIn = pNewEventBuffer +
                    dwMoveSize2 + dwMoveSizeWrapped2;
            }
            else
            {
                ptClient->pDataIn = pNewEventBuffer;
            }

            ServerFree (ptClient->pEventBuffer);

            ptClient->pDataOut =
            ptClient->pEventBuffer = pNewEventBuffer;

            ptClient->dwEventBufferTotalSize =
                dwNewEventBufferTotalSize;

        }


        //
        // Compute the MoveSize's, do the copy(ies), & update the pointers
        //

        if (ptClient->pDataIn >= ptClient->pDataOut)
        {
            DWORD dwFreeSize = ptClient->dwEventBufferTotalSize -
                                   (DWORD) (ptClient->pDataIn -
                                       ptClient->pEventBuffer);


            if (dwMoveSize > dwFreeSize)
            {
                dwMoveSizeWrapped = dwMoveSize - dwFreeSize;

                dwMoveSize = dwFreeSize;
            }
        }

        CopyMemory (ptClient->pDataIn, (LPBYTE) pMsg, dwMoveSize);

        if (dwMoveSizeWrapped != 0)
        {
            CopyMemory(
                ptClient->pEventBuffer,
                ((LPBYTE) pMsg) + dwMoveSize,
                dwMoveSizeWrapped
                );

            ptClient->pDataIn = ptClient->pEventBuffer +
                dwMoveSizeWrapped;
        }
        else
        {
            ptClient->pDataIn += dwMoveSize;

            if (ptClient->pDataIn >= (ptClient->pEventBuffer +
                ptClient->dwEventBufferTotalSize))
            {
                ptClient->pDataIn = ptClient->pEventBuffer;
            }
        }

        dwPreviousUsedSize = ptClient->dwEventBufferUsedSize;

        ptClient->dwEventBufferUsedSize += (DWORD) pMsg->TotalSize;

        if (!IS_REMOTE_CLIENT (ptClient))
        {
            LOG((TL_TRACE, "WriteEventBuffer: SetEvent %p for local client", ptClient->hValidEventBufferDataEvent));
            SetEvent (ptClient->hValidEventBufferDataEvent);
        }
        else if (dwPreviousUsedSize == 0)
        {
            if (IS_REMOTE_CN_CLIENT (ptClient))
            {
                EnterCriticalSection (&gCnClientMsgPendingCritSec);

                InsertTailList(
                    &CnClientMsgPendingListHead,
                    &ptClient->MsgPendingListEntry
                    );

                LeaveCriticalSection (&gCnClientMsgPendingCritSec);

                hMailslot = NULL;
                bSignalRemote = TRUE;
            }
            else
            {
                if (dwPreviousUsedSize == 0)
                {
                    ptClient->dwDgEventsRetrievedTickCount = GetTickCount();
                }
                        
                EnterCriticalSection (&gDgClientMsgPendingCritSec);

                InsertTailList(
                    &DgClientMsgPendingListHead,
                    &ptClient->MsgPendingListEntry
                    );

                LeaveCriticalSection (&gDgClientMsgPendingCritSec);

                hMailslot = ptClient->hMailslot;
                if (ptClient->ptLineApps != NULL)
                {
                    dwData = (DWORD) ptClient->ptLineApps->InitContext;
                }
                else
                {
                    dwData = 0;
                }
                bSignalRemote = TRUE;
            }
        }

        UNLOCKTCLIENT (ptClient);

        if (bSignalRemote)
        {
            if (hMailslot)
            {
                DWORD   dwBytesWritten;


                if (!WriteFile(
                        hMailslot,
                        &dwData,
                        sizeof (DWORD),
                        &dwBytesWritten,
                        (LPOVERLAPPED) NULL
                        ))
                {
                    LOG((TL_ERROR,
                        "WriteEventBuffer: Writefile(mailslot) " \
                            "failed, err=%d",
                        GetLastError()
                        ));
                }
                else
                {
                    ptClient->dwDgRetryTimeoutTickCount =
                        GetTickCount() +
                        2 * DGCLIENT_TIMEOUT;
                }

            }
            else
            {
                SetEvent (gEventNotificationThreadParams.hEvent);
            }
        }
    } else {
        LOG((TL_ERROR, "WriteEventBuffer: - WaitForExclusiveClientAccess returns 0"));
    }
}


LONG
GetPermLineIDAndInsertInTable(
    PTPROVIDER  ptProvider,
    DWORD       dwDeviceID,
    DWORD       dwSPIVersion
    )
{
#if TELE_SERVER

    LONG            lResult = 0;
    DWORD           dwSize;
    LPLINEDEVCAPS   pCaps;


    if (!ptProvider || !ptProvider->apfn[SP_LINEGETDEVCAPS])
    {
        return LINEERR_OPERATIONFAILED;
    }

    dwSize = sizeof (LINEDEVCAPS);

    if (!(pCaps = ServerAlloc (dwSize)))
    {
        return LINEERR_NOMEM;
    }

    pCaps->dwTotalSize  =
    pCaps->dwUsedSize   =
    pCaps->dwNeededSize = dwSize;

    if ((lResult = CallSP4(
            ptProvider->apfn[SP_LINEGETDEVCAPS],
            "lineGetDevCaps",
            SP_FUNC_SYNC,
            (DWORD)dwDeviceID,
            (DWORD)dwSPIVersion,
            (DWORD)0,
            (ULONG_PTR) pCaps

            )) == 0)
    {
        //
        // add to sorted array
        //

        InsertIntoTable(
            TRUE,
            dwDeviceID,
            ptProvider,
            pCaps->dwPermanentLineID
            );
    }

    ServerFree (pCaps);

    return lResult;

#else

    return 0;

#endif
}


LONG
AddLine(
    PTPROVIDER  ptProvider,
    DWORD       dwDeviceID,
    BOOL        bInit
    )
{
    DWORD               dwSPIVersion;
    HANDLE              hMutex = NULL;
    PTLINELOOKUPTABLE   pLookup;

    if (ptProvider->apfn[SP_LINENEGOTIATETSPIVERSION] == NULL)
    {
        return LINEERR_OPERATIONUNAVAIL;
    }

    //
    // First try to negotiate an SPI ver for this device, and alloc the
    // necessary resources
    //

    if (CallSP4(
            ptProvider->apfn[SP_LINENEGOTIATETSPIVERSION],
            "lineNegotiateTSPIVersion",
            SP_FUNC_SYNC,
            (DWORD)dwDeviceID,
            (DWORD)TAPI_VERSION1_0,
            (DWORD)TAPI_VERSION_CURRENT,
            (ULONG_PTR) &dwSPIVersion

            ) != 0)
    {
        //
        // Device failed version negotiation, so we'll keep the id around
        // (since the id's for the devices that follow have already been
        // assigned) but mark this device as bad
        //

        ptProvider = NULL;
    }

    else if (!(hMutex = MyCreateMutex ()))
    {
        LOG((TL_ERROR,
            "AddLine: MyCreateMutex failed, err=%d",
            GetLastError()
            ));

        return LINEERR_OPERATIONFAILED;
    }


    //
    // Now walk the lookup table to find a free entry
    //

    pLookup = TapiGlobals.pLineLookup;

    while (pLookup->pNext)
    {
        pLookup = pLookup->pNext;
    }

    if (pLookup->dwNumUsedEntries == pLookup->dwNumTotalEntries)
    {
        PTLINELOOKUPTABLE   pNewLookup;


        if (bInit)
        {

            //
            // If we're initializing we want to put everything in one big table
            //

            if (!(pNewLookup = ServerAlloc(
                sizeof (TLINELOOKUPTABLE) +
                    (2 * pLookup->dwNumTotalEntries - 1) *
                    sizeof (TLINELOOKUPENTRY)
                )))
            {
                return LINEERR_NOMEM;
            }

            pNewLookup->dwNumTotalEntries = 2 * pLookup->dwNumTotalEntries;

            pNewLookup->dwNumUsedEntries = pLookup->dwNumTotalEntries;

            CopyMemory(
                pNewLookup->aEntries,
                pLookup->aEntries,
                pLookup->dwNumTotalEntries * sizeof (TLINELOOKUPENTRY)
                );

            ServerFree (pLookup);

            TapiGlobals.pLineLookup = pNewLookup;
        }
        else
        {
            if (!(pNewLookup = ServerAlloc(
                sizeof (TLINELOOKUPTABLE) +
                    (pLookup->dwNumTotalEntries - 1) *
                    sizeof (TLINELOOKUPENTRY)
                )))
            {
                return LINEERR_NOMEM;
            }

            pNewLookup->dwNumTotalEntries = pLookup->dwNumTotalEntries;
            pLookup->pNext = pNewLookup;
        }

        pLookup = pNewLookup;
    }


    //
    // Initialize the entry
    //

    {
        DWORD   index = pLookup->dwNumUsedEntries;


        pLookup->aEntries[index].dwSPIVersion = dwSPIVersion;
        pLookup->aEntries[index].hMutex       = hMutex;
        pLookup->aEntries[index].ptProvider   = ptProvider;

        if (ptProvider &&
            lstrcmpi(ptProvider->szFileName, TEXT("remotesp.tsp")) == 0)
        {
            pLookup->aEntries[index].bRemote = TRUE;
        }
    }

    pLookup->dwNumUsedEntries++;

#if TELE_SERVER

    //
    // If this is an NT Server we want to be able to set user
    // permissions regardless of whether or not TAPI server
    // functionality is enabled.  This allows an admin to set
    // stuff up while the server is "offline".
    //

    if (gbNTServer)
    {
        GetPermLineIDAndInsertInTable (ptProvider, dwDeviceID, dwSPIVersion);
    }

#endif

    return 0;
}


DWORD
GetNumLineLookupEntries ()
{
    PTLINELOOKUPTABLE           pLineLookup;
    DWORD                       dwNumLines;

    pLineLookup = TapiGlobals.pLineLookup;
    dwNumLines = 0;
    while (pLineLookup)
    {
        dwNumLines += pLineLookup->dwNumUsedEntries;
        pLineLookup = pLineLookup->pNext;
    }

    return dwNumLines;
}

LONG
GetPermPhoneIDAndInsertInTable(
    PTPROVIDER  ptProvider,
    DWORD       dwDeviceID,
    DWORD       dwSPIVersion
    )
{
#if TELE_SERVER

    LONG        lResult = 0;
    DWORD       dwSize;
    LPPHONECAPS pCaps;


    if (!ptProvider->apfn[SP_PHONEGETDEVCAPS])
    {
        return PHONEERR_OPERATIONFAILED;
    }

    dwSize = sizeof (PHONECAPS);

    if (!(pCaps = ServerAlloc (dwSize)))
    {
        return PHONEERR_NOMEM;
    }

    pCaps->dwTotalSize  =
    pCaps->dwUsedSize   =
    pCaps->dwNeededSize = dwSize;

    if ((lResult = CallSP4(
            ptProvider->apfn[SP_PHONEGETDEVCAPS],
            "phoneGetCaps",
            SP_FUNC_SYNC,
            (DWORD)dwDeviceID,
            (DWORD)dwSPIVersion,
            (DWORD)0,
            (ULONG_PTR) pCaps

            )) == 0)
    {
        //
        // add to sorted array
        //

        InsertIntoTable(
            FALSE,
            dwDeviceID,
            ptProvider,
            pCaps->dwPermanentPhoneID
            );
    }

    ServerFree (pCaps);

    return lResult;

#else

    return 0;

#endif
}


LONG
AddPhone(
    PTPROVIDER  ptProvider,
    DWORD       dwDeviceID,
    BOOL        bInit
    )
{
    DWORD               dwSPIVersion;
    HANDLE              hMutex = NULL;
    PTPHONELOOKUPTABLE  pLookup;

    if (ptProvider->apfn[SP_PHONENEGOTIATETSPIVERSION] == NULL)
    {
        return PHONEERR_OPERATIONUNAVAIL;
    }

    //
    // First try to negotiate an SPI ver for this device, and alloc the
    // necessary resources
    //

    if (CallSP4(
            ptProvider->apfn[SP_PHONENEGOTIATETSPIVERSION],
            "phoneNegotiateTSPIVersion",
            SP_FUNC_SYNC,
            (DWORD)dwDeviceID,
            (DWORD)TAPI_VERSION1_0,
            (DWORD)TAPI_VERSION_CURRENT,
            (ULONG_PTR) &dwSPIVersion

            ) != 0)
    {
        //
        // Device failed version negotiation, so we'll keep the id around
        // (since the id's for the devices that follow have already been
        // assigned) but mark this device as bad
        //

        return PHONEERR_OPERATIONFAILED;
    }

    else if (!(hMutex = MyCreateMutex ()))
    {
        LOG((TL_ERROR,
            "AddPhone: MyCreateMutex failed, err=%d",
            GetLastError()
            ));

        return PHONEERR_OPERATIONFAILED;
    }


    //
    // Now walk the lookup table to find a free entry
    //

    pLookup = TapiGlobals.pPhoneLookup;

    while (pLookup->pNext)
    {
        pLookup = pLookup->pNext;
    }

    if (pLookup->dwNumUsedEntries == pLookup->dwNumTotalEntries)
    {
        PTPHONELOOKUPTABLE  pNewLookup;

        if (bInit)
        {

            //
            // If we're initializing we want to put everything in one big table
            //

            if (!(pNewLookup = ServerAlloc(
                sizeof (TPHONELOOKUPTABLE) +
                    (2 * pLookup->dwNumTotalEntries - 1) *
                    sizeof (TPHONELOOKUPENTRY)
                )))
            {
                return PHONEERR_NOMEM;
            }

            pNewLookup->dwNumTotalEntries = 2 * pLookup->dwNumTotalEntries;

            pNewLookup->dwNumUsedEntries = pLookup->dwNumTotalEntries;

            CopyMemory(
                pNewLookup->aEntries,
                pLookup->aEntries,
                pLookup->dwNumTotalEntries * sizeof (TPHONELOOKUPENTRY)
                );

            ServerFree (pLookup);

            TapiGlobals.pPhoneLookup = pNewLookup;
        }
        else
        {
            if (!(pNewLookup = ServerAlloc(
                sizeof (TPHONELOOKUPTABLE) +
                    (pLookup->dwNumTotalEntries - 1) *
                    sizeof (TPHONELOOKUPENTRY)
                )))
            {
                return PHONEERR_NOMEM;
            }

            pNewLookup->dwNumTotalEntries = pLookup->dwNumTotalEntries;
            pLookup->pNext = pNewLookup;
        }

        pLookup = pNewLookup;
    }


    //
    // Initialize the entry
    //

    {
        DWORD   index = pLookup->dwNumUsedEntries;


        pLookup->aEntries[index].dwSPIVersion = dwSPIVersion;
        pLookup->aEntries[index].hMutex       = hMutex;
        pLookup->aEntries[index].ptProvider   = ptProvider;
    }

    pLookup->dwNumUsedEntries++;

#if TELE_SERVER

    //
    // If this is an NT Server we want to be able to set user
    // permissions regardless of whether or not TAPI server
    // functionality is enabled.  This allows an admin to set
    // stuff up while the server is "offline".
    //

    if (gbNTServer)
    {
        GetPermPhoneIDAndInsertInTable (ptProvider, dwDeviceID, dwSPIVersion);
    }

#endif

    return 0;
}

DWORD
GetNumPhoneLookupEntries ()
{
    PTPHONELOOKUPTABLE          pPhoneLookup;
    DWORD                       dwNumPhones;

    pPhoneLookup = TapiGlobals.pPhoneLookup;
    dwNumPhones = 0;
    while (pPhoneLookup)
    {
        dwNumPhones += pPhoneLookup->dwNumUsedEntries;
        pPhoneLookup = pPhoneLookup->pNext;
    }

    return dwNumPhones;
}

void
PASCAL
GetMediaModesPriorityLists(
    HKEY            hKeyHandoffPriorities,
    PRILISTSTRUCT   **ppList
    )
{
    #define REGNAMESIZE     ( 10 * sizeof(TCHAR) )

    DWORD       dwCount;
    DWORD       dwType, dwNameSize, dwNumBytes;
    TCHAR    *pszName;

    dwNameSize = REGNAMESIZE;
    pszName = ServerAlloc( dwNameSize*sizeof(TCHAR) );
    if (NULL == pszName)
    {
        return;
    }

    dwCount = 0;
    while ( TRUE )
    {
        if (TapiGlobals.dwUsedPriorityLists == TapiGlobals.dwTotalPriorityLists)
        {
            // realloc

            PRILISTSTRUCT *     pNewList;

            pNewList = ServerAlloc( sizeof(PRILISTSTRUCT) * (2*TapiGlobals.dwTotalPriorityLists) );

            if (NULL == pNewList)
            {
                LOG((TL_ERROR, "ServerAlloc failed in GetMediaModesPriorityLists 2"));
                ServerFree( pszName );
                return;
            }

            CopyMemory(
                       pNewList,
                       *ppList,
                       sizeof( PRILISTSTRUCT ) * TapiGlobals.dwTotalPriorityLists
                      );

            ServerFree( *ppList );

            *ppList = pNewList;
            TapiGlobals.dwTotalPriorityLists *= 2;
        }

        dwNameSize = REGNAMESIZE;
        if ( ERROR_SUCCESS != RegEnumValue(
            hKeyHandoffPriorities,
            dwCount,
            pszName,
            &dwNameSize,
            NULL,
            NULL,
            NULL,
            NULL
            ) )
        {
            break;
        }

        (*ppList)[dwCount].dwMediaModes =
                      (DWORD) _ttol( pszName );

        if ((RegQueryValueEx(
                              hKeyHandoffPriorities,
                              pszName,
                              NULL,
                              &dwType,
                              NULL,
                              &dwNumBytes

                             )) == ERROR_SUCCESS &&

            (dwNumBytes != 0))
        {
            // pszPriotiryList needs to be wide because we pack it into one of our
            // little structures and these structures are always WCHAR.
            LPWSTR pszPriorityList;

            // convert from the bytes needed to hold a TCHAR into the bytes to hold a WCHAR
            dwNumBytes *= sizeof(WCHAR)/sizeof(TCHAR);
            pszPriorityList = ServerAlloc ( dwNumBytes + sizeof(WCHAR));
            // need an extra WCHAR for the extra '"'

            if (NULL != pszPriorityList)
            {
                pszPriorityList[0] = L'"';

                if ((TAPIRegQueryValueExW(
                    hKeyHandoffPriorities,
                    pszName,
                    NULL,
                    &dwType,
                    (LPBYTE)(pszPriorityList + 1),
                    &dwNumBytes

                    )) == ERROR_SUCCESS)
                {
                    _wcsupr( pszPriorityList );
                    (*ppList)[dwCount].pszPriList = pszPriorityList;
                    LOG((TL_INFO, "PriList: %ls=%ls", pszName, pszPriorityList));
                }
            }

        }

        TapiGlobals.dwUsedPriorityLists++;
        dwCount++;
    }
    ServerFree( pszName );
}


void
PASCAL
GetPriorityList(
    HKEY    hKeyHandoffPriorities,
    const TCHAR  *pszListName,
    WCHAR **ppszPriorityList
    )
{
    LONG    lResult;
    DWORD   dwType, dwNumBytes;

    *ppszPriorityList = NULL;

    if ((lResult = TAPIRegQueryValueExW(
            hKeyHandoffPriorities,
            pszListName,
            NULL,
            &dwType,
            NULL,
            &dwNumBytes

            )) == ERROR_SUCCESS &&

        (dwNumBytes != 0))
    {
        // Once again, this is going to get packed into a struct and we always use
        // wide chars for things packed in structs.
        WCHAR   *pszPriorityList = ServerAlloc ( dwNumBytes + sizeof(WCHAR));
        // need an extra WCHAR for the extra '"'

        if (pszPriorityList)
        {
            pszPriorityList[0] = L'"';

            if ((lResult = TAPIRegQueryValueExW(
                    hKeyHandoffPriorities,
                    pszListName,
                    NULL,
                    &dwType,
                    (LPBYTE)(pszPriorityList + 1),
                    &dwNumBytes

                    )) == ERROR_SUCCESS)
            {
                _wcsupr( pszPriorityList );
                *ppszPriorityList = pszPriorityList;
                LOG((TL_INFO, "PriList: %ls=%ls", pszListName, pszPriorityList));
            }
        }
        else
        {
            //
            // Don't bother with the failure to alloc a priority list
            // (list defaults to NULL anyway), we'll deal with a lack
            // of memory at a later time
            //

            *ppszPriorityList = NULL;
        }
    }
    else
    {
        *ppszPriorityList = NULL;
        LOG((TL_INFO, "PriList: %ls=NULL", pszListName));
    }
}


LONG
ServerInit(
    BOOL    fReinit
    )
{
    UINT    uiNumProviders, i, j;
    HKEY    hKeyTelephony, hKeyProviders;
    DWORD   dwDataSize, dwDataType, dwNameHash;
    TCHAR   *psz;
    LONG    lResult = 0;
    DWORD   dw1, dw2;


    //
    // Clean up our private heap
    //

    if (ghTapisrvHeap != GetProcessHeap())
    {
        HeapCompact (ghTapisrvHeap, 0);
    }


    //
    // Initialize the globals
    //

    if (!fReinit)
    {
        TapiGlobals.ptProviders = NULL;

        TapiGlobals.pLineLookup = (PTLINELOOKUPTABLE) ServerAlloc(
            sizeof (TLINELOOKUPTABLE) +
                (DEF_NUM_LOOKUP_ENTRIES - 1) * sizeof (TLINELOOKUPENTRY)
            );
        if (!(TapiGlobals.pLineLookup))
        {
            lResult = LINEERR_NOMEM;
            goto ExitHere;
        }

        TapiGlobals.pLineLookup->dwNumTotalEntries = DEF_NUM_LOOKUP_ENTRIES;

        TapiGlobals.pPhoneLookup = (PTPHONELOOKUPTABLE) ServerAlloc(
           sizeof (TPHONELOOKUPTABLE) +
                (DEF_NUM_LOOKUP_ENTRIES - 1) * sizeof (TPHONELOOKUPENTRY)
            );
        if (!(TapiGlobals.pPhoneLookup))
        {
            ServerFree(TapiGlobals.pLineLookup);
            TapiGlobals.pLineLookup = NULL;
            lResult = LINEERR_NOMEM;
            goto ExitHere;
        }

        TapiGlobals.pPhoneLookup->dwNumTotalEntries = DEF_NUM_LOOKUP_ENTRIES;

        gbQueueSPEvents = TRUE;

        OnProxySCPInit ();
    }


    //
    // Determine number of providers
    //
    WaitForSingleObject (ghProvRegistryMutex, INFINITE);

    lResult = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        gszRegKeyTelephony,
        0,
        KEY_ALL_ACCESS,
        &hKeyTelephony
        );
    if (ERROR_SUCCESS != lResult)
    {
        goto ExitHere;
    }

    lResult = RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        gszRegKeyProviders,
        0,
        KEY_ALL_ACCESS,
        &hKeyProviders
        );
    if (ERROR_SUCCESS != lResult)
    {
        RegCloseKey (hKeyTelephony);
        goto ExitHere;
    }

    dwDataSize = sizeof(uiNumProviders);
    uiNumProviders = 0;

    RegQueryValueEx(
        hKeyProviders,
        gszNumProviders,
        0,
        &dwDataType,
        (LPBYTE) &uiNumProviders,
        &dwDataSize
        );

    LOG((TL_INFO, "ServerInit: NumProviders=%d", uiNumProviders));


    //
    // Load & init the providers
    //

    for (i = 0; i < uiNumProviders; i++)
    {
        #define FILENAME_SIZE 128

        TCHAR           szFilename[FILENAME_SIZE];
        TCHAR           buf[32];
        LONG            lResult;
        DWORD           dwNumLines, dwNumPhones, dwPermanentProviderID;
        PTPROVIDER      ptProvider;
        BOOL            fEnumDevices;

        fEnumDevices = FALSE;
        wsprintf(buf, TEXT("%s%d"), gszProviderID, i);

        dwDataSize = sizeof(dwPermanentProviderID);
        dwPermanentProviderID = 0;

        RegQueryValueEx(
            hKeyProviders,
            buf,    //"ProviderID#"
            0,
            &dwDataType,
            (LPBYTE) &dwPermanentProviderID,
            &dwDataSize
            );



        //
        // Back to the main section
        //

        dwDataSize = FILENAME_SIZE;

        wsprintf(buf, TEXT("%s%d"), gszProviderFilename, i);

        RegQueryValueEx(
            hKeyProviders,
            buf,            // "ProviderFilename#"
            0,
            &dwDataType,
            (LPBYTE) szFilename,
            &dwDataSize
            );

        szFilename[dwDataSize/sizeof(TCHAR)] = TEXT('\0');

        //
        //  Compute name hash
        //
        dwNameHash = 0;
        psz = szFilename;
        while (*psz)
        {
            dwNameHash += (DWORD)(*psz);
            psz++;
        }

        //
        //  If fReinit, make sure the provider is not already in
        //
        if (fReinit)
        {
            PTPROVIDER  ptProvider2;
            BOOL        fFound = FALSE;

            ptProvider2 = TapiGlobals.ptProviders;
            while (ptProvider2)
            {
                if ((ptProvider2->dwNameHash == dwNameHash) && 
                    (lstrcmpi(ptProvider2->szFileName, szFilename) == 0))
                {
                    fFound = TRUE;
                    break;
                }
                ptProvider2 = ptProvider2->pNext;
            }
            
            if (fFound)
            {
                continue;
            }
        }

        LOG((TL_INFO, "ServerInit: ProviderFilename=%S", szFilename));

        if (!(ptProvider = (PTPROVIDER) ServerAlloc(
                sizeof(TPROVIDER) + ((lstrlen(szFilename) + 1) * sizeof(TCHAR))
                )))
        {
            break;
        }

        if (!(ptProvider->hDll = LoadLibrary(szFilename)))
        {
            LOG((TL_ERROR,
                "ServerInit: LoadLibrary(%S) failed, err=x%x",
                szFilename,
                GetLastError()
                ));

            ServerFree (ptProvider);
            continue;
        }

        ptProvider->dwNameHash = dwNameHash;
        lstrcpy(ptProvider->szFileName, szFilename);


        //
        // Get all the TSPI proc addrs
        //

        for (j = 0; gaszTSPIFuncNames[j]; j++)
        {
            ptProvider->apfn[j] = (TSPIPROC) GetProcAddress(
                ptProvider->hDll,
                (LPCSTR) gaszTSPIFuncNames[j]
                );
        }


        dwNumLines = dwNumPhones = 0;

        //
        // A real quick check to see if a couple of required entrypoints
        // are exported
        //

        if (!ptProvider->apfn[SP_LINENEGOTIATETSPIVERSION] ||
            !ptProvider->apfn[SP_PROVIDERENUMDEVICES] ||
            !ptProvider->apfn[SP_PROVIDERINIT] ||
            !ptProvider->apfn[SP_PROVIDERSHUTDOWN]
            )
        {
            goto ServerInit_validateEntrypoints;
        }


        //
        // Do global provider version negotiation
        //

        lResult = CallSP4(
            ptProvider->apfn[SP_LINENEGOTIATETSPIVERSION],
            "lineNegotiateTSPIVersion",
            SP_FUNC_SYNC,
            (DWORD)INITIALIZE_NEGOTIATION,
            (DWORD)TAPI_VERSION1_0,
            (DWORD)TAPI_VERSION_CURRENT,
            (ULONG_PTR) &ptProvider->dwSPIVersion
            );

        if (lResult != 0)
        {
provider_init_error:
            if (fEnumDevices)
            {
                lResult = CallSP2(
                    ptProvider->apfn[SP_PROVIDERSHUTDOWN],
                    "providerShutdown",
                    SP_FUNC_SYNC,
                    (DWORD)ptProvider->dwSPIVersion,
                    (DWORD)ptProvider->dwPermanentProviderID
                    );            
            }
            if (ptProvider->hMutex)
            {
                MyCloseMutex (ptProvider->hMutex);
            }
            if (ptProvider->hHashTableReaderEvent)
            {
                CloseHandle (ptProvider->hHashTableReaderEvent);
            }
            if (ptProvider->pHashTable)
            {
                ServerFree (ptProvider->pHashTable);
            }
            FreeLibrary (ptProvider->hDll);
            ServerFree (ptProvider);
            continue;
        }


        //
        // Try to enum the devices if provider supports it, otherwise
        // try grabbing the num lines & phones from ProviderN section
        //

        lResult = CallSP6(
            ptProvider->apfn[SP_PROVIDERENUMDEVICES],
            "providerEnumDevices",
            SP_FUNC_SYNC,
            (DWORD)dwPermanentProviderID,
            (ULONG_PTR) &dwNumLines,
            (ULONG_PTR) &dwNumPhones,
            (ULONG_PTR) ptProvider,
            (ULONG_PTR) LineEventProcSP,
            (ULONG_PTR) PhoneEventProcSP
            );

        if (lResult != 0)
        {
            LOG((TL_ERROR,
                "ServerInit: %s: failed TSPI_providerEnumDevices, err=x%x" \
                    " - skipping it...",
                szFilename,
                lResult
                ));

            goto provider_init_error;
        }

        //
        // Init the provider
        //
        // !!! HACK ALERT: for kmddsp pass ptr's to dwNumXxxs
        //

        {
        BOOL    bKmddsp;

        LOG((TL_INFO, "ServerInit: %s: Calling TSPI_providerInit", szFilename));

        if (lstrcmpi(szFilename, TEXT("kmddsp.tsp")) == 0)
        {
            bKmddsp = TRUE;
        }
        else
        {
            bKmddsp = FALSE;

            if (lstrcmpi(szFilename, TEXT("remotesp.tsp")) == 0)
            {
                pRemoteSP = ptProvider;
            }
        }

        lResult = CallSP8(
            ptProvider->apfn[SP_PROVIDERINIT],
            "providerInit",
            SP_FUNC_SYNC,
            (DWORD)ptProvider->dwSPIVersion,
            (DWORD)dwPermanentProviderID,
            (DWORD)GetNumLineLookupEntries (),
            (DWORD)GetNumPhoneLookupEntries (),
            (bKmddsp ? (ULONG_PTR) &dwNumLines : (ULONG_PTR) dwNumLines),
            (bKmddsp ? (ULONG_PTR) &dwNumPhones : (ULONG_PTR) dwNumPhones),
            (ULONG_PTR) CompletionProcSP,
            (ULONG_PTR) &ptProvider->dwTSPIOptions
            );
        }

        if (lResult != 0)
        {
            LOG((TL_ERROR,
                "ServerInit: %s: failed TSPI_providerInit, err=x%x" \
                    " - skipping it...",
                szFilename,
                lResult
                ));

            goto provider_init_error;
        }

        LOG((TL_INFO,
            "ServerInit: %s init'd, dwNumLines=%ld, dwNumPhones=%ld",
            szFilename,
            dwNumLines,
            dwNumPhones
            ));

        fEnumDevices = TRUE;

        //
        // Now that we know if we have line and/or phone devs check for
        // the required entry points
        //

ServerInit_validateEntrypoints:

        {
            DWORD adwRequiredEntrypointIndices[] =
            {
                SP_LINENEGOTIATETSPIVERSION,
                SP_PROVIDERINIT,
                SP_PROVIDERSHUTDOWN,

                SP_PHONENEGOTIATETSPIVERSION,

                0xffffffff
            };
            BOOL bRequiredEntrypointsExported = TRUE;


            //
            // If this provider doesn't support any phone devices then
            // it isn't required to export phone funcs
            //

            if (dwNumPhones == 0)
            {
                adwRequiredEntrypointIndices[3] = 0xffffffff;
            }

            for (j = 0; adwRequiredEntrypointIndices[j] != 0xffffffff; j++)
            {
                if (ptProvider->apfn[adwRequiredEntrypointIndices[j]]
                        == (TSPIPROC) NULL)
                {
                    LOG((TL_ERROR,
                        "ServerInit: %s: can't init, function [%s] " \
                            "not exported",
                        szFilename,
                        (LPCSTR) gaszTSPIFuncNames[
                             adwRequiredEntrypointIndices[j]
                                                  ]
                        ));

                    bRequiredEntrypointsExported = FALSE;
                }
            }

            if (bRequiredEntrypointsExported == FALSE)
            {
                FreeLibrary (ptProvider->hDll);
                ServerFree (ptProvider);
                continue;
            }
        }

        ptProvider->dwPermanentProviderID = dwPermanentProviderID;

        //
        //
        //

        ptProvider->hMutex = MyCreateMutex();

        //
        // Initialize the call hub hash table for this provider
        //

        MyInitializeCriticalSection (&ptProvider->HashTableCritSec, 1000);

        ptProvider->hHashTableReaderEvent = CreateEvent(
            (LPSECURITY_ATTRIBUTES) NULL,
            FALSE,  // auto reset
            FALSE,  // initially non-signaled
            NULL    // unnamed
            );

        ptProvider->dwNumHashTableEntries = TapiPrimes[0];

        ptProvider->pHashTable = ServerAlloc(
            ptProvider->dwNumHashTableEntries * sizeof (THASHTABLEENTRY)
            );

        if (ptProvider->pHashTable)
        {
            PTHASHTABLEENTRY pEntry = ptProvider->pHashTable;

            for (j = 0; j < ptProvider->dwNumHashTableEntries; j++, pEntry++)
            {
                InitializeListHead (&pEntry->CallHubList);
            }
        }
        else
        {
            ptProvider->dwNumHashTableEntries = 0;

        }

        if (ptProvider->hMutex == NULL ||
            ptProvider->hHashTableReaderEvent == NULL ||
            ptProvider->pHashTable == NULL
            )
        {
            DeleteCriticalSection (&ptProvider->HashTableCritSec);
            goto provider_init_error;
        }

#if TELE_SERVER

        //
        // If this is an NT Server we want to be able to set user
        // permissions regardless of whether or not TAPI server
        // functionality is enabled.  This allows an admin to set
        // stuff up while the server is "offline".
        //

        if (gbNTServer)
        {
            LONG        lResult;


            lResult = AddProviderToIdArrayList(
                ptProvider,
                dwNumLines,
                dwNumPhones
                );

            if (lResult != 0)
            {
                LOG((TL_ERROR,
                    "ServerInit: %s: failed AddProviderToIdArrayList [x%x]" \
                        " - skipping it...",
                    ptProvider->szFileName,
                    lResult
                    ));

                DeleteCriticalSection (&ptProvider->HashTableCritSec);
                goto provider_init_error;
            }
        }
#endif


        //
        // Do version negotiation on each device & add them to lookup lists
        //

        {
            DWORD dwDeviceIDBase;


            dwDeviceIDBase = GetNumLineLookupEntries ();

            for (j = dwDeviceIDBase; j < (dwDeviceIDBase + dwNumLines); j++)
            {
                if (AddLine (ptProvider, j, !fReinit))
                {
                }
            }

            dwDeviceIDBase = GetNumPhoneLookupEntries ();

            for (j = dwDeviceIDBase; j < (dwDeviceIDBase + dwNumPhones); j++)
            {
                if (AddPhone (ptProvider, j, !fReinit))
                {
                }
            }
        }

        //
        // Add provider to head of list, mark as valid
        //

        ptProvider->pPrev = NULL;
        ptProvider->pNext = TapiGlobals.ptProviders;
        if (TapiGlobals.ptProviders)
        {
            TapiGlobals.ptProviders->pPrev = ptProvider;
        }
        TapiGlobals.ptProviders = ptProvider;

        ptProvider->dwKey = TPROVIDER_KEY;

    }


    RegCloseKey (hKeyProviders);
    RegCloseKey (hKeyTelephony);

    ReleaseMutex (ghProvRegistryMutex);

    //
    // Save lookup lists & num devices
    //

    if (fReinit)
    {
        dw1 = TapiGlobals.dwNumLines;
        dw2 = TapiGlobals.dwNumPhones;
    }

    TapiGlobals.dwNumLines = GetNumLineLookupEntries ();
    TapiGlobals.dwNumPhones = GetNumPhoneLookupEntries ();

    //
    //  Notify those apps about these new line/phone devices
    //
    if (fReinit)
    {
        //  TAPI 1.4 and above get LINE_CREATE for each line
        for (i = dw1; i < TapiGlobals.dwNumLines; ++i)
        {
            SendAMsgToAllLineApps(
                        TAPI_VERSION1_4 | 0x80000000,
                        LINE_CREATE,    // Msg
                        i,              // Param1
                        0,              // Param2
                        0               // Param3
                        );
        }
        //  TAPI 1.3 get LINE_LINEDEVSTATE with LINEDEVSTATE_REINIT
        if (dw1 < TapiGlobals.dwNumLines)
        {
            SendAMsgToAllLineApps(
                        TAPI_VERSION1_0,
                        LINE_LINEDEVSTATE,
                        LINEDEVSTATE_REINIT,
                        0,
                        0);
        }

        //  TAPI 1.4 and above get PHONE_CREATE for each phone
        for (i = dw2; i < TapiGlobals.dwNumPhones; ++i)
        {
            SendAMsgToAllPhoneApps(
                        TAPI_VERSION1_4 | 0x80000000,
                        PHONE_CREATE,   // Msg
                        i,              // Param1
                        0,              // Param2
                        0               // Param3
                        );
        }
        //  TAPI 1.3 gets PHONE_STATE with PHONESTATE_REINIT
        if (dw2 < TapiGlobals.dwNumPhones)
        {
            SendAMsgToAllPhoneApps(
                        TAPI_VERSION1_0,
                        PHONE_STATE,
                        PHONESTATE_REINIT,
                        0,
                        0);
        }

        for (i = dw1; i < TapiGlobals.dwNumLines; ++i)
        {
            AppendNewDeviceInfo (TRUE, i);
        }
        for (i = dw2; i < TapiGlobals.dwNumPhones; ++i)
        {
            AppendNewDeviceInfo (FALSE, i);
        }
    }

    // init perf stuff
    PerfBlock.dwLines = TapiGlobals.dwNumLines;
    PerfBlock.dwPhones = TapiGlobals.dwNumPhones;

ExitHere:
    return lResult;
}




#if TELE_SERVER

#ifndef UNICODE
#pragma message( "ERROR: TELE_SERVER builds must define UNICODE" )
#endif

BOOL
LoadNewDll(PTMANAGEDLLINFO pDll)
{
    DWORD       dwCount;
    LONG        lResult;


    // verify pointers.  should we do more?
    if (!pDll || !pDll->pszName)
    {
        return FALSE;
    }

    // load dll
    pDll->hDll = LoadLibraryW(pDll->pszName);

    // if it fails, return
    if (!pDll->hDll)
    {
        LOG((TL_ERROR,
                "LoadLibrary failed for management DLL %ls - error x%lx",
                pDll->pszName,
                GetLastError()
               ));

        return FALSE;
    }

    if ((!(pDll->aProcs[TC_CLIENTINITIALIZE] = (CLIENTPROC) GetProcAddress(
                pDll->hDll,
                gaszTCFuncNames[TC_CLIENTINITIALIZE]
                )))  ||

        (!(pDll->aProcs[TC_CLIENTSHUTDOWN] = (CLIENTPROC) GetProcAddress(
                pDll->hDll,
                gaszTCFuncNames[TC_CLIENTSHUTDOWN]
                )))  ||

        (!(pDll->aProcs[TC_LOAD] = (CLIENTPROC) GetProcAddress(
                pDll->hDll,
                gaszTCFuncNames[TC_LOAD]
                )))  ||

        (!(pDll->aProcs[TC_FREE] = (CLIENTPROC) GetProcAddress(
                pDll->hDll,
                gaszTCFuncNames[TC_FREE]
                ))))

    {
        // must export client init and client shutdown
        LOG((TL_ERROR, "Management DLL %ls does not export Load, Free, ClientIntialize or ClientShutdown", pDll->pszName));
        LOG((TL_ERROR, "  The DLL will not be used"));

        FreeLibrary(pDll->hDll);
        return FALSE;
    }

    // get proc addresses

    for (dwCount = 0; dwCount < TC_LASTPROCNUMBER; dwCount++)
    {
        pDll->aProcs[dwCount] = (CLIENTPROC) GetProcAddress(
            pDll->hDll,
            gaszTCFuncNames[dwCount]
            );
    }

    pDll->dwAPIVersion = TAPI_VERSION_CURRENT;

    lResult = (pDll->aProcs[TC_LOAD])(
        &pDll->dwAPIVersion,
        ManagementAddLineProc,
        ManagementAddPhoneProc,
        0
        );

    if (lResult)
    {
        LOG((TL_ERROR, "Management DLL %ls returned %xlx from TAPICLIENT_Load", pDll->pszName, lResult));
        LOG((TL_ERROR, "   The DLL will not be used"));

        FreeLibrary(pDll->hDll);

        return FALSE;
    }

    if ((pDll->dwAPIVersion > TAPI_VERSION_CURRENT) || (pDll->dwAPIVersion < TAPI_VERSION2_1))
    {
        LOG((TL_INFO,
                "Management DLL %ls returned an invalid API version - x%lx",
                pDll->pszName,
                pDll->dwAPIVersion
              ));
        LOG((TL_INFO, "   Will use version x%lx", TAPI_VERSION_CURRENT));

        pDll->dwAPIVersion = TAPI_VERSION_CURRENT;
    }

    return TRUE;
}


// Only exists for TELE_SERVER, which implies NT and thus Unicode.  As
// such it is safe to assume that TCHAR == WCHAR for these.
void
ReadAndInitMapper()
{
    PTMANAGEDLLINFO pMapperInfo;
    HKEY            hKey;
    DWORD           dwDataSize, dwDataType, dwCount;
    LPBYTE          pHold;
    LONG            lResult;

    assert( sizeof(TCHAR) == sizeof(WCHAR) );

    if (!(TapiGlobals.dwFlags & TAPIGLOBALS_SERVER))
    {
        return;
    }

    if ( ! ( pMapperInfo = ServerAlloc( sizeof(TMANAGEDLLINFO) ) ) )
    {
        LOG((TL_ERROR, "ServerAlloc failed in ReadAndInitMap"));
        TapiGlobals.dwFlags &= ~(TAPIGLOBALS_SERVER);

        return;
    }

    // grab server specific stuff from registry
    RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 gszRegKeyServer,
                 0,
                 KEY_ALL_ACCESS,
                 &hKey
                );

    dwDataSize = 0;
    RegQueryValueExW(
                     hKey,
                     gszMapperDll,
                     0,
                     &dwDataType,
                     NULL,
                     &dwDataSize
                    );

    if (dwDataSize == 0)
    {
        LOG((TL_ERROR, "Cannot init client/server stuff (registry damaged?)"));

        RegCloseKey( hKey );

        ServerFree(pMapperInfo);

        TapiGlobals.dwFlags &= ~(TAPIGLOBALS_SERVER);

        return;
    }

    if (!(pHold = ServerAlloc(dwDataSize)))
    {
        LOG((TL_ERROR, "Alloc failed in ReadAndInitMap(o)"));

        TapiGlobals.dwFlags &= ~(TAPIGLOBALS_SERVER);

        ServerFree(pMapperInfo);

        return;
    }

    RegQueryValueExW(
                     hKey,
                     gszMapperDll,
                     0,
                     &dwDataType,
                     pHold,
                     &dwDataSize
                    );

    RegCloseKey( hKey );

//    LOG((TL_INFO, "MapperDll is %ls", pHold));

    if (!(pMapperInfo->hDll = LoadLibraryW((LPWSTR)pHold)))
    {
        LOG((TL_ERROR, "Serious internal failure loading client/server DLL .  Error %lu", pHold, GetLastError()));

        ServerFree( pHold );
        ServerFree( pMapperInfo );

        TapiGlobals.dwFlags &= ~(TAPIGLOBALS_SERVER);

        return;
    }

    // don't need these two for the mapper
    pMapperInfo->pNext = NULL;

    // save the name
    pMapperInfo->pszName = (LPWSTR)pHold;

    // get proc addresses for the first 5 api
    for (dwCount = 0; dwCount < 5; dwCount ++)
    {
        if (!(pMapperInfo->aProcs[dwCount] = (CLIENTPROC) GetProcAddress(
                pMapperInfo->hDll,
                gaszTCFuncNames[dwCount]
                )))
        {
            // one of these addresses failed.  remove DLL
            LOG((TL_INFO, "MapperDLL does not export %s.  Server functionality disabled", gaszTCFuncNames[dwCount]));
            LOG((TL_INFO, "Disabling the Telephony server! (8)"));

            FreeLibrary(pMapperInfo->hDll);
            ServerFree(pMapperInfo->pszName);
            ServerFree(pMapperInfo);

            TapiGlobals.pMapperDll = NULL;
            TapiGlobals.dwFlags &= ~(TAPIGLOBALS_SERVER);

            return;
        }
    }

    pMapperInfo->dwAPIVersion = TAPI_VERSION_CURRENT;
    lResult = (pMapperInfo->aProcs[TC_LOAD])(
        &pMapperInfo->dwAPIVersion,
        ManagementAddLineProc,
        ManagementAddPhoneProc,
        0
        );

    if (lResult)
    {
        LOG((TL_INFO, "Client/server loadup - x%lx.", lResult));
        FreeLibrary(pMapperInfo->hDll);
        ServerFree(pMapperInfo->pszName);
        ServerFree(pMapperInfo);

        TapiGlobals.pMapperDll = NULL;
        TapiGlobals.dwFlags &= ~(TAPIGLOBALS_SERVER);

        return;
    }

    if ((pMapperInfo->dwAPIVersion > TAPI_VERSION_CURRENT) || (pMapperInfo->dwAPIVersion < TAPI_VERSION2_1))
    {
        LOG((TL_ERROR, "Internal version mismatch!  Check that all components are in sync x%lx", pMapperInfo->dwAPIVersion));
        LOG((TL_INFO, "   Will use version x%lx", TAPI_VERSION_CURRENT));

        pMapperInfo->dwAPIVersion = TAPI_VERSION_CURRENT;
    }

    TapiGlobals.pMapperDll = pMapperInfo;

}

LONG
FreeOldDllListProc(
                   PTMANAGEDLLLISTHEADER   pDllList
                  )
{
    PTMANAGEDLLINFO     pDll, pNext;

#if DBG
    DWORD       dwCount = 0;
#endif

    SetThreadPriority(
                      GetCurrentThread(),
                      THREAD_PRIORITY_LOWEST
                     );

    // wait until count is 0
    while (pDllList->lCount > 0)
    {
        Sleep(100);
#if DBG
        dwCount++;

        if (dwCount > 100)
        {
            LOG((TL_INFO, "FreeOldDllListProc still waiting after 10 seconds"));
        }
#endif
    }

    EnterCriticalSection(&gManagementDllsCritSec);

    // walk the list
    pDll = pDllList->pFirst;

    while (pDll)
    {
        // free all resources
        if (pDll->hDll)
        {
            (pDll->aProcs[TC_FREE])();

            FreeLibrary(pDll->hDll);
        }

        ServerFree(pDll->pszName);

        pNext = pDll->pNext;
        ServerFree(pDll);
        pDll = pNext;
    }

    // free header
    ServerFree(pDllList);

    LeaveCriticalSection(&gManagementDllsCritSec);

    return 0;
}

void
ManagementProc(
                    LONG l
                   )
{
    HKEY        hKey = NULL;
    DWORD       dw, dwDSObjTTLTicks;
    HANDLE      hEventNotify = NULL;
    HANDLE      aHandles[2];

    if (ERROR_SUCCESS != RegOpenKeyEx(
        HKEY_LOCAL_MACHINE,
        gszRegKeyServer,
        0,
        KEY_READ,
        &hKey
        ))
    {
        LOG((TL_ERROR, "RegOpenKeyExW failed in ManagementProc"));
        goto ExitHere;
    }
    hEventNotify = CreateEvent (NULL, FALSE, FALSE, NULL);
    if (hEventNotify == NULL)
    {
        goto ExitHere;
    }
    aHandles[0] = hEventNotify;
    aHandles[1] = ghEventService;

    //  Compute TAPISRV SCP refresh interval in ticks
    //  gdwTapiSCPTTL is expressed in terms of minutes
    dwDSObjTTLTicks = gdwTapiSCPTTL * 60 * 1000 / 2;

    while (TRUE)
    {
        RegNotifyChangeKeyValue(
            hKey,
            TRUE,
            REG_NOTIFY_CHANGE_LAST_SET,
            hEventNotify,
            TRUE
            );
        dw = WaitForMultipleObjects (
            sizeof(aHandles) / sizeof(HANDLE),
            aHandles,
            FALSE,
            dwDSObjTTLTicks
            );

        if (dw == WAIT_OBJECT_0)
        {
            //  Notified of the registry change
            ReadAndInitManagementDlls();
        }
        else if (dw == WAIT_OBJECT_0 + 1)
        {
            //  the service is shutting down, update
            //  DS about this and break out
            UpdateTapiSCP (FALSE, NULL, NULL);
            break;
        }
        else if (dw == WAIT_TIMEOUT)
        {
            //  Time to refresh our DS registration now
            UpdateTapiSCP (TRUE, NULL, NULL);
        }
    }

ExitHere:
    if (hKey)
    {
        RegCloseKey(hKey);
    }
    if (hEventNotify)
    {
        CloseHandle (hEventNotify);
    }
}

//////////////////////////////////////////////////////////////////////
//
//  ReadAndInitManagementDLLs()
//
//  This procedure will read the management dll list from the registry
//  It will then go through that list, and create a linked list of
//  TMANAGEDLLINFO structures to hold all the info about those DLLs
//
//  If there is already a list of these DLLs in TapiGlobals, this procedure
//  will then go through that list and determine which of the old DLLs
//  are in the new list.  For the matches, it will simply copy over
//  the info about that DLL, and zero out the fields in the old list
//
//  It will go through the new list.  Entries that are not already
//  filled in will get initialized.
//
//  Then it will save the new list in TapiGlobals.
//
//  If an old list existed, it will create a thread that will wait
//  for this old list to be freed
//
//  The procedure isn't real efficient, but I believe it's thread safe.
//  Additionally, changing the security DLLs should happen very infrequently,
//  and the list of DLLs should be very short.
//
//////////////////////////////////////////////////////////////////////
void
ReadAndInitManagementDlls()
{
    DWORD                   dwDataSize, dwDataType, dwTID;
    HKEY                    hKey;
    LPWSTR                  pDLLs, pHold1, pHold2;
    DWORD                   dwCount = 0;
    PTMANAGEDLLINFO         pManageDll, pHoldDll, pNewHoldDll, pPrevDll, pTempDll;
    PTMANAGEDLLLISTHEADER   pNewDllList = NULL, pHoldDllList;
    BOOL                    bBreak = FALSE;


    //
    // If it's not a server, we have no business here.
    //
    if (!(TapiGlobals.dwFlags & TAPIGLOBALS_SERVER))
    {
        return;
    }

    EnterCriticalSection(&gManagementDllsCritSec);

    // get info from registry
    RegOpenKeyEx(
                 HKEY_LOCAL_MACHINE,
                 gszRegKeyServer,
                 0,
                 KEY_ALL_ACCESS,
                 &hKey
                );

    dwDataSize = 0;
    RegQueryValueExW(
                     hKey,
                     gszManagementDlls,
                     0,
                     &dwDataType,
                     NULL,
                     &dwDataSize
                    );


    if (dwDataSize == 0)
    {
        LOG((TL_ERROR, "No management DLLs present on this server"));

        // if there was previously a list
        // free it.
        if (TapiGlobals.pManageDllList)
        {
            HANDLE      hThread;


            pHoldDllList = TapiGlobals.pManageDllList;

            EnterCriticalSection( &gDllListCritSec );

            TapiGlobals.pManageDllList = NULL;

            LeaveCriticalSection( &gDllListCritSec );

            // create a thread to wait for the
            // list and free it
            hThread = CreateThread(
                                   NULL,
                                   0,
                                   (LPTHREAD_START_ROUTINE)FreeOldDllListProc,
                                   pHoldDllList,
                                   0,
                                   &dwTID
                                  );

            CloseHandle( hThread );

        }

        RegCloseKey( hKey );
        LeaveCriticalSection(&gManagementDllsCritSec);

        return;
    }

    if (!(pDLLs = ServerAlloc(dwDataSize)))
    {
        RegCloseKey( hKey );
        LeaveCriticalSection(&gManagementDllsCritSec);

        return;
    }

    RegQueryValueExW(
                     hKey,
                     gszManagementDlls,
                     0,
                     &dwDataType,
                     (LPBYTE)pDLLs,
                     &dwDataSize
                    );

    RegCloseKey( hKey );

    // alloc new list header and first element
    if (!(pNewDllList = (PTMANAGEDLLLISTHEADER) ServerAlloc( sizeof( TMANAGEDLLLISTHEADER ) ) ) )
    {
        ServerFree( pDLLs );

        LeaveCriticalSection(&gManagementDllsCritSec);

        return;
    }

    pNewDllList->lCount = 0;

    if (!(pNewDllList->pFirst = ServerAlloc( sizeof( TMANAGEDLLINFO ) ) ) )
    {
        ServerFree( pDLLs );
        ServerFree( pNewDllList );

        LeaveCriticalSection(&gManagementDllsCritSec);

        return;
    }

    // now, go through the list of dll names and initialize
    // the new TMANAGEDLLINFO list
    pHold1 = pHold2 = pDLLs;

    pManageDll = pNewDllList->pFirst;

    while (TRUE)
    {
        // find end or "
        while (*pHold1 && *pHold1 != L'"')
            pHold1++;

        // null terminate name
        if (*pHold1)
        {
            *pHold1 = '\0';
        }
        else
        {
            bBreak = TRUE;
        }

        LOG((TL_INFO, "Management DLL %d is %ls", dwCount, pHold2));

        // alloc space for name and procaddresses
        pManageDll->pszName = ServerAlloc( ( lstrlenW( pHold2 ) + 1 ) * sizeof (WCHAR) );

        if (!pManageDll->pszName)
        {
            goto ExitHere;
        }

        // save name
        wcscpy(
                 pManageDll->pszName,
                 pHold2
                );

        // save ID
        pManageDll->dwID = gdwDllIDs++;

        // if we're at the end of the list,
        // break out
        if (bBreak)
            break;

        // otherwise, skip over null
        pHold1++;

        // save beginning of next name
        pHold2 = pHold1;

        // inc count
        dwCount++;

        // prepare next buffer
        if (!(pManageDll->pNext = ServerAlloc( sizeof ( TMANAGEDLLINFO ) ) ) )
        {
            goto ExitHere;
        }

        pManageDll = pManageDll->pNext;
    }

    // if an old list exists, walk through and copy over Dlls that have
    // not changed

    pHoldDllList = TapiGlobals.pManageDllList;

    if (pHoldDllList)
    {
        pHoldDll = pHoldDllList->pFirst;

        while (pHoldDll)
        {
            pNewHoldDll = pNewDllList->pFirst;

            // walk through list of new dlls
            while (pNewHoldDll)
            {
                // if they are the same
                if (!lstrcmpiW(
                               pNewHoldDll->pszName,
                               pHoldDll->pszName
                              )
                   )
                {
                    // save info
                    memcpy(
                           pNewHoldDll->aProcs,
                           pHoldDll->aProcs,
                           sizeof( pHoldDll->aProcs )
                          );

                    pNewHoldDll->hDll = pHoldDll->hDll;
                    pNewHoldDll->dwID = pHoldDll->dwID;

                    // NULL old hDll so we know that
                    // we have it
                    pHoldDll->hDll = NULL;

                    break;
                }

                pNewHoldDll = pNewHoldDll->pNext;
            } // while pNewHoldDll

            pHoldDll = pHoldDll->pNext;

        } // while pHoldDll
    }

    // walk through the new list and init items that
    // have not been initialized already
    pNewHoldDll = pNewDllList->pFirst;
    pPrevDll = NULL;

    while (pNewHoldDll)
    {
        if (!pNewHoldDll->hDll)
        {
            // try to load the new dll
            if (!LoadNewDll(pNewHoldDll))
            {
                // it failed
                if (pPrevDll)
                {
                    pPrevDll->pNext = pNewHoldDll->pNext;
                    ServerFree(pNewHoldDll);
                    pNewHoldDll = pPrevDll;
                }
                else
                {
                    pNewDllList->pFirst = pNewHoldDll->pNext;
                    ServerFree(pNewHoldDll);
                    pNewHoldDll = pNewDllList->pFirst;
                    continue;
                }

            }
        }

        // next dll
        pPrevDll = pNewHoldDll;
        pNewHoldDll = pNewHoldDll->pNext;
    }


    if (pNewDllList->pFirst == NULL)
    {
        // all the DLLs failed to load, or the DLL list was empty
        ServerFree( pNewDllList );

        pNewDllList = NULL;
    }

    // save old list pointer
    pHoldDllList = TapiGlobals.pManageDllList;

    // replace the list
    EnterCriticalSection( &gDllListCritSec );

    TapiGlobals.pManageDllList = pNewDllList;
    pNewDllList = NULL;

    LeaveCriticalSection( &gDllListCritSec );


    if (pHoldDllList)
    {
        HANDLE          hThread;


        // create a thread to wait for the
        // list and free it
        hThread = CreateThread(
                               NULL,
                               0,
                               (LPTHREAD_START_ROUTINE)FreeOldDllListProc,
                               pHoldDllList,
                               0,
                               &dwTID
                              );

        CloseHandle( hThread );
    }

ExitHere:
    ServerFree( pDLLs );

    // Error during pNewDllList allocation
    if (pNewDllList != NULL)
    {
        pManageDll = pNewDllList->pFirst;
        while (pManageDll != NULL)
        {
            pTempDll = pManageDll;
            pManageDll = pManageDll->pNext;
            ServerFree (pTempDll->pszName);
            ServerFree (pTempDll);
        }
        ServerFree( pNewDllList );
    }

    LeaveCriticalSection(&gManagementDllsCritSec);

    return;
}


void
GetManageDllListPointer(
                        PTMANAGEDLLLISTHEADER * ppDllList
                       )
{
    EnterCriticalSection( &gDllListCritSec );

    if (TapiGlobals.pManageDllList != NULL)
    {
        TapiGlobals.pManageDllList->lCount++;
    }

    *ppDllList = TapiGlobals.pManageDllList;

    LeaveCriticalSection( &gDllListCritSec );
}


void
FreeManageDllListPointer(
                         PTMANAGEDLLLISTHEADER pDllList
                        )
{
    EnterCriticalSection( &gDllListCritSec );


    if (pDllList != NULL)
    {
        pDllList->lCount--;

        if ( pDllList->lCount < 0 )
        {
            LOG((TL_INFO, "pDllList->lCount is less than 0 - pDllList %p", pDllList));
        }
    }

    LeaveCriticalSection( &gDllListCritSec );
}


#endif





void
PASCAL
SetMediaModesPriorityList(
                          HKEY hKeyPri,
                          PRILISTSTRUCT * pPriList
                         )
{
    DWORD       dwCount;

    for (dwCount = 0; dwCount<TapiGlobals.dwUsedPriorityLists; dwCount++)
    {
        TCHAR   szName[REGNAMESIZE];


        if ( (NULL == pPriList[dwCount].pszPriList) ||
             (L'\0' == *(pPriList[dwCount].pszPriList)) )
        {

//         What if there USED TO be an entry, but the app setpri to 0, then this
//         entry would be '\0', but the registry entry would still be there.

            continue;
        }

        wsprintf(
                  szName,
                  TEXT("%d"),
                  pPriList[dwCount].dwMediaModes
                 );

        TAPIRegSetValueExW(
                       hKeyPri,
                       szName,
                       0,
                       REG_SZ,
                       (LPBYTE)( (pPriList[dwCount].pszPriList) + 1 ),
                       (lstrlenW(pPriList[dwCount].pszPriList)) * sizeof (WCHAR)
                      );
    }
}

void
PASCAL
SetPriorityList(
    HKEY    hKeyHandoffPriorities,
    const TCHAR  *pszListName,
    WCHAR  *pszPriorityList
    )
{
    if (pszPriorityList == NULL)
    {
        //
        // There is no pri list for this media mode or ReqXxxCall,
        // so delete any existing value from the registry
        //

        RegDeleteValue (hKeyHandoffPriorities, pszListName);
    }
    else
    {
        //
        // Add the pri list to the registry (note that we don't
        // add the preceding '"')
        //

        TAPIRegSetValueExW(
            hKeyHandoffPriorities,
            pszListName,
            0,
            REG_SZ,
            (LPBYTE)(pszPriorityList + 1),
            lstrlenW (pszPriorityList) * sizeof (WCHAR)
            );
    }
}


LONG
ServerShutdown(
    void
    )
{
    DWORD       i, j;
    PTPROVIDER  ptProvider;


    //
    // Reset the flag that says it's ok to queue sp events, & then wait
    // for the SPEventHandlerThread(s) to clean up the SP event queue(s)
    //

    gbQueueSPEvents = FALSE;


    //
    // Set a reasonable cap on the max time we'll sit here
    // Don't wait for a message to be dispatched if called
    // from "net stop tapisrv"
    //

    i = 10 * 20;  // 200 * 100msecs = 20 seconds

    while (i && !gbSPEventHandlerThreadExit)
    {
        for (j = 0; j < gdwNumSPEventHandlerThreads; j++)
        {
            if (!IsListEmpty (&aSPEventHandlerThreadInfo[j].ListHead))
            {
                break;
            }
        }

        if (j == gdwNumSPEventHandlerThreads)
        {
            break;
        }

        Sleep (100);
        i--;
    }


    //
    // For each provider call the shutdown proc & then unload
    //

    ptProvider = TapiGlobals.ptProviders;

    while (ptProvider)
    {
        PTPROVIDER ptNextProvider = ptProvider->pNext;
        LONG lResult;


        lResult = CallSP2(
            ptProvider->apfn[SP_PROVIDERSHUTDOWN],
            "providerShutdown",
            SP_FUNC_SYNC,
            (DWORD)ptProvider->dwSPIVersion,
            (DWORD)ptProvider->dwPermanentProviderID
            );


        FreeLibrary (ptProvider->hDll);

        MyCloseMutex (ptProvider->hMutex);

        CloseHandle (ptProvider->hHashTableReaderEvent);
        DeleteCriticalSection (&ptProvider->HashTableCritSec);
        ServerFree (ptProvider->pHashTable);

        ServerFree (ptProvider);

        ptProvider = ptNextProvider;
    }

    TapiGlobals.ptProviders = NULL;


    //
    // Clean up lookup tables
    //

    while (TapiGlobals.pLineLookup)
    {
        PTLINELOOKUPTABLE pLookup = TapiGlobals.pLineLookup;


        for (i = 0; i < pLookup->dwNumUsedEntries; i++)
        {
            if (!pLookup->aEntries[i].bRemoved)
            {
                MyCloseMutex (pLookup->aEntries[i].hMutex);
            }
        }

        TapiGlobals.pLineLookup = pLookup->pNext;

        ServerFree (pLookup);
    }

    while (TapiGlobals.pPhoneLookup)
    {
        PTPHONELOOKUPTABLE pLookup = TapiGlobals.pPhoneLookup;


        for (i = 0; i < pLookup->dwNumUsedEntries; i++)
        {
            if (!pLookup->aEntries[i].bRemoved)
            {
                MyCloseMutex (pLookup->aEntries[i].hMutex);
            }
        }

        TapiGlobals.pPhoneLookup = pLookup->pNext;

        ServerFree (pLookup);
    }

    {
        TCHAR       szPerfNumLines[] = TEXT("Perf1");
        TCHAR       szPerfNumPhones[] =TEXT("Perf2");
        HKEY        hKeyTelephony;
        DWORD       dwValue;

        if (ERROR_SUCCESS ==
            RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                gszRegKeyTelephony,
                0,
                KEY_ALL_ACCESS,
                &hKeyTelephony
                ))
        {
            dwValue = TapiGlobals.dwNumLines + 'PERF';

            RegSetValueEx(
                hKeyTelephony,
                szPerfNumLines,
                0,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(DWORD)
                );

            dwValue = TapiGlobals.dwNumPhones + 'PERF';

            RegSetValueEx(
                hKeyTelephony,
                szPerfNumPhones,
                0,
                REG_DWORD,
                (LPBYTE)&dwValue,
                sizeof(DWORD)
                );

            RegCloseKey(hKeyTelephony);
        }
    }

    //
    // Reset globals
    //

    TapiGlobals.dwFlags &= ~(TAPIGLOBALS_REINIT);

    {
        PPERMANENTIDARRAYHEADER pIDArray = TapiGlobals.pIDArrays, pArrayHold;


        while (pIDArray)
        {
            ServerFree (pIDArray->pLineElements);
            ServerFree (pIDArray->pPhoneElements);

            pArrayHold = pIDArray->pNext;

            ServerFree (pIDArray);

            pIDArray = pArrayHold;
        }

        TapiGlobals.pIDArrays = NULL;

        if (gpLineInfoList)
        {
            ServerFree (gpLineInfoList);
            gpLineInfoList = NULL;
            ZeroMemory (&gftLineLastWrite, sizeof(gftLineLastWrite));
        }
        if (gpPhoneInfoList)
        {
            ServerFree (gpPhoneInfoList);
            gpPhoneInfoList = NULL;
            ZeroMemory (&gftPhoneLastWrite, sizeof(gftPhoneLastWrite));
        }
        if (gpLineDevFlags)
        {
            ServerFree (gpLineDevFlags);
            gpLineDevFlags = NULL;
            gdwNumFlags = 0;
        }
        gbLockMMCWrite = FALSE;

        OnProxySCPShutdown ();
    }

    return 0;
}


void
WINAPI
GetAsyncEvents(
	PTCLIENT				ptClient,
    PGETEVENTS_PARAMS       pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    DWORD       dwMoveSize, dwMoveSizeWrapped;

    LOG((TL_TRACE, "GetAsyncEvents: enter (TID=%d)", GetCurrentThreadId()));


    LOG((TL_INFO,
        "M ebfused:x%lx  pEvtBuf: 0x%p  pDataOut:0x%p  pDataIn:0x%p",
        ptClient->dwEventBufferUsedSize,
        ptClient->pEventBuffer,
        ptClient->pDataOut,
        ptClient->pDataIn
        ));


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwTotalBufferSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    //
    // Copy data from ptClient's event buffer
    //
    // An optimization to be made is to alert client (via dwNeededSize)
    // that it might want to alloc a larger buffer when msg traffic is
    // real high
    //

    if (WaitForExclusiveClientAccess (ptClient))
    {
     _TryAgain:
        if (ptClient->dwEventBufferUsedSize == 0)
        {
            if (!IS_REMOTE_CLIENT (ptClient))
            {
                ResetEvent (ptClient->hValidEventBufferDataEvent);
            }

            pParams->dwNeededBufferSize =
            pParams->dwUsedBufferSize   = 0;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG);

            RESET_FLAG (ptClient->dwFlags, PTCLIENT_FLAG_SKIPFIRSTMESSAGE);

            goto GetAsyncEvents_releaseMutex;
        }

        if (ptClient->pDataOut < ptClient->pDataIn)
        {
            dwMoveSize = (DWORD) (ptClient->pDataIn - ptClient->pDataOut);

            dwMoveSizeWrapped = 0;
        }
        else
        {
            dwMoveSize = ptClient->dwEventBufferTotalSize -
                 (DWORD) (ptClient->pDataOut - ptClient->pEventBuffer);

            dwMoveSizeWrapped = (DWORD)
                (ptClient->pDataIn - ptClient->pEventBuffer);
        }

        if (ptClient->dwEventBufferUsedSize <= pParams->dwTotalBufferSize)
        {
            //
            // If here the size of the queued event data is less than the
            // client buffer size, so we can just blast the bits into the
            // client buffer & return. Also make sure to reset the "events
            // pending" event
            //

            CopyMemory (pDataBuf, ptClient->pDataOut, dwMoveSize);

            if (dwMoveSizeWrapped)
            {
                CopyMemory(
                    pDataBuf + dwMoveSize,
                    ptClient->pEventBuffer,
                    dwMoveSizeWrapped
                    );
            }

            ptClient->dwEventBufferUsedSize = 0;

            ptClient->pDataOut = ptClient->pDataIn = ptClient->pEventBuffer;

            RESET_FLAG (ptClient->dwFlags, PTCLIENT_FLAG_SKIPFIRSTMESSAGE);

            if (!IS_REMOTE_CLIENT (ptClient))
            {
                ResetEvent (ptClient->hValidEventBufferDataEvent);
            }

            pParams->dwNeededBufferSize =
            pParams->dwUsedBufferSize   = dwMoveSize + dwMoveSizeWrapped;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                pParams->dwUsedBufferSize;

        }
        else
        {
            //
            // If here the size of the queued event data exceeds that
            // of the client buffer.  Since our events aren't all the
            // same size we need to copy them over one by one, making
            // sure we don't overflow the client buffer.  Don't reset
            // the "events pending" event, so async events thread will
            // call us again as soon as it's done processing messages
            // in the buffer.
            //

            DWORD   dwBytesLeftInClientBuffer = pParams->dwTotalBufferSize,
                    dwDataOffset = 0, dwDataOffsetWrapped = 0;
            DWORD   dwTotalMoveSize = dwMoveSize;


            LOG((TL_TRACE, "GetAsyncEvents: event data exceeds client buffer"));

            pParams->dwNeededBufferSize = ptClient->dwEventBufferUsedSize;

            while (1)
            {
                DWORD   dwMsgSize = (DWORD) ((PASYNCEVENTMSG)
                            (ptClient->pDataOut + dwDataOffset))->TotalSize;


                if (dwMsgSize > dwBytesLeftInClientBuffer)
                {
                    if ((pParams->dwUsedBufferSize = dwDataOffset) != 0)
                    {
                        ptClient->dwEventBufferUsedSize -= dwDataOffset;

                        ptClient->pDataOut += dwDataOffset;
                    }
                    else
                    {
                        //
                        // Special case: the 1st msg is bigger than the entire
                        // buffer
                        //
                        if (IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_SKIPFIRSTMESSAGE))
                        {
                         DWORD dwBytesToTheEndOfTheBuffer = ptClient->dwEventBufferTotalSize - (DWORD)(ptClient->pDataOut - ptClient->pEventBuffer);
                            // This is the second time the client tries to get
                            // this message, with too small a buffer. We can
                            // assume that the client cannot allocate enough
                            // memory, so skip this message...
                            RESET_FLAG(ptClient->dwFlags, PTCLIENT_FLAG_SKIPFIRSTMESSAGE);
                            if (dwMsgSize > dwBytesToTheEndOfTheBuffer)
                            {
                                // This means that this message wraps around...
                                dwBytesToTheEndOfTheBuffer = dwMsgSize - dwBytesToTheEndOfTheBuffer;
                                ptClient->pDataOut = ptClient->pEventBuffer + dwBytesToTheEndOfTheBuffer;
                            }
                            else
                            {
                                ptClient->pDataOut += dwMsgSize;
                            }
                            ptClient->dwEventBufferUsedSize -= dwMsgSize;
                            goto _TryAgain;
                        }
                        else
                        {
                            // Set the flag, so next time we'll skip the message
                            // if the buffer will still be too small.
                            SET_FLAG(ptClient->dwFlags, PTCLIENT_FLAG_SKIPFIRSTMESSAGE);
                        }
                    }

                    *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                        pParams->dwUsedBufferSize;

                    goto GetAsyncEvents_releaseMutex;
                }

                dwBytesLeftInClientBuffer -= dwMsgSize;

                if (dwMsgSize <= dwMoveSize)
                {
                    //
                    // Msg isn't wrapped, a single copy will do
                    //

                    CopyMemory(
                        pDataBuf + dwDataOffset,
                        ptClient->pDataOut + dwDataOffset,
                        dwMsgSize
                        );


                    //
                    // Check to see if the msg ran to the end of the buffer,
                    // & break to the wrapped data code if so
                    //

                    if ((dwDataOffset += dwMsgSize) >= dwTotalMoveSize)
                    {
                        ptClient->pDataOut = ptClient->pEventBuffer;
                        break;
                    }
                }
                else
                {
                    //
                    // This msg is wrapped.  We need to do two copies, then
                    // break out of this loop to the wrapped data code
                    //

                    CopyMemory(
                        pDataBuf + dwDataOffset,
                        ptClient->pDataOut + dwDataOffset,
                        dwMoveSize
                        );

                    dwDataOffset += dwMoveSize;

                    CopyMemory(
                        pDataBuf + dwDataOffset,
                        ptClient->pEventBuffer,
                        dwMsgSize - dwMoveSize
                        );

                    dwDataOffset += ( dwMsgSize - dwMoveSize);

                    ptClient->pDataOut = ptClient->pEventBuffer +
                        (dwMsgSize - dwMoveSize);

                    break;
                }

                dwMoveSize -= dwMsgSize;
            }


            while (1)
            {
                DWORD   dwMsgSize = (DWORD)
                            ((PASYNCEVENTMSG) (ptClient->pDataOut +
                                dwDataOffsetWrapped))->TotalSize;


                if (dwMsgSize > dwBytesLeftInClientBuffer)
                {
                    ptClient->dwEventBufferUsedSize -= dwDataOffset;

                    ptClient->pDataOut += dwDataOffsetWrapped;

                    pParams->dwUsedBufferSize = dwDataOffset;

                    *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                        pParams->dwUsedBufferSize;

                    goto GetAsyncEvents_releaseMutex;
                }

                //
                // Msg isn't wrapped, a single copy will do
                //

                CopyMemory(
                    pDataBuf + dwDataOffset,
                    ptClient->pDataOut + dwDataOffsetWrapped,
                    dwMsgSize
                    );

                dwDataOffset += dwMsgSize;
                dwDataOffsetWrapped += dwMsgSize;

                dwBytesLeftInClientBuffer -= dwMsgSize;
            }
        }

        LOG((TL_TRACE, "GetAsyncEvents: return dwUsedBufferSize:x%lx", 
                pParams->dwUsedBufferSize ));

GetAsyncEvents_releaseMutex:

        if (ptClient->MsgPendingListEntry.Flink)
        {
            //
            // This is a remote Dg client.
            //
            // If there is no more data in the event buffer then remove
            // this client from the DgClientMsgPendingList(Head) so the
            // EventNotificationThread will stop monitoring it.
            //
            // Else, update the tClient's Retry & EventsRetrieved tick
            // counts.
            //

            if (ptClient->dwEventBufferUsedSize == 0)
            {
                EnterCriticalSection (&gDgClientMsgPendingCritSec);

                RemoveEntryList (&ptClient->MsgPendingListEntry);

                ptClient->MsgPendingListEntry.Flink =
                ptClient->MsgPendingListEntry.Blink = NULL;

                LeaveCriticalSection (&gDgClientMsgPendingCritSec);
            }
            else
            {
                ptClient->dwDgEventsRetrievedTickCount = GetTickCount();

                ptClient->dwDgRetryTimeoutTickCount =
                    ptClient->dwDgEventsRetrievedTickCount +
                    3 * DGCLIENT_TIMEOUT;
            }
        }

        UNLOCKTCLIENT (ptClient);
    }
}


void
WINAPI
GetUIDllName(
	PTCLIENT				ptClient,
    PGETUIDLLNAME_PARAMS    pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    LONG                lResult = 0;
    TSPIPROC            pfnTSPI_providerUIIdentify = (TSPIPROC) NULL;
    PTAPIDIALOGINSTANCE ptDlgInst = (PTAPIDIALOGINSTANCE) NULL;
    PTLINELOOKUPENTRY   pLookupEntry = NULL;
    DWORD               dwObjectID = pParams->dwObjectID;


    LOG((TL_TRACE,  "Entering GetUIDllName"));

    switch (pParams->dwObjectType)
    {
    case TUISPIDLL_OBJECT_LINEID:
    {

#if TELE_SERVER

        if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
            !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
        {
            if (pParams->dwObjectID >= ptClient->dwLineDevices)
            {
                pParams->lResult = LINEERR_OPERATIONFAILED;
                return;
            }

            dwObjectID = ptClient->pLineDevices[pParams->dwObjectID];
        }

#endif

        if (TapiGlobals.dwNumLineInits == 0 )
        {
            lResult = LINEERR_UNINITIALIZED;
            break;
        }

        pLookupEntry = GetLineLookupEntry (dwObjectID);

        if (!pLookupEntry)
        {
            lResult = (TapiGlobals.dwNumLineInits == 0 ?
                LINEERR_UNINITIALIZED : LINEERR_BADDEVICEID);
        }
        else if (!pLookupEntry->ptProvider || pLookupEntry->bRemoved)
        {
            lResult = LINEERR_NODEVICE;
        }
        else if (!(pfnTSPI_providerUIIdentify =
                pLookupEntry->ptProvider->apfn[SP_PROVIDERUIIDENTIFY]))
        {
            lResult = LINEERR_OPERATIONUNAVAIL;
        }

        break;
    }
    case TUISPIDLL_OBJECT_PHONEID:
    {


#if TELE_SERVER
        if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
            !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
        {
            if (pParams->dwObjectID >= ptClient->dwPhoneDevices)
            {
                pParams->lResult = PHONEERR_OPERATIONFAILED;
                return;
            }

            dwObjectID = ptClient->pPhoneDevices[pParams->dwObjectID];
        }
#endif

        if (TapiGlobals.dwNumPhoneInits == 0 )
        {
            lResult = PHONEERR_UNINITIALIZED;
            break;
        }

        pLookupEntry = (PTLINELOOKUPENTRY) GetPhoneLookupEntry (dwObjectID);


        if (!pLookupEntry)
        {
            lResult = (TapiGlobals.dwNumPhoneInits == 0 ?
                PHONEERR_UNINITIALIZED : PHONEERR_BADDEVICEID);
        }
        else if (!pLookupEntry->ptProvider || pLookupEntry->bRemoved)
        {
            lResult = PHONEERR_NODEVICE;
        }
        else if (!(pfnTSPI_providerUIIdentify =
                pLookupEntry->ptProvider->apfn[SP_PROVIDERUIIDENTIFY]))
        {
            lResult = PHONEERR_OPERATIONUNAVAIL;
        }

        break;
    }
    case TUISPIDLL_OBJECT_PROVIDERID:

		LOG((TL_INFO, "Looking for provider..."));

#if TELE_SERVER

        // Provider add/remove needs to be restricted to Admins.
        if (!IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR) &&
            (pParams->bRemoveProvider || pParams->dwProviderFilenameOffset != TAPI_NO_DATA))
        {
            lResult = LINEERR_OPERATIONFAILED;
            goto GetUIDllName_return;
        }

#endif

        if (!(ptDlgInst = ServerAlloc (sizeof (TAPIDIALOGINSTANCE))))
        {
            lResult = LINEERR_NOMEM;
            goto GetUIDllName_return;
        }
        ptDlgInst->htDlgInst = NewObject(ghHandleTable, ptDlgInst, NULL);
        if (0 == ptDlgInst->htDlgInst)
        {
            ServerFree (ptDlgInst);
            lResult = LINEERR_NOMEM;
            goto GetUIDllName_return;
        }

        if (pParams->dwProviderFilenameOffset == TAPI_NO_DATA)
        {
            //
            // This is a providerConfig or -Remove request.  Loop thru the
            // list of installed providers, trying to find one with a
            // matching PPID.
            //

            int     i, iNumProviders;
            TCHAR   szProviderXxxN[32];

            HKEY  hKeyProviders;
            DWORD dwDataSize;
            DWORD dwDataType;
            DWORD dwTemp;


            if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    gszRegKeyProviders,
                    0,
                    KEY_ALL_ACCESS,
                    &hKeyProviders

                    ) != ERROR_SUCCESS)
            {
                LOG((TL_ERROR,
                    "RegOpenKeyEx(/Providers) failed, err=%d",
                    GetLastError()
                    ));

                DereferenceObject (ghHandleTable, ptDlgInst->htDlgInst, 1);
                lResult = LINEERR_OPERATIONFAILED;
                goto GetUIDllName_return;
            }

            dwDataSize = sizeof(iNumProviders);
            iNumProviders = 0;

            RegQueryValueEx(
                hKeyProviders,
                gszNumProviders,
                0,
                &dwDataType,
                (LPBYTE) &iNumProviders,
                &dwDataSize
                );

            for (i = 0; i < iNumProviders; i++)
            {
                wsprintf(szProviderXxxN, TEXT("%s%d"), gszProviderID, i);

                dwDataSize = sizeof(dwTemp);
                dwTemp = 0;

                RegQueryValueEx(
                    hKeyProviders,
                    szProviderXxxN,
                    0,
                    &dwDataType,
                    (LPBYTE)&dwTemp,
                    &dwDataSize
                    );

                if (dwTemp == pParams->dwObjectID)
                {
                    //
                    // We found the provider, try to load it & get ptrs
                    // to the relevant funcs
                    //

                    TCHAR szProviderFilename[MAX_PATH];


                    wsprintf(szProviderXxxN, TEXT("%s%d"), gszProviderFilename, i);

                    dwDataSize = MAX_PATH*sizeof(TCHAR);

                    RegQueryValueEx(
                        hKeyProviders,
                        szProviderXxxN,
                        0,
                        &dwDataType,
                        (LPBYTE)szProviderFilename,
                        &dwDataSize
                        );

                    if (!(ptDlgInst->hTsp = LoadLibrary(szProviderFilename)))
                    {
                        LOG((TL_ERROR,
                            "LoadLibrary('%s') failed - err=%d",
                            szProviderFilename,
                            GetLastError()
                            ));

                        lResult = LINEERR_OPERATIONFAILED;
                        goto clean_up_dlg_inst;
                    }

                    if (!(pfnTSPI_providerUIIdentify = (TSPIPROC) GetProcAddress(
                            ptDlgInst->hTsp,
                            (LPCSTR) gaszTSPIFuncNames[SP_PROVIDERUIIDENTIFY]
                            )))
                    {
                        LOG((TL_ERROR,
                            "GetProcAddress(TSPI_providerUIIdentify) " \
                                "on [%s] failed, err=%d",
                            szProviderFilename,
                            GetLastError()
                            ));

                        lResult = LINEERR_OPERATIONUNAVAIL;
                        goto clean_up_dlg_inst;
                    }

                    ptDlgInst->pfnTSPI_providerGenericDialogData = (TSPIPROC)
                        GetProcAddress(
                            ptDlgInst->hTsp,
                            (LPCSTR) gaszTSPIFuncNames[SP_PROVIDERGENERICDIALOGDATA]
                            );

                    ptDlgInst->dwPermanentProviderID = pParams->dwObjectID;
                    ptDlgInst->bRemoveProvider = pParams->bRemoveProvider;
                    break;
                }
            }

            RegCloseKey (hKeyProviders);

            if (i == iNumProviders)
            {
				LOG((TL_ERROR, "Ran out of list..."));

                lResult = LINEERR_INVALPARAM;
            }
        }
        else
        {
            //
            // This is a providerInstall request.  Try to load the provider
            // and get ptrs to the relevant funcs,  then retrieve & increment
            // the next provider ID value in the ini file (careful to wrap
            // next PPID at 64K-1).
            //

            TCHAR   *pszProviderFilename;
            DWORD   dwNameLength;

            HKEY   hKeyProviders;
            DWORD  dwDataSize;
            DWORD  dwDataType;
            DWORD  dwTemp;


            //
            // Verify size/offset/string params given our input buffer/size
            //

            if (IsBadStringParam(
                    dwParamsBufferSize,
                    pDataBuf,
                    pParams->dwProviderFilenameOffset
                    ))
            {
                pParams->lResult = LINEERR_OPERATIONFAILED;
                DereferenceObject (ghHandleTable, ptDlgInst->htDlgInst, 1);
                return;
            }

            pszProviderFilename = (PTSTR)(pDataBuf + pParams->dwProviderFilenameOffset);

            if (!(ptDlgInst->hTsp = LoadLibrary(pszProviderFilename)))
            {
                LOG((TL_ERROR,
                    "LoadLibrary('%s') failed   err=%d",
                    pszProviderFilename,
                    GetLastError()
                    ));

                lResult = LINEERR_OPERATIONFAILED;

                // note: no matter if the XxxProvider call succeeds or fails,
                // we want this goto statement.
                // 16bit service providers are completely handled
                // in the XxxProvider call.
                goto clean_up_dlg_inst;
            }

            if (!(pfnTSPI_providerUIIdentify = (TSPIPROC) GetProcAddress(
                    ptDlgInst->hTsp,
                    (LPCSTR) gaszTSPIFuncNames[SP_PROVIDERUIIDENTIFY]
                    )))
            {
                lResult = LINEERR_OPERATIONUNAVAIL;
                goto clean_up_dlg_inst;
            }

            dwNameLength = (lstrlen(pszProviderFilename) + 1) * sizeof(TCHAR);

            if (!(ptDlgInst->pszProviderFilename = ServerAlloc (dwNameLength)))
            {
                lResult = LINEERR_NOMEM;
                goto clean_up_dlg_inst;
            }

            CopyMemory(
                ptDlgInst->pszProviderFilename,
                pszProviderFilename,
                dwNameLength
                );

            ptDlgInst->pfnTSPI_providerGenericDialogData = (TSPIPROC) GetProcAddress(
                ptDlgInst->hTsp,
                (LPCSTR) gaszTSPIFuncNames[SP_PROVIDERGENERICDIALOGDATA]
                );

            RegOpenKeyEx(
                HKEY_LOCAL_MACHINE,
                gszRegKeyProviders,
                0,
                KEY_ALL_ACCESS,
                &hKeyProviders
                );


            dwDataSize = sizeof (DWORD);
            ptDlgInst->dwPermanentProviderID = 1;

            RegQueryValueEx(
                hKeyProviders,
                gszNextProviderID,
                0,
                &dwDataType,
                (LPBYTE) &(ptDlgInst->dwPermanentProviderID),
                &dwDataSize
                );

            pParams->dwObjectID = ptDlgInst->dwPermanentProviderID;

            dwTemp = ((ptDlgInst->dwPermanentProviderID+1) & 0xffff0000) ?
                1 : (ptDlgInst->dwPermanentProviderID + 1);

            RegSetValueEx(
                hKeyProviders,
                gszNextProviderID,
                0,
                REG_DWORD,
                (LPBYTE) &dwTemp,
                sizeof(DWORD)
                );

            RegCloseKey (hKeyProviders);

        }

        break;
    }


    if (pfnTSPI_providerUIIdentify)
    {

        if (pLookupEntry && (lstrcmpi(
                                      pLookupEntry->ptProvider->szFileName,
                                      TEXT("remotesp.tsp")
                                     ) == 0)
           )
        {
            // ok - hack alert

            // a special case for remotesp to give it more info
            // we're passing the device ID and device type over to remotesp
            // so it can intelligently call over to the remote tapisrv
            // the RSP_MSG is just a key for remotesp to
            // check to make sure that the info is there
            LPDWORD     lpdwHold = (LPDWORD)pDataBuf;

            lpdwHold[0] = RSP_MSG;
            lpdwHold[1] = dwObjectID;
            lpdwHold[2] = pParams->dwObjectType;
        }

        if ((lResult = CallSP1(
                pfnTSPI_providerUIIdentify,
                "providerUIIdentify",
                SP_FUNC_SYNC,
                (ULONG_PTR) pDataBuf

                )) == 0)
        {
            pParams->dwUIDllNameOffset = 0;

            pParams->dwUIDllNameSize = (lstrlenW((PWSTR)pDataBuf) + 1)*sizeof(WCHAR);

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                pParams->dwUIDllNameSize;

            if (ptDlgInst)
            {
                ptDlgInst->dwKey = TDLGINST_KEY;

                if ((ptDlgInst->pNext =
                        ptClient->pProviderXxxDlgInsts))
                {
                    ptDlgInst->pNext->pPrev = ptDlgInst;
                }

                ptClient->pProviderXxxDlgInsts = ptDlgInst;

                pParams->htDlgInst = ptDlgInst->htDlgInst;
            }
        }
        else if (ptDlgInst)
        {

clean_up_dlg_inst:

            if (ptDlgInst->hTsp)
            {
                FreeLibrary (ptDlgInst->hTsp);
            }

            if (ptDlgInst->pszProviderFilename)
            {
                ServerFree (ptDlgInst->pszProviderFilename);
            }

            DereferenceObject (ghHandleTable, ptDlgInst->htDlgInst, 1);
        }
    }

GetUIDllName_return:

    pParams->lResult = lResult;

}


void
WINAPI
TUISPIDLLCallback(
    PTCLIENT                ptClient,
    PUIDLLCALLBACK_PARAMS   pParams,
    DWORD                   dwParamsBufferSize,
    LPBYTE                  pDataBuf,
    LPDWORD                 pdwNumBytesReturned
    )
{
    LONG        lResult;
    ULONG_PTR   objectID = pParams->ObjectID;
    TSPIPROC    pfnTSPI_providerGenericDialogData = NULL;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (ISBADSIZEOFFSET(
            dwParamsBufferSize,
            0,
            pParams->dwParamsInSize,
            pParams->dwParamsInOffset,
            sizeof(DWORD),
            "TUISPIDLLCallback",
            "pParams->ParamsIn"
            ))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    switch (pParams->dwObjectType)
    {
        case TUISPIDLL_OBJECT_LINEID:
        {
            PTLINELOOKUPENTRY   pLine;


    #if TELE_SERVER
            if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
                !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
            {
                if ((DWORD) pParams->ObjectID >= ptClient->dwLineDevices)
                {
                    pParams->lResult = LINEERR_OPERATIONFAILED;
                    return;
                }

                objectID = ptClient->pLineDevices[pParams->ObjectID];
            }
    #endif


            pLine = GetLineLookupEntry ((DWORD) objectID);


            if (!pLine)
            {
                lResult = LINEERR_INVALPARAM;
            }
            else if (!pLine->ptProvider)
            {
                lResult = LINEERR_OPERATIONFAILED;
            }
            else
            {
                pfnTSPI_providerGenericDialogData =
                    pLine->ptProvider->apfn[SP_PROVIDERGENERICDIALOGDATA];
            }

            break;
        }
        case TUISPIDLL_OBJECT_PHONEID:
        {
            PTPHONELOOKUPENTRY  pPhone;


    #if TELE_SERVER
            if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) &&
                !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
            {
                if ((DWORD) pParams->ObjectID >= ptClient->dwPhoneDevices)
                {
                    pParams->lResult = PHONEERR_OPERATIONFAILED;
                    return;
                }

                objectID = ptClient->pPhoneDevices[pParams->ObjectID];
            }
    #endif


            pPhone = GetPhoneLookupEntry ((DWORD) objectID);

            if (!pPhone)
            {
                lResult = LINEERR_INVALPARAM;
            }
            else if (!pPhone->ptProvider)
            {
                lResult = LINEERR_OPERATIONFAILED;
            }
            else
            {
                pfnTSPI_providerGenericDialogData =
                    pPhone->ptProvider->apfn[SP_PROVIDERGENERICDIALOGDATA];
            }

            break;
        }
        case TUISPIDLL_OBJECT_PROVIDERID:
        {
            PTAPIDIALOGINSTANCE ptDlgInst =
                                    ptClient->pProviderXxxDlgInsts;


            while (ptDlgInst)
            {
                if ((DWORD) pParams->ObjectID == ptDlgInst->dwPermanentProviderID)
                {
                    pfnTSPI_providerGenericDialogData =
                        ptDlgInst->pfnTSPI_providerGenericDialogData;

                    break;
                }

                ptDlgInst = ptDlgInst->pNext;
            }

            break;
        }
        case TUISPIDLL_OBJECT_DIALOGINSTANCE:
        {
         PTAPIDIALOGINSTANCE ptDlgInst;

            try
            {
                ptDlgInst = ReferenceObject (ghHandleTable, pParams->ObjectID, TDLGINST_KEY);
                if (NULL == ptDlgInst)
                {
                    pfnTSPI_providerGenericDialogData = NULL;
                    break;
                }

                objectID = (ULONG_PTR)ptDlgInst->hdDlgInst;

                pfnTSPI_providerGenericDialogData =
                    ptDlgInst->ptProvider->apfn[SP_PROVIDERGENERICDIALOGDATA];

                DereferenceObject (ghHandleTable, pParams->ObjectID, 1);

            }
            myexcept
            {
                // just fall thru
            }

            break;
        }

    }

    if (pfnTSPI_providerGenericDialogData)
    {
        if ((lResult = CallSP4(
                pfnTSPI_providerGenericDialogData,
                "providerGenericDialogData",
                SP_FUNC_SYNC,
                (ULONG_PTR) objectID,
                (DWORD)pParams->dwObjectType,
                (ULONG_PTR) (pDataBuf + pParams->dwParamsInOffset),
                (DWORD)pParams->dwParamsInSize

                )) == 0)
        {
            pParams->dwParamsOutOffset = pParams->dwParamsInOffset;
            pParams->dwParamsOutSize   = pParams->dwParamsInSize;

            *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
                                   pParams->dwParamsOutSize +
                                   pParams->dwParamsOutOffset;
        }
    }
    else
    {
        lResult = LINEERR_OPERATIONFAILED;
    }

    pParams->lResult = lResult;
}


void
WINAPI
FreeDialogInstance(
	PTCLIENT					ptClient,
    PFREEDIALOGINSTANCE_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    HKEY  hKeyProviders;
    DWORD dwDataSize;
    DWORD dwDataType;
    DWORD dwTemp;


    PTAPIDIALOGINSTANCE ptDlgInst = ReferenceObject (ghHandleTable, pParams->htDlgInst, TDLGINST_KEY);


    LOG((TL_TRACE,  "FreeDialogInstance: enter, pDlgInst=x%p", ptDlgInst));

    try
    {
        if (ptDlgInst->dwKey != TDLGINST_KEY)
        {
            pParams->lResult = LINEERR_OPERATIONFAILED;
        }
        else
        {
            ptDlgInst->dwKey = INVAL_KEY;
        }
    }
    myexcept
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
    }

    if (pParams->lResult)
    {
        return;
    }

    if (ptDlgInst->hTsp)
    {
        //
        // This dlg inst was a client doing a providerConfig, -Install, or
        // -Remove
        //

        if (ptDlgInst->pszProviderFilename)
        {
            if (pParams->lUIDllResult == 0)
            {
                //
                // Successful provider install
                //

                DWORD   iNumProviders;
                TCHAR   szProviderXxxN[32];
                TCHAR   szProviderXxxNA[32];

                WaitForSingleObject (ghProvRegistryMutex, INFINITE);

                if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    gszRegKeyProviders,
                    0,
                    KEY_ALL_ACCESS,
                    &hKeyProviders
                    ) != ERROR_SUCCESS)
                {
                    ReleaseMutex (ghProvRegistryMutex);
                    goto bail;
                }

                dwDataSize = sizeof(iNumProviders);
                iNumProviders = 0;


                RegQueryValueEx(
                    hKeyProviders,
                    gszNumProviders,
                    0,
                    &dwDataType,
                    (LPBYTE) &iNumProviders,
                    &dwDataSize
                    );

                wsprintf(
                    szProviderXxxNA,
                    TEXT("%s%d"),
                    gszProviderID,
                    iNumProviders
                    );

                RegSetValueEx(
                    hKeyProviders,
                    szProviderXxxNA,
                    0,
                    REG_DWORD,
                    (LPBYTE) &ptDlgInst->dwPermanentProviderID,
                    sizeof(DWORD)
                    );

                wsprintf(
                    szProviderXxxN,
                    TEXT("%s%d"),
                    gszProviderFilename,
                    iNumProviders
                    );

                RegSetValueEx(
                    hKeyProviders,
                    szProviderXxxN,
                    0,
                    REG_SZ,
                    (LPBYTE) ptDlgInst->pszProviderFilename,
                    (lstrlen((PTSTR)ptDlgInst->pszProviderFilename) + 1)*sizeof(TCHAR)
                    );

                iNumProviders++;

                RegSetValueEx(
                    hKeyProviders,
                    gszNumProviders,
                    0,
                    REG_DWORD,
                    (LPBYTE) &iNumProviders,
                    sizeof(DWORD)
                    );

                RegCloseKey( hKeyProviders );

                ReleaseMutex (ghProvRegistryMutex);

                //
                //  If the tapisrv is already INITed, ReInit it to load the provider
                //
                TapiEnterCriticalSection (&TapiGlobals.CritSec);

                if ((TapiGlobals.dwNumLineInits != 0) ||
                    (TapiGlobals.dwNumPhoneInits != 0) ||
                    (TapiGlobals.dwFlags & TAPIGLOBALS_SERVER))
                {

                    pParams->lResult = ServerInit(TRUE);
                }

                TapiLeaveCriticalSection (&TapiGlobals.CritSec);
            }
            else
            {
                //
                // Unsuccessful provider install.  See if we can decrement
                // NextProviderID to free up the unused ID.
                //

                DWORD   iNextProviderID;
                
                WaitForSingleObject (ghProvRegistryMutex, INFINITE);

                if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    gszRegKeyProviders,
                    0,
                    KEY_ALL_ACCESS,
                    &hKeyProviders
                    ) != ERROR_SUCCESS)
                {
                    ReleaseMutex (ghProvRegistryMutex);
                    goto bail;
                }

                dwDataSize = sizeof(iNextProviderID);
                iNextProviderID = 0;

                RegQueryValueEx(
                    hKeyProviders,
                    gszNextProviderID,
                    0,
                    &dwDataType,
                    (LPBYTE)&iNextProviderID,
                    &dwDataSize
                    );

                if ((ptDlgInst->dwPermanentProviderID + 1) == iNextProviderID)
                {
                    RegSetValueEx(
                        hKeyProviders,
                        gszNextProviderID,
                        0,
                        REG_DWORD,
                        (LPBYTE) &(ptDlgInst->dwPermanentProviderID),
                        sizeof(DWORD)
                        );
                }


                RegCloseKey (hKeyProviders);

                ReleaseMutex (ghProvRegistryMutex);
            }

            ServerFree (ptDlgInst->pszProviderFilename);
        }
        else if (ptDlgInst->bRemoveProvider)
        {
            if (pParams->lUIDllResult == 0)
            {
                //
                // Successful provider remove.  Find the index of the
                // provider in the list, then move all the providers
                // that follow up a notch.
                //

                DWORD  iNumProviders, i;
                TCHAR  szProviderXxxN[32];
                TCHAR  buf[MAX_PATH];

                WaitForSingleObject (ghProvRegistryMutex, INFINITE);

                if (RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    gszRegKeyProviders,
                    0,
                    KEY_ALL_ACCESS,
                    &hKeyProviders
                    ) != ERROR_SUCCESS)
                {
                    ReleaseMutex (ghProvRegistryMutex);
                    goto bail;
                }


                dwDataSize = sizeof(iNumProviders);
                iNumProviders = 0;

                RegQueryValueEx(
                    hKeyProviders,
                    gszNumProviders,
                    0,
                    &dwDataType,
                    (LPBYTE) &iNumProviders,
                    &dwDataSize
                    );

                for (i = 0; i < iNumProviders; i++)
                {
                    wsprintf(szProviderXxxN, TEXT("%s%d"), gszProviderID, i);

                    dwDataSize = sizeof(dwTemp);
                    dwTemp = 0;
                    RegQueryValueEx(
                        hKeyProviders,
                        szProviderXxxN,
                        0,
                        &dwDataType,
                        (LPBYTE) &dwTemp,
                        &dwDataSize
                        );

                    if (dwTemp == ptDlgInst->dwPermanentProviderID)
                    {
                        break;
                    }
                }

                for (; i < (iNumProviders - 1); i++)
                {
                    wsprintf(szProviderXxxN, TEXT("%s%d"), gszProviderID, i + 1);

                    dwDataSize = sizeof(buf);

                    RegQueryValueEx(
                        hKeyProviders,
                        szProviderXxxN,
                        0,
                        &dwDataType,
                        (LPBYTE) buf,
                        &dwDataSize
                        );

                    buf[dwDataSize/sizeof(TCHAR)] = TEXT('\0');

                    wsprintf(szProviderXxxN, TEXT("%s%d"), gszProviderID, i);

                    RegSetValueEx(
                        hKeyProviders,
                        szProviderXxxN,
                        0,
                        REG_DWORD,
                        (LPBYTE) buf,
                        sizeof (DWORD)
                        );

                    wsprintf(szProviderXxxN, TEXT("%s%d"), gszProviderFilename, i+1);

                    dwDataSize = MAX_PATH*sizeof(TCHAR);

                    RegQueryValueEx(
                        hKeyProviders,
                        szProviderXxxN,
                        0,
                        &dwDataType,
                        (LPBYTE) buf,
                        &dwDataSize
                        );

                    buf[dwDataSize/sizeof(TCHAR)] = TEXT('\0');

                    wsprintf(szProviderXxxN, TEXT("%s%d"), gszProviderFilename, i);

                    RegSetValueEx(
                        hKeyProviders,
                        szProviderXxxN,
                        0,
                        REG_SZ,
                        (LPBYTE) buf,
                        (lstrlen(buf) + 1) * sizeof(TCHAR)
                        );
                }


                //
                // Remove the last ProviderID# & ProviderFilename# entries
                //

                wsprintf(szProviderXxxN, TEXT("%s%d"), gszProviderID, i);

                RegDeleteValue(hKeyProviders, szProviderXxxN);

                wsprintf(szProviderXxxN, TEXT("%s%d"), gszProviderFilename, i);

                RegDeleteValue(hKeyProviders, szProviderXxxN);


                //
                // Decrement the total num providers to load
                //

                iNumProviders--;

                RegSetValueEx(
                    hKeyProviders,
                    gszNumProviders,
                    0,
                    REG_DWORD,
                    (LPBYTE)&iNumProviders,
                    sizeof(DWORD)
                    );

                RegCloseKey (hKeyProviders);

                ReleaseMutex (ghProvRegistryMutex);
                
                //
                //  Remove user/line association with this provider
                //
                
                {
                    WCHAR *         pSectionNames = NULL;
                    WCHAR *         pSectionNames2 = NULL;
                    WCHAR *         pszLinePhoneSave = NULL;
                    DWORD           dwSize, dwSize2;
                    DWORD           dwResult;
                    WCHAR           szBuf[20];
                    WCHAR * aszKeys[] = {gszLines, gszPhones};

                    //  Only NT server cares about tsec.ini
                    if (!gbNTServer)
                    {
                        goto Exit;
                    }

                    //  Get the list of DomainUser names
                    LOG((TL_INFO, "FreeDialogInstance: getting user names"));

                    do
                    {
                        if  (pSectionNames)
                        {
                            ServerFree (pSectionNames);

                            dwSize *= 2;
                        }
                        else
                        {
                            dwSize = 256;
                        }

                        if (!(pSectionNames = 
                                    ServerAlloc (dwSize * sizeof (WCHAR))))
                        {
                            goto Exit;
                        }

                        pSectionNames[0] = L'\0';

                        dwResult = GetPrivateProfileSectionNamesW(
                            pSectionNames,
                            dwSize,
                            gszFileName
                            );

                    } while (dwResult >= (dwSize - 2));


                    pSectionNames2 = pSectionNames;
                    dwSize = 64 * sizeof(WCHAR);
                    pszLinePhoneSave = ServerAlloc(dwSize);
                    if (pszLinePhoneSave == NULL)
                    {
                        LOG((TL_ERROR,
                                "FreeDialogInstance: Memory failure"));
                        goto Exit;
                    }
                    dwSize2 = wsprintfW (szBuf, L"%d", 
                                ptDlgInst->dwPermanentProviderID);
                    
                    //  Remove all the devices associated with this domain/user
                    while (*pSectionNames)
                    {
                        WCHAR   *psz, *psz2;
                        BOOL    bWriteBack;
                        int     iasz;

                        for (iasz = 0; 
                            iasz < sizeof(aszKeys) / sizeof(WCHAR *); ++iasz)
                        {
                            bWriteBack = FALSE;
                            dwResult = MyGetPrivateProfileString(
                                        pSectionNames,
                                        aszKeys[iasz],
                                        gszEmptyString,
                                        &pszLinePhoneSave,
                                        &dwSize);
                            if (dwResult == 0)
                            {
                                psz = pszLinePhoneSave;
                                while (*psz)
                                {
                                    if (wcsncmp(psz, szBuf, dwSize2) == 0)
                                    {
                                        bWriteBack = TRUE;
                                        psz2 = psz + dwSize2;
                                        if (*psz2 != L',') // Comma?
                                        {
                                            LOG((TL_ERROR, 
                                                "FreeDialogInstance: "
                                                "Corrupted tsec.ini"));
                                            goto Exit;
                                        }
                                        ++ psz2;    //  Skip comma
                                        //  Skip the permanent device ID
                                        while ((*psz2 != L',') && (*psz2 != 0))
                                        {
                                            ++psz2;
                                        }
                                        if (*psz2 == 0) // Last one
                                        {
                                            if (psz > pszLinePhoneSave)
                                                *(psz - 1) = 0;
                                            else
                                                *pszLinePhoneSave = 0;
                                            break;
                                        }
                                        else
                                        {
                                            int i = 0;
                                            ++psz2; // skip the comma
                                            while (*psz2)
                                            {
                                                psz[i++] = *psz2;
                                                ++psz2;
                                            }
                                            psz[i] = 0;
                                        }
                                    }
                                    else
                                    {
                                        //  Skip the provider ID
                                        while ((*psz != 0) && (*psz != L','))
                                        {
                                            ++ psz;
                                        }
                                        if (*psz == 0)
                                            break;
                                        ++ psz;
                                        //  Skip the permanent device ID
                                        while ((*psz != 0) && (*psz != L','))
                                        {
                                            ++ psz;
                                        }
                                        if (*psz == 0)
                                            break;
                                        ++ psz;
                                    }   
                                }
                            
                                if (bWriteBack)
                                {
                                    WritePrivateProfileStringW(
                                        pSectionNames,
                                        aszKeys[iasz],
                                        pszLinePhoneSave,
                                        gszFileName
                                        );
                                }
                            }   // dwResult == 0
                        }
                        
                        //  Advance to the next domain user
                        while (*pSectionNames != 0)
                        {
                            ++pSectionNames;
                        }
                        ++pSectionNames;
                    }

Exit:
                    ServerFree(pSectionNames2);
                    ServerFree(pszLinePhoneSave);
                }

                //
                // if tapi init'd shutdown each provider
                //
                {
                    PTLINELOOKUPENTRY       pLineEntry;
                    PTPHONELOOKUPENTRY      pPhoneEntry;
                    DWORD                   dw;
                    PTPROVIDER              ptProvider;
                    PPERMANENTIDARRAYHEADER pIDArray, *ppLastArray;
                    PTPROVIDER              *pptProvider;

                    //
                    // LINE_REMOVE / PHONE_REMOVE will try to enter gMgmtCritSec while in
                    // TapiGlobals.CritSec.
                    // Need to enter gMgmtCritSec here, to avoid deadlock
                    //
                    EnterCriticalSection (&gMgmtCritSec);

                    TapiEnterCriticalSection (&TapiGlobals.CritSec);
                    
                    //
                    //  Find ptProvider
                    //
                    ptProvider = TapiGlobals.ptProviders;
                    while (ptProvider)
                    {
                        if (ptProvider->dwPermanentProviderID == 
                            ptDlgInst->dwPermanentProviderID)
                        {
                            break;
                        }
                        ptProvider = ptProvider->pNext;
                    }
                    if (ptProvider == NULL)
                    {
                        LeaveCriticalSection (&gMgmtCritSec);
                        TapiLeaveCriticalSection (&TapiGlobals.CritSec);
                        goto bail;
                    }
                
                    //
                    //  Remove all the lines/phones belong to this provider.
                    //
                    
                    for (dw = 0; dw < TapiGlobals.dwNumLines; ++dw)
                    {
                        pLineEntry = GetLineLookupEntry (dw);
                        if (pLineEntry && 
                            pLineEntry->ptProvider == ptProvider && 
                            !pLineEntry->bRemoved)
                        {
                            LineEventProc (
                                0,
                                0,
                                LINE_REMOVE,
                                dw,
                                0,
                                0
                                );
                        }
                    }

                    for (dw = 0; dw < TapiGlobals.dwNumPhones; ++dw)
                    {
                        pPhoneEntry = GetPhoneLookupEntry (dw);
                        if (pPhoneEntry &&
                            pPhoneEntry->ptProvider == ptProvider &&
                            !pPhoneEntry->bRemoved)
                        {
                            PhoneEventProc (
                                0,
                                PHONE_REMOVE,
                                dw,
                                0,
                                0
                                );
                        }
                    }

                    LeaveCriticalSection (&gMgmtCritSec);

                    //
                    //  Remove the provider ID array associate with this provider
                    //
                    ppLastArray = &(TapiGlobals.pIDArrays);
                    while ((*ppLastArray) != NULL && 
                        ((*ppLastArray)->dwPermanentProviderID != 
                            ptProvider->dwPermanentProviderID)
                        )
                    {
                        ppLastArray = &((*ppLastArray)->pNext);
                    }
                    if (pIDArray = (*ppLastArray))
                    {
                        *ppLastArray = pIDArray->pNext;
                        ServerFree (pIDArray->pLineElements);
                        ServerFree (pIDArray->pPhoneElements);
                        ServerFree (pIDArray);
                    }
                    else
                    {
                        //  Should not be here
                    }

                    //
                    //  Remove ptProvider from the global link list
                    //
                    if (ptProvider->pNext)
                    {
                        ptProvider->pNext->pPrev = ptProvider->pPrev;
                    }
                    if (ptProvider->pPrev)
                    {
                        ptProvider->pPrev->pNext = ptProvider->pNext;
                    }
                    else
                    {
                        TapiGlobals.ptProviders = ptProvider->pNext;
                    }

                    //
                    //  Now shutdown and unload the TSP provider
                    //
                    CallSP2(
                        ptProvider->apfn[SP_PROVIDERSHUTDOWN],
                        "providerShutdown",
                        SP_FUNC_SYNC,
                        (DWORD)ptProvider->dwSPIVersion,
                        (DWORD)ptProvider->dwPermanentProviderID
                        );

                    //  Wait for 5 seconds for ongoing calls to finish
                    Sleep (5000);
                    
                    FreeLibrary (ptProvider->hDll);
                    MyCloseMutex (ptProvider->hMutex);
                    CloseHandle (ptProvider->hHashTableReaderEvent);
                    DeleteCriticalSection (&ptProvider->HashTableCritSec);
                    ServerFree (ptProvider->pHashTable);
                    ServerFree (ptProvider);

                    TapiLeaveCriticalSection (&TapiGlobals.CritSec);

                }
            }
            else
            {
                //
                // Unsuccessful provider remove, nothing to do
                //
            }
        }
        else
        {
            //
            // Nothing to do for providerConfig (success or fail)
            //
        }

bail:
        FreeLibrary (ptDlgInst->hTsp);

        pParams->lResult = pParams->lUIDllResult;
    }
    else if (ptDlgInst->ptProvider->apfn[SP_PROVIDERFREEDIALOGINSTANCE])
    {
        //
        // The was a provider-initiated dlg inst, so tell
        // the provider to free it's inst
        //

        CallSP1(
            ptDlgInst->ptProvider->apfn[SP_PROVIDERFREEDIALOGINSTANCE],
            "providerFreeDialogInstance",
            SP_FUNC_SYNC,
            (ULONG_PTR) ptDlgInst->hdDlgInst
            );

    }


    //
    // Remove the dialog instance from the tClient's list & then free it
    //

    if (WaitForExclusiveClientAccess (ptClient))
    {
        if (ptDlgInst->pNext)
        {
            ptDlgInst->pNext->pPrev = ptDlgInst->pPrev;
        }

        if (ptDlgInst->pPrev)
        {
            ptDlgInst->pPrev->pNext = ptDlgInst->pNext;
        }
        else if (ptDlgInst->hTsp)
        {
            ptClient->pProviderXxxDlgInsts = ptDlgInst->pNext;
        }
        else
        {
            ptClient->pGenericDlgInsts = ptDlgInst->pNext;
        }
        UNLOCKTCLIENT (ptClient);
    }

    DereferenceObject (ghHandleTable, pParams->htDlgInst, 2);
}



BOOL
GetNewClientHandle(
    PTCLIENT            ptClient,
    PTMANAGEDLLINFO     pDll,
    HMANAGEMENTCLIENT   *phClient
    )
{
    BOOL            fResult = TRUE;
    PTCLIENTHANDLE  pClientHandle, pNewClientHandle;


    if (!(pNewClientHandle = ServerAlloc (sizeof (TCLIENTHANDLE))))
    {
        return FALSE;
    }

    pNewClientHandle->pNext = NULL;
    pNewClientHandle->fValid = TRUE;
    pNewClientHandle->dwID = pDll->dwID;

    // call init
    if ((pDll->aProcs[TC_CLIENTINITIALIZE])(
            ptClient->pszDomainName,
            ptClient->pszUserName,
            ptClient->pszComputerName,
            &pNewClientHandle->hClient
            ))
    {
        // error - zero out the handle
        pNewClientHandle->hClient = (HMANAGEMENTCLIENT) NULL;
        pNewClientHandle->fValid = FALSE;
        fResult = FALSE;
    }

    // save it no matter what
    // insert at beginning of list

    pClientHandle = ptClient->pClientHandles;

    ptClient->pClientHandles = pNewClientHandle;

    pNewClientHandle->pNext = pClientHandle;

    *phClient = pNewClientHandle->hClient;

    return fResult;
}


BOOL
GetTCClient(
    PTMANAGEDLLINFO       pDll,
    PTCLIENT              ptClient,
    DWORD                 dwAPI,
    HMANAGEMENTCLIENT    *phClient
    )
{

    PTCLIENTHANDLE          pClientHandle;
    BOOL                    bResult;


    if (!pDll->aProcs[dwAPI])
    {
        return FALSE;
    }

    pClientHandle = ptClient->pClientHandles;

    while (pClientHandle)
    {
        if (pClientHandle->dwID == pDll->dwID)
        {
            break;
        }

        pClientHandle = pClientHandle->pNext;
    }

    if (pClientHandle)
    {
        if (!(pClientHandle->fValid))
        {
            return FALSE;
        }

        *phClient = pClientHandle->hClient;
        return TRUE;
    }
    else
    {
        // OK - it's not in the list.
        // get the critical section & check again
        EnterCriticalSection(&gClientHandleCritSec);

        pClientHandle = ptClient->pClientHandles;

        while (pClientHandle)
        {
            if (pClientHandle->dwID == pDll->dwID)
            {
                break;
            }

            pClientHandle = pClientHandle->pNext;
        }

        if (pClientHandle)
        {
            if (!(pClientHandle->fValid))
            {
                LeaveCriticalSection(&gClientHandleCritSec);
                return FALSE;
            }

            *phClient = pClientHandle->hClient;

            LeaveCriticalSection(&gClientHandleCritSec);
            return TRUE;
        }


        // still not there.  add it...
        bResult = GetNewClientHandle(
                                     ptClient,
                                     pDll,
                                     phClient
                                    );

        LeaveCriticalSection(&gClientHandleCritSec);

        return bResult;
    }

}


//#pragma warning (default:4028)



#if DBG

char szBeforeSync[] = "Calling TSPI_%s";
char szBeforeAsync[] = "Calling TSPI_%s, dwReqID=x%x";
char szAfter[]  = "TSPI_%s result=%s";

VOID
DbgPrt(
    IN DWORD  dwDbgLevel,
    IN PUCHAR lpszFormat,
    IN ...
    )
/*++

Routine Description:

    Formats the incoming debug message & calls DbgPrint

Arguments:

    DbgLevel   - level of message verboseness

    DbgMessage - printf-style format string, followed by appropriate
                 list of arguments

Return Value:


--*/
{
    if (dwDbgLevel <= gdwDebugLevel)
    {
        char    buf[1024] = "TAPISRV (0x--------): ";
        va_list ap;

        wsprintfA( &buf[11], "%08lx", GetCurrentThreadId() );
        buf[19] = ')';

        va_start(ap, lpszFormat);

        wvsprintfA(
            &buf[22],
            lpszFormat,
            ap
            );

        lstrcatA(buf, "\n");

        OutputDebugStringA (buf);

        va_end(ap);
    }

    return;
}

char *aszLineErrors[] =
{
    NULL,
    "ALLOCATED",
    "BADDEVICEID",
    "BEARERMODEUNAVAIL",
    "inval err value (0x80000004)",      // 0x80000004 isn't valid err code
    "CALLUNAVAIL",
    "COMPLETIONOVERRUN",
    "CONFERENCEFULL",
    "DIALBILLING",
    "DIALDIALTONE",
    "DIALPROMPT",
    "DIALQUIET",
    "INCOMPATIBLEAPIVERSION",
    "INCOMPATIBLEEXTVERSION",
    "INIFILECORRUPT",
    "INUSE",
    "INVALADDRESS",                     // 0x80000010
    "INVALADDRESSID",
    "INVALADDRESSMODE",
    "INVALADDRESSSTATE",
    "INVALAPPHANDLE",
    "INVALAPPNAME",
    "INVALBEARERMODE",
    "INVALCALLCOMPLMODE",
    "INVALCALLHANDLE",
    "INVALCALLPARAMS",
    "INVALCALLPRIVILEGE",
    "INVALCALLSELECT",
    "INVALCALLSTATE",
    "INVALCALLSTATELIST",
    "INVALCARD",
    "INVALCOMPLETIONID",
    "INVALCONFCALLHANDLE",              // 0x80000020
    "INVALCONSULTCALLHANDLE",
    "INVALCOUNTRYCODE",
    "INVALDEVICECLASS",
    "INVALDEVICEHANDLE",
    "INVALDIALPARAMS",
    "INVALDIGITLIST",
    "INVALDIGITMODE",
    "INVALDIGITS",
    "INVALEXTVERSION",
    "INVALGROUPID",
    "INVALLINEHANDLE",
    "INVALLINESTATE",
    "INVALLOCATION",
    "INVALMEDIALIST",
    "INVALMEDIAMODE",
    "INVALMESSAGEID",                   // 0x80000030
    "inval err value (0x80000031)",      // 0x80000031 isn't valid err code
    "INVALPARAM",
    "INVALPARKID",
    "INVALPARKMODE",
    "INVALPOINTER",
    "INVALPRIVSELECT",
    "INVALRATE",
    "INVALREQUESTMODE",
    "INVALTERMINALID",
    "INVALTERMINALMODE",
    "INVALTIMEOUT",
    "INVALTONE",
    "INVALTONELIST",
    "INVALTONEMODE",
    "INVALTRANSFERMODE",
    "LINEMAPPERFAILED",                 // 0x80000040
    "NOCONFERENCE",
    "NODEVICE",
    "NODRIVER",
    "NOMEM",
    "NOREQUEST",
    "NOTOWNER",
    "NOTREGISTERED",
    "OPERATIONFAILED",
    "OPERATIONUNAVAIL",
    "RATEUNAVAIL",
    "RESOURCEUNAVAIL",
    "REQUESTOVERRUN",
    "STRUCTURETOOSMALL",
    "TARGETNOTFOUND",
    "TARGETSELF",
    "UNINITIALIZED",                    // 0x80000050
    "USERUSERINFOTOOBIG",
    "REINIT",
    "ADDRESSBLOCKED",
    "BILLINGREJECTED",
    "INVALFEATURE",
    "NOMULTIPLEINSTANCE",
    "INVALAGENTID",
    "INVALAGENTGROUP",
    "INVALPASSWORD",
    "INVALAGENTSTATE",
    "INVALAGENTACTIVITY",
    "DIALVOICEDETECT"
};

char *aszPhoneErrors[] =
{
    "SUCCESS",
    "ALLOCATED",
    "BADDEVICEID",
    "INCOMPATIBLEAPIVERSION",
    "INCOMPATIBLEEXTVERSION",
    "INIFILECORRUPT",
    "INUSE",
    "INVALAPPHANDLE",
    "INVALAPPNAME",
    "INVALBUTTONLAMPID",
    "INVALBUTTONMODE",
    "INVALBUTTONSTATE",
    "INVALDATAID",
    "INVALDEVICECLASS",
    "INVALEXTVERSION",
    "INVALHOOKSWITCHDEV",
    "INVALHOOKSWITCHMODE",              // 0x90000010
    "INVALLAMPMODE",
    "INVALPARAM",
    "INVALPHONEHANDLE",
    "INVALPHONESTATE",
    "INVALPOINTER",
    "INVALPRIVILEGE",
    "INVALRINGMODE",
    "NODEVICE",
    "NODRIVER",
    "NOMEM",
    "NOTOWNER",
    "OPERATIONFAILED",
    "OPERATIONUNAVAIL",
    "inval err value (0x9000001e)",      // 0x9000001e isn't valid err code
    "RESOURCEUNAVAIL",
    "REQUESTOVERRUN",                   // 0x90000020
    "STRUCTURETOOSMALL",
    "UNINITIALIZED",
    "REINIT"
};

char *aszTapiErrors[] =
{
    "SUCCESS",
    "DROPPED",
    "NOREQUESTRECIPIENT",
    "REQUESTQUEUEFULL",
    "INVALDESTADDRESS",
    "INVALWINDOWHANDLE",
    "INVALDEVICECLASS",
    "INVALDEVICEID",
    "DEVICECLASSUNAVAIL",
    "DEVICEIDUNAVAIL",
    "DEVICEINUSE",
    "DESTBUSY",
    "DESTNOANSWER",
    "DESTUNAVAIL",
    "UNKNOWNWINHANDLE",
    "UNKNOWNREQUESTID",
    "REQUESTFAILED",
    "REQUESTCANCELLED",
    "INVALPOINTER"
};


char *
PASCAL
MapResultCodeToText(
    LONG    lResult,
    char   *pszResult
    )
{
    if (lResult == 0)
    {
        wsprintfA (pszResult, "SUCCESS");
    }
    else if (lResult > 0)
    {
        wsprintfA (pszResult, "x%x (completing async)", lResult);
    }
    else if (((DWORD) lResult) <= LINEERR_DIALVOICEDETECT)
    {
        lResult &= 0x0fffffff;

        wsprintfA (pszResult, "LINEERR_%s", aszLineErrors[lResult]);
    }
    else if (((DWORD) lResult) <= PHONEERR_REINIT)
    {
        if (((DWORD) lResult) >= PHONEERR_ALLOCATED)
        {
            lResult &= 0x0fffffff;

            wsprintfA (pszResult, "PHONEERR_%s", aszPhoneErrors[lResult]);
        }
        else
        {
            goto MapResultCodeToText_badErrorCode;
        }
    }
    else if (((DWORD) lResult) <= ((DWORD) TAPIERR_DROPPED) &&
             ((DWORD) lResult) >= ((DWORD) TAPIERR_INVALPOINTER))
    {
        lResult = ~lResult + 1;

        wsprintfA (pszResult, "TAPIERR_%s", aszTapiErrors[lResult]);
    }
    else
    {

MapResultCodeToText_badErrorCode:

        wsprintfA (pszResult, "inval error value (x%x)");
    }

    return pszResult;
}

VOID
PASCAL
ValidateSyncSPResult(
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    LONG        lResult
    )
{
    char szResult[32];

    LOG((TL_INFO,
        szAfter,
        lpszFuncName,
        MapResultCodeToText (lResult, szResult)
        ));

    if (dwFlags & SP_FUNC_ASYNC)
    {
        assert (lResult != 0);

        if (lResult > 0)
        {
            assert (lResult == PtrToLong (Arg1) ||
                PtrToLong (Arg1) == 0xfeeefeee ||   // pAsyncRequestInfo freed
                PtrToLong (Arg1) == 0xa1a1a1a1);
        }
    }
    else
    {
        assert (lResult <= 0);
    }

}

LONG
WINAPI
CallSP1(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1
    )
{
    LONG    lResult;


    LOG((TL_INFO, szBeforeSync, lpszFuncName));

    lResult = (*pfn)(Arg1);

    ValidateSyncSPResult (lpszFuncName, dwFlags, Arg1, lResult);

    return lResult;
}


LONG
WINAPI
CallSP2(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2
    )
{
    LONG    lResult;


    if (dwFlags & SP_FUNC_ASYNC)
    {
        LOG((TL_INFO, szBeforeAsync, lpszFuncName, Arg1));
    }
    else
    {
        LOG((TL_INFO, szBeforeSync, lpszFuncName));
    }

    lResult = (*pfn)(Arg1, Arg2);

    ValidateSyncSPResult (lpszFuncName, dwFlags, Arg1, lResult);

    return lResult;
}


LONG
WINAPI
CallSP3(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3
    )
{
    LONG    lResult;


    if (dwFlags & SP_FUNC_ASYNC)
    {
        LOG((TL_INFO, szBeforeAsync, lpszFuncName, Arg1));
    }
    else
    {
        LOG((TL_INFO, szBeforeSync, lpszFuncName));
    }

    lResult = (*pfn)(Arg1, Arg2, Arg3);

    ValidateSyncSPResult (lpszFuncName, dwFlags, Arg1, lResult);

    return lResult;
}


LONG
WINAPI
CallSP4(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4
    )
{
    LONG    lResult;


    if (dwFlags & SP_FUNC_ASYNC)
    {
        LOG((TL_INFO, szBeforeAsync, lpszFuncName, Arg1));
    }
    else
    {
        LOG((TL_INFO, szBeforeSync, lpszFuncName));
    }

    lResult = (*pfn)(Arg1, Arg2, Arg3, Arg4);

    ValidateSyncSPResult (lpszFuncName, dwFlags, Arg1, lResult);

    return lResult;
}


LONG
WINAPI
CallSP5(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4,
    ULONG_PTR   Arg5
    )
{
    LONG    lResult;


    if (dwFlags & SP_FUNC_ASYNC)
    {
        LOG((TL_INFO, szBeforeAsync, lpszFuncName, Arg1));
    }
    else
    {
        LOG((TL_INFO, szBeforeSync, lpszFuncName));
    }

    lResult = (*pfn)(Arg1, Arg2, Arg3, Arg4, Arg5);

    ValidateSyncSPResult (lpszFuncName, dwFlags, Arg1, lResult);

    return lResult;
}


LONG
WINAPI
CallSP6(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4,
    ULONG_PTR   Arg5,
    ULONG_PTR   Arg6
    )
{
    LONG    lResult;


    if (dwFlags & SP_FUNC_ASYNC)
    {
        LOG((TL_INFO, szBeforeAsync, lpszFuncName, Arg1));
    }
    else
    {
        LOG((TL_INFO, szBeforeSync, lpszFuncName));
    }

    lResult = (*pfn)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6);

    ValidateSyncSPResult (lpszFuncName, dwFlags, Arg1, lResult);

    return lResult;
}


LONG
WINAPI
CallSP7(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4,
    ULONG_PTR   Arg5,
    ULONG_PTR   Arg6,
    ULONG_PTR   Arg7
    )
{
    LONG    lResult;


    if (dwFlags & SP_FUNC_ASYNC)
    {
        LOG((TL_INFO, szBeforeAsync, lpszFuncName, Arg1));
    }
    else
    {
        LOG((TL_INFO, szBeforeSync, lpszFuncName));
    }

    lResult = (*pfn)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7);

    ValidateSyncSPResult (lpszFuncName, dwFlags, Arg1, lResult);

    return lResult;
}


LONG
WINAPI
CallSP8(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4,
    ULONG_PTR   Arg5,
    ULONG_PTR   Arg6,
    ULONG_PTR   Arg7,
    ULONG_PTR   Arg8
    )
{
    LONG    lResult;


    if (dwFlags & SP_FUNC_ASYNC)
    {
        LOG((TL_INFO, szBeforeAsync, lpszFuncName, Arg1));
    }
    else
    {
        LOG((TL_INFO, szBeforeSync, lpszFuncName));
    }

    lResult = (*pfn)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8);

    ValidateSyncSPResult (lpszFuncName, dwFlags, Arg1, lResult);

    return lResult;
}


LONG
WINAPI
CallSP9(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4,
    ULONG_PTR   Arg5,
    ULONG_PTR   Arg6,
    ULONG_PTR   Arg7,
    ULONG_PTR   Arg8,
    ULONG_PTR   Arg9
    )
{
    LONG    lResult;


    if (dwFlags & SP_FUNC_ASYNC)
    {
        LOG((TL_INFO, szBeforeAsync, lpszFuncName, Arg1));
    }
    else
    {
        LOG((TL_INFO, szBeforeSync, lpszFuncName));
    }

    lResult = (*pfn)(Arg1, Arg2, Arg3, Arg4, Arg5, Arg6, Arg7, Arg8, Arg9);

    ValidateSyncSPResult (lpszFuncName, dwFlags, Arg1, lResult);

    return lResult;
}

LONG
WINAPI
CallSP12(
    TSPIPROC    pfn,
    LPCSTR      lpszFuncName,
    DWORD       dwFlags,
    ULONG_PTR   Arg1,
    ULONG_PTR   Arg2,
    ULONG_PTR   Arg3,
    ULONG_PTR   Arg4,
    ULONG_PTR   Arg5,
    ULONG_PTR   Arg6,
    ULONG_PTR   Arg7,
    ULONG_PTR   Arg8,
    ULONG_PTR   Arg9,
    ULONG_PTR   Arg10,
    ULONG_PTR   Arg11,
    ULONG_PTR   Arg12
    )
{
    LONG    lResult;


    if (dwFlags & SP_FUNC_ASYNC)
    {
        LOG((TL_INFO, szBeforeAsync, lpszFuncName, Arg1));
    }
    else
    {
        LOG((TL_INFO, szBeforeSync, lpszFuncName));
    }

    lResult = (*pfn)(
        Arg1,
        Arg2,
        Arg3,
        Arg4,
        Arg5,
        Arg6,
        Arg7,
        Arg8,
        Arg9,
        Arg10,
        Arg11,
        Arg12
        );

    ValidateSyncSPResult (lpszFuncName, dwFlags, Arg1, lResult);

    return lResult;
}


#endif // DBG

/*************************************************************************\
* BOOL InitPerf()
*
*   Initialize global performance data
*
\**************************************************************************/

BOOL InitPerf()
{
    FillMemory(&PerfBlock,
               sizeof(PerfBlock),
               0);

    return(TRUE);
}

BOOL VerifyDomainName (HKEY hKey)
{

#define MAX_DNS_NAME_LENGTH 255

    DWORD   dwType;
    DWORD   dwSize;
    BOOL    bReturn = TRUE;
    LPTSTR  pOldName = NULL;
    LPTSTR  pNewName = NULL;

    do {

        //
        // Get the old domain name from registry
        //
        dwSize = 0;
        if (ERROR_SUCCESS == RegQueryValueEx( 
                            hKey, 
                            gszDomainName, 
                            NULL, 
                            &dwType, 
                            NULL, 
                            &dwSize)
            )
        {

            pOldName = ServerAlloc (dwSize);
            if(!pOldName)
            {
                bReturn = FALSE;
                break;
            }
    
            if (ERROR_SUCCESS != RegQueryValueEx( 
                                hKey, 
                                gszDomainName, 
                                NULL, 
                                &dwType, 
                                (LPBYTE)pOldName, 
                                &dwSize)
                )
            {
                bReturn = FALSE;
                break;
            }
        }
        
        //
        // Get the current domain name
        //
        dwSize = MAX_DNS_NAME_LENGTH + 1;
        pNewName = ServerAlloc ( dwSize * sizeof (TCHAR));
        if (!pNewName)
        {
            bReturn = FALSE;
            break;
        }

        if (!GetComputerNameEx (ComputerNameDnsDomain, pNewName, &dwSize))
        {
            bReturn = FALSE;
            LOG((TL_INFO, "VerifyDomainName: GetComputerNameEx failed - error x%x", GetLastError()));
            break;
        }

        if (dwSize == 0)
        {
            // no domain name, save as empty string
            pNewName [0] = TEXT('\0');
            dwSize = 1;
        }
        
        if (!pOldName || _tcscmp(pOldName, pNewName))
        {
            //
            // The domain has changed, save the new domain name
            // We also need to discard the old SCP
            //
            if (ERROR_SUCCESS != RegSetValueEx (
                    hKey, 
                    gszDomainName,
                    0,
                    REG_SZ,
                    (LPBYTE)pNewName,
                    dwSize * sizeof(TCHAR)
                    ))
            {
                LOG((TL_INFO, "VerifyDomainName:RegSetValueEx (%S) failed", pNewName));
            }

            RegDeleteValue (
                hKey, 
                gszRegTapisrvSCPGuid
                );
        }
    } while (0);

    ServerFree(pOldName);
    ServerFree(pNewName);

    return bReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\server\tapimmc.c ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1997-1998  Microsoft Corporation

Module Name:

    tapimmc.c

Abstract:

    Src module for tapi server mmc-support funcs

Author:

    Dan Knudson (DanKn)    10-Dec-1997

Revision History:

--*/


#include "windows.h"
#include "stdio.h"
#include "stdlib.h"
#include "assert.h"
#include "tapi.h"
#include "utils.h"
#include "tapiclnt.h"
#include "tspi.h"
#include "client.h"
#include "server.h"
#include "tapimmc.h"
#include "private.h"
#include "Sddl.h"

typedef struct _USERNAME_TUPLE
{
    LPWSTR  pDomainUserNames;

    LPWSTR  pFriendlyUserNames;

} USERNAME_TUPLE, *LPUSERNAME_TUPLE;


typedef struct _MMCGETAVAILABLEPROVIDERS_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;


    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwProviderListTotalSize;    // size of client buffer
        OUT DWORD       dwProviderListOffset;       // valid offset on success
    };

} MMCGETAVAILABLEPROVIDERS_PARAMS, *PMMCGETAVAILABLEPROVIDERS_PARAMS;


typedef struct _MMCGETDEVICEINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;


    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwDeviceInfoListTotalSize;  // size of client buffer
        OUT DWORD       dwDeviceInfoListOffset;     // valid offset on success
    };

} MMCGETDEVICEINFO_PARAMS, *PMMCGETDEVICEINFO_PARAMS;


typedef struct _MMCGETSERVERCONFIG_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;


    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwServerConfigTotalSize;    // size of client buffer
        OUT DWORD       dwServerConfigOffset;       // valid offset on success
    } ;

} MMCGETSERVERCONFIG_PARAMS, *PMMCGETSERVERCONFIG_PARAMS;


typedef struct _MMCSETDEVICEINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;


    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwDeviceInfoListOffset;     // valid offset
    };

} MMCSETDEVICEINFO_PARAMS, *PMMCSETDEVICEINFO_PARAMS;


typedef struct _MMCSETSERVERCONFIG_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;


    union
    {
        IN  HLINEAPP    hLineApp;
    };

    union
    {
        IN  DWORD       dwServerConfigOffset;       // valid offset
    };

} MMCSETSERVERCONFIG_PARAMS, *PMMCSETSERVERCONFIG_PARAMS;

typedef struct _MMCGETDEVICEFLAGS_PARAMS
{

    OUT LONG            lResult;
    
    DWORD               dwUnused;

    IN HLINEAPP         hLineApp;

    IN DWORD            fLine;

    IN DWORD            dwProviderID;
    
    IN DWORD            dwPermanentDeviceID;

    OUT DWORD           dwFlags;

    OUT DWORD           dwDeviceID;
    
} MMCGETDEVICEFLAGS_PARAM, *PMMCGETDEVICEFLAGS_PARAMS;

LPDEVICEINFOLIST gpLineInfoList = NULL;
LPDEVICEINFOLIST gpPhoneInfoList = NULL;
LPDWORD          gpLineDevFlags = NULL;
DWORD            gdwNumFlags = 0;
BOOL             gbLockMMCWrite = FALSE;

//
//  the last ftLastWriteTime of tsec.ini when we build the
//  gpLineInfoList or gpPhoneInfoList, we will rebuild the
//  *InfList if tsec.ini has been updated since then
//
FILETIME         gftLineLastWrite = {0};
FILETIME         gftPhoneLastWrite = {0};
CRITICAL_SECTION gMgmtCritSec;

WCHAR gszLines[] = L"Lines";
WCHAR gszPhones[] = L"Phones";
WCHAR gszFileName[] = L"..\\TAPI\\tsec.ini"; // Do NOT change! Relative path from %windir%\system32
WCHAR gszEmptyString[] = L"";
WCHAR gszFriendlyUserName[] = L"FriendlyUserName";
WCHAR gszTapiAdministrators[] = L"TapiAdministrators";

//
//  The following are the length of the constant strings
//  defined above (excluding the terminating zero). The above
//  string should not be changed normally. If for some
//  reason the above strings need to be changed, the following
//  CCH_constants need to be changed accordingly.
//

#define CCH_LINES 5
#define CCH_PHONES 6
#define CCH_FRIENDLYUSERNAME 16
#define CCH_TAPIADMINISTRATORS 18

extern TAPIGLOBALS TapiGlobals;

extern TCHAR gszProductType[];
extern TCHAR gszProductTypeServer[];
extern TCHAR gszProductTypeLanmanNt[];
extern TCHAR gszRegKeyNTServer[];

extern HANDLE ghEventService;

PTLINELOOKUPENTRY
GetLineLookupEntry(
    DWORD   dwDeviceID
    );

PTPHONELOOKUPENTRY
GetPhoneLookupEntry(
    DWORD   dwDeviceID
    );

BOOL
InitTapiStruct(
    LPVOID  pTapiStruct,
    DWORD   dwTotalSize,
    DWORD   dwFixedSize,
    BOOL    bZeroInit
    );

DWORD
GetDeviceIDFromPermanentID(
    TAPIPERMANENTID ID,
    BOOL            bLine
    );

DWORD
GetProviderFriendlyName(
    WCHAR  *pFileNameBuf,
    WCHAR **ppFriendlyNameBuf
    );

BOOL
IsBadStructParam(
    DWORD   dwParamsBufferSize,
    LPBYTE  pDataBuf,
    DWORD   dwXxxOffset
    );

LONG
PASCAL
GetClientList(
    BOOL            bAdminOnly,
    PTPOINTERLIST   *ppList
    );

extern CRITICAL_SECTION *gLockTable;
extern DWORD            gdwPointerToLockTableIndexBits;

#define POINTERTOTABLEINDEX(p) \
            ((((ULONG_PTR) p) >> 4) & gdwPointerToLockTableIndexBits)

PTCLIENT
PASCAL
WaitForExclusiveClientAccess(
    PTCLIENT    ptClient
    );
    
#define UNLOCKTCLIENT(p) \
            LeaveCriticalSection(&gLockTable[POINTERTOTABLEINDEX(p)])
            
#define UNLOCKTLINECLIENT(p) \
            LeaveCriticalSection(&gLockTable[POINTERTOTABLEINDEX(p)])
            
#define UNLOCKTPHONECLIENT(p) \
            LeaveCriticalSection(&gLockTable[POINTERTOTABLEINDEX(p)])

BOOL
PASCAL
WaitForExclusivetLineAccess(
    PTLINE      ptLine,
    HANDLE     *phMutex,
    BOOL       *pbDupedMutex,
    DWORD       dwTimeout
    );

BOOL
PASCAL
WaitForExclusiveLineClientAccess(
    PTLINECLIENT    ptLineClient
    );

    
BOOL
PASCAL
WaitForExclusivetPhoneAccess(
    PTPHONE     ptPhone,
    HANDLE     *phMutex,
    BOOL       *pbDupedMutex,
    DWORD       dwTimeout
    );

BOOL
PASCAL
WaitForExclusivePhoneClientAccess(
    PTPHONECLIENT   ptPhoneClient
    );

void
DestroytPhoneClient(
    HPHONE  hPhone
    );

void
PASCAL
DestroytLineClient(
    HLINE   hLine
    );

LONG
PASCAL
GetLineAppListFromClient(
    PTCLIENT        ptClient,
    PTPOINTERLIST  *ppList
    );

LONG
PASCAL
GetPhoneAppListFromClient(
    PTCLIENT        ptClient,
    PTPOINTERLIST  *ppList
    );
    
void
WINAPI
MGetAvailableProviders(
    PTCLIENT                            ptClient,
    PMMCGETAVAILABLEPROVIDERS_PARAMS    pParams,
    DWORD                               dwParamsBufferSize,
    LPBYTE                              pDataBuf,
    LPDWORD                             pdwNumBytesReturned
    )
{
    WCHAR                   szPath[MAX_PATH+8], *pFileNameBuf,
                            *pFriendlyNameBuf, *p, *p2;
    DWORD                   dwFileNameBufTotalSize, dwFileNameBufUsedSize,
                            dwFriendlyNameBufTotalSize,
                            dwFriendlyNameBufUsedSize,
                            dwNumProviders, dwSize, i;
    HANDLE                  hFind;
    WIN32_FIND_DATAW        findData;
    LPAVAILABLEPROVIDERLIST pList = (LPAVAILABLEPROVIDERLIST) pDataBuf;
    RPC_STATUS              RpcStatus;

    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwProviderListTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if (pParams->dwProviderListTotalSize < sizeof (AVAILABLEPROVIDERLIST))
    {
        pParams->lResult = LINEERR_STRUCTURETOOSMALL;
        return;
    }

    pList->dwTotalSize              = pParams->dwProviderListTotalSize;
    pList->dwNeededSize             =
    pList->dwUsedSize               = sizeof (*pList);
    pList->dwNumProviderListEntries =
    pList->dwProviderListSize       =
    pList->dwProviderListOffset     = 0;

    pParams->dwProviderListOffset = 0;


    //
    // Find all the files in the system directory with the extenion .TSP
    //

    GetSystemDirectoryW (szPath, MAX_PATH);

    wcscat (szPath, L"\\*.TSP");

    if ((hFind = FindFirstFileW (szPath, &findData)) == INVALID_HANDLE_VALUE)
    {
        LOG((TL_ERROR,
            "MGetAvailableProviders: FindFirstFile err=%d",
            GetLastError()
            ));

        goto done;
    }

    dwNumProviders         =
    dwFileNameBufTotalSize =
    dwFileNameBufUsedSize  = 0;

    do
    {
        LOG((TL_INFO,
            "MGetAvailableProviders: found '%ws'",
            findData.cFileName
            ));

        dwSize = (wcslen (findData.cFileName) + 1) * sizeof (WCHAR);

        if ((dwSize + dwFileNameBufUsedSize) > dwFileNameBufTotalSize)
        {
            if (!(p = ServerAlloc (dwFileNameBufTotalSize += 512)))
            {
                FindClose (hFind);
                pParams->lResult = LINEERR_NOMEM;
                return;
            }

            if (dwFileNameBufUsedSize)
            {
                CopyMemory (p, pFileNameBuf, dwFileNameBufUsedSize);

                ServerFree (pFileNameBuf);
            }

            pFileNameBuf = p;
        }

        CopyMemory(
            ((LPBYTE) pFileNameBuf) + dwFileNameBufUsedSize,
            findData.cFileName,
            dwSize
            );

        dwFileNameBufUsedSize += dwSize;

        dwNumProviders++;

    } while (FindNextFileW (hFind, &findData));

    FindClose (hFind);


    //
    // For each of the files we found above get their "friendly" name
    // (use the module name if there's no friendly name)
    //
    RpcStatus = RpcImpersonateClient(0);
    if (RPC_S_OK != RpcStatus)
    {
        LOG((TL_ERROR,
            "MGetAvailableProviders: RpcImpersonateClient err=%d",
            RpcStatus
            ));
        pParams->lResult = LINEERR_OPERATIONFAILED;
        ServerFree (pFileNameBuf);
        return;
    }
    dwFriendlyNameBufUsedSize = GetProviderFriendlyName (pFileNameBuf, &pFriendlyNameBuf);
    RpcRevertToSelf();

    if (0 == dwFriendlyNameBufUsedSize)
    {
        pFriendlyNameBuf = pFileNameBuf;

        dwFriendlyNameBufUsedSize = dwFileNameBufUsedSize;
    }

    pList->dwNeededSize +=
        (dwNumProviders * sizeof (AVAILABLEPROVIDERENTRY)) +
        dwFileNameBufUsedSize +
        dwFriendlyNameBufUsedSize;


    //
    // Now if there's enough room in the buffer for everything then
    // pack it all in there
    //

    if (pList->dwNeededSize <= pList->dwTotalSize)
    {
        DWORD                       dwNumAvailProviders;
        LPAVAILABLEPROVIDERENTRY    pEntry = (LPAVAILABLEPROVIDERENTRY)
                                        (pList + 1);


        pList->dwUsedSize += dwNumProviders * sizeof (AVAILABLEPROVIDERENTRY);

        p  = pFileNameBuf;
        p2 = pFriendlyNameBuf;

        for (i = dwNumAvailProviders = 0; i < dwNumProviders; i++)
        {
            HANDLE  hTsp;


            if (!(hTsp = LoadLibraryW (p)))
            {
                //
                // If we can't even load the tsp then ignore it
                //

                p += wcslen (p) + 1;
                p2 += wcslen (p2) + 1;
                continue;
            }
            
            if (GetProcAddress (hTsp, "TSPI_providerInstall"))
            {
                pEntry->dwOptions = AVAILABLEPROVIDER_INSTALLABLE;
            }
            else
            {
                pEntry->dwOptions = 0;
            }

            if (GetProcAddress (hTsp, "TSPI_providerConfig") ||
                GetProcAddress (hTsp, "TUISPI_providerConfig"))
            {
                pEntry->dwOptions |= AVAILABLEPROVIDER_CONFIGURABLE;
            }

            if (GetProcAddress (hTsp, "TSPI_providerRemove"))
            {
                pEntry->dwOptions |= AVAILABLEPROVIDER_REMOVABLE;
            }

            FreeLibrary (hTsp);


            pEntry->dwFileNameSize   = (wcslen (p) + 1) * sizeof (WCHAR);
            pEntry->dwFileNameOffset = pList->dwUsedSize;

            CopyMemory(
                ((LPBYTE) pList) + pEntry->dwFileNameOffset,
                p,
                pEntry->dwFileNameSize
                );

            pList->dwUsedSize += pEntry->dwFileNameSize;

            p += pEntry->dwFileNameSize / sizeof (WCHAR);


            pEntry->dwFriendlyNameSize   = (wcslen (p2) + 1) * sizeof (WCHAR);
            pEntry->dwFriendlyNameOffset = pList->dwUsedSize;

            CopyMemory(
                ((LPBYTE) pList) + pEntry->dwFriendlyNameOffset,
                p2,
                pEntry->dwFriendlyNameSize
                );

            pList->dwUsedSize += pEntry->dwFriendlyNameSize;

            p2 += pEntry->dwFriendlyNameSize / sizeof (WCHAR);


            dwNumAvailProviders++; pEntry++;
        }

        pList->dwNumProviderListEntries = dwNumAvailProviders;
        pList->dwProviderListSize       =
            dwNumProviders * sizeof (AVAILABLEPROVIDERENTRY);
        pList->dwProviderListOffset     = sizeof (*pList);
    }

    ServerFree (pFileNameBuf);

    if (pFriendlyNameBuf != pFileNameBuf)
    {
        ServerFree (pFriendlyNameBuf);
    }

done:

    *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pList->dwUsedSize;

    pParams->lResult = 0;
}


DWORD
PASCAL
MyGetPrivateProfileString(
    LPCWSTR     pszSection,
    LPCWSTR     pszKey,
    LPCWSTR     pszDefault,
    LPWSTR     *ppBuf,
    LPDWORD     pdwBufSize
    )
{
    DWORD dwResult;


    while (1)
    {
        dwResult = GetPrivateProfileStringW(
            pszSection,
            pszKey,
            pszDefault,
            *ppBuf,
            *pdwBufSize / sizeof (WCHAR),
            gszFileName
            );

        if (dwResult < ((*pdwBufSize) / sizeof(WCHAR) - 2))
        {
            return 0;
        }

        ServerFree (*ppBuf);

        *pdwBufSize *= 2;

        if (!(*ppBuf = ServerAlloc (*pdwBufSize)))
        {
            break;
        }
    }

    return LINEERR_NOMEM;
}


DWORD
PASCAL
InsertInfoListString(
    LPDEVICEINFOLIST    *ppInfoList,
    DWORD               dwInfoIndex,
    DWORD               dwXxxSizeFieldOffset,
    LPWSTR              psz,
    DWORD               dwLength,
    BOOL                bAppendNull
    )
{
    LPDWORD             pdwXxxSize;
    LPDEVICEINFO        pInfo;
    LPDEVICEINFOLIST    pInfoList = *ppInfoList;


    if (!dwLength)
    {
        return 0;
    }


    //
    // If the existing buffer is too small the alloc a larger one
    //

    if ((pInfoList->dwUsedSize + dwLength + sizeof (WCHAR)) >
            pInfoList->dwTotalSize)
    {
        DWORD   dwTotalSize = (*ppInfoList)->dwTotalSize + dwLength + 4096;


        if (!(pInfoList = ServerAlloc (dwTotalSize)))
        {
            return LINEERR_NOMEM;
        }

        CopyMemory (pInfoList, *ppInfoList, (*ppInfoList)->dwUsedSize);

        pInfoList->dwTotalSize = dwTotalSize;;

        ServerFree (*ppInfoList);

        *ppInfoList = pInfoList;
    }

    CopyMemory (((LPBYTE) pInfoList) + pInfoList->dwUsedSize, psz, dwLength);

    pInfo = ((LPDEVICEINFO)(pInfoList + 1)) + dwInfoIndex;

    pdwXxxSize = (LPDWORD) (((LPBYTE) pInfo) + dwXxxSizeFieldOffset);

    if ((*pdwXxxSize += dwLength) == dwLength)
    {
        *(pdwXxxSize + 1) = pInfoList->dwUsedSize;
    }

    pInfoList->dwUsedSize += dwLength;

    if (bAppendNull)
    {
        *((WCHAR *)(((LPBYTE) pInfoList) + pInfoList->dwUsedSize)) = L'\0';

        pInfoList->dwUsedSize += sizeof (WCHAR);

        *pdwXxxSize += sizeof (WCHAR);
    }

    return 0;
}


DWORD
PASCAL
GrowCapsBuf(
    LPDWORD    *ppXxxCaps,
    LPDWORD     pdwBufSize
    )
{
    DWORD   dwTotalSize = **ppXxxCaps + 256, *pXxxCapsTmp;


    if (!(pXxxCapsTmp = ServerAlloc (dwTotalSize)))
    {
        return LINEERR_NOMEM;
    }

    *pdwBufSize = *pXxxCapsTmp = dwTotalSize;

    ServerFree (*ppXxxCaps);

    *ppXxxCaps = pXxxCapsTmp;

    return 0;
}


DWORD
PASCAL
ChangeDeviceUserAssociation(
    LPWSTR  pDomainUserName,
    LPWSTR  pFriendlyUserName,
    DWORD   dwProviderID,
    DWORD   dwPermanentDeviceID,
    BOOL    bLine
    )
{
    DWORD   dwSize = 64 * sizeof (WCHAR), dwLength, dwNeededSize;
    WCHAR  *p, *p2, *p3, buf[32];
    BOOL    bAlreadyIn;
    WCHAR  *pSub;


    if (!(p = ServerAlloc (dwSize)))
    {
        return LINEERR_NOMEM;
    }

    if (MyGetPrivateProfileString(
            pDomainUserName,
            (bLine ? gszLines : gszPhones),
            gszEmptyString,
            &p,
            &dwSize
            ))
    {
        ServerFree (p);
        return LINEERR_NOMEM;
    }

    dwLength = wsprintfW (buf, L"%d,%d", dwProviderID, dwPermanentDeviceID);

    //
    //  Check if the specified Device/User assocation is already there
    //  if so bAlreadyIn is set to be true and pSub points to the
    //  (dwProviderID, dwPermanentDeviceID) pair
    //
    bAlreadyIn = FALSE;
    pSub = p;
    while (*pSub)
    {
        if ((wcsncmp(pSub, buf, dwLength) == 0) && 
            (*(pSub + dwLength) == L',' || *(pSub + dwLength) == L'\0'))
        {
            bAlreadyIn = TRUE;
            break;
        }

        //
        //  Skip the next two delimiting ','
        //
        if (!(pSub = wcschr (pSub, L',')))
        {
            break;
        }
        pSub++;
        if (!(pSub = wcschr (pSub, L',')))
        {
            break;
        }
        pSub++;
    }

    if (pFriendlyUserName) // Add device/user association
    {
        //  Always write the friendly name which could be different
        WritePrivateProfileStringW(
            pDomainUserName,
            gszFriendlyUserName,
            pFriendlyUserName,
            gszFileName
            );

        if ( !bAlreadyIn)
        {
            dwNeededSize = (dwLength + wcslen (p) + 2) * sizeof (WCHAR);

            if (dwNeededSize > dwSize)
            {
                if (!(p2 = ServerAlloc (dwNeededSize)))
                {
                    return LINEERR_NOMEM;
                }

                wcscpy (p2, p);
                ServerFree (p);
                p = p2;
            }

            if (*p == L'\0')
            {
                wcscpy (p, buf);
            }
            else
            {
                wcscat (p, L",");
                wcscat (p, buf);
            }
        }
    }
    else // Remove device/user association
    {
        p2 = pSub;

        if (bAlreadyIn)
        {
            if (*(p2 + dwLength) == L',') // not last item in list, so copy
            {
                for(
                    p3 = p2 + dwLength + 1;
                    (*p2 = *p3) != L'\0';
                    p2++, p3++
                    );
            }
            else if (*(p2 + dwLength) == L'\0')
            {
                if (p2 == p) // only item in list, so list == ""
                {
                    *p2 = L'\0';
                }
                else // last item in list, so nuke preceding ','
                {
                    *(p2 - 1) = L'\0';
                }
            }
        }

        if (*p == L'\0')
        {
        }
    }

    if (bLine && *p == 0)
    {
        WritePrivateProfileStringW(
            pDomainUserName,
            NULL,
            NULL,
            gszFileName
            );
    }
    else
    {
        WritePrivateProfileStringW(
            pDomainUserName,
            (bLine ? gszLines : gszPhones),
            p,
            gszFileName
            );
    }

    ServerFree (p);

    return 0;
}

//
//  UpdateLastWriteTime
//      It reads the ftLastWriteTime of the tsec.ini into gftLineLastWrite or
//  gftPhoneLastWrite, it also returns S_FALSE, if the timestamp is newer
//
LONG
UpdateLastWriteTime (
    BOOL                        bLine
    )
{
    LONG     lResult = S_OK;
    WCHAR       szFilePath[MAX_PATH + 16];    // include space for "tsec.ini"
    WIN32_FILE_ATTRIBUTE_DATA fad;
    FILETIME *  pft;
    DWORD       dwError;
        
    if (GetSystemWindowsDirectoryW(szFilePath, MAX_PATH) == 0)
    {
        lResult = LINEERR_OPERATIONFAILED;
        goto ExitHere;
    }

    wcscat (szFilePath, L"\\");
    wcscat (szFilePath, gszFileName);
    pft = bLine ? &gftLineLastWrite : &gftPhoneLastWrite;

    if (GetFileAttributesExW (
        szFilePath,
        GetFileExInfoStandard,
        &fad) == 0
        )
    {
        dwError = GetLastError();
        if (dwError == ERROR_FILE_NOT_FOUND || dwError == ERROR_PATH_NOT_FOUND)
        {
            ZeroMemory (pft, sizeof(FILETIME));
            lResult = S_FALSE;
        }
        else
        {
            lResult = LINEERR_OPERATIONFAILED;
        }
        goto ExitHere;
    }

    if (fad.ftLastWriteTime.dwHighDateTime > pft->dwHighDateTime ||
        fad.ftLastWriteTime.dwLowDateTime > pft->dwLowDateTime)
    {
        pft->dwHighDateTime = fad.ftLastWriteTime.dwHighDateTime;
        pft->dwLowDateTime = fad.ftLastWriteTime.dwLowDateTime;
        lResult = S_FALSE;
    }

ExitHere:
    return lResult;
}

//
//  InsertDevNameAddrInfo
//      Utlity to fill
//          DEVICEINFO.dwDeviceNameSize
//          DEVICEINFO.dwDeviceNameOffset
//          DEVICEINFO.dwAddressSize
//          DEVICEINFO.dwAddressOffset
//      dwDeviceID is the device ID to retrieve information while
//      dwEntry is the DEVICEINFO entry index in the deviceinfo list
//
//

LONG
InsertDevNameAddrInfo (
    BOOL                        bLine,
    LPDEVICEINFOLIST            *ppList,
    LPDWORD                     pdwDevFlags,
    DWORD                       dwDeviceID,
    DWORD                       dwEntry
    )
{
    LPDEVICEINFO                pInfo = ((LPDEVICEINFO)((*ppList) + 1)) + dwEntry;
    PTLINELOOKUPENTRY           pLLE;
    PTPHONELOOKUPENTRY          pPLE;
    LONG                        lResult = S_OK;
    DWORD                       k;
    
    LINEDEVCAPS                 devCaps[3];
    LPLINEDEVCAPS               pDevCaps = devCaps;
    DWORD                       dwDevCapsTotalSize = sizeof(devCaps);
    
    LINEADDRESSCAPS             addrCaps[3];
    LPLINEADDRESSCAPS           pAddrCaps = addrCaps;
    DWORD                       dwAddrCapsTotalSize = sizeof(addrCaps);

    TapiEnterCriticalSection(&TapiGlobals.CritSec);
    
    if (bLine)
    {
        pLLE = GetLineLookupEntry (dwDeviceID);

        if (!pLLE ||
            pLLE->bRemoved)
        {
             lResult = S_FALSE;
             goto ExitHere;
        }

        pInfo->dwProviderID = pLLE->ptProvider->dwPermanentProviderID;
    }
    else
    {
        pPLE = GetPhoneLookupEntry (dwDeviceID);

        if (!pPLE ||
            pPLE->bRemoved)
        {
             lResult = S_FALSE;
             goto ExitHere;
        }
        pInfo->dwProviderID = pPLE->ptProvider->dwPermanentProviderID;
    }

    //
    // Retrieve device name from TSPI_xxGetCaps
    //

get_dev_caps:

    InitTapiStruct(
        pDevCaps,
        dwDevCapsTotalSize,
        sizeof (LINEDEVCAPS),
        TRUE
        );

    if (bLine)
    {
        lResult = CallSP4(
            pLLE->ptProvider->apfn[SP_LINEGETDEVCAPS],
            "lineGetDevCaps",
            SP_FUNC_SYNC,
            (DWORD) dwDeviceID,
            (DWORD) pLLE->dwSPIVersion,
            (DWORD) 0,
            (ULONG_PTR) pDevCaps
            );
    }
    else
    {
        lResult = CallSP4(
            pPLE->ptProvider->apfn[SP_PHONEGETDEVCAPS],
            "phoneGetDevCaps",
            SP_FUNC_SYNC,
            (DWORD) dwDeviceID,
            (DWORD) pPLE->dwSPIVersion,
            (DWORD) 0,
            (ULONG_PTR) pDevCaps
            );
    }
    if (lResult != 0)
    {
        //
        // We can't get the name or the PermDevID, so ignore this device
        //

        goto ExitHere;
    }
    else if (pDevCaps->dwNeededSize <= pDevCaps->dwTotalSize)
    {
        DWORD   dwXxxSize;
        LPWSTR  pwszXxxName;
        const WCHAR szUnknown[] = L"Unknown";

        if (bLine)
        {
            pInfo->dwPermanentDeviceID = pDevCaps->dwPermanentLineID;

            if (pdwDevFlags)
            {
                *pdwDevFlags = pDevCaps->dwDevCapFlags;
            }

            dwXxxSize = pDevCaps->dwLineNameSize;

            pwszXxxName = (WCHAR *) (((LPBYTE) pDevCaps) +
                pDevCaps->dwLineNameOffset);

        }
        else
        {
            LPPHONECAPS pPhoneCaps = (LPPHONECAPS) pDevCaps;


            pInfo->dwPermanentDeviceID = pPhoneCaps->dwPermanentPhoneID;

            dwXxxSize = pPhoneCaps->dwPhoneNameSize;

            pwszXxxName = (WCHAR *) (((LPBYTE) pPhoneCaps) +
                pPhoneCaps->dwPhoneNameOffset);
        }

        if (dwXxxSize == 0  ||  *pwszXxxName == L'\0')
        {
            dwXxxSize = 8 * sizeof (WCHAR);

            pwszXxxName = (LPWSTR) szUnknown;
        }

        if (InsertInfoListString(
                ppList,
                dwEntry,
                (DWORD) (((LPBYTE) &pInfo->dwDeviceNameSize) -
                    ((LPBYTE) pInfo)),
                pwszXxxName,
                dwXxxSize,
                FALSE
                ))
        {
            lResult = LINEERR_NOMEM;
            goto ExitHere;
        }
    }
    //
    //  if the pDevCaps is not large enough, increase the size
    //  by 256 and try again.
    //
    else
    {
        LPLINEDEVCAPS       pNewDevCaps;
        
        dwDevCapsTotalSize += 256;
        pNewDevCaps = ServerAlloc (dwDevCapsTotalSize);
        if (pNewDevCaps == NULL)
        {
            lResult = LINEERR_NOMEM;
            goto ExitHere;
        }
        if (pDevCaps != devCaps)
        {
            ServerFree (pDevCaps);
        }
        pDevCaps = pNewDevCaps;
        goto get_dev_caps;
    }


    if (bLine)
    {
        //
        // for each address on this line retrieve the address "name"
        // by calling TSPI_lineGetAddressCaps.  Terminate the last
        // address name in the list with an extra Null character.
        //

        for (k = 0; k < pDevCaps->dwNumAddresses; k++)
        {

get_addr_caps:
            InitTapiStruct(
                pAddrCaps,
                dwAddrCapsTotalSize,
                sizeof (LINEADDRESSCAPS),
                TRUE
                );

            if ((lResult = CallSP5(
                pLLE->ptProvider->apfn[SP_LINEGETADDRESSCAPS],
                "lineGetAddressCaps",
                SP_FUNC_SYNC,
                (DWORD) dwDeviceID,
                (DWORD) k,
                (DWORD) pLLE->dwSPIVersion,
                (DWORD) 0,
                (ULONG_PTR) pAddrCaps
                )) == 0)
            {
                if (pAddrCaps->dwNeededSize <= pAddrCaps->dwTotalSize)
                {
                    if (InsertInfoListString(
                        ppList,
                        dwEntry,
                        (DWORD) (((LPBYTE) &pInfo->dwAddressesSize) -
                            ((LPBYTE) pInfo)),
                        (LPWSTR) (((LPBYTE) pAddrCaps) +
                            pAddrCaps->dwAddressOffset),
                        pAddrCaps->dwAddressSize,
                        (k < (pDevCaps->dwNumAddresses - 1) ?
                            FALSE : TRUE)
                        ))
                    {
                        lResult = LINEERR_NOMEM;
                        goto ExitHere;
                    }
                }
                //
                //  if the pAddrCaps is not large enough, increase the size
                //  by 256 and try again.
                //
                else
                {
                    LPLINEADDRESSCAPS          pNewAddrCaps;
                    dwAddrCapsTotalSize += 256;
                    pNewAddrCaps = ServerAlloc (dwAddrCapsTotalSize);
                    if (pNewAddrCaps == NULL)
                    {
                        goto ExitHere;
                    }
                    if (pAddrCaps != addrCaps)
                    {
                        ServerFree (pAddrCaps);
                    }
                    pAddrCaps = pNewAddrCaps;
                    goto get_addr_caps;
                }
            }
            else
            {
                // no addr name (will default to blank, not bad)
            }
        }
    }

ExitHere:
    if (pDevCaps != devCaps)
    {
        ServerFree (pDevCaps);
    }
    if (pAddrCaps != addrCaps)
    {
        ServerFree (pAddrCaps);
    }
    TapiLeaveCriticalSection(&TapiGlobals.CritSec);
    return lResult;
}

//
//  AppendNewDeviceInfo
//      This function insert a newly created device identified by 
//  dwDeviceID into the cached gpLineInfoList or gpPhoneInfoList in
//  response to LINE/PHONE_CREATE message
//

LONG
AppendNewDeviceInfo (
    BOOL                        bLine,
    DWORD                       dwDeviceID
    )
{
    LONG             lResult = S_OK;
    LPDEVICEINFOLIST    pXxxList;
    DWORD               dwXxxDevices;
    DWORD               dwTotalSize;
    DWORD               dwSize, dw;

    EnterCriticalSection (&gMgmtCritSec);

    pXxxList = bLine? gpLineInfoList : gpPhoneInfoList;
    dwXxxDevices = bLine ? TapiGlobals.dwNumLines : TapiGlobals.dwNumPhones;

    if (pXxxList == NULL)
    {
        goto ExitHere;
    }

    //
    //  make sure we have enough space to accomodate the new device flags
    if (bLine && gpLineDevFlags && gdwNumFlags < dwXxxDevices)
    {
        LPDWORD         pNewLineDevFlags;

        pNewLineDevFlags = ServerAlloc (dwXxxDevices * sizeof(DWORD));
        if (pNewLineDevFlags == NULL)
        {
            goto ExitHere;
        }
        CopyMemory (
            pNewLineDevFlags, 
            gpLineDevFlags, 
            gdwNumFlags * sizeof(DWORD)
            );
        ServerFree (gpLineDevFlags);
        gpLineDevFlags = pNewLineDevFlags;
        gdwNumFlags = dwXxxDevices;
    }

    //
    //  make sure we have enough space for the new DEVICEINFO entry
    //  An estimate is done for the new DEVICEINFO entry
    //  the estimation includes:
    //      1. Fixed size of DEVICEINFO structure
    //      2. 20 bytes each for DeviceName, Addresses, DomainUserName
    //         and FriendlyUserName
    //
    dwTotalSize = pXxxList->dwUsedSize + 
        sizeof(DEVICEINFO) + (20 + 20 + 20 + 20) * sizeof(WCHAR);
    if (dwTotalSize > pXxxList->dwTotalSize)
    {
        LPDEVICEINFOLIST        pNewList;

        pNewList = ServerAlloc (dwTotalSize);
        if (pNewList == NULL)
        {
            lResult = (bLine ? LINEERR_NOMEM : PHONEERR_NOMEM);
            goto ExitHere;
        }
        CopyMemory (pNewList, pXxxList, pXxxList->dwUsedSize);
        pNewList->dwTotalSize = dwTotalSize;
        pXxxList = pNewList;
        if (bLine)
        {
            ServerFree (gpLineInfoList);
            gpLineInfoList = pXxxList;
        }
        else
        {
            ServerFree (gpPhoneInfoList);
            gpPhoneInfoList = pXxxList;
        }
    }

    //  Now make space for the new DEVICEINFO entry
    if (pXxxList->dwUsedSize > 
        pXxxList->dwDeviceInfoSize + sizeof(*pXxxList))
    {
        LPBYTE      pbVar = (LPBYTE) pXxxList + 
            pXxxList->dwDeviceInfoSize + sizeof(*pXxxList);
        LPDEVICEINFO    pInfo = (LPDEVICEINFO)(((LPBYTE)pXxxList) + 
            sizeof(*pXxxList));
        dwSize = pXxxList->dwUsedSize - 
            pXxxList->dwDeviceInfoSize - sizeof(*pXxxList);
        MoveMemory (
            pbVar + sizeof(DEVICEINFO),
            pbVar,
            dwSize);
        ZeroMemory (pbVar, sizeof(DEVICEINFO));
        for (dw = 0; 
            dw < pXxxList->dwNumDeviceInfoEntries; 
            ++dw
            )
        {
            if (pInfo->dwDeviceNameOffset != 0)
            {
                pInfo->dwDeviceNameOffset += sizeof(DEVICEINFO);
            }
            if (pInfo->dwAddressesOffset != 0)
            {
                pInfo->dwAddressesOffset += sizeof(DEVICEINFO);
            }
            if (pInfo->dwDomainUserNamesOffset != 0)
            {
                pInfo->dwDomainUserNamesOffset += sizeof(DEVICEINFO);
            }
            if (pInfo->dwFriendlyUserNamesOffset != 0)
            {
                pInfo->dwFriendlyUserNamesOffset += sizeof(DEVICEINFO);
            }
            ++pInfo;
        }
    }
    pXxxList->dwUsedSize += sizeof(DEVICEINFO);
    pXxxList->dwNeededSize = pXxxList->dwUsedSize;

    //  Now add the new entry
    lResult = InsertDevNameAddrInfo (
        bLine,
        (bLine ? (&gpLineInfoList) : (&gpPhoneInfoList)),
        (bLine && dwDeviceID < gdwNumFlags) ? (gpLineDevFlags + dwDeviceID) : NULL,
        dwDeviceID,
        pXxxList->dwNumDeviceInfoEntries
        );
    if (lResult == 0)
    {
        pXxxList = bLine? gpLineInfoList : gpPhoneInfoList;
        pXxxList->dwDeviceInfoSize += sizeof(DEVICEINFO);
        ++pXxxList->dwNumDeviceInfoEntries;
        pXxxList->dwNeededSize = pXxxList->dwUsedSize;
    }

ExitHere:
    LeaveCriticalSection (&gMgmtCritSec);

    return lResult;
}

//
//  RemoveDeviceInfoEntry
//      // This function removes a device info entry from the gpLineInfoList
//  or gpPhoneInfoList identified by dwDevice in response to LINE/PHONE_REMOVE
//  message
//

LONG
RemoveDeviceInfoEntry (
    BOOL                        bLine,
    DWORD                       dwDeviceID
    )
{
    LPDEVICEINFOLIST            pXxxList;
    LPDEVICEINFO                pInfo;
    int                         iIndex, cItems;
    LPBYTE                      pb;

    EnterCriticalSection (&gMgmtCritSec);

    pXxxList = bLine ? gpLineInfoList : gpPhoneInfoList;
    if (pXxxList == NULL)
    {
        goto ExitHere;
    }
    
    pInfo = (LPDEVICEINFO)(pXxxList + 1);

    cItems = (int)pXxxList->dwNumDeviceInfoEntries;
    iIndex = dwDeviceID;
    if ((int)dwDeviceID >= cItems)
    {
        iIndex = cItems - 1;
    }
    pInfo += iIndex;
    while (iIndex >= 0)
    {
        TAPIPERMANENTID     tpid;

        tpid.dwDeviceID = pInfo->dwPermanentDeviceID;
        tpid.dwProviderID = pInfo->dwProviderID;

        if (dwDeviceID == GetDeviceIDFromPermanentID(tpid, bLine))
        {
            break;
        }
        --pInfo;
        --iIndex;
    }
    if (iIndex < 0)
    {
        goto ExitHere;
    }

    //  With the entry pointed to by iIndex found, move down
    //  all the DEVICEINFO entry above it
    if (iIndex < cItems - 1)
    {
        pb = (LPBYTE)((LPDEVICEINFO)(pXxxList + 1) + iIndex);
        MoveMemory (
            pb, 
            pb + sizeof(DEVICEINFO), 
            (cItems - 1 - iIndex) * sizeof(DEVICEINFO)
            );
    }
    pXxxList->dwDeviceInfoSize -= sizeof(DEVICEINFO);
    --pXxxList->dwNumDeviceInfoEntries;

ExitHere:
    LeaveCriticalSection (&gMgmtCritSec);
    return 0;
}

BOOL
SecureTsecIni()
{
    SECURITY_DESCRIPTOR * pSD;
    char * szSD =   "D:" //DACL
                    "(D;OICI;GA;;;BG)" // Deny Guests
                    "(A;OICI;GA;;;SY)" // Allow System Full Control
                    "(A;OICI;GA;;;BA)" // Allow Admins Full Control
                    "(D;OICI;GA;;;BU)" // Deny Built-in Users
                    "(D;OICI;GA;;;IU)" // Deny Interactive Users
                    "(D;OICI;GA;;;NU)" // Deny Network Logon Users
                    "(D;OICI;GA;;;RD)"; // Deny Remote Desktop and Terminal Server Users

    WCHAR       szFilePath[MAX_PATH + 1];
    UINT        dwSize;
    HANDLE      hIniFile = NULL;
    BOOL        bRet;
    
    dwSize = GetSystemDirectory(szFilePath, MAX_PATH + 1);
    if (0 == dwSize || dwSize >= MAX_PATH + 1)
    {
        return FALSE;
    }

    if (MAX_PATH - dwSize < 1 + sizeof(gszFileName) / sizeof(WCHAR))
    {
        return FALSE;
    }

    wcscat (szFilePath, L"\\");
    wcscat (szFilePath, gszFileName);

    hIniFile = CreateFile (
        szFilePath, 
        GENERIC_READ, 
        FILE_SHARE_READ,
        NULL,
        OPEN_ALWAYS,
        FILE_ATTRIBUTE_NORMAL,
        NULL
        );

    if (hIniFile == INVALID_HANDLE_VALUE) 
    {
        return FALSE;
    }
    CloseHandle(hIniFile);

    if (!ConvertStringSecurityDescriptorToSecurityDescriptorA(
        szSD,
        SDDL_REVISION_1,
        &pSD,
        NULL))
    {
        return FALSE;
    }

    bRet = SetFileSecurity(
        szFilePath,
        DACL_SECURITY_INFORMATION | PROTECTED_DACL_SECURITY_INFORMATION,
        pSD);

    LocalFree(pSD);

    return bRet;
}

//
//  BuildDeviceInfoList
//      Private function called by GetDeviceInfo to build the DEVICEINFOLIST
//  if not already created, the list is saved in gpLineInfoList or 
//  gpPhoneInfoList
//

LONG
BuildDeviceInfoList(
    BOOL                        bLine
    )
{
    LONG                lResult = S_OK;
    DWORD               dwNumDevices, dwListTotalSize, dwFriendlyNameSize,
                        dwDomainUserNameSize, dwFriendlyUserNameSize;
    DWORD               i, j;
    LPDEVICEINFOLIST    pList = NULL;
    LPUSERNAME_TUPLE    pUserNames= NULL;
    LPWSTR              lpszFriendlyName = NULL;
    LPDEVICEINFO        pInfo;
    
    HANDLE              hIniFile = 0;
    HANDLE              hFileMap = NULL;
    char *              lpszFileBuf = NULL;
    char*               lpszLineAnsiBuf = NULL;
    LPWSTR              lpszLineWcharBuf = NULL;
    DWORD               dwAnsiLineBufSize, dwWcharLineBufSize;
    DWORD               dwTotalFileSize;
    DWORD               dwFilePtr;
    LPWSTR              lpszDomainUser = NULL;
    DWORD               cbDomainUser;
    LPDWORD             lpdwDevFlags = NULL;
    WCHAR               *p;

    //
    // Alloc a buffer to use for the device info list.  Size includes
    // the list header, list entries for each existing device,
    // and space wide unicode strings for device name, (address,)
    // domain\user name(s), and friendly user name(s) (each est to 20 char).
    //
    // Also alloc buffers to use for retrieving device & address caps,
    // and a buffer to temporarily store pointers to user name
    // strings (which are associated with each line)
    //

    TapiEnterCriticalSection(&TapiGlobals.CritSec);
    dwNumDevices = (bLine ? TapiGlobals.dwNumLines : TapiGlobals.dwNumPhones);
    TapiLeaveCriticalSection(&TapiGlobals.CritSec);

    dwAnsiLineBufSize = 256 * sizeof(WCHAR);
    dwWcharLineBufSize = 256 * sizeof(WCHAR);
    dwFriendlyNameSize = 64 * sizeof (WCHAR);
    cbDomainUser = 128;
    dwListTotalSize =
        sizeof (DEVICEINFOLIST) +
        (dwNumDevices * sizeof (DEVICEINFO)) +
        (dwNumDevices * (20 + 20 + 20 + 20) * sizeof (WCHAR));

    if (!(pList      = ServerAlloc (dwListTotalSize)) ||
        !(pUserNames = ServerAlloc (dwNumDevices * sizeof (USERNAME_TUPLE))) ||
        !(lpszFriendlyName = ServerAlloc (dwFriendlyNameSize)) ||
        !(lpszLineAnsiBuf = ServerAlloc (dwAnsiLineBufSize)) ||
        !(lpszLineWcharBuf = ServerAlloc (dwWcharLineBufSize)) ||
        !(lpszDomainUser = ServerAlloc (cbDomainUser)))
    {
        lResult = LINEERR_NOMEM;
        goto ExitHere;
    }

    if (bLine && !(lpdwDevFlags = ServerAlloc (dwNumDevices * sizeof (DWORD))))
    {
        lResult = LINEERR_NOMEM;
        goto ExitHere;
    }

    pList->dwTotalSize            = dwListTotalSize;
    pList->dwUsedSize             = sizeof (*pList) +
                                      dwNumDevices * sizeof (DEVICEINFO);
    pList->dwDeviceInfoSize       = dwNumDevices * sizeof (DEVICEINFO);
    pList->dwDeviceInfoOffset     = sizeof (*pList);

    //
    // Get info for all the lines, including:
    //
    //      Provider ID
    //      Permanent Device ID
    //      Device Name
    //      (Addresses)
    //
    // ... and pack this info in the list sequentially
    //

    LOG((TL_INFO,
        "GetDeviceInfo: getting names (addrs) for %ld %ws",
        dwNumDevices,
        (bLine ? gszLines : gszPhones)
        ));

    for (i = j = 0; i < dwNumDevices; i++)
    {
        if (WaitForSingleObject (
            ghEventService,
            0
            ) == WAIT_OBJECT_0)
        {
            lResult = LINEERR_OPERATIONFAILED;
            goto ExitHere;
        }
    
        lResult = InsertDevNameAddrInfo (
            bLine, 
            &pList, 
            bLine ? lpdwDevFlags + i : NULL, 
            i, 
            j
            );
        if (lResult)
        {
            lResult = 0;
            continue;
        }
        ++j;
    }

    dwNumDevices =
    pList->dwNumDeviceInfoEntries = j;  // the number of devices in the list


    //
    // Now enumerate all the known users & figure out what devices they
    // have access to.  Since each device can be seen by zero, one, or
    // many users, we allocate separate user name buffers in this loop
    // rather than try to pack them into the existing device info list.
    //

    //
    //  Open %windir%\tsec.ini file and map it into memory
    //

    {
        TCHAR       szFilePath[MAX_PATH + 16];    // include space for "tsec.ini"
        OFSTRUCT    ofs;
        
        if (GetCurrentDirectory(MAX_PATH, szFilePath) == 0)
        {
            lResult = LINEERR_OPERATIONFAILED;
            goto ExitHere;
        }

        wcscat (szFilePath, L"\\");
        wcscat (szFilePath, gszFileName);

        hIniFile = CreateFile (
            szFilePath, 
            GENERIC_READ, 
            FILE_SHARE_READ,
            NULL,
            OPEN_EXISTING,
            FILE_ATTRIBUTE_NORMAL,
            NULL
            );

        if (hIniFile == INVALID_HANDLE_VALUE) 
        {
            DWORD           dwError;
            
            dwError = GetLastError();
            if (dwError != ERROR_FILE_NOT_FOUND 
                && dwError != ERROR_PATH_NOT_FOUND)
            {
                lResult = LINEERR_OPERATIONFAILED;
                goto ExitHere;
            }
        }
        if (hIniFile != INVALID_HANDLE_VALUE)
        {
            dwTotalFileSize = GetFileSize(hIniFile, NULL);
        }
        else
        {
            dwTotalFileSize = 0;
        }
        if (dwTotalFileSize > 0)
        {
            hFileMap = CreateFileMapping (
                hIniFile,
                NULL,
                PAGE_READONLY,
                0,
                0,
                NULL
                );
            if (hFileMap == NULL)
            {
                lResult = LINEERR_OPERATIONFAILED;
                goto ExitHere;
            }
            lpszFileBuf = MapViewOfFile (
                hFileMap,
                FILE_MAP_READ,
                0,
                0,
                0
                );
            if (lpszFileBuf == NULL)
            {
                lResult = LINEERR_OPERATIONFAILED;
                goto ExitHere;
            }
        }
        
    }

    pInfo = (LPDEVICEINFO)(pList + 1);

    dwFilePtr = 0;
    while (dwFilePtr < dwTotalFileSize)
    {
        WCHAR               wch;
        DWORD               cch, cb;
        WCHAR *             lpwsz;
        
        if (WaitForSingleObject (
            ghEventService,
            0
            ) == WAIT_OBJECT_0)
        {
            lResult = LINEERR_OPERATIONFAILED;
            goto ExitHere;
        }
        
        ASSERT (lpszFileBuf != NULL);

        //  Read one line from the file
        cch = 0;
        wch = 0;
        cb = 0;
        while (wch != L'\n' && wch != L'\r' && dwFilePtr < dwTotalFileSize)
        {
            //  Not enough line buffer? if so enlarge
            if (cb >= dwAnsiLineBufSize)
            {
                char        * lpszNewAnsi;
            
                if (!(lpszNewAnsi = ServerAlloc (dwAnsiLineBufSize + 256)))
                {
                    lResult = LINEERR_NOMEM;
                    goto ExitHere;
                }
                CopyMemory (lpszNewAnsi, lpszLineAnsiBuf, cb);
                ServerFree (lpszLineAnsiBuf);
                lpszLineAnsiBuf = lpszNewAnsi;
                dwAnsiLineBufSize += 256;
            }
            
            wch = lpszLineAnsiBuf[cb++] = lpszFileBuf[dwFilePtr++];
            if (IsDBCSLeadByte((BYTE)wch))
            {
                lpszLineAnsiBuf[cb] = lpszFileBuf[dwFilePtr++];
                wch = (wch << 8) + lpszLineAnsiBuf[cb];
                ++cb;
            }
            ++cch;
        }

        //  skip the \r & \n
        if (wch == L'\r' || wch == L'\n')
        {
            lpszLineAnsiBuf[cb - 1] = 0;
            if (dwFilePtr < dwTotalFileSize &&
                ((lpszFileBuf[dwFilePtr] == L'\n') ||
                (lpszFileBuf[dwFilePtr] == L'\r')))
            {
                ++dwFilePtr;
            }
        }

        //  Now convert the ANSI string to Wide char

        //  enough wchar line buffer size?
        if (dwWcharLineBufSize <= (cch + 1) * sizeof(WCHAR))
        {
            ServerFree (lpszLineWcharBuf);
            dwWcharLineBufSize = (cch + 256) * sizeof(WCHAR);
            if (!(lpszLineWcharBuf = ServerAlloc (dwWcharLineBufSize)))
            {
                lResult = LINEERR_NOMEM;
                goto ExitHere;
            }
        }

        if ((cch = MultiByteToWideChar (
            CP_ACP,
            MB_PRECOMPOSED,
            lpszLineAnsiBuf,
            cb,
            lpszLineWcharBuf,
            dwWcharLineBufSize / sizeof(WCHAR)
            )) == 0)
        {
            lResult = LINEERR_OPERATIONFAILED;
            goto ExitHere;
        }
        ASSERT (cch < dwWcharLineBufSize / sizeof(WCHAR));
        lpszLineWcharBuf[cch] = 0;

        lpwsz = lpszLineWcharBuf;
        //  Skip white space
        while (*lpwsz && ((*lpwsz == L' ') || (*lpwsz == L'\t')))
        {
            ++lpwsz;
        }

        //  Got a bracket, this might be the starting of a new NT
        //  domain user or the section of [TapiAdministators]
        if (*lpwsz == L'[')
        {
            *lpszFriendlyName = 0;  // reset friendly name
            ++lpwsz;
            if (_wcsnicmp (
                lpwsz, 
                gszTapiAdministrators, 
                CCH_TAPIADMINISTRATORS
                ) == 0 &&
                lpwsz[CCH_TAPIADMINISTRATORS] == L']')
            {
                //  Got [TapiAdministrators], not any domain user
                // to process, reset the lpszDomainUser to empty
                *lpszDomainUser = 0;
                continue;
            }
            else
            {
                // might be a valid NT domain user like [ndev\jonsmith]
                // copy the domain user string over
                cch = 0;
                while (*lpwsz && *lpwsz != L']')
                {
                    if (((cch + 1) * sizeof(WCHAR)) >= cbDomainUser)
                    {
                        LPTSTR      lpszNew;

                        if (!(lpszNew = ServerAlloc (cbDomainUser + 128)))
                        {
                            lResult = LINEERR_NOMEM;
                            goto ExitHere;
                        }
                        CopyMemory (lpszNew, lpszDomainUser, cb);
                        ServerFree (lpszDomainUser);
                        lpszDomainUser = lpszNew;
                        cbDomainUser += 128;
                    }
                    lpszDomainUser[cch++] = *lpwsz++;
                }
                lpszDomainUser[cch] = 0;
                if (*lpwsz == 0)
                {
                    //  did not find a closing ']', ignore this section
                    *lpszDomainUser = 0;
                    continue;
                }
            }
        }
        //
        //  Now it might be some ntdev\jonsmith=1 in [TapiAdministrators] or
        //  Lines=1,1000 under section of [ntdev\jonsmith].
        //  for the first case, we just ignore this line, for the second case
        //  we need to have *lpszDomainUser != 0
        //
        else if (*lpszDomainUser)
        {
            if (_wcsnicmp (
                lpwsz, 
                gszFriendlyUserName, 
                CCH_FRIENDLYUSERNAME
                ) == 0)
            {
                // The tsec.ini friendly name is the following format
                // FriendlyName=Jon Smith
                // skip over the '='
                while (*lpwsz && *lpwsz != L'=')
                {
                    ++lpwsz;
                }
                if (*lpwsz == 0)
                {
                    continue;
                }
                else
                {
                    ++lpwsz;
                }
                if (dwFriendlyNameSize < (1 + wcslen (lpwsz)) * sizeof(WCHAR))
                {
                    ServerFree (lpszFriendlyName);
                    dwFriendlyNameSize = (64 + wcslen (lpwsz)) * sizeof(WCHAR);
                    if (!(lpszFriendlyName = ServerAlloc (dwFriendlyNameSize)))
                    {
                        lResult = LINEERR_NOMEM;
                        goto ExitHere;
                    }
                }
                wcscpy (lpszFriendlyName, lpwsz);
                continue;
            }
            else if (_wcsnicmp (
                lpwsz,
                gszLines,
                CCH_LINES
                ) == 0 && bLine ||
                _wcsnicmp (
                lpwsz,
                gszPhones,
                CCH_PHONES
                ) == 0 && (!bLine))
            {
                //  Here it is either Lines=1,100 or Phones=1,100
                DWORD           dwXxxSize, dwDeviceID;
                WCHAR          *pXxxNames, *pNewXxxNames, * p;
                TAPIPERMANENTID tpid;

                //  first skip over the '=' sign
                while (*lpwsz && *lpwsz != L'=')
                {
                    ++lpwsz;
                }
                if (*lpwsz == 0)
                {
                    continue;
                }
                ++lpwsz;

                p = lpwsz;
                while (*p)
                {
                    if ((tpid.dwProviderID = _wtol (p)) == 0)
                    {
                        //
                        // ProviderID's are never 0, so list must be corrupt.
                        //
                        break;
                    }
    
                    for (; ((*p != L'\0')  &&  (*p != L',')); p++);
    
                    if (*p == L'\0')
                    {
                        //
                        // Couldn't find a trailing ',' so list must be corrupt.
                        //
                        break;
                    }

                    p++; // skip the ','

                    tpid.dwDeviceID = _wtol (p);

                    while (*p != L','  &&  *p != L'\0')
                    {
                        p++;
                    }

                    if (*p == L',')
                    {
                        if (*(p + 1) == L'\0')
                        {
                            //
                            // The ',' is followed by a NULL, so nuke the ','
                            //
                            *p = L'\0';
                        }
                        else
                        {
                            p++;
                        }
                    }
    
                    dwDeviceID = GetDeviceIDFromPermanentID (tpid, bLine);

                    if (dwDeviceID == 0xffffffff)
                    {
                        //
                        // This <ppid>,<plid> pair is bad.  Skip it.
                        //
                        continue;
                    }


                    //
                    // At this point dwDeviceID is the zero-based index
                    // of a fully populated info list (no missing entries).
                    //
                    // If the list is not fully-populated (due to failed
                    // dev caps, or removed devices, etc) we need to
                    // recompute the index by walking the list & comparing
                    // permanent XXX id's.
                    //

                    if (dwNumDevices <
                        (bLine ? TapiGlobals.dwNumLines : TapiGlobals.dwNumPhones))
                    {
                        BOOL  bContinue = FALSE;

        
                        for (i = dwDeviceID;; i--)
                        {
                            LPDEVICEINFO    pInfoTmp = ((LPDEVICEINFO) (pList + 1)) +i;


                            if (pInfoTmp->dwPermanentDeviceID == tpid.dwDeviceID  &&
                                pInfoTmp->dwProviderID == tpid.dwProviderID)
                            {
                                dwDeviceID = i;
                                break;
                            }

                            if (i == 0)
                            {
                                bContinue = TRUE;
                                break;
                            }
                        }

                        if (bContinue)
                        {
                            continue;
                        }
                    }


                    //
                    //
                    //
                    dwDomainUserNameSize = (wcslen(lpszDomainUser) + 1) * sizeof(WCHAR);
                    dwXxxSize = pInfo[dwDeviceID].dwDomainUserNamesOffset;
                    pXxxNames = pUserNames[dwDeviceID].pDomainUserNames;

                    if (!(pNewXxxNames = ServerAlloc(
                            dwXxxSize + dwDomainUserNameSize
                            )))
                    {
                        lResult = LINEERR_NOMEM;
                        goto ExitHere;
                    }

                    CopyMemory (pNewXxxNames, lpszDomainUser, dwDomainUserNameSize);

                    if (dwXxxSize)
                    {
                        CopyMemory(
                            ((LPBYTE) pNewXxxNames) + dwDomainUserNameSize,
                            pXxxNames,
                            dwXxxSize
                            );

                        ServerFree (pXxxNames);
                    }

                    pInfo[dwDeviceID].dwDomainUserNamesOffset +=
                        dwDomainUserNameSize;
                    pUserNames[dwDeviceID].pDomainUserNames = pNewXxxNames;


                    //
                    //
                    //

                    //  If there is no friendly name specified in tsec.ini 
                    //  which happens in NT/SP4 upgrade case, we use the 
                    //  DomainUserName for display
                    //
                    if (*lpszFriendlyName == 0)
                    {
                        wcsncpy(lpszFriendlyName, lpszDomainUser, 
                                dwFriendlyNameSize / sizeof(WCHAR));
                        lpszFriendlyName[(dwFriendlyNameSize / sizeof(WCHAR)) - 1] = 0;
                    }
                    dwFriendlyUserNameSize = (wcslen(lpszFriendlyName) + 1) * sizeof(WCHAR);
                    dwXxxSize = pInfo[dwDeviceID].dwFriendlyUserNamesOffset;
                    pXxxNames = pUserNames[dwDeviceID].pFriendlyUserNames;

                    if (!(pNewXxxNames = ServerAlloc(
                            dwXxxSize + dwFriendlyUserNameSize
                            )))
                    {
                        lResult = LINEERR_NOMEM;
                        goto ExitHere;
                    }

                    CopyMemory(
                        pNewXxxNames,
                        lpszFriendlyName,
                        dwFriendlyUserNameSize
                        );

                    if (dwXxxSize)
                    {
                        CopyMemory(
                            ((LPBYTE) pNewXxxNames) + dwFriendlyUserNameSize,
                            pXxxNames,
                            dwXxxSize
                            );

                        ServerFree (pXxxNames);
                    }

                    pInfo[dwDeviceID].dwFriendlyUserNamesOffset +=
                        dwFriendlyUserNameSize;
                    pUserNames[dwDeviceID].pFriendlyUserNames = pNewXxxNames;
                }
            }
        }
    }

    //
    //
    //

    LOG((TL_INFO,
        "GetDeviceInfo: matching users to %ws",
        (bLine ? gszLines : gszPhones)
        ));

    for (i = 0; i < dwNumDevices; i++)
    {
        pInfo = ((LPDEVICEINFO)(pList + 1)) + i;

        if (InsertInfoListString(
                &pList,
                i,
                (DWORD) (((LPBYTE) &pInfo->dwDomainUserNamesSize) -
                    ((LPBYTE) pInfo)),
                pUserNames[i].pDomainUserNames,
                pInfo->dwDomainUserNamesOffset,
                TRUE
                ))
        {
            lResult = LINEERR_NOMEM;
            goto ExitHere;
        }

        pInfo = ((LPDEVICEINFO)(pList + 1)) + i;

        if (InsertInfoListString(
                &pList,
                i,
                (DWORD) (((LPBYTE) &pInfo->dwFriendlyUserNamesSize) -
                    ((LPBYTE) pInfo)),
                pUserNames[i].pFriendlyUserNames,
                pInfo->dwFriendlyUserNamesOffset,
                TRUE
                ))
        {
            lResult = LINEERR_NOMEM;
            goto ExitHere;
        }
    }


    //
    // If here we successfully built the list
    //

    pList->dwNeededSize = pList->dwUsedSize;

    if (bLine)
    {
        gpLineInfoList = pList;
        gpLineDevFlags = lpdwDevFlags;
        gdwNumFlags = dwNumDevices;
    }
    else
    {
        gpPhoneInfoList = pList;
    }

ExitHere:


    if (pUserNames != NULL)
    {
        for (i = 0; i < dwNumDevices; i++)
        {
            ServerFree (pUserNames[i].pDomainUserNames);
            ServerFree (pUserNames[i].pFriendlyUserNames);
        }
    }

    ServerFree (lpszDomainUser);
    ServerFree (lpszLineAnsiBuf);
    ServerFree (lpszLineWcharBuf);
    ServerFree (lpszFriendlyName);
    ServerFree (pUserNames);
    if (lResult)
    {
        ServerFree (pList);
        if (bLine)
        {
            ServerFree (lpdwDevFlags);
            gdwNumFlags = 0;
        }
    }

    if (hFileMap)
    {
        UnmapViewOfFile(lpszFileBuf);
        CloseHandle (hFileMap);
    }
    if (hIniFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle (hIniFile);
    }

    return lResult;
}

void
GetDeviceInfo(
    PMMCGETDEVICEINFO_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned,
    BOOL                        bLine
    )
{
    LONG                lResult = LINEERR_NOMEM;
    LPDEVICEINFOLIST    pXxxList,
                        pInfoListApp;

    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwDeviceInfoListTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        goto ExitHere;
    }


    if (pParams->dwDeviceInfoListTotalSize < sizeof (*pXxxList))
    {
        pParams->lResult = LINEERR_STRUCTURETOOSMALL;
        goto ExitHere;
    }

    //
    // If there's not an existing device info list then & build a
    // new one or
    // if this is a server and tsec.ini has been updated outside, rebuild the DeviceInfoList
    //

    pInfoListApp = (LPDEVICEINFOLIST) pDataBuf;

    EnterCriticalSection(&gMgmtCritSec);

    pXxxList = (bLine ? gpLineInfoList : gpPhoneInfoList);

    if ((TapiGlobals.dwFlags & TAPIGLOBALS_SERVER) && UpdateLastWriteTime(bLine) == S_FALSE || 
        pXxxList == NULL)
    {

        //  First free old infoList if any (if updated outside)
        if (bLine)
        {
            if (gpLineInfoList)
            {
                ServerFree (gpLineInfoList);
                gpLineInfoList = NULL;
                ServerFree (gpLineDevFlags);
                gpLineDevFlags = NULL;
                gdwNumFlags = 0;
            }
        }
        else
        {
            if (gpPhoneInfoList)
            {
                ServerFree (gpPhoneInfoList);
                gpPhoneInfoList = NULL;
            }
        }

        //  Create new info list, BuildDeviceInfoList is a long process
        pParams->lResult = BuildDeviceInfoList(bLine);
        if (pParams->lResult != S_OK)
        {
            LeaveCriticalSection(&gMgmtCritSec);
            goto ExitHere;
        }
    }

    //
    //  Return the device info list we have in memory
    //

    pXxxList = (bLine ? gpLineInfoList : gpPhoneInfoList);
    ASSERT (pXxxList != NULL);
    if (pParams->dwDeviceInfoListTotalSize < pXxxList->dwNeededSize)
    {
        pInfoListApp->dwNeededSize           = pXxxList->dwNeededSize;
        pInfoListApp->dwUsedSize             = sizeof (*pInfoListApp);
        pInfoListApp->dwNumDeviceInfoEntries =
        pInfoListApp->dwDeviceInfoSize       =
        pInfoListApp->dwDeviceInfoOffset     = 0;
    }
    else
    {
        CopyMemory(
            pInfoListApp,
            pXxxList,
            pXxxList->dwNeededSize
            );
    }

    pInfoListApp->dwTotalSize = pParams->dwDeviceInfoListTotalSize;

    pParams->dwDeviceInfoListOffset = 0;

    *pdwNumBytesReturned = sizeof (TAPI32_MSG) + pInfoListApp->dwUsedSize;

    pParams->lResult = 0;

    LeaveCriticalSection(&gMgmtCritSec);

ExitHere:
    return;
}

void StripUserInfo(LPDEVICEINFOLIST pDeviceInfoList)
{
    DWORD dwIdx;
    LPDEVICEINFO pDeviceInfo;

    if (!pDeviceInfoList)
        return;
    
    for (dwIdx = 0, pDeviceInfo = (LPDEVICEINFO)((BYTE*)pDeviceInfoList + pDeviceInfoList->dwDeviceInfoOffset); 
         dwIdx < pDeviceInfoList->dwNumDeviceInfoEntries; 
         dwIdx++, pDeviceInfo++)
    {
        if (pDeviceInfo->dwDomainUserNamesSize != 0)
        {
            ZeroMemory((BYTE *)pDeviceInfoList + pDeviceInfo->dwDomainUserNamesOffset, 
                pDeviceInfo->dwDomainUserNamesSize);
            pDeviceInfo->dwDomainUserNamesSize = 0;
        }
        if (pDeviceInfo->dwFriendlyUserNamesSize != 0)
        {
            ZeroMemory((BYTE *)pDeviceInfoList + pDeviceInfo->dwFriendlyUserNamesOffset, 
                pDeviceInfo->dwFriendlyUserNamesSize);
            pDeviceInfo->dwFriendlyUserNamesSize = 0;
        }
    }
}

void
WINAPI
MGetLineInfo(
    PTCLIENT                    ptClient,
    PMMCGETDEVICEINFO_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    GetDeviceInfo(
        pParams,
        dwParamsBufferSize,
        pDataBuf,
        pdwNumBytesReturned,
        TRUE
        );

    // Don't return User-Line association info if this is not an admin
    if (0 == pParams->lResult &&
        TapiGlobals.dwFlags & TAPIGLOBALS_SERVER && 
        !(ptClient->dwFlags & PTCLIENT_FLAG_ADMINISTRATOR))
    {
        StripUserInfo((LPDEVICEINFOLIST)pDataBuf);
    }
}


void
WINAPI
MGetPhoneInfo(
    PTCLIENT                    ptClient,
    PMMCGETDEVICEINFO_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    GetDeviceInfo(
        pParams,
        dwParamsBufferSize,
        pDataBuf,
        pdwNumBytesReturned,
        FALSE
        );

    // Don't return User-Phone association info if this is not an admin
    if (0 == pParams->lResult &&
        TapiGlobals.dwFlags & TAPIGLOBALS_SERVER && 
        !(ptClient->dwFlags & PTCLIENT_FLAG_ADMINISTRATOR))
    {
        StripUserInfo((LPDEVICEINFOLIST)pDataBuf);
    }
}


void
SetDeviceInfo(
    PMMCSETDEVICEINFO_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned,
    BOOL                        bLine
    )
{
    DWORD              i;
    WCHAR              *pDomainUserName, *pDomainUserNames,
                       *pFriendlyUserName, *pFriendlyUserNames;
    LPDEVICEINFO       pOldInfo, pNewInfo;
    LPDEVICEINFOLIST   pNewInfoList = (LPDEVICEINFOLIST) (pDataBuf +
                           pParams->dwDeviceInfoListOffset),
                       *ppXxxList = (bLine ?
                           &gpLineInfoList : &gpPhoneInfoList);


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (IsBadStructParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwDeviceInfoListOffset
            ))
    {
        pParams->lResult = PHONEERR_OPERATIONFAILED;
        return;
    }


    //
    // Serialize access to global line info list
    //

    if (!(*ppXxxList))
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        goto exit;
    }


    //
    // Update the global list & ini file by diff'ing old & new settings
    //

    pNewInfo = (LPDEVICEINFO)
        (((LPBYTE) pNewInfoList) + pNewInfoList->dwDeviceInfoOffset);

    for (i = 0; i < pNewInfoList->dwNumDeviceInfoEntries; i++, pNewInfo++)
    {
        DWORD           dwDeviceID;
        DWORD           dwIndex;
        TAPIPERMANENTID tpid;


        tpid.dwProviderID = pNewInfo->dwProviderID;
        tpid.dwDeviceID   = pNewInfo->dwPermanentDeviceID;

        dwDeviceID = GetDeviceIDFromPermanentID (tpid, bLine);

        if (dwDeviceID == 0xffffffff)
        {
            LOG((TL_ERROR,
                "SetDeviceInfo: bad provider/device IDs (x%x/x%x)",
                pNewInfo->dwProviderID,
                pNewInfo->dwPermanentDeviceID
                ));

            continue;
        }

        pOldInfo = dwDeviceID + ((LPDEVICEINFO) (*ppXxxList + 1));

        //
        //  Due to device removal, it is possible pOldInfo is not the entry
        //  desired, we need to search back to find the one we want
        //
        dwIndex = dwDeviceID;
        if ((dwDeviceID >= (*ppXxxList)->dwNumDeviceInfoEntries) ||
            (pOldInfo->dwProviderID != tpid.dwProviderID) ||
            (pOldInfo->dwPermanentDeviceID != tpid.dwDeviceID))
        {
            LPDEVICEINFO    pInfoFirst = (LPDEVICEINFO)(*ppXxxList + 1);
            DWORD dwLastSchDevice = 
                    ((*ppXxxList)->dwNumDeviceInfoEntries <= dwDeviceID)?
                        ((*ppXxxList)->dwNumDeviceInfoEntries - 1) : 
                        (dwDeviceID - 1);
            LPDEVICEINFO    pInfo = pInfoFirst + dwLastSchDevice;
            
            while (pInfo >= pInfoFirst && 
                    ((pInfo->dwProviderID != tpid.dwProviderID) ||
                     (pInfo->dwPermanentDeviceID != tpid.dwDeviceID)))
            {
                --pInfo;
            }
            if (pInfo < pInfoFirst)
            {
                LOG((TL_ERROR,
                    "SetDeviceInfo: bad provider/device IDs (x%x/x%x)",
                    pNewInfo->dwProviderID,
                    pNewInfo->dwPermanentDeviceID
                    ));

                continue;
            }
            pOldInfo = pInfo;
            dwIndex = (DWORD)(ULONG_PTR)(pInfo - pInfoFirst);
        }


        //
        // Remove all the old users from this device
        //

        if (pOldInfo->dwDomainUserNamesSize)
        {
            pDomainUserName = (WCHAR *) (((LPBYTE) *ppXxxList) +
                pOldInfo->dwDomainUserNamesOffset);

            while (*pDomainUserName != L'\0')
            {
                ChangeDeviceUserAssociation(
                    pDomainUserName,
                    NULL,
                    pOldInfo->dwProviderID,
                    pOldInfo->dwPermanentDeviceID,
                    bLine
                    );

                pDomainUserName += wcslen (pDomainUserName) + 1;
            }

            pOldInfo->dwDomainUserNamesSize = 0;
            pOldInfo->dwFriendlyUserNamesSize = 0;
        }


        //
        // Add all the new users to this device
        //

        if (pNewInfo->dwDomainUserNamesSize)
        {
            pDomainUserName =
            pDomainUserNames = (WCHAR *) (((LPBYTE) pNewInfoList) +
                pNewInfo->dwDomainUserNamesOffset);

            pFriendlyUserName =
            pFriendlyUserNames = (WCHAR *) (((LPBYTE) pNewInfoList) +
                pNewInfo->dwFriendlyUserNamesOffset);

            while (*pDomainUserName != L'\0')
            {
                ChangeDeviceUserAssociation(
                    pDomainUserName,
                    pFriendlyUserName,
                    pOldInfo->dwProviderID,
                    pOldInfo->dwPermanentDeviceID,
                    bLine
                    );

                pDomainUserName += wcslen (pDomainUserName) + 1;
                pFriendlyUserName += wcslen (pFriendlyUserName) + 1;
            }

            if (InsertInfoListString(
                    ppXxxList,
                    dwIndex,
                    (DWORD) (((LPBYTE) &pNewInfo->dwDomainUserNamesSize) -
                        ((LPBYTE) pNewInfo)),
                    pDomainUserNames,
                    pNewInfo->dwDomainUserNamesSize,
                    FALSE
                    ))
            {
            }

            if (InsertInfoListString(
                    ppXxxList,
                    dwIndex,
                    (DWORD) (((LPBYTE) &pNewInfo->dwFriendlyUserNamesSize) -
                        ((LPBYTE) pNewInfo)),
                    pFriendlyUserNames,
                    pNewInfo->dwFriendlyUserNamesSize,
                    FALSE
                    ))
            {
            }
        }

        //
        //  Update the device access(phone/line mapping) for the client users
        //  send LINE/PHONE_REMOVE if the domain/user lose the access
        //  send LINE/PHONE_CREATE if the domain/user gained the access
        //
        {
            TPOINTERLIST    clientList = {0}, *pClientList = &clientList;
            DWORD           i, j;

            //
            //  Walk throught the client list
            //
            GetClientList (FALSE, &pClientList);
            for (i = 0; i < pClientList->dwNumUsedEntries; i++)
            {
                PTCLIENT        ptClient;
                BOOL            bHaveAccess = FALSE;
                BOOL            bGainAccess = FALSE;
                BOOL            bLoseAccess = FALSE;
                BOOL            bSendMessage = FALSE;
                WCHAR *         pwsz = NULL;
                WCHAR           wszBuf[255];
                DWORD           dw, dwNewDeviceID;

                ptClient = (PTCLIENT) pClientList->aEntries[i];

                //
                //  Should this client have access to this device?
                //
                if (WaitForExclusiveClientAccess(ptClient))
                {
                    if (IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR) ||
                        ptClient->pszDomainName == NULL ||
                        ptClient->pszUserName == NULL)
                    {
                        UNLOCKTCLIENT (ptClient);
                        continue;
                    }
                    
                    dw = wcslen (ptClient->pszDomainName) +
                        wcslen (ptClient->pszUserName) + 2;
                    dw *= sizeof(WCHAR);
                    if (dw > sizeof (wszBuf))
                    {
                        pwsz = ServerAlloc (dw);
                        if (pwsz == NULL)
                        {
                            UNLOCKTCLIENT (ptClient);
                            continue;
                        }
                    }
                    else
                    {
                        pwsz = wszBuf;
                    }
                    wcscpy (pwsz, ptClient->pszDomainName);
                    wcscat (pwsz, L"\\");
                    wcscat (pwsz, ptClient->pszUserName);
                    UNLOCKTCLIENT (ptClient);
                }
                else
                {
                    continue;
                }
                
                pDomainUserName = (WCHAR *) (((LPBYTE) pNewInfoList) +
                    pNewInfo->dwDomainUserNamesOffset);
                while (*pDomainUserName != L'\0')
                {
                    if (lstrcmpiW (pwsz, pDomainUserName) == 0)
                    {
                        bHaveAccess = TRUE;
                        break;
                    }
                    pDomainUserName += wcslen (pDomainUserName) + 1;
                }
                if (pwsz != wszBuf)
                {
                    ServerFree (pwsz);
                }

                //
                //  Does the client lose/gain the access to this device
                //  if any changes happen, modify the mapping
                //
                if (WaitForExclusiveClientAccess(ptClient))
                {
                    LPDWORD             lpXxxDevices;
                    LPTAPIPERMANENTID   lpXxxMap;
                    DWORD               dwNumDev;

                    if (bLine)
                    {
                        dwNumDev = ptClient->dwLineDevices;
                        lpXxxMap = ptClient->pLineMap;
                        lpXxxDevices = ptClient->pLineDevices;
                    }
                    else
                    {
                        dwNumDev = ptClient->dwPhoneDevices;
                        lpXxxMap = ptClient->pPhoneMap;
                        lpXxxDevices = ptClient->pPhoneDevices;
                    }

                    for (j = 0; j < dwNumDev; ++ j)
                    {
                        if (lpXxxDevices[j] == dwDeviceID)
                        {
                            bLoseAccess = (!bHaveAccess);
                            break;
                        }
                    }
                    if (j == dwNumDev)
                    {
                        bGainAccess = bHaveAccess;
                    }

                    if (bLoseAccess)
                    {
                        lpXxxDevices[j] = 0xffffffff;
                        lpXxxMap[j].dwDeviceID = 0xffffffff;
                        dwNewDeviceID = j;
                    }

                    if (bGainAccess)
                    {
                        LPTAPIPERMANENTID   lpNewXxxMap;
                        LPDWORD             lpNewDevices = NULL;

                        if (lpNewXxxMap = ServerAlloc (
                            sizeof(TAPIPERMANENTID) * (dwNumDev + 1)))
                        {
                            if (lpNewDevices = ServerAlloc (
                                sizeof(DWORD) * (dwNumDev + 1)))
                            {
                                if (dwNumDev != 0)
                                {
                                    memcpy (
                                        lpNewXxxMap,
                                        lpXxxMap,
                                        sizeof (TAPIPERMANENTID) * dwNumDev
                                        );
                                    memcpy (
                                        lpNewDevices,
                                        lpXxxDevices,
                                        sizeof (DWORD) * dwNumDev
                                        );
                                }
                                lpNewDevices[dwNumDev] = dwDeviceID;
                                lpNewXxxMap[dwNumDev] = tpid;
                                ++ dwNumDev;
                            }
                            else
                            {
                                ServerFree (lpNewXxxMap);
                                UNLOCKTCLIENT (ptClient);
                                continue;
                            }
                        }
                        else
                        {
                            UNLOCKTCLIENT(ptClient);
                            continue;
                        }
                        if (bLine)
                        {
                            ptClient->dwLineDevices = dwNumDev;
                            ServerFree (ptClient->pLineDevices);
                            ptClient->pLineDevices = lpNewDevices;
                            ServerFree (ptClient->pLineMap);
                            ptClient->pLineMap = lpNewXxxMap;
                        }
                        else
                        {
                            ptClient->dwPhoneDevices = dwNumDev;
                            ServerFree (ptClient->pPhoneDevices);
                            ptClient->pPhoneDevices = lpNewDevices;
                            ServerFree (ptClient->pPhoneMap);
                            ptClient->pPhoneMap = lpNewXxxMap;
                        }

                        dwNewDeviceID = dwNumDev - 1;
                    }
                    
                    //
                    //  Need to send messsage if there is 
                    //  any line/phoneInitialize(Ex)
                    //
                    if ((ptClient->ptLineApps && bLine) || 
                        (ptClient->ptPhoneApps && (!bLine)))
                    {
                        if (bLoseAccess || bGainAccess)
                        {
                            bSendMessage = TRUE;
                        }
                    }
                    
                    UNLOCKTCLIENT (ptClient);
                }
                else
                {
                    continue;
                }
                
                if (bSendMessage)
                {
                    ASYNCEVENTMSG   msg;
                    TPOINTERLIST    xxxAppList = {0}, 
                        *pXxxAppList = &xxxAppList;

                    msg.TotalSize          = sizeof (ASYNCEVENTMSG);
                    msg.fnPostProcessProcHandle = 0;
                    msg.Msg                = (bLine ? 
                        (bLoseAccess? LINE_REMOVE : LINE_CREATE) :
                        (bLoseAccess? PHONE_REMOVE: PHONE_CREATE));
                    msg.Param1             = dwNewDeviceID;

                    if (bLine)
                    {
                        GetLineAppListFromClient (ptClient, &pXxxAppList);
                    }
                    else
                    {
                        GetPhoneAppListFromClient (ptClient, &pXxxAppList);
                    }

                    for (i = 0; i < pXxxAppList->dwNumUsedEntries; ++i)
                    {
                        BOOL    b;

                        try
                        {
                            if (bLine)
                            {
                                PTLINEAPP ptLineApp = 
                                    (PTLINEAPP) pXxxAppList->aEntries[i];

                                b = FMsgDisabled (
                                    ptLineApp->dwAPIVersion,
                                    ptLineApp->adwEventSubMasks,
                                    (DWORD) msg.Msg,
                                    (DWORD) msg.Param1
                                    );
                                msg.InitContext = ptLineApp->InitContext;
                            }
                            else
                            {
                                PTPHONEAPP ptPhoneApp = 
                                    (PTPHONEAPP) pXxxAppList->aEntries[i];

                                b = FMsgDisabled (
                                    ptPhoneApp->dwAPIVersion,
                                    ptPhoneApp->adwEventSubMasks,
                                    (DWORD) msg.Msg,
                                    (DWORD) msg.Param1
                                    );
                                msg.InitContext = ptPhoneApp->InitContext;
                            }
                        }
                        myexcept
                        {
                            continue;
                        }
                        if (b)
                        {
                            continue;
                        }
                        
                        WriteEventBuffer (ptClient, &msg);
                    }

                    if (pXxxAppList != &xxxAppList)
                    {
                        ServerFree (pXxxAppList);
                    }
                }
                
                //
                //  If the user loses the device access, anything
                //  opened about the device needs to be closed
                //
                if (bLoseAccess)
                {
                    //
                    //  Walk throught all its TLINEAPP
                    //
                    if (bLine)
                    {
                        PTLINELOOKUPENTRY   ptLineLookup;
                        PTLINE              ptLine;
                        PTLINECLIENT        ptLineClient, pNextLineClient;
                        HANDLE              hMutex;
                        BOOL                bDupedMutex;
                        
                        ptLineLookup = GetLineLookupEntry(dwDeviceID);
                        if (!ptLineLookup || !(ptLine = ptLineLookup->ptLine));
                        {
                            continue;
                        }
                        if (!WaitForExclusivetLineAccess(
                            ptLine, 
                            &hMutex, 
                            &bDupedMutex,
                            INFINITE
                            ))
                        {
                            continue;
                        }
                        ptLineClient = ptLine->ptLineClients;
                        while (ptLineClient)
                        {
                            if (WaitForExclusiveLineClientAccess(ptLineClient))
                            {
                                pNextLineClient = ptLineClient->pNextSametLine;
                                
                                if (ptLineClient->ptClient == ptClient)
                                {
                                    HLINE       hLine = ptLineClient->hLine;
                                    UNLOCKTLINECLIENT (ptLineClient);
                                    DestroytLineClient(ptLineClient->hLine);
                                }
                                else
                                {
                                    UNLOCKTLINECLIENT (ptLineClient);
                                }

                                ptLineClient = pNextLineClient;
                            }
                            else
                            {
                                break;
                            }
                        }
                        MyReleaseMutex(hMutex, bDupedMutex);
                    }

                    //
                    //  Walk throught all its TPHONEAPP
                    //
                    else
                    {
                        PTPHONELOOKUPENTRY   ptPhoneLookup;
                        PTPHONE              ptPhone;
                        PTPHONECLIENT        ptPhoneClient, pNextPhoneClient;
                        HANDLE               hMutex;
                        BOOL                 bDupedMutex;
                        
                        ptPhoneLookup = GetPhoneLookupEntry(dwDeviceID);
                        if (!ptPhoneLookup || !(ptPhone = ptPhoneLookup->ptPhone));
                        {
                            continue;
                        }
                        if (!WaitForExclusivetPhoneAccess(
                            ptPhone,
                            &hMutex,
                            &bDupedMutex,
                            INFINITE
                            ))
                        {
                            continue;
                        }
                        ptPhoneClient = ptPhone->ptPhoneClients;
                        while (ptPhoneClient)
                        {
                            if (WaitForExclusivePhoneClientAccess(ptPhoneClient))
                            {
                                pNextPhoneClient = ptPhoneClient->pNextSametPhone;
                                
                                if (ptPhoneClient->ptClient == ptClient)
                                {
                                    HPHONE       hPhone = ptPhoneClient->hPhone;
                                    UNLOCKTPHONECLIENT (ptPhoneClient);
                                    DestroytPhoneClient(ptPhoneClient->hPhone);
                                }
                                else
                                {
                                    UNLOCKTPHONECLIENT (ptPhoneClient);
                                }

                                ptPhoneClient = pNextPhoneClient;
                            }
                            else
                            {
                                break;
                            }
                        }
                        MyReleaseMutex (hMutex, bDupedMutex);
                    }
                }
            }
            
            if (pClientList != &clientList)
            {
                ServerFree (pClientList);
            }
        }
    }


    //
    // Reset the dwNeededSize field since it might have grown adding
    // users to devices
    //

    (*ppXxxList)->dwNeededSize = (*ppXxxList)->dwUsedSize;


exit:

    return;
}


void
WINAPI
MSetLineInfo(
    PTCLIENT                    ptClient,
    PMMCSETDEVICEINFO_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bDidLock;

    if (NULL == ptClient || !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
    {
        pParams->lResult = TAPIERR_NOTADMIN;
        return;
    }

    if (WaitForExclusiveClientAccess(ptClient))
    {
        bDidLock = 
            IS_FLAG_SET (ptClient->dwFlags, PTCLIENT_FLAG_LOCKEDMMCWRITE);
        UNLOCKTCLIENT (ptClient);
    }
    else
    {
        bDidLock = FALSE;
    }

    EnterCriticalSection (&gMgmtCritSec);

    if (gbLockMMCWrite && !bDidLock)
    {
        pParams->lResult = TAPIERR_MMCWRITELOCKED;
    }
    else
    {
        SetDeviceInfo(
            pParams,
            dwParamsBufferSize,
            pDataBuf,
            pdwNumBytesReturned,
            TRUE
            );
        UpdateLastWriteTime(TRUE);
    }

    LeaveCriticalSection (&gMgmtCritSec);

}


void
WINAPI
MSetPhoneInfo(
    PTCLIENT                    ptClient,
    PMMCSETDEVICEINFO_PARAMS    pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    BOOL            bDidLock;

    if (NULL == ptClient || !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
    {
        pParams->lResult = TAPIERR_NOTADMIN;
        return;
    }

    if (WaitForExclusiveClientAccess(ptClient))
    {
        bDidLock = 
            IS_FLAG_SET (ptClient->dwFlags, PTCLIENT_FLAG_LOCKEDMMCWRITE);
        UNLOCKTCLIENT (ptClient);
    }
    else
    {
        bDidLock = FALSE;
    }

    EnterCriticalSection (&gMgmtCritSec);

    if (gbLockMMCWrite && !bDidLock)
    {
        pParams->lResult = TAPIERR_MMCWRITELOCKED;
    }
    else
    {
        SetDeviceInfo(
            pParams,
            dwParamsBufferSize,
            pDataBuf,
            pdwNumBytesReturned,
            FALSE
            );
        UpdateLastWriteTime(FALSE);
    }

    LeaveCriticalSection (&gMgmtCritSec);
}


VOID
PASCAL
InsertString(
    LPVOID      pStruct,
    LPDWORD     pdwXxxSize,
    LPWSTR      pString
    )
{
    DWORD   dwSize = (wcslen (pString) + 1) * sizeof (WCHAR);


    CopyMemory(
        ((LPBYTE) pStruct) + ((LPVARSTRING) pStruct)->dwUsedSize,
        pString,
        dwSize
        );

    if (*pdwXxxSize == 0) // if dwXxxSize == 0 set dwXxxOffset
    {
        *(pdwXxxSize + 1) = ((LPVARSTRING) pStruct)->dwUsedSize;
    }

    ((LPVARSTRING) pStruct)->dwUsedSize += dwSize;

    *pdwXxxSize += dwSize;
}


LONG
PASCAL
GetDomainAndUserNames(
    WCHAR **ppDomainName,
    WCHAR **ppUserName
    )
{
    LONG            lResult = LINEERR_OPERATIONFAILED;
    DWORD           dwInfoBufferSize, dwSize, dwAccountNameSize,
                        dwDomainNameSize;
    HANDLE          hAccessToken;
    LPWSTR          InfoBuffer, lpszAccountName, lpszDomainName;
    PTOKEN_USER     ptuUser;
    SID_NAME_USE    use;


    if (!OpenProcessToken (GetCurrentProcess(), TOKEN_READ, &hAccessToken))
    {
        LOG((TL_ERROR,
            "GetAccountInfo: OpenThreadToken failed, error=%d",
            GetLastError()
            ));

        goto GetDomainAndUserNames_return;
    }

    dwSize = 1000;
    dwInfoBufferSize = 0;
    InfoBuffer = (LPWSTR) ServerAlloc (dwSize);
    if (!InfoBuffer)
    {
        CloseHandle (hAccessToken);
        return LINEERR_NOMEM;
    }

    ptuUser = (PTOKEN_USER) InfoBuffer;

    if (!GetTokenInformation(
            hAccessToken,
            TokenUser,
            InfoBuffer,
            dwSize,
            &dwInfoBufferSize
            ))
    {
        LOG((TL_ERROR,
            "GetAccountInfo: GetTokenInformation failed, error=%d",
            GetLastError()
            ));

        goto close_AccessToken;
    }

    if (!(lpszAccountName = ServerAlloc (200)))
    {
        lResult = LINEERR_NOMEM;
        goto free_InfoBuffer;
    }

    if (!(lpszDomainName = ServerAlloc (200)))
    {
        lResult = LINEERR_NOMEM;
        goto free_AccountName;
    }

    dwAccountNameSize = dwDomainNameSize = 200;

    if (!LookupAccountSidW(
            NULL,
            ptuUser->User.Sid,
            lpszAccountName,
            &dwAccountNameSize,
            lpszDomainName,
            &dwDomainNameSize,
            &use
            ))
    {
        LOG((TL_ERROR,
            "GetAccountInfo: LookupAccountSidW failed, error=%d",
            GetLastError()
            ));
    }
    else
    {
        LOG((TL_INFO,
            "GetAccountInfo: User name %ls Domain name %ls",
            lpszAccountName,
            lpszDomainName
            ));

        lResult = 0;

        *ppDomainName = lpszDomainName;
        *ppUserName = lpszAccountName;

        goto free_InfoBuffer;
    }

    ServerFree (lpszDomainName);

free_AccountName:

    ServerFree (lpszAccountName);

free_InfoBuffer:

    ServerFree (InfoBuffer);

close_AccessToken:

    CloseHandle (hAccessToken);

GetDomainAndUserNames_return:

    return lResult;
}


BOOL
IsNTServer(
    void
    )
{
    BOOL    bResult = FALSE;
    TCHAR   szProductType[64];
    HKEY    hKey;
    DWORD   dwDataSize;
    DWORD   dwDataType;


    if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            gszRegKeyNTServer,
            0,
            KEY_QUERY_VALUE,
            &hKey

            ) == ERROR_SUCCESS)
    {
        dwDataSize = 64*sizeof(TCHAR);

        if (RegQueryValueEx(
                hKey,
                gszProductType,
                0,
                &dwDataType,
                (LPBYTE) szProductType,
                &dwDataSize

                )  == ERROR_SUCCESS)


        if ((!lstrcmpi (szProductType, gszProductTypeServer))  ||
            (!lstrcmpi (szProductType, gszProductTypeLanmanNt)))
        {
            bResult = TRUE;
        }

        RegCloseKey (hKey);
    }

    return bResult;
}


BOOL
IsSharingEnabled(
    void
    )
{
    HKEY    hKey;
    BOOL    bResult = FALSE;
    DWORD   dwType, dwDisableSharing;


    if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony\\Server"),
            0,
            KEY_ALL_ACCESS,
            &hKey

            ) == ERROR_SUCCESS)
    {
        DWORD   dwSize = sizeof (dwDisableSharing);


        dwDisableSharing = 1;   // default is sharing == disabled

        if (RegQueryValueEx(
                hKey,
                TEXT("DisableSharing"),
                0,
                &dwType,
                (LPBYTE) &dwDisableSharing,
                &dwSize

                ) == ERROR_SUCCESS)
        {
            bResult = (dwDisableSharing ? FALSE : TRUE);
        }

        RegCloseKey (hKey);
    }

    return bResult;
}


void
WINAPI
MGetServerConfig(
    PTCLIENT                    ptClient,
    PMMCGETSERVERCONFIG_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    LONG                lResult;
    DWORD               dwDomainNameSize, dwUserNameSize, dwValuesSize,
                        dwResult, dwNeededSize;
    WCHAR              *pValues = NULL, *pValue;
    LPWSTR              pDomainName, pUserName;
    LPTAPISERVERCONFIG  pServerConfig = (LPTAPISERVERCONFIG) pDataBuf;


    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (pParams->dwServerConfigTotalSize > dwParamsBufferSize)
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    //
    // Make sure the buffer is >= fixed size of the structure
    //

    if (pParams->dwServerConfigTotalSize < sizeof (*pServerConfig))
    {
        pParams->lResult = LINEERR_STRUCTURETOOSMALL;
        return;
    }

    pServerConfig->dwTotalSize = pParams->dwServerConfigTotalSize;


    //
    // If this is not an NT server then just set the needed/used size
    // fields & jump to done
    //

    if (!IsNTServer())
    {
        pServerConfig->dwNeededSize =
        pServerConfig->dwUsedSize   = sizeof (*pServerConfig);

        goto MGetServerConfig_done;
    }


    //
    // Retrieve domain & user name strings, & calc their length in bytes
    //

    if ((lResult = GetDomainAndUserNames (&pDomainName, &pUserName)))
    {
        pParams->lResult = lResult;
        return;
    }

    dwDomainNameSize = (wcslen (pDomainName) + 1) * sizeof (WCHAR);
    dwUserNameSize = (wcslen (pUserName) + 1) * sizeof (WCHAR);


    //
    // Retrieve the list of tapi administrators
    //

    do
    {
        if  (pValues)
        {
            ServerFree (pValues);

            dwValuesSize *= 2;
        }
        else
        {
            dwValuesSize = 256;
        }

        if (!(pValues = ServerAlloc (dwValuesSize * sizeof (WCHAR))))
        {
            pParams->lResult = LINEERR_NOMEM;
            goto MGetServerConfig_freeNames;
        }

        pValues[0] = L'\0';

        dwResult = GetPrivateProfileSectionW(
            gszTapiAdministrators,
            pValues,
            dwValuesSize,
            gszFileName
            );

    } while (dwResult >= (dwValuesSize - 2));

    dwNeededSize = dwDomainNameSize + dwUserNameSize + dwValuesSize * sizeof (WCHAR);


    //
    // Fill in the server config structure
    //

    ZeroMemory(
        &pServerConfig->dwFlags,
        sizeof (*pServerConfig) - (3 * sizeof (DWORD))
        );

    pServerConfig->dwFlags |= TAPISERVERCONFIGFLAGS_ISSERVER;

    if (IsSharingEnabled())
    {
        pServerConfig->dwFlags |= TAPISERVERCONFIGFLAGS_ENABLESERVER;
    }

    if (pServerConfig->dwTotalSize < dwNeededSize)
    {
        pServerConfig->dwNeededSize = dwNeededSize;
        pServerConfig->dwUsedSize   = sizeof (*pServerConfig);
    }
    else
    {
        pServerConfig->dwUsedSize = sizeof (*pServerConfig);

        InsertString(
            pServerConfig,
            &pServerConfig->dwDomainNameSize,
            pDomainName
            );

        InsertString(
            pServerConfig,
            &pServerConfig->dwUserNameSize,
            pUserName
            );

        pValue = pValues;

        while (*pValue != L'\0')
        {
            //
            // The string looks like "Domain\User=1", and we want
            // the "Domain\User" part.
            //

            //
            // Walk the string until we find a '=' char, or ' ' space
            // (which might result from user editing ini file manually),
            // or a NULL char (implying corruption).
            //

            WCHAR *p;


            for (p = pValue; *p != L'\0' &&  *p != L'='  &&  *p != L' '; p++);


            //
            // If we found a '=' or ' ' char then we're good to go.
            //
            // A more robust check would be to see that the following
            // string looks like "=1" or "1" (possibly with some spaces
            // thrown in) to make sure.
            //

            if (*p != L'\0')
            {
                *p = L'\0';

                InsertString(
                    pServerConfig,
                    &pServerConfig->dwAdministratorsSize,
                    pValue
                    );

                //
                // Skip the NULL we set above & look for the next NULL
                //

                for (++p; *p != L'\0'; p++);
            }


            //
            // Skip the NULL
            //

            pValue = p + 1;
        }

        if (pServerConfig->dwAdministratorsSize)
        {
            InsertString(
                pServerConfig,
                &pServerConfig->dwAdministratorsSize,
                gszEmptyString
                );
        }

        pServerConfig->dwNeededSize = pServerConfig->dwUsedSize;
    }

    ServerFree (pValues);

MGetServerConfig_freeNames:

    ServerFree (pDomainName);
    ServerFree (pUserName);

MGetServerConfig_done:

    if (pParams->lResult == 0)
    {
        pParams->dwServerConfigOffset = 0;

        *pdwNumBytesReturned = sizeof (TAPI32_MSG) +
            pServerConfig->dwUsedSize;
    }
}


LONG
PASCAL
WriteRegistryKeys(
    LPTSTR  lpszMapper,
    LPTSTR  lpszDlls,
    DWORD   dwDisableSharing
    )
{
    LONG    lResult = LINEERR_OPERATIONFAILED;
    HKEY    hKeyTelephony, hKey;
    DWORD   dw;


    if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Telephony"),
            0,
            KEY_ALL_ACCESS,
            &hKeyTelephony

            ) == ERROR_SUCCESS)
    {
        if (RegCreateKeyEx(
                hKeyTelephony,
                TEXT("Server"),
                0,
                NULL,
                REG_OPTION_NON_VOLATILE,
                KEY_ALL_ACCESS,
                NULL,
                &hKey,
                &dw

                ) == ERROR_SUCCESS)
        {
            if (RegSetValueEx(
                    hKey,
                    TEXT("DisableSharing"),
                    0,
                    REG_DWORD,
                    (LPBYTE) &dwDisableSharing,
                    sizeof (dwDisableSharing)

                    ) == ERROR_SUCCESS  &&

                RegSetValueEx(
                    hKey,
                    TEXT("MapperDll"),
                    0,
                    REG_SZ,
                    (LPBYTE) TEXT ("TSEC.DLL"),
                    (lstrlen (TEXT ("TSEC.DLL")) + 1) * sizeof (TCHAR)

                    ) == ERROR_SUCCESS)
            {
                lResult = 0;
            }

            RegCloseKey (hKey);
        }

        RegCloseKey (hKeyTelephony);
    }

    return lResult;
}


LONG
PASCAL
WriteServiceConfig(
    LPWSTR  pDomainName,
    LPWSTR  pUserName,
    LPWSTR  pPassword,
    BOOL    bServer
    )
{
    LONG       lResult = LINEERR_OPERATIONFAILED;
    SC_HANDLE  sch, sc_tapisrv;


    if ((sch = OpenSCManager (NULL, NULL, SC_MANAGER_ENUMERATE_SERVICE)))
    {
        if ((sc_tapisrv = OpenService(
                sch,
                TEXT("TAPISRV"),
                SERVICE_CHANGE_CONFIG
                )))
        {
            DWORD   dwSize;
            WCHAR  *pDomainUserName;


            dwSize = (wcslen (pDomainName) + wcslen (pUserName) + 2) *\
                sizeof (WCHAR);

            if ((pDomainUserName = ServerAlloc (dwSize)))
            {
                wcscpy (pDomainUserName, pDomainName);
                wcscat (pDomainUserName, L"\\");
                wcscat (pDomainUserName, pUserName);

                if ((ChangeServiceConfigW(
                        sc_tapisrv,
                        SERVICE_WIN32_OWN_PROCESS,
                        bServer ? SERVICE_AUTO_START : SERVICE_DEMAND_START,
                        SERVICE_NO_CHANGE,
                        NULL,
                        NULL,
                        NULL,
                        NULL,
                        pDomainUserName,
                        pPassword,
                        NULL
                        )))
                {
                    lResult = 0;
                }
                else
                {
                    LOG((TL_ERROR,
                        "WriteServiceConfig: ChangeServiceConfig " \
                            "failed, err=%ld",
                        GetLastError()
                        ));
                }

                ServerFree (pDomainUserName);
            }
            else
            {
                lResult = LINEERR_NOMEM;
            }

            CloseServiceHandle(sc_tapisrv);
        }

        CloseServiceHandle(sch);
    }

    return lResult;
}


void
WINAPI
MSetServerConfig(
    PTCLIENT                    ptClient,
    PMMCSETSERVERCONFIG_PARAMS  pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    LONG                lResult;
    BOOL                bIsSharingEnabled;
    LPTAPISERVERCONFIG  pServerConfig = (LPTAPISERVERCONFIG)
                            (pDataBuf + pParams->dwServerConfigOffset);

   
    if (NULL == ptClient || !IS_FLAG_SET(ptClient->dwFlags, PTCLIENT_FLAG_ADMINISTRATOR))
    {
        pParams->lResult = TAPIERR_NOTADMIN;
        return;
    }

    pParams->lResult = 0;

    //
    // Verify size/offset/string params given our input buffer/size
    //

    if (IsBadStructParam(
            dwParamsBufferSize,
            pDataBuf,
            pParams->dwServerConfigOffset
            ))
    {
        pParams->lResult = PHONEERR_OPERATIONFAILED;
        return;
    }


    if (!IsNTServer())
    {
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }

    bIsSharingEnabled = IsSharingEnabled();
    LOG((TL_TRACE, "MSetServerConfig: sharing enabled: %d", bIsSharingEnabled));

    if (pServerConfig->dwFlags & TAPISERVERCONFIGFLAGS_LOCKMMCWRITE)
    {
        EnterCriticalSection (&gMgmtCritSec);
        if (gbLockMMCWrite)
        {
            pParams->lResult = TAPIERR_MMCWRITELOCKED;
        }
        else
        {
            gbLockMMCWrite = TRUE;
        }
        LeaveCriticalSection (&gMgmtCritSec);
        if (pParams->lResult)
        {
            return;
        }
        else if (WaitForExclusiveClientAccess (ptClient))
        {
            SET_FLAG (ptClient->dwFlags, PTCLIENT_FLAG_LOCKEDMMCWRITE);
            UNLOCKTCLIENT (ptClient);
        }
    }

    if (pServerConfig->dwFlags & TAPISERVERCONFIGFLAGS_UNLOCKMMCWRITE &&
        WaitForExclusiveClientAccess (ptClient))
    {   
        BOOL        bToUnlock;

        bToUnlock = 
            IS_FLAG_SET (ptClient->dwFlags, PTCLIENT_FLAG_LOCKEDMMCWRITE);
        RESET_FLAG (ptClient->dwFlags, PTCLIENT_FLAG_LOCKEDMMCWRITE);
        UNLOCKTCLIENT (ptClient);

        if (bToUnlock)
        {
            EnterCriticalSection (&gMgmtCritSec);
            gbLockMMCWrite = FALSE;
            LeaveCriticalSection (&gMgmtCritSec);
        }
    }

    if (pServerConfig->dwFlags & TAPISERVERCONFIGFLAGS_SETACCOUNT)
    {
        HANDLE  hToken;
        LPWSTR  pUserName, pDomainName, pPassword;


        pUserName = (LPWSTR)
            (((LPBYTE) pServerConfig) + pServerConfig->dwUserNameOffset);

        pDomainName = (LPWSTR)
            (((LPBYTE) pServerConfig) + pServerConfig->dwDomainNameOffset);

        pPassword = (LPWSTR)
            (((LPBYTE) pServerConfig) + pServerConfig->dwPasswordOffset);


        //
        // Make sure the new name/domain/password are valid
        //

        if (!LogonUserW(
                pUserName,
                pDomainName,
                pPassword,
                LOGON32_LOGON_NETWORK,
                LOGON32_PROVIDER_DEFAULT,
                &hToken
                ))
        {
            LOG((TL_ERROR,
                "MSetServerConfig: LogonUser failed, err=%ld",
                GetLastError()
                ));

            pParams->lResult = ERROR_LOGON_FAILURE;
            return;
        }

        CloseHandle (hToken);


        //
        //
        //

        if ((lResult = WriteServiceConfig(
                pDomainName,
                pUserName,
                pPassword,
                (pServerConfig->dwFlags & TAPISERVERCONFIGFLAGS_ENABLESERVER)
                )))
        {
            LOG((TL_ERROR,
                "MSetServerConfig: WriteServiceConfig failed, err=%ld",
                lResult
                ));

            pParams->lResult = lResult;
            return;
        }
    }

    if (pServerConfig->dwFlags & TAPISERVERCONFIGFLAGS_ENABLESERVER &&
        !bIsSharingEnabled)
    {
        LOG((TL_TRACE, "MSetServerConfig: enabling tapi server"));

        if ((pParams->lResult = CreateTapiSCP (NULL, NULL)) != 0)
        {
            LOG((TL_ERROR,
                "MSetServerConfig: CreateTapiSCP failed, err=%ld",
                pParams->lResult
                ));
            return;
        }
    }
    else if (!(pServerConfig->dwFlags & TAPISERVERCONFIGFLAGS_ENABLESERVER) &&
        bIsSharingEnabled)
    {
        LOG((TL_TRACE, "MSetServerConfig: disabling tapi server"));

        if ((pParams->lResult = RemoveTapiSCP ()) != 0)
        {
            LOG((TL_ERROR,
                "MSetServerConfig: RemoveTapiSCP failed, err=%ld",
                pParams->lResult
                ));
            return;
        }
        else
        {
            // This is not a Telephony server anymore, so reset the flag
            TapiGlobals.dwFlags = TapiGlobals.dwFlags & ~TAPIGLOBALS_SERVER;
        }
    }
    if ((lResult = WriteRegistryKeys(
            NULL,
            NULL,
            (DWORD) ((pServerConfig->dwFlags &
                TAPISERVERCONFIGFLAGS_ENABLESERVER) ? 0 : 1)
            )))
    {
       LOG((TL_ERROR,
                "MSetServerConfig: WriteRegistryKeys failed, err=%ld",
                lResult
                ));
        pParams->lResult = LINEERR_OPERATIONFAILED;
        return;
    }


    if (pServerConfig->dwFlags & TAPISERVERCONFIGFLAGS_SETTAPIADMINISTRATORS)
    {
        WCHAR  *pAdmin, buf[16];
        DWORD   i;


        //
        // Reset the TapiAdministrators section
        //

        if (WritePrivateProfileSectionW(
            gszTapiAdministrators,
            L"\0",
            gszFileName) == 0)
        {
            pParams->lResult = LINEERR_OPERATIONFAILED;
            return;
        }

        pAdmin = (WCHAR *)
            (((LPBYTE) pServerConfig) + pServerConfig->dwAdministratorsOffset);


        //
        // For each admin in the list write out a "Domain\User=1"
        // value to the TapiAdministrators section
        //

        for (i = 0; *pAdmin != L'\0'; i++)
        {
            if (WritePrivateProfileStringW(
                gszTapiAdministrators,
                pAdmin,
                L"1",
                gszFileName
                ) == 0)
            {
                pParams->lResult = LINEERR_OPERATIONFAILED;
                return;
            }

            pAdmin += (wcslen (pAdmin) + 1);
        }
    }
}


typedef BOOL ( APIENTRY GETFILEVERSIONINFO(
    LPWSTR  lptstrFilename,     // pointer to filename string
    DWORD  dwHandle,    // ignored
    DWORD  dwLen,       // size of buffer
    LPVOID  lpData      // pointer to buffer to receive file-version info.
   ));
typedef DWORD ( APIENTRY GETFILEVERSIONINFOSIZE(
    LPWSTR  lptstrFilename,     // pointer to filename string
    LPDWORD  lpdwHandle         // pointer to variable to receive zero
   ));
typedef BOOL ( APIENTRY VERQUERYVALUE(
   const LPVOID  pBlock,        // address of buffer for version resource
   LPWSTR  lpSubBlock,  // address of value to retrieve
   LPVOID  *lplpBuffer, // address of buffer for version pointer
   PUINT  puLen         // address of version-value length buffer
  ));


static WCHAR gszVarFileInfo[]    = L"\\VarFileInfo\\Translation";
static WCHAR gszStringFileInfo[] = L"\\StringFileInfo\\%04x%04x\\FileDescription";

//
// EmanP
//   Given a multisz of file names,
//   allocates a multisz of friendly names.
//   Returns the number of bytes in the frienly name multisz
//
//

DWORD
GetProviderFriendlyName(
    /*IN */ WCHAR  *pFileNameBuf,
    /*OUT*/ WCHAR **ppFriendlyNameBuf
    )
{
    DWORD                   dwBufTotalSize = 0,
                            dwBufUsedSize  = 0,
                            dwVerSize      = 0,
                            dwSize,
                            dwVerHandle;
    UINT                    uItemSize;
    HINSTANCE               hVerDll;
    GETFILEVERSIONINFO     *pGetFileVersionInfo;
    GETFILEVERSIONINFOSIZE *pGetFileVersionInfoSize;
    VERQUERYVALUE          *pVerQueryValue;
    WCHAR                  *pFileName = pFileNameBuf,
                           *pszBuffer,
                           *pFriendlyNameBuf = NULL,
                           *p;
    BYTE                   *pbVerData = NULL;
    WCHAR                   szItem[1024];
    WORD                    wLangID;
    WORD                    wUserLangID;
    WORD                    wCodePage;
    DWORD                   dwIdx;

    if (NULL == pFileName ||
        NULL == ppFriendlyNameBuf)
    {
        return 0;
    }


    //
    // First, load VERSION.DLL
    //

    hVerDll = LoadLibrary( TEXT("Version.dll") );

    if ( NULL == hVerDll )
    {
        LOG((TL_ERROR,
            "LoadLibrary('VERSION.DLL') failed! err=0x%08lx",
            GetLastError()
            ));

        return 0;
    }


    //
    // Now, get the needed entry points into VERSION.DLL.
    // Use only UNICODE versions.
    //

    pGetFileVersionInfo = (GETFILEVERSIONINFO*) GetProcAddress(
        hVerDll,
        "GetFileVersionInfoW"
        );

    if ( NULL == pGetFileVersionInfo )
    {
        LOG((TL_ERROR,
            "GetProcAddress('VERSION.DLL', 'GetFileVersionInfoW') " \
                "failed! err=0x%08lx",
            GetLastError()
            ));

        goto _Return;
    }

    pGetFileVersionInfoSize = (GETFILEVERSIONINFOSIZE *) GetProcAddress(
        hVerDll,
        "GetFileVersionInfoSizeW"
        );

    if ( NULL == pGetFileVersionInfoSize )
    {
        LOG((TL_ERROR,
            "GetProcAddress('VERSION.DLL', 'GetFileVersionInfoSizeW') " \
                "failed! err=0x%08lx",
            GetLastError()
            ));

        goto _Return;
    }

    pVerQueryValue = (VERQUERYVALUE *) GetProcAddress(
        hVerDll,
        "VerQueryValueW"
        );

    if ( NULL == pVerQueryValue )
    {
        LOG((TL_ERROR,
            "GetProcAddress('VERSION.DLL', 'VerQueryValueW') " \
            "failed! err=0x%08lx",
            GetLastError()
            ));

        goto _Return;
    }

    //
    // Get the current UI language ( this is needed if MUI is enabled )
    // 
    wUserLangID = GetUserDefaultUILanguage ();

    //
    // For each filename in the input multisz,
    // try to get it's friendly name. If anything fails,
    // make the friendly name the same as the file name.
    //

    for (; 0 != *pFileName; pFileName += lstrlenW(pFileName)+1)
    {
        pszBuffer = NULL;

        //
        // 1. Get the size needed for the verion resource
        //

        if ((dwSize = pGetFileVersionInfoSize( pFileName, &dwVerHandle )) == 0)
        {
            LOG((TL_ERROR, "GetFileVersionInfoSize failure for %S", pFileName ));
            goto  _UseFileName;
        }

        //
        // 2. If our current buffer is smaller than needed, reallocate it.
        //

        if (dwSize > dwVerSize)
        {
            if (NULL != pbVerData)
            {
                ServerFree (pbVerData);
            }

            dwVerSize = dwSize + 16; 
            pbVerData = ServerAlloc( dwVerSize );
            if ( pbVerData == NULL )
            {
                dwVerSize = 0;
                goto  _UseFileName;
            }
        }


        //
        // 3. Now, get the version information for the file.
        //

        if (pGetFileVersionInfo(
                pFileName,
                dwVerHandle,
                dwVerSize,
                pbVerData

                ) == FALSE )
        {
            LOG((TL_ERROR, "GetFileVersionInfo failure for %S", pFileName ));
            goto  _UseFileName;
        }


        //
        // 4. Get the Language/Code page translation
        //
        // NOTE: bug in VerQueryValue, can't handle static CS based str
        //

        lstrcpyW ( szItem, gszVarFileInfo );

        if ((pVerQueryValue(
                pbVerData,
                szItem,
                &pszBuffer,
                (LPUINT) &uItemSize

                ) == FALSE) ||

            (uItemSize == 0))
        {
            LOG((TL_ERROR,
                "ERROR:  VerQueryValue failure for %S on file %S",
                szItem,
                pFileName
                ));

            pszBuffer = NULL;
            goto  _UseFileName;
        }


        wCodePage = 0;
        wLangID = wUserLangID;

        //
        // lookup the current user UI language ID in the file version info
        //
        if (0 != wLangID)
        {   
            for( dwIdx=0; dwIdx < uItemSize/sizeof(DWORD); dwIdx++ )
            {
                if ( *(WORD*)((DWORD*)pszBuffer + dwIdx) == wLangID )
                {
                    wCodePage = *( (WORD*)((DWORD*)pszBuffer + dwIdx) + 1);
                    break;
                }
            }
            if( dwIdx == uItemSize/sizeof(DWORD) )
            {
                wLangID = 0;
            }
        }

        //
        // if GetUserDefaultUILanguage() failed, 
        // or the current user UI language doesn't show up in the file version info
        // just use the first language in the file version
        //
        if (0 == wLangID)
        {
            wLangID = *(LPWORD)pszBuffer;
            wCodePage = *(((LPWORD)pszBuffer)+1);
        }

        //
        // 5. Get the FileDescription in the language obtained above.
        //    (We use the FileDescription as friendly name).
        //

        wsprintfW(
            szItem,
            gszStringFileInfo,
            wLangID,
            wCodePage
            );

        if ((pVerQueryValue(
                pbVerData,
                szItem,
                &pszBuffer,
                (LPUINT) &uItemSize

                ) == FALSE) ||

            (uItemSize == 0))
        {
            LOG((TL_ERROR,
                "ERROR:  VerQueryValue failure for %S on file %S",
                szItem,
                pFileName
                ));

            pszBuffer = NULL;
            goto  _UseFileName;
        }

_UseFileName:

        if (NULL == pszBuffer)
        {
            //
            // Something went wrong and we couldn't get
            // the file description. Use the file name
            // instead.
            //

            pszBuffer = pFileName;
        }


        //
        // At this point, pszBuffer points to a (UNICODE) string
        // containing what we deem to be the friendly name.
        // Let's append it to the OUT multisz.
        //

        dwSize = (lstrlenW (pszBuffer) + 1) * sizeof (WCHAR);

        if ((dwSize + dwBufUsedSize) > dwBufTotalSize)
        {
            if (!(p = ServerAlloc (dwBufTotalSize += 512)))
            {
                //
                // We don't have enough memory.
                // Release what we allocated until now, and return 0.
                //

                if (NULL != pFriendlyNameBuf)
                {
                    ServerFree (pFriendlyNameBuf);
                }

                dwBufUsedSize = 0;
                break;
            }

            if (dwBufUsedSize)
            {
                CopyMemory (p, pFriendlyNameBuf, dwBufUsedSize);

                ServerFree (pFriendlyNameBuf);
            }

            pFriendlyNameBuf = p;
        }

        CopyMemory(
            ((LPBYTE) pFriendlyNameBuf) + dwBufUsedSize,
            pszBuffer,
            dwSize
            );

        dwBufUsedSize += dwSize;
    }

_Return:

    //
    // We don't need the library anymore.
    // We don't need the version buffer either.
    //

    FreeLibrary (hVerDll);

    if (NULL != pbVerData)
    {
        ServerFree (pbVerData);
    }

    if (0 != dwBufUsedSize)
    {
        *ppFriendlyNameBuf = pFriendlyNameBuf;
    }

    return dwBufUsedSize;
}

void WINAPI MGetDeviceFlags (
    PTCLIENT                    ptClient,
    PMMCGETDEVICEFLAGS_PARAMS   pParams,
    DWORD                       dwParamsBufferSize,
    LPBYTE                      pDataBuf,
    LPDWORD                     pdwNumBytesReturned
    )
{
    DWORD                   dwDeviceID;
    DWORD                   dwIndex;
    TAPIPERMANENTID         ID;
    LPDEVICEINFOLIST        pList;
    LPDEVICEINFO            pInfo;

    *pdwNumBytesReturned = sizeof (TAPI32_MSG);
    
    //  Support calls on line device only for now
    if (!pParams->fLine)
    {
        pParams->lResult = LINEERR_OPERATIONUNAVAIL;
        return;
    }

    ID.dwDeviceID = pParams->dwPermanentDeviceID;
    ID.dwProviderID = pParams->dwProviderID;

    EnterCriticalSection(&gMgmtCritSec);

    if (gpLineDevFlags == NULL)
    {
        pParams->lResult = LINEERR_OPERATIONUNAVAIL;
        goto ExitHere;
    }

    dwDeviceID = GetDeviceIDFromPermanentID (ID, pParams->fLine);
    if (dwDeviceID == 0xffffffff)
    {
        pParams->lResult = LINEERR_OPERATIONUNAVAIL;
        goto ExitHere;
    }

    // check if the device exists in the device list
    pList = gpLineInfoList;

    pInfo = (LPDEVICEINFO)(((LPBYTE) pList) + pList->dwDeviceInfoOffset);

    for (dwIndex = 0; dwIndex < pList->dwNumDeviceInfoEntries; dwIndex++, pInfo++)
    {
        if (pInfo->dwPermanentDeviceID == ID.dwDeviceID)
        {
            break;
        }
    }
    if (dwIndex > pList->dwNumDeviceInfoEntries) 
    {
        pParams->lResult = LINEERR_OPERATIONUNAVAIL;
        goto ExitHere;
    }

    pParams->dwDeviceID = dwDeviceID;
    pParams->dwFlags = gpLineDevFlags[dwIndex];
    
ExitHere:
    LeaveCriticalSection (&gMgmtCritSec);
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\server\utils.cpp ===
#include <stdio.h>
#include <stdarg.h>
#include "utils.h"

#ifdef __cplusplus
extern "C" {
#endif


#ifdef TRACELOG


DWORD   sg_dwTraceID = INVALID_TRACEID;
char    sg_szTraceName[100];   // saves name of dll

DWORD   sg_dwTracingToDebugger = 0;
DWORD   sg_dwTracingToConsole  = 0;
DWORD   sg_dwTracingToFile     = 0;
DWORD   sg_dwDebuggerMask      = 0;


BOOL TRACELogRegister(LPCTSTR szName)
{
    HKEY       hTracingKey;

    char       szTracingKey[100];
    const char szDebuggerTracingEnableValue[] = "EnableDebuggerTracing";
    const char szConsoleTracingEnableValue[] = "EnableConsoleTracing";
    const char szFileTracingEnableValue[] = "EnableFileTracing";
    const char szTracingMaskValue[]   = "ConsoleTracingMask";

    sg_dwTracingToDebugger = 0;
    sg_dwTracingToConsole = 0;
    sg_dwTracingToFile = 0; 

#ifdef UNICODE
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%ls", szName);
#else
    wsprintfA(szTracingKey, "Software\\Microsoft\\Tracing\\%s", szName);
#endif

    if ( ERROR_SUCCESS == RegOpenKeyExA(HKEY_LOCAL_MACHINE,
                                        szTracingKey,
                                        0,
                                        KEY_READ,
                                        &hTracingKey) )
    {
        DWORD      dwDataSize = sizeof (DWORD);
        DWORD      dwDataType;

        RegQueryValueExA(hTracingKey,
                         szDebuggerTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToDebugger,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szConsoleTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToConsole,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szFileTracingEnableValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwTracingToFile,
                         &dwDataSize);

        RegQueryValueExA(hTracingKey,
                         szTracingMaskValue,
                         0,
                         &dwDataType,
                         (LPBYTE) &sg_dwDebuggerMask,
                         &dwDataSize);

        RegCloseKey (hTracingKey);
    }

#ifdef UNICODE
    wsprintfA(sg_szTraceName, "%ls", szName);
#else
    wsprintfA(sg_szTraceName, "%s", szName);
#endif

    sg_dwTraceID = TraceRegister(szName);

    return (sg_dwTraceID != INVALID_TRACEID);
}


void TRACELogDeRegister()
{
    sg_dwTracingToDebugger = 0;
    sg_dwTracingToConsole = 0;
    sg_dwTracingToFile = 0; 

    if (sg_dwTraceID != INVALID_TRACEID)
    {
        TraceDeregister(sg_dwTraceID);
        sg_dwTraceID = INVALID_TRACEID;
    }
}


void TRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR lpszFormat, IN ...)
{

    char    szTraceBuf[MAXDEBUGSTRINGLENGTH + 1];
    va_list arglist;

    if ( ( sg_dwTracingToDebugger > 0 ) &&
         ( 0 != ( dwDbgLevel & sg_dwDebuggerMask ) ) )
    {

        // retrieve local time
        SYSTEMTIME SystemTime;
        GetLocalTime(&SystemTime);

        wsprintfA(szTraceBuf,
                  "%s:[%02u:%02u:%02u.%03u,tid=%x:] [%s] ",
                  sg_szTraceName,
                  SystemTime.wHour,
                  SystemTime.wMinute,
                  SystemTime.wSecond,
                  SystemTime.wMilliseconds,
                  GetCurrentThreadId(), 
                  TraceLevel(dwDbgLevel));

        va_list ap;
        va_start(ap, lpszFormat);

        _vsnprintf(&szTraceBuf[lstrlenA(szTraceBuf)], 
            MAXDEBUGSTRINGLENGTH - lstrlenA(szTraceBuf), 
            lpszFormat, 
            ap
            );

        lstrcatA (szTraceBuf, "\n");

        OutputDebugStringA (szTraceBuf);

        va_end(ap);
		
    }
    
	if (sg_dwTraceID != INVALID_TRACEID)
    {
		wsprintfA(szTraceBuf, "[%s] %s", TraceLevel(dwDbgLevel), lpszFormat);

		va_start(arglist, lpszFormat);
		TraceVprintfExA(sg_dwTraceID, dwDbgLevel | TRACE_USE_MSEC, szTraceBuf, arglist);
		va_end(arglist);
	}

}
 

char *TraceLevel(DWORD dwDbgLevel)
{
    switch(dwDbgLevel)
    {
        case TL_ERROR: return "ERROR";
        case TL_WARN:  return "WARN ";
        case TL_INFO:  return "INFO ";
        case TL_TRACE: return "TRACE";
        case TL_EVENT: return "EVENT";
        default:       return " ??? ";
    }
}


#endif // TRACELOG
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\server\utils.h ===
#ifndef __SERVER_UTILS_H__
#define __SERVER_UTILS_H__
#ifdef __cplusplus
extern "C" {
#endif


#ifdef TRACELOG
	#include <windows.h>
	#include <winbase.h>
    #include <rtutils.h>
	
    #define MAXDEBUGSTRINGLENGTH 1024

    #define TL_ERROR ((DWORD)0x00010000 | TRACE_USE_MASK)
    #define TL_WARN  ((DWORD)0x00020000 | TRACE_USE_MASK)
    #define TL_INFO  ((DWORD)0x00040000 | TRACE_USE_MASK)
    #define TL_TRACE ((DWORD)0x00080000 | TRACE_USE_MASK)
    #define TL_EVENT ((DWORD)0x00100000 | TRACE_USE_MASK)

    BOOL  TRACELogRegister(LPCTSTR szName);
    void  TRACELogDeRegister();
    void  TRACELogPrint(IN DWORD dwDbgLevel, IN LPCSTR DbgMessage, IN ...);

    extern char *TraceLevel(DWORD dwDbgLevel);
    extern void TAPIFormatMessage(HRESULT hr, LPVOID lpMsgBuf);



    #define TRACELOGREGISTER(arg) TRACELogRegister(arg)
    #define TRACELOGDEREGISTER() TRACELogDeRegister()
	#define LOG(arg) TRACELogPrint arg

	extern char    sg_szTraceName[100];
	extern DWORD   sg_dwTracingToDebugger;
	extern DWORD   sg_dwDebuggerMask;
    extern DWORD   sg_dwTraceID;

#else // TRACELOG not defined

    #define TRACELOGREGISTER(arg)
    #define TRACELOGDEREGISTER() 
    #define LOG(arg)

#endif // TRACELOG

#ifdef __cplusplus
}
#endif

#endif //__SERVER_UTILS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\server\tapy.h ===
/*++ BUILD Version: 0000    // Increment this if a change has global effects

Copyright (c) 1995  Microsoft Corporation

Module Name:

    tapy.h

Abstract:

    Header file for

Author:

    Dan Knudson (DanKn)    dd-Mmm-1995

Revision History:

--*/


typedef struct _TAPIGETLOCATIONINFO_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        OUT DWORD       dwCountryCodeOffset;
    };

    union
    {
        IN OUT DWORD    dwCountryCodeSize;
    };

    union
    {
        OUT DWORD       dwCityCodeOffset;
    };

    union
    {
        IN OUT DWORD    dwCityCodeSize;
    };

} TAPIGETLOCATIONINFO_PARAMS, *PTAPIGETLOCATIONINFO_PARAMS;


typedef struct _TAPIREQUESTDROP_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HWND        hwnd;
       
        union 
        {
            DWORD hwnd32_1;
            DWORD hwnd32_2;
        };

    };

    union
    {
        IN  DWORD       wRequestID;
    };

} TAPIREQUESTDROP_PARAMS, *PTAPIREQUESTDROP_PARAMS;


typedef struct _TAPIREQUESTMAKECALL_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  DWORD       dwDestAddressOffset;
    };

    union
    {
        IN  DWORD       dwAppNameOffset;            // valid offset or
    };
                                                    //   TAPI_NO_DATA
    union
    {
        IN  DWORD       dwCalledPartyOffset;        // valid offset or
    };
                                                    //   TAPI_NO_DATA
    union
    {
        IN  DWORD       dwCommentOffset;            // valid offset or
    };
                                                    //   TAPI_NO_DATA
    union
    {
        IN  DWORD       dwProxyListTotalSize;       // size of client buffer
        OUT DWORD       dwProxyListOffset;          // valid offset on success
    };

    union
    {
        IN  DWORD       hRequestMakeCallFailed;     // Non-zero if failed to
    };
                                                    //   start proxy
    union
    {
        OUT DWORD       hRequestMakeCallAttempted;  // Non-zero if failed to
    };
                                                    //   start proxy
} TAPIREQUESTMAKECALL_PARAMS, *PTAPIREQUESTMAKECALL_PARAMS;


typedef struct _TAPIREQUESTMEDIACALL_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        IN  HWND        hwnd;

        union 
        {
            DWORD hwnd32_1;
            DWORD hwnd32_2;
        };

    };

    union
    {
        IN  DWORD       wRequestID;
    };

    union
    {
        IN  DWORD       dwDeviceClassOffset;
    };

    union
    {
        OUT DWORD       dwDeviceIDOffset;
    };

    union
    {
        IN OUT DWORD    dwSize;
    };

    union
    {
        IN  DWORD       dwSecure;
    };

    union
    {
        IN  DWORD       dwDestAddressOffset;
    };

    union
    {
        IN  DWORD       dwAppNameOffset;            // valid offset or
    };

    union
    {
        IN  DWORD       dwCalledPartyOffset;
    };

    union
    {
        IN  DWORD       dwCommentOffset;            // valid offset or
    };

} TAPIREQUESTMEDIACALL_PARAMS, *PTAPIREQUESTMEDIACALL_PARAMS;


typedef struct _TAPIPERFORMANCE_PARAMS
{
    union
    {
        OUT LONG        lResult;
    };

    DWORD               dwUnused;

    union
    {
        OUT DWORD       dwPerfOffset;
    };

} TAPIPERFORMANCE_PARAMS, *PTAPIPERFORMANCE_PARAMS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\aboutdlg.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// TAPIDialer(tm) and ActiveDialer(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526; 5,488,650; 
// 5,434,906; 5,581,604; 5,533,102; 5,568,540, 5,625,676.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//AboutDlg.h
/////////////////////////////////////////////////////////////////////////////

#ifndef _ABOUTDLG_H_
#define _ABOUTDLG_H_

#include "bscroll.h"
#include "gfx.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CAboutDlg dialog used for App About
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CAboutDlg : public CDialog
{
public:
	CAboutDlg();

public:
   void           SetModeless()        { m_bModeless = TRUE; };
protected:
   BOOL           m_bModeless;

   HBITMAP        m_hbmpBackground;
   HBITMAP        m_hbmpForeground;
   HPALETTE       m_hPalette;
   HBSCROLL       m_hBScroll;

// Dialog Data
	//{{AFX_DATA(CAboutDlg)
	enum { IDD = IDD_ABOUTBOX };
	CString	m_sLegal;
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAboutDlg)
	public:
	virtual BOOL DestroyWindow();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CAboutDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	afx_msg void OnAboutButtonUpgrade();
	afx_msg void OnTimer(UINT nIDEvent);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
// CWndPage window

class CWndPage : public CWnd
{
// Construction
public:
	CWndPage();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CWndPage)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CWndPage();

	// Generated message map functions
protected:
	//{{AFX_MSG(CWndPage)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
class CUserUserDlg : public CDialog
{
public:
	CUserUserDlg();


// Members:
public:
	long		m_lCallID;
	CString		m_strWelcome;
	CString		m_strUrl;
	CString		m_strFrom;
	CWndPage	m_wndPage;

// Dialog Data
	//{{AFX_DATA(CUserUserDlg)
	enum { IDD = IDD_USERUSER };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CUserUserDlg)
	public:
	virtual BOOL OnInitDialog();
	virtual BOOL DestroyWindow();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	void	DoModeless( CWnd *pWndParent );

protected:
	//{{AFX_MSG(CUserUserDlg)
	afx_msg void OnClose();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
	afx_msg void OnUrlClicked();
	afx_msg LRESULT OnCtlColorEdit(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
class CPageDlg : public CDialog
{
public:
	CPageDlg();

// Members:
public:
	CString		m_strWelcome;
	CString		m_strUrl;
	CString		m_strTo;
	CWndPage	m_wndPage;

// Dialog Data
	//{{AFX_DATA(CPageDlg)
	enum { IDD = IDD_PAGE };
	//}}AFX_DATA

	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CPageDlg)
	public:
	virtual BOOL OnInitDialog();
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:
	//{{AFX_MSG(CPage)
	afx_msg LRESULT OnCtlColorEdit(WPARAM wParam, LPARAM lParam);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#endif //_ABOUTDLG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\aexpltre.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// aexpltre.cpp : implementation file
//

#include "stdafx.h"
#include "aexpltre.h"
#include "resource.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CLASS CExplorerTreeItem
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
CExplorerTreeItem::CExplorerTreeItem()
{
	m_pObject = NULL;
	m_pUnknown = NULL;
	m_Type = TOBJ_UNDEFINED;
	m_bDeleteObject = FALSE;
	m_pfnRelease = NULL;
}

/////////////////////////////////////////////////////////////////////////////
CExplorerTreeItem::CExplorerTreeItem(LPCTSTR str) : CAVTreeItem(str)
{
	m_pObject = NULL;
	m_pUnknown = NULL;
	m_Type = TOBJ_UNDEFINED;
	m_bDeleteObject = FALSE;
	m_pfnRelease = NULL;
}

/////////////////////////////////////////////////////////////////////////////
CExplorerTreeItem::~CExplorerTreeItem()
{
	if ( m_bDeleteObject )
	{
		if ( m_pObject ) delete m_pObject;
		if ( m_pUnknown ) m_pUnknown->Release();
	}

  	if ( m_pfnRelease )
		(*m_pfnRelease) ( (VOID *) m_pObject );

}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CLASS CExplorerTreeCtrl
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CExplorerTreeCtrl, CAVTreeCtrl)

/////////////////////////////////////////////////////////////////////////////
CExplorerTreeCtrl::CExplorerTreeCtrl()
{
}

/////////////////////////////////////////////////////////////////////////////
CExplorerTreeCtrl::~CExplorerTreeCtrl()
{
}


/////////////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CExplorerTreeCtrl, CAVTreeCtrl)
	//{{AFX_MSG_MAP(CExplorerTreeCtrl)
	ON_NOTIFY_REFLECT(NM_RCLICK, OnRclick)
	ON_WM_CONTEXTMENU()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
void CExplorerTreeCtrl::Init(UINT uBitmapId, UINT nOverlayInd /*= 0*/, UINT nOverlayCount /*= 0*/)
{	
   DeleteAllItems();
	CAVTreeCtrl::Init(uBitmapId, nOverlayInd, nOverlayCount);
}

/////////////////////////////////////////////////////////////////////////////
BOOL CExplorerTreeCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	//We want lines and buttons
	dwStyle |= TVS_HASLINES|TVS_HASBUTTONS|TVS_SHOWSELALWAYS;

   return CAVTreeCtrl::Create(dwStyle,rect,pParentWnd,nID);
}

/////////////////////////////////////////////////////////////////////////////
BOOL CExplorerTreeCtrl::InsertItem(CExplorerTreeItem* pItem,CExplorerTreeItem* pParent,CExplorerTreeItem* pInsertAfter /*= NULL*/, HTREEITEM hInsertAfter /*= TVI_LAST*/)
{
	//Insert to root and last in list
	return CAVTreeCtrl::InsertItem(pItem,pParent,pInsertAfter, hInsertAfter);
}

/////////////////////////////////////////////////////////////////////////////
void CExplorerTreeCtrl::OnRclick(NMHDR* pNMHDR, LRESULT* pResult) 
{
	//Get the mouse position
	CPoint pt,cpt;
	::GetCursorPos(&pt);
	cpt = pt;
	HTREEITEM hItem;
	UINT flags = 0;
	ScreenToClient(&cpt);
	//Must be on an item
	if (hItem = HitTest(cpt,&flags))
	{
  		SelectItem(hItem);                                                   //select the one
      CExplorerTreeItem* pItem = (CExplorerTreeItem*)GetItemData(hItem);   //Get the item
      if (pItem)
      {
         OnRightClick(pItem,pt);
      }
	}
	*pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
void CExplorerTreeCtrl::OnContextMenu(CWnd* pWnd, CPoint point) 
{
   CExplorerTreeItem* pItem = NULL;

   if ( (point.x == -1) && (point.y == -1) )
   {
      //when we come in from a keyboard (SHIFT + VF10) we get a -1,-1
      point.x = 0;
      point.y = 0;
      pItem = GetSelectedTreeItem();
      CRect rect;
      if ( (pItem) && (SetSelectedItemRect(&rect,FALSE)) )
      {
         //let's offer the point at the upper left corner of rect
         point.x = rect.left;
         point.y = rect.top;
      }
      ClientToScreen(&point);
   }
   else
   {
   	CPoint pt = point;
	   ScreenToClient(&pt);
      HTREEITEM hItem;
	   UINT flags = 0;
	   //Must be on an item
	   if (hItem = HitTest(pt,&flags))
	   {
  		   SelectItem(hItem);                                 //select the one
         pItem = (CExplorerTreeItem*)GetItemData(hItem);    //Get the item
      }
   }

   if (pItem)
   {
      //OnRightClick wants screen coordinates
      OnRightClick(pItem,point);
   }
}

/////////////////////////////////////////////////////////////////////////////
void CExplorerTreeCtrl::OnRightClick(CExplorerTreeItem* pItem,CPoint& pt)
{

}

/////////////////////////////////////////////////////////////////////////////
void CExplorerTreeCtrl::EditLabel()
{
   HTREEITEM hItem;
   if ((hItem = GetSelectedItem()) == NULL)
      return;

   CAVTreeCtrl::EditLabel(hItem);
}

/////////////////////////////////////////////////////////////////////////////
CExplorerTreeItem* CExplorerTreeCtrl::AddObject(CObject* pObject,
                                                CExplorerTreeItem* pParentItem,
                                                TREEOBJECT toType,
                                                TREEIMAGE tiImage,
                                                BOOL bDeleteObject)
{
   CExplorerTreeItem* pItem= new CExplorerTreeItem();   
   pItem->SetObject(pObject);
   pItem->SetType(toType);
   pItem->SetImage(tiImage);
   pItem->DeleteObjectOnClose(bDeleteObject);
   (pParentItem)?InsertItem(pItem,pParentItem):InsertItem(pItem);
   return pItem;
}

/////////////////////////////////////////////////////////////////////////////
//Takes no parent, uses current selection for parent
CExplorerTreeItem* CExplorerTreeCtrl::AddObject(CObject* pObject,
                                                TREEOBJECT toType,
                                                TREEIMAGE tiImage,
                                                BOOL bDeleteObject)
{
   HTREEITEM hItem;
   if ((hItem = GetSelectedItem()) == NULL)
      return NULL;
      
   //get parent from selected
   CExplorerTreeItem* pParentItem = (CExplorerTreeItem*)GetItemData(hItem);

   CExplorerTreeItem* pItem = new CExplorerTreeItem();   
   pItem->SetObject(pObject);
   pItem->SetType(toType);
   pItem->SetImage(tiImage);
   pItem->DeleteObjectOnClose(bDeleteObject);
   InsertItem(pItem,pParentItem);
   return pItem;
}

/////////////////////////////////////////////////////////////////////////////
//uses current selection's parent to add object
CExplorerTreeItem* CExplorerTreeCtrl::AddObjectToParent(CObject* pObject,
                                                TREEOBJECT toType,
                                                TREEIMAGE tiImage,
                                                BOOL bDeleteObject)
{
   CExplorerTreeItem* pItem = NULL;

   HTREEITEM hItem;
   if ((hItem = GetSelectedItem()) == NULL)
      return NULL;

   HTREEITEM hParentItem = GetParentItem(hItem);

   if (hParentItem)
   {
      CExplorerTreeItem* pParentItem = (CExplorerTreeItem*)GetItemData(hParentItem);

      pItem = new CExplorerTreeItem();   
      pItem->SetObject(pObject);
      pItem->SetType(toType);
      pItem->SetImage(tiImage);
      pItem->DeleteObjectOnClose(bDeleteObject);
      InsertItem(pItem,pParentItem);
   }
   return pItem;
}

/////////////////////////////////////////////////////////////////////////////
CExplorerTreeItem* CExplorerTreeCtrl::AddObject(UINT uDisplayTextResourceID,
                                                CExplorerTreeItem* pParentItem,
                                                TREEOBJECT toType,
                                                TREEIMAGE tiImage)
{
   CString sDisplayText;
   sDisplayText.LoadString(uDisplayTextResourceID);
   return AddObject(sDisplayText,pParentItem,toType,tiImage);
}

/////////////////////////////////////////////////////////////////////////////
CExplorerTreeItem* CExplorerTreeCtrl::AddObject(LPCTSTR pszDisplayText,
                                                CExplorerTreeItem* pParentItem,
                                                TREEOBJECT toType,
                                                TREEIMAGE tiImage,
												TREEIMAGE tiImageSel /*= -1*/,
												int nState /*= 0*/,
												HTREEITEM hInsert /*= TVI_LAST*/)
{
   CExplorerTreeItem* pItem= new CExplorerTreeItem(pszDisplayText);   
   pItem->SetType(toType);
   pItem->SetImage(tiImage);
   pItem->SetImageSel( tiImageSel );
   pItem->m_nState = nState;

   InsertItem(pItem, pParentItem, NULL, hInsert);
   return pItem;
}


/////////////////////////////////////////////////////////////////////////////
CExplorerTreeItem* CExplorerTreeCtrl::AddObject(UINT uDisplayTextResourceID,
                                                TREEOBJECT toType,
                                                TREEIMAGE tiImage)
{
   CString sDisplayText;
   sDisplayText.LoadString(uDisplayTextResourceID);
   return AddObject(sDisplayText,toType,tiImage);
}

/////////////////////////////////////////////////////////////////////////////
CExplorerTreeItem* CExplorerTreeCtrl::AddObject(LPCTSTR pszDisplayText,
                                                TREEOBJECT toType,
                                                TREEIMAGE tiImage)
{
   HTREEITEM hItem;
   if ((hItem = GetSelectedItem()) == NULL)
      return NULL;

   CExplorerTreeItem* pParentItem = (CExplorerTreeItem*)GetItemData(hItem);

   CExplorerTreeItem* pItem= new CExplorerTreeItem(pszDisplayText);   
   pItem->SetType(toType);
   pItem->SetImage(tiImage);
   (pParentItem)?InsertItem(pItem,pParentItem):InsertItem(pItem);
   return pItem;
}

/////////////////////////////////////////////////////////////////////////////
TREEOBJECT CExplorerTreeCtrl::GetSelectedObject()
{
   HTREEITEM hItem;
   if ((hItem = GetSelectedItem()) == NULL)
      return TOBJ_UNDEFINED;
      
   CExplorerTreeItem* pItem = (CExplorerTreeItem*)GetItemData(hItem);
   return pItem->GetType();
}

/////////////////////////////////////////////////////////////////////////////
void CExplorerTreeCtrl::DeleteSelectedObject()
{
   HTREEITEM hItem;
   if ((hItem = GetSelectedItem()))
   {
      CExplorerTreeItem* pItem = (CExplorerTreeItem*)GetItemData(hItem);
      DeleteItem(pItem);
   }
}

/////////////////////////////////////////////////////////////////////////////
CObject* CExplorerTreeCtrl::GetSelectedParentObject()
{
   CObject* pRetObject = NULL;

   HTREEITEM hItem;
   if ((hItem = GetSelectedItem()) == NULL)
      return NULL;

   HTREEITEM hParentItem = GetParentItem(hItem);

   if (hParentItem)
   {
      CExplorerTreeItem* pItem = (CExplorerTreeItem*)GetItemData(hParentItem);
      pRetObject = pItem->GetObject();
   }
   return pRetObject;
}

/////////////////////////////////////////////////////////////////////////////
//Object that is being displayed in the listview
CObject* CExplorerTreeCtrl::GetDisplayObject()
{
   HTREEITEM hItem;
   if ((hItem = GetSelectedItem()) == NULL)
      return NULL;

   CExplorerTreeItem* pItem = (CExplorerTreeItem*)GetItemData(hItem);
   return pItem->GetObject();
}

/////////////////////////////////////////////////////////////////////////////
//Only works with first level children of the currently displayed object.  
void CExplorerTreeCtrl::SetDisplayObject(CObject* pObject)
{
   HTREEITEM hItem;
   if (hItem = CAVTreeCtrl::GetSelectedItem())
   {
      CExplorerTreeItem* pChildItem;
      HTREEITEM hChildItem = CAVTreeCtrl::GetChildItem(hItem);
      while (hChildItem)
      {
         pChildItem = (CExplorerTreeItem*)CAVTreeCtrl::GetItemData(hChildItem);
         if (pObject == pChildItem->GetObject())
         {
            CAVTreeCtrl::Select(hChildItem,TVGN_CARET);
            break;
         }
         hChildItem = CAVTreeCtrl::GetNextSiblingItem(hChildItem);
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
//Only works with first level children and siblings of the currently
// displayed object.  
void CExplorerTreeCtrl::SetDisplayObject(TREEOBJECT toType)
{
   HTREEITEM hItem;
   if (hItem = CAVTreeCtrl::GetSelectedItem())
   {
      //check all the children first
      CExplorerTreeItem* pChildItem;
      HTREEITEM hChildItem = CAVTreeCtrl::GetChildItem(hItem);
      while (hChildItem)
      {
         pChildItem = (CExplorerTreeItem*)CAVTreeCtrl::GetItemData(hChildItem);
         if (pChildItem->GetType() == toType)
         {
            CAVTreeCtrl::Select(hChildItem,TVGN_CARET);
            return;
         }
         hChildItem = CAVTreeCtrl::GetNextSiblingItem(hChildItem);
      }
      
      //check all the siblings next
      hChildItem = CAVTreeCtrl::GetParentItem(hItem);
      hChildItem = CAVTreeCtrl::GetChildItem(hChildItem);
      while (hChildItem)
      {
         pChildItem = (CExplorerTreeItem*)CAVTreeCtrl::GetItemData(hChildItem);
         if (pChildItem->GetType() == toType)
         {
            CAVTreeCtrl::Select(hChildItem,TVGN_CARET);
            return;
         }
         hChildItem = CAVTreeCtrl::GetNextSiblingItem(hChildItem);
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CExplorerTreeCtrl::GetSelectedItemText(CString& sText)
{
   HTREEITEM hItem;
   if (hItem = CAVTreeCtrl::GetSelectedItem())
   {
      CExplorerTreeItem* pItem = (CExplorerTreeItem*)GetItemData(hItem);
      if (pItem)
         sText = pItem->GetText();
   }
}

/////////////////////////////////////////////////////////////////////////////
void CExplorerTreeCtrl::GetSelectedItemParentText(CString& sText)
{
	HTREEITEM hItem;
	if ( ((hItem = CAVTreeCtrl::GetSelectedItem()) != NULL) &&
		 ((hItem = CAVTreeCtrl::GetParentItem(hItem)) != NULL) )
	{
		CExplorerTreeItem* pItem = (CExplorerTreeItem*)GetItemData(hItem);
		if (pItem)
			sText = pItem->GetText();
	}
}


/////////////////////////////////////////////////////////////////////////////
void CExplorerTreeCtrl::GetItemText(HTREEITEM hTreeItem,CString& sText)
{
   ASSERT(hTreeItem);
   CExplorerTreeItem* pItem = (CExplorerTreeItem*)GetItemData(hTreeItem);
   if (pItem) 
      sText = pItem->GetText();
}

/////////////////////////////////////////////////////////////////////////////
CExplorerTreeItem* CExplorerTreeCtrl::GetSelectedTreeItem()
{
   CExplorerTreeItem* pItem = NULL;
   HTREEITEM hItem;
   if (hItem = CAVTreeCtrl::GetSelectedItem())
   {
      pItem = (CExplorerTreeItem*)GetItemData(hItem);
   }
   return pItem;
}

/////////////////////////////////////////////////////////////////////////////
void CExplorerTreeCtrl::SetSelectedItemText(LPCTSTR szText)
{
   HTREEITEM hItem;
   if (hItem = CAVTreeCtrl::GetSelectedItem())
   {
      CExplorerTreeItem* pItem = (CExplorerTreeItem*)GetItemData(hItem);
      pItem->SetText(szText);
      CAVTreeCtrl::SetItemText(hItem,szText);  
   }
}

/////////////////////////////////////////////////////////////////////////////
void CExplorerTreeCtrl::SetSelectedItemImage(TREEIMAGE tiImage)
{
   HTREEITEM hItem;
   if (hItem = GetSelectedItem())
   {
      //get item from selected
      CExplorerTreeItem* pItem = (CExplorerTreeItem*)GetItemData(hItem);
      pItem->SetImage(tiImage);
     
      CRect rect;
      GetItemRect(hItem,&rect,FALSE);
      InvalidateRect(rect);
      UpdateWindow();
   }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CExplorerTreeCtrl::SetSelectedItemRect(CRect* pRect,BOOL bTextOnly)
{
   HTREEITEM hItem;
   if (hItem = GetSelectedItem())
   {
      //get item from selected
      CExplorerTreeItem* pItem = (CExplorerTreeItem*)GetItemData(hItem);
      GetItemRect(hItem,pRect,bTextOnly);
      return TRUE;
   }
   return FALSE;
}


/////////////////////////////////////////////////////////////////////////////
int CExplorerTreeCtrl::GetChildCount()
{
   int nRetCount = 0;
   HTREEITEM hParentItem;
   if (hParentItem = CAVTreeCtrl::GetSelectedItem())
   {
      HTREEITEM hChildItem;
      hChildItem = GetChildItem(hParentItem);
      if (hChildItem)
      {
         nRetCount++;
         while (hChildItem = GetNextSiblingItem(hChildItem))
            nRetCount++;
      }
   }
   return nRetCount;
}

/////////////////////////////////////////////////////////////////////////////
void CExplorerTreeCtrl::DeleteAllSiblings()
{
   HTREEITEM hItem;
   if (hItem = CAVTreeCtrl::GetSelectedItem())
   {
      HTREEITEM hParentItem = GetParentItem(hItem);
      if (hParentItem)
      {
         HTREEITEM hChildItem;
         while (hChildItem = GetChildItem(hParentItem))
         {
            CExplorerTreeItem* pChildItem = (CExplorerTreeItem*)CAVTreeCtrl::GetItemData(hChildItem);
            CAVTreeCtrl::DeleteItem(pChildItem);    
         }
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CExplorerTreeCtrl::GetAllChildren(CObList* pRetList)
{
   HTREEITEM hItem;
   if (hItem = CAVTreeCtrl::GetSelectedItem())
   {
      HTREEITEM hChildItem = GetChildItem(hItem);
      if (hChildItem)
      {
         CExplorerTreeItem* pChildItem = (CExplorerTreeItem*)CAVTreeCtrl::GetItemData(hChildItem);
         pRetList->AddTail(pChildItem->GetObject());
         while (hChildItem = GetNextSiblingItem(hChildItem))
         {
            CExplorerTreeItem* pChildItem = (CExplorerTreeItem*)CAVTreeCtrl::GetItemData(hChildItem);
            pRetList->AddTail(pChildItem->GetObject());
         }
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CExplorerTreeCtrl::DeleteAllChildren()
{
   HTREEITEM hItem;
   if (hItem = CAVTreeCtrl::GetSelectedItem())
   {
      DeleteAllChildren(hItem);
   }
}

/////////////////////////////////////////////////////////////////////////////
void CExplorerTreeCtrl::DeleteAllChildren(HTREEITEM hParentItem)
{
   HTREEITEM hChildItem;
   while (hChildItem = GetChildItem(hParentItem))
   {
      CExplorerTreeItem* pChildItem = (CExplorerTreeItem*)CAVTreeCtrl::GetItemData(hChildItem);
      CAVTreeCtrl::DeleteItem(pChildItem);    
   }
}

CExplorerTreeItem*	CExplorerTreeCtrl::GetChildItemWithIUnknown( HTREEITEM hItemParent, IUnknown *pUnknown )
{
	CExplorerTreeItem *pItem = NULL;
	HTREEITEM hChild = GetChildItem( hItemParent );
	if ( hChild )
	{
		do
		{
			pItem = (CExplorerTreeItem *) CAVTreeCtrl::GetItemData( hChild );
			if ( pItem->m_pUnknown == pUnknown )
				break;

			pItem = NULL;
		} while ( (hChild = GetNextSiblingItem(hChild)) != NULL );
	}
	
	return pItem;
}


/////////////////////////////////////////////////////////////////////////////
void CExplorerTreeCtrl::ExpandSelected()
{
   HTREEITEM hItem;
   if (hItem = CAVTreeCtrl::GetSelectedItem())
   {
      Expand(hItem,TVE_EXPAND);
   }   
}

/////////////////////////////////////////////////////////////////////////////
int CExplorerTreeCtrl::OnCompareTreeItems(CAVTreeItem* _pItem1,CAVTreeItem* _pItem2)
{
   int ret = 0;
   CExplorerTreeItem* pItem1 = (CExplorerTreeItem*)_pItem1;
   CExplorerTreeItem* pItem2 = (CExplorerTreeItem*)_pItem2;

/*   if ((ISITEMPURLNAME(pItem1)) && (ISITEMPURLNAME(pItem2)))
   {
      CPurlName* pOwner1 = (CPurlName*)pItem1->GetObject();
      CPurlName* pOwner2 = (CPurlName*)pItem2->GetObject();
      ret = (_tcsicmp(pOwner1->GetText(),pOwner2->GetText()) <= 0)?-1:1;
   }*/

   return ret;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CExplorerTreeCtrl::ItemHasChildren()
{
   HTREEITEM hItem;
   if ((hItem = GetSelectedItem()) == NULL)
      return FALSE;
   
   return CAVTreeCtrl::ItemHasChildren(hItem);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\agentdial.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// AgentDialer.cpp : Implementation of CAgentDialer
#include "stdafx.h"
#include "idialer.h"
#include "AgentDialer.h"
#include "avDialer.h"
#include "mainfrm.h"
#include "dialreg.h"
#include "idialer_i.c"

extern CActiveDialerApp theApp;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
// Class CAgentDialer
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////
CAgentDialer::CAgentDialer()
{
}

/////////////////////////////////////////////////////////////////////////////////////////
void CAgentDialer::FinalRelease()
{
	// clean up here
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CAgentDialer::ActionSelected(long lActionType)
{
   if ( (theApp.m_pMainWnd) && (::IsWindow(theApp.m_pMainWnd->GetSafeHwnd())) )
   {
      theApp.m_pMainWnd->PostMessage(WM_ACTIVEDIALER_INTERFACE_SHOWEXPLORER,NULL,NULL);
   }

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CAgentDialer::SpeedDial(long lOrdinal)
{
   if ( (theApp.m_pMainWnd) && (::IsWindow(theApp.m_pMainWnd->GetSafeHwnd())) )
   {
      theApp.m_pMainWnd->PostMessage(WM_ACTIVEDIALER_INTERFACE_SPEEDDIAL,NULL,(LPARAM)lOrdinal);
   }

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CAgentDialer::Redial(long lOrdinal)
{
   if ( (theApp.m_pMainWnd) && (::IsWindow(theApp.m_pMainWnd->GetSafeHwnd())) )
   {
      theApp.m_pMainWnd->PostMessage(WM_ACTIVEDIALER_INTERFACE_REDIAL,NULL,(LPARAM)lOrdinal);
   }

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CAgentDialer::MakeCall(BSTR bstrName, BSTR bstrAddress, long dwAddressType)
{
   if ( (theApp.m_pMainWnd) && (::IsWindow(theApp.m_pMainWnd->GetSafeHwnd())) )
   {
      USES_CONVERSION;
      CString sName,sAddress;
      if (bstrName)
         sName = OLE2CT( bstrName );
      if (bstrAddress)
         sAddress = OLE2CT( bstrAddress );

      CCallEntry* pCallEntry = new CCallEntry();
      pCallEntry->m_sDisplayName = sName;
      pCallEntry->m_sAddress = sAddress;
      pCallEntry->m_lAddressType = dwAddressType;
      pCallEntry->m_MediaType = DIALER_MEDIATYPE_UNKNOWN;
      theApp.m_pMainWnd->PostMessage(WM_ACTIVEDIALER_INTERFACE_MAKECALL,NULL,(LPARAM)pCallEntry);
   }

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CAgentDialer::SpeedDialEdit(void)
{
   if ( (theApp.m_pMainWnd) && (::IsWindow(theApp.m_pMainWnd->GetSafeHwnd())) )
   {
      theApp.m_pMainWnd->PostMessage(WM_ACTIVEDIALER_INTERFACE_SPEEDDIALEDIT,NULL,NULL);
   }

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CAgentDialer::SpeedDialMore(void)
{
   if ( (theApp.m_pMainWnd) && (::IsWindow(theApp.m_pMainWnd->GetSafeHwnd())) )
   {
      theApp.m_pMainWnd->PostMessage(WM_ACTIVEDIALER_INTERFACE_SPEEDDIALMORE,NULL,NULL);
   }

	return S_OK;
}

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\avdialer.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// ActiveDialer.h : main header file for the ACTIVEDIALER application
//

#if !defined(AFX_ACTIVEDIALER_H__A0D7A95B_3C0B_11D1_B4F9_00C04FC98AD3__INCLUDED_)
#define AFX_ACTIVEDIALER_H__A0D7A95B_3C0B_11D1_B4F9_00C04FC98AD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __AFXWIN_H__
	#error include 'stdafx.h' before including this file for PCH
#endif

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CAboutDlg;

#define ARRAYSIZE(_AR_)		(sizeof(_AR_) / sizeof(_AR_[0]))

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CActiveDialerApp:
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CActiveDialerApp : public CWinApp
{
public:
	virtual BOOL PreTranslateMessage(MSG* pMsg);
	CActiveDialerApp();

//Attributes
   HANDLE		m_hUnique;
   CString      m_sApplicationName;
   CString      m_sInitialCallTo;
protected:
   CAboutDlg*   m_pAboutDlg;

//Operations
public:
	void			ShellExecute(HWND hwnd, LPCTSTR lpOperation, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd);

protected:
	void			CheckCallTo();

	bool			FirstInstance();
	bool			RegisterUniqueWindowClass();

	BOOL			SaveVersionToRegistry();
	void			PatchRegistryForVersion( int nVer );
	bool			CanWriteHKEY_ROOT();

    void            IniUpgrade();
    TCHAR*          IniLoadString(
                        LPCTSTR lpAppName,        // points to section name
                        LPCTSTR lpKeyName,        // points to key name
                        LPCTSTR lpDefault,        // points to default string
                        LPCTSTR lpFileName);

// Overrides
public:
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CActiveDialerApp)
	public:
	virtual BOOL InitInstance();
	virtual int ExitInstance();
	virtual BOOL OnIdle(LONG lCount);
	virtual void WinHelp(DWORD dwData, UINT nCmd = HELP_CONTEXT);
	//}}AFX_VIRTUAL

// Implementation
	COleTemplateServer m_server;
		// Server object for document creation

	//{{AFX_MSG(CActiveDialerApp)
	afx_msg void OnAppAbout();
	afx_msg void OnHelpIndex();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

protected:
    BOOL    SetFocusToCallWindows(
        IN  MSG*    pMsg
        );
};


/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACTIVEDIALER_H__A0D7A95B_3C0B_11D1_B4F9_00C04FC98AD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\agentdialer.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// AgentDialer.h : Declaration of the CAgentDialer

#ifndef __AGENTDIALER_H_
#define __AGENTDIALER_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
// CAgentDialer
class ATL_NO_VTABLE CAgentDialer : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAgentDialer, &CLSID_AgentDialer>,
	public IDispatchImpl<IAgentDialer, &IID_IAgentDialer, &LIBID_AGENTDIALERLib>
{
// Construction
public:
	CAgentDialer();

// Members
public:
   void  FinalRelease();
      
// Implementation
public:
DECLARE_REGISTRY_RESOURCEID(IDR_AGENTDIALER)
DECLARE_NOT_AGGREGATABLE(CAgentDialer)
DECLARE_CLASSFACTORY_SINGLETON(CAgentDialer)

BEGIN_COM_MAP(CAgentDialer)
	COM_INTERFACE_ENTRY(IAgentDialer)
	COM_INTERFACE_ENTRY(IDispatch)
END_COM_MAP()

// IAgentDialer
public:
	STDMETHOD(ActionSelected)(long lActionType);
	STDMETHOD(SpeedDial)(long lOrdinal);
	STDMETHOD(Redial)(long lOrdinal);
	STDMETHOD(MakeCall)(BSTR bstrName, BSTR bstrAddress, long dwAddressType);
	STDMETHOD(SpeedDialEdit)(void);
	STDMETHOD(SpeedDialMore)(void);
};

#endif //__AGENTDIALER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\aexpltre.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// aexpltre.h : header file
//

#ifndef _AEXPLTRE_H_
#define _AEXPLTRE_H_

#include "avtree.h"

/////////////////////////////////////////////////////////////////////////////
//Defines

typedef VOID (CALLBACK* EXPTREEITEM_EXTERNALRELEASEPROC) (VOID *);

//This defines all the different types of object in the tree
typedef enum tagTREEOBJECT
{
	//Directory Tree Objects
	TOBJ_DIRECTORY_ROOT,
	TOBJ_DIRECTORY_WAB_GROUP,
	TOBJ_DIRECTORY_WAB_PERSON,
	TOBJ_DIRECTORY_ILS_SERVER_GROUP,
	TOBJ_DIRECTORY_ILS_SERVER,
	TOBJ_DIRECTORY_ILS_SERVER_PEOPLE,
	TOBJ_DIRECTORY_ILS_SERVER_CONF,
	TOBJ_DIRECTORY_ILS_USER,
	TOBJ_DIRECTORY_DSENT_GROUP,
	TOBJ_DIRECTORY_DSENT_USER,
	TOBJ_DIRECTORY_SPEEDDIAL_GROUP,
	TOBJ_DIRECTORY_SPEEDDIAL_PERSON,
	TOBJ_DIRECTORY_CONFROOM_GROUP,
	TOBJ_DIRECTORY_CONFROOM_ME,
	TOBJ_DIRECTORY_CONFROOM_PERSON,
	TOBJ_UNDEFINED,

}TREEOBJECT;

typedef enum tagTREEIMAGE
{
	TIM_IMAGE_BAD = -1,
	TIM_DIRECTORY_ROOT,
	TIM_DIRECTORY_WAB,
	TIM_DIRECTORY_PERSON,
	TIM_DIRECTORY_GROUP,
	TIM_DIRECTORY_WORKSTATION,
	TIM_DIRECTORY_DOMAIN,
	TIM_DIRECTORY_USER,
	TIM_DIRECTORY_BOOK,
	TIM_DIRECTORY_SPEEDDIAL_GROUP,
	TIM_DIRECTORY_CONFERENCE,
	TIM_DIRECTORY_FOLDER,
	TIM_DIRECTORY_FOLDER_OPEN,
	TIM_DIRECTORY_SPEED_PHONE,
	TIM_DIRECTORY_SPEED_IPADDRESS,
	TIM_DIRECTORY_SPEED_CONF,
	TIM_DIRECTORY_CONFROOM_GROUP,
	TIM_DIRECTORY_CONFROOM_ME,
	TIM_DIRECTORY_CONFROOM_PERSON,
	TIM_DIRECTORY_CONFROOM_ME_BROKEN,
	TIM_DIRECTORY_CONFROOM_ME_NOVIDEO,
	TIM_DIRECTORY_CONFROOM_PERSON_NOVIDEO,
	TIM_MAX,
}TREEIMAGE;      

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//class CExplorerTreeItem 
class CExplorerTreeItem : public CAVTreeItem
{
	friend class CExplorerTreeCtrl;
public:
//Construction
	CExplorerTreeItem();
	CExplorerTreeItem(LPCTSTR str);
	~CExplorerTreeItem();

//Attributes
public:
	IUnknown*							m_pUnknown;
	BOOL								m_bDeleteObject;
	EXPTREEITEM_EXTERNALRELEASEPROC		m_pfnRelease;

protected:
	CObject*		m_pObject;
	TREEOBJECT		m_Type;
	

//Operations
public:
   void          SetObject(CObject* pObject)		{ m_pObject = pObject;			}
   CObject*      GetObject()						{ return m_pObject;				}

   void          SetType(TREEOBJECT toType)			{ m_Type = toType;				}
   TREEOBJECT    GetType()							{ return m_Type;				}

   void          DeleteObjectOnClose(BOOL bDelete)	{ m_bDeleteObject = bDelete;	}
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CExplorerTreeCtrl window
//class CActiveExplorerView;

class CExplorerTreeCtrl : public CAVTreeCtrl
{
	DECLARE_DYNCREATE(CExplorerTreeCtrl)
// Construction
public:
	CExplorerTreeCtrl();

// Attributes
public:

protected:
//   CActiveExplorerView*       m_pParentWnd;

// Operations
public:
	virtual void         Init(UINT uBitmapId, UINT nOverlayInd = 0, UINT nOverlayCount = 0);
	BOOL                 Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

   CExplorerTreeItem*   AddObject(UINT uDisplayTextResourceID,
                                  CExplorerTreeItem* pParentItem,
                                  TREEOBJECT toType,
                                  TREEIMAGE tiImage);
   CExplorerTreeItem*   AddObject(LPCTSTR pszDisplayText,
                                  CExplorerTreeItem* pParentItem,
                                  TREEOBJECT toType,
                                  TREEIMAGE tiImage,
								  TREEIMAGE tiImageSel = TIM_IMAGE_BAD,
								  int nState = 0,
								  HTREEITEM hInsert = TVI_LAST);
   
   CExplorerTreeItem*   AddObject(UINT uDisplayTextResourceID,
                                  TREEOBJECT toType,
                                  TREEIMAGE tiImage);
   CExplorerTreeItem*   AddObject(LPCTSTR pszDisplayText,
                                  TREEOBJECT toType,
                                  TREEIMAGE tiImage);
   
   CExplorerTreeItem*   AddObject(CObject* pObject,
                                  TREEOBJECT toType,
                                  TREEIMAGE tiImage,
                                  BOOL bDeleteObject=FALSE);
   CExplorerTreeItem*   AddObject(CObject* pObject,
                                  CExplorerTreeItem* pParentItem,
                                  TREEOBJECT toType,
                                  TREEIMAGE tiImage,
                                  BOOL bDeleteObject=FALSE);
   CExplorerTreeItem*   AddObjectToParent(CObject* pObject,
                                  TREEOBJECT toType,
                                  TREEIMAGE tiImage,
                                  BOOL bDeleteObject=FALSE);

   void                 DeleteSelectedObject();
   void                 DeleteAllSiblings();
   void                 DeleteAllChildren();
   void                 DeleteAllChildren(HTREEITEM hParentItem);

   void                 GetAllChildren(CObList* pRetList);  //from current selection
   
   int                  GetChildCount();

   TREEOBJECT           GetSelectedObject();
   CObject*             GetSelectedParentObject();

   CObject*             GetDisplayObject();
   void                 SetDisplayObject(CObject* pObject);
   void                 SetDisplayObject(TREEOBJECT toType);

   void                 GetSelectedItemText( CString& sText );
   void					GetSelectedItemParentText( CString& sText );
   void                 SetSelectedItemText(LPCTSTR szText);
   void                 GetItemText(HTREEITEM hTreeItem,CString& sText);
   CExplorerTreeItem*	GetChildItemWithIUnknown( HTREEITEM hItemParent, IUnknown *pUnknown );

   void                 SetSelectedItemImage(TREEIMAGE tiImage);
   BOOL                 SetSelectedItemRect(CRect* pRect,BOOL bTextOnly);
   CExplorerTreeItem*   GetSelectedTreeItem();
   CExplorerTreeItem*   GetTreeItem(HTREEITEM hTreeItem) { return (CExplorerTreeItem*)GetItemData(hTreeItem); };

   BOOL                 ItemHasChildren();
   void                 ExpandSelected();

protected:
	BOOL                 InsertItem(CExplorerTreeItem* pItem,CExplorerTreeItem* pParent=NULL,CExplorerTreeItem* pInsertAfter=NULL, HTREEITEM hInsertAfter = TVI_LAST);
   virtual int          OnCompareTreeItems(CAVTreeItem* pItem1,CAVTreeItem* pItem2);
   virtual void         OnRightClick(CExplorerTreeItem* pItem,CPoint& pt);
   void                 EditLabel();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CExplorerTreeCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CExplorerTreeCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CExplorerTreeCtrl)
	afx_msg void OnRclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif //_AEXPLTRE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\avdialerdoc.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// ActiveDialerDoc.h : interface of the CActiveDialerDoc class
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_ACTIVEDIALERDOC_H__A0D7A962_3C0B_11D1_B4F9_00C04FC98AD3__INCLUDED_)
#define AFX_ACTIVEDIALERDOC_H__A0D7A962_3C0B_11D1_B4F9_00C04FC98AD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "tapidialer.h"
#include "avNotify.h"
#include "CallMgr.h"
#include "CallWnd.h"
#include "avDialerVw.h"
#include "PreviewWnd.h"
#include "PhonePad.h"
#include "DialReg.h"
#include "resolver.h"
#include "Queue.h"

#define ASK_TAPI				true
#define DONT_ASK_TAPI			(!ASK_TAPI)

#define INCLUDE_PREVIEW			true
#define DONT_INCLUDE_PREVIEW	(!INCLUDE_PREVIEW)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#define           CALLCONTROL_HOVER_TIMER          4

typedef enum tagLogCallType
{
   LOGCALLTYPE_OUTGOING=0,
   LOGCALLTYPE_INCOMING,
   LOGCALLTYPE_CONFERENCE,
}LogCallType;

enum
{
   CALLWND_SIDE_LEFT=0,
   CALLWND_SIDE_RIGHT,
};

////////////////////////////////////////////////////////////////////////////
// Don't ask me why we have all these different types of media...
// I just found them and started to try and simplify.  Because these are
// used all over the place I didn't want to spend the time to go through
// and do clean it up at the risk of losing stability -- we're in Beta3 mode
// right now.  Anyways... to whom it may concern, enjoy.  -Brad
//
DialerMediaType CMMToDMT( CallManagerMedia cmm );
long			CMMToAT( CallManagerMedia cmm ); 

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CAsynchEvent
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CAsynchEvent
{
public:
   CAsynchEvent()    { m_pCallEntry = NULL; m_uEventType = AEVENT_UNKNOWN; m_dwEventData1 = NULL; m_dwEventData2= NULL; };
   ~CAsynchEvent()   { if (m_pCallEntry) delete m_pCallEntry; }; 
public:
   CCallEntry*       m_pCallEntry;           //Call entry if needed
   UINT              m_uEventType;           //Type of event
   DWORD             m_dwEventData1;         //Event data specific to event
   DWORD             m_dwEventData2;         //Event data specific to event

public:
   enum
   {
      AEVENT_UNKNOWN=0,
      AEVENT_CREATECALL,
      AEVENT_ACTIONSELECTED,
   };
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CActiveDialerDoc
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CActiveDialerDoc : public CDocument
{
// enums
public:
   enum tagHintTypes
   {
      HINT_INITIAL_UPDATE,
      HINT_POST_TAPI_INIT,
	  HINT_POST_AVTAPI_INIT,
	  HINT_SPEEDDIAL_ADD,
	  HINT_SPEEDDIAL_MODIFY,
	  HINT_SPEEDDIAL_DELETE,
	  HINT_LDAP_UPDATE,
   };

protected: // create from serialization only
	CActiveDialerDoc();
	DECLARE_DYNCREATE(CActiveDialerDoc)

// Members
public:
   BOOL                    m_bInitDialer;
   bool                    m_bWantHover;
   CPhonePad               m_wndPhonePad;

   //DS/ILS/Directory access
   CDirAsynch				m_dir;

   //buddies list
   CObList					m_BuddyList;			//List of CLDAPUser's
   CRITICAL_SECTION			m_csBuddyList;			//Sync on data


protected:
	CRITICAL_SECTION		m_csThis;
	IAVTapi*				m_pTapi;
	CAVTapiNotification*	m_pTapiNotification;

	DWORD					m_dwTapiThread;
	HANDLE					m_hTapiThreadClose;

	IAVGeneralNotification*	m_pAVGeneralNotification;
	CGeneralNotification*	m_pGeneralNotification;

	//Aysnch Event Queue
	CQueue					m_AsynchEventQ;

	// User Resolver Object
	CResolveUser            m_ResolveUser;

	// Call control Windows
	CActiveCallManager   m_callMgr;
	CRITICAL_SECTION     m_csDataLock;              //Sync on data
	BOOL                 m_bCallControlWindowsVisible;
	CObList              m_CallWndList;             //list of call control windows
	BOOL                 m_bCallWndAlwaysOnTop;
	UINT                 m_uCallWndSide;            //CALLWND_SIDE_LEFT-Left CALLWND_SIDE_RIGHT-Right ...others maybe later

	// Preview Window
	CVideoPreviewWnd     m_previewWnd;
	BOOL                 m_bClosePreviewWndOnLastCall;
	BOOL                 m_bShowPreviewWnd;

	// Call control timer
	SIZE_T                 m_nCallControlHoverTimer;
	UINT                 m_uCallControlHoverCount;

	//Logging
	CRITICAL_SECTION     m_csLogLock;               //Sync on log

// Attributes
public:
   IAVTapi*             GetTapi();                 //Must release returned object
   CActiveDialerView*   GetView();

   // Call Control
   BOOL                 IsPtCallControlWindow(CPoint& pt);
   BOOL                 IsCallControlWindowsVisible()       { return m_bCallControlWindowsVisible; };
   BOOL                 IsCallControlWindowsAlwaysOnTop()   { return m_bCallWndAlwaysOnTop; };
   BOOL                 GetCallCaps(UINT uCallId,DWORD& dwCaps);
   BOOL                 GetCallMediaType(UINT uCallId,DialerMediaType& dmtMediaType);

   BOOL                 SetCallControlWindowsAlwaysOnTop(bool bAlwaysOnTop);
   UINT                 GetCallControlSlideSide()           { return m_uCallWndSide; };
   BOOL                 SetCallControlSlideSide(UINT uSide,BOOL bRepaint);

// Operations
public:
   void                 Initialize();
   static DWORD WINAPI  TapiCreateThreadEntry( LPVOID pParam );
   void                 TapiCreateThread();

   // User Resolver Methods
   CResolveUser*        GetResolveUserObject()     { return &m_ResolveUser; };

   // Call control
   BOOL                 CreateCallControl(UINT uCallId,CallManagerMedia cmm);
   void                 OnCreateCallControl(WORD nCallId,CallManagerMedia cmm);
   void                 DestroyActiveCallControl(CCallControlWnd* pCallWnd);
   void                 OnDestroyCallControl(CCallControlWnd* pCallWnd);

   int                  GetCallControlWindowCount(bool bIncludePreview, bool bAskTapi);
   BOOL                 HideCallControlWindows();
   BOOL                 UnhideCallControlWindows();
   BOOL                 HideCallControlWindow(CWnd* pWndToHide);
   void                 ToggleCallControlWindowsVisible();
   void                 ShiftCallControlWindows(int nShiftY);
   void                 CheckCallControlHover();
   void                 GetCallControlWindowText(CStringList& strList);
   void                 SelectCallControlWindow(int nWindow);
   void                 DestroyAllCallControlWindows();
   void                 BringCallControlWindowsToTop();
   void                 CheckCallControlStates();
   void                 SetStatesToolbarInCallControlWindows();
   
   // Call control actions
   void                 ActionSelected(UINT uCallId,CallManagerActions cma);
   void                 ActionRequested(CallClientActions cca);
   void                 PreviewWindowActionSelected(CallManagerActions cma);
   void                 ErrorNotify(LPCTSTR szOperation,LPCTSTR szDetails,long lErrorCode,UINT uErrorLevel);
   HRESULT              DigitPress( PhonePadKey nKey );

   // Video Window and Preview
   WORD					GetPreviewWindowCallId()		 { return m_previewWnd.GetCallId(); }
   void                 SetPreviewWindow(WORD nCallId, bool bShow);
   void                 ShowPreviewWindow(BOOL bShow);
   BOOL                 IsPreviewWindowVisible()                           { return m_bShowPreviewWnd; };

   BOOL                 ShowMedia(UINT uCallId,HWND hwndParent,BOOL bVisible);
   void                 ShowDialerExplorer(BOOL bShowWindow = TRUE);

   // PhonePad
   void                 CreatePhonePad(CWnd* pWnd);
   void                 DestroyPhonePad(CWnd* pWnd);
   void                 ShowPhonePad(CWnd* pWnd,BOOL bShow);

   void                 Dial( LPCTSTR lpszName, LPCTSTR lpszAddress, DWORD dwAddressType, DialerMediaType nMediaType, BOOL bShowDialog );
   void                 MakeCall(CCallEntry* pCallentry,BOOL bShowPlaceCallDialog=TRUE);

   // Registry Setting
   void                 SetRegistrySoundEvents();

   //Logging
   void                 LogCallLog(LogCallType calltype,COleDateTime& time,DWORD dwDuration,LPCTSTR szName,LPCTSTR szAddress);
   void                 CleanCallLog();

   //buddies list
   BOOL                 AddToBuddiesList(CLDAPUser* pUser);
   BOOL                 IsBuddyDuplicate(CLDAPUser* pUser);
   BOOL                 GetBuddiesList(CObList* pRetList);
   BOOL                 DeleteBuddy(CLDAPUser* pUser);
   void                 DoBuddyDynamicRefresh( CLDAPUser* pUser );
   static void CALLBACK LDAPGetStringPropertyCallBackEntry(bool bRet, void* pContext, LPCTSTR szServer, LPCTSTR szSearch,DirectoryProperty dpProperty,CString& sString,LPARAM lParam,LPARAM lParam2);
   void                 LDAPGetStringPropertyCallBack(bool bRet,LPCTSTR szServer,LPCTSTR szSearch,DirectoryProperty dpProperty,CString& sString,CLDAPUser* pUser );

   CWnd*                GetCurrentView()
                        {
                           POSITION pos = GetFirstViewPosition();
                           return (pos)?GetNextView(pos):NULL;
                        }

   void					CreateDataCall(CCallEntry* pCallEntry, BYTE *pBuf, DWORD dwBufSize );

   HRESULT              SetFocusToCallWindows();

protected:
	void				CleanBuddyList();

	//Logging
	BOOL                 FindOldRecordsInCallLog(CFile* pFile,DWORD dwDays,DWORD& dwRetOffset);
	BOOL                 GetDateTimeFromLog(LPCTSTR szData,COleDateTime& time);
	BOOL                 CopyToFile(LPCTSTR szTempFile,CFile* pFile,DWORD dwOffset, BOOL bUnicode);
    TCHAR*              ReadLine(CFile* pFile);

	bool                CreateGeneralNotificationObject();
	bool                CreateAVTapiNotificationObject();
	void				UnCreateAVTapiNotificationObject();
	void                UnCreateGeneralNotificationObject();

	void                 CreateCallSynch(CCallEntry* pCallentry,BOOL bShowPlaceCallDialog);

	//Conferences
	void                 CheckRectAgainstAppBars(UINT uEdge, CRect* pRect, BOOL bFirst);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CActiveDialerDoc)
	public:
	virtual BOOL OnNewDocument();
	virtual void SerializeBuddies(CArchive& ar);
	virtual void OnCloseDocument();
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CActiveDialerDoc();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

protected:

// Generated message map functions
protected:
	//{{AFX_MSG(CActiveDialerDoc)
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()

	// Generated OLE dispatch map functions
	//{{AFX_DISPATCH(CActiveDialerDoc)
		// NOTE - the ClassWizard will add and remove member functions here.
		//    DO NOT EDIT what you see in these blocks of generated code !
	//}}AFX_DISPATCH
	DECLARE_DISPATCH_MAP()
	DECLARE_INTERFACE_MAP()

};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACTIVEDIALERDOC_H__A0D7A962_3C0B_11D1_B4F9_00C04FC98AD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\avdialdoc.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// ActiveDialerDoc.cpp : implementation of the CActiveDialerDoc class
//

#include "stdafx.h"
#include "avDialer.h"
#include "avDialerDoc.h"
#include "MainFrm.h"
#include "tapidialer.h"
#include "tapidialer_i.c"
#include "videownd.h"
#include "CallCtrlWnd.h"
#include "queue.h"
#include "util.h"
#include "avtrace.h"
#include "AboutDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define UNICODE_TEXT_MARK       0xFEFF

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#define           CALLLOG_DEFAULT_LOGBUFFERDAYS    30
#define           CALLLOG_LOGBUFFER_COPYBUFFERSIZE 1024

#define           CALLCONTROL_HOVER_TIMER_INTERVAL 500
#define           CALLCONTROL_SLIDE_TIME           300

void              SlideWindow(CWnd* pWnd,CRect& rcEnd,BOOL bAlwaysOnTop );
void              NewSlideWindow(CWnd* pWnd,CRect& rcEnd,BOOL  );

void TagNewLineChars( CString &strText )
{
    int nInd;
    while ( (nInd = strText.FindOneOf(_T("\n\r\f"))) >= 0 )
        strText.SetAt(nInd, _T(';'));
}


DialerMediaType CMMToDMT( CallManagerMedia cmm )
{
    switch ( cmm )
    {
        case CM_MEDIA_INTERNET:        return DIALER_MEDIATYPE_INTERNET;
        case CM_MEDIA_POTS:            return DIALER_MEDIATYPE_POTS;
        case CM_MEDIA_MCCONF:        return DIALER_MEDIATYPE_CONFERENCE;
    }
    
    return DIALER_MEDIATYPE_UNKNOWN;
}

long CMMToAT( CallManagerMedia cmm )
{
    switch ( cmm )
    {
        case CM_MEDIA_INTERNET:        return LINEADDRESSTYPE_IPADDRESS;
        case CM_MEDIA_POTS:            return LINEADDRESSTYPE_PHONENUMBER;
        case CM_MEDIA_MCCONF:        return LINEADDRESSTYPE_SDP;
    }
    
    // When in doubt, use this one...
    return LINEADDRESSTYPE_IPADDRESS;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CActiveDialerDoc
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CActiveDialerDoc, CDocument)

BEGIN_MESSAGE_MAP(CActiveDialerDoc, CDocument)
    //{{AFX_MSG_MAP(CActiveDialerDoc)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

BEGIN_DISPATCH_MAP(CActiveDialerDoc, CDocument)
    //{{AFX_DISPATCH_MAP(CActiveDialerDoc)
        // NOTE - the ClassWizard will add and remove mapping macros here.
        //      DO NOT EDIT what you see in these blocks of generated code!
    //}}AFX_DISPATCH_MAP
END_DISPATCH_MAP()

// Note: we add support for IID_IActiveDialer to support typesafe binding
//  from VBA.  This IID must match the GUID that is attached to the 
//  dispinterface in the .ODL file.

// {A0D7A958-3C0B-11D1-B4F9-00C04FC98AD3}
static const IID IID_IActiveDialer =
{ 0xa0d7a958, 0x3c0b, 0x11d1, { 0xb4, 0xf9, 0x0, 0xc0, 0x4f, 0xc9, 0x8a, 0xd3 } };

BEGIN_INTERFACE_MAP(CActiveDialerDoc, CDocument)
    INTERFACE_PART(CActiveDialerDoc, IID_IActiveDialer, Dispatch)
END_INTERFACE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CActiveDialerDoc construction/destruction

CActiveDialerDoc::CActiveDialerDoc()
{
    EnableAutomation();
    AfxOleLockApp();

   m_pTapi = NULL;
   m_pTapiNotification = NULL;
   m_pGeneralNotification = NULL;
   m_pAVGeneralNotification = NULL;
   m_bInitDialer = FALSE;

   m_callMgr.Init( this );

   // Hover timer and controls
   CString sRegKey,sBaseKey;
   sBaseKey.LoadString(IDN_REGISTRY_CALLCONTROL_BASEKEY);
   sRegKey.LoadString(IDN_REGISTRY_CALLCONTROL_HOVER);
   m_bWantHover = (BOOL) (AfxGetApp()->GetProfileInt(sBaseKey, sRegKey, TRUE) == TRUE);
   m_nCallControlHoverTimer = 0;
   m_uCallControlHoverCount = 0;
   m_bCallControlWindowsVisible = FALSE;
   //where to show the windows
   sRegKey.LoadString(IDN_REGISTRY_CALLCONTROL_SLIDESIDE);
   m_uCallWndSide = AfxGetApp()->GetProfileInt(sBaseKey, sRegKey, CALLWND_SIDE_LEFT);

   // Always on top
   sRegKey.LoadString(IDN_REGISTRY_CALLCONTROL_ALWAYSONTOP);
   m_bCallWndAlwaysOnTop = AfxGetApp()->GetProfileInt(sBaseKey,sRegKey,TRUE);
   m_bClosePreviewWndOnLastCall = FALSE;

   // Thread management
   m_dwTapiThread = 0;
   m_hTapiThreadClose = CreateEvent( NULL, false, false, NULL );

   //Show the preview window
   m_bShowPreviewWnd = FALSE;

   //make sure the sounds are set properly in the control panel
   SetRegistrySoundEvents();

   InitializeCriticalSection(&m_csDataLock);
   InitializeCriticalSection(&m_csLogLock);
   InitializeCriticalSection(&m_csBuddyList);
   InitializeCriticalSection(&m_csThis);

    m_previewWnd.SetDialerDoc( this );
}

CActiveDialerDoc::~CActiveDialerDoc()
{
    CleanBuddyList();

    // Shutdown TAPI queue
    if ( m_dwTapiThread )
    {
        m_AsynchEventQ.Terminate();

        // Shut the thread down
        if (  WaitForSingleObject(m_hTapiThreadClose, 5000) != WAIT_OBJECT_0 )
        {
            AVTRACE(_T("CActiveDialerDoc::~CActiveDialerDoc() -- forced TERMINATION of worker thread!!!!"));
            TerminateThread((HANDLE)(DWORD_PTR)m_dwTapiThread, 0);
        }

        m_dwTapiThread = 0;
    }

    // Release handle
    if ( m_hTapiThreadClose )    CloseHandle( m_hTapiThreadClose );

    DeleteCriticalSection( &m_csDataLock );
    DeleteCriticalSection( &m_csLogLock );
    DeleteCriticalSection( &m_csBuddyList );
    DeleteCriticalSection( &m_csThis );

    // Save registry settings
    CString sRegKey,sBaseKey;
    sBaseKey.LoadString(IDN_REGISTRY_CALLCONTROL_BASEKEY);
    sRegKey.LoadString(IDN_REGISTRY_CALLCONTROL_ALWAYSONTOP);
    AfxGetApp()->WriteProfileInt(sBaseKey,sRegKey,m_bCallWndAlwaysOnTop);

    //where to show the windows
    sRegKey.LoadString(IDN_REGISTRY_CALLCONTROL_SLIDESIDE);
    AfxGetApp()->WriteProfileInt(sBaseKey,sRegKey,m_uCallWndSide);

    sBaseKey.LoadString(IDN_REGISTRY_AUDIOVIDEO_BASEKEY);
    sRegKey.LoadString(IDN_REGISTRY_AUDIOVIDEO_SHOWPREVIEW);
    AfxGetApp()->WriteProfileInt(sBaseKey,sRegKey,m_bShowPreviewWnd);

    AfxOleUnlockApp();
}

BOOL CActiveDialerDoc::OnNewDocument()
{
    if (!CDocument::OnNewDocument())
        return FALSE;

    // TODO: add reinitialization code here
    // (SDI documents will reuse this document)

    return TRUE;
}

void CActiveDialerDoc::Initialize()
{
    AVTRACE(_T("CActiveDialerDoc::Initialize()."));

    ///////////////////
    //load buddies list
    ///////////////////
    m_dir.Initialize();

    CString sBuddiesPath;
    GetAppDataPath(sBuddiesPath,IDN_REGISTRY_APPDATA_FILENAME_BUDDIES);
    CFile file;
    if (file.Open(sBuddiesPath,CFile::modeRead|CFile::shareDenyWrite))
    {
        CArchive ar(&file, CArchive::load | CArchive::bNoFlushOnDelete);
        ar.m_bForceFlat = FALSE;
        ar.m_pDocument = NULL;

        if (file.GetLength() != 0)
            SerializeBuddies(ar);

        ar.Close();
        file.Close();
    }

    // Create Tapi processing thread
    HANDLE hThreadTemp = CreateThread( NULL, 0, TapiCreateThreadEntry, this, 0, &m_dwTapiThread );
    if ( hThreadTemp )    CloseHandle( hThreadTemp );

    //Initialize ResolveUser Object
    m_ResolveUser.Init();

    //
    // We have to verify the pointer returned by AfxGetMainWnd()
    //

    CWnd* pMainWnd = AfxGetMainWnd();

    if( pMainWnd )
    {
        m_ResolveUser.SetParentWindow(AfxGetMainWnd());
    }

    //do regular clean up of log
    CleanCallLog();
}

/////////////////////////////////////////////////////
void CActiveDialerDoc::CleanBuddyList()
{
    EnterCriticalSection(&m_csBuddyList);

    POSITION pos = m_BuddyList.GetHeadPosition();
    while (pos)
    {
        long lRet = ((CLDAPUser *) m_BuddyList.GetNext(pos))->Release();
        AVTRACE(_T(".1.CActiveDialerDoc::CleanBuddyList() -- release @ %ld."), lRet );
    }

    m_BuddyList.RemoveAll();

    LeaveCriticalSection(&m_csBuddyList);
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::SerializeBuddies(CArchive& ar)
{
    try
    {
        if (ar.IsStoring())
        {
            CString sRegKey;
            sRegKey.LoadString(IDN_REGISTRY_APPLICATION_VERSION_NUMBER);
            int nVer = AfxGetApp()->GetProfileInt(_T(""),sRegKey,0);

            ar << nVer;

            EnterCriticalSection( &m_csBuddyList );
            ar << &m_BuddyList;
            LeaveCriticalSection( &m_csBuddyList );
        }
        else
        {
            //if previous object
            CObList *pList = NULL;

            DWORD dwVersion;
            ar >> dwVersion;
            ar >> pList;

            // Transfer list to buddy list and AddRef all objects
            CleanBuddyList();
            if ( pList )
            {
                EnterCriticalSection( &m_csBuddyList );
                POSITION rPos = pList->GetHeadPosition();
                while ( rPos )
                {
                    CLDAPUser *pUser = (CLDAPUser *) pList->GetNext( rPos );
                    if ( m_BuddyList.AddTail(pUser) )
                    {
                        pUser->AddRef();
                        DoBuddyDynamicRefresh( pUser );
                    }
                }
                LeaveCriticalSection( &m_csBuddyList );

                // Clean out list
                pList->RemoveAll();
                delete pList;
            }
        }
    }
    catch (...)
    {
        ASSERT(0);
    }
}

/////////////////////////////////////////////////////////////////////////////
#ifdef _DEBUG
void CActiveDialerDoc::AssertValid() const
{
    CDocument::AssertValid();
}

void CActiveDialerDoc::Dump(CDumpContext& dc) const
{
    CDocument::Dump(dc);
}
#endif //_DEBUG

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Tapi Methods
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//Must release returned object
IAVTapi* CActiveDialerDoc::GetTapi()
{
    IAVTapi *pRet = NULL;
    EnterCriticalSection( &m_csThis );
    if ( m_pTapi )
    {
        pRet = m_pTapi;
        pRet->AddRef();
    }
    LeaveCriticalSection( &m_csThis );

    return pRet;
}

///////////////////////////////////////////////////////////////////////////////////
// TAPI Create entry point (Static function)
DWORD WINAPI CActiveDialerDoc::TapiCreateThreadEntry( LPVOID pParam )
{
    ASSERT( pParam );
    CActiveDialerDoc* pDoc = (CActiveDialerDoc *) pParam;

    HRESULT hr = CoInitializeEx( NULL, COINIT_MULTITHREADED | COINIT_SPEED_OVER_MEMORY );
    if ( SUCCEEDED(hr) )
    {
        pDoc->TapiCreateThread();
        CoUninitialize();
    }

    SetEvent( pDoc->m_hTapiThreadClose );
    AVTRACE(_T(".enter.CActiveDialerDoc::TapiCreateThreadEntry() -- shutting down thread.") );
    return hr;
}

///////////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::TapiCreateThread()
{
    USES_CONVERSION;

    //check if /callto: was specified on the command line -- make a call if necessary
    // Create AVTapi objects
    if ( CreateGeneralNotificationObject() )
    {
        if ( CreateAVTapiNotificationObject() )
        {
            CActiveDialerApp* pApp = (CActiveDialerApp*)AfxGetApp();
            if ( pApp && !pApp->m_sInitialCallTo.IsEmpty() )
            {
                Dial( pApp->m_sInitialCallTo,
                      pApp->m_sInitialCallTo,
                      LINEADDRESSTYPE_IPADDRESS,
                      DIALER_MEDIATYPE_UNKNOWN,
                      false );
            }

            m_bInitDialer = TRUE;

            /////////////////////////////////
            //Main Aysnch Event Queue Handler
            /////////////////////////////////
            CAsynchEvent* pAEvent = NULL;
            while ( (pAEvent = (CAsynchEvent *) m_AsynchEventQ.ReadTail()) != NULL )
            {
                switch (pAEvent->m_uEventType)
                {
                    case CAsynchEvent::AEVENT_CREATECALL:
                        CreateCallSynch(pAEvent->m_pCallEntry,(BOOL)pAEvent->m_dwEventData1);
                        break;

                    case CAsynchEvent::AEVENT_ACTIONSELECTED:
                        {
                            //just route to all call object and let them figure out if they own the uCallId
                            IAVTapi* pTapi = GetTapi();
                            if (pTapi)
                            {
                                //dwEventData1 has uCallId
                                //dwEventData2 has CallManagerActions
                                pTapi->ActionSelected( (long) pAEvent->m_dwEventData1, (CallManagerActions) pAEvent->m_dwEventData2 );
                                pTapi->Release();
                            }
                        }
                        break;
                }
                delete pAEvent;
            }
            UnCreateAVTapiNotificationObject();
        }
        UnCreateGeneralNotificationObject();
    }
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::CreateCallSynch(CCallEntry* pCallEntry,BOOL bShowPlaceCallDialog)
{
   USES_CONVERSION;
   //move all this into a function and share with non-asynch way of doing it
   IAVTapi* pTapi = GetTapi();
   if (pTapi)
   {
        // Place the call
        AVCreateCall info = { 0 };
        ASSERT( info.lpszDisplayableAddress == NULL );

        info.lAddressType = pCallEntry->m_lAddressType;        
        info.bShowDialog = bShowPlaceCallDialog;
        info.bstrName = pCallEntry->m_sDisplayName.AllocSysString();
        info.bstrAddress =  pCallEntry->m_sAddress.AllocSysString();
      
        HRESULT hr = pTapi->CreateCall(&info);
        pCallEntry->m_lAddressType = info.lAddressType;

        // Did we place the call?
        if ( (SUCCEEDED(hr)) && ( (info.lRet == IDOK) || (bShowPlaceCallDialog == FALSE) ) )
        {
            pCallEntry->m_sAddress = OLE2CT( info.bstrAddress );
            pCallEntry->m_sDisplayName = OLE2CT( info.bstrName);

            if (pCallEntry->m_sDisplayName.IsEmpty())
                pCallEntry->m_sDisplayName = pCallEntry->m_sAddress;

            if (pCallEntry->m_MediaType == DIALER_MEDIATYPE_UNKNOWN)
            {
                switch ( pCallEntry->m_lAddressType )
                {
                    case LINEADDRESSTYPE_IPADDRESS:
                    pCallEntry->m_MediaType = DIALER_MEDIATYPE_INTERNET;
                    break;

                    case LINEADDRESSTYPE_PHONENUMBER:
                    pCallEntry->m_MediaType = DIALER_MEDIATYPE_POTS;
                    break;

                    case LINEADDRESSTYPE_SDP:
                    pCallEntry->m_MediaType = DIALER_MEDIATYPE_CONFERENCE;
                    break;
                }
            }

            // Should we add the number to the speeddial list?
            if ( info.bAddToSpeeddial )
                CDialerRegistry::AddCallEntry( FALSE, *pCallEntry );

            CDialerRegistry::AddCallEntry(TRUE,*pCallEntry);
        }

        // Clean up
        SysFreeString( info.bstrName );
        SysFreeString( info.bstrAddress );
        pTapi->Release();
    }
    else
    {
        AfxMessageBox( IDS_ERR_NO_TAPI_OBJECT, MB_ICONEXCLAMATION | MB_OK );
    }
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::CreateDataCall( CCallEntry *pCallEntry, BYTE *pBuf, DWORD dwBufSize )
{
   USES_CONVERSION;
   //move all this into a function and share with non-asynch way of doing it
   IAVTapi* pTapi = GetTapi();
   if (pTapi)
   {
        // Place the call
        AVCreateCall info = { 0 };
        ASSERT( info.lpszDisplayableAddress == NULL );

        pCallEntry->m_lAddressType = LINEADDRESSTYPE_IPADDRESS;
        pCallEntry->m_MediaType = DIALER_MEDIATYPE_INTERNET;

        BSTR bstrName = pCallEntry->m_sDisplayName.AllocSysString();
        BSTR bstrAddress = pCallEntry->m_sAddress.AllocSysString();
     
        HRESULT hr = pTapi->CreateDataCall( m_callMgr.NewIncomingCall(CM_MEDIA_INTERNETDATA),
                                            bstrName,
                                            bstrAddress,
                                            pBuf,
                                            dwBufSize );

        SysFreeString( bstrName );
        SysFreeString( bstrAddress );

        pTapi->Release();
    }
    else
    {
        AfxMessageBox( IDS_ERR_NO_TAPI_OBJECT, MB_ICONEXCLAMATION | MB_OK );
    }
}

///////////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::UnCreateAVTapiNotificationObject()
{
    // Clean up TAPI notification object
    EnterCriticalSection( &m_csThis );
    if ( m_pTapiNotification )
    {
        m_pTapiNotification->Shutdown();
        m_pTapiNotification->Release();
        m_pTapiNotification = NULL;
    }

    if ( m_pTapi )
    {
        m_pTapi->Term();
        m_pTapi->Release();
        m_pTapi = NULL;
    }
    LeaveCriticalSection( &m_csThis );
}

bool CActiveDialerDoc::CreateAVTapiNotificationObject()
{
    USES_CONVERSION;

    bool bRet = false;
    CString sOperation;
    CString sDetails;
    BSTR bstrOperation = NULL;
    BSTR bstrDetails = NULL;
    IAVTapi *pTapi = NULL;

    //Create the TAPI Dialer Object
    EnterCriticalSection( &m_csThis );
    HRESULT hr = CoCreateInstance( CLSID_AVTapi, NULL, CLSCTX_SERVER, IID_IAVTapi, (void **) &m_pTapi );
    if ( SUCCEEDED(hr) )
    {
        pTapi = m_pTapi;
        pTapi->AddRef();
    }
    LeaveCriticalSection( &m_csThis );

    // Did we successfully create the AVTapi object
    if ( SUCCEEDED(hr) )
    {
        HRESULT hrInit;
        hr = pTapi->Init( &bstrOperation, &bstrDetails, &hrInit );

        if ( SUCCEEDED(hr) )
        {
            //
            // We have to verify the pointer returned by AfxGetMainWnd()
            //

            CWnd* pMainWnd = AfxGetMainWnd();
            if ( pMainWnd )
                pMainWnd->PostMessage( WM_UPDATEALLVIEWS, 0, HINT_POST_TAPI_INIT );

            //set the parent hwnd in the tapi object
            pTapi->put_hWndParent( pMainWnd->GetSafeHwnd() );

            //Create TAPI Notification object
            EnterCriticalSection( &m_csThis );
            m_pTapiNotification = new CComObject<CAVTapiNotification>;
            m_pTapiNotification->AddRef();
            hr = m_pTapiNotification->Init( pTapi, &m_callMgr );
            LeaveCriticalSection( &m_csThis );

            if ( SUCCEEDED(hr) )
            {
                pMainWnd->PostMessage( WM_UPDATEALLVIEWS, 0, HINT_POST_AVTAPI_INIT );

                bRet = true;
            }
            else
            {
                // Failed to setup the conntection points
                sOperation.LoadString( IDS_ERR_INTERNAL );
                sDetails.LoadString( IDS_ERR_AVTAPINOTIFICATION_INIT );
                ErrorNotify( sOperation, sDetails, hr, ERROR_NOTIFY_LEVEL_INTERNAL );
            }
        }
        else
        {
            // Failed to initialize TAPI
            ErrorNotify( OLE2CT(bstrOperation), OLE2CT(bstrDetails), hrInit, ERROR_NOTIFY_LEVEL_INTERNAL );
        }
    }
    else
    {
        // Failed to CoCreate the AVTapi object
        sOperation.LoadString( IDS_ERR_CREATE_OBJECTS );
        sDetails.LoadString( IDS_ERR_AVTAPI_FAILED );
        ErrorNotify(sOperation, sDetails, hr, ERROR_NOTIFY_LEVEL_INTERNAL );
    }

    // Clean up
    RELEASE( pTapi );
    SysFreeString( bstrOperation );
    SysFreeString( bstrDetails );

    // If we failed to create and initialize, clean up objects
    if ( !bRet )
    {
        EnterCriticalSection( &m_csThis );
        RELEASE( m_pTapiNotification );
        RELEASE( m_pTapi );
        LeaveCriticalSection( &m_csThis );
    }

    return bRet;
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::UnCreateGeneralNotificationObject()
{
    // Clean up the general notification object
    EnterCriticalSection( &m_csThis );
    if (m_pGeneralNotification)
    {
        m_pGeneralNotification->Shutdown();
        m_pGeneralNotification->Release();
        m_pGeneralNotification = NULL;
    }

    if ( m_pAVGeneralNotification )
    {
        m_pAVGeneralNotification->Term();
        m_pAVGeneralNotification->Release();
        m_pAVGeneralNotification = NULL;
    }
    LeaveCriticalSection( &m_csThis );
}

bool CActiveDialerDoc::CreateGeneralNotificationObject()
{
    bool bRet = false;
    CString strMessage;

    //Create the AV General Notification object
    IAVGeneralNotification *pGen = NULL;
    EnterCriticalSection( &m_csThis );
    HRESULT hr = CoCreateInstance( CLSID_AVGeneralNotification, NULL, CLSCTX_SERVER, IID_IAVGeneralNotification, (void **) &m_pAVGeneralNotification );
    if ( SUCCEEDED(hr) )
    {
        pGen = m_pAVGeneralNotification;
        pGen->AddRef();
    }
    LeaveCriticalSection( &m_csThis );

    // Did we CoCreate successfully.
    if ( SUCCEEDED(hr) )
    {
        if ( SUCCEEDED(hr = pGen->Init()) )
        {
            //Create General Notification object
            EnterCriticalSection( &m_csThis );
            m_pGeneralNotification = new CComObject<CGeneralNotification>;
            m_pGeneralNotification->AddRef();
            hr = m_pGeneralNotification->Init( pGen, &m_callMgr );
            LeaveCriticalSection( &m_csThis );

            if ( SUCCEEDED(hr) )
            {
                // General notification up and running.
                bRet = true;
            }
            else
            {
                strMessage.LoadString( IDS_ERR_INIT_GENERALNOTIFICATION );
                ErrorNotify( strMessage, _T(""), hr, ERROR_NOTIFY_LEVEL_INTERNAL );
            }
        }
        else
        {
            strMessage.LoadString( IDS_ERR_INIT_GENERALNOTIFICATION );
            ErrorNotify( strMessage ,_T(""), hr, ERROR_NOTIFY_LEVEL_INTERNAL );
        }
    }
    else
    {
        strMessage.LoadString( IDS_ERR_COCREATE_GENERALNOTIFICATION );
        ErrorNotify( strMessage, _T(""), hr, ERROR_NOTIFY_LEVEL_INTERNAL );
    }

    // Clean up objects
    RELEASE( pGen );
    if ( !bRet )
    {
        EnterCriticalSection( &m_csThis );
        RELEASE( m_pGeneralNotification );
        RELEASE( m_pAVGeneralNotification );
        LeaveCriticalSection( &m_csThis );
    }

    return bRet;
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::ErrorNotify(LPCTSTR szOperation,LPCTSTR szDetails,long lErrorCode,UINT uErrorLevel)
{
    //
    // We have to verify the pointer returned by AfxGetMainWnd()
    //

    CWnd* pMainWnd = AfxGetMainWnd();

   if ( pMainWnd && IsWindow(pMainWnd->GetSafeHwnd()) )
   {
      ErrorNotifyData* pErrorNotifyData = new ErrorNotifyData;

      //
      // We have to verify the allocation of ErrorNotifyData object
      // We shouldn't deallocate the object because is deallocated 
      // into CMainFrame::OnActiveDialerErrorNotify() method
      //

      if( pErrorNotifyData )
      {
            pErrorNotifyData->sOperation = szOperation;
            pErrorNotifyData->sDetails = szDetails;
            pErrorNotifyData->lErrorCode = lErrorCode;
            pErrorNotifyData->uErrorLevel = uErrorLevel;

            pMainWnd->PostMessage( WM_DIALERVIEW_ERRORNOTIFY, NULL, (LPARAM)pErrorNotifyData );
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
//DWORD dwDuration - Duration of call in seconds
void CActiveDialerDoc::LogCallLog(LogCallType calltype,COleDateTime& time,DWORD dwDuration,LPCTSTR szName,LPCTSTR szAddress)
{
    TCHAR szQuote[] = _T("\"");
    TCHAR szQuoteComma[] = _T("\",");
    TCHAR szNewLine[] = _T("\x00d\x00a");
    //TCHAR szNewLine[] = _T("\x000D");
    CString strTemp;

    EnterCriticalSection(&m_csLogLock);

    //filter out calltypes
    CWinApp* pApp = AfxGetApp();
    CString sRegKey,sBaseKey;
    sBaseKey.LoadString(IDN_REGISTRY_LOGGING_BASEKEY);
    switch (calltype)
    {
        case LOGCALLTYPE_OUTGOING:
            sRegKey.LoadString(IDN_REGISTRY_LOGGING_OUTGOINGCALLS);
            if (pApp->GetProfileInt(sBaseKey,sRegKey,TRUE) != 1) return;
            break;

        case LOGCALLTYPE_INCOMING:
            sRegKey.LoadString(IDN_REGISTRY_LOGGING_INCOMINGCALLS);
            if (pApp->GetProfileInt(sBaseKey,sRegKey,TRUE) != 1) return;
            break;

        case LOGCALLTYPE_CONFERENCE:
            sRegKey.LoadString(IDN_REGISTRY_LOGGING_CONFERENCECALLS);
            if (pApp->GetProfileInt(sBaseKey,sRegKey,TRUE) != 1) return;
            break;
    }

    //Get path to log file
    CString sLogPath;
    GetAppDataPath(sLogPath,IDN_REGISTRY_APPDATA_FILENAME_LOG);

    CFile File;
    if ( File.Open(sLogPath, 
         CFile::modeCreate|                   //create new
         CFile::modeNoTruncate|               //don't truncate to zero
         CFile::modeReadWrite|                //read/write access
         CFile::shareDenyWrite))              //deny write access to others
    {
        // Write the UNICODE mark
        WORD  wUNICODE = UNICODE_TEXT_MARK;
        File.SeekToBegin();
        File.Write( &wUNICODE, sizeof(wUNICODE) );

        //Write to persistent file
        File.SeekToEnd();

        //resolve calltype to text
        CString sCallType;
        switch (calltype)
        {
            case LOGCALLTYPE_OUTGOING:    sCallType.LoadString(IDS_LOG_CALLTYPE_OUTGOING);   break;
            case LOGCALLTYPE_INCOMING:    sCallType.LoadString(IDS_LOG_CALLTYPE_INCOMING);   break;
            case LOGCALLTYPE_CONFERENCE:  sCallType.LoadString(IDS_LOG_CALLTYPE_CONFERENCE); break;
        }

        
        File.Write( szQuote, _tcslen(szQuote) * sizeof(TCHAR) );
        File.Write( sCallType, sCallType.GetLength() * sizeof(TCHAR) );
        File.Write( szQuoteComma, _tcslen(szQuoteComma) * sizeof(TCHAR) );
        //File.WriteString(szQuote);
        //File.WriteString(sCallType);
        //File.WriteString(szQuoteComma);

        //we are writing the format of the date and the time so COleDateTime can format/read the date/time 
        //back in.

        //write date mm/dd/yy
        strTemp = time.Format(_T("\"%#m/%#d/%Y"));
        File.Write( strTemp, strTemp.GetLength() * sizeof(TCHAR) );
        File.Write( szQuoteComma, _tcslen(szQuoteComma) * sizeof(TCHAR) );
        //File.WriteString(strTemp);
        //File.WriteString(szQuoteComma);

        //write time
        strTemp = time.Format(_T("\"%#H:%M"));
        File.Write( strTemp, strTemp.GetLength() * sizeof(TCHAR) );
        File.Write( szQuoteComma, _tcslen(szQuoteComma) * sizeof(TCHAR) );
        //File.WriteString(strTemp);
        //File.WriteString(szQuoteComma);

        //write duration
        DWORD dwMinutes = dwDuration/60;  
        DWORD dwSeconds = dwDuration - dwMinutes*60;
        strTemp.Format( _T("\"%d:%.2d"), dwMinutes, dwSeconds );
        File.Write( strTemp, strTemp.GetLength() * sizeof(TCHAR) );
        File.Write( szQuoteComma, _tcslen(szQuoteComma) * sizeof(TCHAR) );
        //File.WriteString(strTemp);
        //File.WriteString(szQuoteComma);


        //write name
        strTemp = szName;
        TagNewLineChars( strTemp );
        File.Write( szQuote, _tcslen(szQuote) * sizeof(TCHAR) );
        File.Write( strTemp, strTemp.GetLength() * sizeof(TCHAR) );
        File.Write( szQuoteComma, _tcslen(szQuoteComma) * sizeof(TCHAR) );
        //File.WriteString(szQuote);
        //File.WriteString(strTemp);
        //File.WriteString(szQuoteComma);

        //write address
        strTemp = szAddress;
        TagNewLineChars( strTemp );
        File.Write( szQuote, _tcslen(szQuote) * sizeof(TCHAR) );
        File.Write( strTemp, strTemp.GetLength() * sizeof(TCHAR) );
        File.Write( szQuote, _tcslen(szQuote) * sizeof(TCHAR) );
        //File.WriteString(szQuote);
        //File.WriteString(strTemp);
        //File.WriteString(szQuote);

        //CRLF and close file
        File.Write( szNewLine, _tcslen(szNewLine) * sizeof(TCHAR) );
        //File.WriteString(szNewLine);
        File.Close();
    }

    LeaveCriticalSection(&m_csLogLock);
}

/////////////////////////////////////////////////////////////////////////////
//DWORD dwDuration - Duration of call in seconds
void CActiveDialerDoc::CleanCallLog()
{
   EnterCriticalSection(&m_csLogLock);

   CWinApp* pApp = AfxGetApp();
   CString sRegKey,sBaseKey;
   sBaseKey.LoadString(IDN_REGISTRY_LOGGING_BASEKEY);
   sRegKey.LoadString(IDN_REGISTRY_LOGGING_LOGBUFFERSIZEDAYS);
   DWORD dwDays = pApp->GetProfileInt(sBaseKey,sRegKey,CALLLOG_DEFAULT_LOGBUFFERDAYS);

   //Walk log file and remove the following lines:
   // 1 - If date in log is newer than today
   // 2 - If date is older than today minus dwDays
   //If we run into a valid line in the log we quit and stop cleaning
   //Get path to log file

   CString sLogPath;
   GetAppDataPath(sLogPath,IDN_REGISTRY_APPDATA_FILENAME_LOG);

   CFile File;
   if (File.Open(sLogPath, 
                 CFile::modeCreate|                   //create new
                 CFile::modeNoTruncate|               //don't truncate to zero
                 CFile::modeReadWrite|                //read/write access
                 CFile::typeText|                     //text
                 CFile::shareDenyWrite))              //deny write access to others
   {
      BOOL bCloseFile = TRUE;
      DWORD dwOffset;
      if (FindOldRecordsInCallLog(&File,dwDays,dwOffset))
      {
         //now write all data past dwOffset to temp file
         CString sTempFile;
         if ( (GetTempFile(sTempFile)) && (CopyToFile(sTempFile,&File,dwOffset, FALSE)) )
         {
            //now write all data in temp file back to log
            File.Close();
            bCloseFile = FALSE;
            
            CFile TempFile;
            if (TempFile.Open(sTempFile, 
                   CFile::modeReadWrite|                //read/write access
                   CFile::typeText|                     //text
                   CFile::shareDenyWrite))              //deny write access to others
            {
               CopyToFile(sLogPath,&TempFile,0, TRUE);
               TempFile.Close();
               DeleteFile(sTempFile);
            }
         }
      }
      if (bCloseFile) File.Close();
   }

   LeaveCriticalSection(&m_csLogLock);
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveDialerDoc::FindOldRecordsInCallLog(CFile* pFile,DWORD dwDays,DWORD& dwRetOffset)
{
   COleDateTime currenttime = COleDateTime::GetCurrentTime();
   COleDateTimeSpan timespan(dwDays,0,0,0);
   COleDateTime basetime = currenttime-timespan;

   BOOL bRet = FALSE;
   dwRetOffset = 0;
   try
   {
      DWORD dwCurPos = pFile->GetPosition();

       //Read the unicode mark
       WORD wUNICODE = 0;
       pFile->Read( &wUNICODE, sizeof(wUNICODE) );

       if ( wUNICODE != UNICODE_TEXT_MARK)
           // Go back, is not a UNICODE file
           pFile->Seek(dwCurPos,CFile::begin);

       TCHAR* pszLine = NULL;

       while ( TRUE )
       {
            // Read a new line from the file
            pszLine = ReadLine( pFile );

            // Something wrong?
            if( NULL == pszLine )
                break;

            // Validates the time stamp
            COleDateTime logtime;
            if ( GetDateTimeFromLog(pszLine,logtime) && (logtime > basetime) && (logtime <= currenttime) )
            {
                //back up the file offset since this log record is okay
                pFile->Seek(dwCurPos,CFile::begin);
                delete pszLine;
                break;
            }

            // Increase the cursor position
            dwCurPos = pFile->GetPosition();

            // release the line
            delete pszLine;
       }

      //get offset of current file position
      dwRetOffset = pFile->GetPosition();
      if (dwRetOffset != 0)
         bRet = TRUE;
   }
   catch (...) {}
   return bRet;
}

/*++
ReadLine

Returns a TCHAR buffer with the line from a text file
Is called by FindOldRecordsInCallLog
If something is wrong returns NULL
--*/
TCHAR*  CActiveDialerDoc::ReadLine(
    CFile*  pFile
    )
{
    TCHAR* pszBuffer = NULL;    // The buffer
    DWORD dwCurrentSize = 128;  // The buffer size
    DWORD dwPosition = 0;       // The buffer offset
    TCHAR tchFetched;           // The TCHAR readed

    // Allocate the buffer
    pszBuffer = new TCHAR[dwCurrentSize];
    if( NULL == pszBuffer )
        return NULL;

    // Reset the buffer store
    memset( pszBuffer, 0, dwCurrentSize * sizeof(TCHAR) );

    while( TRUE )
    {
        // Read from the file
        if ( !pFile->Read(&tchFetched, sizeof(TCHAR)) )
        {
            if( dwPosition == 0)
            {
                // The buffer is empty, we don't neet it
                delete pszBuffer;
                pszBuffer = NULL;
            }

            return pszBuffer;   // EOF or Empty
        }

        // Add the new tCHAR to the buffer
        pszBuffer[dwPosition++] = tchFetched;

        // We got the end of the buffer?
        if( dwPosition >= dwCurrentSize - 1)
        {
            // Reallocate the buffer
            TCHAR* pszTemp = NULL;
            pszTemp = new TCHAR[dwCurrentSize * 2];
            if( NULL == pszTemp )
            {
                delete pszBuffer;
                return NULL;
            }

            // Reset the memory 
            memset(pszTemp, 0, dwCurrentSize * 2 * sizeof(TCHAR) );

            // Copy the old buffer into the new one
            memcpy(pszTemp, pszBuffer, dwCurrentSize * sizeof(TCHAR) );

            // Delete the old buffer
            delete pszBuffer;

            // Reassing the new one to the base pointer
            pszBuffer = pszTemp;

            // reset the current size of the buffer
            dwCurrentSize *= 2;
        }

        // Is the end of the line
        if( tchFetched == 0x000A)
            return pszBuffer;
    }

    return pszBuffer;
}
/////////////////////////////////////////////////////////////////////////////
BOOL CActiveDialerDoc::GetDateTimeFromLog(LPCTSTR szData,COleDateTime& time)
{
   BOOL bRet = FALSE;
   CString sDate,sTime;
   CString sEntry = szData;
   CString sValue;

   //get call type (skip for now)
   if (ParseTokenQuoted(sEntry,sValue) == FALSE) return FALSE;

   //get date
   if (ParseTokenQuoted(sEntry,sValue) == FALSE) return FALSE;
   sDate = sValue;

   //get time
   if (ParseTokenQuoted(sEntry,sValue) == FALSE) return FALSE;
   sTime = sValue;

   CString sParseDateTime = sDate + _T(" ") + sTime;

   if (time.ParseDateTime(sParseDateTime))
      bRet = TRUE;

   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveDialerDoc::CopyToFile(LPCTSTR szTempFile,CFile* pFile,DWORD dwOffset, BOOL bUnicode)
{
   BOOL bRet = FALSE;
   CFile* pTempFile = new CFile;
   if (pTempFile->Open(szTempFile, 
                   CFile::modeCreate|                   //create new
                   CFile::modeReadWrite|                //read/write access
                   //CFile::typeText|                     //text
                   CFile::shareDenyWrite))              //deny write access to others
   {
       if(bUnicode)
       {
            //Write the UNICODE flag
            WORD  wUNICODE = UNICODE_TEXT_MARK;
            pTempFile->Write( &wUNICODE, sizeof(wUNICODE) );
       }

      //seek to correct position in read file
      pFile->Seek(dwOffset,CFile::begin);
      
      BYTE* pBuffer = new BYTE[CALLLOG_LOGBUFFER_COPYBUFFERSIZE];
      UINT uReadCount = 0;
      while (uReadCount = pFile->Read(pBuffer,CALLLOG_LOGBUFFER_COPYBUFFERSIZE))
      {
         pTempFile->Write(pBuffer,uReadCount);   
      }
      delete pBuffer;
      bRet = TRUE;
      pTempFile->Close();
   }
   delete pTempFile;
   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Call Control Window Support
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc:: ActionSelected(UINT uCallId,CallManagerActions cma)
{
    //if the asynch queue is available, then send the request there
    //queue up the event
    CAsynchEvent* pAEvent = new CAsynchEvent;
    pAEvent->m_uEventType = CAsynchEvent::AEVENT_ACTIONSELECTED;
    pAEvent->m_dwEventData1 = (DWORD)uCallId;                //CallId
    pAEvent->m_dwEventData2 = (DWORD)cma;                    //CallManagerActions
    m_AsynchEventQ.WriteHead((void*) pAEvent);
    return;


   //just route to all call object and let them figure out if they own the uCallId
   IAVTapi* pTapi = GetTapi();
   if (pTapi)
   {
      pTapi->ActionSelected((long)uCallId,cma);
      pTapi->Release();
   }
//For testing only
#ifdef _DEBUG
   else if (0)
   {
      if (cma == CM_ACTIONS_CLOSE)
      {
         m_callMgr.CloseCallControl(uCallId);
      }
   }
#endif
//For testing only
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveDialerDoc::GetCallCaps(UINT uCallId,DWORD& dwCaps)
{
   BOOL bRet = FALSE;
   IAVTapi* pTapi = GetTapi();
   if (pTapi)
   {
      HRESULT hr = pTapi->get_dwCallCaps((long)uCallId, &dwCaps);
      pTapi->Release();
      bRet = SUCCEEDED(hr);
   }
   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveDialerDoc::GetCallMediaType(UINT uCallId,DialerMediaType& dmtMediaType)
{
   BOOL bRet = FALSE;

   //special case for conferences.  The uCallId is 0 for conferences
   if (uCallId == 0)
   {
      dmtMediaType = DIALER_MEDIATYPE_CONFERENCE;
      return TRUE;
   }

   IAVTapi* pTapi = GetTapi();
   if (pTapi)
   {
      IAVTapiCall* pTapiCall = NULL;
      HRESULT hr = pTapi->get_Call((long)uCallId, &pTapiCall);
      pTapi->Release();

      if ( (SUCCEEDED(hr)) && (pTapiCall) )
      {
         long lAddressType;
         pTapiCall->get_dwAddressType((DWORD*)&lAddressType);
         pTapiCall->Release();

         if (lAddressType == LINEADDRESSTYPE_PHONENUMBER)
            dmtMediaType = DIALER_MEDIATYPE_POTS;
         else if (lAddressType == LINEADDRESSTYPE_SDP)
            dmtMediaType = DIALER_MEDIATYPE_CONFERENCE;
         else
            dmtMediaType = DIALER_MEDIATYPE_INTERNET;

         bRet = TRUE;
      }
   }
   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveDialerDoc:: ShowMedia(UINT uCallId,HWND hwndParent,BOOL bVisible)
{
   BOOL bRet = FALSE;
   //just route to all call object and let them figure out if they own the uCallId
   IAVTapi* pTapi = GetTapi();
   if (pTapi)
   {
      HRESULT hr = pTapi->ShowMedia((long)uCallId,hwndParent,bVisible);
      pTapi->Release();
      bRet = SUCCEEDED(hr);
   }
   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveDialerDoc::CreateCallControl(UINT uCallId,CallManagerMedia cmm)
{
   //have to create new windows on our UI thread and on our own time

   //
   // We have to verify the pointer returned by AfxGetMainWnd()
   //

   CWnd* pMainWnd = AfxGetMainWnd();

   if ( pMainWnd )
   {
      pMainWnd->PostMessage(WM_DIALERVIEW_CREATECALLCONTROL,(WPARAM)uCallId,(LPARAM)cmm);
      return TRUE;
   }

   return FALSE;
}

////////////////////////////////////////////////////////////////
void CActiveDialerDoc::OnCreateCallControl(WORD nCallId,CallManagerMedia cmm)
{
    HWND hWnd = ::GetFocus();

    CCallControlWnd* pCallControlWnd = new CCallControlWnd();
    if (pCallControlWnd)
    {
        //to make parent of explorer frame - if (pCallControlWnd->Create(IDD_CALLCONTROL))
        //see OnCloseDocument() for more changes to make parent explorer frame
        //CWnd* pWnd = CWnd::GetDesktopWindow();
        if (pCallControlWnd->Create(IDD_CALLCONTROL,NULL))
        {
            pCallControlWnd->m_bAutoDelete = true;

            EnterCriticalSection(&m_csDataLock);
            m_CallWndList.AddTail(pCallControlWnd);
            //reset this state
            m_bCallControlWindowsVisible = FALSE;
            LeaveCriticalSection(&m_csDataLock);

            //
            // Get the IAVTapi2 interface
            // We'll pass these interface to the CaaControlWnd dialog
            // The dialog uses this interface to enable/disable
            // 'Take Call' button
            //

            IAVTapi* pAVTapi = GetTapi();
            if( pAVTapi )
            {
                // Get IAVTapi2 interface
                IAVTapi2* pAVTapi2 = NULL;
                HRESULT hr = pAVTapi->QueryInterface(
                    IID_IAVTapi2,
                    (void**)&pAVTapi2
                    );

                if( SUCCEEDED(hr) )
                {
                    //
                    // Pass the IAVTapi2 interface to the dialog
                    //

                    pCallControlWnd->m_pAVTapi2 = pAVTapi2;
                }

                // Clean-up
                pAVTapi->Release();
            }

            // Show the tray as Off-hook
            //
            // We have to verify the pointer returned by AfxGetMainWnd()
            //

            CMainFrame* pMainFrame = (CMainFrame*)AfxGetMainWnd();

            if( pMainFrame )
            {
                pMainFrame->m_trayIcon.SetIcon(IDR_TRAY_ACTIVE);
            }

            //init the call with the call manager
            m_callMgr.InitIncomingCall(pCallControlWnd,nCallId,cmm);

            //Check if we should show preview window on call.  Do this before adding new window
            if (m_bShowPreviewWnd == FALSE)
            {
                CWinApp* pApp = AfxGetApp();
                CString sRegKey,sBaseKey;
                sBaseKey.LoadString(IDN_REGISTRY_AUDIOVIDEO_BASEKEY);
                sRegKey.LoadString(IDN_REGISTRY_AUDIOVIDEO_SHOWPREVIEWONCALL);
                BOOL m_bPreviewOnCall = pApp->GetProfileInt(sBaseKey,sRegKey,TRUE);
                if ( (m_bPreviewOnCall) && (m_bShowPreviewWnd == FALSE) )
                {
                    //we are forcing the video preview on when it was currently off.  So when all
                    //calls are removed, we should get rid of this preview window
                    ShowPreviewWindow(TRUE);

                    m_bClosePreviewWndOnLastCall = TRUE;
                }
            }

            //bring the calls out
            UnhideCallControlWindows();
            pCallControlWnd->SetForegroundWindow();
        }
        else
        {
            delete pCallControlWnd;
            pCallControlWnd = NULL;
        }
    }

    // Restore focus to appropriate window...
    if ( hWnd ) ::SetFocus( hWnd );
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::DestroyActiveCallControl(CCallControlWnd* pCallWnd)
{
   //have to create new windows on our UI thread
   //
   // We have to verify the pointer returned by AfxGetMainWnd()
   //

   CWnd* pMainWnd = AfxGetMainWnd();

   if ( pMainWnd )
      pMainWnd->PostMessage(WM_DIALERVIEW_DESTROYCALLCONTROL,NULL,(LPARAM)pCallWnd);
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::OnDestroyCallControl(CCallControlWnd* pCallWnd)
{
   int nListCount = 0;
   if (pCallWnd == NULL) return;

   //find call window in our list's
   EnterCriticalSection(&m_csDataLock);

   POSITION pos = m_CallWndList.GetHeadPosition();
   while (pos)
   {
      CWnd* pWindow = (CWnd*)m_CallWndList.GetAt(pos);

      // Is this the window we want to destroy? 
      if ( pWindow == pCallWnd )
      {
         //hide the phone pad if there is one associated with it
         DestroyPhonePad(pCallWnd);

         //if we have focus, then give to other call window and not preview window
         if (::GetActiveWindow() == pWindow->GetSafeHwnd())
         {
            //first we will try the head, then the next in list
            POSITION newpos = m_CallWndList.GetHeadPosition();
            CWnd* pWindow = (CWnd*)m_CallWndList.GetNext(newpos);
            if ( (pWindow == pCallWnd) && (newpos) )
               pWindow = (CWnd*)m_CallWndList.GetNext(newpos);
            if (pWindow) pWindow->SetActiveWindow();
         }

         //slide the window off and sort the rest
         HideCallControlWindow(pCallWnd);

         //remove from call list
         m_CallWndList.RemoveAt(pos);

         // Destroy it
//         pWindow->PostMessage( WM_CLOSE );
         pWindow->DestroyWindow();

         break;
      }
      m_CallWndList.GetNext(pos);
   }

   nListCount = (int) m_CallWndList.GetCount();
   LeaveCriticalSection(&m_csDataLock);

   //
   // We have to verify the pointer returned by AfxGetMainWnd()
   //

   CWnd* pMainWnd = AfxGetMainWnd();

   if (GetCallControlWindowCount(DONT_INCLUDE_PREVIEW, DONT_ASK_TAPI) == 0)
   {
      //if we are doing callcontrol hover, delete timer

      if ( m_nCallControlHoverTimer && (nListCount == 0) &&
           pMainWnd && pMainWnd->KillTimer(m_nCallControlHoverTimer) )
      {
         m_nCallControlHoverTimer = 0;
      }

      //If count of calls in just the preview window call and m_bClosePreviewWndOnLastCall then close preview
      if (m_bClosePreviewWndOnLastCall)
      {
         m_previewWnd.CloseFloatingWindow();
         ShowPreviewWindow(FALSE);
         m_bClosePreviewWndOnLastCall = FALSE;
      }
      ((CMainFrame *) pMainWnd)->m_trayIcon.SetIcon(IDR_TRAY_NORMAL);
   }
   else
      ((CMainFrame *) pMainWnd)->m_trayIcon.SetIcon(IDR_TRAY_ACTIVE);
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::DestroyAllCallControlWindows()
{
   EnterCriticalSection(&m_csDataLock);

   if ( m_wndPhonePad.GetSafeHwnd() )
   {
      m_wndPhonePad.SetPeerWindow(NULL);
      m_wndPhonePad.ShowWindow(SW_HIDE);
   }

   //clear the callid/window map in the call manager
   m_callMgr.ClearCallControlMap();

   //destroy the call control windows, excluding preview window
   POSITION pos = m_CallWndList.GetHeadPosition();
   while (pos)
   {
      CWnd* pWindow = (CWnd*) m_CallWndList.GetNext(pos);
      if ( (pWindow->GetSafeHwnd()) && (pWindow->GetSafeHwnd() != m_previewWnd.GetSafeHwnd()) )
         pWindow->DestroyWindow();
   }

   //destroy preview window
   if (m_previewWnd.GetSafeHwnd())
   {
      m_previewWnd.DestroyWindow();
   }

   m_CallWndList.RemoveAll();
   LeaveCriticalSection(&m_csDataLock);
}


/////////////////////////////////////////////////////////////////////////////
int CActiveDialerDoc::GetCallControlWindowCount(bool bIncludePreview, bool bAskTapi )
{
    //find call window in our list's
    EnterCriticalSection(&m_csDataLock);

    int nRet = (int) m_CallWndList.GetCount();

    if ( !bIncludePreview && (nRet > 0) && m_bShowPreviewWnd )
        nRet--;

    //Ask TAPI, maybe it know's about calls
    if ( bAskTapi )
    {
        IAVTapi* pTapi = GetTapi();
        if (pTapi)
        {
            long nCalls = 0;
            if ( (SUCCEEDED(pTapi->get_nNumCalls(&nCalls))) && (nCalls > 0) )
                nRet = max(nCalls, nRet);

            pTapi->Release();
        }
    }

    LeaveCriticalSection(&m_csDataLock);
    return nRet;
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::ToggleCallControlWindowsVisible()
{
   if ( IsCallControlWindowsVisible() )
      HideCallControlWindows();
   else
      UnhideCallControlWindows();
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveDialerDoc::HideCallControlWindows()
{
   BOOL bRet = FALSE;
   EnterCriticalSection(&m_csDataLock);

   if (m_bCallControlWindowsVisible == FALSE)
   {
      LeaveCriticalSection(&m_csDataLock);
      return FALSE;
   }

   POSITION pos = m_CallWndList.GetTailPosition();
   while (pos)
   {
      CWnd* pWindow = (CWnd*)m_CallWndList.GetPrev(pos);
      if ( (pWindow) && (::IsWindow(pWindow->GetSafeHwnd())) )
      {
         //hide the phone pad if there is one associated with it
         ShowPhonePad(pWindow,FALSE);

         BOOL bSlide = TRUE;
         if (bSlide)
         {
            CRect rect;
            pWindow->GetWindowRect(rect);

            if (m_uCallWndSide == CALLWND_SIDE_LEFT)
               rect.OffsetRect(-rect.Width(),0);
            else if (m_uCallWndSide == CALLWND_SIDE_RIGHT)
               rect.OffsetRect(rect.Width(),0);

            NewSlideWindow(pWindow,rect,m_bCallWndAlwaysOnTop);
         }

         //slide window
         pWindow->ShowWindow(SW_HIDE);

         bRet = TRUE;

         //if we are asked to only hide a portion of the windows
         //if (pWindow == pCallWnd)
         //   break;
      }
   }
   m_bCallControlWindowsVisible = FALSE;

    //
    // We have to verify the pointer returned by AfxGetMainWnd()
    //

    CWnd* pMainWnd = AfxGetMainWnd();

    if( pMainWnd )
    {
        // Turn on the call hover timer
        if ( !m_nCallControlHoverTimer && m_bWantHover && pMainWnd && (m_CallWndList.GetCount() > 0) )
            m_nCallControlHoverTimer = pMainWnd->SetTimer(CALLCONTROL_HOVER_TIMER,CALLCONTROL_HOVER_TIMER_INTERVAL,NULL); 
    }

    LeaveCriticalSection(&m_csDataLock);

    if( pMainWnd )
        ((CMainFrame *) pMainWnd)->NotifyHideCallWindows();

    return bRet;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveDialerDoc::HideCallControlWindow(CWnd* pWndToHide)
{
   BOOL bRet = FALSE;
   EnterCriticalSection(&m_csDataLock);

   if (m_bCallControlWindowsVisible == FALSE)
   {
      LeaveCriticalSection(&m_csDataLock);
      return FALSE;
   }

    POSITION pos = m_CallWndList.GetHeadPosition();
    while (pos)
    {
        CWnd* pWindow = (CWnd*)m_CallWndList.GetNext(pos);
        if ( (pWindow) && (::IsWindow(pWindow->GetSafeHwnd())) )
        {
            if (pWndToHide == pWindow)
            {
                //hide the phone pad if there is one associated with it
                ShowPhonePad(pWindow,FALSE);

                CRect rect;
                pWindow->GetWindowRect(rect);

                //slide window
                BOOL bSlide = TRUE;
                if (bSlide)
                {
                    if (m_uCallWndSide == CALLWND_SIDE_LEFT)
                        rect.OffsetRect(-rect.Width(),0);
                    else if (m_uCallWndSide == CALLWND_SIDE_RIGHT)
                        rect.OffsetRect(rect.Width(),0);

                    NewSlideWindow(pWindow,rect,m_bCallWndAlwaysOnTop);
                }
                //hide the window
                pWindow->ShowWindow(SW_HIDE);

                CRect rectPrev;

                //now go through the rest of the windows and shift them up
                while (pos)
                {
                    CWnd* pWindow = (CWnd*)m_CallWndList.GetNext(pos);
                    if ( (pWindow) && (::IsWindow(pWindow->GetSafeHwnd())) )
                    {
                        CRect rcWindow;
                        pWindow->GetWindowRect(rcWindow);

                        //use the height of the window to remove for the shift distance
                        CRect rcFinal(rcWindow);
                        rcFinal.OffsetRect(0,-rect.Height());

                        // Shift window up or keep in same spot depending on the possibility of overlap
                        if ( rectPrev.IsRectEmpty() || (rcFinal.top > rectPrev.top) )
                            NewSlideWindow( pWindow, rcFinal, m_bCallWndAlwaysOnTop );
                        else
                            NewSlideWindow( pWindow, rcWindow, m_bCallWndAlwaysOnTop );

                        //show the phone pad if there is one associated with it
                        ShowPhonePad(pWindow,TRUE);

                        rectPrev = rcFinal;
                    }
                }

                //now set the state toolbar in the call windows.  Only the first window should
                //be showing this toolbar
                SetStatesToolbarInCallControlWindows();

                bRet = TRUE;
            }
        }
    }

    LeaveCriticalSection(&m_csDataLock);

    return bRet;
}

/////////////////////////////////////////////////////////////////////////////
// bUpDown - Direction window are tiled with respect to uWindowPosY
BOOL CActiveDialerDoc::UnhideCallControlWindows()
{
   BOOL bRet = FALSE;

   EnterCriticalSection(&m_csDataLock);
   
   UINT uPosY = 0;
   BOOL bFirst = TRUE;

   POSITION pos = m_CallWndList.GetHeadPosition();
   while (pos)
   {
      CWnd* pWindow = (CWnd*)m_CallWndList.GetNext(pos);
      if ( (pWindow) && (::IsWindow(pWindow->GetSafeHwnd())) )
      {
         //set states toolbar in callcontrolwindow
         ShowStatesToolBar(pWindow,m_bCallWndAlwaysOnTop,bFirst);

         CRect rcWindow;
         pWindow->GetWindowRect(rcWindow);

         CRect rcFinal(0,0,0,0);
         if (m_uCallWndSide == CALLWND_SIDE_LEFT)
         {
            rcFinal.SetRect(0,uPosY,rcWindow.Width(),uPosY+rcWindow.Height());

            //make sure we don't interfere with current windows taskbars
            CheckRectAgainstAppBars( ABE_LEFT, &rcFinal, bFirst );

            //if window is not visible then slide in, otherwise just slide from present position
            if (pWindow->IsWindowVisible() == FALSE)
            {
               pWindow->SetWindowPos((m_bCallWndAlwaysOnTop)?&CWnd::wndTopMost:&CWnd::wndNoTopMost/*wndTop*/,
                               0-rcWindow.Width(),rcFinal.top,rcWindow.Width(),rcWindow.Height(),SWP_NOACTIVATE|SWP_SHOWWINDOW);
               //pWindow->SetWindowPos((m_bCallWndAlwaysOnTop)?&CWnd::wndTopMost:&CWnd::wndNoTopMost/*wndTop*/,
               //                0-rcWindow.Width(),rcFinal.top,0,rcFinal.bottom,/*SWP_NOACTIVATE|*/SWP_SHOWWINDOW);
            }
         }
         else if (m_uCallWndSide == CALLWND_SIDE_RIGHT)
         {
            rcFinal.SetRect(GetSystemMetrics(SM_CXSCREEN)-rcWindow.Width(),uPosY,GetSystemMetrics(SM_CXSCREEN),uPosY+rcWindow.Height());

            //make sure we don't interfere with current windows taskbars
            CheckRectAgainstAppBars( ABE_RIGHT, &rcFinal, bFirst );

            //if window is not visible then slide in, otherwise just slide from present position
            if (pWindow->IsWindowVisible() == FALSE)
            {
               //pWindow->SetWindowPos((m_bCallWndAlwaysOnTop)?&CWnd::wndTopMost:&CWnd::wndNoTopMost/*wndTop*/,
               //                GetSystemMetrics(SM_CXSCREEN),rcFinal.top,GetSystemMetrics(SM_CXSCREEN)+rcWindow.Width(),rcFinal.bottom,SWP_NOACTIVATE|SWP_SHOWWINDOW);
               pWindow->SetWindowPos((m_bCallWndAlwaysOnTop)?&CWnd::wndTopMost:&CWnd::wndNoTopMost/*wndTop*/,
                               GetSystemMetrics(SM_CXSCREEN),rcFinal.top,rcWindow.Width(),rcWindow.Height(),SWP_NOACTIVATE|SWP_SHOWWINDOW);
            }
         }
         
         NewSlideWindow(pWindow,rcFinal,m_bCallWndAlwaysOnTop);

         //show the phone pad if there is one associated with it
         ShowPhonePad(pWindow,TRUE);

         //reget the window position
         pWindow->GetWindowRect(rcWindow);
         uPosY = rcWindow.bottom;

         bRet = TRUE;
         bFirst = FALSE;
      }
   }

    if (bRet) 
        m_bCallControlWindowsVisible = TRUE;

    //make sure we are at the top
    BringCallControlWindowsToTop();

    LeaveCriticalSection(&m_csDataLock);

    //
    // We have to verify the pointer returned by AfxGetMainWnd()
    //

    CWnd* pMainWnd = AfxGetMainWnd();

    if( pMainWnd )
    {
        //if we are doing callcontrol hover, delete timer
        if ( m_nCallControlHoverTimer && pMainWnd && pMainWnd->KillTimer(m_nCallControlHoverTimer) )
            m_nCallControlHoverTimer = 0;

        // Show the proper toolbar on the mainframe
        ((CMainFrame *) pMainWnd)->NotifyUnhideCallWindows();
    }

    return bRet;
    }

/////////////////////////////////////////////////////////////////////////////
//walks through call windows and makes sure states toolbar is set to top
//most window and nobody else is showing it
void CActiveDialerDoc::SetStatesToolbarInCallControlWindows()
{
   EnterCriticalSection(&m_csDataLock);
   BOOL bFirst = TRUE;

   POSITION pos = m_CallWndList.GetHeadPosition();
   while (pos)
   {
      CWnd* pWindow = (CWnd*)m_CallWndList.GetNext(pos);
      if ( (pWindow) && (::IsWindow(pWindow->GetSafeHwnd())) )
      {
         //set states toolbar in callcontrolwindow
         ShowStatesToolBar(pWindow,m_bCallWndAlwaysOnTop,bFirst);
         if (bFirst) bFirst = FALSE;
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::BringCallControlWindowsToTop()
{
   AVTRACE(_T("BringCallControlWindowsToTop"));

   EnterCriticalSection(&m_csDataLock);
   
   int nWindowCount = (int) m_CallWndList.GetCount();
   
   CMainFrame* pFrame = (CMainFrame*)AfxGetMainWnd();
   if (pFrame == NULL) 
   {
      LeaveCriticalSection(&m_csDataLock);
      return;
   }

   //we will control the main window if we are not always on top
   if ( (m_bCallWndAlwaysOnTop == FALSE) && (pFrame->GetStyle() & WS_VISIBLE) )
      nWindowCount += 1;

   HDWP hdwp = ::BeginDeferWindowPos(nWindowCount);
   if (hdwp == NULL)
   {
      LeaveCriticalSection(&m_csDataLock);
      return;
   }

   POSITION pos = m_CallWndList.GetHeadPosition();
   HWND hwndPrev = NULL;
   while (pos)
   {
      CWnd* pWindow = (CWnd*)m_CallWndList.GetNext(pos);

      if ( (pWindow) && (::IsWindow(pWindow->GetSafeHwnd())) && (pWindow->IsWindowVisible()) )
      {
          //
          // deferWindowPos might allocate a new hdwp
          //
         hdwp = ::DeferWindowPos(hdwp,
                          pWindow->GetSafeHwnd(),
                          (hwndPrev)?hwndPrev:(m_bCallWndAlwaysOnTop)?HWND_TOPMOST:HWND_TOP,
                          0,0,0,0,
                          SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE|SWP_SHOWWINDOW);

         //
         // DeferWindow Pos couldn't allocate new memory
         //

         if( NULL == hdwp )
         {
              LeaveCriticalSection(&m_csDataLock);
              return;
         }

         hwndPrev = pWindow->GetSafeHwnd();
      }
   }

   //if we are not always on top, put the main window below call control windows
   if ( (m_bCallWndAlwaysOnTop == FALSE) && (pFrame->GetStyle() & WS_VISIBLE) )
   {
       //
       // DeferWindowPos moght allocate a new hdwp
       //

      hdwp = ::DeferWindowPos(hdwp,
                    pFrame->GetSafeHwnd(),
                    (hwndPrev)?hwndPrev:HWND_TOP,
                    0,0,0,0,
                    SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE|SWP_SHOWWINDOW);
   }

   //
   // DeferWindowPos might modify hdwp
   //

   if( hdwp )
   {
        ::EndDeferWindowPos(hdwp);
   }

   LeaveCriticalSection(&m_csDataLock);
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::ShiftCallControlWindows(int nShiftY)
{
   EnterCriticalSection(&m_csDataLock);
   
   BOOL bHead = (nShiftY < 0);
   
   POSITION pos = (bHead)?m_CallWndList.GetHeadPosition():m_CallWndList.GetTailPosition();
   while (pos)
   {
      CWnd* pWindow = (bHead)?(CWnd*)m_CallWndList.GetNext(pos):(CWnd*)m_CallWndList.GetPrev(pos);
      if ( (pWindow) && (::IsWindow(pWindow->GetSafeHwnd())) )
      {
         CRect rcWindow;
         pWindow->GetWindowRect(rcWindow);

         CRect rcFinal(rcWindow);
         rcFinal.OffsetRect(0,nShiftY);
            
         NewSlideWindow(pWindow,rcFinal,m_bCallWndAlwaysOnTop);

         //show the phone pad if there is one associated with it
         ShowPhonePad(pWindow,TRUE);
      }
   }
   LeaveCriticalSection(&m_csDataLock);
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveDialerDoc::IsPtCallControlWindow(CPoint& pt)
{
   BOOL bRet = FALSE;
   EnterCriticalSection(&m_csDataLock);

   POSITION pos = m_CallWndList.GetHeadPosition();
   while (pos)
   {
      CWnd* pWindow = (CWnd*)m_CallWndList.GetNext(pos);
      if ( (pWindow) && (::IsWindow(pWindow->GetSafeHwnd())) )
      {
         CRect rect;
         pWindow->GetWindowRect(rect);
         if (rect.PtInRect(pt))
         {
            bRet = TRUE;
            break;
         }
      }
   }
   
   LeaveCriticalSection(&m_csDataLock);
   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveDialerDoc::SetCallControlWindowsAlwaysOnTop(bool bAlwaysOnTop )
{
    BOOL bRet = FALSE;

    HWND hWndActive = ::GetActiveWindow();

    EnterCriticalSection(&m_csDataLock);

    m_bCallWndAlwaysOnTop = bAlwaysOnTop;

    POSITION pos = m_CallWndList.GetTailPosition();
    while (pos)
    {
        CWnd* pWindow = (CWnd *) m_CallWndList.GetPrev(pos);
        if ( (pWindow) && (::IsWindow(pWindow->GetSafeHwnd())) )
        {
            // Set state of window
            if (m_bCallWndAlwaysOnTop)
                pWindow->SetWindowPos(&CWnd::wndTopMost,0,0,0,0,SWP_NOACTIVATE|SWP_SHOWWINDOW|SWP_NOMOVE|SWP_NOSIZE);
            else
                pWindow->SetWindowPos(&CWnd::wndNoTopMost,0,0,0,0,SWP_NOACTIVATE|SWP_SHOWWINDOW|SWP_NOMOVE|SWP_NOSIZE);

            pWindow->PostMessage( WM_SLIDEWINDOW_UPDATESTATESTOOLBAR );
            bRet = TRUE;
        }
    }
    LeaveCriticalSection(&m_csDataLock);

    // Should the call window be on top?
    if ( m_wndPhonePad.GetSafeHwnd() )
    m_wndPhonePad.SetWindowPos( (m_bCallWndAlwaysOnTop) ? &CWnd::wndTopMost : &CWnd::wndTop, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE );

    ::SetActiveWindow( hWndActive );
    return bRet;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveDialerDoc::SetCallControlSlideSide(UINT uSide,BOOL bRepaint)
{
   //if no change return
   if (uSide == m_uCallWndSide) return FALSE;

   if (bRepaint)
      HideCallControlWindows();

   //set the new state
   m_uCallWndSide = uSide;

   //show the windows on the correct side
   if (bRepaint)
      UnhideCallControlWindows();

   return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::CheckCallControlStates()
{
   CWnd* pWnd = AfxGetMainWnd();
   if (pWnd) pWnd->PostMessage(WM_ACTIVEDIALER_CALLCONTROL_CHECKSTATES);
}

/////////////////////////////////////////////////////////////////////////////
void SlideWindow(CWnd* pWnd,CRect& rcEnd,BOOL bAlwaysOnTop)
{
   BOOL fFullDragOn;

   // Only slide the window if the user has FullDrag turned on
   ::SystemParametersInfo(SPI_GETDRAGFULLWINDOWS, 0, &fFullDragOn, 0);

   // Get the current window position
   CRect rcStart;
   pWnd->GetWindowRect(rcStart);   

   if (fFullDragOn && (rcStart != rcEnd)) {

      // Get our starting and ending time.
      DWORD dwTimeStart = GetTickCount();
      DWORD dwTimeEnd = dwTimeStart + CALLCONTROL_SLIDE_TIME;
      DWORD dwTime;

      while ((dwTime = ::GetTickCount()) < dwTimeEnd) {

         // While we are still sliding, calculate our new position
         int x = rcStart.left - (rcStart.left - rcEnd.left) 
            * (int) (dwTime - dwTimeStart) / CALLCONTROL_SLIDE_TIME;

         int y = rcStart.top  - (rcStart.top  - rcEnd.top)  
            * (int) (dwTime - dwTimeStart) / CALLCONTROL_SLIDE_TIME;

         int nWidth  = rcStart.Width()  - (rcStart.Width()  - rcEnd.Width())  
            * (int) (dwTime - dwTimeStart) / CALLCONTROL_SLIDE_TIME;

         int nHeight = rcStart.Height() - (rcStart.Height() - rcEnd.Height()) 
            * (int) (dwTime - dwTimeStart) / CALLCONTROL_SLIDE_TIME;

         // Show the window at its changed position
         pWnd->SetWindowPos((bAlwaysOnTop)?&CWnd::wndTopMost:&CWnd::wndNoTopMost,
         //pWnd->SetWindowPos((bAlwaysOnTop)?&CWnd::wndTopMost:&CWnd::wndTop,
                            x, y, nWidth, nHeight,SWP_NOACTIVATE/* | SWP_DRAWFRAME*/);
         pWnd->RedrawWindow();
      }
   }

    // Make sure that the window is at its final position
    pWnd->SetWindowPos( &CWnd::wndTopMost, rcEnd.left, rcEnd.top, rcEnd.Width(), rcEnd.Height(), SWP_NOACTIVATE );

    if ( !bAlwaysOnTop )
        pWnd->SetWindowPos( &CWnd::wndNoTopMost, rcEnd.left, rcEnd.top, rcEnd.Width(), rcEnd.Height(), SWP_NOACTIVATE );

    pWnd->RedrawWindow();
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Preview Window Support
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::SetPreviewWindow(WORD nCallId, bool bVisible )
{
    if (!IsWindow(m_previewWnd.GetSafeHwnd())) return;

    //get preview window hwnd
    HWND hWndToPaint = m_previewWnd.GetCurrentVideoWindow();
    m_previewWnd.SetCallId(nCallId);

    //set the mixers
    DialerMediaType dmtMediaType = DIALER_MEDIATYPE_UNKNOWN;
    GetCallMediaType(nCallId,dmtMediaType);   //get the media type for the callid
    m_previewWnd.SetMixers(dmtMediaType);

    if (hWndToPaint == NULL) return;

    // For hiding preview, show as audio only
    if ( !bVisible )
    {
        m_previewWnd.SetAudioOnly(true);
        return;
    }


    //Let's just call showmediapreview in all cases.  We maybe in a conference and have no call control
    //windows, but we still have a preview stream coming from tapi
    IAVTapi* pTapi = GetTapi();
    if (pTapi)
    {
        //ShowMediaPreview will fail if nCallId cannot support video preview.  
        //we can call ShowMediaPreview(-1) to pick the first nCallId that does, but we
        //will not do this.  We will set the preview to audio only.
        HRESULT hr = pTapi->ShowMediaPreview((long)nCallId,hWndToPaint,TRUE);
        if (SUCCEEDED(hr))
        {
            //this will cause the object to show preview
            m_previewWnd.SetAudioOnly(false);
        }
        else
        {
            //see if the callid is a valid one, maybe the call is gone
            if (m_callMgr.IsCallIdValid(nCallId))
            {
                //we need to set the preview window to audio only
                m_previewWnd.SetAudioOnly(true);
                pTapi->ShowMediaPreview(nCallId,NULL,FALSE);
            }
            else
            {
                //this will cause a blank screen to be displayed
                m_previewWnd.SetAudioOnly(false);
            }
        }
        pTapi->Release();
    }
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::ShowPreviewWindow(BOOL bShow)
{
   //if already in the proper state then do nothing
   if (m_bShowPreviewWnd == bShow) return;

   //save state
   m_bShowPreviewWnd = bShow;

   //Create preview window if not already created
   if (!m_previewWnd.GetSafeHwnd())
   {
      //CWnd* pWnd = CWnd::GetDesktopWindow();
      if (m_previewWnd.Create(IDD_VIDEOPREVIEW,NULL))
      {
         CString sAction;
         sAction.LoadString(IDS_CALLCONTROL_ACTIONS_CLOSE);
         m_previewWnd.AddCurrentActions(CM_ACTIONS_CLOSE,sAction);
      }
   }

   if (!IsWindow(m_previewWnd.GetSafeHwnd()))
      return;

   EnterCriticalSection(&m_csDataLock);

   if (m_bShowPreviewWnd)
   {
      UnhideCallControlWindows();

      //move existing call control windows down 
      CRect rcPreview;
      m_previewWnd.GetWindowRect(rcPreview);
      ShiftCallControlWindows(rcPreview.Height());

      //add to head of list
      m_CallWndList.AddHead(&m_previewWnd);
      m_bCallControlWindowsVisible = FALSE;

      //show windows
      UnhideCallControlWindows();
   }
   else
   {
      POSITION pos = m_CallWndList.GetHeadPosition();
      while (pos)
      {
         CWnd* pWindow = (CWnd*)m_CallWndList.GetAt(pos);
         if ( pWindow->GetSafeHwnd() == m_previewWnd.GetSafeHwnd() )
         {
            m_CallWndList.RemoveAt(pos);

            //Slide and hide video preview
            CRect rect;
            m_previewWnd.GetWindowRect(rect);
            
            if (m_uCallWndSide == CALLWND_SIDE_LEFT)
               rect.OffsetRect(-rect.Width(),0);
            else if (m_uCallWndSide == CALLWND_SIDE_RIGHT)
               rect.OffsetRect(rect.Width(),0);

            NewSlideWindow(&m_previewWnd,rect,m_bCallWndAlwaysOnTop);
            m_previewWnd.ShowWindow(SW_HIDE);

            //move existing call control windows down 
            CRect rcPreview;
            m_previewWnd.GetWindowRect(rcPreview);
            ShiftCallControlWindows(-rcPreview.Height());
            
            //reshow windows
            m_bCallControlWindowsVisible =  FALSE;
            UnhideCallControlWindows();

            break;
         }
         m_CallWndList.GetNext(pos);
      }
   }
   LeaveCriticalSection(&m_csDataLock);
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::ShowDialerExplorer(BOOL bShowWindow)
{
   CWnd* pWnd = AfxGetMainWnd();
   if (pWnd == NULL) return;

   UINT nShowCmd = (bShowWindow) ? ((pWnd->IsIconic()) ? SW_RESTORE : SW_SHOW) : SW_HIDE;
   pWnd->ShowWindow( nShowCmd );
   pWnd->SetForegroundWindow();
   
   if (nShowCmd == SW_RESTORE)
      pWnd->PostMessage(WM_SYSCOMMAND, (WPARAM)SC_RESTORE, NULL);
}


/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::CheckCallControlHover()
{
   CPoint pt;
   GetCursorPos(&pt);
   
   bool bCount = false;
   if (m_uCallWndSide == CALLWND_SIDE_LEFT)
   {
      if (pt.x < 2) bCount = true;
   }
   else if (m_uCallWndSide == CALLWND_SIDE_RIGHT)
   {
      if (pt.x > GetSystemMetrics(SM_CXSCREEN)-2) bCount = true;
   }

   if (bCount)
   {
      m_uCallControlHoverCount++;
      if (m_uCallControlHoverCount >= 2)
      {
         if ( !IsCallControlWindowsVisible() )
            UnhideCallControlWindows();

         m_uCallControlHoverCount = 0;
      }
   }
   else
      m_uCallControlHoverCount = 0;
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::GetCallControlWindowText(CStringList& strList)
{
   EnterCriticalSection(&m_csDataLock);
   
   POSITION pos = m_CallWndList.GetHeadPosition();
   while (pos)
   {
      CWnd* pWindow = (CWnd*)m_CallWndList.GetNext(pos);
      if ( (pWindow) && (::IsWindow(pWindow->GetSafeHwnd())) )
      {
         CString sText;
         pWindow->GetWindowText(sText);
         strList.AddTail(sText);
      }
   }

   LeaveCriticalSection(&m_csDataLock);
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::SelectCallControlWindow(int nWindow)
{
   EnterCriticalSection(&m_csDataLock);
   
   int nCount = GetCallControlWindowCount(INCLUDE_PREVIEW, DONT_ASK_TAPI);
   if ( (nWindow > 0) && (nWindow <= nCount) )
   {
      POSITION pos = m_CallWndList.GetHeadPosition();
      while ( (pos) && (nWindow > 0) )
      {
         CWnd* pWindow = (CWnd*)m_CallWndList.GetNext(pos);
         nWindow--;
         if (nWindow != 0) continue;
         
         if ( (pWindow) && (::IsWindow(pWindow->GetSafeHwnd())) )
         {
            UnhideCallControlWindows();
            pWindow->SetFocus();
         }
         break;
      }
   }

   LeaveCriticalSection(&m_csDataLock);
}

/////////////////////////////////////////////////////////////////////////////
CActiveDialerView* CActiveDialerDoc::GetView()
{
   POSITION pos = GetFirstViewPosition();
   if ( pos )
      return (CActiveDialerView *) GetNextView( pos );

   return NULL;
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::ActionRequested(CallClientActions cca)
{
   //Create or show the explorer window.
   //This is coming from the callmgr object so we should also post out from here. 
   //we do not want to block this call

    //
    // We have to verify the result of GetView()
    //

    CActiveDialerView* pView = GetView();

    if ( pView )
    {
        pView->PostMessage(WM_DIALERVIEW_ACTIONREQUESTED,0,(LPARAM)cca);
    }
}


/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc:: PreviewWindowActionSelected(CallManagerActions cma)
{
   //
   // We have to verify the pointer returned by AfxGetMainWnd()
   //

   CWnd* pMainWnd = AfxGetMainWnd();

   if( NULL == pMainWnd )
   {
       return;
   }

   switch (cma)
   {
      case CM_ACTIONS_CLOSE:
         if ( pMainWnd )
            ((CMainFrame *) pMainWnd)->OnButtonRoomPreview();
         break;
   }
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::OnCloseDocument() 
{
    AVTRACE(_T("CActiveDialerDoc::OnCloseDocument()."));
   //if we are doing callcontrol hover, delete timer

   //
   // We have to verify the pointer returned by AfxGetMainWnd()
   //

   CWnd* pMainWnd = AfxGetMainWnd();

   if( NULL == pMainWnd )
   {
       return;
   }

   if ( m_nCallControlHoverTimer && pMainWnd )
   {
      pMainWnd->KillTimer(m_nCallControlHoverTimer);
      m_nCallControlHoverTimer = 0;
   }

    ///////////////////
    //save buddies list
    ///////////////////
    //get file
    CString sBuddiesPath;
    GetAppDataPath(sBuddiesPath,IDN_REGISTRY_APPDATA_FILENAME_BUDDIES);
    CFile file;

    //open file and serialize data in
    if (file.Open(sBuddiesPath,CFile::modeCreate|CFile::modeReadWrite | CFile::shareExclusive))
    {
        CArchive ar(&file, CArchive::store | CArchive::bNoFlushOnDelete);
        ar.m_bForceFlat = FALSE;
        ar.m_pDocument = NULL;

        SerializeBuddies(ar);

        ar.Close();
        file.Close();
    }

    m_dir.Terminate();

    // Clean up AVTapi objects
    UnCreateAVTapiNotificationObject();
    UnCreateGeneralNotificationObject();

    CDocument::OnCloseDocument();
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// PhonePad Support
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::CreatePhonePad(CWnd* pWnd)
{
   // Create phone pad if it doesn't already exist
   if ( !m_wndPhonePad.GetSafeHwnd() )
      if ( !m_wndPhonePad.Create(IDD_PHONEPAD, NULL) ) //AfxGetMainWnd()) )
         return;

   m_wndPhonePad.SetPeerWindow(pWnd->GetSafeHwnd());

   ShowPhonePad(pWnd,TRUE);
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::DestroyPhonePad(CWnd* pWnd)
{
   if (m_wndPhonePad.GetPeerWindow() == pWnd->GetSafeHwnd())
   {
      ShowPhonePad(pWnd,FALSE);
      m_wndPhonePad.SetPeerWindow(NULL);
   }
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::ShowPhonePad(CWnd* pWnd,BOOL bShow)
{
   if (::IsWindow(m_wndPhonePad.GetSafeHwnd()) == FALSE) return;
   //check if PhonePad is associated with this pWnd
   if (m_wndPhonePad.GetPeerWindow() != pWnd->GetSafeHwnd()) return;

   if (bShow)
   {
      //Align window with side of call control window
      CRect rcCallWindow;
      pWnd->GetWindowRect( rcCallWindow );

      UINT uPosX = 0;
      if (m_uCallWndSide == CALLWND_SIDE_LEFT)
         uPosX = rcCallWindow.right;
      else if (m_uCallWndSide == CALLWND_SIDE_RIGHT)
      {
         uPosX = rcCallWindow.left;
         CRect rcPad;
         m_wndPhonePad.GetWindowRect(rcPad);
         uPosX -= rcPad.Width();
      }

      // Should the call window be on top?
      m_wndPhonePad.SetWindowPos( (m_bCallWndAlwaysOnTop) ? &CWnd::wndTopMost : &CWnd::wndTop, uPosX, rcCallWindow.top, 0, 0, SWP_NOSIZE | SWP_SHOWWINDOW );
      m_wndPhonePad.ShowWindow(SW_SHOW);
      m_wndPhonePad.SetForegroundWindow();
   }
   else
   {
      m_wndPhonePad.ShowWindow(SW_HIDE);
   }
}

/////////////////////////////////////////////////////////////////////////////
//pCallEntry will be deleted by caller.
void CActiveDialerDoc::MakeCall(CCallEntry* pCopyCallentry,BOOL bShowPlaceCallDialog)
{
    //if the asynch queue is available, then send the request there
    //Create call entry

    CCallEntry* pCallEntry = new CCallEntry;

    //copy call entry
    *pCallEntry = *pCopyCallentry;

    //queue up the event
    CAsynchEvent* pAEvent = new CAsynchEvent;
    pAEvent->m_pCallEntry = pCallEntry;
    pAEvent->m_uEventType = CAsynchEvent::AEVENT_CREATECALL;
    pAEvent->m_dwEventData1 = (DWORD)bShowPlaceCallDialog;         //Show call dialog
    m_AsynchEventQ.WriteHead((void *) pAEvent);
}

/////////////////////////////////////////////////////////////////////////////
//FIXUP:merge this function with MakeCall
void CActiveDialerDoc::Dial( LPCTSTR lpszName, LPCTSTR lpszAddress, DWORD dwAddressType, DialerMediaType nMediaType, BOOL bShowDialog )
{
    USES_CONVERSION;

    //if the asynch queue is available, then send the request there
    //create call entry
    CCallEntry* pCallEntry = new CCallEntry;
    pCallEntry->m_sDisplayName = lpszName;
    pCallEntry->m_lAddressType = dwAddressType;
    pCallEntry->m_sAddress = lpszAddress;
    pCallEntry->m_MediaType = nMediaType;

    //queue up the event
    CAsynchEvent* pAEvent = new CAsynchEvent;
    pAEvent->m_pCallEntry = pCallEntry;
    pAEvent->m_uEventType = CAsynchEvent::AEVENT_CREATECALL;
    pAEvent->m_dwEventData1 = (DWORD) bShowDialog;                      //Show call dialog
    m_AsynchEventQ.WriteHead((void*) pAEvent);
}

/////////////////////////////////////////////////////////////////////////////
HRESULT CActiveDialerDoc::DigitPress( PhonePadKey nKey )
{
    HRESULT hr = E_PENDING;

    IAVTapi *pTapi = GetTapi();
    if ( pTapi )
    {
        hr = pTapi->DigitPress( 0, nKey );
        pTapi->Release();
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Registry Setting
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

typedef struct tagSoundEventStruct
{
   UINT     uSoundEventId;
   UINT     uSoundEventFileName;
}SoundEventStruct;

static const SoundEventStruct SoundEventsLoad[] =
{
   { IDS_SOUNDS_INCOMINGCALL,       IDN_REGISTRY_SOUNDS_FILENAME_INCOMINGCALL      },
/*
   { IDS_SOUNDS_OUTGOINGCALL,       IDN_REGISTRY_SOUNDS_FILENAME_OUTGOINGCALL      },
   { IDS_SOUNDS_HOLDING,            IDN_REGISTRY_SOUNDS_FILENAME_HOLDING           },
   { IDS_SOUNDS_HOLDINGREMINDER,    IDN_REGISTRY_SOUNDS_FILENAME_HOLDINGREMINDER   },
#ifndef _MSLITE
   { IDS_SOUNDS_CONFERENCEREMINDER, IDN_REGISTRY_SOUNDS_FILENAME_CONFERENCEREMINDER},
#endif //_MSLITE
   { IDS_SOUNDS_REQUESTACTION,      IDN_REGISTRY_SOUNDS_FILENAME_REQUESTACTION     },
   { IDS_SOUNDS_CALLCONNECTED,      IDN_REGISTRY_SOUNDS_FILENAME_CALLCONNECTED     },
   { IDS_SOUNDS_CALLDISCONNECTED,   IDN_REGISTRY_SOUNDS_FILENAME_CALLDISCONNECTED  },
   { IDS_SOUNDS_CALLABANDONED,      IDN_REGISTRY_SOUNDS_FILENAME_CALLABANDONED     }, */
};

/////////////////////////////////////////////////////////////////////////////
//make sure our sounds are in the registry.  The setup will normally do this, but 
//we will do it here just to force it
void CActiveDialerDoc::SetRegistrySoundEvents()
{
    CString sFileName,sStr;
    //GetSystemDirectory(sFileName.GetBuffer(_MAX_PATH),_MAX_PATH);
    if( GetWindowsDirectory(sFileName.GetBuffer(_MAX_PATH),_MAX_PATH) == 0)
    {
        return;
    }

    sFileName.ReleaseBuffer();
    sStr.LoadString(IDN_REGISTRY_SOUNDS_DIRECTORY);
    sFileName = sFileName + _T("\\") + sStr;

    CString sRegBaseKey,sRegBaseDispName,sWavFile;

    sRegBaseKey.LoadString( IDN_REGISTRY_SOUNDS );
    sRegBaseDispName.LoadString( IDS_APPLICATION_TITLE_DESCRIPTION );
    SetSZRegistryValue( sRegBaseKey, NULL, sRegBaseDispName, HKEY_CURRENT_USER );

    int nCount = sizeof(SoundEventsLoad)/sizeof(SoundEventStruct);
    for (int i=0;i<nCount;i++)
    {
        CString sPath;
        sRegBaseDispName.LoadString(SoundEventsLoad[i].uSoundEventId);
        sWavFile.LoadString(SoundEventsLoad[i].uSoundEventFileName);
        AfxFormatString1(sRegBaseKey,IDN_REGISTRY_SOUNDS_CONTROLPANEL_BASEKEY,sRegBaseDispName);
        GetSZRegistryValue(sRegBaseKey,_T(""),sPath.GetBuffer(_MAX_PATH),_MAX_PATH,sFileName + sWavFile,HKEY_CURRENT_USER);
        sPath.ReleaseBuffer();
    }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Buddies List Support
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveDialerDoc::AddToBuddiesList(CLDAPUser* pAddUser)
{
    EnterCriticalSection(&m_csBuddyList);

    //check if already added   
    if (IsBuddyDuplicate(pAddUser))
    {
        LeaveCriticalSection(&m_csBuddyList);
        CString strFormat, strMessage;
        strFormat.LoadString( IDS_WARN_LDAPDUPLICATEADD );
        strMessage.Format( strFormat, pAddUser->m_sUserName );

        AfxGetApp()->DoMessageBox( strMessage, MB_ICONINFORMATION, MB_OK );
        return FALSE;
    }

    POSITION rPos = m_BuddyList.AddTail(pAddUser);
    if ( rPos ) 
    {
        pAddUser->AddRef();
        DoBuddyDynamicRefresh( pAddUser );
    }

    LeaveCriticalSection(&m_csBuddyList);
    return (BOOL) (rPos != NULL);
};

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveDialerDoc::IsBuddyDuplicate(CLDAPUser* pAddUser)
{
   BOOL bRet = FALSE;
   EnterCriticalSection(&m_csBuddyList);
   POSITION pos = m_BuddyList.GetHeadPosition();
   while (pos)
   {
      CLDAPUser* pUser = (CLDAPUser*) m_BuddyList.GetNext(pos);
      if ( pUser->Compare(pAddUser) == 0 )
      {
         bRet = TRUE;
         break;
      }
   }
   LeaveCriticalSection(&m_csBuddyList);
   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveDialerDoc::GetBuddiesList(CObList* pRetList)
{
    EnterCriticalSection(&m_csBuddyList);

    POSITION pos = m_BuddyList.GetHeadPosition();
    while (pos)
    {
        CLDAPUser* pUser = (CLDAPUser*)m_BuddyList.GetNext(pos);

        //create another user and add to RetList
        pUser->AddRef();
        pRetList->AddTail( pUser );
    }

    LeaveCriticalSection(&m_csBuddyList);
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveDialerDoc::DeleteBuddy(CLDAPUser* pDeleteUser)
{
   EnterCriticalSection(&m_csBuddyList);

   POSITION pos = m_BuddyList.GetHeadPosition();
   while (pos)
   {
      CLDAPUser* pUser = (CLDAPUser * ) m_BuddyList.GetAt(pos);

      if (pUser->Compare(pDeleteUser) == 0 )
      {
         m_BuddyList.RemoveAt(pos);
         AVTRACE(_T("CActiveDialerDoc::DeleteBuddy -- RELEASE %p"), pUser );
         pUser->Release();
         LeaveCriticalSection(&m_csBuddyList);
         return TRUE;
      }

      m_BuddyList.GetNext(pos);
   }
   LeaveCriticalSection(&m_csBuddyList);
   return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
//Will call WM_ACTIVEDIALER_BUDDYLIST_DYNAMICUPDATE when done updating.
//LPARAM will have CLDAPUser pointer.
void CActiveDialerDoc::DoBuddyDynamicRefresh( CLDAPUser* pUser )
{
    ASSERT( pUser );

    DirectoryProperty dp[3] = { DIRPROP_IPPHONE,
                                DIRPROP_TELEPHONENUMBER,
                                DIRPROP_EMAILADDRESS };


    for ( int i = 0; i < ARRAYSIZE(dp); i++ )
    {
        // IP Phone Number
        pUser->AddRef();
        if ( !m_dir.LDAPGetStringProperty(    pUser->m_sServer,
                                            pUser->m_sDN,
                                            dp[i],
                                            (LPARAM) pUser,
                                            NULL,
                                            LDAPGetStringPropertyCallBackEntry,
                                            CLDAPUser::ExternalReleaseProc,
                                            this ) )
        {
            pUser->Release();
        }
    }
}

/////////////////////////////////////////////////////////////////////////////
//static entry
void CALLBACK CActiveDialerDoc::LDAPGetStringPropertyCallBackEntry(bool bRet, void* pContext, LPCTSTR szServer, LPCTSTR szSearch,DirectoryProperty dpProperty,CString& sString,LPARAM lParam,LPARAM lParam2)
{
   ASSERT(pContext);

   try
   {
      CActiveDialerDoc* pObject = (CActiveDialerDoc*)pContext;
      CLDAPUser *pUser = (CLDAPUser *) lParam;
      pObject->LDAPGetStringPropertyCallBack( bRet, szServer, szSearch, dpProperty, sString, pUser );
   }
   catch (...)
   {
      ASSERT(0);   
   }
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerDoc::LDAPGetStringPropertyCallBack(bool bRet,LPCTSTR szServer,LPCTSTR szSearch,DirectoryProperty dpProperty,CString& sString,CLDAPUser* pUser )
{
    //Fill in the structure and make callback
    switch (dpProperty)
    {
        case DIRPROP_IPPHONE:
            pUser->m_sIPAddress = sString;
            break;

        case DIRPROP_TELEPHONENUMBER:
            pUser->m_sPhoneNumber = sString;
            break;

        case DIRPROP_EMAILADDRESS:
            pUser->m_sEmail1 = sString;
            break;
    }

    //post the update
    // Retrieve the ActiveView as the window to post the message to
    HWND hWnd = NULL;

    //
    // We have to verify the pointer returned by AfxGetMainWnd()
    //

    CWnd* pMainWnd = AfxGetMainWnd();

    if ( pMainWnd )
    {
        CView *pView = ((CFrameWnd *) pMainWnd)->GetActiveView();
        if ( pView )
            hWnd = pView->GetSafeHwnd();
    }

    if ( !::PostMessage( hWnd, WM_ACTIVEDIALER_BUDDYLIST_DYNAMICUPDATE, (WPARAM)dpProperty, (LPARAM)pUser ) )
        pUser->Release();
}

HRESULT CActiveDialerDoc::SetFocusToCallWindows()
{
   EnterCriticalSection(&m_csDataLock);

   BOOL bCallWndActive = FALSE;
   CWnd* pWndToActivate = NULL;
   CWnd* pWndFirst = NULL;

   //
   // Parse the call window list
   //

   POSITION pos = m_CallWndList.GetHeadPosition();
   while (pos)
   {
      CWnd* pCallWnd = (CWnd*) m_CallWndList.GetNext(pos);

      //
      // Store the first window
      //
      if( pWndFirst == NULL )
      {
          pWndFirst = pCallWnd;
      }

      //
      // Something wrong
      //

      if( !pCallWnd->GetSafeHwnd() )
      {
          return E_UNEXPECTED;
      }

      //
      // Does this window has the focus?
      //
      if( pCallWnd->GetSafeHwnd() == ::GetActiveWindow() )
      {
          bCallWndActive = TRUE;
          continue;
      }

      //
      // Is this the first next window?
      //
      if( bCallWndActive && (pWndToActivate==NULL))
      {
          pWndToActivate = pCallWnd;
          continue;
      }

   }

   if( bCallWndActive == FALSE )
   {
       //
       // We don't have a call window activated
       // Activate the first window
       //pWndToActivate = (CWnd*)&m_previewWnd;
       pWndToActivate = pWndFirst;
   }
   else
   {
       //
       // We already had an activated window
       //
       if(pWndToActivate == NULL)
       {
           pWndToActivate = AfxGetMainWnd();
       }
   }

    if( pWndToActivate )
    {
        pWndToActivate->SetFocus();
        pWndToActivate->SetActiveWindow();
    }


   LeaveCriticalSection(&m_csDataLock);
    return S_OK;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Windows TaskBar Support
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//We need to check the pRect coming in against current taskbar's shown on the
//desktop.  We will shift pRect accordingly to we do not interfere with the 
//taskbars.
void CActiveDialerDoc::CheckRectAgainstAppBars( UINT uEdge, CRect* pRect, BOOL bFirst )
{
   //shift the rcFinal so they don't interfere with appbars
   APPBARDATA abd;
   memset(&abd,0,sizeof(APPBARDATA));
   abd.cbSize = sizeof(APPBARDATA);

   //
   // We have to verify the pointer returned by AfxGetMainWnd()
   //

   CWnd* pMainWnd = AfxGetMainWnd();

   if( NULL == pMainWnd )
   {
       return;
   }

   abd.hWnd = pMainWnd->GetSafeHwnd();
   abd.uEdge = uEdge; 
   abd.rc = *pRect;
   ::SHAppBarMessage( ABM_QUERYPOS, &abd );

   //now take our new found knowledge and shift the rcFinal
   //for a right side slider we worry about the right edge (what about top and bottom?)
   int nLeftShift = pRect->right - abd.rc.right;
   int nRightShift = abd.rc.left - pRect->left;
   int nTopShift = pRect->top - abd.rc.top;
   int nBottomShift = abd.rc.bottom - pRect->bottom;

   //shift the rect appropriately
   //pRect->OffsetRect( nRightShift-nLeftShift, (bFirst) ? nBottomShift-nTopShift : 0 );
}

/////////////////////////////////////////////////////////////////////////////
void NewSlideWindow(CWnd* pWnd,CRect& rcEnd,BOOL bAlwaysOnTop )
{
   SlideWindow(pWnd,rcEnd,bAlwaysOnTop);
   return;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\avlist.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// AVList.cpp : implementation file
//

#include "stdafx.h"
#include "AVList.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CAVListItem

CAVListItem::CAVListItem()    
        :    nItem(-1),
            sText(_T(""))
{
}

CAVListItem::CAVListItem(LPCTSTR str)
        :    nItem(-1),
            sText(str)
{
}

CAVListItem::~CAVListItem()
{
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CAVListCtrl

IMPLEMENT_DYNCREATE(CAVListCtrl, CListCtrl)

BEGIN_MESSAGE_MAP(CAVListCtrl, CListCtrl)
    //{{AFX_MSG_MAP(CAVListCtrl)
    ON_NOTIFY_REFLECT(LVN_GETDISPINFO, OnGetdispinfo)
    ON_NOTIFY_REFLECT(LVN_DELETEITEM, OnDeleteitem)
    ON_NOTIFY_REFLECT(LVN_COLUMNCLICK, OnColumnclick)
    ON_WM_PAINT()
    ON_WM_SIZE()
    ON_WM_KILLFOCUS()
    ON_WM_SETFOCUS()
    ON_WM_DESTROY()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
CAVListCtrl::CAVListCtrl()
{
    m_SortColumn = 0;
    m_SortOrder = 1;
    m_cxClient = 0;
    m_bClientWidthSel = TRUE;
    m_sEmptyListText = _T("");
}

/////////////////////////////////////////////////////////////////////////////
void CAVListCtrl::OnDeleteitem(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
//    ASSERT(((CAVListItem*)pNVListView->lParam)->IsKindOf( RUNTIME_CLASS( CAVListItem ) 
    delete (CAVListItem*)pNMListView->lParam;    
    *pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CAVListCtrl::Init(UINT nID)
{
    if (nID)
    {
        RemoveImageList( LVSIL_SMALL );
        m_imageList.DeleteImageList();

        if ( m_imageList.Create(nID,AVLIST_BITMAP_CX,0,RGB_TRANS) )
            SetImageList(&m_imageList, LVSIL_SMALL );
        else
            ASSERT( FALSE );
    }
    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
CAVListItem* CAVListCtrl::GetItem(int nItem)
{
    LV_ITEM lv_item;
    memset(&lv_item,0,sizeof(LV_ITEM));
    lv_item.iItem = nItem;
   lv_item.mask = LVIF_PARAM;
    if (CListCtrl::GetItem(&lv_item))
        return (CAVListItem*)lv_item.lParam;        
    else
        return NULL;
}

/////////////////////////////////////////////////////////////////////////////
void CAVListCtrl::InsertItem(CAVListItem* pItem,int nItem,BOOL bSort)
{
    LV_ITEM lv_item;
    memset(&lv_item,0,sizeof(LV_ITEM));

    if (nItem == -1)
        nItem = GetItemCount();

    lv_item.iItem = nItem;

    //text will be given on demand
    lv_item.mask |= LVIF_TEXT;
    lv_item.pszText = LPSTR_TEXTCALLBACK;

    //Put the CAVListItem in the list
    lv_item.mask |= LVIF_PARAM;
    lv_item.lParam = (LPARAM)pItem;

    //images will be given on demand
    if ( m_imageList.GetSafeHandle() )
    {
        lv_item.mask |= LVIF_IMAGE;
        lv_item.iImage = I_IMAGECALLBACK;
    }
    pItem->nItem = CListCtrl::InsertItem(&lv_item);

    if (bSort)
        CListCtrl::SortItems(CompareFunc, (LPARAM)this);
}

/////////////////////////////////////////////////////////////////////////////
//Avoid use of CTCListItem stuff, use a virtual function so derived
//class can set the proper text
void CAVListCtrl::OnGetdispinfo(NMHDR* pNMHDR, LRESULT* pResult) 
{
    LV_DISPINFO* pDispInfo = (LV_DISPINFO*)pNMHDR;
    
    LV_ITEM* pLVItem = &pDispInfo->item;
    
    if (pLVItem->mask & LVIF_TEXT)
    {
        CAVListItem* pItem = (CAVListItem*)pLVItem->lParam;
        //cchTextMax is number of bytes, we need to give number of char's (for UNICODE)
      OnSetDisplayText(pItem,pLVItem->iSubItem,pLVItem->pszText,pLVItem->cchTextMax/sizeof(TCHAR));
    }
    if (pLVItem->mask & LVIF_IMAGE)
    {
        ASSERT(pLVItem->lParam);
        CAVListItem* pItem = (CAVListItem*)pLVItem->lParam;

      DWORD dwStyle = ListView_GetExtendedListViewStyle(GetSafeHwnd());
      if (dwStyle & LVS_EX_SUBITEMIMAGES)
         OnSetDisplayImage(pItem,pLVItem->iSubItem,pLVItem->iImage);
      else
         OnSetDisplayImage(pItem,pLVItem->iImage);
    }
    *pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
void CAVListCtrl::OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult) 
{
    NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
    if (m_SortColumn == pNMListView->iSubItem)
        ToggleSortOrder();
    else
    {
        m_SortColumn = pNMListView->iSubItem;
        ResetSortOrder();
    }
   CListCtrl::SortItems(CompareFunc, (LPARAM)this);
    *pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
int CALLBACK CAVListCtrl::CompareFunc(LPARAM lParam1, LPARAM lParam2,LPARAM lParamSort)
{
    CAVListCtrl* pListCtrl = (CAVListCtrl*)lParamSort;                //this
    CAVListItem* pItem1 = (CAVListItem*)lParam1;
    CAVListItem* pItem2 = (CAVListItem*)lParam2;
    return pListCtrl->CompareListItems(pItem1,pItem2,pListCtrl->GetSortColumn());
}

/////////////////////////////////////////////////////////////////////////////
//Virtual function for comparing items
int CAVListCtrl::CompareListItems(CAVListItem* pItem1,CAVListItem* pItem2,int column)
{
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
#define OFFSET_FIRST    2
#define OFFSET_OTHER    6

void CAVListCtrl::DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct)
{
   COLORREF m_clrText=::GetSysColor(COLOR_WINDOWTEXT);
    COLORREF m_clrTextBk=::GetSysColor(COLOR_WINDOW);
    COLORREF m_clrBkgnd=::GetSysColor(COLOR_WINDOW);

   //pull this out
   int m_cxStateImageOffset = 0;       //to support state images

    CDC* pDC = CDC::FromHandle(lpDrawItemStruct->hDC);
    CRect rcItem(lpDrawItemStruct->rcItem);
    UINT uiFlags=ILD_TRANSPARENT;
    CImageList* pImageList;
    int nItem=lpDrawItemStruct->itemID;
    BOOL bFocus=(GetFocus()==this);
    COLORREF clrTextSave, clrBkSave;
    COLORREF clrImage=m_clrBkgnd;
    static _TCHAR szBuff[MAX_PATH];
    LPCTSTR pszText;

// get item data

    LV_ITEM lvi;
    lvi.mask=LVIF_TEXT | LVIF_IMAGE | LVIF_STATE;
    lvi.iItem=nItem;
    lvi.iSubItem=0;
    lvi.pszText=NULL;       //callback will return pointer to buffer
    lvi.cchTextMax=0;       
    lvi.pszText=szBuff;
    lvi.cchTextMax=sizeof(szBuff);
    lvi.stateMask=0xFFFF;        // get all state flags
   CListCtrl::GetItem(&lvi);

    BOOL bSelected=(bFocus || (GetStyle() & LVS_SHOWSELALWAYS)) && lvi.state & LVIS_SELECTED;
    bSelected=bSelected || (lvi.state & LVIS_DROPHILITED);

// set colors if item is selected

    CRect rcAllLabels;
    CListCtrl::GetItemRect(nItem,rcAllLabels,LVIR_BOUNDS);
    CRect rcLabel;
    CListCtrl::GetItemRect(nItem,rcLabel,LVIR_LABEL);
    rcAllLabels.left=rcLabel.left;
    if(m_bClientWidthSel && rcAllLabels.right<m_cxClient)
        rcAllLabels.right=m_cxClient;

    if(bSelected)
    {
        clrTextSave=pDC->SetTextColor(::GetSysColor(COLOR_HIGHLIGHTTEXT));
        clrBkSave=pDC->SetBkColor(::GetSysColor(COLOR_HIGHLIGHT));
        pDC->FillRect(rcAllLabels,&CBrush(::GetSysColor(COLOR_HIGHLIGHT)));
    }
    else
      pDC->FillRect(rcAllLabels,&CBrush(m_clrTextBk));
// set color and mask for the icon
/*
    if(lvi.state & LVIS_CUT)
    {
        clrImage=m_clrBkgnd;
        uiFlags|=ILD_BLEND50;
    }
    else if(bSelected)
    {
        clrImage=::GetSysColor(COLOR_HIGHLIGHT);
        uiFlags|=ILD_BLEND50;
    }
  */

// draw state icon
/*
    UINT nStateImageMask=lvi.state & LVIS_STATEIMAGEMASK;
    if(nStateImageMask)
    {
        int nImage=(nStateImageMask>>12)-1;
        pImageList=ListCtrl.GetImageList(LVSIL_STATE);
        if(pImageList)
            pImageList->Draw(pDC,nImage,CPoint(rcItem.left,rcItem.top),ILD_TRANSPARENT);
    }
 */
// draw normal and overlay icon

    CRect rcIcon;
    CListCtrl::GetItemRect(nItem,rcIcon,LVIR_ICON);

    pImageList=CListCtrl::GetImageList(LVSIL_SMALL);
    if(pImageList)
    {
        UINT nOvlImageMask=lvi.state & LVIS_OVERLAYMASK;
        if(rcItem.left<rcItem.right-1)
            ImageList_DrawEx(pImageList->m_hImageList,lvi.iImage,pDC->m_hDC,rcIcon.left,rcIcon.top,16,16,m_clrBkgnd,clrImage,uiFlags | nOvlImageMask);
    }

// draw item label

    CListCtrl::GetItemRect(nItem,rcItem,LVIR_LABEL);
    rcItem.right-=m_cxStateImageOffset;

    pszText=MakeShortString(pDC,szBuff,rcItem.right-rcItem.left,2*OFFSET_FIRST);

    rcLabel=rcItem;
    rcLabel.left+=OFFSET_FIRST;
    rcLabel.right-=OFFSET_FIRST;

    pDC->DrawText(pszText,-1,rcLabel,DT_LEFT | DT_SINGLELINE | DT_NOPREFIX | DT_NOCLIP | DT_VCENTER);

// draw labels for extra columns

    LV_COLUMN lvc;
    lvc.mask=LVCF_FMT | LVCF_WIDTH;

    for(int nColumn=1; CListCtrl::GetColumn(nColumn,&lvc); nColumn++)
    {
        rcItem.left=rcItem.right;
        rcItem.right+=lvc.cx;

        int nRetLen = CListCtrl::GetItemText(nItem,nColumn,szBuff,sizeof(szBuff));
        if(nRetLen==0) continue;

        pszText=MakeShortString(pDC,szBuff,rcItem.right-rcItem.left,2*OFFSET_OTHER);

        UINT nJustify=DT_LEFT;

        if(pszText==szBuff)
        {
            switch(lvc.fmt & LVCFMT_JUSTIFYMASK)
            {
            case LVCFMT_RIGHT:
                nJustify=DT_RIGHT;
                break;
            case LVCFMT_CENTER:
                nJustify=DT_CENTER;
                break;
            default:
                break;
            }
        }

        rcLabel=rcItem;
        rcLabel.left+=OFFSET_OTHER;
        rcLabel.right-=OFFSET_OTHER;

        pDC->DrawText(pszText,-1,rcLabel,nJustify | DT_SINGLELINE | DT_NOPREFIX | DT_NOCLIP | DT_VCENTER);
    }

// draw focus rectangle if item has focus

    if(lvi.state & LVIS_FOCUSED && bFocus)
        pDC->DrawFocusRect(rcAllLabels);

// set original colors if item was selected

    if(bSelected)
    {
       pDC->SetTextColor(clrTextSave);
        pDC->SetBkColor(clrBkSave);
    }
}

LPCTSTR CAVListCtrl::MakeShortString(CDC* pDC, LPCTSTR lpszLong, int nColumnLen, int nOffset)
{
    static const _TCHAR szThreeDots[]=_T("...");

    int nStringLen=lstrlen(lpszLong);

    if(nStringLen==0 || pDC->GetTextExtent(lpszLong,nStringLen).cx+nOffset<=nColumnLen)
        return(lpszLong);

    static _TCHAR szShort[MAX_PATH];

    lstrcpy(szShort,lpszLong);
    int nAddLen=pDC->GetTextExtent(szThreeDots,sizeof(szThreeDots)).cx;

    for(int i=nStringLen-1; i>0; i--)
    {
        szShort[i]=0;
        if(pDC->GetTextExtent(szShort,i).cx+nOffset+nAddLen<=nColumnLen)
            break;
    }

    lstrcat(szShort,szThreeDots);

    return(szShort);
}

void CAVListCtrl::OnPaint() 
{
      if(m_bClientWidthSel)// && (GetStyle() & LVS_TYPEMASK)==LVS_REPORT && GetFullRowSel())
    {
        CRect rcAllLabels;
      CListCtrl::GetItemRect(0,rcAllLabels,LVIR_BOUNDS);

        if(rcAllLabels.right<m_cxClient)
        {
            // need to call BeginPaint (in CPaintDC c-tor)
            // to get correct clipping rect
            CPaintDC dc(this);

            CRect rcClip;
            dc.GetClipBox(rcClip);

            rcClip.left=min(rcAllLabels.right-1,rcClip.left);
            rcClip.right=m_cxClient;

            InvalidateRect(rcClip,FALSE);
            // EndPaint will be called in CPaintDC d-tor
        }
    }

    if ( (GetItemCount() == 0) && (!m_sEmptyListText.IsEmpty()) )
   {
       CPaintDC dc(this);

      //get upper-left position of 0 item
      POINT pt;
      GetItemPosition(0,&pt);

      //get rect for text 
       CRect rcRect;
       GetClientRect(rcRect);
       rcRect.top = pt.y + 4;

        HFONT fontOld = (HFONT)dc.SelectObject(GetFont());

        int nModeOld = dc.SetBkMode(TRANSPARENT);
        COLORREF crTextOld = dc.SetTextColor(GetSysColor(COLOR_BTNTEXT));
        dc.DrawText(m_sEmptyListText,m_sEmptyListText.GetLength(), &rcRect, DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_EDITCONTROL );
        dc.SetTextColor(crTextOld);
        dc.SetBkMode(nModeOld );
        dc.SelectObject(fontOld);
   }

      CListCtrl::OnPaint();
}

void CAVListCtrl::OnSize(UINT nType, int cx, int cy) 
{
      m_cxClient=cx;                      //Need for selection painting
   CListCtrl::OnSize(nType, cx, cy);
}

void CAVListCtrl::OnKillFocus(CWnd* pNewWnd) 
{
    CListCtrl::OnKillFocus(pNewWnd);
    // check if we are losing focus to label edit box
    if(pNewWnd!=NULL && pNewWnd->GetParent()==this)
        return;

    // repaint items that should change appearance
//    if(m_bFullRowSel && (GetStyle() & LVS_TYPEMASK)==LVS_REPORT)
        RepaintSelectedItems();
}

void CAVListCtrl::OnSetFocus(CWnd* pOldWnd) 
{
    CListCtrl::OnSetFocus(pOldWnd);
    
    // check if we are getting focus from label edit box
    if(pOldWnd!=NULL && pOldWnd->GetParent()==this)
        return;

    // repaint items that should change appearance
    //if(m_bFullRowSel) && (GetStyle() & LVS_TYPEMASK)==LVS_REPORT)
    RepaintSelectedItems();

    int nSelectedItem = 0;
    nSelectedItem = CListCtrl::GetNextItem(-1, LVNI_ALL|LVNI_SELECTED);
    if( nSelectedItem == -1)
    {
        LVITEM lvItem;
        lvItem.iItem = 0;
        lvItem.iSubItem = 0;
        lvItem.mask = LVIF_STATE;
        lvItem.stateMask = LVIS_SELECTED|LVIS_FOCUSED;
        lvItem.state = 3;
        CListCtrl::SetItem( &lvItem );
        CListCtrl::GetItem( &lvItem );
    }
}

void CAVListCtrl::RepaintSelectedItems()
{
    CRect rcItem, rcLabel;

// invalidate focused item so it can repaint properly

   int nItem=CListCtrl::GetNextItem(-1,LVNI_FOCUSED);
    if(nItem!=-1)
    {
        CListCtrl::GetItemRect(nItem,rcItem,LVIR_BOUNDS);
        CListCtrl::GetItemRect(nItem,rcLabel,LVIR_LABEL);
        rcItem.left=rcLabel.left;
        InvalidateRect(rcItem,FALSE);
    }

// if selected items should not be preserved, invalidate them

    if(!(GetStyle() & LVS_SHOWSELALWAYS))
    {
        for(nItem=CListCtrl::GetNextItem(-1,LVNI_SELECTED);
            nItem!=-1; nItem=CListCtrl::GetNextItem(nItem,LVNI_SELECTED))
        {
            CListCtrl::GetItemRect(nItem,rcItem,LVIR_BOUNDS);
            CListCtrl::GetItemRect(nItem,rcLabel,LVIR_LABEL);
            rcItem.left=rcLabel.left;

            InvalidateRect(rcItem,FALSE);
        }
    }

// update changes 
    UpdateWindow();
}

int CAVListCtrl::GetSelItem()
{
   return CListCtrl::GetNextItem(-1,LVNI_FOCUSED);
}

void CAVListCtrl::SetSelItem(int index)
{
   LV_ITEM lvi;
   memset(&lvi,0,sizeof(LV_ITEM));
   lvi.mask = LVIF_STATE;
    lvi.stateMask=LVIS_FOCUSED;        // get the one that has focus
   lvi.iItem = index;
   CListCtrl::SetItem(&lvi);
}

void CAVListCtrl::OnDestroy() 
{
    CListCtrl::OnDestroy();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\avdialer.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////
// ActiveDialer.cpp : Defines the class behaviors for the application.
//

#include "stdafx.h"
#include <objbase.h>
#include <htmlhelp.h>

#include "avDialer.h"
#include "MainFrm.h"
#include "AboutDlg.h"
#include "resource.h"

#include "idialer.h"
#include "AgentDialer.h"

#ifndef _MSLITE
#include "Splash.h"
#endif //_MSLITE


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

#define PAGE_BKCOLOR    RGB(255,255,166)

static TCHAR s_szUniqueString[] = _T("Brad's Secret Atom");

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#define ACTIVEDIALER_VERSION_INFO   0x100118

extern DWORD_PTR aDialerHelpIds[];

// ATL Global Module only instance
CAtlGlobalModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
    OBJECT_ENTRY(CLSID_AgentDialer, CAgentDialer)
END_OBJECT_MAP()

void ShellExecuteFix();
UINT ShellExecuteFixEntry(LPVOID pParam);

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CActiveDialerApp
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

BEGIN_MESSAGE_MAP(CActiveDialerApp, CWinApp)
    //{{AFX_MSG_MAP(CActiveDialerApp)
    ON_COMMAND(ID_APP_ABOUT, OnAppAbout)
    ON_COMMAND(ID_HELP_INDEX, OnHelpIndex)
    //}}AFX_MSG_MAP
    // Standard file based document commands
    ON_COMMAND(ID_FILE_NEW, CWinApp::OnFileNew)
    ON_COMMAND(ID_FILE_OPEN, CWinApp::OnFileOpen)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CActiveDialerApp construction

CActiveDialerApp::CActiveDialerApp()
{
   m_pAboutDlg = NULL;
   m_hUnique = NULL;
}

/////////////////////////////////////////////////////////////////////////////
// The one and only CActiveDialerApp object

CActiveDialerApp theApp;

// This identifier was generated to be statistically unique for your app.
// You may change it if you prefer to choose a specific identifier.

// {A0D7A956-3C0B-11D1-B4F9-00C04FC98AD3}
static const CLSID clsid =
{ 0xa0d7a956, 0x3c0b, 0x11d1, { 0xb4, 0xf9, 0x0, 0xc0, 0x4f, 0xc9, 0x8a, 0xd3 } };

/////////////////////////////////////////////////////////////////////////////
// CActiveDialerApp initialization

BOOL CActiveDialerApp::InitInstance()
{
    //check for command line callto:
    CheckCallTo();

    // If we have an instance already running, show that one rather than start a new one.
    if( !FirstInstance() )
        return FALSE;

    //deallocate old help path
    if (m_pszHelpFilePath)
    {
        free ((void*) m_pszHelpFilePath);
        m_pszHelpFilePath = NULL;
    }

    //Set help file.  We are not using the default MFC help way of doing things.  NT 5.0
    //wants all help files to be in /winnt/help directory.
    //for now we are just adding a hardcoded path to the windows directory.  There should
    //be a help entry in Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Shell Folders
    //but there isn't right now
    CString sContextHelpFile,sStr;
    ::GetWindowsDirectory(sContextHelpFile.GetBuffer(_MAX_PATH),_MAX_PATH);
    sContextHelpFile.ReleaseBuffer();
    sContextHelpFile += _T("\\");
    sStr.LoadString(IDN_CONTEXTHELPPATH);
    sContextHelpFile += sStr;
    sStr.LoadString(IDN_CONTEXTHELP);
    sContextHelpFile += sStr;
    m_pszHelpFilePath = _tcsdup(sContextHelpFile);

    // Parse command line and show splash screen if specified
    CCommandLineInfo cmdInfo;
    ParseCommandLine(cmdInfo);

#ifndef _MSLITE
   if (cmdInfo.m_bShowSplash || cmdInfo.m_bRunEmbedded || cmdInfo.m_bRunAutomated)
       CSplashWnd::EnableSplashScreen(TRUE);
   else
       CSplashWnd::EnableSplashScreen(FALSE);
#endif //_MSLITE

#ifndef _MSLITE
   //Check for /Silent
   CString sCmdLine = m_lpCmdLine;
   sCmdLine.MakeUpper();
   if (sCmdLine.Find(_T("SILENT")) == -1)
   {
      CSplashWnd::m_bShowMainWindowOnClose = TRUE;
   }
#endif //_MSLITE

    // Standard initialization
    // If you are not using these features and wish to reduce the size
    //  of your final executable, you should remove from the following
    //  the specific initialization routines you do not need.

#ifdef _AFXDLL
    Enable3dControls();            // Call this when using MFC in a shared DLL
#else
    Enable3dControlsStatic();    // Call this when linking to MFC statically
#endif

    INITCOMMONCONTROLSEX ctrlex;
    memset(&ctrlex,0,sizeof(INITCOMMONCONTROLSEX));
    ctrlex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    ctrlex.dwICC = ICC_COOL_CLASSES|ICC_WIN95_CLASSES|ICC_DATE_CLASSES|ICC_BAR_CLASSES;
    InitCommonControlsEx(&ctrlex);

    // Change the registry key under which our settings are stored.
    // You should modify this string to be something appropriate
    // such as the name of your company or organization.
    CString sBaseKey;
    sBaseKey.LoadString( IDN_REGISTRY_BASEKEY );
    SetRegistryKey(sBaseKey);

    CString sRegKey;
    sRegKey.LoadString( IDN_REGISTRY_APPLICATION_VERSION_NUMBER );
    int nVer = GetProfileInt(_T(""), sRegKey, 0);

    // Load standard INI file options (including MRU)
    PatchRegistryForVersion( nVer );
    LoadStdProfileSettings();
    SaveVersionToRegistry();
    _Module.Init(ObjectMap, AfxGetInstanceHandle());

    //Only needs to be done in /regserver
    //_Module.UpdateRegistryFromResource(IDR_AGENTDIALER, TRUE);
    _Module.RegisterServer(TRUE);
    _Module.RegisterClassObjects(CLSCTX_LOCAL_SERVER,REGCLS_MULTIPLEUSE);
    //_Module.UpdateRegistryClass(CLSID_AgentDialer);

    // Register the application's document templates.  Document templates
    //  serve as the connection between documents, frame windows and views.
    CSingleDocTemplate* pDocTemplate;
    pDocTemplate = new CSingleDocTemplate(
        IDR_MAINFRAME,
        RUNTIME_CLASS(CActiveDialerDoc),
        RUNTIME_CLASS(CMainFrame),       // main SDI frame window
        RUNTIME_CLASS(CActiveDialerView));
    AddDocTemplate(pDocTemplate);

    // Connect the COleTemplateServer to the document template.
    //  The COleTemplateServer creates new documents on behalf
    //  of requesting OLE containers by using information
    //  specified in the document template.
    m_server.ConnectTemplate(clsid, pDocTemplate, TRUE);

    // Note: SDI applications register server objects only if /Embedding
    //   or /Automation is present on the command line.

    // When a server application is launched stand-alone, it is a good idea
    //  to update the system registry in case it has been damaged.
    if ( CanWriteHKEY_ROOT() )
    {
        m_server.UpdateRegistry(OAT_DISPATCH_OBJECT);
        COleObjectFactory::UpdateRegistryAll();
    }

    // Dispatch commands specified on the command line
    if (!ProcessShellCommand(cmdInfo))
        return FALSE;

    // The one and only window has been initialized, so show and update it.
//    m_pMainWnd->ShowWindow(SW_HIDE);
//    m_pMainWnd->UpdateWindow();

    return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
int CActiveDialerApp::ExitInstance() 
{
    // Has the module been initialized?
    if ( _Module.m_pObjMap )
    {
        _Module.RevokeClassObjects();
        _Module.Term();
    }

    CoUninitialize();

    // Unregister our unique atom from the table
    if ( m_hUnique )
    {
        CloseHandle( m_hUnique );
        m_hUnique = NULL;
    }

    return CWinApp::ExitInstance();
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveDialerApp::SaveVersionToRegistry()
{
   //we could get this number from the version_info, but for now just use the define
   CString sRegKey;
   sRegKey.LoadString(IDN_REGISTRY_APPLICATION_VERSION_NUMBER);
   return WriteProfileInt(_T(""),sRegKey,ACTIVEDIALER_VERSION_INFO);
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveDialerApp::PreTranslateMessage(MSG* pMsg)
{

#ifndef _MSLITE
    if (CSplashWnd::PreTranslateAppMessage(pMsg))
        return TRUE;
#endif //_MSLITE

    SetFocusToCallWindows(pMsg);

    return CWinApp::PreTranslateMessage(pMsg);
}

BOOL CActiveDialerApp::SetFocusToCallWindows(
    IN  MSG*    pMsg
    )
{
    if( pMsg->message != WM_KEYUP )
    {
        return FALSE;
    }

    if( pMsg->wParam == VK_F7 )
    {
        POSITION pos = this->GetFirstDocTemplatePosition();
        CDocTemplate* pDocTemplate = this->GetNextDocTemplate( pos );
        if( pDocTemplate )
        {
            pos = pDocTemplate->GetFirstDocPosition();
            CDocument* pDocument = pDocTemplate->GetNextDoc( pos );
            if( pDocument )
            {
                ((CActiveDialerDoc*)pDocument)->SetFocusToCallWindows();
            }
        }
        return TRUE;        // Consumed
    }

    return FALSE;   // Not consumed
}


/////////////////////////////////////////////////////////////////////////////
bool CActiveDialerApp::FirstInstance()
{
    CWnd *pWndPrev, *pWndChild;

    // Determine if another window with our class name exists...
    CString sAppName;
    sAppName.LoadString( IDS_APPLICATION_CLASSNAME );

    if (pWndPrev = CWnd::FindWindow(sAppName,NULL))
    {
        //check if a callto was specified.  If yes, do a MakeCall to current process
        if ( !m_sInitialCallTo.IsEmpty() )
        {
            if ( SUCCEEDED(CoInitialize(NULL)) )
            {
                IAgentDialer *pDialer = NULL;
                HRESULT hr = CoCreateInstance( CLSID_AgentDialer, NULL, CLSCTX_LOCAL_SERVER, IID_IAgentDialer, (void **) &pDialer );
                if ( SUCCEEDED(hr) && pDialer )
                {  
                    BSTR bstrCallTo = m_sInitialCallTo.AllocSysString();
                    hr = pDialer->MakeCall(NULL,bstrCallTo,LINEADDRESSTYPE_IPADDRESS);

                    SysFreeString(bstrCallTo);
                    pDialer->Release();
                }
                CoUninitialize();
            }
        }
        else
        {
            //
            // We have to verify if is a real window
            //
            if( pWndPrev->m_hWnd == NULL )
            {
                return false;
            }

            if(!::IsWindow( pWndPrev->m_hWnd) )
            {
                return false;
            }

            // If so, does it have any popups?
            pWndChild = pWndPrev->GetLastActivePopup();

            //
            // We have to verify if is a real window
            //
            if(!::IsWindow( pWndChild->m_hWnd) )
            {
                return false;
            }

            // If iconic, restore the main window
            pWndPrev->ShowWindow( (pWndPrev->IsIconic()) ? SW_RESTORE : SW_SHOW );

            // Bring the main window or its popup to
            // the foreground
            pWndChild->SetActiveWindow();
            pWndChild->SetForegroundWindow();
        }
        return false;
    }

    return RegisterUniqueWindowClass();
}

/////////////////////////////////////////////////////////////////////////////
//Check's if callto was specified on the command line.  If yes, saves
//the address in m_sInitialCallTo.
void CActiveDialerApp::CheckCallTo()
{
   //check if any command line from callto:
   CString sCmdLine = m_lpCmdLine;

   int nIndex;
   if ((nIndex = sCmdLine.Find(_T("/callto:"))) != -1)
   {
      sCmdLine = sCmdLine.Mid(nIndex+_tcslen(_T("/callto:")));
      
      //get all data up to next / or -
      if ((nIndex = sCmdLine.FindOneOf(_T("/"))) != -1)
      {
         sCmdLine = sCmdLine.Left(nIndex);
      }
      sCmdLine.TrimLeft();
      sCmdLine.TrimRight();
      //see if another callto: is in the string
      if ((nIndex = sCmdLine.Find(_T("callto:"))) != -1)
      {
         sCmdLine = sCmdLine.Mid(nIndex+_tcslen(_T("callto:")));
      }
      if (!sCmdLine.IsEmpty())
      {
         //strip "
         if (sCmdLine[0] == '\"') sCmdLine = sCmdLine.Mid(1);     //strip leading "
         if (sCmdLine[sCmdLine.GetLength()-1] == '\"') sCmdLine = sCmdLine.Left(sCmdLine.GetLength()-1); //strip trailing "
         //save the callto address as a member
         m_sInitialCallTo = sCmdLine;
      }
   }
}

/*++
IniUpgrade

Description:
    If the INI file from WinNT4 was not upgraded let's do it!
    It's  called by PatchregistryForVersion when the reg version is 0
--*/
void CActiveDialerApp::IniUpgrade()
{  
#define DIALER_INI      _T("dialer.ini")
#define DIALER_SDL      _T("Speed Dial Settings")
#define DIALER_LDN      _T("Last dialed numbers")
#define DIALER_EMPTY    _T("")

    int nEntry = 1;

    // Speed Dial Settings
    do
    {
        // Get the name registration
        TCHAR szKey[10];
        swprintf(szKey, _T("Name%d"), nEntry);

        TCHAR* pszName = IniLoadString(
            DIALER_SDL,
            szKey,
            _T(""),
            DIALER_INI);

        if( NULL == pszName )
        {
            break;
        }

        // Get the number
        swprintf(szKey, _T("Number%d"), nEntry);

        TCHAR* pszNumber = IniLoadString(
            DIALER_SDL,
            szKey,
            _T(""),
            DIALER_INI);

        if( NULL == pszNumber )
        {
            delete pszName;
            break;
        }

        // Write into the registry the new Speed Dial Entry
        CCallEntry callEntry;

        callEntry.m_MediaType = DIALER_MEDIATYPE_POTS;
        callEntry.m_LocationType = DIALER_LOCATIONTYPE_UNKNOWN;
        callEntry.m_lAddressType = LINEADDRESSTYPE_PHONENUMBER;
        callEntry.m_sDisplayName.Format(_T("%s"), pszName);
        callEntry.m_sAddress.Format(_T("%s"), pszNumber);

        // Deallocate
        delete pszName;
        delete pszNumber;

        if( !CDialerRegistry::AddCallEntry(FALSE, callEntry))
        {
            break;
        }


        // Go to another registration
        nEntry++;
    }
    while ( TRUE);

    // Last dialed numbers
    nEntry = 1;

    do
    {
        // Get the number
        TCHAR szKey[10];
        swprintf(szKey, _T("Last dialed %d"), nEntry);

        TCHAR* pszNumber = IniLoadString(
            DIALER_LDN,
            szKey,
            _T(""),
            DIALER_INI);

        if( NULL == pszNumber )
        {
            break;
        }

        // Write into the registry the new Speed Dial Entry
        CCallEntry callEntry;

        callEntry.m_MediaType = DIALER_MEDIATYPE_POTS;
        callEntry.m_LocationType = DIALER_LOCATIONTYPE_UNKNOWN;
        callEntry.m_lAddressType = LINEADDRESSTYPE_PHONENUMBER;
        callEntry.m_sDisplayName.Format(_T("%s"), pszNumber);
        callEntry.m_sAddress.Format(_T("%s"), pszNumber);

        // Deallocate
        delete pszNumber;

        if( !CDialerRegistry::AddCallEntry(TRUE, callEntry) )
        {
           break;
        }


        // Go to another registration
        nEntry++;
    }
    while ( TRUE);
}

/*++
IniLoadString

Description:
    Read an entry from INI file
    Is called by IniUpgrade
--*/
TCHAR* CActiveDialerApp::IniLoadString(
    LPCTSTR lpAppName,        // points to section name
    LPCTSTR lpKeyName,        // points to key name
    LPCTSTR lpDefault,        // points to default string
    LPCTSTR lpFileName        // points to initialization filename
    )
{
    TCHAR* pszBuffer = NULL;
    DWORD dwSize = 0, dwCurrentSize = 128;

    do
    {
        if( NULL != pszBuffer )
            delete pszBuffer;

        dwCurrentSize *= 2;

        pszBuffer = new TCHAR[dwCurrentSize];

        if( NULL == pszBuffer)
            return NULL;

        dwSize = GetPrivateProfileString(
            lpAppName,
            lpKeyName,
            lpDefault,
            pszBuffer,
            dwCurrentSize,
            lpFileName);

        if( 0 == dwSize)
        {
            // The INI is empty
            delete pszBuffer;
            return NULL;
        }

    }
    while( dwSize > (dwCurrentSize - 1) );

    return pszBuffer;
}
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CAboutDlg
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
CAboutDlg::CAboutDlg() : CDialog(CAboutDlg::IDD)
{
    //{{AFX_DATA_INIT(CAboutDlg)
    m_sLegal = _T("");
    //}}AFX_DATA_INIT
   m_bModeless = FALSE;

   m_hbmpBackground = NULL;
   m_hbmpForeground = NULL;
   m_hPalette = NULL;
   m_hBScroll = NULL;
}

/////////////////////////////////////////////////////////////////////////////
void CAboutDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CAboutDlg)
    DDX_Text(pDX, IDC_ABOUT_EDIT_LEGAL, m_sLegal);
    //}}AFX_DATA_MAP
}

/////////////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CAboutDlg, CDialog)
    //{{AFX_MSG_MAP(CAboutDlg)
    ON_BN_CLICKED(IDC_ABOUT_BUTTON_UPGRADE, OnAboutButtonUpgrade)
    ON_WM_TIMER()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerApp::OnAppAbout()
{
   try
   {
      if (m_pAboutDlg == NULL)
      {
         m_pAboutDlg = new CAboutDlg;
         m_pAboutDlg->DoModal();
         delete m_pAboutDlg;
         m_pAboutDlg = NULL;
      }
      else
      {
         m_pAboutDlg->SetFocus();
      }
   }
   catch (...)
   {
      ASSERT(0);
   }
}

#define ABOUT_TIMER_ANIMATION_ID         1
#define ABOUT_TIMER_ANIMATION_INTERVAL   125
#define ABOUT_ANIMATION_OFFSET_X         208
#define ABOUT_ANIMATION_OFFSET_Y         186
#define ABOUT_ANIMATION_IMAGES           32
#define ABOUT_ANIMATION_IMAGE_X          164
#define ABOUT_ANIMATION_IMAGE_Y          60
#define ABOUT_SCROLL_PIXELS 2
#define ABOUT_SCROLL_INTERVAL (25 * ABOUT_SCROLL_PIXELS)

/////////////////////////////////////////////////////////////////////////////
BOOL CAboutDlg::OnInitDialog() 
{
   m_sLegal.LoadString(IDS_ABOUT_LEGAL);

    CDialog::OnInitDialog();
   
   CenterWindow(GetDesktopWindow());
 
    //SetTimer(ABOUT_TIMER_ANIMATION_ID, ABOUT_TIMER_ANIMATION_INTERVAL, NULL);
   
    // load bitmap resources, get palette
    if ( (m_hbmpBackground = GfxLoadBitmapEx(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDB_ABOUT_BACKGROUND),&m_hPalette)) &&
        (m_hbmpForeground = GfxLoadBitmapEx(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDB_ABOUT_LOGO),NULL)) )
   {
       //3D static control about 120 x 114 dialog units in size
      HWND hwndStatic = NULL;
       if (hwndStatic = ::GetDlgItem(m_hWnd, IDC_ABOUT_STATIC_IMAGE))
      {
         //get width and height of m_hbmpForeground
         BITMAP bmInfo;
         memset(&bmInfo,0,sizeof(BITMAP));
         GetObject(m_hbmpForeground,sizeof(BITMAP),&bmInfo);

         ::SetWindowPos(hwndStatic,NULL,0,0,bmInfo.bmWidth,bmInfo.bmHeight,SWP_NOMOVE|SWP_SHOWWINDOW|SWP_NOZORDER);

         //specify scrolling characteristics
          if (m_hBScroll = BScrollInit(BSCROLL_VERSION, 
                                      AfxGetInstanceHandle(),
                                        hwndStatic,
                                      m_hbmpBackground,
                                      m_hbmpForeground,
                                      RGB(255, 0, 255),
                                      m_hPalette,
                                        ABOUT_SCROLL_INTERVAL,
                                      ABOUT_SCROLL_PIXELS,
                                      0,BSCROLL_BACKGROUND | BSCROLL_LEFT | BSCROLL_DOWN | BSCROLL_MOUSEMOVE))
         {
             BScrollStart(m_hBScroll);
         }
      }
   }
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
BOOL CAboutDlg::DestroyWindow() 
{
    if (m_hBScroll)
   {
      BScrollTerm(m_hBScroll);
        m_hBScroll = NULL;
   }
    if (m_hbmpBackground)
   {
      DeleteObject(m_hbmpBackground);
        m_hbmpBackground = NULL;
   }
    if (m_hbmpForeground)
   {
      DeleteObject(m_hbmpForeground);
        m_hbmpForeground = NULL;
   }
    if (m_hPalette)
   {
      DeleteObject(m_hPalette);
        m_hPalette = NULL;
   }

    BOOL bRet = CDialog::DestroyWindow();
   if (m_bModeless)
      delete this;
   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
void CAboutDlg::OnAboutButtonUpgrade() 
{  
   CString sUrl;
   sUrl.LoadString(IDN_URL_UPGRADE);
   ((CActiveDialerApp*)AfxGetApp())->ShellExecute(GetSafeHwnd(),_T("open"),sUrl,NULL,NULL,NULL);
}

/////////////////////////////////////////////////////////////////////////////
void CAboutDlg::OnOK() 
{
   if (m_bModeless)
      DestroyWindow();
   else
       CDialog::OnOK();
}

/////////////////////////////////////////////////////////////////////////////
void CAboutDlg::OnTimer(UINT nIDEvent) 
{
    // TODO: Add your message handler code here and/or call default
    
    CDialog::OnTimer(nIDEvent);
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerApp::OnHelpIndex() 
{
   if ( AfxGetMainWnd() )
   {
      CString strHelp;
      strHelp.LoadString( IDN_HTMLHELP );
      HtmlHelp( NULL, strHelp, HH_DISPLAY_TOPIC, 0 );
   }
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerApp::WinHelp(DWORD dwData, UINT nCmd) 
{
   if (nCmd == HELP_CONTEXTPOPUP)
   {
      //for dialog boxes that have id's of -1 do not supply help
      if (dwData == -1) return;

      //for IDOK and IDCANCEL call default help in windows.hlp
      if ( (dwData == IDOK) || (dwData == IDCANCEL) )
      {
          CWnd* pWnd = m_pMainWnd->GetTopLevelParent();

        //
        // We have to verify pWnd pointer before use it
        //
        if( pWnd )
        {
            if (!::WinHelp(pWnd->GetSafeHwnd(), _T("windows.hlp"), nCmd,(dwData == IDOK)?IDH_OK:IDH_CANCEL))
                  AfxMessageBox(AFX_IDP_FAILED_TO_LAUNCH_HELP);
                        return;
        }
        else
            return;
      }
   }
   else if (nCmd == HELP_CONTEXTMENU)
   {
      //dwData is HWND of control
      if (!::WinHelp ((HWND)(DWORD_PTR)dwData, m_pszHelpFilePath, HELP_CONTEXTMENU, (DWORD_PTR) &aDialerHelpIds))
         AfxMessageBox(AFX_IDP_FAILED_TO_LAUNCH_HELP);
      return;
   }
   else if (nCmd == HELP_WM_HELP)
   {
      //dwData is HWND of control
      if (!::WinHelp ((HWND)(DWORD_PTR)dwData,m_pszHelpFilePath, HELP_WM_HELP, (DWORD_PTR)&aDialerHelpIds))
         AfxMessageBox(AFX_IDP_FAILED_TO_LAUNCH_HELP);
      return;
   }
   else if (nCmd == HELP_CONTEXT)
   {
      if ( AfxGetMainWnd() )
      {
         CString strHelp;
         strHelp.LoadString( IDN_HTMLHELP );
         HtmlHelp( AfxGetMainWnd()->m_hWnd, strHelp, HH_DISPLAY_TOPIC, 0 );
      }
      return;
   }

    CWinApp::WinHelp(dwData, nCmd);
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveDialerApp::OnIdle(LONG lCount) 
{
   BOOL bMore = CWinApp::OnIdle(lCount);
 
   /*Using a WM_TIMER instead
   if (lCount == 10)  
   {
      //App idle for longer amount of time
      CWnd* pMainWnd = NULL;
      if ((pMainWnd = AfxGetMainWnd()) != NULL)
      {
         if (pMainWnd->IsKindOf(RUNTIME_CLASS(CMainFrame)))
            ((CMainFrame*)pMainWnd)->HeartBeat();
      }
      bMore = TRUE;
   }*/

   return bMore;
   // return TRUE as long as there is any more idle tasks}
}

//////////////////////////////////////////////////////////////////
void CActiveDialerApp::PatchRegistryForVersion( int nVer )
{
    CString sRegKey;

    // Implement a patch
    if ( nVer < ACTIVEDIALER_VERSION_INFO )
    {
        sRegKey.LoadString( IDN_REGISTRY_CONFERENCE_SERVICES );
        HKEY hKey = GetAppRegistryKey();
        if ( hKey )
        {
            RegDeleteKey( hKey, sRegKey );
            RegCloseKey( hKey );
        }

        if( nVer == 0 )
            IniUpgrade();
    }
}

bool CActiveDialerApp::RegisterUniqueWindowClass()
{
    // Check and register ATOM
    m_hUnique = CreateEvent( NULL, false, false, s_szUniqueString );
    DWORD dwErr = GetLastError();
    if ( !m_hUnique || (GetLastError() == ERROR_ALREADY_EXISTS) )
        return false;

    //we register a class name for multi instance checking
    // Register our unique class name that we wish to use
    WNDCLASSEX wndcls;
    memset( &wndcls, 0, sizeof(WNDCLASSEX) );
    wndcls.cbSize = sizeof( WNDCLASSEX );
    wndcls.style = CS_DBLCLKS;
    wndcls.lpfnWndProc = ::DefWindowProc;
    wndcls.hInstance = AfxGetInstanceHandle();
    wndcls.hIcon = LoadIcon(IDR_MAINFRAME); // or load a different icon
    wndcls.hCursor = LoadCursor( IDC_ARROW );
    wndcls.hbrBackground = (HBRUSH) (COLOR_WINDOW + 1);
    wndcls.lpszMenuName = NULL;

    // Specify our own class name for using FindWindow later
    CString sAppName;
    m_sApplicationName.LoadString(IDS_APPLICATION_CLASSNAME);
    wndcls.lpszClassName = m_sApplicationName;

    // Register new class and exit if it fails
    return (bool) (::RegisterClassEx(&wndcls) != NULL);
}

bool CActiveDialerApp::CanWriteHKEY_ROOT()
{    
    // See if we can right to the HKEY_CLASSES_ROOT key
    bool bRet = false;

    CString strValue;
    strValue.LoadString(IDN_HTMLHELP);
    if ( ::RegSetValue( HKEY_CLASSES_ROOT, AfxGetAppName(), REG_SZ, strValue, lstrlen(strValue) * sizeof(TCHAR)) == ERROR_SUCCESS )
    {
        bRet = true;
        RegDeleteValue( HKEY_CLASSES_ROOT, AfxGetAppName() );
    }

    return bRet;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//ShellExecute bug fix for NT 5.0
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//Multithreaded MFC application cause ShellExecutre to fail under NT 5.0.
//This is not a problem on NT 4.0.  This is a bug in NT 5.0.  We make the 
//app free threaded by calling CoInitializeEx(NULL,COINIT_MULTITHREADED).  
//The workaround is to spawn a new thread and call ShellExecute.  This fixes
//the problem for now.
void CActiveDialerApp::ShellExecute(HWND hwnd, LPCTSTR lpOperation, LPCTSTR lpFile, LPCTSTR lpParameters, LPCTSTR lpDirectory, INT nShowCmd)
{
   //copy the string members
   TCHAR* pszOperation = new TCHAR[_MAX_PATH];
   if( pszOperation == NULL)
   {
       return;
   }

   TCHAR* pszFile = new TCHAR[_MAX_PATH];
   if( pszFile == NULL)
   {
       delete pszOperation;
       return;
   }

   TCHAR* pszParameters = new TCHAR[_MAX_PATH];
   if( pszParameters == NULL )
   {
       delete pszOperation;
       delete pszFile;
       return;
   }

   TCHAR* pszDirectory = new TCHAR[_MAX_PATH];
   if( pszDirectory == NULL )
   {
       delete pszOperation;
       delete pszFile;
       delete pszParameters;
       return;
   }

   memset(pszOperation, '\0', _MAX_PATH*sizeof(TCHAR));
   memset(pszFile, '\0', _MAX_PATH*sizeof(TCHAR));
   memset(pszParameters, '\0', _MAX_PATH*sizeof(TCHAR));
   memset(pszDirectory, '\0', _MAX_PATH*sizeof(TCHAR));
   if (lpOperation) _tcsncpy(pszOperation,lpOperation,_MAX_PATH-1);
   if (lpFile) _tcsncpy(pszFile,lpFile,_MAX_PATH-1);
   if (lpParameters) _tcsncpy(pszParameters,lpParameters,_MAX_PATH-1);
   if (lpDirectory) _tcsncpy(pszDirectory,lpDirectory,_MAX_PATH-1);

   //use SHELLEXECUTEINFO to pass the data
   SHELLEXECUTEINFO* pShellInfo = new SHELLEXECUTEINFO;
   memset(pShellInfo,0,sizeof(SHELLEXECUTEINFO));
   pShellInfo->cbSize = sizeof(SHELLEXECUTEINFO);
   pShellInfo->hwnd = hwnd;
   pShellInfo->lpVerb = pszOperation;
   pShellInfo->lpFile = pszFile;
   pShellInfo->lpParameters = pszParameters;
   pShellInfo->lpDirectory = pszDirectory;
   pShellInfo->nShow = nShowCmd;
   AfxBeginThread((AFX_THREADPROC) ShellExecuteFixEntry, pShellInfo);
}

/////////////////////////////////////////////////////////////////////////////
UINT ShellExecuteFixEntry(LPVOID pParam)
{
   ASSERT(pParam);
   
   SHELLEXECUTEINFO* pShellInfo = (SHELLEXECUTEINFO*)pParam;
   ShellExecute(pShellInfo->hwnd,
                pShellInfo->lpVerb,
                pShellInfo->lpFile,
                pShellInfo->lpParameters,
                pShellInfo->lpDirectory,
                pShellInfo->nShow);
   
   //delete shellinfo struct and it's components
   if (pShellInfo->lpVerb) delete (LPTSTR)pShellInfo->lpVerb;
   if (pShellInfo->lpFile) delete (LPTSTR)pShellInfo->lpFile;
   if (pShellInfo->lpParameters) delete (LPTSTR)pShellInfo->lpParameters;
   if (pShellInfo->lpDirectory) delete (LPTSTR)pShellInfo->lpDirectory;
   delete pShellInfo;
   
   return 0;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////




/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CUserUserDlg
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CUserUserDlg, CDialog)
    //{{AFX_MSG_MAP(CUserUserDlg)
    ON_WM_CLOSE()
    ON_WM_SHOWWINDOW()
    ON_BN_CLICKED(IDC_BTN_URL, OnUrlClicked)
    ON_MESSAGE( WM_CTLCOLOREDIT, OnCtlColorEdit )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
CUserUserDlg::CUserUserDlg() : CDialog(CUserUserDlg::IDD)
{
    //{{AFX_DATA_INIT(CUserUserDlg)
    m_strFrom.LoadString( IDS_UNKNOWN );
    //}}AFX_DATA_INIT
}

/////////////////////////////////////////////////////////////////////////////
void CUserUserDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CUserUserDlg)
    DDX_Text(pDX, IDC_LBL_FROM, m_strFrom);
    DDX_Text(pDX, IDC_EDT_WELCOME, m_strWelcome);
    DDX_Control(pDX, IDC_EDT_WELCOME, m_wndPage);
    //}}AFX_DATA_MAP

    if ( !pDX->m_bSaveAndValidate )
        GetDlgItem(IDC_BTN_URL)->SetWindowText( m_strUrl );
}

void CUserUserDlg::OnClose()
{
    DestroyWindow();
}

BOOL CUserUserDlg::DestroyWindow()
{
    BOOL bRet = CDialog::DestroyWindow();
    delete this;    
    return bRet;
}

BOOL CUserUserDlg::OnInitDialog() 
{
    // Hide windows that aren't in use and resize dialog.
    if ( m_strUrl.IsEmpty() )
    {
        GetDlgItem(IDC_LBL_URL)->ShowWindow( FALSE );
        GetDlgItem(IDC_BTN_URL)->ShowWindow( FALSE );

        RECT rc, rcDlg;
        ::GetWindowRect( GetDlgItem(IDC_BTN_URL)->GetSafeHwnd(), &rc );
        GetWindowRect( &rcDlg );

        rcDlg.bottom =  rc.top - 1;
        MoveWindow( &rcDlg, false );
    }

    GetDlgItem(IDC_EDT_WELCOME)->SendMessage( EM_SETMARGINS, (WPARAM) EC_LEFTMARGIN | EC_RIGHTMARGIN, MAKELPARAM(4,4) );

    // Fetch caller ID information from caller
    IAVTapi *pTapi;
    if ( SUCCEEDED(get_Tapi(&pTapi)) )
    {    
        IAVTapiCall *pAVCall;
        if ( SUCCEEDED(pTapi->FindAVTapiCallFromCallID(m_lCallID, &pAVCall)) )
        {
            BSTR bstrID = NULL;
            if ( SUCCEEDED(pAVCall->get_bstrCallerID(&bstrID)) )
                m_strFrom = bstrID;

            SysFreeString( bstrID );

            pAVCall->Disconnect( TRUE );
            pAVCall->Release();
        }
        pTapi->Release();
    }

    CDialog::OnInitDialog();

    // Set focus on website if available
    if ( !m_strUrl.IsEmpty() )
    {
        GetDlgItem(IDC_BTN_URL)->SetFocus();
    }
    else
    {
        // Focus & de-select the edit box
        GetDlgItem(IDC_EDT_WELCOME)->SetFocus();
        GetDlgItem(IDC_EDT_WELCOME)->SendMessage( EM_SETSEL, -1, 0 );
    }
        
    SetWindowPos(&CWnd::wndTopMost, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW );
    SetWindowPos(&CWnd::wndNoTopMost, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW );
    return false;
}

void CUserUserDlg::DoModeless( CWnd *pWndParent )
{
    // Force to the top of the screen
    if ( AfxGetMainWnd() && AfxGetMainWnd()->IsWindowVisible() )
        AfxGetMainWnd()->SetWindowPos(&CWnd::wndTop, 0,0,0,0, SWP_NOMOVE | SWP_NOSIZE | SWP_SHOWWINDOW );

    Create( IDD, pWndParent );
}

void CUserUserDlg::OnUrlClicked()
{
   ((CActiveDialerApp*) AfxGetApp())->ShellExecute( GetSafeHwnd(),
                                                    _T("open"),
                                                    m_strUrl,
                                                    NULL, NULL, NULL);
}

LRESULT CUserUserDlg::OnCtlColorEdit(WPARAM wParam, LPARAM lParam)
{
    ::SetBkColor( (HDC) wParam, PAGE_BKCOLOR );
    return 0;
}

void CUserUserDlg::OnShowWindow(BOOL bShow, UINT nStatus) 
{
    // Ignore size requests when parent is minimizing
    if ( nStatus == SW_PARENTCLOSING ) return;
    CDialog::OnShowWindow(bShow, nStatus);
}


/////////////////////////////////////////////////////////////////////////////
// CWndPage

CWndPage::CWndPage()
{
}

CWndPage::~CWndPage()
{
}


BEGIN_MESSAGE_MAP(CWndPage, CWnd)
    //{{AFX_MSG_MAP(CWndPage)
    ON_WM_ERASEBKGND()
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()


/////////////////////////////////////////////////////////////////////////////
// CWndPage message handlers

BOOL CWndPage::OnEraseBkgnd(CDC* pDC) 
{
    CRect rc;
    GetClientRect( &rc );
    
    HBRUSH hBrNew = (HBRUSH) CreateSolidBrush( PAGE_BKCOLOR );
    HBRUSH hBrOld;

    if ( hBrNew ) hBrOld = (HBRUSH) pDC->SelectObject( hBrNew);
    pDC->PatBlt( 0, 0, rc.Width(), rc.Height(), PATCOPY );
    if ( hBrNew )
    {
        //
        // The hBrNew should be deallocated
        //
        DeleteObject( hBrNew );

        pDC->SelectObject( hBrOld );
    }

    return true;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CPageDlg
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CPageDlg, CDialog)
    //{{AFX_MSG_MAP(CPageDlg)
    ON_MESSAGE( WM_CTLCOLOREDIT, OnCtlColorEdit )
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
CPageDlg::CPageDlg() : CDialog(CPageDlg::IDD)
{
    //{{AFX_DATA_INIT(CPageDlg)
    m_strTo.LoadString( IDS_UNKNOWN );
    //}}AFX_DATA_INIT
}

/////////////////////////////////////////////////////////////////////////////
void CPageDlg::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CPageDlg)
    DDX_Text(pDX, IDC_LBL_TO, m_strTo);
    DDX_Text(pDX, IDC_EDT_WEBADDRESS, m_strUrl);
    DDX_Text(pDX, IDC_EDT_WELCOME, m_strWelcome);
    DDX_Control(pDX, IDC_EDT_WELCOME, m_wndPage);
    //}}AFX_DATA_MAP
}

BOOL CPageDlg::OnInitDialog() 
{
    GetDlgItem(IDC_EDT_WELCOME)->SendMessage( EM_SETMARGINS, (WPARAM) EC_LEFTMARGIN | EC_RIGHTMARGIN, MAKELPARAM(4,4) );
    // Hard code limit text for now
    GetDlgItem(IDC_EDT_WELCOME)->SendMessage( EM_SETLIMITTEXT, 499, 0);
    GetDlgItem(IDC_EDT_WEBADDRESS)->SendMessage( EM_SETLIMITTEXT, 254, 0);

    CDialog::OnInitDialog();

    GetDlgItem(IDC_EDT_WELCOME)->SetFocus();
    return false;
}

LRESULT CPageDlg::OnCtlColorEdit(WPARAM wParam, LPARAM lParam)
{
    if ( (HWND) lParam == GetDlgItem(IDC_EDT_WELCOME)->GetSafeHwnd() )
        ::SetBkColor( (HDC) wParam, PAGE_BKCOLOR );

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\avlist.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// AVList.h : header file
//

#ifndef _AVLIST_H_
#define _AVLIST_H_

#include "TapiDialer.h"

// Quick macro for reading column settings
#define LOAD_COLUMN(_IDS_, _DEF_ )												\
strTemp.LoadString( _IDS_ );													\
if ( bSave )																	\
{																				\
	nColumnWidth[i] = GetColumnWidth(i);										\
	AfxGetApp()->WriteProfileInt( strSubKey, strTemp, nColumnWidth[i++] );		\
}																				\
else																			\
	nColumnWidth[i++] = max( MIN_COL_WIDTH, AfxGetApp()->GetProfileInt( strSubKey, strTemp, _DEF_ ) );\


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CAVListItem

//AV List Ctrl Item
class CAVListItem
{
	friend class CAVListCtrl;
public:
//Construction
   CAVListItem();
	CAVListItem(LPCTSTR str);
	virtual ~CAVListItem();

//Attributes
protected:
   CString     sText;
	int			nItem;
public:   

//Operations
public:
   LPCTSTR     GetText()					{ return sText; };
   void        SetText(LPCTSTR str)		{ sText = str; };

//Operations
public:
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CAVListCtrl window

#define AVLIST_BITMAP_CX				16

class CAVListCtrl : public CListCtrl
{
	DECLARE_DYNCREATE(CAVListCtrl)
// Construction
public:
	CAVListCtrl();

// Attributes
public:
	CImageList		m_imageList;

protected:
	int				m_SortColumn;
	BOOL			m_SortOrder;

	int				m_cxClient;                //to support m_bclientwidthsel
	BOOL			m_bClientWidthSel;         //Selection all the way across the client screen

	CString			m_sEmptyListText;          //Text when listctrl is empty

// Operations
public:
	CAVListItem*	GetItem(int nItem);
	void			InsertItem(CAVListItem* pItem,int nItem=0,BOOL bSort=TRUE);
	int				GetSelItem();
	void			SetSelItem(int index);

	static int CALLBACK	CompareFunc(LPARAM lParam1, LPARAM lParam2,LPARAM lParamSort);

	LPCTSTR			MakeShortString(CDC* pDC, LPCTSTR lpszLong, int nColumnLen, int nOffset);
	void			DrawItem(LPDRAWITEMSTRUCT lpDrawItemStruct);
	void			RepaintSelectedItems();
	void			SortItems()		{ CListCtrl::SortItems(CompareFunc, (LPARAM)this); };
	
protected:
	BOOL				Init(UINT nID);
	virtual void	OnSetDisplayText(CAVListItem* pItem,int SubItem,LPTSTR szTextBuf,int nBufSize) {};
	virtual void	OnSetDisplayImage(CAVListItem* pItem,int& iImage) {};
	virtual void	OnSetDisplayImage(CAVListItem* pItem,int SubItem,int& iImage) {};

	virtual int		CompareListItems(CAVListItem* pItem1,CAVListItem* pItem2,int column);

public:
	inline int		GetSortColumn()					{ return m_SortColumn; };
	inline void		SetSortColumn(int nColumn)		{ m_SortColumn = nColumn; SortItems(); };

	inline int		GetSortOrder()					{ return m_SortOrder; };
	inline void		ToggleSortOrder()				{ m_SortOrder = !m_SortOrder; SortItems(); };
	inline void		ResetSortOrder()				{ m_SortOrder = 0; SortItems(); };
	inline void		SetSortOrder(BOOL bDescending)	{ m_SortOrder = bDescending;  SortItems(); };

	void			SetEmptyListText(LPCTSTR szText){ m_sEmptyListText = szText; };
	LPCTSTR			GetEmtpyListText()				{ return m_sEmptyListText; };

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAVListCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	// Generated message map functions
protected:
	//{{AFX_MSG(CAVListCtrl)
	afx_msg void OnGetdispinfo(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeleteitem(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnColumnclick(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnPaint();
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnKillFocus(CWnd* pNewWnd);
	afx_msg void OnSetFocus(CWnd* pOldWnd);
	afx_msg void OnDestroy();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
#endif //_AVLIST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\avdialervw.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// ActiveDialerView.h : interface of the CActiveDialerView class
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_ACTIVEDIALERVIEW_H__A0D7A964_3C0B_11D1_B4F9_00C04FC98AD3__INCLUDED_)
#define AFX_ACTIVEDIALERVIEW_H__A0D7A964_3C0B_11D1_B4F9_00C04FC98AD3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

class CActiveDialerView;

#include "splitter.h"
#include "explwnd.h"
#include "TapiDialer.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#define  WM_DIALERVIEW_CREATECALLCONTROL	   (WM_USER + 1001)  
#define  WM_DIALERVIEW_DESTROYCALLCONTROL	   (WM_USER + 1002)  
#define  WM_DIALERVIEW_SHOWEXPLORER          (WM_USER + 1003)
#define  WM_DIALERVIEW_ACTIONREQUESTED       (WM_USER + 1004)
#define  WM_DIALERVIEW_ERRORNOTIFY           (WM_USER + 1005)
#define  WM_UPDATEALLVIEWS                   (WM_USER + 1006)
#define  WM_DSCLEARUSERLIST                  (WM_USER + 1007)
#define  WM_DSADDUSER                        (WM_USER + 1008)

typedef struct tagErrorNotifyData
{
   CString  sOperation;
   CString  sDetails;
   long     lErrorCode;
   UINT     uErrorLevel;
}ErrorNotifyData;

#define ERROR_NOTIFY_LEVEL_USER              0x00000001
#define ERROR_NOTIFY_LEVEL_LOG               0x00000002
#define ERROR_NOTIFY_LEVEL_INTERNAL          0x00000004

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CActiveDialerView
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CActiveDialerDoc;

class CActiveDialerView : public CSplitterView
{
protected: // create from serialization only
	CActiveDialerView();
	DECLARE_DYNCREATE(CActiveDialerView)

// Members
public:
   CExplorerWnd         m_wndExplorer;
protected:
   CWnd                 m_wndEmpty;
   CBrush				m_brushBackGround;

// Attributes
public:
	CActiveDialerDoc*	GetDocument();
	IAVTapi*			GetTapi();

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CActiveDialerView)
	public:
	virtual BOOL OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo);
	virtual void OnInitialUpdate();
	virtual void OnDraw(CDC* pDC);      // overridden to draw this view
	protected:
	virtual void OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint);
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CActiveDialerView();
#ifdef _DEBUG
	virtual void AssertValid() const;
	virtual void Dump(CDumpContext& dc) const;
#endif

// Generated message map functions
protected:
	//{{AFX_MSG(CActiveDialerView)
	afx_msg LRESULT OnDialerViewActionRequested(WPARAM,LPARAM);
	afx_msg LRESULT OnDSClearUserList(WPARAM,LPARAM);
	afx_msg LRESULT OnDSAddUser(WPARAM,LPARAM);
	afx_msg LRESULT OnBuddyListDynamicUpdate(WPARAM wParam,LPARAM lParam);
	afx_msg void OnNextPane();
	afx_msg void OnPrevPane();
	afx_msg void OnUpdatePane(CCmdUI* pCmdUI);
	//}}AFX_MSG
	afx_msg void OnGetdispinfoList(NMHDR* pNMHDR, LRESULT* pResult); 
	afx_msg void OnColumnclickList(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDialerDial(UINT nID);
	DECLARE_MESSAGE_MAP()
};

#ifndef _DEBUG  // debug version in ActiveDialerView.cpp
inline CActiveDialerDoc* CActiveDialerView::GetDocument()
   { return (CActiveDialerDoc*)m_pDocument; }
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_ACTIVEDIALERVIEW_H__A0D7A964_3C0B_11D1_B4F9_00C04FC98AD3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\avdialervw.cpp ===
////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// ActiveDialerView.cpp : implementation of the CActiveDialerView class
//
#include "stdafx.h"
#include "avDialer.h"
#include "avDialerDoc.h"
#include "avDialerVw.h"
#include "ds.h"
#include "mainfrm.h"
#include "util.h"
#include "avtrace.h"


#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CActiveDialerView
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CActiveDialerView, CSplitterView)

BEGIN_MESSAGE_MAP(CActiveDialerView, CSplitterView)
	//{{AFX_MSG_MAP(CActiveDialerView)
	ON_MESSAGE(WM_DIALERVIEW_ACTIONREQUESTED,OnDialerViewActionRequested)
	ON_MESSAGE(WM_DSCLEARUSERLIST,OnDSClearUserList)
	ON_MESSAGE(WM_DSADDUSER,OnDSAddUser)
	ON_MESSAGE(WM_ACTIVEDIALER_BUDDYLIST_DYNAMICUPDATE,OnBuddyListDynamicUpdate)
	ON_COMMAND(ID_NEXT_PANE, OnNextPane)
	ON_COMMAND(ID_PREV_PANE, OnPrevPane)
	ON_UPDATE_COMMAND_UI(ID_PREV_PANE, OnUpdatePane)
	ON_UPDATE_COMMAND_UI(ID_NEXT_PANE, OnUpdatePane)
	//}}AFX_MSG_MAP
	ON_NOTIFY(LVN_GETDISPINFO,IDC_CONFERENCESERVICES_VIEWCTRL_DETAILS,OnGetdispinfoList)
	ON_NOTIFY(LVN_COLUMNCLICK,IDC_CONFERENCESERVICES_VIEWCTRL_DETAILS,OnColumnclickList)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
CActiveDialerView::CActiveDialerView()
{
}

/////////////////////////////////////////////////////////////////////////////
CActiveDialerView::~CActiveDialerView()
{
   //write splitter pos to registry
   CString sDialerExplorer,sRegKey;
   sDialerExplorer.LoadString(IDN_REGISTRY_DIALEREXPLORER_KEY);
   sRegKey.LoadString(IDN_REGISTRY_DIALEREXPLORER_SPLITTER_POS);
   AfxGetApp()->WriteProfileInt(sDialerExplorer,sRegKey,CSplitterView::m_percent);
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerView::OnInitialUpdate() 
{
	// Initialize OLE libraries
	if ( FAILED(CoInitializeEx(NULL,COINIT_MULTITHREADED)) )
		AfxMessageBox(IDP_OLE_INIT_FAILED);

	if ( GetDocument() ) 
		GetDocument()->Initialize();

	//set background brush
	m_brushBackGround.CreateSolidBrush( GetSysColor(COLOR_3DFACE) );
	::SetClassLongPtr(GetSafeHwnd(),GCLP_HBRBACKGROUND,(LONG_PTR) m_brushBackGround.GetSafeHandle());

	CSplitterView::OnInitialUpdate();

	if ( !m_wndEmpty.Create(NULL,NULL,WS_CHILD|WS_VISIBLE,CRect(0,0,0,0),this,1) || 
	!m_wndExplorer.Create(NULL,NULL,WS_CHILD|WS_VISIBLE,CRect(0,0,0,0),this,2) )
	{
		// Flailing!
		AfxMessageBox( IDS_FAILED_CREATE_VIEW, MB_OK | MB_ICONEXCLAMATION );
		AfxThrowUserException();
	}

	//get splitter pos from registry
	CString sDialerExplorer,sRegKey;
	sDialerExplorer.LoadString(IDN_REGISTRY_DIALEREXPLORER_KEY);
	sRegKey.LoadString(IDN_REGISTRY_DIALEREXPLORER_SPLITTER_POS);
	int nPercent = AfxGetApp()->GetProfileInt(sDialerExplorer,sRegKey,70);

	//Init the views in the splitter
	Init( SP_VERTICAL );
	SetMainWindow( &m_wndExplorer );
	SetDetailWindow( &m_wndEmpty, nPercent );

	// Initialize explorer views
	m_wndExplorer.Init(this);
}

void CActiveDialerView::OnUpdate(CView* pSender, LPARAM lHint, CObject* pHint) 
{
	switch ( lHint )
	{
		case CActiveDialerDoc::HINT_POST_TAPI_INIT:
			m_wndExplorer.PostMessage( WM_POSTTAPIINIT );
			break;
		
		case CActiveDialerDoc::HINT_POST_AVTAPI_INIT:
			m_wndExplorer.PostMessage( WM_POSTAVTAPIINIT );
			break;

		case CActiveDialerDoc::HINT_SPEEDDIAL_ADD:
		case CActiveDialerDoc::HINT_SPEEDDIAL_DELETE:
		case CActiveDialerDoc::HINT_SPEEDDIAL_MODIFY:
			m_wndExplorer.m_wndMainDirectories.RepopulateSpeedDialList( false );
			break;
	}
}

/////////////////////////////////////////////////////////////////////////////
void CActiveDialerView::OnDraw(CDC* pDC)
{
	CActiveDialerDoc* pDoc = GetDocument();
	ASSERT_VALID(pDoc);
   CSplitterView::OnDraw( pDC );
}

/////////////////////////////////////////////////////////////////////////////
// CActiveDialerView diagnostics

#ifdef _DEBUG
void CActiveDialerView::AssertValid() const
{
	CSplitterView::AssertValid();
}

void CActiveDialerView::Dump(CDumpContext& dc) const
{
	CSplitterView::Dump(dc);
}

/////////////////////////////////////////////////////////////////////////////
CActiveDialerDoc* CActiveDialerView::GetDocument() // non-debug version is inline
{
	ASSERT(m_pDocument->IsKindOf(RUNTIME_CLASS(CActiveDialerDoc)));
	return (CActiveDialerDoc*)m_pDocument;
}
#endif //_DEBUG


IAVTapi* CActiveDialerView::GetTapi()
{
   if ( !GetDocument() ) return NULL;
   return GetDocument()->GetTapi();
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Explorer View Routing
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
LRESULT CActiveDialerView::OnDialerViewActionRequested(WPARAM wParam, LPARAM lParam)
{
	CActiveDialerDoc* pDoc = GetDocument();
	if ( !pDoc ) return -1;

	try
	{
		CallClientActions cca = CallClientActions(lParam);
		switch (cca)
		{
			case CC_ACTIONS_SHOWADDRESSBOOK:
			case CC_ACTIONS_SHOWCONFSERVICES:
			case CC_ACTIONS_SHOWCONFROOM:
				//show the frame window
				pDoc->ShowDialerExplorer(TRUE);    
				m_wndExplorer.ExplorerShowItem(cca);
				break;

			case CC_ACTIONS_SHOWPREVIEW:
				pDoc->ShowPreviewWindow(TRUE);
				break;


			case CC_ACTIONS_HIDEPREVIEW:
				pDoc->ShowPreviewWindow(FALSE);
				break;

			case CC_ACTIONS_JOIN_CONFERENCE:
			case CC_ACTIONS_LEAVE_CONFERENCE:
				if ( AfxGetMainWnd() )
					((CMainFrame *) AfxGetMainWnd())->UpdateTrayIconState();
				break;
		}
	}
	catch (...) {}

	return 0;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveDialerView::OnCmdMsg(UINT nID, int nCode, void* pExtra, AFX_CMDHANDLERINFO* pHandlerInfo) 
{
   if ( !CSplitterView::OnCmdMsg(nID, nCode, pExtra, pHandlerInfo) )
      return m_wndExplorer.OnCmdMsg( nID,nCode,pExtra,pHandlerInfo );

   return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//Special support for listviews
void CActiveDialerView::OnGetdispinfoList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	LV_DISPINFO* pDispInfo = (LV_DISPINFO*)pNMHDR;
	::SendMessage(pNMHDR->hwndFrom, WM_NOTIFY,MAKEWPARAM(LVN_GETDISPINFO,pNMHDR->idFrom), (LPARAM) pNMHDR );
}

/////////////////////////////////////////////////////////////////////////////
//Special support for listviews
void CActiveDialerView::OnColumnclickList(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_LISTVIEW* pNMListView = (NM_LISTVIEW*)pNMHDR;
	::SendMessage(pNMHDR->hwndFrom, WM_NOTIFY,MAKEWPARAM(LVN_COLUMNCLICK,pNMHDR->idFrom), (LPARAM) pNMHDR );
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//DS User Methods
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
LRESULT CActiveDialerView::OnDSClearUserList(WPARAM wParam, LPARAM lParam)
{
   m_wndExplorer.DSClearUserList();
   return 0;
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CActiveDialerView::OnDSAddUser(WPARAM wParam, LPARAM lParam)
{
   CDSUser* pDSUser = (CDSUser*)lParam;
   if (pDSUser == NULL) return 0;

   m_wndExplorer.DSAddUser(pDSUser);

   return 0;
}

LRESULT CActiveDialerView::OnBuddyListDynamicUpdate(WPARAM wParam, LPARAM lParam)
{
	CLDAPUser *pUser = (CLDAPUser *) lParam;
	ASSERT( pUser && pUser->IsKindOf(RUNTIME_CLASS(CLDAPUser)) );

	if ( pUser )
	{
		HWND hWnd[2] = {	m_wndExplorer.m_wndMainDirectories.m_lstPerson.GetSafeHwnd(),
					 		m_wndExplorer.m_wndMainDirectories.m_lstPersonGroup.GetSafeHwnd() };

		for ( int i = 0; i < ARRAYSIZE(hWnd); i++ )
		{
			pUser->AddRef();
			::PostMessage( hWnd[i], WM_ACTIVEDIALER_BUDDYLIST_DYNAMICUPDATE, wParam, lParam );
		}

		// Clean up object
		pUser->Release();
	}

	return 0;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void CActiveDialerView::OnNextPane() 
{
	m_wndExplorer.OnNextPane();
}

void CActiveDialerView::OnPrevPane() 
{
	m_wndExplorer.OnPrevPane();
}

void CActiveDialerView::OnUpdatePane(CCmdUI* pCmdUI) 
{
	pCmdUI->Enable();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\avtrace.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// TAPIDialer(tm) and ActiveDialer(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526; 5,488,650; 
// 5,434,906; 5,581,604; 5,533,102; 5,568,540, 5,625,676.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

#ifndef _AVTRACE_H_
#define _AVTRACE_H_

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#ifdef _DEBUG
   #define  AVTRACE ActiveTrace
#else
   #define  AVTRACE
#endif 

inline void ActiveTrace(LPCTSTR str,...)
{
   TCHAR buffer[256];
	LPTSTR pBuffer = buffer;
	_tcscpy(buffer,_T("Active: "));
	pBuffer += _tcslen(_T("Active: "));
   va_list marker;
   va_start(marker,str);
   _vstprintf(pBuffer,str,marker);
   va_end(marker);
   _tcscat(buffer,_T("\n"));
   OutputDebugString(buffer);
}  

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#endif //_AVTRACE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\avnotify.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// AVTapiNotification.cpp : Implementation of CAVTapiNotification
#include "stdafx.h"
#include "TapiDialer.h"
#include "AVNotify.h"
#include "callmgr.h"
#include "mainfrm.h"
#include "aboutdlg.h"
#include "SpeedDlgs.h"

#define MAIN_POST_MESSAGE(_WM_, _WPARAM_, _LPARAM_ )    \
CMainFrame *pFrame = (CMainFrame *) AfxGetMainWnd();    \
BOOL bPosted = FALSE;                                    \
if ( pFrame )                                            \
{                                                        \
    CActiveDialerView *pView = (CActiveDialerView *) pFrame->GetActiveView();    \
    if ( pView )                                        \
        bPosted = pView->m_wndExplorer.m_wndMainDirectories.PostMessage(_WM_, (WPARAM) (_WPARAM_), (LPARAM) (_LPARAM_));    \
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CAVTapiNotification
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CAVTapiNotification::Init(IAVTapi* pTapi,CActiveCallManager* pCallManager)
{
   m_pCallManager = pCallManager;
   HRESULT hr = AtlAdvise(pTapi,GetUnknown(),IID_IAVTapiNotification,&m_dwCookie);

   if (SUCCEEDED(hr))
   {
      m_pTapi = pTapi;
      m_pTapi->AddRef();

      // Get the IAVTapi2 interface
      IAVTapi2* pTapi2 = NULL;
      pTapi->QueryInterface( IID_IAVTapi2,
          (void**)&pTapi2
          );

      if( pTapi2 )
      {
          // Signal that the Dialer was register
          // as client for the events
          pTapi2->DoneRegistration();

          // clean-up
          pTapi2->Release();
      }
   }

   return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CAVTapiNotification::Shutdown()
{
   AtlUnadvise(m_pTapi,IID_IAVTapiNotification,m_dwCookie);
   m_pTapi->Release();
   return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CAVTapiNotification::NewCall(long * plCallID, CallManagerMedia cmm,BSTR bstrMediaName)
{
   UINT uCallId = m_pCallManager->NewIncomingCall(cmm);
   *plCallID = uCallId;
    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CAVTapiNotification::SetCallerID(long lCallID, BSTR bstrCallerID)
{
   CString sText;
   if (bstrCallerID)
   {
      USES_CONVERSION;
      sText = OLE2CT(bstrCallerID);
   }
   m_pCallManager->SetCallerId((UINT)lCallID,sText);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CAVTapiNotification::ClearCurrentActions(long lCallerID)
{
   m_pCallManager->ClearCurrentActions((UINT)lCallerID);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CAVTapiNotification::AddCurrentAction(long lCallID, CallManagerActions cma, BSTR bstrText)
{
   CString sText;
   if (bstrText)
   {
      USES_CONVERSION;
      sText = OLE2CT( bstrText );
   }
   m_pCallManager->AddCurrentActions((UINT)lCallID,cma,sText);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CAVTapiNotification::SetCallState(long lCallID, CallManagerStates cms, BSTR bstrText)
{
   CString sText;
   if (bstrText)
   {
      USES_CONVERSION;
      sText = OLE2CT( bstrText );
   }
   m_pCallManager->SetCallState((UINT)lCallID,cms,sText);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CAVTapiNotification::CloseCallControl(long lCallID)
{
   m_pCallManager->CloseCallControl((UINT)lCallID);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CAVTapiNotification::ErrorNotify(BSTR bstrOperation,BSTR bstrDetails,long hrError)
{
   USES_CONVERSION;

   CString sOperation,sDetails;
   if (bstrOperation)
      sOperation = OLE2CT( bstrOperation );

   if (bstrDetails)
      sDetails = OLE2CT( bstrDetails );

   m_pCallManager->ErrorNotify(sOperation,sDetails,hrError);

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CAVTapiNotification::ActionSelected(CallClientActions cca)
{
   m_pCallManager->ActionRequested(cca);   
   return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CAVTapiNotification::LogCall(long lCallID,CallLogType nType,DATE dateStart,DATE dateEnd,BSTR bstrAddr,BSTR bstrName)
{
   USES_CONVERSION;

   CString sAddress,sName;
   if (bstrAddr)
      sAddress = OLE2CT(bstrAddr);
   if (bstrName)
      sName = OLE2CT(bstrName);

   COleDateTime startdate(dateStart);
   COleDateTime enddate(dateEnd);
   COleDateTimeSpan timespan = dateEnd - dateStart;

   DWORD dwDuration = (DWORD)timespan.GetTotalSeconds();

   m_pCallManager->LogCall(nType,sName,sAddress,startdate,dwDuration);

   return S_OK;
}

//////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CAVTapiNotification::NotifyUserUserInfo( long lCallID, ULONG_PTR hMem )
{
    TRACE(_T(".enter.CAVTapiNotification::NotifyUserUserInfo(%ld).\n"), lCallID );

    ASSERT( hMem );
    HRESULT hr = E_POINTER;
    bool bShowDialog = false;
    
    if ( hMem )
    {
        hr = S_OK;

        //
        // We should verify the pointer returned by AfxGetMainWnd
        //

        CWnd* pMainWnd = AfxGetMainWnd();

        if ( pMainWnd )
        {
            CUserUserDlg *pDlg = new CUserUserDlg();
            if ( pDlg )
            {
                // Copy information out of User/User info structure
                MyUserUserInfo *pUU = (MyUserUserInfo *) GlobalLock( (HGLOBAL) hMem );
                if ( pUU && (pUU->lSchema == MAGIC_NUMBER_USERUSER) )
                {
                    pDlg->m_lCallID = lCallID;
                    pDlg->m_strWelcome = pUU->szWelcome;
                    pDlg->m_strUrl = pUU->szUrl;
                    bShowDialog = true;
                }
            }

            // Post the message
            if ( bShowDialog )
                pMainWnd->PostMessage( WM_USERUSER_DIALOG, (WPARAM) lCallID, (LPARAM) pDlg );
        }

        CoTaskMemFree( (void *) hMem );
    }

    return hr;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CGeneralNotification
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CGeneralNotification::Init(IAVGeneralNotification* pAVGN,CActiveCallManager* pCallManager)
{
   m_pCallManager = pCallManager;
   HRESULT hr = AtlAdvise(pAVGN,GetUnknown(),IID_IGeneralNotification,&m_dwCookie);
   if (SUCCEEDED(hr))
   {
      m_pAVGN = pAVGN;
      m_pAVGN->AddRef();
   }

   return hr;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CGeneralNotification::Shutdown()
{
   AtlUnadvise(m_pAVGN,IID_IGeneralNotification,m_dwCookie);
   m_pAVGN->Release();
   return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CGeneralNotification::IsReminderSet(BSTR bstrServer,BSTR bstrName)
{
   USES_CONVERSION;

   CString sServer,sName;
   if (bstrServer)
      sServer = OLE2CT( bstrServer );

   if (bstrName)
      sName = OLE2CT( bstrName );

   return (m_pCallManager->IsReminderSet(sServer,sName))?S_OK:S_FALSE;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CGeneralNotification::ResolveAddress(BSTR bstrAddress, BSTR* pbstrName,BSTR* pbstrUser1,BSTR* pbstrUser2)
{
   USES_CONVERSION;

   CString sAddress,sName,sUser1,sUser2;

   if (bstrAddress)
      sAddress = OLE2CT( bstrAddress );

   m_pCallManager->ResolveAddress(sAddress,sName,sUser1,sUser2);

   BSTR bstrName = sName.AllocSysString();
   BSTR bstrUser1 = sUser1.AllocSysString();
   BSTR bstrUser2 = sUser2.AllocSysString();

   *pbstrName = bstrName;
   *pbstrUser1 = bstrUser1;
   *pbstrUser2 = bstrUser2;

   return S_OK;   
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CGeneralNotification::ClearUserList()
{
   //We don't use this to receive DS users anymore.  We manage the DS directly.

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CGeneralNotification::AddUser(BSTR bstrName, BSTR bstrAddress, BSTR bstrPhoneNumber)
{
   MAIN_POST_MESSAGE( WM_MYONSELCHANGED, 0, 0 );
   return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
STDMETHODIMP CGeneralNotification::ResolveAddressEx(BSTR bstrAddress,long lAddressType,DialerMediaType nMedia,DialerLocationType nLocation,BSTR* pbstrName,BSTR* pbstrRetAddress,BSTR* pbstrUser1,BSTR* pbstrUser2)
{
   USES_CONVERSION;

   CString sAddress,sName,sRetAddress,sUser1,sUser2;

   if (bstrAddress)
      sAddress = OLE2CT( bstrAddress );

   BOOL bRet = m_pCallManager->ResolveAddressEx(sAddress,lAddressType,nMedia,nLocation,sName,sRetAddress,sUser1,sUser2);

   BSTR bstrName = sName.AllocSysString();
   BSTR bstrRetAddress = sRetAddress.AllocSysString();
   BSTR bstrUser1 = sUser1.AllocSysString();
   BSTR bstrUser2 = sUser2.AllocSysString();

   *pbstrName = bstrName;
   *pbstrRetAddress = bstrRetAddress;
   *pbstrUser1 = bstrUser1;
   *pbstrUser2 = bstrUser2;

   return (bRet)?S_OK:S_FALSE;
}

STDMETHODIMP CGeneralNotification::AddSiteServer(BSTR bstrServer)
{
    BSTR bstrPost = SysAllocString( bstrServer );
    MAIN_POST_MESSAGE( WM_ADDSITESERVER, 0, bstrPost );
    if ( !bPosted )
        SysFreeString( bstrPost );

    return S_OK;
}

STDMETHODIMP CGeneralNotification::RemoveSiteServer(BSTR bstrName)
{
    BSTR bstrPost = SysAllocString( bstrName );
    MAIN_POST_MESSAGE( WM_REMOVESITESERVER, 0, bstrPost );
    if ( !bPosted )
        SysFreeString( bstrPost );

    return S_OK;
}

STDMETHODIMP CGeneralNotification::NotifySiteServerStateChange(BSTR bstrName, ServerState nState)
{
    BSTR bstrPost = SysAllocString( bstrName );
    MAIN_POST_MESSAGE( WM_NOTIFYSITESERVERSTATECHANGE, nState, bstrPost );
    if ( !bPosted )
        SysFreeString( bstrPost );

    return S_OK;
}

STDMETHODIMP CGeneralNotification::AddSpeedDial(BSTR bstrName, BSTR bstrAddress, CallManagerMedia cmm)
{
    CSpeedDialAddDlg dlg;

    // Setup dialog data
    dlg.m_CallEntry.m_MediaType = CMMToDMT(cmm);
    dlg.m_CallEntry.m_sDisplayName = bstrName;
    dlg.m_CallEntry.m_lAddressType = CMMToAT(cmm);
    dlg.m_CallEntry.m_sAddress = bstrAddress;

    // Show the dialog and add if user says is okay
    if ( dlg.DoModal() == IDOK )
        CDialerRegistry::AddCallEntry( FALSE, dlg.m_CallEntry );

    return S_OK;
}


STDMETHODIMP CGeneralNotification::UpdateConfRootItem(BSTR bstrNewText)
{
    BSTR bstrPost = SysAllocString( bstrNewText );
    MAIN_POST_MESSAGE( WM_UPDATECONFROOTITEM, 0, bstrPost );
    if ( !bPosted )
        SysFreeString( bstrPost );

    return S_OK;
}

STDMETHODIMP CGeneralNotification::UpdateConfParticipant(MyUpdateType nType, IParticipant * pParticipant, BSTR bstrText)
{
    UINT wm;
    switch ( nType )
    {
        case UPDATE_ADD:        wm = WM_UPDATECONFPARTICIPANT_ADD;    break;
        case UPDATE_REMOVE:        wm = WM_UPDATECONFPARTICIPANT_REMOVE; break;
        default:                wm = WM_UPDATECONFPARTICIPANT_MODIFY; break;
    }

    BSTR bstrPost = SysAllocString( bstrText );
    
    if ( pParticipant ) pParticipant->AddRef();
    MAIN_POST_MESSAGE( wm, pParticipant, bstrPost );

    // Basic clean up
    if ( !bPosted )
    {
        SysFreeString( bstrPost );
        if ( pParticipant )    pParticipant->Release();
    }

    return S_OK;
}

STDMETHODIMP CGeneralNotification::DeleteAllConfParticipants()
{
    MAIN_POST_MESSAGE( WM_DELETEALLCONFPARTICIPANTS, 0, 0 );
    return S_OK;
}

STDMETHODIMP CGeneralNotification::SelectConfParticipant(IParticipant * pParticipant)
{
    if ( pParticipant ) pParticipant->AddRef();
    MAIN_POST_MESSAGE( WM_SELECTCONFPARTICIPANT, pParticipant, 0 );

    if ( !bPosted && pParticipant )
        pParticipant->Release();

    return S_OK;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\bitmenu.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// bitmenu.cpp : custom menu

#include "stdafx.h"
#include <windowsx.h>
#include "bitmenu.h"
#include "bmputil.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#define BITMAPMENU_DEFAULT_WIDTH        20
#define BITMAPMENU_DEFAULT_HEIGHT        20
#define BITMAPMENU_TEXTOFFSET_X            24
#define BITMAPMENU_TABOFFSET            20
#define BITMAPMENU_SELTEXTOFFSET_X        (BITMAPMENU_TEXTOFFSET_X - 2)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CBitmapMenu
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CBitmapMenu::MakeMenuOwnerDrawn(HMENU hmenu,BOOL bPopupMenu)
{
   if (hmenu == NULL) return;

   //go through all menu items and set ownerdrawn for any id's that we want bitmaps for
   UINT uMenuCount = ::GetMenuItemCount(hmenu);

   //go through menu and make all ownerdrawn (except separator)
   for (int i=0;i<(int)uMenuCount;i++)
   {
      MENUITEMINFO menuiteminfo;
      memset(&menuiteminfo,0,sizeof(MENUITEMINFO));
      menuiteminfo.fMask = MIIM_SUBMENU|MIIM_TYPE|MIIM_ID;
      menuiteminfo.cbSize = sizeof(MENUITEMINFO);
      if (::GetMenuItemInfo(hmenu,i,TRUE,&menuiteminfo))
      {
         
         if (menuiteminfo.hSubMenu)
         {
            DWORD dwState = GetMenuState(hmenu,i,MF_BYPOSITION);
            //MF_MENUBARBREAK 
            //there is an submenu recurse in and look at that menu
            MakeMenuOwnerDrawn(menuiteminfo.hSubMenu,TRUE);
         }

         if ( ( (menuiteminfo.fType & MFT_SEPARATOR) == FALSE) &&    //Not a separator
              (bPopupMenu == TRUE) )                                 //Make sure it's a popup
         {
            MENUITEMINFO newmenuiteminfo;
            memset(&newmenuiteminfo,0,sizeof(MENUITEMINFO));
            newmenuiteminfo.fMask = MIIM_TYPE;
            newmenuiteminfo.fType = menuiteminfo.fType |= MFT_OWNERDRAW;   //add ownerdraw
            newmenuiteminfo.cbSize = sizeof(MENUITEMINFO);
            ::SetMenuItemInfo(hmenu,i,TRUE,&newmenuiteminfo);
         }

         //
         // Clean-up MENUITEMINFO
         //

         if( menuiteminfo.hbmpChecked )
             DeleteObject( menuiteminfo.hbmpChecked );
         if( menuiteminfo.hbmpItem )
             DeleteObject( menuiteminfo.hbmpItem );
         if( menuiteminfo.hbmpUnchecked )
             DeleteObject( menuiteminfo.hbmpUnchecked );
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CBitmapMenu::DoMeasureItem(int nIDCtl,LPMEASUREITEMSTRUCT lpMIS,LPCTSTR szText)
{
   //validate nIDCtl 
   if (nIDCtl != 0) return;      //Not from a menu control

     // set defaults
    lpMIS->itemWidth = BITMAPMENU_DEFAULT_WIDTH;
    lpMIS->itemHeight = BITMAPMENU_DEFAULT_HEIGHT;

   HWND hwnd = ::GetDesktopWindow();
   HDC hdc = ::GetDC(hwnd);

   //
   // We should verify if hdc is valid
   //

   if( NULL == hdc )
   {
       return;
   }

   //if (pItem == NULL) return;
 
   // Use the SystemParametersInfo function to get info about
   // the current menu font.
   NONCLIENTMETRICS ncm;
   ncm.cbSize = sizeof(NONCLIENTMETRICS);
   SystemParametersInfo(SPI_GETNONCLIENTMETRICS, sizeof(NONCLIENTMETRICS),(void*)&ncm, 0);

   // Create a CFont object based on the menu font and select it
   // into our device context.
   HFONT hFont;
   hFont = ::CreateFontIndirect(&(ncm.lfMenuFont));
   if( hFont == NULL)
   {
       ::ReleaseDC( hwnd, hdc );
       return;
   }
   HFONT hOldFont = (HFONT)::SelectObject(hdc,hFont);

   // Get the size of the text based on the current menu font.
   if (szText)
   {
      SIZE size;
      GetTextExtentPoint32(hdc,szText,_tcslen(szText),&size);

      lpMIS->itemWidth = size.cx + BITMAPMENU_TEXTOFFSET_X;
      lpMIS->itemHeight = (ncm.iMenuHeight > 20 ? ncm.iMenuHeight + 2 : 20);

      // Look for tabs in menu item...
      if ( _tcschr(szText, _T('\t')) )
        lpMIS->itemWidth += BITMAPMENU_TABOFFSET * 2;

   }

   // Reset the device context.
   ::SelectObject(hdc,hOldFont);

   //
   // We should delete the resource hFont
   //
   ::DeleteObject( hFont );

   ::ReleaseDC(hwnd,hdc);
}

void CBitmapMenu::DoDrawItem(int nIDCtl,LPDRAWITEMSTRUCT lpDIS,HIMAGELIST hImageList,int nImageIndex,LPCTSTR szText)
{
   //validate nIDCtl 
   if (nIDCtl != 0) return;      //Not from a menu control

   HDC hdc = lpDIS->hDC;

   /*
   if (lpDIS->itemState & ODS_DISABLED)
      AVTRACE("ODS_DISABLED");
   if (lpDIS->itemState & ODS_GRAYED)
      AVTRACE("ODS_GRAYED");
   if (lpDIS->itemState & ODS_INACTIVE)
      AVTRACE("ODS_INACTIVE");
   if (lpDIS->itemState & ODS_CHECKED)
      AVTRACE("ODS_CHECKED");*/

     if ((lpDIS->itemState & ODS_SELECTED) &&
        (lpDIS->itemAction & (ODA_SELECT | ODA_DRAWENTIRE)))
    {
      // item has been selected - hilite frame
      if ( (hImageList) && (nImageIndex != -1) )
      {
         if ((lpDIS->itemState & ODS_DISABLED) == FALSE)
         {
            RECT rcImage;
            rcImage.left = lpDIS->rcItem.left;
            rcImage.top = lpDIS->rcItem.top;
            rcImage.right = lpDIS->rcItem.left+BITMAPMENU_SELTEXTOFFSET_X;
            rcImage.bottom = lpDIS->rcItem.bottom;
            Draw3dRect(hdc,&rcImage,GetSysColor(COLOR_BTNHILIGHT),GetSysColor(COLOR_BTNSHADOW));
         }

         RECT rcText;
         ::CopyRect(&rcText,&lpDIS->rcItem);
         rcText.left += BITMAPMENU_SELTEXTOFFSET_X;

         ::SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
         ::ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rcText, NULL, 0, NULL);
      }
      else
      {
         ::SetBkColor(hdc, GetSysColor(COLOR_HIGHLIGHT));
         ::ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &lpDIS->rcItem, NULL, 0, NULL);
      }  
    }

    if (!(lpDIS->itemState & ODS_SELECTED) &&
        (lpDIS->itemAction & ODA_SELECT))
    {
        // Item has been de-selected -- remove frame
      //FillSolidRect
      ::SetBkColor(hdc, GetSysColor(COLOR_MENU));
      ::ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &lpDIS->rcItem, NULL, 0, NULL);
    }

    if ( (lpDIS->itemAction & ODA_DRAWENTIRE) ||
        (lpDIS->itemAction & ODA_SELECT) )
    {
      if ( (hImageList) && (nImageIndex != -1) )
      {
         int nPosY = lpDIS->rcItem.top+((lpDIS->rcItem.bottom-lpDIS->rcItem.top-15)/2);
         ImageList_Draw(hImageList,nImageIndex,hdc,lpDIS->rcItem.left+3,nPosY,ILD_TRANSPARENT);
      }

      RECT rcText;
      ::CopyRect(&rcText,&lpDIS->rcItem);
      rcText.left += BITMAPMENU_TEXTOFFSET_X;

        if (szText)
        {
            CString strMenu = szText;
            CString strAccel;

            int nInd = strMenu.Find( _T('\t') );
            if ( (nInd != -1) && (nInd < (strMenu.GetLength() - 1)) )
            {
                strAccel = strMenu.Mid( nInd + 1 );
                strMenu = strMenu.Left( nInd );
            }


            if (lpDIS->itemState & ODS_SELECTED)
            {
                ::SetTextColor(hdc,GetSysColor(COLOR_HIGHLIGHTTEXT));
            }
            else if (lpDIS->itemState & ODS_DISABLED)
            {
                //Draw the text in white (or rather, the 3D highlight color) and then draw the
                //same text in the shadow color but one pixel up and to the left.
                ::SetTextColor(hdc,GetSysColor(COLOR_3DHIGHLIGHT));
                rcText.left++;rcText.right++;rcText.top++;rcText.bottom++;

                ::DrawText(hdc,strMenu,strMenu.GetLength(),&rcText, DT_SINGLELINE | DT_LEFT | DT_VCENTER | DT_EXPANDTABS );
                if ( !strAccel.IsEmpty() )
                {
                    rcText.right -= BITMAPMENU_TABOFFSET;
                    ::DrawText(hdc,strAccel,strAccel.GetLength(),&rcText, DT_SINGLELINE | DT_RIGHT | DT_VCENTER | DT_EXPANDTABS );
                    rcText.right += BITMAPMENU_TABOFFSET;
                }

                rcText.left--;rcText.right--;rcText.top--;rcText.bottom--;

                //DrawState() can do disabling of bitmap if this is desired
                ::SetTextColor(hdc,GetSysColor(COLOR_3DSHADOW));
                ::SetBkMode(hdc,TRANSPARENT);
            }
            else
            {
                ::SetTextColor(hdc,GetSysColor(COLOR_MENUTEXT));
            }


            // Write menu, using tabs for accelerator keys
            ::DrawText( hdc, strMenu, strMenu.GetLength(), &rcText,    DT_SINGLELINE | DT_LEFT | DT_VCENTER | DT_EXPANDTABS);
            if ( !strAccel.IsEmpty() )
            {
                rcText.right -= BITMAPMENU_TABOFFSET;
                ::DrawText(hdc,strAccel,strAccel.GetLength(),&rcText, DT_SINGLELINE | DT_RIGHT | DT_VCENTER | DT_EXPANDTABS );
                rcText.right += BITMAPMENU_TABOFFSET;
            }
        }
    }
}

/////////////////////////////////////////////////////////////////////////////////////////
HBITMAP CBitmapMenu::GetDisabledBitmap(HBITMAP hOrgBitmap,COLORREF crTransparent,COLORREF crBackGroundOut)
{
   return ::GetDisabledBitmap(hOrgBitmap,crTransparent,crBackGroundOut); 
}

/////////////////////////////////////////////////////////////////////////////////////////
void CBitmapMenu::Draw3dRect(HDC hdc,RECT* lpRect,COLORREF clrTopLeft, COLORREF clrBottomRight)
{
    Draw3dRect(hdc,lpRect->left, lpRect->top, lpRect->right - lpRect->left,
        lpRect->bottom - lpRect->top, clrTopLeft, clrBottomRight);
}

/////////////////////////////////////////////////////////////////////////////////////////
void CBitmapMenu::Draw3dRect(HDC hdc,int x, int y, int cx, int cy,
    COLORREF clrTopLeft, COLORREF clrBottomRight)
{
    FillSolidRect(hdc,x, y, cx - 1, 1, clrTopLeft);
    FillSolidRect(hdc,x, y, 1, cy - 1, clrTopLeft);
    FillSolidRect(hdc,x + cx, y, -1, cy, clrBottomRight);
    FillSolidRect(hdc,x, y + cy, cx, -1, clrBottomRight);
}

/////////////////////////////////////////////////////////////////////////////////////////
void CBitmapMenu::FillSolidRect(HDC hdc,int x, int y, int cx, int cy, COLORREF clr)
{
    ::SetBkColor(hdc, clr);
   RECT rect;
   rect.left = x;
   rect.top = y;
   rect.right = x + cx;
   rect.bottom = y + cy;
    ::ExtTextOut(hdc, 0, 0, ETO_OPAQUE, &rect, NULL, 0, NULL);
}

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\avnotify.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// AVTapiNotification.h : Declaration of the CAVTapiNotification and CGeneralNotification
/////////////////////////////////////////////////////////////////////////////////////////

#ifndef __AVTAPINOTIFICATION_H_
#define __AVTAPINOTIFICATION_H_

#include "resource.h"       // main symbols

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CAVTapiNotification
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CActiveCallManager;

class ATL_NO_VTABLE CAVTapiNotification : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CAVTapiNotification, &CLSID_AVTapiNotification>,
	public IAVTapiNotification
{
public:
	CAVTapiNotification()
	{
	}

DECLARE_REGISTRY_RESOURCEID(IDR_AVTAPINOTIFICATION)
DECLARE_NOT_AGGREGATABLE(CComMultiThreadModel)

BEGIN_COM_MAP(CAVTapiNotification)
	COM_INTERFACE_ENTRY(IAVTapiNotification)
END_COM_MAP()

// Attributes
public:
   DWORD                m_dwCookie;
   IAVTapi*             m_pTapi;
   CActiveCallManager*  m_pCallManager;

// IAVTapiNotification
public:
   STDMETHOD(Init)(IAVTapi* pTapi,CActiveCallManager* pCallManager);
   STDMETHOD(Shutdown)();

	STDMETHOD(NotifyUserUserInfo)(long lCallID, ULONG_PTR hMem);
	STDMETHOD(CloseCallControl)(long lCallID);
	STDMETHOD(SetCallState)(long lCallID, CallManagerStates cms, BSTR bstrText);
	STDMETHOD(AddCurrentAction)(long lCallID, CallManagerActions cma, BSTR bstrText);
	STDMETHOD(ClearCurrentActions)(long lCallerID);
	STDMETHOD(SetCallerID)(long lCallID, BSTR bstrCallerID);
	STDMETHOD(NewCall)(long *plCallID, CallManagerMedia cmm,BSTR bstrMediaName);
   STDMETHOD(ErrorNotify)(BSTR bstrOperation,BSTR bstrDetails,long hrError);
   STDMETHOD(ActionSelected)(CallClientActions cca);
   STDMETHOD(LogCall)(long lCallID,CallLogType nType,DATE dateStart,DATE dateEnd,BSTR bstrAddr,BSTR bstrName);
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CGeneralNotification
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class ATL_NO_VTABLE CGeneralNotification : 
	public CComObjectRootEx<CComMultiThreadModel>,
	public CComCoClass<CGeneralNotification, &CLSID_GeneralNotification>,
	public IGeneralNotification
{
public:
	CGeneralNotification()
	{
	}

//DECLARE_REGISTRY_RESOURCEID(IDR_AVGENERALNOTIFICATION)
DECLARE_NOT_AGGREGATABLE(CGeneralNotification)

BEGIN_COM_MAP(CGeneralNotification)
	COM_INTERFACE_ENTRY(IGeneralNotification)
END_COM_MAP()

// Attributes
public:
	DWORD                      m_dwCookie;
	IAVGeneralNotification*    m_pAVGN;
	CActiveCallManager*        m_pCallManager;

// IAVTapiNotification
public:
	STDMETHOD(Init)(IAVGeneralNotification* pAVGN,CActiveCallManager* pCallManager);
	STDMETHOD(Shutdown)();

	STDMETHOD(SelectConfParticipant)(IParticipant *pParticipant);
	STDMETHOD(DeleteAllConfParticipants)();
	STDMETHOD(UpdateConfParticipant)(MyUpdateType nType, IParticipant *pParticipant, BSTR bstrText);
	STDMETHOD(UpdateConfRootItem)(BSTR bstrNewText);
	STDMETHOD(IsReminderSet)(BSTR bstrServer,BSTR bstrName);
	STDMETHOD(ResolveAddress)(BSTR bstrAddress, BSTR* pbstrName,BSTR* pbstrUser1,BSTR* pbstrUser2);
	STDMETHOD(AddUser)(BSTR bstrName, BSTR bstrAddress, BSTR bstrPhoneNumber);
	STDMETHOD(ClearUserList)();
	STDMETHOD(ResolveAddressEx)(BSTR bstrAddress,long lAddressType,DialerMediaType nMedia,DialerLocationType nLocation,BSTR* pbstrName,BSTR* pbstrRetAddress,BSTR* pbstrUser1,BSTR* pbstrUser2);
	STDMETHOD(NotifySiteServerStateChange)(BSTR bstrName, ServerState nState);
	STDMETHOD(RemoveSiteServer)(BSTR bstrName);
	STDMETHOD(AddSiteServer)(BSTR bstrServer);
	STDMETHOD(AddSpeedDial)(BSTR bstrName, BSTR bstrAddress, CallManagerMedia cmm);
};

#endif //__AVTAPINOTIFICATION_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\avtree.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// AVTree.cpp : implementation file
//

#include "stdafx.h"
#include "avtree.h"
#include "aexpltre.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CAVTreeItem

CAVTreeItem::CAVTreeItem()
{
	m_sText = _T("");
	m_hItem = NULL;
	m_nImage = 0;
	m_nImageSel = TIM_IMAGE_BAD;
	m_nState = 0;
}

CAVTreeItem::CAVTreeItem( LPCTSTR str, int nImage /*= 0*/, int nState /*= 0*/ )
{
	m_sText = str;
	m_hItem = NULL;
	m_nImage = nImage;
	m_nState = nState;
	m_nImageSel = TIM_IMAGE_BAD;
}

CAVTreeItem::~CAVTreeItem()
{
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CAVTreeCtrl

IMPLEMENT_DYNCREATE(CAVTreeCtrl, CTreeCtrl)

CAVTreeCtrl::CAVTreeCtrl()
{
	m_pImageList = NULL;
}

CAVTreeCtrl::~CAVTreeCtrl()
{
	if (m_pImageList) delete m_pImageList;
}


BEGIN_MESSAGE_MAP(CAVTreeCtrl, CTreeCtrl)
	//{{AFX_MSG_MAP(CAVTreeCtrl)
	ON_NOTIFY_REFLECT(TVN_GETDISPINFO, OnGetdispinfo)
	ON_NOTIFY_REFLECT(TVN_ENDLABELEDIT, OnEndlabeledit)
	ON_NOTIFY_REFLECT(TVN_DELETEITEM, OnDeleteitem)
	ON_NOTIFY_REFLECT(TVN_SELCHANGED, OnSelchanged)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CAVTreeCtrl message handlers

BOOL CAVTreeCtrl::Init(UINT nID, UINT nOverlayInd /*= 0*/, UINT nOverlayCount /*= 0*/)
{
	m_pImageList = new CImageList;
	m_pImageList->Create(nID,AV_BITMAP_CX,0,RGB_TRANS);

	// Include the overlays if requested
	if ( nOverlayInd )
	{
		for ( UINT i = 1; i <= nOverlayCount; i++ )
			m_pImageList->SetOverlayImage( (nOverlayInd - 1) + i, i );
	}

	SetImageList(m_pImageList,TVSIL_NORMAL);

	return TRUE;
}

BOOL CAVTreeCtrl::InsertItem(CAVTreeItem* pItem,CAVTreeItem* pParent,CAVTreeItem* pInsertAfter, HTREEITEM hInsertAfter /*= TVI_LAST*/)
{
	TV_INSERTSTRUCT tv_inst;
	memset(&tv_inst,0,sizeof(TV_INSERTSTRUCT));

	tv_inst.hParent = (pParent) ? pParent->m_hItem : TVI_ROOT;
	tv_inst.hInsertAfter = (pInsertAfter) ? pInsertAfter->m_hItem : hInsertAfter;
	
	tv_inst.item.mask |= TVIF_TEXT;
	tv_inst.item.pszText = LPSTR_TEXTCALLBACK;

	tv_inst.item.mask |= TVIF_IMAGE | TVIF_SELECTEDIMAGE;

	if ( pItem->m_nState )
	{
		tv_inst.item.mask |= TVIF_STATE;
		tv_inst.item.stateMask |= TVIS_OVERLAYMASK;
		tv_inst.item.state = INDEXTOOVERLAYMASK(pItem->m_nState);
	}

	//images will be given on demand
	tv_inst.item.iImage = I_IMAGECALLBACK;
	tv_inst.item.iSelectedImage = I_IMAGECALLBACK;
	
	tv_inst.item.mask |= TVIF_PARAM;
	tv_inst.item.lParam = (LPARAM)pItem;

	HTREEITEM hItem = CTreeCtrl::InsertItem(&tv_inst);
	pItem->m_hItem = hItem;
	
	//sort the new list
	TV_SORTCB tv_sort;
	tv_sort.hParent = tv_inst.hParent;
	tv_sort.lpfnCompare = CAVTreeCtrl::CompareFunc;
	tv_sort.lParam = (LPARAM)this;
	CTreeCtrl::SortChildrenCB(&tv_sort);

	return (BOOL) (hItem != NULL);
}


void CAVTreeCtrl::OnGetdispinfo(NMHDR* pNMHDR, LRESULT* pResult) 
{
	TV_DISPINFO* pTVDispInfo = (TV_DISPINFO*)pNMHDR;
	TV_ITEM* pTVItem = &pTVDispInfo->item;

	// Not much we can do if we don't have the proper lParam
	ASSERT( pTVItem->lParam );
	if ( !pTVItem->lParam ) return;

	CAVTreeItem* pItem = (CAVTreeItem *) pTVItem->lParam;

	// Image from image list to show
	if ( (pTVItem->mask & TVIF_IMAGE) || (pTVItem->mask & TVIF_SELECTEDIMAGE) )
	{
		pTVItem->iImage = pItem->GetImage();
		pTVItem->iSelectedImage = (pItem->GetImageSel() == TIM_IMAGE_BAD) ? pItem->GetImage() : pItem->GetImageSel();
	}	
	
	// State of image (usually for server states, unknown, broken, etc.)
	if ( (pTVItem->mask & TVIF_STATE) && pItem->m_nState )
		pTVItem->state = INDEXTOOVERLAYMASK(pItem->m_nState );

	// Text for item
	if ( pTVItem->mask & TVIF_TEXT )
	{
		//cchTextMax is number of bytes, we need to give number of char's (for UNICODE)
		if (pItem->m_sText.IsEmpty())
			OnSetDisplayText(pItem,pTVItem->pszText,FALSE,pTVItem->cchTextMax/sizeof(TCHAR));
		else
			pTVItem->pszText = (LPTSTR)pItem->GetText();
	}

	*pResult = 0;
}

void CAVTreeCtrl::OnEndlabeledit(NMHDR* pNMHDR, LRESULT* pResult) 
{
   TV_DISPINFO* pTVDispInfo = (TV_DISPINFO*)pNMHDR;
	TV_ITEM* pTVItem = &pTVDispInfo->item;
	VERIFY(pTVItem->lParam);
	CAVTreeItem* pItem = (CAVTreeItem*)pTVItem->lParam;
	
   //Ask derived class for text
   if (pTVItem->pszText)
   {
		//cchTextMax is number of bytes, we need to give number of char's (for UNICODE)
      OnSetDisplayText(pItem,pTVItem->pszText,TRUE,pTVItem->cchTextMax/sizeof(TCHAR));
   }
   
   //Send notification to parent 
   GetParent()->SendMessage(WM_COMMAND,MAKEWPARAM(GetDlgCtrlID(),TVN_ENDLABELEDIT),(LPARAM)m_hWnd);
   
   *pResult = 0;

   //Resort the tree
   TV_SORTCB tv_sort;
   tv_sort.hParent = CTreeCtrl::GetParentItem(pTVItem->hItem);
   tv_sort.lpfnCompare = CAVTreeCtrl::CompareFunc;
   tv_sort.lParam = (LPARAM)this;
   CTreeCtrl::SortChildrenCB(&tv_sort);
}

BOOL CAVTreeCtrl::DeleteItem(CAVTreeItem* pItem)
{
   return CTreeCtrl::DeleteItem(pItem->m_hItem);
}

void CAVTreeCtrl::OnDeleteitem(NMHDR* pNMHDR, LRESULT* pResult) 
{
	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
  	TV_ITEM* pTVItem = &pNMTreeView->itemOld;

	if ( pTVItem->lParam )
		delete (CAVTreeItem*)pTVItem->lParam;	

   *pResult = 0;
}

void CAVTreeCtrl::OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult) 
{
//	NM_TREEVIEW* pNMTreeView = (NM_TREEVIEW*)pNMHDR;
//  	TV_ITEM* pTVItem = &pNMTreeView->itemNew;
//	VERIFY(pTVItem->lParam);
//	CAVTreeItem* pItem = (CAVTreeItem*)pTVItem->lParam;
 // if (pItem)
//      OnNotifySelChange(pItem);        //notify derived class 

   GetParent()->SendMessage(WM_COMMAND,MAKEWPARAM(GetDlgCtrlID(),TVN_SELCHANGED),(LPARAM)m_hWnd);

   *pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////
//Sorting callback
int CALLBACK CAVTreeCtrl::CompareFunc(LPARAM lParam1, LPARAM lParam2,LPARAM lParamSort)
{
	CAVTreeCtrl* pTreeCtrl = (CAVTreeCtrl*)lParamSort;				//this
	CAVTreeItem* pItem1 = (CAVTreeItem*)lParam1;
	CAVTreeItem* pItem2 = (CAVTreeItem*)lParam2;
	return pTreeCtrl->OnCompareTreeItems(pItem1,pItem2);        //call virtual function
}

/////////////////////////////////////////////////////////////////////////////
BOOL CAVTreeCtrl::ExpandItem(CAVTreeItem* pItem,UINT nCode)
{
   return CTreeCtrl::Expand(pItem->m_hItem,nCode);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\avtree.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// AVTree.h : header file
//

#ifndef _AVTREE_H_
#define _AVTREE_H_

#define AV_BITMAP_CX				16

/////////////////////////////////////////////////////////////////////////////
//CLASS CAVTreeItem
/////////////////////////////////////////////////////////////////////////////
class CAVTreeItem
{
	friend class CAVTreeCtrl;
public:
	//Construction
	CAVTreeItem();
	CAVTreeItem( LPCTSTR str, int nImage = 0, int nState = 0 );
	virtual ~CAVTreeItem();

//Attributes
public:
	CString		m_sText;
	HTREEITEM	m_hItem;
	int			m_nImage;
	int			m_nImageSel;
	int			m_nState;

//Operations
public:
   LPCTSTR		GetText()						{ return m_sText; };
   void			SetText(LPCTSTR str)			{ m_sText = str; };

   int			GetImage()						{ return m_nImage; };
   void			SetImage(int nImage)			{ m_nImage = nImage; };

   int			GetImageSel()					{ return m_nImageSel; }
   void			SetImageSel( int nImageSel )	{ m_nImageSel = nImageSel; }

   HTREEITEM	GetTreeItemHandle()				{ return m_hItem; };
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//CLASS CAVTreeCtrl
/////////////////////////////////////////////////////////////////////////////
class CAVTreeCtrl : public CTreeCtrl
{
	DECLARE_DYNCREATE(CAVTreeCtrl)
// Construction
public:
	CAVTreeCtrl();

// Attributes
public:
	CImageList*		m_pImageList;
// Operations
public:
	//Default parent is root and default insertafter is last
	BOOL           InsertItem(CAVTreeItem* pItem,CAVTreeItem* pParent,CAVTreeItem* pInsertAfter, HTREEITEM hInsertAfter = TVI_LAST );
   BOOL           DeleteItem(CAVTreeItem* pItem);
   BOOL           ExpandItem(CAVTreeItem* pItem,UINT nCode);

   static int CALLBACK	CompareFunc(LPARAM lParam1, LPARAM lParam2,LPARAM lParamSort);

protected:
   BOOL           Init(UINT nID, UINT nOverlayInd = 0, UINT nOverlayCount = 0);

   virtual void   OnNotifySelChange(CAVTreeItem* pItem) {};
 	virtual void   OnSetDisplayText(CAVTreeItem* pItem,LPTSTR text,BOOL dir,int nBufSize) {};
   virtual int    OnCompareTreeItems(CAVTreeItem* pItem1,CAVTreeItem* pItem2) { return 0; };

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CAVTreeCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CAVTreeCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CAVTreeCtrl)
	afx_msg void OnGetdispinfo(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnEndlabeledit(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnDeleteitem(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSelchanged(NMHDR* pNMHDR, LRESULT* pResult);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif //_AVTREE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\bitmenu.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//bitmenu.h
/////////////////////////////////////////////////////////////////////////////

#ifndef _BITMENU_H_
#define _BITMENU_H_

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
typedef struct tagBitmapMenuItem
{
   UINT     uMenuId;
   int      nImageId;
}BitmapMenuItem;
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CBitmapMenu
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CBitmapMenu
{
public:
   static void    MakeMenuOwnerDrawn(HMENU hmenu,BOOL bPopupMenu);

	static void    DoMeasureItem(int nIDCtl, 
                             LPMEASUREITEMSTRUCT lpMIS,
                             LPCTSTR szText);

	static void    DoDrawItem(int nIDCtl,
                          LPDRAWITEMSTRUCT lpDIS,
                          HIMAGELIST hImageList,
                          int nImageIndex,
                          LPCTSTR szText);

   static HBITMAP GetDisabledBitmap(HBITMAP hOrgBitmap,
                                    COLORREF crTransparent,
                                    COLORREF crBackGroundOut);   

protected:
   static void Draw3dRect(HDC hdc,RECT* lpRect,COLORREF clrTopLeft, COLORREF clrBottomRight);
   static void Draw3dRect(HDC hdc,int x, int y, int cx, int cy,COLORREF clrTopLeft, COLORREF clrBottomRight);
   static void FillSolidRect(HDC hdc,int x, int y, int cx, int cy, COLORREF clr);

};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#endif //_BITMENU_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\bmputil.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include <windowsx.h>
#include "bmputil.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#define  WHITE                         GetSysColor(COLOR_BTNHILIGHT)
#define  GRAY                         GetSysColor(COLOR_BTNSHADOW)
#define  WIDTHBYTES(bits)        (((bits) + 31) / 32 * 4)
#define  IS_WIN30_DIB(lpbi)      ((*(LPDWORD) (lpbi)) == sizeof (BITMAPINFOHEADER))

typedef struct TDibInfo
{
    WORD            wNumColors, wPaletteSize;
    LPSTR           lpPalette, lpBits;
}    TDibInfo;

#define DIB_HEADER_MARKER   ((WORD) ('M' << 8) | 'B') 

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Prototypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HANDLE      CreateDibFromBitmap(HBITMAP hBitmap, HPALETTE hPal);
WORD        PaletteSize (LPSTR lpbi);
LPSTR       FindDIBBits (LPSTR lpbi);
WORD        DIBNumColors (LPSTR lpbi);

/////////////////////////////////////////////////////////////////////////////
int ColorEqual(RGBQUAD a, COLORREF b)
{
    return a.rgbRed   == GetRValue(b)
        && a.rgbGreen == GetGValue(b)
        && a.rgbBlue  == GetBValue(b);
} 

/////////////////////////////////////////////////////////////////////////////
void SetRGBColor(RGBQUAD *Quad, COLORREF Color)
{
    Quad->rgbRed    = GetRValue(Color);
    Quad->rgbGreen  = GetGValue(Color);
    Quad->rgbBlue   = GetBValue(Color);
}


/////////////////////////////////////////////////////////////////////////////
// This function  creates a disabled version of the image, and returns it as an
// HBITMAP.
/////////////////////////////////////////////////////////////////////////////
HBITMAP GetDisabledBitmap(HBITMAP hOrgBitmap,COLORREF crTransparent,COLORREF crBackGroundOut)
{
    struct         TDibInfo Info;
    LPBITMAPINFO lpbmInfo;
    HDC          hdcMemory, hdcBitmap, hdcCanvas;
    WORD         i;
    HBITMAP         hTempBitmap, hOldBitmap;
    HBRUSH       hBackgroundBrush;
    HANDLE       hDib;
    HBITMAP      hBitmap = NULL;

    // prepare BITMAPINFO and DIB --------------------------
    hDib = CreateDibFromBitmap(hOrgBitmap, NULL);
    
    lpbmInfo = (LPBITMAPINFO) GlobalLock(hDib);
    if ( lpbmInfo == NULL )
        goto bail1;

    switch (lpbmInfo->bmiHeader.biBitCount)
    {
        case 1 : Info.wNumColors   = 2;    break;
        case 4 : Info.wNumColors   = 16;   break;
        case 8 : Info.wNumColors   = 256;  break;
        default: Info.wNumColors   = 0;
    }

    Info.wPaletteSize = Info.wNumColors * sizeof(RGBQUAD);
    Info.lpBits = (LPSTR)(lpbmInfo) +
        sizeof(BITMAPINFOHEADER) + Info.wPaletteSize;


    // Make copy of palette
    Info.lpPalette = (LPSTR)GlobalAllocPtr(GHND,
        Info.wPaletteSize);
    if ( Info.lpPalette == NULL )
        goto bail2;

    memcpy(Info.lpPalette, (LPSTR)lpbmInfo
        + sizeof(BITMAPINFOHEADER), Info.wPaletteSize);

    //------------------------------------------------------

    if(lpbmInfo == NULL)
        goto bail3;
    /* Create memory bitmap */
    hdcMemory = GetDC(NULL);
    hdcBitmap = CreateCompatibleDC(hdcMemory);
    hdcCanvas = CreateCompatibleDC(hdcMemory);
    hBitmap   = CreateCompatibleBitmap(hdcMemory,
                         (int)lpbmInfo->bmiHeader.biWidth,
                         (int)lpbmInfo->bmiHeader.biHeight);
    SelectBitmap(hdcCanvas, hBitmap);
    hBackgroundBrush = CreateSolidBrush( crBackGroundOut );
    SelectBrush(hdcCanvas, hBackgroundBrush);
    Rectangle(hdcCanvas, -1, -1,
        (int)(lpbmInfo->bmiHeader.biWidth + 1),
        (int)(lpbmInfo->bmiHeader.biHeight + 1));
    SelectBrush(hdcCanvas, GetStockBrush(NULL_BRUSH));
    DeleteBrush(hBackgroundBrush);

    for (i = 0; i < Info.wNumColors; i++)
        if ( ColorEqual( lpbmInfo->bmiColors[i], crTransparent ) ||
             ColorEqual( lpbmInfo->bmiColors[i], RGB(255, 255, 255) ) ||
             ColorEqual( lpbmInfo->bmiColors[i], RGB(192, 192, 192) ) )
            SetRGBColor(&lpbmInfo->bmiColors[i], crBackGroundOut);
        else
            SetRGBColor(&lpbmInfo->bmiColors[i], WHITE);

    hTempBitmap = CreateDIBitmap(hdcMemory, &lpbmInfo->
        bmiHeader, CBM_INIT, Info.lpBits,
        lpbmInfo, DIB_RGB_COLORS);

    hOldBitmap = SelectBitmap(hdcBitmap, hTempBitmap);
    BitBlt(hdcCanvas, 1, 1, (int)lpbmInfo->bmiHeader.biWidth,
        (int)lpbmInfo->bmiHeader.biHeight, hdcBitmap,
        0, 0, SRCCOPY);
    SelectBitmap(hdcBitmap, hOldBitmap);
    DeleteBitmap(hTempBitmap);

    memcpy((LPSTR)lpbmInfo + sizeof(BITMAPINFOHEADER),
              Info.lpPalette, Info.wPaletteSize);

    for (i = 0; i < Info.wNumColors; i++)
        if ( ColorEqual( lpbmInfo->bmiColors[i], crTransparent ) ||
             ColorEqual( lpbmInfo->bmiColors[i], RGB(255, 255, 255) ) ||
             ColorEqual( lpbmInfo->bmiColors[i], RGB(192, 192, 192) ) )
            SetRGBColor(&lpbmInfo->bmiColors[i], RGB(255,255,255));
        else
            SetRGBColor(&lpbmInfo->bmiColors[i], RGB(0,0,0));
    hTempBitmap = CreateDIBitmap(hdcMemory,
        &lpbmInfo->bmiHeader, CBM_INIT, Info.lpBits,
        lpbmInfo, DIB_RGB_COLORS);

    hOldBitmap = SelectBitmap(hdcBitmap, hTempBitmap);
    BitBlt(hdcCanvas, 0, 0, (int)lpbmInfo->bmiHeader.biWidth,
        (int)lpbmInfo->bmiHeader.biHeight, hdcBitmap, 0, 0,
        SRCAND);
    SelectBitmap(hdcBitmap, hOldBitmap);
    DeleteBitmap(hTempBitmap);

    memcpy((LPSTR)lpbmInfo + sizeof(BITMAPINFOHEADER),
        Info.lpPalette, Info.wPaletteSize);

    for (i = 0; i < Info.wNumColors; i++)
        if ( ColorEqual( lpbmInfo->bmiColors[i], crTransparent ) ||
             ColorEqual( lpbmInfo->bmiColors[i], RGB(255, 255, 255) ) ||
             ColorEqual( lpbmInfo->bmiColors[i], RGB(192, 192, 192) ) )
            SetRGBColor(&lpbmInfo->bmiColors[i], RGB(0,0,0));
        else
            SetRGBColor(&lpbmInfo->bmiColors[i], GRAY);
    hTempBitmap = CreateDIBitmap(hdcMemory,
        &lpbmInfo->bmiHeader, CBM_INIT, Info.lpBits,
        lpbmInfo, DIB_RGB_COLORS);

    hOldBitmap = SelectBitmap(hdcBitmap, hTempBitmap);
    BitBlt(hdcCanvas, 0, 0, (int)lpbmInfo->bmiHeader.biWidth,
        (int)lpbmInfo->bmiHeader.biHeight, hdcBitmap, 0, 0,
        SRCPAINT);
    SelectBitmap(hdcBitmap, hOldBitmap);
    DeleteBitmap(hTempBitmap);
    memcpy((LPSTR)lpbmInfo + sizeof(BITMAPINFOHEADER),
        Info.lpPalette, Info.wPaletteSize);
    DeleteDC(hdcCanvas);
    DeleteDC(hdcBitmap);
    ReleaseDC(NULL, hdcMemory);

// What all needs to be cleaned up...
bail3:
    GlobalFreePtr(Info.lpPalette);
bail2:
    if( hDib )
    {
        GlobalUnlock(hDib);
    }
bail1:
    if( hDib )
    {
        GlobalFree( hDib );
    }

    return hBitmap;
}


/////////////////////////////////////////////////////////////////////////////
// Function: CreateDibFromBitmap
/////////////////////////////////////////////////////////////////////////////
HANDLE CreateDibFromBitmap(HBITMAP hBitmap, HPALETTE hPal)
{
   BITMAP             Bitmap;
   BITMAPINFOHEADER   bmInfoHdr;
   LPBITMAPINFOHEADER lpbmInfoHdr;
   LPSTR              lpBits;
   HDC                hMemDC;
   HANDLE             hDIB;
   HPALETTE           hOldPal = NULL;
   unsigned short    nBPP    = 4; // 16 color bitmap

      // Do some setup -- make sure the Bitmap passed in is valid,
      //  get info on the bitmap (like its height, width, etc.),
      //  then setup a BITMAPINFOHEADER.

   if (!hBitmap)
      return NULL;

    //
    // We should initialize BITMAP strucutre
    memset( &Bitmap, 0, sizeof(BITMAP) );

   if (!GetObject (hBitmap, sizeof (Bitmap), (LPSTR) &Bitmap))
      return NULL;

   memset (&bmInfoHdr, 0, sizeof (BITMAPINFOHEADER));

   bmInfoHdr.biSize      = sizeof (BITMAPINFOHEADER);
   bmInfoHdr.biWidth     = Bitmap.bmWidth;
   bmInfoHdr.biHeight    = Bitmap.bmHeight;
   bmInfoHdr.biPlanes    = 1;

   bmInfoHdr.biBitCount  = nBPP; 
   bmInfoHdr.biSizeImage = WIDTHBYTES (Bitmap.bmWidth * nBPP) * Bitmap.bmHeight;

      // Now allocate memory for the DIB.  Then, set the BITMAPINFOHEADER
      //  into this memory, and find out where the bitmap bits go.

   hDIB = GlobalAlloc (GHND, sizeof (BITMAPINFOHEADER) +
             PaletteSize ((LPSTR) &bmInfoHdr) + bmInfoHdr.biSizeImage);

   if (!hDIB)
      return NULL;

   lpbmInfoHdr  = (LPBITMAPINFOHEADER) GlobalLock (hDIB);
   *lpbmInfoHdr = bmInfoHdr;
   lpBits       = FindDIBBits ((LPSTR) lpbmInfoHdr);


      // Now, we need a DC to hold our bitmap.  If the app passed us
      //  a palette, it should be selected into the DC.

   hMemDC       = GetDC (NULL);

   //
   // We have to verify the GetDC return handler before use it
   //

   if( NULL == hMemDC )
   {
       GlobalFree( hDIB );
       return NULL;
   }

   if (hPal)
      {
      hOldPal = SelectPalette (hMemDC, hPal, FALSE);
      RealizePalette (hMemDC);
      }



      // We're finally ready to get the DIB.  Call the driver and let
      //  it party on our bitmap.  It will fill in the color table,
      //  and bitmap bits of our global memory block.
    
   if (!GetDIBits (hMemDC,
                   hBitmap,
                   0,
                   Bitmap.bmHeight,
                   lpBits,
                   (LPBITMAPINFO) lpbmInfoHdr,
                   DIB_RGB_COLORS))
      {
      GlobalUnlock (hDIB);
      GlobalFree (hDIB);
      hDIB = NULL;
      }
   else
      GlobalUnlock (hDIB);


      // Finally, clean up and return.

   if (hOldPal)
      SelectPalette (hMemDC, hOldPal, FALSE);

   ReleaseDC (NULL, hMemDC);

   return hDIB;
}

/////////////////////////////////////////////////////////////////////////////
// Function: PaletteSize
/////////////////////////////////////////////////////////////////////////////
WORD PaletteSize (LPSTR lpbi)
{
   if (IS_WIN30_DIB (lpbi))
      return (DIBNumColors (lpbi) * sizeof (RGBQUAD));
   else
      return (DIBNumColors (lpbi) * sizeof (RGBTRIPLE));
}

/////////////////////////////////////////////////////////////////////////////
// Function: FindDIBBits
/////////////////////////////////////////////////////////////////////////////
LPSTR FindDIBBits (LPSTR lpbi)
{
   return (lpbi + *(LPDWORD)lpbi + PaletteSize (lpbi));
}


/////////////////////////////////////////////////////////////////////////////
// Function: DIBNumColors
/////////////////////////////////////////////////////////////////////////////
WORD DIBNumColors (LPSTR lpbi)
{
   WORD wBitCount;


      // If this is a Windows style DIB, the number of colors in the
      //  color table can be less than the number of bits per pixel
      //  allows for (i.e. lpbi->biClrUsed can be set to some value).
      //  If this is the case, return the appropriate value.

   if (IS_WIN30_DIB (lpbi))
      {
      DWORD dwClrUsed;

      dwClrUsed = ((LPBITMAPINFOHEADER) lpbi)->biClrUsed;

      if (dwClrUsed)
         return (WORD) dwClrUsed;
      }


      // Calculate the number of colors in the color table based on
      //  the number of bits per pixel for the DIB.

   if (IS_WIN30_DIB (lpbi))
      wBitCount = ((LPBITMAPINFOHEADER) lpbi)->biBitCount;
   else
      wBitCount = ((LPBITMAPCOREHEADER) lpbi)->bcBitCount;

   switch (wBitCount)
      {
      case 1:
         return 2;

      case 4:
         return 16;

      case 8:
         return 256;

      default:
         return 0;
      }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Drawing helpers
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

HDIB CopyWindowToDIB(HWND hWnd, WORD fPrintArea) 
{ 
   HDIB     hDIB = NULL;  // handle to DIB 
 
   // check for a valid window handle 
 
    if (!hWnd) 
        return NULL; 
 
    switch (fPrintArea) 
    { 
        case PW_WINDOW: // copy entire window 
        { 
            RECT    rectWnd; 
 
            // get the window rectangle 
 
            GetWindowRect(hWnd, &rectWnd); 
 
            // get the DIB of the window by calling 
            // CopyScreenToDIB and passing it the window rect 
             
            hDIB = CopyScreenToDIB(&rectWnd); 
            break; 
        } 
       
        case PW_CLIENT: // copy client area 
        { 
            RECT    rectClient; 
            POINT   pt1, pt2; 
 
            // get the client area dimensions 
 
            GetClientRect(hWnd, &rectClient); 
 
            // convert client coords to screen coords 
 
            pt1.x = rectClient.left; 
            pt1.y = rectClient.top; 
            pt2.x = rectClient.right; 
            pt2.y = rectClient.bottom; 
            ClientToScreen(hWnd, &pt1); 
            ClientToScreen(hWnd, &pt2); 
            rectClient.left = pt1.x; 
            rectClient.top = pt1.y; 
            rectClient.right = pt2.x; 
            rectClient.bottom = pt2.y; 
 
            // get the DIB of the client area by calling 
            // CopyScreenToDIB and passing it the client rect 
 
            hDIB = CopyScreenToDIB(&rectClient); 
            break; 
        } 
       
        default:    // invalid print area 
            return NULL; 
    } 
 
   // return the handle to the DIB 
 
   return hDIB; 
} 

/************************************************************************* 
 * 
 * CopyScreenToDIB() 
 * 
 * Parameter: 
 * 
 * LPRECT lpRect    - specifies the window 
 * 
 * Return Value: 
 * 
 * HDIB             - identifies the device-independent bitmap 
 * 
 * Description: 
 * 
 * This function copies the specified part of the screen to a device- 
 * independent bitmap. 
 * 
 ************************************************************************/ 
 
HDIB CopyScreenToDIB(LPRECT lpRect) 
{ 
    HBITMAP     hBitmap;        // handle to device-dependent bitmap 
    HPALETTE    hPalette;       // handle to palette 
    HDIB        hDIB = NULL;    // handle to DIB 
 
    // get the device-dependent bitmap in lpRect by calling 
    //  CopyScreenToBitmap and passing it the rectangle to grab 
 
    hBitmap = CopyScreenToBitmap(lpRect); 
 
    // check for a valid bitmap handle 
 
    if (!hBitmap) 
      return NULL; 
 
    // get the current palette 
 
    hPalette = GetSystemPalette(); 

    //
    // We should check if hPalette is a valid handler
    if( NULL == hPalette )
    {
        DeleteObject(hBitmap); 
        return NULL;
    }
 
    // convert the bitmap to a DIB 
 
    hDIB = BitmapToDIB(hBitmap, hPalette); 
 
    // clean up  
 
    DeleteObject(hPalette); 
    DeleteObject(hBitmap); 
 
    // return handle to the packed-DIB 
    return hDIB; 
} 

/************************************************************************* 
 * 
 * CopyScreenToBitmap() 
 * 
 * Parameter: 
 * 
 * LPRECT lpRect    - specifies the window 
 * 
 * Return Value: 
 * 
 * HDIB             - identifies the device-dependent bitmap 
 * 
 * Description: 
 * 
 * This function copies the specified part of the screen to a device- 
 * dependent bitmap. 
 * 
 * 
 ************************************************************************/ 
 
HBITMAP CopyScreenToBitmap(LPRECT lpRect) 
{ 
    HDC         hScrDC, hMemDC;         // screen DC and memory DC 
    HBITMAP     hBitmap, hOldBitmap;    // handles to deice-dependent bitmaps 
    int         nX, nY, nX2, nY2;       // coordinates of rectangle to grab 
    int         nWidth, nHeight;        // DIB width and height 
    int         xScrn, yScrn;           // screen resolution 
 
    // check for an empty rectangle 
 
    if (IsRectEmpty(lpRect)) 
      return NULL; 
 
    // create a DC for the screen and create 
    // a memory DC compatible to screen DC 
     
    hScrDC = CreateDC(_T("DISPLAY"), NULL, NULL, NULL); 

    //
    // We should verify the hScrDC
    //

    if( NULL == hScrDC)
    {
        return NULL;
    }

    hMemDC = CreateCompatibleDC(hScrDC); 

    //
    // We should verify the hMemDC
    //

    if( NULL == hMemDC )
    {
        DeleteDC( hScrDC );
        return NULL;
    }
 
    // get points of rectangle to grab 
 
    nX = lpRect->left; 
    nY = lpRect->top; 
    nX2 = lpRect->right; 
    nY2 = lpRect->bottom; 
 
    // get screen resolution 
 
    xScrn = GetDeviceCaps(hScrDC, HORZRES); 
    yScrn = GetDeviceCaps(hScrDC, VERTRES); 
 
    //make sure bitmap rectangle is visible 
 
    if (nX < 0) 
        nX = 0; 
    if (nY < 0) 
        nY = 0; 
    if (nX2 > xScrn) 
        nX2 = xScrn; 
    if (nY2 > yScrn) 
        nY2 = yScrn; 
 
    nWidth = nX2 - nX; 
    nHeight = nY2 - nY; 
 
    // create a bitmap compatible with the screen DC 
    hBitmap = CreateCompatibleBitmap(hScrDC, nWidth, nHeight); 

    //
    // we have to verify hBitmap
    //
    if( NULL == hBitmap )
    {
        DeleteDC( hMemDC );
        DeleteDC( hScrDC );
        return NULL;
    }
 
    // select new bitmap into memory DC 
    hOldBitmap = (HBITMAP)SelectObject(hMemDC, hBitmap); 
 
    // bitblt screen DC to memory DC 
    BitBlt(hMemDC, 0, 0, nWidth, nHeight, hScrDC, nX, nY, SRCCOPY); 
 
    // select old bitmap back into memory DC and get handle to 
    // bitmap of the screen 

    //
    // We don't need hBitmap, we should delete it
    //

    DeleteObject( hBitmap );
    
    hBitmap = (HBITMAP)SelectObject(hMemDC, hOldBitmap); 
 
    // clean up 
 
    DeleteDC(hScrDC); 
    DeleteDC(hMemDC); 
 
    // return handle to the bitmap 
 
    return hBitmap; 
} 

/************************************************************************* 
 * 
 * BitmapToDIB() 
 * 
 * Parameters: 
 * 
 * HBITMAP hBitmap  - specifies the bitmap to convert 
 * 
 * HPALETTE hPal    - specifies the palette to use with the bitmap 
 * 
 * Return Value: 
 * 
 * HDIB             - identifies the device-dependent bitmap 
 * 
 * Description: 
 * 
 * This function creates a DIB from a bitmap using the specified palette. 
 * 
 ************************************************************************/ 
 
HDIB BitmapToDIB(HBITMAP hBitmap, HPALETTE hPal) 
{ 
    BITMAP              bm;         // bitmap structure 
    BITMAPINFOHEADER    bi;         // bitmap header 
    LPBITMAPINFOHEADER  lpbi;       // pointer to BITMAPINFOHEADER 
    DWORD               dwLen;      // size of memory block 
    HANDLE              hDIB, h;    // handle to DIB, temp handle 
    HDC                 hDC;        // handle to DC 
    WORD                biBits;     // bits per pixel 
 
    // check if bitmap handle is valid 
 
    if (!hBitmap) 
        return NULL; 

    //
    // We should initialize bm structure
    //

    memset( &bm, 0, sizeof( BITMAP ) );
 
    // fill in BITMAP structure, return NULL if it didn't work 
 
    if (!GetObject(hBitmap, sizeof(bm), (LPSTR)&bm)) 
        return NULL; 
 
    // if no palette is specified, use default palette 
 
    if (hPal == NULL) 
        hPal = (HPALETTE)GetStockObject(DEFAULT_PALETTE); 
 
    // calculate bits per pixel 
 
    biBits = bm.bmPlanes * bm.bmBitsPixel; 
 
    // make sure bits per pixel is valid 
 
    if (biBits <= 1) 
        biBits = 1; 
    else if (biBits <= 4) 
        biBits = 4; 
    else if (biBits <= 8) 
        biBits = 8; 
    else // if greater than 8-bit, force to 24-bit 
        biBits = 24; 
 
    // initialize BITMAPINFOHEADER 
 
    bi.biSize = sizeof(BITMAPINFOHEADER); 
    bi.biWidth = bm.bmWidth; 
    bi.biHeight = bm.bmHeight; 
    bi.biPlanes = 1; 
    bi.biBitCount = biBits; 
    bi.biCompression = BI_RGB; 
    bi.biSizeImage = 0; 
    bi.biXPelsPerMeter = 0; 
    bi.biYPelsPerMeter = 0; 
    bi.biClrUsed = 0; 
    bi.biClrImportant = 0; 
 
    // calculate size of memory block required to store BITMAPINFO 
 
    dwLen = bi.biSize + PaletteSize((LPSTR)&bi); 
 
    // get a DC 
 
    hDC = GetDC(NULL); 

    //
    // We have to verify the hDC
    //
    if( NULL == hDC )
    {
        return NULL;
    }
 
    // select and realize our palette 
 
    hPal = SelectPalette(hDC, hPal, FALSE); 
    RealizePalette(hDC); 
 
    // alloc memory block to store our bitmap 
 
    hDIB = GlobalAlloc(GHND, dwLen); 
 
    // if we couldn't get memory block 
 
    if (!hDIB) 
    { 
      // clean up and return NULL 
 
      SelectPalette(hDC, hPal, TRUE); 
      RealizePalette(hDC); 
      ReleaseDC(NULL, hDC); 
      return NULL; 
    } 
 
    // lock memory and get pointer to it 
 
    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB); 

    //
    // We have to initialize the memory
    //
    memset( lpbi, 0, dwLen );

 
    /// use our bitmap info. to fill BITMAPINFOHEADER 
 
    *lpbi = bi; 
 
    // call GetDIBits with a NULL lpBits param, so it will calculate the 
    // biSizeImage field for us     
 
    GetDIBits(hDC, hBitmap, 0, (UINT)bi.biHeight, NULL, (LPBITMAPINFO)lpbi, 
        DIB_RGB_COLORS); 
 
    // get the info. returned by GetDIBits and unlock memory block 
 
    bi = *lpbi; 
    GlobalUnlock(hDIB); 
 
    // if the driver did not fill in the biSizeImage field, make one up  
    if (bi.biSizeImage == 0) 
        bi.biSizeImage = WIDTHBYTES((DWORD)bm.bmWidth * biBits) * bm.bmHeight; 
 
    // realloc the buffer big enough to hold all the bits 
 
    dwLen = bi.biSize + PaletteSize((LPSTR)&bi) + bi.biSizeImage; 
 
    if (h = GlobalReAlloc(hDIB, dwLen, 0)) 
        hDIB = h; 
    else 
    { 
        // clean up and return NULL 
 
        GlobalFree(hDIB); 
        hDIB = NULL; 
        SelectPalette(hDC, hPal, TRUE); 
        RealizePalette(hDC); 
        ReleaseDC(NULL, hDC); 
        return NULL; 
    } 
 
    // lock memory block and get pointer to it */ 

 
    lpbi = (LPBITMAPINFOHEADER)GlobalLock(hDIB); 

    //
    // We have to initialize the memory
    //
    memset( lpbi, 0, dwLen );
 
    // call GetDIBits with a NON-NULL lpBits param, and actualy get the 
    // bits this time 
 
    if (GetDIBits(hDC, hBitmap, 0, (UINT)bi.biHeight, (LPSTR)lpbi + 
            (WORD)lpbi->biSize + PaletteSize((LPSTR)lpbi), (LPBITMAPINFO)lpbi, 
            DIB_RGB_COLORS) == 0) 
    { 
        // clean up and return NULL 
 
        GlobalUnlock(hDIB); 

        //
        // We should deallocate the DIB
        //
        GlobalFree(hDIB);

        hDIB = NULL; 
        SelectPalette(hDC, hPal, TRUE); 
        RealizePalette(hDC); 
        ReleaseDC(NULL, hDC); 
        return NULL; 
    } 
 
    bi = *lpbi; 
 
    // clean up  
    GlobalUnlock(hDIB); 
    SelectPalette(hDC, hPal, TRUE); 
    RealizePalette(hDC); 
    ReleaseDC(NULL, hDC); 
 
    // return handle to the DIB 
    return hDIB; 
} 

/************************************************************************* 
 * 
 * GetSystemPalette() 
 * 
 * Parameters: 
 * 
 * None 
 * 
 * Return Value: 
 * 
 * HPALETTE         - handle to a copy of the current system palette 
 * 
 * Description: 
 * 
 * This function returns a handle to a palette which represents the system 
 * palette.  The system RGB values are copied into our logical palette using 
 * the GetSystemPaletteEntries function.   
 * 
 ************************************************************************/ 
 
HPALETTE GetSystemPalette(void) 
{ 
    HDC hDC;                // handle to a DC 
    static HPALETTE hPal = NULL;   // handle to a palette 
    HANDLE hLogPal;         // handle to a logical palette 
    LPLOGPALETTE lpLogPal;  // pointer to a logical palette 
    unsigned short nColors;            // number of colors 
 
    // Find out how many palette entries we want. 
 
    hDC = GetDC(NULL); 
 
    if (!hDC) 
        return NULL; 
 
    nColors = PalEntriesOnDevice(hDC);   // Number of palette entries 
 
    // Allocate room for the palette and lock it. 
 
    hLogPal = GlobalAlloc(GHND, sizeof(LOGPALETTE) + nColors * 
            sizeof(PALETTEENTRY)); 
 
    // if we didn't get a logical palette, return NULL 
 
    if (!hLogPal) 
    {
        //
        // We need to release hDC resource
        //
        ReleaseDC( NULL, hDC );
        return NULL; 
    }
 
    // get a pointer to the logical palette 
 
    lpLogPal = (LPLOGPALETTE)GlobalLock(hLogPal); 
 
    // set some important fields 
 
    lpLogPal->palVersion = PALVERSION; 
    lpLogPal->palNumEntries = nColors; 

    //
    // We should initialize also palPalEntry structure
    //

    lpLogPal->palPalEntry[0].peFlags = NULL;
    lpLogPal->palPalEntry[0].peRed = 0;
    lpLogPal->palPalEntry[0].peBlue = 0;
    lpLogPal->palPalEntry[0].peGreen = 0;
 
    // Copy the current system palette into our logical palette 
 
    GetSystemPaletteEntries(hDC, 0, nColors, 
            (LPPALETTEENTRY)(lpLogPal->palPalEntry)); 
 
    // Go ahead and create the palette.  Once it's created, 
    // we no longer need the LOGPALETTE, so free it.     
 
    hPal = CreatePalette(lpLogPal); 
 
    // clean up 
 
    GlobalUnlock(hLogPal); 
    GlobalFree(hLogPal); 
    ReleaseDC(NULL, hDC); 
 
    return hPal; 
} 

/************************************************************************* 
 * 
 * PalEntriesOnDevice() 
 * 
 * Parameter: 
 * 
 * HDC hDC          - device context 
 * 
 * Return Value: 
 * 
 * int              - number of palette entries on device 
 * 
 * Description: 
 * 
 * This function gets the number of palette entries on the specified device 
 * 
 ************************************************************************/ 
 
WORD PalEntriesOnDevice(HDC hDC) 
{ 
    WORD nColors;  // number of colors 
 
    // Find out the number of colors on this device. 
     
    nColors = (1 << (GetDeviceCaps(hDC, BITSPIXEL) * GetDeviceCaps(hDC, PLANES))); 
 
    //assert(nColors); 
    return nColors; 
} 

/************************************************************************* 
 * 
 * SaveDIB() 
 * 
 * Saves the specified DIB into the specified file name on disk.  No 
 * error checking is done, so if the file already exists, it will be 
 * written over. 
 * 
 * Parameters: 
 * 
 * HDIB hDib - Handle to the dib to save 
 * 
 * LPCTSTR lpFileName - pointer to full pathname to save DIB under 
 * 
 * Return value: 0 if successful, or one of: 
 *        ERR_INVALIDHANDLE 
 *        ERR_OPEN 
 *        ERR_LOCK 
 * 
 *************************************************************************/ 
 
WORD SaveDIB(HDIB hDib, LPCTSTR lpFileName) 
{ 
    BITMAPFILEHEADER    bmfHdr;     // Header for Bitmap file 
    LPBITMAPINFOHEADER  lpBI;       // Pointer to DIB info structure 
    HANDLE              fh;         // file handle for opened file 
    DWORD               dwDIBSize; 
    DWORD               dwWritten; 
 
    if (!hDib) 
        return ERR_INVALIDHANDLE; 
 
    fh = CreateFile(lpFileName, GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
            FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN, NULL); 
 
    if (fh == INVALID_HANDLE_VALUE) 
        return ERR_OPEN; 
 
    // Get a pointer to the DIB memory, the first of which contains 
    // a BITMAPINFO structure 
 
    lpBI = (LPBITMAPINFOHEADER)GlobalLock(hDib); 
    if (!lpBI) 
    { 
        CloseHandle(fh); 
        return ERR_LOCK; 
    } 
 
    // Check to see if we're dealing with an OS/2 DIB.  If so, don't 
    // save it because our functions aren't written to deal with these 
    // DIBs. 
 
    if (lpBI->biSize != sizeof(BITMAPINFOHEADER)) 
    { 
        GlobalUnlock(hDib); 
        CloseHandle(fh); 
        return ERR_NOT_DIB; 
    } 
 
    // Fill in the fields of the file header 
 
    // Fill in file type (first 2 bytes must be "BM" for a bitmap) 
 
    bmfHdr.bfType = DIB_HEADER_MARKER;  // "BM" 
 
    // Calculating the size of the DIB is a bit tricky (if we want to 
    // do it right).  The easiest way to do this is to call GlobalSize() 
    // on our global handle, but since the size of our global memory may have 
    // been padded a few bytes, we may end up writing out a few too 
    // many bytes to the file (which may cause problems with some apps, 
    // like HC 3.0). 
    // 
    // So, instead let's calculate the size manually. 
    // 
    // To do this, find size of header plus size of color table.  Since the 
    // first DWORD in both BITMAPINFOHEADER and BITMAPCOREHEADER conains 
    // the size of the structure, let's use this. 
 
    // Partial Calculation 
 
    dwDIBSize = *(LPDWORD)lpBI + PaletteSize((LPSTR)lpBI);   
 
    // Now calculate the size of the image 
 
    // It's an RLE bitmap, we can't calculate size, so trust the biSizeImage 
    // field 
 
    if ((lpBI->biCompression == BI_RLE8) || (lpBI->biCompression == BI_RLE4)) 
        dwDIBSize += lpBI->biSizeImage; 
    else 
    { 
        DWORD dwBmBitsSize;  // Size of Bitmap Bits only 
 
        // It's not RLE, so size is Width (DWORD aligned) * Height 
 
        dwBmBitsSize = WIDTHBYTES((lpBI->biWidth)*((DWORD)lpBI->biBitCount)) * 
                lpBI->biHeight; 
 
        dwDIBSize += dwBmBitsSize; 
 
        // Now, since we have calculated the correct size, why don't we 
        // fill in the biSizeImage field (this will fix any .BMP files which  
        // have this field incorrect). 
 
        lpBI->biSizeImage = dwBmBitsSize; 
    } 
 
 
    // Calculate the file size by adding the DIB size to sizeof(BITMAPFILEHEADER) 
                    
    bmfHdr.bfSize = dwDIBSize + sizeof(BITMAPFILEHEADER); 
    bmfHdr.bfReserved1 = 0; 
    bmfHdr.bfReserved2 = 0; 
 
    // Now, calculate the offset the actual bitmap bits will be in 
    // the file -- It's the Bitmap file header plus the DIB header, 
    // plus the size of the color table. 
     
    bmfHdr.bfOffBits = (DWORD)sizeof(BITMAPFILEHEADER) + lpBI->biSize + 
            PaletteSize((LPSTR)lpBI); 
 
    // Write the file header 
 
    WriteFile(fh, (LPSTR)&bmfHdr, sizeof(BITMAPFILEHEADER), &dwWritten, NULL); 
 
    // Write the DIB header and the bits -- use local version of 
    // MyWrite, so we can write more than 32767 bytes of data 
     
    WriteFile(fh, (LPSTR)lpBI, dwDIBSize, &dwWritten, NULL); 
 
    GlobalUnlock(hDib); 
    CloseHandle(fh); 
 
    if (dwWritten == 0) 
        return ERR_OPEN; // oops, something happened in the write 
    else 
        return 0; // Success code 
} 
 
 
/************************************************************************* 
 * 
 * DestroyDIB () 
 * 
 * Purpose:  Frees memory associated with a DIB 
 * 
 * Returns:  Nothing 
 * 
 *************************************************************************/ 
 
WORD DestroyDIB(HDIB hDib) 
{ 
    GlobalFree(hDib); 
    return 0; 
} 

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\callentlst.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// CallEntLst.cpp : implementation file
/////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "CallEntLst.h"
#include "mainfrm.h"
#include "avDialerDoc.h"
#include "util.h"
#include "resource.h"
#include "avtrace.h"
#include "ILSList.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Person Group View
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#define NUM_COLUMNS_CALLENTRYLIST	   2

UINT CCallEntryListCtrl::m_uColumnLabel[NUM_COLUMNS_CALLENTRYLIST]=			//Column headings
{
	IDS_DIRECTORIES_SPEEDDIAL_NAME,
	IDS_DIRECTORIES_SPEEDDIAL_ADDRESS,
};

static int nColumnWidth[NUM_COLUMNS_CALLENTRYLIST]=				   //Column widths
{
	150,
	150
};

enum
{
   CALLENTRYLIST_IMAGE_POTS=0,
   CALLENTRYLIST_IMAGE_INTERNET,
   CALLENTRYLIST_IMAGE_CONFERENCE,
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CCallEntryListCtrl
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNCREATE(CCallEntryListCtrl, CAVListCtrl)

BEGIN_MESSAGE_MAP(CCallEntryListCtrl, CAVListCtrl)
	//{{AFX_MSG_MAP(CCallEntryListCtrl)
	ON_WM_LBUTTONDBLCLK()
	ON_WM_DESTROY()
	ON_COMMAND(ID_BUTTON_MAKECALL, OnButtonMakecall)
	ON_WM_CONTEXTMENU()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
CCallEntryListCtrl::CCallEntryListCtrl()
{
   m_pParentView = NULL;
   m_nNumColumns = 0;
   m_bLargeView = true;
   m_nStyle = (ListStyles_t) -1;
}

/////////////////////////////////////////////////////////////////////////////
CCallEntryListCtrl::~CCallEntryListCtrl()
{
}

/////////////////////////////////////////////////////////////////////////////
void CCallEntryListCtrl::Init(CWnd* pParentView)
{	
	//Set the bitmap for the list 
	if ( pParentView )
	{
		CAVListCtrl::Init(IDB_LIST_DIAL);
		m_pParentView = pParentView;
	}

	SetColumns( STYLE_GROUP );
}

void CCallEntryListCtrl::SaveOrLoadColumnSettings( bool bSave )
{
	// Don't do anything if you are trying to save column settings and you're
	// not using the group style
	if ( bSave && (m_nStyle != STYLE_GROUP) ) return;

	int i = 0;
	CString strSubKey, strTemp;
	strSubKey.LoadString( IDN_REG_SPEEDDIALVIEW );

	LOAD_COLUMN( IDN_REG_HEADING_SD_NAME, 150 );
	LOAD_COLUMN( IDN_REG_HEADING_SD_ADDRESS, 150 );

	// Sort Order
	strTemp.LoadString( IDN_REG_HEADING_SD_SORTORDER );
	if ( bSave ) 
		AfxGetApp()->WriteProfileInt( strSubKey, strTemp, m_SortOrder );
	else
		AfxGetApp()->GetProfileInt( strSubKey, strTemp, m_SortOrder );

	// Sort Column
	strTemp.LoadString( IDN_REG_HEADING_SD_SORTCOLUMN );
	if ( bSave )
		AfxGetApp()->WriteProfileInt( strSubKey, strTemp, m_SortColumn );
	else
		AfxGetApp()->GetProfileInt( strSubKey, strTemp, m_SortColumn );
}


/////////////////////////////////////////////////////////////////////////////
BOOL CCallEntryListCtrl::Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID)
{
	//We want the report style
	dwStyle |= LVS_REPORT | LVS_SINGLESEL;
	BOOL bRet = CAVListCtrl::Create(dwStyle,rect,pParentWnd,nID);

	ListView_SetExtendedListViewStyle(GetSafeHwnd(),LVS_EX_FULLROWSELECT);

	m_imageListLarge.Create( IDB_LIST_MEDIA_LARGE, 24, 0, RGB_TRANS );
	SetImageList( &m_imageListLarge,LVSIL_NORMAL );

	m_imageListSmall.Create( IDB_LIST_MEDIA_SMALL, 16, 0, RGB_TRANS );
	SetImageList( &m_imageListSmall,LVSIL_SMALL );

	ShowLargeView();

	SaveOrLoadColumnSettings( false );

	return bRet;
}


/////////////////////////////////////////////////////////////////////////////
void CCallEntryListCtrl::OnDestroy() 
{
	ClearList();
	CAVListCtrl::OnDestroy();
}

/////////////////////////////////////////////////////////////////////////////
void CCallEntryListCtrl::InsertList(CObList* pCallEntryList,BOOL bForce)
{
	ASSERT(pCallEntryList);

	if ( (bForce == FALSE) && (pCallEntryList == &m_CallEntryList) )
		return;

	//delete the items in the list
	ClearList();

	m_CallEntryList.AddHead( pCallEntryList );

	POSITION pos = m_CallEntryList.GetHeadPosition();
	while ( pos )
	{
		CCallEntryListItem* pItem = new CCallEntryListItem();
		pItem->SetObject( m_CallEntryList.GetNext(pos) );
		CAVListCtrl::InsertItem(pItem,-1,FALSE);              //add to end of list
	}
	CAVListCtrl::SortItems();
}

/////////////////////////////////////////////////////////////////////////////
//clear the objects in the list, but don't delete the list
void CCallEntryListCtrl::ClearList()
{
	//delete the items in the list
	DeleteAllItems();

	//delete old list and objects within
	while ( m_CallEntryList.GetHeadPosition() )
		delete m_CallEntryList.RemoveHead();
}

/////////////////////////////////////////////////////////////////////////////
void CCallEntryListCtrl::OnSetDisplayText(CAVListItem* _pItem,int SubItem,LPTSTR szTextBuf,int nBufSize)
{
	CCallEntry* pCallEntry = (CCallEntry*)(((CCallEntryListItem*)_pItem)->GetObject());
	if (pCallEntry == NULL) return;

	switch ( m_nStyle )
	{
		case STYLE_GROUP:
			switch (SubItem)
			{
				case CALLENTRYLIST_NAME:
					_tcsncpy(szTextBuf,pCallEntry->m_sDisplayName,nBufSize-1);
					szTextBuf[nBufSize-1] = '\0';
					break;

				case CALLENTRYLIST_ADDRESS:
					_tcsncpy(szTextBuf,pCallEntry->m_sAddress,nBufSize-1);
					szTextBuf[nBufSize-1] = '\0';
					break;
			}
			break;

		case STYLE_ITEM:
			// For items, only show address if it is different than the name
			if ( pCallEntry->m_sDisplayName.Compare(pCallEntry->m_sAddress) )
				_sntprintf(szTextBuf, nBufSize, _T("%s\n%s"), pCallEntry->m_sDisplayName, pCallEntry->m_sAddress );
			else
				_tcsncpy(szTextBuf,pCallEntry->m_sDisplayName,nBufSize-1);

			szTextBuf[nBufSize-1] = '\0';
			break;
	}
}  

/////////////////////////////////////////////////////////////////////////////
void CCallEntryListCtrl::OnSetDisplayImage(CAVListItem* _pItem,int& iImage)
{
	iImage = -1;
	CCallEntry* pCallEntry = (CCallEntry*)(((CCallEntryListItem*)_pItem)->GetObject());
	if (pCallEntry)
	{
		switch ( m_nStyle )
		{
			case STYLE_GROUP:
				switch (pCallEntry->m_MediaType)
				{
					case DIALER_MEDIATYPE_POTS:         iImage = CALLENTRYLIST_IMAGE_POTS;          break;
					case DIALER_MEDIATYPE_CONFERENCE:   iImage = CALLENTRYLIST_IMAGE_CONFERENCE;    break;
					case DIALER_MEDIATYPE_INTERNET:     iImage = CALLENTRYLIST_IMAGE_INTERNET;      break;
				}
				break;

			case STYLE_ITEM:
				switch (pCallEntry->m_MediaType)
				{
					case DIALER_MEDIATYPE_POTS:         iImage = PERSONLISTCTRL_IMAGE_PHONECALL;    break;
					case DIALER_MEDIATYPE_CONFERENCE:   iImage = PERSONLISTCTRL_IMAGE_CONFERENCE;    break;
					case DIALER_MEDIATYPE_INTERNET:     iImage = PERSONLISTCTRL_IMAGE_NETCALL;		break;
				}
				break;
		}
	}
}

void CCallEntryListCtrl::DialSelItem()
{
	int nSelItem = GetSelItem();
	if ( nSelItem >= 0 )
	{
		CCallEntryListItem *pItem = (CCallEntryListItem *) GetItem( nSelItem );
		if ( pItem )
		{
			CCallEntry *pEntry = (CCallEntry *) pItem->GetObject();
			if ( pEntry )
			{
				// Send message to window requesting the dial
				CWnd* pWnd  = AfxGetMainWnd();
				if (pWnd)
				{
					CCallEntry *pCallEntry = new CCallEntry;
					if ( pCallEntry )
					{
						*pCallEntry = *pEntry;
						pWnd->PostMessage( WM_ACTIVEDIALER_INTERFACE_MAKECALL,
										   NULL,
										   (LPARAM) pCallEntry );
					}
				}
			}
		}
	}
}


/////////////////////////////////////////////////////////////////////////////
void CCallEntryListCtrl::SetColumns( ListStyles_t nStyle )
{
	if ( nStyle == m_nStyle ) return;

	int i;
	LONG_PTR LPStyle =	GetWindowLongPtr( GetSafeHwnd(), GWL_STYLE );
	DWORD dwStyleEx = 0;

	SaveOrLoadColumnSettings( true );

	m_nStyle = nStyle;
	switch ( m_nStyle )
	{
		// Showing the list of speed dial entries
		case STYLE_GROUP:
			LPStyle |= LVS_REPORT;

			//delete any existing columns
			if ( m_nNumColumns > 0 )
			{
				for ( i = m_nNumColumns - 1; i >= 0; i-- )
					DeleteColumn(i);
			}

			m_nNumColumns = 0;

			//Set the column headings
			SaveOrLoadColumnSettings( false );
			for ( i = 0; i < NUM_COLUMNS_CALLENTRYLIST; i++ )
			{
				CString sLabel;
				sLabel.LoadString( m_uColumnLabel[i] );
				InsertColumn( i, sLabel, LVCFMT_LEFT, nColumnWidth[i] );
				m_nNumColumns++;
			}
			break;

		// Showing an individual item
		case STYLE_ITEM:
			LPStyle &= ~LVS_REPORT;
			dwStyleEx = LVS_EX_TRACKSELECT;
			break;
	}

	SetWindowLongPtr( GetSafeHwnd(), GWL_STYLE, LPStyle );
	ListView_SetExtendedListViewStyle( GetSafeHwnd(), dwStyleEx );
}

/////////////////////////////////////////////////////////////////////////////
void CCallEntryListCtrl::OnLButtonDblClk(UINT nFlags, CPoint point) 
{
	DialSelItem();
}

/////////////////////////////////////////////////////////////////////////////
void CCallEntryListCtrl::OnButtonMakecall() 
{
	DialSelItem();
}


void CCallEntryListCtrl::ShowLargeView()
{
   m_bLargeView = true;

   LONG_PTR LPStyle = ::GetWindowLongPtr(GetSafeHwnd(),GWL_STYLE );
   LPStyle |= LVS_ICON;
   LPStyle |= LVS_ALIGNTOP;
   LPStyle &= ~LVS_ALIGNLEFT;
   LPStyle &= ~LVS_SMALLICON;
   ::SetWindowLongPtr( GetSafeHwnd(), GWL_STYLE, LPStyle );

   ListView_SetIconSpacing( GetSafeHwnd(), LARGE_ICON_X, LARGE_ICON_Y );
}

/////////////////////////////////////////////////////////////////////////////
void CCallEntryListCtrl::ShowSmallView()
{
   m_bLargeView = false;
   
   ULONG_PTR dwStyle = ::GetWindowLongPtr(GetSafeHwnd(),GWL_STYLE );
   dwStyle |= LVS_SMALLICON;
   dwStyle |= LVS_ALIGNLEFT;
   dwStyle &= ~LVS_ALIGNTOP;
   dwStyle &= ~LVS_ICON;
   ::SetWindowLongPtr(GetSafeHwnd(),GWL_STYLE,dwStyle);

   ListView_SetIconSpacing( GetSafeHwnd(), SMALL_ICON_X, SMALL_ICON_Y );
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void CCallEntryListCtrl::OnContextMenu(CWnd* pWnd, CPoint point) 
{
	int nSel = GetSelItem();
	if ( nSel >= 0 )
	{
		CCallEntry *pEntry = (CCallEntry *) GetItem( nSel );
		if ( pEntry )
		{
            CMenu menu;
            menu.LoadMenu( IDR_CONTEXT_SPEEDDIAL );

            CMenu *pContextMenu = menu.GetSubMenu(0);
            if ( pContextMenu )
            {
               pContextMenu->TrackPopupMenu( TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
											 point.x, point.y, GetParent() );
            }
		}
	}
}

void CCallEntryListCtrl::OnPaint() 
{
	if ( !GetItemCount() )
	{
		CPaintDC dc(this); // device context for painting

		// Figure out where we're going to write the text
		POINT pt;
		ListView_GetItemPosition( m_hWnd, 0, &pt );
		RECT rc;
		GetClientRect(&rc);
		rc.top = pt.y + 4;

		// Give a little bit more of a margin if we can
		if ( (rc.right - rc.left) > 7 )
		{
			rc.left += 3;
			rc.right -= 3;
		}

		POINT ptUL = { rc.left + 1, rc.top + 1};
		POINT ptLR = { rc.right - 1, rc.bottom - 1};

		if ( IsRectEmpty(&dc.m_ps.rcPaint) || (PtInRect(&dc.m_ps.rcPaint, ptUL) && PtInRect(&dc.m_ps.rcPaint, ptLR)) )
		{
			CString strText;
			strText.LoadString( IDS_SPEEDDIAL_LIST_EMPTY );

			HFONT fontOld = (HFONT) dc.SelectObject( GetFont() );
			int nModeOld = dc.SetBkMode( TRANSPARENT );
			COLORREF crTextOld = dc.SetTextColor( GetSysColor(COLOR_BTNTEXT) );
			dc.DrawText( strText, &rc, DT_CENTER | DT_WORDBREAK | DT_NOPREFIX | DT_EDITCONTROL );
			dc.SetTextColor( crTextOld );
			dc.SetBkMode( nModeOld );

			dc.SelectObject( fontOld );
			ValidateRect( &rc );
		}
		else
		{
			// Make sure entire row is invalidated so we can properly draw the text
			InvalidateRect( &rc );
		}
	}
	else
	{
		DefWindowProc(WM_PAINT, 0, 0);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\bmputil.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

#ifndef _BMPUTIL_H_
#define _BMPUTIL_H_

//  Header file for Device-Independent Bitmap (DIB) API.  Provides 
//  function prototypes and constants for the following functions: 

//  GetDisabledBitmap()  - Disables Bitmap

//  BitmapToDIB()        - Creates a DIB from a bitmap 
//  CopyScreenToBitmap() - Copies entire screen to a standard Bitmap 
//  CopyScreenToDIB()    - Copies entire screen to a DIB 
//  CopyWindowToDIB()    - Copies a window to a DIB 
//  DestroyDIB()         - Deletes DIB when finished using it 
//  GetSystemPalette()   - Gets the current palette 
//  PalEntriesOnDevice() - Gets the number of palette entries 
//  SaveDIB()            - Saves the specified dib in a file 
//  PaletteSize()        - Calculates the buffer size required by a palette 
//  DIBNumColors()       - Calculates number of colors in the DIB's color table 
 
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
 
/* Handle to a DIB */ 
#define HDIB HANDLE 

/* DIB constants */ 
#define PALVERSION   0x300 
 
/* Print Area selection */ 
#define PW_WINDOW        1 
#define PW_CLIENT        2 
 
/* DIB Macros*/ 
 
// WIDTHBYTES performs DWORD-aligning of DIB scanlines.  The "bits" 
// parameter is the bit count for the scanline (biWidth * biBitCount), 
// and this macro returns the number of DWORD-aligned bytes needed  
// to hold those bits. 
 
#define WIDTHBYTES(bits)    (((bits) + 31) / 32 * 4) 
 
/* Error constants */ 
enum { 
      ERR_MIN = 0,                     // All error #s >= this value 
      ERR_NOT_DIB = 0,                 // Tried to load a file, NOT a DIB! 
      ERR_MEMORY,                      // Not enough memory! 
      ERR_READ,                        // Error reading file! 
      ERR_LOCK,                        // Error on a GlobalLock()! 
      ERR_OPEN,                        // Error opening a file! 
      ERR_CREATEPAL,                   // Error creating palette. 
      ERR_GETDC,                       // Couldn't get a DC. 
      ERR_CREATEDDB,                   // Error create a DDB. 
      ERR_STRETCHBLT,                  // StretchBlt() returned failure. 
      ERR_STRETCHDIBITS,               // StretchDIBits() returned failure. 
      ERR_SETDIBITSTODEVICE,           // SetDIBitsToDevice() failed. 
      ERR_STARTDOC,                    // Error calling StartDoc(). 
      ERR_NOGDIMODULE,                 // Couldn't find GDI module in memory. 
      ERR_SETABORTPROC,                // Error calling SetAbortProc(). 
      ERR_STARTPAGE,                   // Error calling StartPage(). 
      ERR_NEWFRAME,                    // Error calling NEWFRAME escape. 
      ERR_ENDPAGE,                     // Error calling EndPage(). 
      ERR_ENDDOC,                      // Error calling EndDoc(). 
      ERR_SETDIBITS,                   // Error calling SetDIBits(). 
      ERR_FILENOTFOUND,                // Error opening file in GetDib() 
      ERR_INVALIDHANDLE,               // Invalid Handle 
      ERR_DIBFUNCTION,                 // Error on call to DIB function 
      ERR_MAX                          // All error #s < this value 
     }; 

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Prototypes
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
 
HDIB        BitmapToDIB (HBITMAP hBitmap, HPALETTE hPal); 
HBITMAP     CopyScreenToBitmap (LPRECT); 
HDIB        CopyScreenToDIB (LPRECT); 
HDIB        CopyWindowToDIB (HWND, WORD); 
WORD        DestroyDIB (HDIB); 
HPALETTE    GetSystemPalette (void); 
WORD         PalEntriesOnDevice (HDC hDC); 
WORD        SaveDIB (HDIB, LPCTSTR); 
WORD        PaletteSize (LPSTR lpDIB); 
WORD        DIBNumColors (LPSTR lpDIB); 
HBITMAP     GetDisabledBitmap(HBITMAP hOrgBitmap,
                          COLORREF crTransparent,
                          COLORREF crBackGroundOut);

#endif  // _BMPUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\callmgr.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// callmgr.h : header file
//

#ifndef _CALLMGR_H_
#define _CALLMGR_H_

#include "tapidialer.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//class CActiveCallManager 
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CActiveAgent;
class CActiveChatManager;
class CActiveDialerDoc;
class CCallControlWnd;

class CActiveCallManager : public CObject
{
   DECLARE_SERIAL(CActiveCallManager)

public:
//Construction
    CActiveCallManager();
   ~CActiveCallManager();

//Attributes
public:
   CActiveDialerDoc*      m_pDialerDoc;
protected:
   //Serialize attributes

   //Non-serialized attributes
   CRITICAL_SECTION        m_csDataLock;              //Sync on data
   CMapWordToPtr           m_mapCallIdToWnd;
   UINT                    m_uNextId;

public:   

//Operations
protected:
   BOOL                    LookUpCall(WORD nCallId,CCallControlWnd*& pCallWnd);
   BOOL                    CanStopSound(WORD nCallId);

public:
   virtual void            Serialize(CArchive& ar);

   BOOL                    Init(CActiveDialerDoc* pDialerDoc);
   void                    GetTextFromAction(CallManagerActions cma,CString& sActionText);
   void                    GetTextFromState(CallManagerStates cms,CString& sStateText);
   void                    ClearCallControlMap();
   void                    InitIncomingCall(CCallControlWnd* pCallWnd,WORD nCallId,CallManagerMedia cmm);

   //For CallControlWindow
   void                    ActionSelected(WORD nCallId,CallManagerActions cma);
   BOOL                    ShowMedia(WORD nCallId,HWND hwndParent,BOOL bVisible);
   void                    UnhideCallControlWindows();
   void                    HideCallControlWindows();
   void                    SetCallControlWindowsAlwaysOnTop(bool bAlwaysOnTop);
   BOOL                    IsCallControlWindowsAlwaysOnTop();
   void                    SetPreviewWindow(WORD nCallId);
   BOOL                    GetCallCaps(WORD nCallId,DWORD& dwCaps);
   //For CallControlWindow

   //ICallManager C Interface for Media Objects
   BOOL                    IsCallIdValid(WORD nCallId);
   UINT                    NewIncomingCall(CallManagerMedia cmm);
   BOOL                    SetCallerId(WORD nCallId,LPCTSTR szCallerId);
   BOOL                    ClearCurrentActions(WORD nCallId);
   BOOL                    AddCurrentActions(WORD nCallId,CallManagerActions cma,LPCTSTR szActionText=NULL);
   BOOL                    SetCallState(WORD nCallId,CallManagerStates cms,LPCTSTR szStateText=NULL);
   BOOL                    GetCallState(WORD nCallId,CallManagerStates& cms);
   BOOL                    CloseCallControl(WORD nCallId);
   void                    ActionRequested(CallClientActions cca);
   void                    ErrorNotify(LPCTSTR szOperation,LPCTSTR szDetails,long lErrorCode);
   void                    LogCall(CallLogType nType,LPCTSTR szDetails,LPCTSTR szAddress,COleDateTime& starttime,DWORD dwDuration);
   BOOL                    IsReminderSet(LPCTSTR szServer,LPCTSTR szConferenceName);
   void                    DSClearUserList();
   void                    DSAddUser(LPCTSTR szName,LPCTSTR szAddress,LPCTSTR szPhoneNumber);
   BOOL                    ResolveAddress(LPCTSTR szAddress,CString& sName,CString& sUser1,CString& sUser2);
   BOOL                    ResolveAddressEx(LPCTSTR szAddress,long lAddressType,DialerMediaType dmtMediaType,DialerLocationType dltLocationType,CString& sName,CString& sRetAddress,CString& sUser1,CString& sUser2);
   //ICallManager C Interface for Media Objects
};



#endif //_CALLMGR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\callmgr.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// callmgr.cpp : implementation file
//  
#include "stdafx.h"
#include "callmgr.h"
#include "callctrlwnd.h"
#include "avdialerdoc.h"
#include "avdialervw.h"
#include "resolver.h"
#include "ds.h"
#include "util.h"
#include "sound.h"
#include "resource.h"

#ifdef _DEBUG
#undef THIS_FILE
static char BASED_CODE THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_SERIAL(CActiveCallManager,CObject,1)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#define CALLMANAGER_LOOKUPCALL_MAXRETRY            8
#define CALLMANAGER_LOOKUPCALL_RETRYINTERVAL       250


#define ActionStringResourceCount 14

const UINT ActionStringResourceArray[ActionStringResourceCount] =
{
   IDS_CALLCONTROL_ACTIONS_TAKECALL,                        //CM_ACTIONS_TAKECALL
   IDS_CALLCONTROL_ACTIONS_TAKEMESSAGE,                     //CM_ACTIONS_TAKEMESSAGE
   IDS_CALLCONTROL_ACTIONS_REQUESTHOLD,                     //CM_ACTIONS_REQUESTHOLD
   IDS_CALLCONTROL_ACTIONS_HOLD,                            //CM_ACTIONS_HOLD
   IDS_CALLCONTROL_ACTIONS_TRANSFER,                        //CM_ACTIONS_TRANSFER
   IDS_CALLCONTROL_ACTIONS_WHOISIT,                         //CM_ACTIONS_WHOISIT
   IDS_CALLCONTROL_ACTIONS_CALLBACK,                        //CM_ACTIONS_CALLBACK
   IDS_CALLCONTROL_ACTIONS_MONITOR,                         //CM_ACTIONS_MONITOR
   IDS_CALLCONTROL_ACTIONS_DISCONNECT,                      //CM_ACTIONS_DISCONNECT
   IDS_CALLCONTROL_ACTIONS_CLOSE,                           //CM_ACTIONS_CLOSE
   IDS_CALLCONTROL_ACTIONS_LEAVEDESKTOPPAGE,                //CM_ACTIONS_LEAVEDESKTOPPAGE
   IDS_CALLCONTROL_ACTIONS_LEAVEEMAIL,                      //CM_ACTIONS_LEAVEEMAIL
   IDS_CALLCONTROL_ACTIONS_ENTERCONFROOM,                   //CM_ACTIONS_ENTERCONFROOM
   IDS_CALLCONTROL_ACTIONS_REJECTCALL,                      //Not defined yet
};

#define StateStringResourceCount 11

const UINT StateStringResourceArray[StateStringResourceCount] =
{
   IDS_CALLCONTROL_STATE_UNKNOWN,                           //CM_STATES_UNKNOWN
   IDS_CALLCONTROL_STATE_RINGING,                           //CM_STATES_RINGING
   IDS_CALLCONTROL_STATE_HOLDING,                           //CM_STATES_HOLDING
   IDS_CALLCONTROL_STATE_REQUESTHOLD,                       //CM_STATES_REQUESTHOLD
   IDS_CALLCONTROL_STATE_BUSY,                              //CM_STATES_BUSY
   IDS_CALLCONTROL_STATE_TRANSFERRING,                      //CM_STATES_TRANSFERRING
   IDS_CALLCONTROL_STATE_LEAVINGMESSAGE,                    //CM_STATES_LEAVINGMESSAGE
   IDS_CALLCONTROL_STATE_DISCONNECTED,                      //CM_STATES_DISCONNECTED
   IDS_CALLCONTROL_STATE_CONNECTED,                         //CM_STATES_CONNECTED
   IDS_CALLCONTROL_STATE_UNAVAILABLE,                       //CM_STATES_UNAVAILABLE
   IDS_CALLCONTROL_STATE_CONNECTING,
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CActiveCallManager
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
CActiveCallManager::CActiveCallManager()
{
   m_uNextId = 1;
   m_pDialerDoc = NULL;
   InitializeCriticalSection(&m_csDataLock);
}

/////////////////////////////////////////////////////////////////////////////
CActiveCallManager::~CActiveCallManager()
{
   DeleteCriticalSection(&m_csDataLock);
}

/////////////////////////////////////////////////////////////////////////////
void CActiveCallManager::Serialize(CArchive& ar)
{
   CObject::Serialize(ar);    //Always call base class Serialize
   //Serialize members
   if (ar.IsStoring())
   {
   }
   else
   {
   } 
}  

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveCallManager::Init(CActiveDialerDoc* pDialerDoc)
{
   m_pDialerDoc = pDialerDoc;

   //make sure our sounds are in the registry.  The setup will normally do this, but 
   //we will do it here just to force it
   m_pDialerDoc->SetRegistrySoundEvents();

   return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveCallManager::IsCallIdValid(WORD nCallId)
{
   BOOL bRet = FALSE;
   CCallControlWnd* pCallWnd = NULL;

   EnterCriticalSection(&m_csDataLock);
   bRet = m_mapCallIdToWnd.Lookup(nCallId,(void*&)pCallWnd);
   LeaveCriticalSection(&m_csDataLock);

   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
void CActiveCallManager::ClearCallControlMap()
{
   EnterCriticalSection(&m_csDataLock);
   m_mapCallIdToWnd.RemoveAll();
   LeaveCriticalSection(&m_csDataLock);
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveCallManager::LookUpCall(WORD nCallId,CCallControlWnd*& pCallWnd)
{
   BOOL bRet = FALSE;
   int nRetry = 0;

   while ( (bRet == FALSE) && (nRetry < CALLMANAGER_LOOKUPCALL_MAXRETRY) )
   {
      EnterCriticalSection(&m_csDataLock);
   
      bRet = m_mapCallIdToWnd.Lookup(nCallId,(void*&)pCallWnd);

      LeaveCriticalSection(&m_csDataLock);

      if (bRet == FALSE)
      {
         Sleep(CALLMANAGER_LOOKUPCALL_RETRYINTERVAL);
         nRetry++;
      }
   }
   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
//All new call's from the call objects are registered here first
//This is where we hand out the CallId Numbers
//We must try to not do any UI type stuff here.  This could cause deadlock and
//UI creation creation problems since we are not guaranteed the thread we
//are being call on.  The actual call get's initialized in InitIncomingCall().
//This call is reserved for the creator of the call UI 
UINT CActiveCallManager::NewIncomingCall(CallManagerMedia cmm)
{
   ASSERT(m_pDialerDoc);

   WORD nCallId = 0;

   EnterCriticalSection(&m_csDataLock);
   WORD nNextId = (WORD) m_uNextId++;
   LeaveCriticalSection(&m_csDataLock);

   //this call should always return without doing any UI creation
    switch ( cmm )
    {
        case CM_MEDIA_INTERNETDATA:
            nCallId = nNextId;
            break;
        
        default:
           if (m_pDialerDoc->CreateCallControl(nNextId,cmm))
                   nCallId = nNextId;
            break;
    }

   //there is a spot here when the caller will expect to be able to use nNextId and 
   //the control still has not been created.  Should we sleep here for a sec just to make 
   //sure we have UI?  The object is going to call back and we are going to do a LookUpCall()
   //and this method actually has retry logic if a window is not available yet.

   return nCallId;

   /*
   UINT uRet = 0;

   CWnd* pWnd = m_pDialerDoc->CreateCallControl(nNextId,cmm);
   if (pWnd)
   {
      ASSERT(pWnd->IsKindOf(RUNTIME_CLASS(CCallControlWnd)));
      CCallControlWnd* pCallWnd = (CCallControlWnd*)pWnd;

      EnterCriticalSection(&m_csDataLock);
      m_mapCallIdToWnd.SetAt(nNextId,pWnd);
      LeaveCriticalSection(&m_csDataLock);

      uRet = nNextId;

      pCallWnd->SetCallManager(this,nNextId);
      pCallWnd->SetMediaType(cmm);
      m_pDialerDoc->UnhideCallControlWindows();
   }
   return uRet;
*/
}

/////////////////////////////////////////////////////////////////////////////
//Reserved for UI thread to initialize the incoming call that was created.
//This method will be called as a result of NewIncomingCall.
void CActiveCallManager::InitIncomingCall(CCallControlWnd* pCallWnd,WORD nCallId,CallManagerMedia cmm)
{
   //add the call to the map 
   EnterCriticalSection(&m_csDataLock);
   m_mapCallIdToWnd.SetAt(nCallId,pCallWnd);
   LeaveCriticalSection(&m_csDataLock);

   pCallWnd->SetCallManager(this,nCallId);
   pCallWnd->SetMediaType(cmm);
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveCallManager::SetCallerId(WORD nCallId,LPCTSTR szCallerId)
{
   BOOL bRet = FALSE;
   CCallControlWnd* pCallWnd = NULL;

   if (bRet = LookUpCall(nCallId,pCallWnd))
   {
      pCallWnd->SetCallerId(szCallerId);
   }

   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveCallManager::ClearCurrentActions(WORD nCallId)
{
   BOOL bRet = FALSE;
   CCallControlWnd* pCallWnd = NULL;
   
   if (bRet = LookUpCall(nCallId,pCallWnd))
   {
      pCallWnd->ClearCurrentActions();
   }
   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveCallManager::AddCurrentActions(WORD nCallId,CallManagerActions cma,LPCTSTR szActionText)
{
   BOOL bRet = FALSE;
   CCallControlWnd* pCallWnd = NULL;
   
   if (bRet = LookUpCall(nCallId,pCallWnd))
   {
      if ( (szActionText == NULL) || (_tcscmp(szActionText,_T("")) == 0) )
      {
         CString sActionText;
         GetTextFromAction(cma,sActionText);            
         pCallWnd->AddCurrentActions(cma,sActionText);
      }
      else
      {
         pCallWnd->AddCurrentActions(cma,szActionText);
      }
   }
   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
void CActiveCallManager::GetTextFromAction(CallManagerActions cma,CString& sActionText)
{
   //first check the boundaries
   if ( (cma >= 0) && (cma < ActionStringResourceCount) )
   {
      UINT uID = ActionStringResourceArray[cma];   
      sActionText.LoadString(uID);
   }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveCallManager::SetCallState(WORD nCallId,CallManagerStates cms,LPCTSTR szStateText)
{
   BOOL bRet = FALSE;
   CCallControlWnd* pCallWnd = NULL;

   if (bRet = LookUpCall(nCallId,pCallWnd))
   {
      if ( (szStateText == NULL) || (_tcscmp(szStateText,_T("")) == 0) )
      {
         CString sStateText;
         GetTextFromState(cms,sStateText);            
         pCallWnd->SetCallState(cms,sStateText);
      }
      else
      {
         pCallWnd->SetCallState(cms,szStateText);
      }
   }
   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveCallManager::GetCallState(WORD nCallId,CallManagerStates& cms)
{
   BOOL bRet = FALSE;
   CCallControlWnd* pCallWnd = NULL;
   
   if (bRet = LookUpCall(nCallId,pCallWnd))
   {
      cms = pCallWnd->GetCallState();
   }
   else
   {
      cms = CM_STATES_UNKNOWN;
   }
   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
void CActiveCallManager::GetTextFromState(CallManagerStates cms,CString& sStateText)
{
   //first check the boundaries
   if ( (cms >= 0) && (cms < StateStringResourceCount) )
   {
      UINT uID = StateStringResourceArray[cms];   
      sStateText.LoadString(uID);
   }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveCallManager::CloseCallControl(WORD nCallId)
{
   //clear any current sounds
    if( CanStopSound(nCallId) )
    {
        ActiveClearSound();
    }

   BOOL bRet = FALSE;
   CCallControlWnd* pCallWnd = NULL;
   
   if (bRet = LookUpCall(nCallId,pCallWnd))
   {
      EnterCriticalSection(&m_csDataLock);
      //remove from our list
      m_mapCallIdToWnd.RemoveKey(nCallId);
      LeaveCriticalSection(&m_csDataLock);

      //tell agent to close the window
      m_pDialerDoc->DestroyActiveCallControl(pCallWnd);
   }
   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
void CActiveCallManager::ActionRequested(CallClientActions cca)
{
   try
   {
      m_pDialerDoc->ActionRequested(cca);         
   }
   catch (...) {}
}

/////////////////////////////////////////////////////////////////////////////
void CActiveCallManager::ErrorNotify(LPCTSTR szOperation,LPCTSTR szDetails,long lErrorCode)
{
   try
   {
      m_pDialerDoc->ErrorNotify(szOperation,szDetails,lErrorCode,ERROR_NOTIFY_LEVEL_INTERNAL);
   }
   catch (...) {}
}

/////////////////////////////////////////////////////////////////////////////
void CActiveCallManager::LogCall(CallLogType nType,LPCTSTR szDetails,LPCTSTR szAddress,COleDateTime& starttime,DWORD dwDuration)
{
   try
   {
      LogCallType lct = LOGCALLTYPE_INCOMING;
      switch (nType)
      {
         case CL_CALL_INCOMING:     lct = LOGCALLTYPE_INCOMING;      break;
         case CL_CALL_OUTGOING:     lct = LOGCALLTYPE_OUTGOING;      break;
         case CL_CALL_CONFERENCE:
         {
            lct = LOGCALLTYPE_CONFERENCE; 

            //we do not control creation of conferences, so we use the conference log message
            //as a way to enter the conference to the redial list
            CCallEntry callentry;

            callentry.m_sDisplayName = szAddress;
            callentry.m_sAddress = szAddress;
            callentry.m_lAddressType = LINEADDRESSTYPE_SDP;
            callentry.m_MediaType = DIALER_MEDIATYPE_CONFERENCE;
            CDialerRegistry::AddCallEntry(TRUE,callentry);
            break;
         }

      }

      m_pDialerDoc->LogCallLog(lct,starttime,dwDuration,szDetails,szAddress);

      //tell window manager to check call states
      m_pDialerDoc->CheckCallControlStates();
   }
   catch (...) {}
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveCallManager::IsReminderSet(LPCTSTR szServer,LPCTSTR szConferenceName)
{
   //check if reminder entry already exists
   CReminder reminder;
   reminder.m_sServer = szServer;
   reminder.m_sConferenceName = szConferenceName;
   int nFindIndex = CDialerRegistry::IsReminderSet(reminder);
   return (nFindIndex != -1)?TRUE:FALSE;
}

/////////////////////////////////////////////////////////////////////////////
void CActiveCallManager::DSClearUserList()
{
   //get the current view and PostMessage
   CWnd* pView = m_pDialerDoc->GetCurrentView();
   if (pView)
   {
      pView->PostMessage(WM_DSCLEARUSERLIST);

      //The resolve user object needs to know about this clearing
      CResolveUser* pResolveUser = m_pDialerDoc->GetResolveUserObject();
      ASSERT(pResolveUser);
      pResolveUser->ClearUsersDS();
   }
}

/////////////////////////////////////////////////////////////////////////////
void CActiveCallManager::DSAddUser(LPCTSTR szName,LPCTSTR szAddress,LPCTSTR szPhoneNumber)
{
   //get the current view and PostMessage
   CWnd* pView = m_pDialerDoc->GetCurrentView();
   if (pView)
   {
      //receiver will delete dsuser object
      CDSUser* pDSUser = new CDSUser;

      //
      // Validate the allocation
      //

      if( IsBadWritePtr( pDSUser, sizeof(CDSUser)) )
      {
          return;
      }

      pDSUser->m_sUserName = szName;
      pDSUser->m_sIPAddress = szAddress;
      pDSUser->m_sPhoneNumber = szPhoneNumber;
      pView->PostMessage(WM_DSADDUSER,0,(LPARAM)pDSUser);

      //create another user and add resolve user object

      //
      // pDSUser is allocated dynamic and passed like lParam to
      // a PostMessage() method. This method is handled by 
      // CExplorerWnd::DSAddUser() but this method do nothing
      // Next we should pass the pDSUser to CResolveUser without
      // allocate a new memory
      // This memory will be deallcoated by CResolveUser destructor
      // 
      //CDSUser* pNewDSUser = new CDSUser; 
      //*pNewDSUser = pDSUser;

      CResolveUser* pResolveUser = m_pDialerDoc->GetResolveUserObject();
      ASSERT(pResolveUser);
      pResolveUser->AddUser(pDSUser);
   }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveCallManager::ResolveAddress(LPCTSTR szAddress,CString& sName,CString& sUser1,CString& sUser2)
{
   CResolveUser* pResolveUser = m_pDialerDoc->GetResolveUserObject();
   ASSERT(pResolveUser);
   return pResolveUser->ResolveAddress(szAddress,sName,sUser1,sUser2);
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveCallManager::ResolveAddressEx(LPCTSTR szAddress,long lAddressType,DialerMediaType dmtMediaType,DialerLocationType dltLocationType,CString& sName,CString& sRetAddress,CString& sUser1,CString& sUser2)
{
   CResolveUser* pResolveUser = m_pDialerDoc->GetResolveUserObject();
   ASSERT(pResolveUser);
   return pResolveUser->ResolveAddressEx(szAddress,lAddressType,dmtMediaType,dltLocationType,sName,sRetAddress,sUser1,sUser2);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//For CallControlWnd
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CActiveCallManager::ActionSelected(WORD nCallId,CallManagerActions cma)
{
   //just route to all call objects and they will figure out nCallId
   m_pDialerDoc->ActionSelected(nCallId,cma);   
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveCallManager::GetCallCaps(WORD nCallId,DWORD& dwCaps)
{
   //just route to all call objects and they will figure out nCallId
   return m_pDialerDoc->GetCallCaps(nCallId,dwCaps);   
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveCallManager::ShowMedia(WORD nCallId,HWND hwndParent,BOOL bVisible)
{
   //just route to all call objects and they will figure out nCallId
   return m_pDialerDoc->ShowMedia(nCallId,hwndParent,bVisible);   
}

/////////////////////////////////////////////////////////////////////////////
void CActiveCallManager::SetPreviewWindow(WORD nCallId)
{
   if (m_pDialerDoc) m_pDialerDoc->SetPreviewWindow(nCallId, true);
}

/////////////////////////////////////////////////////////////////////////////
void CActiveCallManager::UnhideCallControlWindows()
{
   if (m_pDialerDoc) m_pDialerDoc->UnhideCallControlWindows();   
}

/////////////////////////////////////////////////////////////////////////////
void CActiveCallManager::HideCallControlWindows()
{
   if (m_pDialerDoc) m_pDialerDoc->HideCallControlWindows();   
}

/////////////////////////////////////////////////////////////////////////////
void CActiveCallManager::SetCallControlWindowsAlwaysOnTop(bool bAlwaysOnTop)
{
   if (m_pDialerDoc) m_pDialerDoc->SetCallControlWindowsAlwaysOnTop( bAlwaysOnTop );
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveCallManager::IsCallControlWindowsAlwaysOnTop()
{
   if (m_pDialerDoc) 
      return m_pDialerDoc->IsCallControlWindowsAlwaysOnTop();   
   else
      return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CActiveCallManager::CanStopSound(WORD nCallId)
{
    // Try to find out if exist another call in
    // OFFERING state. If exist this call
    // then don't stop the dinging

    BOOL bStopSound = TRUE;
    int nItemFind = 0;
    WORD nMapCallId = 1;
    EnterCriticalSection(&m_csDataLock);
    while(nItemFind < m_mapCallIdToWnd.GetCount())
    {
        //
        // Try to find out valid callids
        // Get the call window
        //

        CCallControlWnd* pWnd = NULL;   
        m_mapCallIdToWnd.Lookup(nMapCallId,(void*&)pWnd);
        if( pWnd )
        {
            //
            // Increment the found items count
            //
            nItemFind++;

            //
            // Get the call state from the call window
            //
            CallManagerStates callState;
            callState = pWnd->GetCallState();

            //
            // Offering call
            //
            if( callState == CM_STATES_OFFERING )
            {
                //
                // It is another call?
                //
                if( nCallId != nMapCallId)
                {
                    bStopSound = FALSE;
                    break;
                }
            }            
        }

        //
        // Try next callid
        //
        nMapCallId++;

        if( nMapCallId == 1000)
        {
            //
            // It's really enought
            //
            break;
        }
    }

    LeaveCriticalSection(&m_csDataLock);
    return bStopSound;
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\callwnd.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented G
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// CallWnd.cpp : implementation file
/////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "avdialer.h"
#include "util.h"
#include "CallWnd.h"
#include "avDialerDoc.h"
#include "sound.h"
#include "avtrace.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

enum
{
   CALLCONTROL_STATES_TOOLBAR_IMAGE_ALWAYSONTOP_ON=0,
   CALLCONTROL_STATES_TOOLBAR_IMAGE_SLIDE_LEFT,
   CALLCONTROL_STATES_TOOLBAR_IMAGE_ALWAYSONTOP_OFF,
   CALLCONTROL_STATES_TOOLBAR_IMAGE_SLIDE_RIGHT,
};

typedef struct tagCurrentAction
{
   CString              sText;
   CallManagerActions   cma;
}CurrentAction;


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CCallWnd dialog
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_DYNAMIC(CCallWnd, CDialog)

/////////////////////////////////////////////////////////////////////////////
CCallWnd::CCallWnd(CWnd* pParent /*=NULL*/)
{
   m_nNumToolbarItems = 5;
   m_bIsPreview = false;
   m_bAutoDelete = false;

   m_nCallId = 0;

   m_hwndStatesToolbar = NULL;
   m_hCursor = NULL;
   m_hOldCursor = NULL;
   m_bWindowMoving = FALSE;
   m_bPaintVideoPlaceholder = TRUE;
   m_bAllowDrag = TRUE;

   //#APPBAR
   m_bMovingSliders = FALSE;
   //#APPBAR

   m_hwndCurrentVideoWindow = NULL;

   m_pDialerDoc = NULL;
   m_wndFloater.Init( this );

   m_pAVTapi2 = NULL;
}

/////////////////////////////////////////////////////////////////////////////
void CCallWnd::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CCallWnd)
    //}}AFX_DATA_MAP
}

/////////////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CCallWnd, CDialog)
    //{{AFX_MSG_MAP(CCallWnd)
    ON_WM_LBUTTONDOWN()
    ON_WM_LBUTTONUP()
    ON_WM_MOUSEMOVE()
    ON_WM_SETCURSOR()
    ON_WM_PARENTNOTIFY()
    ON_COMMAND(ID_CALLWINDOW_ALWAYSONTOP,OnAlwaysOnTop)
    ON_COMMAND(ID_CALLWINDOW_HIDE,OnHideCallControlWindows)
    ON_WM_DESTROY()
    ON_WM_SHOWWINDOW()
    ON_WM_NCACTIVATE()
    ON_WM_CONTEXTMENU()
    ON_COMMAND(ID_CALLWINDOW_SLIDESIDE_LEFT,OnSlideSideLeft)
    ON_COMMAND(ID_CALLWINDOW_SLIDESIDE_RIGHT,OnSlideSideRight)
    ON_WM_SYSCOMMAND()
    //}}AFX_MSG_MAP
    ON_COMMAND_RANGE(CM_ACTIONS_TAKECALL+1000,CM_ACTIONS_REJECTCALL+1000,OnVertBarAction)
    ON_MESSAGE(WM_SLIDEWINDOW_CLEARCURRENTACTIONS,OnClearCurrentActions)
    ON_MESSAGE(WM_SLIDEWINDOW_ADDCURRENTACTIONS,OnAddCurrentActions)
    ON_MESSAGE(WM_SLIDEWINDOW_SHOWSTATESTOOLBAR,OnShowStatesToolbar)
    ON_MESSAGE(WM_SLIDEWINDOW_UPDATESTATESTOOLBAR, OnUpdateStatesToolbar)
    ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTW, 0, 0xFFFF, OnTabToolTip)
    ON_NOTIFY_EX_RANGE(TTN_NEEDTEXTA, 0, 0xFFFF, OnTabToolTip)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
BOOL CCallWnd::OnInitDialog() 
{
    CDialog::OnInitDialog();
    
   //set the current video window
   m_hwndCurrentVideoWindow = m_wndVideo.GetSafeHwnd();

   //create the bold DEFAULT_GUI_FONT
   CGdiObject obj;
   LOGFONT lfFont;

   //
   // We have to initialize the lfFont
   //
   memset( &lfFont, 0, sizeof(LOGFONT));

   obj.CreateStockObject(DEFAULT_GUI_FONT);
   obj.GetObject(sizeof(LOGFONT),&lfFont);
   lfFont.lfWeight = FW_BOLD;                       //get DEFAULT_GUI_FONT with bold weight
   if (m_fontTextBold.CreateFontIndirect(&lfFont) == FALSE)
   {
      //failure to get bold system font, just try the normal font then
      obj.GetObject(sizeof(LOGFONT),&lfFont);
      m_fontTextBold.CreateFontIndirect(&lfFont);
   }

   //create the drag cursor
   m_hCursor = ::LoadCursor(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDC_CALLCONTROL_VIDEO_GRABBER));

   //create the vertical toolbar
   CreateVertBar();

//   CWnd* pStaticWnd = GetDlgItem(IDC_CALLCONTROL_STATIC_VIDEO);
//   pStaticWnd->ShowWindow(SW_HIDE);

   //Do Palette realization on 256 color bitmap.  
   m_dibVideoImage.Load(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDB_VIDEO_SCREEN1));
   m_palMsgHandler.Install(this, m_dibVideoImage.GetPalette());
    
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
void CCallWnd::OnDestroy() 
{
   //Unhook msg handler
   if ( m_palMsgHandler.IsHooked() ) 
      m_palMsgHandler.HookWindow(NULL);

    CDialog::OnDestroy();

   // clean up the cursor    
   if (m_hCursor) 
   {
      ::DeleteObject(m_hCursor);
      m_hCursor = NULL;
   }

   //
   // Delete the reference to IAVTapi2 interface
   //

   if( m_pAVTapi2 )
   {
       m_pAVTapi2->Release();
       m_pAVTapi2 = NULL;
   }
}

/////////////////////////////////////////////////////////////////////////////
void CCallWnd::OnOK() 
{
   return;
}

/////////////////////////////////////////////////////////////////////////////
void CCallWnd::OnCancel() 
{
   return;
}

/////////////////////////////////////////////////////////////////////////////
void CCallWnd::OnLButtonDown(UINT nFlags, CPoint point) 
{
   CheckLButtonDown(point);

   //#APPBAR
   //check if mouse over
   if (IsMouseOverForDragDropOfSliders(point))
   {
      m_bMovingSliders = TRUE;
      SetCapture();
   }
   //#APPBAR
}


/////////////////////////////////////////////////////////////////////////////
void CCallWnd::OnParentNotify(UINT message, LPARAM lParam)
{
   WORD wEvent = LOWORD(message);

   if (wEvent == WM_LBUTTONDOWN)
   {
      CPoint point;
      point.x = LOWORD(lParam);
      point.y = HIWORD(lParam);
      CheckLButtonDown(point);
   }
}

/////////////////////////////////////////////////////////////////////////////
void CCallWnd::CheckLButtonDown(CPoint& point)
{
   //check if we are already showing a floating window
   if ( m_wndFloater.GetSafeHwnd() ) return;

   //check if we are allowing dragging
   if (m_bAllowDrag == FALSE) return;

   CRect rcVideo;
   m_wndVideo.GetWindowRect(rcVideo);
   ScreenToClient(rcVideo);

   if (rcVideo.PtInRect(point))
   {
      CRect rect;
      m_wndVideo.GetWindowRect(rect);
      CPoint ptScreenPoint(point);
      ClientToScreen(&ptScreenPoint);
      m_ptMouse.x = ptScreenPoint.x - rect.left;
      m_ptMouse.y = ptScreenPoint.y - rect.top;

        CWnd* pWnd = CWnd::GetDesktopWindow();
        CDC* pDC = pWnd->GetDCEx(NULL, DCX_WINDOW|DCX_CACHE|DCX_LOCKWINDOWUPDATE);
      if (pDC)
      {
         CRect rcOld(0,0,0,0);
         m_sizeOldDrag = CSize(1,1);
         pDC->DrawDragRect(&rect,m_sizeOldDrag,&rcOld,m_sizeOldDrag);
         m_rcOldDragRect = rect;

             m_hOldCursor = SetCursor(m_hCursor);
         SetCapture();
         m_bWindowMoving = TRUE;
         pWnd->ReleaseDC(pDC);
      }
   }    
}

/////////////////////////////////////////////////////////////////////////////
void CCallWnd::OnLButtonUp(UINT nFlags, CPoint point) 
{
   //#APPBAR
   if (m_bMovingSliders)
   {
      //clear out the drag/drop state
      m_bMovingSliders = FALSE;
      ReleaseCapture();
      //AVTRACE(_T("APPBAR: OnLButtonUp"));
   }
   //#APPBAR

   if (m_bWindowMoving)
   {
      //check if we are allowing dragging
      if (m_bAllowDrag == FALSE) return;

      m_bWindowMoving = FALSE;
      ReleaseCapture();
      SetCursor(m_hOldCursor);

      CWnd* pWnd = CWnd::GetDesktopWindow();
       CDC* pDC = pWnd->GetDCEx(NULL, DCX_WINDOW|DCX_CACHE|DCX_LOCKWINDOWUPDATE);
      if (pDC)
      {
         //clear out the drag rect
         CRect rcNewDrawRect(0,0,0,0);
         pDC->DrawDragRect(&rcNewDrawRect,CSize(0,0),&m_rcOldDragRect,m_sizeOldDrag);
         pWnd->ReleaseDC(pDC);
      }

      //See if we ended up outside of our window
      CRect rcClient;
      GetWindowRect(rcClient);
      ClientToScreen(&point);

      // If we're outside the client area, show the floating window
      if ( !rcClient.PtInRect(point) && m_wndFloater.Create(IDD_VIDEO_FLOATING_DIALOG,this) )
      {
         //set the current video window
         m_hwndCurrentVideoWindow = m_wndFloater.GetCurrentVideoWindow();

         //set the media window to the current
         SetMediaWindow();

         // Make sure that the floating window has same caption
         CString strText;
         GetWindowText( strText );

         // Go to first new line
         int nInd = strText.FindOneOf( _T("\n") );
         if ( nInd > 0 )
            strText = strText.Left(nInd);

         m_wndFloater.SetWindowText( strText );

         //window will set it's own size
         m_wndFloater.SetWindowPos(NULL,m_rcOldDragRect.left,m_rcOldDragRect.top,0,0,SWP_NOZORDER|SWP_SHOWWINDOW|SWP_NOSIZE);
         
         //Do not paint placeholder when floating window has video
         m_bPaintVideoPlaceholder = FALSE;
         CRect rcVideo;
         m_wndVideo.GetWindowRect(rcVideo);
         ScreenToClient(rcVideo);
         InvalidateRect(rcVideo);
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CCallWnd::OnMouseMove(UINT nFlags, CPoint point) 
{
   //#APPBAR
   if (m_bMovingSliders)
   {
       CWnd* pWnd = CWnd::GetDesktopWindow();
      if (pWnd)
      {
         CRect rcDesktop;
         pWnd->GetWindowRect(&rcDesktop);
         ClientToScreen(&point);
         //split desktop into two parts (left and right)
         rcDesktop.right = (rcDesktop.right - rcDesktop.left) / 2;
      
         if (rcDesktop.PtInRect(point))
         {
            //we are on the left side
            OnSlideSideLeft();
            //AVTRACE(_T("APPBAR: OnSlideSideLeft"));
            SetCapture();
         }
         else
         {
            //we are on the right side
            OnSlideSideRight();
            //AVTRACE(_T("APPBAR: OnSlideSideRight"));
            SetCapture();
         }
      }
   }
   //#APPBAR

   if (m_bWindowMoving)
   {
      //check if we are allowing dragging
      if (m_bAllowDrag == FALSE) return;

      CRect rcClient;
      m_wndVideo.GetClientRect(rcClient);
      
      ClientToScreen(&point);

      CPoint ptNewPoint = point;
      ptNewPoint -= m_ptMouse;

        CWnd* pWnd = CWnd::GetDesktopWindow();
        CDC* pDC = pWnd->GetDCEx(NULL, DCX_WINDOW|DCX_CACHE|DCX_LOCKWINDOWUPDATE);
      if (pDC)
      {
         CSize sizeNewSize;
         CRect rcParent;
         GetWindowRect(rcParent);
         CRect rcNewDrawRect;
   
         if (rcParent.PtInRect(point))
         {
            sizeNewSize = CSize(1,1);
            rcNewDrawRect.SetRect(ptNewPoint.x,ptNewPoint.y,ptNewPoint.x+rcClient.Width(),ptNewPoint.y+rcClient.Height());
         }
         else
         {
            sizeNewSize = CSize(3,3);
            rcNewDrawRect.SetRect(ptNewPoint.x,ptNewPoint.y,ptNewPoint.x+rcClient.Width()*2,ptNewPoint.y+rcClient.Height()*2);
         }

         pDC->DrawDragRect(&rcNewDrawRect,sizeNewSize,&m_rcOldDragRect,m_sizeOldDrag);
         m_rcOldDragRect = rcNewDrawRect;
         m_sizeOldDrag = sizeNewSize; 
         pWnd->ReleaseDC(pDC);
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
BOOL CCallWnd::OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message) 
{
   //check if we are allowing dragging
   if (m_bAllowDrag)
   {
      CPoint point;
      ::GetCursorPos(&point);

      CRect rcVideo;
      m_wndVideo.GetWindowRect(rcVideo);

      if ( m_hCursor && rcVideo.PtInRect(point) && !m_wndFloater.GetSafeHwnd() )
         return (BOOL) (SetCursor(m_hCursor) != NULL);
   }
      return CDialog::OnSetCursor(pWnd, nHitTest, message);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//For Floating Video Frame
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void CCallWnd::CloseFloatingWindow()
{
    if ( IsWindow(m_wndFloater) )
        m_wndFloater.SendMessage( WM_CLOSE, 0, 0 );
}

/////////////////////////////////////////////////////////////////////////////
void CCallWnd::OnCloseFloatingVideo()
{
   //set the current video window back to call window
   m_hwndCurrentVideoWindow = m_wndVideo.GetSafeHwnd();

   //put a blank screen if we are not connected   
   m_bPaintVideoPlaceholder = (BOOL) (m_MediaState != CM_STATES_CONNECTED);

   //show the video back in the video window in this callcontrolwindow
   SetMediaWindow();

   CRect rcVideo;
   m_wndVideo.GetWindowRect(rcVideo);
   ScreenToClient(rcVideo);
   InvalidateRect(rcVideo);

   // Unhide call control windows
   if ( m_pDialerDoc )
      m_pDialerDoc->UnhideCallControlWindows();
}

/////////////////////////////////////////////////////////////////////////////

void CCallWnd::Paint( CPaintDC& dc )
{    
   if (m_bPaintVideoPlaceholder)
   {
      //paint video window
      CRect rcVideo;
      m_wndVideo.GetWindowRect(rcVideo);
      ScreenToClient(rcVideo);
      m_dibVideoImage.Draw(dc,&rcVideo);
   }
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//ToolBars
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CCallWnd::CreateVertBar()
{
   CRect rcVertToolBar;
   GetDlgItem(IDC_CALLCONTROL_STATIC_ACTIONTOOLBAR)->GetWindowRect(rcVertToolBar);
   ScreenToClient(rcVertToolBar);

   m_wndToolbar.Init( IDR_CALLWINDOW_STATES, rcVertToolBar.Height() / m_nNumToolbarItems, m_nNumToolbarItems );
   m_wndToolbar.Create( NULL, NULL, WS_VISIBLE|WS_CHILD, rcVertToolBar, this, 1 );

   ClearCurrentActions();
}

/////////////////////////////////////////////////////////////////////////////
//Cmd Messages from VertBar
void CCallWnd::OnVertBarAction(UINT nID)
{
   CallManagerActions cma = (CallManagerActions)(nID-1000);

   //we need to clear all sounds before we do a takecall.
   //this is a fix until MS get's the audio sounds correct during call control
   if (cma == CM_ACTIONS_TAKECALL)
   {
       // --- BUG416970 ---
       ActivePlaySound(NULL, szSoundDialer, SND_SYNC );
   }

   if ( m_pDialerDoc )
   {
      if ( m_bIsPreview )
         m_pDialerDoc->PreviewWindowActionSelected(cma);
      else
         m_pDialerDoc->ActionSelected(m_nCallId,cma);
   }
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CCallWnd::OnShowStatesToolbar(WPARAM wParam,LPARAM lParam)
{
    BOOL bShow = (BOOL)lParam;
    BOOL bAlwaysOnTop = (BOOL)wParam;

    if ( !m_hwndStatesToolbar )
    {
        //If we don't want to show it, don't create it
        if ( !bShow ) return 0;

        //create the toolbar
        CreateStatesToolBar(bAlwaysOnTop);
    }

    if ( m_hwndStatesToolbar )
    {
        ::ShowWindow( m_hwndStatesToolbar, (bShow) ? SW_SHOW : SW_HIDE );
        OnUpdateStatesToolbar( wParam, lParam );
    }

   return 0;
}

LRESULT CCallWnd::OnUpdateStatesToolbar(WPARAM wParam,LPARAM lParam)
{
    if ( m_pDialerDoc && IsWindow(m_hwndStatesToolbar) )
    {
        BOOL bAlwaysOnTop = m_pDialerDoc->IsCallControlWindowsAlwaysOnTop();

        ::SendMessage( m_hwndStatesToolbar, TB_CHANGEBITMAP, ID_CALLWINDOW_ALWAYSONTOP,
                     (bAlwaysOnTop) ? CALLCONTROL_STATES_TOOLBAR_IMAGE_ALWAYSONTOP_ON : CALLCONTROL_STATES_TOOLBAR_IMAGE_ALWAYSONTOP_OFF );
        RECT rect;  
        ::GetClientRect(m_hwndStatesToolbar,&rect);
        ::RedrawWindow(m_hwndStatesToolbar,&rect,NULL,RDW_ERASE|RDW_INVALIDATE|RDW_UPDATENOW);
    }

    return 0;
}

/////////////////////////////////////////////////////////////////////////////
bool CCallWnd::CreateStatesToolBar(BOOL bAlwaysOnTop)
{
   ASSERT(m_hwndStatesToolbar == NULL);
   ASSERT( m_pDialerDoc );

   TBBUTTON tbb[2];
   
   tbb[0].iBitmap = bAlwaysOnTop?CALLCONTROL_STATES_TOOLBAR_IMAGE_ALWAYSONTOP_ON:
                                 CALLCONTROL_STATES_TOOLBAR_IMAGE_ALWAYSONTOP_OFF;

    tbb[0].idCommand = ID_CALLWINDOW_ALWAYSONTOP;
    tbb[0].fsState = TBSTATE_ENABLED;
    tbb[0].fsStyle = TBSTYLE_BUTTON;
    tbb[0].dwData = 0;
    tbb[0].iString = 0;

   UINT uSlideSide = m_pDialerDoc->GetCallControlSlideSide();
   if (uSlideSide == CALLWND_SIDE_LEFT)
      tbb[1].iBitmap = CALLCONTROL_STATES_TOOLBAR_IMAGE_SLIDE_LEFT;
   else //CALLWND_SIDE_RIGHT
      tbb[1].iBitmap = CALLCONTROL_STATES_TOOLBAR_IMAGE_SLIDE_RIGHT;
    tbb[1].idCommand = ID_CALLWINDOW_HIDE;
    tbb[1].fsState = TBSTATE_ENABLED;
    tbb[1].fsStyle = TBSTYLE_BUTTON;
    tbb[1].dwData = 0;
    tbb[1].iString = 0;

   // Create the toolbar
    DWORD ws = CCS_NORESIZE | CCS_NOPARENTALIGN | WS_CHILD | TBSTYLE_TOOLTIPS | TBSTYLE_FLAT | CCS_NODIVIDER | TTS_ALWAYSTIP;
   m_hwndStatesToolbar = CreateToolbarEx(GetSafeHwnd(),          // parent window
                                    ws,                                         // toolbar style
                                    2,                                         // ID for toolbar
                                    3,                                         // Number of bitmaps on toolbar
                                    AfxGetResourceHandle(),                // Resource instance that has the bitmap
                                    IDR_CALLWINDOW_POSITION,                // ID for bitmap
                                    tbb,                                        // Button information
                                    2,                                       // Number of buttons to add to toolbar
                                    12, 11, 0 ,  0,                        // Width and height of buttons/bitmaps
                                    sizeof(TBBUTTON) );                      // size of TBBUTTON structure

   if (m_hwndStatesToolbar)
   {
      CWnd* pStaticWnd = GetDlgItem(IDC_CALLCONTROL_STATIC_STATETOOLBAR);
      ASSERT(pStaticWnd);
      CRect rcStatesToolBar;
      pStaticWnd->GetWindowRect(rcStatesToolBar);
      ScreenToClient(rcStatesToolBar);

      ::SetWindowPos(m_hwndStatesToolbar,NULL,rcStatesToolBar.left,
                                              rcStatesToolBar.top,
                                              rcStatesToolBar.Width(),
                                              rcStatesToolBar.Height(),
                                              SWP_NOACTIVATE|SWP_NOZORDER);
   }

   return (bool) (m_hwndStatesToolbar != NULL);
}
/////////////////////////////////////////////////////////////////////////////
void CCallWnd::OnAlwaysOnTop()
{
   if (m_pDialerDoc)
      m_pDialerDoc->SetCallControlWindowsAlwaysOnTop( !m_pDialerDoc->IsCallControlWindowsAlwaysOnTop() );
}

/////////////////////////////////////////////////////////////////////////////
void CCallWnd::OnHideCallControlWindows()
{
   if ( m_pDialerDoc )
      m_pDialerDoc->HideCallControlWindows();
}

/////////////////////////////////////////////////////////////////////////////
void CCallWnd::OnSlideSideLeft()
{
   if (m_pDialerDoc)
   {
      if (m_pDialerDoc->SetCallControlSlideSide(CALLWND_SIDE_LEFT,TRUE))
      {
         //change the states toolbar image
         ::SendMessage( m_hwndStatesToolbar, TB_CHANGEBITMAP, ID_CALLWINDOW_HIDE,CALLCONTROL_STATES_TOOLBAR_IMAGE_SLIDE_LEFT);

         RECT rect;  
         ::GetClientRect(m_hwndStatesToolbar,&rect);
         ::RedrawWindow(m_hwndStatesToolbar,&rect,NULL,RDW_ERASE|RDW_INVALIDATE|RDW_UPDATENOW);
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CCallWnd::OnSlideSideRight()
{
   if (m_pDialerDoc)
   {
      if (m_pDialerDoc->SetCallControlSlideSide(CALLWND_SIDE_RIGHT,TRUE))
      {      
         //change the states toolbar image
         ::SendMessage( m_hwndStatesToolbar, TB_CHANGEBITMAP, ID_CALLWINDOW_HIDE,CALLCONTROL_STATES_TOOLBAR_IMAGE_SLIDE_RIGHT);

         RECT rect;  
         ::GetClientRect(m_hwndStatesToolbar,&rect);
         ::RedrawWindow(m_hwndStatesToolbar,&rect,NULL,RDW_ERASE|RDW_INVALIDATE|RDW_UPDATENOW);
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Methods for Call Manager
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
LRESULT CCallWnd::OnClearCurrentActions(WPARAM wParam,LPARAM lParam)
{
   m_wndToolbar.RemoveAll();  
   ClearCurrentActionList();
   return 0;
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CCallWnd::OnAddCurrentActions(WPARAM wParam,LPARAM lParam)
{
    CallManagerActions cma = (CallManagerActions)wParam;
    LPTSTR szActionText = (LPTSTR)lParam;

    //special case where we are being notified of actions that do 
    //no show up as button, but are just notifications of events.
    //If we process these actions, do not continue
    switch (cma)
    {
        case CM_ACTIONS_NOTIFY_PREVIEW_START:
        case CM_ACTIONS_NOTIFY_PREVIEW_STOP:
            if ( m_pDialerDoc && (m_pDialerDoc->GetPreviewWindowCallId() == m_nCallId) )
            m_pDialerDoc->SetPreviewWindow( m_nCallId, (bool) (cma == CM_ACTIONS_NOTIFY_PREVIEW_START) );
            break;


        case CM_ACTIONS_NOTIFY_STREAMSTART:
            OnNotifyStreamStart();
            break;

        case CM_ACTIONS_NOTIFY_STREAMSTOP:
            OnNotifyStreamStop();
            break;

        default:
            //add the button to the call control window
            //cmm+1000 value will be the ID for the button
            m_wndToolbar.AddButton(cma+1000,szActionText,cma);

            // If we have an USBPhone we should be sure it supports
            // speakerphone. If it doesn't we should desable the
            // 'Take Call' button
            if( cma == CM_ACTIONS_TAKECALL)
            {
                // Does phone support speaker phone?
                BOOL bTakeCallEnabled = FALSE;
                HRESULT hr = E_FAIL;
                hr = m_pAVTapi2->USBTakeCallEnabled( &bTakeCallEnabled );
                if( SUCCEEDED(hr) )
                {
                    m_wndToolbar.SetButtonEnabled( cma+1000, bTakeCallEnabled);
                }
            }

            CurrentAction* pAction = new CurrentAction;
            pAction->sText = szActionText;
            pAction->cma = cma;

            m_CurrentActionList.AddTail(pAction);
            break;
    }

    //must delete text when finished
    if (szActionText) delete szActionText;
    return 0;
}

/////////////////////////////////////////////////////////////////////////////
void CCallWnd::ClearCurrentActionList()
{
   POSITION pos = m_CurrentActionList.GetHeadPosition();
   while (pos)
   {
      delete (CurrentAction*)m_CurrentActionList.GetNext(pos);
   }
   m_CurrentActionList.RemoveAll();
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// ToolTips
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
BOOL CCallWnd::OnTabToolTip( UINT id, NMHDR * pNMHDR, LRESULT * pResult )
{
    // need to handle both ANSI and UNICODE versions of the message
    TOOLTIPTEXTA* pTTTA = (TOOLTIPTEXTA*)pNMHDR;
    TOOLTIPTEXTW* pTTTW = (TOOLTIPTEXTW*)pNMHDR;
    CString strTipText;
    SIZE_T nID = pNMHDR->idFrom;
    if (pNMHDR->code == TTN_NEEDTEXTA && (pTTTA->uFlags & TTF_IDISHWND) ||
        pNMHDR->code == TTN_NEEDTEXTW && (pTTTW->uFlags & TTF_IDISHWND))
    {
        // idFrom is actually the HWND of the tool
      nID = ::GetDlgCtrlID((HWND)nID);
    }

    if (nID != 0) // will be zero on a separator
    {
      CString sToken,sTip;
      sTip.LoadString((UINT32) nID);
      ParseToken(sTip,sToken,'\n');
      strTipText = sTip;
    }
#ifndef _UNICODE
    if (pNMHDR->code == TTN_NEEDTEXTA)
        lstrcpyn(pTTTA->szText, strTipText, sizeof(pTTTA->szText));
    else
        _mbstowcsz(pTTTW->szText, strTipText, sizeof(pTTTW->szText));
#else
    if (pNMHDR->code == TTN_NEEDTEXTA)
        _wcstombsz(pTTTA->szText, strTipText, sizeof(pTTTA->szText));
    else
        lstrcpyn(pTTTW->szText, strTipText, sizeof(pTTTW->szText));
#endif
    *pResult = 0;

    return TRUE;    // message was handled
}

/////////////////////////////////////////////////////////////////////////////
void CCallWnd::OnShowWindow(BOOL bShow, UINT nStatus) 
{
   // Ignore size requests when parent is minimizing
   if ( nStatus == SW_PARENTCLOSING ) return;

    CDialog::OnShowWindow(bShow, nStatus);
}

/////////////////////////////////////////////////////////////////////////////
void CCallWnd::PostNcDestroy() 
{
    CDialog::PostNcDestroy();

   ClearCurrentActionList();

   if ( m_bAutoDelete ) delete this;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Focus support
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
BOOL CCallWnd::OnNcActivate( BOOL bActive )
{
   DoActiveWindow(bActive);
   
   //on activate make all call control windows act like they are one object
   if ( bActive && m_pDialerDoc )
      m_pDialerDoc->BringCallControlWindowsToTop();

   return CDialog::OnNcActivate(bActive);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Context Menu Support
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CCallWnd::OnContextMenu(CWnd* pWnd, CPoint point) 
{
   if ( (point.x == -1) && (point.y == -1) )
   {
      //when we come in from a keyboard (SHIFT + VF10) we get a -1,-1
      point.x = 0;
      point.y = 0;
      ClientToScreen(&point);
   }
   
   CMenu menu;
   if (menu.CreatePopupMenu() == 0) return;

   POSITION pos = m_CurrentActionList.GetHeadPosition();
   while (pos)
   {
      CurrentAction* pAction = (CurrentAction*)m_CurrentActionList.GetNext(pos);
      menu.AppendMenu(MF_STRING,pAction->cma+1000,pAction->sText);
   }

    if (GetWindowLongPtr(m_hwndStatesToolbar,GWL_STYLE) & WS_VISIBLE)
    {
        CString sFullText,sText;

        
        //Add always on top and hide
        //Use tooltip for command for text in context menu
        menu.AppendMenu(MF_SEPARATOR);
        PARSE_MENU_STRING( ID_CALLWINDOW_ALWAYSONTOP );
        menu.AppendMenu( MF_STRING | ((m_pDialerDoc->IsCallControlWindowsAlwaysOnTop()) ? MF_CHECKED : NULL),ID_CALLWINDOW_ALWAYSONTOP, sText );
        APPEND_MENU_STRING( ID_CALLWINDOW_HIDE );
        menu.AppendMenu(MF_SEPARATOR);
        APPEND_MENU_STRING( ID_CALLWINDOW_SLIDESIDE_LEFT );
        APPEND_MENU_STRING( ID_CALLWINDOW_SLIDESIDE_RIGHT );

        if ( m_pDialerDoc->GetCallControlSlideSide() == CALLWND_SIDE_RIGHT )
            menu.CheckMenuRadioItem(ID_CALLWINDOW_SLIDESIDE_LEFT,ID_CALLWINDOW_SLIDESIDE_RIGHT,ID_CALLWINDOW_SLIDESIDE_RIGHT,MF_BYCOMMAND);
        else
            menu.CheckMenuRadioItem(ID_CALLWINDOW_SLIDESIDE_LEFT,ID_CALLWINDOW_SLIDESIDE_RIGHT,ID_CALLWINDOW_SLIDESIDE_LEFT,MF_BYCOMMAND);
    }

   //call virtual for derive class to add their own menu options
   OnContextMenu(&menu);

   CPoint pt;
   ::GetCursorPos(&pt);
   menu.TrackPopupMenu(TPM_LEFTALIGN | TPM_LEFTBUTTON | TPM_RIGHTBUTTON,
                        point.x,
                       point.y,
                       this);
}

/////////////////////////////////////////////////////////////////////////////
void CCallWnd::OnNotifyStreamStart()
{
    //allow dragging
    m_bAllowDrag = TRUE;

    //Show video window
    if (IsWindow(m_wndVideo.GetSafeHwnd()))
    {
        m_bPaintVideoPlaceholder = FALSE;

        //set the media window
        SetMediaWindow();

        CRect rcVideo;
        m_wndVideo.GetWindowRect(rcVideo);
        ScreenToClient(rcVideo);
        InvalidateRect(rcVideo);
    }
}

/////////////////////////////////////////////////////////////////////////////
void CCallWnd::OnNotifyStreamStop()
{
    //Go back to audio only state
    m_bAllowDrag = FALSE;
    m_dibVideoImage.DeleteObject();
    //Do Palette realization on 256 color bitmap.  
    m_dibVideoImage.Load(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDB_VIDEO_AUDIO_ONLY1));
    m_bPaintVideoPlaceholder = TRUE;

    if (IsWindow(m_wndVideo.GetSafeHwnd()))
    {
        CRect rcVideo;
        m_wndVideo.GetWindowRect(rcVideo);
        ScreenToClient(rcVideo);
        InvalidateRect(rcVideo);
    }
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


void CCallWnd::OnSysCommand(UINT nID, LPARAM lParam) 
{
    // Hot keys...
    if ( m_pDialerDoc && (nID == SC_KEYMENU) )
    {
        for ( POSITION rPos = m_CurrentActionList.GetHeadPosition(); rPos; )
        {
            CurrentAction *pAction = (CurrentAction *) m_CurrentActionList.GetNext( rPos );
            if ( pAction )
            {
                // Look for an hot keys in the string
                int nInd = pAction->sText.Find( _T("&") );
                if ( (nInd != -1) && ((pAction->sText.GetLength() - 1) > nInd) )
                {
                    if ( _totupper((TCHAR) lParam) == _totupper(pAction->sText[nInd+1]) )
                    {
                        m_pDialerDoc->ActionSelected( m_nCallId, pAction->cma );
                        return;
                    }
                }
            }
        }
    }
    
    CDialog::OnSysCommand(nID, lParam);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\callctrlwnd.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// callcontrolwnd.h : implementation file
/////////////////////////////////////////////////////////////////////////////
#if !defined(AFX_CALLCONTROLWND_H__5811CF83_26DB_11D1_AEB3_08001709BCA3__INCLUDED_)
#define AFX_CALLCONTROLWND_H__5811CF83_26DB_11D1_AEB3_08001709BCA3__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

// FWD define
class CCallControlWnd;

#include "CallWnd.h"
#include "cctrlfoc.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#define CALLCONTROL_HEIGHT                         135
#define CALLCONTROL_WIDTH                          400

enum
{
   MEDIAIMAGE_IMAGE_DESKTOPPAGE=0,
   MEDIAIMAGE_IMAGE_PAGER,
   MEDIAIMAGE_IMAGE_EMAIL,
   MEDIAIMAGE_IMAGE_CHAT,
   MEDIAIMAGE_IMAGE_INTERNETAUDIO,
   MEDIAIMAGE_IMAGE_INTERNETVIDEO,
   MEDIAIMAGE_IMAGE_PHONECALL,
   MEDIAIMAGE_IMAGE_FAXCALL,
   MEDIAIMAGE_IMAGE_PERSONALURL,
   MEDIAIMAGE_IMAGE_PERSONALWEB,
};

enum
{
   MEDIASTATE_IMAGE_UNAVAILABLE=0,
   MEDIASTATE_IMAGE_DISCONNECTED,
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CCallControlWnd window
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CCallControlWnd : public CCallWnd
{
   DECLARE_DYNAMIC(CCallControlWnd)
// Construction
public:
	CCallControlWnd();
protected:
// Dialog Data
	//{{AFX_DATA(CCallControlWnd)
	enum { IDD = IDD_CALLCONTROL };
	CCallControlFocusWnd	m_staticMediaText;
	CAnimateCtrl	m_MediaStateAnimateCtrl;
	//}}AFX_DATA


// Attributes
protected:
   CActiveCallManager*  m_pCallManager;
   CallManagerMedia     m_MediaType;
   CString              m_sCallerId;
   
   CImageList           m_MediaStateImageList;
   HWND                 m_hwndAppToolbar;

// Operations
public:
   //Methods for Call Manager
   virtual void         SetMediaWindow();
   void                 SetPreviewWindow();
   void                 SetCallManager(CActiveCallManager* pManager,WORD nCallId);
   void                 GetMediaText(CString& sText);

   void                 SetCallerId(LPCTSTR szCallerId)
                                    { 
                                       LPTSTR szText = new TCHAR[_tcslen(szCallerId)+1];
                                       _tcscpy(szText,szCallerId);
                                       PostMessage(WM_SLIDEWINDOW_SETCALLERID,NULL,(LPARAM)szText);
                                    };
   void                 SetMediaType(CallManagerMedia cmm)
                                    { 
                                       PostMessage(WM_SLIDEWINDOW_SETMEDIATYPE,NULL,(LPARAM)cmm);
                                    };
   
protected:
   bool                 CreateAppBar();
   void                 DrawMediaStateImage(CDC* pDC,int x,int y);
   virtual void         DoActiveWindow(BOOL bActive);
   virtual void         OnContextMenu(CMenu* pMenu);
   virtual BOOL         IsMouseOverForDragDropOfSliders(CPoint& point);

   virtual void         OnNotifyStreamStart();
   virtual void         OnNotifyStreamStop();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCallControlWnd)
	public:
   virtual BOOL OnInitDialog( );
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
public:
	// Generated message map functions
protected:
	//{{AFX_MSG(CCallControlWnd)
	afx_msg void OnPaint();
   afx_msg void OnCallWindowTouchTone();
   afx_msg void OnCallWindowAddToSpeedDial();
	//}}AFX_MSG
  	afx_msg LRESULT OnSetCallState(WPARAM,LPARAM);
  	afx_msg LRESULT OnSetCallerId(WPARAM,LPARAM);
  	afx_msg LRESULT OnSetMediaType(WPARAM,LPARAM);
	DECLARE_MESSAGE_MAP()
};



/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CALLCONTROLWND_H__5811CF83_26DB_11D1_AEB3_08001709BCA3__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\callentlst.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// CallEntLst.h : header file
/////////////////////////////////////////////////////////////////////////////////////////

#ifndef _CALLENTLST_H_
#define _CALLENTLST_H_

#include "avlist.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//class CCallEntryListItem
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CCallEntryListItem : public CAVListItem
{
	friend class CCallEntryListCtrl;
public:
//Construction
   CCallEntryListItem()  {};
   ~CCallEntryListItem() {};

//Attributes
protected:
	CObject*			m_pObject;
public:   

//Operations
public:
	void			   SetObject(CObject* pObject)   {m_pObject = pObject;};
	CObject*       GetObject()						   {return m_pObject;};
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CCallEntryListCtrl window
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CCallEntryListCtrl : public CAVListCtrl
{
	DECLARE_DYNCREATE(CCallEntryListCtrl)
// Construction
public:
	CCallEntryListCtrl();

public:
   enum		//Needed for subitem definition (must start with zero)
   {
      CALLENTRYLIST_NAME,
	  CALLENTRYLIST_ADDRESS,
   };

	typedef enum tagCallEntryListStyles_t
	{	
		STYLE_GROUP,
		STYLE_ITEM,
	} ListStyles_t;

// Members
public:
   CObList			m_CallEntryList;
   CWnd*			m_pParentView;
   static UINT		m_uColumnLabel[];
   int				m_nNumColumns;
   ListStyles_t		m_nStyle;

protected:
   CImageList		m_imageListLarge;
   CImageList		m_imageListSmall;
   bool				m_bLargeView;


// Attributes
public:
   void           ShowLargeView();
   void           ShowSmallView();
   bool           IsLargeView()                                   { return m_bLargeView; };


// Operations
public:
	void			Init(CWnd* pParentView);
	BOOL			Create(DWORD dwStyle, const RECT& rect, CWnd* pParentWnd, UINT nID);

	void			InsertList(CObList* pCallEntryList,BOOL bForce=FALSE);
	void			ClearList();
	void			SetColumns( ListStyles_t nStyle );
	void			DialSelItem();

	void			SaveOrLoadColumnSettings( bool bSave );


protected:
	void			OnSetDisplayText(CAVListItem* _pItem,int SubItem,LPTSTR szTextBuf,int nBufSize);
	void			OnSetDisplayImage(CAVListItem* pItem,int& iImage);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCallEntryListCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CCallEntryListCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CCallEntryListCtrl)
	afx_msg void OnLButtonDblClk(UINT nFlags, CPoint point);
	afx_msg void OnDestroy();
	afx_msg void OnButtonMakecall();
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	afx_msg void OnPaint();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif //_CALLENTLST_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\callwnd.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// CallWnd.h : header file
/////////////////////////////////////////////////////////////////////////////////////////
#if !defined(AFX_CALLWND_H__D89FB653_7266_11D1_B664_00C04FA3C554__INCLUDED_)
#define AFX_CALLWND_H__D89FB653_7266_11D1_B664_00C04FA3C554__INCLUDED_

#include "resource.h"
#include "slidewindow.h"
#include "callmgr.h"
#include "videownd.h"
#include "palhook.h"
#include "dib.h"
#include "vertbar.h"

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#define PARSE_MENU_STRING( _STR_ )			\
sFullText.LoadString(_STR_);				\
ParseToken(sFullText,sText,'\n');			\
ParseToken(sFullText,sText,'\n');

#define APPEND_MENU_STRING( _STR_ )			\
PARSE_MENU_STRING( _STR_ )					\
menu.AppendMenu( MF_STRING, _STR_, sText );

#define APPEND_PMENU_STRING( _STR_ )			\
PARSE_MENU_STRING( _STR_ )						\
pMenu->AppendMenu( MF_STRING, _STR_, sText );


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CCallWnd dialog
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
class CActiveDialerDoc;

class CCallWnd : public CDialog
{
DECLARE_DYNAMIC(CCallWnd)
// Construction
public:
	CCallWnd(CWnd* pParent = NULL);   // standard constructor

	//{{AFX_DATA(CCallWnd)
	CStatic	m_wndVideo;
	//}}AFX_DATA

// Members
public:
   CFont                   m_fontTextBold;
   int                     m_nNumToolbarItems;
   bool                    m_bIsPreview;
   bool                    m_bAutoDelete;
   HWND                    m_hwndStatesToolbar;
   IAVTapi2*               m_pAVTapi2;          // For USBPhone use

protected:
   CVerticalToolBar        m_wndToolbar;

   WORD                    m_nCallId;
   CVideoFloatingDialog    m_wndFloater;  

   HWND                    m_hwndCurrentVideoWindow;

   HCURSOR                 m_hCursor;
   HCURSOR                 m_hOldCursor;
   BOOL                    m_bWindowMoving;
   CRect                   m_rcOldDragRect;
   CPoint                  m_ptMouse;
   CSize                   m_sizeOldDrag;
   BOOL                    m_bAllowDrag;

   BOOL                    m_bMovingSliders;       //Drag/Drop of sliders

   BOOL                    m_bPaintVideoPlaceholder;

   CActiveDialerDoc*       m_pDialerDoc;
   CallManagerStates       m_MediaState;
   CString                 m_sMediaStateText;

  	CPalMsgHandler          m_palMsgHandler;	// handles palette messages
   CDib                    m_dibVideoImage;

   CPtrList                m_CurrentActionList;

// Attributes
public:
	WORD				GetCallId()		{ return m_nCallId; }
// Operations
public:
   void                 ClearCurrentActions()               { PostMessage(WM_SLIDEWINDOW_CLEARCURRENTACTIONS); };
   
   void                 AddCurrentActions(CallManagerActions cma,LPCTSTR szActionText)
                                                            { 
                                                               LPTSTR szText = new TCHAR[_tcslen(szActionText)+1];
                                                               _tcscpy(szText,szActionText);
                                                               PostMessage(WM_SLIDEWINDOW_ADDCURRENTACTIONS,(WPARAM)cma,(LPARAM)szText);
                                                            };
   
   void                 SetCallState(CallManagerStates cms,LPCTSTR szStateText)  
                                                            { 
                                                               LPTSTR szText = new TCHAR[_tcslen(szStateText)+1];
                                                               _tcscpy(szText,szStateText);
                                                               PostMessage(WM_SLIDEWINDOW_SETCALLSTATE,(WPARAM)cms,(LPARAM)szText);
                                                            };
   
   CallManagerStates    GetCallState()                      { return m_MediaState; };

   //Methods for peer floating video window
   void					CloseFloatingWindow();
   void                 OnCloseFloatingVideo();
   virtual void         SetMediaWindow()                    {};
   virtual HWND         GetCurrentVideoWindow()             { return m_hwndCurrentVideoWindow; };

protected:
   void                 CreateVertBar();
   bool                 CreateStatesToolBar(BOOL bAlwaysOnTop);
   virtual void         DoActiveWindow(BOOL bActive)        {};
   virtual void         OnContextMenu(CMenu* pMenu)         {};
   virtual void         OnNotifyStreamStart();
   virtual void         OnNotifyStreamStop();
   virtual BOOL         IsMouseOverForDragDropOfSliders(CPoint& point)   { return FALSE; };

   void                 ClearCurrentActionList();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCallWnd)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	virtual void PostNcDestroy();
   virtual void OnOK();
   virtual void OnCancel();
	//}}AFX_VIRTUAL

// Implementation
protected:
   void                 CheckLButtonDown(CPoint& point);
   void                 Paint( CPaintDC& dc );

	// Generated message map functions
	//{{AFX_MSG(CCallWnd)
	afx_msg void OnLButtonDown(UINT nFlags, CPoint point);
	afx_msg void OnLButtonUp(UINT nFlags, CPoint point);
	afx_msg void OnMouseMove(UINT nFlags, CPoint point);
	afx_msg BOOL OnSetCursor(CWnd* pWnd, UINT nHitTest, UINT message);
   afx_msg void OnParentNotify(UINT message, LPARAM lParam);
	virtual BOOL OnInitDialog();
   afx_msg void OnAlwaysOnTop();
   afx_msg void OnHideCallControlWindows();
	afx_msg void OnDestroy();
	afx_msg void OnShowWindow(BOOL bShow, UINT nStatus);
   afx_msg BOOL OnNcActivate( BOOL );
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
   afx_msg void OnSlideSideLeft();
   afx_msg void OnSlideSideRight();
	afx_msg void OnSysCommand(UINT nID, LPARAM lParam);
	//}}AFX_MSG
   afx_msg void OnVertBarAction(UINT nID);
	afx_msg LRESULT OnClearCurrentActions(WPARAM,LPARAM);
	afx_msg LRESULT OnAddCurrentActions(WPARAM,LPARAM);
	afx_msg LRESULT OnShowStatesToolbar(WPARAM,LPARAM);
	afx_msg LRESULT OnUpdateStatesToolbar(WPARAM,LPARAM);
   afx_msg BOOL OnTabToolTip( UINT id, NMHDR * pTTTStruct, LRESULT * pResult );
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CALLWND_H__D89FB653_7266_11D1_B664_00C04FA3C554__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\cavwav.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// TAPIDialer(tm) and ActiveDialer(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526; 5,488,650; 
// 5,434,906; 5,581,604; 5,533,102; 5,568,540, 5,625,676.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// CAvWav.h - header file
/////////////////////////////////////////////////////////////////////////////////////////

#ifndef _CAVWAV_H_
#define _CAVWAV_H_

#include "wav.h"
#include "wavmixer.h"

class CActiveDialerDoc;

typedef enum tagAudioDeviceType
{
   AVWAV_AUDIODEVICE_IN=0,
   AVWAV_AUDIODEVICE_OUT,
}AudioDeviceType;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
typedef HWAVINIT        (WINAPI *PWAVINIT)               (DWORD,HINSTANCE,DWORD);
typedef int             (WINAPI *PWAVTERM)               (HWAVINIT);
typedef HWAV            (WINAPI *PWAVOPEN)               (DWORD,HINSTANCE,LPCTSTR,LPWAVEFORMATEX,LPMMIOPROC,DWORD,DWORD);
typedef int             (WINAPI *PWAVCLOSE)              (HWAV);
typedef int             (WINAPI *PWAVPLAY)               (HWAV,int,DWORD);
typedef int             (WINAPI *PWAVRECORD)             (HWAV,int,DWORD);
typedef int             (WINAPI *PWAVSTOP)               (HWAV);
typedef HWAVMIXER       (WINAPI *PWAVMIXERINIT)          (DWORD,HINSTANCE,LPARAM,DWORD,DWORD,DWORD);
typedef int             (WINAPI *PWAVMIXERTERM)          (HWAVMIXER);
typedef BOOL            (WINAPI *PWAVMIXERSUPPVOL)       (HWAVMIXER,DWORD);
typedef int             (WINAPI *PWAVMIXERGETVOL)        (HWAVMIXER,DWORD);
typedef int             (WINAPI *PWAVMIXERSETVOL)        (HWAVMIXER,int,DWORD);
typedef BOOL            (WINAPI *PWAVMIXERSUPPLEVEL)     (HWAVMIXER,DWORD);
typedef int             (WINAPI *PWAVMIXERGETLEVEL)      (HWAVMIXER,DWORD);
typedef int             (WINAPI *PWAVOUTGETIDBYNAME)     (LPCTSTR,DWORD);
typedef int             (WINAPI *PWAVINGETIDBYNAME)      (LPCTSTR,DWORD);

typedef struct
{
	HINSTANCE		            hLib;             
   PWAVINIT                   pfnWavInit;                   //WavInit()
   PWAVTERM                   pfnWavTerm;                   //WavTerm()
   PWAVOPEN                   pfnWavOpen;                   //WavOpen()
   PWAVCLOSE                  pfnWavClose;                  //WavClose()
   PWAVPLAY                   pfnWavPlay;                   //WavPlay()
   PWAVRECORD                 pfnWavRecord;                 //WavRecord()
   PWAVSTOP                   pfnWavStop;                   //WavStop()
   PWAVMIXERINIT              pfnWavMixerInit;              //WavMixerInit()
   PWAVMIXERTERM              pfnWavMixerTerm;              //WavMixerTerm()
   PWAVMIXERSUPPVOL           pfnWavMixerSupportsVolume;    //WavMixerSupportsVolume()
   PWAVMIXERGETVOL            pfnWavMixerGetVolume;         //WavMixerGetVolume()
   PWAVMIXERSETVOL            pfnWavMixerSetVolume;         //WavMixerSetVolume()
   PWAVMIXERSUPPLEVEL         pfnWavMixerSupportsLevel;     //WavMixerSupportsLevel()
   PWAVMIXERGETLEVEL          pfnWavMixerGetLevel;          //WavMixerGetLevel()
   PWAVOUTGETIDBYNAME         pfnWavOutGetIdByName;         //WavOutGetIdByName()
   PWAVINGETIDBYNAME          pfnWavInGetIdByName;          //WavInGetIdByName()
}AVWAVAPI;                         

#define WavInit(a,b,c)                 m_avwavAPI.pfnWavInit(a,b,c)
#define WavTerm(a)                     m_avwavAPI.pfnWavTerm(a)
#define WavOpen(a,b,c,d,e,f,g)         m_avwavAPI.pfnWavOpen(a,b,c,d,e,f,g)
#define WavClose(a)                    m_avwavAPI.pfnWavClose(a)
#define WavPlay(a,b,c)                 m_avwavAPI.pfnWavPlay(a,b,c)
#define WavRecord(a,b,c)               m_avwavAPI.pfnWavRecord(a,b,c)
#define WavStop(a)                     m_avwavAPI.pfnWavStop(a)
#define WavMixerInit(a,b,c,d,e,f)      m_avwavAPI.pfnWavMixerInit(a,b,c,d,e,f)
#define WavMixerTerm(a)                m_avwavAPI.pfnWavMixerTerm(a)
#define WavMixerSupportsVolume(a,b)    m_avwavAPI.pfnWavMixerSupportsVolume(a,b)
#define WavMixerGetVolume(a,b)         m_avwavAPI.pfnWavMixerGetVolume(a,b)
#define WavMixerSetVolume(a,b,c)       m_avwavAPI.pfnWavMixerSetVolume(a,b,c)
#define WavMixerSupportsLevel(a,b)     m_avwavAPI.pfnWavMixerSupportsLevel(a,b)
#define WavMixerGetLevel(a,b)          m_avwavAPI.pfnWavMixerGetLevel(a,b)
#define WavOutGetIdByName(a,b)         m_avwavAPI.pfnWavOutGetIdByName(a,b)
#define WavInGetIdByName(a,b)          m_avwavAPI.pfnWavInGetIdByName(a,b)

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CAvWav - 
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
class CAvWav : public CObject
{
   DECLARE_SERIAL(CAvWav)
public:
//Construction
    CAvWav();
   ~CAvWav();

//Attributes
protected:
   BOOL                 m_bInit;
   AVWAVAPI             m_avwavAPI;
   HWAVINIT             m_hWavInit;

   HWAVMIXER            m_hWavMixerIn;
   int                  m_nWavMixerInDevice;
   HWAVMIXER            m_hWavMixerOut;
   int                  m_nWavMixerOutDevice;

//Operations
public:
   BOOL                 Init( CActiveDialerDoc *pDoc );
   BOOL                 IsInit()    { return m_bInit; };
   bool                 OpenWavMixer(AudioDeviceType adt,int nDeviceId);
   void                 CloseWavMixer(AudioDeviceType adt);
   int                  GetWavMixerVolume(AudioDeviceType adt);
   int                  GetWavMixerLevel(AudioDeviceType adt);
   void                 SetWavMixerVolume(AudioDeviceType adt,int nVolume);
   int                  GetWavIdByName(AudioDeviceType adt,LPCTSTR szName);
protected:
   void                 UnLoad();
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif // _CAVWAV_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\cavwav.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// TAPIDialer(tm) and ActiveDialer(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526; 5,488,650; 
// 5,434,906; 5,581,604; 5,533,102; 5,568,540, 5,625,676.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
#include "stdafx.h"
#include "cavwav.h"
#include "AVDialerDoc.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CAvWav - WAV Helpers
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

IMPLEMENT_SERIAL(CAvWav,CObject,1)

/////////////////////////////////////////////////////////////////////////////
CAvWav::CAvWav()
{
   memset(&m_avwavAPI,0,sizeof(AVWAVAPI));  
   m_bInit = FALSE;
   m_hWavInit = NULL;
   m_hWavMixerIn = NULL;
   m_hWavMixerOut = NULL;
   m_nWavMixerInDevice = -1;
   m_nWavMixerOutDevice = -1;
}

/////////////////////////////////////////////////////////////////////////////
CAvWav::~CAvWav()
{
   UnLoad();
}

/////////////////////////////////////////////////////////////////////////////
//CWnd* pParentWnd - Needed for timer
/////////////////////////////////////////////////////////////////////////////
BOOL CAvWav::Init( CActiveDialerDoc *pDoc )
{
	if (m_bInit) return FALSE;

	if (m_avwavAPI.hLib == NULL)
	{                  
		if (m_avwavAPI.hLib = LoadLibrary (_T("avwav.dll")))
		{
	  	   if ((m_avwavAPI.pfnWavInit =                 (PWAVINIT)GetProcAddress( m_avwavAPI.hLib,"WavInit" )) != NULL)
	  	   if ((m_avwavAPI.pfnWavTerm =                 (PWAVTERM)GetProcAddress( m_avwavAPI.hLib,"WavTerm" )) != NULL)
	  	   if ((m_avwavAPI.pfnWavOpen =                 (PWAVOPEN)GetProcAddress( m_avwavAPI.hLib,"WavOpen" )) != NULL)
	  	   if ((m_avwavAPI.pfnWavClose =                (PWAVCLOSE)GetProcAddress( m_avwavAPI.hLib,"WavClose" )) != NULL)
	  	   if ((m_avwavAPI.pfnWavPlay =                 (PWAVPLAY)GetProcAddress( m_avwavAPI.hLib,"WavPlay" )) != NULL)
	  	   if ((m_avwavAPI.pfnWavRecord =               (PWAVRECORD)GetProcAddress( m_avwavAPI.hLib,"WavRecord" )) != NULL)
	  	   if ((m_avwavAPI.pfnWavStop =                 (PWAVSTOP)GetProcAddress( m_avwavAPI.hLib,"WavStop" )) != NULL)
         if ((m_avwavAPI.pfnWavMixerInit =            (PWAVMIXERINIT)GetProcAddress( m_avwavAPI.hLib,"WavMixerInit" )) != NULL)
	  	   if ((m_avwavAPI.pfnWavMixerTerm =            (PWAVMIXERTERM)GetProcAddress( m_avwavAPI.hLib,"WavMixerTerm" )) != NULL)
	  	   if ((m_avwavAPI.pfnWavMixerSupportsVolume =  (PWAVMIXERSUPPVOL)GetProcAddress( m_avwavAPI.hLib,"WavMixerSupportsVolume")) != NULL)
	  	   if ((m_avwavAPI.pfnWavMixerGetVolume =       (PWAVMIXERGETVOL)GetProcAddress( m_avwavAPI.hLib,"WavMixerGetVolume" )) != NULL)
	  	   if ((m_avwavAPI.pfnWavMixerSetVolume =       (PWAVMIXERSETVOL)GetProcAddress( m_avwavAPI.hLib,"WavMixerSetVolume" )) != NULL)
	  	   if ((m_avwavAPI.pfnWavMixerSupportsLevel =   (PWAVMIXERSUPPLEVEL)GetProcAddress( m_avwavAPI.hLib,"WavMixerSupportsLevel")) != NULL)
	  	   if ((m_avwavAPI.pfnWavMixerGetLevel =        (PWAVMIXERGETLEVEL)GetProcAddress( m_avwavAPI.hLib,"WavMixerGetLevel" )) != NULL)
	  	   if ((m_avwavAPI.pfnWavOutGetIdByName =       (PWAVOUTGETIDBYNAME)GetProcAddress( m_avwavAPI.hLib,"WavOutGetIdByName" )) != NULL)
	  	   if ((m_avwavAPI.pfnWavInGetIdByName =        (PWAVINGETIDBYNAME)GetProcAddress( m_avwavAPI.hLib,"WavInGetIdByName" )) != NULL)
            m_bInit = TRUE;                           //Success

         if (m_bInit)
         {
            if (( m_hWavInit = WavInit(WAV_VERSION,AfxGetInstanceHandle(),NULL)) == NULL)
               m_bInit = FALSE;
         }
         if (m_bInit == FALSE)
         {
			//function pointer is invalid
		    FreeLibrary (m_avwavAPI.hLib);            //Unload the library
            memset(&m_avwavAPI,0,sizeof(AVWAVAPI)); 

			if ( pDoc )
			{
				CString strMessage;
				strMessage.LoadString( IDS_ERR_AVWAV_LOAD_FAIL );
				DWORD dwError = GetLastError();
				pDoc->ErrorNotify( strMessage, _T(""), E_FAIL, ERROR_NOTIFY_LEVEL_INTERNAL);
			}
         }
      }
      else
      {
         DWORD dwError = GetLastError();
      }
   }
   return m_bInit;
}

/////////////////////////////////////////////////////////////////////////////
void CAvWav::UnLoad()
{
   if (!m_bInit) return;

   if (m_hWavInit)
   {
      WavTerm(m_hWavInit);
      m_hWavInit = NULL;
   }

   CloseWavMixer(AVWAV_AUDIODEVICE_IN);
   CloseWavMixer(AVWAV_AUDIODEVICE_OUT);

   if (m_avwavAPI.hLib)
   {
      FreeLibrary (m_avwavAPI.hLib);                  //Unload the library
      memset(&m_avwavAPI,0,sizeof(AVWAVAPI)); 
      m_bInit = FALSE;
   }
}

/////////////////////////////////////////////////////////////////////////////
//init the mixer device, if a mixer is already open for the given adt it will be closed.
//if the same device is being opened for the adt then nothing will happen
bool CAvWav::OpenWavMixer(AudioDeviceType adt,int nDeviceId)
{
   if (!m_bInit) return false;
   
   //if already open mixer and same device, then do nothing
   if ( (adt == AVWAV_AUDIODEVICE_IN) && (m_hWavMixerIn) && (m_nWavMixerInDevice == nDeviceId) )
      return true;
   if ( (adt == AVWAV_AUDIODEVICE_OUT) && (m_hWavMixerOut) && (m_nWavMixerOutDevice == nDeviceId) )
      return true;

   //close any existing mixer
   CloseWavMixer(adt);

   DWORD dwFlags=0;
   if (adt == AVWAV_AUDIODEVICE_IN)
      dwFlags = WAVMIXER_WAVEIN;
   else if (adt == AVWAV_AUDIODEVICE_OUT)
      dwFlags = WAVMIXER_WAVEOUT;

   //Open first device in list
   HWAVMIXER hWavMixer = WavMixerInit(WAVMIXER_VERSION,
                              AfxGetInstanceHandle(),
                              nDeviceId,
                              0,
                              0,
                              dwFlags);

   if (adt == AVWAV_AUDIODEVICE_IN)
   {
      m_hWavMixerIn = hWavMixer;
      m_nWavMixerInDevice = nDeviceId;
   }
   else if (adt == AVWAV_AUDIODEVICE_OUT)
   {
      m_hWavMixerOut = hWavMixer;
      m_nWavMixerOutDevice = nDeviceId;
   }
   return (hWavMixer)?TRUE:FALSE;
}

/////////////////////////////////////////////////////////////////////////////
void CAvWav::CloseWavMixer(AudioDeviceType adt)
{
   if (!m_bInit) return;

   HWAVMIXER hWavMixer = NULL;

   if (adt == AVWAV_AUDIODEVICE_IN)
   {
      if (m_hWavMixerIn)
      {
         WavMixerTerm(m_hWavMixerIn);
         m_hWavMixerIn = NULL;
         m_nWavMixerInDevice = -1;
      }
   }
   else if (adt == AVWAV_AUDIODEVICE_OUT)
   {
      if (m_hWavMixerOut)
      {
         WavMixerTerm(m_hWavMixerOut);
         m_hWavMixerOut = NULL;
         m_nWavMixerOutDevice = -1;
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
// -1 - Does not support volume
int CAvWav::GetWavMixerVolume(AudioDeviceType adt)
{
   if (!m_bInit) return -1;

   HWAVMIXER hWavMixer = NULL;
   if (adt == AVWAV_AUDIODEVICE_IN)
      hWavMixer = m_hWavMixerIn;
   else if (adt == AVWAV_AUDIODEVICE_OUT)
      hWavMixer = m_hWavMixerOut;

   if (hWavMixer == NULL) return -1;

   if (WavMixerSupportsVolume(hWavMixer,0) == false)
      return -1;

   return WavMixerGetVolume(hWavMixer,0);
}

/////////////////////////////////////////////////////////////////////////////
// -1 - Does not support level
int CAvWav::GetWavMixerLevel(AudioDeviceType adt)
{
   if (!m_bInit) return -1;

   HWAVMIXER hWavMixer = NULL;
   if (adt == AVWAV_AUDIODEVICE_IN)
      hWavMixer = m_hWavMixerIn;
   else if (adt == AVWAV_AUDIODEVICE_OUT)
      hWavMixer = m_hWavMixerOut;

   if (WavMixerSupportsLevel(hWavMixer,0) == false)
      return -1;

   return WavMixerGetLevel(hWavMixer,0);
}

void CAvWav::SetWavMixerVolume(AudioDeviceType adt,int nVolume)
{
   if (!m_bInit) return;

   HWAVMIXER hWavMixer = NULL;
   if (adt == AVWAV_AUDIODEVICE_IN)
      hWavMixer = m_hWavMixerIn;
   else if (adt == AVWAV_AUDIODEVICE_OUT)
      hWavMixer = m_hWavMixerOut;

   if (hWavMixer == NULL) return;

   WavMixerSetVolume(hWavMixer,nVolume,0);
}

/////////////////////////////////////////////////////////////////////////////
int CAvWav::GetWavIdByName(AudioDeviceType adt,LPCTSTR szName)
{
   if (!m_bInit) return -1;
   
   if (adt == AVWAV_AUDIODEVICE_IN)
      return WavInGetIdByName(szName,0);
   else if (adt == AVWAV_AUDIODEVICE_OUT)
      return WavOutGetIdByName(szName,0);
   
   return -1;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\cctrlfoc.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// cctrlfoc.cpp : implementation file
/////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "avdialer.h"
#include "cctrlfoc.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CCallControlFocusWnd
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////////////////
CCallControlFocusWnd::CCallControlFocusWnd()
{
   m_bFocusState = FALSE;
}

/////////////////////////////////////////////////////////////////////////////////////////
CCallControlFocusWnd::~CCallControlFocusWnd()
{
}

/////////////////////////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CCallControlFocusWnd, CStatic)
	//{{AFX_MSG_MAP(CCallControlFocusWnd)
	ON_WM_ERASEBKGND()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
BOOL CCallControlFocusWnd::OnEraseBkgnd(CDC* pDC) 
{
	CRect rc;
	GetClientRect(&rc);

   CBrush brush(GetSysColor((m_bFocusState)?COLOR_ACTIVECAPTION:COLOR_BTNFACE));
   CBrush* pBrushOld = NULL;

   pBrushOld = pDC->SelectObject(&brush);
	pDC->PatBlt(0,0,rc.Width(),rc.Height(),PATCOPY);
   if (pBrushOld) pDC->SelectObject(pBrushOld);

   //return that we handled the background painting
   return true;
}

/////////////////////////////////////////////////////////////////////////////
void CCallControlFocusWnd::OnPaint() 
{
   CPaintDC dc(this); // device context for painting

	CRect rc;
	GetClientRect(&rc);

   //draw background
   CBrush brush(GetSysColor((m_bFocusState)?COLOR_ACTIVECAPTION:COLOR_BTNFACE));
   CBrush* pBrushOld = NULL;
   pBrushOld = dc.SelectObject(&brush);
	dc.PatBlt(0,0,rc.Width(),rc.Height(),PATCOPY);
   if (pBrushOld) dc.SelectObject(pBrushOld);
   
   CString sText;
   GetWindowText(sText);

   CFont* pFont = GetFont();
   CFont* pOldFont = NULL;
   if (pFont) pOldFont = (CFont*)dc.SelectObject(pFont);

   if (m_bFocusState)
   {
      dc.SetTextColor(GetSysColor(COLOR_CAPTIONTEXT));
      dc.SetBkColor(GetSysColor(COLOR_ACTIVECAPTION));
   }
   else
   {
      dc.SetTextColor(GetSysColor(COLOR_WINDOWTEXT));
      dc.SetBkColor(GetSysColor(COLOR_BTNFACE));
   }
   dc.DrawText(sText,&rc,DT_SINGLELINE|DT_LEFT|DT_VCENTER);

//   DrawCaption(GetSafeHwnd(),dc.GetSafeHdc(),rc,DC_TEXT|DC_ICON|DC_ACTIVE);

   if (pOldFont) dc.SelectObject(pOldFont);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\confroomwnd.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// MainExplorerWndConfRoom.h : header file
/////////////////////////////////////////////////////////////////////////////

#ifndef _MAINEXPLORERWNDCONFROOM_H_
#define _MAINEXPLORERWNDCONFROOM_H_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "mainexpwnd.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CMainExplorerWndConfRoomDetailsWnd window
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CMainExplorerWndConfRoomDetailsWnd : public CWnd
{
// Construction
public:
	CMainExplorerWndConfRoomDetailsWnd();

// Attributes
public:

// Operations
public:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainExplorerWndConfRoomDetailsWnd)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainExplorerWndConfRoomDetailsWnd();

	// Generated message map functions
protected:
	//{{AFX_MSG(CMainExplorerWndConfRoomDetailsWnd)
	afx_msg void OnSize(UINT nType, int cx, int cy);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CMainExplorerWndConfRoom window
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
interface IConfExplorer;
interface IConfExplorerDetailsView;

class CMainExplorerWndConfRoom : public CMainExplorerWndBase
{
// Construction
public:
	CMainExplorerWndConfRoom();

// Attributes
public:
	IConfRoom*								m_pConfRoom;
	IConfExplorerDetailsView*				m_pConfDetailsView;
	CMainExplorerWndConfRoomDetailsWnd*		m_pDetailsWnd;

// Operations
public:
   virtual void      Init(CActiveDialerView* pParentWnd);
   virtual void      Refresh();
   virtual void      PostTapiInit();

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainExplorerWndConfRoom)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainExplorerWndConfRoom();

	// Generated message map functions
protected:
	//{{AFX_MSG(CMainExplorerWndConfRoom)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnViewVideoParticpantNames();
	afx_msg void OnUpdateViewVideoParticpantNames(CCmdUI* pCmdUI);
	afx_msg void OnViewVideoLarge();
	afx_msg void OnUpdateViewVideoLarge(CCmdUI* pCmdUI);
	afx_msg void OnSize(UINT nType, int cx, int cy);
	afx_msg void OnDestroy();
	//}}AFX_MSG
   afx_msg void OnTreeWndSelChanged(UINT nId,NMHDR* pNMHDR, LRESULT* pResult);
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif //_MAINEXPLORERWNDCONFROOM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\cctrlfoc.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// cctrlfoc.h : header file
/////////////////////////////////////////////////////////////////////////////////////////
#if !defined(AFX_CCTRLFOC_H__661EFD69_934A_11D1_AA27_00C04FA3C552__INCLUDED_)
#define AFX_CCTRLFOC_H__661EFD69_934A_11D1_AA27_00C04FA3C552__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
// Class CCallControlFocusWnd window
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

class CCallControlFocusWnd : public CStatic
{
// Construction
public:
	CCallControlFocusWnd();

// Attributes
protected:
   BOOL           m_bFocusState;

// Operations
public:
   void           SetFocusState(BOOL bState)          { m_bFocusState = bState; RedrawWindow(); };

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CCallControlFocusWnd)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CCallControlFocusWnd();

	// Generated message map functions
protected:
	//{{AFX_MSG(CCallControlFocusWnd)
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
	afx_msg void OnPaint();
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_CCTRLFOC_H__661EFD69_934A_11D1_AA27_00C04FA3C552__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\cnfroomwnd.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// MainExplorerWndConfRoom.cpp : implementation file
//

#include "stdafx.h"
#include "avDialer.h"
#include "MainFrm.h"
#include "ConfRoomWnd.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#define EXPLORERCONFROOM_VIDEO_SIZE_LARGE    0x64
#define EXPLORERCONFROOM_VIDEO_SIZE_SMALL    0x32

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CMainExplorerWndConfRoom
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
CMainExplorerWndConfRoom::CMainExplorerWndConfRoom()
{
   m_pDetailsWnd = NULL;
   m_pConfRoom = NULL;
}

/////////////////////////////////////////////////////////////////////////////
CMainExplorerWndConfRoom::~CMainExplorerWndConfRoom()
{
   if (m_pDetailsWnd) delete m_pDetailsWnd;
}

/////////////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CMainExplorerWndConfRoom, CMainExplorerWndBase)
	//{{AFX_MSG_MAP(CMainExplorerWndConfRoom)
	ON_WM_CREATE()
	ON_COMMAND(ID_VIEW_VIDEO_PARTICPANT_NAMES, OnViewVideoParticpantNames)
	ON_UPDATE_COMMAND_UI(ID_VIEW_VIDEO_PARTICPANT_NAMES, OnUpdateViewVideoParticpantNames)
	ON_COMMAND(ID_VIEW_VIDEO_LARGE, OnViewVideoLarge)
	ON_UPDATE_COMMAND_UI(ID_VIEW_VIDEO_LARGE, OnUpdateViewVideoLarge)
	ON_WM_SIZE()
	ON_WM_PAINT()
	ON_WM_DESTROY()
	//}}AFX_MSG_MAP
   ON_NOTIFY_RANGE(TVN_SELCHANGED, 0,0xffff, OnTreeWndSelChanged)
   ON_NOTIFY_RANGE(TVN_GETDISPINFO, 0, 0xffff, OnTreeWndSelChanged)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
int CMainExplorerWndConfRoom::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CMainExplorerWndBase::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfRoom::Init(CActiveDialerView* pParentWnd)
{
   //Let base class have it first
   CMainExplorerWndBase::Init(pParentWnd);

   ASSERT(m_pParentWnd);
   
   //detail view's have to be parents of the main dialer view
   m_pDetailsWnd = new CMainExplorerWndConfRoomDetailsWnd;
   m_pDetailsWnd->Create(NULL,NULL,WS_CHILD|WS_VISIBLE,CRect(0,0,0,0),m_pParentWnd,IDC_CONFERENCEROOM_VIEWCTRL_DETAILS);
   m_pParentWnd->SetDetailWindow(m_pDetailsWnd);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfRoom::PostTapiInit()
{
	if (m_pConfRoom == NULL)
	{
		//Get Tapi object and register out tree control
		IAVTapi* pTapi = m_pParentWnd->GetTapi();
		if (pTapi)
		{
			if ( (SUCCEEDED(pTapi->get_ConfRoom(&m_pConfRoom))) && (m_pConfRoom) )
			{
#ifdef _DEBUG
				if ( !GetSafeHwnd() )
					AfxMessageBox( _T("CMainExplorerWndConfRoom::PostTapiInit() -- GetSafeHwnd() failed.") );

				if ( !m_pDetailsWnd->GetSafeHwnd() )
					AfxMessageBox( _T("CMainExplorerWndConfRoom::PostTapiInit() -- m_pDetailsWnd->GetSafeHwnd() failed.") );
#endif

				m_pConfRoom->Show(GetSafeHwnd(),m_pDetailsWnd->GetSafeHwnd());
			}
#ifdef _DEBUG
			else
			{
				AfxMessageBox( _T("CMainExplorerWndConfRoom::PostTapiInit() -- failed to get conf room object") );
			}
#endif
			pTapi->Release();
		}
#ifdef _DEBUG
		else
		{
			AfxMessageBox( _T("CMainExplorerWndConfRoom::PostTapiInit() -- get tapi failed") );
		}
#endif
	}
#ifdef _DEBUG
	else
	{
		AfxMessageBox( _T("CMainExplorerWndConfRoom::PostTapiInit() -- m_pConfRoom already defined.\n") );
	}
#endif
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfRoom::Refresh() 
{
   //Let base class have it
   CMainExplorerWndBase::Refresh();
   
   if (m_pConfRoom == NULL)
   {
      //Get Tapi object
      IAVTapi* pTapi = m_pParentWnd->GetTapi();
      if (pTapi)
      {
         if ( (SUCCEEDED(pTapi->get_ConfRoom(&m_pConfRoom))) && (m_pConfRoom) )
           m_pConfRoom->Show(GetSafeHwnd(),m_pDetailsWnd->GetSafeHwnd());

         pTapi->Release();
      }
   }
   //make sure our windows are showing
   m_pParentWnd->SetDetailWindow(m_pDetailsWnd);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfRoom::OnTreeWndSelChanged(UINT nId,NMHDR* pNMHDR, LRESULT* pResult)
{
   //reflect back down to child
   CWnd* pWnd = GetWindow(GW_CHILD);
   if (pWnd)
   {
      pWnd->SendMessage(WM_NOTIFY,(WPARAM)pNMHDR->idFrom,(LPARAM)pNMHDR);
   }
   return;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Button Handlers
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfRoom::OnViewVideoParticpantNames() 
{
   if (m_pConfRoom)
   {
      VARIANT_BOOL bVisible = FALSE;
      m_pConfRoom->get_bShowNames(&bVisible);
      m_pConfRoom->put_bShowNames(!bVisible);
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfRoom::OnUpdateViewVideoParticpantNames(CCmdUI* pCmdUI) 
{
   if (m_pConfRoom)
   {
      VARIANT_BOOL bVisible = FALSE;
      m_pConfRoom->get_bShowNames(&bVisible);
      pCmdUI->SetCheck(bVisible);
      pCmdUI->Enable(TRUE);
   }
   else
      pCmdUI->Enable(FALSE);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfRoom::OnViewVideoLarge() 
{
   if (m_pConfRoom)
   {
      short nSize;
      m_pConfRoom->get_MemberVideoSize(&nSize);
      if (nSize == EXPLORERCONFROOM_VIDEO_SIZE_LARGE)
      {
         m_pConfRoom->put_MemberVideoSize(EXPLORERCONFROOM_VIDEO_SIZE_SMALL);
      }
      else if (nSize == EXPLORERCONFROOM_VIDEO_SIZE_SMALL)
      {
         m_pConfRoom->put_MemberVideoSize(EXPLORERCONFROOM_VIDEO_SIZE_LARGE);
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfRoom::OnUpdateViewVideoLarge(CCmdUI* pCmdUI) 
{
   if (m_pConfRoom)
   {
      short nSize;
      m_pConfRoom->get_MemberVideoSize(&nSize);
      pCmdUI->SetCheck((nSize == EXPLORERCONFROOM_VIDEO_SIZE_LARGE)?TRUE:FALSE);
      pCmdUI->Enable(TRUE);
   }
   else
      pCmdUI->Enable(FALSE);
}

void CMainExplorerWndConfRoom::OnSize(UINT nType, int cx, int cy) 
{
	CMainExplorerWndBase::OnSize(nType, cx, cy);

	CWnd* pWnd = GetDlgItem(IDW_CONFROOM_TREEVIEW);
	if ( (pWnd) && (::IsWindow(pWnd->GetSafeHwnd())) )
	{
		CRect rect;
		GetClientRect(rect);
		pWnd->SetWindowPos(NULL,rect.left,rect.top,rect.Width(),rect.Height(),SWP_NOOWNERZORDER|SWP_SHOWWINDOW);
	}
}

void CMainExplorerWndConfRoom::OnDestroy() 
{
   if (m_pConfRoom)
   {
      m_pConfRoom->UnShow();
      m_pConfRoom->Release();
      m_pConfRoom = NULL;
   }

	CMainExplorerWndBase::OnDestroy();
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CMainExplorerWndConfRoomDetailsWnd
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
CMainExplorerWndConfRoomDetailsWnd::CMainExplorerWndConfRoomDetailsWnd()
{
}

/////////////////////////////////////////////////////////////////////////////
CMainExplorerWndConfRoomDetailsWnd::~CMainExplorerWndConfRoomDetailsWnd()
{
}

/////////////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CMainExplorerWndConfRoomDetailsWnd, CWnd)
	//{{AFX_MSG_MAP(CMainExplorerWndConfRoomDetailsWnd)
	ON_WM_SIZE()
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfRoomDetailsWnd::OnSize(UINT nType, int cx, int cy) 
{
	CWnd::OnSize(nType, cx, cy);

	CWnd* pWnd = GetDlgItem(IDW_CONFROOM);
	if ( (pWnd) && (::IsWindow(pWnd->GetSafeHwnd())) )
	{
		CRect rect;
		GetClientRect(rect);
		pWnd->SetWindowPos(NULL,rect.left,rect.top,rect.Width(),rect.Height(),SWP_NOOWNERZORDER|SWP_SHOWWINDOW);
	}
}


/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\cctrlwnd.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "MainFrm.h"
#include "callctrlwnd.h"
#include "SpeedDlgs.h"
#include "sound.h"
#include "util.h"
#include "avtrace.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#define CALLCONTROL_APPTOOLBAR_IMAGES_COUNT  6
enum
{
   CALLCONTROL_APPTOOLBAR_IMAGE_TOUCHTONE=0,
   CALLCONTROL_APPTOOLBAR_IMAGE_VCARD,
   CALLCONTROL_APPTOOLBAR_IMAGE_DESKTOPPAGE,
   CALLCONTROL_APPTOOLBAR_IMAGE_CHAT,
   CALLCONTROL_APPTOOLBAR_IMAGE_WHITEBOARD,
   CALLCONTROL_APPTOOLBAR_IMAGE_ADDTOSPEEDDIAL,
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CCallControlWnd
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
IMPLEMENT_DYNAMIC(CCallControlWnd,CCallWnd)

/////////////////////////////////////////////////////////////////////////////
CCallControlWnd::CCallControlWnd()
{
   m_pCallManager = NULL;
   m_hwndAppToolbar = NULL;
}

void CCallControlWnd::SetCallManager( CActiveCallManager* pManager,WORD nCallId )
{
   m_pCallManager = pManager;
   m_pDialerDoc = pManager->m_pDialerDoc;
   m_nCallId = nCallId;
}


BEGIN_MESSAGE_MAP(CCallControlWnd, CCallWnd)
	//{{AFX_MSG_MAP(CCallControlWnd)
   ON_COMMAND(ID_CALLWINDOW_TOUCHTONE,OnCallWindowTouchTone)
   ON_COMMAND(ID_CALLWINDOW_ADDTOSPEEDDIAL,OnCallWindowAddToSpeedDial)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
   ON_MESSAGE(WM_SLIDEWINDOW_SETCALLSTATE,OnSetCallState)
   ON_MESSAGE(WM_SLIDEWINDOW_SETCALLERID,OnSetCallerId)
   ON_MESSAGE(WM_SLIDEWINDOW_SETMEDIATYPE,OnSetMediaType)
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
void CCallControlWnd::DoDataExchange(CDataExchange* pDX)
{
	CCallWnd::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CCallControlWnd)
	DDX_Control(pDX, IDC_CALLCONTROL_STATIC_MEDIATEXT, m_staticMediaText);
	DDX_Control(pDX, IDC_CALLCONTROL_ANIMATE_CALLSTATEIMAGE, m_MediaStateAnimateCtrl);
	DDX_Control(pDX, IDC_CALLCONTROL_STATIC_VIDEO, m_wndVideo);
	//}}AFX_DATA_MAP
}

/////////////////////////////////////////////////////////////////////////////
BOOL CCallControlWnd::OnInitDialog()
{
   CCallWnd::OnInitDialog();

   //create the application toolbar
   CreateAppBar();

   // Create the image list for media types
   m_MediaStateImageList.Create(IDB_TERMINATION_STATES, 24,0,RGB_TRANS);

   //CWnd* pStaticWnd = GetDlgItem(IDC_CALLCONTROL_STATIC_MEDIATEXT);
   //ASSERT(pStaticWnd);
   m_staticMediaText.SetFont(&m_fontTextBold);
   //CBrush* m_pbrushBackGround = new CBrush(RGB(20,20,20));
   //::SetClassLong(pStaticWnd->GetSafeHwnd(),GCL_HBRBACKGROUND,(long)m_pbrushBackGround->GetSafeHandle());

   return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
//virtual function of CCallWindow Base Class
void CCallControlWnd::DoActiveWindow(BOOL bActive)
{
   m_staticMediaText.SetFocusState(bActive);
   SetPreviewWindow();
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CCallControlWnd::OnSetCallerId(WPARAM wParam,LPARAM lParam)
{
   ASSERT(lParam);
   LPTSTR szCallerId = (LPTSTR)lParam;

   m_sCallerId = szCallerId;
   
   CWnd* pStaticWnd = GetDlgItem(IDC_CALLCONTROL_STATIC_CALLERID);
   ASSERT(pStaticWnd);
   pStaticWnd->SetWindowText(szCallerId);

   CString sToken,sText,sOut,sCallerId = szCallerId;

   GetMediaText(sText);
   
   ParseToken(sCallerId,sToken,'\n');

   sOut.Format(_T("%s - %s"),sText,sToken);
   SetWindowText(sOut);

   delete szCallerId;

   return 9;
}

/////////////////////////////////////////////////////////////////////////////
LRESULT CCallControlWnd::OnSetMediaType(WPARAM wParam,LPARAM lParam)
{ 
   CallManagerMedia cmm = (CallManagerMedia)lParam;
   m_MediaType = cmm; 
   CString sText;
   GetMediaText(sText);
   m_staticMediaText.SetWindowText(sText);
   return 0;
}

/////////////////////////////////////////////////////////////////////////////
void CCallControlWnd::GetMediaText(CString& sText) 
{ 
   switch(m_MediaType)
   {
	  case CM_MEDIA_MCCONF:
		   sText.LoadString( IDS_MCCONF );
         break;
      case CM_MEDIA_INTERNET:
         sText.LoadString( IDS_NETCALL );
         break;
      case CM_MEDIA_POTS:
         sText.LoadString( IDS_PHONECALL );
         break;
   }
}

/////////////////////////////////////////////////////////////////////////////
void CCallControlWnd::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
   // Paint state bitmap if necessary
   CRect rc;
   GetDlgItem(IDC_CALLCONTROL_ANIMATE_CALLSTATEIMAGE)->GetWindowRect( &rc );
   ScreenToClient( &rc );

   RECT rcIns;
   if ( IntersectRect(&rcIns, &rc, &dc.m_ps.rcPaint) )
      DrawMediaStateImage( &dc, rc.left, rc.top );

   Paint( dc );
}

/////////////////////////////////////////////////////////////////////////////
//This draws the static media state images.  Please be careful not to have the same
//state draw an animated state as well.  See OnSetCallState.
void CCallControlWnd::DrawMediaStateImage(CDC* pDC,int x,int y)
{
   switch (m_MediaState)
   {
      case CM_STATES_DISCONNECTED:
         m_MediaStateImageList.Draw(pDC,MEDIASTATE_IMAGE_DISCONNECTED,CPoint(x,y),ILD_TRANSPARENT);
         break;
      case CM_STATES_UNAVAILABLE:
         m_MediaStateImageList.Draw(pDC,MEDIASTATE_IMAGE_UNAVAILABLE,CPoint(x,y),ILD_TRANSPARENT);
         break;
      case CM_STATES_BUSY:
         m_MediaStateImageList.Draw(pDC,MEDIASTATE_IMAGE_UNAVAILABLE,CPoint(x,y),ILD_TRANSPARENT);
         break;
   }
}

/////////////////////////////////////////////////////////////////////////////
bool CCallControlWnd::CreateAppBar()
{
   TBBUTTON tbb[3];
   tbb[0].iBitmap = CALLCONTROL_APPTOOLBAR_IMAGE_TOUCHTONE;
	tbb[0].idCommand = ID_CALLWINDOW_TOUCHTONE;
	tbb[0].fsState = TBSTATE_ENABLED;
	tbb[0].fsStyle = TBSTYLE_BUTTON;
	tbb[0].dwData = 0;
	tbb[0].iString = 0;
   tbb[1].iBitmap = CALLCONTROL_APPTOOLBAR_IMAGE_ADDTOSPEEDDIAL;
	tbb[1].idCommand = ID_CALLWINDOW_ADDTOSPEEDDIAL;
	tbb[1].fsState = TBSTATE_ENABLED;
	tbb[1].fsStyle = TBSTYLE_BUTTON;
	tbb[1].dwData = 0;
	tbb[1].iString = 0;
   tbb[2].iBitmap = CALLCONTROL_APPTOOLBAR_IMAGE_VCARD;
	tbb[2].idCommand = ID_CALLWINDOW_VCARD;
	tbb[2].fsState = TBSTATE_ENABLED;
	tbb[2].fsStyle = TBSTYLE_BUTTON;
	tbb[2].dwData = 0;
	tbb[2].iString = 0;

   // Create the toolbar
	DWORD ws = CCS_NORESIZE | CCS_NOPARENTALIGN | WS_CHILD | WS_VISIBLE | TBSTYLE_TOOLTIPS | TBSTYLE_FLAT | CCS_NODIVIDER |TTS_ALWAYSTIP;
   m_hwndAppToolbar = CreateToolbarEx(GetSafeHwnd(),	      // parent window
									ws,								         // toolbar style
									3,					                     // ID for toolbar
									CALLCONTROL_APPTOOLBAR_IMAGES_COUNT,// Number of bitmaps on toolbar
									AfxGetResourceHandle(),	            // Resource instance that has the bitmap
									IDR_CALLWINDOW_MEDIA,	   			// ID for bitmap
									tbb,							            // Button information
#ifndef _MSLITE
									3,                					   // Number of buttons to add to toolbar
#else
                           2,                					   // Number of buttons to add to toolbar
#endif //_MSLITE
									12, 11, 0 ,  0,	   		         // Width and height of buttons/bitmaps
									sizeof(TBBUTTON) );				      // size of TBBUTTON structure

   if (m_hwndAppToolbar)
   {
      CWnd* pStaticWnd = GetDlgItem(IDC_CALLCONTROL_STATIC_APPTOOLBAR);
      ASSERT(pStaticWnd);
      CRect rcAppToolBar;
      pStaticWnd->GetWindowRect(rcAppToolBar);
      ScreenToClient(rcAppToolBar);

      ::SetWindowPos(m_hwndAppToolbar,NULL,rcAppToolBar.left,
                                              rcAppToolBar.top,
                                              rcAppToolBar.Width(),
                                              rcAppToolBar.Height(),
                                              SWP_NOACTIVATE|SWP_NOZORDER);
   }

   return (bool) (m_hwndAppToolbar != NULL);
}


/////////////////////////////////////////////////////////////////////////////
LRESULT CCallControlWnd::OnSetCallState(WPARAM wParam,LPARAM lParam)
{
   if( NULL == ((LPTSTR)lParam) )
       return 0;

   try
   {
      CallManagerStates cms = (CallManagerStates)wParam;
      LPTSTR szStateText = (LPTSTR)lParam;

      //should we use the current state and just change the text
      if (cms == CM_STATES_CURRENT)
      {
         m_sMediaStateText = szStateText;

         CWnd* pStaticWnd = GetDlgItem(IDC_CALLCONTROL_STATIC_CALLSTATE);
         ASSERT(pStaticWnd);
         pStaticWnd->SetWindowText(m_sMediaStateText);

         delete szStateText;
         return 0;
      }

      m_sMediaStateText = szStateText;
      m_MediaState = cms;

      CWnd* pStaticWnd = GetDlgItem(IDC_CALLCONTROL_STATIC_CALLSTATE);
      ASSERT(pStaticWnd);
      pStaticWnd->SetWindowText(m_sMediaStateText);

      
      AVTRACE(_T("Set Call State %d"),cms);

      //clear any current sounds
      ActiveClearSound();

      UINT nIDA = 0, nIDS = 0;
      UINT nPlayFlags = SND_ASYNC | SND_LOOP;

      switch ( cms )
      {
         // -------------------------------------------------------- Dialing
         case CM_STATES_DIALING:
   			nIDA = IDR_AVI_ANIMATION_CONNECTING;

            //if we can, let's show the preview window
            SetPreviewWindow();

            break;

         // -------------------------------------------------------- Ringing
         case CM_STATES_RINGING:
            //nIDS = IDS_SOUNDS_OUTGOINGCALL;
            nIDA = IDR_AVI_ANIMATION_RINGING;

            //if we can, let's show the preview window
            SetPreviewWindow();

            break;

         // -------------------------------------------------------- Offering
		   case CM_STATES_OFFERING:
            nIDS = IDS_SOUNDS_INCOMINGCALL;
            nIDA = IDR_AVI_ANIMATION_RINGING;

            //if we can, let's show the preview window
            SetPreviewWindow();

            break;

         // -------------------------------------------------------- Holding
         case CM_STATES_HOLDING:
            nIDA = IDR_AVI_ANIMATION_HOLDING;
            //nIDS = IDS_SOUNDS_HOLDING;
            break;

         // -------------------------------------------------------- RequestHold
         case CM_STATES_REQUESTHOLD:
            nIDA = IDR_AVI_ANIMATION_REQUEST;
            break;

         // -------------------------------------------------------- Leaving Message
         case CM_STATES_LEAVINGMESSAGE:
            nIDA = IDR_AVI_ANIMATION_REQUEST;
            break;
      
         // -------------------------------------------------------- Disconnected
         case CM_STATES_DISCONNECTED:
         {
            //nIDS = IDS_SOUNDS_CALLDISCONNECTED;
		   nPlayFlags &= ~SND_LOOP;

            m_bPaintVideoPlaceholder = TRUE;

            //set the media window
            SetMediaWindow();

            CRect rcVideo;
            m_wndVideo.GetWindowRect(rcVideo);
            ScreenToClient(rcVideo);
            InvalidateRect(rcVideo);

            break;
         }

		  // -------------------------------------------------------- Connecting
		  case CM_STATES_CONNECTING:
			nIDA = IDR_AVI_ANIMATION_CONNECTING;
			break;

         // -------------------------------------------------------- Connected
         case CM_STATES_CONNECTED:
            nIDA = IDR_AVI_ANIMATION_CONNECTED;
            //nIDS = IDS_SOUNDS_CALLCONNECTED;
  
            //get caps of call
            {
               //we will assume that we do not have video and wait for the 
               m_dibVideoImage.DeleteObject();

               //Do Palette realization on 256 color bitmap.  
               m_dibVideoImage.Load(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDB_VIDEO_AUDIO_ONLY1));
               //m_bAllowDrag = FALSE;
               m_bPaintVideoPlaceholder = TRUE;

               //if we can, let's show the preview window
               SetPreviewWindow();
       
               CRect rcVideo;
               m_wndVideo.GetWindowRect(rcVideo);
               ScreenToClient(rcVideo);
               InvalidateRect(rcVideo);
            }
            break;
      }

      // ------------------------------------------------- Play animations
      m_MediaStateAnimateCtrl.Stop();
      if ( nIDA )
      {
         m_MediaStateAnimateCtrl.Open( nIDA );
         m_MediaStateAnimateCtrl.Play(0,-1,-1);
         m_MediaStateAnimateCtrl.ShowWindow( SW_SHOW );
      }
      else
      {
         // Show state in this case  
         m_MediaStateAnimateCtrl.ShowWindow( SW_HIDE );

         CRect rc;
         GetDlgItem(IDC_CALLCONTROL_ANIMATE_CALLSTATEIMAGE)->GetWindowRect( &rc );
         ScreenToClient( &rc );
         InvalidateRect( &rc );
      }

      // ---------------------------------------------------- Play Sound
      if ( nIDS )
      {
          // --- BUG416970 ---
         CString sSound;
         sSound.LoadString(nIDS);
         BOOL bPlayPhone = FALSE;
         if( m_pAVTapi2 != NULL )
         {
             BOOL bUSBPresent = FALSE;
             m_pAVTapi2->USBIsPresent( &bUSBPresent );
             BOOL bUSBCheckbox = FALSE;
             m_pAVTapi2->USBGetDefaultUse( &bUSBCheckbox );
             if ( bUSBPresent && bUSBCheckbox )
             {
                 bPlayPhone = TRUE;
             }
         }

         if( !bPlayPhone )
         {
            ActivePlaySound(sSound, szSoundDialer, nPlayFlags );
         }
      }
      else
      {
          // --- BUG416970 ---
            ActivePlaySound(NULL, szSoundDialer, SND_SYNC );
         //}
      }

      // Invalidate the regions
      
      delete szStateText;

   }
   catch  (...)
   {
      AVTRACE(_T("ASSERT in CCallControlWnd::OnSetCallState()"));
      ASSERT(0);
   }
   
   return 0;
}

/////////////////////////////////////////////////////////////////////////////
void CCallControlWnd::SetMediaWindow()
{
   if ( m_pCallManager )
      m_pCallManager->ShowMedia(m_nCallId, GetCurrentVideoWindow(), TRUE );
}

/////////////////////////////////////////////////////////////////////////////
void CCallControlWnd::SetPreviewWindow()
{
   //if we can, let's show the preview window
   if (m_pCallManager)
      m_pCallManager->SetPreviewWindow(m_nCallId);
}

void CCallControlWnd::OnNotifyStreamStart()
{
	CCallWnd::OnNotifyStreamStart();

	SetMediaWindow();
}

void CCallControlWnd::OnNotifyStreamStop()
{
   if ( m_pCallManager )
      m_pCallManager->ShowMedia(m_nCallId, GetCurrentVideoWindow(), FALSE );

	CCallWnd::OnNotifyStreamStop();
}

/////////////////////////////////////////////////////////////////////////////
void CCallControlWnd::OnCallWindowTouchTone()
{
   if (m_pDialerDoc)
      m_pDialerDoc->CreatePhonePad(this);
}

/////////////////////////////////////////////////////////////////////////////
void CCallControlWnd::OnCallWindowAddToSpeedDial()
{
   CSpeedDialAddDlg dlg;

   // Setup dialog data
   dlg.m_CallEntry.m_MediaType = DIALER_MEDIATYPE_UNKNOWN;
   if (m_pDialerDoc)
   {
      m_pDialerDoc->GetCallMediaType(m_nCallId,dlg.m_CallEntry.m_MediaType);
   }

   //get caller id and break out the displayname and address
   CString sCallerId = m_sCallerId;
   ParseToken(sCallerId,dlg.m_CallEntry.m_sDisplayName,'\n');
   
   if (dlg.m_CallEntry.m_MediaType == DIALER_MEDIATYPE_POTS)
      dlg.m_CallEntry.m_lAddressType = LINEADDRESSTYPE_PHONENUMBER;
   else if (dlg.m_CallEntry.m_MediaType == DIALER_MEDIATYPE_INTERNET)
      dlg.m_CallEntry.m_lAddressType = LINEADDRESSTYPE_IPADDRESS;
   else if (dlg.m_CallEntry.m_MediaType == DIALER_MEDIATYPE_CONFERENCE)
      dlg.m_CallEntry.m_lAddressType = LINEADDRESSTYPE_SDP;
   else
      dlg.m_CallEntry.m_lAddressType = LINEADDRESSTYPE_IPADDRESS;
   
   ParseToken(sCallerId,dlg.m_CallEntry.m_sAddress,'\n');

   EnableWindow(FALSE);

   // Show the dialog and add if user says is okay
   if ( dlg.DoModal() == IDOK )
      CDialerRegistry::AddCallEntry(FALSE,dlg.m_CallEntry);

   EnableWindow(TRUE);
}

/////////////////////////////////////////////////////////////////////////////
//for drag/drop of sliders to left/right sides of desktop
//we must define our own area for context and return true if we within 
//that area
BOOL CCallControlWnd::IsMouseOverForDragDropOfSliders(CPoint& point)
{
   //check if we are trying to move sliders.  We will use the caption text window
   //for context
   CWnd* pCaptionWnd = GetDlgItem(IDC_CALLCONTROL_STATIC_MEDIATEXT);
   if (pCaptionWnd == NULL) return FALSE;

   //get context area
   CRect rcCaption;
   pCaptionWnd->GetWindowRect(rcCaption);
   ScreenToClient(rcCaption);
  
   return rcCaption.PtInRect(point);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Context Menu Support
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CCallControlWnd::OnContextMenu(CMenu* pMenu) 
{
	// Only add the separator if there are other menu items already in the menu
	if ( pMenu->GetMenuItemCount() > 0 )
		pMenu->AppendMenu(MF_SEPARATOR);

	//Use tooltip for command for text in context menu
	CString sFullText,sText;

	APPEND_PMENU_STRING( ID_CALLWINDOW_TOUCHTONE );
	APPEND_PMENU_STRING( ID_CALLWINDOW_ADDTOSPEEDDIAL );

#ifndef _MSLITE
	APPEND_PMENU_STRING( ID_CALLWINDOW_VCARD );
#endif //_MSLITE
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\confservwnd.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// MainExplorerWndConfServices.h : header file
/////////////////////////////////////////////////////////////////////////////
#if !defined(AFX_MAINEXPLORERWNDCONFSERVICES_H__3A58E18D_440B_11D1_B6E7_0800170982BA__INCLUDED_)
#define AFX_MAINEXPLORERWNDCONFSERVICES_H__3A58E18D_440B_11D1_B6E7_0800170982BA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "mainexpwnd.h"

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// CMainExplorerWndConfServices window
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
interface IConfExplorer;
interface IConfRoom;
interface IConfExplorerDetailsView;
interface IConfExplorerTreeView;

class CMainExplorerWndConfServices : public CMainExplorerWndBase
{
// Construction
public:
	CMainExplorerWndConfServices();

// Attributes
public:
   CTreeCtrl                     m_treeCtrl;
   CListCtrl                     m_listCtrl;

protected:
   IConfExplorer*                m_pConfExplorer;
   IConfExplorerDetailsView*     m_pConfDetailsView;
   IConfExplorerTreeView*        m_pConfTreeView;

// Operations
public:
   virtual void      Init(CActiveDialerView* pParentWnd);
   virtual void      PostTapiInit();
   virtual void      Refresh();

//Inlines
protected:
   inline void       ColumnCMDUI(CCmdUI* pCmdUI,short col)
   {
      if (m_pConfDetailsView)
      {
         long nSortColumn=0;
         if (SUCCEEDED(m_pConfDetailsView->get_nSortColumn(&nSortColumn)))
            pCmdUI->SetRadio( (BOOL) (nSortColumn == (long) col) );
      }
   }


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CMainExplorerWndConfServices)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CMainExplorerWndConfServices();

	// Generated message map functions
protected:
	//{{AFX_MSG(CMainExplorerWndConfServices)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	afx_msg void OnPaint();
	afx_msg void OnDestroy();
	afx_msg void OnTreeWndNotify(NMHDR* pNMHDR, LRESULT* pResult);

	afx_msg void OnButtonReminderSet();
	afx_msg void OnButtonReminderEdit();
	afx_msg void OnUpdateButtonReminderSet(CCmdUI* pCmdUI);
	afx_msg void OnUpdateButtonReminderEdit(CCmdUI* pCmdUI);

	afx_msg void OnButtonServicesRefresh();
	afx_msg void OnButtonServicesAddlocation();
	afx_msg void OnButtonServicesAddilsserver();
	afx_msg void OnButtonServicesRenameilsserver();
	afx_msg void OnButtonServicesDeleteilsserver();
	afx_msg void OnUpdateButtonServicesRefresh(CCmdUI* pCmdUI);
	afx_msg void OnUpdateButtonServicesRenameilsserver(CCmdUI* pCmdUI);
	afx_msg void OnUpdateButtonServicesDeleteilsserver(CCmdUI* pCmdUI);
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_MAINEXPLORERWNDCONFSERVICES_H__3A58E18D_440B_11D1_B6E7_0800170982BA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\coolbar.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
// CCoolBar 1997 Microsoft Systems Journal. 
// If this program works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
// CCoolBar implements coolbars for MFC.
//
#include "StdAfx.h"
#include "CoolBar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

IMPLEMENT_DYNAMIC(CCoolBar, CControlBar)

BEGIN_MESSAGE_MAP(CCoolBar, CControlBar)
	//{{AFX_MSG_MAP(CCoolBar)
	ON_WM_CREATE()
	ON_WM_PAINT()
	ON_WM_ERASEBKGND()
	ON_NOTIFY_REFLECT(RBN_HEIGHTCHANGE, OnHeigtChange)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

CCoolBar::CCoolBar()
{
}

CCoolBar::~CCoolBar()
{
}

//////////////////
// Create coolbar
//
BOOL CCoolBar::Create(CWnd* pParentWnd, DWORD dwStyle,
	DWORD dwAfxBarStyle, UINT nID)
{
	ASSERT_VALID(pParentWnd);   // must have a parent

	// dynamic coolbar not supported
	dwStyle &= ~CBRS_SIZE_DYNAMIC;

	// save the style (this code copied from MFC--probably unecessary)
	m_dwStyle = dwAfxBarStyle;
	if (nID == AFX_IDW_TOOLBAR)
		m_dwStyle |= CBRS_HIDE_INPLACE;

	// MFC requires these:
	dwStyle |= CCS_NODIVIDER|CCS_NOPARENTALIGN;

	// Create the cool bar using style and parent.
	CRect rc;
	rc.SetRectEmpty();
	return CWnd::CreateEx(WS_EX_TOOLWINDOW, REBARCLASSNAME, NULL,
		dwStyle, rc, pParentWnd, nID);
}

//////////////////
// Handle WM_CREATE. Call virtual fn so derived class can create bands.
//
int CCoolBar::OnCreate(LPCREATESTRUCT lpcs)
{
	return CControlBar::OnCreate(lpcs) == -1 ? -1
		: OnCreateBands();	// call pure virtual fn to create bands
}

//////////////////
// Standard UI handler updates any controls in the coolbar.
//
void CCoolBar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	UpdateDialogControls(pTarget, bDisableIfNoHndler);
}

/////////////////
// These two functions are called by MFC to calculate the layout of
// the main frame. Since CCoolBar is not designed to be dynamic, the
// size is always fixed, and the same as the window size. 
//
CSize CCoolBar::CalcDynamicLayout(int nLength, DWORD dwMode)
{
	return CalcFixedLayout(dwMode & LM_STRETCH, dwMode & LM_HORZ);
}

CSize CCoolBar::CalcFixedLayout(BOOL bStretch, BOOL bHorz)
{
	CRect rc;
	GetWindowRect(&rc);
	CSize sz(bHorz && bStretch ? 0x7FFF : rc.Width(),
		!bHorz && bStretch ? 0x7FFF : rc.Height());
	return sz;
}

//////////////////
// Low-level height-changed handler just passes to virtual fn w/nicer args.
//
void CCoolBar::OnHeigtChange(NMHDR* pNMHDR, LRESULT* pRes)
{
	CRect rc;
	GetWindowRect(&rc);
	OnHeightChange(rc);
	*pRes = 0; // why not?
}

//////////////////
// Height changed:
// Notify the parent frame by posting a WM_SIZE message. This will cause the
// frame to do RecalcLayout. The message must be posted, not sent, because
// the coolbar could send RBN_HEIGHTCHANGE while the user is sizing, which
// would be in the middle of a CFrame::RecalcLayout, and RecalcLayout doesn't
// let you re-enter it. Posting gurantees that CFrameWnd can finish any recalc
// it may be in the middle of before handling my posted WM_SIZE. Very confusing.
//
void CCoolBar::OnHeightChange(const CRect& rcNew)
{
	CWnd* pParent = GetParent();
	CRect rc;
	pParent->GetWindowRect(&rc);
	pParent->PostMessage(WM_SIZE, 0, MAKELONG(rc.Width(),rc.Height()));
}

void CCoolBar::OnPaint()
{
	Default();	// bypass CControlBar
}

BOOL CCoolBar::OnEraseBkgnd(CDC* pDC)
{
	return (BOOL)Default();  // bypass CControlBar
}

////////////////////////////////////////////////////////////////
// Special tool bar to use in cool bars.
// Mainly, it overides yukky stuff in CToolBar.
//
IMPLEMENT_DYNAMIC(CCoolToolBar, CToolBar)

BEGIN_MESSAGE_MAP(CCoolToolBar, CToolBar)
	ON_WM_NCCREATE()
	ON_WM_NCPAINT()
	ON_WM_PAINT()
	ON_WM_NCCALCSIZE()
END_MESSAGE_MAP()

CCoolToolBar::CCoolToolBar()
{
}

CCoolToolBar::~CCoolToolBar()
{
}

//////////////////
// Make the parent frame my owner. This is important for status bar
// prompts to work. Note that when you create the CCoolToolBar in
// CYourCoolBar::OnCreateBands, you must also set CBRS_FLYBY in the
// the CCoolToolBar style!
//
BOOL CCoolToolBar::OnNcCreate(LPCREATESTRUCT lpcs)
{
	CFrameWnd* pFrame = GetParentFrame();
	ASSERT_VALID(pFrame);
	SetOwner(pFrame);
	return CToolBar::OnNcCreate(lpcs);
}

void CCoolToolBar::OnNcPaint()
{
	Default();	// bypass CToolBar/CControlBar
}

void CCoolToolBar::OnPaint()
{
	Default();	// bypass CToolBar/CControlBar
}

void CCoolToolBar::OnNcCalcSize(BOOL, NCCALCSIZE_PARAMS*)
{
	Default();	// bypass CToolBar/CControlBar
}

////////////////////////////////////////////////////////////////
// The following stuff is to make the command update UI mechanism
// work properly for flat tool bars. The main idea is to convert
// a "checked" button state into a "pressed" button state. Changed 
// lines marked with "PD"

////////////////
// The following class was copied from BARTOOL.CPP in the MFC source.
// All I changed was SetCheck--PD.
//
class CFlatOrCoolBarCmdUI : public CCmdUI // class private to this file !
{
public: // re-implementations only
	virtual void Enable(BOOL bOn);
	virtual void SetCheck(int nCheck);
	virtual void SetText(LPCTSTR lpszText);
};

void CFlatOrCoolBarCmdUI::Enable(BOOL bOn)
{
	m_bEnableChanged = TRUE;
	CToolBar* pToolBar = (CToolBar*)m_pOther;
	ASSERT(pToolBar != NULL);
	ASSERT_KINDOF(CToolBar, pToolBar);
	ASSERT(m_nIndex < m_nIndexMax);
      
   BOOL bRepaint = FALSE;

	UINT nNewStyle = pToolBar->GetButtonStyle(m_nIndex) & ~TBBS_DISABLED;
	if (!bOn)
	{
      if ( (pToolBar->GetButtonStyle(m_nIndex) & TBBS_DISABLED) == FALSE)
      {
         CRect rcItem;
         pToolBar->GetItemRect(m_nIndex,rcItem);   
         pToolBar->InvalidateRect(rcItem);
         pToolBar->UpdateWindow();
         bRepaint = TRUE;
      }

		nNewStyle |= TBBS_DISABLED;
		// WINBUG: If a button is currently pressed and then is disabled
		// COMCTL32.DLL does not unpress the button, even after the mouse
		// button goes up!  We work around this bug by forcing TBBS_PRESSED
		// off when a button is disabled.
		nNewStyle &= ~TBBS_PRESSED;
	}
   else
   {
      if (pToolBar->GetButtonStyle(m_nIndex) & TBBS_DISABLED)
      {
         //Disabled to enabled state doesn't seem to paint correctly
         CRect rcItem;
         pToolBar->GetItemRect(m_nIndex,rcItem);   
         pToolBar->InvalidateRect(rcItem);
         pToolBar->UpdateWindow();
         bRepaint = TRUE;
      }
   }

	ASSERT(!(nNewStyle & TBBS_SEPARATOR));
	pToolBar->SetButtonStyle(m_nIndex, nNewStyle);

   if (bRepaint == TRUE)
   {
      //Disabled to enabled state doesn't seem to paint correctly
      CRect rcItem;
      pToolBar->GetItemRect(m_nIndex,rcItem);   
      pToolBar->InvalidateRect(rcItem);
      pToolBar->UpdateWindow();
   }
}

// Take your pick:
//#define MYTBBS_CHECKED TBBS_CHECKED			// use "checked" state
#define MYTBBS_CHECKED TBBS_PRESSED			// use pressed state

//////////////////
// This is the only function that has changed: instead of TBBS_CHECKED,
// I use TBBS_PRESSED--PD
//
//////////////////
// This is the only function that has changed: instead of TBBS_CHECKED,
// I use TBBS_PRESSED--PD
//
void CFlatOrCoolBarCmdUI::SetCheck(int nCheck)
{
	ASSERT(nCheck >= 0 && nCheck <= 2); // 0=>off, 1=>on, 2=>indeterminate
	CToolBar* pToolBar = (CToolBar*)m_pOther;
	ASSERT(pToolBar != NULL);
	ASSERT_KINDOF(CToolBar, pToolBar);
	ASSERT(m_nIndex < m_nIndexMax);

	UINT nOldStyle = pToolBar->GetButtonStyle(m_nIndex); // PD
	UINT nNewStyle = nOldStyle &
				~(MYTBBS_CHECKED | TBBS_INDETERMINATE); // PD
	if (nCheck == 1)
		nNewStyle |= MYTBBS_CHECKED; // PD
	else if (nCheck == 2)
		nNewStyle |= TBBS_INDETERMINATE;

	// Following is to fix display bug for TBBS_CHECKED:
	// If new state is unchecked, repaint--but only if style actually changing.
	// (Otherwise will end up with flicker)
	// 
	if (nNewStyle != nOldStyle) {
		ASSERT(!(nNewStyle & TBBS_SEPARATOR));
		pToolBar->SetButtonStyle(m_nIndex, nNewStyle);
		pToolBar->Invalidate();
	}
}

void CFlatOrCoolBarCmdUI::SetText(LPCTSTR)
{
	// ignore for now, but you should really set the text
}

//////////////////
// This function is mostly copied from CToolBar/BARTOOL.CPP. The only thing
// that's different is I instantiated a CFlatOrCoolBarCmdUI instead of
// CToolCmdUI.
//
void CCoolToolBar::OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler)
{
	CFlatOrCoolBarCmdUI state; // this is the only line that's different--PD
	state.m_pOther = this;

	state.m_nIndexMax = (UINT)DefWindowProc(TB_BUTTONCOUNT, 0, 0);
	for (state.m_nIndex = 0; state.m_nIndex < state.m_nIndexMax; state.m_nIndex++)
	{
		// get button state
		TBBUTTON button;
		VERIFY(DefWindowProc(TB_GETBUTTON, state.m_nIndex, (LPARAM)&button));
		// TBSTATE_ENABLED == TBBS_DISABLED so invert it
		button.fsState ^= TBSTATE_ENABLED;

		state.m_nID = button.idCommand;

		// ignore separators
		if (!(button.fsStyle & TBSTYLE_SEP))
		{
			// allow the toolbar itself to have update handlers
			if (CWnd::OnCmdMsg(state.m_nID, CN_UPDATE_COMMAND_UI, &state, NULL))
				continue;

			// allow the owner to process the update
			state.DoUpdate(pTarget, bDisableIfNoHndler);
		}
	}

	// update the dialog controls added to the toolbar
	UpdateDialogControls(pTarget, bDisableIfNoHndler);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\cnfservwnd.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// MainExplorerWndConfServices.cpp : implementation file
//

#include "stdafx.h"
#include "avDialer.h"
#include "MainFrm.h"
#include "ConfServWnd.h"

#ifndef _MSLITE
#include "RemindDlgs.h"
#endif _MSLITE

#include "DialReg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
enum
{
   CONFSERVICES_MENU_COLUMN_CONFERENCENAME = 0,
   CONFSERVICES_MENU_COLUMN_DESCRIPTION,
   CONFSERVICES_MENU_COLUMN_START,
   CONFSERVICES_MENU_COLUMN_STOP,
   CONFSERVICES_MENU_COLUMN_OWNER,
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CMainExplorerWndConfServices
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
CMainExplorerWndConfServices::CMainExplorerWndConfServices()
{
   m_pConfExplorer = NULL;
   m_pConfDetailsView = NULL;
   m_pConfTreeView = NULL;
}

/////////////////////////////////////////////////////////////////////////////
CMainExplorerWndConfServices::~CMainExplorerWndConfServices()
{
	RELEASE( m_pConfDetailsView );
	RELEASE( m_pConfTreeView );
	RELEASE( m_pConfExplorer );
}

/////////////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CMainExplorerWndConfServices, CMainExplorerWndBase)
	//{{AFX_MSG_MAP(CMainExplorerWndConfServices)
	ON_WM_CREATE()
	ON_WM_PAINT()
	ON_WM_DESTROY()

	// Notifications
//    ON_NOTIFY(NM_DBLCLK, IDC_CONFERENCESERVICES_VIEWCTRL_DETAILS, OnListWndDblClk)
    ON_NOTIFY(TVN_SELCHANGED, IDC_CONFERENCESERVICES_TREECTRL_MAIN, OnTreeWndNotify)
	ON_NOTIFY(TVN_SETDISPINFO, IDC_CONFERENCESERVICES_TREECTRL_MAIN, OnTreeWndNotify)
	ON_NOTIFY(TVN_ENDLABELEDIT, IDC_CONFERENCESERVICES_TREECTRL_MAIN, OnTreeWndNotify)

	// Reminders
	ON_COMMAND(ID_BUTTON_REMINDER_SET, OnButtonReminderSet)
	ON_COMMAND(ID_BUTTON_REMINDER_EDIT, OnButtonReminderEdit)
	ON_UPDATE_COMMAND_UI(ID_BUTTON_REMINDER_SET, OnUpdateButtonReminderSet)
	ON_UPDATE_COMMAND_UI(ID_BUTTON_REMINDER_EDIT, OnUpdateButtonReminderEdit)

	// Services menu	
	ON_COMMAND(ID_BUTTON_REFRESH, OnButtonServicesRefresh)
	ON_COMMAND(ID_BUTTON_SERVICES_ADDLOCATION, OnButtonServicesAddlocation)
	ON_COMMAND(ID_BUTTON_SERVICES_ADDILSSERVER, OnButtonServicesAddilsserver)
	ON_COMMAND(ID_BUTTON_SERVICES_RENAMEILSSERVER, OnButtonServicesRenameilsserver)
	ON_COMMAND(ID_BUTTON_SERVICES_DELETEILSSERVER, OnButtonServicesDeleteilsserver)
	ON_UPDATE_COMMAND_UI(ID_BUTTON_REFRESH, OnUpdateButtonServicesRefresh)
	ON_UPDATE_COMMAND_UI(ID_BUTTON_SERVICES_DELETEILSSERVER, OnUpdateButtonServicesDeleteilsserver)
	ON_UPDATE_COMMAND_UI(ID_BUTTON_SERVICES_RENAMEILSSERVER, OnUpdateButtonServicesRenameilsserver)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
int CMainExplorerWndConfServices::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CMainExplorerWndBase::OnCreate(lpCreateStruct) == -1)
		return -1;

	return 0;
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::Init(CActiveDialerView* pParentWnd)
{
   //Let base class have it first
   CMainExplorerWndBase::Init(pParentWnd);
   ASSERT(m_pParentWnd);
   
   //Create tree control and make full window size
	m_treeCtrl.Create(TVS_EDITLABELS|WS_VISIBLE|WS_CHILD,CRect(0,0,0,0),this,IDC_CONFERENCESERVICES_TREECTRL_MAIN);

   //detail view's have to be parents of the main dialer view
   m_listCtrl.Create(WS_CHILD|WS_VISIBLE|LVS_REPORT,CRect(0,0,0,0),m_pParentWnd,IDC_CONFERENCESERVICES_VIEWCTRL_DETAILS);
   m_pParentWnd->SetDetailWindow( &m_listCtrl );
}

void CMainExplorerWndConfServices::PostTapiInit()
{
   //Get Tapi object and register out tree control
   IAVTapi* pTapi = m_pParentWnd->GetTapi();
   if (pTapi)
   {
      if ( (SUCCEEDED(pTapi->get_ConfExplorer(&m_pConfExplorer))) && (m_pConfExplorer) )
      {
         //give parent of treectrl and listctrl to conf explorer
         //it will find appropriate children
         m_pConfExplorer->Show(m_treeCtrl.GetSafeHwnd(),m_listCtrl.GetSafeHwnd());
         m_pConfExplorer->get_DetailsView( &m_pConfDetailsView );
         m_pConfExplorer->get_TreeView( &m_pConfTreeView );
      }

      pTapi->Release();
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::OnDestroy() 
{
	if ( m_pConfExplorer )
		m_pConfExplorer->UnShow();

	// Clean up objects
	RELEASE( m_pConfDetailsView );
	RELEASE( m_pConfTreeView );
	RELEASE( m_pConfExplorer );

	CMainExplorerWndBase::OnDestroy();
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::Refresh() 
{
   //Let base class have it
   CMainExplorerWndBase::Refresh();
   
   //make sure our windows are showing
   m_pParentWnd->SetDetailWindow(&m_listCtrl);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::OnPaint() 
{
	CPaintDC dc(this); // device context for painting
	
   if ( m_treeCtrl.GetSafeHwnd() )
   {
      //set size of tree control to full parent window rect
      CRect rect;
      GetClientRect(rect);
      m_treeCtrl.SetWindowPos(NULL,rect.left,rect.top,rect.Width(),rect.Height(),SWP_NOOWNERZORDER|SWP_SHOWWINDOW);
   }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Button Handlers
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////
// Services menu handlers
//
void CMainExplorerWndConfServices::OnButtonServicesRefresh() 
{
   if (m_pConfDetailsView) m_pConfDetailsView->Refresh();
}

void CMainExplorerWndConfServices::OnButtonServicesAddlocation() 
{
   if ( m_pConfTreeView ) m_pConfTreeView->AddLocation(NULL);
}

void CMainExplorerWndConfServices::OnButtonServicesAddilsserver() 
{
   if (m_pConfTreeView) m_pConfTreeView->AddServer( NULL );
}

void CMainExplorerWndConfServices::OnButtonServicesRenameilsserver() 
{
   if (m_pConfTreeView) m_pConfTreeView->RenameServer();
}

void CMainExplorerWndConfServices::OnButtonServicesDeleteilsserver() 
{
   if (m_pConfTreeView == NULL) return;

   BSTR bstrLocation = NULL,bstrServer = NULL;
   if (SUCCEEDED(m_pConfTreeView->GetSelection(&bstrLocation,&bstrServer)))
   {
      m_pConfTreeView->RemoveServer(bstrLocation,bstrServer);
   }
}

// Update handlers

void CMainExplorerWndConfServices::OnUpdateButtonServicesRefresh(CCmdUI* pCmdUI) 
{
   pCmdUI->Enable((BOOL) (m_pConfDetailsView != NULL));
}

void CMainExplorerWndConfServices::OnUpdateButtonServicesRenameilsserver(CCmdUI* pCmdUI) 
{
   //CanRemoveServer can also be used for renaming ILS Server
   pCmdUI->Enable( ( (m_pConfTreeView) && (m_pConfTreeView->CanRemoveServer() == S_OK) )?TRUE:FALSE);
}

void CMainExplorerWndConfServices::OnUpdateButtonServicesDeleteilsserver(CCmdUI* pCmdUI) 
{
   pCmdUI->Enable( ( (m_pConfTreeView) && (m_pConfTreeView->CanRemoveServer() == S_OK) )?TRUE:FALSE);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Reminder Support
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//Format of the reminders in the registry
//"Server1","Conf Name1","Time1","Server2","Conf Name2","Time2",...
//Server value of NULL is MyNetwork server

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::OnButtonReminderSet() 
{
#ifndef _MSLITE
   USES_CONVERSION;
   BSTR bstrStr = NULL;
   DATE dateStart,dateEnd;
   if ( (SUCCEEDED(m_pConfDetailsView->get_Selection(&dateStart,&dateEnd,&bstrStr))) && (bstrStr) )
   {
      CReminder reminder;
      reminder.m_sConferenceName = OLE2CT(bstrStr);
       
      BSTR bstrLocation = NULL,bstrServer = NULL;
      if (SUCCEEDED(m_pConfTreeView->GetSelection(&bstrLocation,&bstrServer)))
      {
         if (bstrServer) reminder.m_sServer = OLE2CT(bstrServer);

         //get start time of the conference
         COleDateTime dtsConferenceStartTime(dateStart);
         CReminderSetDlg dlg;

         //Check if we already have a reminder set for this selection
         int nReminderIndex=-1;
         if ((nReminderIndex = CDialerRegistry::IsReminderSet(reminder)) != -1)
         {
            //get the reminder time of the one set so we can offer the same in the dialog
            CReminder oldreminder;
            if (CDialerRegistry::GetReminder(nReminderIndex,oldreminder))
            {
               //set duration in dialog and tell dialog to use it
               dlg.m_uDurationMinutes = oldreminder.m_uReminderBeforeDuration;               
               dlg.m_bUseDefaultDurationMinutesOnInit = false;
            }
         }

         if ( (dlg.DoModal() == IDOK) && (dlg.m_bReminderTimeValid == true) )
         {
            //subtract the timespan to get the time of the conference reminder
            reminder.m_dtsReminderTime = dtsConferenceStartTime - dlg.m_dtsReminderTime;
            reminder.m_uReminderBeforeDuration = dlg.m_uDurationMinutes;
            
            //check the validity
            if (reminder.m_dtsReminderTime.GetStatus() != COleDateTimeSpan::valid) return;

            //save the reminder
            CDialerRegistry::AddReminder(reminder);

            //refresh list
            m_listCtrl.Invalidate();
            //we have lost the sel so we cannot do this
            //int nItem = m_listCtrl.GetNextItem(-1,LVNI_FOCUSED);
            //if (nItem != -1)
            //{
            //   m_listCtrl.RedrawItems(nItem,nItem);
            //   m_listCtrl.UpdateWindow();
            //}
         }
      }
   }
#endif //_MSLITE
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::OnUpdateButtonReminderSet(CCmdUI* pCmdUI) 
{
#ifndef _MSLITE
   //Make sure we have a selection
   pCmdUI->Enable( ( (m_pConfDetailsView) && (m_pConfDetailsView->IsConferenceSelected() == S_OK) )?TRUE:FALSE);
#endif _MSLITE
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::OnButtonReminderEdit() 
{
#ifndef _MSLITE
   CWinApp* pApp = AfxGetApp();
   CString sBaseKey,sRegKey;
   sBaseKey.LoadString(IDN_REGISTRY_CONFIRM_BASEKEY);
   sRegKey.LoadString(IDN_REGISTRY_CONFIRM_DELETE_CONFERENCE);

   USES_CONVERSION;
   BSTR bstrStr = NULL;
   DATE dateStart,dateEnd;
   if ( (SUCCEEDED(m_pConfDetailsView->get_Selection(&dateStart,&dateEnd,&bstrStr))) && (bstrStr) )
   {
      CReminder reminder;
      reminder.m_sConferenceName = OLE2CT(bstrStr);
       
      BSTR bstrLocation = NULL,bstrServer = NULL;
      if (SUCCEEDED(m_pConfTreeView->GetSelection(&bstrLocation,&bstrServer)))
      {
         if (bstrServer) reminder.m_sServer = OLE2CT(bstrServer);
         
         //Should we confirm this action
         if (GetProfileInt(sBaseKey,sRegKey,TRUE))
         {
            if (AfxMessageBox(IDS_CONFIRM_REMINDER_CANCEL,MB_YESNO|MB_ICONQUESTION) != IDYES)
               return;
         }

         //delete the reminder
         CDialerRegistry::RemoveReminder(reminder);

         m_listCtrl.Invalidate();
         //we have lost the sel so we cannot do this
         //int nItem = m_listCtrl.GetNextItem(-1,LVNI_FOCUSED);
         //if (nItem != -1)
         //{
         //   m_listCtrl.RedrawItems(nItem,nItem);
         //   m_listCtrl.UpdateWindow();
         //}
      }
   }
#endif //_MSLITE
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::OnUpdateButtonReminderEdit(CCmdUI* pCmdUI) 
{
#ifdef _MSLITE
   return;
#endif //_MSLITE

   //***For now just offer edit reminder to all
   pCmdUI->Enable( ( (m_pConfDetailsView) && (m_pConfDetailsView->IsConferenceSelected() == S_OK) )?TRUE:FALSE);
   return;

   //***I need the OnSelChange for the listctrl to get this portion to work right.

   BOOL bEnable = FALSE;
   if ( (m_pConfDetailsView) && (m_pConfDetailsView->IsConferenceSelected() == S_OK) )
   {
      //get CReminder for this selection
      USES_CONVERSION;
      BSTR bstrStr = NULL;
      DATE dateStart,dateEnd;
      if ( (SUCCEEDED(m_pConfDetailsView->get_Selection(&dateStart,&dateEnd,&bstrStr))) && (bstrStr) )
      {
         CReminder reminder;
         reminder.m_sConferenceName = OLE2CT(bstrStr);
          
         BSTR bstrLocation = NULL,bstrServer = NULL;
         if (SUCCEEDED(m_pConfTreeView->GetSelection(&bstrLocation,&bstrServer)))
         {
            if (bstrServer) reminder.m_sServer = OLE2CT(bstrServer);
            
            //now check if this CReminder that is selected has a reminder set for it
            if (CDialerRegistry::IsReminderSet(reminder) != -1)
            {
               bEnable = TRUE;
            }
         }
      }
   }
   pCmdUI->Enable(bEnable);
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Child Notification
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void CMainExplorerWndConfServices::OnTreeWndNotify(NMHDR* pNMHDR, LRESULT* pResult)
{
   m_treeCtrl.SendMessage( WM_NOTIFY, (WPARAM) pNMHDR->idFrom, (LPARAM) pNMHDR );
}


/*
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Column Support
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::OnViewSortConfName() 
{
   if (m_pConfDetailsView) m_pConfDetailsView->OnColumnClicked(CONFSERVICES_MENU_COLUMN_CONFERENCENAME);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::OnUpdateViewSortConfName(CCmdUI* pCmdUI) 
{
   ColumnCMDUI(pCmdUI,CONFSERVICES_MENU_COLUMN_CONFERENCENAME);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::OnViewSortConfDescription() 
{
   if (m_pConfDetailsView) m_pConfDetailsView->OnColumnClicked(CONFSERVICES_MENU_COLUMN_DESCRIPTION);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::OnUpdateViewSortConfDescription(CCmdUI* pCmdUI) 
{
   ColumnCMDUI(pCmdUI,CONFSERVICES_MENU_COLUMN_DESCRIPTION);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::OnViewSortConfStart() 
{
   if (m_pConfDetailsView) m_pConfDetailsView->OnColumnClicked(CONFSERVICES_MENU_COLUMN_START);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::OnUpdateViewSortConfStart(CCmdUI* pCmdUI) 
{
   ColumnCMDUI(pCmdUI,CONFSERVICES_MENU_COLUMN_START);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::OnViewSortConfStop() 
{
   if (m_pConfDetailsView) m_pConfDetailsView->OnColumnClicked(CONFSERVICES_MENU_COLUMN_STOP);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::OnUpdateViewSortConfStop(CCmdUI* pCmdUI) 
{
   ColumnCMDUI(pCmdUI,CONFSERVICES_MENU_COLUMN_STOP);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::OnViewSortConfOwner() 
{
   if (m_pConfDetailsView) m_pConfDetailsView->OnColumnClicked(CONFSERVICES_MENU_COLUMN_OWNER);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::OnUpdateViewSortConfOwner(CCmdUI* pCmdUI) 
{
   ColumnCMDUI(pCmdUI,CONFSERVICES_MENU_COLUMN_OWNER);
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::OnViewSortAscending() 
{
   //just toggle the column
   if (m_pConfDetailsView)
   {
      VARIANT_BOOL bSortAscending = TRUE;
      if (SUCCEEDED(m_pConfDetailsView->get_bSortAscending(&bSortAscending)))
      {
         //Make sure we are really switching
         if (bSortAscending == FALSE)
         {
            long nSortColumn=0;
            if (SUCCEEDED(m_pConfDetailsView->get_nSortColumn(&nSortColumn)))
               m_pConfDetailsView->OnColumnClicked(nSortColumn);
         }
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::OnUpdateViewSortAscending(CCmdUI* pCmdUI) 
{
   if (m_pConfDetailsView)
   {
      VARIANT_BOOL bSortAscending = TRUE;
      if (SUCCEEDED(m_pConfDetailsView->get_bSortAscending(&bSortAscending)))
         pCmdUI->SetRadio( (BOOL) (bSortAscending == TRUE) );
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::OnViewSortDescending() 
{
   //just toggle the column
   if (m_pConfDetailsView)
   {
      VARIANT_BOOL bSortAscending = TRUE;
      if (SUCCEEDED(m_pConfDetailsView->get_bSortAscending(&bSortAscending)))
      {
         //Make sure we are really switching
         if (bSortAscending == TRUE)
         {
            long nSortColumn=0;
            if (SUCCEEDED(m_pConfDetailsView->get_nSortColumn(&nSortColumn)))
               m_pConfDetailsView->OnColumnClicked(nSortColumn);
         }
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CMainExplorerWndConfServices::OnUpdateViewSortDescending(CCmdUI* pCmdUI) 
{
   if (m_pConfDetailsView)
   {
      VARIANT_BOOL bSortAscending = TRUE;
      if (SUCCEEDED(m_pConfDetailsView->get_bSortAscending(&bSortAscending)))
         pCmdUI->SetRadio( (BOOL) (bSortAscending == FALSE) );
   }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\coolbar.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
// CCoolBar 1997 Microsoft Systems Journal. 
// If this program works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
// Compiles with Visual C++ 5.0 on Windows 95
/////////////////////////////////////////////////////////////////////////////

#ifndef _COOLBAR_H_
#define _COOLBAR_H_

#include <commctrl.h>

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CCoolBar
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CCoolBar : public CControlBar
{
protected:
	DECLARE_DYNAMIC(CCoolBar)

public:
	CCoolBar();
	virtual ~CCoolBar();

	BOOL Create(CWnd* pParentWnd, DWORD dwStyle,
		DWORD dwAfxBarStyle = CBRS_ALIGN_TOP,
		UINT nID = AFX_IDW_TOOLBAR);

	// Message wrappers
	BOOL GetBarInfo(LPREBARINFO lp)
		{ ASSERT(::IsWindow(m_hWnd));
		  return (BOOL)SendMessage(RB_GETBARINFO, 0, (LPARAM)lp); }
	BOOL SetBarInfo(LPREBARINFO lp)
		{ ASSERT(::IsWindow(m_hWnd));
		  return (BOOL)SendMessage(RB_SETBARINFO, 0, (LPARAM)lp); }
	BOOL GetBandInfo(int iBand, LPREBARBANDINFO lp)
		{ ASSERT(::IsWindow(m_hWnd));
		  return (BOOL)SendMessage(RB_GETBANDINFO, iBand, (LPARAM)lp); }
	BOOL SetBandInfo(int iBand, LPREBARBANDINFO lp)
		{ ASSERT(::IsWindow(m_hWnd));
		  return (BOOL)SendMessage(RB_SETBANDINFO, iBand, (LPARAM)lp); }
	BOOL InsertBand(int iWhere, LPREBARBANDINFO lp)
		{ ASSERT(::IsWindow(m_hWnd));
		  return (BOOL)SendMessage(RB_INSERTBAND, (WPARAM)iWhere, (LPARAM)lp); }
	BOOL DeleteBand(int nWhich)
		{ ASSERT(::IsWindow(m_hWnd));
		  return (BOOL)SendMessage(RB_DELETEBAND, (WPARAM)nWhich); }
	int GetBandCount()
		{ ASSERT(::IsWindow(m_hWnd));
		  return (int)SendMessage(RB_GETBANDCOUNT); }
	int GetRowCount()
		{ ASSERT(::IsWindow(m_hWnd));
	     return (int)SendMessage(RB_GETROWCOUNT); }
	int GetRowHeight(int nWhich)
		{ ASSERT(::IsWindow(m_hWnd));
	     return (int)SendMessage(RB_GETROWHEIGHT, (WPARAM)nWhich); }
	BOOL ShowBand(int iBand, BOOL fShow)
		{ ASSERT(::IsWindow(m_hWnd));
		  return (BOOL)SendMessage(RB_SHOWBAND, iBand, (LPARAM)fShow); }

protected:
	// new virtual functions you must/can override
	virtual BOOL OnCreateBands() = 0; // return -1 if failed
	virtual void OnHeightChange(const CRect& rcNew);

	// CControlBar Overrides
	virtual CSize CalcFixedLayout(BOOL bStretch, BOOL bHorz);
	virtual CSize CalcDynamicLayout(int nLength, DWORD nMode);
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);

	// message handlers
	DECLARE_MESSAGE_MAP()
	afx_msg int  OnCreate(LPCREATESTRUCT lpcs);
	afx_msg void OnPaint();
	afx_msg void OnHeigtChange(NMHDR* pNMHDR, LRESULT* pRes);
	afx_msg BOOL OnEraseBkgnd(CDC* pDC);
};

//////////////////
// Specialized CToolBar fixes display problems in MFC.
//
class CCoolToolBar : public CToolBar {
public:
	CCoolToolBar();
	virtual ~CCoolToolBar();
protected:
	DECLARE_DYNAMIC(CCoolToolBar)
	virtual void OnUpdateCmdUI(CFrameWnd* pTarget, BOOL bDisableIfNoHndler);
	DECLARE_MESSAGE_MAP()
	afx_msg BOOL OnNcCreate(LPCREATESTRUCT lpcs);
	afx_msg void OnNcPaint();
	afx_msg void OnPaint();
	afx_msg void OnNcCalcSize(BOOL, NCCALCSIZE_PARAMS*);
};

//////////////////
// Programmer-friendly REBARINFO initializes itself
//
class CRebarInfo : public REBARINFO {
public:
	CRebarInfo() {
		memset(this, 0, sizeof(REBARINFO));
		cbSize = sizeof(REBARINFO);
	}
};

//////////////////
// Programmer-friendly REBARBANDINFO initializes itself
//
class CRebarBandInfo : public REBARBANDINFO {
public:
	CRebarBandInfo() {
		memset(this, 0, sizeof(REBARBANDINFO));
		cbSize = sizeof(REBARBANDINFO);
	}
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
#endif //_COOLBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\dialerdlg.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// DialerDlg.cpp : implementation file
//

#include "stdafx.h"
#include "avDialer.h"
#include "DialerDlg.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CDialerExitDlg dialog
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
CDialerExitDlg::CDialerExitDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDialerExitDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDialerExitDlg)
	m_bConfirm = FALSE;
	//}}AFX_DATA_INIT
   m_hImageList = NULL;
}

/////////////////////////////////////////////////////////////////////////////
CDialerExitDlg::~CDialerExitDlg()
{
   if ( m_hImageList ) ImageList_Destroy( m_hImageList );
}

/////////////////////////////////////////////////////////////////////////////
void CDialerExitDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDialerExitDlg)
	DDX_Check(pDX, IDC_CHK_DONT, m_bConfirm);
	//}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDialerExitDlg, CDialog)
	//{{AFX_MSG_MAP(CDialerExitDlg)
	ON_WM_PAINT()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
BOOL CDialerExitDlg::OnInitDialog() 
{
   CenterWindow(GetDesktopWindow());

   m_hImageList = ImageList_LoadBitmap(AfxGetInstanceHandle(),MAKEINTRESOURCE(IDB_DIALOG_BULLET),8,0,RGB_TRANS);

   CDialog::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

void CDialerExitDlg::OnPaint() 
{
	CPaintDC dc(this); // device context for painting

   if (m_hImageList == NULL) return;

   //draw bullets
   CWnd* pStaticWnd;
   CRect rect;
   if ((pStaticWnd = GetDlgItem(IDC_DIALER_EXIT_STATIC_BULLET1)) == NULL) return;
   pStaticWnd->GetWindowRect(rect);
   ScreenToClient(rect);
   ImageList_Draw(m_hImageList,0,dc.GetSafeHdc(),rect.left,rect.top,ILD_TRANSPARENT);
   
   if ((pStaticWnd = GetDlgItem(IDC_DIALER_EXIT_STATIC_BULLET2)) == NULL) return;
   pStaticWnd->GetWindowRect(rect);
   ScreenToClient(rect);
   ImageList_Draw(m_hImageList,0,dc.GetSafeHdc(),rect.left,rect.top,ILD_TRANSPARENT);

#ifndef _MSLITE
   if ((pStaticWnd = GetDlgItem(IDC_DIALER_EXIT_STATIC_BULLET3)) == NULL) return;
   pStaticWnd->GetWindowRect(rect);
   ScreenToClient(rect);
   ImageList_Draw(m_hImageList,0,dc.GetSafeHdc(),rect.left,rect.top,ILD_TRANSPARENT);
#endif //_MSLITE
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\dialer.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by avDialer.rc
//
#define IDH_DRIVER_MISSING_STATIC_LIST  1021
#define IDH_OPTIONS_VIDEO_COMBO_DEVICE  1144
#define IDH_OPTIONS_VIDEO_BUTTON_SOURCE 1145
#define IDH_OPTIONS_VIDEO_BUTTON_DISPLAY 1146
#define IDH_OPTIONS_VIDEO_BUTTON_FORMAT 1147
#define IDH_OPTIONS_VIDEO_STATIC_VIDEOFRAME 1148
#define IDH_SPEEDDIAL_ADD_RADIO_NETCALL 1157
#define IDH_SPEEDDIAL_ADD_RADIO_PHONECALL 1158
#define IDH_SPEEDDIAL_ADD_RADIO_MULTICASTCONFERENCE 1159
#define IDH_OPTIONS_VIDEO_CHECK_AUTOPREVIEW 2087
#define IDH_SPEEDDIAL_MORE_LIST_ADDRESSES 3125
#define IDH_SPEEDDIAL_MORE_BUTTON_PLACECALL 3126
#define IDH_SPEEDDIAL_MORE_BUTTON_EDITLIST 3127
#define IDH_SPEEDDIAL_EDIT_BUTTON_MOVEUP 3128
#define IDH_SPEEDDIAL_EDIT_BUTTON_MOVEDOWN 3129
#define IDH_SPEEDDIAL_EDIT_BUTTON_REMOVE 3130
#define IDH_SPEEDDIAL_EDIT_LIST_ENTRIES 3131
#define IDH_SPEEDDIAL_EDIT_BUTTON_EDIT  3135
#define IDH_SPEEDDIAL_EDIT_BUTTON_ADD   3136
#define IDH_SPEEDDIAL_ADD_EDIT_DISPLAYNAME 3201
#define IDH_SPEEDDIAL_ADD_EDIT_ADDRESS  3203
#define IDH_SELECTADDRESS_BUTTON_PLACECALL 1180
#define IDH_SELECTADDRESS_BUTTON_BROWSE 1181
#define IDH_SELECTADDRESS_LISTBOX_NAMES 1182
#define IDH_SELECTADDRESS_LISTCTRL_ADDRESSES 1183
#define IDH_SELECTADDRESS_STATIC_NAMES  1184
#define IDH_SELECTADDRESS_STATIC_ADDRESSES 1185
//This is from TAPIdialer.rc. All new stuff.
#define IDH_EDT_TRUSTEE                 5231
#define IDH_RDO_ADDADMIN                5232
#define IDH_RDO_ADDPARTICIPANT          5233
#define IDH_RDO_ADDEXCLUDE              5234
#define IDH_EDIT_NAME                   5205
#define IDH_EDIT_DESCRIPTION            5206
#define IDH_CHECK_ENCRYPT               5207
#define IDH_EDIT_OWNER                  5208
#define IDH_DTP_STARTDATE               5219
#define IDH_DTP_STARTTIME               5220
#define IDH_DTP_STOPTIME                5221
#define IDH_DTP_STOPDATE                5222
#define IDH_LST_PERMISSIONS             5223
#define IDH_RDO_ADMIN                   5224
#define IDH_RDO_PARTICIPANT             5225
#define IDH_RDO_EXCLUDE                 5226
#define IDH_BTN_ADDACE                  5227
#define IDH_BTN_REMOVEACE				5228
#define IDH_LST_CONFS                   212
#define IDH_CBO_ADDRESS                 204
#define IDH_RDO_POTS                    228
#define IDH_RDO_INTERNET                229
#define IDH_RDO_CONF                    230
#define IDH_CBO_LOCATION                247
#define IDH_BTN_TELEPHONY_CPL           248
#define IDH_LBL_POTS                    240
#define IDH_LBL_INTERNET                241
#define IDH_LBL_CONF                    242
#define IDH_CBO_POTS                    225
#define IDH_CBO_IPTELEPHONY             226
#define IDH_CBO_IPCONF                  227
#define IDH_LBL_CALLTYPE                243
#define IDH_CBO_CALLTYPE                232
#define IDH_LBL_AUDIO_IN                237
#define IDH_LBL_AUDIO_OUT               238
#define IDH_LBL_VIDEO_IN                239
#define IDH_CBO_AUDIO_IN                234
#define IDH_CBO_AUDIO_OUT               235
#define IDH_CBO_VIDEO_IN                236
#define IDH_CHK_VIDEO_OUT               249
#define IDH_LBL_MAX_WINDOWS             250
#define IDH_EDT_MAX_WINDOWS             5240
#define IDH_EDT_NAME                    208
#define IDH_EDT_LOCATION                218
#define	IDH_JOIN_CONFERENCE_JOIN		254
#define	IDH_LAUNCH_MMCPL				259
#define IDH_DIRECTORIES_FIND_USER_EDIT_USER			300
#define IDH_DIRECTORIES_FIND_USER_BUTTON_SEARCH		301
#define IDH_DIRECTORIES_FIND_USER_LB_USERS			302
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\dialerdlg.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// DialerDlg.h : header file
/////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_DIALERDLG_H__BC8E87FB_4BFF_11D1_B6F2_0800170982BA__INCLUDED_)
#define AFX_DIALERDLG_H__BC8E87FB_4BFF_11D1_B6F2_0800170982BA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CDialerExitDlg dialog
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CDialerExitDlg : public CDialog
{
// Construction
public:
	CDialerExitDlg(CWnd* pParent = NULL);   // standard constructor
   ~CDialerExitDlg();

// Dialog Data
	//{{AFX_DATA(CDialerExitDlg)
	enum { IDD = IDD_DIALER_EXIT };
	BOOL	m_bConfirm;
	//}}AFX_DATA


//Attributes
protected:
   HIMAGELIST		m_hImageList;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDialerExitDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDialerExitDlg)
	virtual BOOL OnInitDialog();
	afx_msg void OnPaint();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DIALERDLG_H__BC8E87FB_4BFF_11D1_B6F2_0800170982BA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\dialsel.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// dialsel.h : header file
/////////////////////////////////////////////////////////////////////////////
#if !defined(AFX_DIALSEL_H__277BD259_D88B_11D1_8E36_0800170982BA__INCLUDED_)
#define AFX_DIALSEL_H__277BD259_D88B_11D1_8E36_0800170982BA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#include "tapidialer.h"

class CDirectory;
class CResolveUserObject;
class CCallEntry;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CDialSelectAddressListCtrl window
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CDialSelectAddressListCtrl : public CListCtrl
{
// Construction
public:
	CDialSelectAddressListCtrl();

// Attributes
protected:
   CResolveUserObject*  m_pDisplayObject;
   CDirectory*          m_pDirectory;
   CImageList           m_imageList;
   
// Operations
public:
   void                 Init(CDirectory* pDirectory);
   int                  InsertObject(CResolveUserObject* pUserObject,DialerMediaType dmtMediaType,DialerLocationType dltLocationType);
   void                 FillCallEntry(CCallEntry* pCallEntry);

protected:
   void                 InsertItem(LPCTSTR szStr,UINT uID,int nImage);
   BOOL                 WabPersonFormatString(CString& sOut,UINT attrib,UINT formatid);
   BOOL                 PersonFormatString(CString& sOut,LPCTSTR szData,UINT formatid);

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDialSelectAddressListCtrl)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CDialSelectAddressListCtrl();

	// Generated message map functions
protected:
	//{{AFX_MSG(CDialSelectAddressListCtrl)
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CDialSelectAddress dialog
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CDialSelectAddress : public CDialog
{
// Construction
public:
	CDialSelectAddress(CWnd* pParent = NULL);   // standard constructor
   ~CDialSelectAddress();

// Dialog Data
	//{{AFX_DATA(CDialSelectAddress)
	enum { IDD = IDD_DIAL_SELECTADDRESS };
	CDialSelectAddressListCtrl	m_lcAddresses;
	CListBox	m_lbNames;
	//}}AFX_DATA

//Methods
public:
   void  SetResolveUserObjectList(CObList* pList) { m_pResolveUserObjectList = pList; };
   void  SetCallEntry(CCallEntry* pCallEntry) { m_pCallEntry = pCallEntry; };

//Attributes
protected:
   CObList*       m_pResolveUserObjectList;
   CDirectory*    m_pDirectory;
   CCallEntry*    m_pCallEntry;

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDialSelectAddress)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDialSelectAddress)
   afx_msg BOOL OnHelpInfo(HELPINFO* pHelpInfo);
	afx_msg void OnContextMenu(CWnd* pWnd, CPoint point);
	virtual BOOL OnInitDialog();
	afx_msg void OnSelchangeSelectaddressListboxNames();
	afx_msg void OnSelectaddressButtonPlacecall();
	afx_msg void OnDblclkSelectaddressListctrlAddresses(NMHDR* pNMHDR, LRESULT* pResult);
	afx_msg void OnSelectaddressButtonBrowse();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DIALSEL_H__277BD259_D88B_11D1_8E36_0800170982BA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\dialtoolbar.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

#if !defined(AFX_DIALTOOLBAR_H__0523E90B_40D5_11D1_B6DF_0800170982BA__INCLUDED_)
#define AFX_DIALTOOLBAR_H__0523E90B_40D5_11D1_B6DF_0800170982BA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000
// DialToolBar.h : header file
//

#include "coolbar.h"

/////////////////////////////////////////////////////////////////////////////
// CDialToolBar window

class CDialToolBar : public CCoolToolBar
{
// Construction
public:
	CDialToolBar();

// Attributes
public:
protected:
   CComboBox      m_comboDial;

// Operations
public:
   void           Init();
protected:

// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDialToolBar)
	//}}AFX_VIRTUAL

// Implementation
public:
	virtual ~CDialToolBar();

	// Generated message map functions
protected:
	//{{AFX_MSG(CDialToolBar)
	afx_msg int OnCreate(LPCREATESTRUCT lpCreateStruct);
	//}}AFX_MSG

	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DIALTOOLBAR_H__0523E90B_40D5_11D1_B6DF_0800170982BA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\dialreg.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// DialerRegistry.cpp

#include "stdafx.h"
#include "tapi3.h"
#include "mainfrm.h"

#include "DialReg.h"
#include "util.h"
#include "resource.h"

#define REDIAL_DEFAULT_MAX_ELEMENTS    10
#define REDIAL_DEFAULT_INDEX_VALUE     1
#define SPEEDDIAL_DEFAULT_MAX_ELEMENTS 50

#define REMINDER_DEFAULT_MAX_ELEMENTS  10

CCriticalSection CDialerRegistry::m_csReminderLock;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CDialerRegistry
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#define MAXKEY	(256 * sizeof(TCHAR))

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Redial and Speeddial Methods
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//This can be used genericaly for redial and speeddial
//nIndex is 1 based
//sDisplayName is only given for speeddial entries
BOOL CDialerRegistry::GetCallEntry(int nIndex,BOOL bRedial,CCallEntry& callentry)
{
   BOOL bRet = FALSE;
   try
   {
      callentry.Initialize();    //Init the call entry

      CString sKey,sTemplate;
      if (bRedial)
      {
         sKey.LoadString(IDN_REGISTRY_REDIAL_KEY);
         sTemplate.LoadString(IDN_REGISTRY_REDIAL_ENTRY);
      }
      else
      {
         sKey.LoadString(IDN_REGISTRY_SPEEDDIAL_KEY);
         sTemplate.LoadString(IDN_REGISTRY_SPEEDDIAL_ENTRY);
      }

      CString sMaxKey,sIndexKey;
      DWORD dwMax=0,dwIndex=0;

      if (bRedial)
         GetRedialMaxIndex(sKey,dwMax,dwIndex);
      else
         dwMax = SPEEDDIAL_DEFAULT_MAX_ELEMENTS;

      //cap the list
      if (nIndex > (int)dwMax) return FALSE;

      CString sRedialKey,sRedial,sAddressType;
      sRedialKey.Format(_T("%s%d"),sTemplate,nIndex);
      GetSZRegistryValueEx(sKey,sRedialKey,sRedial.GetBuffer(MAXKEY),MAXKEY,HKEY_CURRENT_USER);
      sRedial.ReleaseBuffer();

      if (!sRedial.IsEmpty())
      {
         CString sMedia;
         ParseRegistryCallEntry(sRedial,sMedia,sAddressType,callentry.m_sAddress,callentry.m_sDisplayName);
         
         //Convert text to Tapi Address Type
         CString sCompare;
         if ( (sCompare.LoadString(IDN_REGISTRY_ADDRTYPE_CONFERENCE)) && 
              (_tcsicmp(sAddressType,sCompare) == 0) )
            callentry.m_lAddressType = LINEADDRESSTYPE_SDP;
         else if ( (sCompare.LoadString(IDN_REGISTRY_ADDRTYPE_SMTP)) && 
                   (_tcsicmp(sAddressType,sCompare) == 0) )
            callentry.m_lAddressType = LINEADDRESSTYPE_EMAILNAME;
         else if ( (sCompare.LoadString(IDN_REGISTRY_ADDRTYPE_MACHINE)) && 
                   (_tcsicmp(sAddressType,sCompare) == 0) )
            callentry.m_lAddressType = LINEADDRESSTYPE_DOMAINNAME;
         else if ( (sCompare.LoadString(IDN_REGISTRY_ADDRTYPE_PHONENUMBER)) && 
                   (_tcsicmp(sAddressType,sCompare) == 0) )
            callentry.m_lAddressType = LINEADDRESSTYPE_PHONENUMBER;
         else if ( (sCompare.LoadString(IDN_REGISTRY_ADDRTYPE_TCPIP)) && 
                   (_tcsicmp(sAddressType,sCompare) == 0) )
            callentry.m_lAddressType = LINEADDRESSTYPE_IPADDRESS;

         callentry.m_MediaType = GetMediaType(sMedia,callentry.m_lAddressType);

         bRet = TRUE;
      }
   }
   catch (...) {}

   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDialerRegistry::AddCallEntry(BOOL bRedial,CCallEntry& callentry)
{
   if (callentry.m_sDisplayName.IsEmpty())
      callentry.m_sDisplayName = callentry.m_sAddress;

   BOOL bFound = FALSE;
   try
   {
      CString sKey,sTemplate;
      if (bRedial)
      {
         sKey.LoadString(IDN_REGISTRY_REDIAL_KEY);
         sTemplate.LoadString(IDN_REGISTRY_REDIAL_ENTRY);
      }
      else
      {
         sKey.LoadString(IDN_REGISTRY_SPEEDDIAL_KEY);
         sTemplate.LoadString(IDN_REGISTRY_SPEEDDIAL_ENTRY);
      }

      DWORD dwMax=0,dwIndex=0;
      if (bRedial)
         GetRedialMaxIndex(sKey,dwMax,dwIndex);
      else
         dwMax = SPEEDDIAL_DEFAULT_MAX_ELEMENTS;

      //check if entry already exists
      int nIndex = 1;
      CCallEntry callentryCompare;
      while (CDialerRegistry::GetCallEntry(nIndex,bRedial,callentryCompare))
      {
         if ( (callentry.m_MediaType == callentryCompare.m_MediaType) &&
              (callentry.m_lAddressType == callentryCompare.m_lAddressType) &&
              (_tcsicmp(callentry.m_sAddress,callentryCompare.m_sAddress) == 0) &&
              (_tcsicmp(callentry.m_sDisplayName,callentryCompare.m_sDisplayName) == 0) )
         {
            bFound = TRUE;
            break;
         }
         nIndex++;
      }

      CString sRedialValue;
      MakeRegistryCallEntry(sRedialValue,callentry);

      //bring all the strings in and save in linked list
      CStringList strList;
      for (int j=1;j<=(int)dwMax;j++)
      {
         CString sRedialKey,sRedial;
         sRedialKey.Format(_T("%s%d"),sTemplate,j);
         GetSZRegistryValueEx(sKey,sRedialKey,sRedial.GetBuffer(MAXKEY),MAXKEY,HKEY_CURRENT_USER);
         sRedial.ReleaseBuffer();
         
         if (sRedial.IsEmpty())  //first blank means we are at the end
            break;

         strList.AddTail(sRedial);
      }

      //write selected string at first position (i is the selected index in list)
      CString sRedialKey;
      sRedialKey.Format(_T("%s%d"),sTemplate,1);
      SetSZRegistryValue(sKey,sRedialKey,sRedialValue,HKEY_CURRENT_USER);

      //rewrite list but not selected string
      POSITION pos = strList.GetHeadPosition();
      int nCurrentIndex = 1;
      int nNewIndex = 2;               //write starting at index 2
      while (pos)
      {
         if ( (bFound == FALSE) || (nCurrentIndex != nIndex) )       //If the selected item don't write again
         {
            CString sRedialKey;
            sRedialKey.Format(_T("%s%d"),sTemplate,nNewIndex);

            CString sValue = strList.GetAt(pos);

            //set the redial entry
            if (sValue.IsEmpty())
               DeleteSZRegistryValue(sKey,sRedialKey);
            else
               SetSZRegistryValue(sKey,sRedialKey,strList.GetAt(pos),HKEY_CURRENT_USER);

            nNewIndex++;
         }
         nCurrentIndex++;
         strList.GetNext(pos);
      }
   }
   catch (...)
   {
      ASSERT(0);
   }

	// Notify the main view that the speed dial list has changed
	if ( !bFound && !bRedial && AfxGetMainWnd() )
		AfxGetMainWnd()->PostMessage( WM_DOCHINT, 0, CActiveDialerDoc::HINT_SPEEDDIAL_ADD );

   return !bFound;
}

BOOL CDialerRegistry::DeleteCallEntry( BOOL bRedial, CCallEntry& callentry )
{
	if (callentry.m_sDisplayName.IsEmpty())
		callentry.m_sDisplayName = callentry.m_sAddress;

	BOOL bFound = FALSE;
	try
	{
		CString sKey,sTemplate;
		if (bRedial)
		{
			sKey.LoadString(IDN_REGISTRY_REDIAL_KEY);
			sTemplate.LoadString(IDN_REGISTRY_REDIAL_ENTRY);
		}
		else
		{
			sKey.LoadString(IDN_REGISTRY_SPEEDDIAL_KEY);
			sTemplate.LoadString(IDN_REGISTRY_SPEEDDIAL_ENTRY);
		}

		DWORD dwMax=0,dwIndex=0;
		if (bRedial)
			GetRedialMaxIndex(sKey,dwMax,dwIndex);
		else
			dwMax = SPEEDDIAL_DEFAULT_MAX_ELEMENTS;

		//check if entry already exists
		int nIndex = 1;
		CCallEntry callentryCompare;
		while (CDialerRegistry::GetCallEntry(nIndex,bRedial,callentryCompare))
		{
			if ( (callentry.m_MediaType == callentryCompare.m_MediaType) &&
				 (callentry.m_lAddressType == callentryCompare.m_lAddressType) &&
				 (_tcsicmp(callentry.m_sAddress,callentryCompare.m_sAddress) == 0) &&
				 (_tcsicmp(callentry.m_sDisplayName,callentryCompare.m_sDisplayName) == 0) )
			{
				bFound = TRUE;
				break;
			}
			nIndex++;
		}

		CString sRedialValue;
		MakeRegistryCallEntry( sRedialValue, callentry );

		//bring all the strings in and save in linked list
		CStringList strList;
		for ( int j = 1; j <= (int) dwMax; j++ )
		{
			CString sRedialKey,sRedial;
			sRedialKey.Format( _T("%s%d"), sTemplate, j );
			GetSZRegistryValueEx( sKey, sRedialKey, sRedial.GetBuffer(MAXKEY), MAXKEY, HKEY_CURRENT_USER );
			DeleteSZRegistryValue(sKey,sRedialKey);
			sRedial.ReleaseBuffer();

			if (sRedial.IsEmpty())  //first blank means we are at the end
				break;

			strList.AddTail(sRedial);
		}

		//write selected string at first position (i is the selected index in list)
		CString sRedialKey;
		POSITION pos = strList.GetHeadPosition();
		int nCurrentIndex = 1;
		int nNewIndex = 2;               //write starting at index 2

		if ( bRedial )
		{
			sRedialKey.Format(_T("%s%d"),sTemplate,1);
			SetSZRegistryValue(sKey,sRedialKey,sRedialValue,HKEY_CURRENT_USER);
		}
		else
		{
			nNewIndex--;
		}

		while (pos)
		{
			if ( bFound && (nCurrentIndex != nIndex) )       //If the selected item don't write again
			{
				CString sRedialKey;
				CString sValue = strList.GetAt( pos );

				sRedialKey.Format( _T("%s%d"), sTemplate, nNewIndex );

				//set the redial entry
				if (sValue.IsEmpty())
					DeleteSZRegistryValue(sKey,sRedialKey);
				else
					SetSZRegistryValue(sKey,sRedialKey,strList.GetAt(pos),HKEY_CURRENT_USER);

				nNewIndex++;
			}

			nCurrentIndex++;
			strList.GetNext(pos);
		}
	}
	catch (...)
	{
	ASSERT(0);
	}

	// Notify the main view that the speed dial list has changed
	if ( bFound && !bRedial && AfxGetMainWnd() )
		AfxGetMainWnd()->PostMessage( WM_DOCHINT, 0, CActiveDialerDoc::HINT_SPEEDDIAL_DELETE );

	return bFound;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDialerRegistry::ReOrder(BOOL bRedial,CObList* pCallEntryList)
{
   CString sKey,sTemplate;
   if (bRedial)
   {
      sKey.LoadString(IDN_REGISTRY_REDIAL_KEY);
      sTemplate.LoadString(IDN_REGISTRY_REDIAL_ENTRY);
   }
   else
   {
      sKey.LoadString(IDN_REGISTRY_SPEEDDIAL_KEY);
      sTemplate.LoadString(IDN_REGISTRY_SPEEDDIAL_ENTRY);
   }

   DWORD dwMax=0,dwIndex=0;
   if (bRedial)
      GetRedialMaxIndex(sKey,dwMax,dwIndex);
   else
      dwMax = SPEEDDIAL_DEFAULT_MAX_ELEMENTS;

   //clear all entries in the registry
   for (int i=1;i<=(int)dwMax;i++)
   {
      CString sRedialKey,sRedial;
      sRedialKey.Format(_T("%s%d"),sTemplate,i);
      GetSZRegistryValueEx(sKey,sRedialKey,sRedial.GetBuffer(MAXKEY),MAXKEY,HKEY_CURRENT_USER);
      sRedial.ReleaseBuffer();
      
      if (!sRedial.IsEmpty())                               //if there exists a value, delete it
         DeleteSZRegistryValue(sKey,sRedialKey);
      else
         break;                                             //quit deleting items
   }

   //write all new entries to the registry
   POSITION pos = pCallEntryList->GetHeadPosition();
   for (i=1;i<=(int)dwMax && pos;i++)
   {
      CCallEntry* pCallEntry = (CCallEntry*)pCallEntryList->GetNext(pos);
      if (pCallEntry)
      {
         CString sRedialValue;
         MakeRegistryCallEntry(sRedialValue,*pCallEntry);   //make the entry

         //write string
         CString sRedialKey;        
         sRedialKey.Format(_T("%s%d"),sTemplate,i);
         SetSZRegistryValue(sKey,sRedialKey,sRedialValue,HKEY_CURRENT_USER);
      }
   }

	// Notify the main view that the speed dial list has changed
	if ( !bRedial && AfxGetMainWnd() )
		AfxGetMainWnd()->PostMessage( WM_DOCHINT, 0, CActiveDialerDoc::HINT_SPEEDDIAL_MODIFY );


   return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
DialerMediaType CDialerRegistry::GetMediaType(LPCTSTR szMedia,long lAddressType)
{
   DialerMediaType retMediaType = DIALER_MEDIATYPE_UNKNOWN;

   //Convert text to Tapi Address Type
   CString sCompare;
   if ( (sCompare.LoadString(IDN_REGISTRY_MEDIATYPE_POTS)) && 
        (_tcsicmp(szMedia,sCompare) == 0) )
      retMediaType = DIALER_MEDIATYPE_POTS;

   //special case where media is internet and addrtype is conference then media is conference.
   //need this special case to handle how tapidialer.dll is interpreting the redial.  We can
   //remove this case if all objects agree on the data in the registry
   else if ( (sCompare.LoadString(IDN_REGISTRY_MEDIATYPE_INTERNET)) && 
             (_tcsicmp(szMedia,sCompare) == 0) )
   {
      if (lAddressType == LINEADDRESSTYPE_SDP)
         retMediaType = DIALER_MEDIATYPE_CONFERENCE;
      else
         retMediaType = DIALER_MEDIATYPE_INTERNET;
   }

   else if ( (sCompare.LoadString(IDN_REGISTRY_MEDIATYPE_CONFERENCE)) && 
             (_tcsicmp(szMedia,sCompare) == 0) )
      retMediaType = DIALER_MEDIATYPE_CONFERENCE;

   return retMediaType;
}

/////////////////////////////////////////////////////////////////////////////
void CDialerRegistry::ParseRegistryCallEntry(LPCTSTR szRedial,CString& sMedia,CString& sAddressType,CString& sAddress,CString& sDisplayName)
{
   CString sEntry = szRedial;
   CString sValue;
   try
   {
      //get media 
      if (ParseTokenQuoted(sEntry,sValue) == FALSE) return;
      sMedia = sValue;

      //get address type
      if (ParseTokenQuoted(sEntry,sValue) == FALSE) return;
      sAddressType = sValue;

      //get address
      ParseTokenQuoted(sEntry,sValue);
      sAddress = sValue;

      //get display name
      sDisplayName = sAddress;            //just give display name the address for now
      ParseTokenQuoted(sEntry,sValue);
      if (!sValue.IsEmpty())
         sDisplayName = sValue;
   }
   catch(...)
   {
   }
}

/////////////////////////////////////////////////////////////////////////////
void CDialerRegistry::MakeRegistryCallEntry(CString& sRedial,CCallEntry& callentry)
{
   //Convert Tapi Address Type to text
   CString sAddressType;
   switch(callentry.m_lAddressType)
   {
      case LINEADDRESSTYPE_SDP:
         sAddressType.LoadString(IDN_REGISTRY_ADDRTYPE_CONFERENCE);
         break;
      case LINEADDRESSTYPE_EMAILNAME:
         sAddressType.LoadString(IDN_REGISTRY_ADDRTYPE_SMTP);
         break;
      case LINEADDRESSTYPE_DOMAINNAME:
         sAddressType.LoadString(IDN_REGISTRY_ADDRTYPE_MACHINE);
         break;
      case LINEADDRESSTYPE_PHONENUMBER:
         sAddressType.LoadString(IDN_REGISTRY_ADDRTYPE_PHONENUMBER);
         break;
      case LINEADDRESSTYPE_IPADDRESS:
         sAddressType.LoadString(IDN_REGISTRY_ADDRTYPE_TCPIP);
         break;

   }

   CString sMedia;
   switch (callentry.m_MediaType)
   {
      case DIALER_MEDIATYPE_POTS:
         sMedia.LoadString(IDN_REGISTRY_MEDIATYPE_POTS);
         break;
      case DIALER_MEDIATYPE_CONFERENCE:
         sMedia.LoadString(IDN_REGISTRY_MEDIATYPE_CONFERENCE);
         break;
      case DIALER_MEDIATYPE_INTERNET:
         sMedia.LoadString(IDN_REGISTRY_MEDIATYPE_INTERNET);
         break;
   }
   sRedial.Format(_T("\"%s\",\"%s\",\"%s\",\"%s\""),sMedia,sAddressType,callentry.m_sAddress,callentry.m_sDisplayName);
}

/////////////////////////////////////////////////////////////////////////////
void CDialerRegistry::GetRedialMaxIndex(LPCTSTR szKey,DWORD& dwMax,DWORD& dwIndex)
{
   //set the defaults
   dwMax = REDIAL_DEFAULT_MAX_ELEMENTS;
   dwIndex = REDIAL_DEFAULT_INDEX_VALUE;
   try
   {
      //first find if already exists in registry
      CString sMaxKey,sIndexKey;
      sMaxKey.LoadString(IDN_REGISTRY_REDIAL_MAX);
      sIndexKey.LoadString(IDN_REGISTRY_REDIAL_INDEX);

      GetSZRegistryValueEx(szKey,sMaxKey,dwMax,HKEY_CURRENT_USER);
      GetSZRegistryValueEx(szKey,sIndexKey,dwIndex,HKEY_CURRENT_USER);

      dwMax = min(dwMax,50);                   //for safety
      dwIndex = min(dwMax, max(1, dwIndex));
   }
   catch (...)
   {
      ASSERT(0);
   }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Directory Services Methods
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//This can be used genericaly for redial and speeddial
BOOL CDialerRegistry::GetDirectoryEntry(int nIndex,int& nLevel,int& nType,int& nState,CString& sServerName,CString& sDisplayName)
{
   BOOL bRet = FALSE;

   try
   {
      CString sKey,sTemplate;
      sKey.LoadString(IDN_REGISTRY_DIRECTORIES_KEY);
      sTemplate.LoadString(IDN_REGISTRY_DIRECTORIES_ENTRY);
      
      CString sEntryKey,sEntry;
      sEntryKey.Format(_T("%s%d"),sTemplate,nIndex);

      GetSZRegistryValueEx(sKey,sEntryKey,sEntry.GetBuffer(MAXKEY),MAXKEY,HKEY_CURRENT_USER);
      sEntry.ReleaseBuffer();
      sEntry.TrimLeft();
      sEntry.TrimRight();

      if (!sEntry.IsEmpty())
      {
         ParseRegistryDirectoryEntry(sEntry,nLevel,nType,nState,sServerName,sDisplayName);
         bRet = TRUE;
      }
   }
   catch (...)
   {
      ASSERT(0);
   }
   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
//Adds new directory entry to the end of the list
BOOL CDialerRegistry::AddDirectoryEntry(int nLevel,int nType,int nState,LPCTSTR szServerName,LPCTSTR szDisplayName)
{
   //look for duplicate entry
   int nIndex = FindDuplicateDirectoryEntry(nLevel,nType,nState,szServerName,szDisplayName);
   if (nIndex > 0) return FALSE;

   CString sNewEntry;
   sNewEntry.Format(_T("\"%d\",\"%d\",\"%d\",\"%s\",\"%s\""),nLevel,nType,nState,szServerName,szDisplayName);

   CString sKey,sTemplate;
   sKey.LoadString(IDN_REGISTRY_DIRECTORIES_KEY);
   sTemplate.LoadString(IDN_REGISTRY_DIRECTORIES_ENTRY);
   
   CString sEntryKey,sEntry;
   nIndex=1;

   //Find last entry in registry
   while (TRUE)
   {
      sEntryKey.Format(_T("%s%d"),sTemplate,nIndex);
      GetSZRegistryValueEx(sKey,sEntryKey,sEntry.GetBuffer(MAXKEY),MAXKEY,HKEY_CURRENT_USER);
      sEntry.ReleaseBuffer();
      sEntry.TrimLeft();
      sEntry.TrimRight();
      if (sEntry.IsEmpty())
      {
         //nothing in this entry spot, so let's take it
         break;
      }
      sEntry = _T("");
      nIndex++;
   }
   sEntryKey.Format(_T("%s%d"),sTemplate,nIndex);
   SetSZRegistryValue(sKey,sEntryKey,sNewEntry,HKEY_CURRENT_USER);
   return TRUE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDialerRegistry::DeleteDirectoryEntry(int nLevel,int nType,int nState,LPCTSTR szServerName,LPCTSTR szDisplayName)
{
   BOOL bRet = FALSE;

   int nFindIndex = FindDuplicateDirectoryEntry(nLevel,nType,nState,szServerName,szDisplayName);

   if (nFindIndex != 0)
   {
      //found an item, let's delete it

      CStringList strList;

      //bring all the strings in and save in linked list
      CString sKey,sTemplate;
      sKey.LoadString(IDN_REGISTRY_DIRECTORIES_KEY);
      sTemplate.LoadString(IDN_REGISTRY_DIRECTORIES_ENTRY);
      CString sEntryKey,sEntry;
      int nIndex=1;
      do 
      {
         sEntryKey.Format(_T("%s%d"),sTemplate,nIndex);
         GetSZRegistryValueEx(sKey,sEntryKey,sEntry.GetBuffer(MAXKEY),MAXKEY,HKEY_CURRENT_USER);
         sEntry.ReleaseBuffer();
         sEntry.TrimLeft();
         sEntry.TrimRight();

         //add all but remove entry
         if ( (nIndex != nFindIndex) && (!sEntry.IsEmpty()) )
            strList.AddTail(sEntry);

         nIndex++;
      } while (!sEntry.IsEmpty());

      //rewrite list
      int nNewIndex=1;
      POSITION pos = strList.GetHeadPosition();
      while (pos)
      {
         CString sValue = strList.GetAt(pos);

         sEntryKey.Format(_T("%s%d"),sTemplate,nNewIndex);
         SetSZRegistryValue(sKey,sEntryKey,sValue,HKEY_CURRENT_USER);

         strList.GetNext(pos);
         nNewIndex++;
      }

      //now delete the next RegKey (ItemX) to put a cap on the list
      sEntryKey.Format(_T("%s%d"),sTemplate,nNewIndex);
      DeleteSZRegistryValue(sKey,sEntryKey,HKEY_CURRENT_USER);

      bRet = TRUE;
   }
   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
//return 0 - not found
//return > 0 - index of duplicate item
int CDialerRegistry::FindDuplicateDirectoryEntry(int nLevel,int nType,int nState,LPCTSTR szServerName,LPCTSTR szDisplayName)
{
   //find first occurence of item
   CString sNewEntry;
   sNewEntry.Format(_T("\"%d\",\"%d\",\"%d\",\"%s\",\"%s\""),nLevel,nType,nState,szServerName,szDisplayName);

   CString sKey,sTemplate;
   sKey.LoadString(IDN_REGISTRY_DIRECTORIES_KEY);
   sTemplate.LoadString(IDN_REGISTRY_DIRECTORIES_ENTRY);
   
   CString sEntryKey,sEntry;
   int nIndex=1;
   do 
   {
      //get next entry
      sEntryKey.Format(_T("%s%d"),sTemplate,nIndex);
      GetSZRegistryValueEx(sKey,sEntryKey,sEntry.GetBuffer(MAXKEY),MAXKEY,HKEY_CURRENT_USER);
      sEntry.ReleaseBuffer();
      sEntry.TrimLeft();
      sEntry.TrimRight();
      if (sEntry.CompareNoCase(sNewEntry) == 0)
      {
         return nIndex;
      }
      nIndex++;
   } while (!sEntry.IsEmpty());
   return 0;
}

/////////////////////////////////////////////////////////////////////////////
void CDialerRegistry::ParseRegistryDirectoryEntry(LPCTSTR szEntry,int& nLevel,int& nType,int& nState,CString& sServerName,CString& sDisplayName)
{
   CString sEntry = szEntry;
   CString sValue;
   try
   {
      //get level
      if (ParseTokenQuoted(sEntry,sValue) == FALSE) return;
      nLevel = _ttoi(sValue);

      //get type
      if (ParseTokenQuoted(sEntry,sValue) == FALSE) return;
      nType = _ttoi(sValue);

      //get state
      if (ParseTokenQuoted(sEntry,sValue) == FALSE) return;
      nState = _ttoi(sValue);
      
      //get servername
      if (ParseTokenQuoted(sEntry,sValue) == FALSE) return;
      sServerName = sValue;

      //get displayname
      ParseTokenQuoted(sEntry,sValue);
      sDisplayName = sValue;
   }
   catch(...)
   {
   }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Reminder Methods
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
BOOL CDialerRegistry::AddReminder(CReminder& reminder)
{
   m_csReminderLock.Lock();

   BOOL bRet = TRUE;

   try
   {
      CWinApp* pApp = AfxGetApp();
      CString sRegKey,sBaseKey;
      sBaseKey.LoadString(IDN_REGISTRY_CONFERENCE_BASEKEY);
      
      //Get max Reminders
      sRegKey.LoadString(IDN_REGISTRY_CONFERENCE_REMINDER_MAX);
      int nMax = pApp->GetProfileInt(sBaseKey,sRegKey,REMINDER_DEFAULT_MAX_ELEMENTS);

      //check if reminder entry already exists
      int nFindIndex = IsReminderSet(reminder);

      CStringList strList;

      //make entry for new reminder
      CString sReminderEntry;
      MakeRegistryReminderEntry(sReminderEntry,reminder);
      strList.AddTail(sReminderEntry);

      //bring all the strings in and save in linked list
      CReminder savereminder;
      int nMaxEntry=1;
      while (GetReminder(nMaxEntry,savereminder))
      {
         //add all but repeat entry (if any repeat)
         if ( (nFindIndex == -1) || (nMaxEntry != nFindIndex) )
         {
            CString sSaveEntry;
            MakeRegistryReminderEntry(sSaveEntry,savereminder);
            strList.AddTail(sSaveEntry);
         }
         nMaxEntry++;
      }

      //get entry template
      CString sTemplate;
      sTemplate.LoadString(IDN_REGISTRY_CONFERENCE_REMINDER_ENTRY);

      //rewrite list
      int nNewIndex=1;
      POSITION pos = strList.GetHeadPosition();
      while (pos)
      {
         CString sValue = strList.GetAt(pos);

         //write to registry
         sRegKey.Format(_T("%s%d"),sTemplate,nNewIndex);
         pApp->WriteProfileString(sBaseKey,sRegKey,sValue);

         strList.GetNext(pos);
         nNewIndex++;
      }

      //now delete the next RegKey (ReminderX) to put a cap on the list
      sRegKey.Format(_T("%s%d"),sTemplate,nNewIndex);
      pApp->WriteProfileString(sBaseKey,sRegKey,NULL);
   }
   catch (...)
   {
      ASSERT(0);
   }

   m_csReminderLock.Unlock();

   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDialerRegistry::GetReminder(int nIndex,CReminder& reminder)
{
   m_csReminderLock.Lock();

   BOOL bRet = FALSE;
   try
   {
      reminder.Initialize();

      CWinApp* pApp = AfxGetApp();
      CString sRegKey,sBaseKey;
      sBaseKey.LoadString(IDN_REGISTRY_CONFERENCE_BASEKEY);
      
      //Get max Reminders
      sRegKey.LoadString(IDN_REGISTRY_CONFERENCE_REMINDER_MAX);
      int nMax = pApp->GetProfileInt(sBaseKey,sRegKey,REMINDER_DEFAULT_MAX_ELEMENTS);

      //cap the list
      if (nIndex > nMax)
      {
         m_csReminderLock.Unlock();
         return FALSE;
      }

      //get entry template
      CString sTemplate;
      sTemplate.LoadString(IDN_REGISTRY_CONFERENCE_REMINDER_ENTRY);

      sRegKey.Format(_T("%s%d"),sTemplate,nIndex);
      CString sReminderEntry = pApp->GetProfileString(sBaseKey,sRegKey,_T(""));
      
      if (!sReminderEntry.IsEmpty())
      {
         if (ParseRegistryReminderEntry(sReminderEntry,reminder))
         {
            CString sTest = reminder.m_dtsReminderTime.Format(_T("\"%#m/%#d/%Y\""));
            sTest = reminder.m_dtsReminderTime.Format(_T("\"%#H:%M\""));
            bRet = TRUE;
         }
      }
   }
   catch (...) {}

   m_csReminderLock.Unlock();

   return bRet;
}

/////////////////////////////////////////////////////////////////////////////
//check if reminder entry already exists
int CDialerRegistry::IsReminderSet(const CReminder& reminder)
{
   m_csReminderLock.Lock();

   int nRet = -1;
   int nFindIndex = 1;

   CReminder reminderCompare;
   while (GetReminder(nFindIndex,reminderCompare))
   {
      if (reminderCompare == reminder)
      {
         nRet = nFindIndex;
         break;
      }
      nFindIndex++;
   }

   m_csReminderLock.Unlock();

   return nRet;
}

/////////////////////////////////////////////////////////////////////////////
void CDialerRegistry::RemoveReminder(CReminder& reminder)
{
   int nFindIndex = IsReminderSet(reminder);
   
   if (nFindIndex == -1) return;                                     //no match found

   m_csReminderLock.Lock();

   CStringList strList;

   //bring all the strings in and save in linked list
   CReminder savereminder;
   int nMaxEntry=1;
   while (GetReminder(nMaxEntry,savereminder))
   {
      //add all but remove entry
      if (nMaxEntry != nFindIndex)
      {
         CString sSaveEntry;
         MakeRegistryReminderEntry(sSaveEntry,savereminder);
         strList.AddTail(sSaveEntry);
      }
      nMaxEntry++;
   }

   //get entry template
   CString sTemplate;
   sTemplate.LoadString(IDN_REGISTRY_CONFERENCE_REMINDER_ENTRY);

   CWinApp* pApp = AfxGetApp();
   CString sBaseKey,sRegKey;
   sBaseKey.LoadString(IDN_REGISTRY_CONFERENCE_BASEKEY);

   //rewrite list
   int nNewIndex=1;
   POSITION pos = strList.GetHeadPosition();
   while (pos)
   {
      CString sValue = strList.GetAt(pos);

      //write to registry
      sRegKey.Format(_T("%s%d"),sTemplate,nNewIndex);
      pApp->WriteProfileString(sBaseKey,sRegKey,sValue);

      strList.GetNext(pos);
      nNewIndex++;
   }

   //now delete the next RegKey (ReminderX) to put a cap on the list
   sRegKey.Format(_T("%s%d"),sTemplate,nNewIndex);
   pApp->WriteProfileString(sBaseKey,sRegKey,NULL);

   m_csReminderLock.Unlock();
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDialerRegistry::ParseRegistryReminderEntry(LPCTSTR szReminderEntry,CReminder& reminder)
{
   CString sEntry = szReminderEntry;
   CString sValue;

   //get server
   if (ParseTokenQuoted(sEntry,sValue) == FALSE) return FALSE;
   reminder.m_sServer = sValue;

   //get conference name
   if (ParseTokenQuoted(sEntry,sValue) == FALSE) return FALSE;
   reminder.m_sConferenceName = sValue;

   //get reminder before duration
   if (ParseTokenQuoted(sEntry,sValue) == FALSE) return FALSE;
   reminder.m_uReminderBeforeDuration = _ttoi(sValue);

   //get conference reminder date/time
   ParseTokenQuoted(sEntry,sValue);

   return reminder.m_dtsReminderTime.ParseDateTime(sValue);
}

/////////////////////////////////////////////////////////////////////////////
//Date/Time Format is 1/13/1998 13:56
void CDialerRegistry::MakeRegistryReminderEntry(CString& sReminderEntry,CReminder& reminder)
{
   sReminderEntry.Format(_T("\"%s\",\"%s\",\"%d\",\"%s\""),
            reminder.m_sServer,
            reminder.m_sConferenceName,
            reminder.m_uReminderBeforeDuration,
            reminder.m_dtsReminderTime.Format(_T("%#m/%#d/%Y %#H:%M")));
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//General Registry Access Methods
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
//Get the preferred audio in/out device for the dialer.  We can use this
//to get a good idea of the device being used during internet calls,
//conference calls, and POTS calls.
void CDialerRegistry::GetAudioDevice(DialerMediaType dmtMediaType,AudioDeviceType adt,CString& sDevice)
{
   //get data out of Dialer\Redial\AddrIP (or AddrPOTS or AddrConf)
   CString sBaseKey,sRegKey;

   if (dmtMediaType == DIALER_MEDIATYPE_INTERNET)
      sBaseKey.LoadString(IDN_REGISTRY_DEVICE_INTERNET_KEY);
   else if (dmtMediaType == DIALER_MEDIATYPE_CONFERENCE)
      sBaseKey.LoadString(IDN_REGISTRY_DEVICE_CONF_KEY);
   else if (dmtMediaType == DIALER_MEDIATYPE_POTS)
      sBaseKey.LoadString(IDN_REGISTRY_DEVICE_POTS_KEY);

   if (adt == AVWAV_AUDIODEVICE_IN)
      sRegKey.LoadString(IDN_REGISTRY_DEVICE_AUDIOIN_ENTRY);
   else if (adt == AVWAV_AUDIODEVICE_OUT)
      sRegKey.LoadString(IDN_REGISTRY_DEVICE_AUDIOOUT_ENTRY);

   if ( (!sBaseKey.IsEmpty()) && (!sRegKey.IsEmpty()) )
   {
      sDevice = AfxGetApp()->GetProfileString(sBaseKey,sRegKey,_T(""));
   }
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

void CCallEntry::Dial( CActiveDialerDoc* pDoc )
{
	ASSERT( pDoc && !m_sAddress.IsEmpty() );
	if ( pDoc && !m_sAddress.IsEmpty() )
		pDoc->Dial( m_sDisplayName, m_sAddress, m_lAddressType, m_MediaType, false );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\dialreg.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//DialerRegistry.h
/////////////////////////////////////////////////////////////////////////////

#ifndef _DIALERREGISTRY_H_
#define _DIALERREGISTRY_H_

#include "tapidialer.h"
#include "cavwav.h"

class CActiveDialerDoc;

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CCallEntry
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CCallEntry : public CObject
{
public:
   CCallEntry()  { Initialize(); }
   void            Initialize()
   {
      m_MediaType = DIALER_MEDIATYPE_UNKNOWN;
      m_LocationType = DIALER_LOCATIONTYPE_UNKNOWN;
      m_lAddressType = 0;
      m_sAddress = _T("");
      m_sDisplayName = _T("");
      m_sUser1 = _T("");
      m_sUser2 = _T("");
   }

   CCallEntry& operator=(const CCallEntry& src)
   {
      this->m_MediaType = src.m_MediaType;
      this->m_LocationType = src.m_LocationType;
      this->m_lAddressType = src.m_lAddressType;
      this->m_sAddress = src.m_sAddress;
      this->m_sDisplayName = src.m_sDisplayName;
      this->m_sUser1 = src.m_sUser1;
      this->m_sUser2 = src.m_sUser2;

	  return *this;
   }

   //Attributes
public:
   DialerMediaType      m_MediaType;
   DialerLocationType   m_LocationType;
   long                 m_lAddressType;
   CString              m_sAddress;
   CString              m_sDisplayName;
   CString              m_sUser1;
   CString              m_sUser2;

// Operations
public:
	void Dial( CActiveDialerDoc* pDoc );
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CReminder
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CReminder : public CObject
{
public:
   CReminder()   { Initialize(); }
   void            Initialize()
   {
      m_sServer = _T("");
      m_sConferenceName = _T("");
      m_uReminderBeforeDuration = 0;
   }
   const bool operator==(const CReminder& reminder)
   {
      if ( (_tcsicmp(reminder.m_sConferenceName,this->m_sConferenceName) == 0) &&
           (_tcsicmp(reminder.m_sServer,this->m_sServer) == 0) )
         return true;
      else
         return false;
   }
   const void operator=(const CReminder& reminder)
   {
      this->m_sServer = reminder.m_sServer;
      this->m_sConferenceName = reminder.m_sConferenceName;
      this->m_uReminderBeforeDuration = reminder.m_uReminderBeforeDuration;
      this->m_dtsReminderTime = reminder.m_dtsReminderTime;
   }
   void       GetConferenceTime(COleDateTime& dtsConfTime)
   {
      COleDateTimeSpan dtsSpan;         
      dtsSpan.SetDateTimeSpan(0,0,m_uReminderBeforeDuration,0);
      dtsConfTime = m_dtsReminderTime + dtsSpan;
   }

   //Attributes
public:
   CString           m_sServer;                    //Server Name
   CString           m_sConferenceName;            //Conference Name
   UINT              m_uReminderBeforeDuration;    //Reminder Before Duration in minutes
   COleDateTime      m_dtsReminderTime;            //Actual time of reminder, not conference start
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Class CDialerRegistry
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CDialerRegistry
{
//Attributes
public:
protected:
   static CCriticalSection m_csReminderLock;

/////////////////////////////////////////////////////////////////////////////
//Redial and Speeddial Methods
/////////////////////////////////////////////////////////////////////////////
public:
   static BOOL             GetCallEntry(int nIndex,BOOL bRedial,CCallEntry& callentry);
   static BOOL             AddCallEntry(BOOL bRedial,CCallEntry& callentry);
   static BOOL			   DeleteCallEntry( BOOL bRedial, CCallEntry& callentry );
   static BOOL             ReOrder(BOOL bRedial,CObList* pCallEntryList);

protected:
   static void             ParseRegistryCallEntry(LPCTSTR szRedial,CString& sMedia,CString& sAddressType,CString& sAddress,CString& sDisplayName);
   static void             MakeRegistryCallEntry(CString& sRedial,CCallEntry& callentry);
   static DialerMediaType  GetMediaType(LPCTSTR szMedia,long lAddressType);
   static void             GetRedialMaxIndex(LPCTSTR szKey,DWORD& dwMax,DWORD& dwIndex);

/////////////////////////////////////////////////////////////////////////////
//Directory Services Methods
/////////////////////////////////////////////////////////////////////////////
public:

   static BOOL             GetDirectoryEntry(int nIndex,int& nLevel,int& nType,int& nState,CString& sServerName,CString& sDisplayName);
   static BOOL             AddDirectoryEntry(int nLevel,int nType,int nState,LPCTSTR szServerName,LPCTSTR szDisplayName);
   static BOOL             DeleteDirectoryEntry(int nLevel,int nType,int nState,LPCTSTR szServerName,LPCTSTR szDisplayName);
protected:
   static void             ParseRegistryDirectoryEntry(LPCTSTR szEntry,int& nLevel,int& nType,int& nState,CString& sServerName,CString& sDisplayName);
   static int              FindDuplicateDirectoryEntry(int nLevel,int nType,int nState,LPCTSTR szServerName,LPCTSTR szDisplayName);

/////////////////////////////////////////////////////////////////////////////
//Reminder Methods
/////////////////////////////////////////////////////////////////////////////
public:
   static BOOL             AddReminder(CReminder& reminder);
   static BOOL             GetReminder(int nIndex,CReminder& reminder);
   static int              IsReminderSet(const CReminder& reminder);
   static void             RemoveReminder(CReminder& reminder);
protected:
   static BOOL             ParseRegistryReminderEntry(LPCTSTR szReminderEntry,CReminder& reminder);
   static void             MakeRegistryReminderEntry(CString& sReminderEntry,CReminder& reminder);

/////////////////////////////////////////////////////////////////////////////
//General Registry Access Methods
/////////////////////////////////////////////////////////////////////////////
public:
   static void             GetAudioDevice(DialerMediaType dmtMediaType,AudioDeviceType adt,CString& sDevice);
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

#endif //_DIALERREGISTRY_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\dialsel.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1998 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////
// dialsel.cpp : implementation file
/////////////////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "resource.h"
#include "dialsel.h"
#include "ds.h"
#include "directory.h"
#include "resolver.h"
#include "dialreg.h"
#include "mainfrm.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
enum 
{
   DSA_ITEM_WAB_NETCALL = 0,
   DSA_ITEM_WAB_CHAT,
   DSA_ITEM_WAB_PHONECALL_BUSINESS,
   DSA_ITEM_WAB_PHONECALL_HOME,
   DSA_ITEM_WAB_CELLCALL,
   DSA_ITEM_WAB_FAXCALL_BUSINESS,
   DSA_ITEM_WAB_FAXCALL_HOME,
   DSA_ITEM_WAB_PAGER,
   DSA_ITEM_WAB_DESKTOPPAGE,
   DSA_ITEM_WAB_EMAIL,
   DSA_ITEM_WAB_BUSINESSHOMEPAGE,
   DSA_ITEM_WAB_PERSONALHOMEPAGE,
   DSA_ITEM_WAB_PERSONALURL,
   DSA_ITEM_DS_NETCALL,
   DSA_ITEM_DS_PHONECALL_BUSINESS,
   DSA_ITEM_ILS_NETCALL,
};

enum 
{
   DSA_IMAGE_NETCALL = 0,
   DSA_IMAGE_CHAT,
   DSA_IMAGE_PHONECALL,
   DSA_IMAGE_CELLCALL,
   DSA_IMAGE_FAXCALL,
   DSA_IMAGE_PAGER,
   DSA_IMAGE_DESKTOPPAGE,
   DSA_IMAGE_EMAIL,
   DSA_IMAGE_PERSONALWEB,
   DSA_IMAGE_PERSONALURL,
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CDialSelectAddress dialog
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
CDialSelectAddress::CDialSelectAddress(CWnd* pParent /*=NULL*/)
    : CDialog(CDialSelectAddress::IDD, pParent)
{
    //{{AFX_DATA_INIT(CDialSelectAddress)
        // NOTE: the ClassWizard will add member initialization here
    //}}AFX_DATA_INIT
   m_pResolveUserObjectList = NULL;
   m_pDirectory = NULL;
   m_pCallEntry = NULL;
}

/////////////////////////////////////////////////////////////////////////////
CDialSelectAddress::~CDialSelectAddress()
{
   if (m_pDirectory)
   {
      delete m_pDirectory;
      m_pDirectory = NULL;
   }
}

/////////////////////////////////////////////////////////////////////////////
void CDialSelectAddress::DoDataExchange(CDataExchange* pDX)
{
    CDialog::DoDataExchange(pDX);
    //{{AFX_DATA_MAP(CDialSelectAddress)
    DDX_Control(pDX, IDC_SELECTADDRESS_LISTCTRL_ADDRESSES, m_lcAddresses);
    DDX_Control(pDX, IDC_SELECTADDRESS_LISTBOX_NAMES, m_lbNames);
    //}}AFX_DATA_MAP
}


BEGIN_MESSAGE_MAP(CDialSelectAddress, CDialog)
    //{{AFX_MSG_MAP(CDialSelectAddress)
   ON_WM_HELPINFO() 
    ON_WM_CONTEXTMENU()
    ON_LBN_SELCHANGE(IDC_SELECTADDRESS_LISTBOX_NAMES, OnSelchangeSelectaddressListboxNames)
    ON_BN_CLICKED(IDC_SELECTADDRESS_BUTTON_PLACECALL, OnSelectaddressButtonPlacecall)
    ON_NOTIFY(NM_DBLCLK, IDC_SELECTADDRESS_LISTCTRL_ADDRESSES, OnDblclkSelectaddressListctrlAddresses)
    ON_BN_CLICKED(IDC_SELECTADDRESS_BUTTON_BROWSE, OnSelectaddressButtonBrowse)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
BOOL CDialSelectAddress::OnHelpInfo(HELPINFO* pHelpInfo)
{
    if (pHelpInfo->iContextType == HELPINFO_WINDOW)
    {
      AfxGetApp()->WinHelp( HandleToUlong(pHelpInfo->hItemHandle), HELP_WM_HELP );
        return TRUE;
   }
   return FALSE;
}

/////////////////////////////////////////////////////////////////////////////////////////
void CDialSelectAddress::OnContextMenu(CWnd* pWnd, CPoint point) 
{
   AfxGetApp()->WinHelp(HandleToUlong(pWnd->GetSafeHwnd()),HELP_CONTEXTMENU);
}

/////////////////////////////////////////////////////////////////////////////////////////
BOOL CDialSelectAddress::OnInitDialog() 
{
   ASSERT(m_pResolveUserObjectList);
   ASSERT(m_pCallEntry);

   CenterWindow(GetDesktopWindow());

   CDialog::OnInitDialog();

   //init wab 
   m_pDirectory = new CDirectory;
   m_pDirectory->Initialize();
   m_lcAddresses.Init(m_pDirectory);

   int nListBoxItems = 0;
   int nListCtrlItems = 0;

   //Walk object list and get names.  First try WAB, then DS, then ILS for name.
   POSITION pos = m_pResolveUserObjectList->GetHeadPosition();
   while (pos)
   {
      CResolveUserObject* pUserObject = (CResolveUserObject*)m_pResolveUserObjectList->GetNext(pos);
      if ( (pUserObject->m_pWABEntry) && (m_pDirectory) )
      {
         CString sName;
         m_pDirectory->WABGetStringProperty(pUserObject->m_pWABEntry,PR_DISPLAY_NAME,sName);
         int nIndex = m_lbNames.AddString(sName);
         if (nIndex != LB_ERR)
         {
            m_lbNames.SetItemDataPtr(nIndex,pUserObject);
         }
         //if first, insert into listctrl
         if (m_lbNames.GetCount() == 1)
            nListCtrlItems = m_lcAddresses.InsertObject(pUserObject,m_pCallEntry->m_MediaType,m_pCallEntry->m_LocationType);
      }
      //check ILS
      else if (pUserObject->m_pILSUser)
      {
         int nIndex = m_lbNames.AddString(pUserObject->m_pILSUser->m_sUserName);
         if (nIndex != LB_ERR)
         {
            m_lbNames.SetItemDataPtr(nIndex,pUserObject);
         }
         //if first, insert into listctrl
         if (m_lbNames.GetCount() == 1)
            nListCtrlItems = m_lcAddresses.InsertObject(pUserObject,m_pCallEntry->m_MediaType,m_pCallEntry->m_LocationType);
      }
      //check DS
      else if (pUserObject->m_pDSUser)
      {
         int nIndex = m_lbNames.AddString(pUserObject->m_pDSUser->m_sUserName);
         if (nIndex != LB_ERR)
         {
            m_lbNames.SetItemDataPtr(nIndex,pUserObject);
         }
         //if first, insert into listctrl
         if (m_lbNames.GetCount() == 1)
            nListCtrlItems = m_lcAddresses.InsertObject(pUserObject,m_pCallEntry->m_MediaType,m_pCallEntry->m_LocationType);
      }
   }

   //set selection to the first
   if (nListCtrlItems > 0)
   {
      m_lcAddresses.SetItemState(0,LVIS_SELECTED|LVIS_FOCUSED,LVIS_SELECTED|LVIS_FOCUSED);
   }

   //get items in listbox
   nListBoxItems = m_lbNames.GetCount();

   //set selection to the first
   if (nListBoxItems > 0)
      m_lbNames.SetCurSel(0);

   //if no items just dismiss and return
   if (nListBoxItems == 0)
      EndDialog(IDOK);
   //if we have only once choice then dial it
   else if ( (nListBoxItems == 1) && (nListCtrlItems == 1) )
   {
      //Place the call
      OnSelectaddressButtonPlacecall();
   }
   else
   {
      //show the dialog
      ShowWindow(SW_SHOW);
   }
   
    return TRUE;  // return TRUE unless you set the focus to a control
                  // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////////////////
void CDialSelectAddress::OnSelchangeSelectaddressListboxNames() 
{
   int nIndex = m_lbNames.GetCurSel();
   if (nIndex != LB_ERR)
   {
      CResolveUserObject* pUserObject = (CResolveUserObject*)m_lbNames.GetItemDataPtr(nIndex);
      ASSERT(pUserObject);
      int nListCtrlItems = m_lcAddresses.InsertObject(pUserObject,m_pCallEntry->m_MediaType,m_pCallEntry->m_LocationType);

      //set selection to the first
      if (nListCtrlItems > 0)
      {
         m_lcAddresses.SetItemState(0,LVIS_SELECTED|LVIS_FOCUSED,LVIS_SELECTED|LVIS_FOCUSED);
      }
   }
}

/////////////////////////////////////////////////////////////////////////////////////////
void CDialSelectAddress::OnSelectaddressButtonBrowse() 
{
    //
    // We should ckeck if the pointer is valid
    //

    CWnd* pMainWnd = AfxGetMainWnd();
   if ( pMainWnd )
   {
      pMainWnd->PostMessage(WM_ACTIVEDIALER_INTERFACE_SHOWEXPLORER);
   }
   EndDialog(IDCANCEL);    
}

/////////////////////////////////////////////////////////////////////////////////////////
//Fill out the callentry structure and return IDOK
void CDialSelectAddress::OnSelectaddressButtonPlacecall() 
{
   ASSERT(m_pCallEntry);

   //get cursel of listbox and get pUserObject that has been selected
   int nIndex = m_lbNames.GetCurSel();
   if (nIndex != LB_ERR)
   {
      CResolveUserObject* pUserObject = (CResolveUserObject*)m_lbNames.GetItemDataPtr(nIndex);
      ASSERT(pUserObject);

      //ask listctrl what it has selected currently
      m_lcAddresses.FillCallEntry(m_pCallEntry);
   }

   EndDialog(IDOK);    
}

/////////////////////////////////////////////////////////////////////////////////////////
void CDialSelectAddress::OnDblclkSelectaddressListctrlAddresses(NMHDR* pNMHDR, LRESULT* pResult) 
{
    OnSelectaddressButtonPlacecall();

    *pResult = 0;
}

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CDialSelectAddressListCtrl
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
CDialSelectAddressListCtrl::CDialSelectAddressListCtrl()
{
   m_pDisplayObject = NULL;
   m_pDirectory = NULL;
}

/////////////////////////////////////////////////////////////////////////////
CDialSelectAddressListCtrl::~CDialSelectAddressListCtrl()
{
}

/////////////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CDialSelectAddressListCtrl, CListCtrl)
    //{{AFX_MSG_MAP(CDialSelectAddressListCtrl)
    //}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
void CDialSelectAddressListCtrl::Init(CDirectory* pDirectory)
{ 
   m_pDirectory = pDirectory;

   m_imageList.Create(IDB_LIST_MEDIA_SMALL,16,0,RGB_TRANS);
   SetImageList(&m_imageList,LVSIL_SMALL);
}

/////////////////////////////////////////////////////////////////////////////
//Inserts pUserObject into ListCtrl
int CDialSelectAddressListCtrl::InsertObject(CResolveUserObject* pUserObject,DialerMediaType dmtMediaType,DialerLocationType dltLocationType)
{
   ASSERT(m_pDirectory);
   m_pDisplayObject = pUserObject;
   DeleteAllItems();

   CString sOut;
   if (m_pDisplayObject->m_pWABEntry)
   {
      if (dmtMediaType == DIALER_MEDIATYPE_INTERNET)
      {
         if (WabPersonFormatString(sOut,PR_EMAIL_ADDRESS,IDS_WABPERSON_FORMAT_NETPHONE))
            InsertItem(sOut,DSA_ITEM_WAB_NETCALL,DSA_IMAGE_NETCALL);
      }
      else if (dmtMediaType == DIALER_MEDIATYPE_POTS)
      {
         if (WabPersonFormatString(sOut,PR_BUSINESS_TELEPHONE_NUMBER,IDS_WABPERSON_FORMAT_BUSINESSTELEPHONE))
            InsertItem(sOut,DSA_ITEM_WAB_PHONECALL_BUSINESS,DSA_IMAGE_PHONECALL);
      
         if (WabPersonFormatString(sOut,PR_HOME_TELEPHONE_NUMBER,IDS_WABPERSON_FORMAT_HOMETELEPHONE))
            InsertItem(sOut,DSA_ITEM_WAB_PHONECALL_HOME,DSA_IMAGE_PHONECALL);
      
         if (WabPersonFormatString(sOut,PR_MOBILE_TELEPHONE_NUMBER,IDS_WABPERSON_FORMAT_MOBILETELEPHONE))
            InsertItem(sOut,DSA_ITEM_WAB_CELLCALL,DSA_IMAGE_CELLCALL);
      
         if (WabPersonFormatString(sOut,PR_BUSINESS_FAX_NUMBER,IDS_WABPERSON_FORMAT_BUSINESSFAX))
            InsertItem(sOut,DSA_ITEM_WAB_FAXCALL_BUSINESS,DSA_IMAGE_FAXCALL);
      
         if (WabPersonFormatString(sOut,PR_HOME_FAX_NUMBER,IDS_WABPERSON_FORMAT_HOMEFAX))
            InsertItem(sOut,DSA_ITEM_WAB_FAXCALL_HOME,DSA_IMAGE_FAXCALL);
      
         if (WabPersonFormatString(sOut,PR_PAGER_TELEPHONE_NUMBER,IDS_WABPERSON_FORMAT_PAGERTELEPHONE))
            InsertItem(sOut,DSA_ITEM_WAB_PAGER,DSA_IMAGE_PAGER);
      }
   }
   if (m_pDisplayObject->m_pDSUser)
   {
      if (dmtMediaType == DIALER_MEDIATYPE_INTERNET)
      {
         //Netcall
         if (!m_pDisplayObject->m_pDSUser->m_sIPAddress.IsEmpty())
         {
            if (PersonFormatString(sOut,m_pDisplayObject->m_pDSUser->m_sIPAddress,IDS_WABPERSON_FORMAT_NETPHONE))
               InsertItem(sOut,DSA_ITEM_DS_NETCALL,DSA_IMAGE_NETCALL);
         }
      }      
      else if (dmtMediaType == DIALER_MEDIATYPE_POTS)
      {
         if (!m_pDisplayObject->m_pDSUser->m_sPhoneNumber.IsEmpty())
         {
            if (PersonFormatString(sOut,m_pDisplayObject->m_pDSUser->m_sPhoneNumber,IDS_WABPERSON_FORMAT_BUSINESSTELEPHONE))
               InsertItem(sOut,DSA_ITEM_DS_PHONECALL_BUSINESS,DSA_IMAGE_PHONECALL);
         }
      }
   }
   if (m_pDisplayObject->m_pILSUser)
   {
      if (dmtMediaType == DIALER_MEDIATYPE_INTERNET)
      {
         //Netcall
         if (!m_pDisplayObject->m_pILSUser->m_sIPAddress.IsEmpty())
         {
            if (PersonFormatString(sOut,m_pDisplayObject->m_pILSUser->m_sIPAddress,IDS_WABPERSON_FORMAT_NETPHONE))
               InsertItem(sOut,DSA_ITEM_ILS_NETCALL,DSA_IMAGE_NETCALL);
         }
      }      
   }
   return CListCtrl::GetItemCount();
}

/////////////////////////////////////////////////////////////////////////////
void CDialSelectAddressListCtrl::FillCallEntry(CCallEntry* pCallEntry)
{
   if (m_pDisplayObject == NULL) return;

   //get selected object
   int nItem =  CListCtrl::GetNextItem(-1,LVNI_FOCUSED);
   if (nItem != -1)
   {
      UINT uId  = (UINT)GetItemData(nItem);
      switch (uId)
      {
         case DSA_ITEM_DS_NETCALL:
         {
            ASSERT(m_pDisplayObject->m_pDSUser);
            pCallEntry->m_sAddress = m_pDisplayObject->m_pDSUser->m_sIPAddress;
            pCallEntry->m_sDisplayName = m_pDisplayObject->m_pDSUser->m_sUserName;
            pCallEntry->m_sUser1 = m_pDisplayObject->m_pDSUser->m_sUserName;
            pCallEntry->m_sUser2 = m_pDisplayObject->m_pDSUser->m_sPhoneNumber;
            break;
         }
         case DSA_ITEM_DS_PHONECALL_BUSINESS:
         {
            ASSERT(m_pDisplayObject->m_pDSUser);
            pCallEntry->m_sAddress = m_pDisplayObject->m_pDSUser->m_sPhoneNumber;
            pCallEntry->m_sDisplayName = m_pDisplayObject->m_pDSUser->m_sUserName;
            pCallEntry->m_sUser1 = m_pDisplayObject->m_pDSUser->m_sUserName;
            pCallEntry->m_sUser2 = _T("");
            break;
         }
         case DSA_ITEM_ILS_NETCALL:
         {
            ASSERT(m_pDisplayObject->m_pILSUser);
            pCallEntry->m_sAddress = m_pDisplayObject->m_pILSUser->m_sIPAddress;
            pCallEntry->m_sDisplayName = m_pDisplayObject->m_pILSUser->m_sUserName;
            pCallEntry->m_sUser1 = m_pDisplayObject->m_pILSUser->m_sUserName;
            pCallEntry->m_sUser2 = _T("");
            break;
         }
         case DSA_ITEM_WAB_NETCALL:
         {
            ASSERT(m_pDisplayObject->m_pWABEntry);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_EMAIL_ADDRESS, pCallEntry->m_sAddress);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_DISPLAY_NAME, pCallEntry->m_sDisplayName);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_DISPLAY_NAME, pCallEntry->m_sUser1);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_BUSINESS_TELEPHONE_NUMBER, pCallEntry->m_sUser2);
            break;
         }
         case DSA_ITEM_WAB_PHONECALL_BUSINESS:
         {
            ASSERT(m_pDisplayObject->m_pWABEntry);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_BUSINESS_TELEPHONE_NUMBER, pCallEntry->m_sAddress);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_DISPLAY_NAME, pCallEntry->m_sDisplayName);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_DISPLAY_NAME, pCallEntry->m_sUser1);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_EMAIL_ADDRESS, pCallEntry->m_sUser2);
            break;
         }
         case DSA_ITEM_WAB_PHONECALL_HOME:
         {
            ASSERT(m_pDisplayObject->m_pWABEntry);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_HOME_TELEPHONE_NUMBER, pCallEntry->m_sAddress);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_DISPLAY_NAME, pCallEntry->m_sDisplayName);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_DISPLAY_NAME, pCallEntry->m_sUser1);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_EMAIL_ADDRESS, pCallEntry->m_sUser2);
            break;
         }
         case DSA_ITEM_WAB_CELLCALL:
         {
            ASSERT(m_pDisplayObject->m_pWABEntry);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_MOBILE_TELEPHONE_NUMBER, pCallEntry->m_sAddress);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_DISPLAY_NAME, pCallEntry->m_sDisplayName);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_DISPLAY_NAME, pCallEntry->m_sUser1);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_EMAIL_ADDRESS, pCallEntry->m_sUser2);
            break;
         }
         case DSA_ITEM_WAB_FAXCALL_BUSINESS:
         {
            ASSERT(m_pDisplayObject->m_pWABEntry);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_BUSINESS_FAX_NUMBER, pCallEntry->m_sAddress);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_DISPLAY_NAME, pCallEntry->m_sDisplayName);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_DISPLAY_NAME, pCallEntry->m_sUser1);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_EMAIL_ADDRESS, pCallEntry->m_sUser2);
            break;
         }
         case DSA_ITEM_WAB_FAXCALL_HOME:
         {
            ASSERT(m_pDisplayObject->m_pWABEntry);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_HOME_FAX_NUMBER, pCallEntry->m_sAddress);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_DISPLAY_NAME, pCallEntry->m_sDisplayName);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_DISPLAY_NAME, pCallEntry->m_sUser1);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_EMAIL_ADDRESS, pCallEntry->m_sUser2);
            break;
         }
         case DSA_ITEM_WAB_PAGER:
         {
            ASSERT(m_pDisplayObject->m_pWABEntry);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, DSA_IMAGE_PAGER, pCallEntry->m_sAddress);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_DISPLAY_NAME, pCallEntry->m_sDisplayName);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_DISPLAY_NAME, pCallEntry->m_sUser1);
            m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, PR_EMAIL_ADDRESS, pCallEntry->m_sUser2);
            break;
         }
      }
   }
}

/////////////////////////////////////////////////////////////////////////////
void CDialSelectAddressListCtrl::InsertItem(LPCTSTR szStr,UINT uID,int nImage)
{
   int nItem = -1;
   
    LV_ITEM lv_item;
    memset(&lv_item,0,sizeof(LV_ITEM));
    
   if (nItem == -1)
      nItem = GetItemCount();
   lv_item.iItem = nItem;

    lv_item.mask |= LVIF_TEXT;
    lv_item.pszText = (LPTSTR)szStr;
    
   lv_item.mask |= LVIF_IMAGE;
   lv_item.iImage = nImage;

   lv_item.mask |= LVIF_PARAM;
   lv_item.lParam = uID;

    if ((nItem = CListCtrl::InsertItem(&lv_item)) != -1)
      CListCtrl::EnsureVisible(nItem,FALSE);
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDialSelectAddressListCtrl::WabPersonFormatString(CString& sOut,UINT attrib,UINT formatid)
{
   sOut = _T("");
   if (m_pDirectory == NULL) return FALSE;

   CString sText;
   if ( (m_pDirectory->WABGetStringProperty(m_pDisplayObject->m_pWABEntry, attrib, sText) == DIRERR_SUCCESS) &&
        (!sText.IsEmpty()) )
   {
      return PersonFormatString(sOut,sText,formatid);
   }
   return FALSE;
}

/////////////////////////////////////////////////////////////////////////////
BOOL CDialSelectAddressListCtrl::PersonFormatString(CString& sOut,LPCTSTR szData,UINT formatid)
{
   sOut = _T("");
   AfxFormatString1(sOut,formatid,szData);
   int nIndex;
   while ((nIndex = sOut.Find(_T("\r\n"))) != -1)
   {
      CString sTemp = sOut.Left(nIndex);
      sTemp += _T(" - ");
      sOut = sTemp + sOut.Mid(nIndex+2);
   }
   return (sOut.IsEmpty())?FALSE:TRUE;
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\dib.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
// Copyright 1996 Microsoft Systems Journal. 
// If this code works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
// See dib.cpp

#ifndef _INC_VFW
#pragma message ("NOTE: You can speed compilation by including <vfw.h> in stdafx.h")
#include <vfw.h>
#endif

#ifndef _DIB_H_
#define _DIB_H_

// global functions for ordinary CBitmap too
//
extern CSize GetBitmapSize(CBitmap* pBitmap);
extern BOOL  DrawBitmap(CDC& dc, CBitmap* pBitmap,
	const CRect* rcDst=NULL, const CRect* rcSrc=NULL);

////////////////
// CDib implements Device Independent Bitmaps as a form of CBitmap. 
//
class CDib : public CBitmap {
protected:
	DECLARE_DYNAMIC(CDib)
	BITMAP	m_bm;		// stored for speed
	CPalette m_pal;	// palette
	HDRAWDIB m_hdd;	// for DrawDib

public:
	CDib();
	~CDib();

	CSize	GetSize() { return CSize(m_bm.bmWidth, m_bm.bmHeight); }
	BOOL Attach(HGDIOBJ hbm);
	BOOL Load(LPCTSTR szPathName);
	BOOL Load(HINSTANCE hInst, LPCTSTR lpResourceName);
	BOOL Load(HINSTANCE hInst, UINT uID)
		{ return Load(hInst, MAKEINTRESOURCE(uID)); }

	// Universal Draw function can use DrawDib or not.
	BOOL Draw(CDC& dc, const CRect* rcDst=NULL, const CRect* rcSrc=NULL,
		BOOL bUseDrawDib=TRUE, CPalette* pPal=NULL, BOOL bForeground=FALSE);
   BOOL CDib::DrawNoStretch(CDC& dc, const CRect* rcDst=NULL, const CRect* rcSrc=NULL,
	   BOOL bUseDrawDib=TRUE, CPalette* pPal=NULL, BOOL bForeground=FALSE);

	BOOL DeleteObject();
	BOOL CreatePalette(CPalette& pal);
	CPalette* GetPalette()  { return &m_pal; }

	UINT GetColorTable(RGBQUAD* colorTab, UINT nColors);
};
#endif _DIB_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\dialtoolbr.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// DialToolBar.cpp : implementation file
//

#include "stdafx.h"
#include "avDialer.h"
#include "DialToolBar.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
//Defines
#define  COMBO_STATUS_WIDTH            250
#define  COMBO_STATUS_HEIGHT           100

/////////////////////////////////////////////////////////////////////////////
// CDialToolBar

CDialToolBar::CDialToolBar()
{
}

CDialToolBar::~CDialToolBar()
{
}


BEGIN_MESSAGE_MAP(CDialToolBar, CCoolToolBar)
	//{{AFX_MSG_MAP(CDialToolBar)
	ON_WM_CREATE()
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
// CDialToolBar message handlers

int CDialToolBar::OnCreate(LPCREATESTRUCT lpCreateStruct) 
{
	if (CCoolToolBar::OnCreate(lpCreateStruct) == -1)
		return -1;
	
   return 0;

}

void CDialToolBar::Init()
{
   /*
   CString sButtonText;
   sButtonText.LoadString(IDS_TOOLBAR_BUTTON_PLACECALL);
   CToolBar::SetButtonText(0,sButtonText);
   sButtonText.LoadString(IDS_TOOLBAR_BUTTON_REDIAL);
   CToolBar::SetButtonText(1,sButtonText);

   SetButtonStyle(0,TBSTYLE_AUTOSIZE);
   SetButtonStyle(1,TBSTYLE_DROPDOWN|TBSTYLE_AUTOSIZE);
*/
   /*
	SetButtonInfo(1, 1001 , TBBS_SEPARATOR, COMBO_STATUS_WIDTH);

   CRect rect;
	GetItemRect(1, &rect);
	rect.top = 3;
	rect.bottom = rect.top + COMBO_STATUS_HEIGHT;
   rect.DeflateRect(2,0);  //add some border around it

  	if (!m_comboDial.Create(WS_VISIBLE|WS_VSCROLL|CBS_DROPDOWNLIST,//|CBS_SORT, 
      rect, this, 1))
	{
		return;
	}

  	//Default font for GUI
   m_comboDial.SendMessage(WM_SETFONT, (WPARAM)GetStockObject(DEFAULT_GUI_FONT));
   */
	return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\dib.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////
// Copyright 1996 Microsoft Systems Journal. 
// If this program works, it was written by Paul DiLascia.
// If not, I don't know who wrote it.
//
// CDib - Device Independent Bitmap.
// This implementation draws bitmaps using normal Win32 API functions,
// not DrawDib. CDib is derived from CBitmap, so you can use it with
// any other MFC functions that use bitmaps.
//
#include "StdAfx.h"
#include "Dib.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

const  int        MAXPALCOLORS = 256;

IMPLEMENT_DYNAMIC(CDib, CObject)

CDib::CDib()
{
    memset(&m_bm, 0, sizeof(m_bm));
    m_hdd = NULL;
}

CDib::~CDib()
{
    DeleteObject();
}

//////////////////
// Delete Object. Delete DIB and palette.
//
BOOL CDib::DeleteObject()
{
    m_pal.DeleteObject();
    if (m_hdd) {
        DrawDibClose(m_hdd);
        m_hdd = NULL;
    }
    memset(&m_bm, 0, sizeof(m_bm));
    return CBitmap::DeleteObject();
}

//////////////////
// Read DIB from file.
//
BOOL CDib::Load(LPCTSTR lpszPathName)
{
    return Attach(::LoadImage(NULL, lpszPathName, IMAGE_BITMAP, 0, 0,
        LR_LOADFROMFILE | LR_CREATEDIBSECTION | LR_DEFAULTSIZE));
}

//////////////////
// Load bitmap resource. Never tested.
//
BOOL CDib::Load(HINSTANCE hInst, LPCTSTR lpResourceName)
{
    return Attach(::LoadImage(hInst, lpResourceName, IMAGE_BITMAP, 0, 0,
        LR_CREATEDIBSECTION | LR_DEFAULTSIZE));
}

//////////////////
// Attach is just like the CGdiObject version,
// except it also creates the palette
//
BOOL CDib::Attach(HGDIOBJ hbm)
{
    if (CBitmap::Attach(hbm)) {
        if (!GetBitmap(&m_bm))            // load BITMAP for speed
            return FALSE;
        m_pal.DeleteObject();            // in case one is already there
        return CreatePalette(m_pal);    // create palette
    }
    return FALSE;    
}

//////////////////
// Get size (width, height) of bitmap.
// extern fn works for ordinary CBitmap objects.
//
CSize GetBitmapSize(CBitmap* pBitmap)
{
    BITMAP bm;

    //
    // we should initialize BITMAP structure
    //
    memset( &bm, 0, sizeof(BITMAP) );

    return pBitmap->GetBitmap(&bm) ?
        CSize(bm.bmWidth, bm.bmHeight) : CSize(0,0);
}

//////////////////
// You can use this static function to draw ordinary
// CBitmaps as well as CDibs
//
BOOL DrawBitmap(CDC& dc, CBitmap* pBitmap,
    const CRect* rcDst, const CRect* rcSrc)
{
    // Compute rectangles where NULL specified
    CRect rc;
    if (!rcSrc) {
        // if no source rect, use whole bitmap
        rc = CRect(CPoint(0,0), GetBitmapSize(pBitmap));
        rcSrc = &rc;
    }
    if (!rcDst) {
        // if no destination rect, use source
        rcDst=rcSrc;
    }

    // Create memory DC
    CDC memdc;
    memdc.CreateCompatibleDC(&dc);
    CBitmap* pOldBm = memdc.SelectObject(pBitmap);

    // Blast bits from memory DC to target DC.
    // Use StretchBlt if size is different.
    //
    BOOL bRet = FALSE;
    if (rcDst->Size()==rcSrc->Size()) {
        bRet = dc.BitBlt(rcDst->left, rcDst->top, 
            rcDst->Width(), rcDst->Height(),
            &memdc, rcSrc->left, rcSrc->top, SRCCOPY);
    } else {
        dc.SetStretchBltMode(COLORONCOLOR);
        bRet = dc.StretchBlt(rcDst->left, rcDst->top, rcDst->Width(),
            rcDst->Height(), &memdc, rcSrc->left, rcSrc->top, rcSrc->Width(),
            rcSrc->Height(), SRCCOPY);
    }
    memdc.SelectObject(pOldBm);

    return bRet;
}

////////////////////////////////////////////////////////////////
// Draw DIB on caller's DC. Does stretching from source to destination
// rectangles. Generally, you can let the following default to zero/NULL:
//
//        bUseDrawDib = whether to use use DrawDib, default TRUE
//        pPal          = palette, default=NULL, (use DIB's palette)
//        bForeground = realize in foreground (default FALSE)
//
// If you are handling palette messages, you should use bForeground=FALSE,
// since you will realize the foreground palette in WM_QUERYNEWPALETTE.
//
BOOL CDib::Draw(CDC& dc, const CRect* rcDst, const CRect* rcSrc,
    BOOL bUseDrawDib, CPalette* pPal, BOOL bForeground)
{
    if (!m_hObject)
        return FALSE;

    // Select, realize palette
    if (pPal==NULL)                // no palette specified:
        pPal = GetPalette();        // use default
    CPalette* pOldPal = dc.SelectPalette(pPal, !bForeground);
    dc.RealizePalette();

    BOOL bRet = FALSE;
    if (bUseDrawDib) {
        // Compute rectangles where NULL specified
        //
        CRect rc(0,0,-1,-1);    // default for DrawDibDraw
        if (!rcSrc)
            rcSrc = &rc;
        if (!rcDst)
            rcDst=rcSrc;
        if (!m_hdd)
            VERIFY(m_hdd = DrawDibOpen());

        // Get BITMAPINFOHEADER/color table. I copy into stack object each time.
        // This doesn't seem to slow things down visibly.
        //
        DIBSECTION ds;
        VERIFY(GetObject(sizeof(ds), &ds)==sizeof(ds));
        char buf[sizeof(BITMAPINFOHEADER) + MAXPALCOLORS*sizeof(RGBQUAD)];
        BITMAPINFOHEADER& bmih = *(BITMAPINFOHEADER*)buf;
        RGBQUAD* colors = (RGBQUAD*)(&bmih+1);
        memcpy(&bmih, &ds.dsBmih, sizeof(bmih));
        GetColorTable(colors, MAXPALCOLORS);

        // Let DrawDib do the work!
        bRet = DrawDibDraw(m_hdd, dc,
            rcDst->left, rcDst->top, rcDst->Width(), rcDst->Height(),
            &bmih,            // ptr to BITMAPINFOHEADER + colors
            m_bm.bmBits,    // bits in memory
            rcSrc->left, rcSrc->top, rcSrc->Width(), rcSrc->Height(),
            bForeground ? 0 : DDF_BACKGROUNDPAL);

    } else {
        // use normal draw function
        bRet = DrawBitmap(dc, this, rcDst, rcSrc);
    }
    if (pOldPal)
        dc.SelectPalette(pOldPal, TRUE);
    return bRet;
}

////////////////////////////////////////////////////////////////
// Draw DIB on caller's DC. No Stretching is done.
//
//        bUseDrawDib = whether to use use DrawDib, default TRUE
//        pPal          = palette, default=NULL, (use DIB's palette)
//        bForeground = realize in foreground (default FALSE)
//
// If you are handling palette messages, you should use bForeground=FALSE,
// since you will realize the foreground palette in WM_QUERYNEWPALETTE.
//
BOOL CDib::DrawNoStretch(CDC& dc, const CRect* rcDst, const CRect* rcSrc,
    BOOL bUseDrawDib, CPalette* pPal, BOOL bForeground)
{
    if (!m_hObject)
        return FALSE;

    // Select, realize palette
    if (pPal==NULL)                // no palette specified:
        pPal = GetPalette();        // use default
    CPalette* pOldPal = dc.SelectPalette(pPal, !bForeground);
    dc.RealizePalette();

    BOOL bRet = FALSE;
    if (bUseDrawDib) {
        // Compute rectangles where NULL specified
        //
        CRect rc(0,0,-1,-1);    // default for DrawDibDraw
        if (!rcSrc)
            rcSrc = &rc;
        if (!rcDst)
            rcDst=rcSrc;
        if (!m_hdd)
          VERIFY(m_hdd = DrawDibOpen());

        // Get BITMAPINFOHEADER/color table. I copy into stack object each time.
        // This doesn't seem to slow things down visibly.
        //
        DIBSECTION ds;
        
      GetObject(sizeof(ds), &ds);
      //CString sOutput;
      //sOutput.Format("GetObject %d\r\n",uSize);
      //OutputDebugString(sOutput);
      //VERIFY(GetObject(sizeof(ds), &ds)==sizeof(ds));

        char buf[sizeof(BITMAPINFOHEADER) + MAXPALCOLORS*sizeof(RGBQUAD)];
        BITMAPINFOHEADER& bmih = *(BITMAPINFOHEADER*)buf;
        RGBQUAD* colors = (RGBQUAD*)(&bmih+1);
        memcpy(&bmih, &ds.dsBmih, sizeof(bmih));
        GetColorTable(colors, MAXPALCOLORS);

        // Let DrawDib do the work!
        bRet = DrawDibDraw(m_hdd, dc,
            rcDst->left, rcDst->top, -1,-1,//rcDst->Width(), rcDst->Height(),
            &bmih,            // ptr to BITMAPINFOHEADER + colors
            m_bm.bmBits,    // bits in memory
            rcSrc->left, rcSrc->top, rcSrc->Width(), rcSrc->Height(),
            bForeground ? 0 : DDF_BACKGROUNDPAL);

    } else {
        // use normal draw function
        bRet = DrawBitmap(dc, this, rcDst, rcSrc);
    }
    if (pOldPal)
        dc.SelectPalette(pOldPal, TRUE);
    return bRet;
}

#define PALVERSION 0x300    // magic number for LOGPALETTE

//////////////////
// Create the palette. Use halftone palette for hi-color bitmaps.
//
BOOL CDib::CreatePalette(CPalette& pal)
{ 
    // should not already have palette
    ASSERT(pal.m_hObject==NULL);

    BOOL bRet = FALSE;
    RGBQUAD* colors = new RGBQUAD[MAXPALCOLORS];
    UINT nColors = GetColorTable(colors, MAXPALCOLORS);
    if (nColors > 0) {
        // Allocate memory for logical palette 
        int len = sizeof(LOGPALETTE) + sizeof(PALETTEENTRY) * nColors;
        LOGPALETTE* pLogPal = (LOGPALETTE*)new char[len];
        if (!pLogPal)
            return NULL;

        // set version and number of palette entries
        pLogPal->palVersion = PALVERSION;
        pLogPal->palNumEntries = (WORD) nColors;

        // copy color entries 
        for (UINT i = 0; i < nColors; i++) {
            pLogPal->palPalEntry[i].peRed   = colors[i].rgbRed;
            pLogPal->palPalEntry[i].peGreen = colors[i].rgbGreen;
            pLogPal->palPalEntry[i].peBlue  = colors[i].rgbBlue;
            pLogPal->palPalEntry[i].peFlags = 0;
        }

        // create the palette and destroy LOGPAL
        bRet = pal.CreatePalette(pLogPal);
        delete [] (char*)pLogPal;
    } else {
        CWindowDC dcScreen(NULL);
        bRet = pal.CreateHalftonePalette(&dcScreen);
    }
    delete colors;
    return bRet;
}

//////////////////
// Helper to get color table. Does all the mem DC voodoo.
//
UINT CDib::GetColorTable(RGBQUAD* colorTab, UINT nColors)
{
    CWindowDC dcScreen(NULL);
    CDC memdc;
    memdc.CreateCompatibleDC(&dcScreen);
    CBitmap* pOldBm = memdc.SelectObject(this);
    nColors = GetDIBColorTable(memdc, 0, nColors, colorTab);
    memdc.SelectObject(pOldBm);
    return nColors;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\dirasynch.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//
// dirasynch.cpp
//

#include "stdafx.h"
#include <tchar.h>
#include "dirasynch.h"
#include "avtrace.h"


CDirAsynch::CDirAsynch()
{
	InitializeCriticalSection(&m_csQueueLock);

	m_hEvents[DIRASYNCHEVENT_SIGNAL]= CreateEvent( NULL, true, false, NULL );
	m_hEvents[DIRASYNCHEVENT_SHUTDOWN]= CreateEvent( NULL, false, false, NULL );
	m_hThreadEnded = CreateEvent( NULL, false, false, NULL );

	m_fShutdown= false;
	m_bInitialized = false;

	m_hWorkerThread = NULL;
	m_pCurrentQuery = NULL;
}

CDirAsynch::~CDirAsynch()
{
	// did you call terminate on this object?
	ASSERT( m_fShutdown );
}

bool CDirAsynch::Initialize()
{
   bool fSuccess;

   fSuccess= (CDirectory::Initialize() == DIRERR_SUCCESS);

   if (fSuccess)
   {
      // Create the worker thread.
	  DWORD dwID;
      m_hWorkerThread = CreateThread(NULL, 0, WorkerThread, this, 0, &dwID);
   }

   m_bInitialized = fSuccess;
   return fSuccess;
}

void CDirAsynch::Terminate()
{
	AVTRACE(_T(".enter.CDirAsynch::Terminate()."));
	m_fShutdown= true;

	// Did we create a thread that needs to be shutdown?
	if ( m_hWorkerThread )
	{
		SetEvent(m_hEvents[DIRASYNCHEVENT_SHUTDOWN]);

		// Shut the thread down
		if (  WaitForSingleObject(m_hThreadEnded, 15000) != WAIT_OBJECT_0 )
		{
			AVTRACE(_T("CDirAsynch::Terminate() -- forced TERMINATION of worker thread!!!!"));
			TerminateThread( m_hWorkerThread, 0 );

			// Delete item that was currently being processed
			if ( m_pCurrentQuery )
			{
				if ( m_pCurrentQuery->m_pfnRelease )
					(*(m_pCurrentQuery->m_pfnRelease)) ((void *) m_pCurrentQuery->m_lParam);

				delete m_pCurrentQuery;
			}
		}

		CloseHandle( m_hWorkerThread );
		m_hWorkerThread = NULL;
	}

	//delete the CQuery objects if any
	EnterCriticalSection( &m_csQueueLock );
	while ( m_listQueries.GetHeadPosition() )
	{
		CQuery *pQuery = (CQuery *) m_listQueries.RemoveHead();
		AVTRACE(_T(".1.CDirAsynch::Terminate() -- release CQuery object %p."), pQuery );
		if ( pQuery->m_pfnRelease )
			(*(pQuery->m_pfnRelease)) ((void *) pQuery->m_lParam);

		delete pQuery;
	}
	LeaveCriticalSection( &m_csQueueLock );
	DeleteCriticalSection( &m_csQueueLock );

	// Free event handles
	if ( m_hEvents[DIRASYNCHEVENT_SIGNAL] )		CloseHandle( m_hEvents[DIRASYNCHEVENT_SIGNAL] );
	if ( m_hEvents[DIRASYNCHEVENT_SHUTDOWN] )	CloseHandle( m_hEvents[DIRASYNCHEVENT_SHUTDOWN] );
	if ( m_hThreadEnded )						CloseHandle( m_hThreadEnded );

	AVTRACE(_T(".exit.CDirAsynch::Terminate()."));
}


bool CDirAsynch::LDAPListNames(LPCTSTR szServer, LPCTSTR szSearch, 
	CALLBACK_LDAPLISTNAMES pfcnCallBack, void *pThis )
{
	// The worker thread will delete this.
	CQuery* pQuery= new CQuery();

	pQuery->m_Query= QT_LDAPLISTNAMES;
	pQuery->m_sServer= szServer;
	pQuery->m_sSearch= szSearch;
	pQuery->m_pfcnCallBack= (void*) pfcnCallBack;
	pQuery->m_pThis = pThis;


	// Add to the end of the list
	if ( !AddToQueue(pQuery) )
	{
		delete pQuery;
		return false;
	}

	return true;
}

bool CDirAsynch::LDAPGetStringProperty(LPCTSTR szServer, 
	LPCTSTR szDistinguishedName, 
	DirectoryProperty dpProperty,
	LPARAM lParam,
	LPARAM lParam2,
	CALLBACK_GETSTRINGPROPERTY pfcnCallBack,
	EXPTREEITEM_EXTERNALRELEASEPROC pfnRelease,
	void *pThis )
{
	// The worker thread will delete this.
	CQuery* pQuery= new CQuery();

	pQuery->m_Query= QT_LDAPGETSTRINGPROPERTY;
	pQuery->m_sServer= szServer;
	pQuery->m_sSearch= szDistinguishedName,
	pQuery->m_dpProperty = dpProperty;
	pQuery->m_lParam = lParam;
	pQuery->m_lParam2 = lParam2;
	pQuery->m_pfcnCallBack= (void*) pfcnCallBack;
	pQuery->m_pfnRelease = pfnRelease;
	pQuery->m_pThis = pThis;

	// Add to the end of the list
	if ( !AddToQueue(pQuery) )
	{
		delete pQuery;
		return false;
	}

	return true;
}

bool CDirAsynch::ILSListUsers(LPCTSTR szServer,LPARAM lParam,CALLBACK_ILSLISTUSERS pfcnCallBack, void *pThis)
{
	// The worker thread will delete this.
	CQuery* pQuery= new CQuery();

	pQuery->m_Query= QT_ILSLISTUSERS;
	pQuery->m_sServer= szServer;
	pQuery->m_pfcnCallBack= (void*) pfcnCallBack;
	pQuery->m_lParam = lParam;
	pQuery->m_pThis = pThis;

	// Add to the end of the list
	if ( !AddToQueue(pQuery) )
	{
		delete pQuery;
		return false;
	}

	return true;
}

bool CDirAsynch::DirListServers(CALLBACK_DIRLISTSERVERS pfcnCallBack, void *pThis, DirectoryType dirtype)
{
	// The worker thread will delete this.
	CQuery* pQuery= new CQuery();

	pQuery->m_Query= QT_DIRLISTSERVERS;
	pQuery->m_pfcnCallBack= (void*) pfcnCallBack;
	pQuery->m_lParam = dirtype;
	pQuery->m_pThis = pThis;

	// Add to the end of the list
	if ( !AddToQueue(pQuery) )
	{
		delete pQuery;
		return false;
	}

	return true;
}

// Protected Functions

// Adds to the tail of the queue and signals the waiting threads
bool CDirAsynch::AddToQueue(CQuery* pQuery)
{
	if ( !m_bInitialized ) return false;

	EnterCriticalSection(&m_csQueueLock);
	m_listQueries.AddTail(pQuery);
	LeaveCriticalSection(&m_csQueueLock);

	// Signal waiting threads
	SetEvent(m_hEvents[DIRASYNCHEVENT_SIGNAL]);
	return true;
}

// reutrns NULL if list is empty.
CQuery* CDirAsynch::RemoveFromQueue()
{
	CQuery* pQuery= NULL;

	EnterCriticalSection(&m_csQueueLock);
	if (!m_listQueries.IsEmpty())
		pQuery=(CQuery*) m_listQueries.RemoveHead();

	LeaveCriticalSection(&m_csQueueLock);

	return pQuery;
}


ULONG WINAPI CDirAsynch::WorkerThread(void* hThis )
{
	// Must have valid 'this' pointer
	ASSERT( hThis );
	CDirAsynch* pThis= (CDirAsynch*) hThis;
	if ( !pThis ) return E_INVALIDARG;

	
	HRESULT hr = CoInitializeEx( NULL, COINIT_MULTITHREADED | COINIT_SPEED_OVER_MEMORY );
	if ( SUCCEEDED(hr) )
	{
		pThis->Worker();
		CoUninitialize();
	}

	SetEvent( pThis->m_hThreadEnded );
	return hr;
}

void CDirAsynch::Worker()
{
	while ( !m_fShutdown )
	{
		// Reset event if the list appears empty
		EnterCriticalSection(&m_csQueueLock);
		if ( m_listQueries.IsEmpty() )
			ResetEvent( m_hEvents[DIRASYNCHEVENT_SIGNAL] );
		LeaveCriticalSection(&m_csQueueLock);

		// Empty list before waiting on multiples...
		// block indefinitely for either and Add or Shutdown
		DWORD dwWait = WaitForMultipleObjects( 2, m_hEvents, false, INFINITE );

		switch ( dwWait )
		{
			case WAIT_OBJECT_0 + 1:
				{
					// There is a small window of time where we can lose a reference to the Query
					// if the thread is terminated, but there isn't much we can do about this.
					// Since we wait 5 seconds, the likelihood of it happening is virtually zero.  Most
					// of the time the call will be stuck in an LDAP query and from here the release
					// will be executed by the terminating function.  Only if thread is executing a 
					// callback will we potentially lose it, and the callback is designed to return
					// very fast, so we have a 5 second grace period.

					CQuery *pQuery = m_pCurrentQuery = RemoveFromQueue();

					if ( pQuery )
					{
						switch(pQuery->m_Query)
						{
							case QT_LDAPLISTNAMES:
								{
									CALLBACK_LDAPLISTNAMES pfcnCallBack= (CALLBACK_LDAPLISTNAMES) pQuery->m_pfcnCallBack;

									CObList listResponse;

									//get the LDAP names
									DirectoryErr err = CDirectory::LDAPListNames(pQuery->m_sServer, pQuery->m_sSearch,listResponse);

									//callback
									if ( !m_fShutdown )
									{
										m_pCurrentQuery->m_pfnRelease = NULL;
										pfcnCallBack(err, pQuery->m_pThis, pQuery->m_sServer, pQuery->m_sSearch, listResponse);
									}
								}
								break;

							case QT_LDAPGETSTRINGPROPERTY:
								{
									CALLBACK_GETSTRINGPROPERTY pfcnCallBack= (CALLBACK_GETSTRINGPROPERTY) pQuery->m_pfcnCallBack;
									CString sResponse;

									bool fSuccess= (CDirectory::LDAPGetStringProperty(pQuery->m_sServer, pQuery->m_sSearch, 
									pQuery->m_dpProperty, sResponse) == DIRERR_SUCCESS);

									if ( !m_fShutdown )
									{
										m_pCurrentQuery->m_pfnRelease = NULL;
										pfcnCallBack(fSuccess, pQuery->m_pThis, pQuery->m_sServer, pQuery->m_sSearch,
											pQuery->m_dpProperty, sResponse, pQuery->m_lParam,pQuery->m_lParam2);
									}
								}
								break;

							case QT_ILSLISTUSERS:
								{
									CALLBACK_ILSLISTUSERS pfcnCallBack= (CALLBACK_ILSLISTUSERS) pQuery->m_pfcnCallBack;
									CObList listResponse;

									bool fSuccess = (bool) (CDirectory::ILSListUsers(pQuery->m_sServer, &listResponse) == DIRERR_SUCCESS);

									if ( !m_fShutdown )
									{
										m_pCurrentQuery->m_pfnRelease = NULL;
										pfcnCallBack(fSuccess, pQuery->m_pThis, pQuery->m_sServer, listResponse, pQuery->m_lParam);
									}
								}
								break;

							case QT_DIRLISTSERVERS:
								{
									CALLBACK_DIRLISTSERVERS pfcnCallBack= (CALLBACK_DIRLISTSERVERS) pQuery->m_pfcnCallBack;
									CStringList strList;

									DirectoryType dirtype = (DirectoryType)pQuery->m_lParam;

									bool fSuccess = (CDirectory::DirListServers(&strList,dirtype) == DIRERR_SUCCESS);

									if ( !m_fShutdown )
									{
										m_pCurrentQuery->m_pfnRelease = NULL;
										pfcnCallBack(fSuccess, pQuery->m_pThis, strList, dirtype);
									}
								}
								break;

							default:
								break;
						}

						m_pCurrentQuery = NULL;
						delete pQuery;
					}
				}
				break;
				
			// Thread should exit
			case WAIT_OBJECT_0:
				AVTRACE(_T(".enter.CDirAsynch::Worker() -- thread shutting down...") );
			default:
				return;
		}
	}
}

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\dirasynch.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//
// dirasynch.h
//

#ifndef _DIRASYNCH_H_
#define _DIRASYNCH_H_


#include "directory.h"
#include "aexpltre.h"


typedef enum
{
   QT_UNKNOWN,
	QT_LDAPLISTNAMES,
	QT_LDAPGETSTRINGPROPERTY,
   QT_ILSLISTUSERS,
   QT_DIRLISTSERVERS,
} QueryType;

//
// Small class for the QueryQueue
//
class CQuery : public CObject
{
public:
	CQuery()
	{
		m_Query = QT_UNKNOWN;
		m_pfcnCallBack = m_pThis = NULL;
		m_lParam = m_lParam2 = NULL;
		m_dpProperty = DIRPROP_UNKNOWN;
		m_pfnRelease = NULL;
	}

public:
	QueryType							m_Query;
	CString								m_sServer;
	CString								m_sSearch;
	DirectoryProperty					m_dpProperty;
	void								*m_pfcnCallBack;
	void								*m_pThis;
	LPARAM								m_lParam;
	LPARAM								m_lParam2;
	EXPTREEITEM_EXTERNALRELEASEPROC		m_pfnRelease;
};

//
//
//

enum
{
   DIRASYNCHEVENT_SHUTDOWN,
   DIRASYNCHEVENT_SIGNAL,
};


//
//
//

typedef void (CALLBACK * CALLBACK_LDAPLISTNAMES)(DirectoryErr, void*, LPCTSTR, LPCTSTR, CObList&);
typedef void (CALLBACK * CALLBACK_GETSTRINGPROPERTY)(bool, void*, LPCTSTR, LPCTSTR, DirectoryProperty dpProperty, CString&, LPARAM, LPARAM);

typedef void (CALLBACK * CALLBACK_ILSLISTUSERS)(bool, void*, LPCTSTR, CObList&, LPARAM);

typedef void (CALLBACK * CALLBACK_DIRLISTSERVERS)(bool, void*, CStringList&,DirectoryType dirtype);

class CDirAsynch : public CDirectory
{
public:
	bool		m_bInitialized;
	HANDLE		m_hThreadEnded;

protected:
   CRITICAL_SECTION		m_csQueueLock; 
   HANDLE				m_hEvents[2];
   CPtrList				m_listQueries;
   bool					m_fShutdown;
   HANDLE				m_hWorkerThread;
   CQuery				*m_pCurrentQuery;

protected:
   bool AddToQueue(CQuery* pQuery);
   CQuery* RemoveFromQueue();
   static ULONG WINAPI WorkerThread(void* hThis);
   void Worker();

public:
   CDirAsynch();
   ~CDirAsynch();

   // hContext can be whatever you want, it wont be used, only returned
   // with all the callbacks.
   bool Initialize();
   void Terminate();

   // pCalLBack will be called with
   // bool - success or failure
   // void* the hContext handle
   // LPCTSTR, the szServer as originally called.
   // LPCTSTR, the szSearch as originally called.
   // CObList& the answer to the query (CLDAPUser Objects).
   bool LDAPListNames(LPCTSTR szServer, LPCTSTR szSearch, 
	   CALLBACK_LDAPLISTNAMES pfcnCallBack, void *pThis);

   // pCalLBack will be called with
   // bool - success or failure
   // void* the hContext handle
   // LPCTSTR, the szServer as originally called.
   // LPCTSTR, the szDistinguishedName as originally called.
   // DirectoryProperty dpProperty, the LDAP property needed
   // CString& the answer to the query.
   bool LDAPGetStringProperty(LPCTSTR szServer, 
			LPCTSTR szDistinguishedName, 
			DirectoryProperty dpProperty,
			LPARAM lParam,
			LPARAM lParam2,
			CALLBACK_GETSTRINGPROPERTY pfcnCallBack,
			EXPTREEITEM_EXTERNALRELEASEPROC pfnRelease,
			void *pThis);

   // pCalLBack will be called with
   // bool - success or failure
   // void* the hContext handle
   // LPCTSTR, the szServer as originally called.
   // CObList& the answer to the query.
   bool ILSListUsers(LPCTSTR szServer,LPARAM lParam,CALLBACK_ILSLISTUSERS pfcnCallBack, void *pThis);
   
   bool DirListServers(CALLBACK_DIRLISTSERVERS pfcnCallBack, void *pThis, DirectoryType dirtype);
};

#endif

// EOF
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\dirdlgs.h ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// DirectoriesDlgs.h : header file
/////////////////////////////////////////////////////////////////////////////
#if !defined(AFX_DIRECTORIESDLGS_H__41A4FC1D_498F_11D1_B6EF_0800170982BA__INCLUDED_)
#define AFX_DIRECTORIESDLGS_H__41A4FC1D_498F_11D1_B6EF_0800170982BA__INCLUDED_

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CDirAddServerDlg dialog
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

class CDirAddServerDlg : public CDialog
{
// Construction
public:
	CDirAddServerDlg(CWnd* pParent = NULL);   // standard constructor

// Dialog Data
	//{{AFX_DATA(CDirAddServerDlg)
	enum { IDD = IDD_DIRECTORIES_ADDSERVER };
	CString	m_sServerName;
	//}}AFX_DATA


// Overrides
	// ClassWizard generated virtual function overrides
	//{{AFX_VIRTUAL(CDirAddServerDlg)
	protected:
	virtual void DoDataExchange(CDataExchange* pDX);    // DDX/DDV support
	//}}AFX_VIRTUAL

// Implementation
protected:

	// Generated message map functions
	//{{AFX_MSG(CDirAddServerDlg)
	virtual BOOL OnInitDialog();
	virtual void OnOK();
	//}}AFX_MSG
	DECLARE_MESSAGE_MAP()
};

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

//{{AFX_INSERT_LOCATION}}
// Microsoft Developer Studio will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_DIRECTORIESDLGS_H__41A4FC1D_498F_11D1_B6EF_0800170982BA__INCLUDED_)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\dirdlgs.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

// DirectoriesDlgs.cpp : implementation file
/////////////////////////////////////////////////////////////////////////////

#include "stdafx.h"
#include "avDialer.h"
#include "DirDlgs.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
// Class CDirAddServerDlg dialog
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////

/////////////////////////////////////////////////////////////////////////////
CDirAddServerDlg::CDirAddServerDlg(CWnd* pParent /*=NULL*/)
	: CDialog(CDirAddServerDlg::IDD, pParent)
{
	//{{AFX_DATA_INIT(CDirAddServerDlg)
	m_sServerName = _T("");
	//}}AFX_DATA_INIT
}

/////////////////////////////////////////////////////////////////////////////
void CDirAddServerDlg::DoDataExchange(CDataExchange* pDX)
{
	CDialog::DoDataExchange(pDX);
	//{{AFX_DATA_MAP(CDirAddServerDlg)
	DDX_Text(pDX, IDC_DIRECTORIES_ADDSERVER_EDIT_SERVERNAME, m_sServerName);
	//}}AFX_DATA_MAP
}

/////////////////////////////////////////////////////////////////////////////
BEGIN_MESSAGE_MAP(CDirAddServerDlg, CDialog)
	//{{AFX_MSG_MAP(CDirAddServerDlg)
	//}}AFX_MSG_MAP
END_MESSAGE_MAP()

/////////////////////////////////////////////////////////////////////////////
BOOL CDirAddServerDlg::OnInitDialog() 
{
   CenterWindow(GetDesktopWindow());

	CDialog::OnInitDialog();
	
	return TRUE;  // return TRUE unless you set the focus to a control
	              // EXCEPTION: OCX Property Pages should return FALSE
}

/////////////////////////////////////////////////////////////////////////////
void CDirAddServerDlg::OnOK() 
{
   //retreive the data
   UpdateData(TRUE);

   //do validation
   if (m_sServerName.IsEmpty())
   {
      AfxMessageBox(IDS_DIRECTORIES_ADDSERVER_NAME_EMPTY);

      HWND hwnd = ::GetDlgItem(GetSafeHwnd(),IDC_DIRECTORIES_ADDSERVER_EDIT_SERVERNAME);
      if (hwnd) ::SetFocus(hwnd);

      return;
   }
	
	CDialog::OnOK();
}

/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\net\tapi\skywalker\apps\avdialer\avdialer\directory.cpp ===
/////////////////////////////////////////////////////////////////////////////////////////
//
// Copyright (c) 1997 Active Voice Corporation. All Rights Reserved. 
//
// Active Agent(r) and Unified Communications(tm) are trademarks of Active Voice Corporation.
//
// Other brand and product names used herein are trademarks of their respective owners.
//
// The entire program and user interface including the structure, sequence, selection, 
// and arrangement of the dialog, the exclusively "yes" and "no" choices represented 
// by "1" and "2," and each dialog message are protected by copyrights registered in 
// the United States and by international treaties.
//
// Protected by one or more of the following United States patents: 5,070,526, 5,488,650, 
// 5,434,906, 5,581,604, 5,533,102, 5,568,540, 5,625,676, 5,651,054.
//
// Active Voice Corporation
// Seattle, Washington
// USA
//
/////////////////////////////////////////////////////////////////////////////////////////

//
// directory.cpp
//


#include "stdafx.h"
#include <rend.h>
#include <dsgetdc.h>
#include <lmcons.h>
#include <lmapibuf.h>
#include "directory.h"
#include "avDialerDoc.h"

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//Prototypes
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

HRESULT GetNamingContext(LDAP* pLDAP,CString& sNamingContext);
void TestingEntries( LDAP *ld, LDAPMessage *ldres );
HRESULT GetGlobalCatalogName(TCHAR** ppszGlobalCatalogName);

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//Defines
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
#define LDAP_PAGE_SIZE     100

// Property Definitions
// Must match up with the enum in directory.h (DirectoryProperty)
LPCTSTR LDAPDirProps[]=
{
   TEXT("Unknown"),
   TEXT("name"),
   TEXT("ipPhone"),
   TEXT("telephoneNumber"),
   TEXT("mail")
};

LPCTSTR ADSIDirProps[]=
{
   TEXT("Unknown"),
   TEXT("Name"),
   TEXT("EmailAddress")
};

enum 
{
   ieidPR_DISPLAY_NAME = 0,
   ieidPR_ENTRYID,
   ieidPR_OBJECT_TYPE,
   ieidMax
};

static const SizedSPropTagArray(ieidMax, ptaEid)=
{
   ieidMax,
   {
      PR_DISPLAY_NAME,
      PR_ENTRYID,
      PR_OBJECT_TYPE,
   }
};


#ifdef _TEST_MAIN
#include <stdio.h>
void main()
{
   CDirectory Dir;
   
   CoInitialize(NULL);

   Dir.Initialize();

   CObList WABList;
   Dir.WABGetTopLevelContainer(&WABList);
}
#endif

/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////
//Class CDirectory
/////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////////////////////////////////////////////////////

CDirectory::CDirectory()
{
   m_pAddrBook= NULL;
   m_pWABObject= NULL;
   m_fInitialized= false;
   m_pRend = NULL;
   m_ldCacheLDAPServer = NULL;
}

CDirectory::~CDirectory()
{
   //clean cached LDAP connection
   if (m_ldCacheLDAPServer)
   {
      ldap_unbind(m_ldCacheLDAPServer);
      m_ldCacheLDAPServer = NULL;
      m_sCacheLDAPServer = _T("");
   }

   if (m_pAddrBook) m_pAddrBook->Release();
   if (m_pWABObject) m_pWABObject->Release();
   if (m_pRend)
   {
      m_pRend->Release();
      m_pRend = NULL;
   }
}

DirectoryErr CDirectory::Initialize()
{
   DirectoryErr err= DIRERR_UNKNOWNFAILURE;

   if ((err= InitWAB()) == DIRERR_SUCCESS)
   {
      m_fInitialized= true;
   }

   return err;
}


// Dynamically load the WAB library
DirectoryErr CDirectory::InitWAB()
{
   DirectoryErr err= DIRERR_UNKNOWNFAILURE;
   HRESULT hResult; 
   TCHAR szDllPathPre[_MAX_PATH], szDllPath[_MAX_PATH];
   HKEY hKey= NULL;
   HINSTANCE hInst;

   memset(szDllPath, '\0', _MAX_PATH*sizeof(TCHAR));

   if(ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WAB_DLL_PATH_KEY, 0, KEY_READ, &hKey))
   {
      DWORD dwType= 0;
      ULONG cbData= _MAX_PATH;

      RegQueryValueEx(hKey, TEXT(""), NULL, &dwType, (LPBYTE) szDllPathPre, &cbData);
      RegCloseKey(hKey);

      // Replace %SystemDrive% with C:
      if (ExpandEnvironmentStrings(szDllPathPre, szDllPath, _MAX_PATH) == 0)
      {
         // Failure, try without expanded strings
         _tcsncpy(szDllPath, szDllPathPre, _MAX_PATH);
         szDllPath[_MAX_PATH-1] = (TCHAR)0;
      }
   }

   if (_tcslen(szDllPath) > 0)
   {
      // Got the path load it.
      hInst= LoadLibrary(szDllPath);
   }
   else
   {
      // Try the default name "wab32.dll"
      hInst= LoadLibrary(WAB_DLL_NAME);
   }


   if (hInst != NULL)
   {
      LPWABOPEN pfcnWABOpen= NULL;

      if ((pfcnWABOpen= (LPWABOPEN) GetProcAddress(hInst, "WABOpen")) != NULL)
      {
         if ((hResult= pfcnWABOpen(&m_pAddrBook, &m_pWABObject, NULL, 0)) == S_OK)
         {
            err= DIRERR_SUCCESS;
         }
      }
   }

   return err;
}

//
//
//

DirectoryErr CDirectory::CurrentUserInfo(CString& sName, CString& sDomain)
{
   DirectoryErr err= DIRERR_UNKNOWNFAILURE;
   TOKEN_USER  *tokenUser = NULL;
   HANDLE      tokenHandle = NULL;
   DWORD       tokenSize = NULL;
   DWORD       sidLength = NULL;

   if (OpenProcessToken (GetCurrentProcess(), TOKEN_QUERY, &tokenHandle))
   {
      // get the needed size for the tokenUser structure
      GetTokenInformation (tokenHandle,
         TokenUser,
         tokenUser,
         0,
         &tokenSize);

      // allocate the tokenUser structure
      tokenUser = (TOKEN_USER *) new BYTE[tokenSize];

      // get the tokenUser info for the current process
      if (GetTokenInformation (tokenHandle,
         TokenUser,
         tokenUser,
         tokenSize,
         &tokenSize))
      {
         TCHAR szDomain [256];
         TCHAR szName [256];
         DWORD cbName;
         SID_NAME_USE snu;

         cbName= 255;
         LookupAccountSid (NULL,
            tokenUser->User.Sid,
            szName,
            &cbName,
            szDomain,
            &cbName,
            &snu);

         sName= szName;
         sDomain= szDomain;

         err= DIRERR_SUCCESS;
      }

      CloseHandle (tokenHandle);
      delete tokenUser;
   }

   return err;
}


//
// ILS Functions
//

DirectoryEr